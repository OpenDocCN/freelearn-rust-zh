- en: Creating Your Own Macros
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的自己的宏
- en: In previous chapters, we saw how macros and metaprogramming, in general, can
    make your life much easier. We saw both, macros that reduce the required boilerplate
    code and macros that will speed up your final code. It's time for you to learn
    how to create your own macros.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了宏和元编程如何使您的生活变得更加轻松。我们看到了两种宏，一种是减少所需样板代码的宏，另一种是能加快最终代码的宏。现在是时候学习如何创建自己的宏了。
- en: In this chapter, you will learn how to create your own standard macros, how
    to create your own procedural macros and custom derives, and finally, how to use
    nightly features to create your own plugins. You will also see how the new declarative
    macros work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何创建自己的标准宏，如何创建自己的过程宏和自定义的 derive，以及最后如何使用夜间功能来创建自己的插件。您还将了解新的声明式宏是如何工作的。
- en: 'The chapter is divided into three sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为三个部分：
- en: '**Macrosystem**: Understanding the `macro_rules!{}` macro'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宏系统**：理解 `macro_rules!{}` 宏'
- en: '**Procedural macros**: Learning how to create your own custom derives'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程宏**：学习如何创建自己的自定义 derive'
- en: '**Nightly metaprogramming**: Plugins and declarative macros'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**夜间元编程**：插件和声明式宏'
- en: Creating your own standard macros
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的标准宏
- en: Since Rust 1.0, we have had a great macro system. Macros allow us to apply some
    code to multiple types or expressions, as they work by expanding themselves at
    compile time. This means that when you use a macro, you are effectively writing
    a lot of code before the actual compilation starts. This has two main benefits,
    first, the codebase can be easier to maintain by being smaller and reusing code,
    and second, since macros expand before starting the creation of object code, you
    can abstract at the syntactic level.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Rust 1.0 以来，我们有一个非常好的宏系统。宏允许我们将一些代码应用到多个类型或表达式中，因为它们通过在编译时展开自身来实现。这意味着当您使用宏时，您实际上在编译开始之前就写了很多代码。这有两个主要好处，首先，通过变得更小和重用代码，代码库可以更容易维护，其次，由于宏在开始创建目标代码之前展开，您可以在语法级别进行抽象。
- en: 'For example, you can have a function like this one:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以有这样一个函数：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function restricts the input to `u32` types and the return type to `u32`.
    We could add some more accepted types by using generics, which may accept `&u32`
    if we use the `Add` trait. Macros allow us to create this kind of code for any
    element that can be written to the left of the `+` sign and it will be expanded
    differently for each type of element, creating different code for each case.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输入限制为 `u32` 类型，并将返回类型限制为 `u32`。我们可以通过使用泛型添加一些其他可接受类型，如果我们使用 `Add` 特性，它可能接受
    `&u32`。宏允许我们为任何可以写入 `+` 符号左侧的元素创建这种代码，并且它将为每种类型的元素生成不同的代码，为每种情况创建不同的代码。
- en: 'To create a macro, you will need to use a macro built in to the language, the
    `macro_rules!{}` macro. This macro receives the name of the new macro as a first
    parameter and a block with the macro code as a second element. The syntax can
    be a bit complex the first time you see it, but it can be learned quickly. Let''s
    start with a macro that does just the same as the function we saw before:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个宏，您需要使用语言内置的宏，即 `macro_rules!{}` 宏。这个宏接受新宏的名称作为第一个参数，以及包含宏代码的代码块作为第二个元素。第一次看到这个语法时，它可能有点复杂，但可以很快学会。让我们从一个与之前看到的函数做同样事情的宏开始：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can now call that macro from your `main()` function by calling `add_one!(integer);`.
    Note that the macro needs to be defined before the first call, even if it's in
    the same file. It will work with any integer, which wasn't possible with functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从 `main()` 函数中调用该宏，通过调用 `add_one!(integer);`。请注意，即使在同一文件中，宏也需要在第一次调用之前定义。它将适用于任何整数，这是函数所做不到的。
- en: Let's analyze how the syntax works. In the block after the name of the new macro
    (`add_one`), we can see two sections. In the first part, on the left of the `=>`,
    we see `$input:expr` inside parentheses. Then, to the right, we see a Rust block
    where we do the actual addition.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下语法是如何工作的。在新宏（`add_one`）名称之后的代码块中，我们可以看到两个部分。在第一个部分，在 `=>` 的左边，我们看到括号内的
    `$input:expr`。然后，在右边，我们看到一个 Rust 代码块，我们在其中执行实际的加法操作。
- en: The left part works similarly (in some ways) to a pattern match. You can add
    any combination of characters and then some variables, all of them starting with
    a dollar sign (`$`) and showing the type of variable after a colon. In this case,
    the only variable is the `$input` variable and it's an expression. This means
    that you can insert any kind of expression there and it will be written in the
    code to the right, substituting the variable with the expression.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧部分的工作方式（在某些方面）类似于模式匹配。你可以添加任何字符组合和一些变量，所有这些变量都以美元符号（`$`）开头，并在冒号后显示变量的类型。在这种情况下，唯一的变量是
    `$input` 变量，它是一个表达式。这意味着你可以在那里插入任何类型的表达式，它将被写入右侧的代码中，用表达式替换变量。
- en: Macro variants
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏变体
- en: 'As you can see, it''s not as complicated as you might think. As I wrote, you
    can have almost any pattern to the left of the `macro_rules!{}` side. Not only
    that, you can also have multiple patterns, as if it were a match statement, so
    that if one of them matches, it will be the one expanded. Let''s see how this
    works by creating a macro which, depending on how we call it, will add one or
    two to the given integer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它并没有你想象的那么复杂。正如我写的，你可以在 `macro_rules!{}` 侧的左侧几乎有任意模式。不仅如此，你还可以有多个模式，就像是一个匹配语句，所以如果其中一个匹配，它将被展开。让我们通过创建一个宏来了解它是如何工作的，这个宏根据我们如何调用它，将给定的整数加一或加二：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see a couple of clear changes to the macro. First, we swapped braces
    for parentheses and parentheses for braces in the macro. This is because in a
    macro, you can use interchangeable braces (`{` and `}`), square brackets (`[`
    and `]`), and parentheses (`(` and `)`). Not only that, you can use them when
    calling the macro. You have probably already used the `vec![]` macro and the `format!()`
    macro, and we saw the `lazy_static!{}` macro in the last chapter. We use brackets
    and parentheses here just for convention, but we could call the `vec!{}` or the
    `format![]` macros the same way, because we can use braces, brackets, and parentheses
    in any macro call.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到宏的几个明显的变化。首先，我们在宏中交换了花括号和括号。这是因为在一个宏中，你可以使用可互换的花括号（`{` 和 `}`）、方括号（`[` 和
    `]`）和括号（`(` 和 `)`）。不仅如此，你还可以在调用宏时使用它们。你可能已经使用过 `vec![]` 宏和 `format!()` 宏，我们在上一章中看到了
    `lazy_static!{}` 宏。我们在这里使用方括号和括号只是为了约定，但我们可以以相同的方式调用 `vec!{}` 或 `format![]` 宏，因为我们可以在任何宏调用中使用花括号、方括号和括号。
- en: The second change was to add some extra text to our left-hand side patterns.
    We now call our macro by writing the text `one to` or `two to`, so I also removed
    the `one` redundancy to the macro name and called it `add!()`. This means that
    we now call our macro with literal text. That is not valid Rust, but since we
    are using a macro, we modify the code we are writing before the compiler tries
    to understand actual Rust code and the generated code is valid. We could add any
    text that does not end the pattern (such as parentheses or braces) to the pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次更改是在我们的左侧模式中添加一些额外的文本。我们现在通过编写文本 `one to` 或 `two to` 来调用我们的宏，所以我也将 `one`
    的冗余从宏名称中移除，并称之为 `add!()`。这意味着我们现在用文字文本调用我们的宏。这不是有效的 Rust，但由于我们正在使用宏，我们在编译器试图理解实际的
    Rust 代码之前修改了我们正在编写的代码，生成的代码是有效的。我们可以在模式中添加任何不结束模式的文本（例如括号或花括号）。
- en: The final change was to add a second possible pattern. We can now add one or
    two and the only difference will be that the right side of the macro definition
    must now end with a trailing semicolon for each pattern (the last one is optional)
    to separate each of the options.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改是添加第二种可能的模式。现在我们可以添加一个或两个，唯一的区别是宏定义的右侧现在必须以每个模式的尾随分号结尾（最后一个可选），以分隔每个选项。
- en: A small detail that I also added in the example was when calling the macro in
    the `main()` function. As you can see, I could have added `one` or `two` to `5`,
    but I wrote `25/5` for a reason. When compiling this code, this will be expanded
    to `25/5 + 1` (or `2`, if you use the second variant). This will later be optimized
    at compile time, since it will know that `25/5 + 1` is `6`, but the compiler will
    receive that expression, not the final result. The macro system will not calculate
    the result of the expression; it will simply copy in the resulting code whatever
    you give to it and then pass it to the next compiler phase.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中我还添加了一个小细节，那就是在`main()`函数中调用宏。如您所见，我本可以将`one`或`two`加到`5`上，但我写`25/5`是有原因的。在编译这段代码时，这将展开为`25/5
    + 1`（或者如果你使用第二个变体，是`2`）。这将在编译时进行优化，因为它将知道`25/5 + 1`是`6`，但编译器将接收到这个表达式，而不是最终结果。宏系统不会计算表达式的结果；它将简单地复制你给出的结果代码，并将其传递给下一个编译阶段。
- en: You should be especially careful with this when a macro you are creating calls
    another macro. They will get expanded recursively, one inside the other, so the
    compiler will receive a bunch of final Rust code that will need to be optimized.
    Issues related to this were found in the CLAP crate that we saw in the last chapter,
    since the exponential expansions were adding a lot of bloat code to their executables.
    Once they found out that there were too many macro expansions inside the other
    macros and fixed it, they reduced the size of their binary contributions by more
    than 50%.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建的宏调用另一个宏时，你应该特别注意这一点。它们将会递归地展开，一层套一层，因此编译器将接收到一大堆最终的Rust代码，这些代码需要被优化。在上一章中我们看到的CLAP
    crate中发现了与此相关的问题，因为指数展开给它们的可执行文件添加了大量的冗余代码。一旦他们发现其他宏内部有太多的宏展开并且修复了这个问题，他们通过超过50%的比例减少了他们的二进制贡献的大小。
- en: Macros allow for an extra layer of customization. You can repeat arguments more
    than once. This is common, for example, in the `vec![]` macro, where you create
    a new vector with information at compile time. You can write something like `vec![3,
    4, 76, 87];`. How does the `vec![]` macro handle an unspecified number of arguments?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 宏允许额外的定制层。你可以重复参数多次。这在`vec![]`宏中很常见，例如，在编译时创建一个新向量。你可以写像`vec![3, 4, 76, 87];`这样的东西。`vec![]`宏是如何处理未指定数量的参数的？
- en: Complex macros
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂的宏
- en: 'We can specify that we want multiple expressions in the left-hand side pattern
    of the macro definition by adding a `*` for *zero or more* matches or a `+` for
    *one or more* matches. Let''s see how we can do that with a simplified `my_vec![]`
    macro:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在宏定义的左侧模式中添加一个`*`来指定我们想要多个表达式，表示零个或多个匹配，或者添加一个`+`来表示一个或多个匹配。让我们看看我们如何通过简化的`my_vec![]`宏来实现这一点：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's see what is happening here. First, we see that on the left side, we have
    two variables, denoted by the two `$` signs. The first makes reference to the
    actual repetition. Each comma-separated expression will generate a `$x` variable.
    Then, on the right side, we use the various repetitions to push `$x` to the vector
    once for every expression we receive.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。首先，我们看到在左侧，我们有两个变量，由两个`$`符号表示。第一个指的是实际的重复。每个以逗号分隔的表达式将生成一个`$x`变量。然后，在右侧，我们使用各种重复来将`$x`向量为每个接收到的表达式推送一次。
- en: 'There is another new thing on the right-hand side. As you can see, the macro
    expansion starts and ends with a double brace instead of using only one. This
    is because, once the macro gets expanded, it will substitute the given expression
    for a new expression: the one that gets generated. Since what we want is to return
    the vector we are creating, we need a new scope where the last sentence will be
    the value of the scope once it gets executed. You will be able to see it more
    clearly in the next code snippet.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧还有一个新事物。如您所见，宏展开开始和结束于一个双花括号，而不是只使用一个。这是因为一旦宏展开，它将用给定表达式替换一个新表达式：即生成的表达式。由于我们想要返回我们创建的向量，我们需要一个新的作用域，其中最后一句话将是作用域执行后的值。你将在下一个代码片段中更清楚地看到这一点。
- en: 'We can call this code with the `main()` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`main()`函数来调用这段代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It will be expanded to this code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被扩展到以下代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we need those extra braces to create the scope that will return
    the vector so that it gets assigned to the `my_vector` binding.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要这些额外的花括号来创建一个作用域，以便返回向量，这样它就会被分配给`my_vector`绑定。
- en: 'You can have multiple repetition patterns on the left expression and they will
    be repeated for every use, as needed on the right. There is a nice example illustrating
    this behavior in the first edition of the official Rust book, which I have adapted
    here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在左侧表达式中有多重重复模式，并且它们将根据需要重复使用。在官方Rust书的第一个版本中有一个很好的例子说明了这种行为，我在这里进行了改编：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the macro can receive one or more `$x; [$y1, $y2,...]` input.
    So, for each input, it will have one expression, then a semicolon, then a bracket
    with multiple sub-expressions separated by a comma, and finally, another bracket
    and a semicolon. But what does the macro do with this input? Let's check to the
    right-hand side of it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，宏可以接收一个或多个`$x; [$y1, $y2,...]`输入。所以，对于每个输入，它将有一个表达式，然后是一个分号，然后是一个带有多个子表达式并用逗号分隔的括号，最后是另一个括号和一个分号。但宏对这个输入做了什么？让我们检查它的右侧。
- en: As you can see, this will create multiple repetitions. We can see that it creates
    a slice (`&[T]`) of whatever we feed to it, so all the expressions we use must
    be of the same type. Then, it will start iterating over all `$x` variables, one
    per input group. So if we feed it only one input, it will iterate once for the
    expression to the left of the semicolon. Then, it will iterate once for every
    `$y` expression associated with the `$x` expression, add them to the `+` operator,
    and include the result in the slice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这将创建多个重复。我们可以看到它创建了一个切片（`&[T]`），无论我们给它什么，所以所有我们使用的表达式都必须是同一类型。然后，它将遍历所有的`$x`变量，每个输入组一个。所以如果我们只给它一个输入，它将为分号左侧的表达式迭代一次。然后，它将为与`$x`表达式关联的每个`$y`表达式迭代一次，将它们添加到`+`运算符中，并将结果包含在切片中。
- en: If this was too complex to understand, let's look at an example. Let's suppose
    we call the macro with `65; [22, 34]` as input. In this case, `65` will be `$x`,
    and `22`, `24`, and so on will be `$y` variables associated with `65`. So, the
    result will be a slice like this: `&[65+22, 65+34]`. Or, if we calculate the results: `&[87,
    99]`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这太复杂而难以理解，让我们看一个例子。假设我们用`65; [22, 34]`作为输入调用宏。在这种情况下，`65`将是`$x`，而`22`、`24`等将是与`65`关联的`$y`变量。因此，结果将是一个这样的切片：`&[65+22,
    65+34]`。或者，如果我们计算结果：`&[87, 99]`。
- en: If, on the other hand, we give two groups of variables by using `65; [22, 34];
    23; [56, 35]` as input, in the first iteration, `$x` will be `65`, while in the
    second one, it will be `23`. The `$y` variables of `64` will be `22` and `34`,
    as before, and the ones associated with `23` will be `56` and `35`. This means
    that the final slice will be `&[87, 99, 79, 58]`, where `87` and `99` work the
    same way as before and `79` and `58` are the extension of adding `23` to `56`
    and `23` to `35`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`65; [22, 34]; 23; [56, 35]`作为输入提供两组变量，在第一次迭代中，`$x`将是`65`，而在第二次迭代中，它将是`23`。`64`的`$y`变量将是`22`和`34`，如前所述，与`23`关联的变量将是`56`和`35`。这意味着最终的切片将是`&[87,
    99, 79, 58]`，其中`87`和`99`与之前相同，而`79`和`58`是添加`23`到`56`和`23`到`35`的扩展。
- en: This gives you much more flexibility than the functions, but remember, all this
    will be expanded during compile time, which can make your compilation time much
    slower and the final codebase larger and slower still if the macro used duplicates
    too much code. In any case, there is more flexibility to it yet.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这比函数提供了更多的灵活性，但请记住，所有这些都会在编译时展开，这可能会使你的编译时间更长，如果使用的宏重复了太多代码，最终的代码库会更大且运行得更慢。无论如何，它还有更多的灵活性。
- en: 'So far, all variables have been of the `expr` kind. We have used this by declaring
    `$x:expr` and `$y:expr` but, as you can imagine, there are other kinds of macro
    variables. The list follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有变量都为`expr`类型。我们通过声明`$x:expr`和`$y:expr`来使用它，但正如你可以想象的，还有其他类型的宏变量。列表如下：
- en: '`expr`: Expressions that you can write after an `=` sign, such as `76+4` or
    `if a==1 {"something"} else {"other thing"}`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr`：可以在等号后书写的表达式，例如`76+4`或`if a==1 {"something"} else {"other thing"}`。'
- en: '`ident`: An identifier or binding name, such as `foo` or `bar`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ident`：一个标识符或绑定名称，例如`foo`或`bar`。'
- en: '`path`: A qualified path. This will be a path that you could write in a use
    sentence, such as `foo::bar::MyStruct` or `foo::bar::my_func`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：一个合格路径。这将是一个你可以在使用句子中写的路径，例如`foo::bar::MyStruct`或`foo::bar::my_func`。'
- en: '`ty`: A type, such as `u64` or `MyStruct`. It can also be a path to the type.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ty`：一种类型，例如`u64`或`MyStruct`。它也可以是类型的路径。'
- en: '`pat`: A pattern that you can write at the left side of an `=` sign or in a
    match expression, such as `Some(t)` or `(a, b, _)`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pat`：可以在等号左侧或匹配表达式中书写的模式，例如`Some(t)`或`(a, b, _)`。'
- en: '`stmt`: A full statement, such as a let binding like `let a = 43;`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stmt`: 一个完整的语句，例如一个 `let` 绑定，如 `let a = 43;`。'
- en: '`block`: A block element that can have multiple statements and a possible expression
    between braces, such as `{vec.push(33); vec.len()}`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block`: 一个可以包含多个语句并在花括号之间有可选表达式的块元素，例如 `{vec.push(33); vec.len()}`。'
- en: '`item`: What Rust calls *items*. For example, function or type declarations,
    complete modules, or trait definitions.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`: Rust 所称的 *items*。例如，函数或类型声明、完整的模块或特质定义。'
- en: '`meta`: A meta element, which you can write inside of an attribute (`#[]`).
    For example, `cfg(feature = "foo")`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`: 一个元元素，你可以将其写入属性（`#[]`）中。例如，`cfg(feature = "foo")`。'
- en: '`tt`: Any token tree that will eventually get parsed by a macro pattern, which
    means almost anything. This is useful for creating recursive macros, for example.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tt`: 任何最终将被宏模式解析的标记树，这意味着几乎可以是任何东西。这对于创建递归宏非常有用。'
- en: As you can imagine, some of these kinds of macro variables overlap and some
    of them are just more specific than the others. The use will be verified on the
    right-hand side of the macro, in the expansion, since you might try to use a statement
    where an expression must be used, even though you might use an identifier too,
    for example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这些类型的宏变量中有些是重叠的，有些则比其他更具体。使用将在宏的右侧进行验证，在展开时，因为你可能会尝试在一个必须使用表达式的地方使用语句，即使你可能也会使用一个标识符，例如。
- en: There are some extra rules, too, as we can see in the Rust documentation ([https://doc.rust-lang.org/book/first-edition/macros.html#syntactic-requirements](https://doc.rust-lang.org/book/first-edition/macros.html#syntactic-requirements)).
    Statements and expressions can only be followed by `=>`, a comma, or a semicolon.
    Types and paths can only be followed by `=>`, the `as` or `where` keywords, or
    any commas, `=`, `|`, `;`, `:`, `>`, `[`, or `{`. And finally, patterns can only
    be followed by `=>`, the `if` or `in` keywords, or any commas, `=`, or `|`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的规则，正如我们可以在 Rust 文档中看到的那样（[https://doc.rust-lang.org/book/first-edition/macros.html#syntactic-requirements](https://doc.rust-lang.org/book/first-edition/macros.html#syntactic-requirements)）。语句和表达式只能由
    `=>`、逗号或分号跟随。类型和路径只能由 `=>`、`as` 或 `where` 关键字、或任何逗号、`=`、`|`、`;`、`:`、`>`、`[` 或
    `{` 跟随。最后，模式只能由 `=>`、`if` 或 `in` 关键字、或任何逗号、`=` 或 `|` 跟随。
- en: 'Let''s put this in practice by implementing a small `Mul` trait for a currency
    type we can create. This is an adapted example of some work we did when creating
    the Fractal Credits digital currency. In this case, we will look to the implementation
    of the `Amount` type ([https://github.com/FractalGlobal/utils-rs/blob/49955ead9eef2d9373cc9386b90ac02b4d5745b4/src/amount.rs#L99-L102](https://github.com/FractalGlobal/utils-rs/blob/49955ead9eef2d9373cc9386b90ac02b4d5745b4/src/amount.rs#L99-L102)),
    which represents a currency amount. Let''s start with the basic type definition:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现一个针对我们可以创建的货币类型的 `Mul` 特质来将这个概念付诸实践。这是一个我们在创建分形信用数字货币时所做的某些工作的改编示例。在这种情况下，我们将查看
    `Amount` 类型（[https://github.com/FractalGlobal/utils-rs/blob/49955ead9eef2d9373cc9386b90ac02b4d5745b4/src/amount.rs#L99-L102](https://github.com/FractalGlobal/utils-rs/blob/49955ead9eef2d9373cc9386b90ac02b4d5745b4/src/amount.rs#L99-L102)）的实现，它表示货币金额。让我们从基本类型定义开始：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This amount will be divisible by up to three decimals, but it will always be
    an exact value. We should be able to add an `Amount` to the current `Amount`,
    or to subtract it. I will not explain these trivial implementations, but there
    is one implementation where macros can be of great help. We should be able to
    multiply the amount by any positive integer, so we should implement the `Mul`
    trait for `u8`, `u16`, `u32`, and `u64` types. Not only that, we should be able
    to implement the `Div` and the `Rem` traits, but I will leave those out, since
    they are a little bit more complex. You can check them in the implementation linked
    earlier.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个金额可以被最多三位小数整除，但它始终是一个精确值。我们应该能够将一个 `Amount` 添加到当前的 `Amount`，或者从中减去。我不会解释这些简单的实现，但有一个实现中宏可以大有帮助。我们应该能够将金额乘以任何正整数，因此我们应该为
    `u8`、`u16`、`u32` 和 `u64` 类型实现 `Mul` 特质。不仅如此，我们还应该能够实现 `Div` 和 `Rem` 特质，但我会省略这些，因为它们稍微复杂一些。你可以在前面链接的实现中查看它们。
- en: 'The only thing the multiplication of an `Amount` with an integer should do
    is to multiply the value by the integer given. Let''s see a simple implementation
    for `u8`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Amount` 与整数的乘法所做的唯一事情就是将值乘以给定的整数。让我们看看 `u8` 的简单实现：'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, I implemented it both ways so that you can put the `Amount` to
    the left and to the right of the multiplication. If we had to do this for all
    integers, it would be a big waste of time and code. And if we had to modify one
    of the implementations (especially for `Rem` functions), it would be troublesome
    to do it in multiple code points. Let's use macros to help us.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我两种方式都实现了，这样您可以将`Amount`放在乘法符号的左边或右边。如果我们必须对所有整数都这样做，那将是一种时间和代码的巨大浪费。而且，如果我们必须修改其中一个实现（特别是对于`Rem`函数），在多个代码点上进行修改将会很麻烦。让我们使用宏来帮助我们。
- en: 'We can define a macro, `impl_mul_int!{}`, which will receive a list of integer
    types and then implement the `Mul` trait back and forward between all of them
    and the `Amount` type. Let''s see:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个宏，`impl_mul_int!{}`，它将接收一个整数类型的列表，然后在这些类型和`Amount`类型之间实现双向的`Mul`特质。让我们看看：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we specifically ask for the given elements to be types and then
    we implement the trait for all of them. So, for any code that you want to implement
    for multiple types, you might as well try this approach, since it will save you
    from writing a lot of code and it will make it more maintainable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们特别要求给定的元素是类型，然后我们为所有这些元素实现特质。所以，对于您想要为多个类型实现的所有代码，您不妨尝试这种方法，因为它可以节省您大量的代码，并使其更易于维护。
- en: Creating procedural macros
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建过程宏
- en: We have seen what standard macros can do for our crate. We can create complex
    compile-time code that can both reduce the verbosity of our code, making it more
    maintainable, and improve the performance of the final executable by performing
    operations at compile time instead of at runtime.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了标准宏可以为我们的crate做什么。我们可以创建复杂的编译时代码，既可以减少我们代码的冗长性，使其更易于维护，还可以通过在编译时而不是在运行时执行操作来提高最终可执行文件的性能。
- en: Nevertheless, standard macros can only do so much. With them, you can only modify
    some of the Rust grammar token processing, but you are still bound to what the
    `macro_rules!{}` macro can understand. This is where procedural macros, also known
    as macros 1.1 or custom derives, come into play.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，标准宏只能做到如此。使用它们，您只能修改一些Rust语法标记处理，但您仍然受限于`macro_rules!{}`宏所能理解的内容。这就是过程宏（也称为宏1.1或自定义派生）发挥作用的地方。
- en: With procedural macros, you can create libraries that will be called by the
    compiler when deriving their name in some structure or enumeration. You can effectively
    create a custom trait, `derive`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过程宏，您可以为编译器在结构体或枚举中派生其名称时调用的库创建库。您可以有效地创建一个自定义特质，`derive`。
- en: Implementing a simple trait
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个简单的特质
- en: 'Let''s see how this can be done by implementing a simple trait for a structure
    or enumeration. The trait we will be implementing is the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过为结构体或枚举实现一个简单的特质来实现这一点。我们将要实现的特质如下：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `trait` should return the name of the current structure or enumeration
    as a string. Implementing that by hand is really easy, but it doesn't make sense
    to implement it manually, one by one, for our types. The best thing to do is to
    derive it with a procedural macro. Let's see how we can do that.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`trait`应该返回当前结构体或枚举的名称作为字符串。手动实现它非常简单，但手动逐个为我们的类型实现它没有意义。最好的做法是使用过程宏来派生它。让我们看看我们如何做到这一点。
- en: 'First, we will need to create a library crate. As per convention, it should
    have the parent crate''s name and then the `-derive` suffix. In this case, we
    do not have a name for the crate, but let''s call the library `type-name-derive`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个库crate。按照惯例，它应该有父crate的名称，然后是`-derive`后缀。在这种情况下，我们没有为crate命名，但让我们称这个库为`type-name-derive`：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should create a new folder next to the `src/` folder, named `type-name-derive`.
    We can now add it to the `Cargo.toml` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在`src/`文件夹旁边创建一个新的文件夹，命名为`type-name-derive`。现在我们可以将其添加到`Cargo.toml`文件中：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `main.rs` file of our crate, we will need to add the crate and use its
    macros:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的crate的`main.rs`文件中，我们需要添加crate并使用其宏：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s now start with the actual derivation development. We will need to use
    two crates—`syn` and `quote`. We will add them to the `Cargo.toml` file inside
    the `type-name-derive` directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实际的派生开发。我们需要使用两个crate——`syn`和`quote`。我们将把它们添加到`type-name-derive`目录内的`Cargo.toml`文件中：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `syn` crate gives us some useful types and functions to work with the source
    tree and token streams of Rust. We need this because all our macro will see is
    a bunch of information about the source code of our structure or enumeration.
    We will need to parse it and get information from it. The `syn` crate is a `Nom`
    parser that will transform that Rust source code into something we can easily
    use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`syn` crate为我们提供了一些有用的类型和函数，用于处理Rust的源树和标记流。我们需要这个，因为我们的所有宏都将看到有关我们结构体或枚举源代码的大量信息。我们需要解析它并从中获取信息。`syn`
    crate是一个`Nom`解析器，它将Rust源代码转换为我们可以轻松使用的东西。'
- en: The `quote` crate gives us the `quote!{}` macro, which we will use to implement
    the source code of our implementation directly. It basically allows us to write
    almost *normal* Rust code instead of compiler tokens to implement the trait.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`quote` crate为我们提供了`quote!{}`宏，我们将使用它来直接实现实现代码的源代码。它基本上允许我们编写几乎*正常*的Rust代码，而不是编译器标记来实现特性。'
- en: 'There is other extra information we will need to include in the `Cargo.toml`
    file. We need to inform cargo and the Rust compiler that this crate is a procedural
    macro crate. For that, we will need to add this to the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`文件中，我们还需要包含其他一些额外信息。我们需要通知Cargo和Rust编译器，这个crate是一个过程宏crate。为此，我们需要在文件中添加以下内容：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we need to start with the initial schema of the `./type-name-derive/src/lib.rs`
    file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要从`./type-name-derive/src/lib.rs`文件的基本架构开始：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we first imported the required definitions. The `proc_macro`
    crate is built in the compiler and gives us the `TokenStream` type. This type
    represents a stream of Rust tokens (characters in your source files). We then
    import the `syn` and `quote` crates. As we saw earlier, we will need to use the
    `quote!{}` macro from the quote crate, so we import the macros too.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们首先导入了所需的定义。`proc_macro` crate是编译器内置的，为我们提供了`TokenStream`类型。此类型表示Rust标记（源文件中的字符）的流。然后我们导入了`syn`和`quote`
    crate。如我们之前所见，我们需要使用quote crate中的`quote!{}`宏，因此我们也导入了宏。
- en: The syntax for implementing a custom derive is really simple. We need to define
    a function with a `proc_macro_derive` attribute of the value of the trait we want
    to derive. The function will take ownership of a token stream and return another
    (or the same) token stream so that the compiler can later process the new generated
    Rust code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义 derive 的语法非常简单。我们需要定义一个具有`proc_macro_derive`属性值的函数，该值是我们想要派生的特性。该函数将获取标记流的拥有权，并返回另一个（或相同的）标记流，以便编译器可以稍后处理新生成的Rust代码。
- en: 'To implement the trait, I prefer to divide the token parsing and the actual
    trait implementation into two functions. For that, let''s first write the code
    inside our `type_name()` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个特性，我更喜欢将标记解析和实际的特性实现分为两个函数。为此，让我们首先在我们的`type_name()`函数中编写代码：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The token stream first gets converted into a `DeriveInput` structure. This structure
    contains the properly parsed data from the input token stream; deserialized into
    the information of the type here, we will add the `#[derive]` attribute. In a
    production environment, those `unwrap()` functions should probably be changed
    for `expect()`, so that we can add some text if things go wrong.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 标记流首先被转换为`DeriveInput`结构。此结构包含从输入标记流正确解析的数据；反序列化到此处的信息，我们将添加`#[derive]`属性。在生产环境中，这些`unwrap()`函数可能需要更改为`expect()`，这样我们就可以在出错时添加一些文本。
- en: Later, we use that information to call the `impl_type_name()` function, which
    we haven't  yet defined. That function will take that information about the structure
    or enumeration and will return a series of tokens. Since we will use the quote
    crate to create those tokens, they will need to be converted into Rust compiler
    token streams later and returned to the compiler.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用这些信息来调用我们尚未定义的`impl_type_name()`函数。该函数将接受有关结构体或枚举的信息，并返回一系列标记。由于我们将使用quote
    crate来创建这些标记，因此它们需要稍后转换为Rust编译器标记流并返回给编译器。
- en: 'Let''s now implement the `impl_type_name()` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`impl_type_name()`函数：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, this implementation is really simple. We get the name of the
    structure or enumeration from the **advanced source tree** (**AST**), and then
    use it inside the `quote!{}` macro, where we implement the `TypeName` macro for
    the structure or enumeration with that name. The `stringify!()` macro is a native
    Rust macro that gets a token and returns a compile time string representation
    of it. In this case, the `name`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个实现非常简单。我们从**高级源树**（**AST**）中获取结构的名称，然后在`quote!{}`宏中使用它，在那里我们为具有该名称的结构或枚举实现`TypeName`宏。`stringify!()`宏是一个本地的Rust宏，它获取一个标记并返回其编译时字符串表示形式。在这种情况下，是`name`。
- en: 'Let''s see if this works by adding some code in the `main()` function of our
    parent crate and adding a couple of types that will derive our implementation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在我们的父crate的`main()`函数中添加一些代码并添加几个将派生我们实现的类型来测试一下这行是否有效：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you execute `cargo run`, you will see that the output is the following,
    as one would expect:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行`cargo run`，您将看到以下输出，正如预期的那样：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Implementing complex derivations
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现复杂派生
- en: The `syn` and `quote` crates allow for really complex derivations. And, not
    only that, we do not necessarily need to derive a trait; we can implement any
    kind of code for the given structure or enumeration. This means that we can derive
    builder patterns, as we saw in the previous chapter, which will actually create
    a new structure or `Getters` and `Setters` for our structure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`syn`和`quote` crate允许进行非常复杂的派生。不仅如此，我们不一定需要派生一个特质；我们可以为给定的结构或枚举实现任何类型的代码。这意味着我们可以派生构建器模式，正如我们在上一章中看到的，这实际上会为我们的结构创建一个新的结构或`Getters`和`Setters`。'
- en: That is what we are going to do for our next example. We will create structures
    and give them some methods to `get` and `set` the fields of the structure. In
    Rust, convention says that `Getters` should have the name of the field, without
    any prefix or a suffix such as `get`. So, for a field named `foo`, the `Getter`
    should be `foo()`. For mutable `Getters`, the function should have the `_mut`
    suffix, so in this case it would be `foo_mut()`. Setters should have the name
    of the field preceded by a `set_` prefix. So for a field named `bar`, it should
    be `set_bar()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们接下来将要做的。我们将创建结构并给它们一些方法来`get`和`set`结构的字段。在Rust中，惯例是`Getters`应该有字段的名字，没有前缀或后缀，如`get`。所以对于名为`foo`的字段，`Getter`应该是`foo()`。对于可变的`Getters`，函数应该有`_mut`后缀，所以在这种情况下它将是`foo_mut()`。设置器应该以`set_`前缀开头，所以对于名为`bar`的字段，它应该是`set_bar()`。
- en: Let's start with the creation of this new `getset-derive` procedural macro crate.
    As before, remember to set the `proc_macro` variable in the `[lib]` section of
    the `Cargo.toml` file to true and to add the `syn` and `quote` crates as dependencies.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建这个新的`getset-derive`过程宏crate开始。和之前一样，记得在`Cargo.toml`文件的`[lib]`部分中将`proc_macro`变量设置为true，并将`syn`和`quote`
    crate作为依赖项添加。
- en: Implementing getters
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现获取器
- en: 'We will add two derives, `Getters` and `Setters`. We will start with the first
    one by creating the required boilerplate:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加两个派生，`Getters`和`Setters`。我们将从第一个开始，创建所需的模板代码：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will not only need the name of the structure, we will also need any further
    generics added to the structure and `where` clauses. We didn't bother with these
    in our previous example, but we should add them in this more complex one. Gladly,
    the `syn` crate gives us all we need.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅需要结构的名称，还需要添加到结构中的任何进一步泛型以及`where`子句。在先前的例子中我们没有处理这些，但在更复杂的例子中我们应该添加它们。幸运的是，`syn`
    crate为我们提供了所有需要的东西。
- en: 'Let''s write the next piece of code in the `impl_getters()` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`impl_getters()`函数中编写下一部分代码：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have a lot going on here. First, as you can see, we get the generics from
    the `ast.generics` field and we use them later in the `quote!` macro. We then
    check which type of data we have. We cannot implement getters or setters for enumerations,
    unit structs, or structures with no named fields, such as `Foo(T)`, so we panic
    in those cases. Even though it's still not possible to derive anything for unions
    yet, we can specifically filter the options with the `syn` crate, so we just add
    that for potential future changes in the language.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行。首先，如您所见，我们从`ast.generics`字段中获取泛型，并在`quote!`宏中使用它们。然后我们检查我们有什么类型的数据。我们不能为枚举、单元结构或没有命名字段的结构（如`Foo(T)`）实现获取器或设置器，所以在这些情况下我们会panic。尽管目前仍然无法为联合派生任何东西，但我们可以使用`syn`
    crate特别过滤选项，所以我们只是添加它以供语言未来的潜在更改。
- en: In the case of a structure with named fields, we get a list of the fields and,
    for each of them, we implement the getter. For that, we map them to the `generate_getter()`
    function, defined at the bottom but still unimplemented.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有命名字段的结构的情形下，我们得到一个字段列表，并为每个字段实现一个getter。为此，我们将它们映射到在底部定义但尚未实现的`generate_getter()`函数。
- en: Once we have the list of getters, we call the quote `!{}` macro to generate
    the tokens. As you can see, we add the generics for the `impl` block so that if
    we had any in the structure, such as `Bar<T, F, G>`, they would be added to the
    implementation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了getter列表，我们就调用quote的`!{}`宏来生成令牌。正如你所见，我们为`impl`块添加了泛型，这样如果结构体中有任何泛型，例如`Bar<T,
    F, G>`，它们就会被添加到实现中。
- en: To add all the getters from a vector, we use the `#(#var)*` syntax and the same
    as with the `macro_rules!{}` macro, it will add one after the other. We can use
    this syntax with any type implementing the `IntoIterator` trait, in this case,
    `Vec<quote::Tokens>`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加从向量中获取的所有getter，我们使用`#(#var)*`语法，与`macro_rules!{}`宏类似，它会依次添加。我们可以使用这种语法与任何实现了`IntoIterator`特质的类型一起使用，在这种情况下，是`Vec<quote::Tokens>`。
- en: 'So, now we have to actually implement one getter. We have the `generate_getter()`
    function which receives a `syn::Field`, so we have all the information we need.
    The function will return `quote::Tokens`, so we will need to use the `quote!{}`
    macro inside. You can probably implement it yourself if you have been following,
    by checking the `syn` crate documentation at `docs.rs`. Let''s see how it looks
    fully implemented:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们必须实际实现一个getter。我们有`generate_getter()`函数，它接收一个`syn::Field`，因此我们有了所需的所有信息。该函数将返回`quote::Tokens`，因此我们需要在内部使用`quote!{}`宏。如果你一直在跟随，你可以自己实现它，通过检查`syn`包的文档在`docs.rs`。让我们看看完全实现后的样子：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, this is really simple. We get the identifier or name of the
    attribute, which should exist given that we are only implementing it for structures
    for named fields, and then get the type of the field. We then create the getter
    and return a reference to the internal data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这真的很简单。我们获取属性或字段的标识符或名称，鉴于我们只为具有命名字段的结构体实现它，这个名称应该存在，然后获取字段的类型。然后我们创建getter并返回内部数据的引用。
- en: We could improve this further by adding exceptions for types that have their
    borrowed counterparts, such as `String` or `PathBuf`, returning `&str` and `Path`
    respectively, but I don't think it's worth it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加对具有借用对应类型的异常处理来进一步改进，例如`String`或`PathBuf`，分别返回`&str`和`Path`，但我认为这并不值得。
- en: We could also add the documentation of the field to the generated getter. For
    that, we would use the `field.attrs` variable and get the contents of the attribute
    named `doc`, which is the one that includes the documentation text. Nevertheless,
    it's not so easy, because the name of the attribute is stored as a path and we
    would need to convert it to a string. But I invite you to try it with the `syn`
    crate documentation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将字段的文档添加到生成的getter中。为此，我们将使用`field.attrs`变量并获取名为`doc`的属性的值，这是包含文档文本的属性。然而，这并不那么容易，因为属性的名称被存储为路径，我们需要将其转换为字符串。但我邀请你尝试使用`syn`包的文档。
- en: Implementing setters
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现setter
- en: The second part of this exercise will be to implement setters for our structure.
    Usually this is done by creating a `set_{field}()` function for each field. Moreover,
    it's common practice to use generics for it so that they can be used with many
    different types. For example, for a `String` field, it would be great if we didn't
    need to always use an actual `String` type and we could use a `&str`, a `Cow<_,
    str>`, or a `Box<str>`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的第二部分将是实现我们结构体的setter。通常，这是通过为每个字段创建一个`set_{field}()`函数来完成的。此外，使用泛型是常见的做法，这样它们就可以与许多不同的类型一起使用。例如，对于`String`字段，如果我们不需要总是使用实际的`String`类型，而是可以使用`&str`、`Cow<_,
    str>`或`Box<str>`，那就太好了。
- en: We only need to declare the input as `Into<String>`. This makes things a little
    bit more complex, but our API will look much better. To implement the new setters,
    it would only mean changing a little bit of what we saw earlier and most of the
    code would be duplicated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将输入声明为`Into<String>`。这使得事情变得稍微复杂一些，但我们的API看起来会更好。要实现新的setter，只需稍微修改一下我们之前看到的代码，大部分代码都会被复制。
- en: 'To avoid that, we will use the strategy pattern so that we simply change the
    `generate_getter()` function to the `generate_setter()`, one for each field. I
    also moved the field retrieving a new function. Let''s see how it looks:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们将使用策略模式，这样我们只需简单地将`generate_getter()`函数改为`generate_setter()`，每个字段一个。我还将字段检索移动到了一个新的函数中。让我们看看它看起来如何：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Much better, right? It returns an iterator over the fields, which is what we
    need for our functions. We now create the method implementation function, which
    will receive a function as an argument, and will then be used for each field:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了，对吧？它返回一个字段迭代器，这正是我们函数所需要的。我们现在创建一个方法实现函数，它将接收一个函数作为参数，并将用于每个字段：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, apart from small naming changes to make the meaning of bindings
    clearer, the only big change was to add a `FnMut` in the `where` signature of
    the function, which will be the `getter` or `setter` implementer. Therefore, to
    call this new function, we will need to change the `derive_getters()` method and
    add the new `derive_setters()` function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，除了对绑定进行小的命名更改以使意义更清晰之外，唯一的重大变化是在函数的`where`签名中添加了一个`FnMut`，这将作为获取器或设置器的实现者。因此，为了调用这个新函数，我们需要更改`derive_getters()`方法并添加新的`derive_setters()`函数：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, both methods are exactly the same, except that, when calling
    the `impl_methods()` function, they use a different strategy. The first one will
    generate getters and the second one setters. Finally, let''s see what the `generate_setters()`
    function will look like:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这两种方法完全相同，只是在调用`impl_methods()`函数时，它们使用了不同的策略。第一个将生成获取器，第二个生成设置器。最后，让我们看看`generate_setters()`函数将是什么样子：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code is similar in most aspects to the `generate_getter()` function, but
    it has some differences. First, the function name is not the same as the `name`,
    since it needs the `set_` prefix. For that, we create a string with the field
    name after it and we create an identifier with that name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在大多数方面与`generate_getter()`函数类似，但有一些不同。首先，函数名与`name`不同，因为它需要`set_`前缀。为此，我们创建了一个带有字段名的字符串，并使用该名称创建了一个标识符。
- en: We then construct the setter by using the new function name, using a mutable
    `self` and adding a new input variable to the function, the value. Since we want
    this value to be generic, we use the `T` type that we define later in the where
    clause as being a type that can be transformed into our field type (`Into<#ty>`).
    We finally assign the converted value to our field.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用新的函数名，使用可变的`self`，并向函数添加一个新的输入变量（值）来构建设置器。由于我们希望这个值是通用的，我们使用在where子句中定义的`T`类型，它是一个可以转换为我们字段类型的类型（`Into<#ty>`）。我们最终将转换后的值赋给我们的字段。
- en: 'Let''s see how this getter and setter setup works by creating a short example
    in the `main.rs` file of our parent crate. We add the procedural macro dependency
    to the `Cargo.toml` file and we define a structure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在父crate的`main.rs`文件中创建一个简短的示例来查看这个获取器和设置器设置是如何工作的。我们在`Cargo.toml`文件中添加了过程宏依赖项，并定义了一个结构体：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Nothing special about it; except the `Getters` and `Setters` derive. As you
    see, we don''t need to derive an actual trait. Now, we add a simple `main()` function
    to test the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别的地方；除了`Getters`和`Setters`派生。正如你所见，我们不需要派生一个实际的特质。现在，我们添加一个简单的`main()`函数来测试代码：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We create a new `Alice` structure and set the two fields in it. When printing
    the structure, we can see that the `Alice::x()` and `Alice::y()` getters can be
    used directly. Note that the double braces are for escaping.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`Alice`结构体，并在其中设置了两个字段。当打印这个结构体时，我们可以看到可以直接使用`Alice::x()`和`Alice::y()`获取器。注意，双大括号用于转义。
- en: 'Then, since we have a mutable variable, we use the setters to change the values
    of the `x` and `y` fields. As you can see, we don''t have to provide a `String`
    or a `u32`; we can provide any type that can be converted directly to those without
    failing. Finally, since we implemented the `Debug` trait for `Alice`, we can print
    its contents without using the getters. The result after executing `cargo run`
    should be the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于我们有一个可变变量，我们使用设置器来改变`x`和`y`字段的值。正如你所见，我们不必提供`String`或`u32`；我们可以提供任何可以直接转换为这些类型而不会失败的类型。最后，由于我们为`Alice`实现了`Debug`特质，我们可以不使用获取器就打印其内容。执行`cargo
    run`后的结果应该是以下内容：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Procedural macros or custom derives allow for really complex code generation,
    and you can even further customize the user experience. As we saw in the previous
    chapter, with the `serde` crate we could use the `#[serde]` attribute. You can
    add custom attributes to your derive crate by defining them in the `#[proc_macro_derive]`
    attribute, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 过程宏或自定义派生允许进行非常复杂的代码生成，并且您甚至可以进一步自定义用户体验。正如我们在上一章中看到的，使用`serde`包，我们可以使用`#[serde]`属性。您可以通过在`#[proc_macro_derive]`属性中定义它们来向您的派生包添加自定义属性，如下所示：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can then use them by checking the attributes of the structure/enumeration
    or its fields via the `attrs` fields in `Field`, `DeriveInput`, `Variant`, or
    `FieldValue` structures. You could, for example, let the developer decide whether
    they wanted generics in the setters or to fine-tune the attributes that should
    be generic.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过检查结构体/枚举或其字段在`Field`、`DeriveInput`、`Variant`或`FieldValue`结构中的`attrs`字段来使用它们。例如，您可以允许开发者决定他们是否希望在设置器中使用泛型，或者微调应该泛型的属性。
- en: Extra information can be found in the official documentation at [https://doc.rust-lang.org/book/first-edition/procedural-macros.html#custom-attributes](https://doc.rust-lang.org/book/first-edition/procedural-macros.html#custom-attributes).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在官方文档中找到，请参阅[https://doc.rust-lang.org/book/first-edition/procedural-macros.html#custom-attributes](https://doc.rust-lang.org/book/first-edition/procedural-macros.html#custom-attributes)。
- en: Metaprogramming in nightly Rust
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 夜间Rust中的元编程
- en: Until now, we have stayed in stable Rust, since it allows forward compatibility.
    There are some nightly features, though, that can help us improve our control
    over the code we generate. Nevertheless, all of them are experimental and they
    might change or even get removed before being stabilized.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直停留在稳定版Rust中，因为它允许向前兼容。尽管如此，也有一些夜间功能可以帮助我们提高对我们生成的代码的控制。尽管如此，它们都是实验性的，它们在稳定之前可能会改变或甚至被删除。
- en: Therefore, you should take into account that using nightly features will probably
    break your code in the future and it will take more effort to maintain it to be
    compatible with new Rust versions. Nevertheless, we will have a quick look at
    two new features that are coming to Rust.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该考虑到使用夜间功能可能会在未来破坏您的代码，并且为了与新的Rust版本兼容，维护它将需要更多的努力。尽管如此，我们将快速查看即将加入Rust的两个新功能。
- en: Understanding compiler plugins
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解编译器插件
- en: The Rust nightly compiler accepts loading extensions, called **plugins**. They
    effectively change the way the compiler behaves, so they can modify the language
    itself. A plugin is a crate, similar to the procedural macro crate we created
    previously.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Rust夜间编译器接受加载扩展，称为**插件**。它们实际上改变了编译器的行为，因此它们可以修改语言本身。插件是一个crate，类似于我们之前创建的过程宏crate。
- en: The difference between a procedural or standard macro and a plugin is that,
    while the first two modify the Rust code they are given, a plugin is able to perform
    extra computations that can greatly improve the performance of your crate.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 过程宏或标准宏与插件之间的区别在于，虽然前两者修改了它们所提供的Rust代码，但插件能够执行额外的计算，这可以大大提高crate的性能。
- en: Since these plugins get loaded inside the compiler, they will have access to
    a lot of information that standard macros don't have. Moreover, this requires
    using the `rustc` compiler and the `libsyntax` library as external crates, which
    means that you will be loading a lot of the compiler code when compiling the plugin.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些插件在编译器内部加载，它们将能够访问标准宏没有的大量信息。此外，这需要使用`rustc`编译器和`libsyntax`库作为外部crate，这意味着在编译插件时，您将加载大量的编译器代码。
- en: Therefore, do not add your plugin as an external crate to your binaries as it
    will create a huge executable with a lot of compiler code. To use a plugin without
    adding it as a library, you will need the nightly compiler and you will have to
    add `#![feature(plugin)]` and `#![plugin({plugin_name})]` attributes to your crate.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不要将您的插件作为外部crate添加到您的二进制文件中，因为这将创建一个包含大量编译器代码的巨大可执行文件。要使用不作为库添加的插件，您需要夜间编译器，并且必须将`#![feature(plugin)]`和`#![plugin({plugin_name})]`属性添加到您的crate中。
- en: 'When developing a new plugin, you will need to create the crate with some extra
    information in the `Cargo.toml` file, as we did with the procedural macro:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发一个新插件时，您需要在`Cargo.toml`文件中创建带有一些额外信息的crate，就像我们为过程宏所做的那样：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, in the `lib.rs` file, you will need to import the required libraries
    and define the plugin registrar. The bare minimum for the plugin to work would
    be the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `lib.rs` 文件中，你需要导入所需的库并定义插件注册器。插件正常工作的最低要求如下：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Even though, in this example, the `rustc`, `syntax`, and `syntax_pos` crates
    are not being used, it's almost certain you will need them when developing the
    plugin, since they have the required types for you to change any behaviour. The
    `Registry` object lets you register multiple types of new language items, such
    as macros or syntax extensions. For each of them, you will need to define a function
    to receive the compiler tokens and modify them to produce the desired output.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中，`rustc`、`syntax` 和 `syntax_pos` crate 没有被使用，但在开发插件时，你几乎肯定会需要它们，因为它们提供了你改变任何行为所需所需的类型。`Registry`
    对象允许你注册多种新的语言项，例如宏或语法扩展。对于每一个，你都需要定义一个函数来接收编译器标记并修改它们以产生所需的结果。
- en: The `#![crate_type = "dylib"]` attribute tells the compiler to create a dynamic
    library with the crate, instead of the normal static one. This enables the library
    to be loaded by the compiler. The `plugin_registrar` nightly feature lets us create
    the actual plugin registrar function and the `rustc_private` feature allows us
    to use the private Rust compiler types so that we can use the compiler internals.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`#![crate_type = "dylib"]` 属性告诉编译器使用 crate 创建动态库，而不是正常的静态库。这使得库可以被编译器加载。`plugin_registrar`
    夜间功能允许我们创建实际的插件注册器函数，而 `rustc_private` 功能允许我们使用私有的 Rust 编译器类型，这样我们就可以使用编译器内部功能。'
- en: At the time of writing, the only online documentation for these crates is the
    one hosted by Manish Goregaokar, but that should change soon. On his website,
    you can find the API documentation for `rustc_plugin` ([https://manishearth.github.io/rust-internals-docs/rustc_plugin/index.html](https://manishearth.github.io/rust-internals-docs/rustc_plugin/index.html)),
    for `rustc` ([https://manishearth.github.io/rust-internals-docs/rustc/index.html](https://manishearth.github.io/rust-internals-docs/rustc/index.html)),
    for `syntax` ([https://manishearth.github.io/rust-internals-docs/syntax/index.html](https://manishearth.github.io/rust-internals-docs/syntax/index.html)),
    and for `syntax_pox` ([https://manishearth.github.io/rust-internals-docs/syntax_pos/index.html](https://manishearth.github.io/rust-internals-docs/syntax_pos/index.html)).
    I invite you to read the API of those crates and to create small plugins for the
    compiler. Nevertheless, remember that the syntax will probably change, which makes
    it more difficult to maintain.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，这些 crate 的唯一在线文档是由 Manish Goregaokar 提供的，但这种情况很快就会改变。在他的网站上，你可以找到 `rustc_plugin`
    的 API 文档（[https://manishearth.github.io/rust-internals-docs/rustc_plugin/index.html](https://manishearth.github.io/rust-internals-docs/rustc_plugin/index.html)）、`rustc`
    的 API 文档（[https://manishearth.github.io/rust-internals-docs/rustc/index.html](https://manishearth.github.io/rust-internals-docs/rustc/index.html)）、`syntax`
    的 API 文档（[https://manishearth.github.io/rust-internals-docs/syntax/index.html](https://manishearth.github.io/rust-internals-docs/syntax/index.html)）和
    `syntax_pos` 的 API 文档（[https://manishearth.github.io/rust-internals-docs/syntax_pos/index.html](https://manishearth.github.io/rust-internals-docs/syntax_pos/index.html)）。我邀请你阅读这些
    crate 的 API，并为编译器创建小型插件。不过，请记住，语法可能会改变，这会使维护变得更加困难。
- en: Declarative macros
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式宏
- en: The next thing that is coming to Rust are declarative macros, macros 2.0, or
    macros by example. It's true that some call standard macros declarative macros
    too, since they are based on the same principle. But I wanted to make this difference
    known so that we learn about some improvements that these new macros will bring
    to the language.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来即将加入 Rust 的功能是声明式宏，即宏 2.0 或示例宏。确实，有些人也将标准宏称为声明式宏，因为它们基于相同的原则。但我希望让大家知道这种区别，以便了解这些新宏将为语言带来的改进。
- en: These new macros introduce the `macro` keyword, which will work similarly to
    the `macro_rules!{}` macro, but using a syntax more close to the function syntax
    than to the current syntax. Not only that, it will also add modularization to
    macros so that you can have two macros with the same name in the same crate, as
    long as they are in different modules. This extra modularization will make integration
    between crates much easier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新宏引入了 `macro` 关键字，其工作方式将与 `macro_rules!{}` 宏类似，但使用的语法更接近函数语法，而不是当前的语法。不仅如此，它还将模块化引入宏中，这样你就可以在同一个
    crate 中拥有两个同名宏，只要它们位于不同的模块中。这种额外的模块化将使 crate 之间的集成变得更加容易。
- en: Sadly, there is still no syntax proposition for these macros, and the current
    nightly implementation is not much more than a placeholder for what is yet to
    come. I invite you to keep yourself up to date on the standardization of these
    new macros and even to define a future syntax for them by contributing to the
    community.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这些宏还没有提出语法建议，当前nightly的实现也不过是未来将要到来的内容的占位符。我邀请你关注这些新宏的标准化进程，甚至通过为社区做出贡献来定义它们的未来语法。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to create your own macros. First, we saw
    the standard macros and created some that could help you develop more quickly
    and create more efficient code. Then, you learned about procedural macros and
    how to derive your own code for your structures and enumeration. Finally, you
    found out about two features that might be coming to stable Rust in the future,
    which can currently be used in nightly Rust—plugins and declarative macros.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建自己的宏。首先，我们了解了标准宏，并创建了一些可以帮助你更快地开发并编写更高效代码的宏。然后，你学习了过程宏以及如何为你自己的结构和枚举推导出代码。最后，你发现了两个可能在未来稳定版Rust中出现的特性，目前可以在nightly
    Rust中使用——插件和声明式宏。
- en: In the two remaining chapters, we will talk about concurrency in Rust. As you
    will see, once our single-threaded code is fast enough, the next step toward faster
    execution is to compute it in parallel.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个章节中，我们将讨论Rust中的并发。正如你将看到的，一旦我们的单线程代码足够快，向更快执行迈出的下一步就是在并行中计算它。
