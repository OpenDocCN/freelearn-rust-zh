- en: Advanced Programming with Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 进行高级编程
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Defining an expression
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个表达式
- en: Defining constants
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义常量
- en: Performing variable bindings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行变量绑定
- en: Performing type casting in Rust
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中执行类型转换
- en: Decision-making with Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rust 进行决策
- en: Looping operations in Rust
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 中的循环操作
- en: Defining the enum type
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义枚举类型
- en: Defining closures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义闭包
- en: Performing pointer operations in Rust
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中执行指针操作
- en: Defining your first user-defined data type
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义你的第一个用户定义数据类型
- en: Adding functionality to the user-defined data type
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户定义的数据类型添加功能
- en: Similar functionality for different data type
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同数据类型的类似功能
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is focused on equipping you with all the recipes to implement expressions
    that will represent the state of the code, build logic using decision-making statements
    such as `if...else`, declare a custom complex data type to represent a real-world
    scenario using `struct`, add functionality to a complex data type using traits,
    and control code execution using the looping statement.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是为你提供所有食谱来实现表示代码状态的表达式，使用 `if...else` 等决策语句构建逻辑，使用 `struct` 声明自定义复杂数据类型以表示现实世界场景，使用特质向复杂数据类型添加功能，以及使用循环语句控制代码执行。
- en: Defining an expression
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个表达式
- en: An expression, in simple words, is a statement in Rust by using which we can
    create logic and workflows in the program and applications. We will deep dive
    into understanding expressions and blocks in Rust.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，表达式是 Rust 中的一个语句，通过它我们可以在程序和应用程序中创建逻辑和工作流程。我们将深入了解 Rust 中的表达式和块。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the ensuing steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: Create a file named `expression.rs` with the next code snippet.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `expression.rs` 的文件，并包含以下代码片段。
- en: 'Declare the `main` function and create the variables `x_val`, `y_val`, and
    `z_val`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `main` 函数并创建变量 `x_val`、`y_val` 和 `z_val`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should get the ensuing output upon running the code. Please refer to the
    following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，你应该得到以下输出。请参考以下截图：
- en: '![](img/4a06ce81-0c14-41ec-8059-11313a8eee4f.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a06ce81-0c14-41ec-8059-11313a8eee4f.png)'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the statements that end in a semicolon (`;`) are expressions. A block is
    a statement that has a set of statements and variables inside the `{}` scope.
    The last statement of a block is the value that will be assigned to the variable.
    When we close the last statement with a semicolon, it returns `()` to the variable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以分号 (`;`) 结尾的语句都是表达式。一个块是一个包含一组语句和变量的语句，其最后一个语句是分配给变量的值。当我们用分号关闭最后一个语句时，它将
    `()` 返回给变量。
- en: In the preceding recipe, the first statement which is a variable named `x_val`
    , is assigned to the value `5`. Second, `y_val` is a block that performs certain
    operations on the variable `x_val` and a few more variables, which are `x_squared`
    and `x_cube` that contain the squared and cubic values of the variable `x_val`
    , respectively. The variables `x_squared` and `x_cube` , will be deleted soon
    after the scope of the block.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，第一个语句是一个名为 `x_val` 的变量，其值被分配为 `5`。其次，`y_val` 是一个对变量 `x_val` 和其他一些变量执行特定操作的块，这些变量分别是
    `x_squared` 和 `x_cube`，分别包含变量 `x_val` 的平方和立方值。变量 `x_squared` 和 `x_cube` 将在块的范围内很快被删除。
- en: The block where we declare the `z_val` variable has a semicolon at the last
    statement which assigns it to the value of `()`, suppressing the expression. We
    print out all the values in the end.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 `z_val` 变量的块在其最后一个语句中有一个分号，该语句将其赋值为 `()` 的值，抑制了表达式。我们将在最后打印出所有值。
- en: We print all the declared variables values in the end.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在最后打印出所有声明的变量值。
- en: Defining constants
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义常量
- en: Rust provides the ability to assign and maintain constant values across the
    code in Rust. These values are very useful when we want to maintain a global count,
    such as a timer threshold for example. Rust provides two `const` keywords to perform
    this activity. You will learn how to deliver constant values globally in this
    recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 提供了在 Rust 代码中分配和维护常量值的能力。这些值在我们想要维护全局计数时非常有用，例如，例如计时器阈值。Rust 提供了两个 `const`
    关键字来执行此操作。你将在本食谱中学习如何全局传递常量值。
- en: Getting ready
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: Create a file named `constant.rs` with the next code snippet.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `constant.rs` 的文件，并包含以下代码片段。
- en: 'Declare the global `UPPERLIMIT` using `constant`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `constant` 声明全局变量 `UPPERLIMIT`：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the `is_big` function by accepting a single integer as input:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过接受一个整数作为输入来创建 `is_big` 函数：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `main` function, call the `is_big` function and perform the decision-making
    statement:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，调用 `is_big` 函数并执行决策语句：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该得到以下截图作为输出：
- en: '![](img/c60a17c8-d8fc-4ab2-8545-fa765521cbf9.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c60a17c8-d8fc-4ab2-8545-fa765521cbf9.png)'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The workflow of the recipe is fairly simple, where we have a function to check
    whether an integer is greater than a fixed threshold or not. The `UPPERLIMIT`
    variable defines the fixed threshold for the function, which is a constant whose
    value will not change in the code and is accessible throughout the program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的工作流程相当简单，我们有一个函数来检查一个整数是否大于一个固定的阈值。`UPPERLIMIT` 变量定义了函数的固定阈值，它是一个值在代码中不会改变的常量，并且在整个程序中都是可访问的。
- en: We assigned `15` to `random_number` and passed it via `is_big (integer value);`
    and we then get a boolean output, either `true` or `false`, as the return type
    of the function is a `bool` type. The answer to our situation is `false` as `15`
    is not bigger than `12`, which the `UPPERLIMIT` value set as the constant. We
    performed this condition checking using the `if...else` statement in Rust.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `15` 赋值给 `random_number` 并通过 `is_big (integer value);` 传递它，然后我们得到一个布尔输出，即
    `true` 或 `false`，因为函数的返回类型是 `bool` 类型。我们情况下的答案是 `false`，因为 `15` 不大于 `12`，这是 `UPPERLIMIT`
    值设置的常量。我们使用 Rust 中的 `if...else` 语句执行此条件检查。
- en: We cannot change the `UPPERLIMIT` value; when attempted, it will throw an error,
    which is commented in the code section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能更改 `UPPERLIMIT` 的值；当尝试更改时，它将抛出一个错误，这在代码部分中已注释。
- en: 'Constants declare constant values. They represent a value, not a memory address:
    `type = value;`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明常量值。它们代表一个值，而不是内存地址：`type = value;`
- en: Performing variable bindings
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行变量绑定
- en: Variable binding refers to how a variable in the Rust code is bound to a type.
    We will cover pattern, mutability, scope, and shadow concepts in this recipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 变量绑定指的是 Rust 代码中的变量如何绑定到类型。在本食谱中，我们将涵盖模式、可变性、作用域和阴影概念。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来进行编码。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following step:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a file named `binding.rs` and enter a code snippet that includes declaring
    the `main` function and different variables:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `binding.rs` 的文件，并输入以下代码片段，包括声明 `main` 函数和不同变量：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该得到以下截图作为输出：
- en: '![](img/3ec9f244-b7ee-427e-910f-347cb826dc2b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ec9f244-b7ee-427e-910f-347cb826dc2b.png)'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `let` statement is the simplest way to create a binding, where we bind
    a variable to a value, which is the case with variable `a`. To create a pattern
    with the `let` statement, we assign the pattern values to `b` and `c` values in
    the same pattern. Rust is a statically typed language. This means that we have
    to specify our types during an assignment, and at compile time, it is checked
    to see if it is compatible. Rust also has the type reference feature that identifies
    the variable type automatically at compile time. The `variable_name : type` is
    the format we use to explicitly mention the type in Rust. We read the assignment
    in the following format:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 语句是创建绑定最简单的方式，其中我们将变量绑定到一个值，就像变量 `a` 一样。要使用 `let` 语句创建一个模式，我们将模式值分配给相同模式中的
    `b` 和 `c` 值。Rust 是一种静态类型语言。这意味着我们必须在赋值时指定我们的类型，并且在编译时检查它是否兼容。Rust 还具有类型引用功能，该功能在编译时自动识别变量类型。`variable_name
    : type` 是我们在 Rust 中显式提及类型的格式。我们按照以下格式读取赋值：'
- en: x_val is a binding with the type i32 and the value 5.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: x_val 是一个类型为 i32 且值为 5 的绑定。
- en: Here, we declared `x_val` as a 32-bit signed integer. However, Rust has many
    different primitive integer types that begin with `i` for signed integers and
    `u` for unsigned integers, and the possible integer sizes are 8, 16, 32, and 64
    bits.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `x_val` 声明为 32 位有符号整数。然而，Rust 有许多不同的原始整数类型，以 `i` 开头表示有符号整数，以 `u` 开头表示无符号整数，可能的整数大小为
    8、16、32 和 64 位。
- en: Variable bindings have a scope that makes the variable alive only in the scope.
    Once it goes out of the scope, the resources are freed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 变量绑定有一个作用域，使得变量仅在作用域内有效。一旦超出作用域，资源就会被释放。
- en: A block is a collection of statements enclosed by `{}`. Function definitions
    are also blocks! We use a block to illustrate the feature in Rust that allows
    variable bindings to be shadowed. This means that a later variable binding can
    be done with the same name, which in our case is `y_val`. This goes through a
    series of value changes, as a new binding that is currently in scope overrides
    the previous binding. Shadowing enables us to rebind a name to a value of a different
    type. This is the reason why we are able to assign new values to the immutable
    `y_val` variable in and out of the block.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 块是一组由 `{}` 包围的语句。函数定义也是块！我们使用块来展示 Rust 中允许变量绑定被阴影化的特性。这意味着可以使用相同的名称进行后续的变量绑定，在我们的例子中是
    `y_val`。它经历了一系列的值变化，因为当前作用域中的新绑定覆盖了之前的绑定。阴影化使我们能够将名称重新绑定到不同类型的值。这就是为什么我们能够在块内外对不可变的
    `y_val` 变量赋新值的原因。
- en: Performing type casting in Rust
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中进行类型转换
- en: In this recipe, you will learn about casting between different data types in
    Rust. Rust does not provide an automatic type cast. The developer has to manually
    own it. Using as we will perform safe type casting in Rust.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习在 Rust 中进行不同数据类型之间的转换。Rust 不提供自动类型转换。开发者必须手动完成。使用 `as` 我们将在 Rust
    中执行安全类型转换。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a file named `typecasting.rs` and enter the following code to the script:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `typecasting.rs` 的文件，并将以下代码输入到脚本中：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code snippet, we created four variables: `true_positive`,
    `true_negative`, `false_positive`, and `false_negative`. These are basically the
    four measurement parameters of a confusion matrix.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了四个变量：`true_positive`、`true_negative`、`false_positive` 和 `false_negative`。这些都是混淆矩阵的基本四个测量参数。
- en: Call the `accuracy` and `percentage` function that returns the final accuracy
    percentage.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用返回最终准确百分比的 `accuracy` 和 `percentage` 函数。
- en: 'The `total` variable is the sum of all the measurements:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`total` 变量是所有测量的总和：'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `accuracy` function accepts those which are all `int` data types that return
    a `float` data type.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`accuracy` 函数接受所有返回 `float` 数据类型的 `int` 数据类型。'
- en: The value received from the `accuracy` function is passed to the `percentage`
    function and the `accuracy` is printed.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `accuracy` 函数接收的值传递给 `percentage` 函数，并打印出准确度。
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该得到以下截图作为输出：
- en: '![](img/84373cae-5155-4aff-a7bc-984bd5d2cbd2.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84373cae-5155-4aff-a7bc-984bd5d2cbd2.png)'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have two functions, `accuracy` and `percentage`, which take
    in arguments from the `main` function and convert the type passed to the desired
    type, due to the nature of the arithmetic operations for which we use the `as`
    keywords in Rust which helps in type casting in Rust. In the case of the `accuracy`
    function, it takes three input arguments of type `i32` and returns a single `f32`
    type value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们有两个函数，`accuracy` 和 `percentage`，它们从 `main` 函数接收参数，并将传递的类型转换为所需的类型，这是由于我们使用的
    `as` 关键字在 Rust 中的算术运算特性，它有助于 Rust 中的类型转换。在 `accuracy` 函数的情况下，它接受三个类型为 `i32` 的输入参数，并返回一个单一的
    `f32` 类型值。
- en: 'In order to protect developers from accidental casts, Rust makes it mandatory
    for developers to convert data types manually. In the following example, we define
    an `int` variable named `a` and assign it the value `3`; after the assignment
    operation, we would see that a part of the code is commented. This implies that
    it won''t be compiled by the Rust compiler. If we take a careful look at the code,
    we find that we are multiplying an `int` variable with a flat value, which will
    give us a type mismatch error during compilation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护开发者免受意外类型转换的影响，Rust 强制开发者手动转换数据类型。在下面的示例中，我们定义了一个名为 `a` 的 `int` 变量并将其赋值为
    `3`；在赋值操作后，我们会看到部分代码被注释了。这表明它不会被 Rust 编译器编译。如果我们仔细查看代码，我们会发现我们正在将一个 `int` 变量与一个扁平值相乘，这将在编译期间产生类型不匹配错误：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see, we used the `as` keyword converting `int` to `float` (64-bit)
    in order to multiply an `int` value by a `float` variable. This step produced
    `b` without any error:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们使用了 `as` 关键字将 `int` 转换为 `float`（64位），以便将 `int` 值乘以一个 `float` 变量。这一步生成了
    `b` 而没有错误：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that when we perform arithmetic operations in the same kind of data type,
    we don't have to worry about type conversion as the result of the operation produced
    is automatically typecasted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们对同一类型的数据进行算术运算时，我们不必担心类型转换，因为操作产生的结果会自动类型转换。
- en: Decision-making with Rust
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 进行决策
- en: In this recipe, we will learn about decision-making statements in Rust. Condition
    checking in Rust is similar to other dynamic programming languages and is very
    easy to use. Using `if...else` statements, we will perform condition checking
    in Rust.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习 Rust 中的决策语句。Rust 中的条件检查与其他动态编程语言类似，非常容易使用。我们将使用 `if...else` 语句在
    Rust 中执行条件检查。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a file named `condition.rs` and enter the following code to the script:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `condition.rs` 的文件，并将以下代码输入到脚本中：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a variable named `age` and assign it to an integer with the value `10`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `age` 的变量，并将其赋值为整数 `10`。
- en: The preceding code has an `if...else` statement to make a decision about the
    `age` value. It performs print operations based on the conditions.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码包含一个 `if...else` 语句，用于根据 `age` 值做出决策。它根据条件执行打印操作。
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该得到以下截图作为输出：
- en: '![](img/d86289f0-d256-4aaf-a32c-fc91cc7e3e28.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d86289f0-d256-4aaf-a32c-fc91cc7e3e28.png)'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we implemented an `if...else` statement to perform conditional
    statements in Rust. The conditions are performed in the `age` variable. In this
    recipe, we assigned an immutable variable taking the value `10`; after this, we
    compared it with various rules and performed an action based on the qualifying
    rule.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们实现了一个 `if...else` 语句来在 Rust 中执行条件语句。条件在 `age` 变量中执行。在这个菜谱中，我们分配了一个不可变的变量，其值为
    `10`；之后，我们将其与各种规则进行比较，并根据合格规则执行操作。
- en: These rules are the conditions that the developer generates in the form of a
    mathematical operation that yields a result of `true` or `false`. Based on the
    output of the operation, we select a particular set of actions inside the scope
    of the decision statement.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则是开发者以数学运算的形式生成的条件，该运算产生 `true` 或 `false` 的结果。根据操作的输出，我们在决策语句的作用域内选择特定的操作集。
- en: The `if...else` statements are a great tool for developers to route the program
    logic. They are ideal for comparing thresholds at the end state of the application
    for making a logical decision.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else` 语句是开发者路由程序逻辑的强大工具。它们非常适合在应用程序的最终状态比较阈值以做出逻辑决策。'
- en: 'In the preceding case, we checked three cases in the following flow:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，我们按照以下流程检查了三个案例：
- en: The `if` statement checks whether the `age` variable is less than `18`. If the
    operation returns `true`, then we go ahead and print `Go to School`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句检查 `age` 变量是否小于 `18`。如果操作返回 `true`，则继续打印 `Go to School`。'
- en: The next condition is checked in the `else...if` statement when the first condition
    returns `false`; here we check whether the age is between `18` and `28`, and if
    this condition returns `true`, we print `Go to college`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当第一个条件返回 `false` 时，在 `else...if` 语句中检查下一个条件；在这里，我们检查年龄是否在 `18` 到 `28` 之间，如果这个条件返回
    `true`，则打印 `Go to college`。
- en: Lastly, we have the `else` statement, which has no condition and is executed
    only when all the preceding conditions fail.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有 `else` 语句，它没有条件，仅在所有前面的条件失败时执行。
- en: It's often a very important skill to write in a very optimized manner. We should
    learn the ability to develop the skill of writing less and optimized code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 写得非常优化通常是至关重要的技能。我们应该学会发展编写更少、更优化代码的技能。
- en: 'The preceding set of statements contains a lot of lines of code, but we can
    write it in an optimized way, where we would have the `if...else` statement along
    with the condition in a single line. The general syntax for this case is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句集包含大量的代码行，但我们可以将其优化，将 `if...else` 语句与条件放在一行中。这种情况的一般语法如下：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have a variable to which we assign the `if` the `condition 1` operation produces
    `true`; alternatively, we assign the value from the `else` statement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个变量，当 `condition 1` 操作产生 `true` 时，我们将其赋值；否则，我们将其赋值为 `else` 语句中的值。
- en: Looping operations in Rust
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 中的循环操作
- en: In this recipe, you will learn about looping statements in Rust. Looping statements
    that we are referring to in Rust provide interactive functionality. Using the
    `loop`, `while`, and `for` keywords, we can perform iterative operations in Rust.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解 Rust 中的循环语句。在 Rust 中，我们所说的循环语句提供了交互式功能。使用 `loop`、`while` 和 `for`
    关键字，我们可以在 Rust 中执行迭代操作。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a file named `looping.rs` and enter the following code in the script.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `looping.rs` 的文件，并在脚本中输入以下代码。
- en: In the `main` function, perform a looping operation on the mutable variable
    `x`, which is initially assigned to the integer value of `1`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，对可变变量 `x` 执行循环操作，`x` 初始赋值为整数值 `1`。
- en: 'Define a `loop` statement, which is an infinite iterative statement, and check
    the various conditions inside its scope:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `loop` 语句，这是一个无限迭代语句，并检查其作用域内的各种条件：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a mutable variable `y` and assign it to the integer value `1` , and
    define a `while` loop with the `y < 10` condition:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可变变量 `y` 并将其赋值为整数值 `1`，然后定义一个 `while` 循环，条件为 `y < 10`：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Perform a similar operation as for the `while` loop. Here, use the `for` loop
    to iterate over the 1 to 9 range on the mutable variable `z`, which is initially
    assigned to the value `1`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行与 `while` 循环类似的操作。这里，使用 `for` 循环在可变变量 `z` 上迭代 1 到 9 的范围，`z` 初始赋值为 `1`：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该得到以下截图作为输出：
- en: '![](img/8a27d1e7-4a2a-4ab8-b357-e5de211f1e5c.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a27d1e7-4a2a-4ab8-b357-e5de211f1e5c.png)'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `loop` is an iterative keyword in Rust where the statements inside its scope
    run forever, that is, indefinitely, unless they are explicitly stopped by the
    `break` statement. This is very useful when we want a process a particular task
    in an application until it reaches a particular state for further processing.
    Consider a video storage application where I want to continuously save the camera
    feeds until the users give a command to stop the application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop` 是 Rust 中的一个迭代关键字，其中其作用域内的语句会无限循环运行，也就是说，除非通过 `break` 语句显式停止，否则会无限期地运行。这在我们需要在一个应用程序中处理特定任务直到达到特定状态以便进一步处理时非常有用。考虑一个视频存储应用程序，其中我想持续保存摄像头数据流，直到用户发出停止应用程序的命令。'
- en: In this recipe, we declared a mutable `int` variable `x`, which we initialized
    with the value `1`. When it enters the `loop` statement, we had two conditions
    for it. The first condition prints the value of `x`. Only when it is an even number,
    we use the `%` operator to perform this divisibility operation, followed by an
    increase in the value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们声明了一个可变 `int` 变量 `x`，并将其初始化为值 `1`。当它进入 `loop` 语句时，我们为它设置了两个条件。第一个条件打印
    `x` 的值。只有当它是偶数时，我们使用 `%` 运算符执行这个可除性操作，然后增加其值。
- en: Then we used the `continue` keyword, which goes back to the `loop`. The preceding
    statements of the keyword will not be executed. The second condition checks whether
    the value of `x` is greater than `10`. This condition will only be reached at
    runtime. When the value of `x` is odd in this case, we break the `loop`, which
    is the exit point of the infinite loop, which is similar to the case of the stop
    button in the video application discussed in the preceding example. Next, we increase
    the value of the next iteration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用了 `continue` 关键字，它返回到 `loop`。该关键字之前的状态将不会执行。第二个条件检查 `x` 的值是否大于 `10`。这个条件只有在运行时才会达到。在这种情况下，如果
    `x` 的值是奇数，我们将退出 `loop`，这是无限循环的出口点，类似于前面例子中讨论的视频应用程序中的停止按钮。接下来，我们增加下一次迭代的值。
- en: While printing `1` to `9` in two different ways, the first method uses `while`,
    where we have a condition placed which is at first compared to the loop that does
    not have a condition. All the while, the loop checks the condition at every iteration.
    Only if it is `true`, it proceeds. In the preceding case, we had an immutable
    variable `y`, which was initialized with the value `1`. We had a condition which
    checks whether `y` is less than `10` at every iteration. In each iteration, we
    print the value of `y` and increase its value by `1`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在以两种不同的方式打印 `1` 到 `9` 时，第一种方法使用 `while`，其中我们放置了一个条件，该条件最初与没有条件的循环进行比较。在整个循环过程中，循环在每次迭代时都会检查条件。只有当它是
    `true` 时，它才会继续。在前面的情况下，我们有一个不可变的变量 `y`，它被初始化为值 `1`。我们有一个在每次迭代时检查 `y` 是否小于 `10`
    的条件。在每次迭代中，我们打印 `y` 的值并将其值增加 `1`。
- en: The second way to do the preceding activity is by using the `for` looping statement,
    where we specify a range of values in which we want to operate. We don't have
    any explicit condition checking, as in the case of other looping statements. We
    declared an immutable variable `z`, which was initialized to the value `1` and
    then iterated from `1` to `10` in the loop where we print the value in every step.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述活动的第二种方法是使用 `for` 循环语句，其中我们指定了要操作的值的范围。我们没有像其他循环语句那样进行显式条件检查。我们声明了一个不可变的变量
    `z`，它被初始化为值 `1`，然后在循环中从 `1` 迭代到 `10`，在每一步中打印值。
- en: Looping statements are really handy to the developer when there is a requirement
    to perform a particular task repeatedly in the application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 循环语句在需要重复执行特定任务的应用程序中对于开发者来说非常有用。
- en: Defining the enum type
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义枚举类型
- en: In this recipe, you will learn about using the `enum` type in Rust. In Rust,
    the `enum` type lets the developer represent data in multiple formats, and each
    format can optionally have specific data associated with it. Using `enum` keywords,
    we perform iterative operations in Rust.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将了解如何在 Rust 中使用 `enum` 类型。在 Rust 中，`enum` 类型允许开发者以多种格式表示数据，并且每个格式可以可选地与特定的数据相关联。使用
    `enum` 关键字，我们在 Rust 中执行迭代操作。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a file named `enum.rs` and enter the following code in the script:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `enum.rs` 的文件，并在脚本中输入以下代码：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Declare an `enum` date type, namely `Hero`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `Hero` 的 `enum` 数据类型：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a function named `get_info` that will take the `enum` data type as an
    argument:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `get_info` 的函数，该函数将 `enum` 数据类型作为参数：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的代码后，你应该得到以下截图作为输出：
- en: '![](img/a1c20210-9c79-42b3-b994-1c5b4250d9e0.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1c20210-9c79-42b3-b994-1c5b4250d9e0.png)'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `enum` is a very important Rust type as it allows a particular data type
    to be associated with multiple data variants. A value of an `enum` type contains
    information about which data variant it is associated with.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 是 Rust 中一个非常重要的类型，因为它允许特定的数据类型与多个数据变体相关联。`enum` 类型的值包含有关它关联的数据变体的信息。'
- en: Another important point to note about `enum` in Rust before moving to the code
    explanation is you can use the `::` syntax in order to use the name of each data
    variant and assign values to the variables.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向代码解释之前，关于 Rust 中的 `enum` 的另一个重要点是，你可以使用 `::` 语法来使用每个数据变体的名称，并将值分配给变量。
- en: 'In the recipe, we created an `enum` type `Hero`, which has three types of data
    variants: `Fast`, which is not specified with explicit data requirements; `Strong(i32)`,
    which requires a 32-bit integer input; and `Info`, which supports two string data
    variables, `name` and `secret`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们创建了一个名为 `Hero` 的 `enum` 类型，它具有三种数据变体：`Fast`，它没有使用显式数据要求；`Strong(i32)`，它需要一个
    32 位整数输入；以及 `Info`，它支持两个字符串数据变量，`name` 和 `secret`。
- en: Next up, let's check out the initialization of these data variants in the `main`
    function. Here, we have created three variables that represent the three data
    variants and initialized them with the required data requirement. We also called
    the `get_info()` function three times by passing different `enum` data variants
    to print the data values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查 `main` 函数中这些数据变体的初始化。在这里，我们创建了三个变量来表示三种数据变体，并用所需的数据要求初始化它们。我们还三次调用了
    `get_info()` 函数，通过传递不同的 `enum` 数据变体来打印数据值。
- en: 'The is initialized with the `Hero::Strong(100)` `enum` type, `fasty` with `Hero::Fast`,
    and `spiderman` with `Hero::Info`, which requires two variables: `name:"spiderman".to_owned()`
    and `secret:"peter parker".to_owned()`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `Hero::Strong(100)` `enum` 类型初始化，`fasty` 使用 `Hero::Fast`，而 `spiderman` 使用
    `Hero::Info`，这需要两个变量：`name:"spiderman".to_owned()` 和 `secret:"peter parker".to_owned()`。
- en: Note that while declaring the values to `Hero` data variant `Info` , we assigned
    data variables with strings along with `.to_owned()` method, this is done in order
    to ensure the string is owned when borrowed, as `&str` is an immutable reference
    to a string and using `to_owned()` turns it into a string that we own.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在声明 `Hero` 数据变体 `Info` 的值时，我们使用字符串以及 `.to_owned()` 方法分配数据变量，这样做是为了确保在借用时字符串是所有者，因为
    `&str` 是字符串的不可变引用，使用 `to_owned()` 会将其转换为我们所拥有的字符串。
- en: 'The `get_info(argument : enum type)` function takes the `enum` as the data
    type, and when we pass each of the different data variants, the arguments are
    assigned with those values. Then we used the `match` statement, which is a decision-making
    statement, to compare the argument with the different types of data variants mentioned
    as the different cases in the `match` statement.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_info(argument : enum type)` 函数接受 `enum` 作为数据类型，当我们传递不同的数据变体时，参数会被分配这些值。然后我们使用了
    `match` 语句，这是一个决策语句，用于将参数与 `match` 语句中提到的不同数据变体类型进行比较。'
- en: We passed the fast variable, which is of the type `Fast`--variant of `Hero`--and
    it will print `Fast`, which is the first case of the `match` statement. Similarly,
    for the `spiderman` case and `hulk`, which are of the types `Info` and `Strong`,
    respectively, the corresponding statement in the match of the `get_info` function
    will be executed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了 `fast` 变量，其类型为 `Fast`--`Hero` 的变体--它将打印 `Fast`，这是 `match` 语句的第一个情况。同样，对于
    `spiderman` 情况和 `hulk`，它们分别是 `Info` 和 `Strong` 类型，`get_info` 函数中的匹配语句将执行相应的语句。
- en: Defining closures
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义闭包
- en: At an uber level, closures are similar to functions, and calling a closure is
    exactly like a function. Closures are similar to **lambdas**, which are basically
    functions that operate over the variables in a closed scope.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更高的层面上，闭包类似于函数，调用闭包就像调用函数一样。闭包类似于 **lambda**，它们基本上是在封闭作用域中操作变量的函数。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a file named `closures.rs` and enter the following code in the script:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `closures.rs` 的文件，并在脚本中输入以下代码：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define a closure and name it `sum_num`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个闭包并命名为 `sum_num`：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create another closure, namely `add_ten`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个闭包，命名为 `add_ten`：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的代码后，我们应该得到以下截图作为输出：
- en: '![](img/a0fb5d91-5cf4-456f-9a4a-f4c4b37f9058.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0fb5d91-5cf4-456f-9a4a-f4c4b37f9058.png)'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An important thing about a closure is that it's bound or its operations are
    within a scope where it is defined. It is similar to a function that uses the
    free variable in the environment of its operation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的一个重要特点是它是绑定或其操作在其定义的作用域内。这类似于一个使用操作环境中的自由变量的函数。
- en: Closures are great ways to write mathematical operations. If the developer is
    working on Rust to speed up the mathematical computation of the application, then
    the developer can maintain closures in his or her code for different equations
    for better optimization, code debugging, and benchmarking.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是编写数学运算的绝佳方式。如果开发者正在使用 Rust 来加速应用程序的数学计算，那么开发者可以在其代码中维护不同方程的闭包以实现更好的优化、代码调试和基准测试。
- en: In this recipe, we created two closures in the `main` function. The basic way
    to create a simple closure is to have a variable assigned to an operation, before
    in which we could declare the variable types in the pipe symbol in a `let` statement.
    The first closure is named `sum_num`, which basically adds two numbers and returns
    an integer output as the two variables it uses, namely `x` and `y`, which are
    32-bit integers. The second closure `add_ten` adds a fixed integer value of `10`
    to the integer that is passed to the closure. Calling a closure is similar to
    that of a function. The convention is to call the name of the closure followed
    by the parameters to be passed to the closure operation. In this recipe, we called
    `sum_num(7,8)`, which gave the output of `15` at runtime and `add_ten(3)`, which
    produced `13`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们在 `main` 函数中创建了两个闭包。创建简单闭包的基本方法是在操作之前将变量分配给一个操作，在此之前我们可以在 `let` 语句的管道符号中声明变量类型。第一个闭包名为
    `sum_num`，它基本上将两个数字相加并返回一个整数输出，这两个变量是它使用的 `x` 和 `y`，它们是 32 位整数。第二个闭包 `add_ten`
    将固定的整数值 `10` 添加到传递给闭包的整数。调用闭包的方式类似于函数。惯例是调用闭包的名称后跟传递给闭包操作的参数。在这个菜谱中，我们调用了 `sum_num(7,8)`，它在运行时给出了
    `15` 的输出，以及 `add_ten(3)`，它产生了 `13`。
- en: Performing pointer operations in Rust
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中执行指针操作
- en: Rust provides different smart pointers. These are different types of pointers
    used in Rust for different use cases, but `&mut T` is a mutable (exclusive) reference
    that is one of the operations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 提供了不同的智能指针。这些是在 Rust 中用于不同用例的不同类型的指针，但 `&mut T` 是一个可变（独占）引用，这是其中的一种操作。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a file named `pointer.rs` and enter the following code in the script:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pointer.rs` 的文件，并在脚本中输入以下代码：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a vector named `vect1` and assign it to `vec![1,2,3]`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `vect1` 的向量并将其赋值为 `vec![1,2,3]`：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Pass `&vect1` to the `sum_vects()` function:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `&vect1` 传递给 `sum_vects()` 函数：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Perform summation operations for each value of the vector:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对向量的每个值执行求和操作：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该得到以下截图作为输出：
- en: '![](img/9acfd557-9eb0-44fd-929f-794bcd5f3112.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9acfd557-9eb0-44fd-929f-794bcd5f3112.png)'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ownership and borrowing are the main concepts on which Rust is built, and the
    standard APIs given by Rust are based on this concept. In the preceding snippet,
    we created a vector, namely `vect1`, and assigned it `1,2,3` using the `vec!`
    keyword.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权和借用是 Rust 构建的主要概念，Rust 提供的标准 API 也是基于这个概念。在前面的代码片段中，我们创建了一个名为 `vect1` 的向量，并使用
    `vec!` 关键字将其赋值为 `1,2,3`。
- en: Note that a vector is a non-primitive value. Vectors cannot be reused after,
    as shown in the commented section of the code. The compiler will throw an error
    saying that `vect1` is a moved value and cannot be used. This is the case when
    we assign `vect1` to `vect2` and try to assign `vect1` to the print statement.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，向量是一个非原始值。向量在之后不能被重用，如代码注释部分所示。编译器将抛出一个错误，表示 `vect1` 是一个已移动的值，不能使用。这是当我们将
    `vect1` 赋值给 `vect2` 并尝试将其赋值给打印语句时的情况。
- en: In the `sum_vects(&vect1)` function, we passed the ownership of `vect1` to the
    `sum_vector` function, which iterates through each of the objects of the vector
    and produces the sum. Note that we passed `vect1` with a `&` symbol. This way,
    we shared the vector as a reference or pointer, but if we had passed it as `&mut
    vect1`, then the function would have had the ability to mutate or make changes
    in the values of the vector. We verify this by printing `vect1` after processing
    it from the `sum_vects` function, which still yields the same result.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sum_vects(&vect1)` 函数中，我们将 `vect1` 的所有权传递给了 `sum_vector` 函数，该函数遍历向量的每个对象并生成总和。注意，我们使用
    `&` 符号传递了 `vect1`。这样，我们以引用或指针的形式共享了向量，但如果我们将它作为 `&mut vect1` 传递，那么函数将能够修改或更改向量的值。我们通过在
    `sum_vects` 函数处理后打印 `vect1` 来验证这一点，它仍然产生相同的结果。
- en: In `sum_vects(&vect1)`, we had `v1`, which is the argument to which `vect1`
    is moved to. The vector has a method from the standard APIs that allows the `iter`
    function to read one data object from the zero position.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sum_vects(&vect1)` 中，我们有 `v1`，它是 `vect1` 移动到的参数。向量有一个来自标准 API 的方法，允许 `iter`
    函数从零位置读取一个数据对象。
- en: 'The `fold()` function takes two arguments: an initial value and a closure.
    The closure again takes two arguments: an accumulator and an element. The closure
    returns the value that the accumulator should have for the next iteration.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold()` 函数接受两个参数：一个初始值和一个闭包。闭包再次接受两个参数：累加器和元素。闭包返回累加器在下一个迭代中应该具有的值。'
- en: Here the accumulator is `sum` and the element is `x`, which is added to `sum`
    in every iteration. Note that `x` being mutable in the definition of the closure
    can change the values in the scope of its operation. This is stored in the `sum`
    variable and returned to the `main` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里累加器是 `sum`，元素是 `x`，它在每次迭代中添加到 `sum`。请注意，`x` 在闭包定义中是可变的，可以改变其操作范围内的值。这个值存储在
    `sum` 变量中，并返回到 `main` 函数。
- en: Defining your first user-defined data type
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义你的第一个用户定义数据类型
- en: In this recipe, you will learn about structs, which is a way in which you can
    create complex data types in Rust. Using `struct`, we will define user-defined
    data types in Rust.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解结构体，这是在 Rust 中创建复杂数据类型的一种方式。使用 `struct`，我们将定义 Rust 中的用户定义数据类型。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a file named `struct.rs` and enter the following code in the script:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `struct.rs` 的文件，并在脚本中输入以下代码：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a `struct` named `Circle` with two parameters, namely `x` and `radius`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Circle` 的结构体，具有两个参数，即 `x` 和 `radius`：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define a function `get_radius` by accepting `Circle` as a user-defined data
    type:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过接受用户定义的数据类型 `Circle` 来定义一个函数 `get_radius`：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该得到以下截图作为输出：
- en: '![](img/47f4eac1-b057-433f-b3c0-5a7b344aeded.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47f4eac1-b057-433f-b3c0-5a7b344aeded.png)'
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At some point of the product development life cycle, developers often have too
    many variables to handle and the code becomes really complex. This is where structs
    appear as a big savior. Structs enable developers to create complex data types,
    where they allow the unification of multiple data types under a single name.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品开发生命周期的某个阶段，开发者经常需要处理太多的变量，代码变得非常复杂。这就是结构体出现作为大救星的地方。结构体允许开发者创建复杂的数据类型，其中它们允许将多个数据类型统一在一个名称下。
- en: In this recipe, we created a custom data type named `Circle`, which has two
    labels `radius` and `x` of the type `f64`, which is a 64-bit `float` type. Both
    the parameters here are related to the `Circle` data type and uniquely express
    their features.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个名为 `Circle` 的自定义数据类型，它有两个标签 `radius` 和 `x`，类型为 `f64`，这是一个 64 位
    `float` 类型。这里的两个参数都与 `Circle` 数据类型相关，并独特地表达了它们的特征。
- en: Consider use cases such as database management, machine learning models, and
    so on, where the developer has to handle multiple variables conveying the property
    of a single task/entity. Structs, in these cases, are great tools to utilize for
    making the code more optimized and modular. This makes the life of a developer
    easy; we can debug errors easily and scale up features on requests of the application/product.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用案例，如数据库管理、机器学习模型等，在这些案例中，开发者必须处理多个变量，这些变量传达单个任务/实体的属性。在这些情况下，结构体是用于使代码更优化和模块化的优秀工具。这使得开发者的生活变得容易；我们可以轻松地调试错误，并根据应用程序/产品的请求扩展功能。
- en: We use the `struct` keyword to create a user-defined data type, where the custom
    name is provided after the keyword but along with the types of the different labels
    or variables it uses.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `struct` 关键字来创建用户定义的数据类型，其中自定义名称在关键字之后提供，但与它使用的不同标签或变量的类型一起。
- en: In the `main` function, we initialized a mutable variable `circle1` of the user-defined
    data type `Circle` and populated it with its required values, which are `10.0`
    for `radius` and `10.0` for `x`. We did this to access the variable in the scope
    of the program. We get the value by calling the variable name label we require,
    that is, we get the value of the assigned values by calling `circle1.x` and `circle.radius`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们初始化了一个用户定义的数据类型 `Circle` 的可变变量 `circle1`，并用其所需的值填充它，即 `radius`
    为 `10.0`，`x` 为 `10.0`。我们这样做是为了在程序的范围内访问变量。我们通过调用所需的变量名称标签来获取值，也就是说，我们通过调用 `circle1.x`
    和 `circle.radius` 来获取分配的值的值。
- en: We pass the reference of `circle1` to `get_radius`, where we have an argument
    `c1` of the data type `Circle` from which we get the radius of `c1.radius`. Then,
    we call the function with `get_radius(&circle1)` to get the value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `circle1` 的引用传递给 `get_radius`，其中我们有一个 `c1` 参数，其数据类型为 `Circle`，从中我们获取 `c1.radius`
    的半径。然后，我们通过调用 `get_radius(&circle1)` 来获取值。
- en: Adding functionality to the user-defined data type
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向用户定义的数据类型添加功能
- en: You will learn about performing method calls using the `impl` keyword in Rust,
    which helps in adding functionality to a user-defined data type. In this recipe,
    the `impl` block helps us create the methods.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解如何使用 Rust 中的 `impl` 关键字执行方法调用，这有助于向用户定义的数据类型添加功能。在这个配方中，`impl` 块帮助我们创建方法。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a file named `implement.rs` and enter the following code in the script:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `implement.rs` 的文件，并在脚本中输入以下代码：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a `struct` named `Circle` with two parameters, `x` and `radius`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Circle` 的 `struct`，包含两个参数，`x` 和 `radius`：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create the `get_x` method for the user-defined `Circle` data type:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户定义的 `Circle` 数据类型创建 `get_x` 方法：
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该得到以下截图作为输出：
- en: '![](img/fa90b058-9448-4244-b5a4-bf1aaf568991.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa90b058-9448-4244-b5a4-bf1aaf568991.png)'
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we created a custom data type named `Circle`, which has two
    labels: `radius` and `x` of the type `f64`, which is a 64-bit `float` type. Both
    the parameters here are related to the `Circle` data type and uniquely express
    its features.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了一个名为 `Circle` 的自定义数据类型，它有两个标签：`radius` 和 `x`，其类型为 `f64`，这是一个 64
    位 `float` 类型。这里的两个参数都与 `Circle` 数据类型相关，并独特地表达了其特征。
- en: In the `main` function, we initialized a mutable variable `circle1` of the user-defined
    data type `Circle` and populated it with its required values, which are `10.0`
    for `radius` and `10.0` for `x`. To access the variable in the scope of the program,
    we get the value by calling the variable name label we require, that is, we get
    the value of the assigned values by calling `circle1.x` and `circle.radius`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们初始化了一个用户定义的数据类型 `Circle` 的可变变量 `circle1`，并用其所需值填充它，这些值是 `radius`
    的 `10.0` 和 `x` 的 `10.0`。为了在程序的作用域内访问变量，我们通过调用所需的变量名称标签来获取值，即通过调用 `circle1.x` 和
    `circle.radius` 来获取分配的值。
- en: But, we went ahead and created unique functionalities for each data type so
    that they can perform a unique operation on the labels associated with them; this
    eliminates the need to pass argument values to externally created functions. We
    used `impl` to achieve this method call, where we defined functionalities for
    the data type.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们继续为每种数据类型创建了独特的功能，以便它们可以对与之关联的标签执行独特操作；这消除了传递参数值给外部创建的函数的需求。我们使用 `impl`
    实现了这种方法调用，其中我们为数据类型定义了功能。
- en: This feature allows the developer to call functions of the data type using `datatype_name.function1().function2()`,
    which reduces the function call complexity and delivers optimized code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能允许开发者使用 `datatype_name.function1().function2()` 调用数据类型的函数，这减少了函数调用复杂性，并提供了优化的代码。
- en: In the `main` function, we call `circle1.get_x()` to get the value of the `x`
    value. If you closely observe the `impl` code part of `Circle`, you'll notice
    we passed `&self` to the `get_x()` method, which is a reference to the circle
    label's data type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们调用 `circle1.get_x()` 来获取 `x` 值。如果你仔细观察 `Circle` 的 `impl` 代码部分，你会注意到我们传递了
    `&self` 给 `get_x()` 方法，这是一个指向圆标签数据类型的引用。
- en: Similar functionality for different data type
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同数据类型的类似功能
- en: You will learn about the `trait` feature of Rust in this recipe is similar to
    `impl`, which helps the developer make a method call of the user-defined data
    type. However, `trait` provides many more features, such as inheritance and control,
    over the functionality that the user-defined data type provides.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将了解 Rust 的 `trait` 功能，它与 `impl` 类似，有助于开发者对用户定义的数据类型进行方法调用。然而，`trait`
    提供了许多更多功能，如继承和控制，这些功能是用户定义的数据类型提供的。
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a file named `trait.rs` and enter the following code in the script:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `trait.rs` 的文件，并在脚本中输入以下代码：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a `struct` named `Rectangle` with the parameters `h` and `b`, both 64-bit
    `float` data types:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有参数`h`和`b`的`struct`，这两个参数都是64位`float`数据类型：
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a `struct` named `Circle` with the parameter `r`, which is a 64-bit
    `float` data type:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有参数`r`的`struct`，其中`r`是一个64位`float`数据类型：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a `trait` named `HasArea` with the `area` functionality:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HasArea`的`trait`，具有`area`功能：
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the `area` function for the `Circle` user-defined data type:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Circle`用户自定义数据类型定义`area`函数：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the `area` function for the `Rectangle` user-defined data type:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Rectangle`用户自定义数据类型定义`area`函数：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should get the following output upon running the preceding code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你应该得到以下输出：
- en: '![](img/721561fa-e66f-461c-8d4a-8583ec482b3e.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/721561fa-e66f-461c-8d4a-8583ec482b3e.png)'
- en: How it works...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we applied all the concepts that we learned in the previous
    ones. We created two `struct` types: `Circle` with a `radius` of f64 and `Rectangle`
    with the parameters `h` and `b` of f64\. Then, we created the `area` functionality
    for each `struct` data type that operates on the data of the labels, as they are
    referenced by `self`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们应用了之前学到的所有概念。我们创建了两个`struct`类型：具有`radius`的`Circle`，其类型为f64，以及具有参数`h`和`b`的`Rectangle`，这两个参数的类型都是f64。然后，我们为每个`struct`数据类型创建了`area`功能，这些功能操作标签的数据，因为它们是通过`self`引用的。
- en: The function definition of both user-defined data types is different in terms
    of the mathematical operation. We defined the data type `Circle` and `Rectangle`
    in the `main` function. We called the functions in real time by `Circle.area()`
    and `Rectangle.area()`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 用户自定义数据类型的函数定义在数学运算方面是不同的。我们在`main`函数中定义了数据类型`Circle`和`Rectangle`。我们通过`Circle.area()`和`Rectangle.area()`实时调用这些函数。
- en: Here, we observe that both data types provide a similar kind of functionality;
    this is where the `trait` comes into place. It basically tells the compiler the
    functionality that a particular function would use, so we implement the `trait`.
    For the data type in this recipe, we have a `trait` named `HasArea`, which contains
    only the signature of the function that is inside the scope, which contains the
    output that is returned and the reference which was passed as the argument. In
    this recipe, we had a signature of `fn area(&self) -> f64;`, which indicated the
    output of the computation in a 64-bit `float` type. The function operates by taking
    a reference to the label and values of the data type.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到这两种数据类型提供了类似的功能；这就是`trait`发挥作用的地方。它基本上告诉编译器特定函数将使用哪种功能，因此我们实现了`trait`。对于这个菜谱中的数据类型，我们有一个名为`HasArea`的`trait`，它只包含作用域内函数的签名，包含返回的输出和作为参数传递的引用。在这个菜谱中，我们有一个`fn
    area(&self) -> f64;`的签名，这表示计算结果的输出是一个64位的`float`类型。该函数通过获取数据类型的标签和值的引用来操作。
