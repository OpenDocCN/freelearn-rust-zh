- en: Creating a REST Web Service
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 REST 网络服务
- en: Historically, a lot of technologies have been developed and used to create a
    client-server system. In recent decades, though, all client-server architectures
    tend to be web-based—that is, based on the **HyperText Transfer Protocol** (**HTTP**).
    HTTP is based on the **Transfer Control Protocol** (**TCP**) and the **Internet
    Protocol** (**IP**). In particular, two web-based architectures have become popular—the **Simple
    Object Access Protocol** (**SOAP**) and **Representational State Transfer** (**REST**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，许多技术已被开发和用于创建客户端-服务器系统。然而，在最近几十年中，所有客户端-服务器架构都趋向于基于 Web——也就是说，基于 **超文本传输协议**
    (**HTTP**)。HTTP 基于 **传输控制协议** (**TCP**) 和 **互联网协议** (**IP**)。特别是，两种基于 Web 的架构已经变得流行——**简单对象访问协议**
    (**SOAP**) 和 **表征状态转移** (**REST**)。
- en: While SOAP is an actual protocol, REST is only a collection of *principles*.
    The web services adhering to the REST principles are said to be RESTful. In this
    chapter, we'll see how to build RESTful services using the popular Actix web framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SOAP 是一个实际协议，但 REST 只是一系列 *原则*。遵循 REST 原则的网络服务被称为 RESTful。在本章中，我们将看到如何使用流行的
    Actix 网络框架构建 RESTful 服务。
- en: Any web service (REST web services included) can be used by any web client—that
    is, any program that can send HTTP requests over a TCP/IP network. The most typical
    web clients are web pages running in a web browser, and containing JavaScript
    code. Any program written in any programming language and running in any operating
    system implementing the TCP/IP protocols can act as a web client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网络服务（包括 REST 网络服务）都可以被任何网络客户端使用——也就是说，任何可以发送 TCP/IP 网络上的 HTTP 请求的程序都可以作为网络客户端。最典型的网络客户端是在网络浏览器中运行的网页，并包含
    JavaScript 代码。任何用任何编程语言编写并在实现 TCP/IP 协议的任何操作系统上运行的程序都可以作为网络客户端。
- en: The web servers are also known as the **backend**, while the web client is known
    as the **frontend**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器也被称为 **后端**，而网络客户端被称为 **前端**。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The REST architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 架构
- en: Building a stub of a web service using the Actix web framework and implementing
    the REST principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Actix 网络框架构建网络服务的存根并实现 REST 原则
- en: Building a complete web service capable of uploading files, downloading files,
    and deleting files on client request
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个完整的网络服务，能够根据客户端请求上传文件、下载文件和删除文件
- en: Handling an inner state as a memory database or a pool of connections to a database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将内部状态作为内存数据库或数据库连接池来处理
- en: Using **JavaScript Object Notation** (**JSON**) format to send data to clients
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **JavaScript 对象表示法** (**JSON**) 格式向客户端发送数据
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To easily understand this chapter, you should have beginner knowledge of HTTP.
    The required concepts are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松理解本章内容，您应该具备 HTTP 的入门级知识。所需的概念如下：
- en: '**Uniform Resource Identifiers** (**URIs**)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一资源标识符** (**URIs**)'
- en: Methods (such as `GET`)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法（如 `GET`）
- en: Headers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标头
- en: Body
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体
- en: Content type (such as `plain/text`)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容类型（如 `plain/text`）
- en: Status code (such as `Not Found=404`)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态码（如 `Not Found=404`）
- en: Before starting the projects in this chapter, a generic HTTP client should be
    installed on your computer. The tool used in the examples is the command-line
    tool **curl**, freely available for many operating systems. The official download
    page is [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).
    In particular, the page for Microsoft Windows is [https://curl.haxx.se/windows/](https://curl.haxx.se/windows/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章的项目之前，应在您的计算机上安装一个通用的 HTTP 客户端。示例中使用的工具是命令行工具 **curl**，在许多操作系统上免费提供。官方下载页面是
    [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html)。特别是 Microsoft
    Windows 的页面是 [https://curl.haxx.se/windows/](https://curl.haxx.se/windows/)。
- en: Alternatively, you can use one of the several good, free web-browser utilities,
    such as Advanced REST Client for Chrome, or RESTED and RESTer for Firefox.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用几个免费的网络浏览器实用工具之一，例如 Chrome 的 Advanced REST Client 或 Firefox 的 RESTED
    和 RESTer。
- en: The complete source code for this chapter is in the `Chapter03` folder of the
    repository, located at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码位于存储库的 `Chapter03` 文件夹中，该文件夹位于 [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)。
- en: The REST architecture
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 架构
- en: The REST architecture is strongly based on the HTTP protocol but does not require
    any specific kind of data format, and so it can transmit data in several formats
    such as plain text, JSON, **Extensible Markup Language** (**XML**), or binary
    (encoded as Base64).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: REST架构在HTTP协议的基础上构建得非常牢固，但它不要求任何特定的数据格式，因此它可以以多种格式传输数据，如纯文本、JSON、**可扩展标记语言**（**XML**）或二进制（编码为Base64）。
- en: Many web resources describe what the REST architectural paradigm is. One such
    can be found at [https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络资源描述了REST架构范式是什么。其中一个可以在[https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)找到。
- en: However, the concept of the REST architecture is quite simple. It is the purest
    extension of the ideas behind the **World Wide Web** (**WWW**) project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，REST架构的概念非常简单。它是**万维网**（**WWW**）项目背后的思想的纯粹扩展。
- en: The WWW project was born in 1989 as a global library of **hypertexts**. A hypertext
    is a document that contains links to other documents so that, by clicking repeatedly
    on the links, you can see many documents by using only your mouse. Such documents
    are scattered over the internet and are identified by a unique description, the
    **Uniform Resource Locator** (**URL**). The protocol to share such documents is
    HTTP, and the documents are written in **HyperText Markup Language** (**HTML**).
    A document can embed images, referenced by URL addresses too.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**万维网**项目于1989年诞生，作为一个全球性的**超文本**图书馆。超文本是一种包含指向其他文档链接的文档，通过反复点击链接，你可以仅使用鼠标查看许多文档。这样的文档散布在互联网上，并由一个唯一的描述符，即**统一资源定位符**（**URL**）进行标识。共享此类文档的协议是HTTP，文档是用**超文本标记语言**（**HTML**）编写的。文档可以嵌入图像，这些图像也通过URL地址进行引用。'
- en: The HTTP protocol allows you to download pages to your document viewer (the
    web browser), but also to upload new documents to be shared with other people.
    You can also replace existing documents with a new version, or delete existing
    documents.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议允许你将页面下载到你的文档查看器（网页浏览器）中，也可以上传新文档与他人共享。你还可以用新版本替换现有文档，或删除现有文档。
- en: If the concept of a *document* or *file* is replaced by that of *named data*,
    or a *resource*, you get the concept of REST. Any interaction with a RESTful server
    is a manipulation of a piece of data, referencing it by its name. Of course, such
    data can be a disk file, but it can also be a set of records in a database that
    is identified by a query, or even a variable kept in memory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将**文档**或**文件**的概念替换为**命名数据**或**资源**的概念，你就得到了REST的概念。与RESTful服务器的任何交互都是对数据片段的操作，通过其名称进行引用。当然，这样的数据可以是磁盘文件，也可以是数据库中的一组记录，这些记录通过查询进行标识，甚至可以是内存中保留的变量。
- en: A peculiar aspect of RESTful servers is the absence of server-side client sessions.
    As with any hypertext server, RESTful servers do not store the fact that a client
    has logged in. If there is some data associated with a session, such as the current
    user or the previously visited pages, that data belongs only to the client side. As
    a consequence, any time the client needs access to privileged services, or to
    user-specific data, the request must contain the credentials of the user.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务器的一个独特之处在于服务器端没有客户端会话。与任何超文本服务器一样，RESTful服务器不会存储客户端已登录的事实。如果有与会话相关的数据，例如当前用户或之前访问的页面，这些数据仅属于客户端。因此，每当客户端需要访问受保护的服务或特定用户的数据时，请求必须包含用户的凭据。
- en: To improve performance, the server can store session information in a cache,
    but that should be transparent. The server (except for its performance) should
    behave as if it doesn't keep any session information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，服务器可以将会话信息存储在缓存中，但这应该是透明的。服务器（除了性能之外）应该表现得好像它没有保留任何会话信息。
- en: Project overview
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'We are going to build several projects, introducing new features in every project.
    Let''s look at each one, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建几个项目，每个项目都引入了新的功能。让我们依次看看每个项目：
- en: The first project will build a stub of a service that should allow any client
    to upload, download, or delete files from the server. This project shows how to
    create a REST **application programming interface** (**API**), but it does no
    useful work.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个项目将构建一个服务的雏形，该服务应允许任何客户端上传、下载或从服务器删除文件。这个项目展示了如何创建REST **应用程序编程接口**（**API**），但它并不执行任何有用的操作。
- en: The second project will implement the API described in the previous project.
    It will build a service that actually allows any client to upload, download, or
    delete files from the server filesystem.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个项目将实现前一个项目中描述的API。它将构建一个服务，实际上允许任何客户端从服务器文件系统中上传、下载或删除文件。
- en: The third project will build a service that allows clients to add key-value
    records to a memory database residing in the server process, and to recall some
    predefined queries built into the server. The result of such queries will be sent
    back to the client in plain text format.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个项目将构建一个服务，允许客户端向服务器进程中的内存数据库添加键值记录，并调用服务器中预定义的一些查询。这些查询的结果将以纯文本格式发送回客户端。
- en: The fourth project will be similar to the third one, but the results will be
    encoded in JSON format.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个项目将与第三个项目类似，但结果将以JSON格式编码。
- en: Our source code is small, but it includes the Actix web crate, which in turn
    includes around 200 crates, and so the first build of any project will take around
    10 minutes. Following any changes to the application code, a build will take from
    12 to 30 seconds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的源代码很小，但它包括了Actix web crate，而Actix web crate又包括了大约200个crate，因此任何项目的第一次构建将需要大约10分钟。在应用代码的任何更改之后，构建将需要12到30秒。
- en: The Actix web crate has been chosen as it is the most feature-full, reliable,
    high-performance, and well-documented server-side web application framework for
    Rust.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Actix web crate是因为它是功能最全面、最可靠、高性能且文档良好的Rust后端Web应用程序框架。
- en: This framework is not limited to RESTful services, as it can be used to build
    different kinds of server-side web software. It is an extension of the Actix net
    framework, which is a framework designed to implement different kinds of network
    services.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架不仅限于RESTful服务，因为它可以用来构建不同类型的后端Web软件。它是Actix net框架的扩展，这是一个旨在实现不同类型网络服务的框架。
- en: Essential background theory and context
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的背景理论和上下文
- en: Previously, we said that a RESTful service is based on the HTTP protocol. This
    is a rather complex protocol, but its most important parts are quite simple. Here
    is a simplified version of it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，RESTful服务基于HTTP协议。这是一个相当复杂的协议，但它的最重要的部分相当简单。下面是它的简化版本。
- en: The protocol is based on a pair of messages. First, the client sends a request
    to the server, and after the server receives this request, it replies by sending
    a response to the client. Both messages are in **American Standard Code for Information
    Interchange** (**ASCII**) text, and so they are easily manipulated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 协议基于一对消息。首先，客户端向服务器发送请求，服务器在接收到这个请求后，通过向客户端发送响应来回复。这两个消息都是**美国信息交换标准代码**（**ASCII**）文本，因此它们很容易被操作。
- en: The HTTP protocol is usually based on the TCP/IP protocol, which guarantees
    that these messages arrive at the addressed process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议通常基于TCP/IP协议，这保证了这些消息到达指定的进程。
- en: 'Let''s see a typical HTTP request message, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个典型的HTTP请求消息，如下所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This message contains six lines because there is an empty line at the end.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息包含六行，因为结尾有一个空行。
- en: The first line begins with the word `GET`. This word is the *method* that specifies
    which operation is requested. Then, there is a Unix-style *path* of a resource,
    and then the version of the protocol (here, it is `1.1`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以单词`GET`开头。这个单词是*方法*，它指定了请求的操作。然后是一个Unix风格的*路径*，然后是协议的版本（这里，它是`1.1`）。
- en: Then, there are four lines containing rather simple attributes. These attributes
    are name **headers**. There are many possible optional headers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是四行相对简单的属性。这些属性是*头信息*。有许多可能的可选头信息。
- en: What follows the first empty line is the *body*. Here, the body is empty. The
    body is used to send raw data—even a lot of data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行空行之后的文本是*主体*。在这里，主体是空的。主体用于发送原始数据——甚至大量数据。
- en: So, any request from the HTTP protocol sends a command name (the method) to
    a specific server, followed by an identifier of a resource (the path). Then, there
    are a few attributes (one per line), then an empty line, and, finally, the possible
    raw data (the body).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何HTTP协议的请求都会向特定的服务器发送一个命令名（方法），然后是一个资源标识符（路径）。然后是一系列属性（每行一个），然后是一个空行，最后是可能的原始数据（主体）。
- en: 'The most important methods are detailed as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的方法如下详细说明：
- en: '`GET`: This requests a resource to be downloaded from the server (typically
    an HTML file or an image file, but also any data). The path specifies where the
    resource should be read.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：这请求从服务器下载资源（通常是 HTML 文件或图像文件，但也可能是任何数据）。路径指定了资源应读取的位置。'
- en: '`POST`: This sends some data to the server that the server should consider
    as new. The path specifies where to add this data. If the path identifies any
    existing data, the server should return an error code. The contents of the data
    to post are in the body section.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：这向服务器发送一些数据，服务器应将其视为新的。路径指定了添加这些数据的位置。如果路径标识了任何现有数据，服务器应返回错误代码。要发布的数据的内含在正文部分。'
- en: '`PUT`: This is similar to the `POST` command, but it is meant to replace existing
    data.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：这与 `POST` 命令类似，但它的目的是替换现有数据。'
- en: '`DELETE`: This requests the resource to be removed specified by the path. It
    has an empty body.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：这请求根据路径指定的资源被移除。它有一个空体。'
- en: 'Here is a typical HTTP response message:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的 HTTP 响应消息：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line of any response message begins with the protocol version, followed
    by the status code both in text format and in numeric format. Success is represented
    by `200 OK`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 任何响应消息的第一行以协议版本开始，后跟文本格式和数字格式的状态码。成功表示为 `200 OK`。
- en: Then, there are several headers—six, in this example—then an empty line, and
    then the body, which may be empty. In this case, the body contains some HTML code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有几个标题——在这个例子中有六个——然后是一个空行，然后是正文，正文可能为空。在这种情况下，正文包含一些 HTML 代码。
- en: You can find more information regarding the HTTP protocol at: [https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到有关 HTTP 协议的更多信息：[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)。
- en: Building a stub of a REST web service
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 REST 服务的存根
- en: The typical example of a REST service is a web service designed for uploading
    and downloading text files. As it would be too complex to understand, first we
    will look at a simpler project, the `file_transfer_stub` project, which mimics
    this service without actually doing anything on the filesystem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: REST 服务的典型示例是为上传和下载文本文件而设计的网络服务。由于这可能会过于复杂而难以理解，我们首先将查看一个更简单的项目，即 `file_transfer_stub`
    项目，该项目模拟此服务而不在文件系统中实际执行任何操作。
- en: You will see how an API of a RESTless web service is structured, without being
    overwhelmed by the details regarding the implementation of the commands.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到无状态 RESTful 网络服务的 API 结构，而不会被有关命令实现的细节所淹没。
- en: In the next section, this example will be completed with the needed implementation,
    to obtain a working file-managing web app.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，此示例将通过所需实现来完成，以获得一个工作的文件管理网络应用。
- en: Running and testing the service
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和测试服务
- en: To run this service, it is enough to type the command `cargo run` in a console.
    After building the program, it will print `Listening at address 127.0.0.1:8080
    ...`, and it will remain listening for incoming requests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此服务，只需在控制台中键入命令 `cargo run` 即可。构建程序后，它将打印 `Listening at address 127.0.0.1:8080
    ...`，并且它将保持监听传入的请求。
- en: To test it, we need a web client. You can use a browser extension if you prefer,
    but in this chapter, the curl command-line utility will be used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，我们需要一个网络客户端。如果您更喜欢，可以使用浏览器扩展，但在此章节中，我们将使用 curl 命令行工具。
- en: 'The `file_transfer_stub` service and the `file_transfer` service (we''ll see
    them in the next section) have the same API, containing the following four commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_transfer_stub` 服务和 `file_transfer` 服务（我们将在下一节中看到）具有相同的 API，包含以下四个命令：'
- en: Download a file with a specified name.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载具有指定名称的文件。
- en: Upload a file with a specified name and specified contents.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传具有指定名称和指定内容的文件。
- en: Upload a file with a specified name prefix and specified contents, obtaining
    the complete name as a response.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传具有指定名称前缀和指定内容的文件，作为响应获得完整名称。
- en: Delete a file with a specified name.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除指定名称的文件。
- en: Getting a resource using the GET method
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GET 方法获取资源
- en: 'To download a resource in the REST architecture, the `GET` method should be
    used. For these commands, the URL should specify the name of the file to download.
    No additional data should be passed, and the response should contain the contents
    of the file and the status code, which can be `200`, `404`, or `500`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 架构中下载资源时，应使用 `GET` 方法。对于这些命令，URL 应指定要下载的文件名。不应传递任何附加数据，响应应包含文件内容和状态码，可以是
    `200`、`404` 或 `500`：
- en: 'Type the following command into a console:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中输入以下命令：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In that console, the following mock line should be printed, and then the prompt
    should appear immediately:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个控制台中，应该打印以下模拟行，然后立即出现提示符：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Meanwhile, on the other console, the following line should be printed:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，在另一个控制台中，应该打印以下行：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command mimics the request to download the `datafile.txt` file from the
    filesystem of the server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令模拟从服务器文件系统中下载 `datafile.txt` 文件的请求。
- en: 'The `GET` method is the default one for curl, and hence you can simply type
    the following:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET` 方法是 curl 的默认方法，因此你可以简单地输入以下命令：'
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In addition, you can redirect the output to any file by typing the following:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，你可以通过输入以下命令将输出重定向到任何文件：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, we have now seen how our web service can be used by curl to download a remote
    file, to print it on the console, or to save it in a local file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经看到我们的网络服务如何通过 curl 下载远程文件，将其打印到控制台，或者将其保存到本地文件。
- en: Sending a named resource to the server using the PUT method
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PUT 方法将命名资源发送到服务器
- en: 'To upload a resource in the REST architecture, either the `PUT` or `POST` methods
    should be used. The `PUT` method is used when the client knows *where* the resource
    should be stored, in essence, what will be its *identifying key*. If there is
    already a resource that has this key, that resource will be replaced by the newly
    uploaded resource:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 架构中上传资源时，应使用 `PUT` 或 `POST` 方法。`PUT` 方法用于客户端知道资源应存储的位置时，本质上，它将是其 *标识键*。如果已存在具有该键的资源，则该资源将被新上传的资源替换：
- en: 'Type the following command into a console:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中输入以下命令：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In that console, the prompt should appear immediately. Meanwhile, on the other
    console, the following line should be printed:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个控制台中，提示符应立即出现。同时，在另一个控制台中，应该打印以下行：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command mimics the request to send a file to the server, with the client
    specifying the name of that resource, so that if a resource with that name already
    exists, it is overwritten.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令模拟向服务器发送文件的请求，客户端指定该资源的名称，因此如果已存在同名资源，则该资源将被覆盖。
- en: 'You can use *curl* to send the data contained in a specified local file in
    the following way:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 *curl* 以以下方式发送指定本地文件中的数据：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the `curl` command has an additional argument, `-d`, which allows us to
    specify the data we want to send to the server. If it is followed by an `@` symbol,
    the text following this symbol is used as the path of the uploaded file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`curl` 命令有一个额外的参数 `-d`，它允许我们指定要发送到服务器的数据。如果它后面跟着一个 `@` 符号，则该符号后面的文本用作上传文件的路径。
- en: For these commands, the URI should specify the name of the file to upload and
    also the contents of the file, and the response should contain only the status
    code, which can be `200`, `201` (Created), or `500`. The difference between `200`
    and `201` is that in the first case, an existing file is overwritten, and in the
    second case, a new file is created.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些命令，URI 应指定要上传的文件名称和文件内容，并且响应应只包含状态码，可以是 `200`、`201`（已创建）或 `500`。`200` 和
    `201` 之间的区别在于，在第一种情况下，现有文件被覆盖，在第二种情况下，创建了一个新文件。
- en: So, we have now learned how our web service can be used by curl to upload a
    string into a remote file, while also specifying the name of the file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经学会了如何使用 curl 通过我们的网络服务上传字符串到远程文件，同时指定文件名。
- en: Sending a new resource to the server using the POST method
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 POST 方法将新资源发送到服务器
- en: 'In the REST architecture, the `POST` method is the one to use when it is the
    responsibility of the service to generate an identifier key for the new resource.
    Thus, the request does not have to specify it. The client can specify a pattern
    or prefix for the identifier, though. As the key is automatically generated and
    unique, there cannot be another resource that has the same key. The generated
    key should be returned to the client, though, because otherwise, it cannot reference
    that resource afterward:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 架构中，`POST` 方法是在服务负责为新资源生成标识键时使用的方法。因此，请求不需要指定它。客户端可以指定标识符的模式或前缀。由于键是自动生成的且唯一，因此不可能有另一个具有相同键的资源。但是，应该将生成的键返回给客户端，否则，之后无法引用该资源：
- en: 'To upload a file with an unknown name, type the following command into the console:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要上传一个未知名称的文件，请在控制台中输入以下命令：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In that console, the text `data17.txt` should be printed, and then the prompt
    should appear. This text is the simulated name of the file, received from the
    server. Meanwhile, on the other console, the following line should be printed:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个控制台中，应打印文本 `data17.txt`，然后出现提示符。这是从服务器接收到的模拟文件名。同时，在另一个控制台中，应打印以下行：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command represents the request to send a file to the server, with the server
    specifying a new unique name for that resource so that no other resource will
    be overwritten.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令表示向服务器发送文件请求，服务器为该资源指定一个新唯一名称，以确保不会覆盖其他资源。
- en: For this command, the URI should not specify the full name of the file to upload,
    but only a prefix; of course, the request should also contain the contents of
    the file. The response should contain the complete name of the newly created file
    and the status code. In this case, the status code can only be `201` or `500`,
    because the possibility of a file already existing is ruled out.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此命令，URI 不应指定要上传文件的完整名称，而只需指定前缀；当然，请求也应包含文件内容。响应应包含新创建文件的完整名称和状态码。在这种情况下，状态码只能是
    `201` 或 `500`，因为已排除文件已存在的可能性。
- en: We have now learned how our web service can be used by curl to upload a string
    into a new remote file, leaving the task of inventing a new name for that file
    to the server. We have also seen that the generated filename is sent back as a
    response.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用 curl 将字符串上传到新的远程文件，并将为该文件命名的工作留给服务器。我们还看到生成的文件名作为响应被发送回来。
- en: Deleting a resource using the DELETE method
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 DELETE 方法删除资源
- en: 'In the REST architecture, to delete a resource, the `DELETE` method should
    be used:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 架构中，要删除资源，应使用 `DELETE` 方法：
- en: 'Type the following command into a console (don''t worry—no file will be deleted!):'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命令输入到控制台（不用担心——不会删除任何文件！）：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After typing that command, the prompt should appear immediately. Meanwhile,
    in the server console, the following line should be printed:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入该命令后，提示符应立即出现。同时，在服务器控制台中，应打印以下行：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command represents the request to delete a file from the filesystem of
    the server. For such a command, the URL should specify the name of the file to
    delete. No additional data needs to be passed, and the only response is the status
    code, which can be `200`, `404`, or `500`. So, we have seen how our web service
    can be used by *curl* to delete a remote file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令表示从服务器文件系统中删除文件请求。对于此类命令，URL 应指定要删除的文件名称。不需要传递其他数据，唯一的响应是状态码，可以是 `200`、`404`
    或 `500`。因此，我们已经看到我们的网络服务如何使用 *curl* 删除远程文件。
- en: 'As a summary, the possible status codes of this service are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为总结，本服务的可能状态码如下：
- en: '`200`: OK'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`: OK'
- en: '`201`: Created'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201`: 已创建'
- en: '`404`: Not Found'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`: 未找到'
- en: '`500`: Internal Server Error'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`: 内部服务器错误'
- en: 'Also, the four commands of our API are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的 API 的四个命令如下：
- en: '| **Method** | **URI** | **Request data format** | **Response data format**
    | **Status codes** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **URI** | **请求数据格式** | **响应数据格式** | **状态码** |'
- en: '| `GET` | `/{filename}` | --- | text/plain | `200`, `404`, `500` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/{filename}` | --- | text/plain | `200`, `404`, `500` |'
- en: '| `PUT` | `/{filename}` | text/plain | --- | `200`, `201`, `500` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/{filename}` | text/plain | --- | `200`, `201`, `500` |'
- en: '| `POST` | `/{filename` prefix} | text/plain | text/plain | `201`, `500` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/{filename prefix}` | text/plain | text/plain | `201`, `500` |'
- en: '| `DELETE` | `/{filename}` | --- | --- | `200`, `404`, `500` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/{filename}` | --- | --- | `200`, `404`, `500` |'
- en: Sending an invalid command
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送无效命令
- en: 'Let''s see the behavior of the server when an invalid command is received:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看服务器接收到无效命令时的行为：
- en: 'Type the following command into a console:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命令输入到控制台：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In that console, the prompt should appear immediately. Meanwhile, in the other
    console, the following line should be printed:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个控制台中，提示符应立即出现。同时，在另一个控制台中，应打印以下行：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command represents the request to get the `/a/b` resource from the server,
    but, as our API does not permit this method of specifying a resource, the service
    rejects the request.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令表示从服务器获取 `/a/b` 资源请求，但，由于我们的 API 不允许这种指定资源的方法，服务拒绝该请求。
- en: Examining the code
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查代码
- en: 'The `main` function contains the following statements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数包含以下语句：'
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line creates an instance of an HTTP server. Here, the body of the
    closure is omitted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个 HTTP 服务器的实例。在这里，闭包的主体被省略了。
- en: The second line binds the server to an IP endpoint, which is a pair composed
    of an IP address and an IP port, and returns an error if such a binding fails.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将服务器绑定到一个IP端点，这是一个由IP地址和IP端口组成的对，如果绑定失败则返回错误。
- en: The third line puts the current thread in listening mode on that endpoint. It
    blocks the thread, waiting for incoming TCP connection requests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行将当前线程置于该端点的监听模式。它阻塞线程，等待传入的TCP连接请求。
- en: 'The argument of the `HttpServer::new` call is a closure, shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpServer::new`调用的参数是一个闭包，如下所示：'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this closure, a new web app is created, and then one call to the `service` function
    is applied to it. Such a function contains a call to the `resource` function,
    which returns an object on which four calls to the `route` function are applied.
    Lastly, a call to the `default_service` function is applied to the application
    object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个闭包中，创建了一个新的Web应用，然后对其应用了一个对`service`函数的调用。这样一个函数包含了对`resource`函数的调用，该函数返回一个对象，对其应用了四个对`route`函数的调用。最后，对应用对象应用了`default_service`函数的调用。
- en: This complex statement implements a mechanism to decide which function to call
    based on the path and method of the HTTP request. In web programming parlance,
    such a kind of mechanism is named **routing**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复杂的语句实现了一个基于HTTP请求的路径和方法来决定调用哪个函数的机制。在Web编程术语中，这种机制被称为**路由**。
- en: The request routing first performs pattern matching between the address URI
    and one or several patterns. In this case, there is only one pattern, `/{filename}`,
    which describes a URI that has an initial slash and then a word. The word is associated
    with the `filename` name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请求路由首先在地址URI和一或多个模式之间执行模式匹配。在这种情况下，只有一个模式，`/{filename}`，它描述了一个具有初始斜杠然后是一个单词的URI。这个单词与`filename`名称相关联。
- en: The four calls to the `route` method proceed with the routing, based on the
    HTTP method (`DELETE`, `GET`, `PUT`, `POST`). There is a specific function for
    every possible HTTP method, followed by a call to the `to` function that has a
    handling function as an argument.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对`route`方法的四个调用基于HTTP方法（`DELETE`、`GET`、`PUT`、`POST`）进行路由。对于每个可能的HTTP方法都有一个特定的函数，然后调用一个`to`函数，该函数的参数是一个处理函数。
- en: 'Such calls to `route` mean that the following applies:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的`route`调用意味着以下内容：
- en: If the request method of the current HTTP command is `DELETE`, then such a request
    should be handled by going to the `delete_file` function.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前HTTP命令的请求方法是`DELETE`，则应该通过转到`delete_file`函数来处理这样的请求。
- en: If the request method of the current HTTP command is `GET`, then such a request
    should be handled by going to the `download_file` function.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前HTTP命令的请求方法是`GET`，则应该通过转到`download_file`函数来处理这样的请求。
- en: If the request method of the current HTTP command is `PUT`, then such a request
    should be handled by going to the `upload_specified_file` function.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前HTTP命令的请求方法是`PUT`，则应该通过转到`upload_specified_file`函数来处理这样的请求。
- en: If the request method of the current HTTP command is `POST`, then such a request
    should be handled by going to the `upload_new_file` function.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前HTTP命令的请求方法是`POST`，则应该通过转到`upload_new_file`函数来处理这样的请求。
- en: Such four handling functions, named **handlers**, must of course be implemented in
    the current scope. In actuality, they are defined, albeit interleaved with `TODO` comments,
    recalling what is missing to have a working application instead of a stub. Nevertheless,
    such handlers contain much functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个名为**处理程序**的处理函数当然必须在当前作用域中实现。实际上，它们被定义了，尽管与`TODO`注释交织在一起，回忆起要有一个工作应用程序而不是存根所缺少的内容。尽管如此，这些处理程序包含了很多功能。
- en: 'Such a routing mechanism can be read in English, in this way—for example, for
    a `DELETE` command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的路由机制可以用英语阅读，例如，对于一个`DELETE`命令：
- en: Create a `service` to manage the `web::resource` named `/{filename}`, to `route`
    a `delete` command to the `delete_file` handler.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`service`来管理名为`/{filename}`的`web::resource`，将`delete`命令路由到`delete_file`处理程序。
- en: After all of the patterns, there is the call to the `default_service` function that
    represents a catch-all pattern, typically to handle invalid URIs, such as `/a/b` in
    the previous example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有模式之后，是对`default_service`函数的调用，它代表一个捕获所有模式，通常用于处理无效URI，如前例中的`/a/b`。
- en: 'The argument of the catch-all statement—that is, `web::route().to(invalid_resource)`,
    causes the routing to the `invalid_resource` function. You can read it as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获所有语句的参数——即`web::route().to(invalid_resource)`——导致路由到`invalid_resource`函数。你可以这样读：
- en: For this `web` command, `route` it to the `invalid_resource` function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个 `web` 命令，将其路由到 `invalid_resource` 函数。
- en: 'Now, let''s see the handlers, starting with the simplest one, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看处理器，从最简单的一个开始，如下所示：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function receives an `HttpRequest` object and returns something implementing
    the `Responder` trait. It means that it processes an HTTP request, and returns
    something that can be converted to an HTTP response.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接收一个 `HttpRequest` 对象并返回实现了 `Responder` 特性的某个对象。这意味着它处理一个 HTTP 请求，并返回可以转换为
    HTTP 响应的对象。
- en: This function is quite simple because it does so little. It prints the URI to
    the console and returns a *Not Found* HTTP status code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数相当简单，因为它所做的工作很少。它将 URI 打印到控制台，并返回一个 *未找到* HTTP 状态码。
- en: 'The other four handlers get a different argument, though. It is the following: `info:
    Path<(String,)>`. Such an argument contains a description of the path matched
    before, with the `filename` argument put into a single-value tuple, inside a `Path`
    object. This is because such handlers do not need the whole HTTP request, but
    they need the parsed argument of the path.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '其他四个处理器接收不同的参数。它是这样的：`info: Path<(String,)>`。这样的参数包含之前匹配的路径的描述，其中 `filename`
    参数被放入一个单值元组中，该元组位于 `Path` 对象内部。这是因为这样的处理器不需要整个 HTTP 请求，但它们需要解析的路径参数。'
- en: Notice that we have one handler receiving an argument of the `HttpRequest` type,
    and the others receiving an argument of the `Path<(String,)>` type. This syntax
    is possible because the `to` function, called in the `main` function, expects
    as an argument a generic function, whose arguments can be of several different
    types.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有一个处理器接收 `HttpRequest` 类型的参数，而其他处理器接收 `Path<(String,)>` 类型的参数。这种语法是可能的，因为
    `main` 函数中调用的 `to` 函数期望一个泛型函数作为参数，其参数可以是几种不同类型。
- en: 'All four handlers begin with the following statement:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个处理器都以以下语句开始：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Such a statement extracts a reference to the first (and only) field of the tuple
    containing the parameters resulting from the pattern matching of the path. This
    works as long as the path contained exactly one parameter. The `/a/b` path cannot
    be matched with the pattern, because it has two parameters. Also, the `/` path
    cannot be matched, because it has no parameters. Such cases end in the *catch-all*
    pattern.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的语句从与路径模式匹配产生的参数元组的第一个（也是唯一一个）字段中提取一个引用。只要路径恰好包含一个参数，这个操作就会成功。`/a/b` 路径无法与模式匹配，因为它有两个参数。同样，`/`
    路径也无法匹配，因为它没有参数。这些情况最终会落在 *通配符* 模式上。
- en: 'Now, let''s examine the `delete_file` function specifically. It continues with
    the following lines:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专门检查 `delete_file` 函数。它继续以下几行：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It has two informational printing statements, and it ends returning a success
    value. In the middle, the actual statement to delete the file is still missing. The
    call to the `flush_stdout` function is needed to emit the text on the console
    immediately.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个信息打印语句，并以返回成功值结束。在中间，实际删除文件的语句仍然缺失。调用 `flush_stdout` 函数是为了立即在控制台上输出文本。
- en: 'The `download_file` function is similar, but, as it has to send back the contents
    of the file, it has a more complex response, as illustrated in the following code
    snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_file` 函数与此类似，但它需要返回文件内容，因此响应更为复杂，如下面的代码片段所示：'
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The object returned by the call to `Ok()` is decorated, first by calling `content_type` and
    setting `text/plain` as the type of the returned body, and then by calling `body` and
    setting the contents of the file as the body of the response.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ok()` 调用返回的对象首先通过调用 `content_type` 并将返回体的类型设置为 `text/plain` 来装饰，然后通过调用 `body`
    并将文件内容设置为响应体。'
- en: 'The `upload_specified_file` function is quite simple, as its two main jobs
    are missing: getting the text to put in the file from the body of the request,
    and saving that text into the file, as illustrated in the following code block:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload_specified_file` 函数相当简单，因为它的两个主要任务尚未完成：从请求体中获取要放入文件中的文本，并将该文本保存到文件中，如下面的代码块所示：'
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `upload_new_file` function is similar, but it should have another step
    that is still missing: to generate a unique filename for the file to save, as
    illustrated in the following code block:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload_new_file` 函数与此类似，但它还应有一个尚未实现的步骤：为要保存的文件生成一个唯一的文件名，如下面的代码块所示：'
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, we have examined all of the Rust code of the stub of the web service. In
    the next section, we'll look at the complete implementation of this service.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经检查了网络服务存根的所有 Rust 代码。在下文中，我们将查看此服务的完整实现。
- en: Building a complete web service
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个完整的网络服务
- en: The `file_transfer` project completes the `file_transfer_stub` project, by filling
    in the missing features.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_transfer`项目通过填充缺失的功能来完成`file_transfer_stub`项目。'
- en: 'The features were omitted in the previous project for the following reasons:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目中省略了功能，原因如下：
- en: To have a very simple service that actually does not really access the filesystem
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要有一个非常简单的服务，实际上并不真正访问文件系统
- en: To have only synchronous processing
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要有同步处理
- en: To ignore any kind of failure, and keep the code simple
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略任何类型的失败，并保持代码简单
- en: Here, these restrictions have been removed. First of all, let's see what happens
    if you compile and run the `file_transfer` project, and then test it using the
    same commands as in the previous section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这些限制已经被移除。首先，让我们看看如果你编译并运行`file_transfer`项目会发生什么，然后使用与上一节相同的命令进行测试。
- en: Downloading a file
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载文件
- en: 'Let''s try the following steps on how to download a file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下步骤来下载文件：
- en: 'Type the following command into the console:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中输入以下命令：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the download is successful, the server prints the following line to the
    console:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果下载成功，服务器将在控制台打印以下行：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the console of the client, curl prints the contents of that file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端的控制台中，curl打印出该文件的正文。
- en: 'In the case of an error, the service prints the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，服务将打印以下内容：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have now seen how our web service can be used by curl to download a file.
    In the next sections, we'll learn how our web service can perform other operations
    on remote files.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到我们的网络服务如何通过curl下载文件。在下一节中，我们将学习我们的网络服务如何对远程文件执行其他操作。
- en: Uploading a string to a specified file
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字符串上传到指定的文件
- en: 'Here is the command to upload a string into a remote file with a specified
    name:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将字符串上传到具有指定名称的远程文件的命令：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the upload is successful, the server prints the following to the console:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上传成功，服务器将在控制台打印以下内容：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the file already existed, it is overwritten. If it didn't exist, it is created.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已经存在，它将被覆盖。如果它不存在，它将被创建。
- en: 'In the case of an error, the web service prints the following line:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，网络服务将打印以下行：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, it prints the following line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它将打印以下行：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is how our web service can be used by curl to upload a string into a remote
    file while specifying the name of the file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的网络服务如何通过curl上传一个字符串到远程文件，同时指定文件名。
- en: Uploading a string to a new file
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字符串上传到新文件
- en: 'Here is the command to upload a string into a remote file with a name chosen
    by the server:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将字符串上传到由服务器选择的名称的远程文件的命令：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the upload is successful, the server prints to the console something similar
    to the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上传成功，服务器将在控制台打印类似于以下的内容：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This output shows that the name of the file contains a pseudo-random number—
    for this example, this is `917`, but you'll probably see some other number.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示文件名包含一个伪随机数——在这个例子中，这是`917`，但你可能会看到其他一些数字。
- en: In the console of the client, curl prints the name of that new file, as the
    server has sent it back to the client.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端的控制台中，curl打印出该新文件的名称，因为服务器已经将其发送回客户端。
- en: 'In the case of an error, the server prints the following line:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，服务器将打印以下行：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, it prints the following line:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它将打印以下行：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is how our web service can be used by curl to upload a string into a new
    remote file, leaving the task of inventing a new name for that file to the server.
    The curl tool receives this new name as a response.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的网络服务如何通过curl上传一个字符串到新的远程文件，将创建新文件名的任务留给服务器。curl工具将这个新名字作为响应接收。
- en: Deleting a file
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除文件
- en: 'Here is the command to delete a remote file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是删除远程文件的命令：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the deletion is successful, the server prints the following line to the
    console:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果删除成功，服务器将在控制台打印以下行：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Otherwise, it prints this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它将打印这个：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is how our web service can be used by curl to delete a remote file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的网络服务如何通过curl删除远程文件。
- en: Examining the code
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查代码
- en: 'Let''s now examine the differences between this program and the one described
    in the previous section. The `Cargo.toml` file contains two new dependencies,
    as illustrated in the following code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来检查这个程序和上一节中描述的程序之间的差异。`Cargo.toml`文件包含两个新的依赖项，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `futures` crate is needed for asynchronous operations, and the `rand` crate
    is needed for randomly generating the unique names of the uploaded files.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`futures`crate用于异步操作，而`rand`crate用于随机生成上传文件的唯一名称。'
- en: 'Many new data types have been imported from the external crates, as can be
    seen in the following code block:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新的数据类型已从外部crate导入，如下面的代码块所示：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The main function has just two changes, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数只有两个更改，如下所示：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, two calls to the `to` function have been replaced by calls to the `to_async`
    function. While the `to` function is *synchronous* (that is, it keeps the current
    thread busy until that function is completed), the `to_async` function is *asynchronous* (that
    is, it can be postponed until the expected events have happened).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个对`to`函数的调用已被替换为对`to_async`函数的调用。虽然`to`函数是**同步的**（即，它保持当前线程忙碌，直到该函数完成），但`to_async`函数是**异步的**（即，它可以推迟到预期事件发生）。
- en: This change was required by the nature of upload requests. Such requests can
    send large files (several megabytes), and the TCP/IP protocol sends such files
    split into small packets. If the server, when it receives the first packet, just
    waits for the arrival of all the packets, it can waste a lot of time. Even with
    multithreading, if many users upload files concurrently, the system will dedicate
    as many threads as possible to handle such uploads, and this is rather inefficient.
    A more performant solution is asynchronous processing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改是由上传请求的本质所要求的。此类请求可以发送大文件（几个兆字节），而TCP/IP协议将此类文件分割成小数据包。如果服务器在接收到第一个数据包后只是等待所有数据包的到来，它可能会浪费很多时间。即使有多个线程，如果许多用户同时上传文件，系统也会尽可能多地分配线程来处理此类上传，这相当低效。一个更高效的解决方案是异步处理。
- en: The `to_async` function, though, cannot receive as an argument a synchronous
    handler. It must receive a function that returns a value having the `impl Future<Item
    = HttpResponse, Error = Error>` type, instead of the `impl Responder` type, returned
    by synchronous handlers. This is actually the type returned by the two upload
    handlers: `upload_specified_file` and `upload_new_file`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`to_async`函数不能接收一个同步处理程序作为参数。它必须接收一个返回具有`impl Future<Item = HttpResponse,
    Error = Error>`类型的值的函数，而不是由同步处理程序返回的`impl Responder`类型。实际上，这是两个上传处理程序`upload_specified_file`和`upload_new_file`返回的类型。
- en: The object returned is of an abstract type, but it must implement the `Future` trait. The
    concept of a *future*, used also in C++ since 2011, is similar to JavaScript *promises*.
    It represents a value that will be available in the future, and in the meantime,
    the current thread can handle some other events.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象是抽象类型，但必须实现`Future`trait。自2011年以来，C++中也使用了*future*的概念，类似于JavaScript的*promises*。它表示将来可用的值，同时，当前线程可以处理其他事件。
- en: Futures are implemented as asynchronous closures, meaning that these closures
    are put in a queue in an internal futures list, and not run immediately. When no
    other task is running in the current thread, the future at the top of the queue
    is removed from the queue and executed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Futures被实现为异步闭包，这意味着这些闭包被放入内部futures列表的队列中，而不是立即运行。当当前线程没有其他任务运行时，队列顶部的future被从队列中移除并执行。
- en: If two futures are chained, the failure of the first chain causes the second
    future to be destroyed. Otherwise, if the first future of the chain succeeds,
    the second future has the opportunity to run.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个future被链式调用，第一个链的失败会导致第二个future被销毁。否则，如果链的第一个future成功，第二个future有机会运行。
- en: Going back to the two upload functions, another change for their signature is
    the fact that they now get two arguments. In addition to the argument of the `Path<(String,)>`
    type, containing the filename, there is an argument of the `Payload` type. Remember
    that the contents can arrive piece-wise, and so such a `Payload` argument does
    not contain the text of the file, but it is an object to get the contents of the
    uploaded file asynchronously.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 回到两个上传函数，它们签名的一个更改是它们现在接收两个参数。除了包含文件名的`Path<(String,)>`类型的参数外，还有一个`Payload`类型的参数。记住，内容可以分块到达，因此这样的`Payload`参数不包含文件的文本，但它是一个对象，用于异步获取上传文件的正文。
- en: Its use is somewhat complex.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 其使用相对复杂。
- en: 'First, for both upload handlers, there is the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于两个上传处理程序，有以下的代码：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The call to `map_err` is required to convert the error type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 需要调用`map_err`来转换错误类型。
- en: The call to `fold` receives from the network one chunk of data at a time and
    uses it to extend an object of the `BytesMut` type. Such a type implements a kind
    of extensible buffer.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold` 的调用每次从网络接收一块数据，并使用它来扩展 `BytesMut` 类型的对象。这种类型实现了一种可扩展的缓冲区。'
- en: The call to `and_then` chains another future to the current one. It receives
    a closure that will be called when the processing of `fold` will be finished.
    Such a closure receives all the uploaded contents as an argument. This is a way
    to chain two futures—any closure invoked in this way is executed asynchronously,
    after the previous one is finished.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`and_then` 的调用将另一个 future 链接到当前的一个。它接收一个闭包，当 `fold` 的处理完成时将被调用。这个闭包接收所有上传的内容作为参数。这是链式调用两个
    future 的方法——以这种方式调用的任何闭包都是在前一个闭包完成后异步执行的。'
- en: The contents of the closure simply write the received contents into a file with
    the specified name. This operation is synchronous.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的内容只是将接收到的内容写入指定名称的文件。这个操作是同步的。
- en: The last line of the closure is `ok(HttpResponse::Ok().finish())`. This is the
    way to return from a future. Notice the lowercase `ok`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的最后一行是 `ok(HttpResponse::Ok().finish())`。这是从 future 返回的方式。注意小写的 `ok`。
- en: 'The `upload_new_file` function is similar to the previous one, in terms of
    the web programming concepts. It is more complex, just because of the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload_new_file` 函数在网页编程概念上与之前的函数相似。它更复杂，仅仅是因为以下原因：'
- en: Instead of having a complete filename, only a prefix is provided, and the rest
    must be generated as a pseudo-random number.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是提供一个完整的文件名，只提供了一个前缀，其余部分必须生成一个伪随机数。
- en: The resulting filename must be sent to the client.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果文件名必须发送到客户端。
- en: 'The algorithm to generate a unique filename is the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 生成唯一文件名的算法如下：
- en: A three-digit pseudo-random number is generated, and it is concatenated to the
    prefix.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个三位伪随机数，并将其连接到前缀。
- en: The name obtained is used to create a file; this avoids overwriting an existing
    file with that name.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得的名称用于创建一个文件；这避免了覆盖具有该名称的现有文件。
- en: If a collision happens, another number is generated until a new file is created,
    or until 100 failed attempts have been tried.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生冲突，将生成另一个数字，直到创建一个新文件，或者直到尝试了 100 次失败的尝试。
- en: Of course, this assumes that the number of uploaded files will always be significantly
    less than 1,000.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这假设上传的文件数量始终远小于 1,000。
- en: Other changes have been made to consider the chance of failure.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 已经进行了其他更改，以考虑失败的可能性。
- en: 'The final part of the `delete_file` function now looks like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_file` 函数的最后一部分现在看起来是这样的：'
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code handles the case of a failure in the deletion of the file. Notice
    that in the case of an error, instead of returning the success status code `HttpResponse::Ok()` representing
    the number `200`, a `HttpResponse::NotFound()` failure code is returned, representing
    the number `404`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码处理文件删除失败的情况。注意，在出现错误的情况下，不是返回表示数字 `200` 的成功状态码 `HttpResponse::Ok()`，而是返回表示数字
    `404` 的 `HttpResponse::NotFound()` 失败代码。
- en: 'The `download_file` function now contains a local function to read the whole
    contents of a file into a string, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_file` 函数现在包含一个局部函数，用于将整个文件内容读入一个字符串，如下所示：'
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The function ends with some code to handle the possible failure of the function,
    as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 函数以一些代码结束，以处理函数可能的失败，如下所示：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Building a stateful server
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个有状态的服务器
- en: The web app of the `file_transfer_stub` project was completely stateless, meaning
    that every operation had the same behavior independently of the previous operations.
    Other ways to explain this are that no data was kept from one command to the next,
    or that it computed pure functions only.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_transfer_stub` 项目的网页应用是完全无状态的，这意味着每个操作的行为独立于之前的操作。其他解释方式是，没有数据从一个命令保持到下一个命令，或者它只计算纯函数。'
- en: The web app of the `file_transfer` project had a state, but that state was confined
    to the filesystem. Such a state was the content of the data files. Nevertheless,
    the application itself was still stateless. No variable survived from one request
    handling to another request handling.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_transfer` 项目的网页应用有一个状态，但这个状态仅限于文件系统。这种状态是数据文件的内容。尽管如此，应用程序本身仍然是无状态的。没有变量从一个请求处理持续到另一个请求处理。'
- en: The REST principles are usually interpreted as prescribing that any API *must
    be stateless*. That is a misnomer because REST services *can* have a state, but
    they *must behave as if they were stateless*. To be stateless means that, except
    for the filesystem and the database, no information survives in the server from
    one request handling to another request handling. To behave as if stateless means
    that any sequence of requests should obtain the same results even if the server
    is terminated and restarted between one request and a successive one.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: REST 原则通常被解释为规定任何 API *必须是无状态的*。这是一个误解，因为 REST 服务 *可以* 有状态，但它们 *必须表现得像无状态一样*。无状态意味着，除了文件系统和数据库外，没有信息在服务器中从一次请求处理持续到另一次请求处理。表现得像无状态意味着任何请求序列都应该获得相同的结果，即使服务器在两次请求之间被终止并重新启动。
- en: Clearly, if the server is terminated, its state is lost. So, to behave as stateless
    means that the behavior should be the same even if the state is reset. So, what
    is the purpose of the possible server state? It is to store information that can
    be obtained again with any request, but that would be costly to do so. This is
    the concept of caching.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果服务器被终止，其状态就会丢失。因此，作为无状态的行为意味着即使状态被重置，行为也应该保持一致。那么，可能的服务器状态有什么作用呢？它是为了存储可以通过任何请求再次获取的信息，但这样做可能会很昂贵。这就是缓存的概念。
- en: Usually, any REST web server has an internal state. The typical information
    stored in this state is a pool of connections to the database. A pool is initially
    empty, and when the first handler must connect to the database, it searches the
    pool for an available connection. If it finds one, it uses it. Otherwise, a new
    connection is created and added to the pool. A pool is a shared state that must
    be passed to any request handler.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何 REST web 服务器都有一个内部状态。在这个状态中存储的典型信息是数据库连接池。池最初是空的，当第一个处理器必须连接到数据库时，它会搜索池以查找可用的连接。如果找到了，它就会使用它。否则，会创建一个新的连接并将其添加到池中。池是一个共享状态，必须传递给任何请求处理器。
- en: In the projects of the previous sections, the request handlers were pure functions;
    they had no possibility of sharing a common state. In the `memory_db` project,
    we'll see how we can have a shared state in the Actix web framework that is passed
    to any request handler.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节的项目中，请求处理器是纯函数；它们没有共享公共状态的可能性。在 `memory_db` 项目中，我们将看到如何在 Actix web 框架中实现共享状态，并将其传递给任何请求处理器。
- en: This web app represents access to a very simple database. Instead of performing
    actual access to a database, which would require further installations in your
    computer, it simply invokes some functions exported by the `data_access` module,
    defined in the `src/data_access.rs` file, that keep the database in memory.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 web 应用程序代表了对一个非常简单的数据库的访问。而不是执行对数据库的实际访问，这需要在您的计算机上进行进一步的安装，它只是调用了在 `src/data_access.rs`
    文件中定义的 `data_access` 模块导出的某些函数，这些函数将数据库保持在内存中。
- en: A memory database is a state that is shared by all the request handlers. In
    a more realistic app, a state would contain only one or more connections to an
    external database.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 内存数据库是所有请求处理器共享的状态。在一个更现实的应用中，状态将只包含一个或多个与外部数据库的连接。
- en: How to have a stateful server
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何拥有一个有状态的服务器
- en: To have a state in an Actix service, a struct must be declared, and any data
    that should be part of the state should be a field of that struct.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Actix 服务中拥有状态，必须声明一个结构体，并且任何应该作为状态一部分的数据都应该是该结构体的字段。
- en: 'At the beginning of the `main.rs` file, there is the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.rs` 文件的开始处，有以下的代码：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the state of our web app, we need only one field, but other fields can be
    added.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 web 应用程序的状态中，我们只需要一个字段，但可以添加其他字段。
- en: 'The `DbConnection` type declared in the `db_access` module represents the state
    of our web app. In the `main` function, just before creating the server, there
    is the following statement that instantiates the `AppState`, and then properly
    encapsulates it:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `db_access` 模块中声明的 `DbConnection` 类型代表了我们 web 应用程序的状态。在 `main` 函数中，在创建服务器之前，有以下的语句实例化了
    `AppState`，然后适当地封装了它：
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The state is shared by all the requests, and the Actix web framework uses several
    threads to handle the requests, and so the state must be thread-safe. The typical
    way of declaring a thread-safe object in Rust is to encapsulate it in a `Mutex` object.
    This object is then encapsulated in a `Data` object.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 状态被所有请求共享，Actix web 框架使用多个线程来处理请求，因此状态必须是线程安全的。在 Rust 中声明线程安全对象的一种典型方式是将它封装在一个
    `Mutex` 对象中。然后，这个对象被封装在一个 `Data` 对象中。
- en: 'To ensure that such a state is passed to any handler, the following line must
    be added before calling the `service` functions:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这种状态传递给任何处理程序，必须在调用`service`函数之前添加以下行：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, the `db_conn` object is cloned (cheaply, as it is a smart pointer), and
    it is registered into the app.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`db_conn`对象被克隆（由于它是一个智能指针，所以成本较低），并注册到应用程序中。
- en: 'The effect of this registration is that it is now possible to add another type
    of argument to the request handlers (both synchronous and asynchronous), as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这种注册的效果是，现在可以向请求处理程序（同步和异步）添加另一种类型的参数，如下所示：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Such an argument can be used in statements like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这种参数可以在如下语句中使用：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, the state is locked to prevent concurrent access by other requests, and
    its `db` field is accessed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，状态被锁定以防止其他请求的并发访问，并访问其`db`字段。
- en: The API of this service
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 该服务的API
- en: 'The rest of the code in this app is not particularly surprising. The API is
    clear from the names used in the `main` function, as illustrated in the following
    code block:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序中的其余代码并不特别令人惊讶。API从`main`函数中使用的名称中很清楚，如下面的代码块所示：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that the first three patterns use the `GET` method, and so they *query*
    the database. The last one uses the `POST` method, and so it inserts new records
    into the database.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前三个模式使用`GET`方法，因此它们*查询*数据库。最后一个使用`POST`方法，因此它将新记录插入到数据库中。
- en: Notice also the following lexical conventions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下词汇约定。
- en: The path of the URI for the first and third patterns begins with the plural
    word `persons`, which means that zero, one, or several items will be managed by
    this request and that any such item represents a person. Instead, the path of
    the URI for the second and fourth patterns begins with the singular word `person`,
    and this means that no more than one item will be managed by this request.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第三个模式的URI路径以复数名词`persons`开头，这意味着零个、一个或多个项目将由此请求管理，并且任何此类项目代表一个人。相反，第二个和第四个模式的URI路径以单数名词`person`开头，这意味着最多只能由一个项目管理此请求。
- en: The first pattern ends with the plural word `ids`, and so several items regarding
    the `id` will be handled. It has no condition, and so all the IDs are requested. The
    second pattern contains the word `name_by_id`, followed by an `id` parameter,
    and so it is a request of the `name` database column for all the records for which
    the `id` column has the value specified.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模式以复数名词`ids`结尾，因此将处理与`id`相关的几个项目。它没有条件，因此请求所有ID。第二个模式包含单词`name_by_id`，后面跟一个`id`参数，因此它是请求`name`数据库列的所有记录，其中`id`列的值指定。
- en: Even in the case of any doubt, the name of the handling functions or comments
    should make the behavior of the service clear, without having to read the code
    of the handlers. When looking at the implementation of the handlers, notice that
    they either return nothing at all or simple text.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在有任何疑问的情况下，处理函数或注释的名称也应该使服务的操作清晰，而无需阅读处理程序的代码。在查看处理程序的实现时，请注意它们要么根本不返回任何内容，要么只返回简单的文本。
- en: Testing the service
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试服务
- en: Let's test the service with some curl operations.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些curl操作来测试服务。
- en: First of all, we should populate the database that is initially empty. Remember
    that, being only in memory, it is empty any time you start the service.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该填充最初为空的数据库。记住，由于它仅在内存中，每次启动服务时都是空的。
- en: 'After starting the program, type the following commands:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动程序后，输入以下命令：
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After the first command, a number `1` should be printed to the console. After
    the second command, `2` should be printed, and after the third command, `3` should
    be printed. They are the IDs of the inserted names of people.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令之后，应在控制台打印数字`1`。在第二个命令之后，应打印`2`，在第三个命令之后，应打印`3`。它们是插入的人名的ID。
- en: 'Now, type the following command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下命令：
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It should print the following: `1, 2, 3`. This is the set of all the IDs in
    the database.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 应打印以下内容：`1, 2, 3`。这是数据库中所有ID的集合。
- en: 'Now, type the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下命令：
- en: '[PRE53]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It should print the following: `Mary Jane`. This is the name of the unique
    person for which the `id` is equal to `3`. Notice that the input sequence `%20`
    has been decoded into a blank.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 应打印以下内容：`Mary Jane`。这是`id`等于`3`的唯一人员的姓名。注意，输入序列`%20`已被解码为空格。
- en: 'Now, type the following command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下命令：
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It should print the following: `2: Jonathan; 3: Mary Jane`. This is the set
    of all the people for which the `name` column contains the `an` substring.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '它应该打印以下内容：`2: Jonathan; 3: Mary Jane`。这是包含`name`列包含`an`子字符串的所有人员的集合。'
- en: Implementing the database
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库的实现
- en: The whole database implementation is kept in the `db_access.rs` source file.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 整个数据库实现都保存在`db_access.rs`源文件中。
- en: The implementation of the database is quite simple. It is a `DbConnection` type,
    containing `Vec<Person>`, where `Person` is a struct of two fields—`id` and `name`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的实现相当简单。它是一个`DbConnection`类型，包含`Vec<Person>`，其中`Person`是一个包含两个字段的struct——`id`和`name`。
- en: 'The methods of `DbConnection` are described as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbConnection`的方法描述如下：'
- en: '`new`: This creates a new database.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`: 这将创建一个新的数据库。'
- en: '`get_all_persons_ids(&self) -> impl Iterator<Item = u32> + ''_`: This returns
    an iterator that provides all the IDs contained in the database. The lifetime
    of such an iterator must be no more than that of the database itself.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_all_persons_ids(&self) -> impl Iterator<Item = u32> + ''_`: 这返回一个迭代器，它提供了数据库中包含的所有ID。此类迭代器的生命周期不能超过数据库本身的寿命。'
- en: '`get_person_name_by_id(&self, id: u32) -> Option<String>`: This returns the
    name of the unique person having the specified ID if there is one, or zero if
    there isn''t one.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_person_name_by_id(&self, id: u32) -> Option<String>`: 如果存在具有指定ID的唯一人员，则返回该人员的姓名，否则返回零。'
- en: '`get_persons_id_and_name_by_partial_name<''a>(&''a self, subname: &''a str)
    -> impl Iterator<Item = (u32, String)> + ''a`: This returns an iterator that provides
    the ID and the name of all the people whose name contains the specified string. The
    lifetime of such an iterator must be no more than that of the database itself,
    and also no more than that of the specified string.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_persons_id_and_name_by_partial_name<''a>(&''a self, subname: &''a str)
    -> impl Iterator<Item = (u32, String)> + ''a`: 这返回一个迭代器，它提供了所有姓名包含指定字符串的人员的ID和姓名。此类迭代器的生命周期不能超过数据库本身的寿命，也不能超过指定的字符串。'
- en: '`insert_person(&mut self, name: &str) -> u32`: This adds a record to the database,
    containing a generated ID and the specified `name`. This returns the generated
    ID.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert_person(&mut self, name: &str) -> u32`: 这向数据库添加一条记录，包含一个生成的ID和指定的`name`。这返回生成的ID。'
- en: Handling queries
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理查询
- en: 'The request handlers, contained in the `main.rs` file, get arguments of several
    types, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理器，包含在`main.rs`文件中，获取几种类型的参数，如下所示：
- en: '`web::Data<Mutex<AppState>>`: As described previously, this is used to access
    the shared app state.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web::Data<Mutex<AppState>>`: 如前所述，这用于访问共享应用程序状态。'
- en: '`Path<(String,)>`: As described in the previous sections, this is used to access
    the path of the request.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path<(String,)>`: 如前所述，这用于访问请求的路径。'
- en: '`HttpRequest`: As described in the previous sections, this is used to access
    general request information.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpRequest`: 如前所述，这用于访问一般请求信息。'
- en: But also, the request handlers get the `web::Query<Filter>` argument to access
    the optional arguments of the request.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但同时，请求处理器也获得了`web::Query<Filter>`参数来访问请求的可选参数。
- en: 'The `get_persons` handler has a query argument—it is a generic argument, whose
    parameter is the `Filter` type. Such a type is defined as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_persons`处理器有一个查询参数——它是一个泛型参数，其参数是`Filter`类型。此类类型如下定义：'
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This definition allows requests such as `http://localhost:8080/persons?partial_name=an`.
    In this request, the path is just `/persons`, while `?partial_name=an` is the
    so-called query. In this case, it contains just one argument whose key is `partial_name`,
    and whose value is `an`. It is a string and it is optional. This is exactly what
    is described by the `Filter` struct.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此定义允许请求，如`http://localhost:8080/persons?partial_name=an`。在这个请求中，路径只是`/persons`，而`?partial_name=an`是所谓的查询。在这种情况下，它只包含一个参数，其键为`partial_name`，其值为`an`。它是一个字符串，它是可选的。这正是`Filter`结构体所描述的。
- en: In addition, such a type is deserializable, as such an object must be read by
    the request through serialization.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此类类型是可序列化的，因为此类对象必须通过序列化被请求读取。
- en: 'The `get_persons` function accesses the query through the following expression:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_persons`函数通过以下表达式访问查询：'
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `partial_name` field is cloned to get a string. If it is nonexistent, it
    is taken as an empty string.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial_name`字段被克隆以获取一个字符串。如果它不存在，则将其视为空字符串。'
- en: Returning JSON data
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回JSON数据
- en: The previous section returned data in plain text. This is unusual in a web service
    and rarely satisfactory. Usually, web services return data in JSON, XML, or another
    structured format. The `json_db` project is identical to the `memory_db` project,
    except for its returning data in the JSON format.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节返回了纯文本数据。在Web服务中这是不寻常的，并且很少令人满意。通常，Web服务以JSON、XML或其他结构化格式返回数据。`json_db`项目与`memory_db`项目相同，除了它以JSON格式返回数据。
- en: 'First of all, let''s see what happens when the same curl commands from the
    previous section are executed on it, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看当在它上面执行上一节中的相同curl命令时会发生什么，如下所示：
- en: The insertions have the same behavior because they just printed a number.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入的行为相同，因为它们只是打印了一个数字。
- en: The first query should print the following: `[1,2,3]`. The three numbers are
    in an array, and so they are enclosed in brackets.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个查询应该打印以下内容：`[1,2,3]`。这三个数字在一个数组中，因此它们被括号包围。
- en: 'The second query should print the following: `"Mary Jane"`. The name is a string,
    and so it is enclosed in quotation marks.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个查询应该打印以下内容：“Mary Jane”。名字是一个字符串，因此它被引号包围。
- en: 'The third query should print the following: `[[2,"Jonathan"],[3,"Mary Jane"]]`. The
    sequence of persons is an array of two records, and each of them is an array of
    two values, which are a number and a string.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个查询应该打印以下内容：`[[2,"Jonathan"],[3,"Mary Jane"]]`。人员序列是一个包含两个记录的数组，每个记录都是一个包含两个值的数组，一个是数字，一个是字符串。
- en: Now, let's see the differences in the code of this project with respect to the
    previous one.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个项目与之前项目的代码差异。
- en: 'In the `Cargo.toml` file, one dependency has been added, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`文件中，增加了一个依赖项，如下所示：
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is needed to serialize the data in JSON format.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了将数据序列化为JSON格式。
- en: 'In the `main.rs` file, the `get_all_persons_ids` function (instead of returning
    simply a string) has the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.rs`文件中，`get_all_persons_ids`函数（而不是简单地返回一个字符串）有如下代码：
- en: '[PRE58]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: First, a response with a status code `Ok` is created; then, its content type
    is set to `application/json`, to let the client know how to interpret the data
    it will receive; and lastly, its body is set, using the `json` macro taken from
    the `serde_json` crate. This macro takes an expression—in this case, with type, `Vec<Person>`—and
    returns a `serde_json::Value` value. Now, we need a string, and so `to_string()`
    is called. Notice that the `json!` macro requires its argument to implement the
    `Serialize` trait or to be convertible into a string.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个带有状态码`Ok`的响应；然后，将其内容类型设置为`application/json`，以便让客户端知道如何解释它将接收到的数据；最后，使用从`serde_json`crate中取出的`json`宏设置其主体。这个宏接受一个表达式——在这种情况下，类型为`Vec<Person>`——并返回一个`serde_json::Value`值。现在，我们需要一个字符串，因此调用`to_string()`。注意，`json!`宏要求其参数实现`Serialize`特质或可转换为字符串。
- en: The `get_person_name_by_id`, `get_persons`, and `insert_person` functions have
    similar changes. The `main` function has no changes. The `db_access.rs` files
    are identical.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_person_name_by_id`、`get_persons`和`insert_person`函数有类似的变化。`main`函数没有变化。`db_access.rs`文件是相同的。'
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned about a few features of the Actix web framework. It is a really
    complex framework that covers most needs of the backend web developer, and it
    is still in active development.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了一些Actix Web框架的特性。这是一个非常复杂的框架，涵盖了后端Web开发者的大多数需求，并且仍在积极开发中。
- en: Particularly, in the `file_transfer_stub` project, we learned how to create
    an API of a RESTful service. In the `file_transfer` project, we discussed how
    to implement the operations of our web service. In the `memory_db` project, we
    went through how to manage an inner state, in particular, one containing a database
    connection. In the `json_db` project, we have seen how to send a response in JSON
    format.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在`file_transfer_stub`项目中，我们学习了如何创建一个RESTful服务的API。在`file_transfer`项目中，我们讨论了如何实现我们网络服务的操作。在`memory_db`项目中，我们了解了如何管理内部状态，特别是包含数据库连接的状态。在`json_db`项目中，我们看到了如何以JSON格式发送响应。
- en: In the next chapter, we will be learning how to create a full server-side web
    application.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何创建一个完整的后端Web应用程序。
- en: Questions
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: According to the REST principles, what are the meanings of the `GET`, `PUT`,
    `POST`, and `DELETE` HTTP methods?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据REST原则，`GET`、`PUT`、`POST`和`DELETE`HTTP方法分别代表什么意思？
- en: Which command-line tool can be used to test a web service?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令行工具可以用来测试一个网络服务？
- en: How can a request handler retrieve the value of URI parameters?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求处理器如何检索URI参数的值？
- en: How can the content type of an HTTP response be specified?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何指定HTTP响应的内容类型？
- en: How can a unique file name be generated?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何生成一个唯一的文件名？
- en: Why do services that have a stateless API need to manage a state?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么无状态的API服务需要管理状态？
- en: Why must the state of a service be encapsulated in a `Data` and a `Mutex` object?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么服务的状态必须封装在`Data`和`Mutex`对象中？
- en: Why may asynchronous processing be useful in a web service?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么异步处理在Web服务中可能是有用的？
- en: What is the purpose of the `and_then` function of futures?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: futures的`and_then`函数的目的是什么？
- en: Which crates are useful to compose an HTTP response in JSON format?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些crate对于以JSON格式组合HTTP响应是有用的？
- en: Further reading
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about the Actix framework, view the official documentation at [https://actix.rs/docs/](https://actix.rs/docs/),
    and view official examples at [https://github.com/actix/examples/](https://github.com/actix/examples/).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Actix框架的信息，请查看官方文档[https://actix.rs/docs/](https://actix.rs/docs/)，并查看官方示例[https://github.com/actix/examples/](https://github.com/actix/examples/)。
