- en: Common Performance Pitfalls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见性能陷阱
- en: If you are reading this book, you are probably concerned about the performance
    of your Rust code. It's known that Rust can offer performance close to that of
    C/C++ programs, and in some cases, Rust can even win those benchmarks. The main
    issue, though, is that it's sometimes hard to get that efficiency, especially
    if you are coming from C/C++. Some concepts don't apply, and some simple efficient
    approaches in those languages are notably worse in Rust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，你很可能关心你的 Rust 代码的性能。众所周知，Rust 可以提供接近 C/C++ 程序的性能，在某些情况下，Rust 甚至可以在基准测试中胜出。然而，主要问题是，有时很难获得这种效率，尤其是如果你来自
    C/C++。有些概念不适用，而且那些语言中的一些简单高效的方法在 Rust 中明显更差。
- en: In this book, you will learn how to really take advantage of Rust to make it
    perform at its best while maintaining all the benefits it brings—safety, zero-cost
    abstractions, and great concurrency. The book can be read from start to finish,
    and you will probably learn new concepts in every chapter. You can go directly
    to the chapter that interests you, though, as each chapter contains all the required
    information for its completion, so that it can be used as a reference.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将学习如何真正利用 Rust，使其在保持其带来的所有好处——安全性、零成本抽象和出色的并发性的同时，发挥最佳性能。你可以从头到尾阅读这本书，你可能会在每一章中学习到新的概念。不过，你也可以直接阅读你感兴趣的章节，因为每一章都包含了完成其内容所需的所有信息，因此它可以作为参考。
- en: In this first part of the book, we will start with an introduction on how to
    improve the performance of your sequential code. You will learn how to avoid common
    performance pitfalls and how to fix direct translations from other languages.
    You will then learn how to get better performance from your code, and finally
    understand memory management in Rust.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，我们将从介绍如何提高你的顺序代码性能开始。你将学习如何避免常见的性能陷阱，以及如何修复来自其他语言的直接翻译。然后，你将学习如何从你的代码中获得更好的性能，并最终理解
    Rust 中的内存管理。
- en: 'In this chapter, we will be looking into:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Configuration of the compilation process with profiles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置文件配置编译过程
- en: Translation pitfalls—learning how to avoid performance pitfalls with array/slice
    indexing and master iterators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译陷阱——学习如何通过数组/切片索引和掌握迭代器避免性能陷阱
- en: New iterator adaptors, both in the standard library and in external crates,
    and coding any complex behavior at zero cost
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库和外部 crate 中的新迭代器适配器，以及以零成本编码任何复杂行为
- en: How to use the borrow checker to your advantage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用借用检查器
- en: Most of the people that start learning Rust, myself included, tend to bring
    lessons learned in other languages to Rust. This is usually a great thing, as
    it will enable you to learn the language faster. The main issue with this approach
    is that some patterns used in other languages can actually be a trade-off in Rust.
    We will learn about the most common ones and the not-so-common ones, so that anyone
    trying to get better performance in Rust can learn how to do it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开始学习 Rust 的人，包括我自己，往往会将其他语言中学到的经验带到 Rust 中。这通常是一件好事，因为它将使你更快地学习这门语言。这种方法的
    主要问题是，在其他语言中使用的一些模式在 Rust 中实际上可能是一个权衡。我们将学习最常见的和不太常见的一些模式，以便任何试图在 Rust 中获得更好性能的人都能学到如何做到这一点。
- en: Asking the Rust compiler about performance
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 Rust 编译器询问性能
- en: Rust sometimes has interesting and lesser-known features that really make a
    difference when talking about performance enhancements. When it comes to big improvements
    with small changes, the first thing that you should understand is the release
    mode. Rust by default compiles your software in development mode, which is pretty
    good to check for compiling errors quickly, but if you want to run it, it will
    run slowly. This is due to the development mode not performing any optimizations.
    It will create object (machine) code directly related to the Rust code without
    optimizing it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有时有一些有趣且不太为人所知的特性，在谈论性能提升时，这些特性确实能带来很大的差异。当涉及到通过小改动实现大改进时，你应该首先理解的是发布模式。Rust
    默认以开发模式编译你的软件，这对于快速检查编译错误来说相当不错，但如果你想运行它，它会运行得很慢。这是因为开发模式不会进行任何优化。它将创建与 Rust 代码直接相关的对象（机器）代码，而不会对其进行优化。
- en: Rust makes use of the LLVM backend, which makes it easy to take advantage of
    its performance optimizations without having to develop all of these by themselves.
    They will only need to use LLVM intermediate representation. An intermediate language
    between Rust and assembly code that the LLVM compiler understands. While in development
    mode, no optimizations get performed by Rust or LLVM; enabling them is as easy
    as adding the `--release` flag to the cargo compilation. So, for example, if you
    were running your software by typing `cargo run` in the console, just by using `cargo
    run --release` it will compile with optimizations and run much, much faster. Usually,
    the gain is of more than one order of magnitude.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 使用了 LLVM 后端，这使得它能够利用其性能优化，而无需自己开发所有这些。它们只需要使用 LLVM 中间表示。这是 Rust 和汇编代码之间的中间语言，LLVM
    编译器能够理解。在开发模式下，Rust 或 LLVM 不会执行任何优化；启用它们就像在 cargo 编译时添加 `--release` 标志一样简单。例如，如果你通过在控制台输入
    `cargo run` 来运行你的软件，只需使用 `cargo run --release`，它就会进行优化编译并运行得快得多。通常，这种提升是超过一个数量级的。
- en: Optimizations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: By default, Rust will perform level 3 optimizations in the code. Optimizations
    get divided into levels depending on how complex they are. Higher-level optimizations,
    in theory, improve the performance of the code greatly, but they might have bugs
    that could change the behavior of the program. Usually, level 1 optimizations
    are totally safe, and level 2 optimizations are the most-used ones in the C/C++
    ecosystem. Level 3 optimizations have not been known to cause any issues, but
    in some critical situations, it might be better to avoid them. This can be configured,
    but we should first understand how the Rust compiler compiles the code to machine
    instructions so that we know what different options accomplish.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Rust 会在代码中执行第 3 级优化。优化根据其复杂度被分为不同的级别。理论上，高级别的优化可以极大地提高代码的性能，但它们可能存在可能导致程序行为改变的错误。通常，第
    1 级优化是完全安全的，而第 2 级优化在 C/C++ 生态系统中是最常用的。第 3 级优化尚未被证明会引起任何问题，但在某些关键情况下，可能最好避免它们。这可以进行配置，但我们应该首先了解
    Rust 编译器如何将代码编译成机器指令，以便我们知道不同的选项能完成什么。
- en: Rust first starts with parsing your code files. It will get the keywords and
    the different symbols to create a representation of the code in memory. This parsing
    will find common errors such as a missing semicolon or an invalid keyword. This
    memory representation of the code is called **High Intermediate Representation** (**HIR**).
    This representation of the code will be greatly simplified, removing complex flow
    structures and converting it into **Middle Intermediate Representation** (**MIR**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 首先会解析你的代码文件。它会获取关键词和不同的符号来在内存中创建代码的表示。这种解析会找到常见的错误，例如缺少分号或无效的关键词。这种代码的内存表示称为
    **高中间表示**（**HIR**）。这种代码的表示将会大大简化，移除复杂的流程结构，并将其转换为 **中间中间表示**（**MIR**）。
- en: The MIR representation is then used to check more complex flows of the software,
    and enables complex variable lifetime checks, along with some other improvements.
    This is then converted to the LLVM Intermediate Representation and gets passed
    to the LLVM compiler. When passing this code to LLVM, Rust adds some flags that
    will modify the way that LLVM optimizes the code. We have already seen that by
    default one of the flags it passes is the `-O0` flag, or *do not optimize* flag,
    so it simply translates to machine code. When compiling in release mode, though,
    a `-O3` gets passed so that level 3 optimizations get performed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，MIR 表示被用来检查软件的更复杂的流程，并允许进行复杂的变量生命周期检查，以及其他一些改进。然后，它被转换为 LLVM 中间表示，并传递给 LLVM
    编译器。当将此代码传递给 LLVM 时，Rust 会添加一些标志，这些标志将修改 LLVM 优化代码的方式。我们已经看到，默认情况下，它传递的其中一个标志是
    `-O0` 标志，或 *不优化* 标志，因此它简单地转换为机器代码。然而，在发布模式下编译时，会传递 `-O3`，以便执行第 3 级优化。
- en: This behavior can be configured in the `Cargo.toml` file of the project and
    it can be configured for each profile. You can configure how to compile for tests,
    development, documentation, benchmarks, and release. You will probably want to
    keep development and documentation optimizations to a minimum, as in those profiles
    the main idea is to compile quickly. In the case of the development profile, you
    will want to check if everything compiles properly, and even test the behavior
    of the program a little bit, but you probably won't be concerned about the performance.
    When generating the documentation, the performance of the application doesn't
    matter at all, so the best idea is to just not optimized.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可以在项目的 `Cargo.toml` 文件中配置，并且可以为每个配置文件进行配置。你可以配置如何为测试、开发、文档、基准测试和发布进行编译。你可能希望将开发和文档优化保持在最低限度，因为在这些配置文件中，主要目的是快速编译。在开发配置文件的情况下，你将想要检查一切是否都能正确编译，甚至测试程序的行为，但你可能不会关心性能。在生成文档时，应用程序的性能根本不重要，所以最好的办法就是不要进行优化。
- en: When testing, the optimization level you need will depend on how many tests
    you want to run and how computationally expensive they are. If it takes a really
    long time to run the tests, it may make sense to compile them optimized. Also,
    in some critical situations in which you might not be 100% sure that optimizations
    get performed in a completely secure way, you might want to optimize the tests
    the same way you optimize the release, and that way you can check if all unit
    and integration tests pass properly even after optimizations. If they don't, this
    is a compiler malfunction, and you should report it to the Rust compiler team.
    They will be glad to help.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，所需的优化级别将取决于你想要运行多少次测试以及它们的计算成本有多高。如果运行测试需要非常长的时间，那么编译它们以优化可能是有意义的。此外，在某些可能无法完全确保优化以完全安全方式执行的关键情况下，你可能希望以与优化发布相同的方式优化测试，这样你就可以检查所有单元和集成测试在优化后是否都能正确通过。如果它们没有通过，这可能是编译器故障，你应该向Rust编译器团队报告。他们将很高兴提供帮助。
- en: Of course, benchmarks and release profiles should be the most optimized ones.
    In benchmarks, you will want to know the real optimized performance of the code,
    while in the release, you will want your users to get the best out of their hardware
    and your software to make things run as efficiently as possible. In these cases,
    you will want to optimize up to level 2 at least, and if you are not sending satellites
    to space or programming a pacemaker, you will probably want to optimize all the
    way up to level 3.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，基准测试和发布配置文件应该是优化程度最高的。在基准测试中，你将想要知道代码的真实优化性能，而在发布中，你将希望用户从他们的硬件中获得最佳性能，并且你的软件能够尽可能高效地运行。在这些情况下，你将想要至少优化到2级，如果你不是在发送卫星到太空或编程起搏器，你可能会想要将优化进行到3级。
- en: Build configuration
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建配置
- en: 'There is one section in the `Cargo.toml` file that enables these configurations:
    the profile section. In this section, you will find one subsection for each of
    the profiles. Each of them gets declared with the `[profile.{profile}]` format.
    So, for example, for the development profile, it would be `[profile.dev]`. The
    different profile configuration keywords are the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 文件中有一个部分可以启用这些配置：配置文件部分。在这个部分中，你会为每个配置文件找到一个子部分。每个子部分都使用 `[profile.{profile}]`
    格式声明。例如，对于开发配置文件，它将是 `[profile.dev]`。不同的配置文件配置关键字如下：
- en: '`dev` for the development profile, used in `cargo build` or `cargo run`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev` 用于开发配置文件，在 `cargo build` 或 `cargo run` 中使用'
- en: '`release` for the release profile, used in `cargo build --release` or `cargo
    run --release`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release` 用于发布配置文件，在 `cargo build --release` 或 `cargo run --release` 中使用'
- en: '`test` for the testing profile, used in `cargo test`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test` 用于测试配置文件，在 `cargo test` 中使用'
- en: '`bench` for the benchmarking profile, used in `cargo bench`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bench` 用于基准测试配置文件，在 `cargo bench` 中使用'
- en: '`doc` for the documentation profile, used in `cargo doc`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc` 用于文档配置文件，在 `cargo doc` 中使用'
- en: When configuring each profile, you will have many options, and we will check
    all of them out here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置每个配置文件时，你将有很多选项，我们将在这里检查所有这些选项。
- en: Optimization level
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化级别
- en: 'The first option is the one mentioned before, the optimization level. This
    configuration option can be set by using the `opt-level` key in the relevant profile
    section. By default, optimizations will be level 3 for benchmarking and release,
    and zero for the rest. For example, to only perform level `2` optimizations in
    the release profile, you can add this code to your `Cargo.toml` file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是之前提到的优化级别。此配置选项可以通过在相关配置文件部分使用`opt-level`键来设置。默认情况下，优化级别为3用于基准测试和发布，其余为0。例如，要仅在发布配置文件中执行级别`2`的优化，您可以将以下代码添加到您的`Cargo.toml`文件中：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Debug information
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试信息
- en: The next option is the debug information. This does not directly affect performance,
    but it's an interesting configuration item. In this case, you can decide if the
    debug symbol information gets added to the final executable. This is really useful
    if you are developing, and especially if you are using a debugger such as GDB.
    Adding debug information to the executable will enable you to get the function
    names and even the line numbers of each instruction being executed in the processor.
    This will give you great insight about what is happening in the code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是调试信息。这不会直接影响性能，但它是一个有趣的配置项。在这种情况下，您可以决定是否将调试符号信息添加到最终的可执行文件中。如果您正在开发，尤其是如果您正在使用GDB之类的调试器，这将非常有用。将调试信息添加到可执行文件将使您能够获取处理器中每个指令的函数名甚至行号。这将为您提供关于代码中发生情况的深入了解。
- en: In any case, debug information is not so useful in final release binaries, as
    final release binaries are not meant to be used in debugging. And the debug information
    usually adds a lot of size to the final binary. This has many times been a concern
    among developers, as the size of Rust binaries is usually much bigger than the
    ones written in C/C++. This is in part due to this configuration, and in most
    cases due to the panic behavior, which we will check later. Debug symbols will
    also show information about the original code, so it might make sense to hide
    it in closed-source projects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，调试信息在最终发布的二进制文件中并不那么有用，因为最终发布的二进制文件并不是为了调试而设计的。而且，调试信息通常会增加最终二进制文件的大小。这曾多次成为开发者的担忧，因为Rust的二进制文件通常比用C/C++编写的二进制文件要大得多。这在很大程度上是由于这种配置，以及在大多数情况下是由于panic行为，我们稍后会检查。调试符号还会显示有关原始代码的信息，因此在封闭源代码项目中隐藏它可能是有意义的。
- en: 'To avoid extra debug symbols in the final binary, the `debug` option must be
    set to `false`. This can be done for each profile, and by default, it''s `true`
    only for the development profile. If you''d like to enable it for testing also,
    for example, you can add this in the `Cargo.toml` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在最终二进制文件中包含额外的调试符号，必须将`debug`选项设置为`false`。这可以为每个配置文件进行设置，默认情况下，只有开发配置文件为`true`。如果您还希望将其用于测试，例如，您可以在`Cargo.toml`文件中添加以下内容：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can, of course, combine this with any other profile option:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以将此与任何其他配置文件选项结合使用：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Link-time optimizations
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接时间优化
- en: The next configuration option, useful for improving the performance of the application,
    is link-time optimizations. Usually, when a program gets built, once all the code
    has been optimized, it gets linked to other libraries and functions that provide
    the required functionality. This, however, does not always happen in the most
    efficient way. Sometimes, a function gets linked twice, or a piece of code gets
    used in many places, and in that case, the compiler might decide to duplicate
    some code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配置选项，对于提高应用程序的性能很有用，是链接时间优化。通常，当程序构建时，一旦所有代码都已优化，它就会被链接到其他库和函数，以提供所需的功能。然而，这并不总是以最有效的方式进行。有时，一个函数会被链接两次，或者一段代码会在许多地方使用，在这种情况下，编译器可能会决定复制一些代码。
- en: The program will work perfectly, but this has two main disadvantages—first of
    all, duplicating code and links will make the binary bigger, which is probably
    something you don't want, and secondly, it will reduce the performance. You might
    ask why. Well, since it's the same code being accessed from different places in
    the program, it might make sense that if it gets executed once, it gets added
    to the L1/L2/L3 caches in the processor. This will enable the future reuse of
    these instructions without requiring the processor to get them from the RAM memory
    (much slower) or even the disk/SSD (extremely slow) if the memory has been swapped.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将完美运行，但有两个主要缺点——首先，复制代码和链接会使二进制文件更大，这可能是你不想看到的事情，其次，它将降低性能。你可能会问为什么。好吧，由于相同的代码在程序的不同地方被访问，如果它只执行一次，它可能会被添加到处理器的L1/L2/L3缓存中。这将使得未来可以重用这些指令，而无需处理器从RAM内存（较慢）或甚至从磁盘/SSD（极慢）中获取它们（如果内存已经被交换的话）。
- en: The main advantage when performing **Link-Time Optimizations**, or **LTOs**
    in short, is that while Rust compiles the code file by file, LTOs fit the whole,
    almost final, representation into a big compilation unit that can be optimized
    in its entirety, enabling better execution paths.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行**链接时间优化**，或简称为**LTOs**时，主要优势在于，虽然Rust是按文件编译代码的，但LTOs将整个几乎最终的表示形式放入一个大的编译单元中，可以对其进行整体优化，从而实现更好的执行路径。
- en: This can be performed, of course, but at a really high compilation time cost.
    These optimizations are very costly because they sometimes require changing the
    final representation, the one ready to be written to the binary. Not only that,
    but this requires checking lots of execution paths and code samples to find similar
    blocks. And remember, this is done with the object code, not the Rust code, so
    the compiler doesn't know about libraries or modules; it only sees instructions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可以完成，但代价是编译时间会非常长。这些优化非常昂贵，因为它们有时需要改变最终的表现形式，即准备写入二进制的那个形式。不仅如此，这还需要检查大量的执行路径和代码样本以找到相似的块。记住，这是在对象代码上完成的，而不是Rust代码，所以编译器不知道库或模块；它只看到指令。
- en: 'This costly optimization will improve the performance of your software and
    the size of your binaries, but being so costly (usually taking as much time as
    the rest of the compilation, or even more), it''s not enabled by default in any
    of the profiles. And you should not enable it on any but release and maybe benchmarking
    profiles (you don''t want to wait for an LTO every time you make a small change
    in a function and want to test it). The configuration item to change is the `lto`
    configuration item:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代价高昂的优化将提高你软件的性能和二进制文件的大小，但由于代价如此之高（通常需要与编译的其他部分一样多的时间，甚至更多），它默认情况下在所有配置文件中都没有启用。你不应该在除了发布和可能基准测试配置文件之外的地方启用它（你不想每次在函数中做小改动并想要测试它时都等待LTO）。要更改的配置项是`lto`配置项：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is a related configuration item, which will be ignored if LTO is turned
    on for the given profile. I'm talking about the `codegen` units. This divides
    the code into multiple smaller code units and compiles each of them separately,
    enabling parallel compiling, which improves how fast the program compiles. This
    is one in the case of LTO, but can be modified for the rest. Of course, using
    separate compilation units avoids some optimizations that can improve the performance
    of the code, so it might make sense to enable faster compilation in development
    mode. It will be 16 by default in development mode.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个相关的配置项，如果为给定配置文件开启了LTO，则会被忽略。我指的是`codegen`单元。这把代码分成多个更小的代码单元，并分别编译每个单元，从而实现并行编译，这提高了程序编译的速度。这在LTO的情况下是如此，但也可以对其他情况进行修改。当然，使用单独的编译单元可以避免一些可以提高代码性能的优化，因此，在开发模式下启用更快的编译可能是有意义的。默认情况下，它将是16。
- en: 'This is as simple as changing the `codegen-units` configuration option in the
    development profile:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像更改开发配置文件中的`codegen-units`配置选项一样简单：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An example value could be the number of processors/threads in your computer.
    But remember that this will make the compiled software slower, so do not use it
    in the release profile. It will, in any case, be ignored if you activate the link-time
    optimizations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例值可以是你的计算机中的处理器/线程数。但请记住，这将使编译的软件变慢，所以不要在发布配置文件中使用它。无论如何，如果你激活了链接时间优化，它将始终被忽略。
- en: Debug assertions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试断言
- en: The next interesting configuration item is the one that allows debug assertions
    to be removed. Debug assertions are like normal assertions, but by default they
    are only executed in the development profile. They are written in the code by
    prefixing the `assert!` macros with `debug_`, using for example `debug_assert!`
    or `debug_assert_eq!`. This enables you to fill the whole code with assertions
    that must be true and that take processing cycles to test, while not reducing
    the performance of a release application. Of course, this means that those assertions
    won't run in release mode. This is useful for testing internal methods, but is
    probably not the best for APIs, and certainly not a good idea in unsafe code wrappers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个有趣的配置项是允许移除调试断言的选项。调试断言类似于正常断言，但默认情况下它们仅在开发配置文件中执行。它们通过在`assert!`宏前加上`debug_`前缀来写入代码，例如使用`debug_assert!`或`debug_assert_eq!`。这使您能够在整个代码中填充必须为真且需要处理周期来测试的断言，而不会降低发布应用程序的性能。当然，这意味着这些断言在发布模式下不会运行。这对于测试内部方法很有用，但对于API来说可能不是最好的选择，而且在不安全的代码包装器中肯定不是一个好主意。
- en: For example, the indexing function in the standard library `Vec` object has
    an assertion that will check each time you get an element of the vector by index
    if the index is out of bounds. This is great to avoid buffer overflows, but makes
    the operation of getting an element of the vector slower, and if the index is
    out of bounds, the program will panic. We will talk about this particular example
    later, but in general, it shows how useful these assertions are—in this case for
    release mode also.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，标准库`Vec`对象中的索引函数有一个断言，每次您通过索引获取向量的元素时都会检查索引是否超出范围。这可以很好地避免缓冲区溢出，但会使获取向量元素的运算变慢，如果索引超出范围，程序将崩溃。我们稍后会讨论这个特定的例子，但总的来说，它显示了这些断言是多么有用——在这种情况下，对于发布模式也是如此。
- en: On the other hand, if you plan to create a small internal API that will input
    numbers between `0` and `100` and do some calculations with them, but is not exposed
    to the public, you could simply add a `debug_assert!(num <= 100 && num >= 0)`
    and, in tests and debug mode, it will panic the program if a number outside that
    range is received by the function, but it will not run the assertion in release
    mode. This can be a potential error vector, but with thorough unit testing, the
    odds of not getting the error in testing/development mode and an incorrect number
    being received in release mode are much, much lower. Of course, once again, this
    shouldn't be used for security-focused areas or input that would cause unsafe
    or undefined behavior.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您计划创建一个小的内部API，该API将输入介于`0`和`100`之间的数字并对其进行一些计算，但不对公众公开，您只需添加一个`debug_assert!(num
    <= 100 && num >= 0)`，在测试和调试模式下，如果函数接收到该范围之外的数字，程序将恐慌，但在发布模式下不会运行这个断言。这可能会成为一个潜在的错误向量，但通过彻底的单元测试，测试/开发模式下未获得错误以及在发布模式下接收到错误数字的概率要低得多。当然，再次强调，这不应该用于安全重点区域或可能导致不安全或未定义行为的输入。
- en: 'By default, as explained, these assertions run in development, testing, and
    documentation modes. This last one is useful if you have documentation tests with
    debug assertions. This can be configured, in any case, easily, by changing the
    `debug-assertions` configuration option. For example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如解释所述，这些断言在开发、测试和文档模式下运行。最后一个模式在您有带有调试断言的文档测试时很有用。在任何情况下，都可以通过更改`debug-assertions`配置选项轻松地进行配置。例如：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Panic behavior
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 潘克行为
- en: 'The next configuration variable to check is the panic behavior. By default,
    Rust will unwind in a panic. This means that it will call each destructor of each
    variable in the stack if something goes terribly wrong and the application panics.
    There is another option: not calling anything and simply aborting the program
    (the standard C/C++ behavior).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要检查的配置变量是恐慌行为。默认情况下，Rust会在恐慌时进行堆栈展开。这意味着如果发生严重错误并且应用程序恐慌，它将调用堆栈中每个变量的每个析构函数。还有一个选项：不调用任何东西，只是简单地终止程序（这是标准C/C++的行为）。
- en: The main advantage of the unwind is that you will be able to call the destructors,
    so any cleanup that should be done for your variables in the stack of the program
    will be done properly. The main advantage of the `abort` behavior is that it will
    require much less code to be compiled, since for each potential panic location
    a new branch gets added to the code where all the destructors are run. It also
    gives the code much fewer branches, which makes it easier to optimize, but the
    main advantage is smaller binaries. Of course, you lose the ability to run the
    destructors, so some complex behavior might not be properly cleaned, for example,
    if you need to write something to a log upon shutdown.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: unwind 的主要优势是，你将能够调用析构函数，因此程序堆栈中变量的任何清理工作都将得到妥善处理。`abort` 行为的主要优势是，它将需要编译更少的代码，因为对于每个潜在的panic位置，代码中都会添加一个新的分支，其中运行所有析构函数。它还使代码具有更少的分支，这使得优化更容易，但主要优势是更小的二进制文件。当然，你失去了运行析构函数的能力，因此某些复杂的行为可能无法得到适当的清理，例如，如果你需要在关闭时向日志写入某些内容。
- en: 'If you still think that in your use case, using the `abort` behavior is a good
    idea, you can enable it by using the `panic` keyword:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然认为在你的用例中，使用 `abort` 行为是一个好主意，你可以通过使用 `panic` 关键字来启用它：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Runtime library paths
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时库路径
- en: The last configuration option is `rpath`. This configuration item accepts a
    Boolean and allows you to ask the Rust compiler to set loader paths when the executable
    looks OK for libraries at runtime. Even though, most of the time, Rust will link
    crates and libraries statically, you can ask a specific library to be linked dynamically.
    In this case, that library will be searched at runtime, not at compile time, and
    it will therefore use system libraries installed where the program is running.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个配置选项是 `rpath`。此配置项接受一个布尔值，允许你要求 Rust 编译器在可执行文件在运行时查找库时设置加载器路径。尽管如此，大多数时候
    Rust 会将crate和库静态链接，但你可以要求特定的库以动态方式链接。在这种情况下，该库将在运行时而不是编译时搜索，因此它将使用程序运行所在位置的系统库。
- en: This configuration option asks cargo to add `-C rpath` to the `rustc` compiler
    invocation. This will add paths to the dynamic library search paths. Nevertheless,
    this should not be required in most cases, and you should avoid it if it's not
    necessary by using `false` as the option value. If you are having issues making
    your application run in multiple operating systems, you might try it, since it
    might make the executable look for dynamic libraries in new places.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置选项要求 cargo 在 `rustc` 编译器调用时添加 `-C rpath`。这将添加到动态库搜索路径中。尽管如此，在大多数情况下，这不应该被需要，如果你不必要的话，应该通过使用
    `false` 作为选项值来避免它。如果你在使你的应用程序在多个操作系统上运行时遇到问题，你可能可以尝试它，因为它可能会使可执行文件在新位置查找动态库。
- en: Translation issues
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译问题
- en: When translating your C/C++/Java mindset, or directly porting a project to Rust,
    you might find yourself writing similar code to what you wrote in your native
    language, but if you have tried it, you might have noticed that it performs poorly,
    or at least much worse than your old code. This happens, especially with C/C++,
    since in the case of Java the performance issue is much lower compared to the
    high memory and computation footprint of a Java application, with its Java Virtual
    Machine and its garbage collector.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 C/C++/Java 思维方式翻译过来，或者直接将项目移植到 Rust 时，你可能会发现自己写的代码与你用母语写的代码相似，但如果你尝试过，你可能已经注意到它的性能不佳，或者至少比旧代码差得多。这种情况在
    C/C++ 中尤其如此，因为与 Java 应用程序相比，Java 的性能问题要低得多，Java 应用程序具有 Java 虚拟机和垃圾回收器，内存和计算占用都很大。
- en: But why does a direct translation hurt the performance? We will see in this
    section how Rust's guarantees can sometimes create unnecessary boilerplate instructions,
    and we will learn how to bypass them by using safe and efficient code. Of course,
    in some performance-critical situations, unsafe scopes might be needed, but in
    general, that's not the case.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么直接翻译会损害性能？在本节中，我们将看到 Rust 的保证有时会创建不必要的样板指令，我们将学习如何通过使用安全和高效的代码来绕过它们。当然，在某些性能关键的情况下，可能需要使用不安全的作用域，但通常情况下并非如此。
- en: Indexing degradations
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引退化
- en: 'Let''s start with a simple example. This Rust code will perform poorly:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。以下 Rust 代码将表现不佳：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will, of course, work, and it''s perfectly safe. We create an index that
    goes from `0` to the length of the array (`6` in this case), but exclude the last
    one, so the `i` binding will take the values `0`, `1`, `2`, `3`, `4`, and `5`.
    For each of them, it will get the element at that index in the array and print
    it in a new line. There is one problem with this approach though. In C/C++, an
    equivalent code will simply add the size of the element to the pointer in the
    array and get the next element, but that sometimes causes issues. Look at this
    code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会起作用，并且是完全安全的。我们创建一个从`0`到数组长度（在这个例子中是`6`）的索引，但不包括最后一个，所以`i`绑定将取值`0`、`1`、`2`、`3`、`4`和`5`。对于每一个，它将获取数组中该索引处的元素并在新的一行中打印它。然而，这种方法有一个问题。在C/C++中，等效的代码将简单地向数组中的指针添加元素的大小，以获取下一个元素，但有时这会导致问题。看看这段代码：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we are iterating until the array length + 1, and since ranges
    are exclusive, the last index will be 6\. This means it will try to get the seventh
    element in the array, but there is no seventh element. In C/C++, this will create
    a buffer overflow and will get whatever is next in the memory. In the case that
    this memory is outside the program, you will get a segmentation fault, but if
    it's part of the program, it will print whatever was in that position, leading
    to leaks. Of course, that is not possible in Rust, since Rust is a memory-safe
    language, so what will happen?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们迭代到数组长度加一，由于范围是排他的，最后一个索引将是6。这意味着它将尝试获取数组中的第七个元素，但数组中没有第七个元素。在C/C++中，这将创建一个缓冲区溢出，并获取内存中的下一个内容。如果这个内存超出了程序的范围，你将得到一个段错误，但如果它是程序的一部分，它将打印出那个位置的内容，导致泄漏。当然，在Rust中这是不可能的，因为Rust是一种内存安全的语言，所以会发生什么呢？
- en: Well, the answer is surprising—it will panic the program, unwind the stack (call
    all the destructors of all the variables in the stack), and exit the program safely
    without trying to access invalid memory. Depending on your perspective, you might
    think *great, I will no longer have buffer overflows*, or you might think *oh
    my God, the whole server will go down to prevent a buffer overflow*. Well, the
    second can be mitigated by stopping the panic and recovering the proper server
    state, already implemented in most frameworks, so it's mostly a win-win.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，答案令人惊讶——它会惊慌程序，撤销栈（调用栈中所有变量的析构函数），并安全地退出程序，而不尝试访问无效内存。根据你的观点，你可能认为“太好了，我将不再有缓冲区溢出”，或者你可能认为“哦，我的天哪，整个服务器都会崩溃以防止缓冲区溢出”。然而，第二种情况可以通过停止惊慌并恢复适当的服务器状态来缓解，这已经在大多数框架中实现，所以这基本上是一个双赢的局面。
- en: 'But is it? How does Rust know if the index is out of bounds? In this simple
    example, the compiler could know that the `arr` variable has only six elements,
    so trying to access the seventh would violate memory constraints. But what about
    this more complex program:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是真的吗？Rust是如何知道索引是否越界的呢？在这个简单的例子中，编译器可以知道`arr`变量只有六个元素，所以尝试访问第七个将违反内存约束。但关于这个更复杂的程序：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here I'm receiving an HTTP request (very naively represented) that has at least
    one `content_length` attribute and one `data` attribute. The first should contain
    the length of the data field, in a number of bytes, while the second will be a
    vector of bytes. Let's suppose we don't have the `len()` function in that data
    field, and that we trust the `content_length` attribute. What if somebody were
    to send us an invalid request with a bigger `content_length` than the actual length
    of the content? The compiler wouldn't know this in advance because the request
    originated at runtime from a TCP connection, but again, Rust must always be memory-safe
    (unless working in an unsafe scope, which is not the case).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我接收到一个至少包含一个`content_length`属性和一个`data`属性的HTTP请求（非常天真地表示）。第一个应该包含数据字段长度的字节数，而第二个将是一个字节数组。假设我们没有那个数据字段中的`len()`函数，并且我们信任`content_length`属性。如果有人发送一个包含比内容实际长度更大的`content_length`的无效请求怎么办？编译器在请求运行时从TCP连接中产生之前不会知道这一点，但同样，Rust必须始终是内存安全的（除非在不可安全的作用域中工作，这在本例中不是情况）。
- en: Well, what happens is that the index operation has two parts. First, it checks
    the bounds of the slice, and if the index is fine, it will return the element;
    if not, it will panic. And yes, it does this for every indexing operation. So
    in this case, if the request is a valid request with a supposed 1 million bytes
    (1 MB), it will compare the index to the length of the vector 1 million times.
    That is at least 2 million extra instructions (the comparison and the branching
    for each, at least). That becomes much less efficient than the equivalent C/C++
    code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，发生的事情是索引操作有两个部分。首先，它检查切片的界限，如果索引是正确的，它将返回元素；如果不正确，它将引发恐慌。是的，它对每个索引操作都这样做。所以在这种情况下，如果请求是一个有效的请求，假设有100万个字节（1
    MB），它将1百万次比较索引与向量的长度。这至少是200万个额外的指令（每个比较和分支至少）。这比等效的C/C++代码效率低得多。
- en: Using iterators
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: 'There is a way around this, though, that gives the same effect as the C/C++
    code: using iterators. The previous code can be converted into the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种方法可以绕过这个问题，达到与C/C++代码相同的效果：使用迭代器。之前的代码可以转换为以下：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will compile roughly to the same machine code as the C/C++ variant since
    it won't check the bounds of the slice more than once, and it will then use the
    same pointer arithmetic. This is great when iterating through a slice, but in
    the case of a direct lookup, it can be an issue. Suppose we will receive thousands
    of 100-element slices, and we are supposed to get the last element of each and
    print it. In this case, iterating through all 100 elements of each array just
    to get the last one is a bad idea, as it would be more efficient to bounds check
    just the last element. There are a couple of ways of doing this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将大致编译成与C/C++变体相同的机器代码，因为它不会多次检查切片的界限，然后使用相同的指针算术。这在迭代切片时很好，但在直接查找的情况下可能会出现问题。假设我们将收到成千上万的100元素切片，我们需要获取每个切片的最后一个元素并打印它。在这种情况下，为了只获取最后一个元素，遍历每个数组中的所有100个元素是不明智的，因为这会更有效率，只需检查最后一个元素的界限。有几种方法可以做到这一点。
- en: 'The first one is straightforward:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是最直接的：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this concrete case, where we want to get the last element, we can do something
    like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个具体案例中，我们想要获取最后一个元素，我们可以这样做：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will reverse the iterator with the call to `rev()` and then get the next
    element (the last one). If it exists, it will print it. But if we have to get
    a number that is not close to the end or to the beginning of the slice, the best
    way is to use the `get()` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过调用`rev()`来反转迭代器，然后获取下一个元素（最后一个元素）。如果存在，它将打印它。但是，如果我们需要获取一个不接近切片末尾或开头的数字，最好的方法就是使用`get()`方法：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This last one has a double bound check, though. It will first check if the
    index is correct to return a `Some(elt)` or a `None`, and then the last check
    will see if the returned element is `Some` or `None`. If we know for sure, and
    I mean 100% sure, that the index is always inside the slice, we can use `get_unchecked()`
    to get the element. This is an exact equivalent to the C/C++ indexing operation,
    so it will not do bounds checking, allowing for better performance, but it will
    be unsafe to use. So in the HTTP example before, an attacker would be able to
    get what was stored in that index even if it was a memory address outside the
    slice. You will need to use an unsafe scope, of course:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最后一个有双重界限检查。它将首先检查索引是否正确以返回`Some(elt)`或`None`，然后最后一个检查将查看返回的元素是`Some`还是`None`。如果我们确实知道，我是指100%确定，索引始终在切片内，我们可以使用`get_unchecked()`来获取元素。这是C/C++索引操作的精确等效，因此它不会进行界限检查，允许更好的性能，但使用它是不安全的。所以，在之前的HTTP示例中，攻击者能够获取存储在该索引中的内容，即使它是一个切片之外的内存地址。当然，您需要使用一个不安全的作用域：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `get_unchecked()` function will always return something or segfault, so
    no need to check if it's `Some` or `None`. Remember also that upon a segfault,
    this will not panic, and no destructors will be called. It should only be used
    if a safe alternative would not meet the performance requirements and if the bounds
    of the slice were previously known.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_unchecked()`函数将始终返回某些内容或段错误，因此不需要检查它是`Some`还是`None`。记住，在段错误发生时，这不会引发恐慌，并且不会调用析构函数。它只应在没有安全替代方案且切片界限已知的情况下使用。'
- en: In most cases, you will want to use an iterator. Iterators allow for precise
    iteration of elements, even filtering them, skipping some, taking a maximum amount
    of them, and finally, collecting them into a collection. They can even be extended
    or joined with other iterators to allow for any kind of solution. Everything gets
    managed by the `std::iter::Iterator` trait. You now understand the most-used methods
    of the trait, and I leave the rest to you to research in the standard library
    documentation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你将想要使用一个迭代器。迭代器允许精确地迭代元素，甚至过滤它们，跳过一些，取最大数量的它们，最后将它们收集到一个集合中。它们甚至可以被扩展或与其他迭代器连接起来，以允许任何类型的解决方案。所有这些都由`std::iter::Iterator`特质管理。你现在已经理解了特质的常用方法，其余的留给你在标准库文档中研究。
- en: It's important to properly use and understand iterators since they will be very
    useful for doing really fast loops. Iterators are cost-free abstractions that
    work the same way as indexing, but will not require bounds checking, making them
    ideal for efficiency improvements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用和理解迭代器非常重要，因为它们对于执行真正快速的循环非常有用。迭代器是无成本的抽象，它们的工作方式与索引相同，但不需要边界检查，这使得它们非常适合效率提升。
- en: Iterator adaptors
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器适配器
- en: 'Let''s start with the most simple method. The basic method for the rest to
    work is the `next()` method. This function will return either the next element
    in the iteration or a `None` if the iterator has been consumed. This can be used
    to manually get the next element, or to create a for using a `while`, for example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的方法开始。其余方法的基本方法是`next()`方法。这个函数将返回迭代中的下一个元素，或者如果迭代器已经被消耗，则返回`None`。这可以用来手动获取下一个元素，或者创建一个使用`while`的`for`循环，例如：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That would be the same as this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等同于以下内容：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note the `&` before the array variable in the `for`. This is because the basic
    array type does not implement the `Iterator` trait, but a reference to the array
    is a slice, and slices implement the `IntoIterator` trait, which makes it usable
    as an iterator.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`for`中的数组变量前面的`&`。这是因为基本数组类型没有实现`Iterator`特质，但数组的引用是一个切片，而切片实现了`IntoIterator`特质，这使得它可以作为一个迭代器使用。
- en: 'The next two methods you should know about are the `skip()` and the `take()`
    methods. These make it easy to get only the correct members of a known ordered
    iterator. For example, let''s say we want to take from the third to the tenth
    element of an iterator with unknown length (at least 10 elements). In this case,
    the best thing would be to skip the first two and then take the next eight. We
    then collect them in a vector. Note that the iterator will not run until you call
    `collect()` method or use it in a loop. Those are the moments in which the `next()`
    method gets executed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解的下一个两个方法是`skip()`和`take()`方法。这些方法使得获取已知有序迭代器的正确成员变得容易。例如，假设我们想要从一个长度未知的迭代器中取出第三到第十个元素（至少有10个元素）。在这种情况下，最好的办法是跳过前两个，然后取出接下来的八个。然后我们将它们收集到一个向量中。请注意，迭代器不会运行，直到你调用`collect()`方法或者在一个循环中使用它。这些就是`next()`方法被执行的时刻：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will start iterating through the array, and it will first clone each element.
    That's because by default an iterator will yield references to the elements, and
    in the case of `u8` it's better to copy them than to reference them, as we will
    see at the end of the chapter. The `skip()` method will call `next()` twice and
    discard what it returns. Then, for each `next()` operation, it will return the
    element. Until it calls `next()` eight times, the `take()` method will return
    the element. It will then return `None`. The `collect()` method will create an
    empty vector, and will push elements to it, while the `next()` method returns
    `Some`, then returns the vector.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始遍历数组，并且它将首先克隆每个元素。这是因为默认情况下，迭代器会返回元素的引用，而在`u8`的情况下，最好复制它们而不是引用它们，就像我们在本章末尾将看到的那样。`skip()`方法将调用`next()`两次并丢弃它返回的内容。然后，对于每次`next()`操作，它将返回一个元素。直到它调用`next()`八次，`take()`方法将返回一个元素。然后它将返回`None`。`collect()`方法将创建一个空向量，并将元素推送到它里面，而`next()`方法返回`Some`，然后返回向量。
- en: Note that the `collect()` method requires a type hint, as it can return any
    kind of collection—actually, any type that implements the `FromIterator` trait.
    We simply tell it that it will be a standard library `Vec`, and we let the compiler
    infer the type of element the vector will hold.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`collect()`方法需要一个类型提示，因为它可以返回任何类型的集合——实际上，任何实现了`FromIterator`特质的类型。我们只是简单地告诉它它将是一个标准库的`Vec`，然后让编译器推断向量将持有的元素类型。
- en: 'There are also a couple of functions that are a generalization of the previous
    ones, `skip_while()` and `take_while()`. These two will skip or take elements,
    respectively, while the closure they run returns `true`. Let''s see an example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些函数是前一个函数的泛化，分别是 `skip_while()` 和 `take_while()`。这两个函数分别会在闭包返回 `true` 时跳过或取走元素。让我们看一个例子：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, the `skip_while()` method will run `next()` until it finds an
    element bigger than or equal to `25`. In this case, this is the fourth element
    (index 3), number `76`. The `take_while()` method starts then calling `next()`
    and returning all elements while they are less than or equal to `100`. When it
    finds `143`, it returns `None`. The `collect()` method will then include all those
    elements, from the `76` to the `100`, both included in a vector, and return it.
    Note that the `23` is also added to the final result, since even if it's lower
    than `25`, while the skip method stops skipping, it will never skip again.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`skip_while()` 方法将运行 `next()` 直到找到一个大于或等于 `25` 的元素。在这种情况下，这是第四个元素（索引
    3），数字 `76`。`take_while()` 方法随后调用 `next()` 并返回所有小于或等于 `100` 的元素。当它找到 `143` 时，它返回
    `None`。然后 `collect()` 方法将包括所有这些元素，从 `76` 到 `100`（包括），并将它们放入一个向量中，并返回它。请注意，`23`
    也会被添加到最终结果中，因为即使它小于 `25`，跳过方法停止跳过后，它将永远不会再次跳过。
- en: 'To fine-tune the filtering of the elements in the iteration, some other very
    interesting methods are the `filter()` method and its companion `map()`. The first
    lets you filter elements of an iterator based on a closure, while the second lets
    you map each element to a different one. Let''s explore this by using a simple
    iterator that yields the odd elements of an iterator and collects them into a
    vector:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了微调迭代中元素的过滤，还有一些其他非常有趣的方法，比如 `filter()` 方法及其伴随的 `map()` 方法。第一个方法允许你根据闭包过滤迭代器的元素，而第二个方法允许你将每个元素映射到不同的元素。让我们通过使用一个简单的迭代器来探索这一点，该迭代器产生迭代器的奇数元素并将它们收集到一个向量中：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, we enumerate the iterator by calling to `enumerate()`. That will
    yield a tuple with the index and the element for each `next()` call. This will
    then be filtered by checking the index. If the index is odd, it will be returned
    in the `next()` call; if it's not, it will call `next()` again. This will then
    be mapped, as the filter will also return the tuple. The `map()` function will
    take only the element, discard the index, and return it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过调用 `enumerate()` 来枚举迭代器。这将产生一个元组，包含每次 `next()` 调用的索引和元素。然后，通过检查索引进行过滤。如果索引是奇数，它将在
    `next()` 调用中返回；如果不是，它将再次调用 `next()`。然后，它将被映射，因为过滤也会返回元组。`map()` 函数将只取元素，丢弃索引，并返回它。
- en: 'The filter and map functions can be reduced by using the helpful `filter_map()`
    function, which combines the two of them:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用有用的 `filter_map()` 函数，可以将过滤和映射函数简化，该函数结合了这两个功能：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `filter_map()` adaptor expects a closure that will return `Some(element)`
    when it should return the element, and `None` when it should retry and call `next()`.
    This will avoid some extra code. In this concrete case, you can also use the `step_by()`
    method, which only returns one element every *n* elements. In this case, using
    a two-step will have the same effect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_map()` 转换器期望一个闭包，当应该返回元素时返回 `Some(element)`，当应该重试并调用 `next()` 时返回 `None`。这将避免一些额外的代码。在这个具体案例中，你也可以使用
    `step_by()` 方法，它只返回每 *n* 个元素中的一个。在这种情况下，使用两步将产生相同的效果。'
- en: 'When trying to do calculations with iterators, instead of using a `for`, we
    can use the great `fold()` method. This will hold a variable between each call
    to `next()` that you will be able to update. That way, you can sum, multiply,
    and perform any other operation in the iterator. Let''s, for example, perform
    the sum of all the elements of the iterator:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用迭代器进行计算时，我们不必使用 `for` 循环，而是可以使用伟大的 `fold()` 方法。这个方法会在每次调用 `next()` 之间保持一个变量，你可以更新它。这样，你可以在迭代器中求和、乘法，以及执行任何其他操作。例如，让我们求迭代器中所有元素的总和：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will print `985`, without needing a loop. Of course, this will be implemented
    with a loop under the hood, but for the programmer, it's a zero-cost abstraction
    that helps a lot in terms of simplifying the code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印 `985`，而不需要循环。当然，这将在底层使用循环实现，但对于程序员来说，这是一个零成本的抽象，有助于简化代码。
- en: Real-life example
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界的例子
- en: 'As a real-life example, here is the *VSOP87* algorithm''s variable function
    implemented with a `fold()` method. The *VSOP87* algorithm is used to find planets
    and moons in the sky with really good accuracy, useful for simulators and telescope
    star finders, for example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为现实生活中的例子，这里是用`fold()`方法实现的*VSOP87*算法的变量函数。*VSOP87*算法用于在天空中发现行星和卫星，具有非常好的精度，对于模拟器和望远镜星象仪等非常有用：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is equivalent to this other code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下其他代码：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And in C/C++, this would probably require a structure to hold the tuple. Five
    lines reduced to one with the same native code. As we talked about, this has no
    extra cost and will be compiled to the same machine code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 而在C/C++中，这可能需要一个结构来保存元组。五行代码简化为了一行，同时保持了原生代码。正如我们之前讨论的，这没有额外的成本，并且将被编译成相同的机器代码。
- en: Specialized adaptors
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专门适配器
- en: 'In the case of a summation or a multiplication, there are specialized methods:
    the `sum()` and the `product()` methods. These methods will do the same as the `fold()`
    method that is used to add all the numbers in an iterator or to multiply all the
    items of the iterator. The example we saw before can be reduced to this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在求和或乘法的情况下，有一些专门的方法：`sum()`和`product()`方法。这些方法将执行与`fold()`方法相同的功能，即用于在迭代器中添加所有数字或乘以迭代器中的所有项。我们之前看到的例子可以简化为这个：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Type annotations are required for now, but the code looks much simpler. You
    can also use the `product()` function in the same way, and it will be equivalent
    to this code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前需要类型注解，但代码看起来更简单。你还可以以相同的方式使用`product()`函数，它将等同于以下代码：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Interaction between adaptors
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器之间的交互
- en: 'There are also some functions to control how the iterators interact with other
    iterators or even themselves. For example, the `cycle()` function will make the
    iterator start again from the beginning once it gets to the end of the iterator.
    This is useful to create an infinite loop with an iterator. There are also a couple
    of functions that help you deal with multiple iterators at the same time. Let''s
    suppose that you have two slices of the same length and want to generate a new
    vector with that same length, but with each element being the sum of the elements
    with the same index in the slices:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些函数可以控制迭代器如何与其他迭代器或自身交互。例如，`cycle()`函数将在迭代器到达末尾后再次从开头开始。这对于使用迭代器创建无限循环非常有用。还有一些函数可以帮助你同时处理多个迭代器。假设你有两个长度相同的切片，并想生成一个具有相同长度的新的向量，但每个元素都是切片中相同索引的元素之和：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, we have used the `zip()` function that will yield a tuple with
    each element being the next of each iterator. We can also chain them with the
    `chain()` function, which will generate a new iterator that, once the first starts
    yielding `None`, will start yielding elements from the second iterator. There
    are many more iteration functions, but we will leave the standard library here
    for now and focus on external crates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`zip()`函数，它会生成一个元组，其中每个元素都是每个迭代器的下一个元素。我们还可以使用`chain()`函数将它们连接起来，该函数将生成一个新的迭代器，一旦第一个迭代器开始产生`None`，它将开始从第二个迭代器产生元素。还有许多其他的迭代函数，但我们现在先不讨论标准库，而是专注于外部crate。
- en: Itertools
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Itertools
- en: There is one external crate that can make working with iterators much easier,
    and gives you superpowers. Remember the idea that these iterators allow you to
    perform the same operations you would do in C with indexing, but with complete
    memory safety and zero-cost abstractions? They also make the code much easier
    to understand. In terms of iterator capabilities, the most important crate is
    the *itertools* crate. This crate provides a new trait, the `Itertools` trait,
    which gives iterators many new methods and functions that make the life of the
    developer much easier, while staying true to its core values of performance thanks
    to zero-cost abstractions. You can add it to your project by adding it to your
    `Cargo.toml` file in the `[dependencies]` section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个外部crate可以使使用迭代器的工作变得容易得多，并赋予你超级能力。还记得这些迭代器允许你执行在C语言中使用索引会执行的操作的想法吗？但是具有完整的内存安全和零成本抽象？它们还使代码更容易理解。在迭代器功能方面，最重要的crate是*itertools*
    crate。这个crate提供了一个新的trait，即`Itertools` trait，它为迭代器提供了许多新的方法和函数，使开发者的生活变得更加容易，同时保持其核心价值——性能，这得益于零成本抽象。你可以通过将它们添加到`Cargo.toml`文件中的`[dependencies]`部分来将它们添加到你的项目中。
- en: 'Let''s explore some of its iterator adapters. We start with a simple one that
    helps us create batches or chunks of the given iterator, the `batching()` function.
    Let''s say that we want to use an iterator over one of the previous arrays and
    we want to make it return elements in groups of three. It''s as simple as using
    that method and creating a closure that directly calls the `next()` method and
    returns the required tuple:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些它的迭代器适配器。我们从一个简单的适配器开始，它帮助我们创建给定迭代器的批次或块，即 `batching()` 函数。假设我们想要使用一个迭代器遍历之前的数组，并希望它以三组元素的形式返回元素。这就像使用该方法并创建一个直接调用
    `next()` 方法并返回所需元组的闭包一样简单：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will print the array in groups of three elements, in order:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按顺序以三个元素为一组打印数组：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A similar operation can be accomplished by using the `chunks()` function. We
    can say that the `batching()` adaptor is a generalization of the `chunks()` adaptor,
    since it gives you the option to create the internal logic of the function. In
    the case of `chunks()`, it will only receive as a parameter the number of elements
    in a chunk, and it will return slices to those chunks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `chunks()` 函数完成类似的操作。我们可以说，`batching()` 适配器是 `chunks()` 适配器的泛化，因为它为你提供了创建函数内部逻辑的选项。在
    `chunks()` 的情况下，它将只接收块中元素的数量作为参数，并返回这些块的切片。
- en: 'A really similar operation will be performed with the `tuples()` method. As
    you can see, the `batching()` method is a complete generalization in terms of
    how you create batches or chunks of an iterator. Let''s see the same example we
    saw previously using the `tuples()` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tuples()` 方法将执行一个非常类似的操作。正如你所见，`batching()` 方法在创建迭代器的批次或块方面是一个完全的泛化。让我们看看之前用
    `tuples()` 方法看到的相同示例：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Much less boilerplate code, right? In this case, we are required to specify
    the number of elements in a tuple, but if we used type inference in the `for`,
    we could avoid it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 代码量大大减少，对吧？在这种情况下，我们需要指定元组中的元素数量，但如果我们在 `for` 循环中使用类型推断，就可以避免这样做：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of course, in this case, we would be pattern-assigning the variables. There
    is also another interesting function that allows for creating the cartesian product
    of two iterators.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，我们将进行模式赋值。还有一个有趣的功能允许创建两个迭代器的笛卡尔积。
- en: 'Unsurprisingly, the name is `cartesian_product()`. This will create a new iterator
    with all possible combinations of the previous two:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，函数名是 `cartesian_product()`。这将创建一个新的迭代器，包含前两个迭代器所有可能的组合：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will print the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are many other methods in the `Itertools` trait, and I invite you to check
    the official documentation, since it's very detailed and has many examples. For
    now, these common methods should help you do any operation you need to perform
    with slices in a much more efficient way.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Itertools` 特性中还有许多其他方法，我邀请你查看官方文档，因为它非常详细，有很多示例。现在，这些常用方法应该可以帮助你以更高效的方式执行任何需要用切片执行的操作。'
- en: Borrowing degradations
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用退化
- en: 'Iterations are not the only place where translation degradations occur. There
    are also a couple of extra points where you can sometimes see that the same code
    performs much worse in Rust than in C/C++. One of these points is reference handling.
    Due to borrow checker constraints, you can do three things with variables when
    passing them to a function: send a reference (borrow), give the new function control
    of the variable (own), or copy/clone the variable to send it to a function. It
    seems easy to decide, right? If you do not require the variable anymore, let the
    function own your variable. If you require it, send the reference, and if you
    require it and the API only accepts ownership, clone it.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译退化不仅发生在迭代过程中。还有一些额外的点，有时你可以看到相同的代码在 Rust 中的性能比 C/C++ 差得多。其中一个点是引用处理。由于借用检查器的限制，当你将变量传递给函数时，你可以对变量做三件事：发送一个引用（借用）、将变量的控制权交给新函数（拥有），或者复制/克隆变量以将其发送到函数。这似乎很容易决定，对吧？如果你不再需要变量，让函数拥有你的变量。如果你需要它，发送引用，如果你需要它且
    API 只接受拥有，就克隆它。
- en: Well, it actually isn't so simple. For example, integers are faster to copy
    than to reference, and so are small structures. The rule of thumb is, if it's
    smaller than or equal to `usize`, copy, always. If it's somewhere between `usize`
    and 10 times that size, it's probably better to copy. If it's bigger, it's probably
    better to reference. If the structure has a heap allocation (such as a `Vec` or
    a `Box`), it's usually better to send a reference.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上并不那么简单。例如，整数比引用更快地复制，小型结构也是如此。一般来说，如果它的大小小于或等于`usize`，就复制，总是如此。如果它在`usize`和10倍大小之间，可能最好复制。如果更大，可能最好引用。如果结构有堆分配（例如`Vec`或`Box`），通常最好传递一个引用。
- en: There are some cases, though, when you cannot decide what happens to the variable.
    In a macro, for example, the variable is passed as is, and the macro decides what
    to do with it. For example, the `println!` macro gets all elements by reference,
    since it does not require more. The problem is that if you are trying to print
    an integer, for example, a bottleneck appears. That's what happened some time
    ago to Robert Grosse, and he wrote an article about it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些情况下，你无法决定变量的去向。例如，在宏中，变量是原样传递的，宏决定如何处理它。例如，`println!`宏通过引用获取所有元素，因为它不需要更多。问题是，如果你试图打印一个整数，例如，会出现瓶颈。这就是罗伯特·格罗斯（Robert
    Grosse）之前遇到的情况，他写了一篇文章关于这件事。
- en: 'Long story short, he had to force the copying of the integer. How did he do
    that? Well, it''s as simple as creating a scope that will return that integer.
    Since integers implement `Copy`, the integer will be copied to the scope and then
    returned, effectively copying it to the macro:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，他不得不强制复制整数。他是怎么做到的？嗯，这就像创建一个会返回那个整数的范围一样简单。由于整数实现了`Copy`，整数将被复制到范围中，然后返回，实际上是将它复制到了宏中：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For normal prints, this is not usually necessary, but if you need to quickly
    print thousands or millions of integers, you will not avoid the I/O interface,
    but you can at least avoid this bottleneck.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正常的打印，这通常不是必要的，但如果你需要快速打印成千上万或数百万个整数，你将无法避免I/O接口，但至少可以避免这个瓶颈。
- en: Cyclomatic complexity
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 圈复杂度
- en: Another possible bottleneck is the cyclomatic complexity of functions. While
    not directly related to the translation of code from other languages, it's true
    that Rust can sometimes increase the cyclomatic complexity of the code, since
    it forces you to check for optional (nullable) results, some complex iterators,
    functional programming, and so on. This is great for code security, but sometimes
    the compiler has issues properly optimizing the code we write.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的瓶颈是函数的圈复杂度。虽然它与将代码从其他语言翻译过来没有直接关系，但确实，Rust有时会增加代码的圈复杂度，因为它迫使你检查可选（可空）的结果，一些复杂的迭代器，函数式编程等等。这对于代码安全性来说是个好事情，但有时编译器在优化我们编写的代码时会出现问题。
- en: The only way to avoid this is to separate the code into smaller code units that
    will help the compiler optimize better unit by unit. One way of doing that is
    by creating smaller functions, with no more than 20–25 branches each. A branch
    is a place where, depending on one variable, the program will run one code or
    another. The simplest branch is conditional, an `if`. There are many others, such
    as loops (especially when the loop contains returns) or the `?` operator. This
    will create two branches, one for each result option. One of them will return
    the function while the other will assign the variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的唯一方法是将代码分成更小的代码单元，这将有助于编译器逐个优化。实现这一目标的一种方法是通过创建更小的函数，每个函数不超过20-25个分支。分支是程序根据一个变量的值运行一个代码或另一个代码的地方。最简单的分支是条件分支，一个`if`。还有很多其他分支，比如循环（特别是当循环包含返回时）或`?`运算符。这将创建两个分支，每个结果选项一个。其中一个将返回函数，而另一个将分配变量。
- en: Nested loops and conditionals make this list grow larger, and the branches can
    be more and more complex, so you will have to try to divide those deeply nested
    conditionals in new functions. It's even considered a good practice. As you will
    see in the *Tools* section, there are tools that will help you find these bottlenecks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环和条件语句会使这个列表变得更大，分支可以变得越来越复杂，因此你将不得不尝试将这些深层嵌套的条件语句划分到新的函数中。这甚至被认为是一种良好的实践。正如你将在*工具*部分看到的那样，有一些工具可以帮助你找到这些瓶颈。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to avoid the most common errors new Rust programmers
    encounter, and we found out how Rust performs some operations so that we could
    take advantage of them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何避免新Rust程序员遇到的最常见错误，并了解了Rust如何执行某些操作，以便我们可以利用它们。
- en: We saw how to configure the build system to allow for precise compilation. You
    can now set up the optimization passes, the link-time optimizations, or the panic
    behavior, among many other things.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何配置构建系统以允许精确编译。你现在可以设置优化过程、链接时优化或恐慌行为，以及其他许多事情。
- en: You have now also mastered iterators, and are now able to stop indexing slices,
    gaining valuable computation cycles. You also found out about the *Itertools*
    crate, and you can now use it to perform complex operations with iterators.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经掌握了迭代器，并且能够停止索引切片，从而获得宝贵的计算周期。你还发现了*Itertools*包，现在你可以使用它来对迭代器执行复杂操作。
- en: Finally, you learned a couple of tricks on cyclomatic complexity, and you learned
    how borrowing or copying can affect the way the program works.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了一些关于循环复杂度的技巧，并了解了借用或复制如何影响程序的工作方式。
- en: From now on, we will enter the world of more complex issues, which can sometimes
    be difficult to understand for new developers. We will embrace the full power
    of the Rust programming language to create fast and safe applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将进入更复杂的问题的世界，这些问题有时对新开发者来说可能难以理解。我们将充分利用Rust编程语言的全部功能来创建快速且安全的应用程序。
