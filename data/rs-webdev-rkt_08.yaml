- en: '*Chapter 6*: Implementing User CRUD'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：实现用户CRUD'
- en: In the previous chapter, we created a rough outline for the application. In
    this chapter, we are going to implement the endpoints for managing users. By implementing
    the endpoints in this chapter, you are going to learn about HTTP basic operations
    for an entity, that is, creating, reading, updating, and deleting an entity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为应用程序创建了一个大致的轮廓。在本章中，我们将实现管理用户的端点。通过在本章中实现端点，你将了解实体的HTTP基本操作，即创建、读取、更新和删除实体。
- en: In addition, you are going to learn how to construct HTML and an HTML form,
    send the form payload to the server, validate and sanitize the form payload, hash
    the password payload, and handle failure by redirecting to another endpoint with
    a message.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将学习如何构建HTML和HTML表单，将表单有效负载发送到服务器，验证和清理表单有效负载，散列密码有效负载，并通过将消息重定向到另一个端点来处理失败。
- en: Along with implementing the endpoints, you will also learn how to query single
    and multiple rows from the database, and how to insert, update, and delete a row
    from the database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现端点的同时，你还将学习如何从数据库中查询单行和多行，以及如何从数据库中插入、更新和删除一行。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Implementing GET user
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现GET用户
- en: Implementing GET users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现GET用户
- en: Implementing POST user
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现POST用户
- en: Implementing PUT and PATCH user
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现PUT和PATCH用户
- en: Implementing DELETE user
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现DELETE用户
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们与上一章有相同的技术要求。我们需要一个Rust编译器、一个文本编辑器、一个HTTP客户端和一个PostgreSQL数据库服务器。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节中找到源代码：[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06)。
- en: Implementing GET user
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现GET用户
- en: 'Let''s look at the steps to implement this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现这一步骤：
- en: 'We''ll start with the basics by implementing the `get_user()` function in `src/routes/user.rs`:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从实现`src/routes/user.rs`中的`get_user()`函数的基本知识开始：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before we implement `get_user()`, we want to prepare the other routines that
    we will use. For example, we want to return HTML, so we need to create a `const`
    of `&'static str` in the same `src/routes/user.rs` file as our HTML template.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现`get_user()`之前，我们想要准备我们将要使用的其他例程。例如，我们想要返回HTML，因此我们需要在同一个`src/routes/user.rs`文件中创建一个`const`的`&'static
    str`，作为我们的HTML模板。
- en: 'We will create two separate instances of `const` so we can insert different
    contents between the HTML prefix and suffix:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建两个独立的`const`实例，这样我们就可以在HTML前缀和后缀之间插入不同的内容：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After that, we will create two methods for a `User` struct. The first one is
    the find method to find the entry in the database server, and the second one is
    to create an HTML string for a `User` instance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将为`User`结构体创建两个方法。第一个是查找数据库服务器中的条目，第二个是为`User`实例创建HTML字符串。
- en: 'In the `src/models/user.rs` file, add the following lines to the `use` directives:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/user.rs`文件中，向`use`指令中添加以下行：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, create an `impl` block for `User`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为`User`创建一个`impl`块：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the block, add the `find()` method:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在块内部，添加`find()`方法：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We created a similar method before. The first thing we do is parse the UUID
    (Universal Unique Identifier) `&str` into a `Uuid` instance and use the question
    mark operator (`?`) to quickly return `Box<dyn Error>`. After that, we define
    the SQL query string, `query_str`, and finally, we return the `User` instance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了一个类似的方法。我们首先做的事情是将UUID（通用唯一标识符）`&str`解析为`Uuid`实例，并使用问号运算符（`?`）快速返回`Box<dyn
    Error>`。之后，我们定义SQL查询字符串`query_str`，最后，我们返回`User`实例。
- en: One thing a little different here is that we are passing the mutable reference
    to `PgConnection` itself, instead of a mutable reference to `Connection<DBConnection>`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点不同，我们传递的是`PgConnection`本身的可变引用，而不是`Connection<DBConnection>`的可变引用。
- en: 'Remember previously, we used `Connection<DBConnection>` as in the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记得之前，我们使用的是`Connection<DBConnection>`，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We first dereference `db` using an asterisk (`*`) operator. The connection implements
    `std::ops::Deref`, and its implementation exposes the new type, `DBConnection`,
    which is a wrapper for `sqlx::PgPool`, an alias to `sqlx::Pool<sqlx::Postgres>`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用星号 (`*`) 操作符解引用 `db`。连接实现了 `std::ops::Deref`，其实现公开了新类型 `DBConnection`，这是一个
    `sqlx::PgPool` 的包装器，是 `sqlx::Pool<sqlx::Postgres>` 的别名。
- en: The `sqlx::Executor` trait is implemented for `sqlx::PgConnection`, a struct
    that implements the `sqlx::Connection` trait, representing a single connection
    to the database. The `sqlx::Executor` trait is also implemented for `&sqlx::Pool`,
    an asynchronous pool of SQLx database connections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlx::Executor` 特性为 `sqlx::PgConnection` 实现，这是一个实现了 `sqlx::Connection` 特性的结构体，代表对数据库的单个连接。`sqlx::Executor`
    特性也为 `&sqlx::Pool` 实现，这是一个异步的 SQLx 数据库连接池。'
- en: Since various `sqlx` methods (such as `fetch_all`, `fetch_one`, `fetch_many`,
    `fetch`, `execute`, and `execute_many`) accept the generic type `E`, which is
    bound by the `sqlx::Executor` trait, we can use either the reference to the pool
    itself or the connection obtained from the pool in those methods.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种 `sqlx` 方法（如 `fetch_all`、`fetch_one`、`fetch_many`、`fetch`、`execute` 和 `execute_many`）接受泛型类型
    `E`，该类型由 `sqlx::Executor` 特性绑定，因此我们可以使用连接池本身的引用或从池中获取的连接来使用这些方法。
- en: There's a problem with the `find()` method since `OurDateTime` is a type unknown
    by `sqlx`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `find()` 方法中的 `OurDateTime` 类型是 `sqlx` 所未知的，因此存在问题。
- en: 'Add the following directive in `src/models/our_date_time.rs`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/models/our_date_time.rs` 中添加以下指令：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `transparent` directive automatically generates implementations referring
    to the implementation of the inner type, which in our case is `DateTime<Utc>`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`transparent` 指令自动生成引用内部类型实现的实现，在我们的例子中是 `DateTime<Utc>`。'
- en: 'Beside the `find()` method, let''s implement another method to convert `User`
    to an HTML `String`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了 `find()` 方法之外，让我们再实现另一个方法，将 `User` 转换为 HTML `String`：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the `OurDateTime` member is private but we access it like `self.created_at.``.to_rfc3339()`,
    it''s going to create an error when we compile it. To resolve it, convert the
    member of `OurDateTime` in `src/models/our_date_time.rs` to public:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `OurDateTime` 成员是私有的，但我们像 `self.created_at.``.to_rfc3339()` 这样访问它，因此在编译时将会产生错误。为了解决这个问题，将
    `src/models/our_date_time.rs` 中的 `OurDateTime` 成员转换为公共：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need to implement the `to_string()` method for `UserStatus` as well. We can
    choose to implement `to_string()`, or we can implement `std::fmt::Display`, which
    automatically provides `to_string()`. As a bonus, with the `Display` trait, we
    can also use it in the `format!("{}", something)` macro.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为 `UserStatus` 实现 `to_string()` 方法。我们可以选择实现 `to_string()`，或者我们可以实现 `std::fmt::Display`，这会自动提供
    `to_string()`。作为奖励，使用 `Display` 特性，我们还可以在 `format!("{}", something)` 宏中使用它。
- en: 'Modify `src/models/user_status.rs` as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改 `src/models/user_status.rs`：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s time to implement the `get_user()` function in `src/routes/user.rs`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候在 `src/routes/user.rs` 中实现 `get_user()` 函数了：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we add the required `use` directives, and then we remove the underscore
    from `_db` and `_uuid` to mark it as a used variable. Then, we acquire a single
    connection from the database pool or return `InternalServerError` if there's something
    wrong.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加所需的 `use` 指令，然后从 `_db` 和 `_uuid` 中移除下划线以标记它们为已使用的变量。然后，我们从数据库连接池中获取单个连接，如果出现问题则返回
    `InternalServerError`。
- en: 'After we set the connection variable, we can execute the `find()` method we
    defined previously:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们设置连接变量之后，我们可以执行之前定义的 `find()` 方法：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We only expose a simple error, `NotFound`, for this case, but a more complex
    application should handle the error properly, such as logging the error and returning
    the proper error status and error messages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只为这种情况公开了一个简单的错误 `NotFound`，但更复杂的应用程序应该适当地处理错误，例如记录错误并返回适当的错误状态和错误消息。
- en: 'Finally, we can construct the HTML string and return it:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以构建 HTML 字符串并返回它：
- en: '[PRE12]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice we added two links for editing this user and to go to `/users`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加了两个链接，用于编辑此用户和转到 `/users`。
- en: In the next section, we are going to implement the `get_users()` function so
    the application can handle a `/users` endpoint.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现 `get_users()` 函数，以便应用程序可以处理 `/users` 端点。
- en: Implementing GET users
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 GET 用户
- en: 'Now, let''s implement `get_users()`. Here is a quick reminder of what the function
    looked like in the previous chapter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来实现 `get_users()`。以下是对上一章中该函数外观的快速回顾：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As before, we should prepare the routines we''re going to use:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们应该准备我们将要使用的例程：
- en: 'In `src/models/user.rs`, create a method called `find_all`, as in the following:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/models/user.rs` 中创建一个名为 `find_all` 的方法，如下所示：
- en: '[PRE20]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The parameter for `find_all` is `Connection`, which has the connection pool
    and the optional `Pagination`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_all` 函数的参数是 `Connection`，它包含连接池和可选的 `Pagination`。'
- en: 'If the function is successful, we want to return a vector of `User` and `Pagination`.
    We can wrap it as a *tuple* in parentheses `()`, but there''s a possibility that
    there''s no further row in the database, so we wrap the returned `Pagination`
    in `Option`. We then split it into two methods to make it easier to read: `find_all_without_pagination`
    and `find_all_with_pagination`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数执行成功，我们希望返回一个包含 `User` 和 `Pagination` 的向量。我们可以将其作为括号 `()` 中的 *元组* 包装，但是有可能数据库中没有更多的行，所以我们用
    `Option` 包装返回的 `Pagination`。然后将其拆分为两个方法以使其更容易阅读：`find_all_without_pagination`
    和 `find_all_with_pagination`。
- en: 'Let''s modify `src/models/pagination.rs` a little bit, and add `DEFAULT_LIMIT`
    to limit the number of users we want to fetch at a single time:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们稍微修改一下 `src/models/pagination.rs`，并添加 `DEFAULT_LIMIT` 以限制我们一次想要获取的用户数量：
- en: '[PRE21]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can then create and implement the function for the base case in `src/models/user.rs`,
    `find_all_without_pagination`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在 `src/models/user.rs` 中创建并实现基例函数 `find_all_without_pagination`：
- en: '[PRE22]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Like the `find()` method, we define `query_str` and execute the query, and
    bind the `Vec<User>` result to the `users` variable. But, why do we pass the `&mut
    Connection<DBConnection>` database connection pool this time? Let''s continue
    the function first:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `find()` 方法，我们定义 `query_str` 并执行查询，然后将 `Vec<User>` 结果绑定到 `users` 变量。但是，为什么这次我们传递的是
    `&mut Connection<DBConnection>` 数据库连接池而不是 `&mut PgConnection`？我们先继续函数：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We then prepare the returned pagination, setting it to `None` first. If the
    fetched users are equal to `DEFAULT_LIMIT`, there's a possibility of a next row,
    so we do the second query to the database. Since we cannot reuse a single connection,
    we have to obtain a new connection again from the database pool. That's why we
    pass `&mut Connection<DBConnection>` to `find_all` and `find_all_without_pagination`
    instead of `&mut PgConnection`. If there's the next row, we can return the pagination
    wrapped in `Some()`. But, what is `BoolWrapper`? We need to set a type to put
    the result of the `"SELECT EXISTS..."` query.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后准备返回的分页，首先将其设置为 `None`。如果获取的用户等于 `DEFAULT_LIMIT`，则可能存在下一行，所以我们向数据库执行第二次查询。由于我们不能重用单个连接，我们必须再次从数据库池中获取新的连接。这就是为什么我们向
    `find_all` 和 `find_all_without_pagination` 传递 `&mut Connection<DBConnection>`
    而不是 `&mut PgConnection` 的原因。如果存在下一行，我们可以返回包装在 `Some()` 中的分页。但是，什么是 `BoolWrapper`？我们需要设置一个类型来放置
    `"SELECT EXISTS..."` 查询的结果。
- en: 'Add `pub mod bool_wrapper;` to `src/models/mod.rs` and create a new file, `src/models/bool_wrapper.rs`,
    with the following content:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/models/mod.rs` 中添加 `pub mod bool_wrapper;` 并创建一个新文件，`src/models/bool_wrapper.rs`，内容如下：
- en: '[PRE24]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Don't forget to add `use super::bool_wrapper::BoolWrapper;` to `src/models/user.rs`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `src/models/user.rs` 中添加 `use super::bool_wrapper::BoolWrapper;`。
- en: 'Now, it''s time to implement `find_all_with_pagination`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实现 `find_all_with_pagination` 了：
- en: '[PRE25]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The private method works like `find_all_without_pagination`, but we add a `WHERE`
    condition to start querying from a certain point.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法与 `find_all_without_pagination` 的工作方式相同，但我们添加了一个 `WHERE` 条件以从某个点开始查询。
- en: 'Now, it''s time to implement the `get_users()` function:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实现 `get_users()` 函数了：
- en: '[PRE26]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After we have obtained `users` and `new_pagination`, we can construct the HTML
    for the return value:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们获取 `users` 和 `new_pagination` 之后，我们可以构建返回值的 HTML：
- en: '[PRE27]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Append the link to the next page if we have `new_pagination`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有 `new_pagination`，则添加指向下一页的链接：
- en: '[PRE28]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice we use `timestamp_nanos()` to convert time to `i64` to make it easier
    to transport in the HTML.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用 `timestamp_nanos()` 将时间转换为 `i64` 以使其在 HTML 中更容易传输。
- en: 'To finalize the function, append the following lines:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了最终化函数，添加以下行：
- en: '[PRE29]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we have to implement `FromFormField` for `OurDateTime` since we are using
    `OurDateTime` in the pagination. In `src/models/our_date_time.rs`, add the required
    `use` directives:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须为 `OurDateTime` 实现 `FromFormField`，因为我们正在分页中使用 `OurDateTime`。在 `src/models/our_date_time.rs`
    中添加所需的 `use` 指令：
- en: '[PRE30]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because we are cloning `OurDateTime` inside the `User` implementation (`users.last().unwrap().created_at``Clone`
    for `OurDateTime`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们在 `User` 实现内部克隆 `OurDateTime` (`users.last().unwrap().created_at` 克隆 `OurDateTime`：
- en: '[PRE31]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the `from_value` implementation, we are just parsing `i64` from the request
    parameter and converting it to the `OurDateTime` object:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `from_value` 实现，我们只是从请求参数中解析 `i64` 并将其转换为 `OurDateTime` 对象：
- en: '[PRE32]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But, for `from_data`, we have to be more involved because we have to convert
    the request to `bytes`, convert it again into `&str`, and finally, into `i64`.
    First, we get the Rocket limit for the form:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，对于`from_data`，我们不得不更加参与其中，因为我们必须将请求转换为`bytes`，然后再将其转换回`&str`，最后转换为`i64`。首先，我们获取表单的Rocket限制：
- en: '[PRE33]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, get the `bytes` from the request:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从请求中获取`bytes`：
- en: '[PRE34]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And finally, we convert `bytes` to `&str`, parse it as `i64`, and convert it
    to `OurDateTime`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`bytes`转换为`&str`，将其解析为`i64`，并转换为`OurDateTime`：
- en: '[PRE35]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, `get_user` and `get_users` are ready, but we do not have any data yet.
    In the next section, we are going to implement the `new_user` and `create_user`
    functions so we can insert user data through an HTML form.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`get_user`和`get_users`已经准备好了，但我们还没有任何数据。在下一节中，我们将实现`new_user`和`create_user`函数，这样我们就可以通过HTML表单插入用户数据。
- en: Implementing POST user
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现POST用户
- en: To create a user, we are going to use the `new_user` and `create_user` functions.
    The `new_user()` function is relatively easy to implement; we just need to serve
    an HTML page with a form for a user to fill in.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用户，我们将使用`new_user`和`create_user`函数。`new_user()`函数相对容易实现；我们只需要提供一个带有用户填写表单的HTML页面。
- en: 'Let''s look at the steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看步骤：
- en: 'Implement the `new_user()` function in `src/routes/user.rs`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/routes/user.rs`中实现`new_user()`函数：
- en: '[PRE36]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the HTML, we set the `form` tag `action` attribute to `"/users"` and the
    `method` attribute to `"POST"`. This corresponds to the `create_user` route in
    our application. On the HTML page, we have fields for `username`, `email`, `password`,
    `password_confirmation`, and `description`. We then insert the button to submit
    and serve the `html_string` to the client application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，我们将`form`标签的`action`属性设置为`"/users"`，将`method`属性设置为`"POST"`。这对应于我们应用程序中的`create_user`路由。在HTML页面上，我们有`username`、`email`、`password`、`password_confirmation`和`description`字段。然后我们插入提交按钮，并将`html_string`服务给客户端应用程序。
- en: 'Try running the application now and open `http://127.0.0.1:8000/users/new`
    in the web browser. Finally, we have something we can render in the browser:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试运行应用程序，并在网页浏览器中打开`http://127.0.0.1:8000/users/new`。最后，我们有了可以在浏览器中渲染的内容：
- en: '![Figure 6.1 ‒ New user page'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.1 - 新用户页面'
- en: '](img/Figure_6.1_B16825.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B16825.jpg)'
- en: Figure 6.1 ‒ New user page
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 新用户页面
- en: 'As previously, before implementing the `create_user()` function, we want to
    create other routines first. Since the HTML form has no one-to-one mapping to
    a `User` struct, we create another struct. Put this struct in `src/models/user.rs`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，在实现`create_user()`函数之前，我们首先想要创建其他例程。由于HTML表单与`User`结构体没有一对一的映射，我们创建另一个结构体。将此结构体放在`src/models/user.rs`中：
- en: '[PRE37]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We set the derive `FromForm` trait for `NewUser`, so on top of the struct fields,
    we use the `field` directive. This directive can be used to match the request
    payload field name to the struct field name, set the default value, and validate
    the content of the field.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`NewUser`设置`derive` `FromForm`特质，因此我们可以在结构体字段之上使用`field`指令。此指令可以用来匹配请求负载字段名称与结构体字段名称，设置默认值，并验证字段内容。
- en: 'If we have HTML form field that is different from the struct field name, we
    can rename the field using field directive like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTML表单字段与结构体字段名称不同，我们可以使用字段指令进行重命名，如下所示：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It can also be done as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以这样做：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you use uncased macro, then the payload HTML field name containing any case,
    such as `HTML-FIELD-NAME`, will be matched to the struct field name.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用uncased宏，那么包含任何大小写（例如`HTML-FIELD-NAME`）的负载HTML字段名称将与结构体字段名称匹配。
- en: 'For setting the default value, the syntax is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设置默认值，语法如下：
- en: '[PRE40]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And, for validation, the syntax is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于验证，语法如下：
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There are a couple of built-in validation functions in the `rocket::form::validate`
    module:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rocket::form::validate`模块中，有几个内置的验证函数：
- en: '`contains`: This function succeeds when the field as a string has this substring,
    or the field as a `Vec` contains this item, or `Option` has `Some(value)`, or
    `rocket::form::Result` has `Ok(value)` – for example, `contains("foo")`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains`：当字段作为字符串包含此子字符串，或者字段作为`Vec`包含此项目，或者`Option`有`Some(value)`，或者`rocket::form::Result`有`Ok(value)`时，此函数成功——例如，`contains("foo")`。'
- en: '`eq`: This function succeeds when the field value is equal to the function
    parameters. A type in Rust can be compared if the type implements `std::cmp::PartialEq`.
    You can see the example in the `NewUser` struct, `eq(self.password)`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eq`：当字段值等于函数参数时，此函数成功。在Rust中，如果类型实现了`std::cmp::PartialEq`，则类型可以进行比较。你可以在`NewUser`结构体中看到示例，`eq(self.password)`。'
- en: '`ext`: This function succeeds if the field type is `rocket::fs::TempFile` and
    the content type matches the function parameter – for example, `ext(rocket::http::ContentType::JavaScript)`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ext`: 如果字段类型是 `rocket::fs::TempFile` 并且内容类型与函数参数匹配（例如，`ext(rocket::http::ContentType::JavaScript)`），则此函数成功。'
- en: '`len`: This function succeeds if the length of the field value is within the
    parameter range. You can see the example in our `NewUser` struct, `len(5..20)`.
    In Rust, we define the range as `from..to`, but we can omit the `to` part.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len`: 此函数在字段值的长度在参数范围内时成功。您可以在我们的 `NewUser` 结构体中看到示例，`len(5..20)`。在 Rust 中，我们定义范围为
    `from..to`，但我们可以省略 `to` 部分。'
- en: '`ne`: This function succeeds if the field value is not equal (`!=`) to the
    provided parameter. A type implementing the `std::cmp::PartialEq` trait can also
    use the inequality operator.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ne`: 如果字段值不等于提供的参数（`!=`），则此函数成功。实现 `std::cmp::PartialEq` 特性的类型也可以使用不等式运算符。'
- en: '`omits`: This function is the opposite of `contains`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`omits`: 此函数是 `contains` 的反函数。'
- en: '`one_of`: This function succeeds if the value contains one of the items in
    the supplied parameter. The parameter must be an iterator.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`one_of`: 如果值包含提供的参数中的任何一个项目，则此函数成功。参数必须是一个迭代器。'
- en: '`range`: This function is like `len`, but it matches the value of the field
    instead of the value of the length of the field.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`: 此函数类似于 `len`，但它匹配字段值而不是字段长度的值。'
- en: '`with`: We can pass a function or closure with the Boolean return type, and
    the function succeeds when the passed function or closure returns `true`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`: 我们可以传递一个具有布尔返回类型的函数或闭包，并且当传递的函数或闭包返回 `true` 时，函数成功。'
- en: 'Besides those functions, there are three more functions we can use. The functions
    work almost the same, but with different messages:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些函数外，还有三个更多函数我们可以使用。这些函数几乎以相同的方式工作，但消息不同：
- en: '`dbg_contains`: This function also returns the field value in the error message.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbg_contains`: 此函数也在错误消息中返回字段值。'
- en: '`dbg_eq`: This function also returns the item value in the error message.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbg_eq`: 此函数也在错误消息中返回项目值。'
- en: '`dbg_omits`: This function also returns the item value in the error message.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbg_omits`: 此函数也在错误消息中返回项目值。'
- en: 'In the `NewUser` struct, we can see that we can also set a custom error message
    by combining the validation function with `.or_else("other message"`, as shown
    in the following example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NewUser` 结构体中，我们可以看到我们还可以通过将验证函数与 `.or_else("other message"`) 结合来设置自定义错误消息，如下例所示：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Besides the provided functions, we can create a custom validation function.
    The function should return `form::Result<'_, ()>`. We want to implement custom
    validation for checking the strength of the password and the correctness of the
    email.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供的函数外，我们还可以创建一个自定义验证函数。该函数应返回 `form::Result<'_, ()>`。我们希望实现自定义验证来检查密码强度和电子邮件的正确性。
- en: The first validation is password validation. We are going to use a crate called
    `zxcvbn`. This crate is a Rust port of the `npm` module of the same name created
    by Dropbox. The inspiration for the `zxcvbn` library is based on an `"CorrectHorseBatteryStaple"`,
    are easier to remember and harder to crack compared to some rule such as *must
    contain a minimum of eight characters, of which one is upper case, one lower case,
    and one is a number*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项验证是密码验证。我们将使用一个名为 `zxcvbn` 的 crate。这个 crate 是 Dropbox 创建的同名 `npm` 模块的 Rust
    版本。`zxcvbn` 库的灵感基于一个 `"CorrectHorseBatteryStaple"`，与一些规则（如“必须包含至少八个字符，其中一个是大写字母，一个是小写字母，一个是数字”）相比，更容易记住且更难破解。
- en: 'Add `zxcvbn = "2"` to the `Cargo.toml` dependencies, then create the following
    function in `src/models/user.rs`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `zxcvbn = "2"` 添加到 `Cargo.toml` 依赖项中，然后在 `src/models/user.rs` 中创建以下函数：
- en: '[PRE43]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can set the scoring strength up to four, but it means we cannot send a weak
    password to the server. Right now, we just set the threshold of the password score
    to two.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将评分强度设置为最高四分，但这意味着我们无法将弱密码发送到服务器。目前，我们只是将密码评分阈设置为二。
- en: 'After that, we can implement the validation for email correctness. First, add
    `regex = "1.5.4"` to `Cargo.toml` and add this function in `src/models/user.rs`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以实现电子邮件正确性的验证。首先，将 `regex = "1.5.4"` 添加到 `Cargo.toml` 并在 `src/models/user.rs`
    中添加此函数：
- en: '[PRE44]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the email `NewUser` struct:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `NewUser` 结构体的电子邮件：
- en: '[PRE45]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, we can implement the `create()` method for the `User` struct. For security
    purposes, we will hash the password using the secure password-hashing function.
    In 2021, people considered `md5` as a very insecure hashing function, and `sha1`
    and `sha3` as insecure hashing functions, so we will not use those functions.
    People usually consider using `bcrypt`, `scrypt`, or `argon2` instead. Now, `argon2`
    has a version, `argon2id`, which is resistant to side-channel attacks and GPU
    cracking attacks, so we will use `argon2` as a password-hashing implementation.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以为`User`结构体实现`create()`方法。出于安全考虑，我们将使用安全的密码散列函数来散列密码。在2021年，人们认为`md5`是一个非常不安全的散列函数，而`sha1`和`sha3`也被认为是不安全的散列函数，所以我们不会使用这些函数。人们通常考虑使用`bcrypt`、`scrypt`或`argon2`。现在，`argon2`有一个版本，`argon2id`，它对旁路攻击和GPU破解攻击具有抵抗力，所以我们将使用`argon2`作为密码散列实现。
- en: 'There is another possible attack on the `create()` method: `"<script>console.log("hack")</script>"`
    as a description. We can rectify this problem by using an HTML sanitization library
    called `ammonia`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()`方法还存在另一种可能的攻击：将`"<script>console.log("hack")</script>"`作为描述。我们可以通过使用名为`ammonia`的HTML清理库来解决这个问题。'
- en: 'To add `argon2` and `ammonia` for the `create()` method, add these lines in
    `Cargo.toml`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`create()`方法添加`argon2`和`ammonia`，请在`Cargo.toml`中添加以下行：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can create a function to sanitize HTML in `src/models/mod.rs`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`src/models/mod.rs`中创建一个用于清理HTML的函数：
- en: '[PRE47]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The default cleaner from `ammonia::Builder::default` allows many HTML tags,
    and people can still deface the site. To rectify this problem, we are passing
    an empty `HashSet` to disallow any HTML tag.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`ammonia::Builder::default`的默认清理器允许许多HTML标签，人们仍然可以破坏网站。为了解决这个问题，我们传递一个空的`HashSet`来禁止任何HTML标签。
- en: 'After the password hashing and HTML sanitization are ready, it is time to implement
    the `create()` method for the `User` struct. Add the required `use` directives
    in `src/models/user.rs`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在密码散列和HTML清理就绪后，是时候为`User`结构体实现`create()`方法了。在`src/models/user.rs`中添加所需的`use`指令：
- en: '[PRE48]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Put these lines in the `impl User` block:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行放入`impl User`块中：
- en: '[PRE49]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We generate a new UUID for the new `User` instance. After that, we clean the
    username value and description value. We don't clean the email and password because
    we already validate the content of the email using a regex and we will not show
    any password in the HTML.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为新的`User`实例生成一个新的UUID。之后，我们清理用户名值和描述值。我们不清理电子邮件和密码，因为我们已经使用正则表达式验证了电子邮件的内容，并且我们不会在HTML中显示任何密码。
- en: 'Next, append the following lines to hash the password:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下行以散列密码：
- en: '[PRE50]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we send the `INSERT` statement to our database server and return the
    inserted row. Append the following lines:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们向我们的数据库服务器发送`INSERT`语句并返回插入的行。添加以下行：
- en: '[PRE51]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When the `User::create()` method is ready, we can implement the `create_user()`
    function. When the application successfully creates a user, it's better to show
    the result by redirecting to `get_user`. For this purpose, we can use the `rocket::response::Redirect`
    type instead of `RawHtml`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`User::create()`方法就绪时，我们可以实现`create_user()`函数。当应用程序成功创建用户时，最好通过重定向到`get_user`来显示结果。为此，我们可以使用`rocket::response::Redirect`类型而不是`RawHtml`。
- en: Also, if there's an error, it's better to redirect to `new_user()` and show
    the error so the user can fix the input error. We can do this by getting the error
    of the `NewUser` validations or any other error, and redirecting to the `new_user()`
    function with embedded error information.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果存在错误，最好重定向到`new_user()`并显示错误，以便用户可以修复输入错误。我们可以通过获取`NewUser`验证的错误或任何其他错误，并将带有嵌入式错误信息的重定向到`new_user()`函数来实现这一点。
- en: 'We can get the errors for the request form value using `rocket::form::Contextual`,
    a proxy for the form type that contains error information. We also going to use
    `rocket::response::Flash` to send a one-time cookie to the web browser and retrieve
    the message on a route using `rocket::request::FlashMessage`. Append these lines
    to `src/routes/user.rs`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rocket::form::Contextual`来获取请求表单值的错误，它是包含错误信息的表单类型的代理。我们还将使用`rocket::response::Flash`向网络浏览器发送一次性cookie，并使用`rocket::request::FlashMessage`在路由上检索消息。将这些行添加到`src/routes/user.rs`中：
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Change the signature of the `create_user()` function to the following:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`create_user()`函数的签名更改为以下内容：
- en: '[PRE53]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Because we are sending `POST` data, the browser will send `Content-Type` as
    `"application/x-www-form-urlencoded"`, so we have to change the format accordingly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在发送`POST`数据，浏览器将发送`Content-Type`为`"application/x-www-form-urlencoded"`，因此我们必须相应地更改格式。
- en: Also, take a look at the request parameter; instead of `Form<NewUser<'r>>`,
    we are inserting the `Contextual` type in the middle of the parameter. We are
    also changing the return value to `Result<Flash<Redirect>, Flash<Redirect>>`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，查看请求参数；我们不是插入`Form<NewUser<'r>>`，而是在参数中间插入`Contextual`类型。我们还更改了返回值，将其更改为`Result<Flash<Redirect>,
    Flash<Redirect>>`。
- en: 'Now, let''s implement the function body. Append the following lines to the
    function body:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现函数体。将以下行添加到函数体中：
- en: '[PRE54]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If `user_context` has `value`, it means that Rocket successfully converted the
    request payload and put it inside the `value` attribute. We are branching and
    returning `Error` with a `Flash` message and `Redirect` directive to `"/users/new"`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`user_context`有`value`，这意味着Rocket成功转换了请求有效负载并将其放入`value`属性中。我们分支并返回带有`Flash`消息和`Redirect`指令的`Error`到`"/users/new"`。
- en: 'The next implementation is if Rocket successfully parses `NewUser`. Append
    the following lines in the `true` branch:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个实现是如果Rocket成功解析`NewUser`。在`true`分支中添加以下行：
- en: '[PRE55]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Just like the `get_user()` function, we create a routine to get the database
    connection, perform an `INSERT` operation to the database server, and generate
    the successful `Redirect` response. But, when an error occurs, instead of returning
    HTML, we generate the `Redirect` directive with the appropriate path and message.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`get_user()`函数一样，我们创建一个例程来获取数据库连接，对数据库服务器执行`INSERT`操作，并生成成功的`Redirect`响应。但是，当发生错误时，我们不是返回HTML，而是生成带有适当路径和消息的`Redirect`指令。
- en: 'We now need to change the `new_user()` and `get_user()` functions to be able
    to handle incoming `FlashMessage` request guards. First, for the `new_user()`
    function, change the signature to the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要更改`new_user()`和`get_user()`函数，以便能够处理传入的`FlashMessage`请求守卫。首先，对于`new_user()`函数，将签名更改为以下形式：
- en: '[PRE56]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Because the flash message may not always exist, we wrap it in `Option`. After
    `let mut html_string = String::from(USER_HTML_PREFIX);`, append the following
    lines in the function body:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为闪存消息可能并不总是存在，所以我们将其包裹在`Option`中。在`let mut html_string = String::from(USER_HTML_PREFIX);`之后，在函数体中添加以下行：
- en: '[PRE57]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We change the `new_user()` function almost the same. Change the function signature
    to this:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎以相同的方式修改了`new_user()`函数。将函数签名更改为以下形式：
- en: '[PRE58]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, append the following lines after `USER_HTML_PREFIX`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`USER_HTML_PREFIX`之后添加以下行：
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, it''s time to try creating the user data. If everything is correct, you
    should see screens like the following. The error message looks as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候尝试创建用户数据了。如果一切正确，你应该看到以下屏幕。错误消息如下：
- en: '![Figure 6.2 ‒ Error message when failed'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 - 失败时的错误消息](img/Figure_6.2_B16825.jpg)'
- en: '](img/Figure_6.2_B16825.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.2_B16825.jpg]'
- en: Figure 6.2 ‒ Error message when failed
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 - 失败时的错误消息
- en: 'The success message looks like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 成功消息如下所示：
- en: '![Figure 6.3 ‒ Success message'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 - 成功消息](img/Figure_6.3_B16825.jpg)'
- en: '](img/Figure_6.3_B16825.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 - 成功消息](img/Figure_6.3_B16825.jpg)'
- en: Figure 6.3 ‒ Success message
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 - 成功消息
- en: In the next sections, we are going to continue with updating the user and deleting
    a user.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续更新用户和删除用户。
- en: Implementing PUT and PATCH user
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现PUT和PATCH用户
- en: 'To update the user, we need a page such as `new_user()`, but we want the form
    pre-populated with existing data. We also want to add another field for the user
    to confirm the old password. Let''s look at the steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新用户，我们需要一个像`new_user()`这样的页面，但我们希望表单预先填充现有数据。我们还想为用户添加一个字段来确认旧密码。让我们看看步骤：
- en: 'Change the `edit_user()` function signature to the following:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`edit_user()`函数签名更改为以下形式：
- en: '[PRE60]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To get the existing user, append the following lines inside the function body
    block:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取现有用户，在函数体块内部添加以下行：
- en: '[PRE61]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'After that, we can append the HTML, such as `new_user()`, but this time, we
    also include the existing data from the user. Append the following lines inside
    the `edit_user()` function body:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以添加HTML，例如`new_user()`，但这次，我们还包含了用户现有的数据。在`edit_user()`函数体内部添加以下行：
- en: '[PRE62]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: After this, all previous links to `"/users/edit/{}"` that we implemented in
    the previous pages should work.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们之前在之前的页面中实现的指向`"/users/edit/{}"`的所有先前链接都应该正常工作。
- en: If you look at the code, we see the form's `method` attribute has a `"POST"`
    value. The reason is that the HTML standard says that a form method can only be
    `GET` or `POST`. Most web browsers will just change the invalid method, such as
    `PUT` and `PATCH`, to `POST`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看代码，我们会看到表单的`method`属性具有`"POST"`值。原因是HTML标准表示表单方法只能是`GET`或`POST`。大多数网络浏览器会将无效的方法，如`PUT`和`PATCH`，更改为`POST`。
- en: Some web frameworks work around this limitation by sending an `POST` request
    but include a hidden value in the request payload. We are going to use the second
    way to implement updating the user by adding a new field, `name="_METHOD"`, with
    the `"PUT"` value.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Web框架通过发送一个包含隐藏值在请求有效负载中的`POST`请求来绕过这个限制。我们将使用第二种方式通过添加一个新字段`name="_METHOD"`并赋予其`"PUT"`值来实现更新用户的实现。
- en: Just like `create_user()`, we want to execute `update_function()` to redirect
    to `edit_user()` again if there's something wrong. We also want to execute `update_function()`
    to redirect to the user page again after successfully updating the user.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`create_user()`一样，我们希望在出现错误时执行`update_function()`以重定向到`edit_user()`，同样在成功更新用户后，我们也想执行`update_function()`以重定向到用户页面。
- en: 'Since we are adding new payloads, `_METHOD` and `old_password`, we need a new
    type that is different from `NewUser`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在添加新的有效负载，`_METHOD`和`old_password`，我们需要一个与`NewUser`不同的新类型：
- en: 'Create a new struct called `EditedUser` in `src/models/user.rs`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/user.rs`中创建一个名为`EditedUser`的新结构体：
- en: '[PRE63]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We want to skip updating the password if there''s no value in `old_password`,
    but if there is a value in `old_password`, we want to make sure the `password`
    strength is adequate and `password_confirmation` has the same content as `password`.
    Create a function in `src/models/user.rs`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`old_password`中没有值，我们希望跳过更新密码，但如果`old_password`中有值，我们想确保密码强度足够且`password_confirmation`的内容与密码相同。在`src/models/user.rs`中创建一个函数：
- en: '[PRE64]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, use the validation function in the directive above the password field:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用密码字段上方的指令中的验证函数：
- en: '[PRE65]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We need a method for `User` to update the database row based on the `EditedUser`
    content. This method will also verify the hash of `old_password` to make sure
    `EditedUser` is valid.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法让`User`根据`EditedUser`的内容更新数据库行。此方法还将验证`old_password`的哈希值以确保`EditedUser`有效。
- en: 'Add the `use` directive in `src/models/user.rs`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/user.rs`中添加`use`指令：
- en: '[PRE66]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a new method inside the `impl User` block in `src/models/user.rs`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/user.rs`中的`impl User`块内部创建一个新方法：
- en: '[PRE67]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inside the method, fetch the old user data from the database:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法内部，从数据库中获取旧用户数据：
- en: '[PRE68]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Prepare the data for updating:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备更新数据：
- en: '[PRE69]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Because we can change the password or skip changing the password depending
    on whether or not we have `old_password or not`, prepare the query items:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可以根据是否有`old_password`来更改密码或跳过更改密码，准备查询项：
- en: '[PRE70]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If we are updating `password`, we need to verify `old_password` with the existing
    password. We also want to hash a new password and add the password to `set_strings`.
    Append the following lines:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们正在更新`密码`，我们需要验证`old_password`与现有密码是否匹配。我们还想对新的密码进行哈希处理，并将密码添加到`set_strings`中。追加以下行：
- en: '[PRE71]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can then construct the `UPDATE` statement to update the user, execute the
    statement, and return the `User` instance:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，构建更新用户的`UPDATE`语句，执行该语句，并返回`User`实例：
- en: '[PRE72]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, it''s time to use `EditedUser` and implement `update_user()`. Append `EditedUser`
    in the `use` directive:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候使用`EditedUser`并实现`update_user()`了。在`use`指令中追加`EditedUser`：
- en: '[PRE73]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create the `update_user()` function in `src/routes/user.rs`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/routes/user.rs`中创建`update_user()`函数：
- en: '[PRE74]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the function, we need to check whether the form is correct or not. Append
    the following lines:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该函数中，我们需要检查表单是否正确。追加以下行：
- en: '[PRE75]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can tell the application to process depending on `"_METHOD"`. Append the
    following lines:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以告诉应用程序根据`"_METHOD"`来处理。追加以下行：
- en: '[PRE76]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We don't waste the functions we defined before. We are using the `put_user()`
    and `patch_user()` functions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会浪费之前定义的函数。我们正在使用`put_user()`和`patch_user()`函数。
- en: 'Now, it''s time to implement the `put_user()` function. Change the signature
    of the `put_user()` function:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实现`put_user()`函数了。更改`put_user()`函数的签名：
- en: '[PRE77]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, implement the function as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式实现该函数：
- en: '[PRE78]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For the `patch_user()` function, we can just reuse the `put_user()` function.
    Write the code for `patch_user()`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`patch_user()`函数，我们可以直接重用`put_user()`函数。编写`patch_user()`的代码：
- en: '[PRE79]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, append the new route in `src/main.rs`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`src/main.rs`中追加新的路由：
- en: '[PRE80]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The only endpoint left is for deleting the user. Let's continue with that in
    the next section.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一端点是用于删除用户。让我们在下一节继续讨论。
- en: Implementing DELETE user
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 DELETE 用户
- en: 'The first thing we want to do to delete a user is to create a method for the
    `User` struct. Let''s look at the steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 删除用户的第一件事是创建一个针对`User`结构体的方法。让我们看看步骤：
- en: 'Write the method to delete a user in the `impl User` block in `src/models/user.rs`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/user.rs`的`impl User`块中编写删除用户的函数：
- en: '[PRE81]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, we can implement the `delete_user()` function in `src/routes/user.rs`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`src/routes/user.rs`中实现`delete_user()`函数：
- en: '[PRE82]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The problem is that neither the link nor the form in HTML are allowed to use
    the `DELETE` method. We cannot use the link, as any bot seeing it will crawl on
    it and could perform resource deletion accidentally. As with updating the user,
    we can use the form and send a `POST` request to a new endpoint. Add a new function
    in `src/routes/user.rs`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于HTML中的链接和表单都不允许使用`DELETE`方法。我们不能使用链接，因为任何看到它的机器人都会在上面爬行，可能会意外执行资源删除。就像更新用户一样，我们可以使用表单并向新的端点发送`POST`请求。在`src/routes/user.rs`中添加一个新函数：
- en: '[PRE83]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Don''t forget to add the route in `src/main.rs`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在`src/main.rs`中添加路由：
- en: '[PRE84]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, where can we create a form to delete the user? Let''s do that on the `get_user()`
    page. Append the HTML for the form as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在哪里创建一个用于删除用户的表单？让我们在`get_user()`页面上做这件事。按照以下方式添加表单的HTML：
- en: '[PRE85]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We have now completed all of the endpoints used to manage users. Try adding
    users and see how pagination works or try improving the HTML. You can also try
    activating users for a challenge!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了所有用于管理用户的端点。尝试添加用户，看看分页是如何工作的，或者尝试改进HTML。你还可以尝试激活用户以进行挑战！
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the basic operations for user entities
    by implementing the creation, reading, updating, and deleting of user routes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过实现创建、读取、更新和删除用户路由，学习了用户实体的基本操作。
- en: We also learned more about various modules of the Rocket framework such as RawHtml,
    Redirect, Contextual, Flash, Form, and FlashMessage.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了Rocket框架的各个模块，例如RawHtml、Redirect、Contextual、Flash、Form和FlashMessage。
- en: Along with implementing the endpoints, we also learned more about database operations
    such as querying, inserting, updating, and deleting objects on a database server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现端点的同时，我们还了解了数据库操作，如查询、插入、更新和删除数据库服务器上的对象。
- en: In the next chapter, we are going to learn more about error handling and creating
    our own error types.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于错误处理和创建我们自己的错误类型的内容。
