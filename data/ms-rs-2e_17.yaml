- en: Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: This chapter will cover various approaches to debugging Rust programs. Rust
    programs, at the binary level, are very similar to C programs. This means that
    we can leverage the strong legacy of industry standard debuggers such as gdb and
    lldb that are used for debugging C/C++ programs and use the same tools to debug
    Rust code as well. In this chapter, we'll interactively walk through some basic
    debugging workflow and commands with gdb. We'll also cover integrating the gdb
    debugger with **Visual Studio Code** (**vscode**) editor and, later, give a quick
    overview of another debugger, called **rr**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍调试Rust程序的各种方法。在二进制层面，Rust程序与C程序非常相似。这意味着我们可以利用行业标准调试器（如gdb和lldb）的强大遗产，这些调试器用于调试C/C++程序，并使用相同的工具来调试Rust代码。在本章中，我们将交互式地通过一些基本的调试工作流程和gdb命令。我们还将介绍将gdb调试器与**Visual
    Studio Code**（**vscode**）编辑器集成，以及稍后简要概述另一个名为**rr**的调试器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to debugging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试简介
- en: The gdb basics and debugging a Rust program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB基础和Rust程序的调试
- en: The gdb integration with Visual Studio Code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB与Visual Studio Code的集成
- en: RR debugger—a quick overview
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RR调试器——快速概述
- en: Introduction to debugging
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试简介
- en: '"If debugging is the process of removing bugs, then programming must be the
    process of putting them in."                                                 
                                                                                 
                                                                                 
                                                                             - Edsger
    W. Dijkstra'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “如果调试是去除bug的过程，那么编程就必须是放置bug的过程。” —— Edsger W. Dijkstra
- en: 'Here''s the situation: your program doesn''t work, and you have no idea why.
    To fix this mysterious issue in your code, you have added several print statements
    and enabled trace logging, too. Still no luck. Worry not, for you are not alone!
    Every programmer has been there and has spent countless hours finding that one
    nasty bug that brought havoc into production.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是情况：你的程序不工作，你也不知道为什么。为了修复代码中这个神秘的问题，你已经添加了几个打印语句并启用了跟踪日志，但仍然没有成功。不用担心，你不是一个人！每个程序员都曾经遇到过这种情况，并且花费了无数小时寻找那个导致生产混乱的讨厌的bug。
- en: 'Errors and deviations in software are referred to as bugs, and the act of removing
    them is termed debugging. Debugging is a controlled and systematic approach to
    examining the cause and effect of a fault in software. It''s an essential skill
    to learn for anybody that''s interested in gaining more insight into how their
    program behaves and runs. However, debugging is often not an easy task without
    the right tools, and the developer can lose track of what the actual bug is or
    might even be looking for bugs in the wrong place. The approaches we use to identify
    bugs in software can greatly affect the time taken to squash them and continue
    on a happy path. Depending on how complex a bug is, debugging is usually approached
    in one of the following ways:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中的错误和偏差被称为bug，移除它们的行为称为调试。调试是检查软件中故障原因和结果的一种受控和系统化的方法。对于任何希望深入了解其程序行为和运行方式的开发者来说，这是一项必备的技能。然而，没有合适的工具，调试通常不是一项容易的任务，开发者可能会失去对实际bug的追踪，甚至可能在错误的地方寻找bug。我们用于识别软件中bug的方法可以极大地影响解决它们所需的时间，并继续在愉快的路径上前进。根据bug的复杂程度，调试通常采用以下一种方法：
- en: '**Print-line debugging**: In this method, we sprinkle print statements in the
    required places in the code, where we suspect the bug may possibly modify application
    state, and monitor the output when the program is run. This is simple, crude,
    and often effective, but it''s not possible in every situation. This technique
    requires no extra tools, and everybody knows how to do it. It''s actually the
    starting point of debugging for most bugs. To aid with print-line debugging, Rust
    provides the `Debug` trait, which we have already used many times before, and
    the `dbg!`, `println!`, and `eprintln!` family of macros.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印行调试**：在这种方法中，我们在代码中可能存在bug并可能修改应用程序状态的所需位置添加打印语句，并在程序运行时监控输出。这是简单、粗糙且通常有效的，但在某些情况下是不可能的。这项技术不需要额外的工具，每个人都知道如何做。实际上，这是大多数bug调试的起点。为了帮助打印行调试，Rust提供了`Debug`特质，我们之前已经多次使用过，以及`dbg!`、`println!`和`eprintln!`宏系列。'
- en: '**Read-Evaluate-Print-Loop-based debugging**: Languages that are interpreted,
    such as Python, often come with their own interpreter. An interpreter provides
    you with a **Read-Evaluate-Print-Loop (REPL)** interface, where you can load your
    program in an interactive session and examine the state of variables step by step.
    It is very useful in debugging, especially if you''ve managed to properly modularize
    your code so that it can be invoked independently as functions. Unfortunately,
    Rust does not have an official REPL, and its overall design doesn''t really support
    one. However, there have been some efforts on this with the miri project, which
    can be found at [https://github.com/solson/miri](https://github.com/solson/miri).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于读取-评估-打印循环的调试**：像Python这样的解释型语言通常自带自己的解释器。解释器为你提供了一个**读取-评估-打印循环（REPL）**界面，你可以将程序加载到交互会话中，并逐步检查变量的状态。这在调试中非常有用，特别是如果你已经正确地将代码模块化，使其可以作为函数独立调用。不幸的是，Rust没有官方的REPL，其整体设计也不支持REPL。然而，miri项目在这方面做了一些努力，该项目可以在[https://github.com/solson/miri](https://github.com/solson/miri)找到。'
- en: '**Debuggers**: With this approach, we compile our program with special debugging
    symbols in the resulting binary and use an external program to monitor its execution.
    These external programs are called debuggers and the most popular ones are gdb
    and lldb. They are the most powerful and efficient methods of debugging, allowing
    you to inspect a lot of details about your program at runtime. Debuggers give
    you the ability to pause a running program and examine its state in memory to
    find out the specific line of code that introduced the bug.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器**：采用这种方法，我们在生成的二进制程序中添加特殊的调试符号，并使用外部程序来监控其执行。这些外部程序被称为调试器，其中最流行的是gdb和lldb。它们是调试中最强大和高效的方法，允许你在程序运行时检查大量关于程序细节的信息。调试器让你能够暂停正在运行的程序，并检查其在内存中的状态，以找出引入错误的特定代码行。'
- en: 'The first two approaches are quite obvious, and so we don''t need to go through
    them here. This leaves us with the third approach: debuggers. Debuggers as a tool
    are very simple to use, but they are not easy to understand and are often not
    introduced properly to programmers early in their careers. In the next section,
    we''ll go through a step-by-step process of debugging a program written in Rust
    with gdb. But before that, let''s get to know a little about debuggers.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法相当明显，所以我们在这里不需要详细说明。这让我们只剩下了第三种方法：调试器。作为工具，调试器非常容易使用，但它们并不容易理解，并且通常在程序员职业生涯的早期并没有得到适当的介绍。在下一节中，我们将通过一步一步的过程来调试用gdb编写的Rust程序。但在那之前，让我们先了解一下调试器。
- en: Debuggers in general
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试器概述
- en: Debuggers are programs that can inspect a program's internal state at runtime,
    provided that the program has been compiled – debug symbols included. They rely
    on process introspection system calls such as **ptrace** in Linux. They allow
    you to pause the execution of a program at runtime. To achieve this, they provide
    a feature called a breakpoint. A breakpoint represents a suspension point in a
    running program. A breakpoint can be put on any function or line of code in the
    program. Once the debugger hits the breakpoint, it pauses and waits for the user
    to input further instructions. At this point, the program is not running and is
    in the middle of its execution. Here, you can examine the state of variables,
    the active stack frames of a program, and other things such as the program counter
    and the assembly instructions. Debuggers also come with watchpoints, which are
    similar to breakpoints but work on variables. They trigger and stop the execution
    when the variable is read or written to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是可以在程序运行时检查程序内部状态的程序，前提是程序已被编译，包括调试符号。它们依赖于进程内省系统调用，如Linux中的**ptrace**。它们允许你在程序运行时暂停程序的执行。为了实现这一点，它们提供了一个名为断点的功能。断点代表运行程序中的暂停点。可以在程序中的任何函数或代码行上设置断点。一旦调试器遇到断点，它就会暂停并等待用户输入进一步的指令。此时，程序没有运行，正处于执行过程中。在这里，你可以检查变量的状态、程序的活动堆栈帧以及其他如程序计数器和汇编指令等事物。调试器还提供了观察点，它们类似于断点，但作用于变量。当变量被读取或写入时，它们会触发并停止执行。
- en: To use a debugger on a program, we need some prerequisites, though. Let's discuss
    them next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在程序上使用调试器，我们需要一些先决条件。让我们接下来讨论它们。
- en: Prerequisites for debugging
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试前的准备工作
- en: A compiled program or object file is a sequence of zeros and ones that has no
    mapping of the original source from which it was compiled. To enable a program
    to be inspected by a debugger, we need to map the compiled binary instructions
    to the source file somehow. This is done by injecting extra bookkeeping symbols
    and instrumentation code during compilation, which the debugger can then latch
    onto. These symbols are maintained in a symbol table that contains information
    about the elements of the program, such as the names of variables, functions,
    and types. They follow a standard format called **Debugging With Attributed Record
    Format** (**DWARF**), which most standard debuggers know how to parse and understand.
    These symbols give developers the capability to examine the program, such as the
    ability to match the source code to the running binary, keeping information on
    call frames, register values the memory map of the program, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的程序或对象文件是一系列零和一，没有从编译它的原始源代码映射。为了使程序能够被调试器检查，我们需要以某种方式将编译的二进制指令映射到源文件。这是通过在编译过程中注入额外的记账符号和仪器代码来完成的，调试器可以随后锁定这些符号。这些符号保存在一个符号表中，其中包含有关程序元素的信息，例如变量、函数和类型的名称。它们遵循一个称为
    **带有属性记录格式的调试**（**DWARF**）的标准格式，大多数标准调试器都知道如何解析和理解。这些符号使开发者能够检查程序，例如将源代码与运行的二进制文件匹配，保持调用帧、寄存器值和程序内存映射等信息。
- en: To debug our program, we need to compile it in debug mode. In debug mode, a
    compiled binary will include debugging symbols in the DWARF debugging format.
    Here, the binary gains a bit of size and runs more slowly because it has to update
    the debugging symbol table as it runs. When compiling C programs, you need to
    compile with the `-g` flag to tell the compiler to compile with debug symbols
    included. With Cargo, a debug build of the project is compiled by default in the
    `target/debug/` directory, with debugging symbols included.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试我们的程序，我们需要以调试模式编译它。在调试模式下，编译的二进制文件将包含 DWARF 调试格式的调试符号。在这里，二进制文件的大小略有增加，运行速度也较慢，因为它需要在运行时更新调试符号表。当编译
    C 程序时，您需要使用 `-g` 标志来告诉编译器包含调试符号进行编译。使用 Cargo 时，项目的调试构建默认在 `target/debug/` 目录下编译，并包含调试符号。
- en: '**Note**: You can also pass a `-g` flag to `rustc` when using a package manager
    other than Cargo.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：当使用除 Cargo 之外的其他包管理器时，也可以向 `rustc` 传递 `-g` 标志。'
- en: 'Running the debugger is possible against a release build too, but the selection
    of operations is very limited. If you want to enable `DWARF` debugging symbols,
    even in release builds, you can configure that in `Cargo.toml` by modifying the
    `profile.release` section, like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对发布构建运行调试器也是可能的，但可用的操作选择非常有限。如果您想在发布构建中启用 `DWARF` 调试符号，可以在 `Cargo.toml` 中通过修改
    `profile.release` 部分，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With that said, let's dive into setting up gdb.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们深入探讨如何设置 gdb。
- en: Setting up gdb
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 gdb
- en: To get started with gdb, we first need to install it. Usually, it is installed
    by default on Linux systems, but if it isn't, refer to guides on the internet
    for setting it up on your machine. On Ubuntu, it's just a matter of running an
    installation command such as `apt-get install gdb`. We'll be using gdb version
    `7.11.1` for our demo here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 gdb，我们首先需要安装它。通常，Linux 系统上默认安装了它，但如果未安装，请参考互联网上的指南来设置您的机器。在 Ubuntu 上，只需运行一个安装命令，例如
    `apt-get install gdb`。在这里，我们将使用 `7.11.1` 版本的 gdb 进行演示。
- en: While gdb has amazing support for Rust programs, there are some Rust-specific
    things that it doesn't handle correctly, such as getting tidier output. The Rust
    toolchain, rustup, also installs wrappers for both gdb and lldb debuggers, `rust-gdb`
    and `rust-lldb`. It does this to account for some of the limitations in handling
    Rust code such as getting tidier output for mangled types and some pretty printing
    of user-defined types. Let's explore debugging a Rust program with gdb.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 gdb 对 Rust 程序有惊人的支持，但它并没有正确处理一些 Rust 特有的问题，例如获取更整洁的输出。Rust 工具链 rustup 还为
    gdb 和 lldb 调试器安装了包装器，分别是 `rust-gdb` 和 `rust-lldb`。这样做是为了解决处理 Rust 代码的一些限制，例如为混淆类型获取更整洁的输出以及一些用户定义类型的格式化打印。让我们来探索如何使用
    gdb 调试 Rust 程序。
- en: A sample program – buggie
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例程序 - buggie
- en: 'We''ll need a program to debug to experience gdb. Let''s create a new project
    by running `cargo new buggie`. Our program will have a single function, `fibonacci`,
    which takes a position of `n` as `usize`, and gives us the *nth* Fibonacci number.
    This function assumes that the initial values of the Fibonacci numbers are `0`
    and `1`. The following code is the program in its entirety:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个程序来调试以体验gdb。让我们通过运行`cargo new buggie`来创建一个新的项目。我们的程序将有一个单独的函数`fibonacci`，它接受一个`usize`类型的`n`位置，并给出第*n*个斐波那契数。这个函数假设斐波那契数的初始值是`0`和`1`。以下代码是整个程序的代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s take this program for a spin:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试运行这个程序：
- en: '![](img/655ea2ad-b1da-4292-94dd-4089ff58dd2e.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/655ea2ad-b1da-4292-94dd-4089ff58dd2e.png)'
- en: We ran the program with `4` as the argument, but we can see a `0` as the output,
    which should have been `3`. We have a bug here. While we could use the `println!`
    or `dbg!` macro to easily tackle this bug, we'll use gdb this time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`4`作为参数运行了程序，但我们看到输出是`0`，而应该是`3`。这里有一个错误。虽然我们可以使用`println!`或`dbg!`宏轻松解决这个问题，但这次我们将使用gdb。
- en: Before we run gdb, we need to plan our debugging session. This includes deciding
    where to look inside our program and what to look for. As a starting point, we'll
    examine the contents of the `main` function and then step into the `fibonacci`
    function. We'll set two breakpoints, one at `main` and another within `fibonacci`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行gdb之前，我们需要规划我们的调试会话。这包括决定在程序中查看哪些部分以及要查找什么。作为一个起点，我们将检查`main`函数的内容，然后进入`fibonacci`函数。我们将设置两个断点，一个在`main`中，另一个在`fibonacci`内部。
- en: The gdb basics
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gdb基础知识
- en: 'We''ll run our program again, this time with gdb using the `rust-gdb` wrapper
    by running `rust-gdb --args target/debug/buggie 4`. The `--args` flags are used
    to pass arguments to the program. Here, we pass the number `4`. Here''s the output
    from gdb:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次运行我们的程序，这次使用gdb通过`rust-gdb`包装器运行`rust-gdb --args target/debug/buggie 4`。`--args`标志用于将参数传递给程序。这里我们传递了数字`4`。以下是gdb的输出：
- en: '![](img/f3b532f6-1453-4e4d-a53c-6b3438e7319a.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3b532f6-1453-4e4d-a53c-6b3438e7319a.png)'
- en: 'After loading our program, gdb throws us into the `(gdb)` prompt. At this point,
    the program is not running—it''s just been loaded. Let''s take a quick look at
    the scope of gdb''s features. Try using the `help` command (which displays high-level
    sections of commands) and the `help all` command(which displays a help message
    for all available commands):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载我们的程序后，gdb将我们带到`(gdb)`提示符。在这个时候，程序还没有运行——它只是被加载了。让我们快速查看gdb功能的范围。尝试使用`help`命令（显示命令的高级部分）和`help
    all`命令（显示所有可用命令的帮助信息）：
- en: '![](img/ce3e6048-7f4a-43e9-9812-636eb0a4ff29.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce3e6048-7f4a-43e9-9812-636eb0a4ff29.png)'
- en: 'Okay, so it seems that gdb can do a lot: there are `32` pages of these commands.
    Next, let''s run the program and see the outcome by invoking `run` on the gdb
    prompt:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以看起来gdb可以做很多事情：这里有`32`页的命令。接下来，让我们在gdb提示符上调用`run`来运行程序并查看结果：
- en: '![](img/84e23af9-a02d-4f37-80c2-746d56e20078.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84e23af9-a02d-4f37-80c2-746d56e20078.png)'
- en: That's how our program runs within the context of gdb. As you can see, in the
    middle, we have the same faulty output of `0` for the fourth Fibonacci number.
    We'll debug this now. Let's clear the screen by pressing *Ctrl* + *L*. Let's also
    quit gdb by invoking `q` and start afresh by running `rust-gdb --args target/debug/buggie
    4`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的程序在gdb上下文中的运行方式。正如你所见，中间部分，我们得到了第四个斐波那契数的相同错误输出`0`。我们现在将调试这个问题。通过按*Ctrl*
    + *L*来清除屏幕。我们也可以通过调用`q`来退出gdb，然后通过运行`rust-gdb --args target/debug/buggie 4`来重新开始。
- en: 'As a starting point in our debugging session, and to see whether we are passing
    the correct number to our Fibonacci function, we''ll add a breakpoint at the start
    of `main`, which is line `18` in our program. To add a breakpoint on that line,
    we''ll run the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的调试会话的起点，为了查看我们是否向斐波那契函数传递了正确的数字，我们将在`main`的开始处添加一个断点，即我们程序中的第`18`行。为了在该行添加断点，我们将运行以下代码：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This gives us the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The gdb has now set a breakpoint on the same line that we requested, that is, `18`.
    Let''s run our program by invoking `run`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在gdb已经在我们请求的同一行设置了断点，即`18`。让我们通过调用`run`来运行我们的程序：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This gives us the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our program is now paused at the breakpoint, awaiting its next instruction.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的程序在断点处暂停，等待其下一条指令。
- en: 'You''ll see that the symbols from Rust are prefixed with their module and suffixed
    by some random IDs, for example, `buggie::main::h8018d7420dbab31`. Now, to view
    where we are in our program, we can run the `list` command to view the source
    code, or we can use a more visual TUI mode by running the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Rust的符号前面带有它们的模块名，后面跟着一些随机ID，例如，`buggie::main::h8018d7420dbab31`。现在，为了查看我们在程序中的位置，我们可以运行`list`命令来查看源代码，或者我们可以通过运行以下代码来使用更直观的TUI模式：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This opens gdb with some nice feedback, along with our Command Prompt still
    on the bottom half:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开gdb，并有一些不错的反馈，同时我们的命令提示符仍然在底部：
- en: '![](img/341bd30a-1ad4-4a5f-8392-e7cfdad9e198.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/341bd30a-1ad4-4a5f-8392-e7cfdad9e198.png)'
- en: As you can see, the TUI indicates that we have a breakpoint on the left, with
    the `B+>` symbol on line 18\. We can scroll through the code listing in the TUI
    panel to view our entire source code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，TUI指示我们在第18行有一个断点，符号为`B+>`。我们可以通过TUI面板中的代码列表来滚动查看我们的整个源代码。
- en: '**Note**: If the TUI screen renders incorrectly, you can type in `refresh`
    and it will redraw the panels and code listing afresh.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：如果TUI屏幕渲染不正确，你可以输入`refresh`并重新绘制面板和代码列表。'
- en: 'Now, we''ll go through our program line by line. To do that, we have two available
    commands: `next` and `step`. The first is for running through the program line
    by line, while `step` allows you to jump within a function and go through the
    instructions within it line by line. We want to use `next`, which will take us
    to the next line 19, instead of stepping inside the details of Rust''s standard
    library API calls. Run the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐行通过我们的程序。为此，我们有两个可用的命令：`next`和`step`。第一个是逐行运行程序，而`step`允许你跳入函数并逐行执行其中的指令。我们想使用`next`，这将带我们到下一行19，而不是进入Rust标准库API调用的细节。运行以下代码：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have to do this two more times before we reach the Fibonacci function. We
    can run the last command by just pressing *Enter* on the keyboard. In this case,
    pressing *Enter* two times will run the next two lines of code. Now, we''re right
    before the Fibonacci invocation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在达到斐波那契函数之前，我们还需要做两次这样的操作。我们可以通过在键盘上按*Enter*键来运行最后一个命令。在这种情况下，按*Enter*键两次将运行下一行代码。现在，我们就在斐波那契调用的前面：
- en: '![](img/b9b705eb-db3d-42ea-8d03-d91d22b353b2.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9b705eb-db3d-42ea-8d03-d91d22b353b2.png)'
- en: 'Before we step inside the Fibonacci function, let''s examine the `pos` variable
    to check that it''s not some garbage or a `0`. We can do this with the `print`
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入斐波那契函数之前，让我们检查`pos`变量，确保它不是一些垃圾或`0`。我们可以使用`print`命令来做这件事：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Okay, our `pos` is correct. Now, we are at line 20, which is right before our
    `fibonacci` invocation. Now, use the `step` command to walk inside the `fibonacci`
    function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的`pos`是正确的。现在，我们处于第20行，正好在我们调用`fibonacci`之前。现在，使用`step`命令进入`fibonacci`函数：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are now at line 6:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在第6行：
- en: '![](img/51897497-e5fb-4cc6-b9ef-a56533d39b0c.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51897497-e5fb-4cc6-b9ef-a56533d39b0c.png)'
- en: 'Next, let''s step through the code line by line. While we are stepping through
    code in our Fibonacci function, we can examine the variables by using the `info
    locals` and `info args` commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们逐行执行代码。当我们正在斐波那契函数中逐行执行代码时，我们可以使用`info locals`和`info args`命令来检查变量：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding output shows the `iter` variable in the third iteration. The next
    line shows all the other variables being used in our function. We can see that,
    on every iteration, the `c` variable is being reassigned `0`. This is because
    we have `let c = a + b;`, which shadows the `c` variable that was declared outside
    of the loop. Rust allows you to redeclare a variable with the same name. We have
    found our bug here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了第三次迭代的`iter`变量。下一行显示了函数中使用的所有其他变量。我们可以看到，在每次迭代中，`c`变量都被重新赋值为`0`。这是因为我们有`let
    c = a + b;`，它遮蔽了在循环外部声明的`c`变量。Rust允许你使用相同的名称重新声明一个变量。我们在这里找到了我们的错误。
- en: 'We''ll remove our bug by removing the redeclaration of `c`. The Fibonacci function
    changes to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过删除`c`的重新声明来移除我们的错误。斐波那契函数变为以下形式：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With that, let''s take the program for another spin. This time, we''ll run
    it without the gdb debugger:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们再次运行这个程序。这次，我们将不带gdb调试器运行它：
- en: '![](img/334ac92a-d281-48bc-bfc4-2ac17048ea79.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/334ac92a-d281-48bc-bfc4-2ac17048ea79.png)'
- en: We now have the correct output, that is, `2`, for the fourth Fibonacci number.
    Those are the basics of using gdb to debug Rust code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了正确的输出，即第四个斐波那契数的`2`。这些都是使用gdb调试Rust代码的基本知识。
- en: Similar to gdb, lldb is another debugger that is compatible with Rust.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与 gdb 类似，lldb 是另一个与 Rust 兼容的调试器。
- en: Next, let's look at how to integrate gdb with a code editor.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何将 gdb 与代码编辑器集成。
- en: Debugger integration with Visual Studio Code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code 的调试器集成
- en: Using debuggers from the command line is the usual way to debug your program.
    This is also an important skill, as you could easily wind up in a situation where
    your more advanced coding platform is not available. For instance, you may need
    to debug a program that is already running in production. Attaching to a running
    process is possible with both `gdb` and `lldb`, but you may not be able to attach
    to the running program from within your editor.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行中的调试器是调试程序的一种常见方式。这也是一项重要的技能，因为您可能会遇到更高级的编码平台不可用的情况。例如，您可能需要调试一个已经在生产中运行的程序。使用
    `gdb` 和 `lldb` 都可以附加到正在运行的进程，但您可能无法从您的编辑器中附加到正在运行的程序。
- en: Nevertheless, in a typical development environment setting, you would use a
    code editor or an IDE, which is convenient if you can debug your program from
    the editor right away, without leaving your editor. In this way, you get a much
    smoother debugging experience and a faster feedback loop with editors that are
    properly integrated with debuggers. In this section, we'll look at how to integrate
    gdb with **vscode**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在典型的开发环境设置中，您会使用代码编辑器或 IDE，如果您可以直接从编辑器调试程序而不离开编辑器，这将非常方便。这样，您将获得一个与调试器正确集成的编辑器提供的更流畅的调试体验和更快的反馈循环。在本节中，我们将探讨如何将
    gdb 集成到 **vscode** 中。
- en: 'To set up gdb with vscode, we need to install the **Native Debug** extension.
    With our vscode editor open, we''ll press *Ctrl* + *Shift* + *P* and type `install
    extension`. Alternatively, you can select the extension icon at the bottom left,
    as shown in the following screenshot, and type `native debug`. By doing this,
    we get the page for the Native Debug extension:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 vscode 中设置 gdb，我们需要安装 **Native Debug** 扩展。在打开我们的 vscode 编辑器后，我们将按 *Ctrl*
    + *Shift* + *P* 并输入 `install extension`。或者，您可以选择左下角的扩展图标，如图所示，并输入 `native debug`。通过这样做，我们将获得
    Native Debug 扩展的页面：
- en: '![](img/6e65e9ec-80b0-49d4-ab17-5bdde34a90b9.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e65e9ec-80b0-49d4-ab17-5bdde34a90b9.png)'
- en: 'We''ll click on Install and wait for the installation to complete. Once the
    extension has been installed, we''ll click on reload to restart Visual Studio
    Code. This enables any newly installed extension. Next up, we''ll open our `buggie`
    directory inside vscode, click on the **Debug** menu at the top, and select **Start
    Debugging**, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将点击安装并等待安装完成。一旦扩展被安装，我们将点击重新加载以重新启动 Visual Studio Code。这将启用任何新安装的扩展。接下来，我们将在
    vscode 中打开我们的 `buggie` 目录，点击顶部的 **调试** 菜单，并选择 **开始调试**，如图所示：
- en: '![](img/f68dd9ef-df43-4207-87fa-727fe6f24c73.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f68dd9ef-df43-4207-87fa-727fe6f24c73.png)'
- en: 'From here, we''ll be asked to choose an environment, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将被要求选择一个环境，如下所示：
- en: '![](img/f0deef13-5c32-4c8c-bb0a-6e4a1d1881ae.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0deef13-5c32-4c8c-bb0a-6e4a1d1881ae.png)'
- en: 'The `NativeDebug` extension supports both gdb and lldb. We''ll choose gdb from
    this menu. This will open up a new `launch.json` configuration file for configuring
    our debug session for this project. It''s created in the same project root, under
    a directory called `.vscode/`. If it doesn''t open, we can manually create the
    `.vscode/` directory with a `launch.json` inside it. We''ll fill this `launch.json`
    with the following configuration:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`NativeDebug` 扩展支持 gdb 和 lldb。我们将从这个菜单中选择 gdb。这将打开一个新的 `launch.json` 配置文件，用于配置本项目的调试会话。它位于同一项目根目录下的
    `.vscode/` 目录中。如果它没有打开，我们可以手动创建一个包含 `launch.json` 的 `.vscode/` 目录。我们将用以下配置填充这个
    `launch.json`：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `launch.json` file sets up important details for gdb and vscode, such as
    the target to invoke and the arguments to use. The other fields will be automatically
    populated for you in most cases. The only configuration that''s specific to our
    project is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch.json` 文件为 gdb 和 vscode 设置了重要的详细信息，例如要调用的目标和使用参数。在其他大多数情况下，其他字段将自动为您填充。我们项目的特定配置如下：'
- en: We added a name to our configuration, that is, `"Buggie demo"`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们给我们的配置添加了一个名称，即 `"Buggie demo"`。
- en: We added a `gdbpath` variable pointing to `rust-gdb`. This will launch `gdb`
    via the `rust-gdb` wrapper, which knows how to pretty-print complex data types
    in Rust.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个指向 `rust-gdb` 的 `gdbpath` 变量。这将通过 `rust-gdb` 包装器启动 `gdb`，该包装器知道如何在 Rust
    中格式化打印复杂的数据类型。
- en: We pointed the `target` field to our debugging binary, that is, `target/debug/buggie`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `target` 字段指向我们的调试二进制文件，即 `target/debug/buggie`。
- en: 'We''ll save this file. Next, let''s add a breakpoint to our program in the
    editor. We can do this by clicking on the left-hand side of the text area in vscode,
    as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存此文件。接下来，让我们在编辑器中为我们的程序添加一个断点。我们可以通过在 vscode 中的文本区域左侧单击来实现，如下面的截图所示：
- en: '![](img/2f3acd8e-479c-494b-92ee-75fc725e7419.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f3acd8e-479c-494b-92ee-75fc725e7419.png)'
- en: 'In the preceding screenshot, if you hover over the left-hand side, you will
    see a faded red mark appear. We can click to the left of this to set our breakpoint,
    which will then show up as a red blip. Once we''ve done that, we''ll press *F5*
    to start gdb inside vscode. Once gdb runs and hits our breakpoint, our code editor
    will look something like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，如果您将鼠标悬停在左侧，您将看到一个淡红色的标记出现。我们可以点击此标记的左侧来设置断点，然后它将显示为红色的小点。一旦我们完成设置，我们将按
    *F5* 键在 vscode 中启动 gdb。一旦 gdb 运行并遇到我们的断点，我们的代码编辑器将看起来像这样：
- en: '![](img/0d6b967c-c135-4946-9989-ea8790bd49e4.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d6b967c-c135-4946-9989-ea8790bd49e4.png)'
- en: At the top center, we can see the usual controls, such as step over, step into,
    or to pause/stop the debugging in our code. On the left-hand pane, we can get
    information about the variables in the current stack frame. At the bottom left,
    we have information about our call stack. In the middle on the left, we can watch
    for any variable. In the preceding code, I added a watch to our `c` variable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部中心，我们可以看到常用的控件，例如单步执行、进入或暂停/停止代码中的调试。在左侧面板中，我们可以获取有关当前堆栈帧中变量的信息。在左下角，我们有关于我们的调用堆栈的信息。在左侧中间，我们可以监视任何变量。在上面的代码中，我添加了对我们的
    `c` 变量的监视。
- en: 'The program is now paused at line 9\. We can also hover over our variables
    in the code to view their values, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在暂停在第 9 行。我们还可以将鼠标悬停在代码中的变量上以查看它们的值，如下面的截图所示：
- en: '![](img/17996914-cf81-4a50-a5c3-dc9239d74b78.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17996914-cf81-4a50-a5c3-dc9239d74b78.png)'
- en: 'This is quite helpful. Those were the basics of using gdb with vscode. Next,
    let''s go through a brief overview of another debugger that is very helpful in
    debugging multi-threaded code: the RR debugger.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有帮助。这些都是使用 vscode 与 gdb 配合使用的基础知识。接下来，让我们简要概述另一个在调试多线程代码时非常有用的调试器：RR 调试器。
- en: RR debugger – a quick overview
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RR 调试器 – 快速概述
- en: Apart from gdb and lldb, rr is another powerful debugger that is quite helpful
    in debugging multi-threaded code which is harder to debug due to its non-determinism. Often,
    when debugging multi-threaded code, a certain section of code triggers a bug but
    fails to reproduce in subsequent executions of the program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 gdb 和 lldb，rr 是另一个在调试多线程代码时非常有用的强大调试器，由于它的非确定性，调试起来比较困难。通常，在调试多线程代码时，某个代码段会触发一个错误，但在程序后续执行中无法重现。
- en: Bugs arising due to multi-threaded code are also referred to as heisenbugs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多线程代码引起的错误也被称为海森堡错误。
- en: The rr debugger can perform a reproducible debugging session for non-deterministic,
    multi-threaded code. It does this by recording the debugging session, which you
    can replay and track incrementally to close in on the issue. It does this by first
    saving the trace of the program to disk with all the required information to reproduce
    the program execution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: RR 调试器可以为非确定性的多线程代码执行可重现的调试会话。它是通过记录调试会话来实现的，您可以回放并逐步跟踪以缩小问题范围。它是通过首先将程序的跟踪保存到磁盘上，并包含所有重现程序执行所需的信息来做到这一点的。
- en: 'One of the limitations of rr is that it is only supported on Linux and on Intel
    CPUs as of now. To set up the rr debugger on Ubuntu 16.04, we''ll pull the latest
    `.deb` package from [https://github.com/mozilla/rr/releases](https://github.com/mozilla/rr/releases).
    At the time of writing, the rr version is at `5.2.0`. Having downloaded the `deb`
    package, we can then install rr by running the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: RR 的一个限制是，目前它只支持 Linux 和 Intel CPU。要在 Ubuntu 16.04 上设置 RR 调试器，我们将从 [https://github.com/mozilla/rr/releases](https://github.com/mozilla/rr/releases)
    拉取最新的 `.deb` 软件包。在撰写本文时，rr 版本为 `5.2.0`。下载完 `deb` 软件包后，我们可以通过运行以下代码来安装 rr：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Note**: It''s a prerequisite to install perf tools. You can install them
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：安装 perf 工具是先决条件。你可以按照以下步骤安装它们：'
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Replace linux-tools-(version) as applicable for your kernel version. You can
    get the kernel version with the `uname -a` command on Linux. Another prerequisite
    is to set the `sysctl` flag in `perf_event_paranoid` from `3` to `-1`. It''s recommended
    that you set this temporarily by running the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的内核版本，将`linux-tools-(version)`替换为适用版本。您可以在Linux上使用`uname -a`命令获取内核版本。另一个先决条件是将`sysctl`标志在`perf_event_paranoid`中从`3`更改为`-1`。建议您通过运行以下代码临时设置此标志：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With that done, let''s quickly create a new project by running `cargo new rr_demo`
    and go through a debugging session with rr. We''ll explore how to use the rr debugger
    for a sample program which demonstrates non-determinism. We''ll depend on the
    `rand` crate, which we can add to the `Cargo.toml` file by running `cargo add
    rand`. We have the following code in our `main.rs` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，让我们快速通过运行`cargo new rr_demo`来创建一个新的项目，并使用rr进行调试会话。我们将探索如何使用rr调试器对示例程序进行调试，该程序演示了非确定性。我们将依赖`rand`包，我们可以通过运行`cargo
    add rand`将其添加到`Cargo.toml`文件中。在我们的`main.rs`文件中有以下代码：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a minimal, non-deterministic program that spawns `10` threads and prints
    them to stdout. To highlight the reproducibility aspect of rr, we'll spawn threads
    and sleep for a random duration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小化、非确定性的程序，它启动`10`个线程并将它们打印到标准输出。为了突出rr的可重复性方面，我们将启动线程并随机休眠。
- en: 'First, we need to record the program''s execution with rr. This is done by
    running the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用rr记录程序的执行。这是通过运行以下代码完成的：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This gives us the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![](img/13721b87-e2d2-4c9e-a94b-fa2db2030ac4.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13721b87-e2d2-4c9e-a94b-fa2db2030ac4.png)'
- en: 'On my machine, this records and stores the program execution trace at the following
    location:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，程序执行跟踪被记录并存储在以下位置：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The recorded file, `rr_demo-15`, might be named differently on your machine.
    We can now replay the recorded program by running the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的文件，`rr_demo-15`，在您的机器上可能被命名为不同的名称。现在我们可以通过运行以下代码来重新播放记录的程序：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the session with gdb running under rr:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在rr下运行gdb的会话：
- en: '![](img/c4c6279b-155f-47d8-b1ff-9f65d0a5de8d.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4c6279b-155f-47d8-b1ff-9f65d0a5de8d.png)'
- en: As you can see, the same sequence of numbers gets printed every time, as the
    program is being run from the recorded session in the previous run. This helps
    to debug a multi-threaded program where threads run out of order and might not
    reproduce the bug when you run your program next time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每次运行程序时都会打印出相同的数字序列，因为程序是从上一次运行中记录的会话中运行的。这有助于调试多线程程序，其中线程运行顺序混乱，并且您下次运行程序时可能无法重现错误。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a hands-on approach to debugging Rust code using existing
    debuggers with GNU's `gdb`. We also configured gdb with vscode, giving us a convenient
    click-based UI for debugging our code. Finally, we got a glimpse of how the rr
    debugger can make debugging multi-threaded code deterministic.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用GNU的`gdb`和现有的调试器来手动调试Rust代码。我们还配置了gdb与vscode，为我们提供了一个方便的基于点击的UI来调试我们的代码。最后，我们了解到了rr调试器如何使多线程代码的调试变得确定性。
- en: With this, we have come to the end of our programming journey with Rust.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了使用Rust的编程之旅。
