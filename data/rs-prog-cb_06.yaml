- en: Expressing Yourself with Macros
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用宏表达自己
- en: In the previous century, many languages featured a preprocessor (most prominently,
    C/C++) that often did unassuming text replacement. While this is handy for expressing
    constants (`#define MYCONST 1`), it also leads to potentially unexpected outcomes
    once the replacement gets more complex (for example, `#define MYCONST 1 + 1` and
    when applied as `5 * MYCONST` yields *5 * 1 + 1 = 6* instead of the expected 10
    (from *5 * (1 + 1))* ) .
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个世纪，许多语言都包含一个预处理器（最著名的是 C/C++），它通常执行简单的文本替换。虽然这对于表达常量（例如 `#define MYCONST
    1`）很有用，但当替换变得复杂时（例如，`#define MYCONST 1 + 1` 并将其应用于 `5 * MYCONST` 得到 *5 * 1 + 1
    = 6* 而不是预期的 10（来自 *5 * (1 + 1)*））时，可能会导致意想不到的结果。
- en: 'However, a preprocessor allows program programming (metaprogramming) and therefore
    makes things easier for the developer. Instead of copying and pasting expressions
    and excessive boilerplate code, a quick macro definition leads to a smaller code
    base and reusable calls and—as a consequence—fewer errors. In order to make the
    best use of Rust''s type system, macros cannot simply search and replace text;
    they have to work on a higher level: the abstract syntax tree. Not only does this
    require a different calling syntax (such as an exclamation mark at the end of
    a call; for example, `println!`) for the compiler to know what to do, the parameter
    *types* are different as well.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，预处理器允许程序编程（元编程），因此使开发者的工作变得更简单。通过快速定义宏而不是复制粘贴表达式和过多的样板代码，可以减少代码库的大小，并实现可重用的调用——因此减少了错误。为了充分利用
    Rust 的类型系统，宏不能简单地搜索和替换文本；它们必须在更高的层面上工作：抽象语法树。这不仅需要不同的调用语法（例如，在调用末尾使用感叹号；例如，`println!`），而且参数
    *类型* 也不同。
- en: 'At this level, we are talking about expressions, statements, identifiers, types,
    and many more that can be passed into a macro. Ultimately, however, the macro
    preprocessor still inserts the macro''s body into the calling scope before compilation,
    so the compiler catches type mismatches or borrowing violations. If you want to
    read more on macros, check out the blog post at [https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/](https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/),
    *The Little Book of Rust Macros* ([https://danielkeep.github.io/tlborm/book/index.html](https://danielkeep.github.io/tlborm/book/index.html)),
    and the Rust book ([https://doc.rust-lang.org/book/ch19-06-macros.html](https://doc.rust-lang.org/book/ch19-06-macros.html)).
    Macros are best tried out to get a feel for them—we''ll cover the following in
    this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层面上，我们讨论的是表达式、语句、标识符、类型以及许多可以被传递给宏的内容。然而，最终，宏预处理器仍然在编译前将宏的主体插入到调用作用域中，因此编译器会捕获类型不匹配或借用违规。如果您想了解更多关于宏的信息，请查看博客文章[https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/](https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/)、“Rust
    宏小书”（[https://danielkeep.github.io/tlborm/book/index.html](https://danielkeep.github.io/tlborm/book/index.html)）和
    Rust 书籍（[https://doc.rust-lang.org/book/ch19-06-macros.html](https://doc.rust-lang.org/book/ch19-06-macros.html)）。最好通过尝试来了解宏——我们将在本章中介绍以下内容：
- en: Building custom macros in Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中构建自定义宏
- en: Implementing matching with macros
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用宏进行匹配
- en: Using predefined Rust macros
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预定义的 Rust 宏
- en: Code generation using macros
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用宏进行代码生成
- en: Macro overloading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏重载
- en: Using `repeat` for parameter ranges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `repeat` 为参数范围
- en: Don't Repeat Yourself (DRY)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重复自己（DRY）
- en: Building custom macros in Rust
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中构建自定义宏
- en: Previously, we have mostly used predefined macros—it's now time to look at creating
    custom macros. There are several types of macros in Rust—derive-based, function-like,
    and attributes, all of which have their own respective use cases. In this recipe,
    we'll experiment with the function-like variety to get started.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们主要使用预定义的宏——现在是时候看看如何创建自定义宏了。Rust 中有几种类型的宏——基于 derive 的、函数式和属性，它们各自都有相应的用途。在本食谱中，我们将尝试函数式类型以开始。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'You are only a few steps from creating macros:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需几个步骤就可以创建宏：
- en: Run `cargo new custom-macros` in Terminal (or PowerShell on Windows) and open
    the directory with Visual Studio Code.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端（或在 Windows 上的 PowerShell）中运行 `cargo new custom-macros` 并使用 Visual Studio
    Code 打开该目录。
- en: 'Open `src/main.rs` in the editor. Let''s create a new macro called `one_plus_one`
    at the top of the file:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开 `src/main.rs` 文件。让我们在文件顶部创建一个新的宏，命名为 `one_plus_one`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s call this simple macro inside the `main` function:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们称这个位于 `main` 函数内部的简单宏为：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This was a very simple macro, but macros can do so much more! How about one
    that lets us decide on the operation. Add a very simple macro to the top of the
    file:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个非常简单的宏，但宏可以做更多的事情！比如一个让我们决定操作的宏。在文件顶部添加一个非常简单的宏：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since the words in the **matcher **part of the macro are required, we have
    to call the macro exactly like that. Add the following inside the `main` function:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于宏的**匹配器**部分中的单词是必需的，我们必须像那样精确地调用宏。在`main`函数内部添加以下内容：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As the last part, we should think of keeping things in order; creating modules,
    structs, files, and so on. To group similar behavior is a common way to organize
    stuff, and if we want to use it outside of our module we need to make it publicly
    available. Just like the `pub` keyword, macros have to be exported explicitly—but
    with an attribute. Add this module to `src/main.rs` as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一部分，我们应该考虑保持事物的有序；创建模块、结构体、文件等。将类似的行为分组是一种常见的组织方式，如果我们想在模块外部使用它，我们需要使其公开可用。就像`pub`关键字一样，宏必须显式导出——但是使用一个属性。将此模块添加到`src/main.rs`中，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Thanks to the export, we can now also call this function in `main()`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多亏了导出，我们现在也可以在`main()`中调用这个函数：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By issuing `cargo run` from Terminal inside the project''s directory, we will
    then find out whether it worked:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目目录内的终端中发出`cargo run`命令，我们就可以知道它是否成功了：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to understand the code better, let's decipher these steps.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解代码，让我们来解析这些步骤。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As appropriate, we use a macro—`macro_rules!`—to create a custom macro as we
    did in *step 3*. A single macro matches a pattern and consists of three parts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要，我们使用宏——`macro_rules!`——来创建自定义宏，就像我们在*步骤 3*中所做的那样。一个单独的宏匹配一个模式，并包含三个部分：
- en: A name (for example, `one_plus_one`)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称（例如，`one_plus_one`)
- en: A matcher (for example, `(plus) => ...`)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个匹配器（例如，`(plus) => ...`)
- en: A transcriber (for example, `... => { 1 + 1 }`)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个转录器（例如，`... => { 1 + 1 }`)
- en: Calling a macro is always done using its name followed by an exclamation mark
    (*step 4*), and for specific patterns, with the required characters/words (*step
    6*). Note that `plus` and others are not variables, types, or otherwise defined—which
    gives you the power to create your own **domain-specific language** (**DSL**)!
    More on that in other recipes in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个宏始终是通过它的名称后跟一个感叹号（*步骤 4*）来完成的，对于特定的模式，使用所需的字符/单词（*步骤 6*）。请注意，`plus`和其他的不是变量、类型或以其他方式定义的——这给了您创建自己的**领域特定语言**（**DSL**）的能力！关于这一点，本章的其他菜谱中将有更多介绍。
- en: By calling a macro, the compiler takes note of the position in the **abstract
    syntax tree** (**AST**) and, instead of pure text replacement, inserts the macro's
    transcriber sub-tree right there. Afterward, the compiler tries to finish the
    compilation, leading to regular type-safety checks, borrowing rules enforcement,
    and so on, but with awareness for macros. This makes it easier for you, as the
    developer, to find errors and trace them back into the macros they originate from.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用一个宏，编译器会注意抽象语法树（**AST**）中的位置，并且不是进行纯文本替换，而是在那里插入宏的转录子树。之后，编译器尝试完成编译，导致常规类型安全检查、借用规则执行等，但考虑到宏。这使得作为开发者的您更容易找到错误并将它们追溯到它们起源的宏。
- en: In *step 6*, we create a module to export a macro from—something that will improve
    the code structure and maintainability, especially in larger code bases. However,
    the export step is required since macros are private by default. Try removing
    the `#[macro_export]` attribute to see what happens.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 6*中，我们创建了一个模块来导出一个宏——这将会改善代码结构和可维护性，尤其是在较大的代码库中。然而，导出步骤是必需的，因为宏默认是私有的。尝试移除`#[macro_export]`属性来看看会发生什么。
- en: '*Step 8* shows how to call every macro variation in the project as a comparison. For
    more information, you can also check out the blog post at [https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html](https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html),
    which goes into more detail about providing macro crates on `crates.io` ([https://crates.io](https://crates.io)).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 8* 展示了如何将项目中的每个宏变体作为比较来调用。有关更多信息，您还可以查看[https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html](https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html)上的博客文章，该文章更详细地介绍了在`crates.io`上提供宏crate的内容
    ([https://crates.io](https://crates.io))。'
- en: Now that we know how to build custom macros in Rust, we can move on to the next
    recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在Rust中构建自定义宏，我们可以继续到下一个菜谱。
- en: Implementing matching with macros
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用宏实现匹配
- en: 'When we created custom macros, we had already seen pattern matching at play:
    a command was only executed if particular words were present *before compilation*.
    In other words, the macro system compares raw text as patterns before they become
    expressions or types. Consequently, creating a DSL is really easy. Defining a
    web request handler? Use method names in the pattern: `GET`, `POST`, `HEAD`. There
    is an endless variety, however, so let''s see how we can define some patterns
    in this recipe!'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建自定义宏时，我们已经看到了模式匹配在起作用：只有当特定的单词在编译前存在时，才会执行命令。换句话说，宏系统在它们成为表达式或类型之前将原始文本作为模式进行比较。因此，创建一个领域特定语言（DSL）非常容易。定义一个网络请求处理器？使用模式中的方法名称：`GET`、`POST`、`HEAD`。然而，种类繁多，所以让我们看看在这个菜谱中我们如何定义一些模式！
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'By following these next few steps, you will be able to use macros:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循接下来的几个步骤，您将能够使用宏：
- en: Run `cargo new matching --lib` in Terminal (or PowerShell on Windows) and open
    the directory with Visual Studio Code.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端（或在Windows上的PowerShell）中运行`cargo new matching --lib`，然后用Visual Studio Code打开该目录。
- en: 'In `src/lib.rs`, we add a macro to work with specific types as inputs. Insert
    the following at the top of the file:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/lib.rs`中，我们添加一个宏来处理特定类型的输入。在文件顶部插入以下内容：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Clearly, this should be tested to see whether it works. Replace the `it_works()`
    test with a different test function:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，应该对其进行测试以查看它是否工作。将`it_works()`测试替换为不同的测试函数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The patterns can also contain actual input parameters:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式也可以包含实际的输入参数：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A simple test to round it off is as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的测试来结束它如下：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Handling HTTP requests has always been an architectural challenge, with added
    layers and special routes for every business case. As some web frameworks ([https://github.com/seanmonstar/warp](https://github.com/seanmonstar/warp)) show,
    macros can provide useful support to enable composing handlers together. Add another
    macro and support functions to the file—the `register_handler()` function, which
    mocks registering a handler function for our hypothetical web framework:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理HTTP请求始终是一个架构挑战，每个业务案例都需要添加额外的层和特殊路由。正如一些网络框架（[https://github.com/seanmonstar/warp](https://github.com/seanmonstar/warp)）所示，宏可以提供有用的支持，以使处理器能够组合在一起。向文件中添加另一个宏和支持函数——`register_handler()`函数，该函数模拟为我们的假设网络框架注册处理器函数：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to make sure everything works, we should also add a test for the `web!`
    macro. When the function is empty, a macro that doesn''t match the pattern it
    holds leads to a compile-time error:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保一切正常工作，我们还应该为`web!`宏添加一个测试。当函数为空时，不匹配其包含模式的宏会导致编译时错误：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As the final step, let''s run `cargo test` (note: add `#![allow(unused_variables,
    unused_macros)]`at the top of the file to remove warnings):'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们运行`cargo test`（注意：在文件顶部添加`#![allow(unused_variables, unused_macros)]`以消除警告）：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now let's look at what the code does.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看代码做了什么。
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 2* of this recipe, we define a macro that explicitly provides the different
    patterns that the engine can match to. Specifically, the alphanumeric characters
    are limited to `,`, `;`, and `=>`. While this allows Ruby-style map initialization,
    it also limits the elements that a DSL can have. However, macros are still great
    for creating a more expressive way to deal with situations. In *step 6* and *step
    7*, we show a way to create a web request handler using a more expressive way
    than the usual chained function calls. *Step 4* and *step 5* show the usage of
    the arrow (`=>`) inside macros and *step 8* ties it all together by running the
    tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱的*步骤2*中，我们定义了一个宏，该宏明确提供了引擎可以匹配的不同模式。具体来说，字母数字字符限制为`,`、`;`和`=>`。虽然这允许Ruby风格的映射初始化，但它也限制了DSL可以拥有的元素。然而，宏仍然非常适合创建处理情况的更表达性的方式。在*步骤6*和*步骤7*中，我们展示了使用比常规链式函数调用更表达性的方式创建网络请求处理器的方法。*步骤4*和*步骤5*展示了在宏中使用箭头（`=>`）的用法，而*步骤8*通过运行测试将一切联系起来。
- en: In this recipe, we created matching arms for the macro invocation to use, where
    the arms use a literal matching (instead of matching on the types, which will
    come later in this chapter) to decide on a replacement. This shows that not only
    can we use parameters and literals in one arm but we can also automate tasks without
    the constraints of regularly allowed names.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们为宏调用创建了匹配臂，这些臂使用字面量匹配（而不是在类型上匹配，这将在本章后面介绍）来决定替换项。这表明我们不仅可以在一个臂中使用参数和字面量，还可以在没有常规允许的名称约束的情况下自动化任务。
- en: We've successfully learned how to implement matching in macros. Now let's move
    on to the next recipe.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何在宏中实现匹配。现在让我们继续下一个配方。
- en: Using predefined macros
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预定义的宏
- en: As we saw in the previous recipes in this chapter, macros can save a lot of
    writing and provide convenience functions without having to rethink the entire
    application architecture. Consequently, the Rust standard library provides several
    macros for a range of features that might otherwise be surprisingly complex to
    implement. One example is cross-platform prints—how would that work? Is there
    an equivalent way to output console text for every platform? What about color
    support? What is the default encoding? There are a lot of questions, which is
    an indicator of how many things need to be configurable—yet in a typical program,
    we only call `print!("hello")` and it works. Let's see what else there is.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面的配方中看到的，宏可以节省大量的编写工作，并提供便利函数，而无需重新思考整个应用程序架构。因此，Rust标准库提供了许多宏，用于实现可能在其他情况下出人意料地复杂的各种功能。一个例子是跨平台打印——那将如何工作？是否为每个平台都有一个输出控制台文本的等效方式？关于颜色支持呢？默认编码是什么？有很多问题，这是需要可配置的东西很多的一个指标——然而，在典型的程序中，我们只调用`print!("hello")`，它就工作了。让我们看看还有其他什么。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these few steps to implement this recipe:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下几个步骤来实现这个配方：
- en: 'Run `cargo new std-macros` in Terminal (or PowerShell on Windows) and open
    the directory with Visual Studio Code. Then, create a `a.txt` file inside the
    project''s `src` directory with the following content:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端（或在Windows上的PowerShell）中运行`cargo new std-macros`，然后用Visual Studio Code打开该目录。然后，在项目的`src`目录中创建一个名为`a.txt`的文件，并包含以下内容：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'First, the default implementation of `main()` (in `src/main.rs`) already provides
    us with a macro call to `println!`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`main()`的默认实现（在`src/main.rs`中）已经为我们提供了一个调用`println!`的宏：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can extend the function by printing more. Insert the following after the
    `println!` macro call in the `main()` function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过打印更多内容来扩展函数。在`main()`函数中`println!`宏调用之后插入以下内容：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The definition for `MyStruct` is also simple and involves a procedural macro
    that comes with the standard library. Insert this before the `main()` function:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MyStruct`的定义也很简单，涉及标准库中附带的过程宏。在`main()`函数之前插入以下内容：'
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The Rust standard library also includes macros to interact with the outside
    world. Let''s add a few more calls to the `main` function:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rust标准库还包括与外部世界交互的宏。让我们在`main`函数中添加更多调用：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a final step, let''s add two alternatives to the well-known `println!` and
    `assert!` macros to `main()`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们向已知的`println!`和`assert!`宏添加两个替代方案到`main()`函数中：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you haven''t already, we have to run the entire project using `cargo run`
    to see some output:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，我们必须使用`cargo run`运行整个项目，以查看一些输出：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We should now pull back the curtain to understand the code a bit better.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该揭开面纱，更好地理解代码。
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Inside the `main` function, we now have a few macros that are more or less
    well known. Each of them is doing something we thought was useful. We''ll skip
    *step 2* since it only shows the `println!` macro—something that we are using
    constantly. In *step 3*, however, some more exotic macros turn up:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们现在有几个或多或少为人所知的宏。每个宏都在做我们认为有用的操作。我们将跳过*步骤2*，因为它只显示了`println!`宏——这是我们一直在使用的。然而，在*步骤3*中，出现了一些更奇特的宏：
- en: '`vec!` creates and initializes a vector and famously uses `[]` to do so. However,
    while this makes visual sense, the compiler will accept `vec!()` just as well
    as `vec!{}`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec!`创建并初始化一个向量，并且著名地使用`[]`来这样做。然而，虽然这样做在视觉上是有意义的，编译器同样接受`vec!()`和`vec!{}`。'
- en: '`concat!` joins literals from left to right like a static string.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat!`像静态字符串一样从左到右连接字面量。'
- en: '`stringify!` creates a string literal from the input tokens, regardless of
    whether they exist or not (see the word `helloworld`, which got translated to
    a string).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringify!`从输入的标记中创建一个字符串字面量，无论这些标记是否存在（参见单词`helloworld`，它被转换成了字符串）。'
- en: '*Step 4* includes working with a procedural macro in Rust. While the word *derive*
    and the syntax bring to mind inheritance in classic OOP fashion, they are not
    actually deriving anything but are providing an actual implementation. For us,
    `#[derive(Debug)]` has certainly been the most useful, but there is also `PartialEq`,
    `Eq`, and `Clone`, which are closely behind.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4步*包括在Rust中使用过程宏。虽然单词*derive*和语法让人联想到经典OOP中的继承，但实际上它们并没有派生任何东西，而是提供了实际的实现。对我们来说，`#[derive(Debug)]`无疑是迄今为止最有用的，但还有`PartialEq`、`Eq`和`Clone`，它们紧随其后。'
- en: '*Step 5* of the recipe returns to function-like macros:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱的*第5步*回到了函数式宏：
- en: '`cfg!` is similar to the `#[cfg]` attribute, which makes it possible to determine
    conditions at compile time, which allows you—for example—to include platform-specific
    code.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cfg!`与`#[cfg]`属性类似，这使得在编译时确定条件成为可能，这允许你——例如——包含特定平台的代码。'
- en: '`include_str!` is a very interesting one. There are other includes, but this
    is very useful to provide translation to your applications since it reads the
    provided file''s contents as a `''static str` (just like a literal).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include_str!`是一个非常有趣的宏。还有其他包含宏，但这个宏非常有用，因为它可以将提供的文件内容作为`''static str`（就像字面量一样）提供翻译。'
- en: '`option_env!` reads environment variables at **compile time** to provide an
    `Option` result of their values. Be aware that, in order to reflect the changes
    to the variable, the program has to be re-compiled!'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`option_env!`在**编译时**读取环境变量，以提供其值的`Option`结果。请注意，为了反映变量的更改，程序必须重新编译！'
- en: '*Step 6*''s macros are alternatives to other popular macros that we know:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*第6步*的宏是其他已知流行宏的替代品：'
- en: '`debug_assert!` is a variation of `assert!`, which is not included in `--release`
    builds.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug_assert!`是`assert!`的一个变体，它不包括在`--release`构建中。'
- en: '`eprintln!` outputs stuff on standard error instead of standard out.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eprintln!`将内容输出到标准错误而不是标准输出。'
- en: While this is a pretty stable selection, future releases of the Rust Standard
    Library will include more macros to make working with Rust more convenient. The
    most popular example—at the time of writing—for unfinished macros is `await!`,
    which might never be stabilized due to a different approach to `async`/`await`.
    Check out the full list in the document at [https://doc.rust-lang.org/std/#macros](https://doc.rust-lang.org/std/#macros).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个相当稳定的选项，但Rust标准库的未来版本将包括更多宏，使使用Rust更加方便。在撰写本文时，最受欢迎的未完成宏示例是`await!`，由于对`async`/`await`的不同方法，它可能永远不会稳定。请查看文档中的完整列表：[https://doc.rust-lang.org/std/#macros](https://doc.rust-lang.org/std/#macros)。
- en: Now we've learned more about using predefined macros, we can move on to the
    next recipe.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了更多关于使用预定义宏的知识，我们可以继续到下一个菜谱。
- en: Code generation using macros
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用宏进行代码生成
- en: Something derive-type macros already show us is that we can generate entire
    trait implementations using macros. Similarly, we can generate entire structs
    and functions using macros and avoid copy-and-paste programming, as well as tedious
    boilerplate code. Since macros are executed right before compilation, the generated
    code will be checked accordingly while avoiding the details of strictly typed
    languages. Let's see how!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一些派生类型的宏已经向我们展示了我们可以使用宏来生成整个特质的实现。同样，我们也可以使用宏来生成整个结构体和函数，从而避免复制粘贴编程，以及繁琐的样板代码。由于宏是在编译前执行的，生成的代码将相应地进行检查，同时避免了严格类型语言的细节。让我们看看怎么做吧！
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Code generation can be as easy as these few steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成可以像这些简单的步骤一样简单：
- en: Run `cargo new code-generation --lib` in Terminal (or PowerShell on Windows)
    and open the directory with Visual Studio Code.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端（或在Windows上的PowerShell）中运行`cargo new code-generation --lib`，然后使用Visual Studio
    Code打开该目录。
- en: 'Open `src/lib.rs` and add the first simple macro:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/lib.rs`并添加第一个简单的宏：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s do another one, this time a bit more generative. Add this outside of
    the testing module (for example, underneath the previous macro):'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再来一个，这次稍微更具有生成性。将以下内容添加到测试模块外部（例如，在之前的宏下面）：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Both of those macros are also very straightforward to use. Let''s replace the
    `tests` module with relevant tests:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个宏也非常容易使用。让我们用相关的测试替换`tests`模块：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So far, the macros have not done a sophisticated code generation, however.
    In fact, the first one simply repeats a block several times—something that is
    already available through iterators ([https://doc.rust-lang.org/std/iter/fn.repeat_with.html](https://doc.rust-lang.org/std/iter/fn.repeat_with.html)).
    The second macro creates a function, but that''s available, too, via the closure
    syntax ([https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html](https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html)).
    Let''s add something more interesting then, such as `enum` with a `Default` implementation:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，宏还没有进行复杂的代码生成。实际上，第一个宏只是重复一个块多次——这已经可以通过迭代器（[https://doc.rust-lang.org/std/iter/fn.repeat_with.html](https://doc.rust-lang.org/std/iter/fn.repeat_with.html)）来实现。第二个宏创建了一个函数，但这同样可以通过闭包语法（[https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html](https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html)）来实现。那么，让我们添加一些更有趣的东西，比如具有`Default`实现的`enum`：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Nothing can go untested, so here is a test to see whether it works as expected.
    Add this to the preceding tests:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有什么可以未经测试，所以这里有一个测试来查看它是否按预期工作。将此添加到前面的测试中：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we are writing tests, we also want to see them running:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在编写测试，我们也想看到它们在运行：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In order to understand the code, let's talk about what's going on behind the
    scenes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解代码，让我们谈谈幕后发生的事情。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Thanks to the compiler executing macros before the actual compilation, we can
    generate code that will show up in the final program but that was actually created
    via a macro invocation. This lets us reduce boilerplate code, enforce defaults
    (such as implementing certain traits, adding metadata, and many others), or simply
    provide a nicer interface for users of our crate.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器在真正编译之前执行宏，我们可以生成最终程序中将出现的代码，但实际上是通过宏调用创建的。这使得我们可以减少样板代码，强制执行默认值（例如实现某些特性、添加元数据等），或者为我们的crate的用户提供一个更友好的接口。
- en: In *step 2*, we are creating a simple macro to repeat a block (these curly braces—`{
    }`—and their content are called a **block**) several times—using a `for` loop.
    The tests created in *step 4* show how this operates and what it can do—it executes
    as if we were to write a `for` loop right in the test.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们创建了一个简单的宏来重复一个块（这些花括号`{ }`及其内容被称为**块**）多次——使用`for`循环。在**步骤 4**中创建的测试显示了它的操作方式和它能做什么——它执行得就像我们在测试中直接写一个`for`循环一样。
- en: '*Step 3* creates a more interesting thing: a function. Together with the tests
    in *step 4*, we can see how the macro operates and note the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3**创建了一个更有趣的东西：一个函数。结合**步骤 4**中的测试，我们可以看到宏是如何操作的，并注意以下内容：'
- en: The provided block is evaluated lazily (the test only fails when the function
    is called).
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的块是惰性评估的（只有当函数被调用时测试才会失败）。
- en: The compiler complains about an unused function if it is not called.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数没有被调用，编译器会抱怨未使用的函数。
- en: Creating a parameterized function in this way leads to a compiler error (it
    can't find the value).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以这种方式创建参数化函数会导致编译器错误（它找不到值）。
- en: '*Step 5* creates a more complex macro that is able to create an entire `enum`.
    It lets the user define the variants (even using an arrow—`=>`—notation), and
    adds a default value. Let''s look at the pattern the macro expects: `($name: ident,
    $($variant: ident => $val:expr),+)`. The first parameter (`$name`) is an identifier,
    something that names something (that is, the rules of identifiers are enforced).
    The second parameter is a repeated parameter and it is required to be present
    at least once (indicated by `+`), but if you provide more instances, they have
    to be separated by `,`. The expected pattern for those repetitions is as follows:
    identifier, `=>`, and expression (for example, `bla => 1 + 1`, `Five => 5`, or 
    `blog => 0x5ff`, and many others).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 5**创建了一个更复杂的宏，能够创建一个完整的`enum`。它允许用户定义变体（甚至可以使用箭头`=>`记法），并添加一个默认值。让我们看看宏期望的模式：`($name:
    ident, $($variant: ident => $val:expr),+)`。第一个参数（`$name`）是一个标识符，它命名了某个东西（也就是说，标识符的规则被强制执行）。第二个参数是一个重复参数，它至少需要出现一次（由`+`表示），但如果提供了更多实例，它们必须用逗号分隔。这些重复的期望模式如下：标识符，`=>`，和表达式（例如，`bla
    => 1 + 1`，`Five => 5`，或`blog => 0x5ff`，等等）。'
- en: What follows inside the macro is a classic definition of `enum` with the repeated
    parameter inserted just as often as it occurs in the input. Then, we can add derive
    attributes on top of `enum` and implement the `std::default::Default` trait ([https://doc.rust-lang.org/std/default/trait.Default.html](https://doc.rust-lang.org/std/default/trait.Default.html))
    to provide something sensible for when a default value is required.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 宏内部的内容是`enum`的经典定义，重复参数的插入频率与输入中出现的频率相同。然后，我们可以在`enum`上添加derive属性，并实现`std::default::Default`特质（[https://doc.rust-lang.org/std/default/trait.Default.html](https://doc.rust-lang.org/std/default/trait.Default.html)），以便在需要默认值时提供一些合理的东西。
- en: Let's learn some more about macros and parameters and move on to the next recipe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地了解宏和参数，然后继续下一个菜谱。
- en: Macro overloading
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏重载
- en: 'Method/function overloading is a technique to have duplicate method/function
    names but different parameters for each. Many statically typed languages, such
    as C# and Java, support this in order to provide many ways to call a method without
    having to come up with a new name each time (or use generics). Rust, however,
    does not support that for functions—with good reason ([https://blog.rust-lang.org/2015/05/11/traits.html](https://blog.rust-lang.org/2015/05/11/traits.html)).
    Where Rust does support overloading is with macro patterns: you can create a macro
    and have multiple arms that only differ in their input parameters.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 方法/函数重载是一种技术，它允许有重复的方法/函数名，但每个都有不同的参数。许多静态类型语言，如C#和Java，支持这种技术，以便提供多种调用方法，而无需每次都想出一个新名字（或使用泛型）。然而，Rust不支持函数重载——这是有充分理由的（[https://blog.rust-lang.org/2015/05/11/traits.html](https://blog.rust-lang.org/2015/05/11/traits.html)）。Rust支持重载的地方是宏模式：你可以创建一个宏，并拥有多个只有输入参数不同的分支。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s implement some overloaded macros in a few simple steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个简单的步骤实现一些重载宏：
- en: Run `cargo new macro-overloading --lib` in Terminal (or PowerShell on Windows)
    and open the directory with Visual Studio Code.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端（或在Windows上的PowerShell）中运行`cargo new macro-overloading --lib`，然后用Visual Studio
    Code打开该目录。
- en: 'In `src/lib.rs`, we add the following before the `mod tests` module declaration:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/lib.rs`中，在`mod tests`模块声明之前添加以下内容：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s see how we apply this macro. Inside the `tests` module, let''s see if
    the printer macro serializes strings to a stream by adding the following unit
    test (replace the existing `it_works` test):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们如何应用这个宏。在`tests`模块内部，让我们通过添加以下单元测试来看看打印宏是否将字符串序列化到流中（替换现有的`it_works`测试）：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In order to facilitate testing in the future, we should add another macro inside
    the `tests` module. This time, the macro is mocking ([https://martinfowler.com/articles/mocksArentStubs.html](https://martinfowler.com/articles/mocksArentStubs.html))
    a function with a static return value. Write this after the previous test:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了便于未来的测试，我们应该在`tests`模块中添加另一个宏。这次，这个宏是对一个具有静态返回值的函数进行模拟（[https://martinfowler.com/articles/mocksArentStubs.html](https://martinfowler.com/articles/mocksArentStubs.html)）。在之前的测试之后编写这个：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we should test the `mock!` macro as well. Add another test underneath:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们应该也测试一下`mock!`宏。在下面添加另一个测试：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As a final step, we run `cargo test` to see if it works. However, this time,
    we pass `--nocapture` into the test harness to see what''s been printed (for *step
    3*):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们运行`cargo test`来查看它是否工作。然而，这次，我们将`--nocapture`传递给测试工具，以查看打印了什么（对于*步骤
    3*）：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以更好地理解它。
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Overloading is a very simple concept—so simple, in fact, that it's hard to find
    usable examples that can't be done using a sufficiently complex function. However,
    in this recipe, we think that we have come up with something useful.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重载是一个非常简单的概念——实际上简单到难以找到可用的示例，这些示例不能通过足够复杂的函数来完成。然而，在这个菜谱中，我们认为我们已经找到了一些有用的东西。
- en: 'In *step 2*, we created a wrapper around `println!` and similar functions that
    allow writing to standard streams such as standard output and standard error,
    or any other arbitrary stream type, with only a token to make the difference.
    There are a few interesting details to this implementation outside of this as
    well:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们创建了一个围绕`println!`和类似函数的包装器，允许通过仅用一个标记来写入标准流，如标准输出和标准错误，或者任何其他任意流类型。此外，这个实现还有一些有趣的细节：
- en: Each call to `print!` is followed by `;`—except for the last one, which is why
    there is an extra `;` after the `*`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用`print!`都会跟一个`;`——除了最后一个，这就是为什么在`*`后面还有一个额外的`;`的原因。
- en: The pattern allows for an arbitrary number of expressions to be passed in.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模式允许传入任意数量的表达式。
- en: This macro can be useful to avoid repeating `println!("{:?}", "hello")` just
    to quickly see the current value of a variable. Additionally, it facilitates output
    redirection to standard error.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏可以用来避免重复 `println!("{:?}", "hello")` 只是为了快速查看变量的当前值。此外，它还便于将输出重定向到标准错误。
- en: In *step 3*, we create a test for this macro invocation. In a quick check, we
    print to `error`, `stdout`, and `vec!` (which is why we import `std::io::Write`).
    There, we can see the new line at the end and that it's written as a string (the
    numbers are bytes). In either call, it finds the required macro pattern and inserts
    its contents.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们为这个宏调用创建了一个测试。在快速检查中，我们向 `error`、`stdout` 和 `vec!`（这就是为什么我们导入 `std::io::Write`）打印。在那里，我们可以看到末尾的新行，并且它被写为字符串（数字是字节）。在任何调用中，它都找到了所需的宏模式并插入了其内容。
- en: '*Step 4* creates a macro for mocking functions on structs or entire structs.
    This is very useful for isolating the tests to really only test the target implementation
    without running the risk of adding more errors by trying to implement a supporting
    function. In this case, the macro''s arms are easy to distinguish. The first one
    creates a mock implementation of a function and matches the parameters it requires:
    the type it attaches to, the function''s identifier, which return type, and a
    block that returns that type. The second arm creates a struct and therefore only
    requires an identifier to name the struct and properties together with their data
    types.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 4* 创建了一个宏，用于模拟结构体或整个结构体上的函数。这对于隔离测试，真正只测试目标实现而不冒通过尝试实现辅助函数而添加更多错误的风险非常有用。在这种情况下，宏的分支很容易区分。第一个分支创建了一个函数的模拟实现，并匹配它所需的参数：它附加到的类型、函数的标识符、返回类型以及返回该类型的代码块。第二个分支创建了一个结构体，因此只需要一个标识符来命名结构体及其属性及其数据类型。'
- en: Mocking—or creating a mock object—is a testing technique that allows the creation
    of shallow constructs to simulate the desired behavior. This is very useful for
    things that cannot be implemented otherwise (external hardware, third-party web
    services, and many more) or complex internal systems (database connection and
    logic).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟——或者创建一个模拟对象——是一种测试技术，它允许创建浅层结构来模拟所需的行为。这对于无法以其他方式实现的事物（外部硬件、第三方网络服务等等）或复杂的内部系统（数据库连接和逻辑）非常有用。
- en: 'Next, we have to test these outcomes, which is done in *step 5*. There, we
    call the `mock!` macro and define its behavior along with a test to prove it works.
    We run the tests in *step 6* without the harness capturing the console outputs:
    it works!'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须测试这些结果，这在 *步骤 5* 中完成。在那里，我们调用 `mock!` 宏并定义其行为，以及一个测试来证明它的工作。我们在 *步骤
    6* 中运行测试，没有捕获控制台输出：它工作得很好！
- en: We are certain that overloading macros were a breeze to learn. Now let's move
    on to the next recipe.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确信宏的重载很容易学习。现在让我们继续下一个菜谱。
- en: Using repeat for parameter ranges
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用重复来指定参数范围
- en: 'Rust''s `println!` macro has a curious characteristic: there is no upper limit
    on the number of parameters that you can pass into it. Since regular Rust does
    not support arbitrary parameter ranges, it has to be a macro feature—but which?
    In this recipe, find out how to handle and implement parameter ranges for macros.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的 `println!` 宏有一个奇特的特点：你可以传入的参数数量没有上限。由于常规Rust不支持任意参数范围，它必须是一个宏特性——但是哪个呢？在这个菜谱中，找出如何处理和实现宏的参数范围。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'You''ll know how to use parameter ranges after these few steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这几步，你就会知道如何使用参数范围。
- en: Run `cargo new parameter-ranges --lib` in Terminal (or PowerShell on Windows)
    and open the directory with Visual Studio Code.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端（或在Windows上的PowerShell）中运行 `cargo new parameter-ranges --lib` 并使用Visual Studio
    Code打开该目录。
- en: 'In `src/lib.rs`, add the following code to initialize a set in `vec!` style:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/lib.rs` 中，添加以下代码以在 `vec!` 风格中初始化一个集合：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we''ll add a simple macro to create a DTO—a data transmission object:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个简单的宏来创建一个DTO——数据传输对象：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This needs to be tested as well, so let''s add a test to use the new macro
    to create a set:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也需要进行测试，所以让我们添加一个测试来使用新的宏创建一个集合：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the set initializer tested, let''s also test creating a DTO. Add the following
    under the previous test:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集合初始化后，让我们也测试创建一个DTO。在之前的测试下添加以下内容：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As a final step, we also run `cargo test` to show that it works:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们也运行 `cargo test` 来展示它的工作情况：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Parameter ranges in Rust''s macro system work a little bit like regular expressions.
    There are several parts to the syntax: `$()` indicates repetition, the character
    that follows its separator (`,`, `;`, and `=>` are allowed), and lastly, the qualifier
    for how often the repetition is expected (`+` or `*`—just like regular expressions,
    one or more and zero or more respectively).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的宏系统中参数范围的工作方式有点像正则表达式。语法有几个部分：`$()`表示重复，其分隔符后面的字符（`,`、`;`和`=>`是允许的），最后是重复期望的限定符（`+`或`*`——就像正则表达式一样，一个是或多个，另一个是零个或多个）。
- en: '*Step 2* shows the implementation of a set initializer macro akin to `vec!`.
    There, we expect a single expression to populate `std::collections::HashSet` and
    return the result in a sub-block from the transcriber. This is necessary to allow
    things such as variable assignments (which are not allowed directly within the
    transcriber block), but don''t hinder the expansion of the parameters that were
    passed into the macro. In a similar fashion to the declaration, the expansion
    is done using a `$()` area, but instead of a separator, the repetition qualifier
    follows directly. Whatever is contained in there will be run as many times as
    there are parameters.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二步*展示了类似于`vec!`的集合初始化宏的实现。在那里，我们期望一个表达式来填充`std::collections::HashSet`，并在子块中返回结果。这是必要的，以便允许诸如变量赋值（在transcriber块中不允许直接进行）之类的操作，但不要阻碍传递给宏的参数的展开。与声明类似，展开使用`$()`区域进行，但与分隔符不同，重复限定符直接跟随。其中包含的内容将根据参数的数量运行多次。'
- en: The second macro is defined in *step 3* and is much more complex. The name `dto!`
    (data transmission object) indicates a business object such as a data container
    that is only used to pass data around the program without being sent outside the
    program. Since these DTOs contain a significant amount of boilerplate code, they
    can be initialized similarly to a key-value store. By using the `=>` sign in the
    parameter range specification, we can create identifier/type pairs that are used
    to create properties in `struct` and its constructor function. Note that the comma
    that separates the properties is located right before the `+` sign so it gets
    repeated as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个宏在*第三步*中定义，并且更加复杂。名称`dto!`（数据传输对象）表示一个业务对象，如数据容器，它仅用于在程序内部传递数据，而不会被发送到程序外部。由于这些DTO包含大量的样板代码，它们可以像键值存储一样初始化。通过在参数范围指定中使用`=>`符号，我们可以创建用于在`struct`及其构造函数中创建属性的标识符/类型对。请注意，分隔属性的逗号位于`+`符号之前，因此它也会被重复。
- en: '*Step 4* shows an invocation of the macro designed in *step 2* to populate
    a set and test to confirm it was populated properly. Similarly, *step 5* shows
    the creation and instantiation of a DTO instance (`struct` called `Sensordata`)
    along with a test to confirm that the properties were created as expected. The
    last step confirms this by running the tests.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*第四步*展示了调用在*第二步*中设计的宏以填充集合并测试是否正确填充。同样，*第五步*展示了创建和实例化DTO实例（称为`Sensordata`的结构体）以及测试以确认属性按预期创建。最后一步通过运行测试来确认这一点。'
- en: We've successfully learned how to use repeat for parameter ranges. Now let's
    move on to the next recipe.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用repeat来处理参数范围。现在让我们继续下一个菜谱。
- en: Don't Repeat Yourself
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要重复自己
- en: In a previous recipe, we were using macros to generate almost arbitrary code,
    thereby reducing the amount of code to write. Let's dive deeper into this topic
    since this is a great way not only to reduce bugs but also to achieve consistent
    quality in code. One repetitive task that everyone should do is testing (especially
    if it's a public-facing API), and if we copy and paste those tests we expose ourselves
    to errors. Instead, let's see how we can generate boilerplate code with macros
    to stop repeating ourselves.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们使用宏来生成几乎任意的代码，从而减少了需要编写的代码量。让我们更深入地探讨这个话题，因为这是一个不仅能够减少错误而且能够实现代码一致性的好方法。每个人都应该做的重复性任务之一是测试（尤其是如果它是面向公众的API），如果我们复制粘贴这些测试，我们就会暴露自己于错误之中。相反，让我们看看我们如何使用宏生成样板代码来停止重复。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Automated testing with macros is only a few steps away:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏进行自动化测试只需几个步骤：
- en: Run `cargo new dry-macros --lib` in Terminal (or PowerShell on Windows) and
    open the directory with Visual Studio Code.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端（或在Windows上的PowerShell）中运行`cargo new dry-macros --lib`，然后用Visual Studio Code打开该目录。
- en: 'In `src/lib.rs`, we want to create a helper macro and import the stuff we need:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/lib.rs`中，我们想要创建一个辅助宏并导入所需的库：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we define a macro to auto-implement an operator. Let''s add this underneath
    the `assert_equal_len` macro:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个宏来自动实现一个操作符。让我们在 `assert_equal_len` 宏下面添加这个宏：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s call the macro and actually generate the implementation:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用这个宏并实际生成实现：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With these functions in place, we can now generate the test cases as well!
    Add the following instead of the `test` module:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些函数到位之后，我们现在也可以生成测试用例了！用以下内容替换 `test` 模块：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As a final step, let''s see the generated code in action by running `cargo
    test` to see the (positive) test results:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们通过运行 `cargo test` 来查看生成的代码的实际效果，以查看（积极的）测试结果：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In order to understand the code better, let's decipher the steps.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解代码，让我们分析这些步骤。
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While design patterns, `if-else` constructs, and API design, in general, facilitate
    reusing code, it becomes tricky when it's time to hardcode tokens (for example,
    certain names) to remain loosely coupled. Rust's macros can help with that. As
    an example, we generate functions and tests for those functions in an effort to
    avoid copying and pasting test code around files.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设计模式、`if-else` 构造和一般而言的 API 设计有助于代码重用，但当需要将标记（例如，某些名称）硬编码以保持松散耦合时，就会变得复杂。Rust
    的宏可以帮助解决这个问题。作为一个例子，我们为这些函数生成函数和测试，以避免在文件之间复制和粘贴测试代码。
- en: In *step 3*, we declare a macro that wraps around comparing the lengths of two
    sequences and provides a better error message. *Step 4* uses this macro right
    away and creates a function with the name provided, but only if the lengths of
    the multiple input `Vec` instances match.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第3步* 中，我们声明了一个宏，它围绕比较两个序列的长度并提供更好的错误信息。*第4步* 立即使用这个宏并创建一个具有提供名称的函数，但前提是多个输入
    `Vec` 实例的长度匹配。
- en: 'In *step 5*, we call the macros and provide them with the required input: a
    name (for the function) and types for the generic binding. This creates the functions
    using a provided interface without the need to copy and paste code.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第5步* 中，我们调用宏并提供它们所需的输入：一个名称（用于函数）和泛型绑定的类型。这使用提供的接口创建了函数，而不需要复制和粘贴代码。
- en: '*Step 6* creates the associated tests by declaring the `test` module, a macro
    to generate the tests, and the call to finally create the test code as well. This
    allows you to generate the tests on the fly, right before compiling them, which
    significantly reduces the amount of static, repeated code—which has always been
    an issue in testing. The last step shows that these tests are actually created
    and executed when running `cargo test`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*第6步* 通过声明 `test` 模块、一个用于生成测试的宏以及最终创建测试代码的调用来创建相关的测试。这允许你在编译之前即时生成测试，这显著减少了静态、重复代码的数量——这一直是测试中的一个问题。最后一步显示了这些测试实际上是在运行
    `cargo test` 时创建和执行的。'
