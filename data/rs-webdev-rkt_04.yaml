- en: '*Chapter 3*: Rocket Requests and Responses'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：Rocket请求和响应'
- en: We will discuss Rocket **requests** and **responses** more in this chapter.
    The first section will discuss how Rocket handles incoming requests in the form
    of routes. We will learn about various parts of a route including HTTP methods,
    URIs, and paths. Then, we will create an application that uses various parts in
    routes. We will also talk about Rust **traits** and implement a Rust trait to
    create a request handler.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中更详细地讨论Rocket **请求** 和 **响应**。第一部分将讨论Rocket如何以路由的形式处理传入请求。我们将了解路由的各个部分，包括HTTP方法、URI和路径。然后，我们将创建一个使用路由各个部分的应用程序。我们还将讨论Rust
    **特质**并实现一个Rust特质来创建请求处理器。
- en: We are also going to discuss responses in a Rocket route handler and implement
    returning responses. After that, we will talk more about various built-in responder
    implementations and learn how to create an error handler to create a custom error
    when a route handler fails. Finally, we will implement a generic error handler
    to handle common HTTP status codes such as `404` and `500`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论Rocket路由处理器中的响应，并实现返回响应。之后，我们将更多地讨论各种内置响应实现，并学习如何创建错误处理器以在路由处理器失败时创建自定义错误。最后，我们将实现一个泛型错误处理器来处理常见的HTTP状态代码，如`404`和`500`。
- en: 'By the end of the chapter, you will be able to create the most important part
    of the Rocket framework: functions to handle incoming requests and return responses.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够创建Rocket框架最重要的部分：处理传入请求并返回响应的函数。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding Rocket routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Rocket路由
- en: Implementing route handlers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现路由处理器
- en: Creating responses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应
- en: Making default error handlers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建默认错误处理器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We still have the same technical requirements from [*Chapter 2*](B16825_02_ePub.xhtml#_idTextAnchor032),
    *Building Our First Rocket Web Application* for this chapter. We require a Rust
    compiler to be installed, along with a text editor, and an HTTP client.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对于本章仍然有与[*第二章*](B16825_02_ePub.xhtml#_idTextAnchor032)中*构建我们的第一个火箭Web应用程序*相同的技术要求。我们需要安装Rust编译器、文本编辑器和HTTP客户端。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的源代码：[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03)。
- en: Understanding Rocket routes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Rocket路由
- en: 'We begin our chapter by discussing how Rocket handles incoming requests in
    the form of routes. We write functions that can be used to handle incoming requests,
    put route attribute above those functions, and attach the route handling functions
    to the Rocket. A route has an HTTP method and a `src/main.rs` file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章从讨论Rocket如何以路由的形式处理传入请求开始。我们编写可以用来处理传入请求的函数，将这些函数的上方放置路由属性，并将路由处理函数附加到Rocket上。一个路由包含一个HTTP方法和一个`src/main.rs`文件：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The highlighted lines are the `route` attributes. You can only put the `route`
    attribute in a free function and not in a method inside `impl` of a `Struct`.
    Now, let's discuss the route parts in detail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行是`route`属性。您只能在自由函数中放置`route`属性，而不能在`Struct`的`impl`方法内部放置。现在，让我们详细讨论路由的各个部分。
- en: HTTP methods
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP方法
- en: The first parameter you see inside the route definition is the HTTP method.
    The HTTP method is defined in the `rocket::http::Method` enum. The enum has the
    `GET`, `PUT`, `POST`, `DELETE`, `OPTIONS`, `HEAD`, `TRACE`, `CONNECT`, and `PATCH`
    members, which all correspond to valid HTTP methods defined in RFCs (Request For
    Comments).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由定义内部看到的第一个参数是HTTP方法。HTTP方法在`rocket::http::Method`枚举中定义。该枚举有`GET`、`PUT`、`POST`、`DELETE`、`OPTIONS`、`HEAD`、`TRACE`、`CONNECT`和`PATCH`成员，它们都对应于在RFCs（请求评论）中定义的有效HTTP方法。
- en: 'We can use other attributes to denote a route besides using the `#[route...]`
    macro. We can directly use method-specific route attributes such as `#[get...]`.
    There are seven method-specific route attributes: `get`, `put`, `post`, `delete`,
    `head`, `options`, and `patch`. We can rewrite the previous route attributes into
    the following lines:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`#[route...]`宏之外，我们还可以使用其他属性来表示路由。我们可以直接使用特定方法的路由属性，如`#[get...]`。有七个特定方法的路由属性：`get`、`put`、`post`、`delete`、`head`、`options`和`patch`。我们可以将之前的路由属性重写为以下行：
- en: '[PRE16]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It looks simple, right? Unfortunately, we still have to use the `#[route...]`
    attribute if we want to handle `HTTP CONNECT` or `TRACE` as there are no method-specific
    route attributes for these two methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，对吧？不幸的是，如果我们想要处理`HTTP CONNECT`或`TRACE`，我们仍然必须使用`#[route...]`属性，因为这些方法没有特定于方法的路由属性。
- en: URI
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URI
- en: Inside the route attribute, we can see the `?`) is the path and the part after
    the question mark is the query.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由属性内部，我们可以看到`?`)是路径，问号之后的部分是查询。
- en: Both the path and the query can be divided into `/`), as in `/segment1/segment2`.
    The query is segmented by an ampersand (`&`), as in `?segment1&segment2`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 路径和查询都可以被划分为`/`)，例如`/segment1/segment2`。查询通过`&`符号进行分段，例如`?segment1&segment2`。
- en: A segment can be `/static` or `?static`. The dynamic segment is defined inside
    angle brackets (`<>`), as in `/<dynamic>` or `?<dynamic>`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个段可以是`/static`或`?static`。动态段定义在尖括号`<>`内，例如`/<dynamic>`或`?<dynamic>`。
- en: 'If you declare a dynamic segment, you must use the segment as a function parameter
    in the function following the route attribute. The following is an example of
    how we can use the dynamic segment by writing a new application and adding this
    route and function handler:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个动态段，你必须使用该段作为路由属性之后的函数的参数。以下是我们如何通过编写一个新的应用程序并添加此路由和函数处理程序来使用动态段的示例：
- en: '[PRE18]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Path
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径
- en: 'The argument type in the handler function for the path must implement the `rocket::request::FromParam`
    trait. You might be wondering why we used `u8` as a function argument in the previous
    example. The answer is because Rocket has already implemented the `FromParam`
    trait for important types, such as `u8`. The following is a list of all types
    that have already implemented the `FromParam` trait:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 路径在处理函数中的参数类型必须实现`rocket::request::FromParam`特性。你可能想知道为什么在前面的例子中我们使用了`u8`作为函数参数。答案是Rocket已经为重要类型，如`u8`，实现了`FromParam`特性。以下是一个已经实现`FromParam`特性的所有类型的列表：
- en: Primitive types such as `f32`, `f64`, `isize`, `i8`, `i16`, `i32`, `i64`, `i128`,
    `usize`, `u8`, `u16`, `u32`, `u64`, `u128`, and `bool`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型，如`f32`、`f64`、`isize`、`i8`、`i16`、`i32`、`i64`、`i128`、`usize`、`u8`、`u16`、`u32`、`u64`、`u128`和`bool`。
- en: Rust standard library numerical types in the `std::num` module, such as `NonZeroI8`,
    `NonZeroI16`, `NonZeroI32`, `NonZeroI64`, `NonZeroI128`, `NonZeroIsize`, `NonZeroU8`,
    `NonZeroU16`, `NonZeroU32`, `NonZeroU64`, `NonZeroU128`, and `NonZeroUsize`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust标准库中的`std::num`模块的数值类型，例如`NonZeroI8`、`NonZeroI16`、`NonZeroI32`、`NonZeroI64`、`NonZeroI128`、`NonZeroIsize`、`NonZeroU8`、`NonZeroU16`、`NonZeroU32`、`NonZeroU64`、`NonZeroU128`和`NonZeroUsize`。
- en: Rust standard library `net` types in the `std::net` module, such as `IpAddr`,
    `Ipv4Addr`, `Ipv6Addr`, `SocketAddrV4`, `SocketAddrV6`, and `SocketAddr`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust标准库中的`std::net`模块中的`net`类型，例如`IpAddr`、`Ipv4Addr`、`Ipv6Addr`、`SocketAddrV4`、`SocketAddrV6`和`SocketAddr`。
- en: '`&str` and `String`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&str`和`String`。'
- en: '`Option<T>` and `Result<T, T::Error>` where `T:FromParam`. If you are new to
    Rust, this syntax is for a generic type. T:FromParam means that we can use any
    type `T`, as long as that type implements `FromParam`. For example, we can create
    a `User` struct, implement `FromParam` for `User`, and use `Option<User>` as an
    argument in the function handler.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option<T>`和`Result<T, T::Error>`，其中`T:FromParam`。如果你是Rust的新手，这个语法是泛型类型的。`T:FromParam`意味着我们可以使用任何类型`T`，只要该类型实现了`FromParam`。例如，我们可以创建一个`User`结构体，为`User`实现`FromParam`，并将`Option<User>`用作函数处理器的参数。'
- en: If you write a dynamic segment path, you must use the argument in the handler
    function, or else the code will fail to compile. The code will also fail if the
    argument type does not implement the `FromParam` trait.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写一个动态路径段，你必须使用处理函数中的参数，否则代码将无法编译。如果参数类型没有实现`FromParam`特性，代码同样会失败。
- en: 'Let''s see the error if we don''t use the argument in the handler function
    by removing `id: u8` from the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看如果我们从代码中移除`id: u8`参数，不使用处理函数中的参数会出现什么错误：'
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, let''s write the dynamic segment, which does not implement `FromParam`.
    Define an empty struct and use that as an argument in the handler function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们编写一个动态段，它没有实现`FromParam`。定义一个空的`struct`，并将其用作处理函数中的参数：
- en: '[PRE21]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Again, the code will not compile:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，代码将无法编译：
- en: '[PRE24]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see from the compiler output that type `S` must implement the `FromParam`
    trait.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从编译器的输出中看到，类型`S`必须实现`FromParam`特性。
- en: There is another dynamic form in angle brackets but trailed with two full stops
    (`..`), as in `/<dynamic..>`. This dynamic form is called **multiple segments**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在尖括号中还有一个动态形式，但后面跟着两个句点(`..`)，例如`/<dynamic..>`。这种动态形式被称为**多段**。
- en: If a regular dynamic segment must implement the `FromParam` trait, multiple
    segments must implement the `rocket::request::FromSegments` trait. Rocket only
    provides `FromSegments` implementations for the Rust standard library `std::path::PathBuf`
    type. `PathBuf` is a type for representing a file path in the operating system.
    This implementation is very useful for serving a static file from the Rocket application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个常规动态段必须实现`FromParam`特质，多个段必须实现`rocket::request::FromSegments`特质。Rocket只为Rust标准库`std::path::PathBuf`类型提供`FromSegments`实现。`PathBuf`是一种在操作系统中表示文件路径的类型。这种实现对于从Rocket应用程序中提供静态文件非常有用。
- en: You might think serving from a specific path is dangerous because any person
    can try a path traversal such as `"../../../password.txt"`. Fortunately, the `FromSegments`
    implementation for `PathBuf` has already thought about the security problem. As
    a result, access to sensitive paths has been disabled, for example, `".."`, `"."`,
    or `"*"`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为从特定路径提供服务是危险的，因为任何人都可以尝试路径遍历，例如`"../../../password.txt"`。幸运的是，`PathBuf`的`FromSegments`实现已经考虑了安全问题。因此，对敏感路径的访问已被禁用，例如`".."`、`"."`或`"*"`。
- en: Another segment type is the `<_>` or `<_..>`. If you declare an ignored segment,
    it will not show in the function argument list. You must declare ignored multiple
    segments as the last argument in a path, just like regular multiple segments.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种段类型是`<_>`或`<_..>`。如果你声明一个忽略段，它将不会显示在函数参数列表中。你必须将忽略的多个段作为路径中的最后一个参数声明，就像常规的多个段一样。
- en: 'An ignored segment is useful if you want to build an HTTP path that matches
    a lot of things, but you don''t want to process it. For example, if you have the
    following lines of code, you can have a website that handles any path. It will
    handle `/`, `/some`, `/1/2/3`, or anything else:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想构建一个匹配很多内容但不想处理的HTTP路径，忽略段非常有用。例如，如果你有以下代码行，你可以拥有一个处理任何路径的网站。它将处理`/`、`/some`、`/1/2/3`或任何其他路径：
- en: '[PRE25]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Query
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询
- en: Just like a path, a query segment can be a static segment or dynamic segment
    (such as `"?<query1>&<query2>"`) or can be in a multiple `"?<query..>` form. The
    multiple query form is called `"?<_>"`, or ignored trailing parameters such as
    `"?<_..>"`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像路径一样，查询段可以是静态段或动态段（例如`"?<query1>&<query2>"`）或可以以多个`"?<query..>"`形式存在。多个查询形式称为`"?<_>"`，或者忽略尾随参数，如`"?<_..>"`。
- en: Neither dynamic queries nor trailing parameters are supposed to implement `FromParam`,
    but both must implement `rocket::form::FromForm` instead. We will discuss implementing
    `FromForm` more in [*Chapter 8*](B16825_08_ePub.xhtml#_idTextAnchor101), *Serving
    Static Assets and Templates*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 动态查询和尾随参数都不应该实现`FromParam`，但两者都必须实现`rocket::form::FromForm`。我们将在[*第8章*](B16825_08_ePub.xhtml#_idTextAnchor101)中更详细地讨论实现`FromForm`，*提供静态资源和模板*。
- en: Rank
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排名
- en: 'The path and query segments in a URI can be grouped into three **colors**:
    **static**, **partial**, or **wild**. If all segments of the path are static,
    the path is called a static path. If all segments of the query are static, we
    say the query has a static color. If all segments of the path or query are dynamic,
    we call the path or query wild. The partial color is when a path or query has
    both static and dynamic segments.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: URI中的路径和查询段可以分为三种**颜色**：**静态**、**部分**或**通配符**。如果路径的所有段都是静态的，则该路径称为静态路径。如果查询的所有段都是静态的，我们说查询具有静态颜色。如果路径或查询的所有段都是动态的，我们称路径或查询为通配符。部分颜色是当路径或查询既有静态段又有动态段时。
- en: 'Why do we need these colors? They are required to determine the next parameter
    of the route, which is the **rank**. If we have multiple routes handling the same
    path, then Rocket will rank the functions and *start checking from the rank with
    the lowest number*. Let''s see an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要这些颜色？它们是确定路由的下一个参数，即**排名**所必需的。如果我们有多个处理相同路径的路由，那么Rocket将根据排名对函数进行排序，并从排名最低的函数开始检查。让我们看一个例子：
- en: '[PRE31]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we see we have two functions handling the same path, but with two different
    function signatures. Since Rust does not support function overloading, we created
    the functions with two different names. Let''s try calling each of the routes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们有两个函数处理相同的路径，但具有两个不同的函数签名。由于Rust不支持函数重载，我们创建了两个不同名称的函数。让我们尝试调用每个路由：
- en: '[PRE44]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When we look at the application log in the other terminal, we can see how Rocket
    chose the route:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在另一个终端查看应用程序日志时，我们可以看到Rocket是如何选择路由的：
- en: '[PRE45]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Try reversing the rank in the source code and think about what would happen
    if you called it with `u8` as the parameter. After that, try requesting the endpoint
    to see whether your guess is correct.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在源代码中反转优先级，并思考如果用`u8`作为参数调用会发生什么。之后，尝试请求端点以查看您的猜测是否正确。
- en: 'Let''s recall Rocket''s URI colors. Rocket ranks the colors of both path and
    query as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下Rocket的URI颜色。Rocket将路径和查询的颜色优先级排序如下：
- en: static path, static query = -12
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态路径，静态查询 = -12
- en: static path, partial query = -11
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态路径，部分查询 = -11
- en: static path, wild query = -10
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态路径，通配查询 = -10
- en: static path, none query = -9
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态路径，无查询 = -9
- en: partial path, static query = -8
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分路径，静态查询 = -8
- en: partial path, partial query = -7
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分路径，部分查询 = -7
- en: partial path, wild query = -6
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分路径，通配查询 = -6
- en: partial path, none query = -5
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分路径，无查询 = -5
- en: wild path, static query = -4
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配路径，静态查询 = -4
- en: wild path, partial query = -3
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配路径，部分查询 = -3
- en: wild path, wild query = -2
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配路径，通配查询 = -2
- en: wild path, none query = -1
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配路径，无查询 = -1
- en: You can see the path has a lower rank, static is lower than partial, and finally,
    partial is lower than the wild color. Keep this in mind when you create multiple
    routes, as the output might not be what you expect because your route may have
    a lower or higher ranking.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到路径的优先级较低，静态优先级低于部分，最后，部分优先级低于通配颜色。在创建多个路由时请记住这一点，因为输出可能不是您预期的，因为您的路由可能具有较低的或较高的优先级。
- en: Format
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式
- en: Another parameter we can use in a route is `format`. In requests with the HTTP
    method with a payload, such as `POST`, `PUT`, `PATCH` and `DELETE`, the HTTP request
    `Content-Type` is checked against the value of this parameter. When handling HTTP
    requests without payloads, such as `GET`, `HEAD`, and `OPTIONS`, Rocket checks
    and matches the route's format with the HTTP requests' `Accept` header.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由中我们可以使用的另一个参数是`format`。在具有有效载荷的HTTP方法请求中，例如`POST`、`PUT`、`PATCH`和`DELETE`，HTTP请求的`Content-Type`将与该参数的值进行比较。当处理没有有效载荷的HTTP请求，例如`GET`、`HEAD`和`OPTIONS`时，Rocket会检查并匹配路由的格式与HTTP请求的`Accept`头。
- en: 'Let''s create an example for the `format` parameter. Create a new application
    and add the following lines:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`format`参数创建一个示例。创建一个新的应用程序并添加以下行：
- en: '[PRE46]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you pay attention closely, the format for the `/get` endpoint uses the `"text/plain"`
    IANA (Internet Assigned Numbers Authority) media type, but the format for the
    `/post` endpoint is not the correct IANA media type. This is because Rocket accepts
    the following shorthand and converts them to the correct IANA media type:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，`/get`端点的格式使用的是`"text/plain"` IANA（互联网分配号码权威机构）媒体类型，但`/post`端点的格式不是正确的IANA媒体类型。这是因为Rocket接受以下缩写并将其转换为正确的IANA媒体类型：
- en: '`"any"` → `"*/*"`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"any"` → `"*/*"`'
- en: '`"binary"` → `"application/octet-stream"`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"binary"` → `"application/octet-stream"`'
- en: '`"bytes"` → `"application/octet-stream"`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"bytes"` → `"application/octet-stream"`'
- en: '`"html"` → `"text/html; charset=utf-8"`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"html"` → `"text/html; charset=utf-8"`'
- en: '`"plain"` → `"text/html; charset=utf-8"`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"plain"` → `"text/html; charset=utf-8"`'
- en: '`"text"` → `"text/html; charset=utf-8"`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"text"` → `"text/html; charset=utf-8"`'
- en: '`"json"` → `"application/json"`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"json"` → `"application/json"`'
- en: '`"msgpack"` → `"application/msgpack"`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"msgpack"` → `"application/msgpack"`'
- en: '`"form"` → `"application/x-www-form-urlencoded"`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"form"` → `"application/x-www-form-urlencoded"`'
- en: '`"js"` → `"application/javascript"`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"js"` → `"application/javascript"`'
- en: '`"css"` → `"text/css; charset=utf-8"`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"css"` → `"text/css; charset=utf-8"`'
- en: '`"multipart"` → `"multipart/form-data"`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"multipart"` → `"multipart/form-data"`'
- en: '`"xml"` → `"text/xml; charset=utf-8"`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"xml"` → `"text/xml; charset=utf-8"`'
- en: '`"pdf"` → `"application/pdf"`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"pdf"` → `"application/pdf"`'
- en: 'Now, run the application and call each of the two endpoints to see how they
    behave. First, call the `/get` endpoint with both the correct and incorrect `Accept`
    header:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并调用这两个端点以查看它们的行为。首先，使用正确的和错误的`Accept`头调用`/get`端点：
- en: '[PRE58]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The request with the correct `Accept` header returns the correct response,
    while the request with the incorrect `Accept` header returns `404` but with a
    `"Content-Type: application/json"` response header. Now, send the `POST` requests
    to the `/post` endpoint to see the responses:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '具有正确`Accept`头的请求返回正确的响应，而具有不正确`Accept`头的请求返回`404`，但带有`"Content-Type: application/json"`响应头。现在，向`/post`端点发送`POST`请求以查看响应：'
- en: '[PRE59]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Our application outputs the expected response, but the `Content-Type` of the
    response is not what we expected. We will learn how to create a default error
    handler later in this chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序输出了预期的响应，但响应的`Content-Type`不是我们预期的。我们将在本章后面学习如何创建默认的错误处理器。
- en: Data
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据
- en: 'The `data` parameter in the route is for processing the request body. The data
    must be in a dynamic form such as a dynamic `<something>` URI segment. After that,
    the declared attribute must be included as a parameter in the function following
    the route attribute. For example, look at the following lines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 路由中的`data`参数用于处理请求体。数据必须以动态形式存在，例如动态的`<something>` URI段。之后，声明的属性必须作为参数包含在路由属性之后的函数中。例如，看看以下几行：
- en: '[PRE60]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you do not include `data` as a parameter in the function following the route,
    Rust will complain about it at compile time. Try removing the `data` parameters
    in the function signature and try compiling it to see the compiler error output
    in action.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在路由之后的函数中将`data`作为参数包含，Rust将在编译时对此提出抱怨。尝试从函数签名中移除`data`参数，并尝试编译以查看编译器错误输出的实际效果。
- en: We will learn more about data later when we implement forms and upload files
    to the server. Now that we have learned about Rocket routes, let's make an application
    to implement a route that handles a request.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现表单和上传文件到服务器时，我们将在后面了解更多关于数据的内容。现在我们已经学习了关于Rocket路由的知识，让我们创建一个应用程序来实现处理请求的路由。
- en: Implementing route handlers
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现路由处理器
- en: Here, we will make an application that handles a route. We are reusing the first
    code that we wrote in this chapter. The idea is that we have several user data,
    and we want to send requests that will select and return the selected user data
    according to the ID sent in the request. In this part, we will implement the request
    and selecting part of the route handlers. In the next section, we will learn how
    to create a custom response type. In the subsequent section, we will create a
    handler for when the request does not match any user data we have. And finally,
    in the last section, we will create a default error handler to handle invalid
    requests.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个处理路由的应用程序。我们正在重用本章中编写的第一段代码。想法是我们有多个用户数据，我们希望发送请求以根据请求中发送的ID选择并返回选定的用户数据。在本部分中，我们将实现请求和选择路由处理器的部分。在下一节中，我们将学习如何创建自定义响应类型。在随后的章节中，我们将创建一个处理请求不匹配任何我们拥有的用户数据的处理器。最后，在最后一节中，我们将创建一个默认的错误处理器来处理无效请求。
- en: 'Let''s start by copying the first code into a new folder. After that, in `src/main.rs`,
    add a `User` struct after the `Filter` definition:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先复制第一段代码到一个新的文件夹中。之后，在`src/main.rs`中，在`Filter`定义之后添加一个`User`结构体：
- en: '[PRE73]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: For the `User` struct, we are using `uuid` for object identification. The reason
    is that if we use `usize` or another numeric type as an ID without any authentication,
    we might fall into the **Insecure Direct Object References** (**IDOR**) security
    vulnerability where an unauthorized user can easily guess any number as an ID.
    The UUID as an identifier is harder to guess.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`User`结构体，我们使用`uuid`作为对象标识。原因是如果我们使用`usize`或其他数值类型作为ID而不进行任何认证，我们可能会陷入**不安全的直接对象引用**（**IDOR**）安全漏洞，其中未经授权的用户可以轻易猜测任何数字作为ID。作为标识符的UUID更难以猜测。
- en: Also, in real-world applications, we should probably create transparent encryption
    for the *name* and *age* as such information can be considered personally identifiable
    information, but let's skip it in this book for the sake of learning.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在实际应用中，我们可能需要为*姓名*和*年龄*创建透明加密，因为这些信息可能被视为个人可识别信息，但为了学习的目的，我们在这本书中将其省略。
- en: We also add the `#[derive(Debug)]` attribute on top of the struct. The attribute
    automatically creates an implementation for the struct to be printed using `fmt::Debug`.
    We can then use it in code, such as `format!("{:?}", User)`. One of the requirements
    for the `Debug` attribute is that all type members must implement `Debug` as well;
    however, this is not a problem in our case, as all Rust standard library types
    already implement the `Debug` trait.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在结构体顶部添加了`#[derive(Debug)]`属性。该属性会自动为结构体创建一个用于打印的`fmt::Debug`实现。然后我们可以在代码中使用它，例如`format!("{:?}",
    User)`。`Debug`属性的一个要求是所有类型成员都必须实现`Debug`；然而，在我们的情况下这并不是问题，因为所有Rust标准库类型已经实现了`Debug`特质。
- en: As for the next step, we want to store several `User` data in a collection data
    structure. We can store them in a `[User; 5]` array or a growable `std::vec::Vec`
    array type. To find user data inside the array, we can iterate the array or Vec
    one by one until the end or until a match is found, but this is not ideal as it
    is time-consuming for a large array.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于下一步，我们希望在集合数据结构中存储几个 `User` 数据。我们可以将它们存储在一个 `[User; 5]` 数组或一个可增长的 `std::vec::Vec`
    数组类型中。要找到数组中的用户数据，我们可以逐个迭代数组或 Vec，直到结束或找到匹配项，但这不是最佳方案，因为对于大型数组来说，这很耗时。
- en: In computer science, there are better data structures in which we can store
    data and easily find objects by their index, such as a hash map. Rust has many
    libraries that implement various data structures, and a hash map is one of them.
    In the standard library, we can find it in `std::collections::HashMap`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，有一些更好的数据结构可以用来存储数据，并且可以通过索引轻松找到对象，例如哈希表。Rust 有许多库实现了各种数据结构，哈希表就是其中之一。在标准库中，我们可以在
    `std::collections::HashMap` 中找到它。
- en: Besides using a standard library, we can use other alternatives, since the Rust
    community has already created a lot of data structure-related libraries. Try searching
    in [https://crates.io](https://crates.io) or [https://lib.rs](https://lib.rs).
    For example, if we are not using the standard library, we can use an alternative
    crate such as `hashbrown`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用标准库之外，我们还可以使用其他替代方案，因为 Rust 社区已经创建了许多与数据结构相关的库。尝试在 [https://crates.io](https://crates.io)
    或 [https://lib.rs](https://lib.rs) 中搜索。例如，如果我们不使用标准库，我们可以使用替代 crate，如 `hashbrown`。
- en: 'Let''s implement it in our `src/main.rs` file after the `User` struct declaration.
    Unfortunately, the `HashMap` creation requires heap allocation, so we cannot assign
    `HashMap` to a static variable. Adding the following code will not work:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `User` 结构体声明之后在 `src/main.rs` 文件中实现它。不幸的是，`HashMap` 的创建需要堆分配，所以我们不能将 `HashMap`
    赋值给静态变量。添加以下代码将不起作用：
- en: '[PRE84]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'There are several ways to assign `HashMap` to a static variable, but the best
    suggestion is to use the `lazy_static!` macro from the `lazy_static` crate, which
    runs the code at runtime and performs heap allocation. Let''s add it to our code.
    First, add `lazy_static` in the `Cargo.toml` dependencies:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将 `HashMap` 赋值给静态变量，但最好的建议是使用来自 `lazy_static` crate 的 `lazy_static!`
    宏，它在运行时执行代码并执行堆分配。让我们将其添加到我们的代码中。首先，在 `Cargo.toml` 依赖项中添加 `lazy_static`：
- en: '[PRE101]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'After that, use and implement it in the code as follows. Feel free to add extra
    users if you want to test it later:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式在代码中使用和实现它。如果你想稍后测试，可以随意添加额外的用户：
- en: '[PRE104]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Let''s modify `fn user(...)` as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式修改 `fn user(...)`：
- en: '[PRE119]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We want the function to return something when we call it, therefore, we add
    `-> String` in the function signature.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望函数在调用时返回一些内容，因此我们在函数签名中添加 `-> String`。
- en: '`HashMap` has many methods, such as `insert()` for inserting a new key and
    value, or `keys()`, which returns an iterator for the keys in `HashMap`. We are
    just using `get()`, which returns `std::option::Option`. Remember, `Option` is
    just an enum, which can be `None`, or `Some(T)` if it contains a value. Finally,
    the `match` control flow operator returns a string appropriately depending on
    whether the value is `None` or `Some(u)`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 有许多方法，例如用于插入新键值对的 `insert()` 方法，或者 `keys()` 方法，它返回 `HashMap` 中键的迭代器。我们只是使用了
    `get()` 方法，它返回 `std::option::Option`。记住，`Option` 只是一个枚举，可以是 `None`，或者如果它包含值，则是
    `Some(T)`。最后，`match` 控制流运算符根据值是 `None` 还是 `Some(u)` 返回适当的字符串。'
- en: Now, if we try to send a `GET` request to `http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28`,
    we can see that it will return the correct response, and if we send a `GET` request
    to `http://127.0.0.1:8000/user/other`, it will return `"User not found"`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试向 `http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28`
    发送一个 `GET` 请求，我们可以看到它将返回正确的响应，如果我们向 `http://127.0.0.1:8000/user/other` 发送一个 `GET`
    请求，它将返回 `"User not found"`。
- en: 'Now, let''s implement the `users()` function. Let''s recall the original signature:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现 `users()` 函数。让我们回顾一下原始签名：
- en: '[PRE127]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Because `u8` already implements `FromParam`, we can just use it as it is. But,
    we want to see how we can implement `FromParam` for a custom type. Let's change
    our use case to have a path such as `"/users/<name_grade>?<filters...>"`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `u8` 已经实现了 `FromParam`，所以我们可以直接使用它。但是，我们想看看如何为自定义类型实现 `FromParam`。让我们改变我们的用例，使其路径类似于
    `"/users/<name_grade>?<filters...>"`。
- en: 'First, create a custom `NameGrade` struct. The `''r` annotation means that
    this struct should only live as long as the referenced string in its name field:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个自定义的 `NameGrade` 结构体。`'r` 注解意味着这个结构体应该只在其名称字段中引用的字符串存在期间存在：
- en: '[PRE129]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'If we want to implement a trait, we have to look at the signature of that trait.
    The Rust compiler requires a type to implement all methods and a type placeholder
    in a trait. We can find the trait definition for `FromParam` from the Rocket API
    documentation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要实现一个特性，我们必须查看该特性的签名。Rust 编译器要求类型实现特性中的所有方法和类型占位符。我们可以从 Rocket API 文档中找到
    `FromParam` 的特性定义：
- en: '[PRE133]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The `type Error: Debug;` is called a type placeholder. Some traits require
    the implementation to have a certain type. Any type that implements this trait
    should use a concrete type, which also has a debug trait. Because we just want
    to show an error message, we can use `&''static str` as the `Error` type for this
    implementation. Then, write the trait implementation signature for `NameGrade`
    as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`type Error: Debug;` 被称为类型占位符。某些特性要求实现必须具有某种类型。任何实现了此特性的类型都应该使用一个具体的类型，该类型也具有调试特性。因为我们只想显示错误信息，所以我们可以使用
    `&''static str` 作为此实现的 `Error` 类型。然后，按照如下方式编写 `NameGrade` 的特性实现签名：'
- en: '[PRE137]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Inside the function, add the message that we want to show to the app user:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，将我们想要显示给应用程序用户的消息添加进去：
- en: '[PRE144]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Then, let''s split the input parameter at the `''_''` character:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在 `'_'` 字符处拆分输入参数：
- en: '[PRE145]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The `name_grade_vec` length will be either `2` or `other`, so we can use `match`
    on it. As `name_grade_vec[0]` is a string, we can use it as it is, but for the
    second member, we have to parse it. And, since the result can be anything, we
    have to use a special syntax that is formed as in `::<Type>`. This syntax is fondly
    called **turbofish** by the Rust community.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_grade_vec` 的长度将是 `2` 或 `other`，因此我们可以对它使用 `match`。由于 `name_grade_vec[0]`
    是一个字符串，我们可以直接使用它，但对于第二个成员，我们必须对其进行解析。而且，由于结果可以是任何东西，我们必须使用一种特殊的语法，其形式如下 `::<Type>`。这种语法被
    Rust 社区亲切地称为 **turbofish**。'
- en: 'Just like `Option`, `Result` is just an enum which can either be `Ok(T)` or
    `Err(E)`. If the program successfully parses `u8`, the method can return `Ok(NameGrade{...})`,
    or else the function can return `Err("...")`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `Option` 一样，`Result` 只是一个枚举，可以是 `Ok(T)` 或 `Err(E)`。如果程序成功解析 `u8`，该方法可以返回
    `Ok(NameGrade{...})`，否则函数可以返回 `Err("...")`：
- en: '[PRE146]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Now that we have implemented `FromParam` for `NameGrade`, we can use `NameGrade`
    as the parameter in the `users()` function. We also want `String` as the return
    type of the function:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为 `NameGrade` 实现了 `FromParam`，我们可以在 `users()` 函数中使用 `NameGrade` 作为参数。我们还想将
    `String` 作为函数的返回类型：
- en: '[PRE156]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Inside the function, write the routine that filters the `USERS` hash map with
    `name_grade` and `filters`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，编写用 `name_grade` 和 `filters` 过滤 `USERS` 哈希表的例程：
- en: '[PRE158]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '`HashMap` has the `values()` method, which returns `std::collections::hash_map::Values`.
    `Values` implements `std::iter::Iterator`, so we can filter it using the `filter()`
    method. The `filter()` method accepts a *closure*, which returns Rust bool type.
    The `filter()` method itself returns `std::iter::Filter`, which implements the
    `Iterator` trait. The `Iterator` trait has the `collect()` method, which can be
    used to collect items into the collection. Sometimes, you have to use the `::<Type>`
    turbofish in `collect::<Type>()` if the result type cannot be inferred by the
    compiler.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 有一个 `values()` 方法，它返回 `std::collections::hash_map::Values`。`Values`
    实现了 `std::iter::Iterator`，因此我们可以使用 `filter()` 方法对其进行过滤。`filter()` 方法接受一个 *闭包*，它返回
    Rust 的 bool 类型。`filter()` 方法本身返回 `std::iter::Filter`，它实现了 `Iterator` 特性。`Iterator`
    特性有一个 `collect()` 方法，可以用来将项目收集到集合中。有时，如果结果类型不能被编译器推断出来，你必须使用 `::<Type>` turbofish
    在 `collect::<Type>()` 中。'
- en: 'After that, we can convert the collected users into `String`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将收集到的用户转换为 `String`：
- en: '[PRE165]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'After this is done, run the application and try calling the `users()` function:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，运行应用程序并尝试调用 `users()` 函数：
- en: '[PRE174]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'It works, but the problem with this is that the query parameters are cumbersome;
    we want `Filters` to be optional. Let''s modify the code a little bit. Change
    the signature of `fn users` to the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以工作，但问题是查询参数很麻烦；我们希望 `Filters` 是可选的。让我们稍微修改一下代码。将 `fn users` 的签名更改为以下内容：
- en: '[PRE175]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'You might be confused by this piece of code: `if let Some(fts) = &filters`.
    It''s one of the destructuring syntaxes in Rust, just like this piece of code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会被这段代码弄糊涂：`if let Some(fts) = &filters`。这是 Rust 中的解构语法之一，就像这段代码一样：
- en: '[PRE186]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: We have implemented the requests part for these two endpoints, `user()` and
    `users()`, but the return type for those two endpoints is the Rust standard library
    type, `String`. We want to use our own custom type. So, let's see how we can create
    a response from the `User` struct directly in the next section.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了这两个端点的请求部分，`user()`和`users()`，但那些端点的返回类型是Rust标准库类型`String`。我们想要使用我们自己的自定义类型。所以，让我们在下一节中看看如何直接从`User`结构体创建响应。
- en: Creating responses
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建响应
- en: Let's implement a custom response for the `User` type. In Rocket, all types
    that implement `rocket::response::Responder` can be used as a return type in a
    function that handles routes.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`User`类型实现一个自定义响应。在Rocket中，所有实现了`rocket::response::Responder`的类型都可以用作处理路由的函数的返回类型。
- en: 'Let''s take a look at the signature of the `Responder` trait. This trait requires
    two lifetimes, `''r` and `''o`. The result `''o` lifetime must at least be equal
    to the `''r` lifetime:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Responder`特质的签名。这个特质需要两个生命周期，`'r`和`'o'`。结果生命周期`'o'`必须至少等于`'r'`生命周期：
- en: '[PRE190]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'First, we can include the required module to be used for implementing the `Responder`
    trait for the `User` struct:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以包含实现`User`结构`Responder`特质的所需模块：
- en: '[PRE194]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'After that, add the implementation signature for the `User` struct:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加`User`结构的实现签名：
- en: '[PRE197]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Why do we use `rocket::response::{self...}` instead of `rocket::response::{Result...}`?
    If we return `-> Result`, we cannot use `std::result::Result`, which is a pretty
    ubiquitous type in Rust. Write the following lines in the `respond_to()` method
    body:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用`rocket::response::{self...}`而不是`rocket::response::{Result...}`？如果我们返回`->
    Result`，我们就不能使用在Rust中相当普遍的`std::result::Result`类型。在`respond_to()`方法体中写下以下行：
- en: '[PRE201]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: The application generates a user `String` from the `User` object, then generates
    `rocket::response::Builder` by calling `Response::build()`. We can set various
    payloads for the `Builder` instance; for example, the `sized_body()` method adds
    the body of the response, `raw_header()` and `header()` add the HTTP header, and
    finally, we generate `response::Result()` using the `finalize()` method.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序从`User`对象生成一个用户`String`，然后通过调用`Response::build()`生成`rocket::response::Builder`。我们可以为`Builder`实例设置各种有效载荷；例如，`sized_body()`方法添加响应体，`raw_header()`和`header()`添加HTTP头，最后，我们使用`finalize()`方法生成`response::Result()`。
- en: The first parameter of the `sized_body()` method is `Option`, and the parameter
    can be `None`. As a result, the `sized_body()` method requires the second parameter
    to implement the `tokio::io::AsyncRead + tokio::io::AsyncSeek` trait to automatically
    determine the size. Fortunately, we can wrap the body in `std::io::Cursor` as
    Tokio already implements those traits for `Cursor`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`sized_body()`方法的第一个参数是`Option`，参数可以是`None`。因此，`sized_body()`方法需要第二个参数实现`tokio::io::AsyncRead
    + tokio::io::AsyncSeek`特质以自动确定大小。幸运的是，我们可以将主体包装在`std::io::Cursor`中，因为Tokio已经为`Cursor`实现了这些特质。'
- en: 'There''s a common pattern that we can observe when we implement the `std::iter::Iterator`
    trait and `rocket::response::Builder`, called the `Something` instance by chaining
    the command, such as `Something.new().func1().func2()`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现`std::iter::Iterator`特质和`rocket::response::Builder`时，可以观察到的一个常见模式是通过链式命令调用`Something`实例，例如`Something.new().func1().func2()`：
- en: '[PRE207]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Let's also modify the `users()` function to return a new `Responder`. We are
    defining a new type, which is commonly known as a **newtype** idiom. This idiom
    is useful if we want to wrap a collection or work around **orphan rules**.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也修改`users()`函数以返回一个新的`Responder`。我们正在定义一个新的类型，这通常被称为**newtype**习语。如果我们想包装一个集合或绕过**孤儿规则**，这个习语很有用。
- en: Orphan rules mean neither `type` nor `impl` are in our application or crate.
    For example, we cannot implement `impl Responder for Iterator` in our application.
    The reason is that `Iterator` is defined in the standard library, and `Responder`
    is defined in the Rocket crate.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 孤儿规则意味着`type`或`impl`都不在我们的应用程序或crate中。例如，我们无法在我们的应用程序中实现`impl Responder for
    Iterator`。原因是`Iterator`是在标准库中定义的，而`Responder`是在Rocket crate中定义的。
- en: 'We can use the newtype idiom as in the following line:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下行中的newtype习语：
- en: '[PRE213]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Notice that the struct has a `struct NewType(type1, type2, ...)`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结构体有一个`struct NewType(type1, type2, ...)`。
- en: We can also call a struct with a nameless field a `(type1, type2, type3)`. We
    then can access the struct's field by its index, such as `self.0`, `self.1`, and
    so on.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以调用一个无名称字段的`struct`为`(type1, type2, type3)`。然后我们可以通过索引访问结构体的字段，例如`self.0`、`self.1`等等。
- en: 'After the newtype definition, add the implementation as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在新类型定义之后，添加以下实现：
- en: '[PRE214]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Like the `Responder` implementation for the `User` type, in the `Responder`
    implementation for `NewUser`, we basically iterate a collection of users again,
    collect them as a String, and build the `response::Result` again.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 与为`User`类型实现的`Responder`类似，在`NewUser`的`Responder`实现中，我们基本上再次遍历用户集合，将它们收集为一个字符串，并再次构建`response::Result`。
- en: 'Finally, let''s use both the `User` and `NewUser` structs as a response type
    in the `user()` and `users()` functions:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在`user()`和`users()`函数中使用`User`和`NewUser`结构体作为响应类型：
- en: '[PRE229]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Now that we've learned how to implement the `Responder` trait for a type, let's
    learn more about the wrappers that Rocket offers in the next section.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何为类型实现`Responder`特质，让我们在下一节中了解更多Rocket提供的包装器。
- en: Wrapping Responder
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装响应器
- en: Rocket has two modules that can be used to wrap the returned `Responder`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket有两个模块可以用来包装返回的`Responder`。
- en: 'The first module is `rocket::response::status`, which has the following structs:
    `Accepted`, `BadRequest`, `Conflict`, `Created`, `Custom`, `Forbidden`, `NoContent`,
    `NotFound`, and `Unauthorized`. All the responders except `Custom` set the status
    just like their corresponding HTTP response code. For example, we can modify the
    previous `user()` function as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模块是`rocket::response::status`，它有以下结构体：`Accepted`、`BadRequest`、`Conflict`、`Created`、`Custom`、`Forbidden`、`NoContent`、`NotFound`和`Unauthorized`。除了`Custom`之外的所有响应器都设置状态，就像它们对应的HTTP响应代码一样。例如，我们可以将之前的`user()`函数修改如下：
- en: '[PRE246]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'The `Custom` type can be used to wrap a response with other HTTP code not available
    in the other structs. For example, take a look at the following lines:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`Custom`类型可以用来包装带有其他不在其他结构体中可用的HTTP代码的响应。例如，看看以下行：'
- en: '[PRE252]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'The other module, `rocket::response::content`, has the following structs: `Css`,
    `Custom`, `Html`, `JavaScript`, `Json`, `MsgPack`, `Plain`, and `Xml`. Like the
    `status` module, the `content` module is used to set `Content-Type` of the response.
    For example, we can modify our code to the following lines:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个模块`rocket::response::content`有以下结构体：`Css`、`Custom`、`Html`、`JavaScript`、`Json`、`MsgPack`、`Plain`和`Xml`。与`status`模块类似，`content`模块用于设置响应的`Content-Type`。例如，我们可以将我们的代码修改为以下行：
- en: '[PRE259]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'We can also combine both modules as in the following example:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像以下示例那样结合这两个模块：
- en: '[PRE271]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'We can rewrite this using `rocket::http::Status` and `rocket::http::ContentType`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rocket::http::Status`和`rocket::http::ContentType`重写这一点：
- en: '[PRE275]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'Now, you might be wondering how those structs can create HTTP `Status` and
    `Content-Type` and use another `Responder` implementor body. The answer is because
    the `Response` struct has two methods: `join()` and `merge()`.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道这些结构体如何创建HTTP `Status`和`Content-Type`以及使用另一个`Responder`实现体体。答案是`Response`结构体有两个方法：`join()`和`merge()`。
- en: 'Let''s assume there are two `Response` instances: `original` and `override`.
    The `original.join(override)` method merges the `override` body and status if
    it''s not already present in `original`. The `join()` method also adjoins the
    same headers from `override`.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个`Response`实例：`original`和`override`。`original.join(override)`方法如果`original`中不存在，则合并`override`的体和状态。`join()`方法还会附加来自`override`的相同头。
- en: Meanwhile, the `merge()` method replaces the `original` body and status with
    that of `override`, and replaces the `original` header if it exists in `override`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`merge()`方法用`override`的原始体和状态替换`original`，如果`override`中存在，则替换`original`的原始头。
- en: 'Let''s rewrite our application to use a default response. This time we want
    to add a new HTTP header, `"X-CUSTOM-ID"`. To do so, implement the following function:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写我们的应用程序以使用默认响应。这次我们想要添加一个新的HTTP头`"X-CUSTOM-ID"`。为此，实现以下函数：
- en: '[PRE279]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'Then, modify the `Responder` implementation for the `User` struct:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改`User`结构的`Responder`实现：
- en: '[PRE285]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'Finally, modify the `Responder` implementation for `NewUser`. But this time,
    we want to add extra values: the `"X-CUSTOM-ID"` header. We can do that using
    the `join()` method:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改`NewUser`的`Responder`实现。但这次，我们想要添加额外的值：`"X-CUSTOM-ID"`头。我们可以使用`join()`方法做到这一点：
- en: '[PRE294]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'Try opening the URL for `user` and `users` again; you should see the correct
    `Content-Type` and `X-CUSTOM-ID`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试打开`user`和`users`的URL；你应该看到正确的`Content-Type`和`X-CUSTOM-ID`：
- en: '[PRE303]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: Built-in implementations
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置实现
- en: 'Besides `content` and `status` wrappers, Rocket already implemented the `Responder`
    trait for several types to make it easier for developers. The following is a list
    of types already implementing the `Responder` trait:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`content`和`status`包装器外，Rocket已经为几种类型实现了`Responder`特质，以使开发者更容易使用。以下是一个已经实现`Responder`特质的类型列表：
- en: '`std::option::Option` – We can return `Option<T>` for any type of `T` that
    already implements `Responder`. If the returned variant is `Some(T)`, then `T`
    is returned to the client. We already see the example of this return type in the
    `user()` and `users()` functions.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::option::Option` – 对于任何已经实现了 `Responder` 的 `T` 类型，我们都可以返回 `Option<T>`。如果返回的变体是
    `Some(T)`，则将 `T` 返回给客户端。我们已经在 `user()` 和 `users()` 函数中看到了这种返回类型的示例。'
- en: '`std::result::Result` – Both variants `T` and `E` in `Result<T, E>` should
    implement `Responder`. For example, we can change our `user()` implementation
    to return `status::NotFound` as in the following lines:'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::result::Result` – `Result<T, E>` 中的两种变体 `T` 和 `E` 都应该实现 `Responder`。例如，我们可以将我们的
    `user()` 实现更改为返回 `status::NotFound`，如下所示：'
- en: '[PRE304]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '`&str` and `String` – These types are returned with the text content as the
    response body and `Content-Type "text/plain"`.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&str` 和 `String` – 这些类型以文本内容作为响应体返回，并且 `Content-Type` 为 "text/plain"。'
- en: '`rocket::fs::NamedFile` – This `Responder` trait automatically returns a file
    specified with `Content-Type` based on the file content. For example, we have
    the `"static/favicon.png"` file and we want to serve it in our application. Take
    a look at the following example:'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rocket::fs::NamedFile` – 这个 `Responder` 特性会根据文件内容自动返回一个指定了 `Content-Type`
    的文件。例如，我们有 `"static/favicon.png"` 文件，我们想在应用程序中提供它。请看以下示例：'
- en: '[PRE305]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '`rocket::response::Redirect` – `Redirect` is used to return a `redirect` response
    to the client. We will discuss `Redirect` more in [*Chapter 8*](B16825_08_ePub.xhtml#_idTextAnchor101),
    *Serving Static Assets and Templates*.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rocket::response::Redirect` – `Redirect` 用于向客户端返回一个重定向响应。我们将在 [*第 8 章*](B16825_08_ePub.xhtml#_idTextAnchor101)，*提供静态资源和模板*
    中更详细地讨论 `Redirect`。'
- en: '`rocket_dyn_templates::Template` – This responder returns a dynamic template.
    We will discuss templating more in [*Chapter 8*](B16825_08_ePub.xhtml#_idTextAnchor101),
    *Serving Static Assets and Templates*.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rocket_dyn_templates::Template` – 这个响应者返回一个动态模板。我们将在 [*第 8 章*](B16825_08_ePub.xhtml#_idTextAnchor101)，*提供静态资源和模板*
    中更详细地讨论模板。'
- en: '`rocket::serde::json::Json` – This type makes it easy to return the JSON type.
    To use this responder implementation, you must enable the `"json"` feature in
    `Cargo.toml` as follows: `rocket = {version = "0.5.0-rc.1", features = ["json"]}`.
    We will discuss more about JSON in [*Chapter 11*](B16825_11_ePub.xhtml#_idTextAnchor125),
    *Securing and Adding an API and JSON*.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rocket::serde::json::Json` – 这个类型使得返回 JSON 类型变得容易。要使用这个响应者实现，你必须在 `Cargo.toml`
    中启用 `"json"` 功能，如下所示：`rocket = {version = "0.5.0-rc.1", features = ["json"]}`。我们将在
    [*第 11 章*](B16825_11_ePub.xhtml#_idTextAnchor125)，*安全和添加 API 及 JSON* 中更详细地讨论 JSON。'
- en: '`rocket::response::Flash` – `Flash` is a type of cookie that will be erased
    after a client accesses it. We will learn how to use this type in [*Chapter 11*](B16825_11_ePub.xhtml#_idTextAnchor125),
    *Securing and Adding an API and JSON*.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rocket::response::Flash` – `Flash` 是一种在客户端访问后会被删除的 cookie 类型。我们将在 [*第 11 章*](B16825_11_ePub.xhtml#_idTextAnchor125)，*安全和添加
    API 及 JSON* 中学习如何使用这种类型。'
- en: '`rocket::serde::msgpack::MsgPack` – `"msgpack"` feature in `Cargo.toml`.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rocket::serde::msgpack::MsgPack` – `Cargo.toml` 中的 `"msgpack"` 功能。'
- en: Various `stream` responders in the `rocket::response::stream` module – We will
    learn more about these responders in [*Chapter 9*](B16825_09_ePub.xhtml#_idTextAnchor109),
    *Displaying Users' Post*, and [*Chapter 10*](B16825_10_ePub.xhtml#_idTextAnchor118),
    *Uploading and Processing Posts*.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rocket::response::stream` 模块中的各种 `stream` 响应者 – 我们将在 [*第 9 章*](B16825_09_ePub.xhtml#_idTextAnchor109)，*显示用户帖子*
    和 [*第 10 章*](B16825_10_ePub.xhtml#_idTextAnchor118)，*上传和处理帖子* 中了解更多关于这些响应者的信息。'
- en: We have already implemented a couple of routes, derived `FromParam`, and created
    types that implemented the `Responder` trait. In the next section, we will learn
    how to make a default error catcher for the same kind of HTTP status code.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了一些路由，派生自 `FromParam`，并创建了实现了 `Responder` 特性的类型。在下一节中，我们将学习如何为相同的 HTTP
    状态码创建默认的错误处理器。
- en: Making default error catchers
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建默认错误处理器
- en: An application should be able to handle an error that may occur anytime during
    processing. In a web application, the standardized way to return an error to a
    client is by using an HTTP status code. Rocket provides a way to handle returning
    errors to clients in the form of `rocket::Catcher`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该能够在处理过程中处理可能随时发生的错误。在 Web 应用程序中，将错误返回给客户端的标准方式是使用 HTTP 状态码。Rocket 提供了一种以
    `rocket::Catcher` 的形式处理向客户端返回错误的方法。
- en: 'The catcher handler works just like a route handler, with a few exceptions.
    Let''s modify our last application to see how it works. Let''s recall how we implemented
    the `user()` function:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获处理器的工作方式与路由处理器类似，但有几点例外。让我们修改我们的最后一个应用程序来看看它是如何工作的。让我们回顾一下我们是如何实现 `user()`
    函数的：
- en: '[PRE306]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'If we request `GET /user/wrongid`, the application will return an HTTP response
    with code `404`, a `"text/plain"` content type, and a `"User not found"` body.
    Let''s change the function back to the return `Option`:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求 `GET /user/wrongid`，应用程序将返回一个带有代码 `404`、`"text/plain"` 内容类型和 `"User not
    found"` 体的 HTTP 响应。让我们将函数改回返回 `Option`：
- en: '[PRE310]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'A function returning `Option` where the variant is `None` will use the default
    `404` error handler. After that, we can implement the default `404` handler as
    follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `Option` 的函数，其中变体为 `None`，将使用默认的 `404` 错误处理器。之后，我们可以按以下方式实现默认的 `404` 处理器：
- en: '[PRE313]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: Notice the `#[catch(404)]` attribute above the function. It looks like a route
    directive. We can use any valid HTTP status code between `200` to `599` or `default`.
    If we put `default`, it will be used for any HTTP status code not declared in
    the code.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数上方的 `#[catch(404)]` 属性。它看起来像是一个路由指令。我们可以使用 `200` 到 `599` 或 `default` 之间的任何有效
    HTTP 状态码。如果我们放置 `default`，它将用于代码中未声明的任何 HTTP 状态码。
- en: Like `route`, the `catch` attribute must be put above a free function. We cannot
    put the `catch` attribute above a method inside the `impl` block. Also like the
    route handling function, the catcher function must return a type that implements
    `Responder`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `route` 类似，`catch` 属性必须放在一个自由函数上方。我们无法在 `impl` 块内的方法上方放置 `catch` 属性。同样，与路由处理函数一样，捕获函数必须返回一个实现了
    `Responder` 的类型。
- en: The function handling an error can have zero, one, or two parameters. If the
    function has one parameter, the parameter type must be `&rocket::Request`. If
    the function has two parameters, the first parameter type must be `rocket::http::Status`
    and the second parameter must be `&Request`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误的函数可以有零个、一个或两个参数。如果函数有一个参数，参数类型必须是 `&rocket::Request`。如果函数有两个参数，第一个参数类型必须是
    `rocket::http::Status`，第二个参数必须是 `&Request`。
- en: 'The way the catcher function connects to Rocket is a little bit different.
    Where we use `mount()` and the `routes!` macro for the route handling functions,
    we use `register()` and the `catchers!` macro for catcher functions:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获函数连接到火箭的方式略有不同。在我们使用 `mount()` 和 `routes!` 宏处理路由函数时，我们使用 `register()` 和 `catchers!`
    宏处理捕获函数：
- en: '[PRE317]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'How can we tell a route handling function to use a catcher? Let''s say a catcher
    has been defined and registered as in the following lines:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何告诉路由处理函数使用捕获器？假设一个捕获器已经被定义并注册，如下所示：
- en: '[PRE322]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'We can then return `rocket::http::Status` directly on the route handling function.
    The status will then be forwarded to any registered catcher or Rocket built-in
    catcher:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在路由处理函数中直接返回 `rocket::http::Status`。状态随后将被转发到任何已注册的捕获器或火箭内置的捕获器：
- en: '[PRE331]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'Try calling the `GET` request to this endpoint and see what happens:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调用此端点的 `GET` 请求，看看会发生什么：
- en: '[PRE341]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: The application returns the string from the `403` default handler and the correct
    HTTP status is also returned.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序返回 `403` 默认处理器中的字符串，并且也返回正确的 HTTP 状态。
- en: Summary
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored one of the most important parts of the Rocket framework.
    We learned about a route and its parts such as HTTP methods, URIs, path, query,
    rank, and data. We also implemented a couple of routes and various types related
    to routes in an application. After that, we explored ways to create responder
    types and learned about various wrappers and types already implemented in the
    `Responder` trait. Finally, we learned how to create a catcher and connect it
    to a Rocket application.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了 Rocket 框架最重要的部分之一。我们学习了路由及其组成部分，如 HTTP 方法、URI、路径、查询、排名和数据。我们还实现了一些路由以及与应用程序相关的各种路由类型。之后，我们探讨了创建响应类型的方法，并学习了
    `Responder` 特性中已实现的各个包装器和类型。最后，我们学习了如何创建捕获器并将其连接到 Rocket 应用程序。
- en: In the next chapter, we will learn about other Rocket components such as states
    and fairings. We will learn the initialization process of a Rocket application,
    and how we can use those states and fairings to create more modern and complex
    applications.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习其他火箭组件，例如状态和整流罩。我们将学习火箭应用程序的初始化过程，以及我们如何使用这些状态和整流罩来创建更现代和复杂的应用程序。
