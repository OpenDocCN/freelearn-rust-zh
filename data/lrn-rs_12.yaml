- en: Now It&#x27;s Your Turn!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在轮到你了！
- en: We're rapidly approaching the end of the book and it is time for you to put
    what we've covered and you've learned into practice. As with [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*, this chapter will take the form of a number of challenges
    for you. There is no sample code for this chapter, so it's all down to you. The
    majority of the challenges will be based around the `mathlib` library covered
    in [Chapter 10](part0238.html#72V5S0-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Crate*, as well as using code created in [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正迅速接近本书的结尾，是时候将我们所学的内容付诸实践了。就像 [第 6 章](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d)，*创建您的
    Rust 应用程序* 一样，这一章将采取一系列挑战的形式。这一章没有示例代码，所以一切都要靠你自己。大多数挑战将基于 [第 10 章](part0238.html#72V5S0-a5175cb437d742a9aed0ea574000ee2d)，*创建您的自己的
    crate* 中介绍的 `mathlib` 库，以及使用 [第 6 章](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d)，*创建您的
    Rust 应用程序* 中创建的代码。
- en: Task 1 – cleaning the code (part 1)
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 1 – 清理代码（第一部分）
- en: If you consider the code examples in `temperature.rs`, you will see that some
    use a tuple and some use a single type `return`. While for development this is
    a fairly acceptable approach, for a release we may want something more structured.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑 `temperature.rs` 中的代码示例，你会看到有些使用元组，有些使用单个类型 `return`。虽然对于开发来说这是一个相当可接受的方法，但对于发布版本，我们可能希望有更结构化的东西。
- en: 'Consider the two functions `kelvin_to_celcius` and `celcius_to_farenheit`;
    in order to use them, we need to have two variables:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个函数 `kelvin_to_celcius` 和 `celcius_to_farenheit`；为了使用它们，我们需要有两个变量：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are a number of possible solutions to this problem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种可能的解决方案。
- en: Do nothing! Many libraries use multiple variables when the function returns
    different types.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么也不做！许多库在函数返回不同类型时使用多个变量。
- en: Implement a trait within the module that tests the return for false and returns
    either a `String` containing the answer or *calculation failed*.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块内实现一个特例，该特例测试返回值为假时的情况，并返回一个包含答案的 `String` 或 *计算失败*。
- en: 'Define a single `struct` for the answer of the form, which is then passed back
    to the caller, as follows:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个单一的 `struct` 用于形式化的答案，然后将其传递回调用者，如下所示：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we remove the first option (after all, what would be the point in doing this
    as part of a chapter given over to testing what we have covered?), we are left
    with options 2 - 4 or 3.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除第一个选项（毕竟，在一个专门用于测试我们所学内容的章节中这样做有什么意义？），我们就只剩下选项 2 - 4 或 3。
- en: The problems with each option
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个选项的问题
- en: Each option has its own unique associated problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都有其独特的相关问题。
- en: The String option
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串选项
- en: The issue with the second option is that, if we return a `String` and then want
    to do something else with the answer (possibly a further calculation from one
    of the other modules within the crate), we will need some method of converting
    the string (after checking it doesn't contain the error code) back to an `f32`
    to pass into the second function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项的问题在于，如果我们返回一个 `String`，然后想对答案做其他处理（可能是一个来自其他模块的进一步计算），我们需要一种方法将字符串（在检查它不包含错误代码之后）转换回
    `f32` 以传递给第二个函数。
- en: The struct option
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体选项
- en: The problem with the third option is that, when we call within the library,
    we either have a return type of `tuple(bool, f32)` or `f32`. Therefore, in a function
    that only returns a single type, we will need to set `calc_completed` to `true`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项的问题在于，当我们库内调用时，我们要么返回类型为 `tuple(bool, f32)` 或 `f32`。因此，在只返回单个类型的函数中，我们需要将
    `calc_completed` 设置为 `true`。
- en: 'It is possible to set a default value on the `struct` by deriving or implementing
    `std::Default` (we will cover the standard library in [Chapter 13](part0303.html#90UQE0-a5175cb437d742a9aed0ea574000ee2d),
    *The Standard Library*,  and [Chapter 14](part0359.html#AMBPU0-a5175cb437d742a9aed0ea574000ee2d), *Foreign
    Function Interfaces*). Here''s a derived version:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过派生或实现 `std::Default` 在 `struct` 上设置默认值（我们将在 [第 13 章](part0303.html#90UQE0-a5175cb437d742a9aed0ea574000ee2d)，*标准库*，和
    [第 14 章](part0359.html#AMBPU0-a5175cb437d742a9aed0ea574000ee2d)，*外部函数接口*)中介绍标准库）。这是一个派生版本：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All primitive types in Rust have a sensible default value: numbers are zeroes,
    bool is false, Strings are empty strings, and so on. The preceding code is equivalent
    to the following manually implemented `Default` :'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中所有原始类型都有合理的默认值：数字为零，布尔值为假，字符串为空字符串，等等。前面的代码等同于以下手动实现的 `Default`：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, we want the calc_complete default to be true, so we''ll use this implementation
    instead:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望`calc_complete`的默认值为true，因此我们将使用此实现：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the `Default` implementation, we may choose to only fill in some of the
    values when creating an instance and supply `Default::default()` for the rest:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Default`实现之后，我们可以在创建实例时只填充一些值，并为其余部分提供`Default::default()`：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The potential problem is where to put the struct in terms of scope. Where would
    it be best to place it?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的问题在于将struct放在什么范围内。在哪里放置它最好？
- en: The task
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: You are to decide which one of the options for refactoring the code would work
    best and then implement it. You should create a number of unit tests to ensure
    the sanity checks work and then test it in your own test rig application to ensure
    nothing has broken with the crate and scope.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要决定哪种代码重构选项最适合，然后实现它。您应该创建多个单元测试以确保检查正常工作，然后在您的测试应用中测试以确保crate和作用域没有出现问题。
- en: Task 2 – cleaning the code (part 2)
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务2 - 清理代码（第2部分）
- en: While each function is kept apart in the crate, we can always clean up the code
    to make it safer (we have a single public function and keep the calculations away
    from prying eyes).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个函数在crate中都是分开的，但我们总是可以清理代码以使其更安全（我们有一个公共函数，并将计算远离好奇的目光）。
- en: The task
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: 'Each function takes a single parameter of either the `f32` or `i32` type and
    thankfully, we can separate out the modules to be those that return an `f32` or
    `i32` (the bases all return `i32`: all of the others have their answers in `f32`).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都接受一个参数，该参数为`f32`或`i32`类型，幸运的是，我们可以将模块分开，使其返回`f32`或`i32`（所有基础返回值都是`i32`：其他所有答案都在`f32`中）。
- en: If we look at the temperatures module, everything will return the answer as
    `f32` (after task 1, how it does this is up to you). We can therefore create a
    single function that takes as the first parameter the conversion to be performed
    and as the second the value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看温度模块，所有返回值都将作为`f32`（在任务1之后，如何实现这一点取决于您）。因此，我们可以创建一个单函数，该函数将转换作为第一个参数，值作为第二个参数。
- en: When the single function recognizes the first parameter, it calls the now private
    functions and returns the value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个函数识别出第一个参数时，它将调用现在私有的函数并返回值。
- en: As with the first task, you will need to implement this and create documentation
    for the new library. You should create a new unit test for the crate and test
    it in your test rig application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个任务一样，您需要实现这一点并为新库创建文档。您应该为crate创建一个新的单元测试，并在您的测试应用中测试它。
- en: Task 3 – extending the crate (part 1)
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务3 - 扩展crate（第1部分）
- en: You will have noticed that, in the example library, there is no code at all
    for the `regression_analysis` module. This is deliberate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在示例库中，`regression_analysis`模块根本没有任何代码。这是故意的。
- en: 'Back in [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*, one of the tasks was to create code that enabled
    you to perform a regression analysis based on formulae provided. The code created
    can now be firmly split into two parts:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第6章](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d)，*创建您的Rust应用程序*，其中一个任务是创建代码，使您能够根据提供的公式执行回归分析。现在创建的代码可以明确地分为两部分：
- en: The equation for the straight line, *y = mx + c*, which will also give the intercepts
    on the *x* and *y* axis
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直线的方程，*y = mx + c*，这将给出*x*和*y*轴上的截距
- en: The standard deviation and regression analysis
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准差和回归分析
- en: The task
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: 'In this task, you are to take your code and put it into the `mathslib` crate.
    This may not be as simple as it seems. The library will need to take:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，您需要将您的代码放入`mathslib`crate中。这可能不像看起来那么简单。库需要接受：
- en: A filename for the file containing the data
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据的文件名
- en: A vector containing either a `struct` or `tuple` that holds the data
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个`struct`或`tuple`的向量，该向量用于存储数据
- en: However, the problem doesn't lie in the data, but rather in the fact that, each
    time a calculation is made, the whole regression analysis has to be performed.
    For example, to calculate the standard deviation, you can't just pass in the results
    for the equation of a straight line—that won't work, but will cause the whole
    calculation to be performed again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题不在于数据，而在于每次进行计算时，都必须执行整个回归分析。例如，要计算标准差，您不能只传递直线方程的结果——这样不会工作，但会导致整个计算再次执行。
- en: In terms of the speed of a library, this is very inefficient; you should calculate
    once and be able to draw out all answers from there. In terms of your code, this
    will require some re-organization.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就库的速度而言，这非常低效；你应该计算一次，然后能够从那里提取所有答案。至于你的代码，这需要一些重新组织
- en: Once you have done this, you should create the unit tests for each function
    and test them in your test rig app with both a vector then the filename.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你应该为每个函数创建单元测试，并在你的测试应用中用向量以及文件名来测试它们
- en: You will need to add the documentation for this task to your current documentation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将此任务的文档添加到你的当前文档中
- en: Task 4 – extending the crate (part 2)
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务4 – 扩展crate（第二部分）
- en: 'By now, you will have a firm grasp of how crates work, the required testing
    regime, and creating a test rig. Your final task in this section is to create
    your own extension to the crate. There are some criteria though to your extension:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你将牢固掌握crate的工作方式、所需的测试规范以及创建测试应用。本节你最后的任务是创建自己的crate扩展。不过，你的扩展也有一些标准：
- en: One of the functions must return a non-primitive type
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个函数必须返回一个非原始类型
- en: The calculations should be private; there should be some form of interface to
    the function call
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算应该是私有的；应该有一种形式来访问函数调用
- en: There should be a single function that takes an XML file as a parameter to perform
    the calculation
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个函数，它接受一个XML文件作为参数来执行计算
- en: The new module must be fully documented and complete with its own tests
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新模块必须完全文档化，并包含其自身的测试
- en: Summary
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've finished the main part of the book. We've covered the majority of the
    Rust language and these end-of-section chapters should have helped you consolidate
    your knowledge.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了书籍的主要部分。我们已经涵盖了Rust语言的大部分内容，这些章节的结尾应该有助于你巩固你的知识
- en: In the final part of the book, we'll cover the standard libraries and how to
    interface your Rust application to an external library.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的最后一部分，我们将介绍标准库以及如何将你的Rust应用程序与外部库接口
