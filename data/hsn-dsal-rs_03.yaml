- en: Storing Efficiently
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效存储
- en: 'With the foundation of the previous chapters in place, we can now move on to
    more architectural aspects of algorithms and data structures. Rust—with its ownership
    model—calls for considering lifetimes, memory placement, and mutability in their
    algorithmic design. In this chapter, you can look forward to learning about the
    following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章的基础上，我们现在可以继续探讨算法和数据结构的更多架构方面。Rust——凭借其所有权模型——要求在算法设计中考虑生命周期、内存放置和可变性。在本章中，你可以期待学习以下主题：
- en: Trade-offs considering speed and readability
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑速度和可读性的权衡
- en: Accessing heap and stack variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问堆和栈变量
- en: How immutability influences design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变性如何影响设计
- en: Heaps and stacks
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆和栈
- en: 'As we discussed in [Chapter 1](e07bf37e-f255-42ef-abbb-9f141dc5be61.xhtml),
    *Hello Rust!*, stack variables are preferred thanks to their low overhead and
    speed compared to heap-allocated data, which automatically introduces overhead
    thanks to the necessary heap pointer. For stack variables, Rust''s types even
    allow for zero overhead structures, so no additional metadata is stored. The following
    snippet asserts that there are no additional bytes being used for arrays or user-defined
    types:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第一章](e07bf37e-f255-42ef-abbb-9f141dc5be61.xhtml)中讨论的那样，*Hello Rust!*，由于栈变量相比堆分配数据具有低开销和速度优势，因此栈变量更受欢迎。对于栈变量，Rust的类型甚至允许零开销结构，因此不会存储额外的元数据。以下代码片段断言数组或用户定义类型没有使用额外的字节：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Consequently, the size of an instance of the `MyStruct` type is always going
    to be three bytes—perfectly suitable for placing it on the stack. Why is that
    good? In short, data locality. Instead of pointer dereferencing, the data is stored
    right at the point of execution, making it easy to cache and fast to access.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`MyStruct`类型的实例大小始终是三个字节——非常适合将其放置在栈上。这有什么好处呢？简而言之，数据局部性。与指针解引用不同，数据存储在执行点，这使得它易于缓存且访问速度快。
- en: Types that don't have predictable sizes (such as `String` instances) require
    heap allocation, just like objects that are wrapped into `Rc`, `Cell`, `RefCell`,
    or `Box` instances. However, heap allocations and access come at a considerable
    cost, as minimizing those typically yields great performance improvements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 没有可预测大小（例如`String`实例）的类型需要堆分配，就像被`Rc`、`Cell`、`RefCell`或`Box`实例包裹的对象一样。然而，堆分配和访问代价不菲，因为最小化这些通常能带来巨大的性能提升。
- en: Sized and unsized
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有大小和无大小
- en: 'For the compiler to translate written code into a binary format, it''s necessary
    to know each type''s size. As we discussed earlier, the size is important so that
    we can put other types *on top* when working on the stack, something that is easy
    if the size doesn''t change with respect to the data it contains (a sized type).
    The best example for this is `u32`: it uses 32 bits (or 4 bytes), regardless of
    whether you store `0` or `10000900`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译器能够将编写的代码转换为二进制格式，有必要知道每种类型的大小。正如我们之前讨论的那样，大小很重要，这样我们就可以在栈上放置其他类型，如果大小与其包含的数据无关（有大小类型），这很容易做到。这个最好的例子是`u32`：它使用32位（或4字节），无论你存储`0`还是`10000900`。
- en: This isn't the case when the type is unsized or dynamically sized, the best
    example being a `str`. Depending on the number of characters, this type's size
    will vary considerably, and which is why instances are usually encountered in
    the form of slices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型是无大小或动态大小时，情况并非如此，最好的例子是`str`类型。根据字符数，这种类型的大小会有很大变化，这也是为什么实例通常以切片的形式出现。
- en: Slices are Rust's way of providing generic algorithms to all kinds of data types,
    and they will be discussed more in [Chapter 12](04e371f3-13fa-4c73-9329-8074a080785a.xhtml),
    *Algorithms of the Standard Library*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是Rust提供泛型算法给所有数据类型的方式，它们将在[第12章](04e371f3-13fa-4c73-9329-8074a080785a.xhtml)中进一步讨论，*标准库算法*。
- en: Slices work around the size issue by storing a fixed-size reference (`&str`)
    to the heap-allocated value, along with its length in bytes. Similar to pointers,
    this is a fixed-size view into a previously-unsized value. Every time a pointer
    of some kind (`&`, `Rc`, `Box`, `Cell`, and so on) is created, the reference is
    stored alongside the length and some (fixed size) metadata. The knowledge of sized
    versus unsized is especially useful when the type is previously unknown—when working
    with Rust's generics, for example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 切片通过存储一个固定大小的引用（`&str`）到堆分配的值及其字节数来绕过大小问题。类似于指针，这是一个固定大小的对先前未指定大小的值的视图。每次创建某种类型的指针（`&`、`Rc`、`Box`、`Cell`
    等）时，都会将引用与长度和一些（固定大小）元数据一起存储。当类型事先未知时——例如在处理 Rust 的泛型时——了解大小与未指定大小之间的区别特别有用。
- en: Generics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 'Rust supports generics and even allows us to enforce the implementation of
    certain traits. These constraints can either come as a where clause attached to
    the function definition or with a colon in the generic type declaration:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 支持泛型，甚至允许我们强制实现某些特质。这些约束可以作为一个附加在函数定义上的 where 子句，或者是在泛型类型声明中使用冒号：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, the 2018 `impl Trait` syntax simplifies single-trait requirements
    (to do static instead of dynamic dispatch) for input and return parameters, thereby
    eliminating the need for a `Box` or lengthy type constraints (such as `MyTrait`
    in the preceding snippet). Unless multiple trait implementations are required
    (for example, `fn f(x: T) where T: Clone + Debug + MyTrait {}`), the `impl Trait`
    syntax allows us to put them where they matter, which is into the parameter list:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，2018 年的 `impl Trait` 语法简化了输入和返回参数的单个特质要求（执行静态而不是动态分派），从而消除了使用 `Box` 或冗长的类型约束（如前面片段中的
    `MyTrait`）的需要。除非需要多个特质实现（例如，`fn f(x: T) where T: Clone + Debug + MyTrait {}`），否则
    `impl Trait` 语法允许我们将它们放在它们应该放的地方，即参数列表中：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When working with generics, the situation is a bit more complex. Type parameters
    are `Sized` by default (see the preceding snippet), which means that they will
    not match unsized types. To match those as well, the special `?Sized` type constraint
    can be used. This snippet also shows the required change to passing in a reference:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用泛型时，情况会稍微复杂一些。类型参数默认是 `Sized`（见前面的片段），这意味着它们不会匹配未指定大小的类型。为了匹配这些类型，可以使用特殊的
    `?Sized` 类型约束。这个片段还展示了传递引用所需的更改：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, any type of heap-allocated reference will incur an extra step to access
    the contained value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何类型的堆分配引用在访问包含的值时都会多一个步骤。
- en: Accessing the box
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问盒子
- en: An extra step doesn't sound like much, but it has considerable consequences.
    This trade-off for easily sharing ownership across various functions or threads
    removes the ability to put as much data as possible into the CPU's cache, since
    the pointer makes any data locality difficult. Heap allocations themselves are
    expensive operations and reducing those will already provide a major speedup.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的步骤听起来不多，但它有相当大的影响。这种为了在各个函数或线程之间轻松共享所有权而进行的权衡，消除了尽可能将大量数据放入 CPU 缓存的能力，因为指针使任何数据局部性变得困难。堆分配本身是昂贵的操作，减少这些操作将已经提供重大的速度提升。
- en: Furthermore, the compiler cannot deallocate a boxed value if it's still referenced
    in some places—a problem that occurs especially if the program is large and complex.
    Similar to orphaned objects in C# or Java, a saved `Rc` reference can easily be
    forgotten, creating a memory leak. Therefore, it's recommended to use heap memory
    only when required.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果编译器在某个地方仍然引用了boxed值，它就无法释放boxed值——这个问题在程序大且复杂时尤其明显。类似于 C# 或 Java 中的孤儿对象，一个保存的
    `Rc` 引用很容易被遗忘，从而造成内存泄漏。因此，建议仅在需要时使用堆内存。
- en: One principle piece of advice that requires a boxed value in Rust is to "favor
    object composition over class inheritance" (Gang of Four 1995:20). In the absence
    of class inheritance, the choice is obviously to use object composition. Considering
    that you should also "program to an interface not to an implementation" (ibid),
    there is often a strong wish to put a reference to a trait inside of a `struct`
    instead of directly working with the implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中需要boxed值的一个额外建议是“优先使用对象组合而不是类继承”（Gang of Four 1995:20）。在没有类继承的情况下，显然选择使用对象组合。考虑到你也应该“面向接口编程而不是面向实现”（同上），通常会有一个强烈的愿望将特质的引用放在
    `struct` 中，而不是直接与实现交互。
- en: To apply this architecture in Rust, the language requires us to put a trait's
    implementation into a `Box<dyn TheTrait>`, making it more difficult to handle,
    test, and reason about. This `trait` object requires the compiler to rely on dynamic
    dispatch, which is considerably slower than the default static dispatch.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Rust中应用这种架构，语言要求我们将特质的实现放入`Box<dyn TheTrait>`中，这使得处理、测试和推理变得更加困难。这个特质对象要求编译器依赖于动态分派，这比默认的静态分派要慢得多。
- en: Static and dynamic dispatch are the two major ways of calling functions in many
    programming languages, including Rust. While for static dispatch functions, locations
    are known at compile time, dynamic dispatch functions are only known at runtime
    and have to be looked up in a **vtable** that points to the actual address. Both
    have their merits, so be intentional with their use.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和动态分派是许多编程语言（包括Rust）中调用函数的两种主要方式。对于静态分派函数，位置在编译时已知，而动态分派函数仅在运行时已知，并且必须在指向实际地址的**虚表**中查找。两者都有其优点，所以使用时要谨慎。
- en: Other than generics, there is no default solution to this issue. The `impl Trait`
    addition of Rust 2018 alleviates this issue for function parameters and return
    values, but cannot be used for field types.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了泛型之外，没有默认的解决方案来解决这个问题。Rust 2018的`impl Trait`添加缓解了函数参数和返回值的问题，但不能用于字段类型。
- en: So far, it looks like the best choice is to use concrete types instead of traits
    to avoid multiple dereference operations—as long as refactoring on change seems
    to be doable. If you create a library, generics are a better way to go for performance
    and flexibility.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，看起来最好的选择是使用具体类型而不是特质来避免多次解引用操作——只要在更改时重构似乎可行。如果你创建了一个库，泛型对于性能和灵活性来说是一个更好的选择。
- en: Copying and cloning
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拷贝和克隆
- en: In [Chapter 1](e07bf37e-f255-42ef-abbb-9f141dc5be61.xhtml), *Hello Rust!,* we
    discussed `Send`, a marker trait that allows a type to be "sent" across multiple
    threads. Something that's similar but less complex is local moving, which commonly
    occurs in a program—for example, when you pass a variable into a function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](e07bf37e-f255-42ef-abbb-9f141dc5be61.xhtml)，“Hello Rust!”中，我们讨论了`Send`，这是一个标记特质，允许一个类型“发送”到多个线程。类似但更简单的是局部移动，这在程序中很常见——例如，当你将一个变量传递给一个函数时。
- en: Copying and cloning, on the other hand, happen on different occasions. When
    a variable is assigned to another variable, the compiler will typically copy the
    value implicitly, which can be done safely and cheaply for stack-allocated variables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，拷贝和克隆发生在不同的场合。当一个变量被赋值给另一个变量时，编译器通常会隐式地拷贝值，对于栈分配的变量，这可以安全且便宜地完成。
- en: '`Copy` is an implicit, bitwise copy of the value of a variable. If that variable
    is a pointer, the memory responsibility becomes ambiguous (who takes care of freeing?)
    and compilation will fail. This is where `Clone` comes in. The trait requires
    an explicit implementation of the `clone()` function to provide an appropriate
    copy of the type.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Copy`是变量的值的隐式、位拷贝。如果该变量是指针，内存责任就会变得模糊（谁负责释放？）并且编译将失败。这就是`Clone`发挥作用的地方。该特质要求显式实现`clone()`函数以提供适当的类型拷贝。'
- en: 'Cloning is always a deep copy of a type—implemented either manually (with the
    `Clone` trait) or by using the `derive` macro. Then, cloning is only a matter
    of invoking the `clone()` function, an operation that is not necessarily cheap.
    The following snippet illustrates these two operations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆始终是类型的深度拷贝——通过手动实现（使用`Clone`特质）或使用`derive`宏来实现。然后，克隆只是调用`clone()`函数的问题，这个操作并不一定便宜。以下代码片段说明了这两个操作：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The regular usage of these traits and operations is usually intuitive and there
    isn't much that can go wrong. Usually the compiler clearly states the need for
    a `Copy` implementation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特质和操作的常规用法通常是直观的，不太可能出错。通常编译器会清楚地指出需要`Copy`实现。
- en: It's recommended to derive or implement `Copy` wherever possible, but be mindful
    of breaking changes. Adding the trait is a non-intrusive action, whereas removing
    the trait will potentially break other people's code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 建议尽可能使用`Copy`特质或实现，但要注意破坏性变更。添加特质是一个非侵入性操作，而移除特质可能会破坏其他人的代码。
- en: While copying and cloning are great for providing ownership to multiple scopes,
    they are required when working with immutable storage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拷贝和克隆对于向多个作用域提供所有权非常有用，但在处理不可变存储时是必需的。
- en: Immutable storage
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变存储
- en: Garbage collectors simplified mutability considerably and, as a consequence,
    many of these languages don't need a specific modifier for mutability. While this
    garbage collection mechanism comes at the expense of runtime with frequent cleanups,
    not having to care about making variables mutable is very convenient. It lets
    developers focus on the logic they are implementing instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器大大简化了可变性，因此，许多这些语言不需要特定的修饰符来表示可变性。虽然这种垃圾收集机制以运行时频繁清理为代价，但无需关心变量是否可变是非常方便的。它让开发者能够专注于他们正在实现的逻辑。
- en: So why did Rust (and many functional languages) bring back this concept?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么Rust（以及许多函数式语言）又引入了这个概念？
- en: States and reasoning
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态和推理
- en: The state of an object is essentially the current values that its fields have
    at any given time. Changing this state is done by the object itself via messages
    on defined behavior (called methods) according to object-orientation principles.
    These state changes require mutability.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的状态本质上是在任何给定时间其字段具有的当前值。通过对象本身通过定义的行为（称为方法）上的消息来更改此状态，根据面向对象的原则。这些状态更改需要可变性。
- en: Throughout their lifetimes, most objects change their states multiple times,
    and since this happens at runtime, we find ourselves often looking at an object's
    debug print in frustration, thinking, "How did this value get here?"
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们的整个生命周期中，大多数对象会多次改变其状态，由于这发生在运行时，我们常常在沮丧中查看对象的调试打印，心想，“这个值是如何到这里来的？”
- en: Immutable data structures remedy this by making it impossible to change their
    contents, so any time you would look at an object, it has exactly the right values.
    It's a known fact that the majority of variables don't need to be mutable, and
    unless there is a resource constraint, creating another instance of the object
    with its new state is recommended. This principle, called **copy-on-write**, improves
    readability for better maintenance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构通过使其内容无法更改来解决这个问题，所以每次查看对象时，它都具有完全正确的值。众所周知，大多数变量不需要可变，除非存在资源限制，否则建议创建具有新状态的另一个对象实例。这个原则被称为**写时复制**，它提高了可读性，从而改善了维护性。
- en: A popular type that employs copy-on-write is the `String`—in almost any language.
    The type wraps a byte array and interprets it using a provided character set (usually
    UTF-8), and if you modify a character, this array is copied and saved with the
    changes made. This is done so often that `String` allocations are a common performance
    pitfall.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 采用写时复制的流行类型是`String`——在几乎任何语言中。该类型封装了一个字节数组，并使用提供的字符集（通常是UTF-8）对其进行解释，如果你修改了一个字符，则该数组会被复制并保存所做的更改。这种情况发生的频率很高，以至于`String`分配成为常见的性能陷阱。
- en: 'In the Rust standard library, there is a `Cow` enumeration (`std::borrow::Cow`)
    that lazily clones a contained reference whenever mutation or ownership is requested.
    For a great example, check out the Cow documentation: [https://doc.rust-lang.org/std/borrow/enum.Cow.html](https://doc.rust-lang.org/std/borrow/enum.Cow.html).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust标准库中，有一个`Cow`枚举（`std::borrow::Cow`），它会在需要修改或拥有权时懒加载包含的引用。为了一个很好的例子，请查看Cow文档：[https://doc.rust-lang.org/std/borrow/enum.Cow.html](https://doc.rust-lang.org/std/borrow/enum.Cow.html)。
- en: The principle of copy-on-write can also be found in filesystems to create snapshots
    (for example, in ZFS or BRTFS) and provides the benefits of both immutability
    and mutability at the cost of runtime resources. It's a trade-off between maintainability
    and absolute performance. A similar concept is employed by persistent data structures,
    which can be partially or fully persistent and still be immutable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 写时复制的原则也可以在文件系统中找到，用于创建快照（例如，在ZFS或BRTFS中），并且以运行时资源为代价提供了不可变性和可变性的好处。这是维护性和绝对性能之间的权衡。持久数据结构也采用了类似的概念，这些结构可以是部分或完全持久的，同时仍然是不可变的。
- en: Concurrency and performance
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与性能
- en: Having code that is easier to reason about and where the state cannot be changed
    is even more important in multithreaded scenarios. This prevents so-called anomalies
    (or side effects) where the state of an object is changed outside a dependent
    thread.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程场景中，拥有易于推理的代码且状态无法更改尤为重要。这防止了所谓的异常（或副作用）发生，即对象的状态在依赖的线程之外被更改。
- en: Locks are generally made to change the state of a shared object—they secure
    critical sections, which only a single thread can modify at any given time. Other
    threads have to "line up" and wait for the lock to be released to access the part
    as well. In Rust, this is called a **mutex**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 锁通常是为了改变共享对象的状态——它们保护临界区，在任何给定时间只有一个线程可以修改。其他线程必须“排队”等待锁释放才能访问该部分。在Rust中，这被称为**互斥锁**。
- en: 'Locks and mutex zones are bad for the following reasons:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 锁和互斥区域有以下几个原因不好：
- en: They have to be in the right order (acquired and released).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须按照正确的顺序（获取和释放）进行。
- en: What happens when a thread panics in a mutex zone?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个线程在互斥区域中崩溃时会发生什么？
- en: They are hard to integrate seamlessly into the part of the program that they
    protect.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们很难无缝集成到它们所保护的程序部分中。
- en: They are a bottleneck for performance.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是性能的瓶颈。
- en: Immutability is a simple way to avoid all of these, and there are many immutable
    data structure crates available, including one with persistent data structures
    called **Rust Persistent Data Structures** (**RPDS**) ([https://crates.io/crates/rpds](https://crates.io/crates/rpds)),
    that utilize a copy-on-write approach with versioning to capture state changes.
    Since these changes build on top of each other, threads can fully read one consistent
    object state at a time without having to wait or acquire a lock.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性是一种避免所有这些问题的简单方法，并且有许多不可变数据结构库可用，包括一个名为**Rust持久数据结构**（**RPDS**）的库（[https://crates.io/crates/rpds](https://crates.io/crates/rpds)），它使用写时复制和版本控制来捕获状态变化。由于这些变化是相互叠加的，线程可以在一次只完全读取一个一致的对象状态的同时，无需等待或获取锁。
- en: '**Lock-free data structures** are a specialized version of data structures
    that are very challenging to implement. These data structures use atomic operations
    to modify important parts (for example, the head pointer in a stack) and thereby
    achieve excellent performance without locking caveats.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**无锁数据结构**是数据结构的一种特殊版本，其实施非常具有挑战性。这些数据结构使用原子操作来修改重要部分（例如，栈的头指针）并因此在不锁定的情况下实现优异的性能。'
- en: '**Persistent data structures** are a take on creating data structures that
    are as efficient and mutable as their traditional counterparts, but better suited
    for concurrency. This is achieved by keeping the original data immutable and storing
    versioned change sets.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久数据结构**是一种创建数据结构的方法，它们在效率和可变性方面与传统对应物一样高效，但更适合并发。这是通过保持原始数据不可变并存储版本化更改集来实现的。'
- en: 'The idea of immutable data is best thought of in the context of functional
    programming. Functional programming is built on the principle of mathematical
    functions. A function is a relation of two sets of data (typically *X* and *Y*),
    where each element of *X* has exactly one element in *Y* that it maps to using
    the *f* function ( in short: *![](img/db4b77af-b0e4-4a71-8788-925b5d520ea8.png)*where
    *![](img/44f9059b-3a25-4d99-ad23-b9c0c48d3edc.png)).*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据的概念最好在函数式编程的背景下思考。函数式编程建立在数学函数的原则之上。一个函数是两个数据集（通常是*X*和*Y*）之间的关系，其中*X*中的每个元素在*Y*中都有且只有一个元素与之对应，使用*f*函数映射（简而言之：*![](img/db4b77af-b0e4-4a71-8788-925b5d520ea8.png)*其中
    *![](img/44f9059b-3a25-4d99-ad23-b9c0c48d3edc.png)*）。
- en: 'As a consequence, the input data, *X*, will not be changed to produce output
    data, *Y*, making it easy to run the *f* function in parallel. The downside is
    the increased cost at runtime: regardless of the operation, whether it''s only
    to flip a bit on the input data or to overhaul everything, the result is always
    a full copy.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，输入数据*X*不会被改变以产生输出数据*Y*，这使得并行运行*f*函数变得容易。缺点是运行时成本的提高：无论操作是什么，无论是仅仅在输入数据上翻转一个位还是彻底重写一切，结果总是完整的复制。
- en: To reduce this inefficiency, the Gang of Four's decorator pattern on *X*'s iterator
    can be used to stack up only the changes and execute them on every call, reducing
    runtime complexity and avoiding multiple copies of the output data. A problem
    that remains is that if the input and the output are large, a lot of memory is
    required. This is a tricky situation and can only be avoided by the programmer
    thinking thoroughly about decomposing the function better.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少这种低效，可以使用Gang of Four在*X*迭代器上的装饰器模式来堆叠仅有的更改并在每次调用时执行它们，从而减少运行时复杂度并避免输出数据的多次复制。一个问题仍然存在，即如果输入和输出都很大，则需要大量的内存。这是一个棘手的情况，只能通过程序员仔细思考更好地分解函数来避免。
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Moving one level above the details of code, this chapter discusses considerations
    when designing and using types. Rust's differentiation between stack- and heap-allocated
    variables in code provides a level of control that should be used to improve performance
    and API flexibility. `Sized`, a marker trait for mostly stack-allocated values,
    is the default for generic type parameters and can be relaxed by applying the
    `?Sized` constraint instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的细节之上提升一个层次，本章讨论了设计和使用类型时的考虑因素。Rust 在代码中对栈分配和堆分配变量的区分提供了一种应该用来提高性能和API灵活性的控制级别。"Sized"，一个主要用于栈分配值的标记特质，是泛型类型参数的默认值，可以通过应用
    `?Sized` 约束来放宽。
- en: When working with more object-oriented architectures, trait objects become a
    way to "work with interfaces" instead of specific implementations. However, they
    come at a performance cost, that is, dynamic dispatch, another trade-off between
    maintainability and performance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当与更面向对象的架构一起工作时，特质对象成为了一种“使用接口”而不是特定实现的方法。然而，它们会带来性能成本，即动态调度，这是在可维护性和性能之间的另一种权衡。
- en: Other than moving, Rust can copy or clone variables when necessary. Copy performs
    a deep copy in the case of sized values; unsized values require a reference that
    has to be cloned instead. Using these operations is often encountered when working
    with immutable data types in a principle called copy-on-write. Choosing whether
    we are able to reason about the object's state at any given time and avoiding
    data race conditions, but having to create a copy for each change, is another
    important trade-off when designing data structures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了移动之外，Rust 在必要时可以复制或克隆变量。对于有大小值，Copy 执行深拷贝；无大小值需要克隆的引用。当使用名为“写时复制”的原则处理不可变数据类型时，这些操作经常遇到。选择我们是否能够在任何给定时间推理对象的状态，并避免数据竞争条件，但每次更改都需要创建一个副本，这是设计数据结构时的另一个重要权衡。
- en: This trade-off will become apparent in the next chapter, where we will start
    working with lists, such as the singly-linked list, doubly-linked list, and the
    dynamic array.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种权衡将在下一章中变得明显，我们将开始处理列表，例如单链表、双链表和动态数组。
- en: Questions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How are `Sized` types different from other types?
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sized` 类型与其他类型有何不同？'
- en: How does `Clone` differ from `Copy`?
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clone` 与 `Copy` 有何区别？'
- en: What are the main drawbacks of immutable data structures?
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变数据结构的主要缺点是什么？
- en: How can applications benefit from immutable data structures?
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序如何从不可变数据结构中受益？
- en: Think about an immutable list that you want to work on—how would you distribute
    it across multiple threads?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下你想要工作的一个不可变列表——你将如何将它分配到多个线程中？
- en: Further reading
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics that are covered in this chapter, check
    out the following links:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的主题的更多信息，请查看以下链接：
- en: '[http://cglab.ca/~abeinges/blah/too-many-lists/book/](http://cglab.ca/~abeinges/blah/too-many-lists/book/)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://cglab.ca/~abeinges/blah/too-many-lists/book/](http://cglab.ca/~abeinges/blah/too-many-lists/book/)'
- en: '[https://doc.rust-lang.org/std/mem/fn.size_of.html](https://doc.rust-lang.org/std/mem/fn.size_of.html)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://doc.rust-lang.org/std/mem/fn.size_of.html](https://doc.rust-lang.org/std/mem/fn.size_of.html)'
- en: '[https://en.wikipedia.org/wiki/Functional_programming](https://en.wikipedia.org/wiki/Functional_programming)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Functional_programming](https://en.wikipedia.org/wiki/Functional_programming)'
- en: '[https://en.wikipedia.org/wiki/Persistent_data_structure](https://en.wikipedia.org/wiki/Persistent_data_structure)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Persistent_data_structure](https://en.wikipedia.org/wiki/Persistent_data_structure)'
