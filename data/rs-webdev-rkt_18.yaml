- en: '*Chapter 15*: Improving the Rocket Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 15 章*：改进 Rocket 应用程序'
- en: Now that we have finished the simple application, in this final chapter, we
    will explore the improvements we can make to the Rocket application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了简单的应用程序，在本章的最后一节，我们将探讨我们可以对 Rocket 应用程序进行的改进。
- en: In this chapter, we will learn about adding various technologies such as logging,
    tracing, and monitoring to bring the Rocket application up to the standard of
    modern web development. We will explore techniques to scale the Rocket application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何添加各种技术，如日志、跟踪和监控，以使 Rocket 应用程序达到现代 Web 开发的标准。我们将探讨缩放 Rocket 应用程序的技术。
- en: We will also explore other web frameworks for the Rust language. One web framework
    might not be the best tool for everything, so by knowing about other web frameworks,
    we can broaden our knowledge of the Rust web ecosystem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探索其他用于 Rust 语言的 Web 框架。一个 Web 框架可能不是适合所有事情的最好工具，因此通过了解其他 Web 框架，我们可以拓宽我们对
    Rust Web 生态系统的知识。
- en: 'In this chapter, we are going to cover these main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Extending the Rocket application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 Rocket 应用程序
- en: Scaling the Rocket application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放 Rocket 应用程序
- en: Exploring alternative Rust web frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索替代的 Rust Web 框架
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are very simple: the Rust compiler,
    the Cargo command line, and a web browser.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求非常简单：Rust 编译器、Cargo 命令行和一个 Web 浏览器。
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter15](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter15).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter15](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter15)找到本章的代码。
- en: Extending the Rocket application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Rocket 应用程序
- en: We have successfully created a simple Rocket application from scratch, starting
    with a basic Rocket concept such as routing. There are a lot of things that can
    be done to improve the application. In this section, we are going to discuss some
    of the libraries we can use to add functionality and improvements to the system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功从头开始创建了一个简单的 Rocket 应用程序，从基本的 Rocket 概念如路由开始。有很多事情可以做来改进应用程序。在本节中，我们将讨论我们可以使用的库，以添加功能和改进系统。
- en: Adding logging
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加日志
- en: A good web application in a modern setup usually requires logging and monitoring
    systems to obtain information about the system itself. Previously, we learned
    how to add logging to the Rocket application. The logging system writes to `stdout`
    and to a file. We can improve the logging system by using a distributed logging
    system in which the application sends the log to another server to create an ongoing
    record of application events.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代设置中，一个好的 Web 应用程序通常需要日志和监控系统来获取有关系统本身的信息。之前，我们学习了如何向 Rocket 应用程序添加日志。日志系统将信息写入
    `stdout` 和文件。我们可以通过使用分布式日志系统来改进日志系统，其中应用程序将日志发送到另一个服务器以创建应用程序事件的持续记录。
- en: We can create a Rocket fairing that sends log events to a third-party logging
    server such as Logstash, Fluentd, or Datadog. The logs can then be extracted,
    transformed, aggregated, filtered, and searched for further analysis.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个 Rocket 防火墙，将日志事件发送到第三方日志服务器，如 Logstash、Fluentd 或 Datadog。然后，日志可以被提取、转换、聚合、过滤，并用于进一步分析。
- en: An example of a crate that can be used to send a log to Fluentd is at [https://github.com/tkrs/poston](https://github.com/tkrs/poston).
    Using a `poston` crate, we can create a worker pool to send data periodically
    to a Fluentd server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以将日志发送到 Fluentd 的 crate 示例是[https://github.com/tkrs/poston](https://github.com/tkrs/poston)。使用
    `poston` crate，我们可以创建一个工作池，定期将数据发送到 Fluentd 服务器。
- en: Expanding logging to tracing
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日志扩展到跟踪
- en: After setting logging for the Rocket application, we can improve the logging
    functionality further with the tracing concept. Where logging is usually concerned
    with recording an individual event, tracing is concerned with the workflow of
    an application. There are several terminologies that are commonly used, including
    **log**, **event**, **span**, and **trace**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 Rocket 应用程序设置日志之后，我们可以通过跟踪概念进一步改进日志功能。通常，日志关注记录单个事件，而跟踪关注应用程序的工作流程。有几个术语是常用的，包括
    **日志**、**事件**、**跨度**和 **跟踪**。
- en: 'A **log** is a single piece of information used by programmers to capture data,
    while an **event** is the structured form of a log. For example, let''s say we
    have a log using the **Common Log Format** ([https://en.wikipedia.org/wiki/Common_Log_Format](https://en.wikipedia.org/wiki/Common_Log_Format))
    as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**log**是程序员用来捕获数据的单个信息片段，而**event**是日志的结构化形式。例如，假设我们有一个使用**通用日志格式**（[https://en.wikipedia.org/wiki/Common_Log_Format](https://en.wikipedia.org/wiki/Common_Log_Format)）的日志，如下所示：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can convert the log into an event as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将日志转换为事件，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A **span** is a type of log, but instead of information from a single point
    in time, a span covers a duration. And, finally, a **trace** is a collection of
    spans that can be used to create a workflow of application parts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**span**是一种日志类型，但它覆盖的是一段时间，而不是单一时间点的信息。最后，**trace**是一系列span的集合，可以用来创建应用程序各部分的流程。'
- en: 'Suppose we have a Rocket application with a fairing named `Trace`, we can implement
    tracing by using the `Trace` fairing and following these steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`Trace`的公平性Rocket应用程序，我们可以通过使用`Trace`公平性和以下步骤来实现跟踪：
- en: Create a struct that implements a Rocket request guard, for example, `RequestID`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现Rocket请求保护的struct，例如，`RequestID`。
- en: When a request arrives, the `Trace` fairing assigns `request_id` (an instance
    of `RequestID`) to the `Request` instance.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当请求到达时，`Trace`公平性将`request_id`（`RequestID`的一个实例）分配给`Request`实例。
- en: The `Trace` fairing then creates a log with the `request_id` and `start_time`
    information.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`Trace`公平性创建一个包含`request_id`和`start_time`信息的日志。
- en: A route handling function then retrieves `request_id` as a parameter because
    the struct implements the Rocket request guard.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个路由处理函数随后检索`request_id`作为参数，因为结构实现了Rocket请求保护。
- en: Inside the route handling function, the first thing we want the application
    to do is to create a log with `request_id` and the `function_start_time` information.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由处理函数内部，我们希望应用程序首先做的是创建一个包含`request_id`和`function_start_time`信息的日志。
- en: We can add various logs inside the function to record the timing; for example,
    before we send a query to the database, we create a log with `request_id` and
    time information. Later, we can create a log again when we receive the response
    from the database.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在函数内部添加各种日志来记录时间；例如，在我们向数据库发送查询之前，我们创建一个包含`request_id`和时间信息的日志。稍后，当我们从数据库接收到响应时，我们再次创建一个日志。
- en: We can then add a log again before the function returns with the `request_id`
    and time to mark the end of the function.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在函数返回之前再次添加一个日志，包含`request_id`和时间，以标记函数的结束。
- en: Finally, in the `Trace` fairing, we create a log again with `request_id` and
    `end_time`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Trace`公平性中，我们再次使用`request_id`和`end_time`创建一个日志。
- en: By transforming and analyzing the logs, we can construct the logs with the same
    `request_id` into spans. Finally, we can construct the trees of the spans into
    a trace that records the timing of each event of a request in the Rocket request-response
    life cycle. By using tracing information, we can determine which parts of the
    application can be improved further.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转换和分析日志，我们可以将具有相同`request_id`的日志构建成span。最后，我们可以将span的树状结构构建成一个trace，记录Rocket请求-响应生命周期中每个事件的计时。通过使用跟踪信息，我们可以确定哪些应用程序部分可以进一步改进。
- en: There are a couple of crates that we can use to do the tracing, for example,
    [https://docs.rs/tracing/latest/tracing/](https://docs.rs/tracing/latest/tracing/)
    and [https://docs.rs/tracing-log/latest/tracing_log/](https://docs.rs/tracing-log/latest/tracing_log/),
    which bridge the Rust logging functionality to the tracing functionality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个crate我们可以用来进行跟踪，例如，[https://docs.rs/tracing/latest/tracing/](https://docs.rs/tracing/latest/tracing/)
    和 [https://docs.rs/tracing-log/latest/tracing_log/](https://docs.rs/tracing-log/latest/tracing_log/)，它们将Rust日志功能与跟踪功能桥接。
- en: Setting monitoring
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置监控
- en: Where logging and tracing are used to obtain information for the Rocket application,
    then monitoring is the process to obtain information for the system to evaluate
    the system's capabilities itself. For example, we collect our server CPU usage
    for the Rocket application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rocket应用程序中使用日志和跟踪来获取信息时，监控是获取系统信息以评估系统自身能力的过程。例如，我们收集Rocket应用程序的服务器CPU使用情况。
- en: For monitoring, we can use tools such as Prometheus with Grafana as the visualizer,
    Datadog, or other third-party applications. We usually install an agent, an application
    that collects and sends various system information to a distributed monitoring
    server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于监控，我们可以使用Prometheus与Grafana作为可视化工具，Datadog或其他第三方应用程序。我们通常安装一个代理，这是一个收集并发送各种系统信息到分布式监控服务器的应用程序。
- en: Even though there's no direct connection to the Rocket application, usually,
    a monitoring system also collects information about the application itself. For
    example, in a containerized environment, there are liveness and readiness concepts
    that make sure a container is ready to receive its intended function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有直接连接到Rocket应用程序，通常监控系统也会收集有关应用程序本身的信息。例如，在容器化环境中，有活性和就绪概念确保容器准备好接收其预期功能。
- en: We can set a route in the Rocket application that returns a `200` HTTP status
    code, or a route that pings the database and returns a `200` HTTP status code.
    We can then tell the monitoring system to periodically check the response from
    the Rocket application. If there's a response, it means the application still
    works correctly, but if there's no response, it means there's something wrong
    with the Rocket application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Rocket应用程序中设置一个返回`200` HTTP状态码的路由，或者一个ping数据库并返回`200` HTTP状态码的路由。然后我们可以告诉监控系统定期检查Rocket应用程序的响应。如果有响应，这意味着应用程序仍然运行正确，但没有响应则意味着Rocket应用程序存在问题。
- en: Setting up a mailing and alerting system
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置邮件和警报系统
- en: Sometimes, we need mailing functionality in a web application. For example,
    when a user registers on a website, the system then sends an email for verification.
    There are a couple of libraries to send an email for Rust. An example is the Lettre
    crate ([https://crates.io/crates/lettre](https://crates.io/crates/lettre)). Let's
    take a look at the sample code for sending an email.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要在Web应用程序中实现邮件功能。例如，当用户在网站上注册时，系统随后会发送一封验证邮件。有几个库可以用于Rust发送邮件。例如，有一个名为Lette的crate
    ([https://crates.io/crates/lettre](https://crates.io/crates/lettre))。让我们看看发送邮件的示例代码。
- en: 'In `Cargo.toml`, add the following dependencies:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`中添加以下依赖项：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the application, for example in `src/lib.rs`, we can add the following function
    to send an email:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，例如在`src/lib.rs`中，我们可以添加以下函数来发送邮件：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: One more thing we can add to the application is an alerting system for when
    something goes wrong. We can use a third-party notification system or use the
    mailing system to send a notification if something goes wrong.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向应用程序添加一个警报系统，用于在出现问题时发出警报。我们可以使用第三方通知系统或使用邮件系统在出现问题时发送通知。
- en: Now that we have looked at several ways to improve the Rocket application, let's
    scale our application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了多种改进Rocket应用程序的方法，让我们扩展我们的应用程序。
- en: Scaling the Rocket application
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Rocket应用程序
- en: 'After developing the Rocket application and deploying it to a production environment,
    the application might need to be scaled up due to increasing usage. There are
    a couple of ways to scale the web application, and they can be categorized into
    two categories: vertical scaling and horizontal scaling.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Rocket应用程序并将其部署到生产环境之后，由于使用量的增加，应用程序可能需要扩展。有几种扩展Web应用程序的方法，它们可以分为两类：垂直扩展和水平扩展。
- en: '**Vertical scaling** means increasing the resources for a single node. For
    example, we replace the CPU of the computer that runs the Rocket application with
    a CPU with higher speed. Another example of vertical scaling is increasing the
    amount of RAM in the computer that runs the Rocket application.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**垂直扩展**意味着为单个节点增加资源。例如，我们用速度更快的CPU替换运行Rocket应用程序的计算机的CPU。垂直扩展的另一个例子是在运行Rocket应用程序的计算机中增加RAM的数量。'
- en: '**Horizontal scaling** is scaling the application by adding more nodes or more
    computers to handle the workload. An example of horizontal scaling is running
    two servers and setting up a Rocket web server on each server.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**水平扩展**是通过添加更多节点或更多计算机来处理工作负载来扩展应用程序。水平扩展的一个例子是在两台服务器上运行并设置Rocket Web服务器。'
- en: 'Suppose we have the following system:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下系统：
- en: '![ Figure 15.1 – Simple Rocket application'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.1 – 简单的Rocket应用程序'
- en: '](img/Figure_15.1_B16825.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 15.1_B16825.jpg](img/Figure_15.1_B16825.jpg)'
- en: Figure 15.1 – Simple Rocket application
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 简单的Rocket应用程序
- en: 'We can first move the database to another server as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先可以将数据库移动到另一台服务器，如下所示：
- en: '![Figure 15.2 – Separating the database'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.2 – 分离数据库'
- en: '](img/Figure_15.2_B16825.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_15.2_B16825.jpg)'
- en: Figure 15.2 – Separating the database
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – 分离数据库
- en: 'Then, we can add a load balancer as in the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加负载均衡器，如下所示：
- en: '![Figure 15.3 – Adding a load balancer'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.3 – 添加负载均衡器'
- en: '](img/Figure_15.3_B16825.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_15.3_B16825.jpg)'
- en: Figure 15.3 – Adding a load balancer
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – 添加负载均衡器
- en: The load balancer can be a hardware load balancer, an IaaS (Infrastructure as
    a service) load balancer such as AWS Load Balancer, a Kubernetes load balancer,
    or a software load balancer such as HAProxy or NGINX.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器可以是硬件负载均衡器，IaaS（基础设施即服务）负载均衡器，如 AWS Load Balancer，Kubernetes 负载均衡器，或者软件负载均衡器，如
    HAProxy 或 NGINX。
- en: 'After we add the load balancer, we can then add other machines, each with their
    own Rocket server instance, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加负载均衡器后，我们还可以添加其他机器，每台机器都有自己的 Rocket 服务器实例，如下所示：
- en: '![Figure 15.4 – Scaling the Rocket application horizontally'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.4 – 水平扩展 Rocket 应用程序'
- en: '](img/Figure_15.4_B16825.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_15.4_B16825.jpg)'
- en: Figure 15.4 – Scaling the Rocket application horizontally
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 – 水平扩展 Rocket 应用程序
- en: There are a couple of things we need to take care of if we want to load balance
    the Rocket server, for example, make sure `"secret_key"` in `Rocket.toml` is the
    same for all the Rocket server instances. Another thing we can do is make sure
    our session libraries and cookies are not storing the content on the memory of
    each instance, but on shared storage, such as a database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要负载均衡 Rocket 服务器，有一些事情我们需要注意，例如，确保 `Rocket.toml` 中的 `"secret_key"` 在所有
    Rocket 服务器实例中相同。我们还可以确保我们的会话库和 cookie 不在每个实例的内存中存储内容，而是在共享存储中，例如数据库。
- en: Yet another idea to improve Rocket application scaling is hosting static files
    or assets on their own server. The static files server can be a general-purpose
    web server such as an Apache HTTP Server or NGINX or a service such as AWS S3
    or Azure Storage. One thing we need to take care of is that when generating a
    Rocket response, we need to set the static assets into the correct server. For
    example, instead of setting the HTML CSS to `"./mini-default.css"`, we have to
    set `"`[https://static.example.com/mini-default.css](https://static.example.com/mini-default.css)`"`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提高 Rocket 应用程序扩展性的想法是将静态文件或资源托管在它们自己的服务器上。静态文件服务器可以是通用的 Web 服务器，如 Apache
    HTTP 服务器或 NGINX，或者像 AWS S3 或 Azure Storage 这样的服务。我们需要注意的一件事是在生成 Rocket 响应时，我们需要将静态资源设置到正确的服务器上。例如，我们不必将
    HTML CSS 设置为 `"./mini-default.css"`，而必须设置为 `"`[https://static.example.com/mini-default.css](https://static.example.com/mini-default.css)`"`.
- en: 'A diagram of the static server along with the load balancer can be seen in
    the following figure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中可以看到静态服务器与负载均衡器的示意图：
- en: '![Figure 15.5 – Adding a static files server'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.5 – 添加静态文件服务器'
- en: '](img/Figure_15.5_B16825.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_15.5_B16825.jpg)'
- en: Figure 15.5 – Adding a static files server
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5 – 添加静态文件服务器
- en: 'We can also add a **content delivery network** (**CDN**) to distribute the
    load on the system, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个 **内容分发网络** (**CDN**) 来在系统中分配负载，如下所示：
- en: '![Figure 15.6 – Adding a CDN'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.6 – 添加 CDN'
- en: '](img/Figure_15.6_B16825.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_15.6_B16825.jpg)'
- en: Figure 15.6 – Adding a CDN
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6 – 添加 CDN
- en: The CDN can be from the IaaS, such as AWS CloudFront or GCP Cloud CDN, or a
    third-party CDN provider such as Fastly, Akamai, or Cloudflare. These CDNs provide
    servers in various geographical locations and can provide caching and a faster
    network connection to make our application faster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CDN 可以来自 IaaS，例如 AWS CloudFront 或 GCP Cloud CDN，或者第三方 CDN 提供商，如 Fastly、Akamai
    或 Cloudflare。这些 CDN 在各种地理位置提供服务器，并可以提供缓存和更快的网络连接，使我们的应用程序运行更快。
- en: 'After basic scaling, the system can be scaled further, such as by adding database
    replications or clusters, or adding caching systems such as Redis or Redis cache
    clusters. An example of such a system is shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本扩展后，系统可以进一步扩展，例如通过添加数据库复制或集群，或者添加缓存系统，如 Redis 或 Redis 缓存集群。以下是一个此类系统的示例：
- en: '![Figure 15.7 – Adding a database cluster and cache cluster'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.7 – 添加数据库集群和缓存集群'
- en: '](img/Figure_15.7_B16825.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_15.7_B16825.jpg)'
- en: Figure 15.7 – Adding a database cluster and cache cluster
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7 – 添加数据库集群和缓存集群
- en: An important part of scaling the system is identifying which part's specification
    can be improved or which part can be isolated into its own server, for example,
    increasing the CPU of the computer that runs the Rocket server or moving the database
    into its own server and then later scaling the database itself from a single server
    into a database cluster.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 系统扩展的一个重要部分是确定哪些部分的规格可以改进，或者哪些部分可以隔离到自己的服务器中，例如，增加运行 Rocket 服务器的计算机的 CPU，或者将数据库移动到自己的服务器，然后稍后从单个服务器扩展数据库到数据库集群。
- en: Now that we have learned the basic techniques of scaling a Rocket application,
    let's discuss some other software that's similar to the Rocket web framework in
    the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了扩展 Rocket 应用程序的基本技术，让我们在下一节讨论一些与 Rocket Web 框架类似的软件。
- en: Exploring alternative Rust web frameworks
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Rust Web 框架的替代方案
- en: Rocket is a good web framework for the Rust programming language, but sometimes,
    we require other tools to build a web application. In this section, we are going
    to explore some alternatives to the Rocket web framework. The alternative frameworks
    are Actix Web, Tide, and Warp. Let's check the web frameworks one by one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket 是 Rust 编程语言的优秀 Web 框架，但有时我们可能需要其他工具来构建 Web 应用程序。在本节中，我们将探讨一些 Rocket Web
    框架的替代方案。这些替代框架包括 Actix Web、Tide 和 Warp。让我们逐一检查这些 Web 框架。
- en: Actix Web
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Actix Web
- en: One good alternative to Rocket is Actix Web ([https://actix.rs/](https://actix.rs/)).
    Just like Rocket, Actix Web is a web framework. Originally, it was created on
    top of the Actix crate, an actor framework. These days, the functionality from
    Actix is not used anymore as Rust's futures and `async`/`await` ecosystem is maturing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket 的一个很好的替代方案是 Actix Web ([https://actix.rs/](https://actix.rs/))。就像 Rocket
    一样，Actix Web 是一个 Web 框架。最初，它是在 Actix crate（一个演员框架）之上创建的。如今，Actix 的功能不再使用，因为 Rust
    的 futures 和 `async`/`await` 生态系统正在成熟。
- en: Just like Rocket, Actix Web includes concepts such as routing, request extractor,
    form handler, response handler, and a middleware system. Actix Web also provides
    conveniences such as a static file handler, a database connection, templating,
    and many more.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Rocket 一样，Actix Web 包含诸如路由、请求提取器、表单处理器、响应处理器和中间件系统等概念。Actix Web 还提供了诸如静态文件处理器、数据库连接、模板化等功能。
- en: Let's take a look at a code sample for Actix Web to see the similarities with
    Rocket.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 Actix Web 的代码示例，以了解它与 Rocket 的相似之处。
- en: 'In `Cargo.toml`, add the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 中，添加以下内容：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And, in `src/main.rs`, add the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中，添加以下内容：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Try running the application and opening `http://127.0.0.1:8080/hello_world`
    or `http://127.0.0.1:8080/users/world` to see the result.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行应用程序并打开 `http://127.0.0.1:8080/hello_world` 或 `http://127.0.0.1:8080/users/world`
    来查看结果。
- en: Tide
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tide
- en: Another Rust web framework alternative is Tide ([https://github.com/http-rs/tide](https://github.com/http-rs/tide)).
    Unlike Rocket or Actix Web, this framework provides only basic functions, such
    as request type, result type, sessions, and middleware.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Rust Web 框架的替代方案是 Tide ([https://github.com/http-rs/tide](https://github.com/http-rs/tide))。与
    Rocket 或 Actix Web 不同，这个框架只提供基本功能，如请求类型、结果类型、会话和中间件。
- en: Let's take a look at a code sample for Tide to see the similarities with Rocket.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 Tide 的代码示例，以了解它与 Rocket 的相似之处。
- en: 'In `Cargo.toml`, add the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 中，添加以下内容：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And, in `src/main.rs`, add the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中，添加以下内容：
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Try running the application by running `cargo run` on the command line and opening
    `http://127.0.0.1:8080/hello_world` in the browser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行中运行 `cargo run` 并在浏览器中打开 `http://127.0.0.1:8080/hello_world` 来运行应用程序。
- en: Warp
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Warp
- en: Another Rust web framework alternative is Warp ([https://github.com/seanmonstar/warp](https://github.com/seanmonstar/warp)).
    This framework provides various functionalities on top of its filter function.
    By using the filter, it can perform path routing, extract parameters and headers,
    deserialize query strings, and parse various request bodies such as forms, multipart
    form data, and JSON. Warp also supports serving static files, directories, WebSocket,
    logging, middleware, and a basic compression system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Rust Web 框架的替代方案是 Warp ([https://github.com/seanmonstar/warp](https://github.com/seanmonstar/warp))。这个框架在其过滤器功能之上提供了各种功能。通过使用过滤器，它可以执行路径路由、提取参数和头部、反序列化查询字符串，并解析各种请求体，如表单、多部分表单数据和
    JSON。Warp 还支持服务静态文件、目录、WebSocket、日志、中间件和基本的压缩系统。
- en: 'Let''s take a look at an example application using Warp. In the `Cargo.toml`
    file, add the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用 Warp 的示例应用程序。在 `Cargo.toml` 文件中，添加以下内容：
- en: '[PRE56]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And, in the `src/main.rs` file, add the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main.rs`文件中，添加以下内容：
- en: '[PRE59]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Again, like the Tide and Warp examples, try opening `http://127.0.0.1:8080/hello_world`
    in the browser.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，像Tide和Warp示例一样，尝试在浏览器中打开`http://127.0.0.1:8080/hello_world`。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we have learned how to improve and scale a Rocket application.
    We can use various tools to improve Rocket applications, such as adding logging,
    tracing, monitoring, and mailers. We also learned a little bit about principles
    for scaling Rocket applications.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们学习了如何改进和扩展Rocket应用程序。我们可以使用各种工具来改进Rocket应用程序，例如添加日志记录、跟踪、监控和邮件发送器。我们还了解了一些关于扩展Rocket应用程序的原则。
- en: Finally, we learned about alternative Rust web frameworks such as Actix Web,
    Tide, 13 and Warp.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了其他Rust Web框架，如Actix Web、Tide、13和Warp。
- en: We started this book by learning how to create and build Rust application, and
    tools for working with Rust such as Cargo. We then learned the basics of Rocket
    applications such as the life cycle of requests and how to configure a Rocket
    application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从学习如何创建和构建Rust应用程序以及与Rust一起工作的工具，如Cargo开始这本书。然后，我们学习了Rocket应用程序的基础知识，例如请求的生命周期以及如何配置Rocket应用程序。
- en: We then continued by learning about more concepts such as Rocket routes, and
    route parts such as HTTP method, path, format, and data. To handle a route, we
    have to create a function that receives the request object and returns the response
    object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续学习更多概念，例如Rocket路由和路由部分，如HTTP方法、路径、格式和数据。为了处理路由，我们必须创建一个函数，该函数接收请求对象并返回响应对象。
- en: Continuing the basics of Rocket, we learned more about Rocket components such
    as state, connecting a database with Rocket, and fairings.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续学习Rocket的基础知识之后，我们更深入地了解了Rocket组件，例如状态、将数据库与Rocket连接以及防热罩。
- en: After that, we learned how to organize Rust modules to create more complex applications.
    We then designed an application and implemented the routes to manage entities
    such as user and post. To manage entities, we learned how to write queries to
    the database to add, get, modify, or delete items.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们学习了如何组织Rust模块以创建更复杂的应用程序。然后，我们设计了一个应用程序并实现了路由来管理用户和帖子等实体。为了管理实体，我们学习了如何编写查询到数据库以添加、获取、修改或删除项目。
- en: We then discussed more advanced topics such as Rust error handling and its implementation
    in a Rocket application. Continuing the more advanced topics, we also learned
    about Rocket functionalities such as serving static assets and using templates
    to generate a response. We also discussed how to use forms and how to protect
    forms from malicious attackers using CSRF.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了更高级的话题，如Rust错误处理及其在Rocket应用程序中的实现。在继续讨论更高级的话题时，我们还学习了Rocket的功能，例如提供静态资产和使用模板生成响应。我们还讨论了如何使用表单，以及如何使用CSRF保护表单免受恶意攻击者攻击。
- en: After learning how to handle form data, we learned about the Rust generic and
    how to apply the Rust generic in a Rocket application to render `Post` with the
    same trait. To handle the variants of `Post`, we learned more about advanced Rust
    programming, including lifetime and memory safety. We also learned more about
    `async` programming and multithreading when we implemented processing of the variants
    of `Post`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何处理表单数据后，我们学习了Rust泛型和如何在Rocket应用程序中应用Rust泛型以渲染具有相同特质的`Post`。为了处理`Post`的变体，我们学习了更多关于高级Rust编程的知识，包括生命周期和内存安全。我们还学习了在实现`Post`变体的处理时关于`async`编程和多线程的知识。
- en: In order to use Rocket as a modern web framework, we also learned how to allow
    a Rocket application to handle APIs and JSON, protect the application using authentication
    and authorization, and learned how to use JWT to secure an API.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Rocket作为一个现代Web框架使用，我们还学习了如何允许Rocket应用程序处理API和JSON，使用身份验证和授权来保护应用程序，并学习了如何使用JWT来保护API。
- en: To make sure our Rocket application worked as intended, we then learned how
    to test Rust and Rocket applications. After making sure the application worked
    as intended, we learned how to deploy the application in different ways, such
    as putting the Rocket application behind a general-purpose web server and using
    Docker to build and serve the Rocket application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的Rocket应用程序按预期工作，我们接着学习了如何测试Rust和Rocket应用程序。在确认应用程序按预期工作后，我们学习了如何以不同的方式部署应用程序，例如将Rocket应用程序放在通用Web服务器后面，并使用Docker构建和提供Rocket应用程序。
- en: To complement the backend application, we learned how to use Rust to create
    a WebAssembly application in the frontend. And finally, we learned more about
    how to scale Rocket applications, as well as how to find alternatives to the Rocket
    web framework.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了补充后端应用，我们学习了如何在前端使用 Rust 创建 WebAssembly 应用程序。最后，我们还学习了如何扩展 Rocket 应用程序，以及如何寻找
    Rocket 网络框架的替代方案。
- en: Now that we have learned all the foundations for building Rust and Rocket applications,
    we can implement Rust and Rocket web framework skills in production-grade web
    applications. To expand upon your knowledge from this book, you can learn more
    from the Rust or Rocket websites and forums. Don't hesitate to experiment and
    make great applications using the Rust language and Rocket web framework.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了构建 Rust 和 Rocket 应用程序的所有基础知识，我们可以在生产级别的网络应用程序中实现 Rust 和 Rocket 网络框架的技能。为了扩展这本书中的知识，你可以从
    Rust 或 Rocket 网站和论坛中学习更多。不要犹豫，尝试使用 Rust 语言和 Rocket 网络框架制作出优秀的应用程序。
