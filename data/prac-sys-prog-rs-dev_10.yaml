- en: '*Chapter 8*: Working with Processes and Signals'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：与进程和信号一起工作'
- en: Do you know how commands are executed when you type them into a terminal interface
    on your computer? Are these commands directly executed by the operating system,
    or is there an intermediate program that handles them? When you run a program
    from the command line in the foreground, and press *Ctrl* + *C*, who is listening
    to this keypress, and how is the program terminated? How can multiple user programs
    be run at the same time by the operating system? What is the difference between
    a program and a process? If you are curious, then read on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道当你将命令输入到电脑的终端界面时，这些命令是如何被执行的吗？这些命令是直接由操作系统执行的，还是有一个中间程序来处理它们？当你从命令行在前台运行一个程序并按下*Ctrl*
    + *C*时，谁在监听这个按键，程序又是如何被终止的？操作系统如何同时运行多个用户程序？程序和进程之间有什么区别？如果你对此感到好奇，那么请继续阅读。
- en: In the previous chapter, we learned how to control and alter the terminal interface
    that is used to interact with the users in command-line applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何控制并改变用于与命令行应用程序中的用户交互的终端界面。
- en: In this chapter, we will look at *processes*, which are the second most popular
    abstraction in systems programming after *files*. We'll learn what processes are,
    how they differ from programs, how they are started and terminated, and how the
    process environment can be controlled. This skill is necessary if you want to
    write systems programs such as shells, where you want programmatic control over
    the life cycle of processes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨*进程*，这是在系统编程中仅次于*文件*的第二大流行抽象。我们将学习进程是什么，它们与程序有何不同，它们是如何启动和终止的，以及如何控制进程环境。如果你想要编写如shell之类的系统程序，并希望对进程的生命周期有程序控制，这项技能是必要的。
- en: We'll also build an elementary shell program as a mini project by using the
    *Rust Standard Library* This will give you a practical understanding of how popular
    shells such as *Bourne*, *Bash*, and *zsh* work under the hood, and teach you
    the basics of how you can build your own customized shell environments in Rust.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过使用*Rust标准库*构建一个基本的shell程序作为迷你项目。这将让你对流行的shell，如*Bourne*、*Bash*和*zsh*在底层的工作方式有一个实际的理解，并教你如何在Rust中构建你自己的定制shell环境的基础知识。
- en: 'We will cover these topics in the following order:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下顺序介绍这些主题：
- en: Understanding Linux process concepts and syscalls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Linux进程概念和系统调用
- en: Spawning new processes with Rust
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rust启动新进程
- en: Handling I/O and environment variables for child processes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理子进程的I/O和环境变量
- en: Handling panic, errors, and signals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理恐慌、错误和信号
- en: Writing a basic shell program in Rust (project)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rust中编写基本shell程序（项目）
- en: By the end of this chapter, you will have learned how to programmatically launch
    new programs as separate processes, how to set and adjust environment variables,
    how to handle errors, respond to external signals, and exit the process gracefully.
    You will learn how to talk to the operating system to perform these tasks using
    the Rust standard library. This gives you, as a system programmer, great control
    over this important system resource; that is, *processes*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将学会如何以独立进程的方式编程启动新程序，如何设置和调整环境变量，如何处理错误，响应外部信号，以及优雅地退出进程。你将学习如何使用Rust标准库与操作系统进行交互以执行这些任务。这让你作为系统程序员，对这一重要系统资源拥有极大的控制权；即，*进程*。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Verify that `rustc`, and `cargo` have been installed correctly with the following
    command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证`rustc`和`cargo`是否已正确安装：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter08](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter08).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中代码的Git仓库可以在[https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter08](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter08)找到。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The section on signal handling requires a Unix-like development environment
    (*Unix*, *Linux*, or *macOS*), as Microsoft Windows does not directly have the
    concept of signals. If you work with Windows, download a virtual machine such
    as Oracle VirtualBox ([https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads))
    or use a *Docker* container to launch a *Unix/Linux* image to follow along.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理部分需要Unix-like的开发环境（*Unix*、*Linux*或*macOS*），因为Microsoft Windows没有直接的概念。如果您使用Windows，请下载一个虚拟机，例如Oracle
    VirtualBox([https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads))，或者使用*Docker*容器来启动一个*Unix/Linux*镜像以继续操作。
- en: Understanding Linux process concepts and syscalls
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Linux进程概念和系统调用
- en: In this section, we'll cover the fundamentals of process management and get
    an appreciation of why it is important for systems programming. We'll look at
    the process life cycle, including *creating new processes*, *setting their environment
    parameters*, *working with their standard input and output*, and *terminating
    the processes*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍进程管理的 fundamentals，并了解为什么它在系统编程中很重要。我们将查看进程生命周期，包括*创建新进程*、*设置其环境参数*、*处理其标准输入和输出*以及*终止进程*。
- en: This section starts with understanding the differences between a *program* and
    a *process*. We'll then go into a few key details about the fundamentals of processes
    in Linux. Lastly, we'll see an overview of how to manage the process life cycle
    with Rust using syscalls encapsulated by the Rust standard library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本节首先理解*程序*和*进程*之间的区别。然后，我们将深入了解Linux进程的基本要素。最后，我们将概述如何使用Rust标准库封装的系统调用来管理进程生命周期。
- en: How does a program become a process?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序如何变成进程？
- en: A **process** is a running **program**. To be precise, it is an *instance* of
    a running program. You can have *multiple instances* of a single program running
    at the same time, such as starting a text editor from multiple terminal windows.
    Each such instance of a running program is a *process*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程**是一个正在运行的**程序**。更准确地说，它是一个正在运行的程序的*实例*。您可以在同一时间运行单个程序的多个实例，例如从多个终端窗口启动文本编辑器。每个这样的运行程序实例都是一个*进程*。'
- en: Even though a process is created as a result of running (or executing) a program,
    the two are different. A program exists in two forms – **source code** and **machine-executable
    instructions** (object code or executables). A compiler (and linker) is typically
    used to convert the source code of a program into *machine-executable instructions*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个进程是运行（或执行）程序的结果，这两个概念是不同的。程序以两种形式存在——**源代码**和**机器可执行指令**（目标代码或可执行文件）。通常使用编译器（和链接器）将程序的源代码转换为*机器可执行指令*。
- en: '*Machine-executable instructions* contain information for the operating system
    on how to *load a program into memory*, *initialize* it, and *run* it. The instructions
    include the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器可执行指令*包含操作系统如何*将程序加载到内存中*、*初始化*它和*运行*它的信息。指令包括以下内容：'
- en: An executable format (for example, **ELF** is a popular executable format in
    Unix systems).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件格式（例如，**ELF**是Unix系统中流行的可执行文件格式）。
- en: The program logic to be executed by the CPU.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU将要执行的程序逻辑。
- en: The memory address of the entry point of the program.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序入口点的内存地址。
- en: Some data for initializing the program variables and constants.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化程序变量和常数的某些数据。
- en: Information on the location of shared libraries, functions, and variables.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于共享库、函数和变量位置的信息。
- en: 'When a program is started either from a command line, script, or graphical
    user interface, the following steps occur:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序从命令行、脚本或图形用户界面启动时，以下步骤会发生：
- en: The operating system (kernel) allocates virtual memory to the program (which
    is also called the **memory layout** of the program). We saw this in [*Chapter
    5*](B16405_05_Final_NM_ePUB.xhtml#_idTextAnchor083), *Memory Management in Rust*,
    on how virtual memory is laid out for a program in terms of *stack*, *heap*, *text*,
    and *data* segments.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统（内核）为程序分配虚拟内存（这也被称为程序的**内存布局**）。我们在[*第5章*](B16405_05_Final_NM_ePUB.xhtml#_idTextAnchor083)，“Rust中的内存管理”中看到了这一点，它说明了程序在*栈*、*堆*、*文本*和*数据*段方面的虚拟内存布局。
- en: The kernel then loads the program instructions into the *text segment* of the
    virtual memory.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核随后将程序指令加载到虚拟内存的*文本段*中。
- en: The kernel initializes the program variables in the *data segment*.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核在*数据段*中初始化程序变量。
- en: The kernel triggers the CPU to start executing the program instructions.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核触发 CPU 开始执行程序指令。
- en: The kernel also provides the running program with access to resources it needs,
    such as files or additional memory.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核还向运行中的程序提供访问所需资源的权限，例如文件或额外的内存。
- en: 'The memory layout of a process (running program) was discussed in [*Chapter
    5*](B16405_05_Final_NM_ePUB.xhtml#_idTextAnchor083), *Memory Management*. It is
    reproduced here in *Figure 8.1* for reference:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 进程（运行中的程序）的内存布局在第 [*第 5 章*](B16405_05_Final_NM_ePUB.xhtml#_idTextAnchor083)，“内存管理”中进行了讨论。它在此处以
    *图 8.1* 的形式重现，以供参考：
- en: '![Figure 8.1 – Program memory layout](img/Figure_8.1_B16405.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 程序内存布局](img/Figure_8.1_B16405.jpg)'
- en: Figure 8.1 – Program memory layout
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 程序内存布局
- en: We've seen the *memory layout* of a program. What is a *process*, then?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了程序的*内存布局*。那么，什么是*进程*呢？
- en: 'As far as the kernel is concerned, a process is an abstraction that consists
    of the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内核来说，一个进程是一个由以下内容组成的抽象：
- en: Virtual memory in which the program instructions and data are loaded, which
    is represented in the program memory layout in *Figure 8.1*.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟内存，其中加载了程序指令和数据，这在 *图 8.1* 的程序内存布局中表示。
- en: A set of metadata about the running program such as the *process identifier*,
    *system resources* associated with the program (such as a list of open files),
    *virtual memory tables*, and other such information about the program. What is
    of particular importance is the *process ID*, which uniquely identifies an instance
    of a running program.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组关于运行程序的元数据，例如*进程标识符*、与程序关联的*系统资源*（例如打开文件列表）、*虚拟内存表*以及关于程序的其他此类信息。特别重要的是*进程
    ID*，它唯一地标识了一个运行程序的实例。
- en: Note
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The kernel itself is the `init`, which is assigned a *process ID* of *1*. The
    `init` process terminates only when the system is shut down and cannot be killed.
    All future processes are created either by the `init` process or one of its descendent
    processes.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内核本身是 `init`，被分配了一个 *进程 ID* 为 *1*。`init` 进程仅在系统关闭时终止，并且不能被杀死。所有未来的进程都是由 `init`
    进程或其子进程创建的。
- en: Thus, a program refers to instructions created by the programmer (in the source
    or a machine-executable format) and a process is a running instance of a program
    that uses system resources and is controlled by the kernel. As programmers, if
    we want to control a running program, we will need to use appropriate *system
    calls* to the kernel. The Rust standard library wraps these system calls into
    neat APIs for use within Rust programs, as discussed in [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057),
    *Introduction to the Rust Standard Library*.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，程序指的是程序员创建的指令（在源代码或机器可执行格式中），而进程是使用系统资源并由内核控制的程序的运行实例。作为程序员，如果我们想控制一个运行中的程序，我们将需要使用适当的*系统调用*到内核。Rust
    标准库将这些系统调用封装成整洁的 API，以便在 Rust 程序中使用，正如在第 [*第 3 章*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057)，“Rust
    标准库简介”中讨论的那样。
- en: We've seen how programs relate to processes. Let's discuss some more details
    about the *characteristics of processes* in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了程序与进程之间的关系。接下来，让我们在下一节中讨论一下进程的*特性*的更多细节。
- en: Delving into Linux process fundamentals
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入探讨 Linux 进程基础
- en: In [*Chapter 3*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057), *Introduction
    to the Rust Standard Library and Key Crates for Systems Programming*, we saw how
    system calls are the interface between a user program (process) and the kernel
    (operating system). Using system calls, a user program can manage and control
    various system resources such as *files*, *memory*, *devices*, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 3 章*](B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057)，“系统编程的 Rust 标准库和关键
    crate 简介”中，我们看到了系统调用是如何作为用户程序（进程）和内核（操作系统）之间的接口的。使用系统调用，用户程序可以管理和控制各种系统资源，如*文件*、*内存*、*设备*等。
- en: In this section, we'll look at how one running program (the parent process)
    can make system calls to manage the life cycle of another program (the child process).
    Recall that processes are also treated as system resources in Linux, just like
    files or memory. Understanding how one process can manage and communicate with
    another process is the focus of this section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个运行中的程序（父进程）如何通过系统调用管理另一个程序（子进程）的生命周期。回想一下，在 Linux 中，进程也被视为系统资源，就像文件或内存一样。本节的重点是了解一个进程如何管理和与另一个进程通信。
- en: '*Figure 8.2* shows the key set of tasks related to process management:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.2* 展示了与进程管理相关的关键任务集：'
- en: '![Figure 8.2 – Working with processes in Rust](img/Figure_8.2_B16405.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 在 Rust 中处理进程](img/Figure_8.2_B16405.jpg)'
- en: Figure 8.2 – Working with processes in Rust
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 在 Rust 中处理进程
- en: Let's go over the process management tasks shown in the preceding figure. We'll
    see how process management is done on Linux by a non-Rust user program (for example,
    C/C++), and how it is different in Rust.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面图中显示的过程管理任务。我们将看到非 Rust 用户程序（例如，C/C++）如何在 Linux 上进行进程管理，以及它与 Rust 的不同之处。
- en: Creating a new process
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新进程
- en: While working with Unix/Linux, any user program that needs to create a new process
    has to request the kernel to do so using system calls (*syscalls*). A program
    (let's call it the `fork()` syscall. The kernel duplicates the parent process
    and creates a *child process* with a unique ID. The child process gets an exact
    copy of the parent's memory space (the heap, stack, and so on). The child also
    gets access to the same copy of the program instructions as the parent.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Unix/Linux 时，任何需要创建新进程的用户程序都必须使用系统调用（*系统调用*）请求内核执行。一个程序（我们可以称之为 `fork()`
    系统调用。内核复制父进程并创建一个具有唯一 ID 的 *子进程*。子进程获得父进程的内存空间（堆、栈等）的精确副本。子进程也获得了与父进程相同的程序指令副本。
- en: After creation, a child process can choose to load a different program into
    its process memory space and execute it. This is accomplished using one of the
    `exec()` family of *syscalls*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，子进程可以选择将其进程内存空间中的不同程序加载并执行。这是通过 `exec()` 系列的 *系统调用* 实现的。
- en: So, basically, the *syscall* in Unix/Linux to *create a new child process* is
    different from that needed to *load a new program* into the child process and
    execute it. However, the Rust standard library simplifies this for us and provides
    a uniform interface, where both these steps can be combined while creating a new
    child process. We'll see examples of this in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，Unix/Linux 中用于 *创建新子进程* 的 *系统调用* 与用于将 *新程序* 加载到子进程中并执行它的系统调用是不同的。然而，Rust
    标准库为我们简化了这一点，并提供了一个统一的接口，这两个步骤可以在创建新子进程时结合在一起。我们将在下一节中看到这方面的示例。
- en: 'Let''s go back to the question at the beginning of the chapter: *What exactly
    happens when you type something in the command line of a terminal?*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到章节开头的问题：*当你在一个终端的命令行中键入某些内容时，究竟发生了什么？*
- en: 'When you run a program by typing the program executable name in a command line,
    two things take place:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在命令行中键入程序可执行文件名来运行程序时，会发生两件事：
- en: First, a new process is created using the `fork()` system call.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `fork()` 系统调用创建一个新的进程。
- en: Then, the image of the new program (that is, the *program executable*) is loaded
    into memory and executed using the `exec()` family of calls.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，新程序的图像（即，*程序可执行文件*）被加载到内存中，并使用 `exec()` 系列调用执行。
- en: What happens when you type a command in a terminal?
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在终端中键入命令时会发生什么？
- en: A terminal (as we saw in the previous chapter) provides an interface for the
    user to interact with the system. But there has to be something that interprets
    that command and executes it. This is the `find * | grep debug | wc -l`
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 终端（正如我们在上一章中看到的）为用户提供了一个与系统交互的接口。但必须有一些东西来解释这些命令并执行它们。这就是 `find * | grep debug
    | wc -l`
- en: When this command is typed into a terminal, the shell program spawns three processes
    to execute this command pipeline. It is this shell command that makes the system
    call to the kernel to create new processes, load these commands, and execute them
    in a sequence. The shell then returns the results of the execution and prints
    it to standard output.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当这个命令被输入到终端时，shell 程序会启动三个进程来执行这个命令管道。正是这个 shell 命令使系统调用内核创建新进程、加载这些命令并按顺序执行它们。然后
    shell 返回执行结果并将其打印到标准输出。
- en: Checking the status of a child process
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查子进程的状态
- en: Once a child process is spawned by the kernel, it returns a child *process ID*.
    The `wait()` and `waitpid()` syscalls can be used to check whether the child process
    is running by passing the *child process ID* to the call. These are helpful to
    synchronize the execution of the child process with the parent process. The Rust
    system library provides calls to wait for the child process to finish and to check
    its status.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦内核创建了一个子进程，它会返回一个子 *进程 ID*。`wait()` 和 `waitpid()` 系统调用可以通过传递 *子进程 ID* 到调用中来检查子进程是否正在运行。这些调用有助于同步子进程的执行与父进程。Rust
    系统库提供了等待子进程完成并检查其状态的调用。
- en: Communicating using inter-process communication
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用进程间通信进行通信
- en: Processes can communicate with each other and with the kernel (remember that
    the kernel is also a process) to coordinate their activities, using mechanisms
    such as signals, pipes, sockets, message queues, semaphores, and shared memory.
    In Rust also, two processes can communicate using various means including pipes,
    processes, and message queues. But one of the basic forms of **Inter-Process Communication**
    (**IPC**) between parent and child processes involves *stdin/stdout pipes*. The
    parent process can write to standard input and read from the child process's standard
    output. We'll see an example of this in a later section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以通过信号、管道、套接字、消息队列、信号量和共享内存等机制相互通信，并与内核（记住内核也是一个进程）协调其活动。在 Rust 中，两个进程也可以通过管道、进程和消息队列等多种方式通信。但父进程和子进程之间基本形式的**进程间通信**（**IPC**）涉及*stdin/stdout管道*。父进程可以向标准输入写入，并从子进程的标准输出读取。我们将在后面的章节中看到一个例子。
- en: Setting environment variables
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: Each process also has its own set of associated environment variables. The `fork()`
    and `exec()` syscalls allow the passing and setting of environment variables from
    the parent to the child process. The values of these environment variables are
    stored within the virtual memory area of the process. The Rust standard library
    also allows the parent process to explicitly set or reset the environment variables
    of the child process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有自己的关联环境变量集。`fork()`和`exec()`系统调用允许从父进程传递和设置环境变量到子进程。这些环境变量的值存储在进程的虚拟内存区域中。Rust
    标准库还允许父进程显式设置或重置子进程的环境变量。
- en: Terminating a process
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 终止进程
- en: A process can terminate itself by using the `exit()` syscall, or by being killed
    by a signal (such as the user pressing *Ctrl* + *C*) or using the `kill()` syscall.
    Rust also has an `exit()` call for this purpose. Rust also provides other ways
    to abort a process, which we will look at in a later section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以通过使用`exit()`系统调用或被信号（如用户按下*Ctrl* + *C*）或使用`kill()`系统调用杀死来终止自己。Rust 也有一个`exit()`调用用于此目的。Rust
    还提供了其他终止进程的方法，我们将在后面的章节中探讨。
- en: Handling signals
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理信号
- en: Signals are used to communicate asynchronous events such as keyboard interrupts
    to a process. Except for two of the signals, SIGSTOP and SIGKILL, processes can
    either choose to ignore signals or decide how to respond to them in their own
    way. Handling signals directly using the Rust standard library is not developer-friendly,
    so for this, we can use external crates. We'll be using one such crate in a later
    section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 信号用于将异步事件（如键盘中断）与进程通信。除了SIGSTOP和SIGKILL这两个信号外，进程可以选择忽略信号或决定以自己的方式响应它们。直接使用 Rust
    标准库处理信号对开发者来说并不友好，因此我们可以使用外部crate。我们将在后面的章节中使用这样一个crate。
- en: In this section, we've seen the differences between a *program* and a *process*,
    delved into a few of the characteristics of Linux processes, and got an overview
    of the kind of things we can do in Rust to interact with processes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了程序和进程之间的区别，深入探讨了 Linux 进程的一些特性，并概述了在 Rust 中我们可以做些什么来与进程交互。
- en: In the next section, we'll learn first-hand how to spawn, interact, and terminate
    processes using Rust by writing some code. Note that in the next few sections,
    only code snippets are provided. In order to execute the code, you will need to
    create a new cargo project and add the code shown in the `src/main.rs` file with
    the appropriate module imports.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过编写一些代码来亲身体验如何使用 Rust 创建、交互和终止进程。请注意，在接下来的几个章节中，只提供代码片段。为了执行代码，您需要创建一个新的
    cargo 项目，并将显示在`src/main.rs`文件中的代码添加到适当的模块导入中。
- en: Spawning processes with Rust
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 创建进程
- en: In the Rust standard library, `std::process` is the module for working with
    processes. In this section, we'll look at how to *spawn new processes*, *interact
    with child processes*, and *abort the current process* using the Rust standard
    library. The Rust standard library internally uses the corresponding Unix/Linux
    *syscalls* to invoke the kernel operations for managing processes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 标准库中，`std::process`是用于处理进程的模块。在本节中，我们将探讨如何使用 Rust 标准库来*创建新进程*、*与子进程交互*和*终止当前进程*。Rust
    标准库内部使用相应的 Unix/Linux *系统调用*来调用内核操作以管理进程。
- en: Let's begin with launching new child processes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从启动新的子进程开始。
- en: Spawning new child processes
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的子进程
- en: 'The `std::process::Command` is used to launch a program at a specified path,
    or to run a standard shell command. The configuration parameters for the new process
    can be constructed using a builder pattern. Let''s see a simple example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::process::Command`用于在指定路径启动程序或运行标准shell命令。可以使用构建器模式构造新进程的配置参数。让我们看一个简单的例子：'
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code shown uses the `Command::new()` method to create a new command for
    execution, that takes as a parameter the name of the program to be run. The `spawn()`
    method creates a new child process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的代码使用`Command::new()`方法创建一个用于执行的新命令，该命令以要运行的程序名称作为参数。`spawn()`方法创建一个新的子进程。
- en: If you run this program, you will see a listing of files in the current directory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此程序，你将看到当前目录中文件的列表。
- en: This is the simplest way to spin off a standard Unix *shell command* or a *user
    program* as a child process using the Rust standard library.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Rust标准库将标准Unix *shell命令*或*用户程序*作为子进程的最简单方法。
- en: 'What if you would like to pass parameters to the shell command? Some example
    code is shown in the following snippet that passes arguments to the command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要向shell命令传递参数怎么办？以下代码片段显示了传递参数到命令的示例：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `arg()` method can be used to pass one argument to the program. Here we
    want to run the `ls –lh` command to display files in a long format with readable
    file sizes. We have to use the `arg()` method twice to pass the two flags.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`arg()`方法向程序传递一个参数。这里我们想要运行`ls –lh`命令以以长格式显示可读的文件大小。我们必须使用`arg()`方法两次来传递两个标志。
- en: 'Alternatively, the `args()` method can be used as shown here. Note that the
    `std::process` import and the `main()` function declaration have been removed
    in future code snippets to avoid repetition, but you must add them before you
    can run the program:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用如这里所示的方法使用`args()`。请注意，在未来的代码片段中已经删除了`std::process`导入和`main()`函数声明以避免重复，但你在运行程序之前必须添加它们：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's alter the code to list the directory contents for the directory one level
    above (relative to the current directory).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改代码以列出相对于当前目录上一级的目录内容。
- en: The code shows two parameters for the `ls` command configured through the `args()`
    method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示了通过`args()`方法配置的`ls`命令的两个参数。
- en: 'Next, let''s set the current directory for the child process to a non-default
    value:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将子进程的当前目录设置为非默认值：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we are spawning the process to run the `ls` command in
    the directory one level above.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在生成一个进程来在目录上一级运行`ls`命令。
- en: 'Run the program with the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will see the listing of the parent directory displayed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到父目录的列表显示。
- en: We've so far used `spawn()` to create a new child process. This method returns
    a handle to the child process.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用`spawn()`创建了一个新的子进程。此方法返回子进程的句柄。
- en: 'There is another way to spawn a new process using `output()`. The difference
    is that `output()` spawns the child process and waits for it to terminate. Let''s
    see an example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`output()`也可以用另一种方式生成一个新的进程。区别在于`output()`生成子进程并等待其终止。让我们看一个例子：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are spawning a new process using the `output()` method to print out the
    contents of a file named `a.txt`. Let''s create this file using the following
    command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`output()`方法生成一个新的进程来打印出名为`a.txt`的文件内容。让我们使用以下命令创建此文件：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you run the program, you will see the contents of the `a.txt` file printed
    out to the terminal. Note that we are printing out the contents of the standard
    output handle of the child process because that's where the output of the `cat`
    command is directed to by default. We'll learn more details of how to work with
    child processes' `stdin` and `stdout` later in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行程序，你将看到`a.txt`文件的内容打印到终端。请注意，我们正在打印子进程的标准输出句柄的内容，因为默认情况下`cat`命令的输出被定向到那里。我们将在本章后面学习如何与子进程的`stdin`和`stdout`进行更多操作。
- en: We'll now look at how to terminate a process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看如何终止一个进程。
- en: Terminating processes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止进程
- en: We've seen how to spawn new processes. What about terminating them? For this,
    the Rust standard library provides two methods—`abort()` and `exit()`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何生成新的进程。那么，如何终止它们呢？为此，Rust标准库提供了两种方法——`abort()`和`exit()`。
- en: 'The usage of the `abort()` method is shown in the following snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`abort()`方法的使用：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code aborts the current process, and the last statement will not get printed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码终止了当前进程，并且最后的语句将不会打印出来。
- en: There is another `exit()` method similar to `abort()`, but it allows us to specify
    an exit code that is available to the calling process.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个类似于`abort()`的`exit()`方法，但它允许我们指定一个可供调用进程使用的退出代码。
- en: What is the benefit of processes returning error codes? A child process can
    fail due to various errors. When the program fails and the child process exits,
    it would be useful to the calling program or user to know the error code denoting
    the reason for failure. **0** indicates a successful exit. Other error codes indicate
    various conditions such as *data error*, *system file error*, *I/O error*, and
    so on. The error codes are platform-specific, but most Unix-like platforms use
    8-bit error codes, allowing for error values between 0 and 255\. Examples of error
    codes for Unix BSD can be found at [https://www.freebsd.org/cgi/man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+11.2-stable&arch=default&format=html](https://www.freebsd.org/cgi/man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+11.2-stable&arch=default&format=html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 进程返回错误代码有什么好处？子进程可能会因为各种错误而失败。当程序失败且子进程退出时，对于调用程序或用户来说，知道表示失败原因的错误代码将是有用的。**0**表示成功退出。其他错误代码表示各种条件，如*数据错误*、*系统文件错误*、*I/O错误*等。错误代码是平台特定的，但大多数类Unix平台使用8位错误代码，允许错误值在0到255之间。Unix
    BSD的错误代码示例可以在[https://www.freebsd.org/cgi/man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+11.2-stable&arch=default&format=html](https://www.freebsd.org/cgi/man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+11.2-stable&arch=default&format=html)找到。
- en: 'The following is an example showing the returning of error codes from a process
    with the `exit()` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了使用`exit()`方法从进程返回错误代码：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run this program on the command line in your terminal. To know the exit code
    of the last executed process on Unix-like systems, you can type `$?` on the command
    line. Note that this command may vary depending on the platform.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端命令行上运行此程序。要在类Unix系统上知道最后一个执行进程的退出代码，你可以在命令行上输入`$?`。请注意，此命令可能因平台而异。
- en: abort() versus exit()
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`abort()`与`exit()`的比较'
- en: Note that both `abort()` and `exit()` do not clean up and call any destructors,
    so if you want to shut down a process in a clean manner, these methods should
    be called only after all the destructors have been run. However, the operating
    system will ensure that on termination of a process, all the resources associated
    with it, such as memory and file descriptors, are automatically made available
    for re-allocation to other processes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`abort()`和`exit()`都不会清理并调用任何析构函数，所以如果你想以干净的方式关闭进程，这些方法应该在所有析构函数运行之后才调用。然而，操作系统将确保在进程终止时，与该进程关联的所有资源，如内存和文件描述符，将自动可用于其他进程的重新分配。
- en: In this section, we've seen how to spawn and terminate processes. Let's next
    take a look at how to check the status of execution of a child process after it
    has been spawned.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何创建和终止进程。接下来，让我们看看如何在子进程创建后检查其执行状态。
- en: Checking the status of a child process' execution
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查子进程执行状态
- en: As seen earlier, when we start a new process, we also specify the program or
    command to be executed within the process. Frequently, we also care about whether
    this program or command has been executed successfully or not, in order to take
    suitable actions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当我们启动一个新的进程时，我们也会指定在进程内要执行的程序或命令。通常，我们还会关心这个程序或命令是否已成功执行，以便采取适当的行动。
- en: 'The Rust standard library provides a `status()` method to let us find out whether
    a process completed executing successfully. Some example usage is shown in the
    following snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库提供了一个`status()`方法，让我们可以找出进程是否成功完成执行。以下是一些示例用法：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run this program and you will see the message **Unsuccessful operation** printed
    out to your terminal. Re-run the program with a valid filename and you will see
    the success message printed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序，你将在终端看到打印出**操作失败**的消息。使用有效的文件名重新运行程序，你将看到成功消息被打印出来。
- en: This concludes this section. You learned different ways to run commands in a
    separate child process, how to terminate them, and how to get the status of their
    execution.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容到此结束。你学习了在单独的子进程中运行命令的不同方法，如何终止它们，以及如何获取它们执行的状态。
- en: In the next section, we'll look at how to set environment variables and work
    with I/O for child processes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何设置环境变量以及与子进程的I/O操作。
- en: Handling I/O and environment variables
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理I/O和环境变量
- en: In this section, we'll look at how to handle I/O with child processes, and also
    learn to set and clear environment variables for the child process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何处理与子进程的I/O，并学习如何为子进程设置和清除环境变量。
- en: Why would we need this?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要这样做？
- en: Take the example of a load balancer that is tasked with spawning new workers
    (Unix processes) in response to incoming requests. Let's assume the new worker
    process reads configuration parameters from environment variables to perform its
    tasks. The load balancer process then would need to spawn the worker process and
    also set its environment variables. Likewise, there may be another situation where
    the parent process wants to read a child process's standard output or standard
    error and route it to a log file. Let's understand how to perform such activities
    in Rust. We'll start with handling the I/O of the child process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个负载均衡器为例，该负载均衡器负责根据传入的请求启动新的工作进程（Unix进程）。假设新的工作进程从环境变量中读取配置参数以执行其任务。那么，负载均衡器进程就需要启动工作进程并设置其环境变量。同样，可能还有另一种情况，父进程想要读取子进程的标准输出或标准错误并将其路由到日志文件。让我们了解如何在Rust中执行此类活动。我们将从处理子进程的I/O开始。
- en: Handling the I/O of child processes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理子进程的I/O
- en: Standard input (`stdin`), standard output (`stdout`), and standard error (`stderr`)
    are abstractions that allow a process to interact with the surrounding environment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入（`stdin`）、标准输出（`stdout`）和标准错误（`stderr`）是允许进程与周围环境交互的抽象。
- en: For example, when many user processes are running at the same time, and when
    a user types keystrokes on a terminal, the kernel delivers the keystrokes to the
    standard input of the right process. Likewise, a Rust program (running as a process
    in a shell) can print out characters to its standard output, which is in turn
    read by the shell program and delivered to the terminal screen for the user. Let's
    learn how to work with standard input and standard output using the Rust standard
    library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当许多用户进程同时运行时，当用户在终端上输入按键时，内核会将按键传递给正确进程的标准输入。同样，一个Rust程序（作为在shell中运行的进程）可以向其标准输出打印字符，这些字符随后被shell程序读取并传递到终端屏幕供用户查看。让我们学习如何使用Rust标准库来处理标准输入和标准输出。
- en: The `piped()` method on `std::process::Stdio` allows the child process to communicate
    with its parent process using a `pipe` (which is an IPC mechanism in Unix-like
    systems).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::process::Stdio`上的`piped()`方法允许子进程通过管道（这是类Unix系统中的IPC机制）与其父进程通信。'
- en: 'We''ll first look at how to communicate with the standard output handle of
    the child process from the parent process:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看如何从父进程与子进程的标准输出句柄进行通信：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we first create a new child process to run the
    `ps` command to show a list of currently running processes. The output is, by
    default, sent to the child process's `stdout`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先创建一个新的子进程来运行`ps`命令以显示当前正在运行的所有进程。默认情况下，输出会被发送到子进程的`stdout`。
- en: In order to get access to the child process's `stdout` from the parent process,
    we create a Unix pipe using the `stdio::piped()` method. The `process` variable
    is the handle to the child process, and `process.stdout` is the handle to the
    child process's standard output. The parent process can read from this handle,
    and print out its contents to its own `stdout` (that is, the parent process's
    `stdout`). This is how a parent process can read the output of a child process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从父进程获取对子进程`stdout`的访问权限，我们使用`stdio::piped()`方法创建一个Unix管道。`process`变量是子进程的句柄，`process.stdout`是子进程标准输出的句柄。父进程可以从这个句柄读取，并将其内容打印到自己的`stdout`（即父进程的`stdout`）。这就是父进程如何读取子进程的输出。
- en: 'Let''s now write some code to send some bytes from the parent process to the
    standard input of the child process:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来写一些代码，从父进程向子进程的标准输入发送一些字节：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The descriptions of the numbered annotations in the preceding code are provided
    here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中编号注释的描述在此提供：
- en: Register a piped connection between the *parent process* and *standard input*
    of the child process.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父进程和子进程的标准输入之间注册一个管道连接。
- en: Register a piped connection between the *parent process* and *standard output*
    of the child process.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父进程和子进程的标准输出之间注册一个管道连接。
- en: Write bytes to the *standard input* of the child process.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向子进程的标准输入写入字节。
- en: Read from the *standard output* of the child process and print it to the terminal
    screen.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从子进程的*标准输出*读取并打印到终端屏幕。
- en: There are a few other methods available on the child process. The `id()` method
    provides the *process id* of the child process, the `kill()` method kills the
    child process, the `stderr` method gives a handle to the child process's *standard
    error*, and the `wait()` method makes the parent process to wait until the child
    process has completely exited.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程中还有一些其他方法可用。`id()`方法提供子进程的*进程ID*，`kill()`方法终止子进程，`stderr`方法提供对子进程的*标准错误*的句柄，而`wait()`方法使父进程等待直到子进程完全退出。
- en: We've seen how to handle I/O for child processes. Let's now learn how to work
    with environment variables.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何处理子进程的I/O。现在让我们学习如何处理环境变量。
- en: Setting the environment for the child process
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置子进程的环境
- en: 'Let''s look at how to set environment variables for the child process. The
    following example shows how to set the path environment variable for a child process:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为子进程设置环境变量。以下示例展示了如何为子进程设置路径环境变量：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `env()` method on `std::process::Command` allows the parent process to
    set the environment variable for the child process being spawned. Run the program
    and test it with the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::process::Command`上的`env()`方法允许父进程为正在创建的子进程设置环境变量。运行程序并使用以下命令进行测试：'
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You'll see the value of the `MY_PATH` environment variable that was set in the
    program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到程序中设置的`MY_PATH`环境变量的值。
- en: To set multiple environment variables, the `envs()` command can be used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置多个环境变量，可以使用`envs()`命令。
- en: 'The environment variables for a child process can be cleared by using the `env_clear()`
    method, as shown:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`env_clear()`方法清除子进程的环境变量，如下所示：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the program with `cargo run` , and you will see that *nothing* is printed
    out for the `env` command. Re-run the program by commenting out the `.env_clear()`
    statement, and you will find the `env` values printed to terminal.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo run`运行程序，你会看到对于`env`命令没有任何输出。通过注释掉`.env_clear()`语句重新运行程序，你将发现`env`值被打印到终端。
- en: To remove a specific environment variable, the `env_remove()` method can be
    used.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除特定的环境变量，可以使用`env_remove()`方法。
- en: With this, we conclude this section. We've seen how to interact with standard
    input and standard output of a child process and to set/reset the environment
    variables. In the next section, we'll learn how to handle errors and signals in
    child processes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了本节。我们看到了如何与子进程的标准输入和标准输出交互以及如何设置/重置环境变量。在下一节中，我们将学习如何处理子进程中的错误和信号。
- en: Handling panic, errors, and signals
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理恐慌、错误和信号
- en: Processes can fail due to various error conditions. These have to be handled
    in a controlled manner. There may also be situations where we want to terminate
    a process in response to external inputs, such as a user pressing *Ctrl* + *C*.
    How we can handle such situations is the focus of this section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可能由于各种错误条件而失败。这些必须在受控的方式下处理。也可能存在我们想要根据外部输入（如用户按下*Ctrl* + *C*）终止进程的情况。我们如何处理这种情况是本节的重点。
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In cases when processes exit due to errors, the operating system itself performs
    some cleanup, such as releasing memory, closing network connections, and releasing
    any file handles associated with the process. But sometimes, you may want program-driven
    controls to handle these cases.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程由于错误而退出的情况下，操作系统本身会执行一些清理工作，例如释放内存、关闭网络连接以及释放与进程关联的任何文件句柄。但有时，你可能希望程序驱动的控制来处理这些情况。
- en: Failures in process execution can broadly be classified into two types – *unrecoverable
    errors* and *recoverable errors*. When a process encounters an unrecoverable error,
    there is sometimes no option but to abort the process. Let's see how to do that.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 进程执行失败可以大致分为两种类型 – *不可恢复的错误*和*可恢复的错误*。当进程遇到不可恢复的错误时，有时别无选择，只能终止进程。让我们看看如何做到这一点。
- en: Aborting the current process
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止当前进程
- en: We saw how to terminate and exit from a process in the *Spawning processes with
    Rust* section. The `abort()` and `exit()` methods on `process::Command` can be
    used for this purpose.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“使用Rust创建进程”部分看到了如何终止和退出一个进程。`process::Command`上的`abort()`和`exit()`方法可以用于此目的。
- en: 'In some cases, we consciously allow a program to fail under some conditions
    without handling it, mainly in cases of unrecoverable errors. The `std::panic`
    macro allows us to panic the current thread. What this means is that the program
    terminates immediately and provides feedback to the caller. But unlike the `exit()`
    or `abort()` methods, it unwinds the stack of the current thread and calls all
    destructors. Here is an example of the usage of the `panic!` macro:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们故意允许程序在某些条件下失败而不进行处理，主要是在不可恢复错误的情况下。`std::panic`宏允许我们使当前线程崩溃。这意味着程序会立即终止并向调用者提供反馈。但与`exit()`或`abort()`方法不同，它会回滚当前线程的堆栈并调用所有析构函数。以下是`panic!`宏使用的一个示例：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the program with `cargo run` and you will see the error message printed
    out from the `panic!` macro. There is also a custom hook that can be registered
    that will get invoked before the standard cleanup is performed by the `panic`
    macro. Here is the same example, this time with a custom `panic` hook:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo run`运行程序，你将看到从`panic!`宏打印出的错误消息。还有一个可以在`panic`宏执行标准清理之前注册的自定义钩子。以下是相同的示例，这次带有自定义的`panic`钩子：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On running this program, you will see the custom error hook message displayed,
    as we are providing an invalid command to spawn as a child process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序时，你会看到显示自定义错误钩子消息，因为我们提供了一个无效的命令来作为子进程启动。
- en: Note that `panic!` should be used only for non-recoverable errors. For example,
    if a child process tries to open a file that does not exist, this can be handled
    using a recoverable error mechanism such as the `Result enum`. The advantage of
    using `Result` is that the program can return to its original state and the failed
    operation can be retried. If `panic!` is used, the program terminates abruptly,
    and the original state of the program cannot be recovered. But there are situations
    where `panic!` may be appropriate such, as when a process runs out of memory in
    the system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`panic!`仅应用于不可恢复的错误。例如，如果一个子进程尝试打开一个不存在的文件，这可以通过使用可恢复错误机制（如`Result`枚举）来处理。使用`Result`的优势在于程序可以返回到其原始状态，并且失败的操作可以重试。如果使用`panic!`，程序会突然终止，并且无法恢复程序的原始状态。但有些情况下，`panic!`可能是合适的，例如当系统中的进程耗尽内存时。
- en: Let's next look at another aspect of process control—signal handling.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看进程控制的另一个方面——信号处理。
- en: Signal handling
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号处理
- en: In Unix-like systems, the operating system can send signals to processes. Note
    that Windows OS does not have signals. The process can handle the signal in a
    way it deems fit, or even ignore the signal. There are operating-system defaults
    for handling various signals. For example, when you issue a kill command on a
    process from a shell, the `SIGTERM` signal is generated. The program terminates
    on receipt of this signal by default, and there is no special additional code
    that needs to be written in Rust to handle that signal. Similarly, a `SIGINT`
    signal is received when a user presses *Ctrl* + *C*. But a Rust program can choose
    to handle these signals in its own way.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix系统中，操作系统可以向进程发送信号。请注意，Windows操作系统没有信号。进程可以以它认为合适的方式处理信号，甚至可以忽略信号。操作系统为处理各种信号提供了默认设置。例如，当你从shell向一个进程发出kill命令时，会生成`SIGTERM`信号。默认情况下，程序在接收到这个信号时会终止，并且不需要在Rust中编写特殊代码来处理这个信号。同样，当用户按下*Ctrl*
    + *C*时，会接收到`SIGINT`信号。但Rust程序可以选择以自己的方式处理这些信号。
- en: However, handling Unix signals correctly is hard for various reasons. For example,
    a signal can occur at any time and the thread processing cannot continue until
    the signal handler completes execution. Also, signals can occur on any thread
    and synchronization is needed. For this reason, it is better to use third-party
    crates in Rust for signal handling. Note that even while using external crates,
    caution should be exercised as the crates do not solve all problems associated
    with signal handling.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于各种原因，正确处理Unix信号是困难的。例如，信号可以在任何时候发生，并且处理信号的线程无法继续，直到信号处理程序完成执行。此外，信号可以在任何线程上发生，需要同步。因此，在Rust中，最好使用第三方crate进行信号处理。请注意，即使在使用外部crate的情况下，也应谨慎行事，因为这些crate并没有解决与信号处理相关的所有问题。
- en: 'Let''s now see an example of handling signals using the `signal-hook` crate.
    Add it to dependencies in `Cargo.toml` as shown:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用`signal-hook`crate处理信号的示例。将其添加到`Cargo.toml`中的依赖项，如下所示：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'An example code snippet is shown as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例代码片段：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we listen for two specific signals, `SIGTERM` and `SIGINT,`
    within the `match` clause. `SIGINT` can be sent to the program by pressing *Ctrl*
    + *C*. The `SIGTERM` signal can be generated by using the `kill` command on a
    *process id* from the shell.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在 `match` 子句中监听两个特定的信号，`SIGTERM` 和 `SIGINT`。`SIGINT` 可以通过按下 *Ctrl*
    + *C* 发送到程序。`SIGTERM` 信号可以通过在 Unix shell 的命令行中使用 `kill` 命令从 *进程 ID* 生成。
- en: Now, run the program and simulate the two signals. Then, press the *Ctrl* +
    *C* key combination, which generates the `SIGINT` signal. You will see that instead
    of the default behavior (which is to terminate the program), a statement is printed
    out to the terminal.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行程序并模拟两个信号。然后，按下 *Ctrl* + *C* 键组合，这将生成 `SIGINT` 信号。你会看到，与默认行为（即终止程序）不同，终端会打印出一条语句。
- en: To simulate SIGTERM, run a `ps` command on the command line of a Unix shell
    and retrieve the *process id*. Then run a `kill` command with the *process id*.
    You will see that the process terminates, and a statement is printed to the terminal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟 `SIGTERM`，在 Unix shell 的命令行中运行 `ps` 命令并检索 *进程 ID*。然后运行带有 *进程 ID* 的 `kill`
    命令。你会看到进程终止，并且终端会打印出一条语句。
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using **tokio** for asynchronous code, you can use the **tokio-support**
    feature of signal-hook.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 **tokio** 进行异步代码，你可以使用信号钩子的 **tokio-support** 功能。
- en: It is important to remember that signal handling is a complex topic, and even
    with external crates, care must be exercised while writing custom signal-handling
    code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，信号处理是一个复杂的话题，即使在编写自定义信号处理代码时，也需要谨慎行事。
- en: While handling signals or dealing with errors, it is also good practice to log
    the signal or error using a crate such as `log` for future reference and troubleshooting
    by system administrators. However, if you'd like a program to read these logs,
    you can log these messages in JSON format instead of plaintext by using an external
    crate such as `serde_json`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理信号或处理错误时，记录信号或错误也是一个好的做法，以便将来供系统管理员参考和故障排除。然而，如果你想让程序读取这些日志，你可以使用外部包如 `serde_json`
    将这些消息以 JSON 格式记录，而不是纯文本。
- en: This concludes this subsection on working with *panic*, *errors*, and *signals*
    in Rust. Let's now write a shell program that demonstrates some of the concepts
    discussed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于在 Rust 中处理 *panic*、*errors* 和 *signals* 的本小节。现在，让我们编写一个 shell 程序来演示所讨论的一些概念。
- en: Writing a shell program in Rust (project)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中编写 shell 程序（项目）
- en: We learned in the *Delving into Linux process fundamentals* section what a shell
    program is. In this section, let's build a shell program, adding features iteratively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *深入 Linux 进程基础* 部分学习了什么是 shell 程序。在本节中，我们将构建一个 shell 程序，并逐步添加功能。
- en: 'In the first iteration, we''ll write the basic code to read a shell command
    from the command line and spawn a child process to execute the command. Next,
    we''ll add the ability to pass command arguments to the child process. Lastly,
    we will personalize the shell by adding support for users to enter commands in
    a more natural-language-like syntax. We''ll also introduce error handling in this
    last iteration. Let''s get started:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个迭代中，我们将编写基本的代码来从命令行读取 shell 命令并启动子进程来执行该命令。接下来，我们将添加将命令参数传递给子进程的功能。最后，我们将通过添加对用户以更自然语言语法输入命令的支持来个性化
    shell。我们还将在这个最后迭代中引入错误处理。让我们开始吧：
- en: 'Let''s first create a new project:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个新的项目：
- en: '[PRE20]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create three files: `src/iter1.rs`, `src/iter2.rs`, and `src/iter3.rs`. The
    code for the three iterations will be placed in these files so that it will be
    easy to build and test each iteration separately.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个文件：`src/iter1.rs`、`src/iter2.rs` 和 `src/iter3.rs`。三个迭代的代码将放在这些文件中，以便可以单独构建和测试每个迭代。
- en: 'Add the following to `Cargo.toml`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 中添加以下内容：
- en: '[PRE21]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we specify to the Cargo tool that we want to build separate
    binaries for the three iterations.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们指定给 Cargo 工具，我们想要为三个迭代构建单独的二进制文件。
- en: We're now ready to start with the first iteration of the shell program.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始 shell 程序的第一个迭代。
- en: Iteration 1 – Spawning a child process to execute commands
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代 1 – 启动子进程执行命令
- en: 'First, let''s write a program to accept commands from the terminal, and then
    spawn a new child process to execute those user commands. Add a loop construct
    to continue accepting user commands in a loop until the process is terminated.
    The code is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个程序来从终端接收命令，然后启动一个新的子进程来执行这些用户命令。添加一个循环结构以在进程终止前循环接受用户命令。代码如下：
- en: src/iter1.rs
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: src/iter1.rs
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The numbered annotations in the preceding code are described as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的编号注释描述如下：
- en: Display the `$` prompt to nudge the user to enter commands.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示`$`提示符以提示用户输入命令。
- en: Flush the `stdout` handle so that the `$` prompt is immediately displayed on
    the terminal.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清空`stdout`句柄，以便`$`提示符立即在终端上显示。
- en: Create a buffer to hold the command entered by the user.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个缓冲区来保存用户输入的命令。
- en: Read the user commands one line at a time.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐行读取用户命令。
- en: Remove the newline character from the buffer (this is added when the user presses
    the *Enter* key to submit the command).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从缓冲区中删除换行符（这是当用户按下*Enter*键提交命令时添加的）。
- en: Create a new child process and pass the user commands to the child process for
    execution.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的子进程并将用户命令传递给子进程以执行。
- en: Wait until the child process completes execution before accepting additional
    user inputs.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接受更多用户输入之前，请等待子进程完成执行。
- en: 'Run the program with the following command:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Type any command without arguments such as `ls` or `ps` or `du` on the `$` prompt.
    You'll see the output of the command execution displayed on the terminal. You
    can continue to enter more such commands at the next `$` prompt. Press *Ctrl*
    + *C* to exit the program.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$`提示符下输入不带参数的任何命令，如`ls`或`ps`或`du`。你将在终端上看到命令执行的输出。你可以在下一个`$`提示符下继续输入更多此类命令。按*Ctrl*
    + *C*退出程序。
- en: We now have the first version of our shell program working, but this program
    will fail if parameters or flags are entered after the command. For example, typing
    a command such as `ls` works, but typing `ls –lah` will cause the program to panic
    and exit. Let's add support for command arguments in the next iteration of our
    code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了我们shell程序的第一版，但如果在命令后输入参数或标志，这个程序将会失败。例如，输入`ls`这样的命令是可行的，但输入`ls –lah`将会导致程序恐慌并退出。让我们在代码的下一个迭代中添加对命令参数的支持。
- en: Iteration 2 – Adding support for command arguments
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代 2 – 添加对命令参数的支持
- en: 'Let''s add support for command arguments with the `args()` method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`args()`方法添加对命令参数的支持：
- en: src/iter2.rs
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: src/iter2.rs
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code shown is essentially the same as the previous snippet, except for
    the three additional lines added, which are annotated with numbers. The annotations
    are described as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的代码基本上与上一个代码片段相同，除了添加了三条注释编号的额外行。注释描述如下：
- en: Take the user input, split it by whitespace, and store the result in `Vec`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取用户输入，按空格分割，并将结果存储在`Vec`中。
- en: The first element of the `Vec` corresponds to the command. Create a child process
    to execute this command.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Vec`的第一个元素对应于命令。创建一个子进程来执行此命令。'
- en: Pass the list of `Vec` elements, starting from the second element, as a list
    of arguments to the child process.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Vec`元素列表（从第二个元素开始）作为参数列表传递给子进程。
- en: 'Run the program with the following line:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行运行程序：
- en: '[PRE25]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Enter a command and pass arguments to it before hitting the *Enter* key. For
    example, you can type one of the following commands:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按*Enter*键之前输入一个命令并将其参数传递给它。例如，你可以输入以下命令之一：
- en: '[PRE26]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that in the last command, `a.txt` is an existing file holding some contents
    and located in the project root folder.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后一个命令中，`a.txt` 是一个包含一些内容并位于项目根目录中的现有文件。
- en: You will see the command outputs successfully displayed on the terminal. The
    shell works so far as we intended. Let's extend it now a little further in the
    next iteration.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到命令输出成功显示在终端上。到目前为止，shell按预期工作。现在让我们在下一个迭代中稍微扩展一下。
- en: Iteration 3 – Supporting natural-language commands
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代 3 – 支持自然语言命令
- en: 'Since this is our own shell, let''s implement a user-friendly alias for a shell
    command in this iteration (*why not?*). Instead of typing `ls`, what if a user
    could type a command in natural language, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们自己的shell，让我们在这个迭代中实现一个用户友好的shell命令别名（为什么不呢？）。除了输入`ls`之外，如果用户可以像以下这样输入自然语言的命令会怎样：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is what we''ll code next. The following snippet shows the code. Let''s
    look at the module imports first:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们接下来要编写的代码。以下代码片段显示了代码。让我们首先看看模块导入：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Modules from `std::io` are imported for writing to the terminal, reading from
    the terminal, and for error handling. We already know the purpose of importing
    the `process` module.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `std::io` 模块导入用于向终端写入、从终端读取以及用于错误处理的模块。我们已经知道了导入 `process` 模块的目的。
- en: 'Let''s now look at the `main()` program in parts. We won''t cover the code
    already seen in previous iterations. The complete code for the `main()` function
    can be found in the GitHub repo in the `src/iter3.rs` file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来分部分查看 `main()` 程序。我们不会涵盖之前迭代中已经看到的代码。`main()` 函数的完整代码可以在 GitHub 仓库的 `src/iter3.rs`
    文件中找到：
- en: 'After displaying the `$` prompt, check whether the user has entered any command.
    If the user presses just the *Enter* key at the prompt, ignore and redisplay the
    `$` prompt. The following code checks whether at least one command has been entered
    by the user, then processes the user input:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示 `$` 提示符后，检查用户是否输入了任何命令。如果用户在提示符下只按了 *Enter* 键，则忽略并重新显示 `$` 提示符。以下代码检查用户是否至少输入了一个命令，然后处理用户输入：
- en: '[PRE29]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the command entered is `show files`, execute the `ls` command in a child
    process. If the command is `show process`, execute the `ps` command. If `show`
    is entered without a parameter, or if the `show` command is followed by an invalid
    word, throw an error:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入的命令是 `show files`，则在子进程中执行 `ls` 命令。如果命令是 `show process`，则执行 `ps` 命令。如果没有参数输入
    `show`，或者 `show` 命令后跟无效的单词，则抛出错误：
- en: '[PRE30]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Wait for the child process to complete. If the child process fails to execute
    successfully, or if the user input is invalid, throw an error:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待子进程完成。如果子进程未能成功执行，或者用户输入无效，则抛出错误：
- en: '[PRE31]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the program with `cargo run –-bin iter3` and try the following commands
    at the `$` prompt to test:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo run –-bin iter3` 运行程序，并在 `$` 提示符下尝试以下命令以进行测试：
- en: '[PRE32]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You'll see the commands successfully execute, with a statement printed out indicating
    success.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到命令成功执行，并打印出表示成功的语句。
- en: 'You would have noticed that we''ve added some error handling in the code. Let''s
    look at what error conditions we''ve addressed:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在代码中添加了一些错误处理。让我们看看我们解决了哪些错误条件：
- en: If the user presses *Enter* without entering a command
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在输入命令前直接按 *Enter* 键
- en: If the user enters the `show` command without a parameter (either a file or
    process)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入了没有参数的 `show` 命令（无论是文件还是进程）
- en: If the user enters the `show` command with an invalid parameter
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入了无效参数的 `show` 命令
- en: If the user enters a valid Unix command, but one that is not supported by our
    program (for example, `pipes` or `redirection`)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入了有效的 Unix 命令，但该命令不受我们的程序支持（例如，`pipes` 或 `redirection`）
- en: 'Let''s try the following invalid inputs:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下无效输入：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You'll see that an error message is printed to the terminal.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到错误信息被打印到终端。
- en: Try also hitting the *Enter* key without command. You will see that this is
    not processed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 也尝试在提示符下不输入命令直接按 *Enter* 键。你会看到这不会被处理。
- en: In error-handling code, note use of `ErrorKind` `enum`, which is a set of pre-defined
    error types defined in the Rust standard library. The list of predefined error
    types can be found at [https://doc.rust-lang.org/std/io/enum.ErrorKind.html](https://doc.rust-lang.org/std/io/enum.ErrorKind.html).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误处理代码中，注意使用 `ErrorKind` 枚举，它是在 Rust 标准库中定义的一组预定义错误类型。预定义错误类型的列表可以在 [https://doc.rust-lang.org/std/io/enum.ErrorKind.html](https://doc.rust-lang.org/std/io/enum.ErrorKind.html)
    找到。
- en: Congratulations! You have implemented a basic shell program that can recognize
    natural-language commands for non-technical users. You've also implemented some
    error handling so that the program is reasonably robust and doesn't crash on invalid
    inputs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经实现了一个基本的shell程序，它可以识别非技术用户的自然语言命令。你还实现了一些错误处理，使得程序在无效输入时具有一定的鲁棒性，不会崩溃。
- en: 'As an exercise, you can do the following to enhance this shell program:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以做以下事情来增强这个shell程序：
- en: Add support for pipe-operator-separated command chains such as `ps | grep sys`.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对管道操作符分隔的命令链的支持，例如 `ps | grep sys`。
- en: Add support for redirections such as the **>** operator to divert the output
    of a process execution to a file.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对重定向的支持，例如使用 **>** 操作符将进程执行的输出重定向到文件。
- en: Move the logic of command-line parsing into a separate tokenizer module.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令行解析的逻辑移动到单独的标记器模块中。
- en: In this section, we've written a shell program that has a subset of the features
    of a real-world shell program such as `zsh` or `bash`. To be clear, a real-world
    shell program has a lot more complex features, but we have covered the fundamental
    concepts behind creating a shell program here. Also importantly, we've learned
    how to handle errors in case of invalid user inputs or if a child process fails.
    To internalize your learning, it is recommended to write some code for the suggested
    exercises.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们编写了一个具有现实世界shell程序（如`zsh`或`bash`）部分功能的shell程序。为了明确，现实世界的shell程序具有更多复杂的功能，但在这里我们已经涵盖了创建shell程序背后的基本概念。同样重要的是，我们学习了如何处理无效用户输入或子进程失败时的错误。为了内化你的学习，建议为建议的练习编写一些代码。
- en: This concludes the section on writing a shell program in Rust.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了Rust编写shell程序的部分。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the basics of processes in Unix-like operating
    systems. We learned how to spawn a child process, interact with its standard input
    and standard output, and execute a command with its arguments. We also saw how
    to set and clear environment variables. We looked at the various ways to terminate
    a process on error conditions, and how to detect and handle external signals.
    We finally wrote a shell program in Rust that can execute the standard Unix commands,
    but also accept a couple of commands in a natural-language format. We also handled
    a set of errors to make the program more robust.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了类Unix操作系统中进程的基本知识。我们学习了如何创建子进程，与其标准输入和标准输出进行交互，以及如何使用其参数执行命令。我们还看到了如何在错误条件下设置和清除环境变量。我们探讨了在错误条件下终止进程的各种方法，以及如何检测和处理外部信号。最后，我们用Rust编写了一个可以执行标准Unix命令的shell程序，还可以接受一些自然语言格式的命令。我们还处理了一系列错误，使程序更加健壮。
- en: Continuing on the topic of managing system resources, in the next chapter, we
    will learn how to manage threads of a process and build concurrent systems programs
    in Rust.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论管理系统资源的话题，在下一章中，我们将学习如何管理进程的线程，并在Rust中构建并发系统程序。
