- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Recreating Our Application in Rocket
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rocket中重新创建我们的应用程序
- en: At this point, we have built a fully functioning to-do application with the
    **Actix Web framework**. In this chapter, we will go through the core concepts
    so that there will be nothing holding us back if we decide to completely recreate
    the to-do application in **Rocket**. This framework might appeal to some developers
    because it does not need as much boilerplate code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用**Actix Web框架**构建了一个完全功能齐全的待办事项应用程序。在本章中，我们将探讨核心概念，这样如果我们决定在**Rocket**中完全重新创建待办事项应用程序，就不会有任何阻碍。这个框架可能对一些开发者有吸引力，因为它不需要太多的样板代码。
- en: In this chapter, we will fully utilize our isolated modular code to completely
    recreate our application in one chapter by copying over and plugging in our existing
    modules, views, database connection configuration, and test pipeline. Even if
    you are not interested in building web applications in Rocket, I still suggest
    you still complete this chapter because you will get to experience why it is important
    to perform well-decoupled testing and write well-structured code, as good tests
    and structure will enable you to switch web frameworks will little effort.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将充分利用我们隔离的模块化代码，通过复制和插入现有的模块、视图、数据库连接配置和测试管道，在一章中完全重新创建我们的应用程序。即使你对在Rocket中构建Web应用程序不感兴趣，我仍然建议你完成这一章，因为你会体验到为什么执行良好的解耦测试和编写良好的代码是如此重要，因为良好的测试和结构将使你能够轻松切换Web框架。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is Rocket?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Rocket？
- en: Setting up our server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的服务器
- en: Plugging in our existing modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入我们的现有模块
- en: Returning status with JSON
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回JSON状态
- en: Returning multiple statuses
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回多个状态
- en: Registering our views with Rocket
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rocket注册我们的视图
- en: Plugging in our existing tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入我们的现有测试
- en: By the end of this chapter, you will have a fully working to-do application
    in Rocket with minimal coding. Not only will you understand the basics of configuring
    and running a Rocket server but you will also be able to port over modules, views,
    and tests from other code bases that have used Actix Web and plug them into your
    Rocket server, and vice versa. Not only is this a valuable skill but it also concretes
    the need for good-quality, isolated code. You will see firsthand how and why you
    should structure your code the way we have.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个功能齐全的待办事项应用程序，在Rocket中只需编写最少的代码。你不仅将了解配置和运行Rocket服务器的基础知识，而且还将能够将来自使用Actix
    Web的其他代码库的模块、视图和测试迁移到你的Rocket服务器，反之亦然。这不仅是一项宝贵的技能，而且也证实了高质量、隔离代码的需求。你将亲身体验为什么以及如何以我们的方式来结构化你的代码。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’ll build on the code built in [*Chapter 11*](B18722_11.xhtml#_idTextAnchor222),
    *Configuring HTTPS with NGINX on AWS*. This can be found at the following URL:
    [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11/running_https_on_aws](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11/running_https_on_aws).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于在[*第11章*](B18722_11.xhtml#_idTextAnchor222)中构建的代码，*在AWS上使用NGINX配置HTTPS*。您可以在以下URL找到它：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11/running_https_on_aws](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11/running_https_on_aws)。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter12](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter12).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter12](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter12)找到。
- en: What is Rocket?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Rocket？
- en: Rocket is a Rust web framework, like Actix Web. It’s newer than Actix Web and
    has a lower user base at the time of writing. In the previous edition of this
    book, Rocket was running on nightly Rust, meaning that the releases were not stable.
    However, now, Rocket is running on stable Rust.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket是一个Rust Web框架，类似于Actix Web。它比Actix Web更新，在撰写本文时用户基础较小。在本书的前一版中，Rocket运行在nightly
    Rust上，这意味着发布并不稳定。然而，现在，Rocket运行在稳定的Rust上。
- en: The framework does have some advantages, depending on your style of coding.
    Rocket is simpler to write, since it implements boilerplate code itself, so the
    developer does not have to write boilerplate themselves. Rocket also supports
    JSON parsing, forms, and type checking out of the box, which can all be implemented
    with just a few lines of code. Features such as logging are already implemented
    as soon as you start a Rocket server. If you want to just get an application off
    the ground with little effort, then Rocket is a good framework. However, it is
    not as established as Actix Web, meaning that as you get more advanced, you might
    find yourself envying some of the features and implementations Actix Web has.
    However, in all my years of web development, I have never come across a problem
    that has been severely held back by the choice of framework. It will mainly come
    down to preference. To really feel the difference, it makes sense to take Rocket
    for a spin. In the next section, we will create a basic server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架确实有一些优势，这取决于你的编码风格。Rocket 更容易编写，因为它自己实现了样板代码，因此开发者不必自己编写样板代码。Rocket 还支持开箱即用的
    JSON 解析、表单和类型检查，所有这些都可以用几行代码实现。例如，日志记录功能在启动 Rocket 服务器时就已经实现。如果你只想轻松地启动一个应用程序，那么
    Rocket 是一个很好的框架。然而，它不如 Actix Web 稳定，这意味着当你变得更加高级时，你可能会羡慕 Actix Web 的一些特性和实现。然而，在我的所有网络开发年中，我从未遇到过由于框架选择而严重受阻的问题。这主要取决于个人偏好。为了真正感受到差异，尝试一下
    Rocket 是有意义的。在下一节中，我们将创建一个基本服务器。
- en: Setting up our server
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的服务器
- en: 'When it comes to setting up a basic server in Rocket, we are going to start
    with everything defined in the `main.rs` file. First, start a new Cargo project
    and then define the Rocket dependency in the `Cargo.toml` file with the following
    code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在 Rocket 中设置基本服务器时，我们将从 `main.rs` 文件中定义的所有内容开始。首先，启动一个新的 Cargo 项目，然后在 `Cargo.toml`
    文件中使用以下代码定义 Rocket 依赖项：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is all we need for now in terms of dependencies. Now, we can move to our
    `src/main.rs` file to define the application. Initially, we need to import the
    Rocket crate and the macros associated with the Rocket crate with the following
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖项方面，我们现在需要的就是这些。现在，我们可以转到 `src/main.rs` 文件来定义应用程序。最初，我们需要使用以下代码导入 Rocket
    crate 和与 Rocket crate 相关的宏：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now define a basic *hello world* view with the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码定义一个基本的 *hello world* 视图：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the preceding code, we can deduce that the macro before the function defines
    the method and URL endpoint. The function is the logic that is executed when the
    call is made to the view, and whatever the function returns is what is returned
    to the user. To get a feel for how powerful the URL macro is, we can create two
    more views – one saying `hello` and the other saying `goodbye`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码，我们可以推断出函数之前的宏定义了方法和 URL 端点。该函数是在调用视图时执行的逻辑，函数返回的内容就是返回给用户的内容。为了感受 URL
    宏的强大功能，我们可以创建另外两个视图——一个显示 `hello`，另一个显示 `goodbye`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we can see that we can pass parameters from the URL into the function.
    Again, this code is clear and straightforward. There is nothing left for us to
    do, apart from attaching these views to the server and starting it with the following
    code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们可以将参数从 URL 传递到函数中。同样，这段代码清晰易懂。我们除了将这些视图附加到服务器并使用以下代码启动它之外，没有其他事情要做：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we can see that we must decorate the `main` function with a macro from
    Rocket, and we are attaching the views that we defined with no prefix. We can
    then run the `cargo run` command to launch the server. Once we have done the `run`
    command, we get the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们必须用 Rocket 的宏装饰 `main` 函数，并且我们正在附加没有前缀的我们定义的视图。然后我们可以运行 `cargo run`
    命令来启动服务器。一旦我们执行了 `run` 命令，我们就会得到以下输出：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can see that the logging is comprehensive. It defines the port, address,
    and configuration of the server. It then defines the routes that have been attached,
    as well as fairings. With the preceding logging, we can see that the server is
    healthy, and we have the routes that we expected. Here, we can see that logging
    comes out of the box. We do not have to define anything, unlike in Actix Web.
    We also get a note stating what views are mounted and the URL that the server
    is listening on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到日志是全面的。它定义了端口、地址和服务器配置。然后定义了附加的路线以及公平性。有了前面的日志，我们可以看到服务器是健康的，我们有预期的路线。在这里，我们可以看到日志是现成的。我们不需要定义任何东西，与Actix
    Web不同。我们还得到一条说明已挂载的视图和服务器正在监听的URL的注释。
- en: 'We can now call our *hello* view in the browser, which gives us the following
    output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在浏览器中调用我们的*hello*视图，它给出了以下输出：
- en: '![Figure 12.1 – The result of calling our hello view](img/Figure_12.1_B18722.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 调用我们的hello视图的结果](img/Figure_12.1_B18722.jpg)'
- en: Figure 12.1 – The result of calling our hello view
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 调用我们的hello视图的结果
- en: 'Calling this view also gives us the following log:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此视图也给我们以下日志：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From looking at the logs, it seems that we cannot ask any more of it. We now
    have a basic server up and running; however, this does not have all the functionality
    that we had in our previous application, built in Actix Web. Recoding all the
    features that we had would result in an excessively long chapter. In the next
    section, we will take advantage of our modular code and slot all our functionality
    into our Rocket application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从查看日志来看，我们不能再对它提出更多要求了。我们现在已经有一个基本的服务器正在运行；然而，这并没有包含我们在之前的Actix Web应用程序中拥有的所有功能。重新编码我们所有的功能将导致章节过长。在下一节中，我们将利用我们的模块化代码，并将所有功能嵌入到我们的Rocket应用程序中。
- en: Plugging in our existing modules
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入现有模块
- en: Throughout the book, we have been building isolated modules in their own files
    or directories that only concern themselves with one process. For instance, the
    database file only focuses on creating and managing database connections. The
    to-do module only focuses on constructing to-do items, and the JSON serialization
    module is entirely concerned with serializing data structures to and from JSON.
    With all this in mind, we will see how easily these modules can be copied into
    our application and used. Once we have done this, you will get to appreciate firsthand
    why isolated modules are important.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在各自的文件或目录中构建独立的模块，这些模块只关注一个过程。例如，数据库文件只专注于创建和管理数据库连接。待办事项模块只专注于构建待办事项，而JSON序列化模块完全专注于将数据结构序列化为JSON。考虑到这些，我们将看到这些模块如何轻松地复制到我们的应用程序中并使用。一旦我们这样做，你就会亲身体会到为什么独立的模块很重要。
- en: 'First, we must define our dependencies in the `Cargo.toml` file with the following
    code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在`Cargo.toml`文件中用以下代码定义我们的依赖项：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These are the crates that we have used in our previous modules. We can now
    copy over our old modules from the Actix Web application in the `web_app` directory
    to our Rocket application, with the following Bash commands:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们之前模块中使用的crates。现在，我们可以使用以下Bash命令将`web_app`目录中的旧模块复制到我们的Rocket应用程序中：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Everything is close to working; however, we do have some references to the
    Actix web framework. These can be deleted by deleting the trait implications.
    As we can see in the following diagram, isolated modules can be directly referenced,
    and the advanced integration can be implemented using traits:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 事情几乎都正常；然而，我们确实有一些对Actix web框架的引用。这些可以通过删除特质的实现来删除。正如我们可以在以下图中看到的那样，独立的模块可以直接引用，而高级集成可以通过特质来实现：
- en: '![Figure 12.2 – How our modules can interact with different frameworks](img/Figure_12.2_B18722.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 我们的模块如何与不同的框架交互](img/Figure_12.2_B18722.jpg)'
- en: Figure 12.2 – How our modules can interact with different frameworks
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 我们的模块如何与不同的框架交互
- en: 'Once we have deleted the Actix Web trait implementations in the `src/database.rs`
    and `src/json_serialization/to_do_items.rs` files, we can define and import our
    modules in the `main.rs` file. The top of the `main.rs` file should look like
    the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`src/database.rs`和`src/json_serialization/to_do_items.rs`文件中删除了Actix Web特质的实现，我们就可以在`main.rs`文件中定义和导入我们的模块。`main.rs`文件的开头应该看起来像以下这样：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the modules imported, we can recreate the `create` view with the following
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模块后，我们可以用以下代码重新创建`create`视图：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see from the preceding code that it is like our Actix Web implementation
    because we are using our existing modules. The only difference is that we pass
    the `ToDoItems` struct into the `Json` function from the Rocket crate. We have
    not implemented authentication yet, so we are just passing the user ID value of
    `1` for now into all the operations that require a user ID.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看出，它类似于我们的Actix Web实现，因为我们正在使用现有的模块。唯一的区别是我们将`ToDoItems`结构体传递给Rocket
    crate的`Json`函数。我们还没有实现身份验证，所以现在我们只是将用户ID值`1`传递到所有需要用户ID的操作中。
- en: 'Now that our `create` view is done, we can attach it to our server with the
    following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了`create`视图，我们可以使用以下代码将其附加到我们的服务器上：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can see that we do not have to build our own configuration functions. We
    can just line up the views in the array associated with the prefix, and the macro
    decorating the view functions defines the rest of the URL. We can now run our
    Rocket server with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们不必构建自己的配置函数。我们只需将视图按顺序排列在带有前缀的数组中，装饰视图函数的宏定义了其余的URL。现在我们可以使用以下命令运行我们的Rocket服务器：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We must remember to spin up our `docker-compose` so the database is accessible
    and run migrations on the database using the `diesel` client. We can then create
    our first to-do item with a `post` request, using the following URL:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住启动我们的`docker-compose`，以便数据库可访问，并使用`diesel`客户端在数据库上运行迁移。然后我们可以使用以下URL通过`post`请求创建我们的第一个待办事项：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After making the `post` request, we will get the following response body:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出`post`请求后，我们将得到以下响应体：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And there you have it! Our application is functioning, and we did not have to
    recode our entire code base. I know I am repeating myself throughout this book,
    but the importance of well-structured, isolated code cannot be overstated. What
    we have done here is useful when refactoring systems. For instance, I have worked
    on microservices systems where we have had to rip functionality out of one server
    because the scope of it was getting too big and create another one. As you have
    seen here, isolated modules make such tasks a dream that can be completed in record
    time with minimal effort.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们的应用程序正在运行，我们不必重写整个代码库。我知道我在这本书中一直在重复这一点，但结构良好、独立的代码的重要性不容忽视。我们在这里所做的是在重构系统时很有用的。例如，我曾在微服务系统中工作，我们必须从一个服务器中移除功能，因为它的范围变得太大，然后创建另一个。正如你所看到的，独立的模块使这样的任务变得像梦一样，可以在最短的时间内以最小的努力完成。
- en: Now that we have integrated our existing modules in a basic sense, we can move
    on to advanced integration by implementing Rocket traits for our modules.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经以基本的方式集成了现有的模块，我们可以通过为我们的模块实现Rocket特性来继续进行高级集成。
- en: Implementing Rocket traits
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Rocket特性
- en: Most of the logic that we have defined in our modules that we copied over can
    be directly referenced in our code. However, we do have to utilize the database
    connection and the JWT struct that had Actix Web trait implementations. If we
    are to copy over our views, we are going to have to implement Rocket traits for
    the database connection and JWT authentication because we pass them into our view
    functions in the Actix Web application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模块中定义的大部分逻辑，我们复制到代码中，可以直接在我们的代码中引用。然而，我们确实需要利用数据库连接和具有Actix Web特性实现的JWT结构体。如果我们复制视图，我们必须为数据库连接和JWT身份验证实现Rocket特性，因为我们把它们传递到Actix
    Web应用程序的视图函数中。
- en: 'Before we implement the Rocket traits, we must copy over the JWT file with
    the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现Rocket特性之前，我们必须使用以下命令复制JWT文件：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then must declare the following dependency in the `Cargo.toml` file with
    the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在`Cargo.toml`文件中使用以下代码声明以下依赖项：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now move on to the `src/jwt.rs` file for our Rocket trait implementation.
    First, we must import the following traits and structs at the top of the file
    with the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到`src/jwt.rs`文件，为我们的Rocket特性实现。首先，我们必须在文件顶部使用以下代码导入以下特性和结构体：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The core logic of the implementation of `FromRequest` will be the same because
    we are concerned with the decoding and authentication of our token. However, there
    will be some minor differences because we are implementing a trait from the Rocket
    framework, as opposed to an Actix Web crate. The main difference is that we must
    build our own `enum` that defines the possible outcomes with the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromRequest` 特性实现的核心理念将保持一致，因为我们关注的是令牌的解码和认证。然而，由于我们是从 Rocket 框架中实现一个特性，而不是从
    Actix Web crate 中实现，所以会有一些细微的差异。主要区别是我们必须使用以下代码构建自己的 `enum`，以定义可能的结果：'
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have picked the different possibilities here because the token might not
    be in the header, so it would be missing. Alternatively, the token might not be
    one of ours, so it could be invalid. And remember, we have a timestamp to force
    an expiry time. If the token has expired, it will have an expired status.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里选择了不同的可能性，因为令牌可能不在头部，所以可能会缺失。或者，令牌可能不是我们的，所以可能是无效的。记住，我们有一个时间戳来强制过期时间。如果令牌已过期，它将具有过期状态。
- en: 'The next step is merely implementing the `FromRequest` trait. We do not have
    to touch our `JwToken` struct because the code is isolated and only concerned
    with the encoding and decoding of tokens. The outline of our trait implementation
    can be defined with the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步仅仅是实现 `FromRequest` 特性。由于代码是隔离的，并且只关注令牌的编码和解码，我们不需要修改 `JwToken` 结构体。我们可以用以下代码定义特性的实现大纲：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we can see that we have decorated the implementation of the trait with
    an `async` trait macro. This is because requests happen in an async fashion. We
    also must define lifetime notation. This is because we must declare that the lifetime
    of the request will be the same as that of the trait implementation. We can see
    this with the `request` parameter in the `from_request` function. We can now lift
    the logic from our old Actix Web implementation into our `from_request` function
    with a few changes in the types we return. The lifted code should end up looking
    like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们使用 `async` 特性宏装饰了特性的实现。这是因为请求是以异步方式发生的。我们还必须定义生命周期注解。这是因为我们必须声明请求的生命周期将与特性实现的寿命相同。我们可以通过
    `from_request` 函数中的 `request` 参数看到这一点。现在，我们可以将旧 Actix Web 实现的逻辑提升到 `from_request`
    函数中，只需对返回的类型进行一些更改。提升的代码最终应该看起来像以下这样：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can see that we have wrapped our returns in the Rocket `Outcome`, which is
    not too surprising. We have also included our `enum` when decoding or accessing
    the token from the header has failed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经将返回值包装在 Rocket 的 `Outcome` 中，这并不令人意外。当从头部解码或访问令牌失败时，我们也包括了我们的 `enum`。
- en: 'Our `JwToken` struct can now be plugged into our Rocket application, but we
    do have to remember to remove the old Actix implementation and all references
    to the Actix Web framework. We also must declare our `jwt` module in the `main.rs`
    file with the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `JwToken` 结构体现在可以插入到我们的 Rocket 应用程序中，但我们必须记住移除旧的 Actix 实现以及所有对 Actix Web
    框架的引用。我们还在 `main.rs` 文件中声明了 `jwt` 模块，代码如下：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our next step is to implement the `FromRequest` trait for our database connection.
    At this point, it is a good idea for you to try and implement the `FromRequest`
    trait for the database connection by yourself. There is nothing new that you must
    know to achieve this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是实现对数据库连接的 `FromRequest` 特性。在这个阶段，自己尝试实现数据库连接的 `FromRequest` 特性是个不错的主意。为了实现这一点，你不需要了解任何新的内容。
- en: If you have tried to implement the `FromRequest` trait for the database connection
    yourself, then it should be like the following steps.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试自己实现数据库连接的 `FromRequest` 特性，步骤应该如下。
- en: 'First, we must import the required Rocket structs and traits in the `src/database.rs`
    file with the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在 `src/database.rs` 文件中导入所需的 Rocket 结构体和特性，代码如下：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then must define the outcomes. We either get the connection or we do not,
    so there is only one possible error for our `enum`, which takes the following
    form:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须定义结果。我们要么得到连接，要么得不到，所以我们的 `enum` 只有一个可能的错误，其形式如下：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then implement the `FromRequest` trait for the database connection with
    the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码实现对数据库连接的 `FromRequest` 特性：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code should not be too much of a surprise; we have merely fused
    the existing logic of getting a database connection with the implementation of
    a `FromRequest` trait that was laid out in the `JwToken` implementation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不应该令人惊讶太多；我们只是将获取数据库连接的现有逻辑与在`JwToken`实现中定义的`FromRequest`特性实现融合在一起。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may have noticed that we have annotated our `FromRequest` implementation
    with `[rocket::async_trait]`. We use this because, at the time of writing, the
    stabilization for the `async` feature in Rust does not include support for `async`
    functions in traits. If we try and implement an `async` function in a trait without
    the annotation, we will get the following error:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们用`[rocket::async_trait]`注解了我们的`FromRequest`实现。我们使用这个注解是因为，在撰写本文时，Rust中`async`特性的稳定化不包括特性中的`async`函数的支持。如果我们尝试在没有注解的情况下在特性中实现`async`函数，我们将得到以下错误：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `[rocket::async_trait]` annotation enables us to define `async` functions
    in a trait implementation. There are reasons why we cannot simply desugar the
    `async` function and have the following function signature:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`[rocket::async_trait]`注解使我们能够在特性实现中定义`async`函数。我们不能简单地解构`async`函数并拥有以下函数签名的原因有很多：'
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, it will not work because we cannot return the `impl` trait in trait
    functions because this is not supported. For in-depth reading on why `async` functions
    in traits are hard, please visit the following blog post: [https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/](https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会奏效，因为我们不能在特性函数中返回`impl`特性，因为这不被支持。关于为什么特性中的`async`函数难以实现的深入阅读，请访问以下博客文章：[https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/](https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/)。
- en: We can now implement our database connection in the `create` view in the `main.rs`
    file. Again, this is a good opportunity for you to try and implement the database
    connection using the `FromRequest` trait yourself.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`main.rs`文件中的`create`视图中实现我们的数据库连接。再次强调，这是一个很好的机会，让你尝试自己使用`FromRequest`特性来实现数据库连接。
- en: 'If you have attempted to utilize the Rocket `FromRequest` trait in the `create`
    view, your code should look as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在`create`视图中使用Rocket的`FromRequest`特性，你的代码应该看起来如下：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we run our application again and then hit the `create` endpoint, we will
    see that our implementation works! This is a revelation that our views with a
    few alterations can be copied and pasted over to our Rocket application from our
    Actix Web application. In the next section, we will integrate our existing views
    into our Rocket web application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行我们的应用程序，然后点击`create`端点，我们会看到我们的实现是有效的！这是一个启示，即我们的视图经过一些修改后可以复制粘贴到我们的Rocket应用程序中，从我们的Actix
    Web应用程序中。在下一节中，我们将把我们现有的视图集成到我们的Rocket Web应用程序中。
- en: Plugging in our existing views
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入我们现有的视图
- en: 'When it comes to our views, they are also isolated, and we can copy our views
    over to the Rocket application with a few minor changes to recycle the views that
    we built for our Actix Web application. We can copy the views with the following
    command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到我们的视图时，它们也是隔离的，我们可以通过一些小的修改将我们的视图复制到Rocket应用程序中，以回收我们在Actix Web应用程序中构建的视图。我们可以使用以下命令复制视图：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this copy, it goes without saying now that we must go through and scrub
    the views of any mentions of the Actix Web framework, as we are not using it.
    Once we have cleaned our views of any mention of Actix Web, we can refactor our
    existing code so that it works with the Rocket framework. We will start with our
    `login` view, as this takes in a JSON body and returns JSON in the following subsection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次复制，现在不用说我们也必须遍历并清除视图中的任何Actix Web框架的提及，因为我们没有使用它。一旦我们清除了视图中的任何Actix Web提及，我们就可以重构我们的现有代码，使其与Rocket框架兼容。我们将从我们的`login`视图开始，因为这个视图接收JSON体并返回JSON，在接下来的小节中讨论。
- en: Accepting and returning JSON
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受和返回JSON
- en: 'Before we change our view, we need to make sure that we have imported all we
    need in the `src/views/auth/login.rs` file with the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更改视图之前，我们需要确保我们已经使用以下代码在`src/views/auth/login.rs`文件中导入了所有需要的模块：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can see that there is not much that has changed apart from the `Json` struct
    coming from the Rocket crate. Implementing those Rocket traits really helped us
    sever a link in our code to the Actix framework and connect to the Rocket framework,
    without having to change how the structs that are implementing those traits are
    imported or used. With this in mind, the following outline of our login view should
    not be a shock:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，除了来自Rocket包的`Json`结构体之外，没有太多变化。实现这些Rocket特性真的帮助我们切断了代码与Actix框架的联系，并连接到了Rocket框架，而无需更改实现这些特性的结构体的导入或使用方式。考虑到这一点，以下是我们登录视图的轮廓应该不会令人惊讶：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can see that we reference our incoming JSON body and database connection
    in the same way as we did before in the Actix login view. The major difference
    is the macro that highlights what the data is and what format that incoming data
    takes. Inside the `login` view, we have the following logic:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们以与之前在Actix登录视图中相同的方式引用了我们传入的JSON体和数据库连接。主要的不同之处在于宏突出了数据是什么以及传入数据采取的格式。在`login`视图中，我们有以下逻辑：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can see in the code that the only difference is instead of returning multiple
    different codes, we merely throw an error. This approach is not optimal. In previous
    builds, the Rocket framework used to implement a straightforward response builder,
    like in Actix. However, at the time of writing, Rocket has implemented a lot of
    breaking changes in its recent releases. Standard response builders simply do
    not work now, and convoluted implementations of traits are needed just to return
    a response with a code, body, and values in the header. Documentation and examples
    of this are also limited at the time of writing. Further reading on constructing
    more advanced responses is supplied in the *Further* *reading* section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，代码中唯一的区别是，我们不是返回多个不同的代码，而是简单地抛出一个错误。这种方法并不理想。在之前的构建中，Rocket框架曾经使用一个简单的响应构建器，就像在Actix中一样。然而，在撰写本文时，Rocket在其最近的版本中实施了很多破坏性更改。标准响应构建器现在根本不起作用，需要复杂的特性实现才能返回带有代码、正文和头值的响应。撰写本文时，文档和示例也有限。更多关于构建更高级响应的阅读材料可在*进一步阅读*部分找到。
- en: Now that our `login` view is defined, we can move on to our `logout` view that
    returns raw HTML.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`login`视图，我们可以继续到我们的`logout`视图，该视图返回原始HTML。
- en: Returning raw HTML
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回原始HTML
- en: 'If you recall, our logout mechanism returns raw HTML that runs JavaScript in
    a browser to remove our token. When it comes to Rocket, returning raw HTML is
    simple. In our `src/views/auth/logout.rs` file, the entire code takes the following
    form:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们的注销机制返回的是原始HTML，它在浏览器中运行JavaScript来移除我们的令牌。当涉及到Rocket时，返回原始HTML非常简单。在我们的`src/views/auth/logout.rs`文件中，整个代码如下所示：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can see that it is returning a string, just like in the previous Actix Web
    view, but this string is wrapped in a `RawHtml` struct. We can now start updating
    our to-do action views so that our users can manipulate to-do items, as discussed
    in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，它返回的是一个字符串，就像在之前的Actix Web视图中一样，但这个字符串被`RawHtml`结构体包裹。现在我们可以开始更新我们的待办事项操作视图，以便我们的用户可以操作待办事项，如下一节所述。
- en: Returning status with JSON
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回带有JSON的状态
- en: 'So far, we have returned JSON and raw HTML. However, remember that our to-do
    applications return JSON with different statuses. To explore this concept, we
    can revisit our `create` view in the `src/views/to_do/create.rs` file, where we
    must return a created status with a JSON body. First, all our imports are the
    same as they were before, apart from the status and JSON structs from the Rocket
    framework with the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经返回了JSON和原始HTML。然而，请记住，我们的待办事项应用程序返回带有不同状态的JSON。为了探索这个概念，我们可以回顾一下`src/views/to_do/create.rs`文件中的`create`视图，在那里我们必须返回一个带有JSON体的创建状态。首先，所有我们的导入都与之前相同，除了来自Rocket框架的状态和JSON结构体，如下所示：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With these imports, we can define the outline of our `create` view function
    with the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些导入，我们可以用以下代码定义`create`视图函数的轮廓：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can see that our return value is the `Created` struct, containing the `Json`
    struct, which in turn contains the `ToDoItems` struct. We can also see that our
    JWT authentication is implemented in a view the same way because, again, we are
    implementing the Rocket traits. Our database logic is the same as the previous
    view, as seen with the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的返回值是`Created`结构体，其中包含`Json`结构体，而`Json`结构体又包含`ToDoItems`结构体。我们还可以看到，我们的JWT身份验证也是以相同的方式在视图中实现的，因为，再次强调，我们正在实现Rocket特性。我们的数据库逻辑与之前的视图相同，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the task is already not present in the database, we will insert our new
    to-do item. Once we have done this, we get the state of our system and return
    it with the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务已经在数据库中不存在，我们将插入我们的新待办事项。一旦我们这样做，我们就获取我们系统的状态，并使用以下代码返回它：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The empty string is the location. This can be left blank with no consequences.
    We then attach our body with the `body` function of the status. This is all that
    is needed to get our `create` view running as we want it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串是位置。这可以留空，不会产生任何后果。然后我们使用状态的`body`函数附加我们的主体。这就是我们想要运行`create`视图所需的所有内容。
- en: 'When it comes to the other views for our to-do tasks, they will all be some
    variation of what we have done for the `create` view. All to-do views need to
    take the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到我们的待办任务的其它视图时，它们都将是我们为`create`视图所做内容的某种变体。所有待办事项视图都需要采取以下步骤：
- en: Authenticate using JWT.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JWT进行认证。
- en: Connect to a database.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库。
- en: Take in data from the JSON body and/or user data from the JWT.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从JSON主体中获取数据以及/或从JWT获取用户数据。
- en: Make some manipulation of the data in the database (apart from the `GET` view).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对数据库中的数据进行一些操作（除了`GET`视图）。
- en: Return the state of the database for the user.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回用户的数据库状态。
- en: After seeing what we have done with the `create` view, you should be able to
    work through all the other views to make them compatible with the Rocket framework.
    We have covered everything needed to make these changes. Spelling out these changes
    in the book will lead to needless repetitive steps being carried out, excessively
    bloating it. These changes are available on the book’s GitHub repository.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到我们对`create`视图所做的一切之后，你应该能够处理所有其他视图，使它们与Rocket框架兼容。我们已经涵盖了进行这些更改所需的所有内容。在书中详细说明这些更改会导致不必要的重复步骤被执行，过度膨胀它。这些更改可在书的GitHub仓库中找到。
- en: Once the to-do item views have been carried out, we can move on to the final
    view that’s needed, the creation of a user, where we must return different statuses
    depending on the outcome.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了待办事项视图，我们就可以继续到最后一个需要的视图，即创建用户，我们必须根据结果返回不同的状态。
- en: Returning multiple statuses
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回多个状态
- en: 'When it comes to creating a user, we merely return a created status code or
    a conflict status code and nothing else. We do not need to return data because
    the person who has just created the user already knows the user details. In Rocket,
    we can return multiple different status codes with no body. We can explore this
    concept in the `src/views/to_do/create.rs` file, but first, we must ensure that
    we import the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到创建用户时，我们只返回创建状态码或冲突状态码，不再返回其他内容。我们不需要返回数据，因为刚刚创建用户的个人已经知道用户详情。在Rocket中，我们可以不返回任何body而返回多个不同的状态码。我们可以在`src/views/to_do/create.rs`文件中探索这个概念，但首先，我们必须确保以下内容被导入：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that we have everything we need, we can define the outline of the view
    with the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的东西，我们可以使用以下代码定义视图的轮廓：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we can see that there is nothing new, apart from returning a single `Status`
    struct. Our database logic takes the following form:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到除了返回一个单一的`Status`结构体之外，没有新的内容。我们的数据库逻辑如下所示：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And we return a status out of two possible ones with the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码从两种可能的状态中返回一个状态：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our views are complete. We can now move on to the next section to register our
    views with the Rocket application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图已经完整。现在我们可以继续到下一节，将我们的视图注册到Rocket应用程序中。
- en: Registering our views with Rocket
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的视图注册到Rocket
- en: 'Before we move on to the `src/main.rs` file, we must ensure that our view functions
    are available to the `src/main.rs`. This means going through all the `mod.rs`
    files in each view module and declaring the functions that define these views
    as public. We can then move on to the `src/main.rs` file and ensure that the following
    is imported:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到`src/main.rs`文件之前，我们必须确保我们的视图函数对`src/main.rs`可用。这意味着要遍历每个视图模块中的所有`mod.rs`文件，并将定义这些视图的函数声明为公共的。然后我们可以继续到`src/main.rs`文件，并确保以下内容被导入：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `macro_use` declarations should not be a surprise; however, we import the
    Rocket structs to define our CORS policy. With these crates imported, we now must
    ensure that the following modules have been declared:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`macro_use`声明不应该令人惊讶；然而，我们导入Rocket结构体来定义我们的CORS策略。有了这些crate导入，我们现在必须确保以下模块已被声明：'
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'These modules should all look familiar to you. We then must import our views
    with the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块对你来说都应该很熟悉。然后我们必须使用以下代码导入我们的视图：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We now have everything we need imported. Before declaring our views on the
    server, we need to define our CORS policy. This is achieved by declaring a struct
    with no fields. We then implement the `Fairing` trait for this struct, allowing
    traffic. Fairings essentially define middleware. Further information on fairings
    is provided in the *Further reading* section. Our CORS policy can be defined with
    the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经导入了所有需要的内容。在声明服务器上的视图之前，我们需要定义我们的CORS策略。这是通过声明一个没有字段的struct来实现的。然后我们为这个struct实现`Fairing`特质，允许流量。Fairings本质上定义了中间件。关于Fairings的更多信息可以在*进一步阅读*部分找到。我们的CORS策略可以用以下代码定义：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By this point in the book, we are now familiar with the concept of CORS and
    how to implement a Rocket trait. The preceding code needs no elaboration.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，我们现在已经熟悉了CORS的概念以及如何实现Rocket特质。前面的代码不需要详细说明。
- en: 'We now have everything needed to mount our views to the server with the following
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了将视图挂载到服务器所需的所有内容，以下代码所示：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Again, there is no explanation needed. You may have noticed that we have started
    to simply show code with little to no explanation. This is good, as we have become
    familiar with the building blocks that we are using. Do not worry – we have come
    to the end of building the main Rocket application, as it will run and do everything
    we need. We could manually test this. However, this would take time and is error-prone.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里不需要任何解释。你可能已经注意到，我们已经开始简单地展示代码，几乎不进行解释。这是好事，因为我们已经熟悉了我们正在使用的构建块。不用担心——我们已经完成了主要Rocket应用程序的构建，因为它将运行并完成我们所需要的一切。我们可以手动测试这个。然而，这将花费时间且容易出错。
- en: Remember, we built our tests in Newman using Postman! In the next section, we
    will test all our endpoints with a few commands using the existing testing pipeline.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们是用Postman在Newman中构建我们的测试的！在下一节中，我们将使用现有的测试流程，通过几个命令来测试所有我们的端点。
- en: Plugging in our existing tests
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入我们现有的测试
- en: 'Because we have used Newman in our testing pipeline, we do not have to worry
    about high coupling with our choice of web framework. First, we need to copy over
    our tests in the `scripts` directory with the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经在测试流程中使用了Newman，所以我们不必担心与我们的Web框架选择的高耦合。首先，我们需要使用以下命令将`scripts`目录中的测试复制过来：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, before running it, we must add a `GET` method for our `login` view
    with the following outline:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在运行之前，我们必须为我们的`login`视图添加一个`GET`方法，如下所示：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We then need to import this view into the `src/main.rs` file and declare it
    in the `auth` mounting for our server. We are now ready to run our full tests
    with the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将这个视图导入到`src/main.rs`文件中，并在我们的服务器`auth`挂载中声明它。我们现在可以运行我们的完整测试，如下所示：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will run our full pipeline and give the following results:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行我们的完整流程，并给出以下结果：
- en: '![Figure 12.3 – Results from our full test pipeline](img/Figure_12.3_B18722.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 我们完整测试流程的结果](img/Figure_12.3_B18722.jpg)'
- en: Figure 12.3 – Results from our full test pipeline
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 我们完整测试流程的结果
- en: 'We can see that out of 64 checks, only 3 have failed. If we scroll further
    down, we can see that the errors occur only because we are returning different
    response codes for the `create` view, as seen here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在64次检查中，只有3次失败了。如果我们继续向下滚动，我们可以看到错误仅发生因为我们为`create`视图返回了不同的响应代码，如下所示：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Everything else, in terms of the logging in, authentication, migrations, and
    state of the data in the database between every step, has behaved just like we
    expected it to.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录、认证、迁移以及每一步之间数据库中的数据状态方面，其他所有事情的表现都正如我们所预期的那样。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gone through the main concepts needed to replicate
    our to-do application. We built and ran a Rocket server. We then defined routes
    and established a database connection for our server. After that, we explored
    middleware and built authentication and data processing, using guards for our
    views. With this, we created a view that utilized everything we have covered in
    this book.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了复制我们的待办事项应用程序所需的主要概念。我们构建并运行了一个Rocket服务器。然后我们定义了路由并为我们的服务器建立了数据库连接。之后，我们探讨了中间件并构建了认证和数据处理，使用守卫来处理我们的视图。通过这些，我们创建了一个利用了本书中所有内容的视图。
- en: What we gained here was a deeper appreciation for the modular code that we have
    built throughout this book. Even though some of the concepts we revisited had
    not been touched since the start of this book, these modules were isolated, did
    one thing, and did what their labels proposed. Because of this, they can easily
    be copied over and utilized in a completely different framework. Our test pipeline
    also came in handy, instantly confirming that our Rocket application behaves in
    the same way our Actix Web application does. With this in mind, our Rocket application
    could be seamlessly integrated into our build and deployment pipelines instead
    of our Actix Web application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里获得的是对我们在这本书中构建的模块代码的更深刻的欣赏。尽管我们回顾的一些概念自本书开始以来尚未触及，但这些模块是隔离的，只做一件事，并且做了它们标签所提议的事情。正因为如此，它们可以轻松地复制并用于完全不同的框架。我们的测试流程也派上了用场，立即确认我们的
    Rocket 应用程序的行为与我们的 Actix Web 应用程序相同。考虑到这一点，我们的 Rocket 应用程序可以无缝集成到我们的构建和部署流程中，而不是我们的
    Actix Web 应用程序。
- en: In the next chapter, we will cover the best practices for building a web application,
    resulting in a clean web application repository. Here, you will not only learn
    how to structure a web application repository in terms of testing and configuration
    but also how to package a web application in Docker as a distroless distribution,
    resulting in tiny Docker images that are roughly 50 MB.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍构建 Web 应用程序的最佳实践，从而产生一个干净的 Web 应用程序存储库。在这里，你不仅将学习如何从测试和配置的角度来结构 Web
    应用程序存储库，还将学习如何将 Web 应用程序打包到 Docker 中作为无依赖的发行版，从而产生大约 50 MB 的微型 Docker 镜像。
- en: Further reading
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Rocket documentation: [https://rocket.rs/](https://rocket.rs/)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 火箭文档：[https://rocket.rs/](https://rocket.rs/)
- en: 'Fairings documentation: [https://rocket.rs/v0.4/guide/fairings/](https://rocket.rs/v0.4/guide/fairings/)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 火箭组件文档：[https://rocket.rs/v0.4/guide/fairings/](https://rocket.rs/v0.4/guide/fairings/)
- en: '*Rust Web Development with Rocket: A practical guide to starting your journey
    in Rust web development using the Rocket framework*, *Karuna Murti* (2022), *Packt
    Publishing*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用 Rocket 进行 Rust 网络开发：使用 Rocket 框架开始 Rust 网络开发之旅的实用指南》*，*Karuna Murti*（2022年），*Packt
    出版*'
- en: Questions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: We have witnessed firsthand the importance of isolating processes such as our
    test pipeline. Looking at the test pipeline, is there a dependency that could
    be removed to further decouple the pipeline so that it isn’t even dependent on
    us testing a Rust server?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们亲身体验到了隔离过程的重要性，例如我们的测试流程。观察我们的测试流程，是否有可以移除的依赖关系，以进一步解耦流程，使其甚至不依赖于我们测试 Rust
    服务器？
- en: How do we attach and detach all functionality in our modules with frameworks
    such as Actix and Rocket?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用 Actix 和 Rocket 等框架将模块中的所有功能附加和分离？
- en: How would we deploy our Rocket server on AWS?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 AWS 上部署我们的 Rocket 服务器？
- en: Answers
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Right now, our test pipeline relies on Diesel to do the migrations. We could
    simply build our own SQL scripts, housed in directories that define our version
    with a version table in the database. This would completely decouple our testing
    pipeline from the server that we are testing. If the server has the same endpoints
    and access to a PostgreSQL database, it can be tested using our pipeline, no matter
    what language the server is coded in.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们的测试流程依赖于 Diesel 进行迁移。我们可以简单地构建自己的 SQL 脚本，存放在定义我们数据库版本版本的目录中。这将完全解耦我们的测试流程与我们要测试的服务器。如果服务器具有相同的端点和访问
    PostgreSQL 数据库的权限，它可以使用我们的流程进行测试，无论服务器是用什么语言编写的。
- en: If the module is simple with a good interface, we can merely copy it over and
    import it where we want to use it. If the module relies on advanced functionality
    with the framework, we must delete the trait implementations for the framework
    and implement traits for the new one.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模块简单且接口良好，我们只需将其复制并导入我们想要使用它的地方。如果模块依赖于框架的高级功能，我们必须删除框架的特质实现，并为新的一个实现特质。
- en: We need to note that our test pipeline ran the Rocket server without any alterations.
    This is because we are using the same config and using Cargo to build and run
    the application. We would merely just have to point our build to the Rocket application
    and copy over our Dockerfile to the Rocket application. Our build process would
    then build the Rocket application in Docker and deploy it to Docker Hub. Our deployment
    process would then pull the image from Docker Hub and deploy it. We know our endpoints
    are the same and behave in the same way, so integration should be painless.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要注意，我们的测试流程是在没有任何修改的情况下运行了Rocket服务器。这是因为我们使用了相同的配置，并使用Cargo来构建和运行应用程序。我们只需将构建指向Rocket应用程序，并将我们的Dockerfile复制到Rocket应用程序中。然后，我们的构建过程将在Docker中构建Rocket应用程序并将其部署到Docker
    Hub。我们的部署过程将然后从Docker Hub拉取镜像并部署它。我们知道我们的端点是相同的，并且以相同的方式表现，所以集成应该不会痛苦。
