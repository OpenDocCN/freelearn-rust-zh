- en: Metaprogramming with Macros
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用宏进行元编程
- en: Metaprogramming is a concept that changes the way you look at instructions and
    data in a program. It allows you to generate new code by treating instructions
    like any other piece of data. Many languages have support for metaprogramming,
    for example, Lisp's macros, C's `#define` construct, and Python's metaclasses.
    Rust is no different and provides many forms of metaprogramming, which we'll explore
    in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程是一个改变你对程序中指令和数据看法的概念。它允许你通过将指令视为其他任何数据片段来生成新的代码。许多语言都支持元编程，例如 Lisp 的宏、C 的
    `#define` 结构和 Python 的元类。Rust 也不例外，它提供了许多形式的元编程，我们将在本章中探讨。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: What is metaprogramming?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是元编程？
- en: Macros in Rust and their forms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 中的宏及其形式
- en: Declarative macros, macro variables, and types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式宏、宏变量和类型
- en: Repeating constructs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复结构
- en: Procedural macros
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程式宏
- en: Macro use case
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏的使用案例
- en: Available macro crates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的宏库
- en: What is metaprogramming?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是元编程？
- en: '"Lisp isn''t a language, it''s a building material."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '"Lisp 不仅仅是一种语言，它是一种建筑材料。"'
- en: '*– Alan Kay*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*– 阿兰·凯*'
- en: 'Any program, regardless of the language used, contains two entities: data and
    instructions that manipulate the data. The usual flow of a program is mostly concerned
    with manipulating data. The issue with instructions, though, is that once you
    write them, it''s like they''ve been carved into stone, and so they are non-malleable.
    It would be more enabling if we could treat instructions as data and generate
    new instructions using code. Metaprogramming provides exactly that!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序，无论使用何种语言，都包含两个实体：数据和操纵数据指令。程序通常的流程主要关注数据的操纵。然而，指令的问题在于，一旦你编写了它们，就像它们已经被刻在石头上一样，因此它们是不可变的。如果我们能够将指令视为数据并使用代码生成新的指令，那就更有助于实现。元编程正是提供了这样的功能！
- en: 'It''s a programming technique where you can write code that has the ability
    to generate new code. Depending on the language, it can be approached in two ways:
    at runtime or at compile time. Runtime metaprogramming is available in dynamic
    languages such as Python, Javascript, and Lisp. For compiled languages, it''s
    not possible to generate instructions at runtime because these languages perform
    the ahead of time compilation of programs. However, you have the option of generating
    code at compile time, which is what C macros provide. Rust also provides compile
    time code generation capabilities, and these are more capable and sound than C
    macros.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种编程技术，你可以编写具有生成新代码能力的代码。根据语言的不同，它可以通过两种方式来处理：在运行时或在编译时。运行时元编程在动态语言如 Python、JavaScript
    和 Lisp 中可用。对于编译语言，由于这些语言在编译时对程序进行编译，因此无法在运行时生成指令。然而，你可以在编译时生成代码，这正是 C 宏所提供的。Rust
    也提供了编译时代码生成能力，这些能力比 C 宏更强大和可靠。
- en: In many languages, metaprogramming constructs are often denoted by the umbrella
    term **macros**, which for some languages are a built-in feature. For others,
    they are provided as a separate compilation phase. In general, a macro takes an
    arbitrary sequence of code as input and outputs valid code that can be compiled
    or executed by the language, along with other code. The input to the macro doesn't
    need to be a valid syntax and you are free to define your own custom syntax for
    the macro input. Also, how you invoke a macro and the syntax for defining them
    is different across languages. For instance, C macros works at the preprocessor
    stage, which reads tags starting with `#define` and expands them before forwarding
    the source file to the compiler. Here, expanding means generating code by substituting
    inputs that are provided to the macro. Lisp, on the other hand, provides function-like
    macros that are defined with `defmacro` (a macro itself), which takes the name
    of the macro being created and one or more parameters, and returns new Lisp code.
    However, C and Lisp macros lack a property that's referred to as hygiene. They
    are non-hygienic in the sense that they can capture and interfere with code outside
    the macro upon expansion, which can lead to unexpected behavior and logical errors
    when the macro is invoked at certain places in the code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，元编程结构通常由总称**宏**表示，对于某些语言来说，这是一个内置特性。对于其他语言，它们作为单独的编译阶段提供。一般来说，宏接受任意序列的代码作为输入，并输出有效的代码，这些代码可以被语言编译或执行，并与其他代码一起。宏的输入不需要是有效的语法，你可以自由地为宏输入定义自己的自定义语法。此外，调用宏的方式以及定义它们的语法在不同的语言中是不同的。例如，C宏在预处理阶段工作，它读取以`#define`开始的标签，并在将源文件转发给编译器之前将其展开。在这里，展开意味着通过用提供给宏的输入替换来生成代码。另一方面，Lisp提供了类似于函数的宏，这些宏是用`defmacro`（一个宏本身）定义的，它接受正在创建的宏的名称和一个或多个参数，并返回新的Lisp代码。然而，C和Lisp宏缺少一个被称为卫生性的属性。它们在展开时是非卫生的，这意味着它们可以捕获并干扰宏之外的定义的代码，这可能导致在代码的某些位置调用宏时出现意外的行为和逻辑错误。
- en: 'To demonstrate the problem with a lack of hygiene, we''ll take the example
    of a C macro. These macros simply copy/paste code with simple variable substitutions
    and are not context aware. Macros written in C are not hygienic in the sense that
    they can refer to variables defined anywhere, as long as those variables are in
    scope at the macro invocation site. For instance, the following is a macro `SWITCH`
    defined in C that can swap two values, but ignorantly modifies other values in
    doing so:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示缺乏卫生性的问题，我们将以一个C宏为例。这些宏只是简单地复制/粘贴代码并进行简单的变量替换，并且不具备上下文意识。用C编写的宏在意义上不是卫生的，因为它们可以引用任何地方定义的变量，只要这些变量在宏调用位置的作用域内。例如，以下是一个在C中定义的`SWITCH`宏，它可以交换两个值，但在交换过程中无意中修改了其他值：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Compiling this with `gcc c_macros.c -o macro && ./macro` gives the following
    output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gcc c_macros.c -o macro && ./macro`编译此程序会得到以下输出：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, unless we declare our own `temp` variable inside the
    `SWITCH` macro, the original `temp` variable in `main` is modified by the expansion
    of the `SWITCH` macro. This unhygienic nature makes C macros unsound and brittle,
    and can easily make a mess unless special precautions are taken, such as using
    a different name for the `temp` variable within the macro.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，除非我们在`SWITCH`宏内部声明自己的`temp`变量，否则`main`中的原始`temp`变量会被`SWITCH`宏的展开所修改。这种非卫生性使得C宏不可靠且脆弱，除非采取特殊预防措施，例如在宏内部使用不同的`temp`变量名称，否则很容易造成混乱。
- en: 'Rust macros on the other hand are hygienic and also more context aware than
    just performing simple string substitution and expansion. They are aware of the
    scope of the variables that have been referenced within the macro and do not shadow
    any identifiers that have already been declared outside. Consider the following
    Rust program, which tries to implement the macro we used previously:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，Rust宏是卫生的，并且比仅仅执行简单的字符串替换和展开更具有上下文意识。它们知道在宏内部引用的变量的作用域，并且不会影响已经在外部声明的标识符。考虑以下Rust程序，它试图实现我们之前使用的宏：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we created a macro called `switch!` and later invoked
    that in `main` with two values, `x` and `y`. We'll skip explaining the details
    in the macro definition, as we will cover them in detail later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为`switch!`的宏，并在`main`中使用两个值`x`和`y`调用了它。我们将跳过对宏定义的细节解释，因为我们将在这章的后面详细讨论它们。
- en: 'However, to our surprise, this doesn''t compile and fails with the following
    error:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，令我们惊讶的是，这不能编译，并且会失败，错误信息如下：
- en: '![](img/e46aaef8-a1c3-4398-8ed3-d837348112f8.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e46aaef8-a1c3-4398-8ed3-d837348112f8.png)'
- en: From the error message, our `switch!` macro doesn't know anything about the
    `temp` variable that's declared in `main`. As we can see, Rust macros don't capture
    variables from their environment as they work differently compared to C macros.
    Even if it would have, we will be saved from modification as `temp` is declared
    immutable in the preceding program. Neat!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从错误信息来看，我们的 `switch!` 宏对在 `main` 中声明的 `temp` 变量一无所知。正如我们所看到的，Rust 宏在处理时不会像 C
    宏那样从其环境中捕获变量。即使它能够这样做，我们也会因为 `temp` 在前面的程序中被声明为不可变而避免修改。真 neat！
- en: Before we get into writing more macros like these in Rust, it's important to
    have an idea of when to use a macro-based solution for your problem and when not
    to!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写更多这样的 Rust 宏之前，了解何时为你的问题使用基于宏的解决方案，何时不使用它是很重要的！
- en: When to use and not use Rust macros
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用和何时不使用 Rust 宏
- en: One of the advantages of using macros is that they don't evaluate their arguments
    eagerly like functions do, which is one of the motivations to use macros other
    than functions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏的一个优点是它们不像函数那样急于评估它们的参数，这是除了函数之外使用宏的动机之一。
- en: By eager evaluation, we mean that a function call like `foo(bar(2))` will first
    evaluate `bar(2)` and then pass its value to `foo`. Contrary to that, this is
    a lazy evaluation, which is what you see in iterators.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过急于评估，我们指的是像 `foo(bar(2))` 这样的函数调用将首先评估 `bar(2)`，然后将它的值传递给 `foo`。相反，这是一个懒评估，这就是你在迭代器中看到的情况。
- en: 'A general *rule of thumb* is that macros can be used in situations where functions
    fail to provide the desired solution, where you have code that is quite repetitive,
    or in cases where you need to inspect the structure of your types and generate
    code at compile time. Taking examples from real use cases, Rust macros are used
    in a lot of cases, such as the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一般的**经验法则**是，当函数无法提供所需的解决方案时，或者你有相当重复的代码时，或者你需要检查你的类型结构并在编译时生成代码时，可以使用宏。从实际用例中举例，Rust
    宏在许多情况下都被使用，例如以下情况：
- en: Augmenting the language syntax by creating custom **Domain-Specific Languages**
    (**DSLs**)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建自定义**领域特定语言**（**DSLs**）来增强语言语法
- en: Writing compile time serialization code, like serde does
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写编译时序列化代码，就像 serde 所做的那样
- en: Moving computation to compile-time, thereby reducing runtime overhead
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将计算移动到编译时，从而减少运行时开销
- en: Writing boilerplate test code and automating test cases
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写样板测试代码和自动化测试用例
- en: Providing zero cost logging abstractions such as the log crate
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供零成本日志抽象，如 log crate
- en: At the same time, macros should be used sparingly as they make the code difficult
    to maintain and reason about, as they work at the meta level and not many developers
    will be comfortable using them. They make the code harder to read and from a maintainability
    perspective, readability should always be preferred. Also, heavy use of macros
    can result in performance penalties due to a lot of duplicate code generation,
    which affects the CPU instruction cache.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，宏应该谨慎使用，因为它们会使代码难以维护和推理，因为它们在元级别工作，而且并不是很多开发者会感到舒适地使用它们。它们使代码更难阅读，从可维护性的角度来看，可读性应该始终优先。此外，宏的过度使用可能会导致性能惩罚，因为会产生大量的重复代码生成，这会影响
    CPU 指令缓存。
- en: Macros in Rust and their types
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 中的宏及其类型
- en: Rust macros do their magic of code generation before the program compiles to
    a binary object file. They take input, known as **token trees**, and are expanded
    at the end of the second pass of parsing during **Abstract Syntax Tree** (**AST**)
    construction. These are pieces of jargon from the compiler world and need some
    explanation, so let's do that. To understand how macros work, we need to be familiar
    with how source code is processed by the compiler to understand a program. This
    will help us in understanding how a macro processes its input and the error messages
    they emit when we use them incorrectly. We'll only cover parts that are relevant
    to our understanding of macros.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 宏在程序编译成二进制对象文件之前就完成了它们的代码生成魔法。它们接收输入，称为**令牌树**，并在解析的第二遍结束时，在**抽象语法树**（**AST**）构建过程中进行展开。这些都是编译器领域的术语，需要一些解释，所以让我们来解释一下。为了理解宏是如何工作的，我们需要熟悉编译器如何处理源代码以理解程序。这将帮助我们理解宏如何处理其输入，以及当我们使用它们不正确时它们产生的错误信息。我们只涵盖与我们对宏理解相关的部分。
- en: First, the compiler reads the source code byte by byte and groups characters
    into meaningful chunks, which are called **tokens**. This is done by a component
    of the compiler that's generally referred to as the **tokenizer**. Therefore,
    an `a + 3 * 6` expression gets converted to `"a", "+", "3", "*", "6"`, which is
    a sequence of tokens. Other tokens can be the `fn` keyword, any identifier, braces
    `{}` `()`, an assignment operator `=`, and so on. These tokens are called **token
    trees** in macro parlance. There are also tokens trees such as `"(", ")", "}","{"`,
    which can group other tokens. Now, at this stage, the token sequences by themselves
    don't convey any meaning on how to process and interpret the program. For that,
    we need a **parser**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器逐字节读取源代码并将字符分组为有意义的块，这些块被称为**令牌**。这是通过编译器的一个组件完成的，通常被称为**分词器**。因此，`a +
    3 * 6`表达式被转换为`"a", "+", "3", "*", "6"`，这是一个令牌序列。其他令牌可以是`fn`关键字、任何标识符、括号`{}` `()`、赋值运算符`=`等等。这些令牌在宏的术语中被称为**令牌树**。还有一些可以分组其他令牌的令牌树，例如`"(",
    ")", "}", "{"`。现在，在这个阶段，令牌序列本身并不传达任何关于如何处理和解释程序的意义。为此，我们需要一个**解析器**。
- en: A parser converts this flat stream of tokens into a hierarchical structure that
    guides the compiler on how to interpret the program. The token trees are passed
    on to the parser, which constructs an in-memory representation of the program
    called the Abstract Syntax Tree. For instance, our sequence of tokens, `a + 3
    * 6`, which is an expression, can be evaluated with the value `20` when `a` is
    `2`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器将这个扁平的令牌流转换为层次结构，指导编译器如何解释程序。令牌树被传递给解析器，它构建一个内存中的程序表示，称为抽象语法树。例如，我们的令牌序列`a
    + 3 * 6`，它是一个表达式，当`a`的值为`2`时，可以评估为`20`。
- en: 'However, the compiler doesn''t know how to evaluate this expression correctly
    unless we separate the precedence of operators (that is, `*` comes before `+`)
    and represent them with a tree structure, as shown in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非我们分离运算符的优先级（即`*`在`+`之前），并以树结构表示它们，否则编译器不知道如何正确评估这个表达式，如下面的图所示：
- en: '![](img/5ae0a294-4e3c-4870-a569-9c690d823729.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ae0a294-4e3c-4870-a569-9c690d823729.png)'
- en: When we have represented the expression as a tree structure in code so that
    multiplication happens before addition, we can do a post order traversal of this
    tree to correctly evaluate the expression. So, given that explanation, where does
    our macro expansion fit here? Rust macros are parsed at the end of the second
    phase of Abstract Syntax Tree construction, which is a phase where name resolution
    happens. Name resolution is the stage where variables that are defined in the
    expression are looked up for their existence in the scope. In the preceding expression,
    name resolution will happen for the `a` variable. Now, if the `a` variable in
    our preceding expression was assigned a value from a macro invocation such as
    `let a = foo!(2 + 0);`, then the parser goes on to expand the macro before proceeding
    to the name resolution. The name resolution phase catches errors in the program,
    such as using a variable that is not in scope. However, there are more complex
    cases than this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将表达式表示为代码中的树结构，使得乘法发生在加法之前时，我们可以对这个树进行后序遍历以正确评估表达式。因此，根据这个解释，我们的宏展开在这里是如何定位的？Rust宏在抽象语法树构建的第二阶段结束时被解析，这是一个名称解析发生的阶段。名称解析是查找表达式定义中变量在作用域中存在性的阶段。在前面的表达式中，将进行对`a`变量的名称解析。现在，如果前述表达式中的`a`变量从宏调用（如`let
    a = foo!(2 + 0);`）中分配了一个值，那么解析器会在进行名称解析之前展开宏。名称解析阶段会捕捉程序中的错误，例如使用不在作用域中的变量。然而，还有比这更复杂的情况。
- en: This entails Rust macros being context aware and, depending on what your macro
    expands into, they can only appear in supported places, as defined in the language's
    grammar. For example, you cannot write a `let` statement at the item level, that
    is, within a module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Rust宏是上下文感知的，并且根据宏展开的内容，它们只能出现在语言语法定义的支持位置。例如，你无法在项目级别（即在模块内）编写`let`语句。
- en: Grammar defines valid ways to write programs, just like grammar in a spoken
    language guides construction of meaningful sentences. For those who are curious,
    Rust's grammar is defined at [https://doc.rust-lang.org/grammar.html](https://doc.rust-lang.org/grammar.html).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 语法定义了编写程序的有效方式，就像口语中的语法指导构建有意义的句子一样。对于那些好奇的人，Rust的语法定义在[https://doc.rust-lang.org/grammar.html](https://doc.rust-lang.org/grammar.html)。
- en: 'One instance of macros that we''ve seen several times already is the `println!`
    macro. It is implemented as a macro because it allows Rust to check at compile
    time that its arguments are valid and that the string interpolation variables
    that have been passed to it are correct in number. Another advantage of using
    a macro for printing strings is that it allows us to pass as many arguments to
    `println!` as possible, which would not have been possible if it were implemented
    as a regular function. This is because Rust does not support variadic arguments
    for functions. Consider the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次看到的一个宏实例是 `println!` 宏。它被实现为一个宏，因为它允许 Rust 在编译时检查其参数是否有效，以及传递给它的字符串插值变量数量是否正确。使用宏打印字符串的另一个优点是，它允许我们尽可能多地传递参数给
    `println!`，如果它被实现为一个常规函数，这是不可能的。这是因为 Rust 不支持函数的可变参数。考虑以下示例：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you already know, the second form will fail at compile time because it''s
    missing an argument that matches the format string. This is reported at compile
    time. In this way, it is far safer than C''s `printf` function, which can lead
    to memory vulnerabilities such as the format string attack. Other feature of the
    `println!` macro is that we can customize how we want to print values within strings:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，第二种形式将在编译时失败，因为它缺少与格式字符串匹配的参数。这是在编译时报告的。因此，它比 C 的 `printf` 函数要安全得多，后者可能导致内存漏洞，如格式字符串攻击。`println!`
    宏的另一个特性是我们可以自定义如何在字符串中打印值：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we can print the memory address and hexadecimal representation
    of the value stored in `a` via `"{:p}"` and `"{:x}"`, respectively. These are
    called **format specifiers**. We can also print non-primitive types in more of
    a JSON-like format with the `"{:#?}"` format specifier within `println!`. Let''s
    compile and run our preceding program:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以通过 `"{:p}"` 和 `"{:x}"` 分别打印出存储在 `a` 中的值的内存地址和十六进制表示。这些被称为**格式说明符**。我们还可以使用
    `println!` 中的 `"{:#?}"` 格式说明符以更类似于 JSON 的格式打印非原始类型。让我们编译并运行前面的程序：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ok, we have an error. As you may have noticed, in the first `println!` macro
    call, we are trying to print the address of `a` using the `"{:p}"` specifier,
    but the variable we mentioned is a number. We need to pass a reference such as `&a`
    to the format specifier. With that change, the preceding program compiles. All
    of this formatting and checking for proper values for string interpolation happens
    at compile time, thanks to the implementation of macros as part of the parsing
    phase.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们遇到了一个错误。正如你可能已经注意到的，在第一个 `println!` 宏调用中，我们试图使用 `"{:p}"` 说明符打印 `a` 的地址，但提到的变量是一个数字。我们需要将一个引用，如
    `&a`，传递给格式说明符。有了这个更改，前面的程序就可以编译了。所有这些格式化和检查字符串插值中适当值的工作都是在编译时完成的，这要归功于宏作为解析阶段的一部分的实现。
- en: Types of macros
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏的类型
- en: 'There are different forms of macros in Rust. Some allow you to call them like
    functions, while others allow you to conditionally include code, depending on
    compile-time conditions. Another class of macros allows you to implement traits
    on methods at compile time. They can be broadly divided into two forms:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中存在不同形式的宏。一些允许你像函数一样调用它们，而另一些则允许你根据编译时条件有条件地包含代码。另一类宏允许你在编译时在方法上实现特质。它们可以大致分为两种形式：
- en: '**Declarative macros:** These are the simplest form of macros. These are created
    using `macro_rules!`, which itself is a macro. They provide the same ergonomics
    of a calling a function, but are easily distinguished by a `!` at the end. They
    are the go-to approach for writing quick small macros within a project. The syntax
    for defining them is very similar to how you would write match expressions. They
    are called **declarative** in the sense that you already have a mini DSL, along
    with recognized token types and repetition constructs, using which you can declaratively
    express what code you want to generate. You don''t write how you generate the
    code as that is taken care of by the DSL.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式宏**：这是最简单的宏形式。它们使用 `macro_rules!` 创建，而 `macro_rules!` 本身也是一个宏。它们提供了调用函数相同的易用性，但通过末尾的
    `!` 可以轻松区分。它们是编写项目中小型宏的首选方法。定义它们的语法与编写匹配表达式的方式非常相似。它们被称为**声明式**，因为您已经拥有一个迷你领域特定语言（DSL），包括已识别的令牌类型和重复构造，您可以使用它们声明性地表达您想要生成的代码。您不需要编写如何生成代码，因为这由
    DSL 处理。'
- en: '**Procedural macros****:** Procedural macros are a more advanced form of macros
    and give complete control over the manipulation and generation of code. These
    macros don''t come with any DSL support and are procedural in the sense that you
    have to write how you want the code to be generated or transformed for a given
    token tree input. The downside is that they are complex to implement and require
    a bit of understanding of compiler internals and how a program is represented
    in memory within the compiler. While `macro_rules!` can be defined anywhere in
    your project, procedural macros as of now are required to be created as separate
    crates with the special attribute of `proc-macro = true` in `Cargo.toml`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程宏**：过程宏是宏的更高级形式，它提供了对代码操作和生成的完全控制。这些宏不附带任何DSL支持，并且是过程性的，这意味着你必须编写代码来指定对于给定的标记树输入，代码应该如何生成或转换。缺点是它们实现起来比较复杂，需要一点对编译器内部结构和程序在编译器内存中表示的理解。虽然`macro_rules!`可以在项目的任何地方定义，但到目前为止，过程宏必须作为具有`Cargo.toml`中特殊属性`proc-macro
    = true`的独立crate创建。'
- en: Creating your first macro with macro_rules!
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`macro_rules!`创建你的第一个宏
- en: 'Let''s start with declarative macros first by building one using the `macro_rules!`
    macro. Rust already has the `println!` macro, which is used to print things to
    the standard output. However, it doesn''t have an equivalent macro for reading
    input from the standard input. To read from the standard input, you have to write
    something like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从声明式宏开始，首先使用`macro_rules!`宏构建一个。Rust已经有一个`println!`宏，用于将内容打印到标准输出。然而，它没有用于从标准输入读取的等效宏。要从标准输入读取，你必须编写如下内容：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These lines of code can be easily abstracted away with a macro. We''ll name
    our macro `scanline!`. Here''s the code that shows us how we want to use this
    macro:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行可以通过宏轻松抽象出来。我们将我们的宏命名为`scanline!`。以下是展示我们如何使用此宏的代码：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We want to be able to create a `String` instance and just pass it to `scanline!`,
    which handles all the details of reading from standard input. If we compile the
    preceding code by running `rustc first_macro.rs`, we get the following error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够创建一个`String`实例，并将其直接传递给`scanline!`，该函数会处理从标准输入读取的所有细节。如果我们通过运行`rustc first_macro.rs`来编译前面的代码，我们会得到以下错误：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`rustc` cannot find the `scanline!` macro, because we haven''t defined it yet,
    so let''s do that:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustc`找不到`scanline!`宏，因为我们还没有定义它，所以让我们先定义它：'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To create the `scanline!` macro, we use the `macro_rules!` macro, followed by
    the macro name `scanline!`, followed by a pair of braces. Within the braces, we
    have things that look similar to match arms. These are called **matching rules**.
    Every matching rule consists of three parts. The first is the pattern matcher,
    that is, the `($x:expr)` part, followed by a `=>`, and then the code generation
    block, which can be delimited either with `()`, `{}`, or even `[]`. A matching
    rule has to end with a semicolon when there is more than one rule to match.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`scanline!`宏，我们使用`macro_rules!`宏，后跟宏名称`scanline!`，然后是一对花括号。在花括号内，我们有类似于匹配臂的东西。这些被称为**匹配规则**。每个匹配规则由三个部分组成。第一部分是模式匹配器，即`($x:expr)`部分，后面跟着一个`=>`，然后是代码生成块，它可以由`()`、`{}`或甚至`[]`来界定。当有多个规则要匹配时，匹配规则必须以分号结束。
- en: 'In the preceding code, the notation on the left, `($x:expr)`, within parentheses
    is the rules, where `$x` is a token tree variable that needs to have a type specified
    after the colon `:`, which is an `expr` token tree type. Their syntax is similar
    to how we specify parameters in functions. When we invoke the `scanline!` macro
    with any token sequence as input, it gets captured in `$x` and is referred to
    by the same variable within the code generation block on the right. The `expr`
    token type means that this macro can only accept things that are expressions.
    We''ll cover other kinds of token types that are accepted by `macro_rules!` in
    a moment. In the code generation block, we have multi-line code to generate, so
    we have a pair of braces, which are there to account for multi-line expressions.
    The matching rule ends with a semicolon. We can also omit braces if we have a
    single line of code that needs to be generated. The generated code we want is
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，左边的符号`($x:expr)`在括号内是规则，其中`$x`是一个标记树变量，需要在冒号`:`后面指定类型，它是一个`expr`标记树类型。它们的语法类似于我们指定函数参数的方式。当我们用任何标记序列作为输入调用`scanline!`宏时，它会被捕获在`$x`中，并在代码生成块的右侧以相同的变量引用。`expr`标记类型意味着这个宏只能接受表达式。我们稍后会介绍`macro_rules!`接受的其它类型的标记。在代码生成块中，我们有要生成的多行代码，所以我们有一个成对的括号，它们用于处理多行表达式。匹配规则以分号结束。如果我们需要生成单行代码，我们也可以省略括号。我们想要的生成代码如下：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that `read_line` accepts something that doesn''t look like a proper
    mutable reference to some identifier, that is, it''s a `&mut $x` . The `$x` gets
    substituted with an actual expression that we pass to our macro on invocation.
    That''s it; we just wrote our first macro! The complete code is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`read_line`接受的东西看起来不像一个标识符的正确可变引用，即它是一个`&mut $x`。`$x`会被替换为我们传递给宏的实际表达式。就是这样；我们刚刚编写了我们的第一个宏！完整的代码如下：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `main`, we first create our `input` string, which will store our input from
    the user. Next, our `scanline!` macro is invoked where we pass the `input` variable.
    Within this macro, this is then referred to as `$x`, as we saw in the preceding
    definition. With the invocation of `scanline`, when the compiler sees the invocation,
    it replaces that with the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们首先创建我们的`input`字符串，它将存储用户输入的内容。接下来，我们调用`scanline!`宏，并传递`input`变量。在这个宏内部，它被引用为`$x`，正如我们在前面的定义中看到的。当调用`scanline`时，当编译器看到调用时，它会用以下内容替换它：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s the output on running the preceding code with an input string of `Alice`
    from the standard input:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行前面代码并从标准输入输入字符串`Alice`的输出：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Following code generation, the compiler also checks whether the generated code
    makes any sense. For example, if we were to invoke `scanline!` with some other
    item that is not accounted for in the matching rules (say, passing an `fn` keyword,
    such as `scanline!(fn)`), we would get the following error:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码生成之后，编译器还会检查生成的代码是否有意义。例如，如果我们用不在匹配规则中考虑的其他项调用`scanline!`（比如传递一个`fn`关键字，如`scanline!(fn)`），我们会得到以下错误：
- en: '![](img/90c97a40-a22c-4879-b9f1-02275ad3edbb.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90c97a40-a22c-4879-b9f1-02275ad3edbb.png)'
- en: 'Also, even if we pass an expression (say, `2`), which is valid to pass (as
    it''s also an `expr` ) to this macro but doesn''t make sense in this context,
    Rust will catch this and report as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使我们传递一个表达式（比如，`2`），它在传递给这个宏时是有效的（因为它也是一个`expr`），但在这种上下文中没有意义，Rust 也会捕获并报告如下：
- en: '![](img/e7617a02-277a-4ed8-88d1-050170cb1e96.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7617a02-277a-4ed8-88d1-050170cb1e96.png)'
- en: 'This is neat! Now, we can also add multiple matching rules to our macro. So,
    let''s add an empty rule that covers the case where we just want `scanline!` to
    allocate the `String` for us, read from `stdin`, and return the string back. To
    add a new rule, we modify the code like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒！现在，我们也可以给我们的宏添加多个匹配规则。所以，让我们添加一个空规则，覆盖我们只想让`scanline!`为我们分配`String`的情况，从`stdin`读取，并返回字符串。要添加一个新规则，我们修改代码如下：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We added an empty match rule, `() => {}`. Within the braces, we generate a
    bunch of code where we first create a `String` instance in `s`, call `read_line`,
    and pass `&mut s`. Finally, we return `s` to the caller. Now, we can call our
    `scanline!` without a pre-allocated `String` buffer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个空匹配规则``() => {}`。在大括号内，我们生成了一堆代码，首先在`s`中创建一个`String`实例，调用`read_line`，并传递`&mut
    s`。最后，我们将`s`返回给调用者。现在，我们可以调用我们的`scanline!`而不需要一个预先分配的`String`缓冲区：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It's also important to note that we cannot invoke this macro anywhere outside
    functions. For instance, the `scanline!` invocation at the root of a module will
    fail, as it is invalid to write a `let` statement within a `mod {}` declaration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们无法在函数外部调用此宏。例如，模块根部的 `scanline!` 调用将失败，因为在 `mod {}` 声明内编写 `let` 语句是不合法的。
- en: Built-in macros in the standard library
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库中的内置宏
- en: Apart from `println!`, there are other useful macros in the standard library
    that are implemented using the `macro_rules!` macro. Knowing about them will help
    us appreciate the places and situations where using a macro is a cleaner solution,
    while not sacrificing readability.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `println!` 之外，标准库中还有其他一些有用的宏，它们是通过使用 `macro_rules!` 宏实现的。了解它们将帮助我们欣赏使用宏的地方和情况，这样既不会牺牲可读性，又是一个更干净的解决方案。
- en: 'Some of these macros are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些宏如下：
- en: '`dbg!`: This allows you to print the value of expressions with their values.
    This macro moves whatever is passed to it, so if you only want to give read access
    to their types, you need to pass a reference to this macro instead. It''s quite
    handy as a tracing macro for expressions during runtime.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbg!`：这个宏允许你打印带有其值的表达式的值。这个宏移动传递给它的任何内容，所以如果你只想提供对其类型的读取访问，你需要传递这个宏的引用。它作为一个在运行时跟踪表达式的实用宏。'
- en: '`compile_error!`: This macro can be used to report an error from code at compile
    time. This is a handy macro to use when you are building your own macro and want
    to report any syntactic or semantic errors to the user.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile_error!`：这个宏可以在编译时从代码中报告错误。当你构建自己的宏并想向用户报告任何语法或语义错误时，这是一个很有用的宏。'
- en: '`concat!`: This macro can be used to concatenate any number of literals passed
    to it and returns the concatenated literals as a `&''static str`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat!`：这个宏可以用来连接传递给它的任意数量的字面量，并返回连接后的字面量作为 `&''static str`。'
- en: '`env!`: This inspects an environment variable at compile time. In a lot of
    languages, accessing values from the environment variable is mostly done at runtime.
    In Rust, by using this macro, you can resolve environment variables at compile
    time. Note that this method panics when it cannot find the variable that''s defined,
    so a safe version of this is the `option_env!` macro.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env!`：这个宏在编译时检查环境变量。在许多语言中，从环境变量中访问值主要是运行时完成的。在 Rust 中，通过使用这个宏，你可以在编译时解析环境变量。请注意，当找不到定义的变量时，此方法会引发恐慌，因此这个宏的安全版本是
    `option_env!` 宏。'
- en: '`eprint!` and `eprintln!`: This is similar to `println!`, but outputs messages
    to the standard error stream.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eprint!` 和 `eprintln!`：这与 `println!` 类似，但将消息输出到标准错误流。'
- en: '`include_bytes!`: This macro can be used as a quick way to read files as an
    array of bytes, such as `&''static [u8; N]`. The file path given to it is resolved
    relative to the current file in which this macro is invoked.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include_bytes!`：这个宏可以用作快速读取文件为字节数组的快捷方式，例如`&''static [u8; N]`。传递给它的文件路径是相对于调用此宏的当前文件解析的。'
- en: '`stringify!`: This macro is useful if you want to get a literal translation
    of a type or a token as a string. We''ll use this when we write our own procedural
    macro.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringify!`：如果你想要获取类型或令牌的文本表示作为字符串，这个宏很有用。当我们编写自己的过程宏时，我们会使用这个宏。'
- en: If you want to explore the full set of macros that are available in the standard
    library, they can be found at [https://doc.rust-lang.org/std/#macros](https://doc.rust-lang.org/std/#macros).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索标准库中可用的完整宏集，可以在[https://doc.rust-lang.org/std/#macros](https://doc.rust-lang.org/std/#macros)找到。
- en: macro_rules! token types
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`macro_rules!` 令牌类型'
- en: Before we build more complex macros, it's important to become familiar with
    the valid inputs that `macro_rules!` can take. Since `macro_rules!` work at the
    syntactic level, it needs to provide users, a handle to these syntactic elements,
    and distinguish what can and cannot be included within a macro and how we can
    interact with them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建更复杂的宏之前，熟悉 `macro_rules!` 可以接受的合法输入非常重要。由于 `macro_rules!` 在语法层面工作，它需要为用户提供对这些语法元素的访问，并区分可以在宏中包含的内容以及我们如何与之交互。
- en: 'The following are some important token tree types that you can pass into a
    macro as input:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的令牌树类型，您可以将它们作为输入传递给宏：
- en: '`block`: This is a sequence of statements. We have already used `block` in
    the debugging example. It matches any sequence of statements, delimited by braces,
    such as what we were using before:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block`：这是一个语句序列。我们已经在调试示例中使用了 `block`。它匹配任何由花括号分隔的语句序列，就像我们之前使用的那样：'
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This block includes the statements `silly` and `things`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块包含了 `silly` 和 `things` 两个语句。
- en: '`expr`**:** This matches any expression, for example:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr`**:** 这匹配任何表达式，例如：'
- en: '`1`'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`x + 1`'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x + 1`'
- en: '`if x == 4 { 1 } else { 2 }`'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if x == 4 { 1 } else { 2 }`'
- en: '`ident`: This matches an identifier. Identifiers are any unicode strings that
    are not keywords (such as `if` or `let`). As an exception, the underscore character
    alone is not an identifier in Rust. Examples of identifiers are as follows:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ident`: 这匹配一个标识符。标识符是任何非关键字（如 `if` 或 `let`）的 Unicode 字符串。作为例外，Rust 中单独的下划线字符不是标识符。以下是一些标识符的示例：'
- en: '`x`'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`'
- en: '`long_identifier`'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long_identifier`'
- en: '`SomeSortOfAStructType`'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SomeSortOfAStructType`'
- en: '`item`: This matches an item. Module-level things are idenitified as items**.**
    These include functions, use declarations, type definitions, and so on. Here are
    some examples:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`: 这匹配一个项目。模块级别的对象被识别为项目**。** 这包括函数、使用声明、类型定义等。以下是一些示例：'
- en: '`use std::io;`'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use std::io;`'
- en: '`fn main() { println!("hello") }`'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn main() { println!("hello") }`'
- en: '`const X: usize = 8;`'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const X: usize = 8;`'
- en: These do not have to be one-liners, of course. The `main` function could be
    a single item, even if it spanned several lines.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些不必是一行代码。`main` 函数可以是一个单独的项目，即使它跨越了多行。
- en: '`meta`**:** A `meta` item. The parameters inside attributes are called meta
    items, which are captured by `meta`. The attributes themselves look as follows:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`**:** 一个 `meta` 项。属性内部的参数称为元项，由 `meta` 捕获。属性本身看起来如下：'
- en: '`#![foo]`'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#![foo]`'
- en: '`#[baz]`'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#[baz]`'
- en: '`#[foo(bar)]`'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#[foo(bar)]`'
- en: '`#[foo(bar="baz")]`'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#[foo(bar="baz")]`'
- en: 'Meta items are the things that are found inside brackets. So, for each of the
    preceding attributes, the corresponding meta items are as follows:'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元项是括号内的东西。因此，对于前面的每个属性，相应的元项如下：
- en: '`foo`'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo`'
- en: '`baz`'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baz`'
- en: '`foo(baz)`'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo(baz)`'
- en: '`foo(bar="baz")`'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo(bar="baz")`'
- en: '`pat`**:** This is a pattern. Match expressions have patterns on the left-hand
    side of each match, which `pat` captures. Here are some examples:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pat`**:** 这是一个模式。匹配表达式在每行的左侧都有模式，由 `pat` 捕获。以下是一些示例：'
- en: '`1`'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`"x"`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"x"`'
- en: '`t`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`'
- en: '`*t`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*t`'
- en: '`Some(t)`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Some(t)`'
- en: '`1 | 2 | 3`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1 | 2 | 3`'
- en: '`1 ... 3`'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1 ... 3`'
- en: '`_`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_`'
- en: '`path`**:** It matches a qualified name**.** Paths are qualified names, that
    is, names with a namespace attached to them. They''re quite similar to identifiers,
    except that they allow the double colon in their names because they signify paths.
    Here are some examples:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`**:** 它匹配一个有资格的名称**。** 路径是有资格的名称，即带有命名空间附加的名称。它们与标识符非常相似，除了它们允许在名称中使用双冒号，因为它们表示路径。以下是一些示例：'
- en: '`foo`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo`'
- en: '`foo::bar`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo::bar`'
- en: '`Foo`'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Foo`'
- en: '`Foo::Bar::baz`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Foo::Bar::baz`'
- en: This is useful in cases where you need to capture the path of some type so that
    you can use it later in code generation, such as when aliasing complex types with
    paths.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这在需要捕获某些类型的路径以便稍后在代码生成中使用时很有用，例如在用路径别名复杂类型时。
- en: '`stmt`**:** This is a statement. Statements are like expressions, except that
    more patterns are accepted by `stmt`. The following are some examples of this:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stmt`**:** 这是一个语句。语句类似于表达式，但 `stmt` 可以接受更多模式。以下是一些示例：'
- en: '`let x = 1`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let x = 1`'
- en: '`1`'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`foo`'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo`'
- en: '`1+2`'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1+2`'
- en: In contrast to the first example, `let x = 1` wouldn't be accepted by `expr.`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个示例相比，`let x = 1` 不会被 `expr` 接受。
- en: '`tt`**:** This is a token tree, which is a sequence of other tokens. The `tt`
    keyword captures a single token tree. A token tree is either a single token (such
    as `1`, `+`, or `"foo bar"`) or several tokens surrounded by any of the braces,
    `()`, `[]`, or `{}`. The following are some examples:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tt`**:** 这是一个令牌树，它是一系列其他令牌。`tt` 关键字捕获单个令牌树。令牌树要么是一个单独的令牌（如 `1`、`+` 或 `"foo
    bar"`），要么是任何花括号 `()`, `[]`, 或 `{}` 包围的几个令牌。以下是一些示例：'
- en: '`foo`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo`'
- en: '`{ bar; if x == 2 { 3 } else { 4 }; baz }`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ bar; if x == 2 { 3 } else { 4 }; baz }`'
- en: '`{ bar; fi x == 2 ( 3 ] ulse ) 4 {; baz }`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ bar; fi x == 2 ( 3 ] ulse ) 4 {; baz }`'
- en: As you can see, the insides of the token tree do not have to make semantic sense;
    they just have to be a sequence of tokens. Specifically, what does not match this
    are two or more tokens not enclosed in braces (such as `1 + 2`). This is the most
    general sequence of code or tokens `macro_rules!` can capture.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，令牌树内部的元素不必具有语义意义；它们只需是令牌的序列。具体来说，不匹配的是两个或更多未括在花括号内的令牌（如 `1 + 2`）。这是 `macro_rules!`
    可以捕获的最一般代码或令牌序列。
- en: '`ty`: This is a Rust type. The `ty` keyword captures things that look like
    types. Here are some examples:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ty`: 这是一个 Rust 类型。`ty` 关键字捕获看起来像类型的对象。以下是一些示例：'
- en: '`u32`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u32`'
- en: '`u33`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u33`'
- en: '`String`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: 'No semantic checking that the type is actually a type is done in the macro
    expansion phase, so `"u33"` is accepted just as well as `"u32"`. However, once
    the code gets generated and goes to the semantic analysis phase, the type is checked,
    giving an error message of `` error: expected type, found `u33` ``. This is used
    when you are generating code to create a function or implementing methods of a
    trait on a type.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '在宏展开阶段，不会进行任何语义检查以确定类型实际上是一个类型，所以 `"u33"` 和 `"u32"` 都会被接受。然而，一旦代码生成并进入语义分析阶段，类型就会被检查，并给出错误信息“`error:
    expected type, found `u33``”。这用于当你生成创建函数或实现类型上特质的方法的代码时。'
- en: '`vis`: This represents a visibility modifier. This captures visibility modifiers `pub`,
    `pub(crate)`, and so on. This is helpful when you are generating module-level
    code and need to capture privacy modifiers in code fragments that have been passed
    to the macro.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vis`：这代表一个可见性修饰符。它捕获可见性修饰符 `pub`、`pub(crate)` 等。当你生成模块级别的代码并需要在传递给宏的代码片段中捕获隐私修饰符时，这很有用。'
- en: '`lifetime`: Identifies a lifetime such as `''a`, `''ctx`, `''foo`, and so on.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lifetime`：标识一个生命周期，如 `''a`、`''ctx`、`''foo` 等。'
- en: '`literal`: A literal that can be any token, like a string literal such as `"foo"`
    or an identifier such as `bar`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`literal`：可以是任何标记，例如字符串字面量如 `"foo"` 或标识符如 `bar`。'
- en: Repetitions in macros
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏中的重复
- en: 'Apart from token tree types, we also need a way to repeatedly generate certain
    parts of our code. One of the practical examples from the standard library is
    the `vec![]` macro, which relies on repetition to give an illusion of variadic
    arguments, and allows you to create Vecs in any of the following manners:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标记树类型之外，我们还需要一种方法来重复生成代码的某些部分。标准库中的一个实际例子是 `vec![]` 宏，它依赖于重复来产生变长参数的错觉，并允许你以以下任何一种方式创建
    Vec：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s see how `vec!` does this. Here''s vec''s `macro_rules!` definition from
    the standard library:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `vec!` 是如何做到这一点的。以下是标准库中 vec 的 `macro_rules!` 定义：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By ignoring the details to the right of `=>` and focusing on the last two matching
    rules on the left-hand side, we can see something new in these rules:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过忽略 `=>` 右侧的细节，并关注左侧最后两个匹配规则，我们可以在这条规则中看到一些新的内容：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These are repeating rules. The repeating pattern rule follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是重复规则。重复模式规则如下：
- en: '**pattern**: `$($var:type)*`. Notice the `$()*`. For the sake of referring
    to them, we''ll call them **repeaters**. Also, let''s denote the inner `($x:expr)`
    as `X`. Repeaters come in three forms:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pattern**：`$($var:type)*`。注意 `$()*`。为了便于引用，我们将它们称为**重复器**。此外，让我们将内部的 `($x:expr)`
    表示为 `X`。重复器有三种形式：'
- en: '`*`, meaning the repetition needs to happen zero or more times'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`，表示重复需要发生零次或多次'
- en: '`+`, meaning the repetition needs to happen at least one or more times'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`，表示重复至少需要发生一次或更多次'
- en: '`?`, meaning the token can repeat once at most'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`，表示标记最多重复一次'
- en: Repeaters can also include extra literal characters that can be part of the
    repetition. In the case of `vec!`, there is the comma character, which we need
    to support to distinguish each element in `Vec` in the macro invocation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重复器也可以包括额外的字面字符，这些字符可以是重复的一部分。在 `vec!` 的情况下，有逗号字符，我们需要支持它以在宏调用中区分 `Vec` 中的每个元素。
- en: In the first matching rule, the comma character is after `X`. This allows for
    expressions such as `vec![1, 2, 3,]`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个匹配规则中，逗号字符位于 `X` 之后。这允许使用如 `vec![1, 2, 3,]` 这样的表达式。
- en: The second matching rule has the comma inside `X` after the elements. This is
    a typical case and will match sequences such as `1, 2, 3`. We needed two rules
    here because the first rule cannot account for cases such as where we don't have
    the trailing comma, which is the common case. Also, the patterns in `vec!` use
    `*`, which implies that `vec![]` is also an allowed invocation of the macro. With
    `+`, it wouldn't be.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个匹配规则中，逗号位于元素之后的 `X` 内。这是一个典型的情况，可以匹配如 `1, 2, 3` 这样的序列。我们在这里需要两个规则，因为第一个规则无法处理没有尾随逗号的情况，而这通常是常见的情况。此外，`vec!`
    中的模式使用 `*`，这意味着 `vec![]` 也是宏的一个允许的调用。如果使用 `+`，则不会。
- en: 'Now, let''s look at how the captured repetition rule is forwarded on the right-hand
    side in the code generation block. In the second matching rule, the `vec!` macro
    just forwards them into a `Box` type using an identical syntax:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看捕获的重复规则如何在代码生成块中的右侧传递。在第二个匹配规则中，`vec!` 宏只是使用相同的语法将它们转发到一个 `Box` 类型：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only difference we can see between the token tree variable declaration on
    the left-hand side and the usage on the right-hand side is that the right-hand
    side does not include the type (`expr`) of the token variable. The third matching
    rule just piggybacks on the second rule's code generation block and calls `vec![$($x),*]`,
    thus changing the comma placement and calling it again. This means that we can
    also call a macro within a macro, which is a really powerful feature. All of this
    can get pretty meta-level and you should aim for simpler maintainable macros as
    much as possible.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在左侧的标记树变量声明和右侧的使用之间看到的唯一区别是，右侧不包括标记变量的类型（`expr`）。第三个匹配规则只是依赖于第二个规则的代码生成块，并调用`vec![$($x),*]`，从而改变逗号的位置并再次调用它。这意味着我们也可以在宏内部调用宏，这是一个非常强大的功能。所有这些都可以达到相当元级别的程度，你应该尽可能追求更简单、可维护的宏。
- en: Now, let's take a look at how to build a macro that uses repetitions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何构建一个使用重复的宏。
- en: A more involved macro – writing a DSL for HashMap initialization
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更复杂的宏——编写HashMap初始化的领域特定语言（DSL）
- en: 'Armed with the knowledge of repetitions and token tree types, let''s build
    something practical using repetitions in `macro_rules!`. In this section, we''ll
    build a crate that exposes a macro that allows you to create HashMaps such as
    the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 带着重复和标记树类型的知识，让我们使用`macro_rules!`中的重复来构建一些实用的东西。在本节中，我们将构建一个crate，它公开一个宏，允许你创建如下所示的`HashMap`：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is more concise and readable compared to manually calling `HashMap::new()`,
    followed by one or more `insert` calls. Let''s  create a new `cargo` project by
    running `cargo new macro_map --lib` with the initial block for `macro_rules!`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动调用`HashMap::new()`后跟一个或多个`insert`调用相比，这更加简洁和易读。让我们通过运行`cargo new macro_map
    --lib`并使用`macro_rules!`的初始块来创建一个新的`cargo`项目：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since we want the users to use our macros, we need to add a `#[macro_export]`
    attribute on this macro definition. Macros are private by default in a module,
    which is similar to other items. We''ll call our macro `map!` and since we are
    building our own syntax to initialize HashMap, we''ll go with the `k => v` syntax,
    where `k` is the key and `v` is the value in our HashMap. Here''s our implementation
    within `map! {}`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望用户使用我们的宏，我们需要在这个宏定义上添加`#[macro_export]`属性。默认情况下，宏在模块中是私有的，这与其他项目类似。我们将我们的宏命名为`map!`，因为我们正在构建自己的语法来初始化`HashMap`，我们将采用`k
    => v`语法，其中`k`是HashMap中的键，`v`是值。以下是我们在`map! {}`中的实现：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's understand the matching rule here. First, we'll examine the inner part,
    which is `( $k:expr => $v:expr )`. Let's denote this part of the rule as `Y`.
    So, `Y` captures our key `k` and value `v` literals as `expr` with a `=>` in between
    them. Surrounding `Y`, we have `($(Y),*)`, which denotes the repetition of `Y`
    zero or more times, delimited by a comma. On the right of the matching rule within
    braces, we first create a `HashMap` instance. Then, we write the repeaters `$()*`,
    which have our `map.insert($k, $v)` code fragment within them, which will be repeated
    the same number of times as in our macro input.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来理解这里的匹配规则。首先，我们将检查内部部分，它是`( $k:expr => $v:expr )`。让我们将这个规则部分称为`Y`。所以，`Y`捕获我们的键`k`和值`v`字面量，它们之间用`=>`连接，并以`expr`表示。围绕`Y`的部分是`($(Y),*)`，表示`Y`可以重复零次或多次，由逗号分隔。在大括号内的匹配规则右侧，我们首先创建一个`HashMap`实例。然后，我们编写重复器`$()*`，其中包含我们的`map.insert($k,
    $v)`代码片段，它将重复与我们的宏输入相同的次数。
- en: 'Let''s quickly write a test for that:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速为它编写一个测试：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By running a cargo test, we get the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`cargo test`，我们得到以下输出：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Nice! Our test passes and we can now initialize HashMaps in a convenient way
    using our shiny new `map!` macro!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的测试通过了，现在我们可以使用我们闪亮的新`map!`宏方便地初始化`HashMap`了！
- en: Macro use case – writing tests
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏用例——编写测试
- en: 'Macros are used quite a lot when writing test cases for unit tests. Let''s
    say you were writing a HTTP client library and you would like to test your client
    on various HTTP verbs such as `GET` or `POST` and on a variety of different URLs. The
    usual way you would write your tests is to create functions for each type of request
    and the URL. However, there''s a better way to do this. Using macros, you can
    cut down your testing time by many folds by building a small DSL to perform the
    tests, which is readable and can also be type checked at compiled time. To demonstrate
    this, let''s create a new crate by running `cargo new http_tester --lib`, which
    contains our macro definition. This macro implements a small language that''s
    designed for describing simple HTTP `GET`/`POST` tests to a URL. Here''s a sample
    of what the language looks like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写单元测试用例时，宏的使用相当频繁。假设你正在编写一个 HTTP 客户端库，并且想要测试你的客户端在多种 HTTP 动词（如 `GET` 或 `POST`）以及各种不同的
    URL 上的表现。通常，你会为每种请求类型和 URL 创建函数。然而，有一种更好的方法来做这件事。使用宏，你可以通过构建一个用于执行测试的小型 DSL（领域特定语言）来减少测试时间，这个
    DSL 便于阅读，并且在编译时也可以进行类型检查。为了演示这一点，让我们通过运行 `cargo new http_tester --lib` 创建一个新的
    crate，其中包含我们的宏定义。这个宏实现了一种小型语言，用于描述简单的 HTTP `GET`/`POST` 测试到 URL。以下是这种语言的一个示例：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first line makes a `GET` request to `duckduckgo.com`, and expects a return
    code of `200` (`Status Ok`). The second one makes a `POST` request to `httpbin.org`,
    along with form parameters `"key"="value"` with a custom syntax. It also expects
    a return code of `200`. This is very simplistic but sufficient for demonstration
    purposes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行向 `duckduckgo.com` 发送 `GET` 请求，并期望返回代码为 `200`（状态正常）。第二行向 `httpbin.org` 发送
    `POST` 请求，并带有 `"key"="value"` 的表单参数，使用自定义语法。它也期望返回代码为 `200`。这非常简单，但对于演示目的来说是足够的。
- en: 'We''ll assume that we already have our library implemented and will use a HTTP
    request library called `reqwest`. We''ll add a dependency on `reqwest` in our
    `Cargo.toml` file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们的库已经实现，并将使用一个名为 `reqwest` 的 HTTP 请求库。我们将在 `Cargo.toml` 文件中添加对 `reqwest`
    的依赖：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here''s `lib.rs`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '这里是 `lib.rs`:'
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Within the macro definition, we just match on the rules, which is where `GET`
    and `POST` are treated as literal tokens. Within the arms, we create our request
    client and assert on the status code that's returned by the input, which is provided
    to the macro. The POST test case also has a custom syntax for providing query
    parameters such as `key => value`, which is collected as an array in the `params`
    variable. This is then passed to the `form` method of the `reqwest::post` builder
    method. We'll explore the request library more when we get to [Chapter 13](ea972b20-1dc0-46d2-a0b8-d4186b0fe2c7.xhtml),
    *Building Web Applications in Rust*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏定义中，我们只是匹配规则，这是 `GET` 和 `POST` 被视为字面标记的地方。在分支中，我们创建我们的请求客户端，并断言由宏接收到的输入返回的状态码。POST
    测试用例还有一个用于提供查询参数的自定义语法，如 `key => value`，这些参数被收集到 `params` 变量中。然后，这些参数被传递到 `reqwest::post`
    构建方法的 `form` 方法中。当我们到达第 13 章 [构建 Web 应用程序](ea972b20-1dc0-46d2-a0b8-d4186b0fe2c7.xhtml)时，我们将更深入地探讨请求库。
- en: 'Let''s run `cargo test` and see the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `cargo test` 看看输出结果：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Take a moment to think about what the benefit of using a macro here is. This
    could be implemented as a `#[test]` annotated function call as well, but the macro
    has a few benefits, even in this basic form. One benefit is that the HTTP verb
    is checked at compile time and our tests are now more declarative. If we try to
    invoke the macro with a test case that is not accounted for (say, HTTP `DELETE`),
    we''ll get the following error:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 抽时间思考一下在这里使用宏的好处。这也可以作为一个带有 `#[test]` 注解的函数调用的实现，但即使在这个基本形式中，宏也有几个好处。一个好处是 HTTP
    动词在编译时进行检查，我们的测试现在更加声明式。如果我们尝试使用未考虑到的测试用例（比如 HTTP `DELETE`）调用宏，我们会得到以下错误：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Apart from using them for enumerating tests cases, macros are also used to generate
    Rust code based on some outside environmental state (such as database tables,
    time and date, and so on). They can be used to decorate structures with custom
    attributes, generating arbitrary code for them at compile time, or to create new
    linter plugins for making additional static analysis that the Rust compiler itself
    does not support. A great example is the clippy lint tool, which we've used already.
    Macros are also used to generate code that invokes native C libraries. We'll see
    how that happens when we get to [Chapter 10](9e9ce701-5f35-4351-b76b-a5f2bd541059.xhtml),
    *Unsafe Rust and Foreign Function Interfaces*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于枚举测试用例之外，宏还可以用于根据某些外部环境状态（如数据库表、日期和时间等）生成Rust代码。它们可以用来装饰结构体，在编译时为它们生成任意代码，或者创建新的linter插件以进行额外的静态分析，这些分析是Rust编译器本身不支持的。一个很好的例子是clippy
    lint工具，我们之前已经使用过。宏还可以用来生成调用本地C库的代码。我们将在第10章中看到它是如何发生的，*不安全Rust和外部函数接口*。
- en: Exercises
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'If you are already finding macros empowering, here are some exercises for you
    to try so that you can tinker with macros some more:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经觉得宏很有用，这里有一些练习供你尝试，以便你可以进一步探索宏：
- en: 'Write a macro that accepts the following language:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个宏，它接受以下语言：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For instance, the following strings would be acceptable in this language:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下字符串将在这个语言中是可接受的：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Make the macro generate code that outputs a greeting that's directed to the
    recipient.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让宏生成一个针对收件人的问候语。
- en: Write a macro that takes an arbitrary number of elements and outputs an unordered
    HTML list in a literal string, for instance, `html_list!([1, 2]) => <ul><li>1/<li><li>2</li></ul>`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个宏，它接受任意数量的元素，并以字面字符串的形式输出一个无序列表，例如，`html_list!([1, 2]) => <ul><li>1/<li><li>2</li></ul>`.
- en: Procedural macros
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过程宏
- en: Declarative macros can become tedious to read and maintain when your code generation
    logic becomes complex, as you need to write your logic with its own DSL to manipulate
    tokens. There are better, more flexible ways than using `macro_rules!`. For complex
    problems, you can leverage procedural macros as they are better suited to writing
    something non-trivial. They are suitable for cases where you need full control
    of code generation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码生成逻辑变得复杂时，声明性宏可能会变得难以阅读和维护，因为你需要用自己定义的DSL来操作标记。与使用 `macro_rules!` 相比，有更好、更灵活的方法。对于复杂问题，你可以利用过程宏，因为它们更适合编写非平凡的东西。它们适用于需要完全控制代码生成的场景。
- en: 'These macros are implemented as functions. These functions receive the macro
    input as a `TokenStream` type and return the generated code as a `TokenStream`
    after undergoing any transformation at compile time. To mark a function as a procedural
    macro, we need to annotate it with the `#[proc_macro]` attribute. At the time
    of writing this book, procedural macros come in three forms, which are categorized
    by how they are invoked:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏作为函数实现。这些函数接收宏输入作为 `TokenStream` 类型，并在编译时经过任何转换后返回生成的代码作为 `TokenStream`。为了将一个函数标记为过程宏，我们需要用
    `#[proc_macro]` 属性来注释它。在撰写本书时，过程宏有三种形式，它们根据如何调用进行分类：
- en: '**Function-like procedural macros:** These use `#[proc_macro]` attribute on
    functions. The `lazy_static!` macro from the `lazy_static` crate uses function-like
    macros.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式进程宏:** 这些使用函数上的 `#[proc_macro]` 属性。`lazy_static` 库中的 `lazy_static` 宏使用函数式宏。'
- en: '**Attribute-like procedural macros:** These use `#[proc_macro_attribute]` attribute
    on functions. The `#[wasm-bindgen]` attribute in the `wasm-bindgen` crate uses
    this form of macro.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类似属性的进程宏:** 这些使用函数上的 `#[proc_macro_attribute]` 属性。`wasm-bindgen` 库中的 `#[wasm-bindgen]`
    属性使用这种形式的宏。'
- en: '**Derive procedural macros:** These use `#[proc_macro_derive]`. These are the
    most frequently implemented macros in the majority of Rust crates, such as `serde`.
    They are also known as **derive macros** or **macros 1.1** due to the name of
    the RFC that introduced them.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推导过程宏:** 这些使用 `#[proc_macro_derive]`。在大多数Rust库中，如 `serde`，这些宏是最频繁实现的宏。由于引入它们的RFC名称，它们也被称为
    **推导宏** 或 **宏1.1**。'
- en: At the time of writing this book, the procedural macro API is very limited on
    what can be done with a `TokenStream`, so we need to use third-party crates such
    as `syn` and `quote` to parse the input as a Rust code data structure, which can
    then be analyzed according to your needs for code generation. Also, procedural
    macros need to be created as a separate crate with the special crate attribute
    of `proc-macro = true`, which is specified in `Cargo.toml`. To use the macro,
    we can depend on the macro in the same way as other crates by specifying it under
    dependencies in `Cargo.toml` and importing the macro with `use` statements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，过程宏 API 在使用 `TokenStream` 上非常有限，所以我们需要使用第三方 crate，如 `syn` 和 `quote`，将输入解析为
    Rust 代码数据结构，然后根据你的需要进行分析，以生成代码。此外，过程宏需要作为一个单独的 crate 创建，并带有特殊的 crate 属性 `proc-macro
    = true`，这在 `Cargo.toml` 中指定。要使用宏，我们可以像其他 crate 一样在 `Cargo.toml` 的依赖项中指定它，并通过 `use`
    语句导入宏。
- en: Among all three forms, derive macros are the most widely used form of procedural
    macros. We'll take a deep dive into them next.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三种形式中，derive 宏是过程宏最广泛使用的形式。我们将在下一节深入探讨它们。
- en: Derive macros
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Derive 宏
- en: 'We already saw that we can write `#[derive(Copy, Debug)]` on any struct, enum,
    or union type to get the `Copy` and `Debug` traits implemented for it, but this
    auto-derive feature is limited only to a few built-in traits in the compiler.
    With derive macros or macros 1.1, you get the ability to derive your own custom
    trait on any struct or enum or union type, thereby reducing the amount of boilerplate
    code that you would have written by hand. This may seem like a niche use case,
    but it is the most used procedural macro form, which high performance crates such
    as `serde` and `diesel` use. The derive macros only apply to data types such as
    structs, enums, or unions. Creating a custom derive macro for implementing a trait
    on a type requires the following steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以在任何结构体、枚举或联合类型上写 `#[derive(Copy, Debug)]` 来为它实现 `Copy` 和 `Debug`
    特性，但这种自动推导功能仅限于编译器中的一些内置特性。使用 derive 宏或宏 1.1，你可以在任何结构体、枚举或联合类型上推导出你自己的自定义特性，从而减少了你需要手动编写的样板代码量。这看起来可能像是一个利基用例，但它是最常用的过程宏形式，高性能的
    crate，如 `serde` 和 `diesel` 都使用它。derive 宏仅适用于如结构体、枚举或联合这样的数据类型。为在类型上实现特性创建自定义 derive
    宏需要以下步骤：
- en: First, you need your type and the trait that you want to implement on the type.
    These can come from any crate, either locally defined or from a third party, provided
    that one of them has to be defined by you, because of the orphan rule.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要你的类型以及你想要在类型上实现的特性。这些可以来自任何 crate，无论是本地定义的还是第三方定义的，只要其中之一必须由你定义，因为孤儿规则。
- en: Next, we need to create a new crate with the `proc-macro` attribute set to `true`
    in `Cargo.toml`. This marks the crate as a procedural macro crate. This is done
    because procedural macros need to live in their own crate, as per the current
    implementation. This separation as a crate might change in the future, though.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新的 crate，并在 `Cargo.toml` 中将 `proc-macro` 属性设置为 `true`。这标志着这个 crate
    是一个过程宏 crate。这样做是因为过程宏需要生活在它们自己的 crate 中，按照当前实现。这种作为 crate 的分离可能在将来会改变。
- en: Then, within this crate, we need to create a function that's annotated with
    the `proc_macro_derive` attribute. To the `proc_macro_derive` attribute, we pass
    in the trait name `Foo` as an argument. This function is what will get called
    when we write `#[derive(Foo)]` on any `struct`, `enum`, or `union`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在这个 crate 中，我们需要创建一个带有 `proc_macro_derive` 属性的函数。我们将 `Foo` 特性名称作为参数传递给 `proc_macro_derive`
    属性。这个函数是我们写 `#[derive(Foo)]` 在任何 `struct`、`enum` 或 `union` 上时会被调用的函数。
- en: Only functions that have the `proc_macro_derive` attribute are allowed to be
    exported from this crate.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 只有带有 `proc_macro_derive` 属性的函数才能从这个 crate 中导出。
- en: However, all of this is a bit vague until we see it in real code. So, let's
    build our own derive macro crate. The macro that we are going to build will be
    able to convert any given struct to a dynamic map of key values, such as `BTreeMap<String,
    String>`. The choice of `BtreeMaps` is just to have a sorted iteration on the
    fields, which is not the case with `HashMap`, though you can use hashmaps too.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，直到我们在实际代码中看到这一切，所有这些才显得有些模糊。因此，让我们构建自己的 derive 宏 crate。我们将要构建的宏能够将任何给定的结构体转换为动态的键值映射，例如
    `BTreeMap<String, String>`。选择 `BTreeMap` 是为了在字段上有一个排序的迭代，这与 `HashMap` 不同，尽管你也可以使用哈希表。
- en: 'We''ll also make use of two crates, `syn` and `quote`, which will allow us
    to parse our code into a convenient data structure that we can examine and manipulate.
    We''ll build three crates for this project. First, we''ll create a binary crate
    by running `cargo new into_map_demo`, which uses our library crate and the derive
    macro crate. The following are the dependencies in our `Cargo.toml` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用两个包，`syn` 和 `quote`，这将允许我们将代码解析为方便的数据结构，我们可以检查和操作它。我们将为这个项目构建三个包。首先，我们将通过运行
    `cargo new into_map_demo` 创建一个二进制包，它使用我们的库包和派生宏包。以下是我们 `Cargo.toml` 文件中的依赖项：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding `into_map` and `into_map_derive` crates are specified as local
    to this crate as path dependencies. However, we don''t have them yet, so let''s
    create them in the same directory by running the following commands:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `into_map` 和 `into_map_derive` 包被指定为本地包，作为路径依赖项。然而，我们还没有它们，所以让我们在同一个目录下通过运行以下命令来创建它们：
- en: '`cargo new into_map`: This crate will contain our trait as a separate library'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo new into_map`：这个包将包含我们的特性作为单独的库'
- en: '`cargo new into_map_derive`: This is our derive macro crate'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo new into_map_derive`：这是我们派生宏包'
- en: 'Now, let''s examine our `main.rs`, which contains the following initial code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们的 `main.rs` 文件，它包含以下初始代码：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, we have our `User` struct annotated with `#[derive(IntoMap)]`. `#[derive(IntoMap)]`
    will invoke our procedural macro from the `into_map_derive` crate. This does not
    compile as we don''t have the `IntoMap` derive macro implemented yet. However,
    this shows us how we want to use the macro as a consumer of this crate. Next,
    let''s see what we have in our `into_map` crate''s `lib.rs` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `#[derive(IntoMap)]` 注释了 `User` 结构体。`#[derive(IntoMap)]` 将调用来自
    `into_map_derive` 包的过程宏。由于我们还没有实现 `IntoMap` 派生宏，所以这不会编译。然而，这显示了作为此包的消费者我们希望如何使用宏。接下来，让我们看看
    `into_map` 包的 `lib.rs` 文件中有什么：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our `lib.rs` file simply contains an `IntoMap` trait definition with a single
    method named `into_map` that takes a reference to `self` and returns a `BTreeMap<String,
    String>`. We want to derive the `IntoMap` trait for our `User` struct through
    our derive macro.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `lib.rs` 文件仅包含一个 `IntoMap` 特性定义，该定义有一个名为 `into_map` 的方法，它接受对 `self` 的引用并返回一个
    `BTreeMap<String, String>`。我们希望通过我们的派生宏为我们的 `User` 结构体派生 `IntoMap` 特性。
- en: 'Let''s examine our `into_map_derive` crate next. In this crate, we have the
    following dependencies in `Cargo.toml`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来检查我们的 `into_map_derive` 包。在这个包中，我们在 `Cargo.toml` 中有以下依赖项：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we mentioned previously, we annotate the `[lib]` section with the `proc-macro`
    attribute set to `true`. We also use `syn` and `quote` as they help us parse Rust
    code from the `TokenStream` instance. The `syn` crate creates an in-memory data
    structure called the AST, which represents a piece of Rust code. We can then use
    this structure to examine our source code and extract information programmatically.
    The `quote` crate is a complement to the `syn` crate in the sense that it allows
    you to generate Rust code within the provided `quote!` macro, and also allows
    you to substitute values from `syn` data types. We also depend on the `into_map`
    crate, from where we bring the `IntoMap` trait into scope within our macro definition.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们使用 `proc-macro` 属性将 `[lib]` 部分注释为 `true`。我们还使用了 `syn` 和 `quote`，因为它们帮助我们从
    `TokenStream` 实例解析 Rust 代码。`syn` 包创建了一个内存中的数据结构，称为 AST，它表示一段 Rust 代码。然后我们可以使用这个结构来检查我们的源代码并程序化地提取信息。`quote`
    包是 `syn` 包的补充，因为它允许你在提供的 `quote!` 宏内生成 Rust 代码，并允许你从 `syn` 数据类型中替换值。我们还依赖于 `into_map`
    包，我们从其中将 `IntoMap` 特性引入到我们的宏定义的作用域内。
- en: 'The code we want this macro to generate will look something like the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个宏生成的代码看起来可能如下所示：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We want to implement the `into_map` method on our `User` struct, but we want
    it to be generated automatically for us. This is something that is quite tedious
    to hand code for cases where we have a struct with lots of fields. Derive macros
    are tremendously helpful in such cases. Let's look at an implementation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在 `User` 结构体上实现 `into_map` 方法，但我们希望它是自动为我们生成的。对于具有许多字段的结构体，手动编码这种情况相当繁琐。在这种情况下，派生宏非常有帮助。让我们看看一个实现示例。
- en: 'At a high level, the code generation in the `into_map_derive` crate is divided
    into two phases. In the first phase, we iterate over the fields of the struct
    and collect code for inserting items into the `BTreeMap`. The generated `insert`
    code tokens will look something like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，`into_map_derive`包中的代码生成分为两个阶段。在第一阶段，我们遍历结构体的字段，收集将项插入`BTreeMap`的代码。生成的`insert`代码标记将看起来像这样：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will be collected into a vector. In the second phase, we take all of the
    generated `insert` code tokens and expand them into another token sequence, which
    is the `impl` block for the `User` struct.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被收集到一个向量中。在第二阶段，我们取所有生成的`insert`代码标记，并将它们扩展成另一个标记序列，这是`User`结构体的`impl`块。
- en: 'Let''s start by exploring the implementation in `lib.rs`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`lib.rs`中的实现开始探索：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Whew, that's a lot of strange looking code! Let's go through this line by line.
    First, we have our `into_map_derive` function annotated with the `#[proc_macro_derive(IntoMap)]`
    attribute. We can give any name this function, though. This function receives
    a `TokenStream` as input, which will be our `User` struct declaration. We then
    create an `insert_tokens` list to store our input tokens, which is part of the
    actual code generation. We'll explain that in a moment.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这有很多看起来很奇怪的代码！让我们逐行分析。首先，我们的`into_map_derive`函数被`#[proc_macro_derive(IntoMap)]`属性注释。我们可以给这个函数任何名字。这个函数接收一个`TokenStream`作为输入，这将是我们`User`结构体的声明。然后我们创建一个`insert_tokens`列表来存储我们的输入标记，这是实际代码生成的一部分。我们稍后会解释这一点。
- en: 'We then call the `parse_macro_input!` macro from the `syn` crate, passing the
    `input` token stream. This gives us back a `DeriveInput` instance in the `parsed_input`
    variable. `parsed_input` represents our `User` struct definition as a token data
    structure. From that, we pull out the struct name with the `parsed_input.ident`
    field. Next, we match on the `parsed_input.data` field, which returns what kind
    of item it is: struct, enum, or union.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后从`syn`包中调用`parse_macro_input!`宏，传入`input`标记流。这使我们从`parsed_input`变量中获取一个`DeriveInput`实例。`parsed_input`代表我们的`User`结构定义作为一个标记数据结构。从那里，我们使用`parsed_input.ident`字段提取结构名称。接下来，我们匹配`parsed_input.data`字段，它返回它是什么类型的项：结构体、枚举或联合。
- en: 'To keep our implementation simpler, we are only implementing the `IntoMap`
    trait for structs, so we match only when our `parsed_input.data` is a `Data::Struct(s)`.
    The inner `s` is, again, a struct that represents the items that constitute a
    struct definition. We are interested in what fields `s` has, particularly named
    fields, so we use an `if let` to specifically match for that. Inside the `if`
    block, we get a reference to all the fields of our struct and then iterate over
    them. For each field, we generate an insert code for our `btree` map using the
    `quote!` macro from the `quote` crate:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的实现更简单，我们只为结构体实现`IntoMap`特质，所以我们只匹配当`parsed_input.data`是`Data::Struct(s)`时。内部的`s`再次是一个表示构成结构定义的项的结构体。我们感兴趣的是`s`有哪些字段，特别是命名字段，所以我们使用`if
    let`来特别匹配。在`if`块内部，我们获取我们结构体所有字段的引用，然后遍历它们。对于每个字段，我们使用来自`quote`包的`quote!`宏为我们的`btree`映射生成插入代码：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice the `#field` symbol. Within the `quote!` macro, we can have template
    variables that will be substituted with their value in the generated code. In
    this case, `#field` gets replaced with whatever field is present in our struct.
    First, we convert `#field` to a string literal by using the `stringify!` macro,
    which is an `Ident` type from the `syn` crate. We then push this generated chunk
    of code into the `insert_tokens` vec.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`#field`符号。在`quote!`宏内部，我们可以有模板变量，这些变量将在生成的代码中用它们的值替换。在这种情况下，`#field`被替换为我们结构体中存在的任何字段。首先，我们使用`stringify!`宏将`#field`转换为字符串字面量，这是来自`syn`包的`Ident`类型。然后我们将这个生成的代码块推入`insert_tokens`向量。
- en: 'Following that, we come to our final phase of code generation:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们进入代码生成的最终阶段：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we are finally generating our final `impl` block for our struct. Within
    the `quote!` block, whatever we write will be generated exactly as written, including
    the indentation and code comments. First, we do the imports of the `BtreeMap`
    type and the `IntoMap` trait. Then, we have the `IntoMap` implementation. Within
    that, we create our `map`, and just expand out the `insert_tokens` that we collected
    in the first phase of code generation. Here, the outer `#()*` repeater tells the
    `quote!` macro to repeat the same code zero or more times. For iterable items
    such as our `insert_tokens`, this will repeat all the items within it. This generates
    code for inserting the field name and field value from the struct into the `map`.
    Finally, we take the whole implementation code that''s stored in the `tokens`
    variable and return this as a `TokenStream` by calling `TokenStream::from(tokens)`.
    That''s it! Let''s try this macro in `main.rs`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们终于生成了我们结构的最终`impl`块。在`quote!`块内，无论我们写什么，都会被原样生成，包括缩进和代码注释。首先，我们导入`BtreeMap`类型和`IntoMap`特质。然后，我们有`IntoMap`实现。在其中，我们创建我们的`map`，并展开我们在代码生成的第一阶段收集到的`insert_tokens`。在这里，外部的`#()*`重复器告诉`quote!`宏重复相同的代码零次或多次。对于如我们的`insert_tokens`这样的可迭代项，这将重复其中的所有项。这会生成将结构体中的字段名和字段值插入到`map`中的代码。最后，我们取存储在`tokens`变量中的整个实现代码，通过调用`TokenStream::from(tokens)`将其作为`TokenStream`返回。就这样！让我们在`main.rs`中尝试这个宏：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running `cargo run` gives us the following output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo run`给出以下输出：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Great! It works. Next, let's look at how we can debug macros.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，它工作了。接下来，让我们看看我们如何调试宏。
- en: Debugging macros
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试宏
- en: 'When developing complex macros, most of the time you need ways to analyze how
    your code expands to the inputs you gave to the macro. You can always use `println!`
    or `panic!` at the places you want to see the generated code, but it''s a very
    crude way to debug it. There''s are better way, though. The Rust community provides
    us with a subcommand called `cargo-expand`. This subcommand was developed by David
    Tonlay at [https://github.com/dtolnay/cargo-expand](https://github.com/dtolnay/cargo-expand),
    who is also the author of the `syn` and `quote` crates. This command internally
    calls the nightly compiler flag `-Zunstable-options --pretty=expanded`, but the
    design of the subcommand was done in such a way that it doesn''t require you to
    manually switch to the nightly tool chain as it finds and switches to it automatically.
    To demonstrate this command, we''ll take the example of our `IntoMap` derive macro
    and observe what code it generated for us. By switching into the directory and
    running `cargo expand`, we get the following output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发复杂宏时，大多数情况下你需要方法来分析你的代码是如何扩展到宏输入的。你可以在你想看到生成代码的地方使用`println!`或`panic!`，但这是一种非常原始的调试方式。尽管如此，还有更好的方法。Rust社区为我们提供了一个名为`cargo-expand`的子命令。这个子命令是由David
    Tonlay在[https://github.com/dtolnay/cargo-expand](https://github.com/dtolnay/cargo-expand)开发的，他也是`syn`和`quote`crate的作者。这个命令内部调用夜间编译器的标志`-Zunstable-options
    --pretty=expanded`，但子命令的设计是这样的，它不需要你手动切换到夜间工具链，因为它会自动找到并切换。为了演示这个命令，我们将以我们的`IntoMap`派生宏为例，并观察它为我们生成了什么代码。通过切换到目录并运行`cargo
    expand`，我们得到以下输出：
- en: '![](img/0bdd3a71-91b6-49d8-b60c-0b9d50665e4e.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bdd3a71-91b6-49d8-b60c-0b9d50665e4e.png)'
- en: As you can see, the `impl` block at the bottom is what was generated by the
    `IntoMap` derive macro. `cargo-expand` also includes pretty printed syntax highlighted
    output. This command is a must-have tool for someone writing complex macros.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，底部的`impl`块是由`IntoMap`派生宏生成的。`cargo-expand`还包括了格式化并带有语法高亮的输出。这个命令对于编写复杂宏的人来说是一个必备的工具。
- en: Useful procedural macro crates
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的过程宏crate
- en: 'As procedural macros can be distributed as crates, a lot of emerging helpful
    macro crates are available, which can be found at `crates.io`. Using them can
    greatly reduce the boilerplate you need to write for generating Rust code. Some
    of them are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过程宏可以作为crate分发，因此有很多新兴的有用宏crate可用，可以在`crates.io`上找到。使用它们可以大大减少你需要编写的用于生成Rust代码的样板代码。以下是一些例子：
- en: '`derive-new`: A derive macro provides a default all-fields constructor for
    structs and is quite customizable.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`derive-new`：派生宏为结构体提供了一个默认的全字段构造函数，并且相当可定制。'
- en: '`derive-more`: A derive macro that circumvents the limitation where we wrap
    a type for which we already have a lot of traits auto-implemented, but lose the
    ability to create our own type wrapping for it. This crate helps us provide the
    same set of traits, even on these wrapper types.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`derive-more`：一个绕过限制的 derive 宏，这个限制是我们对一个已经有很多特质自动实现的类型进行包装，但失去了为它创建自己的类型包装的能力。这个
    crate 帮助我们为这些包装类型提供相同的一组特质。'
- en: '`lazy_static`: This crate provides a function-like procedural macro called
    `lazy_static!`, where you can declare `static` values that require dynamically
    initialized types. For example, you can declare a configuration object as a `HashMap`
    and can access it globally across the code base.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lazy_static`：这个 crate 提供了一个类似函数的过程宏 `lazy_static!`，其中你可以声明需要动态初始化类型的 `static`
    值。例如，你可以声明一个配置对象作为 `HashMap`，并且可以在整个代码库中全局访问它。'
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the metaprogramming abilities of Rust and looked
    at many kinds of macros. The most frequently used macro is `macro_rules!`, which
    is a declarative macro. Declarative macros work at the abstract syntax tree level,
    which means that they do not support arbitrary expansions, but require that the
    macro expansions are well-formed in the AST. For more complex use cases, you can
    use procedural macros where you get complete control of manipulating the input
    and generating the desired code. We also looked at ways to debug macros using
    the cargo subcommand `cargo-expand`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Rust 的元编程能力，并探讨了多种宏。最常用的宏是 `macro_rules!`，它是一个声明式宏。声明式宏在抽象语法树级别上工作，这意味着它们不支持任意扩展，但要求宏扩展在
    AST 中是良好形成的。对于更复杂的使用案例，你可以使用过程宏，这样你就可以完全控制对输入的处理和生成所需的代码。我们还探讨了使用 cargo 子命令 `cargo-expand`
    调试宏的方法。
- en: Macros are indeed a powerful tool, but not something that should be used heavily.
    Only when the more usual mechanisms of abstraction such as functions, traits,
    and generics do not suffice for the problem at hand should we turn to macros.
    Also, macros make the code less readable for newcomers to a code base and should
    be avoided. Having said that, they are quite useful in writing test case conditions
    and are widely used by developers.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 宏确实是一个强大的工具，但并不是应该被过度使用的东西。只有当更常见的抽象机制，如函数、特性和泛型，不足以解决手头的问题时，我们才应该转向宏。此外，宏会使代码对代码库的新手来说更难以阅读，应该避免使用。话虽如此，它们在编写测试用例条件时非常有用，并且被开发者广泛使用。
- en: In the next chapter, we'll get a glimpse of another side of Rust, the unsafe
    bits, which are less recommended but unavoidable if you want to interoperate Rust
    with different languages.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将一瞥 Rust 的另一面，即不推荐但如果你想要 Rust 与不同语言交互时不可避免的不安全部分。
