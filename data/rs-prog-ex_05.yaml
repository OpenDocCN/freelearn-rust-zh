- en: Creating a Music Player
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建音乐播放器
- en: In previous chapters you created an awesome game, so now let's move on to another
    exciting topic—desktop applications. We'll use the Rust bindings of the GTK+ library
    in order to code an MP3 music player. We'll have the opportunity to learn about
    threads to code the music player itself in the next chapter. But, in this chapter,
    we'll focus on the graphical interface, how to manage the layout of the interface,
    and how to manage user events.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你创建了一个很棒的游戏，现在让我们继续到另一个令人兴奋的主题——桌面应用程序。我们将使用 GTK+ 库的 Rust 绑定来编写一个 MP3
    音乐播放器。在下一章中，我们将有机会学习线程来编写音乐播放器本身。但是，在这一章中，我们将专注于图形界面，如何管理界面的布局，以及如何管理用户事件。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Windows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: Widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件
- en: Events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Closures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Event loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环
- en: Containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Installing the prerequisite
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: Since GTK+ is a C library, we'll need to install it first. The Rust bindings
    use GTK+ version 3, so make sure you do not install the old version 2.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GTK+ 是一个 C 库，我们首先需要安装它。Rust 绑定使用 GTK+ 版本 3，所以请确保你没有安装旧版本 2。
- en: Installing GTK+ on Linux
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 GTK+
- en: On Linux, GTK+ can be installed through the package manager of your distribution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，GTK+ 可以通过你的发行版的包管理器安装。
- en: 'On Ubuntu (or other Debian derivatives):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu（或其他 Debian 衍生版）上：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing GTK+ on Mac
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Mac 上安装 GTK+
- en: 'On OSX, you just need to run the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OSX 上，你只需要运行以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing GTK+ on Windows
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 GTK+
- en: 'On Windows, you''ll need to first download and install MSYS2, which provides
    a Unix-like environment on Windows. After it is installed, issue the following
    command in a MSYS2 shell:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你首先需要下载并安装 MSYS2，它为 Windows 提供了一个类 Unix 环境。安装完成后，在 MSYS2 终端中运行以下命令：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating your first window
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个窗口
- en: 'Now we''re ready to start using GTK+ from Rust. Let''s create a new project
    for our music player:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好从 Rust 开始使用 GTK+。让我们为我们的音乐播放器创建一个新的项目：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the dependency on the `gio` and `gtk` crates in your `Cargo.toml` file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `Cargo.toml` 文件中添加对 `gio` 和 `gtk` 依赖项：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Replace the content of the `src/main.rs` file with this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `src/main.rs` 文件的内容替换为以下内容：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, run the application with `cargo run`. You should see a small and empty
    window:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `cargo run` 运行应用程序。你应该看到一个小的空窗口：
- en: '![](img/00029.gif)**Figure 5.1**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1](img/00029.gif)**图 5.1**'
- en: If you saw this window, it means you have installed GTK+ correctly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到了这个窗口，这意味着你已经正确安装了 GTK+。
- en: 'Let''s explain this code in smaller chunks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分块解释这段代码：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As usual, when using an external crate, we need to declare it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，当使用外部 crate 时，我们需要声明它。
- en: 'Then, we import the types and modules we''ll use from the standard library,
    `gio`, and `gtk`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们导入从标准库、`gio` 和 `gtk` 中我们将使用的类型和模块：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, we start the `main` function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始 `main` 函数：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line of this function creates a new `gio` application. We provide
    an application ID that can be used to make sure the application is only run once.
    An `Application` makes it easier to manage applications and its windows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一行创建了一个新的 `gio` 应用程序。我们提供了一个应用程序 ID，可以用来确保应用程序只运行一次。`Application` 使得管理应用程序及其窗口变得更加容易。
- en: 'Next, we create the window, set its title, and show it to the screen:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建窗口，设置其标题，并将其显示到屏幕上：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After creating a new window, we set its title and show it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新窗口后，我们设置其标题并显示它。
- en: Here, we're actually handling an event; the `startup` is a signal that is emitted
    when the application is registered- so, when it is ready to be used. As you can
    see in the documentation on GTK+ ([https://developer.gnome.org/gio/stable/GApplication.html#GApplication-startup](https://developer.gnome.org/gio/stable/GApplication.html#GApplication-startup)),
    signals are represented by strings. This signal is actually called `startup`,
    but the Rust method we used to connect this signal is `connect_startup`. So, we
    need to add `connect_` before the signal name and change the dashes to underscores.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实际上正在处理一个事件；`startup` 是当应用程序注册时发出的一个信号，所以，当它准备好使用时。正如你在 GTK+ 文档中可以看到的（[https://developer.gnome.org/gio/stable/GApplication.html#GApplication-startup](https://developer.gnome.org/gio/stable/GApplication.html#GApplication-startup)），信号由字符串表示。这个信号实际上叫做
    `startup`，但我们用来连接这个信号的 Rust 方法是 `connect_startup`。因此，我们需要在信号名称前添加 `connect_` 并将破折号改为下划线。
- en: Closure
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'The argument of this method is somewhat special:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的参数有些特殊：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is what we call a closure. A closure is a concise way of declaring a function
    that does not have a name and can capture the environment. Capturing the environment
    means that it can access the variables from outside the closure, something which
    is not possible to do with normal functions. The methods to connect a signal will
    run the function (in this case, a closure) passed as an argument. Here, create
    the window.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的闭包。闭包是一种简洁地声明没有名称且可以捕获环境的函数的方法。捕获环境意味着它可以访问闭包外部的变量，这是普通函数无法做到的。连接信号的函数将运行作为参数传递的函数（在这种情况下，一个闭包）。在这里，创建窗口。
- en: 'We could have decided to create a normal function, as the following code does:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以决定创建一个普通函数，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But that is less convenient than using a closure. Besides the fact that you
    might need to import other crates and types, you need to specify the types of
    the parameters and the return type. Indeed, type inference is available for closures
    but not for functions. Also, the function must be declared elsewhere, so it can
    become less readable than using a closure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但这比使用闭包不太方便。除了你可能需要导入其他crate和类型之外，你还需要指定参数的类型和返回类型。实际上，闭包有类型推断，但函数没有。此外，函数必须在其他地方声明，因此它可能没有使用闭包那么易于阅读。
- en: 'The rest of the `main` function is:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数的其余部分是：'
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This starts the `gtk` event loop. This is an infinite loop that processes the
    user events like a button click or a request to close a window. It also manages
    other things like timeouts and asynchronous, IO-like network requests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这启动了`gtk`事件循环。这是一个无限循环，它处理用户事件，如按钮点击或请求关闭窗口。它还管理其他事情，如超时和异步、类似IO的网络请求。
- en: Some event handlers require you to return a value, which is the case for the
    signal `delete_event` where we need to return `Inhibit(false)`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件处理器要求你返回一个值，例如对于`delete_event`信号，我们需要返回`Inhibit(false)`。
- en: Preventing the default behavior of an event
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻止事件默认行为
- en: 'The `Inhibit` type is only a wrapper over the `bool` type. It is used to indicate
    whether we should  stop propagating the event to the default handler or not. To
    see what this means, let''s add an event handler for the window:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inhibit`类型只是`bool`类型的包装。它用于指示我们是否应该停止将事件传播到默认处理器。为了了解这意味着什么，让我们为窗口添加一个事件处理器：'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you run it, you'll note that we cannot close the window anymore. That's because
    we returned `Inhibit(true)` to indicate that we want to prevent the default behavior
    of the `delete_event` signal, which is to close the window.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行它，你会注意到我们不能再关闭窗口了。这是因为我们返回了`Inhibit(true)`来表示我们想要阻止`delete_event`信号的默认行为，即关闭窗口。
- en: 'Now let''s try a slight variant of the previous code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试对之前的代码进行轻微的变体：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, we do not prevent the default handler from being run, so the window
    will be closed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不阻止默认处理器运行，因此窗口将被关闭。
- en: Creating a toolbar
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建工具栏
- en: 'We''ll start our music player by adding a toolbar with the buttons needed for
    such software:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加一个带有所需按钮的工具栏来开始我们的音乐播放器：
- en: Open a file
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开文件
- en: Play
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放
- en: Pause
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停
- en: Stop
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止
- en: Previous/next song
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一首/下一首歌曲
- en: Remove song from playlist
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从播放列表中移除歌曲
- en: That'll be a good start for our first non-empty window.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的第一个非空窗口的好开始。
- en: 'First of all, we''ll need some additional import statements:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些额外的导入语句：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we''ll declare a constant because we''ll use this value elsewhere:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将声明一个常量，因为我们将在其他地方使用这个值：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We'll explain what this is very soon.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会解释这是怎么回事。
- en: 'We''ll now create a toolbar and add it to the window:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个工具栏并将其添加到窗口中：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note: Don''t call `window.show()` yet, as we''ll use another method ahead.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：不要调用`window.show()`，因为我们将在之后使用另一种方法。
- en: This code is pretty straightforward. The only thing to note is that the `gtk-rs`
    API requires a reference to values in most cases; in this case, we send a reference
    to the toolbar as a parameter to the `add()` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当直接。唯一需要注意的是，`gtk-rs` API在大多数情况下需要值的引用；在这种情况下，我们将工具栏的引用作为参数发送到`add()`方法。
- en: You'll see this `add()` method called literally everywhere. It allows you to
    add a widget to another. A widget is a component (visual or not) of a user interface.
    It can be a button, a menu, a separator, but it can also be an invisible component
    such as a box allowing you to place the widgets horizontally. We'll talk about
    containers like `gtk::Box` and how to lay out our widgets later in this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这个`add()`方法几乎被到处调用。它允许你将小部件添加到另一个小部件中。小部件是用户界面（视觉或非视觉）的组件。它可以是一个按钮、一个菜单、一个分隔符，但它也可以是一个不可见组件，例如一个盒子，允许你水平放置小部件。我们将在本章后面讨论像`gtk::Box`这样的容器以及如何布局我们的小部件。
- en: 'Let''s add a button to this toolbar:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在工具栏中添加一个按钮：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This creates a toolbar button and adds it to the toolbar.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个工具栏按钮并将其添加到工具栏中。
- en: Stock item
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存项
- en: Instead of using the usual `new()` constructor, we decided to use the `new_from_stock()`
    one here. This takes a string as an argument. This string is an identifier for
    the item that represents a built-in menu or toolbar item, such as `Open` or `Save`.
    These items have an icon and a label that is translated according to the user
    locale. By using stock items, you can quickly create a beautiful application that
    will look the same as other applications built with GTK+.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用常规的`new()`构造函数，而是决定在这里使用`new_from_stock()`。这个函数需要一个字符串作为参数。这个字符串是表示内置菜单或工具栏项的标识符，例如`Open`或`Save`。这些项有一个图标和一个标签，该标签根据用户的区域设置进行翻译。通过使用库存项，您可以快速创建一个看起来与其他使用GTK+构建的应用程序相同的应用程序。
- en: 'Let''s show this window containing the toolbar:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示包含工具栏的此窗口：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This goes right at the end of the startup event handler. Here, we use `show_all()`
    instead of only `show()` because we have more widgets to show. Instead of using
    `show_all()`, we could call `show()` on every single widget, but this can become
    cumbersome; that's why `show_all()` exists.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接位于启动事件处理器的末尾。在这里，我们使用`show_all()`而不是仅使用`show()`，因为我们有更多的小部件需要显示。我们本可以调用每个单独的小部件上的`show()`，但这可能会变得繁琐；这就是为什么有`show_all()`的原因。
- en: 'If you run this application, you''ll see the following window with an open
    button:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个应用程序，你会看到一个带有打开按钮的以下窗口：
- en: '![](img/00030.gif)*Figure 5.2*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2](img/00030.gif)*图5.2*'
- en: 'Let''s add the open buttons we''ll need:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们需要的打开按钮：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code should go right before the call to `window.show_all()`.  `SeparatorToolItem` ,
    which was added several times to separate the buttons logically so that buttons
    for similar actions are grouped together.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该放在调用`window.show_all()`之前。`SeparatorToolItem`，它被添加了几次，以逻辑上分隔按钮，使得类似操作的按钮可以分组在一起。
- en: 'Now we have an application that is starting to look like a music player, as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个开始看起来像音乐播放器的应用程序，如下所示：
- en: '![](img/00031.jpeg)*Figure 5.3*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3](img/00031.jpeg)*图5.3*'
- en: Improving the organization of the application
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改善应用程序的组织结构
- en: The `main` function is starting to get bigger, so we'll refactor our code a
    little to make it easier to update in the upcoming sections and chapters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数开始变得更大，所以我们将稍微重构我们的代码，以便在接下来的章节中更容易更新。'
- en: 'First, we''ll create a new module called `toolbar`. As a reminder, here''s
    how to do so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`toolbar`的新模块。作为一个提醒，以下是这样做的方法：
- en: Create a new file: `src/toolbar.rs`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件：`src/toolbar.rs`。
- en: Add a statement, `mod toolbar;`, at the top of the file `main.rs`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.rs`文件的顶部添加一个语句，`mod toolbar;`。
- en: 'This new module `toolbar` will start with the import statement and the `const`
    declaration:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`toolbar`模块将从导入语句和`const`声明开始：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll then create a new structure holding all the widgets that compose the
    toolbar:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个新的结构，它包含组成工具栏的所有小部件：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We use the `pub` keyword here because we want to be able to use this type from
    other modules.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`pub`关键字，因为我们希望能够从其他模块中使用这个类型。
- en: 'Then, we''ll create a constructor for this `struct` that will create all the
    buttons, like we did earlier:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为这个`struct`创建一个构造函数，它将创建所有按钮，就像我们之前做的那样：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The only difference with the previous code is that we now return a `struct
    MusicToolbar`. We''ll also add a method in this `impl` to be able to access the
    `gtk::Toolbar` widget from the outside:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的代码相比，唯一的区别是我们现在返回一个`struct MusicToolbar`。我们还会在这个`impl`中添加一个方法，以便从外部访问`gtk::Toolbar`小部件：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s all for now for this `toolbar` module. Let''s go back to the `main`
    module. First, we need to import our new `MusicToolbar` type:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于这个`工具栏`模块的内容就到这里。让我们回到`主`模块。首先，我们需要导入我们新的`MusicToolbar`类型：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we''ll create a structure like we did for our toolbar:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个类似于我们为工具栏创建的结构：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And we will also create a constructor for it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为它创建一个构造函数：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we created the window as we did before and then created our own `MusicToolbar`
    structure. We add the wrapped toolbar widget by sending the result of the `toolbar()`
    method (which returns the `gtk` widget) to the `add()` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们像之前一样创建了窗口，然后创建了我们的 `MusicToolbar` 结构。我们通过将 `toolbar()` 方法（它返回 `gtk` 小部件）的结果传递给
    `add()` 方法来添加包装的工具栏小部件。
- en: 'After that, we used a little trick that enabled us to call a method on the
    `struct` yet to be created; we first assign the `struct` to a variable, then call
    the method and return the variable. This method is defined next, within the same
    `impl` block:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用了一个小技巧，使我们能够在尚未创建的 `struct` 上调用方法；我们首先将 `struct` 赋值给一个变量，然后调用方法并返回该变量。这个方法定义在同一个
    `impl` 块中：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We'll fill in this method in the next chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中填充这个方法。
- en: Adding tool button events
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加工具按钮事件
- en: We'll continue by adding event handlers to some of the buttons.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续添加一些按钮的事件处理器。
- en: 'First of all, we''ll need new `use` statements:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要新的 `use` 语句：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We import `ToolButtonExt`, which provides methods to be called on `ToolButton`
    and `App` from the `main` module, because we''ll add a new method to this type:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `ToolButtonExt`，它提供了从 `main` 模块调用 `ToolButton` 和 `App` 的方法，因为我们将为这个类型添加一个新方法：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In Rust, it's perfectly valid to declare a method in a module different to where
    the type was created. Here, we say that clicking the quit button will destroy
    the window, which will effectively exit the application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，在创建类型不同的模块中声明方法是完全有效的。在这里，我们说点击退出按钮将销毁窗口，这将有效地退出应用程序。
- en: 'Let''s add another event that will toggle the play button image with the pause
    image:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个事件，该事件将切换播放按钮图像和暂停图像：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code requires a new constant to be added next to `PLAY_STOCK`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码需要在 `PLAY_STOCK` 旁边添加一个新的常量：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's first look at the body of the closure before looking at the peculiarities
    of this code. Here, we use a condition to check whether the button is showing
    the play image—if it is, we switch to the pause stock item. Otherwise, we switch
    back to the play icon.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这段代码的奇特之处之前，我们先看看闭包的主体。在这里，我们使用一个条件来检查按钮是否显示播放图像——如果是，我们切换到暂停库存项。否则，我们切换回播放图标。
- en: 'But why do we need to clone the button and use this `move` keyword before the
    closure? Let''s try the normal way, that is, how you would do that in most programming
    languages:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们需要克隆按钮并在闭包之前使用这个 `move` 关键字呢？让我们尝试正常的方式，即在大多数编程语言中你会怎么做：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we do that, we get the following compilation error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们会得到以下编译错误：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And it continues even further to explain why the lifetime cannot be inferred.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至进一步解释了为什么无法推断生命周期。
- en: 'Let''s look at the signature of the `connect_clicked()` method to understand
    what''s going on:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `connect_clicked()` 方法的签名，以了解发生了什么：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Fn(&Self)` part means the function requires something that looks like a
    function that takes a parameter that is a reference to `Self` (`ToolButton` in
    this case). The `'static` part is a lifetime annotation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fn(&Self)` 部分表示这个函数需要类似函数的东西，它接受一个参数，该参数是 `Self`（在这种情况下是 `ToolButton`）的引用。`''static''
    部分是一个生命周期注解。'
- en: Lifetime
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'Lifetime is one of the Rust features that the compiler uses to ensure memory
    safety. The lifetime specifies the minimum duration an object must live to be
    used safely. Let''s try to do something that is allowed in certain programming
    languages, but is actually an error to do so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期是 Rust 编译器用来确保内存安全的一个特性。生命周期指定了一个对象必须存在的最小持续时间，以便安全地使用。让我们尝试在某些编程语言中允许做某事，但实际上这样做是错误的：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we try to return a reference from a stack-allocated value. The problem
    is that this value will be deallocated when the function returns and the caller
    will try to access this deallocated value. In other programming languages, this
    code will compile fine and produce (hopefully) a segmentation fault at runtime.
    But Rust is a safe programming language and refuses to compile such code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们尝试从一个栈分配的值返回一个引用。问题是这个值在函数返回时将被回收，调用者将尝试访问这个已回收的值。在其他编程语言中，这段代码可以编译并产生（希望是）运行时的段错误。但
    Rust 是一种安全的编程语言，拒绝编译这样的代码：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The compile noticed that the value `element` will be deallocated at the end
    of the function; that''s what the sentence on the last line means. This is right,
    because the lifetime of `element` starts from its declaration until the end of
    the scope where it is declared; here, the scope is the function. Here''s an illustration
    of the lifetime of `element`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器注意到`element`值将在函数结束时被销毁；这就是最后一行句子所表达的意思。这是正确的，因为`element`的生命周期从其声明开始，直到其声明的范围结束；在这里，范围是函数。以下是`element`生命周期的示意图：
- en: '![](img/00032.jpeg)*Figure 5.4*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00032.jpeg)*图5.4*'
- en: 'But how does the compiler know what the required lifetime is for the returned
    value? To answer this question, let''s add the lifetime annotations that were
    added by the compiler:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但编译器是如何知道返回值所需的生命周期的呢？为了回答这个问题，让我们添加编译器添加的生命周期注释：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, the syntax for lifetimes is the same as the one used for labels—`'label`.
    When we want to specify the lifetimes, we need to declare the lifetime names between
    angle brackets, in a similar way to how we declare generic types. In this case,
    we specified that the lifetime of the returned value must be the same as the one
    from the parameter `elements`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，生命周期的语法与用于标签的语法相同——`'label'`。当我们想要指定生命周期时，我们需要在尖括号内声明生命周期名称，这与声明泛型类型的方式类似。在这种情况下，我们指定了返回值的生命周期必须与参数`elements`的生命周期相同。
- en: 'Let''s annotate the code again with lifetimes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次用生命周期来注释代码：
- en: '![](img/00033.jpeg)*Figure 5.5*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00033.jpeg)*图5.5*'
- en: Here, we clearly see that the lifetime of the returned value is smaller than
    the required one; that's why the compiler rejected our code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以清楚地看到返回值的生命周期小于所需的生命周期；这就是为什么编译器拒绝了我们的代码。
- en: 'In this case, there are two ways to fix this code (without changing the signature).
    One way to get a value that satisfies the lifetime `''a` is to get a reference
    to a value of the same lifetime; the parameter `elements` also has the lifetime
    `''a` , so we can write the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有两种方法可以修复这段代码（而不改变签名）。获得满足生命周期`'a'`的值的一种方法是通过引用相同生命周期的值；参数`elements`也有生命周期`'a'`，因此我们可以编写以下代码：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Another way is to return a reference to a value of lifetime `''static`. This
    special lifetime is equal to the duration of the program, that is, the value must
    live until the end of the program. One way to get such a lifetime is to use a
    literal:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是返回一个生命周期为`'static'`的值的引用。这个特殊的生命周期等于程序的持续时间，也就是说，值必须持续到程序结束。获得这种生命周期的
    一种方法是用字面量：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The lifetime `'static` satisfies the constraint `'a` because `'static` lives
    longer than the latter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`''static''`生命周期满足`''a''`约束，因为`''static''`的生命周期比后者长。'
- en: 'In both of these examples, the lifetime annotations were not required. We didn''t
    have to specify the lifetime in the first place, thanks to a feature called lifetime
    elision; the compiler can infer what the required lifetimes are in most cases
    by following these simple rules:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，生命周期注释不是必需的。由于一个叫做生命周期省略的特性，我们一开始就不需要指定生命周期；编译器可以通过遵循这些简单的规则在大多数情况下推断出所需的生命周期：
- en: A different lifetime parameter is assigned to each parameter
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个参数被分配不同的生命周期
- en: If there's only one parameter that needs a lifetime, that lifetime is assigned
    to every lifetime in the return value (as for our `get_element` function)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只有一个参数需要生命周期，那么这个生命周期会被分配给返回值中的每一个生命周期（就像我们的`get_element`函数一样）
- en: If there are multiple parameters that need a lifetime, but one of them is for
    `&self`, the lifetime for `self` is assigned to every lifetime in the return value
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有多个参数需要生命周期，但其中一个是用于`&self`的，则`self`的生命周期会被分配给返回值中的每一个生命周期
- en: 'Let''s go back to the method signature:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到方法签名：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we notice that the parameter `f` has the `''static` lifetime. We now
    know that this means that this parameter must live until the end of the program.
    That''s why we cannot use the *normal* version of the closure: because the lifetime
    of `self` is not `''static` , meaning the `app` will get deallocated when the
    `main` function ends. To make this work, we cloned the `play_button` variable:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注意到参数`f`具有`'static'`生命周期。我们现在知道这意味着这个参数必须持续到程序结束。这就是为什么我们不能使用*普通*版本的闭包：因为`self`的生命周期不是`'static'`，这意味着`app`将在`main`函数结束时被销毁。为了使这可行，我们克隆了`play_button`变量：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we can use this new variable in the closure.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在这个闭包中使用这个新变量。
- en: 'Note: Take note that cloning a GTK+ widget is really cheap; only a pointer
    is cloned.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请注意，克隆GTK+小部件是非常便宜的；只需克隆一个指针。
- en: 'However, trying to do the following will still result in a compilation error:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试执行以下操作仍然会导致编译错误：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here''s the error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是错误信息：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The problem with this code is that the closure can (and will) be called after
    the function returns, but the variable button is declared in the method `connect_toolbar_events()`
    and will be deallocated when it returns. Again, Rust prevents us from having a
    segmentation fault by checking if we correctly use references. The compiler talks
    about ownership; let's look at what that is.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于闭包可以在函数返回之后被调用，但是变量 `button` 在 `connect_toolbar_events()` 方法中被声明，并在返回时被释放。再次强调，Rust
    通过检查我们是否正确使用引用来防止我们出现段错误。编译器谈论所有权的概念；让我们看看这是什么。
- en: Ownership
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权的概念
- en: 'In Rust, there''s no garbage collector to deallocate the memory when it''s
    not needed anymore. Also, there''s no need for the programmer to specify where
    the memory should be deallocated. But how can this work? The compiler is able
    to determine when to deallocate the memory thanks to the concept of ownership;
    only one variable can own a value. By this simple rule, the matter of when to
    deallocate the value is simple: when the owner goes out of scope, the value is
    deallocated.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，没有垃圾回收器来处理不再需要的内存的释放。此外，程序员也不需要指定内存应该在哪里释放。但是，这怎么可能工作呢？编译器能够通过所有权的概念来确定何时释放内存；只有一个变量可以拥有一个值。通过这个简单的规则，何时释放值的处理变得简单：当所有者超出作用域时，值就会被释放。
- en: 'Let''s see an example of how deallocation is related to scope:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，看看释放与作用域的关系：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we remove an element from the vector in a new scope—the block for the
    condition. The variable `element` will own the value that was removed from the
    vector (we also say that the value was moved from the vector to the variable `element`).
    Since it owns the value, the variable is not responsible for deallocating it when
    it goes out of scope. Thus, after the condition, the value `"string"` will be
    freed and cannot be accessed anymore.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在新的作用域中从向量中移除一个元素——条件块的块。变量 `element` 将拥有从向量中移除的值（我们也可以说值从向量移动到变量 `element`）。由于它拥有这个值，变量在超出作用域时不需要负责释放它。因此，在条件之后，值
    `"string"` 将被释放并且不能再被访问。
- en: 'Let''s get back to our code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的代码：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We added the keyword `move` to closure to indicate that the value must be moved
    into the closure. (That's actually what the compiler told us to do, if you remember
    the error message.) By doing so, we satisfy the borrow checker because the value
    is not borrowed anymore. This was causing a lifetime error, but has now been moved
    into the closure and will thus live as long as the closure itself.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在闭包中添加了关键字 `move` 来表示值必须被移动到闭包中。（如果你记得错误信息，这就是编译器告诉我们要做的事情。）通过这样做，我们满足了借用检查器的条件，因为值不再被借用。这之前导致生命周期错误，但现在已经被移动到闭包中，因此它将像闭包本身一样长时间存在。
- en: 'Don''t forget to add the call to this method in the method `App::new()`, right
    after the call to `connect_events()`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `App::new()` 方法中调用此方法，在调用 `connect_events()` 之后：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Containers
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: 'We''ll now add other widgets to our window: an image to show the cover of the
    song that is currently being played and a cursor to see the progression of the
    music. However, it is not possible to add multiple widgets to a window. To do
    so, we need to use containers.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向我们的窗口添加其他小部件：一个显示当前播放歌曲封面的图像和一个光标来查看音乐的进度。然而，不可能向窗口添加多个小部件。要做到这一点，我们需要使用容器。
- en: Containers are a way to manage how multiple widgets will be shown.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一种管理多个小部件如何显示的方式。
- en: Types of containers
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的类型
- en: 'Here are simple non-visual containers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些简单的非视觉容器：
- en: '`gtk::Box`: disposes widgets either horizontally or vertically'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gtk::Box`：水平或垂直地处理小部件'
- en: '`gtk::Grid`: disposes widgets in rows and columns, like a table'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gtk::Grid`：像表格一样按行和列处理小部件'
- en: '`gtk::Fixed`: displays widgets at a very specific position in pixels'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gtk::Fixed`：在像素级别的特定位置显示小部件'
- en: '`gtk::Stack`: displays only one widget at a time'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gtk::Stack`：一次只显示一个小部件'
- en: All of these widgets, except `gtk::Fixed` , automatically rearrange the widgets
    when the window is resized. That's why you should avoid using this one.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些小部件，除了 `gtk::Fixed` ，在窗口大小调整时都会自动重新排列小部件。这就是为什么你应该避免使用这个的原因。
- en: 'Here are some more fancy containers:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更复杂的容器：
- en: '`gtk::Notebook`: displays only one widget at a time, but the user can select
    which one to show by clicking on a tab'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gtk::Notebook`：一次只显示一个小部件，但用户可以通过点击标签来选择显示哪个'
- en: '`gtk::Paned`: displays two widgets, separated by a handle that the user can
    drag to adjust the division between the widgets'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gtk::Paned`：显示两个小部件，由用户可以拖动的手柄分隔，以调整小部件之间的分隔'
- en: The Box container
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盒子容器
- en: 'We''ll use a `gtk::Box` to arrange our widgets. First of all, remove the call
    to `Window::add()` that we added before:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`gtk::Box`来排列我们的小部件。首先，删除我们之前添加的`Window::add()`调用：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We remove this call because we''ll instead add the toolbar to the box and the
    box to the window. Let''s do that, but before we do, we''ll add a couple of new
    imports:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除这个调用，因为我们将向盒子中添加工具栏，并将盒子添加到窗口中。让我们这样做，但在我们这样做之前，我们将添加一些新的导入：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we create the box:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建盒子：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: (This code goes into the `App::new()` method.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: （此代码将放入`App::new()`方法中。）
- en: Here, we fully qualified `gtk::Box` because `Box` is a type from the standard
    library that is automatically imported. We specified that the orientation of the
    box is vertical and there's no spacing (`0`) between the children widgets of the
    container.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们完全限定了`gtk::Box`，因为`Box`是标准库中的一个类型，它会被自动导入。我们指定了盒子的方向是垂直的，并且容器的小部件之间没有间隔（`0`）。
- en: 'Now we''re ready to add widgets to this box:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好向这个盒子添加小部件：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We first add our toolbar, then add an image and load a cover from a static file
    because we haven't yet written the code to extract the cover from an MP3 file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加我们的工具栏，然后添加一个图片并从静态文件中加载封面，因为我们还没有编写从MP3文件中提取封面的代码。
- en: 'Let''s also add the cursor widget:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个光标小部件：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The cursor widget is named `Scale`. This widget needs an `Adjustment`, which
    is an object that represents which values the cursor can take, and also contains
    the current value and the increment values. Again, since we don't know how to
    fetch the duration of a song from an MP3 file, we hardcode values for  `Adjustment`.
    We also disable the feature to show the actual value of the cursor by calling
    `set_draw_value(false)`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 光标小部件命名为`Scale`。这个小部件需要一个`Adjustment`，它是一个表示光标可以取哪些值的对象，并且包含当前值和增量值。同样，由于我们不知道如何从MP3文件中获取歌曲的持续时间，我们为`Adjustment`硬编码了值。我们还通过调用`set_draw_value(false)`禁用了显示光标实际值的特性。
- en: 'If you run the application, you''ll see the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你会看到以下内容：
- en: '![](img/00034.jpeg)*Figure 5.6*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6](img/00034.jpeg)*图5.6*'
- en: (We can almost hear the music when looking at it.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: （我们几乎可以听到音乐，当我们看着它的时候。）
- en: 'To conclude this section, we''ll add a few fields to the `App` structure so
    that it becomes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本节，我们将在`App`结构中添加几个字段，使其变为：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The end of the `App` constructor is then updated to:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`构造函数的末尾更新为：'
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Adding a playlist
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加播放列表
- en: We're now ready to add the playlist widget to our music player.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好将播放列表小部件添加到我们的音乐播放器中。
- en: 'We''ll use new crates, so add the following to the `main.rs` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用新的crate，所以请在`main.rs`文件中添加以下内容：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The crate `gdk_pixbuf` will be used to show and manipulate the cover and the
    `id3` crate to get the metadata from MP3 files.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用`gdk_pixbuf` crate来显示和操作封面，以及`id3` crate来从MP3文件中获取元数据。
- en: 'Also, add the following to `Cargo.toml`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将以下内容添加到`Cargo.toml`：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we''ll create a new module to contain this new widget:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个新的模块来包含这个新小部件：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We''ll start this module by adding a bunch of `use` statements:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个模块开始，添加一些`use`语句：
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'These will be followed by some constants:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些常量：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `*_COLUMN` constant represents the column we''ll show in the playlist.
    The last one, `PIXBUF_COLUMN`, is a bit special: it will be a hidden column holding
    the cover of a bigger size so that we can show this image in the `cover` widget
    we created earlier.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`*_COLUMN` 常量代表我们将在播放列表中显示的列。最后一个，`PIXBUF_COLUMN`，有点特别：它将是一个隐藏的列，用于存储更大尺寸的封面，这样我们就可以在我们之前创建的`cover`小部件中显示这张图片。'
- en: 'Next, we''ll create a new structure to hold the widget and its model:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的结构来存放小部件及其模型：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The MVC pattern
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC模式
- en: For the list and tree widgets, GTK+ follows the MVC pattern. MVC stands for
    Model-View-Controller.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表和树小部件，GTK+遵循MVC模式。MVC代表模型-视图-控制器。
- en: 'Now we can add a constructor for our playlist:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为我们的播放列表添加一个构造函数：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `gtk::ListStore` type is a model to represent the data as a list. Its constructor
    needs the types of the columns; in this case, most of the types are strings for
    the metadata of the MP3 files, such as the song title and author name. The first
    `Pixbuf` is for the thumbnail image and the last one is for the bigger image only
    shown for the music currently playing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`gtk::ListStore`类型是一个将数据表示为列表的模型。它的构造函数需要列的类型；在这种情况下，大多数类型都是字符串，用于MP3文件的元数据，例如歌曲标题和作者姓名。第一个`Pixbuf`用于缩略图图像，最后一个用于仅显示当前播放音乐的较大图像。'
- en: 'Next, we create a `TreeView`, which will actually be a view for a list since
    we initialize it with our list model. We then modify the widget so that it expands
    both vertically and horizontally, meaning that the widget will use as much space
    as possible. Finally, just before we return the `struct Playlist`, we call the
    `create_columns()` method, which will create the columns to be shown in this view.
    Let''s see this new method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`TreeView`，它实际上是一个列表的视图，因为我们用我们的列表模型初始化它。然后我们修改widget，使其在垂直和水平方向上扩展，这意味着widget将尽可能使用空间。最后，在返回`struct
    Playlist`之前，我们调用`create_columns()`方法，该方法将创建在此视图中显示的列。让我们看看这个新方法：
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, we call two methods to create the different types of columns—we specify
    the header label and the column number of every column. As for the last parameter
    of the `add_pixbuf_column()` method, it indicates whether the column is visible
    or not. This parameter is of a custom type, so let''s declare it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用两个方法来创建不同类型的列——我们指定每个列的表头标签和列号。至于`add_pixbuf_column()`方法的最后一个参数，它表示列是否可见。这个参数是一个自定义类型，所以让我们声明它：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We also added a `use` statement to be able to directly use `Visible` instead
    of having to fully qualify it (`Visibility::Visible`).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`use`语句，以便能够直接使用`Visible`而不是必须完全限定它（`Visibility::Visible`）。
- en: 'Let''s write the `add_text_column()` method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`add_text_column()`方法：
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We start by creating the column itself and setting the label of the header
    by calling `set_title()`. Then, we create a `CellRenderer`, which indicates how
    the data from the model should be rendered in the view; here, we only want to
    show some text, so we chose `CellRendererText`, we set it to take up as much space
    as possible, and added the renderer to the column. Next comes a very important
    line:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建列本身，并通过调用`set_title()`设置表头标签。然后，我们创建一个`CellRenderer`，它指示模型数据在视图中的渲染方式；在这里，我们只想显示一些文本，所以我们选择了`CellRendererText`，将其设置为尽可能占用空间，并将渲染器添加到列中。接下来是一行非常重要的代码：
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This line specifies that the view will set the `text` attribute from the data
    that comes from the model at the specified column.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码指定视图将从模型在指定列的数据中设置`text`属性。
- en: At the end, we add the column to the view.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将列添加到视图中。
- en: 'Now we''ll write a similar function for the `pixbuf`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为`pixbuf`编写一个类似的功能：
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we create a new type of renderer (`CellRendererPixbuf`), which will show
    an image instead of text. This time, we set the `pixbuf` attribute because we
    want to show an image. The renderer is only created if the column is visible.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一种新的渲染器类型（`CellRendererPixbuf`），它将显示图像而不是文本。这次，我们设置了`pixbuf`属性，因为我们想显示一个图像。只有当列可见时，才会创建渲染器。
- en: 'Now, all that''s left is to write a function to get the actual widget to be
    able to add the widget in the `main` module:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的只是编写一个函数来获取实际的widget，以便能够在`main`模块中添加widget：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s go back to the method `App::new()` and create the playlist:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`App::new()`方法，并创建播放列表：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: (Add this code right before creating the `Image`.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: （在创建`Image`之前添加此代码。）
- en: 'We''ll also add a `playlist` attribute in the structure:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会在结构中添加一个`playlist`属性：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Also, don''t forget to edit the creation of the structure to include the following
    new field:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了编辑结构的创建以包括以下新字段：
- en: '[PRE70]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We''re now ready to launch our application again to see an empty playlist:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备再次启动我们的应用程序，以查看一个空白的播放列表：
- en: '![](img/00035.jpeg)**Figure 5.7**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7](img/00035.jpeg)**图5.7**'
- en: Opening MP3 files
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开MP3文件
- en: Let's finish this chapter by adding the ability to open MP3 files and show their
    metadata in the playlist widget we just created.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加打开MP3文件并显示其元数据在刚刚创建的播放列表小部件中的功能来完成这一章。
- en: 'First of all, we''ll remove this line:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将删除这一行：
- en: '[PRE71]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is because the image will be set from the data of the MP3 files we play.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为图像将从我们播放的MP3文件的数据中设置。
- en: 'We''ll use a new crate, so add this line in the `[dependencies]` section of
    your `Cargo.toml`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个新的crate，所以请在你的`Cargo.toml`的`[dependencies]`部分添加这一行：
- en: '[PRE72]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Also, add the following line to your `main.rs`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要在您的`main.rs`中添加以下行：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `*-sys` crates of the `gtk-rs` ecosystem are low-level crates, the ones
    that directly bind to the GTK+ C library. Since they're very low-level and require
    the use of unsafe code, wrappers have been made; these are crates without the
    `-sys` suffix, such as `gtk` and `gdk`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`gtk-rs`生态系统中的`*-sys`crate是低级crate，它们直接绑定到GTK+ C库。由于它们非常低级且需要使用unsafe代码，因此创建了包装器；这些是没有`-sys`后缀的crate，例如`gtk`和`gdk`。'
- en: Reference-counting pointer
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用计数指针
- en: 'We''ll also change some code before we continue. Since we''ll want to share
    our `Playlist` widget with different parts of our code, including some event handlers,
    we need a way of sharing a reference that will last long enough (remember the
    issue we had with the lifetime). One easy way of doing so is to use a reference-counting
    pointer type—`Rc`. So, in our `App` structure, let''s change the `playlist` field
    to use an `Rc`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们还将更改一些代码。由于我们希望将我们的`Playlist`小部件与代码的不同部分共享，包括一些事件处理程序，我们需要一种方法来共享一个持续时间足够长的引用（记住我们遇到的寿命问题）。这样做的一个简单方法是使用引用计数指针类型——`Rc`。因此，在我们的`App`结构中，让我们将`playlist`字段更改为使用`Rc`：
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This requires a new import at the top of the `main` module:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要在`main`模块的顶部添加一个新的导入：
- en: '[PRE75]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Also, the creation of the playlist needs to be updated:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要更新播放列表的创建：
- en: '[PRE76]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We now wrap the `Paylist` inside an `Rc`. We can still use the playlist like
    before, as long as we''re calling immutable methods, that is, methods that take
    `&self` but not `&mut self`. So, the next line is still valid:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将`Playlist`包装在一个`Rc`中。只要我们调用不可变方法，即那些接受`&self`但不接受`&mut self`的方法，我们仍然可以使用播放列表，就像以前一样。所以，下一行仍然有效：
- en: '[PRE77]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Before we create the method to add an MP3 file to the playlist, we''ll need
    another method to set the `pixbuf` values in the model from the MP3 metadata.
    In the `impl Playlist`, add the following method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建将MP3文件添加到播放列表的方法之前，我们需要另一个方法来从MP3元数据中设置模型中的`pixbuf`值。在`impl Playlist`中添加以下方法：
- en: '[PRE78]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The type `Tag` represents the metadata of an MP3 file. We get the first picture
    contained in the file and we load it. If the loading was successful, we resize
    it to get a thumbnail and then we set the values in the model.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`Tag`表示MP3文件的元数据。我们获取文件中包含的第一张图片并将其加载。如果加载成功，我们将它调整大小以获取缩略图，然后设置模型中的值。
- en: ID3— MP3 metadata
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ID3—MP3元数据
- en: 'We''re now ready to get all the relevant metadata from the MP3 files and add
    them to the playlist. Let''s start the `Playlist::add()` method by fetching the
    metadata:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好从MP3文件中获取所有相关元数据并将其添加到播放列表中。让我们通过获取元数据来开始`Playlist::add()`方法：
- en: '[PRE79]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We first get the filename without the extension and convert it to a string;
    we'll show this if there's no song title in the file. Then, we read the metadata
    from the file and assign a default value such as `"(no artist)"` in case a value
    is missing by calling `unwrap_or()`, which gets the value from `Option` if or
    returns the argument if the value is `None`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取没有扩展名的文件名并将其转换为字符串；如果没有歌曲标题在文件中，我们将显示这个。然后，我们从文件中读取元数据，并在调用`unwrap_or()`的情况下分配一个默认值，例如`"(no
    artist)"`，如果值缺失。`unwrap_or()`从`Option`获取值，如果值是`None`，则返回参数。
- en: 'Now let''s see the rest of the method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看方法的其余部分：
- en: '[PRE80]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we create a new row in the model and call the `set_pixbuf()` we created
    just before. After that, we set the value in the new row. One special value is
    the path, which will be useful later when we want to play the selected song from
    the playlist; we'll only need to fetch the path and then play it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在模型中创建一个新的行，并调用我们刚才创建的`set_pixbuf()`。之后，我们在新行中设置值。一个特殊的值是路径，这在稍后我们想要从播放列表中播放所选歌曲时将很有用；我们只需要获取路径然后播放它。
- en: Opening files with a file dialog
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件对话框打开文件
- en: 'There''s another function we''ll need before we can handle the click event
    of the open button. We need a function that''ll show a file dialog to allow the
    user to select a file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以处理打开按钮的点击事件之前，我们还需要另一个函数。我们需要一个函数来显示文件对话框，允许用户选择文件：
- en: '[PRE81]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This function starts by creating a new file dialog of the type `open`. Afterwards,
    it adds a filter to this dialog so that it only shows MP3 files. Then, we add
    two buttons using some constants that we'll define later. At the moment, we can
    show the dialog by calling `run()`; this function blocks until the dialog is closed
    and returns which button was clicked. After that, we check whether the accept
    button was clicked to save the filename that was selected by the user and we return
    that filename.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先创建一个类型为 `open` 的新文件对话框。之后，它向此对话框添加一个过滤器，以便只显示MP3文件。然后，我们使用我们稍后定义的一些常量添加两个按钮。目前，我们可以通过调用
    `run()` 来显示对话框；此函数会阻塞，直到对话框关闭，并返回被点击的按钮。之后，我们检查是否点击了接受按钮以保存用户选择的文件名，并返回该文件名。
- en: 'Here are the constants needed by the previous function:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前函数所需的常量：
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We''re now ready to handle the click event of the open button. Add the following
    in the method `App::connect_toolbar_events()`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好处理打开按钮的点击事件。在方法 `App::connect_toolbar_events()` 中添加以下内容：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the event handler, we call the function we just defined and, if a file was
    selected, we call the `add()` method of the playlist.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理程序中，我们调用我们刚刚定义的函数，如果选择了文件，我们调用播放列表的 `add()` 方法。
- en: 'You can now try the application and open an MP3 file. Here''s what you''ll
    see:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以尝试应用程序并打开一个MP3文件。您将看到以下内容：
- en: '![](img/00036.jpeg)*Figure 5.8*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00036.jpeg)*图5.8*'
- en: Let's add two more features before we end this chapter. The first one is to
    remove a song from the playlist.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们添加两个更多功能。第一个是从播放列表中删除一首歌曲。
- en: Deleting a song
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除歌曲
- en: 'We need to add a method to the `Playlist` struct to remove the selected item:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 `Playlist` 结构中添加一个方法来删除所选项：
- en: '[PRE84]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This first starts by getting the selection and, if there was one, we remove
    it from the model. We can now add an event handler for the remove button in the
    `App::connect_toolbar_events()` method:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这首先从获取选择项开始，如果有，我们从模型中移除它。现在我们可以在 `App::connect_toolbar_events()` 方法中为删除按钮添加事件处理程序：
- en: '[PRE85]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: There's nothing new in this code; we simply clone the reference-counted playlist
    and call a method on it when the button is clicked.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有新内容；我们只是在按钮点击时简单地克隆引用计数的播放列表并调用其上的一个方法。
- en: Displaying the cover when playing a song
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放歌曲时显示封面
- en: 'The other feature to add is to show a bigger cover when we click the play button. We''ll
    start by adding a function to get the image from the selection in the playlist:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要添加的功能是在点击播放按钮时显示更大的封面。我们将首先添加一个从播放列表中的选择项获取图像的函数：
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This method to be added to the `Playlist` structure starts by getting the selection;
    if there's one, it simply gets the `pixbuf` from the model and returns it. Otherwise,
    it returns `None`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加到 `Playlist` 结构中的此方法首先获取选择项；如果有，它从模型中获取 `pixbuf` 并返回它。否则，它返回 `None`。
- en: 'We can now write a function that will fetch the cover from the playlist and
    show the image:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写一个函数，该函数将从播放列表中获取封面并显示图像：
- en: '[PRE87]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Add this function in the `toolbar` module. And, finally, we can call this function
    from the click event handler of the play button:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `toolbar` 模块中添加此函数。最后，我们可以从播放按钮的点击事件处理程序中调用此函数：
- en: '[PRE88]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here''s the result after adding a song and clicking play:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 添加歌曲并点击播放后的结果：
- en: '![](img/00037.jpeg)*Figure 5.9*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00037.jpeg)*图5.9*'
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter started by showing you how to install GTK+ on your machine. You
    then learned how to use `gtk-rs` to create windows, to manage user events like
    mouse click, to add different types of widgets to your window, to arrange your
    widgets with containers, and to show beautiful icons with stock items. You also
    saw how to use complex GTK+ widgets that use the MVC pattern.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先向您展示了如何在您的机器上安装GTK+。然后您学习了如何使用 `gtk-rs` 创建窗口，管理用户事件如鼠标点击，向窗口添加不同类型的控件，使用容器排列控件，以及使用库存项显示漂亮的图标。您还了解了如何使用遵循MVC模式的复杂GTK+控件。
- en: You also gained more knowledge of Rust in the areas of closures, lifetimes,
    and ownerships, which are key concepts in this language.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您在Rust的闭包、生命周期和所有权等领域也获得了更多的知识，这些是该语言的关键概念。
- en: Finally, you learned how to extract the metadata of an MP3 file by getting the
    ID3 tags.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您学习了如何通过获取ID3标签来提取MP3文件的元数据。
- en: In the next chapter, we'll improve the music player so that it can actually
    play a song.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将改进音乐播放器，使其能够真正播放一首歌曲。
