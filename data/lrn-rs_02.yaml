- en: Variables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: As with all programming languages, we need a way to store information within
    our application. This information can be anything and, as with every other language,
    it's stored in a variable. However, unlike every other language, Rust does not
    store data in the same way as (say) C does.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有编程语言一样，我们需要一种方式在我们的应用程序中存储信息。这些信息可以是任何东西，并且与每种其他语言一样，它存储在变量中。然而，与每种其他语言不同，Rust不按（比如说）C的方式存储数据。
- en: 'To that end, in this chapter we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将做以下事情：
- en: Understand variable mutability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变量可变性
- en: See how Rust stores information in a variable, and the types of variable available
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看Rust如何在变量中存储信息，以及可用的变量类型
- en: See how Rust deals with vector variable types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看Rust如何处理向量变量类型
- en: Understand how Rust can and cannot manipulate variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Rust如何以及如何不能操作变量
- en: See how Rust can pass variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看Rust如何传递变量
- en: Take a look at how Rust stores a variable internally
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看Rust如何内部存储变量
- en: Variable mutability
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量可变性
- en: Unlike many other languages, Rust defaults to non-mutability of variables. That
    means that variable bindings are actually constants if not explicitly defined
    as mutable. The compiler checks against all variable mutations and refuses to
    accept mutating non-mutable variable bindings.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言不同，Rust默认变量不可变。这意味着如果未明确定义为可变的，变量绑定实际上是常量。编译器会检查所有变量突变，并拒绝接受可变不可变变量绑定。
- en: If you come from one of the C family of languages, a non-mutable can be considered
    to be roughly the same as a `const` type.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自C语言家族之一，不可变可以被认为是与 `const` 类型大致相同。
- en: Creating a variable
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建变量
- en: 'To create a new variable binding in Rust, we use the following form:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中创建新的变量绑定，我们使用以下形式：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This means that we create a new variable binding called `x` whose content will
    be `1`. The default type for numbers depends on the situation a bit, but usually
    it''s a 32-bit signed integer. If we need a variable that can change, we use this
    form:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们创建了一个名为 `x` 的新变量绑定，其内容将是 `1`。数字的默认类型取决于具体情况，但通常是一个32位有符号整数。如果我们需要一个可以改变的变量，我们使用以下形式：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By default, all variables in Rust are non-mutable; therefore, we have to explicitly
    define a variable as being mutable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Rust中的所有变量都是不可变的；因此，我们必须明确地将变量定义为可变的。
- en: How can we tell the compiler that we want x to be an int?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何让编译器知道我们想让 `x` 是一个整型？
- en: 'Rust has a way of informing both the compiler and the developer of the variable
    type. For example, for a 32-bit `int`, we would use the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有一种方式可以通知编译器和开发者变量类型。例如，对于32位的 `int`，我们会使用以下形式：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In other words, `x` = `1`, a 32-bit signed `int`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`x` = `1`，一个32位有符号的 `int`。
- en: If a variable is defined without the `i32` (or any other value), the compiler
    will decide the type depending on how the value is used, defaulting to `i32`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有定义 `i32`（或任何其他值），编译器将根据值的用法决定类型，默认为 `i32`。
- en: Defining other variable types
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义其他变量类型
- en: Other variable types can be declared in the same way as `int` variables.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其他变量类型可以像 `int` 变量一样声明。
- en: Float
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数
- en: 'Much as with other languages, floating point arithmetic can be performed in
    Rust. As with an integer variable, a floating point variable is defined for a
    32-bit `float` as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言一样，在Rust中可以执行浮点运算。与整型变量一样，浮点型变量定义为32位 `float` 如下：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For a 64-bit `float`, it will be defined as this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于64位的 `float`，它将被定义为如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The variables are literal values. Another way to declare the size would be
    via types:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是字面值。另一种声明大小的方式是通过类型：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If a type is omitted (for example, let `x` = `3.14`), the variable will be declared
    as a 64-bit floating point variable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了类型（例如，let `x` = `3.14`），变量将被声明为64位浮点变量。
- en: Signed and unsigned integers
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有符号和无符号整数
- en: 'A signed `int` (one that can have positive or negative values) is defined like
    this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有符号的 `int`（可以具有正负值）的定义如下：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An unsigned `int` has a `u` instead of `i` in the definition:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号的 `int` 在定义中用 `u` 代替 `i`：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, these are number literals, and the same declaration can be made via
    types:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些是数字字面量，可以通过类型进行相同的声明：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Both signed and unsigned `int` values can be 8, 16, 32, or 64-bits long.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号和无符号的 `int` 值可以是8、16、32或64位长。
- en: Const and static
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量和静态
- en: 'Rust has two types of constants: **consts** and **statics**. Consts are sort
    of like aliases: their contents are sort of replaced on the place where they are
    used. The syntax is like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有两种类型的常量：**const**和**static**。Const有点像别名：它们的内含在它们被使用的地方被替换。语法如下：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Statics are more like variables. They have a global scope of the program, and
    are defined as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量更像是变量。它们具有程序的全球作用域，并且如下定义：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: They cannot be altered.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不能被更改。
- en: Rust is able to guess the types of local function variables. This is called
    **local type inference**. However, it is only local, so types of statics and consts
    must always be typed out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Rust能够猜测局部函数变量的类型。这被称为**局部类型推断**。然而，它只是局部的，所以静态和常量的类型必须始终显式指定。
- en: Defining the variable value before use
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用前定义变量值
- en: While it is not enforced in some languages, a variable must have an initial
    value in Rust, even if it is zero. This is good practice, and also helps when
    it comes to debugging since all variables have known contents. If they didn't,
    there'd be a risk of undefined behavior.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些语言中这不是强制性的，但在Rust中，变量必须有一个初始值，即使它是零。这是一个好习惯，也有助于调试，因为所有变量都有已知的内容。如果没有，就存在未定义行为的风险。
- en: Undefined behavior means that what the program does is anyone's guess. For instance,
    if variables did not have initial values, their values would be whatever happens
    to be in memory at the time that the value is allocated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义行为意味着程序执行的动作是任何人都可以猜测的。例如，如果变量没有初始值，它们的值将是分配值时内存中任意的内容。
- en: Strings
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Typically, a string can be defined in one of two ways:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，字符串可以通过两种方式之一来定义：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is known as a **string slice**. These will be dealt with in a while.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**字符串切片**。这些将在稍后处理。
- en: The second way is to use `String::new();`. This is a String, with a capital
    S. It is allocated in the heap and can grow dynamically.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是使用`String::new();`。这是一个字符串，首字母大写S。它在堆上分配，并且可以动态增长。
- en: At this point, it would be a good idea to break with the current narrative and
    discuss how Rust uses memory, as it will help greatly with explaining a number
    of upcoming topics.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，打破当前的叙述并讨论Rust如何使用内存是个好主意，因为它将极大地帮助解释即将到来的许多主题。
- en: How Rust uses memory
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust如何使用内存
- en: 'The memory occupied by any Rust program is split into two distinct areas: the
    heap and the stack. Simply put, the stack contains primitive variables, while
    the heap stores complex types. As with the mess on my daughter''s bedroom floor,
    a heap can grow and grow until the available memory is exhausted. The stack is
    faster and simpler but may not grow without limits. Every binding in Rust is in
    a stack, but those bindings may refer to things in the heap, and elsewhere.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Rust程序占用的内存分为两个不同的区域：堆和栈。简单来说，栈包含原始变量，而堆存储复杂类型。就像我女儿卧室地板上的混乱一样，堆可以不断增长，直到可用内存耗尽。栈更快、更简单，但可能不会无限增长。Rust中的每个绑定都在栈上，但这些绑定可能指向堆或其他地方的东西。
- en: This all relates directly to the string example. The binding `myName` is in
    the stack, and refers to a literal static string, *my name*. That string being
    static means that it is somewhere in memory when the program starts. Its being
    static also means that it cannot be changed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都直接与字符串示例相关。绑定`myName`在栈上，并引用一个字面量静态字符串`*my name*`。这个字符串是静态的，意味着它在程序开始时就在内存中。它也是静态的，这意味着它不能被改变。
- en: '`String::new`, on the other hand, creates a String in the heap. It is initially
    empty, but may grow to fill the whole virtual memory space.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`String::new`另一方面，在堆上创建一个字符串。它最初是空的，但可能增长以填充整个虚拟内存空间。'
- en: 'Here is an example of a growing String:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个正在增长的字符串的例子：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One of the ways of creating Strings is to call the `to_owned` method on a string
    slice, like we have just done. There are other ways, but this is the most recommended
    one because it underlines the ownership issue. We'll get back to that later.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字符串的一种方法是在字符串切片上调用`to_owned`方法，就像我们刚才做的那样。还有其他方法，但这是最推荐的一种，因为它强调了所有权问题。我们稍后会回到这个问题。
- en: Here, the binding `myStringOne` starts out at 24 characters long, and would
    be allocated at least that size on the heap. The binding `myStringOne` is actually
    a reference to the position on the heap where `myStringOne` lives.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，绑定`myStringOne`最初是24个字符长，并且至少会在堆上分配那么大的空间。绑定`myStringOne`实际上是`myStringOne`在堆上位置的引用。
- en: As we add to `myStringOne`, the size it occupies on the heap increases; however,
    the reference to the base position remains the same.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向`myStringOne`添加内容时，它在堆上占用的空间会增加；然而，对基本位置的引用保持不变。
- en: The lifetime and scope of a variable have to be taken into account. For example,
    if we define a string within part of a function, and then try and access the string
    outside the function, we get a compiler error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的生命周期和作用域必须考虑。例如，如果我们在一个函数的部分定义了一个字符串，然后尝试在函数外部访问这个字符串，我们会得到编译器错误。
- en: Back to Strings
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到字符串
- en: 'As we saw before diverting onto the heap and stack, we can also define a string
    like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在堆和栈上看到的，我们也可以这样定义一个字符串：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `String::` tells the compiler that we are going to use the standard library,
    `String`, and we tell the program that we are going to create a mutable String
    and store a reference to it on the stack in something called `myString`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`String::`告诉编译器我们将使用标准库中的`String`，我们告诉程序我们将创建一个可变的字符串，并在名为`myString`的地方将其引用存储在栈上。'
- en: 'The dynamic string can be created as either being empty, or with memory preallocated
    to it. For example, say we want to store the words *You''ll never walk alone* (a
    total of 23 bytes), preallocating the space for them. This is how to do it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 动态字符串可以创建为空，或者预先为其分配内存。例如，如果我们想存储单词*You'll never walk alone*（总共23个字节），预先为它们分配空间。这是如何做的：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is just a performance optimization and is not typically required, since
    Strings grow automatically when they need to. The following does roughly the same
    job:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个性能优化，通常不是必需的，因为当字符串需要增长时，它们会自动增长。以下做了大致相同的工作：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Rust strings are not null-terminated, and consist entirely of valid Unicode.
    Therefore, they can contain null bytes and characters from any language, but they
    may require more bytes than they contain characters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Rust字符串不是以空字符终止的，完全由有效的Unicode组成。因此，它们可以包含空字节和任何语言的字符，但它们可能需要的字节数比它们包含的字符数多。
- en: String slices
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串切片
- en: 'String slices can be confusing at first sight. We define a string slice like
    this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串切片一开始可能会让人感到困惑。我们这样定义一个字符串切片：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Coming from more dynamic languages, you might think that we are assigning the
    string `Liverpool` to the variable binding `homeTeam`. That''s not exactly what
    happens, however. The `homeTeam` binding is actually a string slice: a reference
    to a part of the string that actually resides somewhere else.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 来自更动态的语言，你可能会认为我们在将字符串`Liverpool`赋值给变量绑定`homeTeam`。然而，实际情况并非如此。`homeTeam`绑定实际上是一个字符串切片：一个指向字符串某一部分的引用，而这个字符串实际上位于别处。
- en: The string slice is also not mutable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串切片也不是可变的。
- en: 'The following will not work in Rust:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下在Rust中是不行的：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The compiler will not allow this, and will give an error as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不会允许这样做，并且会给出如下错误：
- en: '![](img/00020.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: We cannot concatenate the slice directly, since string slices cannot be mutable.
    To do that, we need to first convert the string slice into something that is mutable,
    or build the string with something like the `format!` macro. Let's try them both.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接连接字符串切片，因为字符串切片是不可变的。为了做到这一点，我们首先需要将字符串切片转换成可变的东西，或者使用类似`format!`宏的方式来构建字符串。让我们都试一试。
- en: 'Like before, the `to_owned()` method takes the slice the method is attached
    to, and converts it to a `String` type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，`to_owned()`方法接受方法附加到的切片，并将其转换为`String`类型：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `to_owned()` method is only applied to the first slice. This converts the
    string slice `homeTeam` into a String, and using the `+` operator on a String
    is fine.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_owned()`方法只应用于第一个切片。这把字符串切片`homeTeam`转换成String，在String上使用`+`操作符是可行的。'
- en: 'When this is built and executed, you will see the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建并执行时，你会看到以下内容：
- en: '![](img/00021.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: What's with the warnings?
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这些警告是什么意思？
- en: The recommended format that Rust uses is snake case (rather than CamelCase).
    The warnings can be removed if we change the variable name from `homeTeam` to
    `home_team`. It's not fatal, or likely to cause the program to go on a homicidal
    rampage; it's more of a style issue.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Rust推荐使用的格式是蛇形命名法（而不是驼峰命名法）。如果我们把变量名从`homeTeam`改为`home_team`，就可以移除警告。这并不是致命的，或者不太可能导致程序进行杀戮性的狂暴；这更多的是一个风格问题。
- en: Using the format! macro
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`format!`宏
- en: 'The `format!` macro works in a way similar to string formatters in other languages:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`format!`宏的工作方式与其他语言的字符串格式化器类似：'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `{}` in the format strings mark spots for the following parameters. The
    spots are filled in order, so `full_line` will be a concatenation of `home_team`,
    `result`, and `away_team`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串中的`{}`标记了后续参数的位置。这些位置按顺序填充，因此`full_line`将是`home_team`、`result`和`away_team`的连接。
- en: 'When the preceding code snippet is compiled and executed, you will see the
    following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述代码片段编译并执行时，你会看到以下内容：
- en: '![](img/00022.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: Building a string
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建字符串
- en: We've seen that we can create a String from a string slice (using `to_owned()`
    or the `format!` macro), or we can create it using `String::new()`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以从字符串切片（使用`to_owned()`或`format!`宏）创建一个String，或者我们可以使用`String::new()`创建它。
- en: 'There are two further ways to help build the string: `push` adds a single character
    to the string, and `push_str` adds an `str` to the string.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种进一步的方法可以帮助构建字符串：`push`向字符串添加单个字符，而`push_str`向字符串添加一个`str`。
- en: 'The following shows this in action:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了这一过程：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When this last code snippet is compiled and executed, you will see this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段最后代码编译并执行时，你会看到以下内容：
- en: '![](img/00023.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: Code review
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查
- en: The preceding code is somewhat different from the code in previous examples
    where we have simply used `to_owned()` to convert the slice to a string. We now
    have to create a mutable string and assign to that rather than just add to the
    end of `full_line` as we did previously.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与之前示例中的代码略有不同，我们之前只是简单地使用`to_owned()`将切片转换为字符串。我们现在必须创建一个可变字符串并将其分配给该字符串，而不是像之前那样只添加到`full_line`的末尾。
- en: The reason is that the slice being converted to string is not mutable; therefore,
    the type created will also be non-mutable. Since you cannot add to a non-mutable
    variable, we could not use the `push` and `push_str` methods.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是正在转换为字符串的切片不是可变的；因此，创建的类型也将是非可变的。由于你不能向非可变变量添加内容，所以我们不能使用`push`和`push_str`方法。
- en: Casting
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投掷
- en: 'Rust allows for variables to be cast differently. This is achieved using the
    `as` keyword. This works in the same way as it does in C#:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Rust允许变量以不同的方式进行转换。这是通过使用`as`关键字实现的。这与C#中的用法相同：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also cast to a different type (for example, `float` to `int`):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将类型转换为其他类型（例如，`float`到`int`）：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, the effects of precision-losing casts like this one may not be desirable.
    For instance, if you cast a float that''s over the bit size of `i8` to `i8`, the
    number gets truncated to `0`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像这种精度丢失的投掷效果可能并不理想。例如，如果你将一个超过`i8`位大小的浮点数投掷到`i8`，数字会被截断为`0`：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'An error will occur if the types you are attempting to cast to are not compatible;
    for example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试转换的类型不兼容，将会发生错误；例如：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Rust does not do implicit casting between primitive types, even when it would
    be safe. That is, if a function expects an `i8` as a parameter, you must cast
    an `i16` value to `i8` before passing it. The reason for this is to achieve the
    maximum type checking and, therefore, reduce the number of potential (and more
    problematic) hidden bugs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Rust不会在原始类型之间进行隐式转换，即使这样做是安全的。也就是说，如果一个函数期望一个`i8`作为参数，你必须将`i16`值转换为`i8`然后再传递。这样做的原因是为了实现最大程度的类型检查，从而减少潜在（且更复杂）的隐藏错误数量。
- en: String methods
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串方法
- en: 'Strings are important in any language. Without them, it becomes difficult to
    communicate with users, and if data is coming from a web service (in the form
    of XML, plain text, or JSON), this data will need to be manipulated. Rust provides
    the developer with a number of methods in the standard library to deal with strings.
    Here''s a table of some useful methods (don''t worry about the types yet):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何语言中，字符串都很重要。没有它们，与用户的沟通变得困难，如果数据来自网络服务（以XML、纯文本或JSON的形式），则需要对这些数据进行操作。Rust为开发者提供了标准库中的许多方法来处理字符串。以下是一些有用方法的表格（现在不用担心类型）：
- en: '| **Method** | **What it does** | **Usage (or example project)** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **作用** | **用法（或示例项目）** |'
- en: '| `from(&str) -> String` | This method creates a new String from a string slice.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `from(&str) -> String` | 此方法从一个字符串切片创建一个新的String。 |'
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `from_utf8( Vec < u8 > ) -> Result<String, FromUtf8Error>` | This method
    creates a new string buffer from a valid vector of UTF-8 characters. It will fail
    if the vector contains non-UTF8 data. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `from_utf8(Vec<u8>) -> Result<String, FromUtf8Error>` | 此方法从一个有效的UTF-8字符向量创建一个新的字符串缓冲区。如果向量包含非UTF-8数据，它将失败。
    |'
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `with_capacity(usize) -> String` | This method preallocates a String with
    a number of bytes. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `with_capacity(usize) -> String` | 此方法预先分配一个具有指定字节数的String。 |'
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `as_bytes -> &[u8]` | This method outputs a String as a byte slice. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `as_bytes -> &[u8]` | 此方法将字符串输出为字节切片。|'
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `insert(usize, char)` | This method inserts `char` at position `index`. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `insert(usize, char)` | 此方法在位置 `index` 插入 `char`。|'
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `len -> usize` | This method returns the length of the String in bytes. It
    may therefore be larger than the number of characters in the String. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `len -> usize` | 此方法返回字符串的字节长度。因此，它可能大于字符串中的字符数。|'
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `is_empty -> bool` | This method returns `true` if the String is empty. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `is_empty -> bool` | 此方法返回 `true`，如果字符串为空。|'
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `is_char_boundary(usize) -> bool` | This method returns `true` if a character
    at `index` falls on a Unicode boundary. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `is_char_boundary(usize) -> bool` | 此方法返回 `true`，如果索引处的字符位于 Unicode 边界上。|'
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Generics and arrays
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型和数组
- en: 'For those coming from a C# or C++ background, you will no doubt be used to
    generic types (often referred to as having a type `T`); you will be used to seeing
    things like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自 C# 或 C++ 背景的人来说，无疑已经习惯了泛型类型（通常称为具有类型 `T`）；你会习惯看到如下内容：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Generics allow defining methods for several types. In its most general form,
    `T` means "any type." The following function, for instance, takes two arguments
    that can be any type `T`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许为几种类型定义方法。在其最一般的形式中，`T` 表示“任何类型”。例如，以下函数接受两个可以是任何类型 `T` 的参数：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`T`, as has been established, can be of any type. This means that we cannot
    do much with them, since only a few methods are implemented for "any type." For
    instance, if we would like to add these variables together, we would need to restrict
    the generic types somewhat. We would essentially need to tell Rust that "T may
    be of any type, as long as it implements addition." More about this later.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`，如前所述，可以是任何类型。这意味着我们无法对它们做太多，因为只有少数方法实现了“任何类型”。例如，如果我们想将这些变量相加，我们需要对泛型类型进行一些限制。我们本质上需要告诉
    Rust，“T 可以是任何类型，只要它实现了加法。”关于这一点稍后会有更多介绍。'
- en: Arrays
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays are simple to construct. For example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 数组易于构建。例如：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Arrays must comply with a number of rules, which are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 数组必须遵守一些规则，如下所示：
- en: The array has a fixed size. It can never grow as it is stored as a continuous
    memory block.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组具有固定的大小。它永远不会增长，因为它作为连续的内存块存储。
- en: The contents of the array can only ever be of one type.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的内容只能是单一类型。
- en: As with any type of variable, by default arrays are non-mutable. Even if the
    array is mutable, the overall size cannot be changed. For example, if an array
    has five elements, it cannot be changed to six.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何类型的变量一样，默认情况下数组是不可变的。即使数组是可变的，整体大小也不能改变。例如，如果一个数组有五个元素，它不能变成六个。
- en: 'We can also create an array with a type, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建具有类型的数组，如下所示：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It is also possible to create an array a number of times with the same value,
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过以下方式创建具有相同值的数组多次：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will create an array called `number` with `5` elements, all initialized
    to a value of `111`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `number` 的数组，包含 `5` 个元素，所有元素都初始化为值 `111`。
- en: Array performance
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组性能
- en: While arrays are useful, they do have a performance hit; as with most operations
    on an array, the Rust runtime will perform bound checks to ensure the program
    does not access the array out of bounds. This prevents classic array overflow
    attacks and bugs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组很有用，但它们确实有性能损失；与数组上的大多数操作一样，Rust 运行时会执行边界检查以确保程序不会访问数组越界。这防止了经典的数组溢出攻击和错误。
- en: Vectors
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: 'While arrays are simple to use, they have a single big disadvantage: they cannot
    be resized. The vector (`Vec`) acts in a way similar to a `List` in C#. It is
    also a generic type, as `Vec` itself is actually `Vec<T>`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组易于使用，但它们有一个很大的缺点：它们不能调整大小。向量（`Vec`）的行为类似于 C# 中的 `List`。它也是一个泛型类型，因为 `Vec`
    本身实际上是 `Vec<T>`。
- en: The `Vec` type is found in the standard library (`std::vec`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec` 类型位于标准库中（`std::vec`）。'
- en: 'To create a vector, we use something akin to either of the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建向量时，我们使用类似于以下任一的方法：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `f32` within the `Vec` macro tells the compiler that the type for the vector
    is `f32`. The `f32` can be omitted, as the compiler can determine the type for
    the vector.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec` 宏中的 `f32` 告诉编译器向量的类型是 `f32`。`f32` 可以省略，因为编译器可以确定向量的类型。'
- en: Creating a vector with an initial size
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有初始大小的向量
- en: 'As with a String, it is possible to create a vector with an initial allocation
    of memory, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串一样，可以创建一个具有初始内存分配的向量，如下所示：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Creating a vector via an iterator
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过迭代器创建向量
- en: 'Another way to create a vector is via an iterator. This is achieved via the
    `collect()` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建向量的另一种方法是使用迭代器。这是通过`collect()`方法实现的：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The format for the iterator is very convenient. Instead of the likes of `let
    foo = {0,1,2,3};`, this is shortened to use `..`, which means all numbers between
    *a* and *b* (*b* being excluded - so `0 .. 10` creates a vector containing 0,1,2,3,4,5,6,7,8,9).
    This can be seen in the source example supplied with this book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的格式非常方便。与`let foo = {0,1,2,3};`这样的类似，这被缩短为使用`..`，这意味着所有在*a*和*b*之间的数字（*b*被排除
    - 因此`0 .. 10`创建一个包含0,1,2,3,4,5,6,7,8,9的向量）。这可以在本书提供的源示例中看到。
- en: Adding and removing from the vector
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量中添加和删除元素
- en: 'In a similar fashion to string, it is possible to add and remove from the vector
    list using the `push` and `pull` methods. These add or remove from the top of
    the vector stack. Consider the following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于字符串，可以使用`push`和`pull`方法向向量列表中添加和删除元素。这些方法从向量栈的顶部添加或删除。考虑以下示例：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We create the vector list with values from 0 going up to 10 (so the last value
    is 9).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用从0开始到10（因此最后一个值是9）的值创建向量列表。
- en: The line `println!("{:?}", my_vec);` outputs the entire contents of `my_vec`.
    `{:?}` is required here due to the type `Vec<i32>` not implementing certain formatting
    functionalities.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 行`println!("{:?}", my_vec);`输出`my_vec`的全部内容。`{:?}`在这里是必需的，因为`Vec<i32>`没有实现某些格式化功能。
- en: We then push onto the top of the vector list 13 then 21, display the output
    on the screen, and then remove the top-most value on the vector list, and output
    it again.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在向量列表的顶部添加13和21，显示输出，然后从向量列表中移除最顶部的值，再次输出。
- en: Manipulating an array or vector via slices
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过切片操作数组或向量
- en: Both arrays and vectors can be accessed using a value (such as `my_vec[4]`).
    However, if you want to manipulate a section of the array, then you would take
    a slice from the array. A slice is like a window to a part of the original thing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和向量都可以使用一个值（如`my_vec[4]`）来访问。然而，如果你想操作数组的一部分，那么你将从一个数组中取一个切片。切片就像是对原始事物一部分的窗口。
- en: 'To create a slice, use this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个切片，使用以下方法：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A slice also has no predefined size: it can be 2 bytes, or it can be 202 bytes.
    Due to this, the size of the slice is not known at compile time. This is important
    to know, because it prevents certain methods from working.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 切片也没有预定义的大小：它可以是2字节，也可以是202字节。因此，切片的大小在编译时是未知的。这一点很重要，因为它阻止了某些方法的工作。
- en: Passing values around
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递值
- en: Up to this point, we have kept everything within a single method. For small
    demonstrations (or for method testing), this is fine. However, for larger applications,
    passing values between methods is essential.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在单个方法内保持一切。对于小型演示（或方法测试），这是可以的。然而，对于更大的应用程序，方法之间传递值是必不可少的。
- en: 'Rust has two main ways to pass information to other methods: by reference or
    by value. Passing by reference usually implies borrowing, which means that ownership
    is only temporarily given and can be used again after the function call. Passing
    by value implies either a permanent ownership change, which means that the caller
    of a function can no longer access the value, or it might imply copying the data.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有两种主要方式将信息传递给其他方法：通过引用或通过值。通过引用通常意味着借用，这意味着所有权只是暂时性地给出，函数调用后可以再次使用。通过值意味着所有权的永久性改变，这意味着函数的调用者将无法访问该值，或者它可能意味着复制数据。
- en: Passing by value
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过值传递
- en: 'The following code shows how to pass a number between two functions, and to
    receive a result:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何在两个函数之间传递一个数字，并接收一个结果：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s have a look at the receiving function''s definition line:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看接收函数的定义行：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As with any programming language, we have to give the function a name, and then
    a parameter list. The parameter names are followed by a colon and the type of
    the parameter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何编程语言一样，我们必须给函数一个名字，然后是一个参数列表。参数名称后面跟着一个冒号和参数的类型。
- en: Our function returns a value (this is signified by the `->` symbol) of a particular
    type (in this case, `i32`). The last evaluated thing in the function will be returned
    from the function, provided that you don't accidentally put a semi-colon there.
    An implicit return statement also exists, but it's not required and it's usually
    better style to omit it if possible.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能返回一个特定类型的值（在这种情况下，`i32`）。只要你不意外地在那里放置分号，函数中最后评估的内容将从函数返回。隐式返回语句也存在，但它不是必需的，如果可能的话，通常更好的风格是省略它。
- en: 'When built and run, you will see the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行后，你会看到以下内容：
- en: '![](img/00024.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00024.jpeg)'
- en: Passing by reference
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过引用传递
- en: 'A variable passed by a reference looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递的变量看起来是这样的：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We take two variables as references, and return a value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个变量作为引用，并返回一个值。
- en: 'To obtain a value from a reference, the first thing to do is dereference it.
    This is done with the asterisk (`*`) operator:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要从引用中获取值，首先要做的就是取消引用。这是通过星号（`*`）操作符完成的：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The reference type
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'A reference is written in one of three ways: `&`, `ref`, or `ref mut`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 引用可以以三种方式之一书写：`&`、`ref` 或 `ref mut`：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The references are all equivalent here. Note, however, that the preceding code
    doesn't work as it is due to mutable reference rules. Rust allows several immutable
    reference to a thing, but if a mutable reference is taken, no other references
    may exist at the time. Therefore, the last line would not work, since there are
    already two active references to var.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的引用都是等效的。然而，请注意，前面的代码由于可变引用规则而无法正常工作。Rust 允许多个不可变引用指向一个东西，但如果取了可变引用，则在此期间不能存在其他引用。因此，最后一行将不会工作，因为已经有两个活跃的引用指向
    var。
- en: A practical example
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实际例子
- en: 'In the example code, `matrix`, we can see how to use a 2D array and how to
    pass by a reference, with the receiving function calculating the result of a matrix
    multiplication. Let''s examine the code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码 `matrix` 中，我们可以看到如何使用二维数组以及如何通过引用传递，接收函数计算矩阵乘法的结果。让我们来检查一下代码：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When compiled, you will get the following output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，你会得到以下输出：
- en: '![](img/00025.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00025.jpeg)'
- en: 'What we need to really consider here is the definition line for the `matrix_multiply`
    function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里真正需要考虑的是 `matrix_multiply` 函数的定义行：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you recall how we told a function the name of the variable and the type
    earlier, we said it was `variable_name: variable_type`. The preceding line may
    look very much different, but it really isn''t:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你还记得我们之前是如何告诉函数变量名和类型的，我们说它是 `variable_name: variable_type`。前面的行可能看起来非常不同，但实际上并不是：'
- en: '![](img/00026.gif)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00026.gif)'
- en: 'We are passing in a reference to a holding array, which holds references to
    other arrays. The array is defined using `[i32;4]`; therefore, the reference is
    `&[i32;4]`. This is the inner array. The outer array `[i32;4]` is also a reference
    (`&[i32;4]`), which has a size of 4\. Therefore, when we put these together, we
    have the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在传递一个持有数组的引用，该数组持有其他数组的引用。数组使用 `[i32;4]` 定义；因此，引用是 `&[i32;4]`。这是内部数组。外部数组
    `[i32;4]` 也是一个引用（`&[i32;4]`），大小为 4。因此，当我们把它们放在一起时，我们就有以下内容：
- en: '![](img/00027.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00027.jpeg)'
- en: The preceding example shows how to pass by a reference quite nicely, though
    in reality, it is most likely that the compiler will optimize this out to something
    faster for such a small data sample. It does show, however, how it's done.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子很好地展示了如何通过引用传递，尽管在现实中，编译器很可能会优化这个小数据样本，使其运行更快。然而，它确实展示了如何操作。
- en: The golden rule is that what you send over to the function has to marry up with
    what the function is expecting.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 金规则是，你发送给函数的内容必须与函数期望的内容相匹配。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a great deal in this chapter, and I really encourage you to
    play around creating functions and passing values around.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量的内容，我真心鼓励你尝试创建函数并传递值。
- en: If you don't want to continually create new projects every time you create a
    new application, you can create and test your code on the Rust Playground website
    ([https://play.rust-lang.org](https://play.rust-lang.org)). Here you can enter
    your code, hit Run, and see instantly if what you have written works.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想每次创建新应用程序时都不断创建新项目，你可以在 Rust Playground 网站上创建和测试你的代码（[https://play.rust-lang.org](https://play.rust-lang.org)）。在这里，你可以输入你的代码，点击运行，立即查看你所写的内容是否有效。
- en: In the next chapter, we will be covering getting information in and out, and
    validating your entries.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何获取信息，以及验证你的输入。
