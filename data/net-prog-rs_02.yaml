- en: Introduction to Rust and its Ecosystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust及其生态系统的介绍
- en: The Rust programming language is sponsored by Mozilla and supported by a community
    of developers from across the globe. Rust is promoted as a systems programming
    language that supports automatic memory management without the overhead of a runtime
    or a garbage collector, concurrency without data races enforced by the compiler,
    and zero cost abstractions and generics. In subsequent sections, we will discuss
    these features in more detail. Rust is statically typed and borrows a number of
    functional programming ideas. A fascinating aspect of Rust is the use of the type
    system to guarantee memory safety without using a runtime. This makes Rust uniquely
    suitable for low-resource embedded devices and real-time systems, which require
    strong guarantees around code correctness. On the flip side, this often means
    that the compiler has to do a lot more work to ensure syntactical correctness
    and then translate source code, resulting in higher build times. While the community
    is working on methods to reduce compile time as much as possible, this is still
    an important issue encountered by a lot of developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust编程语言由Mozilla赞助，并得到全球开发者社区的支持。Rust被推广为一种支持自动内存管理（无需运行时或垃圾收集器开销）、无数据竞争的并发（由编译器强制执行）以及零成本抽象和泛型的系统编程语言。在随后的章节中，我们将更详细地讨论这些特性。Rust是静态类型，并借鉴了许多函数式编程思想。Rust的一个迷人之处在于，它使用类型系统来保证内存安全，而不使用运行时。这使得Rust特别适合低资源嵌入式设备和实时系统，这些系统需要对代码正确性提供强有力的保证。另一方面，这通常意味着编译器必须做更多的工作来确保语法正确性，然后翻译源代码，从而导致构建时间更长。尽管社区正在努力尽可能减少编译时间，但这仍然是许多开发者遇到的一个重要问题。
- en: The **Low Level Virtual Machine** (**LLVM**) project started as a university
    research project aimed at developing a set of tools for building compilers that
    can generate machine code for a range of CPU architectures. This was achieved
    using the **LLVM intermediate representation** (**LLVM IR**). The toolchain can
    compile any higher-level language to LLVM IR, which can then be targeted for a
    given CPU. The Rust compiler depends heavily on the LLVM project for interoperability,
    using it as a backend. It actually translates Rust code into LLVM's intermediate
    representation and optimizes it as necessary. LLVM then translates that into machine
    code for the specific platform, which gets run on the CPU.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**低级虚拟机**（**LLVM**）项目最初是一个大学研究项目，旨在开发一套构建编译器的工具，这些编译器可以为一系列CPU架构生成机器代码。这是通过使用**LLVM中间表示**（**LLVM
    IR**）实现的。工具链可以将任何高级语言编译成LLVM IR，然后针对特定的CPU进行编译。Rust编译器严重依赖于LLVM项目以实现互操作性，将其用作后端。它实际上将Rust代码翻译成LLVM的中间表示，并根据需要进行优化。然后LLVM将其转换为特定平台的机器代码，该代码在CPU上运行。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to the ecosystem and how Rust works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生态系统介绍和Rust的工作原理
- en: Installing Rust and setting up the toolchain
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Rust和设置工具链
- en: An introduction to its major features, starting from the borrow checker and
    how ownership works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从借用检查器和所有权的工作原理开始，介绍其主要特性
- en: Generics and how the trait system works with the ownership model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型和如何与所有权模型一起工作的特质系统
- en: Error handling and the macro system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理和宏系统
- en: Concurrency primitives
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发原语
- en: Testing primitives
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试原语
- en: Note that this chapter is a very high-level overview of the language and some
    of its most distinctive features, not a deep dive.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章是对语言及其一些最显著特性的非常高级概述，而不是深入探讨。
- en: The Rust ecosystem
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust生态系统
- en: 'The success or failure of an open source project is often determined by the
    strength of the community around it. Having a coherent ecosystem helps in building
    a strong community. Since Rust is primarily driven by Mozilla, they have been
    able to build a strong ecosystem around it, the primary components being:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开源项目的成功或失败往往取决于其周围社区的强度。拥有一个连贯的生态系统有助于构建一个强大的社区。由于Rust主要由Mozilla推动，因此他们能够围绕它构建一个强大的生态系统，主要组成部分包括：
- en: 'Source code: Rust hosts all the source code in GitHub. Developers are encouraged
    to report bugs and submit pull requests in there. At the time of writing, the
    Rust repository on GitHub has 1,868 unique contributors, over 2,700 open bug reports,
    and 90 open pull requests. The core Rust team is composed of Mozilla employees
    and contributors from other organizations (like Google, Baidu, and so on). The
    team uses GitHub for all collaborations; even major changes to any component have
    to be first proposed by writing a **Request For Comments** (**RFC**). This way,
    everyone has a chance to take a look at it and collaborate on improving it. Once
    it is approved, the actual change can be implemented.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码：Rust 在 GitHub 上托管所有源代码。开发者被鼓励在 GitHub 上报告错误和提交拉取请求。在撰写本书时，GitHub 上的 Rust
    仓库有 1,868 个独特的贡献者，超过 2,700 个开放的错误报告和 90 个开放的拉取请求。Rust 的核心团队由 Mozilla 员工和其他组织（如
    Google、百度等）的贡献者组成。团队使用 GitHub 进行所有协作；即使是任何组件的重大更改，也必须首先通过撰写 **请求评论**（**RFC**）来提出。这样，每个人都有机会查看它并协作改进它。一旦获得批准，实际更改就可以实施。
- en: 'Compiler: The Rust compiler is named *rustc.* Since Rust follows semantic versioning
    for compiler releases, there cannot be any backward incompatible breaking changes
    between minor releases. At the time of writing this book, the compiler has already
    reached version 1.0, thus it can be assumed that there will not be any breaking
    changes till version 2.0\. Note that breaking changes do slip once in a while.
    But in all those cases, they are treated as bugs and fixed as soon as possible.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器：Rust 编译器的名称为 *rustc*。由于 Rust 对编译器版本采用语义版本控制，因此在小版本之间不可能有任何向后不兼容的破坏性更改。在撰写本书时，编译器已经达到
    1.0 版本，因此可以假设在 2.0 版本之前不会有任何破坏性更改。请注意，偶尔确实会有破坏性更改发生。但在所有这些情况下，它们都被视为错误，并尽快修复。
- en: To facilitate adding new compiler features without breaking existing dependent
    libraries, Rust releases new compiler versions in stages. At any point, three
    different versions of the compiler (and the standard library) are maintained.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不破坏现有依赖库的情况下方便添加新的编译器功能，Rust 以阶段的方式发布新的编译器版本。在任何时候，都维护着三个不同的编译器版本（以及标准库）。
- en: The first one is called **nightly**. As the name implies, it is built each night
    from the tip of the source tree. Since this is only tested by unit and integration
    tests, this release often has more bugs in the real world.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个版本被称为 **nightly**。正如其名所示，它每晚从源代码树的顶端构建。由于这个版本只经过单元和集成测试，因此在现实世界中通常会有更多错误。
- en: The second stage is **beta**, which is a planned release. By the time a nightly
    has reached this stage, it has gone through multiple rounds of unit, integration,
    and regression testing. Additionally, the community has had the time to use it
    in real projects and share feedback with the Rust team.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二阶段是 **beta**，这是一个计划中的发布版本。当一个夜间版本达到这个阶段时，它已经经过了多次单元、集成和回归测试。此外，社区也有时间在实际项目中使用它并与
    Rust 团队分享反馈。
- en: Once everyone is confident about the release, it is tagged as a **stable** release
    and pushed out. Since the compiler supports a variety of platforms (from Windows
    to Redox) and architectures (amd64), each release has pre-built binaries for all
    combinations of platforms and architectures.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦每个人都对发布版本有信心，它就会被标记为 **稳定** 版本并发布。由于编译器支持各种平台（从 Windows 到 Redox）和各种架构（amd64），每个版本都为所有平台和架构的组合提供了预构建的二进制文件。
- en: 'Installation mechanism: The community supported installation mechanism is via
    a tool called *rustup. *This tool can install a given version of Rust along with
    everything needed to use it (including the compiler, standard library, package
    manager, and so on).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装机制：社区支持的安装机制是通过一个名为 *rustup* 的工具。这个工具可以安装指定版本的 Rust 以及使用它所需的所有内容（包括编译器、标准库、包管理器等）。
- en: 'Package manager: Rust''s package manager is called *Cargo, *while individual
    packages are called *crates*. All external libraries and applications can be packaged
    in a crate and published using the Cargo CLI tool. A user can then use it to search
    for and install packages. All crates can be searched using the following website: [https://crates.io/](https://crates.io/).
    For all packages hosted on *crates.io*, the corresponding documentation is available
    at: [https://docs.rs/](https://docs.rs/).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包管理器：Rust 的包管理器称为 *Cargo*，而单个包称为 *crates*。所有外部库和应用程序都可以打包成一个 crate，并使用 Cargo
    CLI 工具发布。用户可以使用它来搜索和安装包。所有 crate 都可以使用以下网站进行搜索：[https://crates.io/](https://crates.io/)。对于所有托管在
    *crates.io* 上的包，相应的文档可在：[https://docs.rs/](https://docs.rs/) 上找到。
- en: Getting started with Rust
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust入门
- en: The Rust toolchain installer is available at: [https://www.rustup.rs/](https://www.rustup.rs/).
    The following commands will install all three versions of the toolchain on a system.
    For the examples in this book, we will use a Linux machine running Ubuntu 16.04\.
    While most of Rust should not depend on the OS, there can be minor differences.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rust工具链安装程序可在[https://www.rustup.rs/](https://www.rustup.rs/)找到。以下命令将在系统上安装工具链的所有三个版本。对于本书中的示例，我们将使用运行Ubuntu
    16.04的Linux机器。虽然Rust的大部分内容不应依赖于操作系统，但可能会有一些细微的差异。
- en: 'We will point out any strict dependencies on the OS:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指出对操作系统的任何严格依赖：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will need to put Cargo''s bin directory to our **PATH** by editing **.bashrc**.
    Run the following to do that:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过编辑**.bashrc**将Cargo的bin目录添加到我们的**PATH**中。运行以下命令来完成此操作：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A Rust installation comes with a lot of documentation built in; they can be
    accessed by running the following command. This should open up the documentation
    in a browser window:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的安装自带了大量内置文档；可以通过运行以下命令来访问它们。这应该在浏览器窗口中打开文档：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is to set up a Rust project and run it, all using Cargo:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置Rust项目并运行它，全部使用Cargo：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This tells Cargo to set up a new project called `hello-rust` in the current
    directory. Cargo will create a directory of that name and set up the basic structure.
    Since the type of this project is set to be a binary, Cargo will generate a file
    called `main.rs` which will have an empty `main` function, the entry point for
    the application. The other (default) option here is that of a library, in this
    case, a file named `lib.rs` will be generated. The file named `Cargo.``toml` has
    a bunch of metadata for the current project and is used by Cargo. All source code
    is located in the `src` directory:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Cargo在当前目录下设置一个名为`hello-rust`的新项目。Cargo将创建一个同名目录并设置基本结构。由于此项目的类型被设置为二进制，Cargo将生成一个名为`main.rs`的文件，该文件将包含一个空的`main`函数，这是应用程序的入口点。这里的另一个（默认）选项是库，在这种情况下，将生成一个名为`lib.rs`的文件。名为`Cargo.toml`的文件包含当前项目的元数据，并由Cargo使用。所有源代码都位于`src`目录中：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The project can then be built and run using the following command. Note that
    this command should be run from the `hello-rust` directory that Cargo created
    previously:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用以下命令构建和运行项目。请注意，此命令应在Cargo之前创建的`hello-rust`目录中运行：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Interestingly, this command modifies the directory quite a bit. The `target`
    directory contains compilation artifacts. The structure of this is heavily platform
    dependent, but always includes everything necessary to run the application in
    the given build mode. The default build mode is `debug`, which includes debugging
    information and symbols to be used with a debugger:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，此命令对目录进行了相当大的修改。`target`目录包含编译工件。其结构高度依赖于平台，但始终包括在给定构建模式下运行应用程序所需的所有内容。默认构建模式是`debug`，它包括用于调试器的调试信息和符号：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Rust, each application must have a single entry point called `main`, which
    should be defined as a function that does not take in parameters. Functions are
    defined using the `fn` keyword. The phrase `extern crate term` tells the toolchain
    that we want to use an external crate as a dependency of our current application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，每个应用程序都必须有一个名为`main`的单个入口点，该入口点应定义为不带参数的函数。函数使用`fn`关键字定义。短语`extern crate
    term`告诉工具链我们想要将外部crate作为当前应用程序的依赖项。
- en: 'Now, we can run it using Cargo. It automatically downloads and builds the library
    we need and all of its dependencies. Finally, it calls the Rust compiler so that
    our application is linked with the library and runs the executable. Cargo also
    generates a file called `Cargo.lock` that has a snapshot of everything needed
    to run the application in a consistent manner. This file should never be edited
    manually. Since cargo caches all dependencies locally, subsequent invocations
    do not need internet access:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用Cargo运行它。它将自动下载和构建所需的库及其所有依赖项。最后，它调用Rust编译器，以便我们的应用程序与库链接并运行可执行文件。Cargo还生成一个名为`Cargo.lock`的文件，该文件包含以一致方式运行应用程序所需的所有内容的快照。此文件不应手动编辑。由于cargo在本地缓存所有依赖项，后续调用不需要互联网访问：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Introduction to the borrow checker
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用检查器简介
- en: 'The most important aspect of Rust is the ownership and borrowing model. Based
    on the strict enforcing of borrowing rules, the compiler can guarantee memory
    safety without an external garbage collector. This is done by the borrow checker,
    a subsystem of the compiler. By definition, every resource created has a lifetime
    and an owner associated with it, which operates under the following rules:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Rust最重要的方面是所有权和借用模型。基于对借用规则的严格执行，编译器可以在没有外部垃圾收集器的情况下保证内存安全。这是通过借用检查器完成的，它是编译器的一个子系统。根据定义，每个创建的资源都有一个生命周期和与之关联的所有者，它遵循以下规则：
- en: Each resource has exactly one owner at any point in time. By default, the owner
    is the variable that created that resource, and its lifetime is the lifetime of
    the enclosing scope. Others can borrow or copy the resource if they need to. Note
    that a resource can be anything from a variable or a function. A function takes
    ownership of a resource from its caller; returning from the function transfers
    back ownership.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时间点，每个资源都恰好有一个所有者。默认情况下，所有者是创建该资源的变量，其生命周期与包含的作用域相同。其他人如果需要可以借用或复制该资源。请注意，资源可以是任何东西，从变量或函数。函数从其调用者那里接管资源；从函数返回时，所有权会转移回去。
- en: When the owner's scope has finished executing, all resources owned by it will
    be dropped. This is statically computed by the compiler, which then produces machine
    code accordingly.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有者的作用域执行完毕后，它拥有的所有资源都将被丢弃。这是由编译器静态计算的，然后根据此产生机器代码。
- en: 'Some examples of these rules are shown in the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了这些规则的一些示例：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Rust, variables are declared using the `let` keyword. All variables are
    immutable by default and can be made mutable by using the `mut` keyword. The `::`
    syntax refers to an object in the given namespace, in this case, the `from` function.
    `println!` is a built-in macro that the compiler provides; it is used to write
    to the standard output with a trailing newline. Functions are defined using the
    `fn` keyword. When we try to build it, we get the following error:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，使用`let`关键字声明变量。所有变量默认是不可变的，可以通过使用`mut`关键字使其可变。`::`语法指的是给定命名空间中的对象，在这种情况下是`from`函数。`println!`是编译器提供的一个内置宏，用于写入标准输出并带有换行符。函数使用`fn`关键字定义。当我们尝试构建它时，我们得到以下错误：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, a string resource is created which is owned by the variable `mystr`,
    in the function `heap_example`. Thus, its lifetime is the same as its scope. Under
    the hood, since the compiler does not know the length of the string at compile
    time, it must place it on the heap. The owner variable is created on the stack
    and points to the resource on the heap. When we assign that resource to a new
    variable, the resource is now owned by the new variable. Rust will mark `mystr`
    as invalid at this point to prevent situations where the memory associated with
    the resource might be freed multiple times. Thus, compilation fails here to guarantee
    memory safety. We can force the compiler to copy the resource and have the second
    owner point to the newly created resource. For that, we will need to `.clone()`
    the resource named `mystr`. Here is how it looks:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，创建了一个字符串资源，由函数`heap_example`中的变量`mystr`拥有。因此，其生命周期与作用域相同。在底层，由于编译器在编译时不知道字符串的长度，它必须将其放置在堆上。所有者变量在栈上创建，并指向堆上的资源。当我们将资源分配给新变量时，资源现在由新变量拥有。Rust会在此时将`mystr`标记为无效，以防止与资源相关的内存可能被多次释放的情况。因此，编译失败以确保内存安全。我们可以强制编译器复制资源，并让第二个所有者指向新创建的资源。为此，我们需要`.clone()`名为`mystr`的资源。以下是它的样子：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As expected, this does not throw any errors on compilation and prints the given
    string `"Test"` on running. Notice that till now, we have been using Cargo for
    running our code. Since in this case, we just have a simple file and no external
    dependency, we will use the Rust compiler directly to compile our code, and we
    will run it manually:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在编译时没有抛出任何错误，并且在运行时打印了给定的字符串`"Test"`。注意，到目前为止，我们一直在使用Cargo来运行我们的代码。由于在这种情况下，我们只有一个简单的文件，没有外部依赖，我们将直接使用Rust编译器来编译我们的代码，并且我们将手动运行它：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Consider the code sample below which shows the case when resources are stored
    on the stack:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例，它展示了资源存储在栈上的情况：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Interestingly, though it looks exactly the same as the code block before, this
    does not throw a compilation error. We build and run this using the Rust compiler
    directly from the command line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管它与之前的代码块看起来完全相同，但这不会抛出编译错误。我们直接使用 Rust 编译器从命令行构建和运行这个程序：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The difference is in the types of the variables. Here, the original owner and
    the resource are both created on the stack. When the resource is reassigned, it
    is copied over to the new owner. This is possible only because the compiler knows
    that the size of an integer is always fixed (and hence can be placed on the stack).
    Rust provides a special way to say that a type can be placed on the stack via
    the `Copy` trait. Our example works only because built-in integers (and some other
    types) are marked with this trait. We will explain the trait system in more detail
    in subsequent sections.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于变量的类型。在这里，原始所有者和资源都是在栈上创建的。当资源被重新分配时，它会被复制到新的所有者那里。这是可能的，因为编译器知道整数的尺寸总是固定的（因此可以放在栈上）。Rust
    提供了一种特殊的方式来表示一个类型可以通过 `Copy` 特性放在栈上。我们的例子之所以可行，仅仅是因为内置整数（以及一些其他类型）被标记了此特性。我们将在后续章节中更详细地解释特性系统。
- en: 'One might have noticed that copying a resource of unknown length to a function
    might lead to memory bloats. In a lot of languages, the caller will pass a pointer
    to a memory location, and then to the function. Rust does this by using references.
    These allow you to refer to a resource without actually owning it. When a function
    receives a reference to a resource, we say that it borrowed that resource. In
    the following example, the function `heap_example` borrows the resource owned
    by the variable `s`. Since borrowing is not absolute ownership, the scope of the
    borrowing variable does not affect how memory associated with the resource is
    freed. That also means there is no chance of freeing the borrowed resource multiple
    times in the function, since nobody in the function''s scope actually owns that
    resource. Thus, the earlier code that failed works in this case:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能已经注意到，将未知长度的资源复制到一个函数中可能会导致内存膨胀。在许多语言中，调用者会传递一个指向内存位置的指针，然后传递给函数。Rust 通过使用引用来实现这一点。这些引用允许你引用一个资源，而不必真正拥有它。当一个函数接收一个资源的引用时，我们说它借用了那个资源。在下面的例子中，函数
    `heap_example` 借用了变量 `s` 所拥有的资源。由于借用不是绝对的所有权，借用变量的作用域不会影响与资源相关的内存释放方式。这也意味着在函数中不可能多次释放借用的资源，因为函数作用域内没有人真正拥有那个资源。因此，之前失败的代码在这个情况下是可行的：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The borrowing rules also imply that the borrow is immutable. However, there
    can be cases where one needs to mutate the borrow. To handle those cases, Rust
    allows mutable references (or borrowing). As one would expect, this takes us back
    to the problem we had in the first example, and compilation fails with the following
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 借用规则还意味着借用是不可变的。然而，可能会有需要修改借用的借用的情况。为了处理这些情况，Rust 允许可变引用（或借用）。正如预期的那样，这让我们回到了第一个例子中的问题，并且编译失败，以下代码：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that a resource can be mutably borrowed only once in a scope. The compiler
    will refuse to compile code that tries to do otherwise. While this might look
    like an annoying error, you need to remember that in a working application, these
    functions will often be called from competing threads. If there is a synchronization
    error due to a programming fault, we will end up with a data race where multiple
    unsynchronized threads race to modify the same resource. This feature helps prevent
    such situations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个资源在作用域内只能被可变借用一次。编译器将拒绝编译尝试做其他事情的代码。虽然这看起来可能像是一个令人烦恼的错误，但你需要记住，在一个工作应用程序中，这些函数通常会从竞争的线程中被调用。如果由于编程错误导致同步错误，我们最终会得到一个数据竞争，其中多个未同步的线程竞相修改相同的资源。这个特性有助于防止这种情况。
- en: 'Another language feature that is closely related to references is that of a
    lifetime. A reference lives as long as it is in scope, thus its lifetime is that
    of the enclosing scope. All variables declared in Rust can have a lifetime explicit
    elision that puts a name to its lifetime. This is useful for the borrow checker
    to reason about the relative lifetimes of variables. In general, one does not
    need to put an explicit lifetime name to each and every variable since the compiler
    manages that. In certain scenarios, this is needed, especially when automatic
    lifetime determination cannot work. Let''s look at an example where this happens:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与引用密切相关的高级语言特性是生存期的概念。引用在作用域内存在时存活，因此其生存期是封装作用域的生存期。在 Rust 中声明的所有变量都可以有一个显式的生存期省略，这给它赋予了一个名称。这对于借用检查器推理变量的相对生存期很有用。一般来说，不需要为每个变量都指定显式的生存期名称，因为编译器会管理这一点。在某些场景下，这很有必要，尤其是在自动生存期确定无法工作的情况下。让我们看看一个发生这种情况的例子：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `vec!` macro constructs a vector from the given list of objects. Note that
    unlike previous examples, our function here needs to return a value back to the
    caller. We need to specify the return type using the arrow syntax. Here, we are
    given two vectors, and we want to print the longest of the two. Our `longer_vector`
    function does just that. It takes in references to two vectors, computes their
    length, and returns a reference to the one with the larger length. This fails
    to compile with the following error:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec!` 宏从给定的一组对象列表中构建一个向量。请注意，与之前的例子不同，我们这里的函数需要返回一个值给调用者。我们需要使用箭头语法来指定返回类型。这里，我们给出了两个向量，我们想打印出两个中最长的。我们的
    `longer_vector` 函数正是这样做的。它接收两个向量的引用，计算它们的长度，并返回长度较大的那个向量的引用。这会导致以下错误而无法编译：'
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This tells us that the compiler could not determine if the returned reference
    should refer to the first parameter or the second, so it could not determine how
    long it should live. There is no way this can be determined at compile time since
    we have no control of the inputs. A key insight here is that we do not need to
    know the lifetimes of all the references at compile time. We need to make sure
    the following things hold true:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们编译器无法确定返回的引用应该指向第一个参数还是第二个参数，因此它无法确定其应该存活多长时间。由于我们没有控制输入，所以在编译时无法确定这一点。这里的一个关键洞察是，我们不需要在编译时知道所有引用的生存期。我们需要确保以下事项成立：
- en: The two inputs should have the same lifetimes since we want to compare their
    lengths in the function
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个输入应该具有相同的生存期，因为我们想在函数中比较它们的长度
- en: The return value should have the same lifetime as that of the input, which is
    the longer of the two
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值应该具有与输入相同的生存期，即两者中较长的那个
- en: 'Given these two axioms, it follows that the two inputs and the return should
    have the same lifetime. We can annotate this, as shown in the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这两个公理，可以得出结论，两个输入和返回值应该具有相同的生存期。我们可以像以下代码片段所示那样进行注释：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This works as expected since the compiler can happily guarantee code correctness.
    Lifetime parameters can also be attached to structs and method definitions. There
    is a special lifetime called `'static` that refers to the entire duration of the
    program.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如预期的那样工作，因为编译器可以愉快地保证代码的正确性。生存期参数也可以附加到结构体和方法定义上。有一个特殊的生存期称为 `'static`，它指的是整个程序的生命周期。
- en: Rust recently accepted a proposal to add a new designated lifetime called `'fn`
    that will be equal to the scope of the innermost function or closure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 最近接受了一个提议，要添加一个新的指定生存期 `'fn`，它将与最内层函数或闭包的作用域相等。
- en: Generics and the trait system
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型和特质系统
- en: Rust supports writing generic code that is later bound with more concrete types,
    either during compile time or during runtime. People who are familiar with templates
    in C++ might notice that generics in Rust are pretty similar to templates, as
    far as syntax goes. The following example illustrates how to use generic programming.
    We also introduce some new constructs which we haven't discussed before, which
    we will explain as we proceed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 支持编写在编译时或运行时绑定到更具体类型的泛型代码。熟悉 C++ 模板的开发者可能会注意到，Rust 中的泛型在语法上与模板非常相似。以下示例说明了如何使用泛型编程。我们还将介绍一些之前未讨论过的新结构，我们将在继续进行时进行解释。
- en: 'Much like C and C++, a Rust `struct` defines a user-defined type that aggregates
    multiple logically connected resources in one unit. Our struct here defines a
    tuple of two variables. We define a generic struct and we use a generic *type
    parameter*, written here as `<T>`. Each member of the struct is defined to be
    of that type. We later define a generic function that sums the two elements of
    the tuple. Let''s look at a naive implementation of this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与C和C++类似，Rust的`struct`定义了一个用户自定义的类型，它将多个逻辑上连接的资源聚合在一个单元中。我们这里的`struct`定义了一个包含两个变量的元组。我们定义了一个泛型`struct`，并使用了一个泛型`type
    parameter`，在这里写作`<T>`。`struct`中的每个成员都被定义为该类型。我们后来定义了一个泛型函数，用于计算元组的两个元素的和。让我们看看这个简单的实现：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This fails to compile, and the compiler throws the following error:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法编译，编译器抛出了以下错误：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This error is important. The compiler is telling us that it does not know how
    to add two operands of type `T`. It also (correctly) guessed that the `T` type
    needs to be bound by the `Add` trait. This means that the list of possible concrete
    types for `T` should only have types that implement the `Add` trait, which are
    types whose concrete references can be added. Let''s go ahead and put the trait
    bound in the `sum` function. Our code should look like this now:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误很重要。编译器告诉我们它不知道如何将两个类型为`T`的操作数相加。它还（正确地）猜测`T`类型需要通过`Add`特质进行绑定。这意味着`T`可能的实际类型列表应该只包含实现了`Add`特质的类型，这些类型的实际引用可以进行相加。让我们继续在`sum`函数中添加这个特质绑定。现在我们的代码应该看起来像这样：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For this to work, the elements must be summable; there should be a logical meaning
    of summing them. So, we have constrained the possible types the `T` parameter
    can have to those which have the `Add` trait implemented. We also need to let
    the compiler know that the output for this function should be of the type `T`.
    Given this information, we can construct our tuples and call the sum function
    on them, and they will behave as expected. Also, note that a tuple of strings
    will fail to compile with the error, since the `Add` trait is not implemented
    for strings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，元素必须是可求和的；它们相加应该有一个逻辑意义。因此，我们将`T`参数可能的类型限制为实现了`Add`特质的那些类型。我们还需要让编译器知道这个函数的输出应该是`T`类型。有了这些信息，我们可以构造元组并调用求和函数，它们将按预期行为。此外，请注意，字符串的元组将无法编译，因为字符串没有实现`Add`特质。
- en: From the last example, one might notice that traits are essential to properly
    implement generics. They help the compiler reason about properties of generic
    types. In essence, a trait defines properties of a type. The library defines a
    bunch of commonly used traits and their implementations for built-in types. For
    any user-defined types, it's up to the user to define what properties those types
    should have by defining and implementing traits.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后一个例子中，人们可能会注意到特质对于正确实现泛型是必不可少的。它们帮助编译器推理泛型类型的属性。本质上，一个特质定义了一个类型的属性。库定义了一组常用特质及其内置类型的实现。对于任何用户自定义类型，用户需要通过定义和实现特质来定义这些类型应该具有的属性。
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We start by defining a generic trait of type `T`. Our trait has a single function
    that will return the maximum of the given type that implements it. What counts
    as the maximum is an implementation detail and is not important at this stage.
    We then define a tuple of three elements, each of the same generic type. Later,
    we implement our trait for that type we defined. In Rust, a function returns the
    last expression if there is no explicit return statement. Using this style is
    considered idiomatic in the community. Our `max` function uses this feature in
    the `if...else` block. For the implementation to work, the generic types must
    have an ordering relation defined between them so that we can compare them. In
    Rust, this is achieved by constraining the possible types to those which implement
    the `PartialOrd` trait. We also need to put a constraint on the `Copy` trait so
    that the compiler can make copies of the self parameter before returning from
    the function. We move on to defining another tuple, which has two elements. We
    implement the same trait here in a similar fashion. When we actually use these
    in our `main` function, they work as expected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个泛型特性类型`T`。我们的特性有一个单一的功能，它将返回实现它的给定类型的最大值。什么算是最大值是一个实现细节，在这个阶段并不重要。然后我们定义一个包含三个元素的元组，每个元素都是相同的泛型类型。稍后，我们为定义的类型实现我们的特性。在Rust中，如果没有显式的返回语句，函数会返回最后一个表达式。使用这种风格在社区中被认为是惯用的。我们的`max`函数在`if...else`块中使用了这个特性。为了使实现工作，泛型类型必须在它们之间定义一个排序关系，这样我们就可以比较它们。在Rust中，这是通过将可能的类型限制为实现了`PartialOrd`特性的类型来实现的。我们还需要对`Copy`特性施加约束，以便编译器可以在从函数返回之前对self参数进行复制。我们继续定义另一个包含两个元素的元组。我们以类似的方式在这里实现相同的特性。当我们实际上在`main`函数中使用这些特性时，它们按预期工作。
- en: 'Traits can also be used to extend built-in types and add new functionalities.
    Let''s look at the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 特性也可以用来扩展内置类型并添加新的功能。让我们看看以下示例：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we want to implement the sawtooth ([https://en.wikipedia.org/wiki/Sawtooth_wave](https://en.wikipedia.org/wiki/Sawtooth_wave))
    function on the built-in `f64` type. This function is not available in the standard
    library, so we would need to write some code to get it working by extending the
    standard library. To have this seamlessly integrated into the type system, we
    will need to define a trait and implement it for the `f64` type. This enables
    us to use the new function using the dot notation like any other built-in function
    on the `f64` type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要在内置的`f64`类型上实现锯齿波([https://en.wikipedia.org/wiki/Sawtooth_wave](https://en.wikipedia.org/wiki/Sawtooth_wave))函数。这个函数在标准库中不可用，因此我们需要编写一些代码来通过扩展标准库使其工作。为了无缝集成到类型系统中，我们需要定义一个特性和为`f64`类型实现它。这使我们能够使用新的函数，就像使用`f64`类型上的任何其他内置函数一样，通过点符号使用。
- en: 'The standard library provides a number of built-in traits; the most common
    of these are `Display` and `Debug`. These two are used to format types while printing.
    `Display` corresponds to the empty formatter `{}` and `Debug` corresponds to format
    debugging output. All of the mathematical operations are defined as traits, such
    as `Add`, `Div`, and so on. The compiler attempts to provide default implementations
    for user-defined types if they are marked with the `#[derive]` attribute. However,
    an implementation might choose to override any of these if necessary. An example
    of this is shown in the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一些内置特性；其中最常见的是`Display`和`Debug`。这两个特性用于在打印时格式化类型。`Display`对应于空格式化器`{}`，而`Debug`对应于格式化调试输出。所有的数学运算都定义为特性，例如`Add`、`Div`等。如果用户定义的类型带有`#[derive]`属性，编译器会尝试提供默认实现。然而，如果需要，实现可以选择覆盖这些中的任何一个。以下代码片段展示了这种情况：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We define a generic point structure with two fields. We let the compiler generate
    implementations of some common traits. We must, however, implement the `Display`
    trait by hand, since the compiler cannot determine the best way to display user-defined
    types. We have to constrain the generic type to types that implement `Display`
    using the `where` clause. This example also demonstrates the alternate way to
    constrain types based on traits. Having set all of this up, we can display our
    point using the default formatter. This produces the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个具有两个字段的泛型点结构。我们让编译器生成一些常见特质的实现。然而，我们必须手动实现 `Display` 特质，因为编译器无法确定显示用户定义类型的最优方式。我们必须使用
    `where` 子句将泛型类型限制为实现了 `Display` 特质的类型。这个例子还展示了基于特质约束类型的另一种方法。在设置好所有这些之后，我们可以使用默认格式化程序显示我们的点。这会产生以下输出：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Error handling
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'One of Rust''s major goals is enabling the developer to write robust software.
    An essential component of this is advanced error handling. In this section, we
    will take a deeper look at how Rust does error handling. But before that, let''s
    take a detour and look at some type theory. Specifically, we are interested in
    **algebraic data types** (**ADT**), types formed by combining other types. The
    two most common ADTs are sum and product types. A `struct` in Rust is an example
    of a product type. This name derives from the fact that given a struct, the range
    of its type is essentially the Cartesian product of the ranges of each of its
    components, since an instance of the type has values for all of its constituent
    types. In contrast, a sum type is when the ADT can assume the type of only one
    of its constituents. An example of this is an `enum` in Rust. While similar to
    enums in C and other languages, Rust enums provide a number of enhancements: they
    allow variants to carry data.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的一个主要目标就是让开发者能够编写健壮的软件。这其中的一个关键组成部分就是高级错误处理。在本节中，我们将更深入地探讨 Rust 是如何处理错误的。但在那之前，让我们先偏离一下，看看一些类型理论。具体来说，我们感兴趣的是**代数数据类型**（**ADT**），这是通过组合其他类型形成的类型。最常见的两种
    ADT 是求和类型和乘积类型。Rust 中的 `struct` 是乘积类型的一个例子。这个名字来源于这样一个事实：给定一个结构体，其类型的范围本质上是其各个组成部分的范围的笛卡尔积，因为类型的实例具有其所有组成部分类型的值。相反，当
    ADT 只能假设其组成部分之一的数据类型时，就是求和类型。Rust 中的 `enum` 就是这样一个例子。虽然 Rust 中的枚举与 C 语言和其他语言中的枚举类似，但
    Rust 枚举提供了一些增强功能：它们允许变体携带数据。
- en: 'Now, back to error handling. Rust mandates that operations which can result
    in an error must return a special `enum` that carries the result. Conveniently,
    this `enum` looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到错误处理。Rust 强制要求可能产生错误的操作必须返回一个特殊的 `enum`，该 `enum` 携带结果。方便的是，这个 `enum` 看起来是这样的：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The two possible options are called variants. In this case, they represent
    the non-error case and the error case, respectively. Note that this is generically
    defined so that an implementation is free to define the types in both cases. This
    is useful in applications that want to expand on the standard error type and implement
    custom errors. Let''s look at an example of this in action:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 两种可能的选择被称为变体。在这种情况下，它们分别代表非错误情况和错误情况。请注意，这是通用的定义，因此实现可以自由地在两种情况下定义类型。这在需要扩展标准错误类型并实现自定义错误的程序中非常有用。让我们看看一个实际应用的例子：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For this example, we define a function that simply returns the quotient when
    the first operand is divided by the second. This function must handle the error
    case when the divisor is zero. We also want it to signal an error to its caller
    if that is the case. Also, let's assume that this is a part of a library that
    will expand to include more such operations. To make the code manageable, we create
    an error class for our library, with one element that represents the divide by
    zero error. For the Rust compiler to know that the enum is an error type, our
    enum has to implement the `Error` trait from the standard library. It also needs
    to implement the `Display` trait manually. Having set up this boilerplate, we
    can define our division method. We will take advantage of the generic `Result`
    trait to annotate that on success, it should return a `u32`, the same type as
    the operands. On failure, it should return an error of type `OperationsError`.
    In the function, we raise the error if our divisor is zero. Otherwise, we carry
    out the division, wrap the result in a `Ok` so that it becomes a variant of the
    `Result` enum, and return it. In our `main` function, we call this with a zero
    divisor. The result will be an error, as shown by the first print macro. In the
    second invocation, we know that the divisor is not zero. Thus, we can safely unwrap
    the result to convert it from `Ok(50)` to `50`. The standard library has a number
    of utility functions to handle `Result` types, safely reporting the error to the
    caller.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们定义了一个函数，该函数简单地返回第一个操作数除以第二个操作数时的商。这个函数必须处理除数为零的错误情况。我们还想让它在其调用者遇到这种情况时发出错误信号。此外，让我们假设这是一个将扩展以包含更多此类操作的库的一部分。为了使代码易于管理，我们为我们的库创建了一个错误类，其中包含一个表示除以零错误的元素。为了让Rust编译器知道枚举是一个错误类型，我们的枚举必须实现标准库中的`Error`特质。它还需要手动实现`Display`特质。在设置好这些样板代码之后，我们可以定义我们的除法方法。我们将利用泛型`Result`特质来注解，在成功的情况下，它应该返回一个`u32`类型的值，与操作数相同。在失败的情况下，它应该返回类型为`OperationsError`的错误。在函数中，如果我们的除数为零，我们将引发错误。否则，我们执行除法，将结果包装在`Ok`中，使其成为`Result`枚举的一个变体，并返回它。在我们的`main`函数中，我们用零除数调用这个函数。结果将是一个错误，如第一个打印宏所示。在第二次调用中，我们知道除数不是零。因此，我们可以安全地解包结果，将其从`Ok(50)`转换为`50`。标准库提供了一些实用函数来处理`Result`类型，安全地向调用者报告错误。
- en: 'Here is a sample run of the last example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是上一个示例的运行样本：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Given this type, we could have written our divide function like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这种类型，我们可以这样编写我们的除法函数：
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We modify our function to return an `Option` of type `u32`. In our `main` function,
    we call our function. In this case, we can match on the return type. If it happens
    to be `None`, we know that the function did not succeed. In that case, we can
    print an error. In case it returned `Some`, we extract the underlying value and
    print it. The second invocation works fine since we know it did not get a zero
    divisor. Using `Option` for error handling can be a bit easier to manage since
    it involves less boilerplate. However, this can be a bit difficult to manage in
    a library with custom error types since errors are not handled by the type system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改我们的函数以返回一个类型为`u32`的`Option`。在我们的`main`函数中，我们调用我们的函数。在这种情况下，我们可以根据返回类型进行匹配。如果它恰好是`None`，我们知道函数没有成功。在这种情况下，我们可以打印一个错误。如果它返回`Some`，我们提取其底层值并打印它。第二次调用工作正常，因为我们知道它没有收到零除数。使用`Option`进行错误处理可能更容易管理，因为它涉及更少的样板代码。然而，在具有自定义错误类型的库中，这可能有点难以管理，因为错误不是由类型系统处理的。
- en: Note that `Option` can be represented as a `Result` of a given type and the
    unit type
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Option`可以表示为给定类型和单位类型的`Result`。
- en: '`type Option<T> = Result<T, ()>;`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`type Option<T> = Result<T, ()>;`。'
- en: What we have described so far for error handling has been done with recoverable
    errors. In some cases, though, it might be wise to abort execution if an error
    occurs. The standard library provides the `panic!` macro to handle such cases.
    Calling this stops the execution of the current thread, prints a message on the
    screen, and unwinds the call stack. However, one needs to use this cautiously
    since in a lot of cases, a better option is to handle the error properly and bubble
    the error up to the caller.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前描述的错误处理已经使用了可恢复的错误。然而，在某些情况下，如果发生错误，中止执行可能是明智的。标准库提供了`panic!`宏来处理这种情况。调用此宏将停止当前线程的执行，在屏幕上打印一条消息，并回滚调用栈。然而，需要谨慎使用，因为在很多情况下，更好的选择是正确处理错误并将错误向上传递给调用者。
- en: 'A number of built-in methods and functions call this macro in case of an error.
    Let''s look at the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 许多内置方法和函数在出错时会调用这个宏。让我们看看以下示例：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This fails with the following error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这会引发以下错误：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Some methods that call panic are `expect()` and `unwrap()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 调用panic的一些方法是`expect()`和`unwrap()`。
- en: The macro system
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏系统
- en: Rust supports a macro system that has evolved quite a lot over the years. A
    distinctive feature of Rust macros are that they are guaranteed to not refer to
    identifiers outside their scope by accident, and so the macro implementation in
    Rust is *hygienic*. As one would expect, Rust macros are expanded to source code
    ahead of the compilation in place, and are compiled with the translation unit.
    The compiler enforces scoping rules on expanded macros to make them hygienic.
    Rust macros differ from other constructs in that they always end in an exclamation
    mark `!`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Rust支持一个经过多年演变的宏系统。Rust宏的一个显著特点是它们保证不会意外地引用其作用域之外的标识符，因此Rust中的宏实现是“卫生”的。正如预期的那样，Rust宏在编译前被展开为源代码，并与翻译单元一起编译。编译器对展开的宏执行作用域规则以使它们卫生。Rust宏与其他构造不同，因为它们总是以感叹号`!`结尾。
- en: 'Modern Rust has two ways of working with macros; the older, syntactic macro
    way, and the newer, procedural macro way. Let''s look at each of these:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Rust有两种处理宏的方法；较老的，基于语法的宏方法，以及较新的，过程宏方法。让我们看看这些方法中的每一个：
- en: Syntactic macros
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法宏
- en: 'This system of macros has existed as part of Rust since pre- 1.0 releases.
    These macros are defined using a macro called `macro_rules!`. Let''s look at an
    example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏系统自Rust 1.0之前的版本以来一直是Rust的一部分。这些宏是通过一个名为`macro_rules!`的宏定义的。让我们看看一个示例：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We start with defining the factorial macro. Since we do not want the compiler
    to refuse to compile our code as it might overflow the macro stack, we will use
    a non-recursive implementation. A syntactic macro in Rust is a collection of rules
    where the left-hand side dictates how the rule should be matched to an input,
    and the right-hand side dictates what it should expand to. A rule maps to an expression
    on the right-hand side via the `=>` operator. Variables local to a rule are declared
    using the `$` sign. Match rules are expressed using a special macro language which
    has its own set of reserved keywords. Our declaration says that we want to take
    in any valid Rust expression; in this specific case, it should evaluate to an
    integer. We will leave it to the caller to make sure that is true. We then loop
    over from 1 to the last integer in the range while accumulating the result. Once
    done, we return back the result using the implicit return syntax.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义阶乘宏开始。由于我们不希望编译器拒绝编译我们的代码，因为它可能会溢出宏栈，我们将使用非递归实现。Rust中的语法宏是一组规则，其中左侧指定规则应该如何与输入匹配，右侧指定它应该展开成什么。规则通过`=>`运算符映射到右侧的表达式。规则局部变量使用`$`符号声明。匹配规则使用一种特殊的宏语言表达，它有一套自己的保留关键字。我们的声明表明我们希望接受任何有效的Rust表达式；在这种情况下，它应该评估为整数。我们将把它留给调用者来确保这是真的。然后我们从这个范围的最后一个整数开始循环到1，同时累积结果。一旦完成，我们使用隐式返回语法返回结果。
- en: 'Our caller is the main function, in that we take input from the user using
    the `std::env` module. We fetch the first in the list of inputs and throw an error
    if there are no inputs. We then print the result from our macro, and we try to
    parse the input as a `u64` before passing to it. We also handle the case where
    parsing might fail. This works as expected:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的调用者是主函数，因为我们使用`std::env`模块从用户那里获取输入。我们获取列表中的第一个输入，如果没有输入则抛出错误。然后我们打印出宏的结果，并在传递之前尝试将输入解析为`u64`。我们还处理解析可能失败的情况。这按预期工作：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Rust also provides a few tools to debug macros. One might be interested to
    see what the expanded macro looks like. The `trace_macros!` macro does exactly
    that. To make it work, we will need to enable a feature gate, as shown in the
    following code snippet (since it is not stable in Rust yet, this code will only
    work in Rust nightly):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Rust还提供了一些调试宏的工具。有人可能会对查看展开的宏是什么样子感兴趣。`trace_macros!` 宏正是这样做的。为了使其工作，我们需要启用一个功能门，如下面的代码片段所示（由于在Rust中尚不稳定，此代码只能在Rust
    nightly版本中工作）：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that the expansion also includes `println!` since it is a macro defined
    in the standard library.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，展开还包括`println!`，因为它是在标准库中定义的宏。
- en: 'The same expansion can also be examined using the following command to invoke
    the compiler:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的展开也可以使用以下命令来调用编译器进行检查：
- en: '`rustc -Z unstable-options --pretty expanded syntactic-macro.rs`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustc -Z unstable-options --pretty expanded syntactic-macro.rs`。'
- en: Procedural macros
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**过程宏**'
- en: While regular syntactic macros are useful in a number of scenarios, some applications
    need advanced code generation features that are better done using the AST that
    the compiler operates on. Thus, there was a need to extend the macro system to
    include this. It was later decided that the old macro system and this new system
    called *procedural macros* would co-exist. Over time, this is intended to replace
    the syntactic macro system. The compiler supports loading plugins from external
    crates; these can receive the AST once the compiler has generated it. There are
    APIs available to modify the AST in-place to add new code as required. A detailed
    discussion of this system is beyond the scope of this book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然常规的语法宏在许多场景下很有用，但某些应用需要更高级的代码生成功能，这些功能最好使用编译器操作的抽象语法树（AST）来实现。因此，有必要扩展宏系统以包括这一功能。后来决定，旧的宏系统和这个新系统，即所谓的**过程宏**，将共存。随着时间的推移，这个新系统预计将取代语法宏系统。编译器支持从外部crate加载插件；这些插件可以在编译器生成AST后接收AST。有API可以修改AST以添加所需的新代码。关于这个系统的详细讨论超出了本书的范围。
- en: Functional features in Rust
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust中的函数式特性
- en: Rust has been inspired by functional languages such as Haskell and OCaml. Unsurprisingly,
    Rust has rich support for functional programming both in the language and in the
    standard library. In this section, we will look at some of these.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Rust受到了像Haskell和OCaml这样的函数式语言的影响。不出所料，Rust在语言和标准库中都对函数式编程提供了丰富的支持。在本节中，我们将探讨其中的一些。
- en: Higher-order functions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'We have seen previously how Rust functions define an isolated scope in which
    all local variables live. Thus, variables outside the scope can never leak into
    it unless they are explicitly passed as arguments. There can be cases where this
    is not the desired behavior; closures provide an anonymous function like mechanism,
    which has access to all the resources defined in the scope in which it is defined.
    This enables the compiler to enforce the same borrow checking rules while making
    it easier to reuse code. In Rust terminology, a typical closure borrows all bindings
    of its surrounding scope. A closure can be forced to own those by marking it with
    the move keyword. Let''s look at some examples:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到，Rust函数定义了一个独立的范围，其中所有局部变量都存在。因此，除非它们被明确地作为参数传递，否则范围外的变量永远不会泄漏到其中。可能会有这种情况，这不是期望的行为；闭包提供了一个类似匿名函数的机制，它能够访问其定义范围内定义的所有资源。这使得编译器能够强制执行相同的借用检查规则，同时使代码的重用更容易。在Rust术语中，一个典型的闭包会借用其周围作用域的所有绑定。可以通过使用`move`关键字标记来强制闭包拥有这些绑定。让我们看看一些例子：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first example is a simple closure that adds two numbers given to it. The
    second example is more involved; it shows a real example of closures for functional
    programming. We are interested in filtering a list of integers to collect only
    the even ones out of it. So, we start with a range from 1 to 10, which returns
    an instance of the built-in type `Range`. Since that type implements the `IntoIterator` trait,
    that type behaves as an iterator. Thus, we can filter it by passing a closure
    that returns true only if the input can be divided by two. Finally, we collect
    the resultant iterator into a vector of `u32` and print it out. The last example
    is similar in construction. It borrows the variable times from the closure's enclosing
    scope and uses it to map to items of the range.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个例子是一个简单的闭包，它接受两个数字并对其求和。第二个例子更为复杂；它展示了闭包在函数式编程中的实际应用。我们感兴趣的是过滤一个整数列表，只收集其中的偶数。因此，我们从1到10的范围开始，它返回内置类型`Range`的一个实例。由于该类型实现了`IntoIterator`特质，该类型表现得像一个迭代器。因此，我们可以通过传递一个只返回输入可以被2整除的闭包来过滤它。最后，我们将结果迭代器收集到一个`u32`类型的向量中，并打印出来。最后一个例子在结构上相似。它从闭包的包围作用域中借用变量times，并使用它来映射到范围的项目。 '
- en: 'Let''s look at an example of using the `move` keyword in closures:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在闭包中使用`move`关键字的一个例子：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The difference between the first closure (`borrow`) and the ones we have discussed
    so far is that this mutates the variable it inherits from the enclosing scope.
    We must declare the variable and the closure as `mut`. We also need to put the
    closure in a different scope so that the compiler does not complain about double
    borrowing when we try to assert its value. As asserted, the closure called `borrow` borrows
    the variables from its parent scope, and that''s why its original value changes
    to `7`. The second closure called `own` is a move closure, thus it gets a copy
    of the variable `times`. For this to work, the variable has to implement the `Copy` trait
    so that the compiler can copy it to the closure, which all built-in types do.
    Since the variable that the closure gets and the original variable are not the
    same, the compiler does not complain about borrowing it twice. Also, the original
    value of the variable does not change. These types of closures are immensely important
    in implementing threads, as we will see in a later section. The standard library
    also supports accepting and returning closures in user-defined functions or methods
    using a number of built-in traits, as shown in the following table:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个闭包（`borrow`）与我们之前讨论的闭包之间的区别是，它会修改从封装作用域继承的变量。我们必须声明变量和闭包为`mut`。我们还需要将闭包放在不同的作用域中，这样编译器就不会在我们尝试断言其值时抱怨双重借用。如断言，名为`borrow`的闭包从其父作用域借用变量，这就是为什么它的原始值变为`7`。第二个名为`own`的闭包是一个移动闭包，因此它获得了变量`times`的一个副本。为了使这可行，变量必须实现`Copy`特质，这样编译器才能将其复制到闭包中，所有内置类型都这样做。由于闭包获取的变量和原始变量不是同一个，编译器不会抱怨双重借用。此外，变量的原始值不会改变。这类闭包在实现线程时非常重要，我们将在后面的章节中看到。标准库还支持使用多个内置特质在用户定义的函数或方法中接受和返回闭包，如下表所示：
- en: '| **Trait name** | **Function** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **特质名称** | **函数** |'
- en: '| `std::ops::Fn` | Implemented by closures that do not receive mutable captured
    variables. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `std::ops::Fn` | 由不接受可变捕获变量的闭包实现。|'
- en: '| `std::ops::FnMut` | Implemented by closures that need to mutate the captured variables.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `std::ops::FnMut` | 由需要修改捕获变量的闭包实现。|'
- en: '| `std::ops::FnOnce` | Implemented by all closures. Indicates that the closure
    can be called exactly once. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `std::ops::FnOnce` | 由所有闭包实现。表示闭包可以被调用正好一次。|'
- en: Iterators
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'Another important functional aspect is that of lazy iteration. Given a collection
    of types, one should be able to loop over those or a subset in any given order.
    In Rust, a common iterator is a range which has a start and an end. Let''s look
    at how these work:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的功能性方面是惰性迭代。给定一组类型，应该能够以任何给定的顺序遍历这些类型或其子集。在Rust中，一个常见的迭代器是一个范围，它有一个起始点和结束点。让我们看看它们是如何工作的：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first range is an exclusive range that spans from the first element to the
    last but one. The second range is an inclusive one which spans till the last element.
    Note that inclusive range is an experimental feature that might change in the
    future.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个范围是一个排他性范围，从第一个元素到倒数第二个元素。第二个范围是一个包含性范围，一直延伸到最后一个元素。请注意，包含性范围是一个实验性特性，未来可能会发生变化。
- en: 'As one would expect, Rust does provide interfaces with which a user-defined
    type can be iterated on. The type just needs to implement the trait `std::iterator::Iterator`. Let''s
    look at an example. We are interested in generating the Collatz sequence ([https://en.wikipedia.org/wiki/Collatz_conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)), given
    an integer. This is given by the recurrence relation below, given an integer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，Rust确实提供了接口，允许用户定义的类型可以迭代。类型只需要实现`std::iterator::Iterator`特质。让我们看看一个例子。我们感兴趣的是生成给定整数的柯勒茨序列([https://en.wikipedia.org/wiki/Collatz_conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture))，这是由以下递归关系给出的，给定一个整数：
- en: If it is even, divide it by two
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是偶数，就除以二
- en: If it is odd, multiply it by 3 and add one
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是奇数，就乘以3然后加1
- en: 'According to the conjecture, this sequence will always terminate at 1\. We
    will assume that is true and define our code respecting that:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据猜想，这个序列将始终终止于1。我们将假设这是真的，并定义我们的代码以尊重这一点：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In our code, the state of the current iteration is represented by the struct
    called `Collatz`. We implement the `Iterator` protocol on it. For that, we need
    to implement the `next` function, which takes in the current state and produces
    the next state. When it reaches the end state, it must return a `None` so that
    the caller knows that the iterator has been exhausted. This is represented by
    the nullable return value of the function. Given the recurrence, the implementation
    is straightforward. In our main function, we instantiate the initial state and
    we can iterate using regular `for` loops. The `Iterator` trait automatically implements
    a number of useful functions; the `take` function takes the given number of elements
    from the iterator, while the `skip` function skips the given number of elements.
    All these are very important for working with iterable collections.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，当前迭代的态由名为 `Collatz` 的结构体表示。我们在其上实现了 `Iterator` 协议。为此，我们需要实现 `next` 函数，该函数接收当前态并生成下一个态。当它达到结束态时，它必须返回一个
    `None`，以便调用者知道迭代器已经耗尽。这由函数的可空返回值表示。鉴于递归关系，实现是直接的。在我们的主函数中，我们实例化初始态，我们可以使用常规的 `for`
    循环进行迭代。`Iterator` 特质自动实现了许多有用的函数；`take` 函数从迭代器中取出给定数量的元素，而 `skip` 函数则跳过给定数量的元素。所有这些对于处理可迭代集合都非常重要。
- en: 'The following is the output of a run of our example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们示例运行的结果：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Concurrency primitives
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发原语
- en: 'One of the promises of Rust is to enable *fearless concurrency*. Quite naturally,
    Rust has support for writing concurrent code through a number of mechanisms. In
    this chapter, we will discuss a few of these. We have seen how the Rust compiler
    uses borrow checking to ensure correctness of programs at compile time. It turns
    out that those primitives are also useful in verifying correctness of concurrent
    code. Now, there are multiple ways of implementing threading in a language. The
    simplest possible way is to create a new OS thread for each thread created in
    the platform. This is often called 1:1 threading. On the other hand, a number
    of application threads can be mapped to one OS thread. This is called N:1 threading.
    While this approach is resource-light since we end up with fewer actual threads,
    there is a higher overhead of context switches. A middle ground is called M:N
    threading, where multiple application threads are mapped to multiple OS level
    threads. This approach requires the maximum amount of safeguarding and is implemented
    using a runtime, something that Rust avoids. Thus, Rust uses the 1:1 model. A
    thread in Rust corresponds to one OS thread in contrast to languages like Go.
    Let''s start with a look at how Rust enables writing multithreaded applications:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的一个承诺是能够实现 *无畏的并发*。很自然地，Rust 通过多种机制支持编写并发代码。在本章中，我们将讨论其中的一些。我们已经看到 Rust
    编译器如何使用借用检查来确保程序在编译时的正确性。事实证明，这些原语在验证并发代码的正确性时也非常有用。现在，有多种方式在语言中实现线程。最简单的方式是为平台中创建的每个线程创建一个新的操作系统线程。这通常被称为
    1:1 线程。另一方面，多个应用程序线程可以映射到一个操作系统线程。这被称为 N:1 线程。虽然这种方法资源消耗较少，因为我们最终得到的实际线程较少，但上下文切换的开销更高。一种中间方案称为
    M:N 线程，其中多个应用程序线程映射到多个操作系统级别的线程。这种方法需要最大的保护措施，并且使用运行时实现，而 Rust 避免使用运行时。因此，Rust
    使用 1:1 模型。在 Rust 中，一个线程对应一个操作系统线程，这与 Go 等语言不同。让我们先看看 Rust 是如何使编写多线程应用程序成为可能的：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We start by importing the threading library. In our main function, we create
    an empty vector that we will use to store references to the threads we create
    so that we can wait for them to exit. The threads are actually created using `thread::spawn`,
    to which we must pass a closure that will be executed in each of those threads.
    Since we must borrow a variable from the enclosing scope (the loop index `i`)
    in our closure, the closure itself must be a move closure. Right before exiting
    the closure, we call join on the current thread handle so that all threads wait
    for one another. This produces the following output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入线程库。在我们的主函数中，我们创建一个空向量，我们将使用它来存储我们创建的线程的引用，以便我们可以等待它们退出。线程实际上是通过 `thread::spawn`
    创建的，我们必须传递一个闭包，该闭包将在每个线程中执行。由于我们必须从封装作用域（循环索引 `i`）借用变量，因此闭包本身必须是一个移动闭包。在退出闭包之前，我们调用当前线程句柄的
    `join`，以便所有线程相互等待。这产生了以下输出：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The real power of multithreaded applications is when threads can cooperate
    to do meaningful work. For that, two important things are necessary. Threads need
    to be able to pass data from one another and there should be ways to coordinate
    how the threads are scheduled so that they don''t step over one another. For the
    first problem, Rust provides a message, passing mechanisms via channels. Let''s look
    at the following example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程应用程序的真正力量在于线程可以合作完成有意义的工作。为此，需要两个重要的事情。线程需要能够相互传递数据，并且应该有方法来协调线程的调度，以便它们不会相互干扰。对于第一个问题，Rust通过通道提供了消息传递机制。让我们看看以下示例：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This example is much like the previous one. We import the necessary modules
    to be able to work with channels. We define two vectors, and we will create a
    thread for each pair of elements in the two vectors so that we can add those and
    return the result. We create the channel, which returns handles to the sending
    and the receiving ends. As a safety check, we make sure that the two vectors are
    indeed of equal length. Then, we move on to creating our threads. Since we would
    need to access outside variables here, the threads need to take in a move closure
    like the last example. Further, the compiler will try to use the `Copy` trait
    to copy those variables to the threads. In this case, that will fail since the
    vector type does not implement `Copy`. We need to explicitly `clone` the resources
    so that they do not need to be copied. We run the computation and send the result
    on the sending end of the pipe. Later, we join all the threads. Before we loop
    over the receiving end and print the results, we need to explicitly drop the reference
    to the original handle to the sending end so that all senders are destroyed before
    we start receiving (the cloned senders will be automatically destroyed when the
    threads exit). This prints the following, as expected:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子非常相似。我们导入必要的模块以便能够处理通道。我们定义了两个向量，并将为两个向量中的每一对元素创建一个线程，以便我们可以将它们相加并返回结果。我们创建了通道，它返回发送端和接收端的句柄。作为一个安全检查，我们确保两个向量确实具有相同的长度。然后，我们继续创建我们的线程。由于我们在这里需要访问外部变量，线程需要接受一个类似于上一个例子的`move`闭包。此外，编译器将尝试使用`Copy`特质来复制这些变量到线程中。在这种情况下，这将会失败，因为向量类型没有实现`Copy`。我们需要显式地`clone`资源，这样它们就不需要被复制。我们运行计算，并将结果发送到管道的发送端。稍后，我们连接所有线程。在我们遍历接收端并打印结果之前，我们需要显式地丢弃对原始发送端句柄的引用，这样在我们开始接收之前，所有发送者都会被销毁（复制的发送者将在线程退出时自动销毁）。这会打印出以下内容，正如预期的那样：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Also note that mpsc stands for multiple producer single consumer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，mpsc代表多个生产者单消费者。
- en: 'While working with multiple threads, another common idiom is that of sharing
    a common state between all of those. That, however, can be a can of worms in a
    lot of cases. The caller needs to carefully set up exclusion mechanisms so that
    the state is shared in a race-free manner. Luckily, the borrow checker can help
    in ensuring this is easier. Rust has a number of smart pointers for dealing with
    the shared state. The library also provides a generic mutex type that can be used
    as a lock while working with multiple threads. But perhaps the most important
    are the `Send` and the `Sync` traits. Any type that implements the `Send` trait
    can be shared safely between multiple threads. The `Sync` trait indicates that
    access from multiple threads is safe for the given data. There are a few rules
    around these traits:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在与多个线程一起工作时，另一个常见的习惯用法是在所有这些线程之间共享一个公共状态。然而，在许多情况下，这可能会成为一个问题。调用者需要仔细设置排除机制，以确保状态在无竞争的情况下共享。幸运的是，借用检查器可以帮助确保这一点更容易。Rust有几个智能指针用于处理共享状态。库还提供了一个通用的互斥锁类型，可以在多线程工作时用作锁。但可能最重要的是`Send`和`Sync`特质。任何实现了`Send`特质的数据类型都可以在多个线程之间安全共享。`Sync`特质表示对给定数据的访问在多个线程中是安全的。这些特质有一些规则：
- en: All built-in types implement both `Send` and `Sync` with the exception of anything
    `unsafe`, a few smart pointer types like `Rc<T>` and `UnsafeCell<T>`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有内置类型都实现了`Send`和`Sync`特质，除了任何`unsafe`类型，一些智能指针类型如`Rc<T>`和`UnsafeCell<T>`。
- en: A composite type will automatically implement both, as long as it does not have
    any type that does not implement `Send` and `Sync`
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果复合类型没有包含任何没有实现`Send`和`Sync`的类型，它将自动实现这两个特质。
- en: The `std::sync` package has a lot of types and helpers for working with parallel
    code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sync`包提供了许多类型和辅助工具，用于处理并行代码。'
- en: 'In the previous paragraph, we mentioned unsafe Rust. Let''s take a detour and
    look at that in a bit more detail. The Rust compiler provides some strong guarantees
    around safe programming by using a robust type system. However, there can be cases
    where these become more of an overhead. To handle such cases, the language provides
    a way to opt out of those guarantees. A block of code marked with the `unsafe`
    keyword can do everything Rust can do, and the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段中，我们提到了 unsafe Rust。让我们稍微详细地看看这一点。Rust 编译器通过使用健壮的类型系统提供了一些关于安全编程的强保证。然而，在某些情况下，这些可能更多地成为负担。为了处理这些情况，语言提供了一种退出这些保证的方法。标记为
    `unsafe` 关键字的代码块可以做 Rust 可以做的任何事情，以及以下：
- en: Dereference raw pointer types (*mut T or `*const T`)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解引用原始指针类型 (*mut T 或 `*const T`)
- en: Call unsafe functions or methods
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 unsafe 函数或方法
- en: Implement a trait marked as `unsafe`
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个标记为 `unsafe` 的特质
- en: Mutate a static variable
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改静态变量
- en: 'Let''s look at an example which uses the `unsafe` block of code to dereference
    a pointer:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用 `unsafe` 代码块来解引用指针的示例：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we create a variable and a pointer to it; if we try to dereference the
    pointer without using the `unsafe` block, the compiler will refuse to compile.
    Inside the `unsafe` block, we get back the original value on dereferencing. While
    unsafe code can be dangerous to work with, it's very useful in lower level programming
    like Kernel (RedoxOS) and embedded systems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个变量及其指针；如果我们尝试在不使用 `unsafe` 块的情况下解引用指针，编译器将拒绝编译。在 `unsafe` 块内部，我们在解引用时获得了原始值。虽然与
    unsafe 代码一起工作可能很危险，但它对于底层编程（如内核（RedoxOS）和嵌入式系统）非常有用。
- en: Testing
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'Rust treats testing as a first-class construct; all tools in the ecosystem
    supports testing. The compiler provides a built-in configuration attribute that
    designates a module for testing. There is also a test attribute that designates
    functions as tests. When Cargo generates a project from scratch, it sets up this
    boilerplate. Let''s look at an example project; we will call it factorial. It
    will export a macro that computes the factorial given an integer. Since we have
    conveniently written such a macro before, we will just re-use that code here.
    Note that since this crate will be used as a library, this does not have a main
    function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 将测试视为一等构造；生态系统中的所有工具都支持测试。编译器提供了一个内置的配置属性，用于指定测试模块。还有一个测试属性，用于指定函数为测试。当
    Cargo 从头生成项目时，它会设置这个样板代码。让我们看看一个示例项目；我们将称之为阶乘。它将导出一个宏，用于计算给定整数的阶乘。由于我们之前已经方便地编写了这样一个宏，所以我们在这里将重用那段代码。请注意，由于这个crate将用作库，它没有主函数：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Running `cargo test` runs the stub tests that Cargo generates for us. We will
    copy the code for the factorial macro to the `lib.rs`, which will look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `cargo test` 会运行 Cargo 为我们生成的存根测试。我们将复制阶乘宏的代码到 `lib.rs`，它看起来像这样：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We also added a test to make sure factorial actually works as one would expect.
    The `#[macro_export]` attribute tells the compiler that this macro is to be used
    outside the crate. The compiler built-in `assert_eq!` macro checks that the two
    arguments are indeed equal. We also need to put the `#[allow(unused_macros)]`
    attribute since, without it, the compiler will complain that the macro is not
    being used in non-test code. If we add one more test that looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个测试，以确保阶乘确实按预期工作。`#[macro_export]` 属性告诉编译器这个宏将在crate外部使用。编译器内置的 `assert_eq!`
    宏检查两个参数是否确实相等。我们还需要放置 `#[allow(unused_macros)]` 属性，因为没有它，编译器会抱怨这个宏在非测试代码中没有使用。如果我们添加一个类似的测试：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is obviously wrong, and as expected, fails and gives us a descriptive error.
    The compiler also supports an attribute called `#[should_panic]` that marks tests
    that should panic. In this case, the tests pass only if there is a panic. Another
    way of writing tests is in the documentation which is also run on a Cargo invocation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是错误的，并且如预期的那样失败，并给出了描述性的错误。编译器还支持一个名为 `#[should_panic]` 的属性，用于标记应该引发恐慌的测试。在这种情况下，只有当发生恐慌时，测试才会通过。另一种编写测试的方法是在文档中，这也将在
    Cargo 调用中运行。
- en: 'This is a very important tool in documenting code with working examples, which
    are guaranteed to work as the codebase evolves. Let''s go ahead and add some doctest
    for our factorial macro:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在文档中带有工作示例的重要工具，这些示例在代码库演变过程中保证能够正常工作。让我们继续添加一些关于阶乘宏的 doctest：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '/// # #[macro_use] extern crate factorial;'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # #[macro_use] extern crate factorial;'
- en: '/// # fn main() {'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # fn main() {'
- en: /// assert_eq!(factorial!(0), 1);
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: /// assert_eq!(factorial!(0), 1);
- en: /// assert_eq!(factorial!(6), 720);
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: /// assert_eq!(factorial!(6), 720);
- en: '/// # }'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # }'
- en: /// [PRE53]
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE53]
- en: 'Doctests for macros differ a bit from doctests for everything else in the following
    way:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的doctests与其他内容的doctests略有不同：
- en: They must use the `#[macro_use]` attribute to mark that the macro is being used
    here. Note that an external crate that depends on the crate that exports a macro
    must use that attribute too.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须使用`#[macro_use]`属性来标记这里正在使用宏。请注意，依赖于导出宏的crate的外部crate也必须使用该属性。
- en: They must define the main function and include an `extern crate` directive in
    the doctests. For everything else, the compiler generates the main function as
    needed. The extra `#` marks hide those from the generated documentation.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须定义主函数并在doctests中包含一个`extern crate`指令。对于其他所有内容，编译器会根据需要生成主函数。额外的`#`标记隐藏了这些内容，使其不会出现在生成的文档中。
- en: In general, the tests module, doctests, and the `#[test]` attributes should
    be used only for unit tests. Integration tests should be placed in a top-level
    tests directory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试模块、doctests和`#[test]`属性仅应用于单元测试。集成测试应放置在顶级测试目录中。
- en: The Rust team is working on adding support for running benchmarks in the test
    system. This is only available on nightly for now.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Rust团队正在努力在测试系统中添加运行基准测试的支持。目前这仅限于nightly版本。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter was a very short introduction to the Rust language and the ecosystem.
    Given this background in Rust, let''s look at a frequently asked question: should
    a company adopt Rust? Like a lot of things in engineering, the correct answer
    is that it depends on a lot of factors. One of the primary reasons for adopting
    Rust would be the ability to write robust code with less of a footprint as possible.
    Thus, Rust is suitable for projects targeting embedded devices. This area has
    traditionally used assembly, C, and C++. Rust can provide the same performance
    guarantees while ensuring code correctness. Rust also works well for offloading performance
    intensive computation from Python or Ruby. The primary pain point with Rust is
    that the learning curve can be steep. Thus, a team trying to adopt Rust might
    spend a lot of time fighting with the compiler, trying to run code. This, however,
    eases out with time. Luckily, the compiler error messages are generally very helpful.
    In 2017, the Rust team decided to make ergonomics a priority. This push has made
    onboarding new developers a lot easier. For large Rust projects, compile time
    can be larger than C, C++, or Go. This can become a problem for some teams. There
    are a few ways to work around this problem, one of them being incremental compilation.
    Thus, it is difficult to arrive at a one size fits all solution. Hopefully, this
    short introduction will help in deciding whether to choose Rust in a new project.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对Rust语言及其生态系统的非常简短的介绍。鉴于在Rust方面的这一背景，让我们来看一个经常被问到的问题：公司是否应该采用Rust？像工程中的许多事情一样，正确的答案取决于许多因素。采用Rust的一个主要原因是能够以尽可能小的足迹编写健壮的代码。因此，Rust适合针对嵌入式设备的项目。这个领域传统上使用汇编、C和C++。Rust可以提供相同的表现力保证，同时确保代码的正确性。Rust也很好地用于从Python或Ruby卸载性能密集型计算。Rust的主要痛点是学习曲线可能很陡峭。因此，试图采用Rust的团队可能会花很多时间与编译器斗争，试图运行代码。然而，这会随着时间的推移而缓解。幸运的是，编译器错误信息通常非常有帮助。2017年，Rust团队决定将人体工程学作为优先事项。这一推动使得新开发者的入职变得更加容易。对于大型Rust项目，编译时间可能比C、C++或Go更长。这可能会成为某些团队的问题。有几种方法可以解决这个问题，其中之一是增量编译。因此，很难找到一个适合所有情况的解决方案。希望这篇简短的介绍能帮助决定是否在新项目中选择Rust。
- en: In the next chapter, we will build on what we studied here by looking at how
    Rust handles TCP and UDP connections between two hosts in a network.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过研究Rust如何在网络中处理两个主机之间的TCP和UDP连接，来在此基础上构建我们在这里学到的内容。
