- en: Heap Memory and Smart Pointers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆内存和智能指针
- en: We've talked about the stack, and how it is the place where Rust stores data
    and keeps track of what needs to be kept around and what needs to be cleaned up.
    It's a powerful, useful mechanism, but it's not right for everything.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了栈，以及它是Rust存储数据和跟踪需要保留和需要清理的内容的地方。这是一个强大而实用的机制，但并不适合所有情况。
- en: Imagine we have a variable that contains an image. It takes up several megabytes
    of memory, and we need to transfer ownership of it between various parts of our
    program at different times. If we just put it on the stack, and allow Rust to
    move it into new scopes as needed, everything will work, but it will be slowed
    down by the need to copy those megabytes of data every time it moves the value
    to a new owner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含图像的变量。它占用几个兆字节的内存，我们需要在不同时间将它的所有权在程序的不同部分之间转移。如果我们只是将它放在栈上，并允许Rust根据需要将其移动到新的作用域，一切都会正常工作，但每次将值移动到新的所有者时，都需要复制这些兆字节的数据，这会减慢速度。
- en: That's not the only scenario where storing information on the stack isn't ideal,
    but it's a good illustration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是存储信息在栈上不理想的情况的唯一场景，但它是一个很好的说明。
- en: On the other hand, the last thing we want to do is to break the stack and scope-based
    ownership model, which gives Rust so much of its power.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们最不想做的事情就是破坏栈和基于作用域的所有权模型，这是Rust获得其强大功能的原因。
- en: 'Fortunately, there''s a way to store data outside of the stack, and still have
    it act as though it were part of a scope: smart pointers.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种方法可以在栈外存储数据，同时让它表现得好像它是作用域的一部分：智能指针。
- en: The Rust standard library includes several different kinds of smart pointer,
    meant to address different needs. Smart pointer values themselves are stored in
    the stack, just like other data values are, but they include the necessary instrumentation
    to allocate a chunk of *heap* memory when they are created, and release it back
    to the system when their lifetimes end. A data value stored in that heap memory
    can be accessed through the smart pointer, as if it was stored inside the smart
    pointer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库包括几种不同类型的智能指针，旨在满足不同的需求。智能指针的值本身存储在栈上，就像其他数据值一样，但它们包括在创建时分配一块*堆*内存的必要工具，并在其生命周期结束时将其释放回系统。存储在该堆内存中的数据值可以通过智能指针访问，就像它存储在智能指针内部一样。
- en: The **heap** is the counterpoint to the stack. Where the stack has a specific
    structure that helps Rust keep track of which operations are safe and which are
    not at any given time, the heap can be thought of as unorganized memory. In general,
    a program can ask for a section of heap memory to be reserved for use at any time,
    and can release it back to the system at any time. Now imagine what happens when
    a section of heap memory is allocated too late, or released too soon, or not released
    when it should be. Mistakes with memory allocation and deallocation are one of
    the main reasons programs crash.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**是栈的对立面。栈有一个特定的结构，有助于Rust跟踪在任何给定时间哪些操作是安全的，哪些是不安全的，而堆可以被视为无组织内存。一般来说，程序可以在任何时间请求为使用保留一段堆内存，并且可以在任何时间将其释放回系统。现在想象一下，当分配的堆内存部分分配得太晚，或者释放得太早，或者应该在释放时没有释放会发生什么。内存分配和释放的错误是程序崩溃的主要原因之一。'
- en: Thanks to smart pointers, the lifetime of values stored in heap memory mirror
    the lifetimes of values that follow Rust's normal rules, but with the big advantage
    that the section of heap memory does not have to be copied when the smart pointer
    is moved to a new scope. Our multi-megabyte image can be moved around between
    scopes for the cost of moving a few bytes, because the image itself does not have
    to move, just the smart pointer that controls it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了智能指针，存储在堆内存中的值的生命周期与遵循Rust正常规则的值的生命周期相匹配，但有一个大优点，即当智能指针移动到新的作用域时，不需要复制堆内存的部分。我们的多兆字节图像可以在作用域之间移动，只需移动几个字节，因为图像本身不需要移动，只需要控制它的智能指针。
- en: Box
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Box
- en: 'The most straightforward of the standard smart pointers is the `Box`. A `Box`
    does what we''ve been discussing so far: it stores a data value on the heap, while
    ensuring that it still follows the lifetime rules as if it were actually part
    of the `Box` value itself.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 标准智能指针中最直接的是`Box`。`Box`做了我们之前讨论的事情：它在堆上存储一个数据值，同时确保它仍然遵循生命周期规则，就像它是`Box`值本身的一部分一样。
- en: 'Here''s an example. First, we''ll create a data type for the data we want to
    store on the heap:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。首先，我们将为要在堆上存储的数据创建一个数据类型：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, creating and using the `Box` itself is easy:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建和使用`Box`本身是很容易的：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line creates a `Box`. We have to give it a data value to store, because
    one thing Rust is not okay with is an empty `Box`, so we initialize a `Person`
    object and pass it to the function, which creates a new `Box` to be used as its
    internal value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个`Box`。我们必须给它一个要存储的数据值，因为Rust不允许空`Box`，所以我们要初始化一个`Person`对象并将其传递给函数，该函数创建一个新的`Box`作为其内部值。
- en: Why does Rust not allow an empty `Box`, or any other kind of smart pointer,
    for that matter? Because if it did, then it would have to worry about whether
    a given smart pointer referred to initialized memory or not whenever that smart
    pointer's contents were accessed. Requiring that as long as the smart pointer
    exists the memory it manages must contain a valid data value simplifies many things
    and makes a common kind of error impossible.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Rust不允许空`Box`，或者任何其他类型的智能指针？因为如果允许，那么每次访问该智能指针的内容时，它都必须担心该智能指针是否指向已初始化的内存。要求只要智能指针存在，它管理的内存必须包含有效的数据值，这简化了许多事情，并使得一种常见的错误变得不可能。
- en: 'Once we have an initialized the `Box`, we can mostly treat it as if it was
    a normal borrow of the contained data. We can move the data back out onto the
    stack by dereferencing it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了`Box`，我们就可以将其主要视为对包含数据的正常借用。我们可以通过解引用来将数据移回栈上：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This moves the `Person` value from inside the `Box` named `jack` to the `x`
    variable, and renders `jack` unusable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`Person`值从名为`jack`的`Box`内部移动到`x`变量中，使得`jack`变得不可用。
- en: 'We can also access the contained data value''s data and functions through the
    `Box`, again as if it were a borrow of the contained data:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过`Box`访问包含的数据值的数据和函数，就像它是包含数据的借用一样：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we''re asking to borrow `jack.name` into `x`, then printing out that
    name. We could have also gotten the same result by doing the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求借用`jack.name`到`x`，然后打印出那个名字。我们也可以通过以下方式得到相同的结果：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But that actually works in a very different way. The first example borrows the
    name, and then prints out that borrowed `String` value. The second one actually
    calls a function called `jack.name.fmt`, which has an immutable borrow as its
    `self` parameter. This works out because Rust is smart about dereferencing and
    function calls.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但这实际上是以非常不同的方式工作的。第一个例子是借用名称，然后打印出借用的`String`值。第二个实际上调用了一个名为`jack.name.fmt`的函数，它的`self`参数是一个不可变借用。这是因为Rust在解引用和函数调用方面非常智能。
- en: Where did `fmt` get called? The answer is that `println!` is a *macro*, which
    means that it's not actually a function, but instead is kind of like pasting some
    code right into the program here. The pasted code calls `fmt`, so it's as if we
    called `fmt` ourselves. In Rust, we can recognize macros because their names always
    end with `!`, and function names never do.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt`在哪里被调用的？答案是`println!`是一个宏，这意味着它实际上不是一个函数，而是像将一些代码直接粘贴到程序中一样。粘贴的代码调用`fmt`，所以这就像我们亲自调用了`fmt`一样。在Rust中，我们可以通过宏的名称总是以`!`结尾来识别它们，而函数名称则不会。'
- en: Box and variable size
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Box`和可变大小'
- en: We've previously bumped into the need for Rust to know exactly how many bytes
    a particular data value can occupy. Most of the time, Rust can figure that out,
    and most of the time, it's not a problem, but there are a few cases where it's
    impossible to define a fixed size for a data value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前遇到过Rust需要确切知道特定数据值可以占用多少字节的必要性。大多数时候，Rust可以解决这个问题，大多数时候这并不是问题，但有一些情况下，为数据值定义固定大小是不可能的。
- en: 'One fundamental example is a data structure, such as the following one, where
    an instance contains other instances of itself:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的例子是数据结构，例如以下结构，其中实例包含它自己的其他实例：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That looks reasonable at first glance, but Rust quite rightly points out that
    the calculated size is infinite (because the size of a `TreeNode` is the size
    of two `TreeNodes` plus `32` bits):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看这似乎是合理的，但Rust正确地指出，计算出的尺寸是无限的（因为`TreeNode`的大小是两个`TreeNode`的大小加上`32`位）：
- en: '![](img/b2cba01a-667a-40e2-ba7b-61bb6c478338.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2cba01a-667a-40e2-ba7b-61bb6c478338.png)'
- en: 'Just as the compiler suggests, we can fix this with a `Box`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如编译器建议的那样，我们可以用一个`Box`来修复这个问题：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, the size of a `TreeNode` is the size of two Boxes plus 32 bits, which is
    entirely reasonable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`TreeNode`的大小是两个`Box`的大小加上32位，这是完全合理的。
- en: Box and Any
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Box`和`Any`'
- en: When a variable's type is `Box<dyn Any>`, it acts much like an `&dyn Any`, but
    gains a new feature. A normal `&dyn Any` has a `downcast_ref` function that we
    can use to get a reference to the contained value, if we know what type to use
    to extract it. Now, `&dyn mut Any` adds a `downcast_mut` that we can use to get
    a mutable reference. When we have a `Box<dyn Any>`, we have access to both of
    those functions, but we can also call a plain `downcast` function to move the
    contained value out of the `Any` and into a variable of the correct type. This
    consumes the `Box` and the `Any`, and gives us back a new `Box` containing the
    data value with its correct data type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量的类型是 `Box<dyn Any>` 时，它表现得就像一个 `&dyn Any`，但增加了一个新特性。一个普通的 `&dyn Any` 有一个
    `downcast_ref` 函数，我们可以使用它来获取包含值的引用，如果我们知道使用什么类型来提取它。现在，`&dyn mut Any` 增加了一个 `downcast_mut`，我们可以使用它来获取可变引用。当我们有一个
    `Box<dyn Any>` 时，我们可以访问这两个函数，但也可以调用一个普通的 `downcast` 函数，将包含的值从 `Any` 移动到正确类型的变量中。这会消耗
    `Box` 和 `Any`，并给我们返回一个新的包含数据值及其正确数据类型的 `Box`。
- en: Don't forget that we need to have `use std::any::Any;` in our code if we're
    going to use the `Any` trait.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，如果我们打算使用 `Any` 特性，我们代码中需要包含 `use std::any::Any;`。
- en: 'We can create a boxed `Any` almost the same way we created a boxed `Person`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以几乎以创建boxed `Person` 相同的方式创建boxed `Any`：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only difference here is that we're telling Rust that we want the `jill`
    variable to contain a `Box<dyn Any>` instead of letting it decide for itself that
    the variable contains a `Box<Person>`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是，我们告诉 Rust 我们想要 `jill` 变量包含一个 `Box<dyn Any>` 而不是让它自己决定变量包含 `Box<Person>`。
- en: 'Now, to access the contained `Person`, we can do this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要访问包含的 `Person`，我们可以这样做：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Like the other downcast functions, we need to specify which concrete data type
    we're downcasting for. The downcast function returns a `Result`, which contains
    a `Box<Person>` if it's successful. Once we have a `Box<Person>`, we can do whatever
    we like with the `Person` value it contains.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他 downcast 函数一样，我们需要指定我们正在向下转换的具体数据类型。downcast 函数返回一个 `Result`，如果成功，则包含一个
    `Box<Person>`。一旦我们有了 `Box<Person>`，我们就可以对它包含的 `Person` 值做任何我们想做的事情。
- en: The `unwrap` function we're calling here consumes a `Result` and returns its
    contained value if it's a success, or terminates the program with an error message
    if it's a failure. We use `unwrap` to handle a `Result` when we're very sure that
    it's going to be a success.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里调用的 `unwrap` 函数消耗一个 `Result`，如果成功，则返回其包含的值，如果失败，则终止程序并显示错误信息。我们使用 `unwrap`
    来处理一个我们非常确信将会成功的 `Result`。
- en: Vec and String
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vec 和 String
- en: When a data value might *change* size, it pretty much has to be stored on the
    heap. For this reason, the Rust prelude includes the `String` and `Vec` types,
    which are smart pointers specialized for storing text and variable-length arrays,
    respectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据值可能 *改变* 大小时，它几乎必须在堆上存储。因此，Rust 预定义中包含了 `String` 和 `Vec` 类型，它们分别是用于存储文本和可变长度数组的智能指针。
- en: String
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: String
- en: We've already seen `String` several times, when we used it to simplify the ownership
    of text strings. There are other things we can do with it, though, because the
    text stored in a `String` can be changed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次看到了 `String`，当我们使用它来简化文本字符串的所有权时。尽管如此，我们还可以用它做其他事情，因为存储在 `String` 中的文本可以更改。
- en: 'Here, we''re changing a `String` several times, as shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们像以下代码所示那样多次更改 `String`：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s take a look at that step by step:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地看看：
- en: On the first line, we're creating an empty `String`, and storing it in a mutable
    variable. It has to be mutable, because we're going to change the stored value.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个空的 `String`，并将其存储在一个可变变量中。它必须是可变的，因为我们将要改变存储的值。
- en: On the second line, we're appending a single character to the `String`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二行，我们正在向 `String` 添加一个字符。
- en: On the third line, we're appending the whole contents of an `&str` to the `String`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三行，我们正在将一个 `&str` 的全部内容追加到 `String` 中。
- en: On the fourth line, we're inserting the whole contents of an `&str` at byte
    offset `11` in the string. Remember that Rust starts counting from zero, so the
    offset of the `W` in the string is `0`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第四行，我们正在将一个 `&str` 的全部内容插入到字符串的 `11` 字节偏移处。记住，Rust 从零开始计数，所以字符串中 `W` 的偏移量是
    `0`。
- en: On the fifth line, we're replacing the characters in a range of offsets with
    a new sequence of characters. The specific range we're using is `28..`, which
    means the range beginning at `28` and going on to infinity (or the end of the
    `String`, whichever comes first).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第五行，我们正在替换一系列偏移量中的字符，用一组新的字符序列来替换。我们使用的具体范围是 `28..`，这意味着从 `28` 开始的范围，一直延伸到无限（或者字符串的末尾，哪个先到算哪个）。
- en: Last, we print out the final result of all our manipulations.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们打印出所有操作的最后结果。
- en: We have to be careful about using byte offsets with `String`, because the `String`
    type always stores text encoded with the `UTF-8` encoding. That means that the
    number of bytes any single character might use can be as little as one, and as
    large as four bytes. If we try to use an offset that is in the middle of a character,
    the program will terminate with an error message. `String` and `&str` have an
    assortment of functions that let us find valid byte offsets within a `String`,
    or manipulate it without using offsets at all, such as `find`, `lines`, `split_whitespace`,
    `contains`, `starts_with`, `ends_with`, `split`, `trim`, and `char_indices`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在使用 `String` 的字节偏移量时必须小心，因为 `String` 类型总是使用 `UTF-8` 编码来存储文本。这意味着任何单个字符可能使用的字节数可以从一个字节少到四个字节。如果我们尝试使用位于字符中间的偏移量，程序将因错误信息而终止。`String`
    和 `&str` 有许多函数可以让我们在 `String` 中找到有效的字节偏移量，或者在不使用偏移量的情况下操作它，例如 `find`、`lines`、`split_whitespace`、`contains`、`starts_with`、`ends_with`、`split`、`trim`
    和 `char_indices`。 '
- en: Using our `text` variable, the data type of `&text` can be `&String` *or* `&str`.
    Rust's type inference system makes that decision, based on the data type of the
    variable where the value will be stored, or the function parameter that it will
    be assigned to, and so on. That also means that any functions that are implemented
    for `&str` or that take an `&str` parameter can be used on a `String` as well.
    For example, `str` has a `lines(&self)` function, so we can call `text.lines()`.
    Further, we can pass a `String` as the text parameter to the `push_str`, `insert_str`,
    and `replace_range` functions we saw in this example, just as if it was a real
    `&str`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 `text` 变量，`&text` 的数据类型可以是 `&String` 或 `&str`。Rust 的类型推断系统会根据将要存储值的变量的数据类型，或者将要分配给函数参数的数据类型等来做出决定。这也意味着，任何为
    `&str` 实现的函数或者接受 `&str` 参数的函数也可以用在 `String` 上。例如，`str` 有一个 `lines(&self)` 函数，所以我们可以调用
    `text.lines()`。此外，我们还可以将 `String` 作为文本参数传递给我们在本例中看到的 `push_str`、`insert_str` 和
    `replace_range` 函数，就像它是一个真正的 `&str` 一样。
- en: Vec
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vec
- en: The `Vec` data type stores a *vector*, which is a word commonly used in programming
    to indicate a one-dimensional, variable-size array. Like actual arrays, they can
    store multiple data values, as long as those data values all have the same data
    type. Like `Strings`, `Vecs` can change size, and so they are specialized smart
    pointers that store their contained values on the heap.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec` 数据类型存储一个 *向量*，这是编程中常用的一个词，用来表示一维、可变长度的数组。像实际的数组一样，它们可以存储多个数据值，只要这些数据值都具有相同的数据类型。像
    `Strings` 一样，`Vecs` 可以改变大小，因此它们是专门化的智能指针，它们在堆上存储包含的值。'
- en: 'To create an empty `Vec`, we can use `Vec::new()`, like so:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空的 `Vec`，我们可以使用 `Vec::new()`，如下所示：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we can append a data value to it using `push`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `push` 向它添加一个数据值：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, so far, we haven't said a word about what type of data the vector can contain,
    and Rust is perfectly happy because we didn't *need* to. Everything we wrote is
    consistent with the vector containing one of the floating point primitive data
    types, so that's what Rust figures it contains.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到目前为止，我们还没有提到向量可以包含哪种类型的数据，而 Rust 对此非常满意，因为我们不需要这样做。我们写的所有内容都与向量包含浮点原始数据类型之一是一致的，所以
    Rust 就认为它包含的是这种类型。
- en: What happens if we do something that isn't consistent, such as try to store
    an `&str` in the vector?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们做了不一致的事情，比如尝试在向量中存储一个 `&str`，会发生什么？
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now Rust can''t figure out what data type the vector is supposed to contain,
    so it refuses to compile:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Rust 无法确定向量应该包含哪种数据类型，因此它拒绝编译：
- en: '![](img/1eecb891-377b-426c-b184-815c363aabfd.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1eecb891-377b-426c-b184-815c363aabfd.png)'
- en: 'However, we can do something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以这样做：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we've got a variable named `x` that has `f64` for its data type. That's
    compatible with the "some kind of floating point number" that Rust was able to
    figure out before, so adding it to the vector doesn't cause any problems. In fact,
    it tells Rust that our earlier `1.5` should be treated as an `f64` too, and that
    the vector contains `f64` values, specifically.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为 `x` 的变量，其数据类型为 `f64`。这与 Rust 之前能够识别的“某种浮点数”兼容，因此将其添加到向量中不会引起任何问题。实际上，它告诉
    Rust，我们之前的 `1.5` 应该被视为 `f64`，并且该向量包含特定的 `f64` 值。
- en: We used numbers for that example, but Rust can store any data type in a `Vec`,
    as long is we follow the rule of only one data type per vector.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了数字作为那个例子，但只要我们遵循每个向量只包含一个数据类型的规则，Rust 就可以在 `Vec` 中存储任何数据类型。
- en: 'Adding an `&str` to our vector of numbers was a problem, but we can create
    a vector of `&str` without any trouble:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个 `&str` 添加到我们的数字向量中是个问题，但我们可以无任何困难地创建一个 `&str` 向量：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can access elements contained in a vector using the same syntax we would
    use for an array:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与数组相同的语法来访问向量中的元素：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Vec` implements a number of functions for accessing the stored data values,
    such as the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec` 实现了多个用于访问存储数据值的函数，如下所示：'
- en: '`pop`, which removes and returns the last item in the vector'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop`，它移除并返回向量中的最后一个项目'
- en: '`remove`, which removes the item at a specific index'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`，它从特定索引处移除项目'
- en: '`insert`, which adds an item at a specific index, pushing the item that was
    at that index and everything after it back one'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert`，它在特定索引处添加一个项目，将位于该索引处的项目以及之后的所有项目向后推一个位置'
- en: '`append`, which moves values out of another vector and adds them at the end'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append`，它将值从另一个向量中移出并添加到末尾'
- en: '`len`, which just tells us how many items are in the vector'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len`，它只是告诉我们向量中有多少个项目'
- en: '`iter`, which returns an iterator for the contained data'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iter`，它返回包含数据的迭代器'
- en: 'Creating an empty vector and then pushing a bunch of values to it can get a
    little bit tedious, so there''s a macro to make things easier:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空向量然后向其中推送大量值可能会有些繁琐，所以有一个宏可以使事情变得更容易：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We recognize the macro by its `!` as always, but this time it's not really pretending
    to be a function. Instead, it almost looks like a prefixed array expression. Macros
    have a lot of flexibility about how they look, and for this one, looking similar
    to an array expression makes sense. The end result of this is just like we'd created
    a vector with `new` and then added information to it with `push`. It's just a
    more convenient way of writing the same thing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过其 `!` 符号来识别宏，但这次它并不是真正地假装是一个函数。相反，它几乎看起来像是一个前缀数组表达式。宏在它们的形态上有很多灵活性，对于这个宏来说，看起来像数组表达式是有意义的。这个结果就像我们使用
    `new` 创建了一个向量，然后使用 `push` 向其中添加信息一样。这仅仅是一种更方便的写法。
- en: Rc
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rc
- en: There are times when Rust's insistence that each data value has only one owner
    just doesn't fit our program's data model. What if we're writing a word processing
    engine, and we wanted people to be able to include the same image in multiple
    places without wasting memory on duplicates; or what if we were modeling an organization
    where one person might be referenced by multiple roles?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，Rust 对每个数据值只有一个所有者的坚持并不适合我们的数据模型。如果我们正在编写一个文字处理引擎，并希望人们能够在多个地方包含相同的图像而不浪费内存在重复上；或者如果我们正在模拟一个组织，其中一个人可能被多个角色引用呢？
- en: 'We could have one definitive owner of the shared information, and use borrows
    everywhere else, and if that works, it''s probably the way to go. There are two
    situations where it doesn''t work, though:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个共享信息的确定所有者，并在其他地方使用借用，如果这行得通，那可能就是可行的方案。尽管如此，有两种情况它是不适用的：
- en: We don't know how long the lifetimes of each of the users of the shared data
    value will be
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不知道共享数据值每个用户的生命周期有多长
- en: We need write access to the shared data in at least one of the users
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们至少需要有一个用户对共享数据有写访问权限
- en: 'A word processing engine is a good example of problem number one: An image
    may be used more than once in the same document, but we never know when the user
    might decide to delete one of them, nor do we know which one will be deleted.
    Maybe all of them will be deleted, and who knows what order that will happen in
    or what the timing will be like.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 文字处理引擎是问题一的很好例子：一个图像可能在同一文档中被使用多次，但我们永远不知道用户何时会决定删除其中一个，也不知道哪个会被删除。也许所有都会被删除，而且谁知道这会发生什么顺序或时间呢。
- en: To fully address problem number two, we'll need both the `Rc` and `RefCell`
    data types, so we'll talk about that later in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全解决第二个问题，我们需要 `Rc` 和 `RefCell` 数据类型，所以我们将在本章后面讨论这一点。
- en: When we find ourselves in a situation where we need to share information without
    knowing about the relative lifetimes of the various borrows of that information,
    we can use the `Rc` smart pointer to make everything work. `Rc` stands for "reference
    counted," and what it does is keep track of how many copies of itself exist. When
    that number reaches zero, the lifetime of the contained data value ends.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发现自己处于需要共享信息但不知道该信息各种借用相对生命周期的情境时，我们可以使用 `Rc` 智能指针来让一切正常工作。`Rc` 代表 "引用计数"，它所做的就是跟踪自身存在的副本数量。当这个数字达到零时，包含的数据值的生命周期结束。
- en: 'Let''s look at creating some reference-counted smart pointers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一些引用计数智能指针：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We created the first `Rc` values using `Rc::new`, on the first two lines of
    the function body. Both of them contain a `String` value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Rc::new` 在函数体的前两行创建了第一个 `Rc` 值。它们都包含一个 `String` 值。
- en: After that, we used `Rc::clone` to create several duplicates of each `Rc`. Keep
    in mind that the `String` values are *not* being duplicated, just the `Rc` smart
    pointer. The returned vector contains four `Rc`s that share access to the same `ada`
    string, and three that share access to the same `mel` string.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用 `Rc::clone` 来创建每个 `Rc` 的几个副本。请注意，`String` 值**没有**被复制，只是 `Rc` 智能指针。返回的向量包含四个共享相同
    `ada` 字符串的 `Rc`，以及三个共享相同 `mel` 字符串的 `Rc`。
- en: Then the function's scope ends, and so does the lifetime of the original `ada`
    and `mel` reference-counted smart pointers. However, the various copies are part
    of the return value, so their lifetimes do not end, and as a consequence the reference
    counts of the two string values are still greater than zero, and their lifetimes
    also do not end.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数的作用域结束，原始的 `ada` 和 `mel` 引用计数智能指针的生命周期也随之结束。然而，各种副本是返回值的一部分，所以它们的生命周期不会结束，因此这两个字符串值的引用计数仍然大于零，它们的生命周期也不会结束。
- en: We used `Rc::clone` here, but if we'd written `ada.clone()` or `mel.clone()`,
    it would have produced the same result. People usually prefer to write it as `Rc::clone`
    to make it plain that we're cloning the `Rc`, and not the data value the `Rc`
    contains.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了 `Rc::clone`，但如果我们写了 `ada.clone()` 或 `mel.clone()`，会产生相同的结果。人们通常更喜欢写成
    `Rc::clone`，以清楚地表明我们正在克隆 `Rc`，而不是 `Rc` 包含的数据值。
- en: Now we'll write a short program that relies on user input to determine when
    the lifetime of each of the `Rc` copies ends. There's no fixed order in which
    the `Rc`s are to be removed, so the compiler can't know ahead of time when it's
    safe to clean up their shared data values, but thanks to the reference counting
    mechanism, the `String` values are retained as long as they are needed, and then
    their lifetime ends.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个简短的程序，该程序依赖于用户输入来确定每个 `Rc` 副本的生命周期何时结束。没有固定的 `Rc` 删除顺序，所以编译器无法提前知道何时可以清理它们共享的数据值，但多亏了引用计数机制，只要需要，`String`
    值就会被保留，然后它们的生命周期结束。
- en: 'Here, we remove elements from the vector based on the user input:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据用户输入从向量中删除元素：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we call our `make_vector_of_rcs` function to create the initial vector
    of reference-counted smart pointers to the shared data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用我们的 `make_vector_of_rcs` 函数来创建初始的引用计数智能指针向量，这些智能指针指向共享数据。
- en: Then, we loop as long as there are any values still stored in the vector. Within
    the loop, we first print out the current vector (the `{:?}` code tells Rust to
    print out the `'debug'` representation of the vector, which looks like a Rust
    array expression). Then we print out a prompt, and flush the output stream to
    make sure the prompt is actually displayed. Then we read a line from the input
    stream, parse it into an integer, and use that integer as an index to remove an
    element from the vector.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们循环，直到向量中还有任何值仍然被存储。在循环中，我们首先打印出当前的向量（`{:?}` 代码告诉 Rust 打印出向量的 `'debug'`
    表示形式，它看起来像 Rust 数组表达式）。然后我们打印出一个提示，并刷新输出流以确保提示确实被显示。然后我们从输入流中读取一行，将其解析为整数，并使用该整数作为索引从向量中删除一个元素。
- en: 'When we run that program, it looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行那个程序时，它看起来像这样：
- en: '![](img/8602814b-242b-41a5-b7cd-57772c25200c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8602814b-242b-41a5-b7cd-57772c25200c.png)'
- en: When the last `Rc` that references the `"Mel"` value is removed, the lifetime
    of that `String` finally ends, and the same goes for the `String` containing `"Ada"`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当最后一个引用`"Mel"`值的`Rc`被移除时，那个`String`的生命周期最终结束，对包含`"Ada"`的`String`也是如此。
- en: We used `unwrap` a lot in that code, and really, we overused it. Unwrapping
    the results of `flush` and `read_line` makes sense; if those return a failed `Result`,
    the program should probably terminate because something has gone wrong on the
    operating system level. However, unwrapping the result of `parse` is not such
    a good idea, because a failed result there just means that the user entered something
    unexpected. We really should have used `match` to respond by printing out a message
    when the input doesn't parse properly. We also should have checked that the number
    was the index of a value that was actually within the vector, and not off beyond
    one of the ends. Rust won't let us access an invalid index, but trying to do so
    will terminate the program with an error message, which isn't great.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在那段代码中使用了大量的`unwrap`，实际上，我们过度使用了它。对`flush`和`read_line`的结果进行解包是有意义的；如果它们返回一个失败的`Result`，程序可能应该终止，因为操作系统级别出了问题。然而，对`parse`的结果进行解包并不是一个好主意，因为那里的失败结果只是意味着用户输入了意料之外的内容。我们真的应该使用`match`来响应，当输入无法正确解析时打印出一条消息。我们还应该检查数字是否是向量中实际存在的值的索引，而不是超出两端。Rust不会让我们访问无效的索引，但尝试这样做将导致程序因错误消息而终止，这并不理想。
- en: Parsing means taking information encoded as a text string, and turning it into
    a data value we can actually work with; for example, turning `"5"` into the number `5`.
    The `parse` function is pretty wild, because it figures out what kind of information
    we want based on the data type of the variable we're assigning its return value
    to, and then figures out which function to use to turn a string into that kind
    of data value. Of course, it can't write that function for us, so it only works
    for data types that have such a function in the first place. Also, it's really
    the Rust compiler doing all of the figuring out. The `parse` function just takes
    advantage of the compiler's rules and inference system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解析意味着将编码为文本字符串的信息转换为我们可以实际处理的数据值；例如，将`"5"`转换为数字`5`。`parse`函数相当强大，因为它根据我们分配给其返回值的变量的数据类型来确定我们想要的信息类型，然后确定使用哪个函数将字符串转换为那种数据类型。当然，它不能为我们编写那个函数，所以它只适用于最初就有那种函数的数据类型。此外，实际上所有的推理工作都是由Rust编译器完成的。`parse`函数只是利用了编译器的规则和推理系统。
- en: Weak references
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弱引用
- en: 'Reference counting has one fatal flaw, which is the reason why it''s not used
    by default for all variables in every programming language: cycles. If two or
    more reference counted values somehow refer to each other, their lifetimes would
    never end. They form what is called a *cycle*.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数有一个致命的缺陷，这也是为什么它不是默认用于每种编程语言中所有变量的原因：循环。如果有两个或更多引用计数的值以某种方式相互引用，它们的生命周期将永远不会结束。它们形成了所谓的*循环*。
- en: It isn't always obvious when a cycle happens. If A refers to B, which refers
    to C, which refers to D, which refers to A, we still have a cycle.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是一目了然何时发生循环。如果A指向B，B指向C，C指向D，D又指向A，我们仍然有一个循环。
- en: We can break cycles by using *weak references*, which are an ancillary data
    type for `Rc`. When we have an `Rc`, we can call its `downgrade` function (for
    example, `let weak_mel = Rc::downgrade(&mel)`) to retrieve a `Weak` data value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用*弱引用*来打破循环，这是`Rc`的辅助数据类型。当我们有一个`Rc`时，我们可以调用它的`downgrade`函数（例如，`let weak_mel
    = Rc::downgrade(&mel)`）来检索一个`Weak`数据值。
- en: We can't actually do anything with a `Weak` except retrieve an `Rc` by calling
    its `upgrade` function (for example `weak_mel.upgrade()`), but using a `Weak`
    lets us keep track of a reference-counted value without actually referencing it,
    which means we can avoid creating cycles while still organizing our information
    in the way that seems natural.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上对`Weak`无法做任何事情，除了通过调用其`upgrade`函数（例如`weak_mel.upgrade()`）来检索一个`Rc`，但使用`Weak`让我们能够在不实际引用的情况下跟踪引用计数值，这意味着我们可以在组织信息的方式上保持自然的同时避免创建循环。
- en: If the number of `Rcs` that reference a data value is zero, that data value's
    lifetime ends, *even if there are still* `Weaks` *that reference the value*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引用数据值的`Rcs`的数量为零，即使还有*弱引用*引用该值，该数据值的生命周期也会结束。
- en: Because the referenced value might not exist anymore, the `upgrade` function
    returns an `Option`. When we call `upgrade`, we'll either get a `Some` containing
    our `Rc`, or we'll get `None`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引用的值可能已经不存在，`upgrade`函数返回一个`Option`。当我们调用`upgrade`时，我们可能会得到包含我们的`Rc`的`Some`，或者我们可能会得到`None`。
- en: So, the pattern here is that we use `Rc` when we want to make sure that the
    data value sticks around as long as we need it, and `Weak` when we *know* it's
    going to stick around (for example, when it's referring to the parent node in
    a tree structure) or when we *don't care* whether it sticks around (for example,
    when it's a cached value that we can regenerate if it's missing).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的模式是，当我们想要确保数据值在我们需要它的时候一直存在时，我们使用`Rc`，当我们**知道**它将一直存在（例如，当它引用树结构中的父节点时）或者当我们**不关心**它是否存在（例如，当它是一个可以重新生成的缓存值时）时，我们使用`Weak`。
- en: Cell and RefCell
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cell和RefCell
- en: Rust's rule that only one block of code can have write access to a data value
    at any one time is a good one, but sometimes the restrictions that are needed
    to be sure *when the compiler is running* that this rule will always be followed
    are too tight. Sometimes, we need the extra freedom that comes from having the
    rule checked *while the program is running*, instead.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的规则是任何时刻只有一个代码块可以写入数据值，这是一个好规则，但有时确保在编译器运行时始终遵循此规则的限制过于严格。有时，我们需要在程序运行时检查规则的额外自由度。
- en: The compiler checks would ensure that the program *can't* break the rule, while
    the runtime checks ensure that the program *doesn't* break the rule, giving us
    more flexibility at the cost of some overhead.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器检查将确保程序**不能**破坏规则，而运行时检查将确保程序**不会**破坏规则，这为我们提供了更多的灵活性，但代价是增加了开销。
- en: To support this option, Rust provides us with the `Cell` and `RefCell` data
    types, which are smart pointers that allow us to change their contents, even if
    they are not stored in a mutable variable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个选项，Rust为我们提供了`Cell`和`RefCell`数据类型，它们是智能指针，允许我们在它们的内容不是存储在可变变量中的情况下更改它们。
- en: Cell
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cell
- en: 'The `Cell` type stores a single data value, which we can move in and out of
    the `Cell` even if the `Cell` is not marked as mutable. To move a value into the
    `Cell`, we can use the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cell`类型存储单个数据值，即使`Cell`没有标记为可变，我们也可以将其移动到`Cell`中。要将值移动到`Cell`中，我们可以使用以下方法：'
- en: '`Cell::new`, because the initial value was moved into the cell when the cell
    is created'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cell::new`，因为当创建单元格时，初始值已经移动到单元格中'
- en: '`set`, to move a new value into the cell, and end the lifetime of the value
    already stored there'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`，用于将新值移动到单元格中，并结束已存储值的生命周期'
- en: '`replace`, to move a new value into the cell, and move the old value into the
    current scope'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`，用于将新值移动到单元格中，并将旧值移动到当前作用域'
- en: 'To move a value out of the `Cell`, we can use the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值从`Cell`中移出，我们可以使用以下方法：
- en: '`replace`, to move a new value into the cell, and move the old value into the
    current scope'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`，用于将新值移动到单元格中，并将旧值移动到当前作用域'
- en: '`into_inner`, to consume the cell, and return the value it contained'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`into_inner`，用于消耗单元格，并返回它所包含的值'
- en: '`Cell`s don''t support any operations that would allow us to have an empty
    `Cell`: they always have to contain something, just like the other smart pointer
    types.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cell`不支持任何允许我们拥有空`Cell`的操作：它们总是必须包含某些内容，就像其他智能指针类型一样。'
- en: 'Let''s take a look at a cell in action:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个单元格的实际应用：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that the `cell` variable *is not mutable*. Here, we're setting up a cell,
    using `replace` a couple of times to retrieve the old value from the `cell` at
    the same time that we set a new one, and then using `set` to set a new value while
    discarding the old one, and finally using `into_inner` to get rid of the `cell`
    while extracting its contained value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`cell`变量**不是可变的**。在这里，我们设置了一个单元格，使用`replace`几次来从`cell`中检索旧值，同时设置一个新值，然后使用`set`来设置新值并丢弃旧值，最后使用`into_inner`来移除`cell`并提取其包含的值。
- en: 'The `into_inner` function moves the contained value out of the `cell`, but
    that doesn''t create an empty `cell` because the `cell` no longer exists. If we
    tried to access it after calling `into_inner`, we''d get an error from the compiler,
    as shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`into_inner`函数将包含的值从`cell`中移出，但这不会创建一个空的`cell`，因为`cell`已经不存在了。如果我们尝试在调用`into_inner`之后访问它，编译器会显示错误，如下面的截图所示：'
- en: '![](img/8a5ccd98-2829-485e-aed6-421c44daa6a7.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a5ccd98-2829-485e-aed6-421c44daa6a7.png)'
- en: 'There''s one more function that we can use to access the data value contained
    in a `Cell`, but only if the contained data type has the `Copy` trait: `get`.
    We could do something like `println!("{}", cell.get())` to leave the content of
    the `cell` in place while retrieving a copy of it, but only if copying the data
    value is actually possible.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用一个函数来访问`Cell`中包含的数据值，但前提是包含的数据类型具有`Copy`特性：`get`。我们可以做类似`println!("{}",
    cell.get())`的事情，在检索其副本的同时保留`cell`的内容，但前提是复制数据值实际上是可能的。
- en: What's the point?
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这有什么用？
- en: Okay, so what's this actually good for? We could have just used a mutable variable,
    and produced the same result with less overhead. `Cell` (and `RefCell`) are mostly
    for use with `Rc` and similar data types. The `Rc` type follows Rust's normal
    rules about mutability, and since it's meant to be a mechanism for accessing a
    shared data value in many places, that means that the shared value must be immutable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这实际上有什么好处？我们本来可以用一个可变变量，以更少的开销产生相同的结果。`Cell`（和`RefCell`）主要用于与`Rc`和类似的数据类型一起使用。`Rc`类型遵循Rust关于可变性的正常规则，并且由于它旨在作为在许多地方访问共享数据值的机制，这意味着共享值必须是不可变的。
- en: Unless that value is a `Cell` or `RefCell` containing the *real* shared value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除非该值是一个包含*真实*共享值的`Cell`或`RefCell`。
- en: The `Cell` or `RefCell` ensures that only one block of code at a time *actually*
    modifies the shared value, but any of the blocks that have access to it through
    a clone of the `Rc` have the *ability* to do so.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cell`或`RefCell`确保一次只有一个代码块*实际上*修改共享值，但任何通过`Rc`的克隆访问它的代码块都有*能力*这样做。'
- en: RefCell
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RefCell
- en: '`Cell`''s semantics of moving the stored data value in and out of the `cell`
    are not always convenient to work with, and for large data values, moving them
    can be an expensive operation that we don''t want to keep repeating over and over
    without need. `RefCell` to the rescue!'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cell`在将存储的数据值移入和移出`cell`时的语义并不总是方便使用，对于大型数据值，移动它们可能是一个昂贵的操作，我们不想在没有必要的情况下反复重复。`RefCell`来拯救！'
- en: The `RefCell` type supports `RefCell::new`, `replace`, and `into_inner`, just
    as `Cell` does, but it also has functions that allow us to borrow the contained
    value, either mutably or immutably.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`RefCell`类型支持`RefCell::new`、`replace`和`into_inner`，就像`Cell`一样，但它还有允许我们以可变或不可变方式借用包含值的函数。'
- en: 'Let''s give `RefCell` a whirl:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试一试`RefCell`：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we created a new `RefCell`, containing a text string. After that, we
    used the `try_borrow` function to retrieve an immutable borrow of the contained
    data value. The rules about borrowing are still enforced, meaning we can't borrow
    a value if it's mutably borrowed, and we can't mutably borrow a value if the value
    is already borrowed at all, which means that `try_borrow` might not actually succeed.
    Therefore, we have to handle the possibility that it fails, which we're doing
    here by using a `match` expression.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个新的`RefCell`，包含一个文本字符串。之后，我们使用`try_borrow`函数来获取包含的数据值的不可变借用。关于借用的规则仍然得到执行，这意味着如果我们已经对值进行了可变借用，我们就不能借用该值，如果我们已经以任何方式借用了该值，我们也不能对该值进行可变借用，这意味着`try_borrow`可能实际上不会成功。因此，我们必须处理它可能失败的可能性，我们在这里通过使用`match`表达式来做到这一点。
- en: Next, we retrieve a mutable borrow and store it in a local variable. The previous
    borrow's lifetime ended at the end of the chosen block in the `match` expression,
    so there are no live borrows and we expect the `try_borrow_mut` to succeed, but
    we still need to handle the possibility of failure. In this case, we're using
    `?` to handle the returned `Result`, which will extract the value of a success,
    or return a failure to the function that called our current function. If the `try_borrow_mut`
    succeeds as expected, that leaves the `borrowed_mutably` variable containing a
    mutable reference to `refcell`'s contained data value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取一个可变借用并将其存储在一个局部变量中。之前的借用在`match`表达式中选择的块的末尾结束，因此没有活跃的借用，我们预计`try_borrow_mut`会成功，但我们仍然需要处理失败的可能性。在这种情况下，我们使用`?`来处理返回的`Result`，它将提取成功的值，或者将失败返回给调用我们当前函数的函数。如果`try_borrow_mut`如预期那样成功，那么`borrowed_mutably`变量将包含对`refcell`包含的数据值的可变引用。
- en: Then we again try to borrow the contained data value, immutably. Since immutable
    borrows are not compatible with mutable borrows, and our mutable borrow is still
    around, we expect this attempt to fail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次尝试不可变地借用包含的数据值。由于不可变借用与可变借用不兼容，而且我们的可变借用仍然存在，我们预计这次尝试会失败。
- en: Arc
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arc
- en: 'There''s another layer of complexity when it comes to sharing data between
    multiple code blocks: threads and multithreading. `Rc`, `Cell`, and `RefCell`
    are all impossible to share between threads, but the ideas they represent would
    be useful for enabling communication between threads.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在多个代码块之间共享数据时，还有另一层复杂性：线程和多线程。`Rc`、`Cell` 和 `RefCell` 都无法在线程之间共享，但它们所代表的思想对于实现线程间的通信是有用的。
- en: 'There''s a direct equivalent of `Rc` for use with threads: `Arc`. An `Arc`
    is an *atomic reference-counted smart pointer*, which is valid for sharing between
    threads thanks to that *atomic*, which basically means that even if two threads
    try to use it at the same time, it''s not going to get messed up or confused.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于线程的使用，有一个 `Rc` 的直接等效物：`Arc`。`Arc` 是一个原子引用计数的智能指针，它因为那个 `atomic` 而可以在线程之间共享，这基本上意味着即使两个线程同时尝试使用它，它也不会被搞乱或混淆。
- en: '`Arc` has a different name and works differently inside, but on the surface
    it''s just like `Rc`. The things we''ve learned about how to use an `Rc` apply
    to an `Arc` as well.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arc` 在内部有不同的名称和不同的工作方式，但表面上它就像 `Rc` 一样。我们关于如何使用 `Rc` 的知识也适用于 `Arc`。'
- en: It's hard to demonstrate the special features of `Arc` without using `Mutex`
    or `RwLock` as well, so see the next section for some example code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `Mutex` 或 `RwLock` 就难以展示 `Arc` 的特殊功能，所以请参阅下一节中的示例代码。
- en: Mutex and RwLock
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mutex 和 RwLock
- en: '`Mutex` and `RwLock` are both similar to `RefCell` in some ways, but not as
    closely related as `Arc` is to `Rc`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutex` 和 `RwLock` 在某些方面与 `RefCell` 类似，但与 `Arc` 和 `Rc` 的关系并不那么紧密。'
- en: It's `Mutex's` job to make sure that only one thread has access to the contained
    data at a time. Since it guarantees that only one block of code has access at
    all at any given time, a `Mutex` can safely provide both read and write access
    without breaking Rust's rules.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutex` 的职责是确保一次只有一个线程可以访问包含的数据。由于它保证了在任何给定时间只有一个代码块可以访问，因此 `Mutex` 可以安全地提供读写访问，而不会违反
    Rust 的规则。'
- en: 'In the following example, we have `Mutex` and `Arc` in action, and some very
    basic multithreading:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们有 `Mutex` 和 `Arc` 的实际应用，以及一些非常基本的线程操作：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing we're doing is creating a new `Arc` containing a `Mutex`, which
    in turn contains an integer. So, our integer can only be accessed by one thread
    at a time, but it can be shared among many and its lifetime will not end until
    all of them are done with it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的是创建一个新的 `Arc`，其中包含一个 `Mutex`，而 `Mutex` 又包含一个整数。因此，我们的整数一次只能被一个线程访问，但它可以在多个线程之间共享，并且它的生命周期将持续到所有线程都完成使用它。
- en: Next, we have a `for` loop, which goes through 10 cycles, and launches a thread
    on each cycle. Notice how we're creating a clone of the `Arc` *before* we call
    `thread::spawn`. That's because we're using a *closure* to define what the threads
    should do. A closure is like a function in a lot of ways, but it can borrow or
    move local variables into its own scope when it's defined. We need to create the
    `Arc` value that it's going to move into its own scope, before asking it to perform
    the move.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个 `for` 循环，它经过 10 个周期，并在每个周期启动一个线程。注意我们如何在调用 `thread::spawn` 之前创建 `Arc`
    的克隆。这是因为我们正在使用闭包来定义线程应该做什么。闭包在很多方面都像函数，但它可以在定义时将其局部变量借用或移动到自己的作用域中。我们需要在要求它执行移动之前创建一个将要移动到其作用域中的
    `Arc` 值。
- en: This closure is moving local variables into its own scope because we used the
    `move` keyword when we defined it, and it's moving the `local_counter` variable
    specifically simply because we referred to it within the closure.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个闭包将局部变量移动到其自己的作用域中，因为我们定义它时使用了 `move` 关键字，并且它特别移动了 `local_counter` 变量，仅仅因为我们在这个闭包中引用了它。
- en: Within each thread's closure, we ask it to wait for a random duration less than
    8 seconds, and then add 1 to the counter. In order to add 1 to the counter, we
    first have to lock the `Mutex`, so that we can be sure no other thread has access.
    We do that by calling the `Mutex`'s `lock()` function via the `Arc` (because an
    `Arc` can pretend to be a normal borrow of the thing inside it). The value that
    the `lock` function returns both provides us with access to the contained data
    when we dereference it, and keeps track of how long the `Mutex` should remain
    locked. When the lifetime of that returned value ends, the `Mutex` is unlocked
    so that other threads can access the contained data value. If another thread tries
    to lock the value while it's still locked, `Mutex` makes that other thread wait
    until it's unlocked before continuing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个线程的闭包中，我们要求它等待少于 8 秒的随机持续时间，然后向计数器加 1。为了向计数器加 1，我们首先必须锁定 `Mutex`，以确保没有其他线程可以访问。我们通过调用
    `Mutex` 的 `lock()` 函数并通过 `Arc`（因为 `Arc` 可以假装是它内部事物的正常借用）来实现这一点。`lock` 函数返回的值在解引用时为我们提供对包含数据的访问，并跟踪
    `Mutex` 应保持锁定的时间。当该返回值的生命周期结束时，`Mutex` 被解锁，以便其他线程可以访问包含的数据值。如果另一个线程在 `Mutex` 仍然锁定时尝试锁定该值，`Mutex`
    将使该线程等待直到它被解锁才能继续。
- en: The `lock` function actually returns a `Result`, but we're just unwrapping that
    here. If the call to `lock` fails, it's because one of the other threads had a
    bad error while it had the `Mutex` locked, and ending the program is probably
    the smart thing to do.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`lock` 函数返回一个 `Result`，但我们在这里只是解包它。如果 `lock` 调用失败，那是因为在另一个线程拥有 `Mutex` 锁定时发生了错误，结束程序可能是明智的选择。
- en: Finally, we can just do a `*shared +=1` to actually add `1` to the shared counter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需执行 `*shared +=1` 来实际上将 `1` 添加到共享计数器中。
- en: After that, we have a loop, which locks the `Mutex`, then prints out the current
    value of the counter, and ends the loop (using the `break` keyword) if it is greater
    than or equal to 10\. If the loop hasn't ended, it then waits one second and does
    it again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有一个循环，它锁定 `Mutex`，然后打印出计数器的当前值，并在它大于或等于 10 时结束循环（使用 `break` 关键字）。如果循环没有结束，它将等待一秒钟，然后再次执行。
- en: 'Notice that within that loop, we have another block expression, and that the
    `thread::sleep` call is outside of it. That''s because of the way `Mutex` works:
    as long as the returned value''s lifetime hasn''t ended, the `Mutex` remains locked.
    We don''t want the `Mutex` to be locked while this code is sleeping, so we put
    the return value into a shorter scope, so that its lifetime would end before we
    called `thread::sleep`, and the `Mutex` would be unlocked.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在那个循环中，我们还有一个代码块表达式，并且 `thread::sleep` 调用位于它之外。这是因为 `Mutex` 的工作方式：只要返回值的生命周期没有结束，`Mutex`
    就保持锁定。我们不希望 `Mutex` 在代码睡眠时被锁定，所以我们把返回值放入一个更短的范围内，这样它的生命周期就会在我们调用 `thread::sleep`
    之前结束，`Mutex` 也会被解锁。
- en: 'An `RwLock` is similar to a `Mutex`, but it has different rules about how access
    to the contained data value is managed. Instead of a single lock function, `RwLock`
    has two: `read` and `write`. Any number of threads can call `read` to access the
    contained information at the same time, but only one thread can use `write` to
    access it at any given moment, and while a thread has write access, no other threads
    are allowed to read it. If a thread tries to read or write at a time when it''s
    not allowed, `RwLock` makes the thread wait until what it wants to do is allowed
    again.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`RwLock` 与 `Mutex` 类似，但它对管理包含数据值的访问有不同的规则。`RwLock` 有两个而不是一个锁函数：`read` 和 `write`。任何数量的线程都可以同时调用
    `read` 来访问包含的信息，但任何给定时刻只有一个线程可以使用 `write` 来访问它，并且当线程有写访问权限时，不允许其他线程读取。如果线程在不受允许的时间尝试读取或写入，`RwLock`
    将使线程等待直到它想要做的事情再次被允许。'
- en: We don't need to use `read` and `write` together to have both kinds of access.
    Using `write` implies that we have read access as well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要同时使用 `read` 和 `write` 来获得两种类型的访问。使用 `write` 意味着我们也有读访问权限。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we''ve learned about the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了以下内容：
- en: The differences between heap and stack memory
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆内存和栈内存之间的区别
- en: How to use `Box` to simply store something on the heap, when we wish to do so
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们希望这样做时，如何使用 `Box` 简单地在堆上存储某些东西
- en: How to use `Rc` to manage the lifetime of a data value that is needed in many
    scopes with varying lifetimes
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `Rc` 来管理在多个具有不同生命周期的作用域中所需的数据值的生命周期
- en: How to use `Cell` and `RefCell` to allow write access to data stored in an `Rc`
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `Cell` 和 `RefCell` 允许对存储在 `Rc` 中的数据进行写访问
- en: How to use `Arc`, `Mutex`, and `RwLock` to manage sharing information between
    threads
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `Arc`、`Mutex` 和 `RwLock` 来管理线程间的信息共享
- en: In the next chapter, we're going to be looking at generic types, and how to
    use generic type parameters for our own data types.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨泛型类型，以及如何为我们的数据类型使用泛型类型参数。
