- en: Using Experimental Nightly Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实验性Nightly功能
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Iterating over an inclusive range
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历一个包含范围的迭代
- en: Returning abstract types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回抽象类型
- en: Composing functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合
- en: Filtering strings efficiently
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地过滤字符串
- en: Stepping through an iterator in regular intervals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以常规间隔遍历迭代器
- en: Benchmarking your code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的代码进行基准测试
- en: Using generators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'This final chapter leads us to the most important experimental features in
    Rust, provided on the newest `nightly` toolchain. As of the time of writing, this
    is `rustc 1.25.0-nightly`. If you are using `rustup` ([https://rustup.rs/](https://rustup.rs/)),
    you can set it as your default toolchain like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章将带我们了解Rust中最重要的实验性功能，这些功能在最新的`nightly`工具链上提供。截至编写时，这是`rustc 1.25.0-nightly`。如果你使用`rustup`（[https://rustup.rs/](https://rustup.rs/)），你可以像这样将其设置为默认工具链：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These recipes will ensure that you stay ahead in your knowledge of Rust, and
    are ready to use them effectively once they are stabilized, or right now in your
    own unstable apps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些食谱将确保你在Rust的知识上保持领先，一旦它们稳定下来，或者现在在你的不稳定应用中，你就可以有效地使用它们。
- en: 'All of the recipes in this chapter have varying stability guarantees. Many
    will undergo drastic changes before they land in the `stable` toolchain, and others
    are nearly done. This means that some of the example code provided is expected
    not to work on your newest `nightly`. When this happens, you can find help in
    two places:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有食谱都有不同的稳定性保证。许多在进入`stable`工具链之前将经历巨大的变化，而其他的一些几乎已经完成。这意味着提供的某些示例代码可能无法在你的最新`nightly`版本上运行。当这种情况发生时，你可以在两个地方找到帮助：
- en: If the feature is still experimental, it will have an entry in *The Unstable
    Book* ([https://doc.rust-lang.org/unstable-book/](https://doc.rust-lang.org/unstable-book/)),
    and a link to the relevant GitHub issue and its surrounding discussion
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该特性仍然是实验性的，它将在*《不稳定手册》*（[https://doc.rust-lang.org/unstable-book/](https://doc.rust-lang.org/unstable-book/)）中有一个条目，以及一个链接到相关的GitHub问题和其周围的讨论
- en: If the feature has been stabilized, there is a good chance you will find it
    listed in the appendix of *The Rust Programming Language, Second Edition* ([https://doc.rust-lang.org/stable/book/second-edition/appendix-06-newest-features.html](https://doc.rust-lang.org/stable/book/second-edition/appendix-06-newest-features.html))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该特性已经稳定，你很可能会在*《Rust编程语言，第二版》*（[https://doc.rust-lang.org/stable/book/second-edition/appendix-06-newest-features.html](https://doc.rust-lang.org/stable/book/second-edition/appendix-06-newest-features.html)）的附录中找到它）
- en: Iterating over an inclusive range
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历一个包含范围的迭代
- en: We begin the chapter with a small feature that can make your code a bit more
    readable. The inclusive range syntax (`..=`) will create a range up to a value
    *including* it. This helps you eliminate ugly instances of things like `n .. m+1`
    by rewriting them as `n ..= m`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个小特性开始本章，这个特性可以使你的代码更易于阅读。包含范围的语法（`..=`）将创建一个包含该值的范围。这有助于你通过将它们重写为`n ..=
    m`来消除像`n .. m+1`这样的丑陋实例。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a Rust project to work on during this chapter with `cargo new chapter-ten`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new chapter-ten`创建一个Rust项目，在本章中工作。
- en: Navigate into the newly-created `chapter-ten` folder. For the rest of this chapter,
    we will assume that your command line is currently in this directory.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`chapter-ten`文件夹。在本章的其余部分，我们将假设你的命令行当前位于这个目录中。
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的`lib.rs`文件，因为我们不是在创建一个库。
- en: Inside the `src` folder, create a new folder called `bin`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，创建一个新的名为`bin`的文件夹。
- en: In the `src/bin` folder, create a file called `inclusive_range.rs`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`inclusive_range.rs`的文件。
- en: 'Add the following code, and run it with `cargo run --bin inclusive_range`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin inclusive_range`运行它：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, the code is the promised rewrite of a snippet in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*; *Accessing collections as iterators*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，代码是[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)中提到的片段的预期重写；*与集合一起工作*；*将集合作为迭代器访问*。
- en: The traditional range syntax (`n .. m`) is exclusive, meaning that `0 .. 5`
    will only include the numbers 0, 1, 2, 3, and 4\. This is good for uses cases
    where you count up to a length of something, but in our case, we want to iterate
    over the alphabet, including Z [5]. The inclusive range syntax (`n ..= m`) helps
    us by including the last element, so that `0 ..= 5` will yield 0, 1, 2, 3, 4,
    and 5.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的范围语法（`n .. m`）是排他的，意味着 `0 .. 5` 只包括数字 0、1、2、3 和 4。这对于需要计算某物长度的用例来说很好，但在这个案例中，我们想要遍历字母表，包括
    Z [5]。包含范围的语法（`n ..= m`）通过包含最后一个元素来帮助我们，所以 `0 ..= 5` 将产生 0、1、2、3、4 和 5。
- en: See also
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Accessing collections as iterators* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml) *与集合一起工作* 中的 *将集合作为迭代器访问*
    配方'
- en: Returning abstract types
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回抽象类型
- en: Remember when we used `Box` to create trait objects in order to hide the exact
    implementation returned, and instead only give guarantees about implemented traits?
    That required us to accept some overhead, as a `Box` allocates its resources on
    the heap; however, on the current `nightly`, things are different. You can use
    the `impl trait` syntax introduced in this recipe to return objects as their trait
    directly on the stack, all without boxes. At the moment, this only works for returned
    types, but the syntax is planned to be extended to most places where you could
    write a concrete type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们使用 `Box` 创建特质对象以隐藏返回的确切实现，并只提供关于实现特质的保证吗？这需要我们接受一些开销，因为 `Box` 在堆上分配其资源；然而，在当前的
    `nightly` 中，情况不同。你可以使用本配方中引入的 `impl trait` 语法，将对象直接作为它们的特质返回到栈上，而无需使用 `Box`。目前，这仅适用于返回类型，但该语法计划扩展到大多数可以写入具体类型的地方。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的 `Cargo.toml` 文件。
- en: In the `bin` folder, create a file called `return_abstract.rs`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `return_abstract.rs` 的文件。
- en: 'Add the following code, and run it with `cargo run --bin return_abstract`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin return_abstract` 运行它：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you've read [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*; *Boxing data*, this recipe doesn't need much explanation. By
    returning an `impl trait`, we tell the caller of a function to not care about
    the specific struct that is returned, and that its only guarantee about it is
    that it implements some trait. In this sense, abstract return types work like
    the trait objects discussed in the said recipe, with the added bonus of being
    way faster, as they don't have any overhead. This is useful for returning iterators
    [37] and closures [43], which we adapted from the recipe about boxes, but also
    to hide implementation details. Consider our function `create_animal`[32]. A caller
    will only care that it returns a struct that implements `Animal`, but not which
    exact animal. If a `Dog` [7] doesn't prove to be the right thing because of changing
    requirements, you can create a `Cat`, and return that one without touching the
    rest of the code, as it all just depends on `Animal`. This is a form of *dependency
    inversion* ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*；*数据装箱*，这个配方不需要太多解释。通过返回一个
    `impl trait`，我们告诉函数的调用者不必关心返回的具体结构体，它对其的唯一保证是它实现了某些特质。从这个意义上说，抽象返回类型就像在所述配方中讨论的特质对象一样工作，而且还有一个额外的优点，那就是它们要快得多，因为它们没有任何开销。这对于返回迭代器
    [37] 和闭包 [43] 很有用，这些是从关于装箱的配方中改编的，但也可以用来隐藏实现细节。考虑我们的函数 `create_animal`[32]。调用者只关心它返回一个实现了
    `Animal` 的结构体，但不关心确切的动物。如果由于需求变化，`Dog` [7] 证明不是正确的东西，你可以创建一个 `Cat`，并返回它，而无需触及代码的其他部分，因为所有这些都依赖于
    `Animal`。这是一种 *依赖倒置* ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle))
    的形式。
- en: The `conservative` in `conservative_impl_trait` [1] tells us that this is just
    a part of a bigger feature. At the moment, you can only use it in return types
    of functions. In the future, you'll be able to use it in traits, constraints,
    and bindings as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`conservative` 在 `conservative_impl_trait` [1] 中告诉我们，这只是一个更大功能的组成部分。目前，你只能将其用于函数的返回类型。将来，你将能够在特质、约束和绑定中使用它。'
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Of all the recipes in this chapter, this one is probably the most stable, as
    it is being considered for immediate stabilization. The discussion can be found
    at [https://github.com/rust-lang/rust/issues/34511.](https://github.com/rust-lang/rust/issues/34511)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有食谱中，这个可能是最稳定的，因为它正在被考虑立即稳定化。讨论可以在[https://github.com/rust-lang/rust/issues/34511.](https://github.com/rust-lang/rust/issues/34511)找到。
- en: 'While you can use abstract return types for some forms of dependency inversion,
    you cannot use them for traditional Java-style factories that return different
    objects depending on a parameter. This is because abstract return types only hide
    the specific struct returned on the outside of the function, but still internally
    rely on a specific return value. Because of this, the following code will not
    compile:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以为某些形式的依赖反转使用抽象返回类型，但你不能为根据参数返回不同对象的传统Java风格工厂使用它们。这是因为抽象返回类型仅隐藏函数外部返回的特定结构，但仍然在内部依赖于特定的返回值。正因为如此，以下代码将无法编译：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While the outside world doesn''t know which animal is going to be returned
    by `create_animal`, the function itself needs a specific return type internally.
    Because the first possible return from our match is an instance of `Cat`, `create_animal`
    assumes that we are going to return no other type. We break that expectation in
    the next line by returning a `Dog`, so the compiler fails:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然外界不知道`create_animal`将返回哪种动物，但函数本身在内部需要特定的返回类型。因为我们的匹配中第一个可能的返回值是`Cat`的一个实例，`create_animal`假设我们将不会返回其他类型。我们在下一行通过返回一个`Dog`来打破这种预期，因此编译器会失败：
- en: '![](img/9eeed4e9-fed8-46e6-bbf9-94318249d556.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9eeed4e9-fed8-46e6-bbf9-94318249d556.png)'
- en: 'If we want this factory to compile, we need to resort back to `Box` again:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让这个工厂编译，我们需要再次求助于`Box`：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By the way, this is also exactly what Java does under the hood.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这正是Java在底层所做的事情。
- en: For most purposes, you won't need a factory such as the one presented here.
    It is considered more idiomatic to use generics with trait bounds.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用途，你不需要像这里展示的这样的工厂。使用泛型和特质界限被认为更符合惯例。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Boxing data* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*中的*装箱数据*食谱'
- en: Composing functions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: Because we have now learned how to return arbitrary closures with no overhead,
    we can combine that with macros that accept any number of parameters ([Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*; *Accepting
    a variable number of arguments*) to create an easy way to chain actions as you
    would be used to in functional languages such as *Haskell*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在已经学会了如何无开销地返回任意闭包，我们可以将此与接受任何数量参数的宏（[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*；*接受可变数量的参数*）结合起来，创建一种易于链式操作的方法，就像你在函数式语言如*Haskell*中习惯的那样。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到它...
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的`Cargo.toml`文件。
- en: In the `bin` folder, create a file called `compose_functions.rs`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`compose_functions.rs`的文件。
- en: 'Add the following code, and run it with `cargo run --bin compose_functions`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin compose_functions`运行它：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By the usage of `compose!` in main [30 and 34], you should see clearly what
    it does: it takes as many closures as you want, and combines them into a new closure
    that runs them one by one. This is really useful for runtime user-driven functionality
    composition.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在主函数中使用`compose!`（[30和34]），你应该清楚地看到它做了什么：它接受你想要的任意数量的闭包，并将它们组合成一个新闭包，依次运行它们。这对于运行时用户驱动的功能组合非常有用。
- en: 'The macro is implemented similarly to the standard macro for variable arguments
    from [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*;
    *Accepting a variable number of arguments*, with its edge case being a single
    closure [6]. When encountering more, it will recursively go through them and combine
    them in pairs by calling the helper function `compose_two` [14]. Usually, type
    parameters are written as a single character, but we are using full words for
    them in this recipe for readability reasons, as there are quite a number of types
    involved. The type constraints used should illustrate how the types are used pretty
    well [18 to 20]:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的实现方式与[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*；*接受可变数量参数*的标准宏类似；其边缘情况是一个单独的闭包[6]。当遇到更多时，它将通过递归遍历它们，并通过调用辅助函数`compose_two`
    [14]将它们成对组合。通常，类型参数以单个字符书写，但在这个配方中，我们为了可读性原因使用完整的单词，因为涉及到的类型有很多。使用的类型约束应该很好地说明了如何使用这些类型
    [18到20]：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`FunOne` is a closure that takes an `Input`, turns it into an `Intermediate`,
    and passes it to `FunTwo`, which returns an `Output`. As you can see from the
    implementation, the only thing we do is call `fun_one` on a value, and then call
    `fun_two` on its returned value [22]:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`FunOne`是一个闭包，它接受一个`Input`，将其转换为`Intermediate`，并将其传递给`FunTwo`，后者返回一个`Output`。正如你所看到的实现，我们唯一做的事情就是在值上调用`fun_one`，然后在其返回值上调用`fun_two`
    [22]：'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Accepting a variable number of arguments* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接受可变数量参数*的配方在[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*'
- en: Filtering strings efficiently
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效地过滤字符串
- en: While you can filter characters out of a `String` on the stable channel already,
    this requires creating a new `String` with the filtered characters. On `nightly`,
    you can do this in place of the same `String`, helping you a lot with performance
    if you need to perform this kind of action many, many times, or on very large
    strings.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在稳定频道上从`String`中过滤字符，但这需要创建一个新的包含过滤字符的`String`。在`nightly`上，你可以直接在同一个`String`上执行此操作，如果你需要多次或对非常大的字符串执行此类操作，这将大大提高你的性能。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的`Cargo.toml`文件。
- en: In the `bin` folder, create a file called `retain_string.rs`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`retain_string.rs`的文件。
- en: 'Add the following code, and run it with `cargo run --bin retain_string`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin retain_string`运行它：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*;
    *Using a Vector*, we learned about `Vec::retain`, which filters a vector in place.
    On the `nightly` toolchain, this functionality has arrived in `String` and works
    the same way, as if a `String` was a `Vec<char>—`which, if you think about it,
    it really is.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*与集合一起工作*；*使用向量*中，我们学习了`Vec::retain`，它可以在原地过滤向量。在`nightly`工具链上，这个功能已经出现在`String`中，并且以相同的方式工作，就像`String`是一个`Vec<char>`——如果你这么想的话，它确实如此。
- en: The functionality of filtering a `String` was always there, but it required
    going over the string as an `Iterator` and creating a new `String` with the filtered
    characters; or worse yet, converting a `String` to a newly-created `Vec<char>`,
    using `retain` on it, and then converting the chars back into another newly-created
    `String`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤`String`的功能始终存在，但它需要遍历字符串作为一个`Iterator`，并创建一个新的包含过滤字符的`String`；或者更糟糕的是，将`String`转换为一个新的`Vec<char>`，使用`retain`操作它，然后将字符转换回另一个新创建的`String`。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using a vector* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用向量*的配方在[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*与集合一起工作*'
- en: Stepping through an iterator in regular intervals
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以常规间隔遍历迭代器
- en: Have you ever wanted to step through data by only looking at every nth item?
    On stable Rust, the best solution to this problem is using the third-party crate
    `itertools` ([https://crates.io/crates/itertools](https://crates.io/crates/itertools)),
    which brings you a whole lot of iterator goodies, or allows you to code the functionality
    yourself; however, you have a built-in `step_by` method doing exactly this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾想通过仅查看每第n个项来遍历数据？在稳定的Rust中，解决这个问题的最佳方案是使用第三方crate `itertools` ([https://crates.io/crates/itertools](https://crates.io/crates/itertools))，它为你带来一大堆迭代器好东西，或者允许你自己编写这个功能；然而，你有一个内置的`step_by`方法，它正好能做这件事。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为您生成的`Cargo.toml`文件。
- en: In the `bin` folder, create a file called `iterator_step_by.rs`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`iterator_step_by.rs`的文件。
- en: 'Add the following code, and run it with `cargo run --bin iterator_step_by`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin iterator_step_by`运行它：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe shines when you are being handed an unstructured data stream that
    follows a certain pattern. For example, sometimes some old APIs that don''t use
    JSON, or other programs you might want to interact with, hand you streams of data
    that are grouped by position, like the data we stored in `grouped_stream`[15],
    which follows the following pattern:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你被 handed 一个遵循特定模式的非结构化数据流时，这个配方特别出色。例如，有时一些不使用JSON的旧API，或者你可能想要与之交互的其他程序，会给你一些按位置分组的数据流，就像我们存储在`grouped_stream`[15]中的数据，它遵循以下模式：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`step_by` lets us parse this structure very easily. It works by handing you
    current element, and then skipping a certain amount of elements on every iteration.
    In our example, we parse `grouped_stream` by first creating an iterator over every
    substring that is not whitespace with `split_whitespace` [17], then, because we
    are only interested in the weights, `skip` the first two elements (`"Aaron"` and
    `"182cm"`), which places our iterator at `"70kg"`. We then tell the iterator to
    only look at every third element from now on with `step_by(3)` [19], resulting
    in us iterating over `"70kg"`, `"90kg"`, and `"83kg"`. Finally, we `collect` the
    elements into a vector [20].'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`step_by`让我们能够非常容易地解析这个结构。它通过给你当前元素，然后在每次迭代中跳过一定数量的元素来实现。在我们的例子中，我们通过使用`split_whitespace`[17]创建一个遍历每个非空白子字符串的迭代器来解析`grouped_stream`，然后，因为我们只对权重感兴趣，所以我们跳过前两个元素（`"Aaron"`和`"182cm"`），这使得我们的迭代器位于`"70kg"`。然后我们告诉迭代器从现在开始只查看每隔第三个元素，使用`step_by(3)`[19]，结果是我们遍历`"70kg"`、`"90kg"`和`"83kg"`。最后，我们将元素`collect`到一个向量[20]中。'
- en: See also
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using a string* and *Accessing collections as iterators* recipes in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用字符串*和*将集合作为迭代器访问*配方在[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*与集合一起工作*'
- en: Benchmarking your code
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试您的代码
- en: The Rust project has developed a testing crate for the compiler itself. Because
    it includes some quite useful features, most importantly a benchmarker, it is
    accessible on nightly builds as the built-in `test` crate. Because it gets shipped
    with every nightly build, you don't need to add it to your `Cargo.toml` to use
    it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Rust项目为编译器本身开发了一个测试crate。因为它包括一些相当有用的功能，最重要的是一个基准测试器，所以它可以在夜间构建中作为内置的`test`
    crate访问。因为它随着每个夜间构建一起分发，所以您不需要将其添加到`Cargo.toml`中即可使用它。
- en: The `test` crate is marked unstable because of its tight coupling to the compiler.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`test` crate与编译器的紧密耦合，它被标记为不稳定。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为您生成的`Cargo.toml`文件。
- en: In the `bin` folder, create a file called `benchmarking.rs`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`benchmarking.rs`的文件。
- en: 'Add the following code, and run it with `cargo bench`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo bench`运行它：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running benchmarks:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行基准测试：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The bread and butter of the `test` crate is the `Bencher` struct [59]. An instance
    of it is passed automatically to every function annotated with the `#[bench]`
    attribute [63] when running `cargo bench`. Its `iter` method takes a closure [65],
    and runs it multiple times to determine how long one iteration of it takes. While
    doing this, it also discards time measurements that are far off the others to
    eliminate one-off extremes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` crate的精髓是`Bencher`结构体[59]。当运行`cargo bench`时，它的一个实例会自动传递给每个带有`#[bench]`属性的函数[63]。它的`iter`方法接受一个闭包[65]，并多次运行它以确定其一次迭代所需的时间。在这个过程中，它还会丢弃与其他时间测量相差甚远的测量值，以消除一次性极端值。'
- en: Another useful part of the `test` crate is its `black_box` struct [68], which
    wraps any value and tells the compiler and LLVM to not optimize it away, no matter
    what. If we didn't use it in our benchmarks, they might get optimized away and
    result in a rather optimistic and unhelpful measurement of 0 ns/iter, or zero
    nanoseconds per execution of the closure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` crate的另一个有用部分是其`black_box`结构体[68]，它封装任何值并告诉编译器和LLVM不要优化它，无论什么情况。如果我们不在我们的基准测试中使用它，它们可能会被优化掉，导致一个相当乐观且无用的测量结果，即0
    ns/iter，或者每次闭包执行的零纳秒。'
- en: We can use the tools at our disposal to test out some theories. Remember the
    recursive **Fibonacci** implementation discussed in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*; *Running two operations together*? Well, it is repeated
    here as `slow_fibonacci_recursive`[6].
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们手中的工具来测试一些理论。记住在[第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)中讨论的递归**斐波那契**实现，*并行和射线*；*同时运行两个操作*？嗯，这里重复一下，作为`slow_fibonacci_recursive`[6]。
- en: 'This implementation is slow because both calls to `slow_fibonacci_recursive(n
    - 1)` and  `slow_fibonacci_recursive(n - 2)` need to recalculate *all* values
    individually. Worse yet, every call also splits up into a call to `slow_fibonacci_recursive(n
    - 1)` and  `slow_fibonacci_recursive(n - 2)` once more, recalculating everything
    again and again! In terms of *Big O*, this is an efficiency of ![](img/f67731c7-d87b-4a16-aa3c-756bc09bec79.png)
    (proof at [https://stackoverflow.com/a/360773/5903309](https://stackoverflow.com/a/360773/5903309)).
    In comparison, the imperative algorithm, `fibonacci_imperative` [14] is a simple
    loop, so it''s at ![](img/2dafef58-b819-4df9-bb92-6dcbb8defb4e.png). By this theory,
    it should be *a lot* faster than the slow, recursive one. Running `cargo bench`
    lets us verify these assertions easily:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现之所以慢，是因为对`slow_fibonacci_recursive(n - 1)`和`slow_fibonacci_recursive(n -
    2)`的两次调用都需要单独重新计算*所有*值。更糟糕的是，每次调用还会再次拆分成对`slow_fibonacci_recursive(n - 1)`和`slow_fibonacci_recursive(n
    - 2)`的调用，一次又一次地重新计算！在*大O*的术语中，这是效率为![](img/f67731c7-d87b-4a16-aa3c-756bc09bec79.png)（证明见[https://stackoverflow.com/a/360773/5903309](https://stackoverflow.com/a/360773/5903309)）。相比之下，命令式算法`fibonacci_imperative`
    [14]只是一个简单的循环，所以它处于![](img/2dafef58-b819-4df9-bb92-6dcbb8defb4e.png)。根据这个理论，它应该比慢速的递归实现快得多。运行`cargo
    bench`可以让我们轻松验证这些断言：
- en: '![](img/10c2847a-9095-4c00-bdb2-1c84cd3364e1.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10c2847a-9095-4c00-bdb2-1c84cd3364e1.png)'
- en: What a difference! On my computer, the slow, recursive implementation is more
    than 7,000 times slower than the imperative one! Surely, we can do better.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 差异多么大！在我的电脑上，慢速的递归实现比命令式实现慢了7,000多倍！当然，我们可以做得更好。
- en: '**StackOverflow** user **Boiethios** helpfully provided us with `memoized_fibonacci_recursive`
    at [https://stackoverflow.com/a/49052806/5903309](https://stackoverflow.com/a/49052806/5903309).
    As the name suggests, this implementation uses a concept known as *memoization*.
    This means that the algorithm has some way of passing around already-calculated
    values. An easy way of doing this would be to pass around a `HashMap` with all
    calculated values, but that would again bring its own overhead, as it operates
    on the heap. Instead, we go for the route of *accumulators*. This means that we
    just pass the relevant values directly as parameters, which in our case are `penultimate`,
    which represents the Fibonacci of `n-2`, and `last`, which represents the Fibonacci
    of `n-1`. If you want to read more about these functional concepts, check out
    [http://www.idryman.org/blog/2012/04/14/recursion-best-practices/](http://www.idryman.org/blog/2012/04/14/recursion-best-practices/).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**StackOverflow**用户**Boiethios**友好地为我们提供了`memoized_fibonacci_recursive`[https://stackoverflow.com/a/49052806/5903309](https://stackoverflow.com/a/49052806/5903309)。正如其名所示，这种实现使用了一种称为*记忆化*的概念。这意味着算法有某种方式传递已经计算过的值。一种简单的方法是传递一个包含所有计算值的`HashMap`，但这又会带来自己的开销，因为它在堆上操作。相反，我们选择了*累加器*的方法。这意味着我们只需直接将相关值作为参数传递，在我们的例子中，这些值是`penultimate`，它代表`n-2`的斐波那契数，以及`last`，它代表`n-1`的斐波那契数。如果你想了解更多关于这些函数式概念的信息，请查看[http://www.idryman.org/blog/2012/04/14/recursion-best-practices/](http://www.idryman.org/blog/2012/04/14/recursion-best-practices/)。'
- en: Checking the benchmarks, we can see that we managed to improve the algorithm
    quite a bit with `memoized_fibonacci_recursive`. But it's still a bit slower than
    `fibonacci_imperative`. One of many possible ways to further improve the algorithm
    is by extracting the `n == 1` match that would be checked in every recursive call
    outside, as demonstrated in `fast_fibonacci_recursive` [43], which clocks in at
    a great three nanoseconds per iteration!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 检查基准测试，我们可以看到我们通过`memoized_fibonacci_recursive`大大提高了算法的效率。但它仍然比`fibonacci_imperative`慢一点。提高算法的许多可能方法之一是将每次递归调用中都会检查的`n
    == 1`匹配提取出来，如`fast_fibonacci_recursive` [43]所示，它在每次迭代中只需要3纳秒！
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Our implementation also employs another optimization: *tail call* *optimization*,
    or *TCO* for short. In oversimplified terms, TCO happens when the compiler is
    able to rewrite a recursive algorithm into an imperative one. More generally,
    TCO is when the compiler can compile a recursive call into a form that doesn''t
    add a new stack frame per call, and as a consequence, can''t cause a stack overflow
    (not the website, but the error). For a good discussion on the topic, see [https://stackoverflow.com/questions/310974/what-is-tail-call-optimization](https://stackoverflow.com/questions/310974/what-is-tail-call-optimization).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现还采用了另一种优化：*尾调用优化*，或简称 *TCO*。用简化的术语来说，TCO发生在编译器能够将递归算法重写为命令式算法时。更普遍地说，TCO是当编译器能够将递归调用编译成不需要为每个调用添加新的栈帧的形式，因此不会导致栈溢出（不是网站，而是错误）。关于这个话题的深入讨论，请参阅[https://stackoverflow.com/questions/310974/what-is-tail-call-optimization](https://stackoverflow.com/questions/310974/what-is-tail-call-optimization)。
- en: Although Rust doesn't support TCO per se (see the RFC at [https://github.com/rust-lang/rfcs/issues/271](https://github.com/rust-lang/rfcs/issues/271)),
    the lower-level LLVM does. It requires the last call of a function to be a call
    to itself. The last line of `inner` [40] is a call to `inner`, so it's eligible
    for TCO.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Rust本身不支持尾调用优化（TCO）（参见[https://github.com/rust-lang/rfcs/issues/271](https://github.com/rust-lang/rfcs/issues/271)中的RFC），但底层的LLVM支持。它要求函数的最后一个调用必须是它自己的调用。`inner`
    函数的最后一行是对 `inner` 的调用，因此它符合TCO的条件。
- en: This is somewhat hard to guarantee in bigger Rust algorithms, though, as objects
    implementing the `Drop` trait will inject a call to `drop()` at the end of a function,
    removing any possibility of TCO.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更大的Rust算法中，这有点难以保证，因为实现 `Drop` 特质的对象将在函数末尾注入一个对 `drop()` 的调用，从而消除了TCO的可能性。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: '*Running two operations together* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)的 *并行性和Rayon* 中，*同时运行两个操作*
    的配方
- en: Using generators
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器
- en: The biggest concept that is still not quite usable yet in Rust is *easy async*.
    One reason for that is a lack of compiler support for certain things, which is
    being worked on right now. One important part of the road to async is *generators*,
    which are implemented similarly to how they're used in C# or Python.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，目前仍有一些概念尚未完全可用，其中最大的概念之一就是 *简单异步*。其中一个原因是编译器对某些事物的支持不足，目前正在解决这个问题。异步之路的一个重要部分是
    *生成器*，它们的实现方式类似于在C#或Python中的使用。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为您生成的 `Cargo.toml` 文件。
- en: In the `bin` folder, create a file called `generator.rs`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `generator.rs` 的文件。
- en: 'Add the following code, and run it with `cargo run --bin generator`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin generator` 运行它：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A `Generator` is currently defined as any closure that uses the new `yield`
    keyword. When it is executed with `.resume()` [11], it will run until it hits
    a `yield`. If run again, the generator will continue where it left off until it
    reaches another `yield` or encounters a `return`. If there are no more yields
    left in the generator, it will simply return an empty tuple, behaving as if encountering
    `return ();`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generator` 当前定义为任何使用新 `yield` 关键字的闭包。当它通过 `.resume()` [11] 执行时，它将运行到遇到 `yield`
    为止。如果再次运行，生成器将从上次停止的地方继续执行，直到遇到另一个 `yield` 或遇到 `return`。如果没有更多的 `yield`，生成器将简单地返回一个空元组，就像遇到了
    `return ();`。'
- en: Because there are two scenarios of what a generator does (`yield` vs `return`),
    you have to check the result of `.resume()` every time you use it, as it could
    be `GeneratorState::Yielded` or `GeneratorState::Complete`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因为生成器执行时存在两种情况（`yield` 与 `return`），所以每次使用它时都必须检查 `.resume()` 的结果，它可能是 `GeneratorState::Yielded`
    或 `GeneratorState::Complete`。
- en: At the time of writing, you can `return` a different type than you `yield`.
    The situation around this is somewhat unclear, as the reason for this quirk is
    the aforementioned convention to `return ();` when running out of yields. Maybe
    the final version of generators in Rust will not rely on this behavior, and only
    allow returning the same type as yielding. You can find the discussion about this
    and more at [https://github.com/rust-lang/rust/issues/43122](https://github.com/rust-lang/rust/issues/43122).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，你可以 `return` 一个不同于 `yield` 的类型。关于这一点的情况有些不清楚，因为这种异常的原因是上述在 `yield` 用尽时
    `return ();` 的约定。也许Rust中生成器的最终版本将不会依赖这种行为，而只允许返回与 `yield` 相同的类型。你可以在[https://github.com/rust-lang/rust/issues/43122](https://github.com/rust-lang/rust/issues/43122)找到关于这个话题和更多内容的讨论。
- en: Besides async, another big use case for generators is iterators. So much so
    that the Rust standard library iterators are planned to eventually be rewritten
    with generators. At the moment, the exact way of how this transition should happen
    has not been figured out, so there is no generic implementation of `Iterator for
    Generator`. To work around this, you can create a little wrapper type like we
    did with `GeneratorIterator`[50], which implements `Iterator` for its wrapped
    `Generator`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异步之外，生成器另一个重要的用例是迭代器。如此之多，以至于Rust标准库的迭代器计划最终将被生成器重写。目前，如何实现这一过渡的具体方式尚未确定，因此没有`Iterator
    for Generator`的泛型实现。为了解决这个问题，你可以创建一个小的包装类型，就像我们用`GeneratorIterator`[50]做的那样，它为它的包装`Generator`实现了`Iterator`。
- en: 'We illustrate how to use it by rewriting the Fibonacci iterator from [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*; *Creating
    an own iterator,* with a generator in the `fibonacci` function [64]. The implementation
    looks pretty clean, doesn''t it? As a reminder, here is how we wrote the original
    implementation using the `Iterator` trait directly, which not only needed a function,
    but also a `struct` and a trait implementation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过重写第2章中的斐波那契迭代器来说明如何使用它，该章节名为*处理集合*；*创建自定义迭代器*，在`fibonacci`函数中使用生成器[64]。实现看起来相当简洁，不是吗？作为提醒，以下是使用`Iterator`特质直接编写的原始实现，它不仅需要一个函数，还需要一个`struct`和一个特质实现：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating an own iterator* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第2章中，*处理集合*的*创建自定义迭代器*配方[977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml]
