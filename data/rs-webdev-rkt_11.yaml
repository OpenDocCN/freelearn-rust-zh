- en: '*Chapter 9*: Displaying Users'' Post'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：显示用户帖子'
- en: 'In this chapter, we are going to implement displaying user posts. Along with
    displaying user posts, we are going to learn about **generic data types** and
    **trait bounds** to group types that behave similarly and so reduce the creation
    of similar code. We are also going to learn about the most important part of the
    Rust programming language: the memory model and its terminologies. We are going
    to learn more about **ownership**, **moving**, **copying**, **cloning**, **borrowing**,
    and **lifetime**, and how we can implement those in our code.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现显示用户帖子。除了显示用户帖子外，我们还将学习 **泛型数据类型** 和 **特质边界**，以将行为相似的类型分组，从而减少相似代码的创建。我们还将学习
    Rust 编程语言最重要的部分：内存模型及其术语。我们将学习更多关于 **所有权**、**移动**、**复制**、**克隆**、**借用** 和 **生命周期**
    的知识，以及如何在我们的代码中实现这些。
- en: After completing this chapter, you will understand and implement those concepts
    in Rust programming. Generic data types and trait bounds are useful to reduce
    repetitions, while the Rust memory model and concepts are arguably the most distinctive
    features of the Rust language and make it not only fast but one of the safest
    programming languages. Those concepts also make people say that Rust has a steep
    learning curve.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将理解并在 Rust 编程中实现这些概念。泛型数据类型和特质边界有助于减少重复，而 Rust 的内存模型和概念可以说是 Rust 语言最独特的特性，使其不仅速度快，而且是最安全的编程语言之一。这些概念也使得人们说
    Rust 有一个陡峭的学习曲线。
- en: 'In this chapter, we are going to cover these main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Displaying posts – text, photo, and video
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示帖子 – 文本、照片和视频
- en: Using generic data types and trait bounds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型数据类型和特质边界
- en: Learning about ownership and moving
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习所有权和移动
- en: Borrowing and lifetime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借用和生命周期
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们与上一章有相同的技术要求。我们需要一个 Rust 编译器、一个文本编辑器、一个 HTTP 客户端和一个 PostgreSQL 数据库服务器。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09)
    找到本章的源代码。
- en: Displaying posts – text, photo, and video
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示帖子 – 文本、照片和视频
- en: In the previous chapters, we implemented user management, including listing,
    showing, creating, updating, and deleting user entities. Now, we want to do the
    same with posts. To refresh your memory, we are planning to have `User` posts.
    The posts can be either text, photos, or videos.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们实现了用户管理，包括列出、显示、创建、更新和删除用户实体。现在，我们想要对帖子做同样的事情。为了刷新你的记忆，我们计划有 `User`
    帖子。帖子可以是文本、照片或视频。
- en: 'When we implemented the application skeleton, we created a `Post` struct in
    `src/models/post.rs` with the following content:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现了应用程序骨架时，我们在 `src/models/post.rs` 中创建了一个 `Post` 结构体，其内容如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The plan is to use `post_type` to differentiate a post based on its type and
    use the `content` field to store the content of the post.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 计划使用 `post_type` 来区分帖子类型，并使用 `content` 字段来存储帖子的内容。
- en: 'Now that we have rehashed what we wanted to do, let''s implement showing the
    posts:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重新梳理了我们想要做的事情，让我们来实现显示帖子：
- en: 'The first thing we want to do is to create a migration file to change the database
    schema. We want to create a table to store the posts. In the application root
    folder, run this command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是创建一个迁移文件来更改数据库模式。我们想要创建一个表来存储帖子。在应用程序根目录下，运行以下命令：
- en: '[PRE7]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We should then see a new file in the `migrations` folder named `YYYYMMDDHHMMSS_create_posts.sql`
    (depending on the current date-time). Edit the file with the following lines:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该会在 `migrations` 文件夹中看到一个名为 `YYYYMMDDHHMMSS_create_posts.sql` 的新文件（取决于当前日期时间）。使用以下行编辑文件：
- en: '[PRE8]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After editing the file, run the migration in the command line to create the
    database table:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑文件后，在命令行中运行迁移以创建数据库表：
- en: '[PRE9]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have also created a `DisplayPostContent` trait in `src/traits/mod.rs`, which
    has the `raw_html()` method. We want to show content in `Post` by converting content
    to HTML snippets and rendering the snippets in the Tera template. Change the signature
    of `raw_html()` so we can use `Post` as the source of HTML snippets:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在 `src/traits/mod.rs` 中创建了一个名为 `DisplayPostContent` 的特质，它有一个 `raw_html()`
    方法。我们希望通过将内容转换为 HTML 片段并在 Tera 模板中渲染这些片段来显示 `Post` 中的内容。更改 `raw_html()` 的签名，以便我们可以使用
    `Post` 作为 HTML 片段的来源：
- en: '[PRE10]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can implement each of the types in `src/models/text_post.rs`, `src/models/photo_post.rs`,
    and `src/models/video_post.rs`. Start with changing `src/models/text_post.rs`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以实现 `src/models/text_post.rs`、`src/models/photo_post.rs` 和 `src/models/video_post.rs`
    中的每个类型。从修改 `src/models/text_post.rs` 开始：
- en: '[PRE11]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The implementation is very simple, we are just wrapping the `Post` content inside
    a `p` HTML tag.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简单，我们只是在 `Post` 内容周围包裹了一个 `p` HTML 标签。
- en: 'Next, modify `src/models/photo_post.rs`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改 `src/models/photo_post.rs`：
- en: '[PRE12]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For `PhotoPost`, we used the `Post` content as the source of the `img` HTML
    tag.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `PhotoPost`，我们使用 `Post` 内容作为 `img` HTML 标签的来源。
- en: 'The last type we modify is `src/models/video_post.rs`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个我们修改的类型是 `src/models/video_post.rs`：
- en: '[PRE13]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For `VideoPost`, we are using the `Post` content as the source of the `video`
    HTML tag.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `VideoPost`，我们使用 `Post` 内容作为 `video` HTML 标签的来源。
- en: We need to create templates for the posts. Let's start with a template that
    will be used in a single post or multiple posts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为帖子创建模板。让我们从一个将用于单个帖子或多个帖子的模板开始。
- en: 'Create a `posts` folder in the `src/views` folder. Then, create a `_post.html.tera`
    file inside the `src/views/posts` folder. Add the following lines to the file:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/views` 文件夹中创建一个 `posts` 文件夹。然后，在 `src/views/posts` 文件夹中创建一个 `_post.html.tera`
    文件。将该文件中的以下行添加到文件中：
- en: '[PRE14]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are wrapping some content inside a `div` and filtering the content as safe
    HTML.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `div` 中包裹了一些内容，并将内容过滤为安全的 HTML。
- en: 'In the `src/views/posts` folder, create a `show.html.tera` file as a template
    to show a single post. Add the following lines to the file:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/views/posts` 文件夹中，创建一个 `show.html.tera` 文件作为模板来显示单个帖子。将该文件中的以下行添加到文件中：
- en: '[PRE15]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create an `index.html.tera` file inside the `src/views/posts` folder to show
    user posts. Add the following lines:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/views/posts` 文件夹中创建一个 `index.html.tera` 文件来显示用户帖子。将该文件中的以下行添加到文件中：
- en: '[PRE16]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After creating the views, we can implement methods for the `Post` struct to
    get the data from the database. Modify the `src/models/post.rs` file to include
    `use` declarations:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建视图后，我们可以实现 `Post` 结构体的方法来从数据库获取数据。修改 `src/models/post.rs` 文件以包含 `use` 声明：
- en: '[PRE17]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We need to derive `FromRow` for the `Post` struct to convert database rows
    into `Post` instances:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为 `Post` 结构体派生 `FromRow` 以将数据库行转换为 `Post` 实例：
- en: '[PRE18]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create an `impl` block for `Post`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Post` 创建一个 `impl` 块：
- en: '[PRE19]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside the `impl Post` block, we can add functions to query the database and
    return the `Post` data. As the functions are similar to the `User` functions,
    you can copy the code for *steps 14* to *17* in the `Chapter09/01DisplayingPost`
    source code folder. First, we add the `find()` method to get a single post:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `impl Post` 块内部，我们可以添加查询数据库并返回 `Post` 数据的函数。由于这些函数与 `User` 函数类似，你可以从 `Chapter09/01DisplayingPost`
    源代码文件夹中的 *步骤 14* 到 *17* 复制代码。首先，我们添加 `find()` 方法来获取单个帖子：
- en: '[PRE20]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the `find_all()` method:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `find_all()` 方法：
- en: '[PRE21]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the `find_all_without_pagination()` method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `find_all_without_pagination()` 方法：
- en: '[PRE22]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the `find_all_with_pagination()` method:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `find_all_with_pagination()` 方法：
- en: '[PRE23]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to add methods to convert a `Post` instance into `TextPost`, `PhotoPost`,
    or `VideoPost`. Add the following lines inside the `impl Post` block:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加将 `Post` 实例转换为 `TextPost`、`PhotoPost` 或 `VideoPost` 的方法。在 `impl Post`
    块内部添加以下行：
- en: '[PRE24]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the view and model implementations are ready, we can implement the function
    for showing user posts. In `src/routes/post.rs`, add the required `use` declarations:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当视图和模型实现就绪后，我们可以实现显示用户帖子的函数。在 `src/routes/post.rs` 中添加所需的 `use` 声明：
- en: '[PRE25]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify the `get_post()` function inside `src/routes/post.rs`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `src/routes/post.rs` 中的 `get_post()` 函数：
- en: '[PRE26]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside the `get_post()` function, query the `user` information and the `post`
    information from the database. Write the following lines:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `get_post()` 函数内部，从数据库查询 `user` 信息和 `post` 信息。写入以下行：
- en: '[PRE27]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `src/views/posts/show.html.tera` and `src/views/posts/_post.html.tera`,
    we have set two variables: `user` and `post`. We have to add those two variables
    into the context passed to the template. Append two structs that will be passed
    to templates:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/views/posts/show.html.tera` 和 `src/views/posts/_post.html.tera` 文件中，我们设置了两个变量：`user`
    和 `post`。我们必须将这两个变量添加到传递给模板的上下文中。添加两个将要传递给模板的结构体：
- en: '[PRE28]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And finally, we can pass the `user` and `post` variables into `context`, render
    the template along with `context`, and return from the function. Append the following
    lines:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将`user`和`post`变量传递到`context`中，与`context`一起渲染模板，并从函数中返回。添加以下行：
- en: '[PRE29]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the `get_posts()` function in `src/routes/post.rs`, we want to get the
    `posts` data from the database. Modify the function into the following lines:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`src/routes/post.rs`中的`get_posts()`函数，我们希望从数据库中获取`posts`数据。将函数修改为以下行：
- en: '[PRE30]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have implemented getting the `posts` data, it''s time to render
    those posts as well. Inside the `get_posts()` function, append the following lines:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经实现了获取`posts`数据的功能，是时候将这些帖子渲染出来了。在`get_posts()`函数内部，添加以下行：
- en: '[PRE31]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we have finished the code for `get_post()` and `get_posts()`, it''s time
    to test those two endpoints. Try adding images and videos to a static folder and
    add an entry in the database. You can find a sample image and video in the static
    folder in the source code in the GitHub repository for this chapter. Here is an
    example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`get_post()`和`get_posts()`的代码，是时候测试这两个端点了。尝试向静态文件夹中添加图片和视频，并在数据库中添加条目。你可以在GitHub仓库中找到本章源代码中的静态文件夹中的示例图片和视频。以下是一个示例：
- en: '![Figure 9.1 – Testing the endpoints'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 测试端点'
- en: '](img/Figure_9.1_B16825.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B16825.jpg)'
- en: Figure 9.1 – Testing the endpoints
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 测试端点
- en: 'When we open a web browser and navigate to the user posts page, we should be
    able to see something similar to this screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开网络浏览器并导航到用户帖子页面时，我们应该能够看到类似于以下截图的内容：
- en: '![Figure 9.2 – Example user posts page'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 示例用户帖子页面'
- en: '](img/Figure_9.2_B16825.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B16825.jpg)'
- en: Figure 9.2 – Example user posts page
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 示例用户帖子页面
- en: We have implemented the functions to show posts, but if we look back at the
    code, we can see that all three types (Text, Photo, and Video) have the same method
    because they are all implementing the same interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了显示帖子的函数，但如果我们回顾一下代码，我们可以看到这三种类型（文本、照片和视频）都有相同的方法，因为它们都在实现相同的接口。
- en: Let's convert those into generic data types and trait bounds in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们将这些内容转换为泛型数据类型和特质界限。
- en: Using generic data types and trait bounds
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型数据类型和特质界限
- en: A **generic data type**, **generic type**, or simply, **generic**, is a way
    for programming languages to be able to apply the same routine to different data
    types.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型数据类型**、**泛型类型**，或者简单地称为**泛型**，是编程语言能够将相同的程序应用于不同数据类型的一种方式。'
- en: 'For example, we want to create a `multiplication(a, b) -> c {}` function for
    different data types, `u8` or `f64`. If a language does not have a generic, a
    programmer might have to implement two different functions, for example, `multiplication_u8(a:
    u8, b: u8) -> u8` and `multiplication_f64(a: f64, b: f64) -> f64`. Creating two
    different functions might look simple, but as the application grows in complexity,
    the branching and figuring out which function to use will be more complex. If
    a language has a generic, then the problem of multiple functions can be solved
    by using a single function that can accept `u8` and `f64`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，我们希望为不同的数据类型创建一个`multiplication(a, b) -> c {}`函数，例如`u8`或`f64`。如果一个语言没有泛型，程序员可能不得不实现两个不同的函数，例如，`multiplication_u8(a:
    u8, b: u8) -> u8`和`multiplication_f64(a: f64, b: f64) -> f64`。创建两个不同的函数看起来可能很简单，但随着应用程序的复杂性增加，分支和确定使用哪个函数将会更加复杂。如果一个语言有泛型，那么可以通过使用单个可以接受`u8`和`f64`的函数来解决多个函数的问题。'
- en: 'In the Rust language, we can make a function to use generics by declaring the
    generics inside angle brackets after the function name as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust语言中，我们可以通过在函数名后面声明泛型来创建一个泛型函数，如下所示：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can also use generics in a `struct` or `enum` definition. Here is an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`struct`或`enum`定义中使用泛型。以下是一个示例：
- en: '[PRE33]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can also use generics inside method definitions. Following `Something<T>`,
    we can implement the method as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在方法定义中使用泛型。在`Something<T>`之后，我们可以实现方法如下：
- en: '[PRE41]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At compile time, the compiler identifies and changes the generic code into specific
    code by using the concrete type (`u8` or `f64` in our multiplication example),
    depending on which type is used. This process is called **monomorphization**.
    Because of monomorphization, code written using a generic will produce a binary
    that has the same execution speed as binary generated using specific code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，编译器通过使用具体的类型（在我们的乘法示例中为 `u8` 或 `f64`）来识别和将泛型代码转换为特定代码，具体取决于使用了哪种类型。这个过程称为**单态化**。由于单态化，使用泛型编写的代码生成的二进制文件将具有与使用特定代码生成的二进制文件相同的执行速度。
- en: 'Now that we have looked at an introduction to generics, let''s use generics
    in our existing application:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了泛型简介，让我们在我们的现有应用程序中使用泛型：
- en: 'In the `src/models/post.rs` file, add another method to convert `Post` instances
    into `media`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/models/post.rs` 文件中，添加另一个方法将 `Post` 实例转换为 `media`：
- en: '[PRE44]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We are telling the `to_media()` method to return the type that implemented `DisplayPostContent`
    and put `TextPost`, `PhotoPost`, or `VideoPost` into the heap.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在告诉 `to_media()` 方法返回实现了 `DisplayPostContent` 的类型，并将 `TextPost`、`PhotoPost`
    或 `VideoPost` 放入堆中。
- en: 'In the `src/routes/post.rs` file, inside the `get_post()` function, and after
    the `Context` struct declaration, add the following lines:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/routes/post.rs` 文件中，`get_post()` 函数内部，`Context` 结构体声明之后，添加以下行：
- en: '[PRE45]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Yes, we can create a function inside another function. The inner function will
    have local scope and cannot be used outside the `get_post()` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以在另一个函数内部创建一个函数。内部函数将具有局部作用域，并且不能在 `get_post()` 函数外部使用。
- en: 'We need to change the `context` variable from initiating the struct directly,
    as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将 `context` 变量从直接初始化结构体更改为如下所示：
- en: '[PRE46]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to change it into using the `create_context()` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其更改为使用 `create_context()` 函数：
- en: '[PRE47]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: At this point, we can see that `create_context()` can use any type, such as
    `String` or `u8`, but `String` and `u8` types don't have the `raw_html()` function.
    The Rust compiler will show an error when compiling the code. Let's fix this problem
    by using **trait bounds**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以看到 `create_context()` 可以使用任何类型，例如 `String` 或 `u8`，但 `String` 和 `u8`
    类型没有 `raw_html()` 函数。当编译代码时，Rust 编译器将显示错误。让我们通过使用**特性界限**来解决这个问题。
- en: We have defined and implemented traits several times, and we already know that
    a trait provides consistent behavior for different data types. We defined the
    `DisplayPostContent` trait in `src/traits/mod.rs`, and every type that implements
    `DisplayPostContent` has the same method, `raw_html(&self) -> String`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义和实现了多个特性，并且我们已经知道特性为不同数据类型提供了一致的行为。我们在 `src/traits/mod.rs` 中定义了 `DisplayPostContent`
    特性，并且实现了 `DisplayPostContent` 的每个类型都有相同的方法，即 `raw_html(&self) -> String`。
- en: 'We can limit the generic type by adding a trait after the generic declaration.
    Change the `create_context()` function to use trait bounds:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在泛型声明后添加一个特性来限制泛型类型。将 `create_context()` 函数更改为使用特性界限：
- en: '[PRE48]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Unfortunately, using `DisplayPostContent` alone is not enough, because the
    `T` size is not fixed. We can change the function parameters from `media: T` into
    a `media: &T` reference, as a reference has a fixed size. We also have another
    problem, as the `DisplayPostContent` size is not known at compile time, so we
    need to add another bound. Every `T` type is implicitly expected to have a constant
    size at compile time, implicitly trait bound to `std::marker::Sized`. We can remove
    the implicit bound by using a special `?Size` syntax.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '不幸的是，仅使用 `DisplayPostContent` 是不够的，因为 `T` 的大小不是固定的。我们可以将函数参数从 `media: T` 改为
    `media: &T` 引用，因为引用具有固定的大小。我们还有另一个问题，因为 `DisplayPostContent` 的大小在编译时是未知的，所以我们需要添加另一个界限。每个
    `T` 类型在编译时都隐式地期望具有一个常量大小，隐式特性界限为 `std::marker::Sized`。我们可以通过使用特殊的 `?Size` 语法来移除隐式界限。'
- en: 'We can have more than one trait bound and combine them using the `+` sign.
    The resulting signature for the `create_context()` function will be as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多个特性绑定，并通过使用加号（`+`）将它们组合起来。`create_context()` 函数的结果签名将如下所示：
- en: '[PRE49]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Writing multiple trait bounds inside angle brackets (`<>`) can make the function
    signature hard to read, so there''s an alternative syntax for defining trait bounds:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在尖括号（`<>`）内编写多个特性界限会使函数签名难以阅读，因此有一个用于定义特性界限的替代语法：
- en: '[PRE50]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Because we changed the function signature to use a reference, we have to change
    the function usage as well:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们更改了函数签名以使用引用，因此我们必须更改函数的使用方式：
- en: '[PRE52]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We get `media` object by dereferencing using the `*` sign and referencing `media`
    again using the `&` sign.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用解引用符号（`*`）获取 `media` 对象，并通过使用引用符号（`&`）再次引用 `media`。
- en: Now, the Rust compiler should be able to compile the code again. We will learn
    more about reference in the next two sections, but before that, we have to learn
    about Rust's memory model called ownership and moving.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Rust 编译器应该能够再次编译代码。我们将在下一两个部分中学习更多关于引用的内容，但在那之前，我们必须学习 Rust 的内存模型，称为所有权和移动。
- en: Learning about ownership and moving
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习所有权和移动
- en: When we instantiate a struct, we create an **instance**. Imagine a struct as
    being like a template; an instance is created in the memory based on the template
    and filled with appropriate data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化一个结构体时，我们创建一个**实例**。想象一下结构体就像一个模板；实例是基于模板在内存中创建的，并填充了适当的数据。
- en: 'An instance in Rust has a **scope**; it is created in a function and gets returned.
    Here is an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的实例有一个**作用域**；它在函数中创建并返回。以下是一个例子：
- en: '[PRE53]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If an instance is not returned, then it''s removed from memory because it''s
    not used anymore. In this example, the `user` instance will be removed by the
    end of the function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个实例没有被返回，那么它将从内存中移除，因为它不再被使用。在这个例子中，`user` 实例将在函数结束时被移除：
- en: '[PRE58]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can say that an instance has a scope, as mentioned previously. Any resources
    created inside a scope will be destroyed by the end of the scope in the *reverse
    order* of their creation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说实例有一个作用域，如前所述。在作用域内创建的资源将在作用域结束时以它们创建的**相反顺序**被销毁。
- en: 'We can also create a local scope in a routine by using curly brackets, `{}`.
    Any instance created inside the scope will be destroyed by the end of the scope.
    For example, the `user` scope is within the curly brackets:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用花括号 `{}` 在例程中创建一个局部作用域。在作用域内创建的任何实例将在作用域结束时被销毁。例如，`user` 作用域位于花括号内：
- en: '[PRE62]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: An instance **owns** resources, not only in **stack memory** but also in **heap
    memory**. When an instance goes out of scope, either because of function exits
    or curly brackets scope exits, the resource attached to the instance is automatically
    cleaned *in reverse order of the creation*. This process is called **resource
    acquisition is initialization** (**RAII**).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实例**拥有**资源，不仅是在**栈内存**中，也在**堆内存**中。当实例超出作用域时，无论是由于函数退出还是花括号作用域退出，附加到实例的资源将自动以创建的**相反顺序**清理。这个过程被称为**资源获取即初始化**（**RAII**）。
- en: 'Imagine that computer memory consists of a stack and a heap:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下计算机内存由栈和堆组成：
- en: '[PRE67]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'An instance owns memory from stack memory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实例拥有栈内存中的内存：
- en: '[PRE69]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Another instance may own memory from the stack and the heap. For example, a
    string can be a single word or a couple of paragraphs. We cannot say how large
    a `String` instance is going to be, so we cannot store all of the information
    in stack memory; instead, we can store some in stack memory and some in heap memory.
    This is a simplification of what it looks like:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个实例可能从栈和堆中拥有内存。例如，一个字符串可以是一个单词或几段文字。我们无法确定 `String` 实例的大小，因此我们无法将所有信息存储在栈内存中；相反，我们可以将一些信息存储在栈内存中，将一些信息存储在堆内存中。这是一个简化的表示：
- en: '[PRE71]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In other programming languages, there's a function called a `std::ops::Drop`
    trait. But, most types don't need to implement the `Drop` trait and are automatically
    removed from memory when they're out of scope.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言中，有一个名为 `std::ops::Drop` 的函数。但是，大多数类型不需要实现 `Drop` 特性，并且当它们超出作用域时将自动从内存中移除。
- en: 'In Rust, if we create an instance and set the instance to another instance,
    it is called `src/routes/post.rs` file, inside the `get_posts()` function, modify
    it into the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，如果我们创建一个实例并将其设置为另一个实例，它被称为 `src/routes/post.rs` 文件中的 `get_posts()`
    函数，修改如下：
- en: '[PRE74]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If we compile the program, we should see an error similar to the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译程序，我们应该看到类似于以下错误的错误：
- en: '[PRE82]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'What is moving? Let''s go back to the simplification of memory. When an instance
    is assigned to another instance, some of the second instance is allocated in stack
    memory:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是移动？让我们回到内存简化的例子。当一个实例被分配给另一个实例时，第二个实例的一部分将在栈内存中分配：
- en: '[PRE83]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, some of the new instance points to old data in the heap:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一些新的实例指向堆中的旧数据：
- en: '[PRE86]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If both instances point to the same heap memory, what happens if the first instance
    gets dropped? Because of the possibility of invalid data, in Rust, only one instance
    may have its own resources. The Rust compiler will refuse to compile code that
    uses an instance that has been moved.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个实例都指向相同的堆内存，那么第一个实例被丢弃时会发生什么？由于无效数据的可能性，在 Rust 中，只有一个实例可以拥有自己的资源。Rust 编译器将拒绝编译使用已移动实例的代码。
- en: 'If we look at our code, the `to_media()` method in `Post` moved the `post`
    instance and put it inside either `TextPost`, `PhotoPost`, or `VideoPost`. As
    a result, we cannot use the `post` instance again in `post.uuid.to_string()` because
    it has been moved. Right now, we can fix the code by changing the order of the
    lines:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的代码，`Post`中的`to_media()`方法移动了`post`实例，并将其放入`TextPost`、`PhotoPost`或`VideoPost`中。因此，我们不能在`post.uuid.to_string()`中使用`post`实例，因为它已经被移动了。现在，我们可以通过改变行顺序来修复代码：
- en: '[PRE89]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: There's no moving when we use `post.uuid.to_string()`, so the code should compile.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`post.uuid.to_string()`时没有移动，所以代码应该可以编译。
- en: 'But, how we can create a `std::marker::Copy` trait, then when we assign an
    instance from another instance, it will create a duplicate in the stack. This
    is the reason why simple types such as `u8`, which don''t require a lot of memory
    or have a known size, implement the `Copy` trait. Let''s see the illustration
    of how this code works:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何创建一个`std::marker::Copy` trait，这样当我们从一个实例赋值给另一个实例时，它会在栈上创建一个副本。这就是为什么像`u8`这样的简单类型，它们不需要太多内存或具有已知大小，实现了`Copy`
    trait。让我们看看这个代码是如何工作的说明：
- en: '[PRE96]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'A type may automatically derive the `Copy` trait if all members of that type
    implement the `Copy` trait. We also have to derive `Clone`, because the `Copy`
    trait is trait bound by the `Clone` trait in its definition: `pub trait Copy:
    Clone { })`. Here is an example of deriving the `Copy` trait:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个类型的所有成员都实现了`Copy` trait，那么这个类型可以自动推导出`Copy` trait。我们还需要推导`Clone`，因为`Copy`
    trait在其定义中由`Clone` trait所约束：`pub trait Copy: Clone { })`。以下是一个推导`Copy` trait的例子：'
- en: '[PRE100]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'However, this example will not work because `String` does not implement `Copy`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个例子将不会工作，因为`String`没有实现`Copy`：
- en: '[PRE104]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This example will work:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子会工作：
- en: '[PRE110]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Cloning works by copying the content of the heap memory. For example, let''s
    say we have the preceding code and the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆是通过复制堆内存的内容来工作的。例如，假设我们有前面的代码和以下代码：
- en: '[PRE116]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We can visualize `dolly` as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`dolly`可视化如下：
- en: '[PRE117]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Let''s say we assign another instance from `dolly`, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们像这样从`dolly`赋值另一个实例：
- en: '[PRE120]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'This is what the memory usage looks like:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是内存使用的情况：
- en: '[PRE121]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'As allocating heap memory is expensive, we can use another way to see the value
    of an instance: **borrowing**.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分配堆内存很昂贵，我们可以使用另一种方式来查看实例的值：**借用**。
- en: Borrowing and lifetime
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用和生命周期
- en: 'We have used **references** in our code. A reference is an instance in the
    stack that points to another instance. Let''s recall what an instance memory usage
    looks like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的代码中使用了**引用**。引用是栈中的一个实例，它指向另一个实例。让我们回顾一下实例内存使用的情况：
- en: '[PRE124]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'A reference is allocated in stack memory, pointing to another instance:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是在栈内存中分配的，指向另一个实例：
- en: '[PRE127]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Allocating in the stack is cheaper than allocating in the heap. Because of this,
    using references most of the time is more efficient than cloning. The process
    of creating a reference is called **borrowing**, as the reference borrows the
    content of another instance.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈上分配比在堆上分配更便宜。正因为如此，大多数时候使用引用比克隆更高效。创建引用的过程被称为**借用**，因为引用借用了另一个实例的内容。
- en: 'Suppose we have an instance named `airwolf`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`airwolf`的实例：
- en: '[PRE130]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We can create a reference to `airwolf` by using an ampersand (`&`) operator:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用连字符(`&`)操作符来创建对`airwolf`的引用：
- en: '[PRE140]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Borrowing an instance is like a camera monitor; a reference can see the value
    of the referenced instance, but the reference cannot modify the value. We can
    have more than one reference, as seen in this example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 借用一个实例就像是一个摄像头监视器；一个引用可以看到被引用实例的值，但不能修改这个值。我们可以有多个引用，就像这个例子中看到的那样：
- en: '[PRE141]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'What if we want a reference that can modify the value of the instance it referenced?
    We can create a `&mut` operator:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个可以修改其所引用实例值的引用呢？我们可以创建一个`&mut`操作符：
- en: '[PRE145]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Now, what will happen if we have two remote controls? Well, the helicopter cannot
    ascend and descend at the same time. In the same way, Rust restricts mutable references
    and only allows one mutable reference at a time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有两个遥控器会发生什么呢？嗯，直升机不能同时上升和下降。同样地，Rust限制了可变引用，并且一次只允许一个可变引用。
- en: 'Rust also disallows using mutable references along with immutable references
    because data inconsistency may occur. For example, adding the following lines
    will not work:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Rust还禁止同时使用可变引用和不可变引用，因为可能会发生数据不一致。例如，添加以下行将不会工作：
- en: '[PRE147]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: What is the value of `last_load`? We expected `last_load` to be `None`, but
    the remote control already pushed something to cargo. Because of the data inconsistency
    problem, the Rust compiler will emit an error if we try to compile the code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`last_load`的值是多少？我们期望`last_load`为`None`，但遥控器已经将某些内容推送到货物中。由于数据不一致问题，如果我们尝试编译代码，Rust编译器将发出错误。'
- en: Implementing borrowing and lifetime
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现借用和生命周期
- en: Now that we have learned about ownership, moving, and borrowing, let's modify
    our code to use references.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了所有权、移动和借用，让我们修改我们的代码以使用引用。
- en: 'If we look at the current definition for `TextPost`, `PhotoPost`, and `VideoPost`,
    we can see we are taking ownership of `post` and moving the `post` instance into
    a new instance of `TextPost`, `PhotoPost`, or `VideoPost`. In `src/models/text_post.rs`
    add the following struct:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看`TextPost`、`PhotoPost`和`VideoPost`的当前定义，我们可以看到我们正在获取`post`的所有权并将`post`实例移动到新的`TextPost`、`PhotoPost`或`VideoPost`实例中。在`src/models/text_post.rs`中添加以下结构体：
- en: '[PRE149]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'And in `src/models/post.rs` , add the following function:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/post.rs`中，添加以下函数：
- en: '[PRE150]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'We can convert the `TextPost` field to be a reference to a `Post` instance.
    Modify `src/models/text_post.rs` into the following:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将`TextPost`字段转换为对`Post`实例的引用。将`src/models/text_post.rs`修改为以下内容：
- en: '[PRE151]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Since we are converting the unnamed field into a private unnamed field, we
    also need an initializer. Append the following lines:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将未命名的字段转换为私有未命名的字段，我们还需要一个初始化器。追加以下行：
- en: '[PRE152]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Since we changed the initialization of `TextPost`, we also need to change the
    implementation of `to_text()` and `to_media()`. In `src/models/post.rs`, change
    the `to_text()` method to the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们改变了`TextPost`的初始化，我们还需要更改`to_text()`和`to_media()`的实现。在`src/models/post.rs`中，将`to_text()`方法修改为以下内容：
- en: '[PRE153]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Change the `to_media()` method to the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将`to_media()`方法修改为以下内容：
- en: '[PRE154]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Let''s try compiling the code. We should see an error as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试编译代码。我们应该看到一个错误，如下所示：
- en: '[PRE155]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The reason for this error is that the code needs a **lifetime specifier**.
    What is a lifetime specifier? Let''s see an example of a very simple program:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 出现这个错误的原因是代码需要一个**生命周期指定符**。生命周期指定符是什么？让我们看看一个非常简单的程序的例子：
- en: '[PRE156]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Remember, in Rust, any instance is removed automatically after we reach the
    end of the scope. In the preceding code, `y` is created inside a scope denoted
    by curly brackets, `{}`. When the code reaches the end of the scope, `}`, the
    `y` instance is cleared from the memory. So, what will happen with `x`? The preceding
    code will fail to compile because `x` is not valid anymore. We can fix the code
    as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，在Rust中，任何实例在达到作用域的末尾后都会自动移除。在前面的代码中，`y`是在由花括号`{}`表示的作用域内创建的。当代码到达作用域的末尾`}`时，`y`实例将从内存中清除。那么`x`会发生什么？前面的代码将无法编译，因为`x`不再有效。我们可以按照以下方式修复代码：
- en: '[PRE157]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Now, let''s take a look at our code in `src/models/text_post.rs`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看`src/models/text_post.rs`中的代码：
- en: '[PRE158]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Because Rust is multithreaded and has a lot of branching, we cannot guarantee
    that the reference to the `Post` instance, `&Post`, can exist for as long as the
    `TextPost` instance. What will happen if `&Post` is already destroyed while the
    `TextPost` instance is not destroyed? The solution is that we place a marker called
    a `TextPost` as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Rust是多线程的，并且有很多分支，我们无法保证对`Post`实例的引用`&Post`可以像`TextPost`实例一样长命。如果`&Post`在`TextPost`实例未销毁的情况下已经被销毁，会发生什么？解决方案是在以下位置放置一个标记，称为`TextPost`：
- en: '[PRE159]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: We are telling the compiler that any instance of `TextPost` should live as long
    as the referenced `&Post`, which indicated by lifetime indicator, `'a`. If the
    compiler finds out that `&Post` is not living as long as the `TextPost` instance,
    it does not compile the program.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在告诉编译器，任何`TextPost`实例都应该与引用的`&Post`一样长命，这由生命周期指示符`'a`表示。如果编译器发现`&Post`没有像`TextPost`实例一样长命，它将不会编译程序。
- en: 'The convention for a lifetime specifier is using a small, single letter such
    as `''a`, but there''s also a special lifetime specifier, `''static`. A `''static`
    lifetime specifier means the data referenced is living as long as the application.
    For example, we are saying the data referenced by `pi` will live as long as the
    application:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期指定符的约定是使用小写单字母，如`'a`，但还有一个特殊的生命周期指定符，`'static`。`'static`生命周期指定符意味着引用的数据与应用程序一样长命。例如，我们说`pi`引用的数据将与应用程序一样长命：
- en: '[PRE160]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Let''s modify the rest of the application. We have seen how we use a lifetime
    specifier in the type definition; let''s use it in an `impl` block and method
    as well. Modify the rest of `src/models/text_post.rs` into the following:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改应用程序的其余部分。我们已经看到了如何在类型定义中使用生命周期指定符；现在让我们在 `impl` 块和方法中也使用它。将 `src/models/text_post.rs`
    的其余部分修改为以下内容：
- en: '[PRE161]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Let''s change `PhotoPost` in `src/models/photo_post.rs` to use lifetime as
    well:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 `src/models/photo_post.rs` 中的 `PhotoPost` 修改为也使用生命周期：
- en: '[PRE162]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Let''s also change `VideoPost` in `src/models/video_post.rs`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也将 `VideoPost` 在 `src/models/video_post.rs` 中进行更改：
- en: '[PRE163]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'And in `src/models/post.rs`, modify the code as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/models/post.rs` 文件中，按照以下方式修改代码：
- en: '[PRE164]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Now, we are using a borrowed `Post` instance for `TextPost`, `PhotoPost`, or
    `VideoPost` instances. But, before we end this chapter, let''s refactor the code
    a little bit by following these instructions:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在使用借用的 `Post` 实例来处理 `TextPost`、`PhotoPost` 或 `VideoPost` 实例。但在结束本章之前，让我们根据以下说明稍微重构一下代码：
- en: 'We can see the `ShowPost` struct is duplicated inside `get_post()` and `get_posts()`.
    Add a new struct into `src/models/post.rs`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到 `ShowPost` 结构体在 `get_post()` 和 `get_posts()` 中被重复。在 `src/models/post.rs`
    中添加一个新的结构体：
- en: '[PRE165]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Add a method to convert `Post` into `ShowPost`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个将 `Post` 转换为 `ShowPost` 的方法：
- en: '[PRE166]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'In `src/routes/post.rs`, add `ShowPost` to a `use` declaration:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/routes/post.rs` 中，将 `ShowPost` 添加到 `use` 声明中：
- en: '[PRE167]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Modify the `get_post()` function by removing these lines to remove unnecessary
    struct declarations and functions:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过删除以下行来修改 `get_post()` 函数，以删除不必要的结构体声明和函数：
- en: '[PRE168]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Replace those lines with the `context!` macro:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些行替换为 `context!` 宏：
- en: '[PRE169]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'In the `get_posts()` function, remove these lines:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `get_posts()` 函数中，删除以下行：
- en: '[PRE170]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Replace those lines with this line:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行替换为这一行：
- en: '[PRE171]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Also, change the `context` instantiation:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，更改 `context` 实例化：
- en: '[PRE172]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'And finally, remove the unnecessary `use` declaration. Remove these lines:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，删除不必要的 `use` 声明。删除以下行：
- en: '[PRE173]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The implementation of showing posts should be cleaner now we are using the borrowed
    `Post` instance. There should be no difference in the speed of the application
    because we are just using the reference of a single instance.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用借用的 `Post` 实例显示帖子，实现应该更简洁。应用程序的速度应该没有差异，因为我们只是使用单个实例的引用。
- en: In fact, sometimes it's better to use an owned attribute instead of a reference
    because there's no significant performance improvement. Using references can be
    useful in complex applications, high-memory usage applications, or high-performance
    applications such as gaming or high-speed trading with a lot of data, at the cost
    of development time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有时使用所有者属性而不是引用更好，因为没有显著的性能提升。在复杂的应用程序、高内存使用应用程序或高性能应用程序（如游戏或高速交易，数据量很大）中，使用引用可能是有用的，但这要以开发时间为代价。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have implemented `get_post()` and `get_posts()` to show
    `Post` information in a web browser. Along with those implementations, we have
    learned about reducing code duplication through generics and trait bounds.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了 `get_post()` 和 `get_posts()` 来在网页中显示 `Post` 信息。随着这些实现，我们还学习了通过泛型和特质界限来减少代码重复。
- en: 'We have also learned about the most distinct and important feature of Rust:
    its memory model. We now know an instance owns a memory block, either in the stack
    or in both the stack and heap. We have also learned that assigning another instance
    to an instance means moving ownership unless it''s a simple type that implements
    the `Copy` and/or `Clone` trait. We have also learned about borrowing, the rules
    of borrowing, and the use of the lifetime specifier to complement moving, copying,
    and borrowing.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了 Rust 最独特和最重要的特性：其内存模型。我们现在知道一个实例拥有一个内存块，要么在栈上，要么同时在栈和堆上。我们还了解到将另一个实例赋值给实例意味着移动所有权，除非它是一个实现了
    `Copy` 和/或 `Clone` 特性的简单类型。我们还学习了借用、借用的规则以及使用生命周期指定符来补充移动、复制和借用。
- en: Those rules are some of the most confusing parts of Rust, but those rules are
    also what make Rust a very safe language while still having the same performance
    as other system languages such as C or C++. Now that we have implemented showing
    posts, let's learn how to upload data in the next chapter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则是 Rust 中最令人困惑的部分之一，但正是这些规则使得 Rust 在保持与其他系统语言（如 C 或 C++）相同性能的同时，成为一个非常安全的语言。现在我们已经实现了显示帖子，让我们在下一章学习如何上传数据。
