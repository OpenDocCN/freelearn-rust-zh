- en: Concurrency in Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 的并发
- en: Computers have come a long way in the last 35 years or so. Originally, we had
    the likes of the 6502, 6809, and Z80 processors. These were known as **single
    processing units**; they could only run a single program at a time and software
    ran in a linear fashion (this meant that performing two tasks at once wasn't possible).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去 35 年左右的时间里，计算机已经取得了长足的进步。最初，我们有 6502、6809 和 Z80 处理器。这些被称为**单处理单元**；它们一次只能运行一个程序，软件以线性方式运行（这意味着同时执行两个任务是不可能的）。
- en: Processors moved on, and from the single processing units (single-core), we
    moved on to processors that contained multiple processing units (multi-core).
    Programming languages evolved to allow for this form of processor, and running
    multiple operations (threads) at the same time became a reality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器不断发展，我们从单个处理单元（单核）过渡到了包含多个处理单元的处理器（多核）。编程语言也进化以支持这种处理器，同时运行多个操作（线程）成为现实。
- en: Rust, being a very modern language, also has this ability to multiprocess. All
    of the benefits are available that you would expect from Rust (such as memory
    safety and avoiding race conditions), but there are some other things that you
    need to be aware of.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 作为一种非常现代的语言，也具有多处理的能力。所有你期望从 Rust 中获得的好处（例如内存安全和避免竞态条件）都可用，但还有一些其他的事情你需要注意。
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Understand the mechanisms by which Rust performs concurrent processes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Rust 执行并发过程的方式
- en: Learn how to use threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用线程
- en: See the difference between different threading models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看不同线程模型之间的区别
- en: A bit of a story
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点故事
- en: The Mystery Mobile was heading down a very dark road. There was no way of knowing
    what was ahead. At a certain point, they came to a point in the road with three
    roads coming off. Each road had a sign on them saying *Exit*. Being the intrepid
    type, Freddie sent Velma down one road, Shaggy and Scooby down the second and
    Daphne down the third. Being the brave sort, Freddie would drive down the road.
    They did know, though, that the roads would feed back into the main road at some
    point.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 神秘移动设备正走在一条非常黑暗的道路上。无法知道前方是什么。在某个时刻，他们来到了一个道路交叉口，有三条道路从这里分叉。每条道路上都有一个写着*出口*的标志。作为勇敢的类型，弗雷迪让维拉走了一条路，夏吉和史酷比走第二条，达芬妮走第三条。作为勇敢的人，弗雷迪会开车走这条路。他们知道，尽管如此，这些道路最终会回到主路上。
- en: They agreed that whoever reached the exit first would send a message to the
    others. They synchronized their watches and moved off, not knowing who would reach
    the exit first or even if the exit could be reached at all.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 他们同意，第一个到达出口的人会给其他人发消息。他们同步了手表，然后出发，不知道谁会第一个到达出口，甚至不知道是否能够到达出口。
- en: What was that all about?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那一切都是关于什么的？
- en: In roughly two paragraphs, I've illustrated three very important aspects of
    concurrency in Rust: Send (shown in the message being sent to the others from
    the Mystery Mobile), Sync, and Threads (each road donates a thread, and really,
    there is no real way to know when a thread will rejoin the sender, which can cause
    no ends of problems!).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大概在两段文字中，我阐述了 Rust 中并发性的三个非常重要的方面：Send（如神秘移动设备向其他人发送的消息所示）、Sync 和线程（每条道路都贡献一个线程，实际上，我们根本无法知道线程何时会重新连接到发送者，这可能会引起无数问题！）。
- en: Let's deal with each aspect in turn.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一处理每个方面。
- en: Send
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Send
- en: Send transfers the type safely to another thread—in other words, if type `T`
    implements Send, then it means `T` has been passed safely to another thread.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Send 将类型安全地传输到另一个线程——换句话说，如果类型 `T` 实现了 Send，那么这意味着 `T` 已经被安全地传递到另一个线程。
- en: 'There are a couple of caveats on using Send:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Send 有一些注意事项：
- en: You don't use it for a process that is not thread safe (such as FFI)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会用它来处理非线程安全的进程（例如 FFI）
- en: Send has to be implemented for the type
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Send 必须为该类型实现
- en: Sync
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sync
- en: Sync is considered the uber-safe option. When `T` implements Sync, there is
    a guarantee of memory safety. However, before we go any further, we need to consider
    the following question.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Sync 被认为是超级安全的选项。当 `T` 实现了 Sync，就有内存安全的保证。然而，在我们继续之前，我们需要考虑以下问题。
- en: When is an immutable variable not an immutable variable?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时一个不可变变量不再是不可变的？
- en: Up to this point, we have considered variables to be either mutable or immutable,
    and that's it. However, this is not the case.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直认为变量要么是可变的，要么是不可变的，就是这样。然而，事实并非如此。
- en: 'Consider the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What does this actually mean? First, we create a mutable binding to `a` that
    initially contains the value `10`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着什么？首先，我们创建一个对 `a` 的可变绑定，最初包含值 `10`。
- en: Next, we create an immutable binding to `b` that contains a reference to the
    mutable value of `a`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个不可变的绑定到 `b`，它包含对 `a` 的可变值的引用。
- en: And it's obviously mutable, it has mut in the definition
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它显然是可变的，定义中有 `mut`
- en: 'Let''s consider a different example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个不同的例子：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example is not what it seems. When the clone trait is called, `vc` has
    to update its reference count. The problem is, `vc` is not mutable, yet this code
    compiles and runs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不是表面上看起来那样。当调用克隆特质时，`vc` 必须更新其引用计数。问题是，`vc` 不是可变的，但这段代码可以编译并运行。
- en: 'To understand how, we have to know how the borrowing system works (for more
    information on borrowing, please refer to [Chapter 8](part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d),
    *The Rust Application Lifetime*) in this instance. Borrowing has two very clear
    modes of operation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这一点，我们必须知道借用系统是如何工作的（有关借用的更多信息，请参阅本实例中的[第8章](part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d)，*Rust
    应用程序生命周期*)。借用有两种非常明确的操作模式：
- en: One (or more) references to the resource
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对资源的单一（或多个）引用
- en: Exactly one mutable reference
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确一个可变引用
- en: Really, then, when we talk about immutability, we're not really talking about
    whether a variable is fixed, but whether it is safe to have more than one reference
    to the variable. In the preceding case, the mutation occurs within the vector
    structure and we have the `&T` from there.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 真正地，当我们谈论不可变性时，我们并不是真的在谈论一个变量是否固定，而是在谈论是否安全地拥有该变量的多个引用。在前面的例子中，可变发生在向量结构中，我们从中得到
    `&T`。
- en: As the vector structure is not user facing, it is called as **exterior mutable**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量结构不是面向用户的，它被称为**外部可变**。
- en: Interior mutability
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部可变性
- en: 'The opposite (interior mutability) can be found in this example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相反（内部可变性）可以在本例中找到：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `RefCell` gives the `&mut` when `borrow_mut()` is called. It works well,
    but will cause a panic if a second `borrow_mut()` is called on `x`; you are only
    allowed a single reference to a mutable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`RefCell` 在调用 `borrow_mut()` 时提供 `&mut`。它工作得很好，但如果在 `x` 上再次调用 `borrow_mut()`，将会引发恐慌；你只能有一个可变引用。
- en: Back to sync
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到 `sync`
- en: For sync to occur, we cannot have any type that uses interior mutability (which
    also includes some of the primitive types).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同步，我们不能有任何使用内部可变性的类型（这还包括一些原始类型）。
- en: 'When it comes to sharing across threads, Rust uses `Arc<T>`. This is a wrapper
    type that implements `send` and `sync` if the following condition is met: `T`
    must implement both `send` and `sync`. `RefCell` uses interior mutability, so
    `Arc<RefCell<T>>` won''t implement `sync`, which also means `send` can''t be used—therefore
    `RefCell` can''t be passed around threads.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到线程间的共享时，Rust 使用 `Arc<T>`。这是一个包装类型，如果满足以下条件，则实现 `send` 和 `sync`：`T` 必须同时实现
    `send` 和 `sync`。`RefCell` 使用内部可变性，所以 `Arc<RefCell<T>>` 不会实现 `sync`，这也意味着不能使用 `send`——因此
    `RefCell` 不能在线程间传递。
- en: Using `send` and `sync` provides the strong guarantees of safety Rust relies
    upon to ensure the code is rock solid when using a threading system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `send` 和 `sync` 提供了 Rust 依赖以确保代码在使用线程系统时坚如磐石的安全保证。
- en: A beginner's guide to threading in Rust
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 线程入门指南
- en: 'Threads allow multiple processes to execute at the same time. The following
    is a very simple example of a threaded program:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 线程允许多个进程同时执行。以下是一个非常简单的线程程序示例：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Code files can be found in `Chapter11/SimpleThreadExample`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码文件可以在 `Chapter11/SimpleThreadExample` 中找到。
- en: 'When compiled, you may expect the `println!` to show. However, what you get
    is this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译时，你可能期望看到 `println!` 输出。然而，你得到的是这个：
- en: '![](img/00088.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: Figure 1
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: Why is the `println!` not showing?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `println!` 没有显示？
- en: An easy approach to thinking about how threads work.
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考线程工作方式的一个简单方法。
- en: 'Threads are more easily thought of graphically (at least I think so). We start
    with our main thread:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 线程更容易用图形方式思考（至少我认为是这样）。我们从主线程开始：
- en: '![](img/00089.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: Figure 2
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: The main thread goes from the start of the application to the end of the application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程从应用程序的开始到结束。
- en: At any point on our main thread, we can create a new thread (or new threads,
    if required).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程的任何点上，我们都可以创建一个新的线程（或如果需要，创建多个线程）。
- en: '![](img/00090.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: Figure 3
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: 'These two new threads can do anything the application needs them to do. There
    is a simple rule though: The threads can only last as long the application does.
    As *Figure 3* shows, the threads start and carry on their merry way; there is
    nothing to say the thread has to rejoin the main thread, nor is there any rule
    to say at what point the thread returns (which can cause some very large thread
    safety issues, leading to panics).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新线程可以执行应用程序需要的任何操作。但是有一个简单的规则：线程只能持续到应用程序结束。正如*图3*所示，线程开始并继续它们愉快的旅程；没有任何规定说线程必须重新连接到主线程，也没有任何规则说明线程何时返回（这可能导致一些非常大的线程安全问题，导致恐慌）。
- en: 'It goes without saying that each thread can also spawn their own threads to
    perform sub-processes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，每个线程也可以生成它们自己的线程来执行子进程：
- en: '![](img/00091.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00091.jpeg)'
- en: Figure 4
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图4
- en: If you're accustomed to threading in the likes of C, C++, and C#, you'll already
    know that a thread can return to the main thread at any time and that this *at
    any time* can be disastrous to the safe running of the application. It is different
    in Rust.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了C、C++和C#中的线程，你将已经知道线程可以在任何时候返回到主线程，并且这个*任何时候*可能会对应用程序的安全运行造成灾难。在Rust中则不同。
- en: When a thread in Rust is spawned from either the main thread (or any subthread)
    a handle is created. Rust then uses this token to retrieve the thread at a given
    point; therefore, the issue of a race condition (where one thread returns before
    another, leading to crashes) is essentially removed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当Rust中的线程从主线程（或任何子线程）生成时，会创建一个句柄。然后Rust使用这个令牌在给定点检索线程；因此，竞态条件的问题（其中一个线程在另一个线程之前返回，导致崩溃）基本上被消除了。
- en: Joining threads
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程连接
- en: To retrieve the spawned thread, Rust uses the `join()` trait and then unwraps
    the result.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索生成的线程，Rust使用`join()`特性和然后解包结果。
- en: '![](img/00092.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00092.jpeg)'
- en: Figure 5
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图5
- en: 'To make our small example application output, we therefore need to join the
    spawned thread back to the main thread:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使我们的小型示例应用程序输出，我们需要将生成的线程连接回主线程：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Code for the alterations can be found in `Chapter11/joined_thread`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 修改的代码可以在`Chapter11/joined_thread`中找到。
- en: 'When we run the code, this time we see the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，这次我们看到以下内容：
- en: '![](img/00093.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00093.jpeg)'
- en: Figure 6
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: Hold on. That code isn't the same! This is true, and it is due to the spawn
    accepting a closure (`||`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，那代码并不相同！这是真的，这是由于spawn接受了一个闭包（`||`）。
- en: Closures
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: Closures are a powerful piece of code present in many languages. Essentially,
    a closure wraps code or variables used only within the scope of the current code
    in a neat little package.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是许多语言中存在的一种强大的代码片段。本质上，闭包将当前代码范围内使用的代码或变量封装在一个整洁的小包中。
- en: 'In its simplest form, we can have something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，我们可以有类似以下的内容：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The part within the `| |` defines a variable called `x` that is only used within
    the scope of the calculation, and it is of type `i32`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`| |`内部定义了一个名为`x`的变量，它只在计算的范围内使用，并且其类型为`i32`。'
- en: Okay, that may not seem that useful—after all, what we're doing here is adding
    two numbers together. Hold on though—if `x` is only defined within the scope of
    the calculation, what does `x` actually equal?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这可能看起来并不那么有用——毕竟，我们在这里所做的只是将两个数字相加。但是等等——如果`x`只在计算的范围内定义，那么`x`实际上等于多少呢？
- en: This is where closures come into their own. Typically, when we create a binding,
    we create a binding to something definite. Here, we are creating a binding, but
    binding it to the content of the closure. Anything between the pipes (`| |`) is
    an argument, with the expression being whatever follows the end pipe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是闭包发挥作用的地方。通常，当我们创建一个绑定时，我们创建一个绑定到某个确定的东西。在这里，我们正在创建一个绑定，但是将其绑定到闭包的内容。管道`|
    |`之间的是参数，表达式是管道结束之后的内容。
- en: 'If you think about it, you''ve actually created something closer to the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这么想，你实际上创建的更接近以下内容：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In answer to our question "what does `x` actually equal?", here it is equal
    to the only known parameter, `t`. Therefore, `x + t` is the same as saying `t
    + t`. The add variable isn''t being bound directly (that is, in the same way that
    we bind under normal conditions), but is borrowing the binding. This means that
    we have to apply the same borrowing rules as before. Say that we have the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的问题“`x`实际上等于多少？”答案是它等于唯一的已知参数`t`。因此，`x + t`与说`t + t`相同。添加变量并没有直接绑定（即，与我们正常情况下绑定的方式相同），而是借用绑定。这意味着我们必须应用之前的相同借用规则。比如说我们有以下内容：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will give the following error:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下错误：
- en: '![](img/00094.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00094.jpeg)'
- en: Figure 7
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图7
- en: You will find an example of this error in `Chapter 11/close_mut_error`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`第11章/close_mut_error`中找到一个这个错误的例子。
- en: 'The important part of the throwback is that we''re trying to borrow something
    that is being borrowed in an immutable line. We can fix this by changing the scope
    of the closure, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 抛回的重要部分是我们试图借用在不可变行中被借用的东西。我们可以通过改变闭包的作用域来修复这个问题，如下所示：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will result in the error going.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致错误发生。
- en: With that in mind, we can start to expand on this. If the value between the
    pipes is the argument, then we can clearly do some interesting things with closures
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以开始扩展这个概念。如果管道之间的值是参数，那么我们可以清楚地用闭包做一些有趣的事情
- en: The code for this part can be found in `Chapter11/closures`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分代码可在`第11章/closures`中找到。
- en: 'Take this code, for example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以此代码为例：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Rather than create a whole new function, we use the closure and create the function
    inline with `result` and `x` only existing within the scope of the enclosure `{
    }`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建一个全新的函数，我们使用闭包并在`{}`的作用域内内联创建函数，只存在`result`和`x`。
- en: 'A closure without any arguments is the inline equivalent of the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何参数的闭包是以下内容的内联等价物：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Closures aren't all they first appear to be
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包并不像它们最初看起来那样简单
- en: Closures are known as **syntax sugar** (they effectively sweeten the bitterness
    of whatever they coat) for the underpinning trait they cover. This makes closures
    in Rust different to closures in other languages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包被称为**语法糖**（它们有效地为它们覆盖的基础特性增添了甜味）。这使得Rust中的闭包与其他语言中的闭包不同。
- en: Given this premise, we can also use closures as arguments, as well as returning
    them from a function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，我们也可以将闭包作为参数使用，以及从函数中返回它们。
- en: Closures as function arguments
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包作为函数参数
- en: 'Consider the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code for this section can be found in `Chapter 11/close_fn_args`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码可在`第11章/close_fn_args`中找到。
- en: 'We call `call_with_three` and pass in the closure as the parameter. The function
    `call_with_three` takes a parameter of type `F`. So far, it''s no different from
    any other function taking a generic value as an argument. However, we''re binding
    `F` to be a function of type `i32`, which returns a value of type `i32`. We have
    created an inline function to be a parameter for a called function! When the code
    is compiled, we get the expected value on screen—13:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`call_with_three`并传递闭包作为参数。函数`call_with_three`接受一个类型为`F`的参数。到目前为止，它与任何其他接受泛型值作为参数的函数没有区别。然而，我们将`F`绑定为一个返回类型为`i32`的函数类型，这使我们创建了一个内联函数作为被调用函数的参数！当代码编译时，我们在屏幕上得到预期的值——13：
- en: '![](img/00095.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00095.jpeg)'
- en: Figure 8
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图8
- en: Closures with explicit lifetimes – a special case
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有显式生命周期的闭包 - 一个特殊情况
- en: 'As we saw back in [Chapter 8](part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d),
    *The Rust Application Lifetime*, there are two main types of scope: global and
    local. A variable that has a local scope goes out of bounds as soon as it is finished
    with, whereas a global scope variable is cleaned up when the application terminates.
    A global scope variable is also given the lifetime marker, `''`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第8章](part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d)“Rust应用程序生命周期”中看到的，存在两种主要的作用域类型：全局和局部。具有局部作用域的变量一旦完成其任务就会超出范围，而全局作用域变量则在应用程序终止时清理。全局作用域变量还赋予生命周期标记，`'`。
- en: Closures also have different scopes. Typically, they will only be for the lifetime
    if they are called in, but they can also be global.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包也有不同的作用域。通常，如果它们在调用时，它们将只有生命周期，但它们也可以是全局的。
- en: 'A "normal" function (as shown previously) would be as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “正常”函数（如之前所示）如下所示：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Conversely, for a lifetime scope, we would have the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，对于生命周期作用域，我们将有以下内容：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, this won't compile. The problem is with the scope.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会编译。问题在于作用域。
- en: In our first example, the scope is purely for the lifetime of the invocation.
    In the second, it's for the lifetime of the function (and that is for the entirety
    of the function), which means that the compiler will see a mutable reference at
    the same lifetime as the immutable reference.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，作用域仅限于调用期间。在第二个例子中，它是函数的生命周期（并且这是整个函数的生命周期），这意味着编译器将看到与不可变引用相同生命周期的可变引用。
- en: 'Although Rust does still allow us to use this, we need to use something called
    a **higher-ranked trait bounds** (in simple terms, it means that, in order of
    importance, this trumps something below it). This works by telling the compiler
    to use the minimum lifetime for the closure to run, which in turn should satisfy
    the borrow-checker. In this case, we use `for<...>`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Rust仍然允许我们这样做，但我们需要使用一个叫做**高阶特质界限**的东西（简单来说，这意味着按照重要性的顺序，这会覆盖下面的东西）。这是通过告诉编译器使用闭包运行的最小生命周期来实现的，这反过来应该会满足借用检查器。在这种情况下，我们使用
    `for<...>`：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Returning a closure
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回一个闭包
- en: As threads within Rust use a return from a closure, it makes sense for us to
    consider that it is entirely possible to return a closure. However, returning
    a closure is not as straightforward as you'd expect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Rust 中的线程使用闭包返回，因此我们考虑返回一个闭包是完全可能的。然而，返回一个闭包并不像你想象的那样简单。
- en: 'Let''s consider a normal function first:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑一个普通函数：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will output the value `10`. It''s not rocket science. Let''s change this
    to a closure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出值 `10`。这并不是什么火箭科学。让我们将其改为闭包：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code for the example can be found in `Chapter 11/return_closure_one`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在 `第 11 章/return_closure_one` 中找到。
- en: 'When we run this, though, we don''t get the expected answer of `10`—instead
    we get this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们运行这个程序时，我们并没有得到预期的 `10` 答案——相反，我们得到这个：
- en: '![](img/00096.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00096.jpeg)'
- en: Figure 9
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9
- en: 'So what has gone wrong? When we return from a function, we have to tell the
    compiler the type we''re returning. However, `Fn` is a trait, so we have to somehow
    satisfy this requirement. We could always have it return a reference:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，出了什么问题？当我们从函数返回时，我们必须告诉编译器我们返回的类型。然而，`Fn` 是一个特质，所以我们必须以某种方式满足这个要求。我们总是可以使其返回一个引用：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will generate another compiler error as it needs a lifetime expectancy
    applied.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成另一个编译器错误，因为它需要应用生命周期期望。
- en: 'We could always make the function return a lifetime static reference:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以让函数返回一个生命周期静态引用：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, this will produce a different error, which may look somewhat confusing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将产生一个不同的错误，可能看起来有些令人困惑：
- en: '![](img/00097.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00097.jpeg)'
- en: Figure 10
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10
- en: Why are the types mismatched? It's expecting an `i32`, but has found a closure.
    Makes sense really, but why is this happening?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么类型不匹配？它期望一个 `i32` 类型，但发现了一个闭包。这确实很有道理，但为什么会发生这种情况？
- en: This is down to how Rust works. For a closure, it generates its own struct and
    implementation of `Fn` (and anything else required) therefore, we're dealing not
    with a literal, but something else.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Rust 的工作方式。对于一个闭包，它会生成自己的结构体和 `Fn`（以及任何其他所需的内容）的实现，因此，我们处理的不只是一个字面量，而是其他东西。
- en: 'Trying to return a trait object (such as `Box`) won''t work either as the function
    relies on the `num` binding (which is stack allocated). However, if we move from
    the stack to the heap, we can now return the closure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试返回一个特质对象（如 `Box`）也不会工作，因为函数依赖于 `num` 绑定（它是栈分配的）。但是，如果我们从栈移动到堆，我们现在可以返回闭包：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The source for this can be found in `Chapter 11/return_closure_three`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的源代码可以在 `第 11 章/return_closure_three` 中找到。
- en: 'This will now compile and give the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码可以编译，并给出以下结果：
- en: '![](img/00098.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00098.jpeg)'
- en: Figure 11
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11
- en: What is the move parameter?
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动参数是什么？
- en: 'The `move` parameter forces the closure to take ownership of whatever is contained
    within. Let''s look at that a bit closer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 参数强制闭包获取其内部包含的所有内容的所有权。让我们更仔细地看看这一点：'
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `myMove` takes ownership of `myNum`. The value of `myNum` implements `Copy`,
    which is assigned to the binding. This is the same as the operation of any variable,
    so there has to be something to differentiate `move` from anything else.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`myMove` 获取 `myNum` 的所有权。`myNum` 的值实现了 `Copy`，它被分配给绑定。这和任何变量的操作是一样的，所以必须有某种东西来区分
    `move` 和其他任何东西。
- en: 'Let''s look at a slightly different example and see if we can see what is actually
    going on:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个稍微不同的例子，看看我们是否能看到实际发生的事情：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ve seen this before, so it should not be too hard to understand. This would
    give the answer `7`. If we used `move`, however, the answer may not be as expected:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过这个，所以应该不难理解。这将给出答案 `7`。然而，如果我们使用 `move`，答案可能并不像预期的那样：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code for this example is in `Chapter 11/move_closure_one`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的代码在 `第 11 章/move_closure_one` 中。
- en: 'When compiled, you may expect the answer `7`, but instead you get:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译时，你可能期望得到 `7` 的答案，但结果却是：
- en: '![](img/00099.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00099.jpeg)'
- en: Figure 12
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12
- en: How can we have a value of `10`?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得到一个值为 `10` 的值？
- en: In the nonmove version, we borrow the value of the mutable. With `move`, we
    take ownership of a copy. In practical terms, we have created a completely new
    stack frame for the closure. The `sub_num()` call is still being executed, but
    when it is called, the value returned is not the expected one, but the ownership
    of the copy of the original value (`10`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在非移动版本中，我们借用可变值的值。使用`move`，我们接管一个副本的所有权。从实际的角度来看，我们为闭包创建了一个全新的栈帧。`sub_num()`调用仍在执行，但当它被调用时，返回的值不是预期的值，而是原始值副本的所有权（`10`）。
- en: Back to threading
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到线程
- en: Now we have seen how closures work and their importance, we can continue with
    threading.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了闭包是如何工作的以及它们的重要性，我们可以继续讨论线程。
- en: 'If we consider *Figure 5*, we can use a closure to return a value from one
    of the subthreads:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑*图5*，我们可以使用闭包从子线程中返回一个值：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Will this work as is? Unfortunately not. We are borrowing `x`, which we can''t
    do because of ownership problems. However, we could add `move` to the invocation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这会按原样工作吗？不幸的是，不会。我们正在借用`x`，由于所有权问题，我们无法这样做。然而，我们可以在调用中添加`move`：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The thread will take ownership of the copy of `x` rather than borrow the value.
    By taking ownership, Rust prevents a common issue with any form of threading:
    race conditions. If you recall, from the start of this chapter I said that conventional
    threading has no guarantees of when a thread will return, which can cause all
    sorts of issues. Typically, other languages use mutexes to try and prevent the
    race condition (`mutex` stands for mutual exclusion, which should give an idea
    as to how they work). By taking ownership, Rust does a lot to prevent racing.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 线程将接管`x`的副本的所有权，而不是借用其值。通过接管所有权，Rust防止了任何形式线程的常见问题：竞态条件。如果你还记得，从本章开始我就说过，传统线程没有保证线程何时返回的保证，这可能会引起各种问题。通常，其他语言使用互斥锁（`mutex`代表互斥排他，这应该能给你一些它们是如何工作的想法）来尝试防止竞态条件。通过接管所有权，Rust做了很多防止竞态的事情。
- en: Ownership has its advantages
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权有其优势
- en: With the Rust ownership system, we can largely negate what many other languages
    have issues with, that of shared mutable states. Developers in other languages
    would usually rather chew off their legs than have to deal with a shared mutable
    state; they're inherently problematic—how can you share a mutable and not have
    problems with the return of the thread?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust的所有权系统中，我们可以很大程度上消除许多其他语言存在的问题，即共享可变状态。其他语言的开发者通常宁愿咬掉自己的腿也不愿处理共享可变状态；它们固有问题——你怎么能共享一个可变值而不产生线程返回的问题呢？
- en: Rust doesn't have this issue, as the shared part is sorted with the ownership
    system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Rust没有这个问题，因为共享部分是通过所有权系统排序的。
- en: The reference counter
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用计数器
- en: 'Consider the following piece of code. It won''t work because there are multiple
    owners of the `vec`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段。它不会工作，因为`vec`有多个所有者：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There has to be a way to get this compile, and there is. Rust provides us with
    a reference counter called `Rc`. The reference count has to have a type associated
    with it, and so it is commonly quoted as `Rc<T>`. This can be used to keep track
    of each reference. Every time we execute a clone on the execution, the reference
    count is incremented (and a new owned reference created), so the compiler always
    knows when something is returned.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 必须有一种方法可以使这个编译通过，而且确实有。Rust为我们提供了一个名为`Rc`的引用计数器。引用计数必须与一个类型相关联，因此它通常被引用为`Rc<T>`。这可以用来跟踪每个引用。每次我们在执行中克隆时，引用计数都会增加（并创建一个新的所有者引用），因此编译器总是知道何时有东西被返回。
- en: The only problem with using `Rc<T>` is that it doesn't implement send. Therefore,
    we use `Arc<T>` (the `A` stands for atomic—it is Rust's own reference count and
    can be accessed across threads).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Rc<T>`的唯一问题是它没有实现`send`。因此，我们使用`Arc<T>`（`A`代表原子——这是Rust自己的引用计数，可以在线程间访问）。
- en: '`Arc<T>`, though, has its own problem: by default, the contents are immutable.
    You can share data with `Arc<T>`, but *shared* mutable values—that''s a different
    matter. Mutable shared values give rise to race conditions and that is what we
    are most certainly not after.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Arc<T>`也有它自己的问题：默认情况下，内容是不可变的。你可以用`Arc<T>`共享数据，但*共享*可变值则是另一回事。可变共享值会导致竞态条件，而这正是我们最不想看到的。
- en: There are alternatives to `Arc<T>` (namely `RefCell<T>` and `Cell<T>`, but neither
    of these implement sync, and so they can't be used with threading).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arc<T>`有替代方案（即`RefCell<T>`和`Cell<T>`，但这两个都没有实现`sync`，因此不能用于线程）。'
- en: Problem solved – use Mutex
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题解决——使用Mutex
- en: 'Rust provides us with `Mutex<T>`. This works in much the same way as other
    languages by locking the thread. We implement `mutex` in our code like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Rust为我们提供了`Mutex<T>`。它与其他语言中的工作方式非常相似，通过锁定线程。我们在代码中实现`mutex`的方式如下：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code for this example is in `Chapter 11/mutex`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的代码位于`Chapter 11/mutex`。
- en: By using `lock`, we only allow a single thread to have access to that data at
    any one time (it has mutual exclusion). No other thread has access to that value,
    and if any other thread tries to access the value, it has to wait until the lock
    is released. When data goes out of scope (when `i` is incremented), the lock is
    released.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`lock`，我们只允许在任何时候只有一个线程访问该数据（它具有互斥性）。其他任何线程都无法访问该值，如果任何其他线程尝试访问该值，它必须等待锁被释放。当数据超出作用域（当`i`增加时），锁将被释放。
- en: Why do we put the thread to sleep?
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么要让线程休眠？
- en: Usually, the use of `thread::sleep` allows the execution to pause for a finite
    amount of time as an extra protection against racing. This is not always a good
    plan as there isn't any real way to tell how long a thread is going to take, so
    it's at best a guess. As with all guesses, they can be wildly inaccurate (it is
    used here as we're not doing anything with the data value).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用`thread::sleep`可以让执行暂停一段时间，作为防止竞态条件的额外保护措施。但这并不总是一个好的计划，因为没有真正的方法可以知道一个线程将花费多长时间，所以这最多只是一个猜测。就像所有的猜测一样，它们可能会非常不准确（在这里使用它是因为我们并没有对数据值做任何事情）。
- en: In real systems, the preferred method, to ensure that the correct amount of
    time is given to ensure that everything has worked is to synchronize the threads
    using channels.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际系统中，为了确保给予正确的时间以确保一切正常工作，通常的方法是使用通道同步线程。
- en: Thread synchronization
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程同步
- en: 'The best way to think of a channel is to see it as a walkie-talkie. At one
    end you have the transmitter (send) and at the other end, the receiver:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方式是将通道视为一个对讲机。一端是发射器（发送），另一端是接收器：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code for this example is in `Chapter 11/channels`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的代码位于`Chapter 11/channels`。
- en: 'When we run this, we get the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们会得到以下结果：
- en: '![](img/00100.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00100.jpeg)'
- en: Figure 13
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图13
- en: Thread panics
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程panic
- en: 'As with anything in Rust (and pretty much any language), things can go wrong
    and the application will throw a panic. As with any other time a panic occurs,
    we can use panic! to catch the panic and then test the result to see if the thread
    did indeed panic. We do this using a construct such as:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Rust（以及几乎所有其他语言）中的任何事物一样，事情可能会出错，应用程序会抛出panic。就像任何其他panic发生时一样，我们可以使用panic!来捕获panic，然后测试结果以查看线程是否确实panic了。我们使用如下构造：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `join()` will return `Result<T,E>`, which can then be checked to see if
    there is an exception.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`将返回`Result<T,E>`，然后可以检查是否有异常。'
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen in this chapter how Rust deals with threading within an application.
    Be under no illusion of the power threading has and the inherent issues it gives
    rise to. However, when used correctly, threading can greatly improve the performance
    of your application. Think of a web browser if you need further proof; imagine
    the speed of one if everything was performed on a single thread—a simple page
    could take over a minute to render!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了Rust如何处理应用程序内的线程。不要对线程的力量及其固有的问题抱有任何幻想。然而，当正确使用时，线程可以大大提高应用程序的性能。如果你需要进一步的证据，想想网络浏览器；想象一下如果所有操作都在单个线程上执行，一个简单的页面可能需要超过一分钟才能渲染！
- en: We have also looked at closures and the power behind them. Put the two together
    and you can appreciate how powerful threading and inline functions can be.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了闭包及其背后的力量。将两者结合起来，你可以欣赏到线程和内联函数是多么强大。
- en: We're taking a break in the next chapter to access how your Rust skills are
    progressing with another project task that will build upon the ones performed
    in [Chapter 6](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d), *Creating
    Your Own Rust Applications*. After that, we'll be concluding the book with a look
    at the standard libraries and using external libraries to further improve your
    Rust applications by interfacing with them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中暂停一下，通过另一个项目任务来检查你的Rust技能的进步，该任务将建立在[第6章](part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d)中执行的任务之上，即*创建你自己的Rust应用程序*。在那之后，我们将通过查看标准库和使用外部库来结束本书，通过它们与Rust应用程序的接口进一步改进你的Rust应用程序。
