- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Accepting TCP Traffic with Tokio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tokio 接受 TCP 流量
- en: In the previous chapter, we managed to get actors running in different threads
    to send messages to each other. While it is exciting to code the building blocks
    for async programming, we left that chapter with a not-very-practical application.
    In this chapter, we will be creating a server with Tokio that listens to **TCP**
    traffic on a port. If messages are sent, our TCP server will process the incoming
    data, perform operations through a series of actors and threads, and then return
    the updated data to the client.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们成功地在不同的线程中运行演员以相互发送消息。虽然编写异步编程的构建块令人兴奋，但我们留下了那个不太实用的应用。在本章中，我们将创建一个使用
    Tokio 的服务器，该服务器监听端口上的 **TCP** 流量。如果发送了消息，我们的 TCP 服务器将处理传入的数据，通过一系列演员和线程执行操作，然后将更新后的数据返回给客户端。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Exploring TCP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 TCP
- en: Accepting TCP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 TCP
- en: Processing bytes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理字节
- en: Passing TCP to an actor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 TCP 传递给演员
- en: Keeping track of orders with actors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用演员跟踪订单
- en: Chaining communication between actors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接演员之间的通信
- en: Responding with TCP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TCP 进行响应
- en: Sending different commands via the client
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过客户端发送不同的命令
- en: By the end of this chapter, you will understand how to use TCP and how to package
    and unpack data sent via TCP with bytes. With this knowledge, you will be able
    to create a server using Tokio to listen to incoming messages, process those messages,
    and then perform units of computation based on the incoming message through a
    series of threads and actors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何使用 TCP，以及如何使用字节打包和解包通过 TCP 发送的数据。有了这些知识，您将能够创建一个使用 Tokio 来监听传入消息的服务器，处理这些消息，然后通过一系列线程和演员根据传入的消息执行计算单元。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be building on the code from [*Chapter 14*](B18722_14.xhtml#_idTextAnchor279),
    *Exploring the Tokio Framework*. This can be found at the following URL: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14/working_with_actors](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14/working_with_actors).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于第[*14章*](B18722_14.xhtml#_idTextAnchor279)的代码，*探索 Tokio 框架*进行构建。您可以在以下网址找到它：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14/working_with_actors](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14/working_with_actors)。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter15](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter15).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter15](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter15)找到。
- en: Exploring TCP
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 TCP
- en: '**TCP** stands for **transmission control protocol**. TCP is one of the most
    widely used transfer protocols on the internet. TCP is essentially a protocol
    that transports bytes over a socket from one program or computer to another using
    an **internet protocol** (**IP**). TCP is used for the world wide web, email,
    remote administration, and file transfer. The **transport layer security/secure
    sockets layer** (**TLS/SSL**) protocols are built on top of TCP. This means that
    HTTP and HTTPS are built on top of TCP.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP** 代表 **传输控制协议**。TCP 是互联网上使用最广泛的传输协议之一。TCP 实质上是一种协议，它通过套接字在程序或计算机之间传输字节。TCP
    用于万维网、电子邮件、远程管理和文件传输。**传输层安全性/安全套接字层**（**TLS/SSL**）协议建立在 TCP 之上。这意味着 HTTP 和 HTTPS
    是建立在 TCP 之上的。'
- en: 'TCP is a connection-oriented protocol. This is where a connection between the
    client and server is established before any data is transferred. This is achieved
    by a three-way handshake:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是一种面向连接的协议。这意味着在传输任何数据之前，客户端和服务器之间会建立连接。这是通过三次握手实现的：
- en: '**SYN**: Initially, the client sends a SYN to the server. The SYN is a message
    with a random number to ensure that the same client is communicating with the
    server.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SYN**：最初，客户端向服务器发送一个 SYN。SYN 是一个带有随机数的消息，以确保相同的客户端正在与服务器通信。'
- en: '**SYN-ACK**: The server then responds to the client with the initial sequence
    number and an additional random number known as the ACK.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SYN-ACK**：然后服务器向客户端响应初始序列号和一个额外的随机数，称为 ACK。'
- en: '**ACK**: Finally, the client returns the ACK to the server to establish that
    the connection has been acknowledged.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ACK**：最后，客户端向服务器返回 ACK 以确认连接已被确认。'
- en: '*Steps 1* and *2* establish and acknowledge the sequence number from the client
    and the server. *Steps 2* and *3* establish and acknowledge the sequence number
    from the server to the client:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*和*步骤2*建立并确认客户端和服务器之间的序列号。*步骤2*和*步骤3*建立并确认从服务器到客户端的序列号：'
- en: '![Figure 15.1 – A TCP handshake](img/Figure_15.1_B18722.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – TCP握手](img/Figure_15.1_B18722.jpg)'
- en: Figure 15.1 – A TCP handshake
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – TCP握手
- en: In this chapter, we will be converting the actor model we built in the previous
    chapter so that it accepts TCP traffic from outside of our program as commands.
    First, we need to get our program to accept TCP connections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把上一章构建的actor模型转换为能够接受来自程序外部的TCP流量作为命令。首先，我们需要让我们的程序接受TCP连接。
- en: Accepting TCP
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受TCP
- en: 'Before we write any TCP code, we must acknowledge that our code is at risk
    of becoming bloated due to all the code being in one file. To prevent the `src/main.rs`
    file from becoming bloated, we must copy all the code apart from the main function
    from the `src/main.rs` file into a file called `src/actors.rs`. Now, we can wipe
    our `src/main.rs` file completely and fill it with the following outline:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何TCP代码之前，我们必须承认我们的代码存在因所有代码都在一个文件中而变得臃肿的风险。为了防止`src/main.rs`文件变得臃肿，我们必须将`src/main.rs`文件中除主函数之外的所有代码复制到一个名为`src/actors.rs`的文件中。现在，我们可以完全清除`src/main.rs`文件，并用以下大纲填充它：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we imported a TCP listener to listen to incoming traffic. We also imported
    structs that enable us to perform a sleep function from the `Tokio` crate and
    define our `main` runtime function. In our `main` function, we define our address
    and bind it to a TCP listener. We directly unwrap this because if we fail to bind
    the address, there is no point in continuing with the program. You could handle
    the outcome of binding the address by increasing the port number by 1 until you
    find an open port number, but for this example, we should keep our implementation
    of the server simple. Then, we have a `while` loop that continues to accept new
    connections throughout the lifetime of the program, which can be infinite if the
    program is not interrupted or there is no problem with the socket. Once we get
    a connection, we spawn a new thread and process the incoming message.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了一个TCP监听器来监听传入的流量。我们还导入了`Tokio`crate中的结构体，使我们能够执行睡眠函数并定义我们的`main`运行时函数。在我们的`main`函数中，我们定义了我们的地址并将其绑定到TCP监听器。我们直接解包，因为如果我们无法绑定地址，就没有继续程序的必要。你可以通过增加端口号1直到找到一个开放的端口号来处理地址绑定的结果，但在这个例子中，我们应该保持服务器实现的简单性。然后，我们有一个`while`循环，在整个程序的生命周期内持续接受新的连接，如果程序没有被中断或套接字没有问题，这个循环可以是无限的。一旦我们得到一个连接，我们就创建一个新的线程并处理传入的消息。
- en: 'For now, for our incoming message, we will merely sleep for 5 seconds, as seen
    in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，对于我们的传入消息，我们只需睡眠5秒钟，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we print when the thread is starting and finish printing the time duration
    at the end. The duration should be more than the delay. We also make the thread
    sleep. The printout statements and sleep functionality will enable us to trace
    what is happening when we send multiple messages from different programs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打印线程开始时的时间，并在结束时打印持续时间。持续时间应该超过延迟。我们还让线程睡眠。打印语句和睡眠功能将使我们能够追踪当我们从不同的程序发送多个消息时发生了什么。
- en: 'Now that we have defined our program, which accepts TCP traffic, we can create
    a new Rust cargo project in a different directory for the client, which will send
    messages to the server. In this new project, the `Cargo.toml` file will contain
    the same dependencies as those in the TCP server. Inside the `main.rs` file, we
    have the following simple program:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了接受TCP流量的程序，我们可以在不同的目录中创建一个新的Rust cargo项目作为客户端，该客户端将向服务器发送消息。在这个新项目中，`Cargo.toml`文件将包含与TCP服务器相同的依赖项。在`main.rs`文件中，我们有以下简单的程序：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This program merely makes a connection with the TCP server and then writes
    `hello world` in bytes to the TCP stream. Once the bytes have been written, we
    finish. Now, we can test our server. First, we need to run our server, which will
    give us the following printout:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序仅仅与TCP服务器建立连接，然后将`hello world`以字节形式写入TCP流。一旦字节写入完成，我们就结束了。现在，我们可以测试我们的服务器。首先，我们需要运行我们的服务器，这将给出以下输出：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The terminal should now be hanging, which means we can run our client in a
    different terminal three times in a row as quickly as possible to get three requests
    in before the first thread stops sleeping. This will allow us to see the effect
    the sleeping threads have on our application. Our client printout should look
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 终端现在应该处于挂起状态，这意味着我们可以尽可能快地连续在另一个终端运行我们的客户端三次，以便在第一个线程停止休眠之前获得三个请求。这将使我们能够看到休眠线程对我们应用程序的影响。我们的客户端输出应该如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we wait for 7 seconds, we can inspect our server terminal, which should
    have the following printout:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们等待7秒钟，我们可以检查我们的服务器终端，它应该有以下的输出：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can see that each process has a port on the local host. As expected
    with spawning threads to handle the incoming messages, the messages were handled
    in an async manner. We could handle many more connections if needed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到每个进程在本地主机上都有一个端口。正如预期的那样，通过创建线程来处理传入的消息，消息是以异步方式处理的。如果需要，我们可以处理更多的连接。
- en: Now that we have managed to accept bytes through TCP, we will process these
    bytes in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功通过TCP接收到了字节，我们将在下一节中处理这些字节。
- en: Processing bytes
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字节
- en: Why do we send bytes through the TCP channel as opposed to the string itself?
    We send bytes because they have a standardized way of being encoded and decoded.
    For instance, in this chapter, we are creating a client that is written in Rust.
    However, the client might be written in JavaScript or Python. Primitive data structures
    such as string characters can be encoded into bytes and then decoded when received
    by the TCP server. Because of the UTF-8 standard, we can use these strings anywhere.
    Our data could be saved in a file by one text editor and loaded by another text
    editor because they are both using the same encoding.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们通过TCP通道发送字节而不是字符串本身呢？我们发送字节是因为它们有标准化的编码和解码方式。例如，在本章中，我们创建了一个用Rust编写的客户端。然而，客户端可能是用JavaScript或Python编写的。原始数据结构，如字符串字符，可以编码成字节，然后在TCP服务器接收到时解码。由于UTF-8标准，我们可以在任何地方使用这些字符串。我们的数据可以通过一个文本编辑器保存，并通过另一个文本编辑器加载，因为它们都使用相同的编码。
- en: If we keep exploring the concept of bytes, we will conclude that the only data
    that a computer can store is bytes. MP3, WAV, JPEG, PNG, and so on are all examples
    of encoding. If you save any file, you will encode the data into bytes. If we
    load any file, we will be decoding the data from bytes. Now, let us decode our
    byte string that was sent over TCP.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续探索字节的概念，我们将得出结论，计算机能够存储的唯一数据是字节。MP3、WAV、JPEG、PNG等都是编码的例子。如果你保存任何文件，你将把数据编码成字节。如果我们加载任何文件，我们将从字节中解码数据。现在，让我们解码通过TCP发送的字节字符串。
- en: 'In our `main.rs` file in the TCP server project, we first need to import the
    following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP服务器项目的 `main.rs` 文件中，我们首先需要导入以下内容：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `BufReader` struct essentially adds a buffer to any reader, which improves
    the speed of small frequent reads from the same file or socket. While this greatly
    helps us as we are expecting multiple small messages to be sent down the same
    TCP socket, it will not give us any speed improvement if we are trying to read
    a large stream of data in one go from a file or socket. The other two import traits
    must be imported to enable the `BufReader` struct to read or write.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufReader` 结构体本质上为任何读取器添加了一个缓冲区，这提高了从同一文件或套接字进行的小而频繁读取的速度。虽然这在我们期望通过同一TCP套接字发送多个小消息时非常有帮助，但如果我们要一次性从文件或套接字中读取大量数据，它将不会给我们带来任何速度提升。其他两个导入特性必须导入，才能使
    `BufReader` 结构体能够读取或写入。'
- en: 'Now, we must wipe all code in our thread spawn section of the code to start
    again as we will be doing a range of different processes. First, inside our thread
    spawn code, we must print out that we are starting the thread by splitting our
    stream into a reader and writer, and then creating our buffer reader from the
    reader and an empty vector to store the processed incoming data:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须擦除代码中线程创建部分的全部代码，以便重新开始，因为我们将会进行一系列不同的进程。首先，在我们的线程创建代码内部，我们必须打印出我们正在启动线程，通过将我们的流拆分为读取器和写入器，然后从读取器创建我们的缓冲区读取器，并使用一个空的向量来存储处理后的传入数据：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have everything ready for reading, we can continuously read one
    line at a time, telling the reader to stop reading once it hits the EOF condition,
    `''b\n''`, from our stream:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好读取一切，我们可以逐行连续读取，告诉读者一旦遇到流中的EOF条件（`'b\n'`），就停止读取：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that if there is an error, we will print it out. However, the rest
    of the code that we are concerned with when it comes to processing bytes is in
    our `Ok` code block.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，如果发生错误，我们会将其打印出来。然而，当我们处理字节时，我们关心的其余代码都在我们的`Ok`代码块中。
- en: 'Inside our `Ok` code block, we initially need to check to see if the stream
    has closed by checking if zero bytes are received:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Ok`代码块内部，我们最初需要检查流是否已关闭，方法是检查是否接收到了零字节：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`EOF` stands for *end-of-file*. EOF is the standard way of declaring that we
    have come to the end of the file or that the data stream has finished. Once we
    get past the preceding code block, we know that we have some bytes to process.
    We must convert our incoming bytes into a string using the UTF-8 encoding:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`EOF`代表*文件结束*。EOF是声明我们已到达文件末尾或数据流已结束的标准方式。一旦我们越过前面的代码块，我们就知道我们有一些字节需要处理。我们必须使用UTF-8编码将我们的输入字节转换为字符串：'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The lossy reference in the preceding code is where nonstandard characters are
    replaced with a placeholder, so nonstandard characters are lost in translation.
    This is not going to be an issue for us as we are sending over standard characters.
    With our string data, we are going to separate values in a message with a `;`
    delimiter. We will split our string into a vector of strings, replacing all new
    lines with the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的丢失引用是指非标准字符被替换为占位符，因此非标准字符在翻译中会丢失。由于我们发送的是标准字符，所以这对我们来说不会是问题。在我们的字符串数据中，我们将使用`;`分隔符将消息中的值分开。我们将使用以下代码将字符串拆分为字符串向量，并将所有新行替换掉：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can print out the processed message and then clear the buffer so that
    the line that we are processing does not get caught up in the next processing
    step:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打印出处理过的消息，然后清除缓冲区，这样我们正在处理的行就不会在下一个处理步骤中被捕获：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are now at the end of the loop. Right outside the loop, we must print out
    that the thread is finished with the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在到达了循环的末尾。在循环外部，我们必须使用以下代码打印出线程已完成：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With that, we have finished our server for now as we can process bytes. Now,
    we can go to the `main.rs` file in our client project and write the following
    byte string:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在已经完成了服务器，因为我们能够处理字节。现在，我们可以转到客户端项目的`main.rs`文件，并写入以下字节字符串：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What outcome do you think we will get from this byte string? If we look at
    the byte string, we will see that there is a new line, so we are sending two messages
    in one packet over the TCP connection. Each message has two values due to the
    `;` delimiter. When we spin up our server and run the client, we will get the
    following printout:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为我们会从这个字节字符串中得到什么结果？如果我们查看字节字符串，我们会看到有一个新行，因此我们通过TCP连接发送了一个数据包中的两个消息。由于`;`分隔符，每个消息有两个值。当我们启动服务器并运行客户端时，我们将得到以下输出：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see that our server processed two messages in the same thread before
    we closed the thread. With this, we can see that we have a lot of flexibility
    with TCP sockets. We are now ready to route TCP traffic to our actors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在我们关闭线程之前，我们的服务器在同一线程中处理了两个消息。因此，我们可以看到，我们在TCP套接字方面有很多灵活性。我们现在已经准备好将TCP流量路由到我们的actor。
- en: Passing TCP to an actor
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将TCP传递给actor
- en: 'When it comes to routing TCP data to actors, we need to import our actors and
    channels into the `main.rs` file in our server project with the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将TCP数据路由到actor时，我们需要将我们的actor和channel导入服务器项目中的`main.rs`文件，以下代码如下：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we have to construct our *order book* actor and run it. However, as you
    may recall, we merely ran the *order book* actor at the end of the Tokio runtime.
    However, if we apply this strategy here, we will block the loop from executing,
    so we can listen to incoming traffic. If we run the *order book* actor after the
    loop, the *order book* actor will never run as the loop runs indefinitely in a
    `while` loop and thus blocks the execution of any code following it. In our case,
    there is a further complication. This complication is that the actor run function
    enters a `while` loop, which further explains the need to put this entire code
    in a separate spawned Tokio task. Because of this, we must spawn a thread before
    the loop:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须构建我们的*订单簿*actor并运行它。然而，如您所回忆的，我们只是在Tokio运行时的末尾运行了*订单簿*actor。然而，如果我们在这里应用这种策略，我们将阻塞循环的执行，这样我们就可以监听传入的流量。如果我们将*订单簿*actor在循环之后运行，由于循环在`while`循环中无限期运行，因此会阻塞任何后续代码的执行。在我们的情况下，还有一个更复杂的因素。这个复杂因素是actor运行函数进入了一个`while`循环，这进一步解释了为什么需要将整个代码放在一个单独的spawned
    Tokio任务中。因此，我们必须在循环之前spawn一个线程：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we directly move the `tx` receiver into the Tokio task without cloning
    it because `OrderBookActor` is the only actor taking full exclusive ownership
    of the receiver. Here, we can see that the TCP listener is the same. Then, we
    create the `mpsc` channel, which we use to create and run our *order book* actor
    in the first thread that we spawn. Then, we enter the `while` loop to listen for
    TCP traffic. Note that the clone of the sender of the mpsc channel for the *order
    book* actor is cloned straight away. This is because we are going to have to clone
    it again in the reading loop on every next iteration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们直接将`tx`接收器移动到Tokio任务中而不进行克隆，因为`OrderBookActor`是唯一完全独占拥有接收器的演员。在这里，我们可以看到TCP监听器也是一样的。然后，我们创建`mpsc`通道，我们使用它来在第一个我们创建的线程中创建和运行我们的*订单簿*演员。然后，我们进入`while`循环来监听TCP流量。注意，*订单簿*演员的mpsc通道发送者的克隆立即进行。这是因为我们将在下一次迭代的读取循环中再次克隆它。
- en: 'Inside the `Ok` block in our loop, we process our byte string, create the new
    *buy order* actor, and then send the message to the *order* *book* actor:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中的`Ok`块内，我们处理我们的字节字符串，创建新的*购买订单*演员，然后将消息发送到*订单* *簿*演员：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And this should be it. We can see that the actors that we defined in a standard
    Tokio runtime without listening to traffic can be plugged into our TCP network
    application. There is only one thing left to do, and that is to update the message
    being sent in the client `main.rs` file with the following content:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就应该是全部了。我们可以看到，在标准Tokio运行时中定义的演员，无需监听流量就可以插入到我们的TCP网络应用程序中。只剩下最后一件事要做，那就是更新客户端`main.rs`文件中发送的消息内容：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we are sending two buy orders (`BYND` and `PLTR`). If we run our server
    and then run our client, we will get the following printout for the server:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发送了两个购买订单（`BYND`和`PLTR`）。如果我们运行我们的服务器然后运行我们的客户端，我们将得到以下服务器打印输出：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this printout, we can see that we run our *order book* actor and listen
    to TCP traffic before we process incoming traffic. Then, we accept our packet,
    process the data, and send our data into the actor system. Overall, our application
    flow takes the following form:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个打印输出，我们可以看到我们在处理传入流量之前运行了*订单簿*演员并监听了TCP流量。然后，我们接受我们的数据包，处理数据，并将数据发送到演员系统。总的来说，我们的应用程序流程如下所示：
- en: '![Figure 15.2 – Our TCP application flow](img/Figure_15.2_B18722.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2 – 我们的TCP应用程序流程](img/Figure_15.2_B18722.jpg)'
- en: Figure 15.2 – Our TCP application flow
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 – 我们的TCP应用程序流程
- en: With this, we now have a network application that accepts TCP traffic and passes
    the processed data from the incoming bytes to our actor system. We create *buy
    order* actors on the fly when we accept a new message via TCP, while our *order
    book* actor continues to run throughout the lifetime of our program. If we were
    to add another order book or a different type of actor, we could simply spin off
    another thread where we construct and run the actor. There is no limit to this,
    so our system can scale.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在有一个网络应用程序，它可以接受TCP流量并将处理后的数据从传入的字节传递到我们的演员系统中。当我们通过TCP接受新消息时，我们会即时创建*购买订单*演员，而我们的*订单簿*演员在整个程序的生命周期内持续运行。如果我们想添加另一个订单簿或不同类型的演员，我们只需在另一个线程中构建和运行演员即可。这没有限制，因此我们的系统可以扩展。
- en: Right now, our client does not know what happened. Therefore, our server must
    reply to our client about what happened. However, before we can do this, we must
    keep track of our stock orders so that we can return the state of our orders when
    we need them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的客户端不知道发生了什么。因此，我们的服务器必须向客户端回复发生了什么。然而，在我们能够这样做之前，我们必须跟踪我们的股票订单，以便在需要时返回订单的状态。
- en: Keeping track of orders with actors
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用演员跟踪订单
- en: When it comes to keeping track of our orders, we could simply add a HashMap
    to our order book and add a couple of other messages that can be sent to the *order
    book* actor. This is one approach. We are getting into territory where there are
    no clear correct approaches, and people within the community debate on the best
    approaches to solve problems. In this chapter, we will get used to creating actors
    and managing multiple actors in Tokio by creating two new actors. One actor will
    merely keep track of our stock purchases, while the other actor will send messages
    to the order tracker to get the state of our orders.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到跟踪我们的订单时，我们可以在订单簿中简单地添加一个HashMap，并添加几个可以发送给*订单簿*actor的其他消息。这是一种方法。我们正在进入一个没有明确正确方法的领域，社区内的人们在最佳解决方案上争论。在本章中，我们将通过创建两个新的actor来习惯在Tokio中创建actor和管理多个actor。一个actor将仅跟踪我们的股票购买，而另一个actor将向订单跟踪器发送消息以获取我们订单的状态。
- en: 'First, we need to create a separate file in `src/order_tracker.rs`. In this
    file, we initially need to import what we need to handle the collection of stocks
    and the channels that enable the connections between the actors:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`src/order_tracker.rs`中创建一个单独的文件。在这个文件中，我们最初需要导入处理股票集合和actor之间连接的通道所需的内容：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we need to create the message struct for the messages sent to our tracker
    actor:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要为发送给我们的tracker actor的消息创建消息结构体：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we need to pass in a command. This command is needed because the tracker
    actor can perform multiple actions, such as `BUY` and `GET`. If the command is
    just a `GET`, then we do not need anything else, which is why the rest of the
    fields are optional.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要传递一个命令。这个命令是必需的，因为tracker actor可以执行多个操作，例如`BUY`和`GET`。如果命令只是`GET`，那么我们不需要其他任何东西，这就是为什么其余字段都是可选的。
- en: 'With this message defined, we can build the most basic actor, which merely
    sends a `get` message to the tracker actor and returns the state of our orders:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了此消息后，我们可以构建最基础的actor，它仅仅向tracker actor发送一个`get`消息并返回我们订单的状态：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we can see that no state is held by `GetTrackerActor`. We could just
    make this whole actor a function in another actor. However, as stated, we want
    to get comfortable with managing multiple actors in an async system in this chapter.
    To enable our `GetTrackerActor` to get data, we must create a `send` function
    that will send a `GET` command to the tracker actor and return the state of the
    tracker actor as a string:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`GetTrackerActor`没有保留任何状态。我们完全可以把这个整个actor做成另一个actor中的函数。然而，正如之前所述，我们希望在本章中熟悉在异步系统中管理多个actor。为了使我们的`GetTrackerActor`能够获取数据，我们必须创建一个`send`函数，该函数将发送`GET`命令到tracker
    actor，并将tracker actor的状态作为字符串返回：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This method should be familiar to you now. We created a one-shot channel so
    that the tracker actor could send a message back to the `GetTrackerActor` actor.
    Then, we sent the `GET` message and waited for a response. You may have also noticed
    that we are printing out that the `send` function is firing. We will be peppering
    the code with print statements throughout so that we can track how the `async`
    code runs in the printout and in what order.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该熟悉这个方法了。我们创建了一个单次通道，以便tracker actor可以向`GetTrackerActor` actor发送消息。然后，我们发送了`GET`消息并等待响应。您可能也注意到了，我们在打印出`send`函数正在触发。我们将在代码中穿插打印语句，以便我们可以跟踪`async`代码在打印输出中的运行情况和顺序。
- en: 'We are now at the stage where to need to create our *order tracker* actor.
    We need a HashMap and a channel to receive messages, which we can create with
    the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于需要创建我们的*订单跟踪器*actor的阶段。我们需要一个HashMap和一个接收消息的通道，我们可以用以下代码创建：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This actor is more complex as we need the actor to run to receive messages,
    handle the messages, and send the state of the order, which takes the following
    outline:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个actor更复杂，因为我们需要actor运行以接收消息、处理消息并发送订单状态，其结构如下：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you wish to test your handle on actors, now is a good time to try and implement
    the preceding functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试对actor的处理，现在是尝试实现前面函数的好时机。
- en: 'If you have attempted these functions, they should be implemented similarly
    to what’s shown in the following code, which we are going to cover here. First,
    our constructor takes the following form:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试了这些函数，它们应该类似于以下代码所示，我们将在这里介绍。首先，我们的构造函数如下所示：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This constructor should not be a surprise for anyone. We need a HashMap with
    a string as a key to denote the ticker and a float for the number of stocks we
    own for that ticker. We also accept a channel receiver to receive messages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数对任何人来说都不应该感到惊讶。我们需要一个HashMap，其中字符串作为键来表示股票代码，浮点数表示我们拥有的该股票代码的股票数量。我们还接受一个通道接收器来接收消息。
- en: 'The next process we need to define is how to package our data into a string
    so that we can send it over TCP. We can do this with the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要定义的过程是如何将我们的数据打包成一个字符串，以便我们可以通过TCP发送它。我们可以用以下代码来完成这个任务：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we create a vector that holds our data. Then, we loop through our HashMap,
    which is logging our stock holdings. We can see that we separate the ticker from
    the amount with a `:`, and then we separate the individual stock tickers with
    counts with a `;`. At this point, our response should be something like `"BYND:8;PLTR:9;\n"`,
    which means that we have 8 of BYND and 9 of PLTR. Once we have stored the entire
    state in a vector of strings, we join the vector into one string and then send
    that string over a channel.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个向量来存储我们的数据。然后，我们遍历我们的HashMap，它记录着我们的股票持有情况。我们可以看到，我们用冒号`:`将股票代码和数量分开，然后用分号`;`将单独的股票代码和计数分开。此时，我们的响应应该是类似`"BYND:8;PLTR:9;\n"`的字符串，这意味着我们持有8股BYND和9股PLTR。一旦我们将整个状态存储在一个字符串向量中，我们就将向量连接成一个字符串，然后通过通道发送该字符串。
- en: 'We now have everything we need to handle an incoming message, which can be
    handled with the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了处理传入消息所需的一切，这可以通过以下代码来完成：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we match the command being passed via the incoming message. If a `GET`
    command is passed, we merely return the state with the address to respond to extracted
    from the incoming message. If a `BUY` command is passed, we extract the parameters
    for the purchase order from the message and try and get the ticker from the HashMap.
    If the ticker is not present, we create a new entry. If the ticker is present,
    we merely increase the count of the ticker that we have bought.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们匹配通过传入消息传递的命令。如果传递了一个`GET`命令，我们只需返回带有响应地址的状态，该地址从传入的消息中提取出来。如果传递了一个`BUY`命令，我们从消息中提取购买订单的参数并尝试从HashMap中获取股票代码。如果股票代码不存在，我们创建一个新的条目。如果股票代码存在，我们只需增加我们已购买的股票代码的数量。
- en: 'We have now handled our messages and state. There is only one thing left to
    do and that is to run the actor; this can be achieved with the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经处理了我们的消息和状态。只剩下一件事要做，那就是运行演员；这可以通过以下代码实现：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With this, our tracker actor is fully working, so it is time to stand back
    and look at our system and how we envision it to work, as shown in the following
    diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们的跟踪器演员已经完全工作，现在是时候退后一步，看看我们的系统以及我们设想它如何工作，如下面的图所示：
- en: '![Figure 15.3 – Interactions between actors](img/Figure_15.3_B18722.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3 – 演员之间的交互](img/Figure_15.3_B18722.jpg)'
- en: Figure 15.3 – Interactions between actors
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 演员之间的交互
- en: Here, we can see that there must be an interaction between the *order book*
    actor and the *tracker actor* when a buy order is executed. Therefore, we need
    to refactor our *order book* actor to enable chained communication between multiple
    actors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，当执行购买订单时，*订单簿*演员和*跟踪器演员*之间必须存在交互。因此，我们需要重构我们的*订单簿*演员，以实现多个演员之间的链式通信。
- en: Chaining communication between actors
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接演员之间的通信
- en: 'As we can see in *Figure 15**.2*, our *order book* actor is running and accepting
    orders. The *order book* actor then sends a message to the *tracker* actor, updating
    the state once the `BUY` order is processed. This means that our actor needs to
    manage two channels. To handle two channels, inside the `src/actors.rs` file,
    we need to import the tracker message with the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图15.2*所示，我们的*订单簿*演员正在运行并接受订单。一旦处理完`BUY`订单，*订单簿*演员就会向*跟踪器*演员发送消息，更新状态。这意味着我们的演员需要管理两个通道。为了处理两个通道，在`src/actors.rs`文件中，我们需要用以下代码导入跟踪器消息：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we must hold two channels, resulting in our `OrderBookActor` struct having
    the following fields:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须持有两个通道，这导致我们的`OrderBookActor`结构体具有以下字段：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, the fields are essentially the same, but we are holding onto a sender
    that sends messages to the tracker. We can see how helpful different messages
    are. We know exactly where the message is destined to be. With this extra field,
    we need to slightly change the constructor for `OrderBookActor` with the following
    code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，字段基本上是相同的，但我们保留了一个发送消息到跟踪器的sender。我们可以看到不同的消息是多么有帮助。我们知道消息确切的目的地。有了这个额外字段，我们需要稍微修改`OrderBookActor`的构造函数，使用以下代码：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There is only one other behavior that we must add. Remember that we process
    our incoming messages in the `handle_message` function. Here, we must send a `TrackerMessage`
    to the tracker actor with the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加的唯一其他行为是。记住我们在`handle_message`函数中处理我们的传入消息。在这里，我们必须使用以下代码向跟踪器actor发送一个`TrackerMessage`：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, the logic for deciding whether a buy order is going to be processed
    is the same, but if the buy order is processed, we merely construct a `TrackerMessage`
    and send it to the *tracker* actor.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，决定是否处理买入订单的逻辑是相同的，但如果买入订单被处理，我们只是构建一个`TrackerMessage`并发送到`*tracker*`actor。
- en: Now that our actors have been built and refactored, our actor system will behave
    as shown in *Figure 15**.2*. We can now implement our new actor system so that
    we can respond to the TCP traffic with TCP.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建和重构了actors，我们的actor系统将像*图15**.2*所示那样表现。我们现在可以实施我们的新actor系统，以便我们可以用TCP响应TCP流量。
- en: Responding with TCP
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TCP响应
- en: 'When it comes to responding to TCP, we must implement our actor system in the
    `src/main.rs` file. First, we need to import our new actors with the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到响应TCP时，我们必须在`src/main.rs`文件中实现我们的actor系统。首先，我们需要使用以下代码导入我们的新actors：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we must construct our extra channel in the `main` function with the following
    code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在`main`函数中使用以下代码构建我们的额外通道：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we have a `tracker` channel. With the `tracker` and `main` channels,
    we can spin up two different threads with the *tracker* actor and *order book*
    actor with the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个`tracker`通道。使用`tracker`和`main`通道，我们可以使用以下代码启动两个不同的线程，分别运行`*tracker*`actor和`*订单簿*`actor：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With this, we now have two of our actors running, awaiting incoming messages.
    Now, we must manage our incoming TCP traffic and spin up different actors, depending
    on the command passed in. As a design choice, we are going to have the first string
    passed in via TCP to be the command that our application has:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在有两个actor正在运行，等待传入的消息。现在，我们必须管理我们的传入TCP流量，并根据传入的命令启动不同的actor。作为一个设计选择，我们将通过TCP传入的第一个字符串作为我们的应用程序的命令：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we must match our command with the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须使用以下代码匹配我们的命令：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For our buy order, we still simply spin up the *buy order* actor and send it
    to the *order* *book* actor:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的买入订单，我们仍然简单地启动`*买入订单*`actor并将其发送到`*订单簿*`actor：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The main change here is how we manage the incoming data, and this is because
    we have introduced the `command` parameter. For the `get` command, we create `GetTrackerActor`,
    which sends a message to the tracker actor. Then, we write the state that we got
    from the *tracker* actor with the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要变化是我们如何管理传入的数据，这是因为我们引入了`command`参数。对于`get`命令，我们创建`GetTrackerActor`，向跟踪器actor发送消息。然后，我们使用以下代码写入从`*tracker*`actor获取的状态：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this, our server can now accept different commands and track all the buy
    orders that we have made.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的服务器现在可以接受不同的命令并跟踪我们所有的买入订单。
- en: Even though our server is now fully functional, our client will not work. This
    is because we have not updated our client with the commands. In the next section,
    we will update our client, which can send multiple different commands.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的服务器现在完全功能化，但我们的客户端将不会工作。这是因为我们没有更新我们的客户端以包含命令。在下一节中，我们将更新我们的客户端，使其能够发送多个不同的命令。
- en: Sending different commands via the client
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过客户端发送不同的命令
- en: 'Our client is simple, and it is going to stay simple. First, we must ensure
    our read and write traits are imported as this time, we will be reading a response.
    Our imports in the `src/main.rs` file should look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端很简单，并且将保持简单。首先，我们必须确保我们的读取和写入特性被导入，因为这次我们将读取一个响应。我们的`src/main.rs`文件中的导入应该看起来像这样：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we must write a series of messages to our connection and then read until
    we get a new line:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须向我们的连接写入一系列消息，然后读取，直到我们得到一个新行：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this, we are done. All we must do now is run the server and then run the
    client. The client has the following printout:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经完成了。我们现在必须做的就是运行服务器，然后运行客户端。客户端有以下输出：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we get the state of our stock orders after sending our orders. Even though
    this state is in a single string, we have delimiters so that we can split our
    data up into something useful. Once our client has run, our server will have the
    following printout:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在发送我们的订单后获得了我们的股票订单的状态。尽管这个状态是一个单独的字符串，但我们有分隔符，这样我们就可以将我们的数据分割成有用的东西。一旦我们的客户端运行完毕，我们的服务器将会有以下输出：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is a long printout, but we can see how our order message got converted
    into a vector. We can also see how the state of our tracker changes over time,
    and at the end, we can see how our `get` command is processed with the *get state*
    actor and *tracker* actor.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的输出，但我们可以看到我们的订单消息是如何被转换成向量的。我们还可以看到我们的跟踪器状态是如何随时间变化的，最后，我们可以看到我们的`get`命令是如何与`*get状态*`演员和`*跟踪器*`演员一起处理的。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we managed to bring our Tokio async program to the next level
    by accepting incoming TCP traffic. Then, we processed our TCP traffic, which was
    packaged in bytes, essentially creating a protocol for processing buy orders for
    stocks. We must note that we have a lot of flexibility with this approach. We
    managed to stuff multiple buy orders and then a `get` command into one message.
    We can become creative with our message structure as there is little constraint
    in how to package our message and unpack it in the server if the protocols are
    consistent between the server and the client.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们通过接受传入的TCP流量，将我们的Tokio异步程序提升到了下一个层次。然后，我们处理了我们的TCP流量，这些流量被封装在字节中，实际上创建了一个处理股票买入订单的协议。我们必须注意，我们在这方面有很大的灵活性。我们设法将多个买入订单和一个`get`命令塞进一个消息中。如果我们保持服务器和客户端之间协议的一致性，我们可以在消息结构上变得更有创意，因为包装和服务器中的解包消息的方式几乎没有限制。
- en: Then, we added more threads and actors to our system to handle multiple commands
    passed into our server. We finished up this chapter by updating our client and
    returning the state of our orders. The result is a highly async-safe network application
    that accepts messages via TCP. This network application is not just for running
    on our local computers. We can wrap this TCP Tokio network application in Docker
    and deploy it on a server. You now have the tools to build lower-level network
    applications to aid your web applications. Considering that our distroless Rust
    servers are roughly 50 MB in size, these network applications will be an inexpensive
    aid to whatever problems you are trying to solve.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在系统中添加了更多的线程和演员来处理传递给我们的服务器的多个命令。我们通过更新我们的客户端并返回我们的订单状态来完成这一章。结果是，一个高度异步安全的网络应用程序，通过TCP接受消息。这个网络应用程序不仅可以在我们的本地计算机上运行。我们可以将这个TCP
    Tokio网络应用程序包装在Docker中，并在服务器上部署它。你现在有了构建底层网络应用程序的工具，以帮助你的Web应用程序。考虑到我们的distroless
    Rust服务器大小约为50 MB，这些网络应用程序将是你试图解决的问题的低成本辅助工具。
- en: While having a protocol is useful and gives us more freedom, we will take our
    protocol processing of TCP traffic to the next level in the next chapter with
    framing, enabling us to have even more control over how we process and package
    our messages as they’re being sent via TCP.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拥有协议很有用，并给我们更多的自由度，但我们在下一章中会将TCP流量处理的协议处理提升到下一个层次，通过帧定界，使我们能够对通过TCP发送的消息的处理和包装有更多的控制。
- en: Further reading
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Tokio TCP documentation: [https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html](https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Tokio TCP文档：[https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html](https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html)。
- en: Questions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do we create an actor that accepts messages and sends messages to other
    actors?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何创建一个接受消息并将消息发送给其他演员的演员？
- en: Why do we need to spin our long-running actors up in their own threads?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要在我们的线程中启动长时间运行的演员？
- en: How can we have multiple actors processing the same type of job?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何让多个演员处理相同类型的任务？
- en: Answers
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We create an actor that has a minimum of two fields. These two fields hold the
    sender for the channel of the actor we are sending messages to and the receiver
    of the channel we are receiving messages from. Then, we need a `run` function
    to enable our actor to run awaiting incoming messages.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个具有至少两个字段的演员。这两个字段持有我们发送消息的演员的通道发送者和我们接收消息的通道接收者。然后，我们需要一个`run`函数来使我们的演员能够运行并等待传入的消息。
- en: If we do not create a thread to run our long-running actors, our main runtime
    will be blocked by this actor running. If only one actor is running after the
    server is listening, this is OK; however, if there are multiple actors or a loop
    that is accepting TCP traffic, then we have a problem as the system will essentially
    be gridlocked and our actor system will not work.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不创建一个线程来运行我们的长时间运行actor，我们的主运行时将被这个运行中的actor阻塞。如果服务器监听后只有一个actor在运行，这是可以的；然而，如果有多个actor或一个接受TCP流量的循环，那么我们将遇到问题，因为系统将基本上陷入僵局，我们的actor系统将无法工作。
- en: We can build an actor that essentially acts like a router. It can keep track
    of incoming messages and alternate sending messages to multiple different actors
    who do the same type of job. However, do not do this if multiple actors rely on
    the internal state.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以构建一个本质上像路由器的actor。它可以跟踪传入的消息，并将消息交替发送到多个执行相同类型工作的不同actor。然而，如果多个actor依赖于内部状态，则不要这样做。
