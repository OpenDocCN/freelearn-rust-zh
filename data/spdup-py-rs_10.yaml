- en: '*Chapter 10*: Injecting Rust into a Python Flask App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：将 Rust 注入 Python Flask 应用'
- en: In [*Chapter 9*](B17720_09_Final_SK_ePub.xhtml#_idTextAnchor158), *Structuring
    a Python Flask App for Rust*, we set up a basic Python web application in Flask
    that could be deployed using Docker. In this chapter, we are going to fuse Rust
    into every aspect of that web application. This means polishing our skills of
    defining Rust packages that can be installed using `pip`. With these packages,
    we are going to plug Rust code into our Flask and Celery containers. We are also
    going to directly interact with an existing database using Rust, without having
    to worry about migrations. This is because our Rust package is going to mirror
    the schema of the existing database. We will need a Rust `nightly` version to
    compile our package, so we will also learn how to manage Rust `nightly` when building
    our Flask image. We will also learn how to use Rust packages from private GitHub
    repositories.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 9 章*](B17720_09_Final_SK_ePub.xhtml#_idTextAnchor158) 中，*为 Rust 结构化 Python
    Flask 应用*，我们设置了一个基本的 Python 网络应用程序，该应用程序可以使用 Docker 部署。在本章中，我们将把 Rust 融入该网络应用程序的各个方面。这意味着我们将磨练定义可以安装使用
    `pip` 的 Rust 包的技能。有了这些包，我们将把 Rust 代码插入我们的 Flask 和 Celery 容器中。我们还将直接使用 Rust 与现有的数据库交互，无需担心迁移。这是因为我们的
    Rust 包将镜像现有数据库的模式。我们需要 Rust `nightly` 版本来编译我们的包，因此我们还将学习如何在构建 Flask 镜像时管理 Rust
    `nightly`。我们还将学习如何使用来自私有 GitHub 仓库的 Rust 包。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Fusing Rust into Flask and Celery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Rust 融入 Flask 和 Celery
- en: Deploying Flask and Celery with Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rust 部署 Flask 和 Celery
- en: Deploying with a private GitHub repository
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用私有 GitHub 仓库部署
- en: Fusing Rust with data access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Rust 与数据访问融合
- en: Deploying Rust `nightly` in Flask
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Flask 中部署 Rust `nightly`
- en: Learning about these topics will enable us to use our Rust packages in a Python
    web application so that it can be deployed in Docker. This will bring our Rust
    skills directly in line with the real world, enabling us to speed up Python web
    applications without having to rewrite our entire infrastructure. If you are a
    Python web developer, you will be able to turn up to work after reading this chapter
    and start injecting Rust into web applications to introduce fast, safe code without
    much risk.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些主题将使我们能够在 Python 网络应用程序中使用我们的 Rust 包，以便可以在 Docker 中部署。这将使我们的 Rust 技能直接与实际世界接轨，使我们能够加快
    Python 网络应用程序的速度，而无需重写整个基础设施。如果你是 Python 网络开发者，你将在阅读本章后能够上班并开始将 Rust 注入网络应用程序，以引入快速、安全的代码而风险不大。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的技术要求：
- en: The code and data for this chapter can be found at [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_ten](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_ten).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码和数据可以在 [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_ten](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_ten)
    找到。
- en: 'In this chapter, you will be building a Docker-contained Flask application.
    This is available via the following GitHub repository: [https://github.com/maxwellflitton/fib-flask](https://github.com/maxwellflitton/fib-flask).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，你将构建一个 Docker 容器中的 Flask 应用程序。这可以通过以下 GitHub 仓库获取：[https://github.com/maxwellflitton/fib-flask](https://github.com/maxwellflitton/fib-flask)。
- en: Fusing Rust into Flask and Celery
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Rust 融入 Flask 和 Celery
- en: 'We will fuse Rust into our Flask application by installing our Rust Fibonacci
    calculation library using `pip`. We will then use it in our views and Celery tasks.
    This will speed up our Flask application without us having to make big changes
    to our infrastructure. To achieve this, we will carry out the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 `pip` 安装我们的 Rust 斐波那契计算库来将 Rust 融入我们的 Flask 应用程序。然后我们将在我们的视图和 Celery
    任务中使用它。这将加快我们的 Flask 应用程序，而无需对我们基础设施进行大的改动。为了实现这一点，我们将执行以下步骤：
- en: Define our dependency on the Rust Fibonacci number calculation package.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们对 Rust 斐波那契数计算包的依赖。
- en: Build our calculation module with Rust.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Rust 构建我们的计算模块。
- en: Create a calculation view using Rust in our Flask application.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 Flask 应用程序中使用 Rust 创建一个计算视图。
- en: Insert Rust into our Celery task.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Rust 插入我们的 Celery 任务。
- en: With this, we will have a Flask application that has a speedup due to Rust.
    Let's get started!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们将拥有一个由于 Rust 而加速的 Flask 应用程序。让我们开始吧！
- en: Defining our dependency on the Rust Fibonacci number calculation package
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们对 Rust 斐波那契数计算包的依赖
- en: 'When it comes to our Rust dependency, it would be tempting to just put our
    Rust dependency in our `requirements.txt` file. However, this can become confusing.
    Also, we are using an automated process to update our `requirements.txt` file.
    This runs the risk of wiping our GitHub repositories from the `requirements.txt`
    file. We must remember that our `requirements.txt` file is just a text file. Therefore,
    nothing is stopping us from just adding another text file that lists our GitHub
    repositories and using it to install the GitHub repositories that our application
    is dependent on. To do this, we will populate our `src/git_repos.txt` file with
    the following dependency:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到我们的 Rust 依赖项时，可能会诱使我们直接将 Rust 依赖项放入我们的 `requirements.txt` 文件中。然而，这可能会变得令人困惑。此外，我们正在使用一个自动化的过程来更新我们的
    `requirements.txt` 文件。这可能会使我们的 GitHub 仓库从 `requirements.txt` 文件中被清除。我们必须记住，我们的
    `requirements.txt` 文件只是一个文本文件。因此，没有任何东西阻止我们添加另一个文本文件，列出我们的 GitHub 仓库，并使用它来安装我们的应用程序所依赖的
    GitHub 仓库。为此，我们将使用以下依赖项填充我们的 `src/git_repos.txt` 文件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can install our GitHub repository dependencies with the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令安装我们的 GitHub 仓库依赖项：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will result in our Python system downloading the GitHub repository and
    compiling it in our Python packages. We now know which GitHub repositories are
    powering our application, so we can start using automation tools to update our
    `requirements.txt` file. Now that we have installed our Rust package, we can start
    building a calculation module that will use Rust.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致我们的 Python 系统下载 GitHub 仓库并在我们的 Python 包中编译它。我们现在知道哪些 GitHub 仓库在为我们的应用程序提供动力，因此我们可以开始使用自动化工具来更新我们的
    `requirements.txt` 文件。现在我们已经安装了 Rust 包，我们可以开始构建一个将使用 Rust 的计算模块。
- en: Building our calculation model with Rust
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Rust 构建我们的计算模型
- en: 'Our calculation module will have the following structure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算模块将具有以下结构：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We already have our Python calculation in the `fib_calculation.py` file from
    the previous chapter. However, we are now supporting both Rust and Python implementations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章的 `fib_calculation.py` 文件中有了我们的 Python 计算代码。然而，我们现在支持 Rust 和 Python
    的实现。
- en: 'To do this, we will start by defining an enum in our `enums.py` file with the
    following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先将在我们的 `enums.py` 文件中定义一个枚举，如下所示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this enum, we can keep adding methods. For instance, if we were to develop
    microservices later on and have a separate server for calculating our Fibonacci
    numbers, we can add an API call to our enum and support it in our calculation
    interface. Depending on the configuration file, we can switch between all of them.
    Now that we have defined our enums, we can build our interface in the `src/fib_calcs/__init__.py`
    file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个枚举，我们可以继续添加方法。例如，如果我们稍后开发微服务并有一个单独的服务器来计算我们的斐波那契数，我们可以在枚举中添加一个 API 调用，并在我们的计算接口中支持它。根据配置文件，我们可以在它们之间切换。现在我们已经定义了枚举，我们可以在
    `src/fib_calcs/__init__.py` 文件中构建我们的接口：
- en: 'First of all, we have to import what we need with the following code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使用以下代码导入我们需要的内容：
- en: '[PRE11]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we used the `time` module to time how long a process takes to run. We
    also imported our Python and Rust implementations for our calculations. Finally,
    we imported our enum to map which method we used.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `time` 模块来计时一个过程运行所需的时间。我们还导入了我们的 Python 和 Rust 实现来进行计算。最后，我们导入了我们的枚举来映射我们使用了哪种方法。
- en: 'With all of this, we can start building the time process function in our `src/fib_calcs/__init__.py`
    file with the following code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有这些之后，我们可以在我们的 `src/fib_calcs/__init__.py` 文件中开始构建时间处理函数，如下所示：
- en: '[PRE12]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we took in a calculation function under the `processor` parameter name
    and passed the `input_number` parameter into the function. We also timed this
    process and returned it with the Fibonacci number. Now that we've done this, we
    can build a function that processes an input string and convert that into our
    enum. We will not always pass a string into our interface, but if we can load
    a string signaling what process type we want from a configuration file, this will
    be important.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们接受了一个名为 `processor` 的计算函数参数，并将 `input_number` 参数传递给该函数。我们还计时了这个过程，并返回了斐波那契数。现在我们已经完成了这个，我们可以构建一个函数来处理输入字符串，并将其转换为我们的枚举。我们并不总是将字符串传递给我们的接口，但如果我们可以从配置文件中加载一个表示我们想要哪种处理类型的字符串，这将很重要。
- en: 'Our processing method can be defined with the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码定义我们的处理方法：
- en: '[PRE13]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we can see that our string is stored in the key values of the `_value2member_map_`
    map. If it is not in the keys, then our enum will not support it, and the method
    will throw an error. However, if it exists, we return the enum associated with
    the key value.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们可以看到我们的字符串存储在`_value2member_map_`映射的键值中。如果它不在键中，那么我们的枚举将不支持它，并且方法将抛出错误。然而，如果它存在，我们返回与键值关联的枚举。
- en: 'Now, we can define the two helper functions for our interface with the following
    code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码定义我们的接口的两个辅助函数：
- en: '[PRE14]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, if we pass in a string for our method, we can convert it into an enum.
    If the enum points to Python, we can pass our Python calculation object, along
    with the input number, into our `_time_process` function. Then, we can return
    the Fibonacci number and time taken. If our enum points to Rust, we can perform
    the same operations but with the Rust function. With this approach, we can add
    and take away functionality. For instance, we can switch the timing process with
    another parameter that's pointing to another calculation function that does not
    time the process, resulting in a process that just performs the calculation without
    timing it if we want. However, for this example, we will be using the timing process
    to compare speeds. Now that we have built our interface, we can create our calculation
    view with this interface.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，如果我们传递一个字符串作为我们的方法，我们可以将其转换为枚举。如果枚举指向Python，我们可以将我们的Python计算对象以及输入数字传递到我们的`_time_process`函数中。然后，我们可以返回斐波那契数和所需时间。如果枚举指向Rust，我们可以执行相同的操作，但使用Rust函数。通过这种方法，我们可以添加和移除功能。例如，我们可以用指向另一个不计时过程的计算函数的参数来切换计时过程，如果我们想在不计时的情况下仅执行计算，那么这个过程将不会计时。然而，对于这个例子，我们将使用计时过程来比较速度。现在，我们已经构建了我们的接口，我们可以使用这个接口创建我们的计算视图。
- en: Creating a calculation view using Rust
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Rust创建计算视图
- en: 'We are hosting our view in the `src/app.py` file. First, we will import our
    interface with the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`src/app.py`文件中托管我们的视图。首先，我们将使用以下代码导入我们的接口：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this new interface and enum, we can make changes to our standard calculation
    view with the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新接口和枚举，我们可以通过以下代码对我们的标准计算视图进行修改：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we are using the new interface. Because of this, we can also return the
    time taken to perform the calculation. Now, we can build our Rust calculation
    view. It will take the same form as the standard calculation view, meaning that
    you can refactor it to have the Rust and Python calculation methods in the same
    view based on the parameter that''s passed into the URL. If not, our Rust calculation
    view will take the form of the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用的是新接口。正因为如此，我们还可以返回执行计算所需的时间。现在，我们可以构建我们的Rust计算视图。它将具有与标准计算视图相同的形式，这意味着您可以根据传递到URL的参数重构它，以便在同一个视图中拥有Rust和Python计算方法。如果不这样做，我们的Rust计算视图将采用以下代码的形式：
- en: '[PRE32]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The dots in the aforementioned code show that this is the same code that's used
    in the standard calculation function. Now that our Rust package has been fused
    with our Flask application, we can insert Rust into our Celery task.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的点表明，这是在标准计算函数中使用的相同代码。现在，我们的Rust包已经与我们的Flask应用融合，我们可以将Rust插入到我们的Celery任务中。
- en: Inserting Rust into our Celery task
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Rust插入我们的Celery任务
- en: 'When it comes to our background task in Celery, we do not have to worry about
    the timing. Because of the interface and configuration, we have to import the
    parameters and interface into the `src/task_queue/fib_calc_task.py` file with
    the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到我们的Celery后台任务时，我们不必担心计时。由于接口和配置，我们必须使用以下代码将参数和接口导入到`src/task_queue/fib_calc_task.py`文件中：
- en: '[PRE42]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this, we can now refactor our Celery task with the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们现在可以使用以下代码重构我们的Celery任务：
- en: '[PRE44]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we can see that we get the global parameters. We pass the `CELERY_METHOD`
    global parameter into the `params`. Considering that the parameters are inherited
    from the dictionary class, we can use the built-in `get` method. We can set the
    default calculation method to `rust` if we have not defined `CELERY_METHOD` in
    the configuration file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到我们获取了全局参数。我们将`CELERY_METHOD`全局参数传递到`params`中。考虑到参数是从字典类继承的，我们可以使用内置的`get`方法。如果我们没有在配置文件中定义`CELERY_METHOD`，我们可以将默认计算方法设置为`rust`。
- en: 'The application is now fully integrated, which means we can test our application.
    We must remember to run our development `docker-compose` environment, Flask application,
    and Celery worker. Accessing our two views will give us the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在已完全集成，这意味着我们可以测试我们的应用程序。我们必须记住运行我们的开发 `docker-compose` 环境、Flask 应用程序和
    Celery 工作进程。访问我们的两个视图将给出以下输出：
- en: '![](img/B17720_10_01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17720_10_01.jpg)'
- en: Figure 10.1 – Flask, Python, and Rust requests
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Flask、Python 和 Rust 请求
- en: In the preceding screenshot, we can see that our Rust call is four times faster,
    even though the Rust request number is higher. We now have a working Python application
    that uses Rust to speed up the calculations. However, this is not very useful
    if we cannot deploy it. The internet is full of half-baked tutorials that teach
    you how to do something superficially in a development environment, while not
    being able to use or configure it in a production environment. In the next section,
    we will configure our Docker environment so that we can deploy our application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到我们的 Rust 调用速度提高了四倍，尽管 Rust 请求的数量更高。现在我们有一个使用 Rust 加速计算的运行中的
    Python 应用程序。然而，如果我们不能部署它，这并不很有用。互联网上充满了半成品教程，它们教你如何在开发环境中表面地做某事，而在生产环境中却无法使用或配置它。在下一节中，我们将配置我们的
    Docker 环境，以便我们可以部署我们的应用程序。
- en: Deploying Flask and Celery with Rust
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 部署 Flask 和 Celery
- en: 'For our Flask application''s Docker image to support our Rust packages, we
    need to make some changes to the `src/Dockerfile` file. Looking at this file,
    we can see that our image is built on `python:3.6.13-stretch`. This is essentially
    a Linux environment with Python installed. When we see this, we realize that we
    can be confident in manipulating our Docker image environment. If we can do this
    in Linux, there is a high chance we can do this in our Docker image. Considering
    this, what we must do in our `src/Dockerfile` file is install Rust and register
    `cargo` with the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的 Flask 应用程序的 Docker 镜像支持 Rust 包，我们需要对 `src/Dockerfile` 文件进行一些修改。查看这个文件，我们可以看到我们的镜像基于
    `python:3.6.13-stretch` 构建。这本质上是一个安装了 Python 的 Linux 环境。当我们看到这一点时，我们意识到我们可以对我们的
    Docker 镜像环境有信心。如果我们能在 Linux 上做到这一点，那么在 Docker 镜像上做到这一点的高概率也很高。考虑到这一点，我们在 `src/Dockerfile`
    文件中必须安装 Rust 并使用以下代码注册 `cargo`：
- en: '[PRE57]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Luckily for us, Rust is very easy to install. Remember that the `apt-get install
    -y python3-dev python-dev gcc` command allows us to use compiled extensions when
    using Python. Now that we''ve done this, we can pull and compile our Rust package
    with the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Rust 非常容易安装。记住，`apt-get install -y python3-dev python-dev gcc` 命令允许我们在使用
    Python 时使用编译扩展。现在我们已经这样做，我们可以使用以下代码拉取和编译我们的 Rust 包：
- en: '[PRE66]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Everything else is the same. Our image is now ready to be built with the following
    command while our terminal is in the root of the `src/` directory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切保持不变。现在我们的图片已经准备好，可以使用以下命令在 `src/` 目录的根目录下构建：
- en: '[PRE72]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This will rebuild our Docker image for our Flask application. Some bits might
    be skipped over in this build. Don''t worry – Docker caches the layers in the
    image build that have not been changed. This is denoted with the following printout:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重建我们的 Flask 应用程序的 Docker 镜像。在构建过程中可能会跳过一些部分。不用担心——Docker 缓存了镜像构建中未更改的层。这用以下打印输出表示：
- en: '[PRE73]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Once a step has been changed, every step following it will be rerun since the
    interrupted step might change the outcome of the steps following it. Note that
    the build might hang when `pip` installs our Rust package. This is because the
    package is being compiled. You may have noticed that we have to do this every
    time we install the Rust package. A more optimal distribution strategy will be
    explored in the next chapter. Now, if we run `docker-compose` in our deployment
    directory, we will see that we can use our Rust Flask container without any problems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦某个步骤被更改，其后的每个步骤都将重新运行，因为中断的步骤可能会改变后续步骤的结果。请注意，当 `pip` 安装我们的 Rust 包时，构建可能会挂起。这是因为包正在编译。你可能已经注意到，我们每次安装
    Rust 包时都必须这样做。在下一章中，我们将探讨更优的发行策略。现在，如果我们在我们部署目录中运行 `docker-compose`，我们将看到我们可以无任何问题地使用我们的
    Rust Flask 容器。
- en: Deploying with a private GitHub repository
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用私有 GitHub 仓库进行部署
- en: 'If you are coding for a side project, company, or paid feature, you will be
    working with private GitHub repositories. This makes sense as we do not want people
    accessing a repository for free that you or your company plans on charging them
    for. However, if we set our Rust Fibonacci package''s GitHub repository to private,
    delete all of our Flask images using the `docker image rm YOUR_IMAGE_ID_HERE`
    command, and run our `docker build . -t flask-fib` command again, we would get
    the following printout:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为一个副项目、公司或付费功能编码，你将需要与私有GitHub仓库合作。这很合理，因为我们不希望人们免费访问你或你的公司打算收费的仓库。然而，如果我们把我们的Rust
    Fibonacci包的GitHub仓库设置为私有，使用`docker image rm YOUR_IMAGE_ID_HERE`命令删除所有我们的Flask镜像，然后再次运行我们的`docker
    build . -t flask-fib`命令，我们会得到以下输出：
- en: '[PRE80]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is because our isolated Linux-based Docker image that is being built is
    not logged into GitHub, even though we are. As a result, the image that''s being
    built could not pull the package from the GitHub repository. We could pass our
    GitHub credentials into the build via arguments, but this will show up in the
    image build layers. Therefore, anyone who has access to our image could look and
    see our GitHub credentials. This is a security hazard. Docker does have some documentation
    on passing in secrets. However, at the time of writing this book, the documentation
    is sparse and convoluted. A more straightforward approach is to clone our `flitton-fib-rs`
    package outside the image and pass it into the Docker image build, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们正在构建的基于Linux的隔离Docker镜像没有登录GitHub，尽管我们已经登录了。因此，正在构建的镜像无法从GitHub仓库中拉取包。我们可以通过参数将我们的GitHub凭据传递到构建过程中，但这将出现在镜像构建层中。因此，任何可以访问我们的镜像的人都可以查看我们的GitHub凭据。这是一个安全隐患。Docker确实有一些关于传递机密的文档。然而，在撰写本书时，文档稀少且复杂。一个更直接的方法是在镜像外部克隆我们的`flitton-fib-rs`包，并将其传递到Docker镜像构建过程中，如下所示：
- en: '![](img/B17720_10_02.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17720_10_02.jpg)'
- en: Figure 10.2 – Private repository image build flow
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 私有仓库镜像构建流程
- en: 'If we are going to use a continuous integration tool such as GitHub Actions
    or Travis, then we can run the process laid out in the preceding diagram with
    GitHub credentials passed in as secrets. GitHub Actions and Travis handle secrets
    with efficiency and simplicity. If we are building it locally, as we are doing
    in this example, then we should already be logged into GitHub as we are directly
    working on the Flask project in this project. To carry out the process laid out
    in the preceding diagram, we must carry out the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用GitHub Actions或Travis这样的持续集成工具，那么我们可以运行前面图表中描述的过程，并将GitHub凭据作为机密传递。GitHub
    Actions和Travis以高效和简单的方式处理机密。如果我们本地构建，就像在这个例子中一样，那么我们应该已经登录GitHub，因为我们在这个项目中直接在Flask项目上工作。为了执行前面图表中描述的过程，我们必须执行以下步骤：
- en: Build a Bash script that orchestrates the process depicted in the preceding
    diagram.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个Bash脚本，以协调前面图表中描述的过程。
- en: Reconfigure our Rust Fib package installment in our Dockerfile.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Dockerfile中重新配置Rust Fib包的安装。
- en: This is the most straightforward approach to using private GitHub repositories
    in our web application builds. We will start by looking at the Bash script.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用私有GitHub仓库进行我们的Web应用程序构建的最直接方法。我们将从查看Bash脚本开始。
- en: Building a Bash script that orchestrates the whole process
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个Bash脚本，以协调整个过程
- en: 'Our script is housed in `src/build_image.sh`. First, we must declare that this
    is a Bash script and that the code should run in the directory of the Flask application.
    To do so, we must change to the directory that contains the script with the following
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本存放在`src/build_image.sh`中。首先，我们必须声明这是一个Bash脚本，代码应该在Flask应用程序的目录中运行。为此，我们必须使用以下代码更改到包含脚本的目录：
- en: '[PRE89]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we have to clone our package and remove our `.git` file from the repository
    with the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须使用以下代码克隆我们的包并从仓库中删除我们的`.git`文件：
- en: '[PRE92]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, our package is just a directory. We are ready to build our Docker image.
    However, if we do so, it might not work because our files might be cached. To
    prevent this from happening, we can run our build with no cache and then remove
    our cloned package after the build with the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的包只是一个目录。我们准备好构建我们的Docker镜像。然而，如果我们这样做，它可能不会工作，因为我们的文件可能被缓存。为了防止这种情况发生，我们可以不带缓存运行我们的构建，然后在构建后使用以下代码删除我们的克隆包：
- en: '[PRE95]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We will have to run this script to run a build of our Flask application. However,
    if we were to run a build now, it would not work as our Dockerfile will still
    be trying to pull the directory from GitHub. To fix this, we will move on to the
    second step.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要运行这个脚本来构建我们的Flask应用程序。然而，如果我们现在就运行构建，它将不会工作，因为我们的Dockerfile仍然会尝试从GitHub拉取目录。为了解决这个问题，我们将继续进行第二步。
- en: Reconfiguring the Rust Fib package installment in our Dockerfile
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的Dockerfile中重新配置Rust Fib包安装
- en: 'In our `src/Dockerfile` file, we must remove the `RUN pip install -r git_repos.txt`
    line as this will stop our image build from trying to pull from the GitHub repository.
    Now, we can `pip` `install` the local directory that has been passed in, and then
    remove it with the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`src/Dockerfile`文件中，我们必须删除`RUN pip install -r git_repos.txt`行，因为这会阻止我们的镜像构建尝试从GitHub仓库中拉取。现在，我们可以使用以下代码`pip
    install`安装已传递的本地目录，然后删除它：
- en: '[PRE97]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, we can build our Flask image by running the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过运行以下命令来构建我们的Flask镜像：
- en: '[PRE99]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This will result in a long printout that will eventually tell us that the image
    was successfully built. Running our deployment `docker-compose` file will confirm
    this. You may want to install our package from a different Git branch. This can
    be done by adding three more lines to our `src/build_image.sh` file, as shown
    here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个长打印输出，最终会告诉我们镜像已成功构建。运行我们的部署`docker-compose`文件将确认这一点。你可能希望从不同的Git分支安装我们的包。这可以通过向我们的`src/build_image.sh`文件中添加三行来完成，如下所示：
- en: '[PRE100]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here, we cloned the repository containing the branch, whose name is based on
    the argument that's passed into the script. Once we've done this, we can remove
    the Git history by removing the `.git` file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们克隆了包含分支的仓库，该分支的名称基于传递给脚本的参数。一旦我们完成这个操作，我们可以通过删除`.git`文件来移除Git历史记录。
- en: Our Rust package is now fully fused with our Python web application in Docker.
    One bonus of installing our Rust package when building an image is that it does
    not have to be compiled every time we use the image.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将Rust包完全融合到我们的Python Web应用程序中，在Docker中。安装我们的Rust包时构建镜像的一个额外好处是，它不需要每次使用镜像时都进行编译。
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can go one step further when it comes to reducing our build, though this
    is optional. You do not have to do this to complete this chapter. Right now, we
    are installing Rust and then compiling our Rust Python package for the Fibonacci
    calculations. We can avoid the need to install Rust and compile every time by
    building wheels for a range of Linux distributions and Python versions. This can
    be done by pulling the ManyLinux Docker images and using them to compile our package
    into multiple distributions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在减少构建方面，我们可以更进一步，尽管这是可选的。你不必这样做来完成这一章。目前，我们正在安装Rust并编译我们的Rust Python包以进行斐波那契计算。我们可以通过为一系列Linux发行版和Python版本构建wheel来避免每次都需要安装Rust和编译。这可以通过拉取ManyLinux
    Docker镜像并使用它们来编译我们的包到多个发行版中完成。
- en: The detailed steps on how to do this to your Python `pip` package coded in Rust
    are laid out in the Rust setup tools documentation (see the *Further reading*
    section). Once those steps are completed, you will end up with a range of wheels
    in your `dist` directory. Copy and paste the 3.6 version into your Flask `src`
    directory and instruct your Dockerfile to copy it into the image when it is being
    built. Once you've done this, you can point the `pip install` command directly
    to the wheel file you copied into the image build. The installation will be nearly
    instant.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将Rust设置工具文档中详细说明的步骤应用于用Rust编写的Python `pip`包（请参阅*进一步阅读*部分）。一旦完成这些步骤，你将在`dist`目录中获得一系列的wheel文件。将3.6版本的wheel文件复制粘贴到Flask的`src`目录中，并指示Dockerfile在构建时将其复制到镜像中。完成这些操作后，你可以直接将`pip
    install`命令指向复制到镜像构建中的wheel文件。安装过程将几乎是瞬间的。
- en: While fusing Rust with our Flask application is certainly useful, since we now
    have a real-world example of how our Rust code can be used in a deployment setting,
    we can go even further. In the next section, we will have our Rust code interact
    with our database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将Rust与我们的Flask应用程序融合确实很有用，因为我们现在有一个真实世界的例子，展示了我们的Rust代码如何在部署环境中使用，但我们还可以更进一步。在下一节中，我们将让我们的Rust代码与我们的数据库交互。
- en: Fusing Rust with data access
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Rust与数据访问融合
- en: In web applications, accessing a database is a big part of the process. We could
    import the `dal` object that we created in the `src/data_access.py` file and pass
    it into our Rust function, executing database operations through Python. While
    this will technically work, it is not ideal as we will have to waste time and
    effort extracting objects from the database queries, inspecting them, and converting
    them into Rust structs. We would then have to convert the Rust structs into Python
    objects before inserting them into the database. This is a lot of excess code
    that has a lot of interaction with Python, reducing its speed gain.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序中，访问数据库是过程的一个重要部分。我们可以导入在`src/data_access.py`文件中创建的`dal`对象，并将其传递给我们的Rust函数，通过Python执行数据库操作。虽然技术上可行，但这并不是最佳方案，因为我们将不得不浪费时间从数据库查询中提取对象，检查它们，并将它们转换为Rust结构体。然后我们必须将Rust结构体转换为Python对象，然后再将它们插入数据库。这是一大堆与Python交互的冗余代码，减少了其速度优势。
- en: 'Because a database is external from the Python web application, and it contains
    information about its schema, we can completely bypass Python''s implementations
    by using the `diesel` Rust crate to automatically write our schema and database
    models in Rust based on the live database. We can also use `diesel` to manage
    the connection to the database. As a result, we can directly interact with the
    database, reducing our reliance on Python, speeding up our code, and reducing
    the amount of code that we have to write. To achieve this, we have to carry out
    the following steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库是Python网络应用程序的外部组件，并且它包含有关其模式的信息，我们可以通过使用`diesel` Rust包完全绕过Python的实现，根据实时数据库自动在Rust中编写我们的模式和数据库模型。我们还可以使用`diesel`来管理数据库连接。因此，我们可以直接与数据库交互，减少我们对Python的依赖，加快我们的代码执行速度，并减少我们需要编写的代码量。为了实现这一点，我们必须执行以下步骤：
- en: Set up our database cloning package.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的数据库克隆包。
- en: Set up our `diesel` environment.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的`diesel`环境。
- en: Autogenerate and configure our database models and schema.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动生成并配置我们的数据库模型和模式。
- en: Define our database connection in Rust.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Rust中定义我们的数据库连接。
- en: Create a Rust function that gets all the Fibonacci records and returns them.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Rust函数，该函数获取所有斐波那契记录并返回它们。
- en: Once we have completed these steps, we will have a Rust package that interacts
    with the database that can be added to our Flask application build and used if
    needed. We will start by setting up our database cloning package.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这些步骤，我们将拥有一个可以添加到我们的Flask应用程序构建中并按需使用的与数据库交互的Rust包。我们将首先设置我们的数据库克隆包。
- en: Setting up our database cloning package
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的数据库克隆包
- en: 'We should now be familiar with setting up a standard Rust package for Python.
    For our database package, we will have the following layout:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该熟悉设置标准的Rust包用于Python。对于我们的数据库包，我们将有以下布局：
- en: '[PRE107]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You should know the role of some of these files by now. The new files have
    the following purposes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该知道一些这些文件的作用。新文件有以下用途：
- en: '`database.rs`: Houses the function that returns a database connection'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database.rs`：包含返回数据库连接的函数'
- en: '`models.rs`: Houses the structs that define the database models, fields, and
    the behavior of the individual rows of a table in the database'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.rs`：包含定义数据库模型、字段以及数据库表中单个行行为的结构体'
- en: '`schema.rs`: Houses the schema of the tables of the database'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schema.rs`：包含数据库表的模式'
- en: '`.env`: Houses the database URL for our **command-line interface** (**CLI**)
    interactions'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.env`：包含用于**命令行界面**（CLI）交互的数据库URL'
- en: '`Diesel.toml`: Houses the configuration for our `diesel` CLI'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Diesel.toml`：包含我们`diesel` CLI的配置'
- en: 'Now, we can turn our attention to the `setup.py` file. Looking at the package
    layout, you should be able to define this file yourself, and I encourage you to
    give it a try. Here is an example of the barebones `setup.py` file that is needed
    to enable this package to be installed with `pip`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将注意力转向`setup.py`文件。查看包布局，你应该能够自己定义此文件，我鼓励你尝试一下。以下是一个示例的裸骨`setup.py`文件，它是使此包能够通过`pip`安装所必需的：
- en: '[PRE118]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'With this, our `rust_db_cloning/__init__.py` file contains the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`rust_db_cloning/__init__.py`文件包含以下代码：
- en: '[PRE132]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now, we can move onto our `Cargo.toml` file, which will list some dependencies
    that you are familiar with, as well as the new `diesel` dependency:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转向我们的`Cargo.toml`文件，该文件将列出一些你熟悉的依赖项，以及新的`diesel`依赖项：
- en: '[PRE133]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: With that, we have defined the basics for our package to be installed via `pip`.
    It will not be installed yet as we have nothing in our `src/lib.rs` file, but
    we will fill that file out in the final step. Now, we can move on to the next
    step, which is setting up our `diesel` environment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经为我们的包定义了通过`pip`安装的基本内容。它现在还没有安装，因为我们`src/lib.rs`文件中没有任何内容，但在最终步骤中我们将填写这个文件。现在，我们可以继续到下一步，即设置我们的`diesel`环境。
- en: Setting up the diesel environment
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置`diesel`环境
- en: 'We will be cloning our schema from our development database so that we can
    hardcode the URL into our `.env` file, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的开发数据库克隆我们的模式，这样我们就可以将URL硬编码到我们的`.env`文件中，如下所示：
- en: '[PRE147]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Since this database configuration will never end up in a production environment
    and is merely used to generate the schema and models from a development database,
    it is OK if this URL gets into the wrong hands. Having this hardcoded into your
    GitHub repository is not the end of the world. With this in mind, we can define
    where we want our schema to be printed in our `diesel.toml` file with the following
    code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个数据库配置永远不会进入生产环境，它仅仅用于从开发数据库生成模式和模型，所以如果这个URL落入错误的手中，也没有关系。将这个硬编码到你的GitHub仓库中并不是世界末日。考虑到这一点，我们可以在`diesel.toml`文件中使用以下代码来定义我们希望模式打印的位置：
- en: '[PRE148]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Now that we have written everything we need, we can start installing and running
    the `diesel` CLI. You may get compilation errors when installing and compiling
    `diesel`. If this is the case while you are reading this, you can get around these
    compilation errors by switching to Rust `nightly`. Rust `nightly` provides the
    latest releases of Rust; however, it is less stable. Therefore, you should try
    and follow these steps without switching to `nightly` but if you find that you
    need to, then you can switch to `nightly` by installing it with the following
    code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经写下了所有需要的内容，我们可以开始安装和运行`diesel` CLI。在安装和编译`diesel`时可能会遇到编译错误。如果你在阅读这段内容时遇到这种情况，你可以通过切换到Rust
    `nightly`来绕过这些编译错误。Rust `nightly`提供了Rust的最新版本；然而，它不够稳定。因此，你应该尝试在不切换到`nightly`的情况下遵循这些步骤，但如果发现你需要这样做，你可以通过以下代码安装它来切换到`nightly`：
- en: '[PRE150]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Once it has been installed, we can switch to `nightly` with the following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以使用以下命令切换到`nightly`：
- en: '[PRE151]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Your Rust compilations will be running in `nightly` now. Going back to setting
    up our `diesel` environment, we have to install the `diesel` CLI with the following
    command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Rust编译现在将在`nightly`模式下运行。回到设置我们的`diesel`环境，我们必须使用以下命令安装`diesel` CLI：
- en: '[PRE152]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: With this, we can now use the CLI combined with the URL in the `.env` file to
    interact with our database.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用CLI结合`.env`文件中的URL来与我们的数据库进行交互。
- en: Autogenerating and configuring our database models and schema
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成和配置我们的数据库模型和模式
- en: 'In this step, we will be interacting with the development database in Docker.
    Considering this, before moving on, you need to open another terminal and run
    the development `docker-compose` environment in the `flask-fib` repository. Running
    this will run the database that we will connect to so that we can access the database
    schema and models. Now that the CLI has been installed, we can print the schema
    with the following command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们将与Docker中的开发数据库进行交互。考虑到这一点，在继续之前，你需要打开另一个终端，并在`flask-fib`仓库中运行开发`docker-compose`环境。运行此命令将运行我们将要连接的数据库，以便我们可以访问数据库模式和模型。现在CLI已经安装，我们可以使用以下命令打印模式：
- en: '[PRE154]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'There will be no printouts in the terminal but if we open our `src/schema.rs`
    file, we will see the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 终端将不会有打印输出，但如果我们打开`src/schema.rs`文件，我们会看到以下代码：
- en: '[PRE155]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Here, we can see that our `alembic` version is in the schema as a separate table.
    This is how `alembic` keeps track of the migrations. We can also see that our
    `fib_entries` table has been mapped. While we could have done this ourselves without
    the `diesel` CLI, it is a lifesaver, ensuring that the schema is always up to
    date with the database. This also saves time in big, complex databases and reduces
    errors.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的`alembic`版本作为单独的表存在于模式中。这就是`alembic`跟踪迁移的方式。我们还可以看到我们的`fib_entries`表已经被映射。虽然我们可以不使用`diesel`
    CLI自己完成这项工作，但它是一个救星，确保模式始终与数据库保持最新。这也在大型、复杂的数据库中节省了时间，并减少了错误。
- en: 'Now that our schema has been defined, we can define our models with the following
    command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的模式，我们可以使用以下命令来定义我们的模型：
- en: '[PRE171]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'This gives us the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下代码：
- en: '[PRE172]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'This is not completely perfect, and we have to make some changes. The models
    do not have the tables defined. `diesel` assumes that the table name is just the
    plural of the model''s name. For instance, if we have a data model called *test*,
    then `diesel` would assume that the table is called *tests*. However, for us,
    this is not the case as we specifically defined our tables in our Flask application
    when running migrations in the previous chapter. We can also remove the two `allow`
    macros as we will not be using this functionality. Instead, we will import our
    schemas and define them in the `table` macro. After this rearrangement, our `src/models.rs`
    file should look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全完美，我们必须做一些修改。模型没有定义表。`diesel`假设表名只是模型名称的复数形式。例如，如果我们有一个名为*test*的数据模型，那么`diesel`会假设表名为*tests*。然而，对我们来说，情况并非如此，因为我们已经在上一章运行迁移时在我们的Flask应用程序中明确定义了我们的表。我们还可以删除两个`allow`宏，因为我们不会使用这个功能。相反，我们将导入我们的模式并在`table`宏中定义它们。经过这次调整后，我们的`src/models.rs`文件应该看起来像这样：
- en: '[PRE185]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Our models and schema are now ready to be used in our Rust package. Considering
    this, we can move on to the next step, which is defining our database connection.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式和模式现在已准备好在我们的Rust包中使用。考虑到这一点，我们可以继续下一步，即定义我们的数据库连接。
- en: Defining our database connection in Rust
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Rust中定义我们的数据库连接
- en: 'Our database connection would traditionally take the database URL from the
    environment and use this to make a connection. However, this is a Rust package
    that is an appendage to our Flask application. There is no point in having another
    sensitive piece of information that has to be loaded. Therefore, to avoid extra
    complications and another point of security failure, we will merely pass the database
    URL from the Flask application to make the connection, since the Flask application
    is managing the configuration and loading the sensitive data anyway. The entirety
    of our database connection can be handled in our `src/database.rs` file. First,
    we must import what we need with the following code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库连接通常会从环境中获取数据库URL，并使用它来建立连接。然而，这是一个附加到我们的Flask应用程序的Rust包。没有必要再有一个需要加载的敏感信息。因此，为了避免额外的复杂性和另一个安全漏洞，我们将仅从Flask应用程序传递数据库URL来建立连接，因为Flask应用程序已经在管理配置和加载敏感数据了。我们的整个数据库连接可以在我们的`src/database.rs`文件中处理。首先，我们必须用以下代码导入我们需要的内容：
- en: '[PRE200]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '`prelude` helps us use the `diesel` macros, and `PgConnection` is what we will
    return to get a database connection. With this, we can build our database connection
    function with the following code:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`prelude`帮助我们使用`diesel`宏，而`PgConnection`是我们将返回以获取数据库连接的东西。有了这个，我们可以用以下代码构建我们的数据库连接函数：'
- en: '[PRE202]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: This can be imported anywhere where we need a database connection. At this point,
    we can start creating a function that gets all the records and returns them in
    dictionaries.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在我们需要数据库连接的任何地方导入。在这个时候，我们可以开始创建一个函数，该函数获取所有记录并以字典的形式返回它们。
- en: Creating a Rust function that gets all the Fibonacci records and returns them
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Rust函数，该函数获取所有斐波那契记录并返回它们
- en: 'To avoid excessive complexity in this example, we will be doing everything
    in the `src/lib.rs` file. However, it is advised that you build some modules and
    import them into the `src/lib.rs` file for more complex packages. First of all,
    we will import everything we need to build the function and bind it with the following
    code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在这个例子中过度复杂化，我们将所有内容都在`src/lib.rs`文件中完成。然而，建议你在更复杂的包中构建一些模块并将它们导入到`src/lib.rs`文件中。首先，我们将导入构建函数并绑定所需的所有内容，以下代码：
- en: '[PRE206]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'The order of the imports matters here. We import the `diesel` crate with macro
    use straightaway. Therefore, files such as `database` and `schema` will not error
    out because they are using `diesel` macros. `dotenv` is not being used in our
    example as we are passing in the database URL from the Python system. However,
    it''s useful to know about this if you want to get database URLs from the environment.
    Then, we can import the `pyo3` macros and structs that we need, and the structs
    and functions that we defined. With these imports, we can define our `get_fib_entries`
    function with the following code:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，导入的顺序很重要。我们直接导入带有宏使用的`diesel` crate。因此，像`database`和`schema`这样的文件不会出错，因为它们使用了`diesel`宏。在我们的例子中，我们没有使用`dotenv`，因为我们是从Python系统传递数据库URL。然而，如果你想要从环境中获取数据库URL，了解这一点是有用的。然后，我们可以导入所需的`pyo3`宏和结构体，以及我们定义的结构体和函数。有了这些导入，我们可以用以下代码定义我们的`get_fib_entries`函数：
- en: '[PRE218]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Using Python to build a list of dictionaries is not new, and neither is the
    definition of the function. What is new, however, is establishing a connection,
    ordering it using the schema columns, and loading it as a list of `FibEntry` structs.
    We pass a reference to the connection into our query and unwrap it as it returns
    a result. We can chain more functions to it, such as `.filter`, if needed. The
    `diesel` documentation does a good job of covering the different types of queries
    and inserts you can perform. Once we''ve done this, we can add it to our `rust_db_cloning`
    module with the following code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python构建字典列表并不新鲜，函数的定义也是如此。然而，新的地方在于建立连接，使用模式列对其进行排序，并将其作为`FibEntry`结构体的列表加载。我们将连接的引用传递到查询中，并在它返回结果时解包它。如果需要，我们可以向它链式调用更多函数，例如`.filter`。`diesel`文档很好地涵盖了你可以执行的不同类型的查询和插入。一旦我们完成这些，我们可以使用以下代码将其添加到我们的`rust_db_cloning`模块中：
- en: '[PRE236]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: With this, our code is ready to be uploaded to the GitHub repository and used
    in our Flask application.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的代码就准备好上传到GitHub仓库并在我们的Flask应用程序中使用。
- en: 'Now, we can quickly test whether our package works before defining it in our
    Dockerfile. First of all, we need to `pip` `install` it in our Flask application
    virtual environment. This is another point where you might have compilation issues.
    To get around this, you might have to switch to Rust `nightly` to `pip` `install`
    the package you just built. Once our package has been installed, we can check
    it out by adding a simple `get` view to our Flask application. In the `src/app.py`
    file of our Flask application, we can import our function with the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在定义Dockerfile之前快速测试我们的包是否工作。首先，我们需要在我们的Flask应用程序虚拟环境中`pip`安装它。这是你可能会遇到编译问题的另一个地方。为了解决这个问题，你可能需要切换到Rust
    `nightly`来`pip`安装你刚刚构建的包。一旦我们的包被安装，我们可以通过向Flask应用程序添加一个简单的`get`视图来检查它。在我们的Flask应用程序的`src/app.py`文件中，我们可以使用以下代码导入我们的函数：
- en: '[PRE242]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Now, we can define our `get` view with the following code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码定义我们的`get`视图：
- en: '[PRE243]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Remember that in the previous chapter, we defined the `url` attribute of `dal`
    with the URL from `GlobalParams`, which was loaded from the `.yml` config file.
    We have to turn it into a string; otherwise, the Flask serialization will not
    be able to process it. Running this in the development `docker-compose` environment
    will give us the following output:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在上一章中，我们定义了`dal`的`url`属性，使用的是从`.yml`配置文件加载的`GlobalParams`中的URL。我们必须将其转换为字符串；否则，Flask序列化将无法处理它。在开发`docker-compose`环境中运行此代码将给出以下输出：
- en: '![Figure 10.3 – Simple get view from our Flask application'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 从我们的Flask应用程序获取的简单视图'
- en: '](img/B17720_10_03.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17720_10_03.jpg)'
- en: Figure 10.3 – Simple get view from our Flask application
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 从我们的Flask应用程序获取的简单视图
- en: You may have different numbers, depending on what you have in your database.
    However, what we have here is a Rust package that keeps up with the changes in
    the database that can interact directly with the database. Now that this is working
    in our development setup, we can start packaging our Rust `nightly` package for
    deployment.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会有不同的数字，这取决于你数据库中的内容。然而，我们这里有一个Rust包，它能跟上数据库的变化，并能直接与数据库交互。现在，这个功能在我们的开发环境中已经工作，我们可以开始打包我们的Rust
    `nightly`包以进行部署。
- en: Deploying Rust nightly in Flask
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flask中部署Rust nightly
- en: To package our `nightly` database Rust package so that it can be deployed, we
    have to add another clone of our GitHub repository to our build Bash script, install
    `nightly`, and switch to it when we are installing our database package with `pip`.
    You can probably guess what we are going to achieve by cloning our database GitHub
    repository in our Bash script.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要打包我们的`nightly`数据库Rust包以便部署，我们必须在我们的构建Bash脚本中添加我们GitHub仓库的另一个副本，安装`nightly`，并在使用`pip`安装数据库包时切换到它。你可能会猜到，通过在我们的Bash脚本中克隆数据库GitHub仓库，我们将实现什么。
- en: 'For reference, our `src/build_image.sh` file will take the form of the following
    code:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，我们的`src/build_image.sh`文件将采用以下代码的形式：
- en: '[PRE246]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'Here, we can see that we have merely added the code for cloning the `rust-db-cloning`
    repository, removed the `.git` file in that `rust-db-cloning` repository, and
    then removed the `rust-db-cloning` repository once the image build has finished.
    When it comes to our Dockerfile, these steps will remain the same. The only difference
    is that after installing our normal Rust package, we install `nightly`, switch
    to it, and then install our database package. This can be achieved with the following
    code:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们仅仅添加了克隆`rust-db-cloning`仓库的代码，从那个`rust-db-cloning`仓库中移除了`.git`文件，然后在镜像构建完成后移除了`rust-db-cloning`仓库。当我们谈到我们的Dockerfile时，这些步骤将保持不变。唯一的区别是，在安装我们的常规Rust包之后，我们安装`nightly`，切换到它，然后安装我们的数据库包。这可以通过以下代码实现：
- en: '[PRE256]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Even though one is compiled with normal Rust, while the other is compiled with
    Rust `nightly`, they will both run fine when the application is running. Building
    this image and running it in the deployment `docker-compose` environment will
    show us that the container will process the Rust computation view and get it from
    the database view without any problems. With this, we now have all the tools we
    need to fuse Rust into Python web applications and deploy them in Docker.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个是用常规Rust编译的，而另一个是用Rust `nightly`编译的，但当应用程序运行时，它们都会正常运行。构建这个镜像并在部署`docker-compose`环境中运行它将显示容器将处理Rust计算视图并从数据库视图中获取它而没有任何问题。有了这个，我们现在拥有了将Rust融合到Python
    Web应用程序并部署它们的全部工具。
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have put all our Rust fusing skills to work to build packages
    that are baked into Docker images for a Python web application. We attached Rust
    packages directly to the web application, and then to the Celery worker, resulting
    in a significant speedup when we asked our web application to calculate the Fibonacci
    number.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将所有Rust融合技能用于构建打包到Python Web应用程序Docker镜像中的包。我们将Rust包直接附加到Web应用程序，然后到Celery工作进程，当我们要求Web应用程序计算斐波那契数时，这导致了显著的加速。
- en: Then, we altered our build process to take Rust packages from private GitHub
    repositories when building our Python web application image. Finally, we connected
    directly to the database with Rust and used Rust `nightly` to compile it. We managed
    to include this in our Python web application Docker build. This resulted in us
    not only being able to fuse Rust into a deployable web application but also use
    Rust `nightly` and databases to solve our problems
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们改变了我们的构建过程，在构建我们的Python Web应用程序镜像时从私有GitHub仓库中获取Rust包。最后，我们用Rust直接连接到数据库，并使用Rust
    `nightly`来编译它。我们设法将其包含在我们的Python Web应用程序Docker构建中。这使我们不仅能够将Rust融合到可部署的Web应用程序中，还能使用Rust
    `nightly`和数据库来解决问题
- en: With this in mind, we can now use what we have learned in this book for production
    web applications. You can now start coding in Rust and plug your Rust packages
    into existing Python web applications that can be deployed in Docker, without
    having to make major changes to the Python web application build process.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们现在可以使用这本书中学到的知识来生产Web应用程序。你现在可以开始用Rust编码，并将你的Rust包插入到可以部署在Docker中的现有Python
    Web应用程序中，而无需对Python Web应用程序的构建过程进行重大更改。
- en: Reaching for Rust to solve a speed bottleneck or to ensure that the code is
    consistent and safe in a live Python web application is something you can do in
    your day job tomorrow. You can now bring forward the fastest memory-safe programming
    language into your Python projects without having to overhaul your existing system.
    You are now capable of bridging the gap between practically maintaining an existing
    tried and tested system and a cutting-edge language. In the next and final chapter,
    we will cover some best practices. But right now, you know the key concepts to
    go and change your project or organization.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的日常工作中明天使用Rust来解决速度瓶颈或确保代码在实时Python Web应用程序中的一致性和安全性，这是你可以做到的。你现在可以将最快的内存安全编程语言带入你的Python项目中，而无需彻底改造现有的系统。你现在能够弥合维护现有经过验证的系统与前沿语言之间的差距。在下一章和最后一章中，我们将介绍一些最佳实践。但现在，你知道了改变你的项目或组织的核心概念。
- en: Questions
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does directly connecting to a database in Rust reduce code?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接在Rust中连接到数据库如何减少代码？
- en: Why can't we just pass login credentials into our Docker image build Dockerfile?
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不能直接在我们的Docker镜像构建Dockerfile中传递登录凭证？
- en: We did not make any migrations in this chapter. How did we map our models and
    schema of a database to our Rust module, and how do we continue to keep up with
    database changes?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中，我们没有进行任何迁移。我们是如何将数据库的模型和模式映射到我们的Rust模块中，以及我们如何继续跟踪数据库的变化？
- en: Why do we pass the database URL into our database Rust package as opposed to
    loading it from a config file or environment?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们将数据库URL传递给我们的Rust数据库包，而不是从配置文件或环境中加载它？
- en: Do we have to do anything extra if we were going to fuse Rust with a Django,
    bottle, or FastAPI Python web application?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们要将Rust与Django、bottle或FastAPI Python Web应用融合，我们是否需要做任何额外的事情？
- en: Answers
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Directly connecting to a database with Rust reduces the amount of code we must
    write as we do not have to inspect the Python objects that are returned from the
    Python database call. We also do not have to package data into Python objects
    before inserting them into the database. This essentially removes a whole layer
    of code that we must write when interacting with the database.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Rust直接连接到数据库减少了我们必须编写的代码量，因为我们不需要检查Python数据库调用返回的Python对象。我们也不需要在将数据插入数据库之前将数据打包成Python对象。这实际上消除了我们在与数据库交互时必须编写的整个代码层。
- en: If someone gets hold of our image, they can access the layers of the build.
    As a result, they can access the arguments that have been passed into the build.
    This will mean that they can see the credentials we use to log in.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有人获取了我们的镜像，他们可以访问构建的层。结果，他们可以访问传递给构建的参数。这意味着他们可以看到我们用来登录的凭证。
- en: We used the `diesel` crate to connect to the database and automatically print
    the schemas and models based on the database it connects to. We can do this repeatedly
    to keep up to date with new database migrations.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了`diesel`包来连接到数据库，并自动根据连接的数据库打印出模式和模型。我们可以重复这样做，以保持与新的数据库迁移同步。
- en: We must remember that our Rust database package is an appendage to our Python
    web application. Our Python web application has already loaded the database URL.
    Loading credentials into our package just adds another possibility for a security
    breach with no advantages.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须记住，我们的Rust数据库包是我们Python Web应用的补充。我们的Python Web应用已经加载了数据库URL。将凭证加载到我们的包中只是增加了另一个安全漏洞的可能性，而没有带来任何优势。
- en: No – our fusing method is completely detached from the `pip` installation process
    and the database mapping process.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，我们的融合方法与`pip`安装过程和数据库映射过程完全分离。
- en: Further reading
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Diesel documentation for Rust (2021): Crate Diesel: [https://diesel.rs](https://diesel.rs)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Rust的Diesel文档（2021）：Crate Diesel: [https://diesel.rs](https://diesel.rs)'
- en: 'Setup tools Rust documentation (2021): Distributing a Rust Python package with
    wheels: [https://pypi.org/project/setuptools-rust/](https://pypi.org/project/setuptools-rust/)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust的设置工具文档（2021）：使用wheels分发Rust Python包：[https://pypi.org/project/setuptools-rust/](https://pypi.org/project/setuptools-rust/)
- en: 'ManyLinux GitHub (2021): [https://github.com/pypa/manylinux](https://github.com/pypa/manylinux%0D)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ManyLinux GitHub (2021): [https://github.com/pypa/manylinux](https://github.com/pypa/manylinux%0D)'
