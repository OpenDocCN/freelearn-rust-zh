- en: Collections in Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 的集合
- en: 'In the previous chapters, we implemented a range of data structures, something
    that rarely happens in reality. Especially in Rust, the excellent `Vec<T>` covers
    a lot of cases, and if a map type structure is required, the `HashMap<T>` covers
    most of these too. So what else is there? How are they implemented? Why were they
    implemented if they won''t be used? These are all great questions, and they''ll
    get answered in this chapter. You can look forward to learning about the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们实现了一系列数据结构，这在现实中很少发生。特别是在 Rust 中，优秀的 `Vec<T>` 覆盖了大量的用例，如果需要映射类型结构，`HashMap<T>`
    也覆盖了其中大部分。那么还有什么？它们是如何实现的？为什么实现它们如果它们不会被使用呢？这些都是很好的问题，它们将在本章中得到解答。你可以期待学习以下内容：
- en: Sequence data types such as `LinkedList<T>`, `Vec<T>`, or `VecDeque<T>`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 `LinkedList<T>`、`Vec<T>` 或 `VecDeque<T>` 之类的序列数据类型
- en: Rust's `BinaryHeap<T>` implementation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 的 `BinaryHeap<T>` 实现
- en: '`HashSet<T>` and `BTreeSet<T>`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashSet<T>` 和 `BTreeSet<T>`'
- en: How to map things with the `BTreeMap<T>` and `HashMap<T>`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `BTreeMap<T>` 和 `HashMap<T>` 映射事物
- en: Sequences
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: Lists of any kind are the most essential data structure in a typical program;
    they provide flexibility and can be used as a queue, as a stack, as well as a
    searchable structure. Yet the limitations and the operations make a huge of difference
    between different data structures, which is why the documentation for `std::collections`
    offers a decision tree to find out the collection type that is actually required
    to solve a particular problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的列表都是典型程序中最基本的数据结构；它们提供了灵活性，可以用作队列、栈，以及可搜索的结构。然而，限制和操作在不同的数据结构之间造成了巨大的差异，这就是为什么
    `std::collections` 的文档提供了一个决策树，以找出解决特定问题实际所需的集合类型。
- en: 'The following were discussed in [Chapter 4](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml),
    *Lists, Lists, More Lists*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下在第 4 章 [“列表，列表，更多列表”](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml) 中进行了讨论：
- en: '**Dynamic arrays** (`Vec<T>`) are the most universal and straightforward to
    use sequential data structure. They capture the speed and accessibility of an
    array, the dynamic sizing of a list, and they are the fundamental building block
    for higher order structures (such as stacks, heaps, or even trees). So, when in
    doubt a `Vec<T>` is always a good choice.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态数组** (`Vec<T>`) 是最通用且最易于使用的顺序数据结构。它们结合了数组的速度和可访问性，列表的动态大小，并且是构建更高阶结构（如栈、堆或甚至树）的基本构建块。因此，在不确定的情况下，`Vec<T>`
    总是一个不错的选择。'
- en: '`VecDeque<T>` is a close relative of the `Vec<T>`, implemented as a **ring
    buffer**—a dynamic array that wraps around the ends end, making it look like a
    circular structure. Since the underlying structure is still the same as `Vec<T>`,
    many of its aspects also apply here.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VecDeque<T>` 是 `Vec<T>` 的一个近亲，实现为一个 **环形缓冲区**——一个动态数组，它围绕两端回绕，使其看起来像一个环形结构。由于底层结构仍然与
    `Vec<T>` 相同，因此许多方面也适用于这里。'
- en: The `LinkedList<T>` is very limited in its functionality in Rust. Direct index
    access will be inefficient (it's a counted iteration), which is probably why it
    can only iterate, merge and split, and insert or retrieve from the back and front.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中，`LinkedList<T>` 的功能非常有限。直接索引访问将是不高效的（它是一个计数迭代），这可能是为什么它只能迭代、合并和拆分，以及从后端和前端插入或检索。
- en: This was a nice primer, so let's look deeper into each of Rust's data structures
    in `std::collections`!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的入门，那么让我们深入探讨 Rust 的 `std::collections` 中每个数据结构！
- en: Vec<T> and VecDeque<T>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Vec<T>` 和 `VecDeque<T>`'
- en: Just like the dynamic array in [Chapter 4](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml),
    *Lists, Lists, More Lists*, `Vec<T>` and `VecDeque<T>` are growable, list-like
    data structures with support for indexing and based on a heap-allocated array.
    Other than the previously implemented dynamic array, it is generic by default
    without any constraints for the generic type, allowing literally any type to be
    used.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像第 4 章 [“列表，列表，更多列表”](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml) 中的动态数组一样，`Vec<T>`
    和 `VecDeque<T>` 是可增长的、类似列表的数据结构，支持索引，并且基于堆分配的数组。除了之前实现的动态数组之外，它默认是泛型的，没有对泛型类型的任何约束，允许使用任何类型。
- en: '`Vec<T>` aims to have as little overhead as possible, while providing a few
    guarantees. At its core, it is a triple of (`pointer`, `length`, `capacity`) that
    provides an API to modify these elements. The `capacity` is the amount of memory
    that is allocated to hold items, which means that it fundamentally differs from
    `length`, the number of elements currently held. In case a zero-sized type or
    no initial length is provided, `Vec<T>` won''t actually allocate any memory. The
    `pointer` only points to the reserved area in memory that is encapsulated as a
    `RawVec<T>` structure.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec<T>` 旨在尽可能减少开销，同时提供一些保证。在其核心，它是一个包含 (`指针`, `长度`, `容量`) 的三元组，提供了修改这些元素的
    API。`容量` 是分配以存放项的内存量，这意味着它与 `长度` 有根本的不同，`长度` 是当前持有的元素数量。如果提供了零大小类型或没有初始长度，`Vec<T>`
    实际上不会分配任何内存。`指针` 只指向内存中保留的区域，该区域被封装为 `RawVec<T>` 结构。'
- en: The main drawback of `Vec<T>` is its lack of efficient insertion at the front,
    which is what `VecDeque<T>` aims to provide. It is implemented as a ring, which
    wraps around the edges of the array, creating a more complex situation when the
    memory has to be expanded, or an element is to be inserted at a specified position.
    Since the implementations of `Vec<T>` and `VecDeque<T>` are quite similar, they
    can be used in similar contexts. This can be shown in their architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec<T>` 的主要缺点是其前端的插入效率不高，这正是 `VecDeque<T>` 旨在提供的。它被实现为一个环形，环绕数组的边缘，当内存需要扩展或需要在指定位置插入元素时，会创建一个更复杂的情况。由于
    `Vec<T>` 和 `VecDeque<T>` 的实现相当相似，它们可以在类似的环境中使用。这可以在它们的架构中体现出来。'
- en: Architecture
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: 'Both structures, `Vec<T>` and `RawVec<T>`, allocate memory in the same way:
    by using the `RawVec<T>` type. This structure is a wrapper around lower level
    functions to allocate, reallocate, or deallocate an array in the heap part of
    the memory, built for use in higher level data structures. Its primary goal is
    to avoid capacity overflows, out-of-memory errors, and general overflows, which
    saves the developer a lot of boilerplate code.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种结构，`Vec<T>` 和 `RawVec<T>`，都以相同的方式分配内存：通过使用 `RawVec<T>` 类型。这种结构是围绕低级函数的一个包装，用于在内存的堆部分分配、重新分配或释放数组，专为在高级数据结构中使用而构建。其主要目标是避免容量溢出、内存不足错误和一般性溢出，从而为开发者节省大量样板代码。
- en: 'The use of this buffer by `Vec<T>` is straightforward. Whenever the length
    threatens to exceed capacity, allocate more memory and transfer all elements,
    shown in the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec<T>` 使用此缓冲区的方式很简单。每当长度威胁要超过容量时，就分配更多内存并将所有元素转移，如下面的代码所示：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So this goes on to call the `reserve()` function, followed by the `try_reserve()`,
    followed by the `amortized_new_size()` of `RawVec<T>`, which also makes the decision
    about the size:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，接下来会调用 `reserve()` 函数，然后是 `try_reserve()`，接着是 `RawVec<T>` 的 `amortized_new_size()`，它也会决定大小：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's take a look at `VecDeque<T>`. On top of memory allocation, `VecDeque<T>`
    has to deal with wrapping the data around the ring, which adds considerable complexity
    to inserting an element at a specified position, or when the capacity has to increase.
    Then, the old elements need to be copied to the new memory area, starting with
    the shortest part of a wrapped list.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `VecDeque<T>`。除了内存分配之外，`VecDeque<T>` 还必须处理数据在环形中的环绕，这为在指定位置插入元素或容量需要增加时增加了相当大的复杂性。然后，需要将旧元素复制到新的内存区域，从环绕列表的最短部分开始。
- en: Like the `Vec<T>`, the `VecDeque<T>` doubles its buffer in size if it is full,
    but uses the `double()` function to do so. *Be aware that doubling is not a guaranteed
    strategy and might change.*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Vec<T>` 类似，当 `VecDeque<T>` 满时，它会将缓冲区大小加倍，但使用 `double()` 函数来实现。*请注意，加倍不是一个保证的策略，可能会改变。*
- en: '*However, whatever replaces it will have to retain the runtime complexities
    of the operations.* The following are the functions used to determine whether
    the data structure is full and if it needs to grow in size:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*然而，无论取代它的是什么，都必须保留操作的运行时复杂性。* 以下是用以确定数据结构是否已满以及是否需要增长大小的函数：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `handle_cap_increase()` function will then decide where the new ring should
    live and how the copying into the new buffer is handled, prioritizing copying
    as little data as possible. Other than `Vec<T>`, calling the `new()` function
    on `VecDeque<T>` allocates at `RawVec<T>` with enough space for seven elements,
    which then can be inserted without growing the underlying memory, therefore it
    is not a zero-size structure when empty.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_cap_increase()`函数将决定新的环应该放在哪里以及如何处理复制到新缓冲区，优先考虑尽可能少地复制数据。除了`Vec<T>`之外，在`VecDeque<T>`上调用`new()`函数会在`RawVec<T>`中分配足够的空间以容纳七个元素，然后可以插入而不会增加底层内存的大小，因此当它为空时不是一个零大小结构。'
- en: Insert
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: 'There are two ways to add elements to `Vec<T>`: `insert()` and `push()`. The
    former takes two parameters: an index of where to insert the element and the data.
    Before inserting, the position on the index will be freed by moving all succeeding
    elements towards the end (to the right). Therefore, if an element is inserted
    at the front, every element has to be shifted by one. `Vec<T>` code shows the
    following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Vec<T>`添加元素有两种方式：`insert()`和`push()`。前者接受两个参数：要插入元素的位置索引和数据。在插入之前，索引上的位置将通过将所有后续元素移动到末尾（向右）来释放。因此，如果元素在前面插入，每个元素都必须移动一个位置。`Vec<T>`代码如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While shifting is done efficiently, by calling `push()`, the new item can be
    added without moving data around, shown as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过调用`push()`进行高效移动时，新项目可以添加而无需移动数据，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The main drawback of regular `Vec<T>` is the inability of efficiently adding
    data to the front, which is where `VecDeque<T>` excels. The code for doing this
    is nice and short, shown as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正规的`Vec<T>`的主要缺点是无法高效地向前面添加数据，这正是`VecDeque<T>`擅长的领域。执行此操作的代码既简洁又短小，如下所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the use of `unsafe {}` in these functions, the code is much shorter and
    faster than it would be using safe Rust exclusively.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些函数中使用`unsafe {}`，代码比仅使用安全的Rust要短得多，也快得多。
- en: Look up
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找
- en: One major upside of using array-type data allocation is the simple and fast
    element access, which `Vec<T>` and `VecDeque<T>` share. The formal way to implement
    the direct access using brackets (`let my_first_element= v[0];`) is provided by
    the `Index<I>` trait.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组类型数据分配的主要优点是简单的快速元素访问，这是`Vec<T>`和`VecDeque<T>`共有的。使用括号直接访问的正式方式由`Index<I>`特质提供（`let
    my_first_element= v[0];`）。
- en: Other than direct access, iterators are provided to search, fold, map, and so
    on the data. Some are equivalent to the `LinkedList<T>` part of this section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接访问之外，迭代器还提供了搜索、折叠、映射等功能。其中一些与这一节中的`LinkedList<T>`部分相当。
- en: 'As an example, the `Vec<T>`''s owning iterator (`IntoIter<T>`) owns the pointer
    to the buffer and moves a pointer to the current element forward. There is also
    a catch though: if the size of an element is zero bytes, how should the pointer
    be moved? What data is returned? The `IntoIter<T>` structure comes up with a clever
    solution (**ZSTs** are **zero-sized types**, so types that don''t actually take
    up space):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Vec<T>`的所有权迭代器（`IntoIter<T>`）拥有缓冲区的指针并将当前元素的指针向前移动。不过，这里也有一个陷阱：如果一个元素的大小是零字节，指针应该如何移动？返回什么数据？`IntoIter<T>`结构提出了一个巧妙的解决方案（**ZSTs**是**零大小类型**，所以实际上不占用空间）：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The comments already state what's happening, the iterator avoids returning the
    same pointer over and over again, and instead, increments it by one and returns
    a zeroed out memory. This is clearly something that the Rust compiler would not
    tolerate, so `unsafe` is a great choice here. Furthermore, the regular iterator
    (`vec![].iter()`) is generalized in the `core::slice::Iter` implementation, which
    works on generic, array-like parts of the memory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注释已经说明了正在发生的事情，迭代器避免反复返回相同的指针，而是将其增加一个并返回一个清零的内存。这显然是Rust编译器不会容忍的事情，因此在这里使用`unsafe`是一个很好的选择。此外，常规迭代器（`vec![].iter()`）在`core::slice::Iter`实现中被泛化，它作用于内存的泛型、类似数组的部分。
- en: 'Contrary to that, the iterator of `VecDeque<T>` resorts to moving an index
    around the ring until a full circle is reached. Here is its implementation, shown
    in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`VecDeque<T>`的迭代器会通过在环中移动索引直到完成一圈来达到目的。以下是它的实现，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Among other traits, both implement the `DoubleEndedIterator<T>` work on both
    ends, a special function called `DrainFilter<T>`, in order to retrieve items in
    an iterator only if a predicate applies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他特质中，两者都实现了在两端工作的`DoubleEndedIterator<T>`，一个特殊的功能称为`DrainFilter<T>`，以便仅在应用谓词的情况下从迭代器中检索项目。
- en: Remove
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: '`Vec<T>` and `VecDeque<T>` both remain efficient when removing items. Although,
    they don''t change the amount of memory allocated to the data structure, both
    types provide a function called `shrink_to_fit()` to readjust the capacity to
    the length it has.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec<T>` 和 `VecDeque<T>` 在删除元素时都保持高效。尽管如此，它们不会改变分配给数据结构的内存量，这两种类型都提供了一个名为 `shrink_to_fit()`
    的函数来调整容量以适应其长度。'
- en: 'On `remove`, `Vec<T>` shifts the remaining elements toward the start of the
    sequence. Like the `insert()` function, it simply copies the entire remaining
    data with an offset, shown as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `remove` 操作中，`Vec<T>` 将剩余的元素移向序列的开始。像 `insert()` 函数一样，它只是简单地复制整个剩余数据并偏移，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For `VecDeque<T>`, the situation is much more complex: since the data can wrap
    around the ends of the underlying buffer (for example, the tail is on index three,
    head on index five, so the space from three to five is considered empty), it can''t
    blindly copy in one direction. Therefore, there is some logic that deals with
    these different situations, but it is much too long to add here.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `VecDeque<T>`，情况要复杂得多：因为数据可以绕过底层缓冲区的末端（例如，尾部在索引三，头部在索引五，所以从三到五的空间被认为是空的），它不能盲目地单向复制。因此，有一些逻辑来处理这些不同的情况，但这里添加的代码太长了。
- en: LinkedList<T>
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LinkedList<T>
- en: 'Rust''s `std::collection::LinkedList<T>` is a doubly linked list that uses
    an `unsafe` pointer operation to get around the `Rc<RefCell<Node<T>>>` unpacking
    we had to do in [Chapter 4](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml), *Lists,
    Lists, and More Lists*. While unsafe, this is a great solution to that problem,
    since the pointer operations are easy to comprehend and provide significant benefits.
    Let''s look at the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的 `std::collection::LinkedList<T>` 是一个使用 `unsafe` 指针操作来绕过我们在第 4 章[列表、列表和更多列表](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml)中必须进行的
    `Rc<RefCell<Node<T>>>` 解包的双向链表。虽然不安全，但这是对该问题的绝佳解决方案，因为指针操作易于理解，并提供显著的好处。让我们看看以下代码：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`NonNull` is a structure that originates from `std::ptr::NonNull`, which provides
    a non-zero pointer to a portion of heap memory in unsafe territory. Hence, the
    interior mutability pattern can be skipped at this fundamental level, eliminating
    the need for runtime checks.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`NonNull` 是一个结构，它起源于 `std::ptr::NonNull`，在 `unsafe` 领域提供了一个非零指针到堆内存的一部分。因此，在基本层面上可以跳过内部可变性模式，消除运行时检查的需要。'
- en: Architecture
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: Fundamentally, `LinkedList` is built just the way we built the doubly linked
    list in [Chapter 4](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml), *Lists, Lists,
    and More Lists*, with the addition of a `PhantomData<T>` type pointer. Why? This
    is necessary to inform the compiler about the properties of the type that contains
    the marker when generics are involved. With it, the compiler can determine a range
    of things, including drop behavior, lifetimes, and so on. The `PhantomData<T>`
    pointer is a zero-size addition, and pretends to own type `T` content, so the
    compiler can reason about that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`LinkedList` 是按照我们在第 4 章[列表、列表和更多列表](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml)中构建双向链表的方式构建的，增加了
    `PhantomData<T>` 类型指针。为什么？这是必要的，以便在泛型涉及时通知编译器包含标记的类型属性。有了它，编译器可以确定一系列事情，包括析构行为、生命周期等。《PhantomData<T>`
    指针是一个零大小的添加，它假装拥有类型 `T` 的内容，因此编译器可以对此进行推理。
- en: Insert
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: The `std::collections::LinkedList` employs several unsafe methods in order to
    avoid the `Rc<RefCell<Node<T>>>` and `next.as_ref().unwrap().borrow()` calls that
    we saw when implementing a doubly linked list in a safe way. This also means that
    adding a node at either end entails the use of `unsafe` to set these pointers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::collections::LinkedList` 使用了几个不安全的方法来避免我们在以安全方式实现双向链表时看到的 `Rc<RefCell<Node<T>>>`
    和 `next.as_ref().unwrap().borrow()` 调用。这也意味着在两端添加节点需要使用 `unsafe` 来设置这些指针。'
- en: 'In this case, the code is easy to read and comprehend, which is important to
    avoid sudden crashes due to unsound code being executed. This is the core function
    to add a node in the front, shown as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码易于阅读和理解，这对于避免由于执行不稳定的代码而导致的意外崩溃非常重要。这是在前面添加节点的基本函数，如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code is wrapped by the publicly facing `push_front()` function, shown
    in the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被公开的 `push_front()` 函数包裹，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `push_back()` function, which performs the same action but on the end of
    the list, works just like this. Additionally, the linked list can append another
    list just as easily, since it is almost the same as adding a single node, but
    with additional semantics (such as: is the list empty?) to take care of:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`push_back()`函数，它执行与之前相同的操作，但作用于列表的末尾，工作方式如下。此外，链表可以像添加单个节点一样轻松地附加另一个列表，因为它几乎与添加单个节点相同，但需要额外的语义（例如：列表是否为空？）来处理：'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Adding things is one of the strong suits of a linked list. But how about looking
    up elements?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 添加项目是链表的一个强项。但查找元素呢？
- en: Look up
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找
- en: 'The `collections::LinkedList` relies a lot on the `Iterator` trait to look
    up various items, which is great since it saves a lot of effort. This is achieved
    by extensively implementing various iterator traits using several structures,
    like the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections::LinkedList`在很大程度上依赖于`Iterator`特质来查找各种项目，这是非常好的，因为它节省了很多精力。这是通过广泛实现各种迭代器特质来实现的，使用几个结构，如下所示：'
- en: '`Iter`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iter`'
- en: '`IterMut`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IterMut`'
- en: '`IntoIter`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntoIter`'
- en: 'Technically, `DrainFilter` also implements `Iterator`, but it''s really a convenience
    wrapper. The following is the `Iter` structure declaration that the `LinkedList`
    uses:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`DrainFilter`也实现了`Iterator`，但它实际上是一个便利包装器。以下是`LinkedList`使用的`Iter`结构声明：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you remember the list's declaration earlier, it will become obvious that
    they are very similar! In fact, they are the same, which means that when iterating
    over a linked list, you are essentially creating a new list that gets shorter
    with every call to `next()`. As expected, this is a very efficient process that
    is employed here, since no data is copied and the `Iter` structures' head can
    move back and forth with the `prev`/`next` pointers of the current head.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前列表的声明，就会很明显，它们非常相似！事实上，它们是相同的，这意味着在遍历链表时，你实际上是在创建一个新的列表，每次调用`next()`都会变得更短。正如预期的那样，这是一个非常高效的过程，在这里被采用，因为没有任何数据被复制，`Iter`结构的头部可以随着当前头部的`prev`/`next`指针来回移动。
- en: '`IterMut` and `IntoIter` have a slightly different structure, due to their
    intended purposes. `IntoIter` takes ownership of the entire list, and just calls
    `pop_front()` or `pop_back()` as requested.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`IterMut`和`IntoIter`的结构略有不同，这是由于它们的目的不同。`IntoIter`获取整个列表的所有权，并根据请求调用`pop_front()`或`pop_back()`。'
- en: '`IterMut` has to retain a mutable reference to the original list in order to
    provide mutable references to the caller, but other than that, it''s basically
    an `Iter` type structure.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`IterMut`必须保留对原始列表的可变引用，以便向调用者提供可变引用，但除此之外，它基本上是一个`Iter`类型结构。'
- en: The other structure that also does iteration is `DrainFilter`, which as the
    name suggests, removes items.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个也进行迭代的结构是`DrainFilter`，正如其名所示，它用于移除项目。
- en: Remove
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除
- en: 'The linked list contains two functions: `pop_front()` and `pop_back()`, and
    they simply wrap around an "inner" function called `pop_front_node()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 链表包含两个函数：`pop_front()`和`pop_back()`，它们简单地封装了一个名为`pop_front_node()`的“内部”函数：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This way, removing a specific element from `LinkedList<T>` has to be done either
    by splitting and appending the list (skipping the desired element), or by using
    `drain_filter()` function, which does almost exactly that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，要从`LinkedList<T>`中移除特定元素，必须通过分割和附加列表（跳过所需元素）来完成，或者使用`drain_filter()`函数，它几乎就是这样做。
- en: Wrap up
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: '`Vec<T>` and `VecDeque<T>` both build on a heap-allocated array, and perform
    very well on `insert` and `find` operations, thanks to the elimination of several
    steps. However, the dynamic array implementation from earlier in the book can
    actually hold its own against these.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec<T>`和`VecDeque<T>`都基于堆分配的数组构建，并且在`insert`和`find`操作上表现良好，这得益于消除了几个步骤。然而，书中早期提到的动态数组实现实际上可以与这些相媲美。'
- en: 'The doubly-linked list implemented previously does not look good against the
    `LinkedList<T>` provided by `std::collections`, which is built far simpler and
    does not use `RefCells` that do runtime borrow checking:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前实现的双向链表与`std::collections`提供的`LinkedList<T>`相比并不理想，后者构建得更加简单，并且不使用进行运行时借用检查的`RefCells`：
- en: '![](img/870e3231-79b6-4d11-b995-18007bf90028.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/870e3231-79b6-4d11-b995-18007bf90028.png)'
- en: Clearly, if you need a linked list, do not implement it yourself, `std::collections::LinkedList<T>`
    is excellent as far as linked lists go. Commonly, `Vec<T>` will perform better
    while providing more features, so unless the linked list is absolutely necessary,
    `Vec<T>` should be the default choice.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你需要链表，不要自己实现，`std::collections::LinkedList<T>` 在链表方面非常出色。通常，`Vec<T>` 会表现得更好，同时提供更多功能，所以除非链表绝对必要，否则
    `Vec<T>` 应该是默认选择。
- en: Maps and sets
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射和集合
- en: 'Rust''s maps and sets are based largely on two strategies: B-Tree search and
    hashing. They are very distinct implementations, but achieve the same results:
    associating a key with a value (map) and providing a fast unique collection based
    on keys (set).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的映射和集合主要基于两种策略：B-Tree 搜索和哈希。它们是两种非常不同的实现，但达到了相同的结果：将键与值关联（映射）以及基于键提供快速的唯一集合（集合）。
- en: Hashing in Rust works with a `Hasher` trait, which is a universal, stateful
    hasher, to create a hash value from an arbitrary byte stream. By repeatedly calling
    the appropriate `write()` function, data can be added to the hasher's internal
    state and finished up with the `finish()` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的哈希使用 `Hasher` 特征，它是一个通用的、有状态的哈希器，从任意字节流中创建哈希值。通过重复调用适当的 `write()` 函数，可以将数据添加到哈希器的内部状态，并通过
    `finish()` 函数完成。
- en: Unsurprisingly the B-Tree in Rust is highly optimized. The `BTreeMap` documentation
    provides rich details on why the regular implementation (as previously shown)
    is cache inefficient and not optimized for modern CPU architectures. Hence, they
    provide a more efficient implementation, which is definitely fascinating, and
    you should check it out in the source code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，B-Tree 的优化程度很高。`BTreeMap` 文档提供了丰富的细节，说明了为什么常规实现（如之前所示）在缓存效率低下，并且没有针对现代
    CPU 架构进行优化。因此，他们提供了一个更有效的实现，这绝对令人着迷，你应该在源代码中查看它。
- en: HashMap and HashSet
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashMap 和 HashSet
- en: Both `HashMap` and `HashSet` use a hashing algorithm to produce the unique key
    required for storing and retrieving values. Hashes are created with an instance
    of the `Hasher` trait (`DefaultHasher` if nothing is specified) for each key that
    implements the `Hash` and `Eq` traits. They allow a `Hasher` instance to be passed
    into the `Hash` implementor to generate the required output and the data structure
    to compare keys for equality.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 和 `HashSet` 都使用哈希算法来生成存储和检索值所需的唯一键。哈希是通过 `Hasher` 特征的实例（如果没有指定则为
    `DefaultHasher`）为每个实现了 `Hash` 和 `Eq` 特征的键创建的。它们允许将 `Hasher` 实例传递给 `Hash` 实现者以生成所需输出，并将数据结构用于比较键的相等性。'
- en: If a custom structure is to be used as a hashed key (for the map, or simply
    to store in the set), this implementation can be derived as well, which adds every
    field of the structure to the `Hasher`'s state. In case the trait is implemented
    by hand, it has to create equal hashes whenever two keys are equal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将自定义结构用作哈希键（用于映射，或者简单地存储在集合中），则也可以从该实现中派生出来，这会将结构的每个字段添加到 `Hasher` 的状态中。如果特徵是手动实现的，它必须为两个相等的键创建相等的哈希值。
- en: 'Since both data structures build on keys having implemented this trait, and
    both should be highly optimized, one question comes up: why bother with two variants?'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两种数据结构都基于实现了此特性的键，并且都应该高度优化，因此出现了一个问题：为什么需要两种变体？
- en: 'Let''s take a look into the source, shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看源代码，如下所示：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The rest of this section will only talk about `HashMap`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余部分将仅讨论 `HashMap`。
- en: Architecture
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: '`HashMap` is a highly optimized data structure that employs a performance heuristic
    called **Robin Hood hashing** to improve caching behavior, and thereby lookup
    times.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap` 是一种高度优化的数据结构，它使用一种称为 **Robin Hood 哈希** 的性能启发式方法来改善缓存行为，从而提高查找时间。'
- en: Robin Hood hashing is best explained together with the insertion algorithm linear
    probing, which is somewhat similar to the algorithm used in the hash map of the
    previous chapter. However, instead of an array of arrays (or `Vec<Vec<(K, V)>>`),
    the basic data structure is a flat array wrapped (together with all unsafe code)
    in a structure called `RawTable<K, V>`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Robin Hood 哈希最好与插入算法线性探测一起解释，这与上一章中使用的哈希表算法有些相似。然而，它不是数组数组的数组（或 `Vec<Vec<(K,
    V)>>`），基本数据结构是一个扁平数组，它被包裹在一个称为 `RawTable<K, V>` 的结构中（以及所有不安全的代码）。
- en: The table organizes its data into buckets (empty or full) that represent the
    data at a particular hash. Linear probing means that whenever a collision occurs
    (two hashes are equal without their keys being equal), the algorithm keeps looking
    into ("probing") the following buckets until an empty bucket is found.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表将数据组织成代表特定哈希值的桶（空或满）。线性探测意味着每当发生冲突（两个哈希值相等，而它们的键不相等）时，算法会继续查找（“探测”）下一个桶，直到找到一个空桶。
- en: The Robin Hood part is to count the steps from the original (ideal) position,
    and whenever an element in a bucket is closer to its ideal position (that is,
    richer), the bucket content is swapped, and the search continues with the element
    that was swapped out of its bucket. Thus, the search takes from the rich (with
    only a few steps removed from their ideal spot) and gives to the poor (those that
    are further away from their ideal spot).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 罗宾汉的部分是计算从原始（理想）位置的距离，每当桶中的元素更接近其理想位置（即更丰富）时，桶的内容就会交换，并且搜索继续使用从其桶中移出的元素。因此，搜索从富有（只有少量步骤远离理想位置）到贫穷（那些远离理想位置的人）。
- en: This strategy organizes the array into clusters around the hash values and greatly
    reduces the key variance, while improving CPU cache-friendliness. Another main
    factor that influences this behavior is the size of the table and how many buckets
    are occupied (called **load factor**). `DefaultResizePolicy` of `HashMap` changes
    the table's size to a higher power of two at a load factor of 90.9%—a number that
    provides ideal results for the Robin Hood bucket stealing. There are also some
    great ideas on how to manage that growth without having to reinsert every element,
    but they would certainly exceed the scope of this chapter. It's recommended to
    read the source's comments if you are interested (see *Further reading* section).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略将数组组织成以哈希值为中心的簇，大大减少了键值方差，同时提高了CPU缓存友好性。影响这种行为的另一个主要因素是表的大小以及有多少个桶被占用（称为**负载因子**）。`HashMap`的`DefaultResizePolicy`在负载因子为90.9%时将表的大小改变为2的更高次幂——这是一个为罗宾汉桶窃取提供理想结果的数量。还有一些关于如何管理这种增长而不必重新插入每个元素的好想法，但它们肯定超出了本章的范围。如果你对此感兴趣，建议阅读源代码的注释（见*进一步阅读*部分）。
- en: Insert
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: 'The Robin Hood hashing strategy already describes a large portion of the `insert`
    mechanism: hash the key value, look for an empty bucket, and reorder elements
    along the way according to their probing distance:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 罗宾汉哈希策略已经描述了`insert`机制的大部分内容：对键值进行哈希，寻找空桶，并在过程中根据它们的探测距离重新排列元素：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This function only does the first step and expands the basic data structure—if
    needed. The `insert_hashed_nocheck()` function provides the next step by searching
    for the hash in the existing table, and returning the appropriate bucket for it.
    The element is responsible for inserting itself into the right spot. The steps
    necessary to do that depend on whether the bucket is full or empty, which is modeled
    as two different structures: `VacantEntry` and `OccupiedEntry`. While the latter
    simply replaces the value (this is an update), `VacantEntry` has to find a spot
    not too far from the assigned bucket:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只执行第一步并扩展基本数据结构——如果需要的话。`insert_hashed_nocheck()`函数通过在现有表中搜索哈希值并提供相应的桶来提供下一步。元素负责将自己插入正确的位置。完成这一步骤所需的步骤取决于桶是满的还是空的，这被建模为两种不同的结构：`VacantEntry`和`OccupiedEntry`。后者简单地替换值（这是一个更新），而`VacantEntry`必须找到一个离分配的桶不太远的空位：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The call to `robin_hood()` executes the search and swap described earlier.
    One interesting variable here is the `DISPLACEMENT_THRESHOLD`. Does this mean
    that there is an upper limit of how many displacements a value can have? Yes!
    This value is `128` (so `128` misses are required), but it wasn''t chosen randomly.
    In fact, the code comments go into the details of why and how it was chosen, shown
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`robin_hood()`执行前面描述的搜索和交换。这里有一个有趣的变量是`DISPLACEMENT_THRESHOLD`。这难道意味着一个值可以有的位移上限吗？是的！这个值是`128`（因此需要`128`次错过），但这并不是随机选择的。实际上，代码注释详细说明了为什么以及如何选择这个值，如下所示：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As the comment states, the chance is *very* low that an element actually exceeds
    that threshold. Once a spot was found for every element, a look up can take place.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如评论所述，一个元素实际上超过该阈值的可能性*非常低*。一旦每个元素都找到了合适的位置，就可以进行查找。
- en: Lookup
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找
- en: 'Looking up entries is part of the insert process of `HashMap` and it relies
    on the same functions to provide a suitable entry instance to add data. Just like
    the insertion process, the lookup process does almost the same, save some steps
    in the end, listed as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 查找条目是`HashMap`的插入过程的一部分，它依赖于相同的函数来提供合适的条目实例以添加数据。就像插入过程一样，查找过程几乎相同，只是在最后省略了一些步骤，如下所示：
- en: Create a hash of the key
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建键的哈希
- en: Find the hash's bucket in the table
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表中找到哈希的桶
- en: Move away from the bucket comparing keys (linear search) until found
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离开桶比较键（线性搜索）直到找到
- en: 'Since all of this has already been implemented for use in other functions,
    `get()` is pretty short, shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些都已经实现并用于其他函数，`get()`相当短，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similarly, the `remove` function requires `search`, and removal is implemented
    on the entry type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`remove`函数需要`search`，并且删除是在条目类型上实现的。
- en: Remove
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: 'The `remove` function looks a lot like the `search` function, shown as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`函数看起来很像`search`函数，如下所示：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is one major difference: `search` returns a mutable bucket from which
    the key can be removed (or rather, the entire bucket since it''s now empty). `HashMap`
    turns out to be an impressive piece of code; can `BTreeMap` compete?'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个主要区别：`search`返回一个可变的桶，可以从其中删除键（或者更确切地说，是整个桶，因为它现在为空）。`HashMap`最终证明是一段令人印象深刻的代码；`BTreeMap`能与之竞争吗？
- en: BTreeMap and BTreeSet
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BTreeMap和BTreeSet
- en: Talking about B-Trees in [Chapter 5](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml),
    *Robust Trees*, their purpose is storing key-value pairs—ideal for a map-type
    data structure. Their ability to find and retrieve these pairs is achieved by
    effectively minimizing the number of comparisons required to get to (or rule out)
    a key. Additionally, a tree keeps the keys in order, which means iteration is
    going to be implicitly ordered. Compared to `HashMap`, this can be an advantage
    since it skips a potentially expensive step.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml)中讨论B树，*鲁棒树*，其目的是存储键值对——非常适合映射类型的数据结构。它们通过有效地最小化到达（或排除）键所需的比较次数来实现查找和检索这些对的能力。此外，树保持键的顺序，这意味着迭代将是隐式有序的。与`HashMap`相比，这可能是一个优点，因为它跳过了一个可能昂贵的步骤。
- en: Since—just like `HashSet`—`BTreeSet` simply uses `BTreeMap` with an empty value
    (only the key) underneath, only the latter is discussed in this section since
    the working is assumed to be the same. Again, let's start with the architecture.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于——就像`HashSet`一样——`BTreeSet`只是使用带有空值（只有键）的`BTreeMap`，因此本节只讨论后者，因为假设工作方式相同。再次，让我们从架构开始。
- en: Architecture
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: Rust's `BTreeMap` chose an interesting approach to maximize performance for
    search by creating large individual nodes. Recalling the typical sizes of nodes
    (that is, the number of children they have), they were more than two (root only),
    or half the tree's level to the tree's level number of children. In a typical
    B-Tree, the level rarely exceeds 10, meaning that the nodes stay rather small,
    and the number of comparisons within a node do too.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的`BTreeMap`选择了一种有趣的方法，通过创建大型单个节点来最大化搜索性能。回想一下节点的典型大小（即它们拥有的子节点数量），它们多于两个（只有根节点），或者树的水平数的一半到树的水平数的子节点数。在一个典型的B-Tree中，水平很少超过10，这意味着节点保持相当小，节点内的比较次数也相应较少。
- en: The implementors of the Rust `BTreeMap` chose a different strategy in order
    to improve caching behavior. In order to improve cache-friendliness and reduce
    the number of heap allocations required, Rusts' `BTreeMap` stores from *level
    - 1* to *2 * level - 1* number of elements per node, which results in a rather
    large array of keys.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Rust `BTreeMap`的实现者选择了一种不同的策略来改善缓存行为。为了提高缓存友好性和减少所需的堆分配次数，Rust的`BTreeMap`每个节点存储从*level
    - 1*到*2 * level - 1*个元素，这导致了一个相当大的键数组。
- en: While the opposite—small arrays of keys—fit the CPU's cache well enough, the
    tree itself has a larger number of them, so more nodes might need to be looked
    at. If the number of key-value pairs in a single node is higher, the overall node
    count shrinks, and if the key array still fits into the CPU's cache, these comparisons
    are as fast as they can be. The downside of larger arrays to search the key in
    is mitigated by using more intelligent searches (like binary search), so the overall
    performance gain of having fewer nodes outweighs the downside.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然——小数组的键——足以适应 CPU 的缓存，但树本身有更多的这些数组，因此可能需要查看更多的节点。如果一个节点中的键值对数量更高，整体节点数量就会减少，如果键数组仍然适合
    CPU 的缓存，这些比较就可以尽可能快地进行。使用更智能的搜索（如二分搜索）来减轻搜索键的大数组带来的缺点，因此拥有较少节点的整体性能提升超过了缺点。
- en: In general, when comparing the B-Tree from earlier in this book to `BTreeMap`,
    only a few similarities stand out, one of them being inserting a new element.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当将本书中较早提到的 B-Tree 与 `BTreeMap` 进行比较时，只有几个相似之处脱颖而出，其中之一就是插入新元素。
- en: Insert
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: 'Like every B-Tree, inserts are done by first searching a spot to insert, and
    then applying the split procedure in case the node has more than the expected
    number of values (or children). Insertion is split into three parts and it starts
    with the first method to be called, which glues everything together and returns
    an expected result:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个 B-Tree 一样，插入操作首先搜索插入的位置，然后如果节点具有超过预期数量的值（或子节点），则应用拆分过程。插入操作分为三个部分，它从要调用的第一个方法开始，该方法将一切粘合在一起并返回预期的结果：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second step is finding the handle for the node that the pair can be inserted
    into, shown as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是找到可以插入键值对的节点句柄，如下所示：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the handle is known, the entry (which is either a structure modeling a
    vacant or occupied spot) inserts the new key-value pair. If the entry was occupied
    before, the value is simply replaced—no further steps required. If the spot was
    vacant, the new value could trigger a tree rebalancing where the changes are bubbled
    up the tree:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道了句柄，条目（无论是模拟空位还是占用位的结构）就会插入新的键值对。如果条目之前是占用的，值将被简单地替换——不需要进一步的操作。如果位置是空的，新值可能会触发树的重平衡，其中更改会向上冒泡到树中：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Looking up keys is already part of the insert process, but it deserves a closer
    look too.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 查找键已经是插入过程的一部分，但也值得仔细看看。
- en: Look up
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找
- en: 'In a tree structure, inserts and deletes are based on looking up the keys that
    are being modified. In the case of `BTreeMap`, this is done by a function called
    `search_tree()` which is imported from the parent module:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在树结构中，插入和删除都是基于查找正在修改的键。在 `BTreeMap` 的情况下，这是通过从父模块导入的 `search_tree()` 函数完成的：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code itself is very easy to read, which is a good sign. It also avoids the
    use of recursion and uses a `loop{}` construct instead, which is a benefit for
    large lookups since Rust does not expand tail-recursive calls into loops (yet?).
    In any case, this function returns the node that the key resides in, letting the
    caller do the work of extracting the value and key from it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身非常易于阅读，这是一个好兆头。它还避免了递归的使用，而是使用 `loop{}` 构造，这对于大范围查找来说是一个优点，因为 Rust 目前还没有将尾递归调用展开成循环（？）。无论如何，这个函数返回键所在的节点，让调用者从该节点中提取值和键。
- en: Remove
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: The `remove` function wraps the occupied node's `remove_kv()` function, which
    removes a key-value pair from the handle that `search_tree()` unearthed. This
    removal also triggers a merging of nodes if a node now has less than the minimum
    amount of children.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 函数封装了被占用节点的 `remove_kv()` 函数，该函数从 `search_tree()` 挖掘出的句柄中删除一个键值对。这种删除还会触发节点合并，如果节点现在拥有的子节点数量少于最小数量。'
- en: Wrap up
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'As shown in this section, maps and sets have a lot in common and there are
    two ways that the Rust collections library provides them. `HashMap` and `HashSet`
    use a smart approach to finding and inserting values into buckets called Robin
    Hood hashing. Recalling the comparison benchmarks from [Chapter 6](95653045-6e1c-4ef7-bd0c-8e45b1ccfa1d.xhtml),
    *Exploring Maps and Sets*, it provided a more stable and significantly better
    performance over a naive implementation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节所示，映射和集合有很多共同之处，Rust 收集库提供了两种方式来实现它们。`HashMap` 和 `HashSet` 使用一种智能方法来查找和将值插入到称为
    Robin Hood 哈希的桶中。回想一下 [第 6 章](95653045-6e1c-4ef7-bd0c-8e45b1ccfa1d.xhtml) 的比较基准测试，*探索映射和集合*，它提供了一个更稳定且性能显著更好的实现：
- en: '![](img/6182aa28-e48e-4ff7-91cb-9b6846b469db.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6182aa28-e48e-4ff7-91cb-9b6846b469db.png)'
- en: '`BTreeMap` and `BTreeSet` are based on a different, more efficient implementation
    of a B-Tree. How much more efficient (and effective)? Let''s find out!'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`BTreeMap`和`BTreeSet`基于B-树的不同、更有效的实现。它有多高效（和有效）？让我们来看看！'
- en: '![](img/624801cf-0f59-4aea-9923-88f54cce1df4.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/624801cf-0f59-4aea-9923-88f54cce1df4.png)'
- en: For a naive implementation of a B-Tree (from [Chapter 5](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml),
    *Robust Trees*), the performance is not that bad. However, while there might be
    some tweaks to be added here and there, evidence shows that there is a better
    and faster tree out there, so why not use that?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于B-树的简单实现（来自第5章，*鲁棒树*），性能并不那么糟糕。然而，尽管可能需要在这里和那里做一些调整，但证据表明，有一个更好、更快的树存在，那么为什么不使用它呢？
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Rust standard library features a great collections part, providing a few
    highly optimized implementations of basic data structures.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库具有出色的集合部分，提供了一些基本数据结构的优化实现。
- en: We started with `Vec<T>` and `VecDeque<T>`, both based on a heap-allocated array
    and wrapped in the `RawVec<T>` structure. They show excellent performance while
    memory efficiency remains high, thanks to the array base and `unsafe` operations
    based on pointers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Vec<T>`和`VecDeque<T>`开始，它们都基于堆分配的数组，并封装在`RawVec<T>`结构中。由于数组基础和基于指针的`unsafe`操作，它们在保持内存效率高的同时表现出色。
- en: '`LinkedList<T>` is a doubly-linked list that performs really well, thanks to
    direct data manipulation and the lack of runtime checking. While it excels at
    splitting and merging, most other operations are slower than `Vec<T>` and it lacks
    some useful features.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`是一个双向链表，由于直接数据操作和缺乏运行时检查，它表现得很出色。虽然它在分割和合并方面表现优异，但大多数其他操作比`Vec<T>`慢，并且缺少一些有用的功能。'
- en: '`HashSet` and `HashMap` are based on the same implementation (`HashMap`) and—unless
    specified differently—use `DefaultHasher` to generate a hashed key of an object.
    This key is stored (and later retrieved) using the Robin Hood hashing method,
    which provides major performance benefits over a naive implementation.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet`和`HashMap`基于相同的实现（`HashMap`），除非指定不同，否则使用`DefaultHasher`来生成对象的哈希键。这个键使用罗宾汉哈希方法存储（并稍后检索），这种方法与原始实现相比提供了主要性能优势。'
- en: Alternatively, `BTreeSet` and `BTreeMap` use a B-Tree structure to organize
    keys and values. This implementation is also specialized and geared towards CPU-cache
    friendliness, and reducing the number of nodes (thereby minimizing the number
    of allocations) in order to create the high performance data structure that it
    is.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`BTreeSet`和`BTreeMap`使用B-树结构来组织键和值。这种实现也是专门化的，并且针对CPU缓存友好性进行优化，通过减少节点数量（从而最小化分配次数）来创建高性能的数据结构。
- en: 'In the next chapter, we will decrypt the O notation, something that has been
    used sparingly up until this point, but is necessary for what follows: algorithms.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解析O表示法，这是到目前为止使用得很少，但对于接下来的内容（算法）是必要的。
- en: Questions
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which `std::collections` data structure is not discussed here?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个`std::collections`数据结构在这里没有讨论？
- en: How does `Vec<T>` or `VecDeque<T>` grow as of 2018?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截至2018年，`Vec<T>`或`VecDeque<T>`是如何增长的？
- en: Is `LinkedList<T>` a good default data structure?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`是否是一个好的默认数据结构？'
- en: What hashing implementation does the 2018 `HashMap` use by default?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2018年的`HashMap`默认使用哪种哈希实现？
- en: What are three benefits of `BTreeMap` over a `HashMap`?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BTreeMap`相对于`HashMap`有哪些三个优点？'
- en: Is a `BTreeMap` internal tree wider or higher?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BTreeMap`的内部树是更宽还是更高？'
- en: Further reading
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for more information on topics covered
    in this chapter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接，了解更多关于本章涵盖主题的信息：
- en: '[https://doc.rust-lang.org/std/collections/index.html](https://doc.rust-lang.org/std/collections/index.html)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://doc.rust-lang.org/std/collections/index.html](https://doc.rust-lang.org/std/collections/index.html)'
- en: '[http://cglab.ca/~abeinges/blah/rust-btree-case/](http://cglab.ca/~abeinges/blah/rust-btree-case/)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://cglab.ca/~abeinges/blah/rust-btree-case/](http://cglab.ca/~abeinges/blah/rust-btree-case/)'
- en: '[https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#148](https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#148)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#148](https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#148)'
