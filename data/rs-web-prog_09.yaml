- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Testing Our Application Endpoints and Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的应用程序端点和组件
- en: Our to-do Rust application now fully works. We are happy with our first version
    as it manages authentication, different users, and their to-do lists, and logs
    our processes for inspection. However, a web developer’s job is never done.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务Rust应用程序现在完全工作。我们对我们的第一个版本感到满意，因为它管理着身份验证、不同用户及其待办事项列表，并记录我们的流程以供检查。然而，一个网络开发者的工作永远不会结束。
- en: While we have now come to the end of adding features to our application, we
    know that the journey does not stop here. In future iterations beyond this book,
    we may want to add teams, new statuses, multiple lists per user, and so on. However,
    as we add these features, we must ensure that our old application’s behavior stays
    the same unless we actively change it. This is done by building tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在已经完成了为我们的应用程序添加功能的工作，但我们知道旅程并没有在这里结束。在未来这本书之外的迭代中，我们可能希望添加团队、新的状态、每个用户的多列表等。然而，当我们添加这些功能时，我们必须确保我们的旧应用程序的行为保持不变，除非我们主动改变它。这是通过构建测试来实现的。
- en: In this chapter, we’ll build tests that check our existing behavior, laying
    down traps that will throw errors that report to us if the app’s behavior changes
    without us actively changing it. This prevents us from breaking the application
    and pushing it to a server after adding a new feature or altering the code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建检查我们现有行为的测试，设置陷阱，如果应用程序的行为在没有我们主动改变的情况下发生变化，则会抛出错误并报告给我们。这防止我们在添加新功能或更改代码后破坏应用程序并将其推送到服务器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building our unit tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的单元测试
- en: Building JWT unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建JWT单元测试
- en: Writing functional API tests in Postman
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Postman中编写功能API测试
- en: Automating Postman tests with Newman
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Newman自动化Postman测试
- en: Building an entire automated testing pipeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建整个自动化测试管道
- en: By the end of this chapter, we will understand how to build unit tests in Rust,
    inspecting our structs in detail with a range of edge cases. If our structs behave
    in a way we do not expect, our unit tests will report it to us.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将了解如何在Rust中构建单元测试，通过一系列边缘情况详细检查我们的结构体。如果我们的结构体以我们预料之外的方式表现，我们的单元测试将向我们报告。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we’ll build on the code built in [*Chapter 8*](B18722_08.xhtml#_idTextAnchor168),
    *Building RESTful Services*. This can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter08/caching](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter08/caching).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于第8章中构建的代码，即*构建RESTful服务*。这可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter08/caching](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter08/caching)找到。
- en: Node and NPM are also needed for installing and running the automated API tests,
    which can be found at [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Node和NPM也需要用于安装和运行自动化API测试，可以在[https://nodejs.org/en/download/](https://nodejs.org/en/download/)找到。
- en: We will also be running a part of the automated testing pipeline in Python.
    Python can be downloaded and installed at [https://www.python.org/downloads/](https://www.python.org/downloads/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将运行自动化测试管道的一部分，使用Python。Python可以从[https://www.python.org/downloads/](https://www.python.org/downloads/)下载并安装。
- en: 'You can find the full source code used in this chapter here: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章使用的完整源代码：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09)。
- en: Building our unit tests
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的单元测试
- en: In this section, we will explore the concept of unit tests and how to build
    unit test modules that contain tests as functions. Here, we are not going to achieve
    100% unit test coverage for our application. There are places in our application
    that can be covered by our functional tests, such as API endpoints and JSON serialization.
    However, unit tests are still important in some parts of our application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨单元测试的概念以及如何构建包含测试函数的单元测试模块。在这里，我们不会为我们的应用程序实现100%的单元测试覆盖率。在我们的应用程序中，有些地方可以通过我们的功能测试来覆盖，例如API端点和JSON序列化。然而，单元测试在我们的应用程序的某些部分仍然很重要。
- en: Unit tests enable us to look at some of our processes in more detail. As we
    saw with our logging in [*Chapter 8*](B18722_08.xhtml#_idTextAnchor168), *Building
    RESTful Services*, a functional test might work the way we want it to end-to-end,
    but there might be edge cases and behaviors that we do not want. This was seen
    in the previous chapter, where we saw our application make two `GET` calls when
    one was enough.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试使我们能够更详细地查看我们的某些流程。正如我们在[*第8章*](B18722_08.xhtml#_idTextAnchor168)“构建 RESTful
    服务”中看到的那样，一个功能测试可能按预期的方式从端到端工作，但可能会有我们不希望出现的边缘情况和行为。这在上一章中有所体现，我们看到了应用程序在只需要一个
    `GET` 请求的情况下进行了两次 `GET` 调用。
- en: In our unit tests, we will break down the processes one by one, mock certain
    parameters, and test the outcomes. These tests are fully isolated. The advantage
    of this is that we get to test a range of parameters quickly, without having to
    run a full process each time. This also helps us pinpoint exactly where the application
    is failing and with what configuration. Unit testing is also useful for test-driven
    development, where we build the components of a feature bit by bit, running the
    unit tests and altering the components as and when the test outcomes require.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单元测试中，我们将逐一分解流程，模拟某些参数，并测试结果。这些测试是完全隔离的。这种优势在于我们可以快速测试一系列参数，而无需每次都运行整个流程。这也帮助我们精确地确定应用程序失败的位置和配置。单元测试对于测试驱动开发也很有用，在那里我们逐步构建一个功能的组件，运行单元测试，并根据测试结果修改组件。
- en: In big, complex systems, this saves a lot of time as you do not have to spin
    up the app and run the full system to spot a typo or failure to account for an
    edge case.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型、复杂的系统中，这可以节省大量时间，因为你不需要启动应用程序并运行整个系统来查找错误或处理边缘情况。
- en: However, before we get too excited, we must acknowledge that unit testing is
    a tool, not a lifestyle, and there are some fallbacks to using it. The tests are
    only as good as their mocks. If we do not mock realistic interactions, then a
    unit test could pass but the application could fail. Unit tests are important,
    but they also must be accompanied by functional tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们过于兴奋之前，我们必须承认单元测试是一种工具，而不是一种生活方式，并且使用它有一些局限性。测试的质量取决于它们的模拟。如果我们不模拟真实的交互，那么单元测试可能会通过，但应用程序可能会失败。单元测试很重要，但它们也必须与功能测试相结合。
- en: Rust is still a new language, so at this point, unit testing support is not
    as advanced as with other languages such as Python or Java. For instance, with
    Python, we can mock any object from any file with ease at any point in the test.
    With these mocks, we can define outcomes and monitor interactions. While Rust
    does not have these mocks so readily available, this does not mean we cannot unit
    test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 仍然是一门新兴语言，因此到目前为止，单元测试的支持并不像 Python 或 Java 等其他语言那样先进。例如，在使用 Python 时，我们可以在测试的任何阶段轻松地模拟任何文件中的任何对象。有了这些模拟，我们可以定义结果并监控交互。虽然
    Rust 并没有这样现成的模拟，但这并不意味着我们不能进行单元测试。
- en: '*A bad craftsman always blames their tools*. The craftsmanship behind successful
    unit testing is constructing our code in such a way that individual code pieces
    won’t depend on each other, giving the pieces will have as much autonomy as possible.
    Because of this lack of dependency, testing can easily be performed without the
    necessity of having a complex mocking system.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*拙匠常怪其工具*。成功的单元测试背后的工艺是构建我们的代码，使各个代码块尽可能独立，这样各个部分就会尽可能具有自主性。正因为这种缺乏依赖性，测试可以很容易地进行，而无需复杂的模拟系统。'
- en: 'First, we can test our to-do structs. As you’ll remember, we have the `done`
    and `pending` structs, which inherit a `base` struct. We can start by unit testing
    the struct that has no dependencies and then move down to other structs that have
    dependencies. In our `src/to_do/structs/base.rs` file, we can define our unit
    tests for the `base` struct at the bottom of the file with the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以测试我们的待办事项结构体。如您所记得，我们有 `done` 和 `pending` 结构体，它们继承了一个 `base` 结构体。我们可以从单元测试没有依赖的结构体开始，然后向下移动到有依赖的其他结构体。在我们的
    `src/to_do/structs/base.rs` 文件中，我们可以在文件底部定义 `base` 结构体的单元测试，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we merely create a struct and assess the fields of that
    struct, ensuring that they are what we expect them to be. We can see that we created
    our `test` module, which is annotated with a `#[cfg(test)]` attribute. The `#[cfg(test)]`
    attribute is a conditional check where the code is only active if we run `cargo
    test`. If we do not run `cargo test`, the code annotated with `#[cfg(test)]` is
    not compiled.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们仅仅创建了一个结构体，并评估了该结构体的字段，确保它们是我们预期的。我们可以看到我们创建了一个带有`#[cfg(test)]`属性的`test`模块。`#[cfg(test)]`属性是一个条件检查，只有当我们运行`cargo
    test`时，代码才是活跃的。如果我们不运行`cargo test`，则带有`#[cfg(test)]`属性的代码不会被编译。
- en: nside the module, we will import the `Base` struct from the file outside of
    the `base_tests` module, which is still in the file. In the Rust world, it is
    typical to import what we are testing using `super`. There is a well-established
    standard to have the testing code right under the code that is being tested in
    the same file. We will then test the `Base::new` function by decorating our `new`
    function with a `#[``test]` attribute.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内部，我们将从`base_tests`模块外部的文件中导入`Base`结构体，该模块仍然位于文件中。在Rust的世界里，使用`super`导入我们正在测试的内容是典型的。有一个既定的标准，即测试代码应该位于同一文件中被测试代码的下方。然后，我们将通过在`new`函数上添加`#[test]`属性来测试`Base::new`函数。
- en: This is the first time we have covered attributes. An **attribute** is simply
    metadata applied to modules and functions. This metadata aids the compiler by
    giving it information. In this case, it is telling the compiler that this module
    is a test module and that the function is an individual test.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次介绍属性。**属性**简单来说就是应用于模块和函数的元数据。这些元数据通过提供信息来帮助编译器。在这种情况下，它是在告诉编译器这个模块是一个测试模块，而这个函数是一个单独的测试。
- en: 'However, if we run the preceding code, it would not work. This is because the
    `Eq` trait is not implemented in the `TaskStatus` enum, meaning that we cannot
    execute the following line of code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们运行前面的代码，它将不会工作。这是因为`TaskStatus`枚举中没有实现`Eq`特质，这意味着我们无法执行以下代码行：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This also means that we cannot use the `==` operator between two `TaskStatus`
    enums. Therefore, before we try and run our test, we will have to implement the
    `Eq` trait on the `TaskStatus` enum in the `src/to_do/structs/enums.rs` file with
    the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们无法在两个`TaskStatus`枚举之间使用`==`运算符。因此，在我们尝试运行测试之前，我们必须在`src/to_do/structs/enums.rs`文件中实现`TaskStatus`枚举的`Eq`特质，以下为相关代码：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see that we have implemented the `Eq` and `Debug` traits, which are
    needed for the `assert_eq!` macro. However, our test still will not run because
    we have not defined the rules around equating two `TaskStatus` enums. We could
    implement the `PartialEq` trait by simply adding the `PartialEq` trait to our
    derive annotation. However, we should explore how to write our own custom logic.
    To define the equating rules, we implement the `eq` function under the `PartialEq`
    trait with the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们已经实现了`Eq`和`Debug`特质，这些特质对于`assert_eq!`宏是必需的。然而，我们的测试仍然无法运行，因为我们还没有定义两个`TaskStatus`枚举之间等价的规则。我们可以通过简单地将`PartialEq`特质添加到我们的`derive`注解中来实现`PartialEq`特质。然而，我们应该探索如何编写我们自己的自定义逻辑。为了定义等价规则，我们在`PartialEq`特质下实现`eq`函数，以下为相关代码：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we can see that we manage to confirm if the `TaskStatus` enum is equal
    to the other `TaskStatus` enum being compared using two match statements. It seems
    more intuitive to use the `==` operator in the `eq` function; however, using the
    `==` operator calls the `eq` function resulting in an infinite loop. The code
    will still compile if you use the `==` operator in the `eq` function but if you
    run it you will get the following unhelpful error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们通过两个`match`语句成功确认了`TaskStatus`枚举是否等于正在比较的其他`TaskStatus`枚举。在`eq`函数中使用`==`运算符似乎更直观；然而，使用`==`运算符会调用`eq`函数，从而导致无限循环。如果你在`eq`函数中使用`==`运算符，代码仍然可以编译，但如果你运行它，你会得到以下无用的错误：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have now essentially created a new `base` struct and then checked to see
    if the fields are what we expected. To run this, run the `cargo test` functionality,
    pointing it to the file we want to test, which is denoted by the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在实际上创建了一个新的`base`结构体，然后检查字段是否符合我们的预期。要运行此操作，请使用`cargo test`功能，指向我们想要测试的文件，以下为相关命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see that our test was run and that it passed. Now, we’ll move on to
    writing tests for the rest of the module, which are the `Done` and `Pending` structs.
    Now is the time to see if you can write a basic unit test in the `src/to_do/structs/done.rs`
    file. If you have attempted to write a unit test for the `Done` struct in the
    `src/to_do/structs/done.rs` file, your code should look like the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的测试已经运行并通过了。现在，我们将继续编写模块其余部分的测试，这些部分是`Done`和`Pending`结构体。现在是时候看看你能否在`src/to_do/structs/done.rs`文件中编写一个基本的单元测试了。如果你已经尝试在`src/to_do/structs/done.rs`文件中为`Done`结构体编写单元测试，你的代码应该看起来像以下代码：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can run both tests with the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行这两个测试：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives the following output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下输出：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running `cargo test` runs all the tests across all Rust files. We can see that
    all our tests have now run and passed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo test`将在所有Rust文件中运行所有测试。我们可以看到现在所有的测试都已经运行并通过了。
- en: Now that we have done some basic testing, let’s look at the other modules that
    we can test. Our JSON serialization and views can be tested in our functional
    tests with **Postman**. Our database models do not have any advanced functionality
    that we have purposefully defined.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进行了一些基本的测试，让我们看看我们可以测试的其他模块。我们的JSON序列化和视图可以通过**Postman**在我们的功能测试中进行测试。我们的数据库模型没有我们故意定义的任何高级功能。
- en: Building JWT unit tests
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建JWT单元测试
- en: All our models do is read and write to the database. This has been shown to
    work. The only module left that we’ll unit test is the `auth` module. Here, we
    have some logic that has multiple outcomes based on the inputs. We also must do
    some mocking as some of the functions accept `actix_web` structs, which have certain
    fields and functions. Luckily for us, `actix_web` has a test module that enables
    us to mock requests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的模型所做的只是读取和写入数据库。这已经被证明是可行的。我们唯一剩下的要单元测试的模块是`auth`模块。在这里，我们有一些基于输入有多个结果的逻辑。我们还必须做一些模拟，因为一些函数接受`actix_web`结构体，这些结构体有特定的字段和函数。幸运的是，`actix_web`有一个测试模块，它使我们能够模拟请求。
- en: Building a configuration for tests
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建测试配置
- en: 'Before we start building our unit tests for the JWT, we must remember that
    there is a dependency on the `config` file to get the secret key. Unit tests must
    be isolated. They should not need to have the correct parameters passed into them
    to work. They should work every time in isolation. Because of this, we are going
    to have to build a `new` function for our `Config` struct in our `src/config.rs`
    file. The outline for the coding tests will look like the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为JWT构建单元测试之前，我们必须记住，有一个对`config`文件的依赖，以获取密钥。单元测试必须是隔离的。它们不应该需要传递正确的参数才能工作。它们应该每次都是隔离地工作。正因为如此，我们将在`src/config.rs`文件中为我们的`Config`结构体构建一个`new`函数。编码测试的大纲将看起来像以下代码：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding outline shows that there are two `new` functions. Our new `new`
    function gets compiled if tests are being run, and the old `new` function gets
    compiled if the server is running as normal. Our test `new` function has the standard
    values hardcoded in with the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述大纲显示有两个`new`函数。我们的新`new`函数在运行测试时被编译，如果服务器以正常方式运行，则旧`new`函数被编译。我们的测试`new`函数有标准值硬编码在以下代码中：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These default functions are the same as our development `config` file; however,
    we know that these variables are going to be consistent. We do not need to pass
    in anything when running the tests and we do not run the risk of reading another
    file. Now that our tests have been configured, we can define the requirements,
    including the configuration for our JWT tests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些默认函数与我们的开发`config`文件相同；然而，我们知道这些变量将是一致的。我们在运行测试时不需要传递任何东西，我们也不存在读取另一个文件的风险。现在我们的测试已经配置好了，我们可以定义要求，包括JWT测试的配置。
- en: Defining the requirements for JWT tests
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义JWT测试的要求
- en: 'Now that we have secured our `Config` struct for tests, we can go to our `src/jwt.rs`
    file and define the imports for our tests with the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为测试安全地构建了`Config`结构体，我们可以转到我们的`src/jwt.rs`文件，并使用以下代码定义测试的导入：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the preceding code, we can import a range of `actix_web` structs and functions
    to enable us to create fake HTTP requests and send them to a fake application
    to test how the `JwToken` struct works during the HTTP request process. We will
    also define a `ResponseFromTest` struct that can be processed to and from JSON
    to extract the user ID from the HTTP request as the `JwToken` struct houses the
    user ID. The `ResponseFromTest` struct is the HTTP response we are expecting to
    have so we are closely mocking the response object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码，我们可以导入一系列 `actix_web` 结构体和函数，使我们能够创建伪造的HTTP请求并将它们发送到伪造的应用程序以测试 `JwToken`
    结构体在HTTP请求过程中的工作情况。我们还将定义一个 `ResponseFromTest` 结构体，它可以被处理为JSON，以从HTTP请求中提取用户ID，因为
    `JwToken` 结构体包含了用户ID。`ResponseFromTest` 结构体是我们期望得到的HTTP响应，因此我们正在紧密模拟响应对象。
- en: 'Now that we have imported all that we need, we can define the outline of our
    tests with the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所有需要的，我们可以用以下代码定义测试的轮廓：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we can see that we test the getting of the key and the encoding and decoding
    of the token. They are native functions to the `JwToken` struct and, with what
    we have covered previously, you should be able to write them yourself. The other
    functions are decorated with `#[actix_web::test]`. This means that we are going
    to create fake HTTP requests to test how our `JwToken` implements the `FromRequest`
    trait. Now, there is nothing stopping us from writing the tests, which we will
    cover in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们测试了获取密钥和令牌的编码和解码。它们是 `JwToken` 结构体的原生函数，并且根据我们之前所讨论的，你应该能够自己编写它们。其他函数被装饰为
    `#[actix_web::test]`。这意味着我们将创建伪造的HTTP请求来测试我们的 `JwToken` 如何实现 `FromRequest` 特性。现在，没有什么阻止我们编写测试，我们将在下一节中介绍。
- en: Building basic function tests for JWT
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为JWT构建基本功能测试
- en: 'We will start with the most basic test, getting the key, which takes the following
    form:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最基础的测试开始，获取密钥，其形式如下：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We must remember that `"secret"` is the hardcoded key defined in the `Config::new`
    function for test implementations. If the test `Config::new` function works, the
    aforementioned test will work. Getting the expiry can also be important. Because
    we directly rely on the expiration minutes to be extracted from `config`, the
    following test will ensure that we are returning 120 minutes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住 `"secret"` 是在 `Config::new` 函数中硬编码的密钥，用于测试实现。如果 `Config::new` 测试函数工作正常，上述测试也将工作正常。获取过期时间也可能很重要。因为我们直接依赖于从
    `config` 中提取的过期分钟数，所以以下测试将确保我们返回120分钟：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now move on to test how invalid tokens are handled with the following
    test:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续测试如何处理无效令牌，以下是一个测试示例：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we pass in an `"invalid_token"` string that should fail the decoding process
    because it is clearly not a valid token. We will then match the outcome. If the
    outcome is an error, we will then assert that the message is that the error is
    a result of an invalid token. If there is any other output apart from an error,
    then we throw an error failing the test because we expect the decode to fail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递一个 `"invalid_token"` 字符串，它应该会失败解码过程，因为它显然不是一个有效的令牌。然后我们将匹配结果。如果结果是错误，我们将断言错误信息是无效令牌的结果。如果有任何其他输出而不是错误，那么我们将抛出一个错误，使测试失败，因为我们期望解码会失败。
- en: 'Now that we have written two tests for our `JwToken` struct functions, this
    is a good time for you to attempt to write the test for encoding and decoding
    a token. If you have attempted to write the encoding and decoding test, it should
    look like the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的 `JwToken` 结构体函数编写了两个测试，这是一个很好的时机让你尝试编写编码和解码令牌的测试。如果你尝试编写了编码和解码测试，它应该看起来像以下代码：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding test essentially boils down the login and authenticated request
    process around the token. We create a new token with a user ID, encode the token,
    and then decode the token testing to see if the data we passed into the token
    is the same as we get out when we decode it. If we don’t, then the test will fail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试实际上将登录和认证请求过程简化为围绕令牌。我们创建一个新的带有用户ID的令牌，对令牌进行编码，然后解码令牌以测试我们传递到令牌中的数据是否与我们解码时得到的数据相同。如果不相同，则测试将失败。
- en: 'Now that we have finished testing the functions for the `JwToken` struct, we
    can move on to testing how the `JwToken` struct implements the `FromRequest` trait.
    Before we do this, we must define a basic view function that will merely handle
    the authentication of `JwToken` and then returns the user ID from the token with
    the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对`JwToken`结构体函数的测试，我们可以继续测试`JwToken`结构体如何实现`FromRequest`特质。在我们这样做之前，我们必须定义一个基本的视图函数，该函数将仅处理`JwToken`的认证，然后返回令牌中的用户ID，以下代码所示：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is nothing new, in fact, this outline is also how we define our views in
    our application. With our basic tests defined, we can move on to building tests
    for web requests.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是什么新东西，事实上，这个大纲也是我们定义应用程序中视图的方式。有了我们的基本测试定义，我们可以继续构建针对Web请求的测试。
- en: Building tests for web requests
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Web请求的测试
- en: 'We can now test our test view to see how it handles a request with no token
    in the header with the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下代码来测试我们的测试视图，看看它如何处理头部没有令牌的请求：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we can see that we can create a fake server and attach
    our `test_handler` test view to it. We can then create a fake request that does
    not have any token in the header. We will then call the server with the fake request,
    then assert that the response code of the request is unauthorized. We can now
    create a test that inserts a valid token with the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们可以创建一个假服务器并将我们的`test_handler`测试视图附加到它上。然后我们可以创建一个没有令牌的假请求。然后我们将使用假请求调用服务器，并断言请求的响应代码为未授权。我们现在可以创建一个插入有效令牌的测试，以下代码所示：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we can see that we create a valid token. We can create our fake server
    and attach our `test_handler` function to that fake server. We will then create
    a request that can be mutated. Then, we will insert the token into the header
    and call the fake server with the fake request, using the `call_and_read_body_json`
    function. It must be noted that when we call the `call_and_read_body_json` function,
    we declare that the type returned under the `resp` variable name to be `ResponseFromTest`.
    We then assert that the user ID is from the request response.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们创建了一个有效的令牌。我们可以创建我们的假服务器并将我们的`test_handler`函数附加到那个假服务器上。然后我们将创建一个可以变异的请求。然后，我们将令牌插入到头部，并使用`call_and_read_body_json`函数调用假服务器，使用假请求。必须注意的是，当我们调用`call_and_read_body_json`函数时，我们声明在`resp`变量名下返回的类型是`ResponseFromTest`。然后我们断言用户ID来自请求响应。
- en: 'Now that we have seen how to create a fake HTTP request with a header, this
    is a good opportunity for you to try and build the test that makes a request with
    a fake token that cannot be decoded. If you have attempted this, it should look
    like the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建带有头部的假HTTP请求，这是一个很好的机会让你尝试构建一个请求带有无法解码的假令牌的测试。如果你已经尝试过，它应该看起来像以下代码：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Looking at the following code, we can see that we inserted a false token into
    the header using the approach laid out in the passing token request test with
    the unauthorized assertion used in the test with no token provided. If we run
    all the tests now, we should get the following printout:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下代码，我们可以看到我们使用在通过令牌请求测试中概述的方法将一个假令牌插入到头部，并在没有提供令牌的测试中使用未授权断言。如果我们现在运行所有测试，我们应该得到以下输出：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: From the preceding output, our `jwt` and `to_do` modules are now fully unit-tested.
    Considering that Rust is still a new language, we have managed to painlessly unit
    test our code because we structured our code in a modular fashion.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们的`jwt`和`to_do`模块现在已经完全进行了单元测试。考虑到Rust仍然是一种新的语言，我们设法无痛地单元测试了我们的代码，因为我们以模块化的方式结构了我们的代码。
- en: The `tests` crate that `actix_web` provided enabled us to test edge cases quickly
    and easily. In this section, we tested how our functions processed requests with
    missing tokens, false tokens, and correct tokens. We have seen first-hand how
    Rust enables us to run unit tests on our code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`actix_web`提供的`tests` crate使我们能够快速轻松地测试边缘情况。在本节中，我们测试了我们的函数如何处理缺少令牌、假令牌和正确令牌的请求。我们亲眼见证了Rust如何使我们能够在代码上运行单元测试。'
- en: Everything is configured with `cargo`. We do not have to set up paths, install
    extra modules, or configure environment variables. All we must do is define modules
    with the `test` attribute and run the `cargo test` command. However, we must remember
    that our views and JSON serialization code are not unit-tested. This is where
    we switch to Postman to test our API endpoints.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的配置都是通过`cargo`完成的。我们不需要设置路径，安装额外的模块，或配置环境变量。我们只需使用`test`属性定义模块，并运行`cargo test`命令。然而，我们必须记住，我们的视图和JSON序列化代码没有进行单元测试。这就是我们切换到Postman来测试我们的API端点的原因。
- en: Writing tests in Postman
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Postman中编写测试
- en: 'In this section, we will be implementing functional integration tests using
    Postman to test our API endpoints. This will test our JSON processing and database
    access. To do this, we will follow these steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Postman实现功能集成测试，以测试我们的API端点。这将测试我们的JSON处理和数据库访问。为此，我们将遵循以下步骤：
- en: 'We are going to have to create a test user for our Postman tests. We can do
    this with the JSON body shown as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不得不为我们的Postman测试创建一个测试用户。我们可以使用以下JSON体来完成此操作：
- en: '[PRE23]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We need to add a `POST` request to the `http://127.0.0.1:8000/v1/user/create`
    URL. Once we have done this, we can use our login endpoint for our Postman tests.
    Now that we have created our test user, we must get the token from the response
    header of the `POST` request to the `http://127.0.0.1:8000/v1/auth/login` URL
    with the JSON request body:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向`http://127.0.0.1:8000/v1/user/create` URL添加一个`POST`请求。一旦完成，我们就可以使用我们的登录端点进行Postman测试。现在我们已经创建了测试用户，我们必须从`http://127.0.0.1:8000/v1/auth/login`
    URL的`POST`请求响应头中获取令牌：
- en: '[PRE28]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This gives us the following Postman layout:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下Postman布局：
- en: '![Figure 9.1 – Creating a new use Postman request](img/Figure_9.1_B18722.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 创建新的使用Postman请求](img/Figure_9.1_B18722.jpg)'
- en: Figure 9.1 – Creating a new use Postman request
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 创建新的使用Postman请求
- en: 'With this token, we have all the information needed to create our Postman collection.
    Postman is a collection of API requests. In this collection, we can bunch all
    our to-do item API calls together using the user token as authentication. The
    result of the call is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此令牌，我们拥有创建我们的Postman集合所需的所有信息。Postman是一组API请求。在这个集合中，我们可以使用用户令牌作为认证，将所有待办事项API调用组合在一起。调用结果如下：
- en: '![Figure 9.2 – Creating new use Postman response](img/Figure_9.2_B18722.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 创建新的使用Postman响应](img/Figure_9.2_B18722.jpg)'
- en: Figure 9.2 – Creating new use Postman response
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 创建新的使用Postman的响应
- en: 'We can create our collection with the following Postman button, that is, **+**
    **New Collection**:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下Postman按钮创建我们的集合，即**+** **新建集合**：
- en: '![Figure 9.3 – Creating new Postman collection](img/Figure_9.3_B18722.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 创建新的Postman集合](img/Figure_9.3_B18722.jpg)'
- en: Figure 9.3 – Creating new Postman collection
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 创建新的Postman集合
- en: 'Once we have clicked this, we must make sure that our user token is defined
    for the collection, as all to-do item API calls need the token. This can be done
    by using the **Authorization** configuration for our API calls, as seen in the
    following screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击此按钮后，我们必须确保我们的用户令牌已为集合定义，因为所有待办事项API调用都需要令牌。这可以通过使用API调用的**授权**配置来完成，如下面的截图所示：
- en: '![Figure 9.4 – Defining AUTH credentials in a new Postman collection](img/Figure_9.4_B18722.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 在新的Postman集合中定义AUTH凭据](img/Figure_9.4_B18722.jpg)'
- en: Figure 9.4 – Defining AUTH credentials in a new Postman collection
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 在新的Postman集合中定义AUTH凭据
- en: We can see that we have merely copied and pasted our token into the value with
    **token** as the key, which will be inserted into the header of the requests.
    This should now be passed in all our requests in the collection. This collection
    is now stored on the left-hand side navigation bar under the **Collections** tab.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们只是将令牌复制粘贴到以**token**为键的值中，这将插入到请求的头部。现在这个令牌应该被传递到集合中的所有请求中。这个集合现在存储在左侧导航栏的**集合**选项卡下。
- en: 'We have now configured our collection and can now add requests under the collection
    by clicking the grayed-out **Add Request** button shown in this screenshot:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经配置了我们的集合，并且现在可以通过点击此截图所示的灰色**添加请求**按钮在集合下添加请求：
- en: '![Figure 9.5 – Creating a new request for our Postman collection](img/Figure_9.5_B18722.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 为我们的Postman集合创建新的请求](img/Figure_9.5_B18722.jpg)'
- en: Figure 9.5 – Creating a new request for our Postman collection
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 为我们的Postman集合创建新的请求
- en: Now, we must think about our approach to testing the flow of testing as this
    has to be self-contained.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须考虑我们测试流程的方法，因为这必须是一个自包含的过程。
- en: Writing ordered requests for tests
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试的有序请求
- en: 'Our requests will take the following order:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的要求将按以下顺序进行：
- en: '**Create**: Create a to-do item, then check the return to see if it is stored
    correctly.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建**：创建一个待办事项，然后检查返回值以查看它是否已正确存储。'
- en: '**Create**: Create another to-do item, checking the return to see if the previous
    one is stored and that the process can handle two items.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建**：创建另一个待办事项，检查返回值以查看前一个是否已存储，并且流程可以处理两个项目。'
- en: '**Create**: Create another to-do item with the same title as one of the other
    items, checking the response to ensure that our application is not storing duplicate
    to-do items with the same title.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建**：创建另一个与另一个项目具有相同标题的待办事项，检查响应以确保我们的应用程序不会存储具有相同标题的重复待办事项。'
- en: '**Edit**: Edit an item, checking the response to see if the edited item has
    been changed to *done* and that it is stored in the correct list.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑**：编辑一个项目，检查响应以查看编辑后的项目是否已更改状态为*完成*，并且是否已存储在正确的列表中。'
- en: '**Edit**: Edit the second item to see if the *edit* effect is permanent and
    that the *done* list supports both items.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑**：编辑第二个项目，以查看*编辑*效果是否是永久的，以及*完成*列表是否支持两个项目。'
- en: '**Edit**: Edit an item that is not present in the application to see if the
    application handles this correctly.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑**：编辑应用程序中不存在的项目，以查看应用程序是否正确处理这种情况。'
- en: '**Delete**: Delete one to-do item to see if the response no longer returns
    the deleted to-do item, meaning that it is no longer stored in the database.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除**：删除一个待办事项以查看响应是否不再返回被删除的待办事项，这意味着它不再存储在数据库中。'
- en: '**Delete**: Delete the final to-do item, checking the response to see if there
    are no items left, showing that the *delete* action is permanent.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除**：删除最后一个待办事项，检查响应以查看是否没有剩余项目，这表明*删除*操作是永久的。'
- en: 'We need to run the preceding tests for them to work as they rely on the previous
    action being correct. When we create a request for the collection, we must be
    clear about what the request is doing, which step it is on, and what type of request
    it is. For instance, creating our first *create* test will look like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要运行前面的测试，因为它们依赖于前面的操作是正确的。当我们为集合创建请求时，我们必须清楚请求正在做什么，它处于哪个步骤，以及它是什么类型的请求。例如，创建我们的第一个*创建*测试将如下所示：
- en: '![Figure 9.6 – Creating our first Postman create request](img/Figure_9.6_B18722.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 创建我们的第一个Postman创建请求](img/Figure_9.6_B18722.jpg)'
- en: Figure 9.6 – Creating our first Postman create request
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 创建我们的第一个Postman创建请求
- en: As we can see, the step is appended with the type by an underscore. We then
    put the description of the test from the list in the **Request description (Optional)**
    field. When defining the request, you may realize that the API key is not in the
    header of the request.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，步骤通过下划线附加了类型。然后我们将测试列表中的测试描述放入**请求描述（可选）**字段。在定义请求时，你可能会意识到API密钥不在请求的标题中。
- en: This is because it is in the hidden autogenerated headers of the request. Our
    first request must be a `POST` request with the `http://127.0.0.1:8000/v1/item/create/washing`
    URL.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它位于请求的隐藏自动生成标题中。我们的第一个请求必须是一个`POST`请求，带有`http://127.0.0.1:8000/v1/item/create/washing`
    URL。
- en: 'This creates the to-do item *washing*. However, before we click the **Send**
    button, we must move over to the **Tests** tab in our Postman request, just to
    the left of the **Settings** tab, to write our tests as seen in the following
    screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了待办事项*洗涤*。然而，在我们点击**发送**按钮之前，我们必须切换到Postman请求中的**测试**选项卡，就在**设置**选项卡的左侧，以便编写以下截图所示的测试：
- en: '![Figure 9.7 – Accessing the tests script in Postman](img/Figure_9.7_B18722.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 在Postman中访问测试脚本](img/Figure_9.7_B18722.jpg)'
- en: Figure 9.7 – Accessing the tests script in Postman
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 在Postman中访问测试脚本
- en: 'Our tests must be written in JavaScript. However, we can get access to Postman’s
    `test` library by typing `pm` into the test script. First, at the top of the test
    script, we need to process the request, which is done with this code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须用JavaScript编写测试。然而，我们可以通过在测试脚本中键入`pm`来访问Postman的`test`库。首先，在测试脚本顶部，我们需要处理请求，这是通过以下代码完成的：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With the preceding line, we can access the response JSON throughout the test
    script. To comprehensively test our request, we need to follow these steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的行，我们可以在整个测试脚本中访问响应JSON。为了全面测试我们的请求，我们需要遵循以下步骤：
- en: 'First, we need to check the basic content of the response. Our first test is
    to check to see if the response is `200`. This can be done with the following
    code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要检查响应的基本内容。我们的第一个测试是检查响应是否为`200`。这可以通过以下代码完成：
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we define the test description. Then, the function that the test runs
    is defined.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义测试描述。然后，定义测试运行的函数。
- en: 'Then, we check the length of data in the response. After the preceding test,
    we will define our test to check if the pending item has a length of one via the
    following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查响应中的数据长度。在先前的测试之后，我们将定义以下代码来检查待办事项的长度是否为1：
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we do a simple check of the length and throw an error
    if the length is not one as we only expect one pending item in the `pending_items`
    list.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们进行了一个简单的长度检查，如果长度不是一，则抛出错误，因为我们只期望`pending_items`列表中有一个待办事项。
- en: 'Then, we inspect the title and status of the pending item in the following
    code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在以下代码中检查待办事项的标题和状态：
- en: '[PRE42]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding code, we throw an error if the status or title does not match
    what we want. Now we have satisfied our tests for the pending items, we can move
    on to the tests for the done items.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果状态或标题不符合我们的预期，我们将抛出错误。现在我们已经满足了待办事项的测试，我们可以继续对已完成事项进行测试。
- en: 'Seeing as our done items should be zero, the tests have the following definition:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的已完成事项应该是零，测试的定义如下：
- en: '[PRE59]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding code, we are merely ensuring that the `done_items` array has
    a length of zero.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是确保`done_items`数组长度为零。
- en: 'Now, we must check the counts of our done and pending items. This is done in
    the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须检查已完成和待办事项的数量。这可以通过以下代码完成：
- en: '[PRE65]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now that our tests are built, we can make the request by clicking the **SEND**
    button in Postman to get the following output for the tests:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了测试，我们可以通过点击Postman中的**发送**按钮来发出请求，以获取以下测试输出：
- en: '![Figure 9.8 – Postman tests output](img/Figure_9.8_B18722.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – Postman测试输出](img/Figure_9.8_B18722.jpg)'
- en: Figure 9.8 – Postman tests output
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – Postman测试输出
- en: We can see that our test descriptions and the status of the test are highlighted.
    If you get an error the status will be red with a **FAIL**. Now that our first
    create test has been done, we can create our second create test.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的测试描述和测试状态被突出显示。如果你得到一个错误，状态将是红色，显示**FAIL**。现在我们的第一个创建测试已经完成，我们可以创建第二个创建测试。
- en: Creating a test for an HTTP request
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个HTTP请求的测试
- en: 'We can then create the `2_create` test with this URL: `http://127.0.0.1:8000/v1/item/create/cooking`.
    This is a good opportunity to try and build the test yourself with the testing
    methods that we have explored in the previous step. If you have attempted to build
    the tests, they should look like the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用此URL创建`2_create`测试：`http://127.0.0.1:8000/v1/item/create/cooking`。这是一个尝试使用我们在上一步中探索的测试方法自己构建测试的好机会。如果你尝试构建测试，它们应该看起来像以下代码：
- en: '[PRE77]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We can see that we have added a couple of extra tests on the second pending
    item. The preceding tests also directly apply to the `3_create` test as a duplicate
    creation will be the same as we will be using the same URL as `2_create`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们在第二个待办事项上添加了一些额外的测试。前面的测试也直接适用于`3_create`测试，因为重复创建将与我们将使用与`2_create`相同的URL相同。
- en: 'The preceding tests require a fair amount of repetition in these tests, slightly
    altering the length of arrays, item counts, and attributes within these arrays.
    This is a good opportunity to practice basic Postman tests. If you need to cross-reference
    your tests with mine, you can assess them in the JSON file at the following URL:
    [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/blob/main/chapter09/building_test_pipeline/web_app/scripts/to_do_items.postman_collection.json](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/blob/main/chapter09/building_test_pipeline/web_app/scripts/to_do_items.postman_collection.json).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试在这些测试中需要相当多的重复，稍微改变数组的长度、项目计数和数组内的属性。这是一个练习基本Postman测试的好机会。如果你需要将你的测试与我的测试进行交叉引用，你可以在以下URL的JSON文件中评估它们：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/blob/main/chapter09/building_test_pipeline/web_app/scripts/to_do_items.postman_collection.json](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/blob/main/chapter09/building_test_pipeline/web_app/scripts/to_do_items.postman_collection.json)。
- en: In this section, we have put in a series of steps for Postman to test when an
    API call is made. This is not just useful for our application. Postman can hit
    any API on the internet it has access to. Therefore, you can use Postman tests
    to monitor live servers and third-party APIs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为Postman测试当API调用时执行了一系列步骤。这不仅对我们应用程序有用。Postman可以访问互联网上的任何API。因此，您可以使用Postman测试来监控实时服务器和第三方API。
- en: Now, running all these tests can be arduous if it must be done manually every
    time. We can automate the running and checking of all the tests in this collection
    using **Newman**. If we automate these collections, we can run tests at certain
    times every day on live servers and third-party APIs we rely on, alerting us to
    when our servers or the third-party API breaks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果必须手动每次运行所有这些测试，可能会很费力。我们可以使用**新曼**自动化运行和检查这个集合中的所有测试。如果我们自动化这些集合，我们可以在每天特定时间运行测试，以实时服务器和我们所依赖的第三方API，并在我们的服务器或第三方API出现问题时提醒我们。
- en: Newman will give us a good foundation for further development in this area.
    In the next section, we’ll export the collection and run all the API tests in
    the exported collection in sequence using Newman.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 新曼将为我们在这个领域进一步开发提供一个良好的基础。在下一节中，我们将导出集合，并使用新曼按顺序运行导出集合中的所有API测试。
- en: Automating Postman tests with Newman
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新曼自动化Postman测试
- en: 'To automate the series of tests, in this section, we will export our to-do
    item Postman collection in the correct sequence. But first, we must export the
    collection as a JSON file. This can be done by clicking on our collection in Postman
    on the left-hand navigation bar and clicking the grayed-out **Export** button,
    as seen in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化一系列测试，在本节中，我们将按照正确的顺序导出我们的待办事项Postman集合。但首先，我们必须将集合导出为JSON文件。这可以通过在Postman的左侧导航栏中点击我们的集合，然后点击灰色显示的**导出**按钮来完成，如以下截图所示：
- en: '![Figure 9.9 – Exporting our Postman collection](img/Figure_9.9_B18722.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 导出我们的Postman集合](img/Figure_9.9_B18722.jpg)'
- en: Figure 9.9 – Exporting our Postman collection
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 导出我们的Postman集合
- en: 'Now that we have exported the collection, we can quickly inspect it to see
    how the file is structured. The following code defines the header of the suite
    of tests:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导出了集合，我们可以快速检查它以查看文件是如何结构的。以下代码定义了测试套件的头部：
- en: '[PRE78]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The preceding code tells Postman what schema is needed to run the tests. If
    the code is imported into Postman, the ID and name will be visible. The file then
    goes on to define the individual tests via the code given as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码告诉Postman需要什么模式来运行测试。如果代码被导入到Postman中，ID和名称将可见。然后文件继续通过以下代码定义单个测试：
- en: '[PRE79]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: From the preceding code, we can see that our tests, method, URL, headers, and
    more are all defined in an array. A quick inspection of the `item` array will
    show that the tests will be executed in the order that we want.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中，我们可以看到我们的测试、方法、URL、头部等都在一个数组中定义。快速检查`item`数组将显示测试将按照我们想要的顺序执行。
- en: 'Now, we can simply run it with Newman. We can install Newman with the following
    command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地使用新曼运行它。我们可以使用以下命令安装新曼：
- en: '[PRE80]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'It must be noted that the preceding command is a global install, which can
    sometimes have issues. To avoid this, you can setup a `package.json` file with
    the following contents:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，上述命令是一个全局安装，有时可能会出现问题。为了避免这种情况，你可以设置一个包含以下内容的`package.json`文件：
- en: '[PRE81]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'With this `package.json`, we have defined the test command and the Newman dependency.
    We can install our dependencies locally with the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`package.json`，我们已经定义了测试命令和新曼依赖。我们可以使用以下命令在本地上安装我们的依赖项：
- en: '[PRE82]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This then installs all we need under the `node_modules` directory. Instead
    of running the Newman test command directly, we can use the test command defined
    in `package.json` with the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`node_modules`目录下安装我们所需的所有内容。我们不必直接运行新曼测试命令，可以使用`package.json`中定义的测试命令，使用以下命令：
- en: '[PRE83]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now that we have installed Newman, we can run the collection of tests against
    the exported collection JSON file with this command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了新曼，我们可以使用以下命令运行测试集合对导出的集合JSON文件进行测试：
- en: '[PRE84]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding command runs all the tests and gives us a status report. Each
    description is printed out and the status is also denoted by the side of the test.
    The following is a typical printout of an API test being assessed:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令运行所有测试并给出状态报告。每个描述都打印出来，测试的状态也在测试旁边表示。以下是一个典型的API测试评估的打印输出：
- en: '[PRE85]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The preceding output gives us the name, method, URL, and response. Here, all
    of them passed. If one did not, then the test description would sport a *cross*
    instead of a *tick*. We also get the following summary:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出给出了名称、方法、URL 和响应。在这里，所有这些都通过了。如果其中任何一个没有通过，那么测试描述将显示一个 *叉* 而不是 *勾*。我们还得到了以下摘要：
- en: '![Figure 9.10 – Newman summary](img/Figure_9.10_B18722.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – Newman 摘要](img/Figure_9.10_B18722.jpg)'
- en: Figure 9.10 – Newman summary
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – Newman 摘要
- en: We can see that all our tests passed. With this, we have managed to automate
    our functional testing, enabling us to test a full workflow with minimal effort.
    However, what we have done is not maintainable. For instance, our token will expire,
    meaning that if we run tests later in the month, they will fail. In the next section,
    we will build an entire automated pipeline that will build our server, update
    our token, and run our tests.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有测试都通过了。通过这种方式，我们已经成功自动化了我们的功能测试，使我们能够以最小的努力测试完整的流程。然而，我们所做的是不可维护的。例如，我们的令牌将过期，这意味着如果我们在本月稍后运行测试，它们将失败。在下一节中，我们将构建一个完整的自动化流程，该流程将构建我们的服务器，更新我们的令牌，并运行我们的测试。
- en: Building an entire automated testing pipeline
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建整个自动化测试流程
- en: 'When it comes to development and testing, we need an environment that can be
    torn down and recreated easily. There is nothing worse than building up data in
    a database on your local machine to be able to develop further features using
    that data. However, the database container might be deleted by accident, or you
    may write some code that corrupts the data. Then, you must spend a lot of time
    recreating the data before you can get back to where you were. If the system is
    complex and there is missing documentation, you might forget the steps needed
    to recreate your data. If you are not comfortable with destroying your local database
    and starting again when developing and testing, there is something wrong and it
    is only a matter of time before you get caught out. In this section, we are going
    to create a single Bash script that carries out the following actions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和测试方面，我们需要一个可以轻松拆解和重建的环境。没有什么比在你的本地机器上构建数据库中的数据来进一步开发使用这些数据的功能更糟糕的了。然而，数据库容器可能会意外删除，或者你可能编写了一些损坏数据的代码。然后，你必须花费大量时间重新创建数据，才能回到之前的状态。如果系统复杂且缺少文档，你可能会忘记重新创建数据所需的步骤。如果你在开发和测试时对销毁本地数据库并重新开始感到不舒服，那么就有问题，而且你被抓住只是时间问题。在本节中，我们将创建一个单个
    Bash 脚本，该脚本执行以下操作：
- en: Starts database Docker containers in the background.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台启动数据库 Docker 容器。
- en: Compiles the Rust server.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译 Rust 服务器。
- en: Runs unit tests.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行单元测试。
- en: Starts running the Rust server.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Rust 服务器运行。
- en: Runs migrations to the database running in Docker.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将迁移运行在 Docker 中的数据库。
- en: Makes an HTTP request to create a user.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送 HTTP 请求创建用户。
- en: Makes an HTTP request to log in and get a token.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送 HTTP 请求进行登录并获取令牌。
- en: Updates the Newman JSON file with the token from the login.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用登录令牌更新 Newman JSON 文件。
- en: Runs the Newman tests.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Newman 测试。
- en: Removes the files produced in this whole process.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除整个过程中产生的文件。
- en: Stops the Rust server from running.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止 Rust 服务器运行。
- en: Stops and destroy the Docker containers that were running for the whole process.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止并销毁整个过程中运行的 Docker 容器。
- en: There are a lot of steps laid out in the preceding list. Glancing at this list,
    it would seem intuitive to break the code blocks that we are going to explore
    into steps; however, we are going to run nearly all the steps in one Bash script.
    A lot of the preceding steps outlined can be achieved in one line of Bash code
    each. It would be excessive to break the code down into steps. Now that we have
    all the steps needed, we can set up our testing infrastructure. First, we need
    to set up a `scripts` directory alongside the `src` directory in the root of `web_app`.
    Inside the `scripts` directory, we then need to have a `run_test_pipeline.sh`
    script that will run the main testing process. We also need to put our Newman
    JSON `config` file in the `scripts` directory.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表中列出了许多步骤。浏览这个列表，直观地似乎应该将我们要探索的代码块分解成步骤；然而，我们将几乎在单个 Bash 脚本中运行所有这些步骤。许多前面概述的步骤可以用一行
    Bash 代码实现。将代码分解成步骤将是多余的。现在我们已经拥有了所有需要的步骤，我们可以设置我们的测试基础设施。首先，我们需要在 `web_app` 根目录中
    `src` 目录旁边设置一个 `scripts` 目录。然后在 `scripts` 目录中，我们需要一个 `run_test_pipeline.sh` 脚本，该脚本将运行主要的测试过程。我们还需要将我们的
    Newman JSON `config` 文件放在 `scripts` 目录中。
- en: 'We will use `bash` to orchestrate the entire testing pipeline, which is the
    best tool for orchestrating testing tasks. In our `srcipts/run_test_pipeline.sh`
    script, we will start out with the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `bash` 来编排整个测试流程，这是编排测试任务的最佳工具。在我们的 `scripts/run_test_pipeline.sh` 脚本中，我们将从以下代码开始：
- en: '[PRE86]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the preceding code, we told the computer that the code block is a Bash script
    with the `#!/bin/bash` shebang line. Bash scripts run from the current working
    directory of where the Bash script it called from. We can call the script from
    multiple directories so we need to ensure that we get the directory of where the
    script is housed, which is the `scripts` directory, assign that to a variable
    called `SCRIPTPATH`, move to that directory, and then move out one with the `cd..`
    command to be in the main directory where the Docker, config, and Cargo files
    are. We can then spin up our Docker containers in the background with the `-d`
    flag and loop until the database is accepting connections with the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们告诉计算机代码块是一个 Bash 脚本，使用 `#!/bin/bash` shebang 行。Bash 脚本从调用它的 Bash 脚本的当前工作目录运行。我们可以从多个目录调用脚本，因此我们需要确保我们获取到脚本所在的目录，即
    `scripts` 目录，将其分配给名为 `SCRIPTPATH` 的变量，移动到该目录，然后使用 `cd..` 命令向上移动一个目录，以便位于包含 Docker、配置和
    Cargo 文件的父目录中。然后我们可以使用 `-d` 标志在后台启动 Docker 容器，并循环直到数据库接受连接，以下为相关代码：
- en: '[PRE87]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now that our Docker containers are running, we can now move on to building
    our Rust server. First, we can compile the Rust server and run our unit tests
    with the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了 Docker 容器，我们可以继续构建我们的 Rust 服务器。首先，我们可以编译 Rust 服务器并使用以下代码运行我们的单元测试：
- en: '[PRE88]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Once the unit tests have been run, we can then run our server in the background
    with the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试运行完毕后，我们可以使用以下代码在后台运行我们的服务器：
- en: '[PRE89]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'With `&` at the end of the command, the `cargo run config.yml` runs in the
    background. We then get the process ID of the `cargo run config.yml` command and
    assign it to the variable `SERVER_PID`. We then sleep for 5 seconds to be sure
    that the server is ready to accept connections. Before we make any API calls to
    our server, we must run our migrations to the database with the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 命令末尾的 `&` 使得 `cargo run config.yml` 在后台运行。然后我们获取 `cargo run config.yml` 命令的进程
    ID，并将其分配给变量 `SERVER_PID`。然后我们等待 5 秒以确保服务器已准备好接受连接。在我们向服务器发送任何 API 调用之前，我们必须使用以下代码运行数据库迁移：
- en: '[PRE90]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We then move back into our `scripts` directory and make an API call to our
    server that creates a user:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们回到 `scripts` 目录，向我们的服务器发送一个创建用户的 API 调用：
- en: '[PRE91]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'If you are wondering how to use `curl` to make HTTP requests in Bash, you can
    autogenerate them using your Postman tool. On the right-hand side of the Postman
    tool, you can see a **Code** button, as shown in the following screenshot:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道如何在 Bash 中使用 `curl` 发送 HTTP 请求，你可以使用 Postman 工具自动生成它们。在 Postman 工具的右侧，你可以看到一个
    **代码** 按钮，如下面的截图所示：
- en: '![Figure 9.11 – Code generation tool](img/Figure_9.11_B18722.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 代码生成工具](img/Figure_9.11_B18722.jpg)'
- en: Figure 9.11 – Code generation tool
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 代码生成工具
- en: Once you have clicked on the code tag, there is a drop-down menu where you can
    select from a range of languages. Once you have selected the language you want,
    your API call will be displayed in a code snippet for your chosen language, which
    you can then copy and paste.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击了代码标签，就会出现一个下拉菜单，你可以从中选择多种语言。一旦你选择了你想要的编程语言，你的 API 调用就会以代码片段的形式显示在你选择的编程语言中，然后你可以复制并粘贴。
- en: 'Now that we have created our user, we can log in and store the token in the
    `fresh_token.json` file with the following code; however, it must be noted that
    `curl` first needs to be installed:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用户，我们可以登录并使用以下代码将令牌存储在 `fresh_token.json` 文件中；然而，需要注意的是，`curl` 首先需要被安装：
- en: '[PRE92]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'What is happening here is that we can wrap the result of the API call into
    a variable with `$(...)`. We then echo this and write it to the file using `echo
    $(...) > ./fresh_token.json`. We can then insert the fresh token into the Newman
    data and run the Newman API tests with the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是我们可以将 API 调用的结果包装在一个变量 `$(...)` 中。然后我们通过 `echo $(...) > ./fresh_token.json`
    将其输出并写入文件。然后我们可以将新的令牌插入到 Newman 数据中，并使用以下代码运行 Newman API 测试：
- en: '[PRE93]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Our testing is now done. We can clean up the files created when running the
    tests, destroy the Docker containers, and stop our server running with the following
    code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试现在完成了。我们可以清理测试运行时创建的文件，销毁 Docker 容器，并使用以下代码停止运行的服务器：
- en: '[PRE94]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`curl` and `jq` both need to be installed before we can run the Bash script.
    If you are using Linux, you might need to run the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行Bash脚本之前，`curl`和`jq`都需要安装。如果您使用Linux，可能需要运行以下命令：
- en: '[PRE95]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can then run our testing script with the following command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行我们的测试脚本：
- en: '[PRE96]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Showing the whole printout would just needlessly fill up the book. However,
    we can see the end of the test printout in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 展示整个打印输出只会无谓地填满书籍。然而，我们可以在以下屏幕截图中看到测试打印输出的结尾：
- en: '![Figure 9.12 – The testing pipeline output](img/Figure_9.12_B18722.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 测试管道输出](img/Figure_9.12_B18722.jpg)'
- en: Figure 9.12 – The testing pipeline output
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 测试管道输出
- en: 'Here, the printout makes it clear that the Newman tests have run and passed.
    After the tests were completed, the server was shut down and the Docker containers
    that were supporting the server were stopped and removed. If you want to write
    this log to a `txt` file, you can do so with the following command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，打印输出清楚地表明纽曼测试已经运行并通过。测试完成后，服务器被关闭，支持服务器的Docker容器也被停止并移除。如果您想将此日志写入`txt`文件，可以使用以下命令：
- en: '[PRE97]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: There you have it! A fully working test pipeline that automates the setting
    up, testing, and clean-up of our server. Because we have written it in a simple
    Bash test pipeline, we could integrate these steps in automation pipelines such
    as Travis, Jenkins, or GitHub Actions. These pipeline tools fire automatically
    when a `pull` request and merges are performed.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是了！一个完全工作的测试管道，它自动化了我们的服务器设置、测试和清理。因为我们将其编写为简单的Bash测试管道，所以我们可以将这些步骤集成到自动化管道中，如Travis、Jenkins或GitHub
    Actions。这些管道工具在执行`pull`请求和合并时自动触发。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the workflows and components of our application,
    breaking them down so we could pick the right tools for the right part. We used
    unit testing so we could inspect several edge cases quickly to see how each function
    and struct interacted with others.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了我们应用程序的工作流程和组件，将它们分解以便我们可以为正确部分选择正确的工具。我们使用了单元测试，以便可以快速检查几个边缘情况，以了解每个函数和结构体如何与其他部分交互。
- en: We also directly inspected our custom structs with unit tests. We then used
    the `actix_web` test structs to mock requests to see how the functions that use
    the structs and process the requests work. However, when we came to the main API
    views module, we switched to Postman.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还直接使用单元测试检查了我们的自定义结构体。然后，我们使用`actix_web`测试结构体来模拟请求，以查看使用结构体并处理请求的函数如何工作。然而，当我们来到主API视图模块时，我们转向了Postman。
- en: This is because our API endpoints were simple. They created, edited, and deleted
    to-do items. We could directly assess this process by making API calls and inspecting
    the responses. Out of the box we managed to assess the JSON processing for accepting
    and returning data. We were also able to assess the querying, writing, and updating
    of the data in the database with these Postman tests.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的API端点是简单的。它们创建、编辑和删除待办事项。我们可以通过直接进行API调用并检查响应来直接评估此过程。我们能够直接评估JSON处理以接受和返回数据。我们还能够使用这些Postman测试评估数据库中的数据查询、写入和更新。
- en: Postman enabled us to test a range of processes quickly and efficiently. We
    even sped up this testing process by automating it via Newman. However, it must
    be noted that this approach is not a one-size-fits-all approach. If the API view
    functions become more complex, with more moving parts, such as communicating with
    another API or service, then the Newman approach would have to be redesigned.
    Environment variables that trigger mocking such processes would have to be considered
    so we can quickly test a range of edge cases.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Postman使我们能够快速高效地测试一系列流程。我们甚至通过Newman自动化这个过程来加快测试速度。然而，必须注意的是，这种方法并不是万能的。如果API视图函数变得更加复杂，有更多的移动部件，例如与另一个API或服务通信，那么Newman方法将需要重新设计。需要考虑触发模拟此类过程的环境变量，以便我们可以快速测试一系列边缘情况。
- en: Mocking objects will be needed if the system grows as the dependencies of our
    structs will grow. This is where we create a fake struct or function and define
    the output for a test. To do this, we will need an external crate such as `mockall`.
    The documentation on this crate is covered in the *Further reading* section of
    this chapter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统随着我们结构体的依赖关系增长而增长，将需要模拟对象。这就是我们创建一个假的结构体或函数并定义测试输出的地方。为此，我们需要一个外部crate，例如`mockall`。关于这个crate的文档在本章的*进一步阅读*部分有所介绍。
- en: Our application now fully runs and has a range of tests. Now, all we have left
    is to deploy our application on a server.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在完全运行，并有一系列测试。现在，我们剩下的就是将我们的应用程序部署到服务器上。
- en: In the next chapter, we will set up a server on **Amazon** **Web** **Services**
    (**AWS**), utilizing *Docker* to deploy our application on a server. We will cover
    the process of setting up the AWS configuration, running tests, and then deploying
    our application on our server if the tests pass.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 *Docker* 在 **Amazon** **Web** **Services** (**AWS**) 上设置一个服务器，将我们的应用程序部署到服务器上。我们将介绍设置
    AWS 配置、运行测试，并在测试通过的情况下将我们的应用程序部署到服务器上的过程。
- en: Questions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do we bother with unit tests if we can just manually play with the application?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们可以手动操作应用程序，为什么还要费心进行单元测试？
- en: What is the difference between unit tests and functional tests?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试和功能测试有什么区别？
- en: What are the advantages of unit tests?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试有哪些优点？
- en: What are the disadvantages of unit tests?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试有哪些缺点？
- en: What are the advantages of functional tests?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试有哪些优点？
- en: What are the disadvantages of functional tests?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试有哪些缺点？
- en: What is a sensible approach to building unit tests?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建单元测试的合理方法是什么？
- en: Answers
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: When it comes to manual testing, you may forget to run a certain procedure.
    Running tests standardizes our standards and enables us to integrate them into
    continuous integration tools to ensure new code will not break the server as continuous
    integration can block new code merges if the code fails.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到手动测试时，你可能会忘记运行某个特定程序。运行测试标准化了我们的标准，并使我们能够将它们集成到持续集成工具中，以确保新代码不会破坏服务器，因为如果代码失败，持续集成可以阻止新代码的合并。
- en: Unit tests isolate individual components such as functions and structs. These
    functions and structs are then assessed with a range of fake inputs to assess
    how the component interacts with different inputs. Functional tests assess the
    system, hitting API endpoints, and checking the response.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试将单个组件（如函数和结构体）隔离开来。然后，通过一系列模拟输入对这些函数和结构体进行评估，以了解组件如何与不同的输入交互。功能测试评估系统，调用
    API 端点，并检查响应。
- en: Unit tests are lightweight and do not need an entire system to run. They can
    test a whole set of edge cases quickly. Unit tests can also isolate exactly where
    the error is.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试轻量级，不需要整个系统运行。它们可以快速测试一系列边缘情况。单元测试还可以精确地隔离错误发生的位置。
- en: Unit tests are essentially isolated tests with made-up inputs. If the type of
    input is changed in the system but not updated in the unit test, then this test
    will essentially pass when it should fail. Unit tests also do not assess how the
    system runs.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试基本上是使用虚构输入的隔离测试。如果系统中的输入类型更改但单元测试未更新，那么这个测试在应该失败时实际上会通过。单元测试也不评估系统是如何运行的。
- en: Functional tests ensure that the entire infrastructure works together as it
    should. For instance, there could be an issue with how we configure and connect
    to the database. With unit tests, such problems can be missed. Also, although
    mocking ensures isolated tests, unit test mocks might be out of date. This means
    that a mocked function might return data that the updated version does not. As
    a result, the unit test will pass but the functional tests will not as they test
    everything.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试确保整个基础设施按预期协同工作。例如，我们配置和连接数据库的方式可能存在问题。使用单元测试，这些问题可能会被忽略。此外，尽管模拟确保了隔离的测试，但单元测试的模拟可能过时。这意味着模拟的函数可能会返回更新版本中没有的数据。因此，单元测试会通过，但功能测试不会，因为它们测试一切。
- en: Functional tests need to have the infrastructure to run like a database. There
    also must be a setup and teardown function. For instance, a functional test will
    affect the data stored in the database. At the end of the test, the database needs
    to be wiped before running the test again. This can increase the complications
    and can require “glue” code between different operations.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试需要具有像数据库这样的基础设施来运行。还必须有设置和拆卸函数。例如，功能测试将影响数据库中存储的数据。在测试结束时，需要在再次运行测试之前清除数据库。这可能会增加复杂性，并可能需要在不同操作之间使用“粘合”代码。
- en: We start off with testing structs and functions that do not have any dependencies.
    Once these have been tested, we know that we are comfortable with them. We then
    move on to the functions and structs that have the dependencies we previously
    tested. Using this approach, we know that the current test we are writing does
    not fail due to a dependency.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先测试那些没有依赖的 struct 和函数。一旦这些测试完成，我们就知道我们对它们很熟悉。然后我们转向那些具有我们之前测试过的依赖的函数和 struct。采用这种方法，我们知道我们正在编写的当前测试不会因为依赖而失败。
- en: Further reading
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Mockall documentation: [https://docs.rs/mockall/0.9.0/mockall/](https://docs.rs/mockall/0.9.0/mockall/)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mockall 文档：[https://docs.rs/mockall/0.9.0/mockall/](https://docs.rs/mockall/0.9.0/mockall/)
- en: 'Github Actions documentation: [https://github.com/features/actions](https://github.com/features/actions)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Github Actions 文档：[https://github.com/features/actions](https://github.com/features/actions)
- en: 'Travis documentation: [https://docs.travis-ci.com/user/for-beginners/](https://docs.travis-ci.com/user/for-beginners/'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis 文档：[https://docs.travis-ci.com/user/for-beginners/](https://docs.travis-ci.com/user/for-beginners/)
- en: )
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Circle CI documentation: [https://circleci.com/docs/](https://circleci.com/docs/)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Circle CI 文档：[https://circleci.com/docs/](https://circleci.com/docs/)
- en: 'Jenkins documentation: [https://www.jenkins.io/doc/](https://www.jenkins.io/doc/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins 文档：[https://www.jenkins.io/doc/](https://www.jenkins.io/doc/)
