- en: Hello Rust!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到Rust！
- en: First, thank you for picking up a copy of this book! Many of you will only have
    talked about the topic of algorithms and data structures back in university. In
    fact, regardless of whether this is your first endeavor in programming or not,
    we worked hard to make this book a great learning experience. Our primary focus
    will be the unique influence of Rust on algorithm and data structure design, so
    we would like to start with a recap of important fundamentals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，感谢您拿起这本书！你们中的许多人可能只在大学时讨论过算法和数据结构这个话题。实际上，无论这是您编程生涯的第一次尝试与否，我们都努力使这本书成为一次极好的学习体验。我们的主要关注点将是Rust对算法和数据结构设计的独特影响，因此我们想从回顾一些重要的基础知识开始。
- en: 'Starting off with the Rust 2018 edition changes, we will cover how borrowing
    and ownership, mutability, and concurrency influence how and where data can be
    held, and what algorithms can be executed. In this chapter, you can look forward
    to learning about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从Rust 2018版的变化开始，我们将探讨借用和所有权、可变性以及并发如何影响数据可以存储的位置以及可以执行哪些算法。在本章中，您可以期待学习以下内容：
- en: A quick refresh on Rust and what awaits in the 2018 edition (Rust 1.31)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速回顾Rust以及2018版（Rust 1.31）中期待的内容
- en: The latest and greatest about borrowing and ownership
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于借用和所有权的最新和最佳内容
- en: How we can leverage concurrency and mutability properly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何正确利用并发和可变性
- en: References (not pointers!) to where Rust lives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向Rust所在之处的引用（不是指针！）
- en: Rust in 2018
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2018年的Rust
- en: How old is Rust? It started off in 2006 as a side project of Graydon Hoare,
    an engineer at Mozilla, and was later (in 2009) adopted by the company. Fast forward
    to less than a decade later to May 15, 2015, and the Rust team announced a stable
    version 1.0!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有多久了？它始于2006年，是Mozilla工程师Graydon Hoare的一个副项目，后来（在2009年）被公司采纳。快进到不到十年后的2015年5月15日，Rust团队宣布了稳定版本1.0！
- en: During its journey, there have been many features that have been added and removed
    again (for example, a garbage collector, classes, and interfaces) to help it become
    the fast and safe language that it is today.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在其发展过程中，许多特性被添加和移除（例如，垃圾回收器、类和接口），以帮助它成为今天既快速又安全的语言。
- en: Before getting deeper into borrowing and ownership, mutability, concurrency,
    safety, and so on in Rust, we would like to recap some major concepts in Rust
    and why they change architectural patterns significantly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨Rust中的借用和所有权、可变性、并发、安全性等之前，我们想回顾一下Rust的一些主要概念以及它们如何显著改变架构模式。
- en: The 2018 edition
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2018年版
- en: Rust in the 2015 edition is essentially the 1.0 version with a few non-breaking
    additions. Between 2015 and 2018, however, features and **Requests for Comments **(**RFCs**),
    Rust's way of changing core features with the community, accumulated, and worries
    about backward compatibility arose.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的2015年版基本上是1.0版本，增加了一些非破坏性特性。然而，在2015年和2018年之间，特性和**请求评论（RFCs**）——Rust社区改变核心特性的方式——不断积累，对向后兼容性的担忧也随之产生。
- en: 'With the goal of keeping this compatibility, editions were introduced and,
    with the first additional edition, many major changes made it into the language:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持这种兼容性，引入了版本，并且随着第一个附加版本，许多重大变化被纳入了语言：
- en: Changes to the module path system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块路径系统的变化
- en: '`dyn Trait` and `impl Trait` syntax'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dyn Trait`和`impl Trait`语法'
- en: '`async`/`await` syntax'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`/`await`语法'
- en: Simplifications to the lifetime syntax
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期语法的简化
- en: With these additions, Rust will introduce asynchronous programming into its
    syntax (`async`/`await` keywords) and improve the language's usability. This book
    uses the Rust 2018, released on December 6, 2018 ([https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html))
    edition by default, so all the following snippets will already include these new
    language features!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些新增特性，Rust将异步编程引入其语法（`async`/`await`关键字），并提高了语言的可用性。本书默认使用2018年12月6日发布的Rust
    2018版（[https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html)），因此所有以下代码片段都将包含这些新的语言特性！
- en: The Rust language
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust语言
- en: Many of the established programming languages today are multi-paradigm languages,
    but still remain focused on the principles of object orientation. This means that
    they have classes, methods, interfaces, inheritance, and so on, none of which
    can be found in Rust, giving it a steep learning curve for many established developers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当今许多已建立的编程语言是多范式语言，但仍然专注于面向对象的原则。这意味着它们有类、方法、接口、继承等，这些在 Rust 中都找不到，这使得许多已建立的开发者学习曲线陡峭。
- en: More experienced readers will miss many aspects of what makes Rust an excellent
    language, such as static versus dynamic method invocation, memory layouts, and
    so on. I recognize the importance of those things, yet for brevity and focus chose
    to leave it to you to explore these things further. Check the *Further reading*
    section for resources.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 经验更丰富的读者可能会错过许多使 Rust 成为优秀语言的方面，例如静态与动态方法调用、内存布局等。我认识到这些事情的重要性，但为了简洁和专注，选择将其留给您进一步探索。请参阅
    *进一步阅读* 部分，以获取资源。
- en: As a multi-paradigm language, Rust has many functional concepts and paradigms
    that guide it, but they make traditional object-oriented patterns more difficult
    to apply. Other than organizing code without classes and interfaces, there are
    various methods to handle errors, change the code itself, or even work with raw
    pointers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种多范式语言，Rust 有许多功能概念和范式来指导它，但它们使得传统的面向对象模式更难应用。除了不使用类和接口来组织代码之外，还有各种方法来处理错误、更改代码本身，甚至与原始指针一起工作。
- en: In the following sections, we want to explore a few concepts that make Rust
    unique and have a major influence on the way we develop algorithms and data structures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们想要探索一些使 Rust 独特并对我们开发算法和数据结构有重大影响的几个概念。
- en: Objects and behavior
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象和行为
- en: 'Organizing code in Rust is a bit different from regular object-oriented languages
    such as C#. There, an object is supposed to change its own state, interfaces are
    simple contract definitions, and specialization is often modeled using class inheritance:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中组织代码与常规的面向对象语言（如 C#）略有不同。在那里，一个对象应该改变自己的状态，接口是简单的合同定义，而专业化通常是通过类继承来建模的：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With Rust, this pattern would require constant mutability of any `Door` instance
    (thereby requiring explicit locking for thread safety), and without inheritance
    `GlassDoor` would have to duplicate code, making it harder to maintain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，这种模式将需要任何 `Door` 实例的恒定可变性（因此需要显式锁定以实现线程安全），而且没有继承，`GlassDoor` 将不得不重复代码，这使得维护变得更加困难。
- en: 'Instead, it''s recommended to create traits to implement (shared) behavior.
    Traits have a lot in common with abstract classes in traditional languages (such
    as default implementations of methods/functions), yet any `struct` in Rust can
    (and should) implement several of those traits:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，建议创建特质来实现（共享）行为。特质与传统语言中的抽象类有很多共同之处（例如方法的默认实现），而且 Rust 中的任何 `struct` 都可以（并且应该）实现这些特质中的几个：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This pattern is very common in the standard library, and often third-party libraries
    will even add behavior to existing types by implementing traits in their code
    (also known as extension traits).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在标准库中非常常见，第三方库甚至会在自己的代码中通过实现特质来向现有类型添加行为（也称为扩展特质）。
- en: Other than a typical class, where data fields and methods are in a single construct,
    Rust emphasizes the separation between those by declaring a `struct` for data
    and an `impl` part for the methods/functions. Traits name and encapsulate behaviors
    so they can easily be imported, shared, and reused.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了典型的类，其中数据字段和方法位于单个结构中之外，Rust 强调通过声明一个用于数据的 `struct` 和一个用于方法/函数的 `impl` 部分来分离它们。特质命名并封装行为，以便可以轻松导入、共享和重用。
- en: Going wrong
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出错
- en: 'Other than classes, Rust comes without another well-known companion: `null`.
    In the absence of pointers and with a very different memory management model,
    there is no typical `null` pointer/reference.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了课程之外，Rust 没有另一个众所周知的伴侣：`null`。在没有指针和非常不同的内存管理模型的情况下，不存在典型的 `null` 指针/引用。
- en: 'Instead, the language works with `Option` and `Result` types that let developers
    model success or failure. In fact, there is no exception system either, so any
    failed execution of a function should be indicated in the return type. Only in
    rare cases when immediate termination is required does the language provide a
    macro for panicking: `panic!()`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，该语言使用`Option`和`Result`类型，让开发者能够建模成功或失败。实际上，也没有异常系统，因此任何函数的失败执行都应该在返回类型中指示。只有在需要立即终止的情况下，该语言才提供用于恐慌的宏：`panic!()`。
- en: '`Option<T>` and `Result<T, E>` both encapsulate one (`Option<T>`) or two (`Result<T,
    E>`) values that can be returned to communicate an error or whether something
    was found or not. For example, a `find()` function could return `Option<T>`, whereas
    something like `read_file()` would typically have a `Result<T, E>` return type
    to communicate the content or errors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option<T>`和`Result<T, E>`都封装了一个（`Option<T>`）或两个（`Result<T, E>`）值，可以返回以传达错误或是否找到了某些内容。例如，一个`find()`函数可以返回`Option<T>`，而像`read_file()`这样的函数通常会有`Result<T,
    E>`返回类型来传达内容或错误：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Handling those return values is often done with `match` or `if let` clauses
    in order to handle the cases of success or failure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用`match`或`if let`子句来处理这些返回值，以处理成功或失败的情况：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is due to `Option<T>` and `Result<T, E>` both being enumerations that have
    generic type parameters; they can assume any type in their variants. Matching
    on their variants provides access to their inner values and types to allow a branch
    of the code to be executed and handle the case accordingly. Not only does this
    eliminate the need for constructs such as try/catch with multiple—sometimes cast—exception
    arms, it makes failure part of the normal workflow that needs to be taken care
    of.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`Option<T>`和`Result<T, E>`都是具有泛型类型参数的枚举；它们可以假设其变体中的任何类型。对其变体的匹配提供了访问其内部值和类型的能力，从而允许执行代码的一个分支并相应地处理该情况。这不仅消除了需要具有多个——有时是类型转换——异常臂的try/catch结构的需求，而且还使失败成为需要处理的正常工作流程的一部分。
- en: Macros
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: Another aspect of Rust is the ability to do metaprogramming—basically programming
    programming—using macros! Macros are expanded in Rust code before compilation,
    which gives them more power than a regular function. The generated code can, for
    instance, create functions on the fly or implement traits for a structure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Rust具有使用宏进行元编程的能力——基本上是编程编程！宏在Rust代码编译之前展开，这使得它们比普通函数拥有更多的功能。生成的代码可以动态创建函数或为结构体实现特质。
- en: These pieces of code make everyday life a lot easier by reducing the need to
    create and then initialize vectors, deriving the ability to clone a structure,
    or simply printing stuff to the command line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码片段通过减少创建和初始化向量、派生结构体克隆能力或简单地打印内容到命令行的需求，使日常生活变得更加容易。
- en: 'This is a simplified example for the declarative `vec![]` macro provided in
    the *Rust Book* (second edition, Appendix D):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化版的`vec![]`声明性宏示例，它包含在*《Rust编程语言》（第二版，附录D）*中：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Declarative macros work on patterns and run code if that pattern matches; the
    previous example matches *0 - n* expressions (for example, a number, or a function
    that returns a number) and inserts `temp_vec.push(...)` *n* times, iterating over
    the provided expressions as a parameter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性宏在模式上工作，如果该模式匹配，则运行代码；前面的示例匹配`*0 - n*`表达式（例如，一个数字，或返回数字的函数）并插入`temp_vec.push(...)`
    *n* 次，迭代提供的表达式作为参数。
- en: The second type, procedural macros, operate differently and are often used to
    provide a default trait implementation. In many code bases, the `#[derive(Clone,
    Debug)]` statement can be found on top of structures to implement the `Clone`
    and `Debug` traits automatically.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型，过程宏，操作方式不同，通常用于提供默认的特质实现。在许多代码库中，可以在结构体顶部找到`#[derive(Clone, Debug)]`语句来自动实现`Clone`和`Debug`特质。
- en: 'Later in this chapter, we are going to use a structure, `FileName`, to illustrate
    reference counting, but for printing it to the command line using the debug literal
    `"{:?}"`, we need to derive `Debug`, which recursively prints all members to the
    command line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将使用一个结构体，`FileName`，来展示引用计数，但为了使用调试字面量`"{:?}"`将其打印到命令行，我们需要派生`Debug`，它递归地将所有成员打印到命令行：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Rust standard library provides several macros already, and by creating custom
    macros, you can minimize the boilerplate code you have to write.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库已经提供了几个宏，通过创建自定义宏，您可以最小化必须编写的样板代码。
- en: Unsafe
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全
- en: 'Rust''s code is "safe" because the compiler checks and enforces certain behavior
    when it comes to memory access and management. However, sometimes these rules
    have to be forgone, making the code unsafe. `unsafe` is a keyword in Rust and
    declares a section of code that can do most of the things the C programming language
    would let you do. For example, it lets the user do the following (from the *Rust
    Book*, chapter 19.1):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的代码是“安全”的，因为编译器在内存访问和管理方面检查并强制执行某些行为。然而，有时这些规则必须被放弃，使得代码变得不安全。`unsafe`是Rust中的一个关键字，它声明了一段代码，可以执行C编程语言允许你做的许多事情。例如，它允许用户执行以下操作（来自*《Rust编程语言》*，第19.1章）：
- en: Dereference a raw pointer
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解引用原始指针
- en: Call an `unsafe` function or method
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个`不安全`的函数或方法
- en: Access or modify a mutable static variable
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问或修改可变静态变量
- en: Implement an `unsafe` trait
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`unsafe`特质
- en: 'These four abilities can be used for things such as very low-level device access,
    language interoperability (the compiler can''t know what native libraries do with
    their memory), and so on. In most cases, and certainly in this book, `unsafe`
    is not required. In fact, the Rustonomicon ([https://doc.rust-lang.org/nomicon/what-unsafe-does.html](https://doc.rust-lang.org/nomicon/what-unsafe-does.html))
    defines a list of issues the language is trying to prevent from happening by providing
    the safe part:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种能力可以用于诸如非常低级的设备访问、语言互操作性（编译器无法知道原生库如何使用它们的内存）等情况。在大多数情况下，当然在这本书中，`unsafe`是不必要的。事实上，Rustonomicon（[https://doc.rust-lang.org/nomicon/what-unsafe-does.html](https://doc.rust-lang.org/nomicon/what-unsafe-does.html)）定义了一个列表，列出了语言试图通过提供安全部分来防止发生的问题：
- en: Dereferencing null, dangling, or unaligned pointers.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解引用空、悬垂或未对齐的指针。
- en: Reading uninitialized memory.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取未初始化的内存。
- en: Breaking the pointer aliasing rules.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏指针别名规则。
- en: 'Producing invalid primitive values:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成无效的原始值：
- en: Dangling/null references
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬垂/空引用
- en: Null `fn` pointers
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空的`fn`指针
- en: A bool that isn't 0 or 1
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是0或1的布尔值
- en: An undefined `enum` discriminant
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义的`enum`判别符
- en: A char outside the ranges [`0x0`, `0xD7FF`] and [`0xE000`, `0x10FFFF`]
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符超出范围[`0x0`, `0xD7FF`]和[`0xE000`, `0x10FFFF`]
- en: A non-UTF8 string
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非UTF8字符串
- en: Unwinding into another language.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用其他语言。
- en: Causing a data race.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致数据竞争。
- en: The fact that these potential issues are prevented in safe Rust certainly makes
    the life of a developer easier, especially when designing algorithms or data structures.
    As a consequence, this book will always work with safe Rust.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些潜在问题在安全Rust中被防止，这无疑使开发者的生活变得更轻松，尤其是在设计算法或数据结构时。因此，这本书将始终使用安全Rust。
- en: Borrowing and ownership
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用和所有权
- en: 'Rust is famous for its memory management model, which replaces runtime garbage
    collection with compile-time checks for memory safety. The reason why Rust can
    work without a garbage collector and still free the programmer from error-prone
    memory management is simple (but not easy): borrowing and ownership.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Rust以其内存管理模型而闻名，该模型用编译时对内存安全的检查取代了运行时垃圾回收。Rust能够在没有垃圾回收器的情况下工作，并且仍然让程序员摆脱易出错的内存管理，原因简单（但不容易）：借用和所有权。
- en: While the particulars are quite complex, the high-level view is that the compiler
    inserts any "provide *x* amounts of memory" and "remove *x* amounts of memory"
    (somewhat like `malloc()` and `free()` for C programmers) statements for the developer.
    Yet how can it do that?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然具体细节相当复杂，但高层次的观点是，编译器为开发者插入任何“提供*x*数量的内存”和“移除*x*数量的内存”（对于C程序员来说类似于`malloc()`和`free()`）语句。然而，它是如何做到这一点的呢？
- en: 'The rules of ownership are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权规则如下：
- en: The owner of a value is a variable
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的所有者是变量
- en: At any time, only a single owner is allowed
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时候，只允许一个所有者
- en: The value is lost once the owner goes out of scope
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有者超出作用域时，值就会丢失
- en: 'This is where Rust''s declarative syntax comes into play. By declaring a variable,
    the compiler knows—at compile time—that a certain amount of memory needs to be
    reserved. The lifetime is clearly defined too, from the beginning to end of a
    block or function, or as long as the `struct` instance lives. If the size of this
    variable is known at compile time, the compiler can provide exactly the necessary
    amount of memory to the function for the time required. To illustrate, let''s
    consider this snippet, where two variables are allocated and removed in a deterministic
    order:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Rust声明性语法发挥作用的地方。通过声明一个变量，编译器在编译时就知道需要预留一定量的内存。其生命周期也是明确定义的，从块的开始到结束，或只要`struct`实例存在。如果这个变量的大小在编译时已知，编译器就可以为函数提供所需的精确内存量。为了说明这一点，让我们考虑这个片段，其中两个变量以确定的顺序分配和释放：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Is this not what every other compiler does? The answer is yes—and no. At compile
    time, the "provide *x* amounts of memory" part is fairly simple; the tricky part
    is keeping track of how much is still in use when references can be passed around
    freely. If, during the course of a function, a particular local reference becomes
    invalid, a static code analysis will tell the compiler about the lifetime of the
    value behind the reference. However, what if a thread changes that value at an
    unknown time during the function's execution?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这难道不是每个其他编译器都做的事情吗？答案是是的——也不是。在编译时，“提供*x*量的内存”这部分相对简单；棘手的部分是跟踪在可以自由传递引用时还有多少内存在使用中。如果在函数执行过程中，某个局部引用变得无效，静态代码分析会告诉编译器引用背后的值的生命周期。然而，如果在函数执行过程中某个线程在未知的时间改变了这个值呢？
- en: 'At compile time, this is impossible to know, which is why many languages do
    these checks at runtime using a garbage collector. Rust forgoes this, with two
    primary strategies:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，这是不可能知道的，这就是为什么许多语言使用垃圾回收器在运行时进行这些检查。Rust放弃了这种方法，采用两种主要策略：
- en: Every variable is owned by exactly one scope at any time
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个变量在任何时候都恰好由一个作用域拥有
- en: Therefore, the developer is forced to pass ownership as required
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，开发者被迫按照要求传递所有权
- en: Especially when working with scopes, the nature of stack variables comes in
    handy. There are two areas of memory, stack and heap, and, similar to other languages,
    the developer uses types to decide whether to allocate heap (`Box`, `Rc`, and
    so on) or stack memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在处理作用域时，栈变量的特性非常有用。存在两个内存区域，栈和堆，类似于其他语言，开发者使用类型来决定是分配堆（`Box`、`Rc`等）还是栈内存。
- en: 'Stack memory is usually short-lived and smaller, and operates in a first-in,
    last-out manner. Consequently, a variable''s size has to be known before it is
    put on the stack:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 栈内存通常是短暂的且较小的，以先进先出的方式操作。因此，在将变量放入栈之前，必须知道其大小：
- en: '![](img/04d4f181-3289-4b0a-97ed-7942ad366875.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04d4f181-3289-4b0a-97ed-7942ad366875.png)'
- en: 'Heap memory is different; it''s a large portion of the memory, which makes
    it easy to allocate more whenever needed. There is no ordering, and memory is
    accessed by using an addresses. Since the pointer to an address on the heap has
    a known size at compile time, it fits nicely on the stack:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存不同；它是内存的一部分，这使得在需要时很容易分配更多内存。没有顺序，内存通过地址访问。由于堆上的地址指针在编译时已知大小，它非常适合放在栈上：
- en: '![](img/f30496bb-f144-45a9-befa-4e66a0f8b4cf.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f30496bb-f144-45a9-befa-4e66a0f8b4cf.png)'
- en: 'Stack variables are typically passed by value in other languages, which means
    that the entire value is copied and placed into the stack frame of the function.
    Rust does the same, but it also invalidates further use of that variable in the—now
    parent—scope. Ownership moves into the new scope and can only be transferred back
    as a return value. When trying to compile this snippet, the compiler will complain:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，栈变量通常按值传递，这意味着整个值被复制并放置在函数的栈帧中。Rust也这样做，但它还使该变量在——现在的父——作用域中的进一步使用无效。所有权移动到新的作用域，并且只能作为返回值转移回来。当尝试编译这个片段时，编译器会报错：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Borrowing is similar but, instead of copying the entire value, a reference to
    the original value is moved into the new scope. Just like in real life, the value
    continues to be owned by the original scope; scopes with a reference are just
    allowed to use it as it was provided. Of course, this comes with drawbacks for
    mutability, and some functions will require ownership for technical and semantic
    reasons, but it also has advantages such as a smaller memory footprint.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 借用类似，但不是复制整个值，而是将原始值的引用移动到新的作用域。就像在现实生活中一样，值继续由原始作用域拥有；具有引用的作用域只是允许像提供的那样使用它。当然，这也带来了可变性的缺点，并且一些函数可能需要所有权，这既有技术原因也有语义原因，但它也有优点，例如更小的内存占用。
- en: 'These are the rules of borrowing:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是借用规则：
- en: Owners can have immutable or mutable references, but not both
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有者可以拥有不可变或可变引用，但不能同时拥有两者
- en: There can be multiple immutable references, but only one mutable reference
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以有多个不可变引用，但只能有一个可变引用
- en: References cannot be invalid
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用不能是无效的
- en: 'By changing the previous snippet to borrow the variable to `do_something()`
    (assuming this is allowed, of course), the compiler will be happy:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将前面的片段更改为将变量借用给`do_something()`（假设这是允许的，当然），编译器将很高兴：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Borrowed variables rely heavily on lifetimes. The most basic lifetime is the
    scope it was created in. However, if a reference should go into a struct field,
    how can the compiler know that the underlying value has not been invalidated?
    The answer is explicit lifetimes!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 借用的变量在很大程度上依赖于生命周期。最基本的生命周期是它在其中创建的作用域。然而，如果引用应该进入结构体字段，编译器如何知道底层值没有被无效化？答案是显式生命周期！
- en: Exceptional lifetimes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊生命周期
- en: Some lifetimes are different and Rust denominates them with a `'`. While this
    could be the predefined `'static`, it's equally possible to create your own, something
    that is often required when working with structures.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生命周期是不同的，Rust用`'`来表示它们。虽然这可能是预定义的`'static`，但在处理结构时，创建自己的生命周期也是同样可能的。
- en: 'This makes sense when thinking about the underlying memory structure: if an
    input parameter is passed into the function and returned at the end, its lifetime
    surpasses the function''s. While the function owns this part of the memory during
    its lifetime, it cannot borrow a variable for longer than it actually exists.
    So, this snippet cannot work:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑底层内存结构时，这是有意义的：如果输入参数被传递到函数中并在最后返回，它的生命周期超过了函数。虽然函数在其生命周期内拥有这部分内存，但它不能借用一个比它实际存在的时间更长的变量。因此，这个片段无法工作：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The reason is that the `passing_through` variable outlives `x`. There are several
    solutions to this problem:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`passing_through`变量比`x`存在的时间更长。解决这个问题有几种方法：
- en: 'Change the type definition of `MyStruct` to require ownership. This way, the
    structure now owns the variable and it will live as long as the structure:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`MyStruct`的类型定义更改为要求所有权。这样，结构现在拥有变量，并且它的生命周期将与结构相同：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Clone `x` to pass ownership into `passing_through`:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`x`克隆到`passing_through`以传递所有权：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, `vec![]` is statically defined, so it could make sense to add
    it as a function parameter. This is not only more allocation-efficient, but also
    can enforce an appropriate lifetime:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，`vec![]`是静态定义的，因此将其作为函数参数可能是有意义的。这不仅更高效地分配内存，还可以强制执行适当的生命周期：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Lifetimes cause a lot of strange errors for many Rust users, and in the 2018
    edition there is one less to worry about. With the introduction of non-lexical
    lifetimes, the borrow checker got a lot smarter and it is now able to check—up
    to a certain degree—semantically whether the variable was used. Recall from the
    rules of borrowing that, if a mutable reference is created, no immutable references
    can exist.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期给许多Rust用户带来了很多奇怪的错误，在2018版中有一个可以少担心的问题。随着非词法生命期的引入，借用检查器变得更聪明了，现在它能够在一定程度上检查变量是否被使用。回想一下借用规则，如果创建了一个可变引用，则不能存在不可变引用。
- en: 'This code did not compile before Rust 1.31:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust 1.31之前，这段代码无法编译：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now it will compile since the compiler does not just check the beginning and
    ending of a scope, but also if the reference was used at all.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它将能够编译，因为编译器不仅检查作用域的开始和结束，还检查引用是否被使用过。
- en: Multiple owners
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个所有者
- en: 'As powerful as single ownership is, it does not work for every use case. Large
    objects or shared objects that other instances need to own are examples where
    immutable ownership makes life easier. Consider a function that requires an owned
    object to be passed in:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 单一所有权的功能虽然强大，但并不适用于所有用例。例如，大型对象或需要其他实例拥有的共享对象，在这些情况下不可变所有权会使生活变得更简单。考虑一个需要传入拥有对象的函数：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When trying to compile `no_ref_counter()`, the compiler creates a scope for
    each iteration of the loop and owns any value that is used within it. This works
    exactly once, since afterward, the variable has been moved and is inaccessible
    for subsequent iterations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试编译`no_ref_counter()`时，编译器为循环的每次迭代创建一个作用域，并拥有其中使用的任何值。这只会成功一次，因为之后变量已经被移动，并且对于后续迭代不可访问。
- en: 'Consequently, these values (in this case, `name` and `ext`) are gone and compilation
    will yield two errors, one for each "second" move of a string:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些值（在这种情况下，`name`和`ext`）消失了，编译将产生两个错误，每个错误对应于字符串的“第二次”移动：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One solution is to clone the object in every iteration, but that causes a lot
    of slow memory allocations. For this, the Rust standard library provides a solution:
    reference counting.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是在每次迭代中克隆对象，但这会导致大量的缓慢内存分配。为此，Rust标准库提供了一个解决方案：引用计数。
- en: A reference counter (`std::rc::Rc<T>`) encapsulates a variable of type `T` allocated
    on the heap and returns an **immutable** reference when created. This reference
    can be cloned with low overhead (it's only a reference count that is incremented)
    but never transformed into a mutable reference. Regardless, it acts just like
    owned data, passing through function calls and property lookups.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数器（`std::rc::Rc<T>`）封装了一个在堆上分配的类型为`T`的变量，并在创建时返回一个**不可变**引用。这个引用可以以低开销克隆（它只是增加引用计数），但永远不会转换为可变引用。无论如何，它就像拥有数据一样，通过函数调用和属性查找传递。
- en: 'While this requires a change to the variable types, a call to `clone()` is
    now far cheaper than cloning the data directly:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这需要改变变量类型，但现在调用`clone()`比直接克隆数据要便宜得多：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running this snippet prints the debug version of the `FileName` object three
    times:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码片段会打印出`FileName`对象的调试版本三次：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This approach works great for single-threaded and immutable scenarios, but will
    refuse to compile multithreaded code. The solution to this will be discussed in
    the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于单线程和不可变场景非常有效，但会拒绝编译多线程代码。这个解决方案将在下一节讨论。
- en: Concurrency and mutability
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和可变性
- en: 'Rust''s approach to managing memory is a powerful concept. In fact, it is powerful
    enough to also facilitate concurrency and parallel execution. However, first things
    first: how do threads work in the Rust standard library?'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Rust管理内存的方法是一个强大的概念。事实上，它足够强大，可以促进并发和并行执行。然而，首先：Rust标准库中的线程是如何工作的？
- en: Concurrency and parallelism are two different modes of execution. While concurrency
    means that parts of a program run independently of each other, parallelism refers
    to these parts executing at the same time. For simplicity, we will refer to both
    concepts as concurrency.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行性是两种不同的执行模式。虽然并发意味着程序的某些部分可以独立运行，但并行性指的是这些部分同时执行。为了简单起见，我们将这两个概念统称为并发。
- en: 'Due to its low-level nature, Rust provides an API to the operating system''s
    threading capabilities (for example, POSIX on Linux/Unix systems). If no variables
    are passed into the scope, their usage is very straightforward:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其底层性质，Rust提供了操作系统线程功能的API（例如，Linux/Unix系统上的POSIX）。如果没有变量传递到作用域中，其使用非常简单：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, when passing data back and forth, more work has to be done to hold
    up Rust's safety guarantees, especially when mutability comes into play. Before
    getting into that, it is important to recap immutability.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在传递数据时，为了保持Rust的安全性保证，需要做更多的工作，尤其是在涉及可变性时。在深入探讨这一点之前，回顾不可变性是很重要的。
- en: Immutable variables
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变变量
- en: Rust—like many functional languages—embraces immutable variables. They are the
    default, and changing mutability requires explicit declaration with `mut`, which
    tells the compiler what the variable is going to be used for (reading or writing).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Rust——就像许多函数式语言一样——拥抱不可变变量。它们是默认的，改变可变性需要使用`mut`进行显式声明，这告诉编译器变量将要被用于什么（读取或写入）。
- en: Functional programming languages are known for facilitating the ability to work
    concurrently, thanks to immutability guarantees; reading data does not produce
    side effects! Requiring explicit mutability gives the compiler a chance to check
    where and if mutability is required, and therefore whether a data race may occur.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言因通过不可变性保证促进并发工作能力而闻名；读取数据不会产生副作用！要求显式可变性给编译器一个检查何时以及是否需要可变性的机会，因此是否可能发生数据竞争。
- en: This results in compile-time warnings and errors instead of crashes and strange
    race conditions at runtime, something that many production users appreciate. In
    short, it's easier to think through your code if mutability is a (rare) option
    instead of the norm.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致编译时警告和错误而不是运行时崩溃和奇怪的竞争条件，这是许多生产用户所欣赏的。简而言之，如果可变性是（罕见的）选项而不是规范，那么思考代码就更容易。
- en: Shadowing
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阴影（Shadowing）
- en: Instead of changing variable properties, it's often more readable to overwrite
    a variable with a different value (for example, a changed copy of the original).
    This technique is called **shadowing**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与改变变量属性不同，用不同的值（例如，原始值的更改副本）覆盖变量通常更易于阅读。这种技术被称为**阴影（shadowing）**。
- en: 'Typically, this is used to reuse a variable name, even though the actual value
    has changed, to work in the current situation. This snippet sanitizes `String`
    and, by using the same name throughout the function, it''s always clear that it''s
    the input parameter that is changed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这用于重用变量名，即使实际值已经改变，以便在当前情况下工作。此代码片段清理`String`，通过在整个函数中使用相同的名称，始终可以清楚地知道是输入参数被更改：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While this is akin to changing the value of a variable, shadowing does not replace
    mutability, especially when it's less costly to actually change properties of
    that variable; Rust has a specific design pattern for that!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这与改变变量的值类似，但阴影（shadowing）并不会取代可变性，尤其是在实际改变该变量的属性成本较低时；Rust为此有一个特定的设计模式！
- en: Interior mutability
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部可变性
- en: Can a variable be immutable and mutable at the same time? Of course. Boxed variables
    (`Box`, `Rc`, and so on) are an immutable reference to the heap and they contain
    the actual value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 变量能否同时是不可变和可变的？当然可以。装箱变量（`Box`、`Rc`等）是对堆的不可变引用，它们包含实际值。
- en: For these kinds of containers, there is no reason why the inner variable cannot
    be changed—a task that can be done safely in Rust using `RefCell`. `RefCell` maintains
    single ownership of a value but allows mutable borrowing **checked at runtime.**
    Instead of compiler errors, violating the rules of borrowing will lead to a runtime
    `panic!`, crashing the program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些类型的容器，没有理由说内部变量不能被更改——这是一个可以在Rust中使用`RefCell`安全完成的任务。`RefCell`维护值的单一所有权，但允许在运行时进行可变借用**检查**。而不是编译器错误，违反借用规则将导致运行时`panic!`，使程序崩溃。
- en: This entire concept is called **interior mutability** and is often used in combination
    with `Rc` in order to provide a value to multiple owners with mutability at will.
    Clearly, to provide a great user experience, it is strongly recommended to make
    sure the borrowing rules can't be violated in other ways.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 整个概念被称为**内部可变性（interior mutability）**，通常与`Rc`结合使用，以便为多个所有者提供可变性的值。显然，为了提供良好的用户体验，强烈建议确保借用规则不会被其他方式违反。
- en: Wrapping a `RefCell` in an `Rc` acts as the gatekeeper for having multiple owners,
    including a way to change the contents. This is actually similar to more traditional
    programming languages such as Java or C#, where typically references are moved
    between method calls, pointing to the object's instance on the heap memory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将`RefCell`包裹在`Rc`中充当拥有多个所有者的看门人，包括更改内容的方式。这实际上类似于更传统的编程语言，如Java或C#，在这些语言中，通常在方法调用之间移动引用，指向堆内存中的对象实例。
- en: 'This pattern is very important for implementing complex programs and data structures,
    since ownership of a specific variable is not always clear. For example, later
    in the book we will examine doubly linked lists, which famously have a pointer
    to the preceding and succeeding node. Which node *should* have ownership of which
    pointer? Interior mutability allows us to say both. Consider the node declaration
    we will use later:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对于实现复杂程序和数据结构非常重要，因为特定变量的所有权并不总是明确的。例如，本书后面我们将研究双链表，它著名地有一个指向前一个和后继节点的指针。哪个节点**应该**拥有哪个指针的所有权？内部可变性允许我们说两者都有。考虑我们稍后将使用的节点声明：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this list declaration, we can see the pattern in this simpler version
    of the `append` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个列表声明，我们可以看到这个`append`函数简单版本中的模式：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code adds a new node at the front (head) of the list, which contains all
    data in the form of nodes stored on the heap. In order to add a node at the head
    of the list, the references have to be set properly, so the previous and next
    pointers actually refer to the same nodes instead of copies. A more detailed exploration
    is going to be covered in [Chapter 3](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml),
    *Lists, Lists, and More Lists*. For now, the important part is setting the variables
    using `borrow_mut()`. This mutable reference only lives as long as the assignment
    takes, thereby ruling out creating a too-large scope and violating the borrowing
    rules.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在列表的前端（头部）添加一个新节点，该节点包含所有以节点形式存储在堆上的数据。为了在列表头部添加一个节点，必须正确设置引用，以便前一个和下一个指针实际上指向相同的节点而不是副本。更详细的探索将在[第3章](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml)，“列表，列表，还有更多列表”中介绍。现在，重要部分是使用`borrow_mut()`设置变量。这个可变引用仅在赋值期间存在，因此排除了创建过大作用域并违反借用规则的可能性。
- en: By using the `RefCell` function's `borrow_mut()`, it will check for and enforce
    borrowing rules and panic in the case of a violation. Later on, we will also talk
    about the `Mutex` type, which is essentially a multithreaded version of these
    cells.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`RefCell`函数的`borrow_mut()`，它将检查并强制执行借用规则，并在违反规则的情况下引发恐慌。稍后，我们还将讨论`Mutex`类型，它本质上是多线程版本的这些单元格。
- en: Moving data
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据移动
- en: The introductory snippet showed code that spawns a thread but did not pass any
    data into the scope. Just like any other scope, it requires either ownership of
    a value or at least a borrowed reference in order to work with that data. In this
    case, passing ownership is what we want, something that is called **moving data**
    into the scope.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍片段展示了启动线程但未将任何数据传递到作用域中的代码。就像任何其他作用域一样，它需要拥有一个值的所有权或至少一个借用引用才能处理该数据。在这种情况下，传递所有权是我们想要的，这被称为**移动数据**到作用域中。
- en: 'If we change the snippet from the introduction to include a simple variable
    to print from within the thread, compilation is going to fail:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将简介中的片段修改为包含一个用于从线程内部打印的简单变量，编译将会失败：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The reason for this is simple: the compiler cannot determine the lifetimes
    of each of the scopes (will `x` still be there when the thread needs it?), so
    it refuses to compile the code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单：编译器无法确定每个作用域的生命周期（当线程需要时`x`还在吗？），因此拒绝编译代码：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As the compiler messages indicate, adding the `move` keyword will solve the
    issue! This keyword lets a thread pass ownership to a different thread; it "moves"
    the memory area:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如编译器消息所示，添加`move`关键字将解决问题！此关键字允许一个线程将所有权传递给另一个线程；它“移动”内存区域：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When running this snippet, the output is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此片段时，输出如下：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, for passing multiple messages into a thread or implementing *an actor
    model*, the Rust standard library offers channels. Channels are single-consumer,
    multi-producer queues that let the caller send messages from multiple threads.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于将多个消息传递到线程或实现**演员模型**，Rust标准库提供了通道。通道是单消费者、多生产者队列，允许调用者从多个线程发送消息。
- en: 'This snippet will spawn 10 threads and have each send a number into the channel,
    where it will be collected into a vector after the senders have finished executing:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段将启动10个线程，每个线程将一个数字发送到通道，发送者执行完毕后，这些数字将被收集到一个向量中：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As expected, the output is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，输出如下：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With these tools, a multithreaded application can move data between threads
    without the need for manual locking or the dangers of inadvertently creating side
    effects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具，多线程应用程序可以在线程之间移动数据，而无需手动锁定或无意中创建副作用的风险。
- en: Sharing data
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据共享
- en: Other than sending data into threads one way, many programs operate on a shared
    state where multiple execution streams have to access and change one or more shared
    variables. Typically, this warrants a **mutex** (short for **mutual exclusion**),
    so that any time something is accessed within this locked mutex, it is guaranteed
    to be a single thread.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将数据以某种方式发送到线程之外，许多程序在共享状态上操作，其中多个执行流必须访问和更改一个或多个共享变量。通常，这需要使用**互斥锁**（简称**互斥**），以确保在锁定互斥锁内访问任何内容时，都保证是单个线程。
- en: This is an old concept and implemented in the Rust standard library. How does
    that facilitate accessing a variable? Wrapping a variable into a `Mutex` type
    will provide for the locking mechanism, thereby making it accessible from multiple
    concurrent writers. However, they don't have ownership of that memory area yet.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个旧概念，在 Rust 标准库中实现。它是如何方便访问变量的？将变量包装成 `Mutex` 类型将提供锁定机制，从而使其可以从多个并发写入者处访问。然而，他们还没有拥有那个内存区域。
- en: 'In order to provide that ownership across threads—similar to what `Rc` does
    within a single thread—Rust provides the concept of an `Arc`, an atomic reference
    counter. Using this `Mutex` on top, it''s the thread-safe equivalent of an `Rc`
    wrapping a `RefCell`, a reference counter that wraps a mutable container. To provide
    an example, this works nicely:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在多个线程之间提供这种所有权——类似于 `Rc` 在单个线程中所做的——Rust 提供了 `Arc` 的概念，一个原子引用计数器。使用这个 `Mutex`，它是一个线程安全的
    `Rc` 包装 `RefCell` 的等价物，一个包装可变容器的引用计数器。为了提供一个例子，这工作得很好：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When running this example, the output is this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此示例时，输出如下：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While the preferred way of doing concurrent programming is still to use immutable
    variables as often as possible, safe Rust provides the tools for working with
    shared data without side effects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然进行并发编程的首选方式仍然是尽可能多地使用不可变变量，但安全的 Rust 提供了处理共享数据而不产生副作用的工具。
- en: Send and Sync
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Send 和 Sync
- en: 'These marker traits are fundamental to Rust''s multithreading policies. They
    have distinct purposes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标记特质是 Rust 多线程策略的基础。它们有各自的目的：
- en: '`Send`: A data type is safe to send (move) from one thread to the other'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Send`: 数据类型可以安全地从一条线程发送（移动）到另一条线程'
- en: '`Sync`: The data type can be shared across threads without manual locks or
    mutex areas'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sync`: 数据类型可以在线程之间共享，无需手动锁或互斥区域'
- en: These marker traits are implemented in all basic types of the standard library
    and can be inherited for custom types (if all properties of a type are `Sync`,
    then the type itself is `Sync` too).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标记特质在标准库的所有基本类型中实现，并且可以继承到自定义类型中（如果一个类型的所有属性都是 `Sync`，那么该类型本身也是 `Sync`）。
- en: Implementing `Sync` or `Send` is unsafe because there is no way for the compiler
    to know if you are right and the code can be shared/sent between threads, which
    is why it's very unusual to do this.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `Sync` 或 `Send` 是不安全的，因为编译器无法知道你是否正确，代码是否可以在线程之间共享/发送，这就是为什么这样做非常不寻常。
- en: In case your program requires this depth of Rust programming, be sure to read
    up on this topic in the *Rust Book*, chapter 16 ([https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html](https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序需要这种深度的 Rust 编程，务必阅读《Rust 书》第 16 章（[https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html](https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html)）的相关内容。
- en: Deeper into Rust
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入 Rust
- en: 'Another one of Rust''s strong points is its thriving community. Many users
    actively participate in their local community (by going to or organizing meetups)
    or online via working groups, the IRC/Discord channel, or the official forum.
    The most important online resources are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的另一个强点是它繁荣的社区。许多用户积极参与他们的本地社区（通过参加或组织聚会）或通过工作组、IRC/Discord 频道或官方论坛在线参与。以下是最重要的在线资源：
- en: 'The main website with pointers to various resources: [https://www.rust-lang.org](https://www.rust-lang.org)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主网站，包含指向各种资源的链接：[https://www.rust-lang.org](https://www.rust-lang.org)
- en: 'The Rust user forum: [https://users.rust-lang.org](https://users.rust-lang.org)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 用户论坛：[https://users.rust-lang.org](https://users.rust-lang.org)
- en: 'The official Twitter account: [https://twitter.com/rustlang](https://twitter.com/rustlang)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的 Twitter 账号：[https://twitter.com/rustlang](https://twitter.com/rustlang)
- en: A collection of IRC channels at [https://wiki.mozilla.org/Rust](https://wiki.mozilla.org/Rust)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列位于 [https://wiki.mozilla.org/Rust](https://wiki.mozilla.org/Rust) 的 IRC 频道
- en: 'Rust''s official blog: [https://blog.rust-lang.org](https://blog.rust-lang.org)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 的官方博客：[https://blog.rust-lang.org](https://blog.rust-lang.org)
- en: 'The Rust Book: [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Rust 书》：[https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)
- en: Other than that, users have created additional content, such as podcasts, blogs,
    and various tools and libraries. The most impressive user contributions, however,
    can be found in the core language!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，用户还创建了额外的内容，例如播客、博客以及各种工具和库。然而，最令人印象深刻的用户贡献可以在核心语言中找到！
- en: Rust's official GitHub repository at [https://github.com/rust-lang](https://github.com/rust-lang)
    holds the source code for many of the resources (for example, the website, blog,
    book, and documentation), and contributions are very welcome.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的官方GitHub仓库位于[https://github.com/rust-lang](https://github.com/rust-lang)，其中包含了众多资源（例如网站、博客、书籍和文档）的源代码，并且非常欢迎贡献。
- en: Mozilla has an impressive record of creating and fostering open source communities,
    and Rust is no different. As active members of these communities, we encourage
    everyone to take part and help make Rust the most enjoyable and useful language
    around!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla在创建和培养开源社区方面有着令人印象深刻的记录，Rust也不例外。作为这些社区的活跃成员，我们鼓励每个人参与进来，帮助使Rust成为最受欢迎和最有用的语言之一！
- en: Requests for Comments (RFCs)
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求评论（RFCs）
- en: Due to the open source nature of Rust, there are some governance rules in place
    to maintain stable and flexible interfaces, yet encourage change and discussion
    as the language evolves.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Rust的开源特性，有一套治理规则在位，以保持接口的稳定性和灵活性，同时鼓励随着语言的发展进行变革和讨论。
- en: For something as sensitive as a programming language and its standard library,
    a more rigid process than the regular pull request approval is required to have
    deeper discussions. Imagine the impact of changing a single keyword and how many
    projects would stop working immediately!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像编程语言及其标准库这样敏感的事物，比常规的拉取请求审批更严格的过程是必要的，以便进行更深入的讨论。想象一下更改单个关键字的影响，以及会有多少项目立即停止工作！
- en: This is where RFCs come in. They provide a way for all stakeholders to contribute
    to the discussion with an equal chance to comment. A typical workflow for integrating
    change in open source projects uses the fork and pull method where the contributor
    creates a **pull request** (**PR**) to propose changes ([https://help.github.com/articles/about-pull-requests/](https://help.github.com/articles/about-pull-requests/)).
    Unlike in the RFC process, this gets hard to manage in larger code bases and only
    starts the discussion *after* a solution has been proposed, narrowing the focus
    considerably.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是RFCs发挥作用的地方。它们为所有利益相关者提供了一个平等的机会来参与讨论。开源项目中整合变更的典型工作流程使用的是分支和拉取请求方法，其中贡献者创建一个**拉取请求**（**PR**）来提出变更（[https://help.github.com/articles/about-pull-requests/](https://help.github.com/articles/about-pull-requests/)）。与RFC过程不同，在大型代码库中这很难管理，并且只有在解决方案提出之后才开始讨论，大大缩小了焦点。
- en: 'A repository of active and past RFCs can be found here: [https://github.com/rust-lang/rfcs](https://github.com/rust-lang/rfcs).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃和过去的RFCs的仓库可以在这里找到：[https://github.com/rust-lang/rfcs](https://github.com/rust-lang/rfcs)。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Rust is a multi-paradigm language with exceptional concepts: the language emphasizes
    data and behavior separation with structures and traits, uses macros for metaprogramming,
    and leverages explicit ownership of memory to determine variable lifetimes. Knowing
    these lifetimes removes the need for runtime garbage collection and, at the same
    time, greatly facilitates concurrency by allowing mutable borrowing only in certain
    circumstances.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Rust是一种多范式语言，具有卓越的概念：该语言强调通过结构和特性实现数据和行为的分离，使用宏进行元编程，并利用显式的内存所有权来确定变量的生命周期。了解这些生命周期可以消除运行时垃圾收集的需要，同时，通过仅在特定情况下允许可变借用，极大地促进了并发性。
- en: Consequently, threads and other asynchronous processes can change variables
    only when they have mutable ownership of them, something that is mostly enforced
    at compile time, but can also be done at runtime! Therefore, safe Rust is effectively
    free of data races.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，线程和其他异步进程只能在它们拥有可变所有权时更改变量，这通常在编译时强制执行，但也可以在运行时完成！因此，安全的Rust实际上没有数据竞争。
- en: Another strong point of the Rust ecosystem is its diverse and welcoming community.
    Sponsored by Mozilla, development is guided by RFCs, events are organized and
    centrally advertised, and learning resources are available online. Another way
    to be a part of the ecosystem is to contribute packages to `crates.io` ([https://crates.io/](https://crates.io/)),
    Rust's public package repository. Read the next chapter to find out more about
    `cargo`, Rust's universal tool to build and package.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Rust生态系统另一个显著的优势是其多元化和包容性的社区。Mozilla赞助了社区的发展，开发过程由RFCs指导，活动由中心组织并宣传，在线上提供学习资源。成为生态系统的一部分另一种方式是向`crates.io`（[https://crates.io/](https://crates.io/)），Rust的公共包仓库贡献包。阅读下一章，了解更多关于`cargo`的信息，它是Rust构建和打包的通用工具。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are traits and how are they different from interfaces?
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性和接口有什么不同？
- en: Why doesn't Rust have a garbage collector?
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 Rust 没有垃圾回收器？
- en: Name three examples of how lifetimes are created in Rust (explicitly and implicitly)!
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举三个在 Rust 中创建生命周期（显式和隐式）的例子！
- en: Why is immutability for variables important?
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的不可变性为什么很重要？
- en: What does the Sync marker trait do?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步标记特性有什么作用？
- en: Where can you go to participate in the Rust community?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以去哪里参与 Rust 社区？
- en: Why are RFCs preferred over PRs?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 RFC 比 PR 更受欢迎？
- en: Further reading
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Refer to the following books for more information:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下书籍提供了更多信息：
- en: '*Hands-On Concurrency with Rust* by Brian L. Troutwine (Packt)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Rust并发实战》* by Brian L. Troutwine (Packt)'
- en: '*Functional Programming in Rust* by Andrew Johnson (Packt)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Rust中的函数式编程》* by Andrew Johnson (Packt)'
