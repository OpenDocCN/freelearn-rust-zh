- en: Chapter 4. Structuring Data and Matching Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 结构化数据和模式匹配
- en: 'Until now we have only used simple data, but to do real programming, more composite
    and structured data values are needed. Among them are flexible arrays and tuples,
    enums, and structs that represent more object-like behavior, similar to that found
    in classical object-oriented languages. Options are another important type that
    are used to ensure that cases where no value is returned are accounted for. Then,
    we will look at pattern matching, which is another typical functional construct
    in Rust. However, we will start by looking more carefully at strings. We will
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止我们只使用了简单的数据，但要进行真正的编程，需要更多复合和结构化的数据值。其中包含灵活的数组、元组和枚举，以及表示更类似面向对象语言中对象行为的结构体。选项是另一种重要的类型，用于确保考虑了没有返回值的情况。然后，我们将探讨模式匹配，这是Rust中另一种典型的函数式结构。然而，我们将首先更仔细地查看字符串。我们将涵盖以下主题：
- en: Strings
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Arrays, vectors, and slices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组、向量和切片
- en: Tuples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Structs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Enums
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Getting input from the console
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从控制台获取输入
- en: Matching patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Strings
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'The way Rust works with strings differs a bit to how strings work in other
    languages. All strings are valid sequences of Unicode (UTF-8) bytes. They can
    contain null bytes, but they are not null terminated as in C. Rust distinguishes
    two types of strings:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Rust处理字符串的方式与其他语言中的字符串处理方式略有不同。所有字符串都是有效的Unicode（UTF-8）字节序列。它们可以包含空字节，但它们不是以空字符终止，如C语言中的那样。Rust区分两种类型的字符串：
- en: 'Literal strings, which we have used until now, are string slices whose type
    is `&str`. The `&` character points out that the string slice is a reference to
    a string. They are immutable and have a fixed size. For example, the following
    bindings declare string slices:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直至现在我们所使用的字面量字符串，是类型为`&str`的字符串切片。`&`字符表示字符串切片是字符串的引用。它们是不可变的，并且具有固定的大小。例如，以下绑定声明了字符串切片：
- en: '[PRE0]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Otherwise, we care to explicitly annotate the string variable with its type:'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，我们关心的是明确注释字符串变量及其类型：
- en: '[PRE1]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `&''static` command denotes that the string is statically allocated. We
    saw this notation earlier in [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*, when we declared global string
    constants. In that case, indicating the type was mandatory, but for a let binding,
    it is superfluous because the compiler infers the type:'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`&''static`命令表示字符串是静态分配的。我们之前在[第二章](part0023.xhtml#aid-LTSU1 "第二章 使用变量和类型")中看到了这种表示法，即当我们声明全局字符串常量时。在那个情况下，指定类型是强制性的，但对于一个`let`绑定来说，它是多余的，因为编译器可以推断类型：'
- en: '[PRE2]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Prints out: `Magician Merlin greets magician Gandalf with Hello,` `世界` `!`'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印输出：`魔术师梅林向魔术师甘道夫问候，世界！`
- en: These strings live as long as the program; they have the lifetime of the program,
    which is the static lifetime. They are described in the `std::str` module.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些字符串与程序的生命周期相同；它们具有程序的静态生命周期。它们在`std::str`模块中进行了描述。
- en: 'A `String` on the other hand can grow dynamically in size (it is in fact a
    buffer), and so it must be allocated on the heap. We can create an empty string
    with the following snippet:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`String`可以动态地增长大小（实际上是一个缓冲区），因此它必须在堆上分配。我们可以使用以下代码片段创建一个空字符串：
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each time the string grows, it has to be reallocated in the memory. So, for
    example, if you know that it will start out as 25 bytes , you can create the string
    by allocating this amount of memory as follows:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次字符串增长时，它都必须在内存中重新分配。所以，例如，如果你知道它将开始为25个字节，你可以通过以下方式分配这么多的内存来创建字符串：
- en: '[PRE4]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This type is described in the `std::string` module. To convert a string slice
    into a String, use the `to_string` method:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此类型在`std::string`模块中进行了描述。要将字符串切片转换为String，请使用`to_string`方法：
- en: '[PRE5]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `to_string()` method can be used to convert any object into a `String` (more
    precisely, any object that implements the `ToString` trait; we will talk about
    traits in the next chapter). This method allocates memory on the heap.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`to_string()`方法可以用于将任何对象转换为`String`（更精确地说，任何实现了`ToString`特质的对象；我们将在下一章讨论特质）。此方法在堆上分配内存。'
- en: 'If `str3` is a String, then you can make a string slice from it with `&str3`
    or `&str3[..]`:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`str3`是一个String，那么你可以使用`&str3`或`&str3[..]`从它创建一个字符串切片：
- en: '[PRE6]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A string slice created this way can be considered as a view into the `String`.
    It is a reference to the interior of the String and making it has no cost involved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建的字符串切片可以被视为对`String`的视图。它是String内部的引用，对其进行操作没有成本。
- en: 'I prefer this way instead of `to_string()` when comparing strings because using
    `&[..]` doesn''t consume resources while `to_string()` allocates heap memory:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢这种方式而不是`to_string()`来比较字符串，因为使用`&[..]`不会消耗资源，而`to_string()`会分配堆内存：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To build a String, we can use a number of methods, which are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个`String`，我们可以使用多种方法，如下所示：
- en: 'The `push` method: This appends a character to the String'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`方法：将一个字符追加到`String`'
- en: 'The `push_str` method: This appends another string to the String'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push_str`方法：将另一个字符串追加到`String`'
- en: 'You can see them in action in the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下代码片段中看到它们的作用：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you need to get the characters of a `String` one by one and in order, use
    the `chars()` method. This method returns an `Iterator`, so we can use the for
    in loop (see the *Looping* section of [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要逐个按顺序获取`String`的字符，请使用`chars()`方法。此方法返回一个`Iterator`，因此我们可以使用for in循环（参见第2章的*循环*部分，*使用变量和类型*），如下所示：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Which prints out: `M - e - r - l - i - n -`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果为：`M - e - r - l - i - n -`.
- en: 'To loop over the parts of a `String` that are separated by whitespace, we can
    use the `split()` method, which also returns an `Iterator`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历由空格分隔的`String`部分，我们可以使用`split()`方法，该方法还返回一个`Iterator`：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Which prints out: `q` `/ Level / 1 / is / finished / - / Rise / up / to / Level
    / 2 /`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果为：`q` `/ Level / 1 / is / finished / - / Rise / up / to / Level / 2 /`.
- en: 'To change the first part of a `String` that matches with another string, use
    the `replace` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改与另一个字符串匹配的`String`的第一部分，请使用`replace`方法：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code allocates new memory for the modified `str5` string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码为修改后的`str5`字符串分配了新的内存。
- en: 'When you write a function that takes a string as an argument, always declare
    it as a string slice, which is a view into the string, as shown in the following
    code snippet:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写一个接受字符串作为参数的函数时，始终将其声明为字符串切片，这是一个字符串的视图，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The reason for this is that passing a String `str1` as argument allocates memory,
    so we better pass it as a slice. The easiest and most elegant way to do this is
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是传递`String` `str1`作为参数会分配内存，所以我们最好将其作为切片传递。这样做最简单、最优雅的方式如下：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Consult the documentation at [http://doc.rust-lang.org/std/str/](http://doc.rust-lang.org/std/str/)
    and [http://doc.rust-lang.org/std/string/](http://doc.rust-lang.org/std/string/)
    for more functionality. Here is a schema to see the difference between the two
    string types more clearly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[http://doc.rust-lang.org/std/str/](http://doc.rust-lang.org/std/str/)和[http://doc.rust-lang.org/std/string/](http://doc.rust-lang.org/std/string/)的文档以获取更多功能。以下是一个更清晰地显示两种字符串类型之间差异的方案：
- en: '| String | String slice (&str) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 字符串切片(&str) |'
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| mutable – heap memory allocationmodule: std::string | fixed size – view on
    String – reference(&)module: std::str |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 可变 – 堆内存分配模块：`std::string` | 固定大小 – `String`的视图 – 引用(&)模块：`std::str` |'
- en: Arrays, vectors, and slices
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组、向量和切片
- en: 'Suppose we have a bunch of alien creatures to populate a game level, then we
    would probably want to store their names in a handy list. Rust''s array is just
    what we need:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一群外星生物来填充游戏关卡，那么我们可能希望将它们的名称存储在一个方便的列表中。Rust的数组正是我们所需要的：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To make an array, separate the different items by commas and enclose the whole
    thing within `[ ]` (rectangular brackets). All the items must be of the same type.
    Such an array must be of a fixed size (this must be known at compile time) and
    cannot be changed; this is stored in one contiguous piece of memory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数组，请用逗号分隔不同的项目，并将整个内容括在`[ ]`（方括号）内。所有项目都必须是同一类型。这样的数组必须是固定大小的（这必须在编译时已知）且不能更改；这是存储在一个连续的内存块中。
- en: 'If the items have to be modifiable, declare your array with `let mut`; however,
    even then the number of items cannot change. The aliens array could be of the
    type that is annotated as `[&str; 4]` where the first parameter is the type of
    the items and the second is their number:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目需要可修改性，请使用`let mut`声明您的数组；然而，即使在这种情况下，项目数量也不能改变。外星人数组可以是类型注释为`[&str; 4]`的类型，其中第一个参数是项目类型，第二个是它们的数量：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we want to initialize an array with three `Zuxus`, that''s easy too:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用三个`Zuxus`初始化一个数组，这也很简单：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'How would you then make an empty array? This is shown as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么您如何创建一个空数组？如下所示：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also access individual items with their index, starting from 0:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过它们的索引访问单个项目，从0开始：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The number of items in the array is given by `aliens.len()`; so, how would you
    get the last item? Exactly! By using `aliens[aliens.len() - 1]`. Alternatively,
    this can be found by using `aliens.iter().last().unwrap();`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的元素数量由 `aliens.len()` 给出；那么，你是如何获取最后一个元素的？正是这样！通过使用 `aliens[aliens.len()
    - 1]`。或者，这也可以通过使用 `aliens.iter().last().unwrap();` 来找到。
- en: 'Pointers to arrays use automatic dereferencing so that you do not need to use
    `*` explicitly, as demonstrated in this code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的指针使用自动解引用，因此你不需要显式地使用 `*`，如以下代码片段所示：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Which prints: `Third item via pointer: Shirack`. What do you think will happen
    when we try to change an item as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印出：`通过指针访问的第三个元素：Shirack`。你认为当我们尝试如下方式更改一个元素时会发生什么：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hopefully, you didn't think that Rust would allow this, did you? Unless you
    told it explicitly that aliens can change with let `mut aliens = […];` then it
    is alright!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你没有认为 Rust 会允许这样做，对吧？除非你明确地告诉它外星人可以通过 `let mut aliens = [...];` 来改变，否则这是可以的！
- en: 'The index is also checked at runtime to be within the array bounds of 0 and
    `aliens.len();` if it is not, the program will crash with a runtime error or panic:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 索引在运行时也会检查是否在数组的界限内，即0和 `aliens.len()`；如果不是，程序将因运行时错误或恐慌而崩溃：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It gives the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了以下输出：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we want to go through the items successively one by one and print them out
    or do something useful with them, we can do it as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想逐个连续地遍历元素并打印它们或对它们进行一些有用的操作，我们可以这样做：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This works and it gives us the index for each item, which might be useful.
    However, when we use the index to fetch each consecutive item, Rust also has to
    check each time whether we are still within the bounds of the array in memory.
    That''s why this is not very efficient, and in the *Iterators* section of [Chapter
    5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing Code with Higher-order Functions
    and Parametrization"), *Generalizing Code with Higher-order Functions and Parametrization*,
    we will see a much more efficient way by iterating over the items as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，并且它为我们提供了每个元素的索引，这可能很有用。然而，当我们使用索引来获取每个连续的元素时，Rust 也必须每次检查我们是否仍然在内存数组的界限内。这就是为什么这并不非常高效，在[第5章](part0046.xhtml#aid-1BRPS1
    "第5章。使用高阶函数和参数化泛化代码")的*迭代器*部分，*使用高阶函数和参数化泛化代码*，我们将看到一种更高效的方法，如下迭代元素：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `for` loop can be written even shorter as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环可以写成更短的形式如下：'
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Vectors
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: 'Often, it is more practical to work with a kind of array that can grow (or
    shrink) in size because it is allocated on the heap. Rust provides this through
    the `Vec` vector type from the `std::vec` module. This is a generic type, which
    means that the items can have any `T` type, where `T` is specified in the code;
    for example, we can have vectors of the `Vec<i32>` type or the `Vec<&str>` type.
    To indicate that this is of the generic type, it is written as `Vec<T>`. Again,
    all elements must be of the same `T` type. We can make a vector in two ways, with
    `new()` or with the `vec!` macro. These are shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与可以增长（或缩小）大小的数组一起工作更为实用，因为它是分配在堆上的。Rust 通过 `std::vec` 模块中的 `Vec` 向量类型提供了这一点。这是一个泛型类型，这意味着元素可以具有任何
    `T` 类型，其中 `T` 在代码中指定；例如，我们可以有 `Vec<i32>` 类型或 `Vec<&str>` 类型的向量。为了表示这是一个泛型类型，它被写成
    `Vec<T>`。同样，所有元素都必须是相同的 `T` 类型。我们可以用两种方式创建一个向量，使用 `new()` 或使用 `vec!` 宏。这些在这里展示：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the first case, the type is indicated explicitly with `Vec<i32>`; in the
    second case, this is done by giving the first item an `i32` suffix, but this is
    usually optional.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，类型通过 `Vec<i32>` 明确指示；在第二种情况下，这是通过给第一个元素添加 `i32` 后缀来完成的，但这通常是可选的。
- en: 'We can also make a new vector and allocate an initial memory size to it, which
    can be useful if you know in advance that you will need at least that many items.
    The following initializes a vector for signed integers with a memory allocated
    for 25 integers:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个新的向量并为其分配一个初始内存大小，如果你事先知道你至少需要那么多元素，这可能会很有用。以下初始化了一个用于有符号整数的向量，并为25个整数分配了内存：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We need to provide the type here, otherwise the compiler would not be able to
    calculate the amount of memory needed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里提供类型，否则编译器无法计算所需的内存量。
- en: 'A vector can also be constructed from an iterator through the `collect()` method
    with a range, such as in this example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 向量也可以通过 `collect()` 方法和一个范围来从迭代器构建，例如在这个例子中：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'which prints out: `Collected the range into: [0, 1, 2, 3, 4, 5, 6]`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印出：`将范围收集到：[0, 1, 2, 3, 4, 5, 6]`。
- en: 'Indexing, getting the length, and looping over a vector works the same as with
    arrays. For example, a `for` loop over a vector can be written simply as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 索引、获取长度和遍历向量与数组的工作方式相同。例如，一个遍历向量的 `for` 循环可以简单地写成以下形式：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a new item to the end of a vector with `push()`, remove the last item with
    `pop()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `push()` 向向量的末尾添加新项，使用 `pop()` 移除最后一个项：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If a function needs to return many values of the same type, you can make an
    array or vector with these values and return that object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数需要返回许多相同类型的值，你可以用这些值创建一个数组或向量，并返回该对象。
- en: Slices
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: What would you do if you want to do something with a part of an array or a vector?
    Perhaps, your first idea is to copy that part out to another array, but Rust has
    a safer and more efficient solution; take a slice of the array. No copy is needed,
    instead you get a view into the existing array, similar to how a string slice
    is a view into a string.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对数组或向量的某个部分进行操作，你可能会首先想到将这部分复制到另一个数组中，但 Rust 有一个更安全、更高效的解决方案；取数组的切片。不需要复制，而是你得到对现有数组的视图，类似于字符串切片是字符串的视图。
- en: 'As an example, suppose I only need the numbers 42, 47, and 45 from our `magic_numbers`
    vector. Then, I can take the following slice:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我只需要从我们的 `magic_numbers` 向量中获取数字 42、47 和 45。那么，我可以采取以下切片：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The starting index 1 is the index of 42, the last index 4 points to 54, but
    this item is not included. The `&` shows that we are referencing an existing memory
    allocation. Slices share the following with vectors:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 起始索引 1 是 42 的索引，最后一个索引 4 指向 54，但这个项不包括在内。`&` 表示我们正在引用现有的内存分配。切片与向量共享以下特点：
- en: They are generic and have the `&[T]` type for a `T` type
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是泛型的，对于 `T` 类型具有 `&[T]` 类型
- en: Their size does not have to be known at compile time
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的大小不必在编译时已知
- en: Strings and arrays
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串和数组
- en: Back in the first section of this chapter, we saw that the sequence of characters
    in a `String` is given by the `chars()` function. Doesn't this look like an array
    to you? A `String` is backed up by an array if we look at the memory allocation
    of its characters; it is stored as a vector of bytes `Vec<u8>`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一节中，我们看到了 `String` 中的字符序列是由 `chars()` 函数给出的。这看起来像数组吗？如果我们查看 `String` 字符的内存分配，它是由数组支持的；它存储为一个字节数组
    `Vec<u8>` 的向量。
- en: 'This means that we can also take a slice of the `&str` type from a `String`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们也可以从 `String` 中取出 `&str` 类型的切片：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can collect the characters of a slice into a vector and sort them as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将切片的字符收集到一个向量中，并按如下方式排序：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This prints out `M e i l n r` (capital letters come before small letters in
    the sort order). Here are some other examples of using the `collect()` method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出 `M e i l n r`（在排序顺序中，大写字母先于小写字母）。以下是一些使用 `collect()` 方法的其他示例：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, `split()` takes a closure to determine on which character to split. Both
    the slice types, `&str` and `&[T]`, can be seen as views into `Strings` and vectors
    respectively. The following scheme compares the types that we just encountered
    (`T` denotes a generic type):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`split()` 接收一个闭包来决定在哪个字符上分割。切片类型 `&str` 和 `&[T]` 可以分别看作是 `Strings` 和向量的视图。以下方案比较了我们刚刚遇到的类型（`T`
    表示一个泛型类型）：
- en: '| Fixed-size(stack allocated) | Slices |   | Dynamic size (growable)(heap allocated)
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 固定大小（栈分配） | 切片 |   | 动态大小（可增长）（堆分配） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|   | `&str``type: &[u8]` | is a view into | `String` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|   | `&str``类型: &[u8]` | 是视图到 | `String` |'
- en: '| array type: `[T;size]` | slice type: `&[T]` | is a view into | Vector type:
    `Vec<T>` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 数组类型: `[T;size]` | 切片类型: `&[T]` | 是视图到 | 向量类型: `Vec<T>` |'
- en: 'Perform the following exercise by referring to `Chapter 4/exercises/chars_string.rs`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参考 `Chapter 4/exercises/chars_string.rs` 执行以下练习：
- en: Try out whether you can get the first or the fifth character of a string by
    using `[0]` or `[4]`
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 `[0]` 或 `[4]` 来获取字符串的第一个或第五个字符
- en: Compare the `bytes()` method with `chars()` on the `let greeting = "Hello,`
    `世界``!";` string
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `bytes()` 方法与 `chars()` 方法在 `let greeting = "Hello,` `世界``!";` 字符串上比较
- en: Tuples
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'If you want to combine a certain number of values of different types, then
    you can collect them in a tuple, which is enclosed between parentheses (`( )`)
    and separated by commas, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要组合一定数量的不同类型的值，那么你可以将它们收集在一个元组中，元组用括号 `(` `)` 括起来，并用逗号分隔，如下所示：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The type of `thor` is `(&str, bool, u32)`, that is: the tuple of the item''s
    types. To extract an item on an index, use a dot-syntax:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`thor` 的类型是 `(&str, bool, u32)`，即：项类型的元组。要在一个索引上提取一个项，使用点语法：'
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another way to extract items to other variables is by *destructuring* the tuple:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将项目提取到其他变量中的方法是通过对元组进行*解构*：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Which prints out: `Thor has 3500 points of power`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出：`索尔有3500点力量值`。
- en: Here the `let` statement matches the pattern on the left with the right-hand
    side. The `_` indicates that we are not interested in the second item of `thor`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`let`语句将左侧的模式与右侧匹配。`_`表示我们对`thor`的第二个项目不感兴趣。
- en: 'Tuples can only be assigned to one another or compared with each other if they
    are of the same type. A one-element tuple needs to be written: `let one = (1,);`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元组具有相同的类型，则它们只能相互赋值或比较。一个单元素元组需要这样写：`let one = (1,);`。
- en: 'A function that needs to return some values of different types can collect
    them in a tuple and return that tuple as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 需要返回不同类型一些值的函数可以将它们收集在元组中，并如下返回该元组：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we call this with the following code snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用以下代码片段调用它：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is: `This god Thor has now 10500 strength`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：`这个神索尔现在有10500点力量值`。
- en: 'Perform the following exercise by referring to the code at `Chapter 4/exercises/tuples_ex.rs)`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参考`Chapter 4/exercises/tuples_ex.rs)`中的代码进行以下练习：
- en: Try to compare the tuples (2, 'a') and (5, false) and explain the error message.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试比较元组`(2, 'a')`和`(5, false)`，并解释错误信息。
- en: Make an empty tuple. Haven't we encountered this before? So, the unit value
    is in fact an empty tuple!
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空元组。我们之前没有遇到过吗？所以，单元值实际上是一个空元组！
- en: Structs
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: 'Often, you might need to keep several values of possibly different types together
    in your program; for example, the scores of the players. Let us assume that the
    score contains numbers that indicate the health of the players and the level at
    which they are playing. The first thing that you can then do to clarify your code
    is to give these tuples a common name, such as struct Score or better still, you
    can indicate the types of the values: `struct Score(i32, u8)` and we can make
    a score as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能需要在程序中将几个不同类型的值一起保存；例如，玩家的得分。让我们假设得分包含表示玩家健康和他们在哪个级别上玩游戏的数字。然后你可以做的第一件事是为这些元组赋予一个共同的名称，例如`struct
    Score`，或者更好的是，你可以指示值的类型：`struct Score(i32, u8)`，然后我们可以创建一个得分如下：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'These are called tuple structs because they resemble tuples very much. The
    values contained in them can be extracted as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为元组结构体，因为它们非常类似于元组。它们包含的值可以按如下方式提取：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Which prints out: `Health 73 - Level 2`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出：`健康 73 - 级别 2`。
- en: 'A tuple struct with only one field (called a newtype) gives us the possibility
    to create a new type that is based on an old one so that both have the same memory
    representation. Here is an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个字段（称为新类型）的元组结构体使我们能够创建一个基于旧类型的新类型，这样它们就有相同的内存表示。以下是一个例子：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This prints: `weight is 250 kilograms`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印：`重量是250公斤`。
- en: 'However, we will still have to remember what these numbers mean and to which
    players they belong. We can make coding much simpler by defining a struct with
    named fields:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要记住这些数字的含义以及它们属于哪个玩家。我们可以通过定义一个具有命名字段的`struct`来使编码更加简单：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This could be defined inside `main()` or outside it, although the latter is
    preferred. Now, we can make player instances or objects as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在`main()`内部或外部定义，尽管后者更受欢迎。现在，我们可以创建玩家实例或对象如下：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note the curly braces (`{ }`) around the object and the `key: value` syntax.
    The `nname` field is a constant string, and Rust requires that we indicate its
    lifetime, how long this string will be needed in the program. We used the global
    scope, `&''static`, from the *Global constants* section in [Chapter 2](part0023.xhtml#aid-LTSU1
    "Chapter 2. Using Variables and Types"), *Using Variables and Types*.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '注意对象周围的括号（`{ }`）和`key: value`语法。`nname`字段是一个常量字符串，Rust要求我们指出其生命周期，即这个字符串在程序中需要多长时间。我们在全局作用域中使用了`&''static`，来自[第2章](part0023.xhtml#aid-LTSU1
    "第2章。使用变量和类型")的*全局常量*部分，*使用变量和类型*。'
- en: 'We can access the fields of the instance with the dot-notation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用点符号来访问实例的字段：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The struct variable has to be declared as mutable if the field values can change;
    for example, when the player enters a new level:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段值可以改变，结构变量必须声明为可变的；例如，当玩家进入新关卡时：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By convention, the name of a struct always starts with a capital letter and
    follows CamelCase. It also defines a type of its own, which is composed of the
    types of its items.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，结构体的名称始终以大写字母开头，并遵循驼峰命名法。它还定义了一个由其项目类型组成的自己的类型。
- en: 'Like tuples, structs can also be destructured in a `let` binding, for example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组一样，结构体也可以在 `let` 绑定中进行解构，例如：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Which prints out: `Player Dzenan has health 73`. This shows that you can rename
    fields, reorder them if you want, or leave fields out with.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印出：`Player Dzenan has health 73`。这表明你可以重命名字段，如果你想的话可以重新排序它们，或者省略字段。
- en: 'Pointers carry out automatic dereferencing when accessing data structure elements,
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 指针在访问数据结构元素时执行自动解引用，如下所示：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Structs are quite similar to the records or structs in C or even classes in
    other languages. In [Chapter 5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing
    Code with Higher-order Functions and Parametrization"), *Generalizing Code with
    Higher-order Functions and Parametrization*, we will see how we can define methods
    on structs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体（Structs）与 C 语言中的记录或结构体非常相似，甚至与其他语言中的类相似。在 [第 5 章](part0046.xhtml#aid-1BRPS1
    "第 5 章。使用高阶函数和参数化泛化代码")，*使用高阶函数和参数化泛化代码* 中，我们将看到如何定义结构体上的方法。
- en: 'Perform the following exercise by referring to the code in `Chapter 4/exercises/monster.rs`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第 4 章/exercises/monster.rs 中的代码执行以下练习：
- en: Define a `Monster` struct with the health and damage fields. Then, make a `Monster`
    and show its condition.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个具有健康和伤害字段的 `Monster` 结构体。然后，创建一个 `Monster` 并显示其状态。
- en: Enums
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举（Enums）
- en: 'If something can be only one of a limited number of named values, then define
    it as an enum. For example, if our game needs the compass directions, we could
    define it as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个值只能是有限数量的命名值之一，则将其定义为枚举。例如，如果我们的游戏需要指南针方向，我们可以定义如下：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And then use it as shown in `main()` or another function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照 `main()` 或另一个函数中的示例使用它：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The enum''s values can also be of other types or structs, as in this example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的值也可以是其他类型或结构体，如下例所示：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Enums are sometimes called union types or algebraic data types in other languages.
    If we make a `use` function at the start of the code file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，枚举有时被称为联合类型或代数数据类型。如果我们在一开始就在代码文件中创建一个 `use` 函数：
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, the type can be shortened, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，类型可以缩短，如下所示：
- en: '[PRE54]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Enums are really nice to bring clarity in your code, and they are used a lot
    in Rust. To apply them usefully in code, see the *Matching patterns* section of
    this chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举在使代码清晰方面非常出色，并且在 Rust 中使用得很多。要有效地在代码中使用它们，请参阅本章的 *匹配模式* 部分。
- en: Result and Option
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Result 和 Option
- en: 'Here, we look at two kinds of enums that are pervasive in a Rust code. A *Result*
    is a special kind of enum that is defined in the standard library. It is used
    whenever something is executed, that can either end:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们查看 Rust 代码中普遍存在的两种枚举。*Result* 是在标准库中定义的一种特殊枚举。当执行某些操作，可能以以下两种方式结束时使用：
- en: Successfully, then an `Ok` value (of a certain type `T`) is returned
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功的话，则返回一个 `Ok` 值（某种类型 `T`）
- en: With an error, then an `Err` value (of type `E`) is returned
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出错时，则返回一个 `Err` 值（类型 `E`）
- en: 'Since this situation is so common, provision is made so that the value `T`
    and error `E` types can be as general or generic as possible. The Result enum
    is defined as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种情况很常见，因此提供了这样的规定，即值 `T` 和错误 `E` 类型可以尽可能通用或泛型。Result 枚举定义如下：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'An *Option* is another enum that is defined in the standard library. It is
    used whenever there is a value, but there can also be a possibility that there
    is no value. For example, suppose our program expects to read a value from the
    console. However, when it is run as a background program by accident, it will
    never get an input value. Rust wants to be on the safe side whenever it is possible,
    so in this case, it is better to read the value as an Option enum with two possibilities:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*Option* 是在标准库中定义的另一个枚举。当存在值时使用，但也可能不存在值。例如，假设我们的程序期望从控制台读取一个值。然而，当它意外地作为后台程序运行时，它将永远不会得到输入值。Rust
    希望在可能的情况下始终采取安全措施，因此在这种情况下，最好将值读取为具有两种可能性的 Option 枚举：'
- en: '`Some`, if there is a value'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Some`，如果有值'
- en: '`None`, if there is no value'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`，如果没有值'
- en: 'This value can be of any type `T`, so option again is defined as a generic
    type:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值可以是任何类型 `T`，因此选项再次被定义为泛型类型：
- en: '[PRE56]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Getting input from the console
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从控制台获取输入
- en: Suppose we want to capture the nicknames of our players before starting the
    game; how would we do that? Input/output functionality is handled by the `io`
    module in the `std` crate. It has a `stdin()` function to read input from the
    console. This function returns an object of the `Stdin` type, which is a reference
    to the input stream. `Stdin` has a `read_line(buf)` method to read a full line
    of input that ends with a new line character (when the user hits *Enter*). This
    input is read into a String buffer, `buf`. A method is a name for a function that
    is defined for a certain type, and it is called using dot notation, such as `object.method`
    (see [Chapter 5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing Code with
    Higher-order Functions and Parametrization"), *Generalizing Code with Higher-order
    Functions and Parametrization*).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在游戏开始之前捕获玩家的昵称；我们该如何做？输入/输出功能由`std` crate中的`io`模块处理。它有一个`stdin()`函数用于从控制台读取输入。这个函数返回一个`Stdin`类型的对象，它是输入流的引用。`Stdin`有一个`read_line(buf)`方法用于读取以换行符结束的完整输入行（当用户按下*Enter*键时）。这个输入被读取到一个String缓冲区`buf`中。方法是为定义在特定类型上的函数命名，它使用点符号调用，例如`object.method`（参见[第5章](part0046.xhtml#aid-1BRPS1
    "第5章。使用高阶函数和参数化泛化代码")，*使用高阶函数和参数化泛化代码*）。
- en: 'So, our code will look as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的代码将如下所示：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: However, this is not good enough for Rust; it gives us the warning, `unused
    result which must be used`. Rust is foremost a safe language and we must be ready
    to cope with everything than can occur. Reading a line might work and supply the
    input value, but it can also fail; for example, if this code was running in the
    background on a machine so that no console was available to get input from.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对Rust来说还不够好；它给出了警告，`未使用的result必须使用`。Rust首先是一个安全的语言，我们必须准备好应对可能发生的一切。读取一行可能成功并提供输入值，但它也可能失败；例如，如果这段代码在后台运行在机器上，那么没有控制台可以获取输入。
- en: How will you cope with this? Well, `read_line()` returns a Result value, which
    can either be a real value (an `Ok`) when everything works fine or an error value
    (an `Err`) when there is a problem. To cope with a possible error, we need an
    `ok()` function and an `expect()` function; `ok()` converts the Result into an
    Option value (which contains how many bytes were read) and `expect()` gives this
    value or shows its message when an error occurs. In Rust, a program panics when
    an error occurs that cannot be recovered from, and the string argument from `expect()`
    is displayed to tell us where it occurred.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何应对这种情况？嗯，`read_line()`返回一个Result值，它可以是正常值（一个`Ok`），当一切正常时，或者是一个错误值（一个`Err`），当出现问题时。为了处理可能出现的错误，我们需要一个`ok()`函数和一个`expect()`函数；`ok()`将Result转换为Option值（它包含读取的字节数）和`expect()`在发生错误时给出这个值或显示其消息。在Rust中，当发生无法恢复的错误时，程序会崩溃，`expect()`中的字符串参数会显示出来，告诉我们错误发生的位置。
- en: 'This is written in Rust in a chained form (and is a bit unusual the first time
    you see it) as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是用Rust编写的，采用链式形式（第一次看到可能会觉得有点不寻常），如下所示：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Rust allows us to write these successive calls on separate lines, which clarifies
    the code a lot for most people:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Rust允许我们将这些连续的调用写在单独的行上，这对大多数人来说可以大大澄清代码：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When we run this code from the command line, we get the following conversation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从命令行运行这段代码时，我们得到以下对话：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Can you guess why `that''s a mighty name indeed!` appears on a new line? This
    is because the input `buf` still contains a newline character, `\n!` Luckily,
    we have a `trim()` method to remove trailing and leading whitespace from a string.
    If we insert the line shown in the following snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到为什么`that's a mighty name indeed!`出现在新的一行上吗？这是因为输入`buf`仍然包含一个换行符，`\n!`幸运的是，我们有一个`trim()`方法来从字符串中删除前后空白。如果我们插入以下代码片段中的行：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We now get a correct output: `Riddick, that''s a mighty name indeed!`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了正确的输出：`Riddick，这确实是一个响亮的名字！`
- en: 'In case the input does not succeed, our program will crash with the following
    output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入不成功，我们的程序将崩溃，并显示以下输出：
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How would we read in a positive integer number from the console?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从控制台读取一个正整数？
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We read the number in from the console in a `buf` String buffer and `trim()`
    the value; `expect()` will show us the message if something goes wrong. However,
    what we have read in is still a `String`, so we must convert the `String` to a
    number.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从控制台读取数字到`buf` String缓冲区，并使用`trim()`处理值；如果出现问题，`expect()`将显示消息。然而，我们读取的内容仍然是一个`String`，因此我们必须将`String`转换为数字。
- en: The `parse()` method tries to convert the input to an unsigned 32-bit integer
    in this case. What it returns is in fact a Result value again; this can either
    be an integer (`Ok<u32>`) or an error (`Err`) when the conversion fails.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，`parse()`方法尝试将输入转换为无符号32位整数。它返回的实际上又是一个Result值；这可以是整数（`Ok<u32>`）或错误（`Err`），当转换失败时。
- en: We will encounter more examples of Option and Result in the *Generics* section
    of *Chapter 5*, *Generalizing Code with Higher-order Functions and Parametrization*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第5章的*泛型*部分遇到更多Option和Result的例子，*使用高阶函数和参数化泛化代码*。
- en: Matching patterns
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配模式
- en: 'But how will we test whether `input_num` from the previous section, which is
    of the Result type, contains a value or not? When the value is an `Ok(T)` function,
    the `unwrap()` function can extract `T` like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何测试上一节中的`input_num`，它是一个Result类型，是否包含值呢？当值是`Ok(T)`函数时，`unwrap()`函数可以像这样提取`T`：
- en: '[PRE64]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Which prints: `Unwrap found 42`. However, when the result is an `Err` value,
    this lets the program crash with a panic, which is ``thread ''<main>'' panicked
    at ''called `Result::unwrap()` on an `Err` value''``. This is bad!'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果为：`Unwrap found 42`。然而，当结果是`Err`值时，这会导致程序因恐慌而崩溃，具体表现为`thread '<main>' panicked
    at 'called `Result::unwrap()` on an `Err` value'`。这是不好的！
- en: 'To solve this, no complex if – else constructs will be enough; we need Rust''s
    magical match here, which has a lot more possibilities than the switch in other
    languages, and is used frequently when handling errors:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，仅使用复杂的if-else结构是不够的；我们需要在这里使用Rust的神奇match，它比其他语言的switch有更多的可能性，并且在处理错误时经常使用：
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `match` function tests the value of an expression against all possible values.
    Only the code (which can be a block) after the `=>` of the first matching branch
    is executed. All branches are separated by commas. In this case, the same number
    that is given as input is printed out. There is no fall through from one branch
    to the next, so a break statement is not necessary; this enables us to avoid a
    common bug in C++.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`函数测试一个表达式的值与所有可能值。只有第一个匹配分支后面的`=>`之后的代码（可以是一个代码块）被执行。所有分支都由逗号分隔。在这种情况下，打印出与输入相同的数字。没有从一分支到下一分支的跳转，因此不需要break语句；这使我们能够避免C++中常见的错误。'
- en: 'In order to continue working with the return value of `match`, we have to bind
    that value to a variable, which is possible because match itself is an expression:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续使用`match`的返回值，我们必须将那个值绑定到一个变量上，这是可能的，因为match本身是一个表达式：
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This `match` extracts the number from `input_num` so that we can compare it
    with other numbers or calculate with it. Both branches must return a value of
    the same type; this is why we returned `0` in the `Err` case (supposing we expect
    a number greater than 0).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`match`从`input_num`中提取数字，以便我们可以将其与其他数字进行比较或进行计算。两个分支都必须返回相同类型的值；这就是为什么我们在`Err`情况下返回`0`（假设我们期望一个大于0的数字）。
- en: 'An alternative way to get the Result or Option value is by using the `if let`
    construct as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 获取Result或Option值的另一种方法是使用`if let`构造，如下所示：
- en: '[PRE67]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `input_num` function is destructured and if it contains a value `val`,
    this is extracted. In certain cases, this can simplify the code, but you lose
    the exhaustive match check. The same principle can be applied inside a `while`
    loop as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`input_num`函数被解构，如果它包含一个值`val`，则提取该值。在某些情况下，这可以简化代码，但你会失去穷尽匹配检查。相同的原理也可以在`while`循环内部应用，如下所示：'
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: With `match`, all possible values must be covered, which is the case if we match
    with a Result, Option (`Some` or `None` is pretty exhaustive), or some other enum
    value.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`match`，必须覆盖所有可能值，这在我们使用Result、Option（`Some`或`None`相当穷尽）或其他枚举值匹配时是成立的。
- en: 'However, look what happens when we test on a string slice for example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看看当我们测试一个字符串切片时会发生什么：
- en: '[PRE69]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This `match` on `magician` gives us an error: non-exhaustive patterns: `_`
    not covered. After all, there are other magicians besides "Gandalf" and "Sauron"!
    The compiler even gives us the solution: use an underscore (`_`) for all other
    possibilities; so, this is a complete match:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`match`在`magician`上给出了一个错误：非穷尽模式：`_`未覆盖。毕竟，除了"Gandalf"和"Sauron"之外，还有其他魔术师！编译器甚至给出了解决方案：使用下划线（`_`）表示所有其他可能性；因此，这是一个完整的匹配：
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To be always on the safe side, use match when testing on the possible values
    of a variable or expression!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了始终确保安全，在测试变量的可能值或表达式时使用match！
- en: 'The left-hand side of a branch can contain several values if they are separated
    by a `|` sign or an inclusive range of values written as start … end. The following
    code snippet shows this in action:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 分支的左侧可以包含多个值，如果它们由`|`符号分隔或以起始值 … 结束值的包含值范围形式书写。以下代码片段展示了这一功能的应用：
- en: '[PRE71]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This prints out: `It is contained in this range`. The matched value can be
    captured in a variable (here `num`) using the `@` symbol as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出：“它包含在这个范围内”。匹配的值可以使用`@`符号捕获到变量中（这里为`num`），如下所示：
- en: '[PRE72]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Which prints: `42 is contained in this range`.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出：“42 包含在这个范围内”。
- en: 'Matches are even more powerful than this; the expression that is being matched
    can be destructured on the left-hand side, and this can even be combined with
    the `if` conditions that are called *guards*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配甚至比这更强大；正在匹配的表达式可以在左侧进行解构，并且这甚至可以与称为*守卫*的`if`条件结合：
- en: '[PRE73]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Which prints out: `This is a demigod called Loki`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出：“这是一个半神洛基”。
- en: Note that since `demi` is a Boolean, we don't have to write `if demi == true`.
    If you want to do nothing in a branch, then write `=> {}`. Destructuring works
    not only for tuples, like this example, but it can also be applied for structs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`demi`是布尔值，我们不必写`if demi == true`。如果你想在分支中不执行任何操作，则写`=> {}`。解构不仅适用于元组，如这个示例所示，还可以应用于结构体。
- en: 'Perform the following exercise:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: What happens if you move the `_` branch from the last position upwards? See
    an example in `Chapter 4/exercises/pattern_match.rs`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`_`分支从最后一个位置向上移动会发生什么？请参见`Chapter 4/exercises/pattern_match.rs`中的示例。
- en: 'The use of the `..` and `...` notations can be confusing, so here is a summary
    of the situations in Rust 1.0:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`..`和`...`记号可能会令人困惑，所以这里是对 Rust 1.0 中情况的总结：
- en: '|   | What works | Does not work |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|   | What works | Does not work |'
- en: '| --- | --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `for in` | `..` exclusive | `...` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `for in` | `..` exclusive | `...` |'
- en: '| `Match` | `...` inclusive | `..` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `Match` | `...` inclusive | `..` |'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we increased our capabilities for working with composite data
    in Rust, from strings, arrays and vectors, and slices of both, to tuples, structs,
    and enums. We also discovered that pattern matching, combined with destructuring
    and guards, is a very powerful tool for writing clear and elegant code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们增强了在 Rust 中处理复合数据的能力，从字符串、数组、向量以及它们的切片，到元组、结构体和枚举。我们还发现，模式匹配结合解构和守卫是一个编写清晰、优雅代码的非常强大的工具。
- en: In the following chapter, we will see that functions are much more powerful
    than we expected. Furthermore, we will discover that structs can have methods
    by implementing traits, almost like classes and interfaces in other languages.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到函数比我们预期的要强大得多。此外，我们将发现结构体可以通过实现特质来拥有方法，这几乎就像在其他语言中的类和接口一样。
