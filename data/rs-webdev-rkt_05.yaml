- en: '*Chapter 4*: Building, Igniting, and Launching Rocket'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：构建、点燃和发射 Rocket'
- en: Many web applications require some kind of object management that can be reused
    again and again, be it a connection pool for a database server, a connection to
    a memory store, an HTTP client to third-party servers, or any other object. Another
    common feature in a web application is **middleware**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络应用程序需要某种可以反复使用的对象管理，无论是数据库服务器的连接池、内存存储的连接、第三方服务器的 HTTP 客户端，还是任何其他对象。网络应用程序中的另一个常见功能是**中间件**。
- en: In this chapter, we will discuss two Rocket features (state and fairings), which
    act as the reusable object management and middleware parts of Rocket. We will
    also learn how to create and use connections to database servers, which is very
    important in almost all web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将讨论两个 Rocket 功能（状态和火箭头），它们作为 Rocket 的可重用对象管理和中间件部分。我们还将学习如何创建和使用数据库服务器的连接，这在几乎所有网络应用程序中都非常重要。
- en: After completing this chapter, we expect you to be able to use and implement
    the reusable object management and middleware parts of the Rocket web framework.
    We also expect you to be able to connect to a database of your own choice.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们希望您能够使用和实现 Rocket 网络框架的可重用对象管理和中间件部分。我们还希望您能够连接到您自己选择的数据库。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要主题：
- en: Managing state
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理状态
- en: Working with a database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: Attaching Rocket fairings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Rocket 火箭头
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Besides the usual requirements of a Rust compiler, a text editor, and an HTTP
    client, starting from this chapter, we're going to work with a database. The database
    we're going to use throughout this book is PostgreSQL, and you can download it
    from [https://www.postgresql.org/](https://www.postgresql.org/), install it from
    your operating system package manager, or use a third-party server such as **Amazon
    Web Services** (**AWS**), Microsoft Azure, or **Google Cloud Platform** (**GCP**).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Rust 编译器、文本编辑器和 HTTP 客户端等常规要求外，从本章开始，我们将与数据库一起工作。本书中我们将使用的数据库是 PostgreSQL，您可以从[https://www.postgresql.org/](https://www.postgresql.org/)下载它，通过您的操作系统包管理器安装它，或使用第三方服务器，如**亚马逊网络服务**（**AWS**）、Microsoft
    Azure 或**谷歌云平台**（**GCP**）。
- en: We're going to see how to connect to other **Relational Database Management
    Systems** (**RDBMSs**) such as SQLite, MySQL, or Microsoft SQL Server, and you
    can adjust the lesson code to make the type suitable to those RDBMSs, but it's
    easier to follow using PostgreSQL.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何连接到其他**关系数据库管理系统**（**RDBMSs**）如 SQLite、MySQL 或 Microsoft SQL Server，您可以将课程代码调整为适合这些
    RDBMS，但使用 PostgreSQL 更容易理解。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04)找到本章的源代码。
- en: Managing state
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理状态
- en: In a web application, usually, programmers need to create an object that can
    be reused during the request/response life cycle. In the Rocket web framework,
    that object is called a **state**. A state can be anything such as a database
    connection pool, an object to store various customer statistics, an object to
    store a connection to a memory store, a client to send **Simple Mail Transfer
    Protocol** (**SMTP**) emails, and many more.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序中，通常程序员需要创建一个在请求/响应生命周期中可以重复使用的对象。在 Rocket 网络框架中，这个对象被称为**状态**。状态可以是任何东西，例如数据库连接池、存储各种客户统计信息的对象、存储到内存存储的连接的对象、用于发送**简单邮件传输协议**（**SMTP**）电子邮件的客户端，等等。
- en: We can tell Rocket to maintain the state, and this is called a **managed state**.
    The process of creating a managed state is quite simple. We need to initialize
    an object, tell Rocket to manage it, and finally use it in a route. One caveat
    is that we can manage many states from different types, but Rocket can only manage
    one instance of a Rust type.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以告诉 Rocket 维护状态，这被称为**管理状态**。创建管理状态的过程相当简单。我们需要初始化一个对象，告诉 Rocket 管理它，并在路由中使用它。一个注意事项是，我们可以从不同类型管理多个状态，但
    Rocket 只能管理 Rust 类型的单个实例。
- en: Let's try it directly. We are going to have a visitor counter state and tell
    Rocket to manage it and increment the counter for every incoming request. We can
    reuse the previous application from the previous chapter, copy the program from
    `Chapter03/15ErrorCatcher` into `Chapter04/01State`, and rename the application
    in `Cargo.toml` as `chapter4`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接尝试一下。我们将有一个访问计数器状态，并告诉 Rocket 管理它，并为每个传入的请求增加计数器。我们可以重用前一章中的应用程序，将 `Chapter03/15ErrorCatcher`
    中的程序复制到 `Chapter04/01State` 中，并在 `Cargo.toml` 中将应用程序重命名为 `chapter4`。
- en: 'In `src/main.rs`, define a struct to hold the value of the visitor counter.
    For the state to work, the requirement is `T: Send + Sync + ''static`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `src/main.rs` 中，定义一个结构体来保存访问计数器的值。为了状态能够工作，要求是 `T: Send + Sync + ''static`：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We already know that `'static` is a lifetime marker, but what is `Send + Sync`?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 `'static` 是一个生命周期标记，但 `Send + Sync` 是什么？
- en: In modern computing, due to its complexity, there are many ways a program can
    be executed in a way not intended. For example, multithreading makes it hard to
    know whether a variable value has been changed on another thread or not. Modern
    CPUs also perform branch prediction and execute multiple instructions at the same
    time. Sophisticated compilers also rearrange the resulting binary code execution
    flow to optimize the result. To overcome those problems, some kind of syncing
    is needed in the Rust language.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算中，由于其复杂性，程序可能会以非预期的方式执行。例如，多线程使得很难知道变量的值是否在另一个线程上被更改。现代 CPU 也执行分支预测，并同时执行多个指令。复杂的编译器也会重新排列生成的二进制代码执行流程以优化结果。为了克服这些问题，在
    Rust 语言中需要某种同步机制。
- en: The Rust language has traits and memory containers to solve syncing problems
    depending on how programmers intended the application to work. We might want to
    create an object in the heap and share the reference to that object in multiple
    other objects. For example, we create object `x`, and we use the reference of
    x, `&x` in other objects field, `y` and `z`. This creates another problem, as
    the program can delete `x` in other routines making the program unstable. The
    solution is to create different containers for different use cases. These include
    `std::cell::Rc` and `std::box::Box`, among others.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 语言有特性和内存容器来解决同步问题，这取决于程序员如何期望应用程序工作。我们可能想在堆中创建一个对象，并在多个其他对象中共享对该对象的引用。例如，我们创建对象
    `x`，并在其他对象的字段 `y` 和 `z` 中使用 `x` 的引用 `&x`。这会创建另一个问题，因为程序可以在其他例程中删除 `x`，从而使程序变得不稳定。解决方案是为不同的用例创建不同的容器。这些包括
    `std::cell::Rc` 和 `std::box::Box` 等。
- en: '`std::marker::Send` is one of those traits. The `Send` trait is making sure
    any `T` type is safe to be transferred to another thread. Almost all types in
    the `std` library are `Send`, with a few exceptions such as `std::rc::Rc` and
    `std::cell::UnsafeCell`. Rc is a single-threaded reference counted pointer.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::marker::Send` 是这些特性之一。`Send` 特性确保任何 `T` 类型在转移到另一个线程时是安全的。几乎 `std` 库中的所有类型都是
    `Send`，但有少数例外，例如 `std::rc::Rc` 和 `std::cell::UnsafeCell`。Rc 是一个单线程的引用计数指针。'
- en: Meanwhile, `std::marker::Sync` is saying the `T` type is safe to be shared across
    multiple threads. That only holds `true` if the `&T` reference is safe to be sent
    to another thread. Not all `Send` types are `Sync`. For example, `std::cell::Cell`
    and `std::cell::RefCell` are `Send` but not `Sync`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`std::marker::Sync` 表示 `T` 类型可以在多个线程之间安全共享。只有当 `&T` 引用可以安全地发送到另一个线程时，这才会成立。并非所有
    `Send` 类型都是 `Sync`。例如，`std::cell::Cell` 和 `std::cell::RefCell` 是 `Send` 但不是 `Sync`。
- en: '`Both` `Send + Sync` are `Send + Sync` in our type? These types are also `Send`
    automatically becomes a `Send` type. Almost all types in the `std` library are
    `Send + Sync` apart from the raw pointers, `Rc`, `Cell`, and `RefCell`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Both` `Send + Sync` 都是 `Send + Sync` 吗？这些类型自动成为 `Send` 类型。除了原始指针、`Rc`、`Cell`
    和 `RefCell` 之外，`std` 库中的几乎所有类型都是 `Send + Sync`。'
- en: What is `AtomicU64`? With the regular `u64` type, even though it's `Send + Sync`,
    there's no synchronization between threads so a data race condition might happen.
    For example, two threads access the same variable, `x` (which has a value of `64`)
    at the same time, and they increment the value by one. We expect the result to
    be `66` (as there are two threads), but because there's no synchronization between
    threads, the final result is unpredictable. It can be `65` or `66`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`AtomicU64`是什么？使用常规的`u64`类型，尽管它是`Send + Sync`，但线程之间没有同步，因此可能会发生数据竞争条件。例如，两个线程同时访问相同的变量`x`（其值为`64`），并且它们将值增加一。我们期望结果是`66`（因为有两条线程），但由于线程之间没有同步，最终结果是不可预测的。它可以是`65`或`66`。'
- en: The types in the `std::sync` module provide a couple of ways to share updates
    between multiple threads, including the `std::sync::Mutex`, `std::sync::RwLock`,
    and `std::sync::atomic` types. We can also use other libraries that might provide
    better speed than a standard library, such as the `parking_lot` crate.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sync`模块中的类型提供了一些在多个线程之间共享更新的方法，包括`std::sync::Mutex`、`std::sync::RwLock`和`std::sync::atomic`类型。我们还可以使用可能比标准库提供更好速度的其他库，例如`parking_lot`crate。'
- en: 'Now we have defined `VisitorCounter`, let''s initialize it and tell Rocket
    to manage it as a state. Write the code inside the `rocket()` function as in the
    following lines:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`VisitorCounter`，让我们初始化它并告诉Rocket将其作为状态管理。在`rocket()`函数中写入以下代码：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After we tell Rocket to manage the state, we can use it inside the route handling
    functions. In the previous chapter, we learned about dynamic segments that we
    have to use in `function` arguments. There are other arguments we can use in a
    route handling function, which we call **request guards**. They are called *guards*
    because if a request does not pass the validation inside the guard, the request
    will be rejected, and an error response will be returned.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们告诉Rocket管理状态之后，我们可以在路线处理函数中使用它。在前一章中，我们学习了必须在使用`function`参数时使用的动态段。在路线处理函数中，我们还可以使用其他参数，我们称之为**请求守卫**。它们被称为*守卫*，因为如果请求没有通过守卫内的验证，请求将被拒绝，并返回错误响应。
- en: Any type that implements `rocket::request::FromRequest` can be considered a
    request guard. Incoming requests are then validated against each request guard
    from left to right and will short circuit and return an error if the request is
    not valid.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了`rocket::request::FromRequest`的类型都可以被视为请求守卫。传入的请求将与从左到右的每个请求守卫进行验证，如果请求无效，将短路并返回错误。
- en: 'Suppose we have a route handling function as in the following lines:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个如下所示的路线处理函数：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Guard1` and `Guard2` types are the request guards. The incoming request
    is then validated against the `Guard1` methods, and if an error occurs, the proper
    error response will be returned immediately.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guard1`和`Guard2`类型是请求守卫。然后，传入的请求将与`Guard1`方法进行验证，如果发生错误，将立即返回适当的错误响应。'
- en: We will learn about and implement request guards throughout the book, but we
    will just use a request guard without implementing it in this chapter. `FromRequest`
    is already implemented for `rocket::State<T>`, so we can use it in the route handling
    function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中学习并实现请求守卫，但在这个章节中，我们将只使用请求守卫而不进行实现。`FromRequest`已经为`rocket::State<T>`实现，因此我们可以在路线处理函数中使用它。
- en: 'Now that we have learned why we use `State` in a route handling function, let''s
    use it in our functions. We want to set the visitor counter so each hit to the
    request should increment the counter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了为什么在路线处理函数中使用`State`，让我们在我们的函数中使用它。我们想要设置访问者计数器，以便每个请求都应该增加计数器：
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Why do we add the `'a` lifetime? We are adding a new reference argument, and
    Rust cannot infer which lifetime the returned `&User` should follow. In this case,
    we are saying the lifetime of the `User` reference should be as long as `uuid`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们添加`'a`生命周期？我们正在添加一个新的引用参数，而Rust无法推断返回的`&User`应该遵循哪个生命周期。在这种情况下，我们表示`User`引用的生命周期应该与`uuid`相同。
- en: Inside the function, we use the AtomicU64 `fetch_add()` method to increment
    the value of the visitor, and we print the value using the AtomicU64 `load()`
    method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们使用AtomicU64的`fetch_add()`方法来增加访问者的值，并使用AtomicU64的`load()`方法打印该值。
- en: 'Let''s add the same for the `users()` function, but since we have the exact
    same routine with the `user()` function, let''s make another function instead:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`users()`函数中也添加相同的处理，但由于我们与`user()`函数有完全相同的流程，所以让我们创建另一个函数：
- en: '[PRE24]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This example works fine with the `Atomic` type, but if you ever needed a more
    complex type to work with, such as `String`, `Vec`, or `Struct`, try using `Mutex`
    or `RwLock` from either the standard library or a third-party crate such as `parking_lot`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例与`Atomic`类型配合良好，但如果您需要处理更复杂的数据类型，例如`String`、`Vec`或`Struct`，请尝试使用标准库或第三方crate（如`parking_lot`）中的`Mutex`或`RwLock`。
- en: Now that we know what `State` is in Rocket, let's expand our application by
    combining it with a database server. We will use `State` for storing the connection
    to the database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了在Rocket中`State`是什么，让我们通过结合数据库服务器来扩展我们的应用程序。我们将使用`State`来存储数据库连接。
- en: Working with a database
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: Currently, in our application, we are storing user data in a static variable.
    This is very cumbersome, as it is inflexible and we cannot update the data easily.
    Most modern applications handling data will use some kind of persistent storage,
    be it filesystem-backed storage, a document-oriented database, or a traditional
    RDBMS.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在我们的应用程序中，我们正在使用静态变量存储用户数据。这非常麻烦，因为它不够灵活，我们无法轻松更新数据。大多数现代处理数据的应用程序将使用某种持久存储，无论是基于文件系统的存储、面向文档的数据库还是传统的RDBMS。
- en: Rust has many libraries to connect to various databases or database-like storage.
    There's the `postgres` crate, which works as a PostgreSQL client for Rust. There
    are also other clients such as `mongodb` and `redis`. For `diesel`, which can
    be used to connect to various database systems. For connection pool management,
    there are the `deadpool` and `r2d2` crates. All crates have their strengths and
    limitations, such as not having an asynchronous application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有许多库可以连接到各种数据库或类似存储。有`postgres`crate，它是Rust的PostgreSQL客户端。还有其他客户端，如`mongodb`和`redis`。对于`diesel`，它可以连接到各种数据库系统。对于连接池管理，有`deadpool`和`r2d2`crate。所有crate都有其优势和局限性，例如没有异步应用程序。
- en: In this book, we're going to use `sqlx` to connect to an RDBMS. `sqlx` claims
    to be an SQL toolkit for Rust. It has abstractions for clients to connect to various
    RDBMSs, it has a connection pool trait, and it can also be used to convert types
    to queries and query responses to Rust types.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用`sqlx`连接到RDBMS。`sqlx`声称是一个Rust的SQL工具包。它为客户端提供了连接到各种RDBMS的抽象，它有一个连接池特质，并且还可以用于将类型转换为查询以及将查询响应转换为Rust类型。
- en: As mentioned in the *Technical requirements* section of this chapter, we're
    going to use PostgreSQL as our RDBMS, so please prepare the connection information
    to PostgreSQL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章*技术要求*部分所述，我们将使用PostgreSQL作为我们的RDBMS，因此请准备PostgreSQL的连接信息。
- en: 'After that, follow these steps to convert our application into using a database:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，按照以下步骤将我们的应用程序转换为使用数据库：
- en: 'We will reuse our application again. The first thing we want to do is to install
    `sqlx-cli` by typing this command in the terminal:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次使用我们的应用程序。我们首先想做的事情是在终端中输入以下命令来安装`sqlx-cli`：
- en: '[PRE47]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`sqlx-cli` is a useful command-line application to create a database, create
    migrations, and run the migrations. It''s not as sophisticated as migration tools
    in other established frameworks, but it does its job very well.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlx-cli`是一个有用的命令行应用程序，用于创建数据库、创建迁移和运行迁移。它不如其他成熟框架中的迁移工具复杂，但它非常有效地完成了工作。'
- en: 'Prepare the connection information and set the `DATABASE_URL` environment variable
    in your terminal. The `DATABASE_URL` format should look as follows, depending
    on which RDBMS you are using:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备连接信息，并在您的终端中设置`DATABASE_URL`环境变量。`DATABASE_URL`的格式应如下所示，具体取决于您使用的RDBMS：
- en: '[PRE48]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For `connect_options`, it''s in query form, and the reference can be found
    at [https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING).
    Other DATABASE_URL format for other RDBMS might look like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`connect_options`，它以查询形式存在，相关信息可以在[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING)找到。其他RDBMS的`DATABASE_URL`格式可能如下所示：
- en: '[PRE49]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Or `sqlite::memory:` or `sqlite://path/to/file.db?connect_options` or `sqlite:///path/to/file.db?connect_options`.
    The connect options for SQLite can be found at [https://www.sqlite.org/uri.html](https://www.sqlite.org/uri.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者`sqlite::memory:`或`sqlite://path/to/file.db?connect_options`或`sqlite:///path/to/file.db?connect_options`。SQLite的连接选项可以在[https://www.sqlite.org/uri.html](https://www.sqlite.org/uri.html)找到。
- en: 'Create a new database using this command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个新的数据库：
- en: '[PRE50]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can create a migration named `create_users` using this command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令创建一个名为`create_users`的迁移：
- en: '[PRE51]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `sqlx` CLI will create a new folder named `migrations` inside the root
    directory of our application, and inside the folder, there will be a file with
    the `timestamp_migration_name.sql` pattern. In our example, the filename will
    look like `migrations/20210923055406_create_users.sql`. Inside the file, we can
    write SQL queries to create or modify the `User` struct, so let''s write the following
    code into the SQL file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sqlx` CLI 将在我们的应用程序根目录内创建一个名为 `migrations` 的新文件夹，在该文件夹内，将有一个符合 `timestamp_migration_name.sql`
    模式的文件。在我们的示例中，文件名将看起来像 `migrations/20210923055406_create_users.sql`。在文件中，我们可以编写
    SQL 查询来创建或修改 `User` 结构体，所以让我们将以下代码写入 SQL 文件：'
- en: '[PRE52]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How do we know what the mapping between the database column type and Rust type
    is? `sqlx` provides its own mapping; we can find the documentation at [https://docs.rs/sqlx](https://docs.rs/sqlx).
    The crate has great modules for a supported database. We can search for it in
    the top search bar; for example, we can find the documentation for PostgreSQL
    in [https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html](https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html).
    On that page, we can see there are `types` modules that we can look at.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道数据库列类型和 Rust 类型之间的映射关系？`sqlx` 提供了自己的映射；我们可以在 [https://docs.rs/sqlx](https://docs.rs/sqlx)
    找到相关文档。该包为支持的数据库提供了优秀的模块。我们可以在顶部的搜索栏中搜索它；例如，我们可以在 [https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html](https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html)
    找到 PostgreSQL 的文档。在该页面上，我们可以看到有 `types` 模块，我们可以查看它们。
- en: 'After we write the content of the migration file, we can run the migration
    using the following command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编写迁移文件的内容后，我们可以使用以下命令运行迁移：
- en: '[PRE53]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: After the migration, check the generated database table and see whether the
    table schema is correct or not. Let's insert the data from the previous chapter.
    Also, feel free to fill the table with sample data of your choice.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移后，检查生成的数据库表，看看表模式是否正确。让我们插入上一章的数据。也可以随意用您选择的数据填充表格。
- en: 'After migration, include the `sqlx` crate in our `Cargo.toml` file. We should
    also include the `uuid` crate as we''re going to use PostgreSQL''s `uuid` type.
    Take a look at the API documentation of the crate if you want to enable another
    RDBMS:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移后，将 `sqlx` 包包含在我们的 `Cargo.toml` 文件中。由于我们将使用 PostgreSQL 的 `uuid` 类型，我们还应该包含
    `uuid` 包。如果您想启用其他 RDBMS，请查看该包的 API 文档：
- en: '[PRE54]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can delete `lazy_static` from `Cargo.toml` and remove references of `lazy_static!`,
    `USERS`, and `HashMap` from the `src/main.rs` file. We don''t need those, and
    we are only going to retrieve the `User` data from the database that we inserted
    earlier. Use the following `SQL INSERT` syntax to insert the previous user data:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从 `Cargo.toml` 中删除 `lazy_static`，并从 `src/main.rs` 文件中移除 `lazy_static!`、`USERS`
    和 `HashMap` 的引用。我们不需要这些，我们只将从我们之前插入的数据库中检索 `User` 数据。使用以下 `SQL INSERT` 语法插入之前用户的数据：
- en: '[PRE55]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Modify the `User` struct to follow the database that we''ve created:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `User` 结构体以符合我们创建的数据库：
- en: '[PRE56]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When `sqlx` retrieves the result from the database, it will be stored in `sqlx::Database::Row`.
    This type can then be converted to any type that implements `sqlx::FromRow`. Luckily,
    we can derive `FromRow` as long as all the members implement `sqlx::Decode`. There
    are a few exceptions that we can use to override `FromRow`. Here is an example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `sqlx` 从数据库检索结果时，它将被存储在 `sqlx::Database::Row` 中。这种类型可以转换为任何实现了 `sqlx::FromRow`
    的类型。幸运的是，只要所有成员实现了 `sqlx::Decode`，我们就可以推导出 `FromRow`。有一些异常情况，我们可以用来覆盖 `FromRow`。以下是一个示例：
- en: '[PRE57]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For `rename_all`, we can use these options: `snake_case`, `lowercase`, `UPPERCASE`,
    `camelCase`, `PascalCase`, `SCREAMING_SNAKE_CASE`, and `kebab-case`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `rename_all`，我们可以使用以下选项：`snake_case`、`lowercase`、`UPPERCASE`、`camelCase`、`PascalCase`、`SCREAMING_SNAKE_CASE`
    和 `kebab-case`。
- en: '`rename` is used when we have different column names and type member names.
    If a member has no column in the database, and that type has the implementation
    of the `std::default::Default` trait, we can use the `default` directive.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们具有不同的列名和类型成员名时，使用 `rename`。如果一个成员在数据库中没有列，并且该类型实现了 `std::default::Default`
    特性，我们可以使用 `default` 指令。
- en: Why do we use `i16`? The answer is the PostgreSQL type has no mapping to the
    Rust `u8` type. We can either use `i8`, use a bigger `i16` type, or try implementing
    `Decode` for `u8`. In this case, we choose to use the `i16` type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用 `i16`？答案是 PostgreSQL 类型没有映射到 Rust 的 `u8` 类型。我们可以使用 `i8`，使用更大的 `i16`
    类型，或者尝试为 `u8` 实现 `Decode`。在这种情况下，我们选择使用 `i16` 类型。
- en: We want the program to read the connection information (`DATABASE_URL`) from
    the environment variable. In [*Chapter 2*](B16825_02_ePub.xhtml#_idTextAnchor032),
    *Building Our First Rocket Web Application*, we learned how to configure Rocket
    using standard configuration, but this time, we want to add extra configuration.
    We can start by adding `serde` to application dependencies in `Cargo.toml`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望程序从环境变量中读取连接信息 (`DATABASE_URL`)。在 [*第 2 章*](B16825_02_ePub.xhtml#_idTextAnchor032)，*构建我们的第一个
    Rocket Web 应用程序*，我们学习了如何使用标准配置来配置 Rocket，但这次，我们想添加额外的配置。我们可以从在 `Cargo.toml` 中将
    `serde` 添加到应用程序依赖项开始。
- en: '`serde` is one of the most used and important libraries in Rust. The name comes
    from *serialization and deserialization*. It is used for anything that involves
    serialization and deserialization. It can be used to convert Rust type instances
    to bytes representations and vice versa, to JSON and vice versa, to YAML, and
    any other type, as long as they implement the `serde` traits. It can also be used
    to transcode one type that implements `serde` traits to another type that implements
    `serde` traits.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`serde` 是 Rust 中使用最广泛且最重要的库之一。其名称来源于 *序列化和反序列化*。它用于涉及序列化和反序列化的任何事物。它可以用于将 Rust
    类型实例转换为字节表示，反之亦然，转换为 JSON 和反之亦然，转换为 YAML，以及任何其他类型，只要它们实现了 `serde` 特性。它还可以用于将实现
    `serde` 特性的一个类型转换为另一个实现 `serde` 特性的类型。'
- en: If you want to look at the `serde` documentation, you can find it on their website
    at [https://serde.rs](https://serde.rs).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看 `serde` 的文档，你可以在他们的网站上找到它，网址为 [https://serde.rs](https://serde.rs)。
- en: The `serde` documentation mentions many native or third-party supports for many
    data formats such as JSON, Bincode, CBOR, YAML, MessagePack, TOML, Pickle, RON,
    BSON, Avro, JSON5, Postcard, URL query strings, Envy, Envy Store, S-expressions,
    D-Bus's binary wire format, and FlexBuffers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`serde` 的文档中提到了许多对多种数据格式的原生或第三方支持，例如 JSON、Bincode、CBOR、YAML、MessagePack、TOML、Pickle、RON、BSON、Avro、JSON5、Postcard、URL
    查询字符串、Envy、Envy Store、S-expressions、D-Bus 的二进制线格式和 FlexBuffers。'
- en: 'Let''s add the following lines into `Cargo.toml` to include `serde` in our
    application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Cargo.toml` 中添加以下行以将 `serde` 包含到我们的应用程序中：
- en: '[PRE58]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After that, create a struct that will be used to contain our custom configuration:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，创建一个将用于包含我们自定义配置的结构体：
- en: '[PRE59]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`serde` already provides the `Deserialize` macro that can be used in the `derive`
    attribute. So far, we have used a lot of macros providing libraries that can be
    used in the `derive` attribute, such as `Debug`, `FromRow`, `Deserialize`. The
    macro system is one of the important Rust features.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`serde` 已经提供了可以在 `derive` 属性中使用的 `Deserialize` 宏。到目前为止，我们已经使用了大量提供库的宏，这些库可以在
    `derive` 属性中使用，例如 `Debug`、`FromRow`、`Deserialize`。宏系统是 Rust 的重要特性之一。'
- en: 'Implement the routine to read the configuration and map it into the `rocket()`
    function:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现读取配置并将其映射到 `rocket()` 函数的例程：
- en: '[PRE60]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that the application can get the `DATABASE_URL` information from environment
    variables, it''s time to initialize the database connection pool and tell Rocket
    to manage it. Write the following lines:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应用程序可以从环境变量中获取 `DATABASE_URL` 信息，是时候初始化数据库连接池并告诉 Rocket 管理它了。编写以下行：
- en: '[PRE61]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We initialize the connection pool using `PgPoolOptions`. Other databases can
    use their corresponding type, such as `sqlx::mysql::MySqlPoolOptions` or `sqlx::sqlite::SqlitePoolOptions`.
    The `connect()` method is an `async` method, so we must make `rocket()` async
    as well to be able to use the result.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `PgPoolOptions` 初始化连接池。其他数据库可以使用它们对应的类型，例如 `sqlx::mysql::MySqlPoolOptions`
    或 `sqlx::sqlite::SqlitePoolOptions`。`connect()` 方法是一个 `async` 方法，因此我们必须使 `rocket()`
    也异步，以便能够使用结果。
- en: After that, inside the `rocket()` function, we tell Rocket to manage the connection
    pool.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在 `rocket()` 函数内部，我们告诉 Rocket 管理连接池。
- en: 'Before using the database connection, we used `lazy_static` and created `user`
    objects as references to the `USERS` hash map. Now, we will use the data from
    the database, so we need to use concrete objects instead of references. Remove
    the ampersand (`&`) from the `Responder` implementation for the `User` and `NewUser`
    structs:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用数据库连接之前，我们使用了 `lazy_static` 并创建了 `user` 对象作为 `USERS` 哈希表的引用。现在，我们将使用数据库中的数据，因此我们需要使用具体对象而不是引用。从
    `User` 和 `NewUser` 结构体的 `Responder` 实现中移除 ampersand (`&`)：
- en: '[PRE62]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, it''s time to implement the `user()` function to use the database connection
    pool to query from the database. Modify the `user()` function as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实现 `user()` 函数以使用数据库连接池从数据库中查询了。按照以下方式修改 `user()` 函数：
- en: '[PRE63]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We included the connection pool managed state in the function arguments. After
    that, we parsed the UUID `&str` parameter into the `Uuid` instance. If there's
    an error parsing the `uuid` parameter, we change the error to `Status::BadRequest`
    and return the error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数参数中包含了连接池管理状态。之后，我们将 UUID `&str` 参数解析为 `Uuid` 实例。如果解析 `uuid` 参数时发生错误，我们将错误更改为
    `Status::BadRequest` 并返回错误。
- en: We then use the `query_as!` macro to send a query to the database server and
    convert the result to a `User` instance. There are many `sqlx` macros we can use,
    such as `query!`, `query_file!`, `query_as_unchecked!`, and `query_file_as!`.
    You can find the documentation for those macros in the `sqlx` API documentation
    that we mentioned earlier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `query_as!` 宏向数据库服务器发送查询并将结果转换为 `User` 实例。我们可以使用许多 `sqlx` 宏，例如 `query!`、`query_file!`、`query_as_unchecked!`
    和 `query_file_as!`。您可以在我们之前提到的 `sqlx` API 文档中找到这些宏的文档。
- en: 'The format to use this macro is as follows: `query_as!(RustType, "prepared
    statement", bind parameter1, ...)`. If you don''t need to get the result as a
    Rust type, you can use the `query!` macro instead.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此宏的格式如下：`query_as!(RustType, "prepared statement", bind parameter1, ...)`。如果您不需要将结果作为
    Rust 类型获取，可以使用 `query!` 宏代替。
- en: We then use the `fetch_one()` method. If you want to execute instead of query,
    for example, to update or delete rows, you can use the `execute()` method. If
    you want to get all the results, you can use the `fetch_all()` method. You can
    find other methods to use and their documentation in the `sqlx::query::Query`
    struct documentation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `fetch_one()` 方法。如果您想执行而不是查询，例如更新或删除行，可以使用 `execute()` 方法。如果您想获取所有结果，可以使用
    `fetch_all()` 方法。您可以在 `sqlx::query::Query` 结构的文档中找到其他可用的方法和它们的文档。
- en: We can either keep the `user()` function return as `Option<User>` and use `user.ok()`,
    or we change the return to `Status::SomeStatus`. Since we change the return type
    to either `Ok(user)` or `Err(some_error)`, we can just return the `Ok(user)` variant,
    but we want to use `map_err(|_| Status::NotFound)` to change the error to a `Status`
    type.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择保留 `user()` 函数返回的 `Option<User>` 并使用 `user.ok()`，或者我们将返回值更改为 `Status::SomeStatus`。由于我们将返回类型更改为
    `Ok(user)` 或 `Err(some_error)`，我们可以直接返回 `Ok(user)` 变体，但我们需要使用 `map_err(|_| Status::NotFound)`
    将错误更改为 `Status` 类型。
- en: You might be thinking, if we send raw SQL queries to the server, is it possible
    to do a SQL injection attack? Is it possible to mistakenly get any user input
    and execute `sqlx::query_as::<_, User>("SELECT * FROM users WHERE name = ?").bind``).fetch_one(pool.inner())`?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能正在想，如果我们向服务器发送原始 SQL 查询，是否可能进行 SQL 注入攻击？是否可能错误地获取任何用户输入并执行 `sqlx::query_as::<_,
    User>("SELECT * FROM users WHERE name = ?").bind``).fetch_one(pool.inner())`？
- en: The answer is no. `sqlx` prepared and cached each statement. As the result of
    using a prepared statement, it's more secure than a regular SQL query, and the
    type returned is also what we expect from the RDBMS server.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。`sqlx` 预编译并缓存了每个语句。由于使用预编译语句的结果，它比常规 SQL 查询更安全，并且返回的类型也是我们从 RDBMS 服务器期望的类型。
- en: 'Let''s also change the `users()` function. Like the `user()` function, we want
    the function to be `async` and get the connection pool from the Rocket managed
    state. We also want to remove the lifetime from `NewUser` as we are not referencing
    `USERS` anymore:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再修改一下 `users()` 函数。像 `user()` 函数一样，我们希望该函数是 `async` 并从 Rocket 管理状态中获取连接池。我们还想从
    `NewUser` 中移除生命周期，因为我们不再引用 `USERS`：
- en: '[PRE64]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After that, we can prepare the prepared statement. We append more conditions
    to `WHERE` if the client sends the `filters` request. For PostgreSQL, the prepared
    statement uses `$1`, `$2`, and so on, but for other RDBMSs, you can use `?` for
    the prepared statement:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以准备预编译语句。如果客户端发送 `filters` 请求，我们将更多条件追加到 `WHERE` 子句中。对于 PostgreSQL，预编译语句使用
    `$1`、`$2` 等等，但对于其他 RDBMS，您可以使用 `?` 作为预编译语句：
- en: '[PRE65]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, write the code to execute the query, but the number of bound parameters
    may change depending on whether filters exist or not; we use the `query_as` function
    instead so we can use the `if` branching. We also add `%name%` for the name-bound
    parameter because we use the `LIKE` operator in the SQL statement. We also have
    to cast the `u8` type to the `i16` type. And, finally, we use the `fetch_all`
    method to retrieve all the results. The nice thing with the `query_as!` macro
    and query as function is they both returned `Vec<T>` or not depending on the `fetch_one`
    or `fetch_all`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编写执行查询的代码，但绑定参数的数量可能会根据是否存在过滤器而改变；我们使用`query_as`函数，这样我们就可以使用`if`分支。我们还添加了`%name%`作为名称绑定参数，因为我们使用了SQL语句中的`LIKE`运算符。我们还需要将`u8`类型转换为`i16`类型。最后，我们使用`fetch_all`方法检索所有结果。`query_as!`宏和查询函数的不错之处在于，它们都根据`fetch_one`或`fetch_all`返回`Vec<T>`或不是：
- en: '[PRE66]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can return the result as usual:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像往常一样返回结果：
- en: '[PRE67]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, let''s try calling the `user()` and `users()` endpoints again. It should
    work as it did when we used `HashMap`. Since we didn''t modify the connection
    options after we wrote `connect()` on the connection pool, the SQL output is written
    on the terminal:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试调用`user()`和`users()`端点。它应该像我们使用`HashMap`时一样工作。由于我们在连接池上写下`connect()`之后没有修改连接选项，SQL输出被写入终端：
- en: '[PRE68]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here is some more of the output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的输出：
- en: '[PRE69]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this book, we are not going to use ORM; instead, we are going to use `sqlx`
    only, as it is enough for the scope of this book. If you want to use ORM in your
    application, you can use ORM and query builders from [https://github.com/NyxCode/ormx](https://github.com/NyxCode/ormx)
    or [https://www.sea-ql.org/SeaORM/](https://www.sea-ql.org/SeaORM/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会使用ORM；相反，我们将只使用`sqlx`，因为这对于本书的范围已经足够了。如果你想在应用程序中使用ORM，你可以使用来自[https://github.com/NyxCode/ormx](https://github.com/NyxCode/ormx)或[https://www.sea-ql.org/SeaORM/](https://www.sea-ql.org/SeaORM/)的ORM和查询构建器。
- en: Now that we have learned about `State` and how to use databases using `State`,
    it is time to learn about another Rocket middleware capability, attaching fairings.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`State`以及如何使用`State`来使用数据库，现在是时候学习Rocket的另一个中间件功能，即附加整流罩。
- en: Attaching Rocket fairings
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加Rocket整流罩
- en: In real life, a rocket fairing is a nose cone used to protect the rocket payload.
    In the Rocket framework, a fairing is not used to protect the payload but is instead
    used to hook in to any part of the request life cycle and rewrite the payload.
    Fairings are analogous to middleware in other web frameworks but with few differences.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，火箭整流罩是一种用于保护火箭有效载荷的头部锥体。在Rocket框架中，整流罩不是用来保护有效载荷的，而是用来钩入请求生命周期的任何部分并重写有效载荷。整流罩在其他Web框架中类似于中间件，但有一些不同之处。
- en: Other framework middleware may be able to inject any arbitrary data. In Rocket,
    the fairing can be used to modify the request but cannot be used to add information
    that is not part of the request. For example, we can use fairings to add a new
    HTTP header in the requests or responses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其他框架的中间件可能能够注入任何任意数据。在Rocket中，整流罩可以用来修改请求，但不能用来添加不属于请求的信息。例如，我们可以使用整流罩在请求或响应中添加新的HTTP头。
- en: Some web frameworks might be able to terminate and directly respond to incoming
    requests, but in Rocket, the fairings cannot stop the incoming requests directly;
    the request must go through the route handling function, and then the route can
    create the proper response.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Web框架可能能够终止并直接响应传入的请求，但在Rocket中，整流罩不能直接停止传入的请求；请求必须通过路由处理函数，然后路由可以创建适当的响应。
- en: 'We can create a fairing by implementing `rocket::fairing::Fairing` for a type.
    Let''s first see the signature of the trait:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为类型实现`rocket::fairing::Fairing`来创建一个整流罩。让我们首先看看特质的签名：
- en: '[PRE70]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: There are a couple of types we are not familiar with, such as `Build` and `Orbit`.
    These types are related to phases in Rocket.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些类型我们不太熟悉，例如`Build`和`Orbit`。这些类型与Rocket中的阶段相关。
- en: Rocket phases
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rocket阶段
- en: 'The types that we want to discuss are `Build` and `Orbit`, with the full module
    paths of `rocket::Orbit` and `rocket::Build`. What are these types? The signature
    for a Rocket instance is `Rocket<P: Phase>`, which means any `P` type that implements
    `rocket::Phase`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '我们想要讨论的类型是`Build`和`Orbit`，它们的完整模块路径是`rocket::Orbit`和`rocket::Build`。这些类型是什么？Rocket实例的签名是`Rocket<P:
    Phase>`，这意味着任何实现了`rocket::Phase`的`P`类型。'
- en: '`Phase` is a `pub trait SomeTrait: private::Sealed {}`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phase`是一个`pub trait SomeTrait: private::Sealed {}`。'
- en: 'The `Phase` trait is sealed because Rocket authors intended only three phases
    in the Rocket application: `rocket::Build`, `rocket::Ignite`, and `rocket::Orbit`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phase` 特征被密封，因为 Rocket 作者只打算在 Rocket 应用程序中有三个阶段：`rocket::Build`、`rocket::Ignite`
    和 `rocket::Orbit`。'
- en: 'We initialize a Rocket instance through `rocket::build()`, which uses the `Config::figment()`default,
    or `rocket::custom<T: Provider>(provider: T)`, which uses the custom configuration
    provider. In this phase, we can also chain the generated instance with custom
    configuration using `configure<T: Provider>(self, provider: T)`. We can then add
    a route using `mount()`, register a catcher using `register()`, manage the states
    using `manage()`, and attach fairings using `attach()`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通过 `rocket::build()` 初始化一个 Rocket 实例，它使用 `Config::figment()` 默认配置，或者使用 `rocket::custom<T:
    Provider>(provider: T)`，它使用自定义配置提供者。在这个阶段，我们还可以使用 `configure<T: Provider>(self,
    provider: T)` 将生成的实例与自定义配置链式连接。然后我们可以使用 `mount()` 添加路由，使用 `register()` 注册捕获器，使用
    `manage()` 管理状态，并使用 `attach()` 附加防热罩。'
- en: After that, we can change the Rocket phase to `Ignite` through the `ignite()`
    method. In this phase, we have a Rocket instance with the final configuration.
    We can then send the Rocket to the `Orbit` phase through the `launch()` method
    or return `Rocket<Build>` and use the `#[launch]` attribute. We can also skip
    the `Ignite` phase and use `launch()` directly after `build()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过 `ignite()` 方法将 Rocket 阶段更改为 `Ignite`。在这个阶段，我们有一个具有最终配置的 Rocket 实例。然后我们可以通过
    `launch()` 方法将 Rocket 发送到 `Orbit` 阶段，或者返回 `Rocket<Build>` 并使用 `#[launch]` 属性。我们还可以跳过
    `Ignite` 阶段，并在 `build()` 之后直接使用 `launch()`。
- en: 'Let''s recall the code that we have created up to now:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止我们创建的代码：
- en: '[PRE81]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This function generates `Rocket<Build>`, and the `#[launch]` attribute generates
    the code that uses `launch()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数生成 `Rocket<Build>`，而 `#[launch]` 属性生成使用 `launch()` 的代码。
- en: The conclusion for this subsection is that the Rocket phase goes from `Build`
    to `Ignite` to `Launch`. How are those phases related to fairing? Let's discuss
    this in the next subsection.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小节的结论是，Rocket 阶段从 `Build` 到 `Ignite` 到 `Launch`。这些阶段与防热罩有何关系？让我们在下一个小节中讨论这个问题。
- en: Fairing callbacks
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防热罩回调
- en: 'Any type implementing fairings must implement one mandatory function, `info()`,
    which returns `rocket::fairing::Info`. The `Info` struct is defined as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 实现防热罩的任何类型都必须实现一个强制函数，`info()`，它返回 `rocket::fairing::Info`。`Info` 结构体被定义为如下：
- en: '[PRE91]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: And, `rocket::fairing::Kind` is defined as just an empty struct, `pub struct
    Kind(_);`, but `Kind` has the `Kind::Ignite`, `Kind::Liftoff`, `Kind::Request`,
    `Kind::Response`, and `Kind::Singleton`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`rocket::fairing::Kind` 被定义为只是一个空的 struct，`pub struct Kind(_);`，但 `Kind` 包含了
    `Kind::Ignite`、`Kind::Liftoff`、`Kind::Request`、`Kind::Response` 和 `Kind::Singleton`。'
- en: 'What are associated constants? In Rust, we can declare **associated items**,
    which are items declared in traits or defined in implementations. For example,
    we have this piece of code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关联常量是什么？在 Rust 中，我们可以声明**关联项**，这些是在特征中声明的或在实现中定义的项。例如，我们有这样一段代码：
- en: '[PRE95]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We can use the `Something::new()` `self` as the first parameter. We have already
    implemented an associated method a couple of times.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Something::new()` `self` 作为第一个参数。我们已经实现了一个关联方法几次。
- en: 'We can also define an **associated type** as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义一个**关联类型**如下：
- en: '[PRE105]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And, finally, we can have an `rocket::fairing::Kind`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以有一个 `rocket::fairing::Kind`：
- en: '[PRE113]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Let''s go back to `Info`. We can make an `Info` instance as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `Info`。我们可以创建一个 `Info` 实例如下：
- en: '[PRE122]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: We are saying the value for `kind` is the result of the `OR` bitwise operation
    between the `kind` associated constants. `Kind::Request` is `1<<2`, which means
    `100` in binary or `4` in decimal. `Kind::Response` is `1<<3`, which means `1000`
    in binary or `8` in decimal. The result of `0100 | 1000` is `1100` in binary or
    `12` in decimal. With this knowledge, we can set the value for the `Info` instance,
    `kind`, from `00000` to `11111`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说的是 `kind` 的值是 `kind` 关联常量之间 `OR` 位运算的结果。`Kind::Request` 是 `1<<2`，这意味着二进制中的
    `100` 或十进制中的 `4`。`Kind::Response` 是 `1<<3`，这意味着二进制中的 `1000` 或十进制中的 `8`。`0100 |
    1000` 的结果是二进制中的 `1100` 或十进制中的 `12`。有了这些知识，我们可以将 `Info` 实例的 `kind` 值从 `00000` 设置到
    `11111`。
- en: Setting configuration using bitwise is a very common design pattern for packing
    multiple values into one variable. Some other languages even make this design
    pattern into its own type and call it **bitset**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位运算设置配置是一个非常常见的将多个值打包到一个变量中的设计模式。一些其他语言甚至将这个设计模式变成自己的类型，并称之为**bitset**。
- en: In a type that implements the `Fairing` trait, the mandatory method implementation
    is `info()`, which returns the `Info` instance. We also have to implement `on_ignite()`,
    `on_liftoff()`, `on_request()`, and `on_response()` depending on the `kind` instance
    that we defined. In our case, this means we have to implement `on_request()` and
    `on_response()`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`Fairing`特质的类型中，必须实现的方法是`info()`，它返回`Info`实例。我们还需要根据我们定义的`kind`实例实现`on_ignite()`、`on_liftoff()`、`on_request()`和`on_response()`。在我们的情况下，这意味着我们必须实现`on_request()`和`on_response()`。
- en: Rocket executes our fairing method on different occasions. If we have `on_ignite()`,
    it will be executed before launch. This type of fairing is special as `on_ignite()`
    returns `Result`, and if the returned variant is `Err`, it can abort the launch.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket在不同的场合执行我们的公平器方法。如果我们有`on_ignite()`，它将在发射前执行。这种类型的公平器是特殊的，因为`on_ignite()`返回`Result`，如果返回的变体是`Err`，则可以中止发射。
- en: For `on_liftoff()`, this method will be executed after launch, which means when
    Rocket is in the `Orbit` phase.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`on_liftoff()`，此方法将在发射后执行，这意味着当Rocket处于`Orbit`阶段时。
- en: If we have `on_request()`, it will be executed after Rocket gets the request
    but before the request is routed. This method will have access to `Request` and
    `Data`, which means we can modify these two items.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有`on_request()`，它将在Rocket获取请求但请求尚未路由之前执行。此方法将可以访问`Request`和`Data`，这意味着我们可以修改这两个项目。
- en: And, `on_response()` will be executed when the route handler has created the
    response but before the response is sent to the HTTP client. This callback has
    access to the `Request` and `Response` instances.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由处理程序创建响应但尚未将其发送到HTTP客户端时，将执行`on_response()`。此回调可以访问`Request`和`Response`实例。
- en: '`Kind::Singleton` is special. We can create multiple instances of fairings
    of the same type and attach them to Rocket. But, maybe we only want to allow one
    instance of the `Fairing` implementing type to be added. We can use `Kind::Singleton`
    and it will make sure only the last attached instance of this type will be added.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kind::Singleton`是特殊的。我们可以创建同一类型的多个公平器实例并将它们附加到Rocket上。但是，我们可能只想允许添加一个`Fairing`实现类型的实例。我们可以使用`Kind::Singleton`，这将确保只有最后附加的此类型的实例将被添加。'
- en: Now that we know more about Rocket phases and `Fairing` callbacks, let's implement
    the `Fairing` trait in the next subsection.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Rocket阶段和`Fairing`回调有了更多的了解，让我们在下一小节中实现`Fairing`特质。
- en: Implementing and attaching fairings
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现并附加公平器
- en: Right now, our Rocket application manages `VisitorCounter`, but we did not add
    `State<VisitorCounter>` to the `favicon()` function. We might also want to add
    new route handling functions, but adding `State<VisitorCounter>` as an argument
    parameter for every route handling function is cumbersome.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的Rocket应用程序管理`VisitorCounter`，但我们没有将`State<VisitorCounter>`添加到`favicon()`函数中。我们可能还想添加新的路由处理函数，但将`State<VisitorCounter>`作为每个路由处理函数的参数参数是很繁琐的。
- en: We can change `VisitorCounter` from a managed state into a fairing. At the same
    time, let's imagine that we have another requirement in our application. We want
    to have a custom header for the request and response for internal logging purposes.
    We can do it by adding another fairing to change the incoming requests and responses.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`VisitorCounter`从受管理状态改为公平器。同时，让我们假设我们的应用程序中还有另一个要求。我们希望为请求和响应添加自定义头，用于内部日志记录。我们可以通过添加另一个公平器来更改传入的请求和响应来实现它。
- en: 'First, let''s organize our module usage a little bit. We need to add the fairing-related
    modules, `rocket::http::Header`, `rocket::Build`, and `rocket::Orbit`, so we can
    use those for our `VisitorCounter` fairing and another fairing to modify the requests
    and responses:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们稍微组织一下我们的模块使用。我们需要添加与公平器相关的模块，`rocket::http::Header`、`rocket::Build`和`rocket::Orbit`，这样我们就可以为我们的`VisitorCounter`公平器和另一个修改请求和响应的公平器使用它们：
- en: '[PRE126]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Add the `Fairing` trait implementation for `VisitorCounter`. We need to decorate
    the `impl` with `#[rocket::async_trait]`, since this trait is an `async` trait:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为`VisitorCounter`添加`Fairing`特质实现。由于此特质是一个`async`特质，我们需要用`#[rocket::async_trait]`装饰`impl`：
- en: '[PRE132]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We added the `info()` mandatory method, which returned the `Info` instance.
    Inside the `Info` instance, we only really need `Kind::Request` as we only need
    to increment the visitor counter for every incoming request. But this time, we
    also added `Kind::Ignite` and `Kind::Liftoff` because we want to see when the
    callback is executed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了强制性的 `info()` 方法，它返回 `Info` 实例。在 `Info` 实例内部，我们实际上只需要 `Kind::Request`，因为我们只需要为每个传入请求增加访问者计数器。但这次，我们还添加了
    `Kind::Ignite` 和 `Kind::Liftoff`，因为我们想看到回调何时执行。
- en: 'Then, we can add the callbacks inside the `impl Fairing` block:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `impl Fairing` 块内添加这些回调：
- en: '[PRE142]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: What is the return type on the `on_ignite()` method? `rocket::fairing::Result`
    is defined as `Result<T = Rocket<Build>, E = Rocket<Build>> = Result<T, E>`. This
    method is used to control whether the program continues or not. For example, we
    can check the connection to a third-party server to ensure its readiness. If the
    third-party server is ready to accept connections, we can return `Ok(rocket)`.
    But, if the third-party server is not available, we can return `Err(rocket)` to
    halt the launch of Rocket. Notice that `on_liftoff()`, `on_request()`, and `on_response()`
    do not have a return type, as `Fairing` is designed to only fail when we build
    Rocket.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_ignite()` 方法的返回类型是什么？`rocket::fairing::Result` 被定义为 `Result<T = Rocket<Build>,
    E = Rocket<Build>> = Result<T, E>`。此方法用于控制程序是否继续。例如，我们可以检查与第三方服务器的连接以确保其就绪。如果第三方服务器准备好接受连接，我们可以返回
    `Ok(rocket)`。但是，如果第三方服务器不可用，我们可以返回 `Err(rocket)` 以停止Rocket的启动。注意，`on_liftoff()`、`on_request()`
    和 `on_response()` 没有返回类型，因为 `Fairing` 被设计为仅在构建Rocket时失败。'
- en: 'For `on_liftoff()`, we just want to print something to the application output.
    For `on_request()`, we undertake the real purpose of this fairing: increase the
    counter for every request.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `on_liftoff()`，我们只想将一些信息打印到应用程序输出中。对于 `on_request()`，我们承担这个舱盖的真实目的：为每个请求增加计数器。
- en: 'After implementing the `Fairing` trait, we can remove `counter: &State<VisitorCounter>`
    from the `user()` and `users()` function arguments. We also need to remove `counter.increment_counter();`
    from the body of those functions.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '在实现 `Fairing` 特性之后，我们可以从 `user()` 和 `users()` 函数参数中移除 `counter: &State<VisitorCounter>`。我们还需要从这些函数的主体中移除
    `counter.increment_counter();`。'
- en: After we have modified the `user()` and `users()` functions, we can attach the
    fairing to the Rocket application. Change `manage(visitor_counter)` to `attach(visitor_counter)`
    in the Rocket initialization code.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改了 `user()` 和 `users()` 函数之后，我们可以将舱盖附加到Rocket应用程序上。在Rocket初始化代码中将 `manage(visitor_counter)`
    改为 `attach(visitor_counter)`。
- en: 'Time to see the fairing in action! First, take a look at the initialization
    sequence. You can see `on_ignite()` is executed in the beginning, and `on_liftoff()`
    is executed after everything is ready:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看舱盖的实际效果了！首先，看看初始化序列。你可以看到 `on_ignite()` 在开始时执行，而 `on_liftoff()` 在一切准备就绪后执行：
- en: '[PRE152]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'After that, try calling our route handling function again to see the counter
    increase again:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，再次尝试调用我们的路由处理函数，以查看计数器再次增加：
- en: '[PRE153]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'And, in the Rocket output, we can see it increase when we use it as a state:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Rocket输出中，我们可以看到当我们将其用作状态时，它会增加：
- en: '[PRE154]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Now, let's implement our second use case, injecting a tracing ID to our requests
    and responses.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现第二个用例，将跟踪ID注入到我们的请求和响应中。
- en: 'First, modify `Cargo.toml` to ensure the `uuid` crate can generate a random
    UUID:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改 `Cargo.toml` 以确保 `uuid` 包可以生成一个随机的UUID：
- en: '[PRE155]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'After that, inside `src/main.rs`, we can define the header name we want to
    inject and a type that works as the fairing:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在 `src/main.rs` 中，我们可以定义我们想要注入的头部名称以及作为舱盖工作的类型：
- en: '[PRE156]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Afterward, we can implement the `Fairing` trait for `XtraceId`. This time,
    we want to have `on_request()` and `on_response()` callbacks:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以为 `XtraceId` 实现一个 `Fairing` 特性。这次，我们希望有 `on_request()` 和 `on_response()`
    回调：
- en: '[PRE158]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Now, write the `on_request()` and `on_response()` implementations inside the
    `impl Fairing` block:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `impl Fairing` 块内编写 `on_request()` 和 `on_response()` 的实现：
- en: '[PRE167]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: In `on_request()`, we generate a random UUID and inject the resulting string
    as one of the request headers. In `on_response()`, we inject the response with
    the same header from the request.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `on_request()` 中，我们生成一个随机UUID，并将生成的字符串作为请求头部之一注入。在 `on_response()` 中，我们将具有相同头部的响应注入到请求中。
- en: 'Don''t forget to initialize and attach this new fairing to the Rocket build
    and launch process:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记初始化并将这个新的舱盖附加到Rocket构建和启动过程中：
- en: '[PRE177]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Rerun the application. We should have a new fairing in the application output
    and `"x-trace-id"` in the HTTP response:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行应用程序。我们应该在应用程序输出中看到一个新舱盖，并在HTTP响应中包含 `"x-trace-id"`：
- en: '[PRE183]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Here is another example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE184]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Please note that we can use both `State` and `Fairing` in our application. Only
    use `Fairing` if we need to call this for every request.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以在应用程序中使用 `State` 和 `Fairing`。只有在我们需要为每个请求调用它时才使用 `Fairing`。
- en: Previously, we created a connection pool and told Rocket to manage it using
    managed state but Rocket already has a way to connect to the database via its
    built-in database connection, `rocket_db_pools`, which is a type of fairings.
    Let's see how we can do it in the next part.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们创建了一个连接池，并告诉 Rocket 使用管理状态来管理它，但 Rocket 已经有通过其内置数据库连接 `rocket_db_pools`
    连接到数据库的方法，`rocket_db_pools` 是一种公平的连接方式。让我们看看在下一部分如何实现它。
- en: Connecting to a database using rocket_db_pools
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 rocket_db_pools 连接到数据库
- en: 'Rocket provided a *sanctioned* way to connect to some RDBMSs by using `rocket_db_pools`.
    That crate provides the database driver integration for Rocket. We are going to
    learn how to use this crate for connecting to the database. Let''s change the
    connection pool that we made previously from using state into using fairings:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket 通过使用 `rocket_db_pools` 提供了一种连接到某些 RDBMS 的官方方法。该 crate 为 Rocket 提供了数据库驱动程序的集成。我们将学习如何使用这个
    crate 来连接到数据库。让我们将之前创建的连接池从使用状态改为使用公平连接：
- en: 'We don''t need `serde`, as `rocket_db_pools` already has its own configuration.
    Remove `serde` from `Cargo.toml` and add `rocket_db_pools` as a dependency:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要 `serde`，因为 `rocket_db_pools` 已经有自己的配置。从 `Cargo.toml` 中删除 `serde` 并添加 `rocket_db_pools`
    作为依赖项：
- en: '[PRE185]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: You can also use different features such as `sqlx_mysql`, `sqlx_sqlite`, `sqlx_mssql`,
    `deadpool_postgres`, `deadpool_redis`, or `mongodb`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用不同的功能，如 `sqlx_mysql`、`sqlx_sqlite`、`sqlx_mssql`、`deadpool_postgres`、`deadpool_redis`
    或 `mongodb`。
- en: 'In `Rocket.toml`, remove the line containing the `database_url` configuration
    and replace it with these lines:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Rocket.toml` 中，删除包含 `database_url` 配置的行，并替换为以下行：
- en: '[PRE186]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: You can use `default.databases.main_connection` if you like, and you can also
    change `main_connection` to whatever name you see fit.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢，可以使用 `default.databases.main_connection`，你也可以将 `main_connection` 改成你喜欢的任何名称。
- en: 'In the Cargo library project, we can re-export something in `our_library` using
    the `pub use something;` syntax, and another library can then use that through
    `our_library::something`. Remove these `use sqlx...` and `use serde...` lines,
    as `rocket_db_pools` already re-exported `sqlx` and we don''t need `serde` anymore:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Cargo 库项目中，我们可以使用 `pub use something;` 语法在 `our_library` 中重新导出某些内容，然后另一个库可以通过
    `our_library::something` 使用它。删除这些 `use sqlx...` 和 `use serde...` 行，因为 `rocket_db_pools`
    已经重新导出了 `sqlx`，我们也不再需要 `serde`：
- en: '[PRE187]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Add the following lines to use `rocket_db_pools`. Notice that we can multiline
    the `use` declaration in the code:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下行来使用 `rocket_db_pools`。注意，我们可以在代码中多行声明 `use`：
- en: '[PRE188]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Delete the struct `Config` declaration and add the following lines to declare
    the database connection type:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `Config` 结构体的声明，并添加以下行来声明数据库连接类型：
- en: '[PRE189]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The database derives an automatically generated `rocket_db_pools::Database`
    implementation for the `DBConnection` type. Notice that we wrote the connection
    name `"main_connection"`, just like what we have set in `Rocket.toml`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库为 `DBConnection` 类型自动生成 `rocket_db_pools::Database` 实现。注意，我们写的是连接名称 `"main_connection"`，就像我们在
    `Rocket.toml` 中设置的那样。
- en: 'Remove the config and connection pool initializations in the `rocket()` function:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `rocket()` 函数中移除配置和连接池初始化：
- en: '[PRE190]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Add `DBConnection::init()` inside the `rocket()` function and attach it to
    Rocket:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `rocket()` 函数中添加 `DBConnection::init()` 并将其附加到 Rocket：
- en: '[PRE191]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Change the `user()` and `users()` functions to use the `rocket_db_pools::Connection`
    request guard:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `user()` 和 `users()` 函数修改为使用 `rocket_db_pools::Connection` 请求保护：
- en: '[PRE192]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The application should work just like when we managed the connection pool using
    state, but with minor differences. Here''s the output we see:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该像我们使用状态管理连接池时一样工作，但有一些细微的差别。以下是我们的输出：
- en: '[PRE193]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: We can see there's a new fairing in the application output but there is no prepared
    SQL statement in the application output.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到应用程序输出中有一个新的公平连接，但应用程序输出中没有准备好的 SQL 语句。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about two Rocket components, `State` and `Fairing`.
    We can manage state objects and attach fairings upon building rockets, use the
    `state` objects in route handling functions, and use the `fairing` functions to
    execute callbacks on the build, after launch, on request, and on response.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了两个 Rocket 组件，`State` 和 `Fairing`。我们可以在构建火箭时管理状态对象和附加公平连接，在路由处理函数中使用
    `state` 对象，并使用 `fairing` 函数在构建后、启动后、请求时和响应时执行回调。
- en: We also created counter states and used them in the route handling functions.
    We also learned how to use `sqlx`, made a database migration, made a database
    connection pool state, and used `state` to query the database.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了计数器状态并在路由处理函数中使用它们。我们还学习了如何使用 `sqlx`，进行了数据库迁移，创建了数据库连接池状态，并使用 `state`
    查询数据库。
- en: Afterward, we learned more about the Rocket initialization process and the building,
    igniting, and launching phases.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们更多地了解了 Rocket 初始化过程以及构建、点燃和发射阶段。
- en: Finally, we changed the counter state into a fairing and created a new fairing
    to inject a custom HTTP header into the incoming requests and outgoing responses.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将计数器状态改为公平器，并创建了一个新的公平器来向传入的请求和传出的响应中注入自定义的 HTTP 头部。
- en: Armed with that knowledge, you can create reusable objects between route handling
    functions, and create a method that can be executed globally between requests
    and responses.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有了这些知识，你可以在路由处理函数之间创建可重用的对象，并创建一个可以在请求和响应之间全局执行的方法。
- en: Our `src/main.rs` file is getting bigger and more complicated; we will learn
    how to manage our Rust code in modules and plan a more complex application in
    the next chapter.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `src/main.rs` 文件正在变得越来越大和复杂；我们将在下一章学习如何以模块的方式管理我们的 Rust 代码，并规划一个更复杂的应用程序。
