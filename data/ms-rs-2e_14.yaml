- en: Interacting with Databases in Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 与数据库交互
- en: In this chapter, we'll discuss on why databases are essential to modern applications.
    We'll cover a few crates that are available in the Rust ecosystem, which allows
    one to interact with databases. We'll then continue with our linksnap API server
    that we developed in the previous chapter and integrate database support into
    it through a convenient library. This will allow us to persist new bookmarks that
    are sent to our API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论为什么数据库对现代应用程序至关重要。我们将介绍 Rust 生态系统中的几个 crate，这些 crate 允许与数据库交互。然后，我们将继续讨论我们在上一章中开发的
    linksnap API 服务器，并通过一个方便的库将其数据库支持集成进去。这将使我们能够持久化发送到我们 API 的新书签。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: SQLite integration using `rusqlite`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `rusqlite` 进行 SQLite 集成
- en: Interacting with PostgreSQL with Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rust 与 PostgreSQL 交互
- en: Database connection pooling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接池
- en: Object-relational mapping using the `diesel` crate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `diesel` crate 进行对象关系映射
- en: Integrating diesel with the linksnap API server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 diesel 与 linksnap API 服务器集成
- en: Why do we need data persistence?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要数据持久化？
- en: '"Sometimes, elegant implementation is just a function. Not a method. Not a
    class. Not a framework. Just a function."                                     
                                                                                 
                                                                                 
                           - John Carmack'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “有时，优雅的实现仅仅是一个函数。不是一个方法。不是一个类。不是一个框架。仅仅是一个函数。” —— 约翰·卡马克
- en: Modern applications these days are data-heavy. Data is the new oil, as many
    say. Database-backed services are everywhere, from social gaming to cloud storage,
    to e-commerce, to healthcare, and so on. All of these services need to store and
    retrieve data correctly. The data that they store, must be easy to retrieve and
    must have guarantees regarding consistency and durability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序通常数据密集。正如许多人所说，数据是新石油。数据库支持的服务无处不在，从社交游戏到云存储，再到电子商务，以及医疗保健等等。所有这些服务都需要正确地存储和检索数据。它们存储的数据必须易于检索，并且必须保证一致性和持久性。
- en: Databases are the go-to solution for providing a robust foundation for building
    applications that are data-backed and that support the expectations of their users.
    Before we build anything involving databases with Rust, we need to get an idea
    of the basics. A database, in general, is a collection of tables. Tables are units
    of data organization.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是构建基于数据的应用程序并提供用户期望的强大基础的解决方案。在我们用 Rust 构建涉及数据库的任何东西之前，我们需要了解一些基础知识。一般来说，数据库是一组表。表是数据组织的单元。
- en: Data that's been organized into tables is only applicable to relational databases.
    Other databases, such as NoSQL and graph-based databases, use a more flexible
    document model to store and organize data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 组织到表中的数据仅适用于关系数据库。其他数据库，如 NoSQL 和基于图的数据库，使用更灵活的文档模型来存储和组织数据。
- en: Data is organized into logical bodies called tables. Tables are usually representations
    of entities from the real world. These entities can have various attributes that
    take the place of columns in these tables. These entities can also have relations
    with other entities. A column in one table can refer to another column. Changes
    to any database is performed using a specific DSL called **Structured Query Language
    (SQL)**. SQL queries also allow you to spread a query across multiple tables using
    query clauses such as JOIN. Those are the basics. A common pattern with a user
    interacting with database-backed applications is the **CRUD** pattern, which is
    short for **Create, Read, Update, and Delete**. These are the usual operations
    a user performs most of the time on a database through the application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据被组织成逻辑实体，称为表。表通常代表现实世界中的实体。这些实体可以具有各种属性，这些属性在表中取代了列的位置。这些实体还可以与其他实体有联系。一个表中的列可以引用另一个表中的列。对任何数据库的更改都通过一个特定的
    DSL（领域特定语言）执行，称为**结构化查询语言（SQL）**。SQL 查询还允许您使用查询子句（如 JOIN）将查询扩展到多个表。这些都是基础知识。用户与数据库支持的应用程序交互的常见模式是**CRUD**模式，即**创建、读取、更新和删除**。这些是用户在应用程序中对数据库执行的最常见操作。
- en: SQL is a declarative way to perform transactions on a database. A transaction
    is a group of modifications to a database that must happen atomically or not at
    all in case there are any failures midway. The naive way to write a database transaction
    in any application is through a raw SQL query. However, there's a better way to
    do this, and it's called **Object Relational Mapping (ORM)**. This is a technique
    that's used to access a database using native language abstractions and types
    that map almost one to one with the SQL syntax and semantics. Languages provide
    higher-level libraries for speaking SQL, which allow you to write queries in their
    native language, which is then translated into a raw SQL query. In traditional
    object-oriented languages, your objects become SQL-speaking objects. These libraries
    are called object-relational mappers. Many of these libraries exist in mainstream
    languages such as Hibernate for Java, Active Record for Ruby, SQLAlchemy for Python,
    and so on. Using ORMs reduces the possibility of any errors occurring when you're
    using raw SQL queries. However, ORMs also suffer from not being able to map themselves
    completely to the language's object model with the database model. As such, ORM
    libraries should try to limit the amount of abstraction they provide for interacting
    with a database and leave some of the parts to raw SQL queries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SQL是一种声明式的方法，用于在数据库上执行事务。事务是一组对数据库的修改，这些修改必须原子性地发生，或者在中间出现任何故障时根本不发生。在任何应用程序中编写数据库事务的直观方法是使用原始SQL查询。然而，有一种更好的方法来做这件事，它被称为**对象关系映射（ORM）**。这是一种使用本地语言抽象和类型访问数据库的技术，这些类型几乎与SQL语法和语义一一对应。语言提供了用于与SQL对话的高级库，允许你用它们的本地语言编写查询，然后这些查询被翻译成原始SQL查询。在传统的面向对象语言中，你的对象变成了会说话的SQL对象。这些库被称为对象关系映射器。许多这些库存在于主流语言中，如Java的Hibernate、Ruby的Active
    Record、Python的SQLAlchemy等。使用ORM可以减少在使用原始SQL查询时出现任何错误的可能性。然而，ORM也受到无法将自身完全映射到语言的对象模型和数据库模型的限制。因此，ORM库应尽量减少它们在交互数据库时提供的抽象量，并将一些部分留给原始SQL查询。
- en: The Rust ecosystem provides quite a few high-quality solutions to manage and
    build persistent applications. We'll look at a couple of them in the following
    section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust生态系统提供了许多高质量解决方案来管理和构建持久化应用程序。我们将在下一节中探讨其中的一些。
- en: SQLite
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite
- en: SQLite is a very lightweight embedded database. It does not require a special
    database management system for you to be able to use it. Databases created by
    SQLite are represented as files or as in memory database, and you don't need to
    connect to an external remote endpoint or a local socket connection to use a database.
    It serves a different target audience than traditional client-server database
    engines such as MySQL or PostgreSQL, and is the go-to solution for use cases where
    an application needs to store data locally but in a secure and efficiently retrievable
    manner. The Android platform is a heavy user of SQLite and allows mobile applications
    to store preferences or configurations for users within an application. It is
    also used by many desktop applications that need to store any kind of state with
    durability guarantees.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个非常轻量级的嵌入式数据库。它不需要特殊的数据库管理系统，你就可以使用它。SQLite创建的数据库可以表示为文件或内存中的数据库，你不需要连接到外部远程端点或本地套接字连接来使用数据库。它服务于与传统客户端-服务器数据库引擎（如MySQL或PostgreSQL）不同的目标受众，并且是应用需要本地存储数据但又要安全且高效检索的用例的首选解决方案。Android平台是SQLite的重度使用者，允许移动应用程序在应用程序内存储用户的偏好或配置。它也被许多需要存储任何类型状态并保证持久性的桌面应用程序所使用。
- en: The Rust community provides us with a couple of options for connecting to and
    interacting with a SQLite database. We'll go with the `rusqlite` crate, which
    is available on `crates.io` at [https://crates.io/crates/rusqlite](https://crates.io/crates/rusqlite).
    This crate supports SQLite version 3.6.8 and above. Its API cannot be considered
    an ORM, but can be considered a mid-level abstraction of what an ORM provides,
    as it helpfully hides many of the details of the actual SQLite API. In contrast
    to many other relational database systems, SQLite's type system is dynamic. This
    means that columns do not have types, but each individual value does. Technically,
    SQLite separates storage classes from data types, but this is mainly an implementation
    detail, and we can just think in terms of types without being too far from the
    truth.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 社区为我们提供了连接和与 SQLite 数据库交互的几种选择。我们将选择 `rusqlite` crate，该 crate 可在 `crates.io`
    上找到，网址为 [https://crates.io/crates/rusqlite](https://crates.io/crates/rusqlite)。此
    crate 支持 SQLite 版本 3.6.8 及以上。其 API 不能被视为 ORM，但可以被视为 ORM 提供的中间层抽象，因为它有助于隐藏实际 SQLite
    API 的许多细节。与许多其他关系型数据库系统相比，SQLite 的类型系统是动态的。这意味着列没有类型，但每个单独的值都有类型。技术上，SQLite 将存储类和数据类型分开，但这主要是实现细节，我们可以简单地从类型的角度思考，而不会离真相太远。
- en: 'The `rusqlite` crate provides the `FromSql` and `ToSql` traits for converting
    objects between SQLite and Rust types. It also provides the following implementations
    out of the box for most standard library types and primitives:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`rusqlite` crate 提供了 `FromSql` 和 `ToSql` 特性，用于在 SQLite 和 Rust 类型之间转换对象。它还提供了以下开箱即用的实现，用于大多数标准库类型和原语：'
- en: '| **Description** | **SQLite** | **Rust** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | **SQLite** | **Rust** |'
- en: '| The null value | `NULL` | `rusqlite::types::Null` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 空值 | `NULL` | `rusqlite::types::Null` |'
- en: '| 1, 2, 3, 4, 6, or 8-byte signed integers | `INTEGER` | `i32` (with possible
    truncation) and `i64` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 1、2、3、4、6 或 8 字节有符号整数 | `INTEGER` | `i32`（可能截断）和 `i64` |'
- en: '| 8-byte IEEE floats | `REAL` | `f64` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 8 字节 IEEE 浮点数 | `REAL` | `f64` |'
- en: '| UTF-8, UTF-16BE or UTF-16LE strings | `TEXT` | `String` and `&str` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| UTF-8、UTF-16BE 或 UTF-16LE 字符串 | `TEXT` | `String` 和 `&str` |'
- en: '| Bytestrings | `BLOB` | `Vec<u8>` and `&[u8]` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 字节字符串 | `BLOB` | `Vec<u8>` 和 `&[u8]` |'
- en: With the basics of the `rusqlite` crate covered, let's see it in action.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了 `rusqlite` crate 的基础知识之后，让我们看看它是如何应用的。
- en: 'We''ll create a new project by running `cargo new rusqlite_demo`. Our program
    takes a properly formatted **Comma Separated Values** (**CSV**) list of book data
    from the standard input, stores it in SQLite, and then retrieves a subset of the
    data using a filter SQL query. First, let''s create our table creation and deletion
    QueryNStrings and our `Book` struct, which will store the data retrieved from
    the query:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过运行 `cargo new rusqlite_demo` 来创建一个新的项目。我们的程序从标准输入接收一个格式正确的逗号分隔值（**CSV**）格式的书籍列表，将其存储在
    SQLite 中，然后使用 SQL 查询的过滤器检索数据子集。首先，让我们创建我们的表创建和删除查询以及我们的 `Book` 结构体，它将存储从查询中检索到的数据：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have two constants, `CREATE_TABLE` and `DROP_TABLE`, defined, which contain
    raw SQL queries for creating a `books` table and deleting it, respectively. We
    then have the book struct, which contains the following fields:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个常量，`CREATE_TABLE` 和 `DROP_TABLE`，分别包含创建 `books` 表和删除它的原始 SQL 查询。然后我们有书籍结构体，它包含以下字段：
- en: '`id`: This acts as the primary key and can be used to distinguish books from
    one another when inserting a book into our books table'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 它作为主键使用，可以在将书籍插入我们的书籍表中时区分不同的书籍'
- en: '`title`: The title of the book'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 书籍的标题'
- en: '`author`: The author of the book'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`: 该书的作者'
- en: '`year`: The year of publication'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`year`: 出版年份'
- en: 'Next, let''s look at our `main` function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的 `main` 函数：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we open our connection to our SQLite database by calling `Connection::open`
    and providing a path, `"./books"`, to create the database in the current directory.
    Next, we call `init_database()`, passing a reference to `conn`, which is defined
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用 `Connection::open` 并提供一个路径，`"./books"`，来创建当前目录中的数据库，从而打开我们的 SQLite
    数据库连接。接下来，我们调用 `init_database()`，传递对 `conn` 的引用，它如下定义：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We then call the `insert` method, passing our `conn`. Finally, we call the `query`
    method, which queries our `books` database.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `insert` 方法，传递我们的 `conn`。最后，我们调用 `query` 方法，查询我们的 `books` 数据库。
- en: 'Here''s our `insert` function method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `insert` 函数方法：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In `insert`, we first get a lock on `stdout` and iterate over the lines. Each
    line is split with commas. Following that, we call `execute` on `conn`, passing
    in an insert query string. In the query string, we use the template variables
    `?1`, `?2`, and so on, whose corresponding values are taken from the `elems` vector.
    If the number of elements collected is up to `4`, we insert the book using the
    raw SQL query and provide the corresponding values from the `elems` `Vec` for
    template variables.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`insert`中，我们首先锁定`stdout`，然后遍历行。每行用逗号分隔。随后，我们在`conn`上调用`execute`方法，传入一个插入查询字符串。在查询字符串中，我们使用模板变量`?1`、`?2`等，其对应的值是从`elems`向量中取出的。如果收集到的元素数量达到`4`，我们使用原始SQL查询插入书籍，并为模板变量提供`elems`
    `Vec`中的相应值。
- en: 'Next, our `query` function is defined as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的`query`函数定义如下：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The query function takes in `conn`, on which we call `prepare`, passing in
    the raw SQL query string. Here, we''re filtering books that are greater than a
    given year. We store this query in `stmt`. Next, we call `query_map` on this type,
    passing in a reference to an array that contains just the number `2013`, which
    represents the year we want to filter the books against. As you can see, the API
    is a bit uneasy here. The second argument to `query_map` is a closure that is
    a `Row` type. Within the closure, we extract the respective fields from the `row`
    instance and construct a `Book` instance out of it. This returns an iterator,
    which we store in `movie_iter`. Finally, we iterate over our `movie_iter`, filtering
    any failed values using the `extract_ok` helper method. This is defined as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 查询函数接收`conn`参数，我们在其上调用`prepare`方法，传入原始的SQL查询字符串。在这里，我们正在过滤那些出版年份大于给定年份的书籍。我们将这个查询存储在`stmt`中。接下来，我们在这个类型上调用`query_map`，传入一个只包含数字`2013`的数组引用，这个数字代表我们要过滤书籍的年份。正如你所见，这里的API有点不自然。`query_map`的第二个参数是一个闭包，它是一个`Row`类型。在闭包内部，我们从`row`实例中提取相应的字段，并从中构建一个`Book`实例。这返回一个迭代器，我们将其存储在`movie_iter`中。最后，我们遍历`movie_iter`，使用`extract_ok`辅助方法过滤任何失败的值。这个方法定义如下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we print the books. The full code is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打印书籍。完整的代码如下：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also have a books.csv file in the same directory. We can run it by running:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在同一目录下还有一个books.csv文件。我们可以通过以下命令运行它：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the output of the program upon running:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序运行后的输出：
- en: '![](img/9605d0c0-ab0d-4296-b8fe-93a031b7a0f0.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9605d0c0-ab0d-4296-b8fe-93a031b7a0f0.png)'
- en: This is nowhere near a representative real-world database-backed application
    and is just for demonstrating the usage of the library. A real-world application
    wouldn't be reading from the standard input and the querying routines would have
    better error handling.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这远非一个代表性的真实世界数据库支持的应用程序，它只是为了演示库的使用。一个真实世界的应用程序不会从标准输入读取，查询例程会有更好的错误处理。
- en: This was a brief demonstration of how to use a SQLite database with Rust by
    using the `rusqlite` crate. The API is not very strongly typed, but currently
    it's the only solution we've got. Next, we'll look at one of the big brothers
    of SQLite, which is the PostgreSQL database management system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简要的演示，说明如何使用`rusqlite`crate通过Rust使用SQLite数据库。API不是非常强类型，但这是我们目前唯一的选择。接下来，我们将看看SQLite的“大哥”——PostgreSQL数据库管理系统。
- en: PostgreSQL
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: While SQLite is fine for prototyping and simpler use cases, a real relational
    database management system can make the life of a developer much easier. One such
    sophisticated database system is PostgreSQL. To integrate postgres in Rust, we
    have the `postgres` crate on *crates.io*. It's a native Rust client, meaning that
    it does not ride on a C library but implements the whole protocol in Rust. If
    the API looks familiar to the `rusqlite` crate, this is deliberate; the SQLite
    client's API is actually based on the postgres client.The `postgres` crate supports
    some of PostgreSQL's unique features, such as bit vectors, time fields, JSON support,
    and UUIDs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLite适合原型设计和简单的用例，但一个真正的关系型数据库管理系统可以使开发者的生活更加轻松。这样一个复杂的数据库系统是PostgreSQL。要在Rust中集成PostgreSQL，我们可以在*crates.io*上找到`postgres`crate。它是一个本地的Rust客户端，这意味着它不依赖于C库，而是在Rust中实现了整个协议。如果API看起来与`rusqlite`crate相似，这是故意的；SQLite客户端的API实际上是基于PostgreSQL客户端的。`postgres`crate支持一些PostgreSQL的独特功能，如位向量、时间字段、JSON支持和UUID。
- en: In this section, we'll explore interacting with postgres by creating a sample
    program that initializes the postgres database and does a few inserts and queries
    on the database. We assume that you have already set up the database on your system.
    The PostgreSQL version used for the example is 9.5.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个初始化PostgreSQL数据库并在数据库上进行一些插入和查询的示例程序来探索与PostgreSQL的交互。我们假设您已经在系统上设置了数据库。本例中使用的PostgreSQL版本是9.5。
- en: To install the PostgreSQL database system, the following DigitalOcean article
    is recommended: [https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-16-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-16-04).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装PostgreSQL数据库系统，以下DigitalOcean文章推荐：[https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-16-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-16-04)。
- en: 'Postgres comes with its command line tool called `psql` which can be used to
    run queries, examine tables, manage roles, view system information and much more.
    You can view the postgres version running on your system by running the following
    commands inside the psql prompt. First we''ll launch `psql` by running:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Postgres自带一个名为`psql`的命令行工具，可以用来运行查询、检查表、管理角色、查看系统信息等等。您可以通过在psql提示符内运行以下命令来查看您系统上运行的PostgreSQL版本。首先，我们将通过运行以下命令来启动`psql`：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once we are within the psql, we run the following command at the prompt:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入psql，我们就在提示符下运行以下命令：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the command above, gives the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令，会得到以下输出：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To make this example simpler, we''ll reuse the same books data that we used
    in our `rusqlite` demo. We''ll use the default `"postgres"` user in the following
    examples, with the password as `"postgres"`. You''ll need to adapt the following
    examples to match your new user. Let''s fire up a new project by running `cargo
    new postgres_demo`. Here''s our dependencies in `Cargo.toml`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子更简单，我们将重用我们在`rusqlite`演示中使用的相同的书籍数据。在以下示例中，我们将使用默认的`"postgres"`用户，密码为`"postgres"`。您需要将以下示例修改以匹配您的新用户。让我们通过运行`cargo
    new postgres_demo`来启动一个新的项目。以下是我们的`Cargo.toml`中的依赖项：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s run through the code in `main.rs`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看`main.rs`中的代码：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have a bunch of string constants for connecting to the database and creating
    and deleting the books table. Next is our function `main`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一系列用于连接数据库以及创建和删除书籍表的字符串常量。接下来是我们的`main`函数：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Because we are not using an ORM here, and just a low-level interface, we''ll
    need to unpack the values into the database query manually. Let''s run this program:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里没有使用ORM，而是一个低级接口，我们需要手动将值解包到数据库查询中。让我们运行这个程序：
- en: '![](img/21ff948c-f012-4cce-83bb-1f2f8a075cd5.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21ff948c-f012-4cce-83bb-1f2f8a075cd5.png)'
- en: 'Here''s an output of the program, along with a `psql` query of the table to
    show the contents afterwards:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出，以及随后在`psql`中对表的查询，以显示其内容：
- en: '![](img/bbef2889-a031-4572-a8e0-efeae1da3fd9.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbef2889-a031-4572-a8e0-efeae1da3fd9.png)'
- en: First, we list our database with the `\dt` command at the `psql` prompt. Following
    that, we use the query, that is, `"select * from books"`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在psql提示符下使用`\dt`命令列出我们的数据库。之后，我们使用查询，即`"select * from books"`。
- en: That's the basics o interacting with PostgreSQL with Rust. Next, let's explore
    how we can make our database queries efficient by using the concept of connection
    pooling.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用Rust与PostgreSQL交互的基础。接下来，让我们探索如何通过使用连接池的概念来提高我们的数据库查询效率。
- en: Connection pooling with r2d2
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用r2d2进行连接池
- en: Opening and closing a database connection every time new transactions take place
    becomes a bottleneck really quickly. Typically, opening a database connection
    is an expensive operation. This is mostly because of the associated TCP handshake
    that's required to create socket connections on both sides. The overhead is even
    more expensive if the database is hosted on a remote server, which is usually
    the case. If we could reuse the connection for every subsequent request that gets
    sent to our database, we might reduce the latency a great deal. An efficient way
    to mitigate this overhead is to employ database connection pooling. When a process
    needs a new connection, it is given an existing connection from the pool of connections.
    When the process has completed the required operation with the database, this
    connection handle goes back to the pool to be used later.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每次新事务发生时都打开和关闭数据库连接很快就会成为瓶颈。通常，打开数据库连接是一个昂贵的操作。这主要是因为需要在两端的套接字连接上创建所需的TCP握手。如果数据库托管在远程服务器上，这通常是情况，开销就更加昂贵。如果我们能够为发送到我们数据库的每个后续请求重用连接，我们可能会大大减少延迟。缓解这种开销的有效方法之一是采用数据库连接池。当进程需要新的连接时，它从连接池中获取现有的连接。当进程完成与数据库的必要操作后，这个连接句柄就会回到池中以便以后使用。
- en: 'In Rust, we have the `r2d2` crate, which leverages traits to provide a generic
    way of maintaining connection pools for various databases. It provides various
    backends as sub-crates, and supports PostgreSQL, Redis, MySQL, MongoDB, SQLite,
    and a few other known database systems. The architecture of `r2d2` consists of
    two parts: a generic part and a backend-specific part. The backend code attaches
    to the generic part by implementing r2d2''s `ManageConnection` trait and by adding
    a connection manager for the specific backend. The trait is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们有`r2d2`crate，它利用特质提供了一种通用的方式来维护各种数据库的连接池。它提供了各种后端作为子crate，并支持PostgreSQL、Redis、MySQL、MongoDB、SQLite以及一些其他已知的数据库系统。`r2d2`的架构由两部分组成：一个通用部分和一个特定后端部分。后端代码通过实现r2d2的`ManageConnection`特质，并为特定后端添加连接管理器来附加到通用部分。特质如下：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Looking at the trait definition, we need to specify a `Connection` type, which
    must be `Send` and `'static`, and an `Error` type. We also have three methods: `connect`,
    `is_valid`, and `has_broken`. The `connect` method returns the `Connection` type
    that comes from the underlying backend crate; for instance, it would be the `postgres::Connection`
    type for the postgres backend. The `Error` type is an enum that specifies all
    the possible `Error` cases that may happen during either the connection phase
    or while checking the validity of the connection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 查看特质定义，我们需要指定一个`Connection`类型，它必须是`Send`和`'static`，以及一个`Error`类型。我们还有三个方法：`connect`、`is_valid`和`has_broken`。`connect`方法返回来自底层后端crate的`Connection`类型；例如，对于Postgres后端，它将是`postgres::Connection`类型。`Error`类型是一个枚举，它指定了在连接阶段或检查连接有效性期间可能发生的所有可能的`Error`情况。
- en: For demonstration purposes, we'll look at how we can use the `r2d2` crate here
    by first checking out how to connect to PostgreSQL using a pool. We'll take the
    code from the previous section and modify it to use a connection pool, where we
    make SQL queries from `8` threads.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将查看如何使用`r2d2`crate，首先检查如何使用池连接到PostgreSQL。我们将从上一节中的代码开始，并修改它以使用连接池，其中我们从`8`个线程中执行SQL查询。
- en: 'Here''s the full code of a pooled and threaded implementation using `r2d2-postgres`
    backend crate:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`r2d2-postgres`后端crate的池化和线程化实现的完整代码：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code is fairly straight forward from the last example, except that we now
    spawn 8 threads to do a select query on our database. The pool size is configured
    to a value of `8`, which means that the `SELECT` query threads get to do 8 queries
    concurrently by reusing the connections for any further requests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与上一个示例相比相当直接，除了我们现在会启动8个线程来对我们的数据库执行选择查询。池的大小被配置为`8`，这意味着`SELECT`查询线程可以通过重用连接来并发执行8个查询。
- en: Now up until this point, we have been mostly using raw SQL queries for interacting
    with databases from Rust. But, there's a more convenient strongly typed approach
    to interacting with databases through an ORM library called diesel. Let's explore
    that next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要使用原始SQL查询从Rust与数据库交互。但是，有一个更方便的强类型方法，通过一个名为diesel的ORM库与数据库交互。让我们接下来探索一下。
- en: Postgres and the diesel ORM
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Postgres和diesel ORM
- en: Writing a complex application using low-level database libraries with raw SQL
    queries is a recipe for a lot of mistakes. Diesel is an ORM (Object Relational
    Mapper) and a query builder for Rust. It makes heavy use of procedural macros.
    It detects most database interaction errors at compile time and is able to produce
    very efficient code in most cases, sometimes even beating low-level access with
    C. This is due to its ability to move checks that are typically made at runtime
    to compile time. At the time of writing, diesel supports PostgreSQL, MySQL, and
    SQLite out of the box.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用低级数据库库和原始 SQL 查询编写复杂的应用程序是犯许多错误的原因。Diesel 是一个 Rust 的 ORM（对象关系映射器）和查询构建器。它大量使用过程宏。它在编译时检测大多数数据库交互错误，并且在大多数情况下能够生成非常高效的代码，有时甚至能超越
    C 语言的底层访问。这是因为它能够将通常在运行时进行的检查移动到编译时。在撰写本文时，diesel 支持开箱即用的 PostgreSQL、MySQL 和 SQLite。
- en: We'll be integrating database support to the linksnap server that we developed
    in [Chapter 13](ea972b20-1dc0-46d2-a0b8-d4186b0fe2c7.xhtml), *Building Web Applications
    with Rust*. We're going to use diesel to communicate with our postgres database
    in a type-safe manner. We'll copy the `linksnap` project from [Chapter 13](80838e60-3afc-4e3b-8ad4-493d7f9381af.xhtml),
    *Building Web Applications with Rust*, and rename it `linksnap_v2`. We won't be
    going over the full source code walk-through—only the parts that affect the integration
    of the database with diesel. The rest of the code base is exactly the same as
    in the previous chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把数据库支持集成到我们在 [第 13 章](ea972b20-1dc0-46d2-a0b8-d4186b0fe2c7.xhtml)，*使用 Rust
    构建 Web 应用程序* 中开发的 linksnap 服务器中。我们将使用 diesel 以类型安全的方式与我们的 postgres 数据库通信。我们将从
    [第 13 章](80838e60-3afc-4e3b-8ad4-493d7f9381af.xhtml)，*使用 Rust 构建 Web 应用程序* 中复制
    `linksnap` 项目，并将其重命名为 `linksnap_v2`。我们不会详细介绍完整的源代码，只会介绍影响数据库与 diesel 集成的部分。其余的代码库与上一章完全相同。
- en: The diesel project is built of many components. First, we have a command line
    tool called `diesel-cli` that automates the process of creation of database and
    performing any migration to the database if required.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: diesel 项目由许多组件组成。首先，我们有一个名为 `diesel-cli` 的命令行工具，它可以自动化创建数据库和执行任何必要的数据库迁移的过程。
- en: 'Now, before we start implementing routines for talking to our database, we
    need to install the `diesel-cli` tool, which will set up our database and the
    tables inside it. We can install it by running the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们开始实现与数据库通信的例程之前，我们需要安装 `diesel-cli` 工具，这将设置我们的数据库及其内部的表。我们可以通过运行以下命令来安装它：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are only using the postgres feature from this CLI tool and so the `--features`
    flag. `Cargo` will fetch and build `diesel_cli` and its dependencies, and install
    the binary to Cargo's default binary location for your user, which is usually
    `~/.cargo/bin/` directory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用此 CLI 工具的 postgres 功能和 `--features` 标志。`Cargo` 将获取并构建 `diesel_cli` 及其依赖项，并将其安装到用户
    Cargo 的默认二进制位置，通常是 `~/.cargo/bin/` 目录。
- en: 'Within our `linksnap_v2` directory, we''ll then add the connection URL to our
    database in a `.env` file that''s located in the directory root with the following
    contents:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `linksnap_v2` 目录中，我们将在目录根部的 `.env` 文件中添加数据库的连接 URL，其内容如下：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our database in postgres is named `linksnap`, and both the username and password
    is `postgres`. This is in no way a secure way to access our database and it's
    recommended that you use the best security practices to set up your postgres database
    in a production environment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 postgres 中的数据库名为 `linksnap`，用户名和密码都是 `postgres`。这绝对不是访问数据库的安全方式，建议您在生产环境中使用最佳安全实践来设置您的
    postgres 数据库。
- en: 'We''ll also need to add `diesel` as a dependency in our `Cargo.toml` file,
    along with the `dotenv` library. The `dotenv` crate handles local configuration
    via *dotfiles*. Here''s our `Cargo.toml` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `Cargo.toml` 文件中添加 `diesel` 作为依赖项，以及 `dotenv` 库。`dotenv` 包通过 *dotfiles*
    处理本地配置。以下是我们的 `Cargo.toml` 文件：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice the features on the diesel crate where we use `"postgres"` and `"r2d2"`.
    Next, we''ll run `diesel setup`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 diesel 包中我们使用的 `"postgres"` 和 `"r2d2"` 功能。接下来，我们将运行 `diesel setup`：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This creates a diesel.toml file at the root directory with the following contents:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在根目录下创建一个 diesel.toml 文件，其内容如下：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Diesel uses macros quite heavily to give us great features, such as extra safety
    and performance at compile time. To be able to do this, it needs compile-time
    access to the database. This is why the `.env` file is important. The `diesel
    setup` command automatically generates model types by reading the database and
    writing it to a file called `schema.rs`. The models are generally split into query
    and insert structs. Both use derive macros to generate model code for different
    use cases. In addition to this, a diesel-based application needs code to connect
    to the database and a set of database migrations to build up and maintain the
    database tables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Diesel 依赖于宏来提供一些出色的功能，例如在编译时提供额外的安全和性能。为了能够做到这一点，它需要编译时对数据库的访问。这就是为什么 `.env`
    文件很重要的原因。`diesel setup` 命令通过读取数据库并将其写入一个名为 `schema.rs` 的文件来自动生成模型类型。模型通常分为查询和插入结构体。两者都使用
    derive 宏来为不同的用例生成模型代码。此外，基于 diesel 的应用程序需要代码来连接到数据库，以及一组数据库迁移来构建和维护数据库表。
- en: 'Now, let''s add a migration that creates our table by running the following
    code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个迁移，通过运行以下代码来创建我们的表：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command generates a new migration with two empty `up.sql` and `down.sql`
    migration files:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成一个新的迁移，包含两个空的 `up.sql` 和 `down.sql` 迁移文件：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The migration files are just plain SQL, so we can just put in our earlier `CREATE
    TABLE` command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件只是普通的 SQL，所以我们可以直接放入我们之前的 `CREATE TABLE` 命令：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `down.sql` file should contain a corresponding `DROP TABLE`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`down.sql` 文件应该包含相应的 `DROP TABLE`：'
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once we do that, we have to run:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们就必须运行：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will create a `schema.rs` file by reading from the database:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过从数据库中读取来创建一个 `schema.rs` 文件：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `table!` macro generates code for the `linksnap` table with `id` as the
    primary key. It also specifies the column names with `id`, `title`, `url` and
    `added`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`table!` 宏为具有 `id` 作为主键的 `linksnap` 表生成代码。它还指定了列名，包括 `id`、`title`、`url` 和 `added`。'
- en: 'Now we can write a model for this table. In diesel, models can live in any
    visible module, but we''ll go with the convention of putting them in `src/models.rs`.
    Here''s its contents for our `Link` model:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为这个表编写一个模型。在 diesel 中，模型可以存在于任何可见的模块中，但我们将遵循将它们放在 `src/models.rs` 中的约定。以下是我们的
    `Link` 模型的内容：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have created a `Link` struct that can be used to query the database. It also
    has various methods that are invoked when we our server receives requests on the
    respective endpoints.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `Link` 结构体，它可以用来查询数据库。它还包含各种方法，当我们的服务器在相应的端点上收到请求时会被调用。
- en: 'Next, the `state.rs` file contains diesel and postgres specific code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`state.rs` 文件包含 diesel 和 postgres 特定的代码：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First we create a bunch of convenient aliases for our PostgreSQL connection
    pool. We have the same `Db` struct that wraps a PgPool type. The PgPool type is
    a `ConnectionManager` from the `r2d2` module in diesel. On the `Db` struct, we
    also define the `get_conn` method, which returns a reference to a pooled connection.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的 PostgreSQL 连接池创建了一组方便的别名。我们有一个相同的 `Db` 结构体，它封装了 PgPool 类型。PgPool 类型是
    diesel 中 `r2d2` 模块的一个 `ConnectionManager`。在 `Db` 结构体上，我们还定义了 `get_conn` 方法，它返回一个指向池连接的引用。
- en: 'Continuing down the same file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读同一文件：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have the familiar State type, but the init method is different here. It first
    creates accesses the `DATABASE_URL` environment variable and tries to make a pooled
    connection using the `database_url` in `pool`.  We then start a `SyncArbiter`
    thread cloning the `pool`. Finally we return back the `state` instance to the
    caller.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有熟悉的 State 类型，但这里的 init 方法不同。它首先访问 `DATABASE_URL` 环境变量，并尝试使用 `pool` 中的 `database_url`
    来建立一个池连接。然后我们启动一个 `SyncArbiter` 线程，克隆 `pool`。最后，我们将 `state` 实例返回给调用者。
- en: 'Apart from that, we don''t need to change much of our linksnap code base from
    the previous version. Let''s take our new server for a spin. We''ll insert a Link
    to our server using curl as:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们不需要对之前的 linksnap 代码库做太多修改。让我们试运行一下我们的新服务器。我们将使用 curl 将一个 Link 插入到我们的服务器中，如下所示：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now to confirm that this link made it to our postgres database, let''s query
    for this entry from the psql prompt:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了确认这个链接已经到达我们的 postgres 数据库，让我们从 psql 提示符中查询这个条目：
- en: '![](img/1acba38a-6390-427f-856b-61382f6c1174.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1acba38a-6390-427f-856b-61382f6c1174.png)'
- en: Great ! our curl request made it to the postgres database.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的 curl 请求已经到达了 postgres 数据库。
- en: Diesel's barrier to entry is a tad high though, but the situation should improve
    as more and more examples and literature come along.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Diesel 的入门门槛有点高，但随着越来越多的示例和文献出现，情况应该会得到改善。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a quick look at a few ways to perform basic database
    interaction using Rust by using the low-level SQLite and PostgreSQL library crates.
    We saw how to augment database connectivity with a connection pool using r2d2\.
    Finally, we made a small application with Diesel, a safe and performant ORM.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要地探讨了使用 Rust 通过低级别的 SQLite 和 PostgreSQL 库 crate 来执行基本数据库交互的几种方法。我们看到了如何使用
    r2d2 来增强数据库连接性，并使用连接池。最后，我们使用 Diesel，一个安全且高效的 ORM，创建了一个小型应用程序。
- en: In the next chapter, we'll take a look at how Rust can be made to run on the
    web by using a bleeding edge technology called WebAssembly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用名为 WebAssembly 的前沿技术使 Rust 能够在网络上运行。
