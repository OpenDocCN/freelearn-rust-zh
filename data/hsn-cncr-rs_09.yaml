- en: FFI and Embedding – Combining Rust and Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FFI和嵌入——结合Rust和其他语言
- en: Up until this point in the book, we've discussed Rust more or less in isolation.
    Rust was intentionally designed to integrate with other programming languages
    by calling external programming languages through its **Foreign Function Interface**
    (**FFI**) and by being embedded itself. Many modern programming languages offer
    FFI, easy embedding, or both. Python, for instance, can very conveniently call
    out to libraries with C calling conventions and can be embedded with a little
    forethought. Lua, a high-level and garbage-collected language like Python, has
    a convenient FFI and can be embedded without much trouble. Erlang has a small
    handful of FFI interfaces but Erlang is not, itself, easily embedded into user-space
    environments. Amusingly, it's fairly straightforward to compile Erlang into an
    RTOS image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们基本上是独立地讨论了Rust。Rust被有意设计成可以通过其**外部函数接口**（**FFI**）调用外部编程语言，并且自身也可以嵌入。许多现代编程语言都提供了FFI、易于嵌入或两者兼而有之。例如，Python可以非常方便地调用具有C调用约定的库，并且只需稍加考虑就可以嵌入。Lua是一种类似于Python的高级和垃圾回收语言，它有一个方便的FFI，并且可以轻松嵌入。Erlang有几个FFI接口，但Erlang本身并不容易嵌入到用户空间环境中。有趣的是，将Erlang编译成RTOS映像相当直接。
- en: In this chapter, we'll discuss calling out to foreign code in Rust and embedding
    Rust into foreign programming languages. We'll start off by extending the corewars
    evolver program —feruscore—that we covered at the tail end of [Chapter 8](d4802512-564b-4037-9407-b6035bd38f31.xhtml),
    *High-Level Parallelism – Threadpools, Parallel Iterators, and Processes*. You
    are encouraged to read that material before starting this chapter. After we've
    extended feruscore by embedding a C MARS simulator inside it, we'll move on to
    calling Rust functions from a C program. We'll demonstrate embedding Lua into
    a Rust system for convenient scripting and close the chapter by embedding Rust
    in high-level garbage-collected languages—Python and Erlang.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在Rust中调用外部代码以及将Rust嵌入到外部编程语言中。我们将从扩展我们在[第8章](d4802512-564b-4037-9407-b6035bd38f31.xhtml)的末尾介绍的corewars
    evolver程序——feruscore——开始。您被鼓励在开始本章之前阅读该材料。在我们通过在内部嵌入C MARS模拟器来扩展feruscore之后，我们将转向从C程序中调用Rust函数。我们将展示如何将Lua嵌入到Rust系统中以方便脚本编写，并以将Rust嵌入到高级垃圾回收语言（Python和Erlang）中结束本章。
- en: 'By the end of this chapter, we will have:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将：
- en: Adapted the feruscore project from the last section to incorporate a C simulator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将上一节中的feruscore项目调整为包含C模拟器
- en: Demonstrated the inclusion of Lua code into a Rust project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示了将Lua代码包含到Rust项目中的方法
- en: Demonstrated the inclusion of Rust code into a C project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示了将Rust代码包含到C项目中的方法
- en: Demonstrated the inclusion of Rust code into a Python project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示了将Rust代码包含到Python项目中的方法
- en: Demonstrated the inclusion of Rust code into an Erlang/Elixir project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示了将Rust代码包含到Erlang/Elixir项目中的方法
- en: Embedding C into Rust – feruscore without processes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将C嵌入到Rust中——feruscore不使用进程
- en: When we wrapped up our discussion of feruscore in the previous chapter, we'd
    constructed a program that could discover corewars warriors through simulated
    natural selection. This was done by writing evolved warriors out to disk, using
    Rust's OS process interface to call out to pmars—the de facto standard MARS—and
    competing them to discover their relative fitness. We used Rayon—Rust's very convenient
    data parallelism library—to distribute the workload of competitions between available
    CPUs. Unfortunately, the implementation was pretty slow. Building a tournament
    selection criteria was maybe more difficult to express than we might have hoped—though
    I'm sure there a bright-spark of a reader out there who will improve that substantially
    and wow me. The real pain point was serializing *every* warrior to disk multiple
    times, allocating similar structures repeatedly to establish each round, and then
    eating pmars' allocation and parsing overhead. It's this last step, calling out
    to an external program to run competitions, is something we'll address in this
    chapter. We will also address the other two issues because, well, why not go all-in?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一章结束对 feruscore 的讨论时，我们已经构建了一个程序，可以通过模拟自然选择来发现 corewars 战士。这是通过将进化的战士写入磁盘，使用
    Rust 的操作系统进程接口调用 pmars（事实上的标准 MARS）来竞争，以发现它们的相对适应性来完成的。我们使用了 Rayon（Rust 的非常方便的数据并行库）来在可用的
    CPU 之间分配竞争的工作负载。不幸的是，实现相当慢。构建锦标赛选择标准可能比我们希望的更难表达——尽管我确信一定有一个聪明的读者会大幅改进这一点并让我感到惊讶。真正的痛点是将每个战士多次序列化到磁盘，重复分配相似的结构来建立每一轮，然后消耗
    pmars 的分配和解析开销。正是这一步，调用外部程序来运行竞争，我们将在本章中解决。我们还将解决其他两个问题，因为，嗯，为什么不全力以赴呢？
- en: Not all of feruscore's source code appears in this chapter. Some of it was discussed
    in-depth in the previous chapter, some of it—such as benchmarking code—would be
    a rehash of material already covered in the book. The C code is not printed in
    its entirety as it's very dense and very long. You can find the full listing in
    the book's source repository.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并非 feruscore 的所有源代码都出现在本章中。其中一些在上一章中进行了深入讨论，一些——例如基准测试代码——将是书中已覆盖材料的重复。C 代码没有全部打印出来，因为它非常密集且非常长。你可以在本书的源代码库中找到完整的列表。
- en: The MARS C interface
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MARS C 接口
- en: Corewars is a venerable game and there are many implementations of MARS out
    there. pMARS, like I mentioned, is the defacto standard, implementing the '94
    ICWS draft and adding later additions, such as new instructions and a thing called
    *p-space*, that we won't go into here. Corewars has never been serious business.
    Many of the MARS available online today have traded code back and forth over the
    years, have been written with varying levels of attention to correctness, and
    sometimes programmed for older machines where multiprocessing was a concern for
    research labs. Most make no distinction between their internal library interface
    and executable consumer, like Rust programs do. Some blessed few are designed
    to be embedded, or, at least, are extractions of older MARS codebases that can
    be extended. Some blessed few of those don't use static globals in their implementations
    and can be embedded in a multiprocessing environment, such as feruscore.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Corewars 是一款古老的比赛，现在有很多 MARS 的实现。pMARS，如我提到的，是事实上的标准，实现了 '94 ICWS 草案，并添加了后来的补充，例如新的指令和称为
    *p-space* 的东西，我们在这里不会深入讨论。Corewars 从未是严肃的业务。现在在线上可用的许多 MARS 在过去几年中相互交换代码，编写时对正确性的关注程度不同，有时是为旧机器编写的，在研究实验室中，多处理是一个问题。大多数没有在其内部库接口和可执行消费者之间做出区分，就像
    Rust 程序那样。一些幸运的少数被设计为嵌入式，或者至少是旧 MARS 代码库的提取，可以扩展。其中一些幸运的少数在其实现中不使用静态全局变量，并且可以嵌入到多处理环境中，例如
    feruscore。
- en: 'In the grand tradition of MARS implementations, we will take an existing, public
    domain MARS, whittle it down to a manageable core, and put a new spin on it. Specifically,
    the feruscore introduced in this chapter embeds exhaust 1.9.2 ([http://corewar.co.uk/pihlaja/exhaust/](http://corewar.co.uk/pihlaja/exhaust/)),
    written by M. Joonas Pihlaja in the early 2000s. Pihlaja seems to have extracted
    select code from pMARS, especially in and around exhaust''s main and parser functions.
    We aren''t after any of that code. What we need is the simulator. This means that
    we can toss out anything to do with parsing, and any support code needed for exhaust''s
    `main` function. The extracted code we require lives in the feruscore project
    root, in `c_src/`. The functions we''ll embed are all implemented in `c_src/sim.c`.
    These are from `c_src/sim.h`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在MARS实现的传统大背景下，我们将从一个现有的、公有领域的MARS开始，将其精简为一个可管理的核心，并给它带来新的变化。具体来说，本章中引入的feruscore嵌入了一个1.9.2版本的exhaust
    ([http://corewar.co.uk/pihlaja/exhaust/](http://corewar.co.uk/pihlaja/exhaust/))，这是M.
    Joonas Pihlaja在2000年代初编写的。Pihlaja似乎从pMARS中提取了部分代码，尤其是在exhaust的主函数和解析函数周围。我们并不需要这些代码。我们需要的是模拟器。这意味着我们可以丢弃与解析相关的任何内容，以及为exhaust的`main`函数所需的所有支持代码。我们需要的提取代码位于feruscore项目的根目录下，在`c_src/`中。我们将嵌入的函数都实现在`c_src/sim.c`中。这些函数来自`c_src/sim.h`：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `sim_alloc_bufs` function is responsible for allocating the internal storage
    of a blank `mars_t`, the structure on which simulation is performed. `sim_clear_core`
    clears `mars_t` between rounds, setting core memory to `DAT`, and resetting any
    warrior queues. `sim_load_warrior` loads the warrior into core memory, the warrior
    really just being a pointer to an array of instructions—`insn_t`—with the `len`
    passed length. `sim_mw` runs the simulation, reading the warrior positions from
    `war_pos_tab`, and writing to `death_tab` when a warrior completely dies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`sim_alloc_bufs`函数负责分配空白`mars_t`的内部存储，这是模拟所执行的结构体。`sim_clear_core`在回合之间清除`mars_t`，将核心内存设置为`DAT`，并重置任何战士队列。`sim_load_warrior`将战士加载到核心内存中，战士实际上只是一个指向包含指令的数组的指针—`insn_t`—并传递`len`长度。`sim_mw`运行模拟，从`war_pos_tab`读取战士位置，并在战士完全死亡时写入`death_tab`。'
- en: Creating C-structs from Rust
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Rust创建C-structs
- en: Now, how do we call these functions from Rust? Moreover, how do we create instances
    of `mars_t` or `insn_t`? Well, recall back in [Chapter 03](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml),
    *The Rust Memory Model – Ownership, References, and Manipulation*, that Rust allows
    control over memory layout in structures. Specifically, all Rust structures are
    implicitly `repr(Rust)`, types aligned to byte boundaries with structure fields
    being reordered as the compiler sees fit, among other details. We also noted the
    existence of a `repr(C)` for structures, in which Rust would lay out a structure's
    memory representation in the same manner as C. That knowledge now comes to bear.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何从Rust调用这些函数？此外，我们如何创建`mars_t`或`insn_t`的实例？回想一下[第三章](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml)，*Rust内存模型
    – 所有权、引用和操作*，Rust允许对结构体的内存布局进行控制。具体来说，所有Rust结构体都是隐式地`repr(Rust)`，类型对齐到字节边界，结构体字段按编译器认为合适的方式进行排序，以及其他细节。我们还提到了结构体的`repr(C)`的存在，其中Rust将以与C相同的方式布局结构体的内存表示。现在，这些知识将得到应用。
- en: 'What we will do is this. First, we''ll compile our C code as a library and
    rig it to link into feruscore. That''s done by placing a `build.rs` at the root
    of the project and using the cc ([https://crates.io/crates/cc](https://crates.io/crates/cc))
    crate to produce a static archive, like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这样做。首先，我们将C代码编译成一个库，并将其链接到feruscore。这是通过在项目根目录放置一个`build.rs`文件并使用cc ([https://crates.io/crates/cc](https://crates.io/crates/cc))
    crate来生成一个静态归档来完成的：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Cargo will produce `libmars.a` into `target/` when the project is built. But,
    how do we make `insn_t`? We copy the representation. The C side of this project
    defines `insn_t` like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目构建时，Cargo会将`libmars.a`生成到`target/`目录下。但是，我们如何创建`insn_t`呢？我们复制了表示。本项目的C部分定义`insn_t`如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`uint16_t a` and `uint16_t b` are the *a*-field and *b*-field of the instruction,
     where `uint16_t` is a compressed representation of the `OpCode`, `Modifier`,
    and `Modes` in an instruction. The Rust side of the project defines an instruction
    like so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint16_t a`和`uint16_t b`是指令的*a*-字段和*b*-字段，其中`uint16_t`是指令中的`OpCode`、`Modifier`和`Modes`的压缩表示。项目的Rust部分定义指令如下：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the exact layout of the `inst_t` C. The reader will note that this
    is quite different from the definition of `Instruction` we saw in the previous
    chapter. Also, note that the field names do not matter, only the bit representation.
    The C structure calls the last field of the struct in, but this is a reserved
    keyword in Rust, so it is `ins` in the Rust side. Now, what is going on with that
    `ins` field? Recall that the `Mode` enumeration only had five fields. All we really
    need to encode a mode is three bits, converting the enumeration into numeric representation.
    A similar idea holds for the other components of an instruction. The layout of
    the `ins` field is:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`inst_t` C的确切布局。读者会注意到这与我们在上一章中看到的`Instruction`定义有很大不同。此外，请注意字段名并不重要，只有位表示。C结构体在结构体的最后一个字段中调用，但在Rust中这是一个保留关键字，所以在Rust这边是`ins`。现在，`ins`字段发生了什么？回想一下，`Mode`枚举只有五个字段。我们实际上只需要三个位来编码一个模式，将枚举转换为数值表示。对于指令的其他组件也有类似的想法。`ins`字段的布局如下：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Mode` for a-field is encoded in bits 0, 1 and, 2\. The `Mode` for b-field
    is in bits 3, 4, and 5, and so on for the other instruction components. The last
    two bits, 14 and 15, encode a `flag` that is almost always zero. A non-zero flag
    is an indicator to the simulator that the non-zero instruction is the `START`
    instruction—the 0^(th) instruction of a warrior is not necessarily the one executed
    first by MARS. This compact structure requires a little more work on the part
    of the programmer to support it. For instance, the `Instruction` can no longer
    be created directly by the programmer but has to be constructed through a builder.
    The `InstructionBuilder`, defined in `src/instruction.rs`, is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: a字段的`Mode`编码在位0、1和2。b字段的`Mode`在位3、4和5，其他指令组件以此类推。最后两个位，14和15，编码了一个几乎总是为零的`flag`。非零标志是向模拟器指示非零指令是`START`指令——战士的第0条指令不一定是MARS首先执行的指令。这种紧凑的结构需要程序员做更多的工作来支持它。例如，`Instruction`不能再由程序员直接创建，而必须通过构建器构建。`InstructionBuilder`定义在`src/instruction.rs`中，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As always, we have to keep track of the core size. Building the builder is
    straightforward enough, by this point:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们必须跟踪核心大小。构建构建器这个过程足够直接，到这个阶段为止：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Writing a field into the instruction requires a little bit manipulation. Here''s
    writing a `Modifier`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将字段写入指令需要一点位操作。以下是如何写入一个`Modifier`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The constant `MODIFIER_MASK` is defined in a block at the top of the source
    file with the other field masks:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`MODIFIER_MASK`在源文件顶部的某个代码块中定义，与其他字段掩码一起：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Observe that the relevant bits in the masks are 1 bits. In `InstructionBuilder::modifier`
    we `&=` the negation of the mask, which boolean-ands `ins` with the negation of
    the modifier mask, zero-ing the `Modifier` that was previously there. That done,
    the `Modifier` encoded as u16 is shifted left and boolean-or'ed into place. The
    `trailing_zeros()` function returns the total number of contiguous zeros in the
    lower end of a word, the exact number we need to shift by for each mask. Those
    readers that have done bit-manipulation work in other languages may find this
    to be very clean. I think so as well. Rust's explicit binary form for integers
    makes writing, and later, understanding, masks a breeze. Common bit-manipulation
    operations and queries are implemented on every basic integer type. Very useful.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到掩码中的相关位是1位。在`InstructionBuilder::modifier`中，我们使用`&=`操作符对掩码取反，然后将`ins`与掩码取反后的结果进行布尔与操作，将之前存在的`Modifier`清零。完成这些后，将编码为u16的`Modifier`左移，并布尔或操作到正确的位置。`trailing_zeros()`函数返回一个单词低端的连续零的总数，这是我们每个掩码需要左移的确切数量。那些在其他语言中做过位操作工作的读者可能会觉得这个过程非常简洁。我也这么认为。Rust的整数显式二进制形式使得编写和后来理解掩码变得非常容易。常见的位操作和查询在每种基本整数类型上都有实现。非常有用。
- en: 'The `OpCode` layout has changed somewhat. We don''t `repr(C)` the enum, as
    the bit representation does not matter. What does matter, since this is enumeration
    is field-less, is which integer the variants cast to. First in the source maps
    to 0, the second to 1, and so forth. The C code has op-codes defined like so in
    `c_src/insn.h`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpCode`布局有所变化。我们不使用`repr(C)`枚举，因为位表示并不重要。重要的是，由于这个枚举没有字段，所以它转换到的整数。在源代码中第一个映射到0，第二个映射到1，以此类推。C代码在`c_src/insn.h`中定义操作码如下：'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Rust version is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Rust版本如下：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The other instruction components have been shuffled around just a little bit
    to cope with the changes required by the C code. The good news is, this representation
    is more compact than the one from the previous chapter and should probably be
    maintained, even if all the C code were ported into Rust, a topic we'll get into
    later. But—and I'll spare you the full definition of `InstructionBuilder` because
    once you've seen one set-function you've seen them all—all this bit fiddling does
    make the implementation harder to see, and to correct at a glance. The instruction
    module now has QuickCheck tests to verify that all the fields get set correctly,
    meaning they can be ready right back out again no matter how many times fields
    are set and reset. You are encouraged to examine the QuickCheck tests yourself.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 其他指令组件已经稍微调整了一下，以应对C代码所需的变更。好消息是，这种表示形式比上一章中的表示形式更紧凑，并且应该保留，即使所有C代码都移植到Rust中，这也是我们稍后将要讨论的主题。但是——我将省略`InstructionBuilder`的完整定义，因为一旦你看过一组设置函数，你就已经看过了它们——所有这些位操作确实使得实现更难以看到，并且难以一眼纠正。指令模块现在有QuickCheck测试来验证所有字段是否正确设置，这意味着无论字段设置和重置多少次，它们都可以立即准备好。鼓励你自己检查QuickCheck测试。
- en: The high-level idea is this—a blank `Instruction` is made and a sequence of
    change orders is run over that Instruction—momentarily shifted into an `InstructionBuilder`
    to allow for modification—and then the changed field is read and confirmed to
    have become the value it was changed to. The technique is inline with what we've
    seen before elsewhere.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 高级理念是这样的——创建一个空的`指令`，然后在该指令上运行一系列变更订单——暂时将其移入`指令构建器`以允许修改——然后读取并确认变更的字段已变为所更改的值。这项技术与我们在其他地方之前看到的技术是一致的。
- en: 'Now, what about that `mars_t`? The C definition, in `c_src/sim.h`, is:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于那个`mars_t`呢？在`c_src/sim.h`中的C定义是：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `nWarriors` field sets how many warriors will be in the simulation, which
    for feruscore is always two cycles controls the number of cycles a round will
    take before ending if both warriors are still alive, processes the maximum number
    of processes available, and `maxWarriorLength` shows the maximum number of instructions
    a warrior may be. All of these are more or less familiar from the last chapter,
    just in a new programming language and with different names. The final three fields
    are pointers to arrays and are effectively private to the simulation function.
    These are allocated and deallocated by `sim_alloc_bufs` and `sim_free_bufs`, respectively.
    The Rust side of this structure looks like so, from `src/mars.rs`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`nWarriors`字段设置模拟中将有多少战士，对于feruscore来说，总是两个周期，控制了如果两个战士都还活着，一个回合将需要多少周期才能结束，处理可用的最大进程数，`maxWarriorLength`显示战士可能的最大指令数。所有这些在上一章中或多或少都是熟悉的，只是在新编程语言中，并且有不同的名称。最后三个字段是指向数组的指针，并且对于模拟函数来说是私有的。这些是通过`sim_alloc_bufs`和`sim_free_bufs`分别分配和释放的。这个结构的Rust版本看起来是这样的，来自`src/mars.rs`：'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The only new type here is `WarTable`. Even though our code will never explicitly
    manipulate the warrior table, we do still have to be bit-compatible with C. The
    definition of `WarTable` is:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新类型是`WarTable`。尽管我们的代码永远不会显式地操作战士表，但我们仍然必须与C兼容。`WarTable`的定义如下：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We could have maybe got away with just making these private fields in `Mars`
    pointers to void in `mars_st`, but that would have reduced type information on
    the C side of the project and this approach might hamper future porting efforts.
    With the type explicit on the Rust side of the project, it's much easier to consider
    rewriting the C functions in Rust.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以只通过在`Mars`中将这些私有字段设置为`mars_st`中的`void`指针来解决这个问题，但这会减少项目C端的信息类型，并且这种方法可能会阻碍未来的移植工作。由于项目Rust端类型明确，因此考虑在Rust中重写C函数要容易得多。
- en: Calling C functions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用C函数
- en: 'Now that we can create Rust structs with C-bit layout, we can start passing
    that memory down into C. It''s important to understand, this is an inherently
    unsafe activity. The C code might fiddle with memory in a way that breaks Rust''s
    invariants and the only way we can be sure this isn''t true is auditing the C
    code ahead of time. This is the same with fuzzing, which we''ll do too. How do
    we link with `libmars.a`? A small `extern` block will do it, in `src/mars.rs`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建具有C位布局的Rust结构，我们可以开始将内存传递到C中。重要的是要理解，这是一个固有的不安全活动。C代码可能会以破坏Rust不变性的方式操作内存，而我们唯一能确保这不是真的方法是在事先审计C代码。这与模糊测试一样，我们也会进行。我们如何链接到`libmars.a`？一个小的`extern`块就可以做到，在`src/mars.rs`中：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With `#[link(name = "mars")]`, we''re instructing the compiler to link to the
    `libmars.a` produced in the build process. If we were linking to a system library,
    the approach would be the same. The Rust Nomicon section on FFI—referenced in
    the *Further reading* section at the end of this chapter—links to libsnappy, for
    example. The extern block informs the compiler that these functions will need
    to be called with the C ABI, not Rust''s. Let''s compare `sim_load_warrior` side
    by side. Here is the C version:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `#[link(name = "mars")]`，我们指示编译器链接到构建过程中生成的 `libmars.a`。如果我们正在链接到系统库，方法将是相同的。Rust
    Nomicon 部分关于 FFI 的内容——在本章末尾的 *进一步阅读* 部分中引用——链接到 libsnappy，例如。extern 块通知编译器，这些函数将需要使用
    C ABI 调用，而不是 Rust 的。让我们将 `sim_load_warrior` 进行并排比较。以下是 C 版本：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the Rust version:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Rust 版本：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These are similar. C doesn't have the same mutability concept as Rust, though
    there are const annotations for code that Rust picks up for free. We've enhanced
    that by making all of Instruction's query functions take `&self`. Rule of thumb—unless
    the C is const-correct, you should probably assume the Rust needs a `*mut`. This
    isn't always true, but it saves a fair deal of headache. Now, on that notion,
    the careful reader may note that as I ported exhaust's code into feruscore, I
    adapted it to use `stdint.h`. In the unaltered code, `pos` has the unsigned int
    type or `usize`. The simulator C code assumes `pos` will be at least 32 bits wide,
    hence the explicit conversation to a 32-bit integer. This wasn't entirely necessary,
    but it's good form to used fixed-width types as they minimize surprises moving
    between CPU architectures.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相似的。尽管 Rust 可以免费获取代码的 const 注释，但 C 没有与 Rust 相同的可变性概念。我们通过使所有指令的查询函数都接受 `&self`
    来增强了这一点。经验法则——除非 C 是 const-correct，否则你可能需要假设 Rust 需要 `*mut`。这并不总是正确的，但它可以节省很多麻烦。现在，关于这个概念，细心的读者可能会注意到，当我将
    exhaust 的代码移植到 feruscore 时，我将其修改为使用 `stdint.h`。在未修改的代码中，`pos` 有无符号整型或 `usize`
    类型。模拟器 C 代码假设 `pos` 至少有 32 位宽，因此显式转换为 32 位整数。这并不完全必要，但使用固定宽度类型是一种良好的做法，因为它们最小化了在
    CPU 架构之间移动时的惊喜。
- en: Managing cross-language ownership
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理跨语言所有权
- en: 'Rust is now aware of the C functions, and we have our internal structs reworked
    to use C layout: it is time to link up the C functions that manipulate `mars_t`
    with our `Mars`. Because we''re sharing ownership of `Mars` between the Rust allocator
    and the C allocator, we''ve got to be careful to initialize the `Mars` struct
    with null pointers in the fields that C will own, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 现在知道 C 函数了，并且我们已经将内部结构重新设计为使用 C 布局：现在是时候将操作 `mars_t` 的 C 函数与我们的 `Mars`
    链接起来。因为我们正在 Rust 分配器和 C 分配器之间共享 `Mars` 的所有权，所以我们必须小心地将 `Mars` 结构体中的字段初始化为 null
    指针，这些字段将由 C 拥有，如下所示：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This `MarsBuilder` is a builder-pattern for producing a `Mars`. The remainder
    of the implementation works how you might expect:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `MarsBuilder` 是一个用于生成 `Mars` 的构建器模式。实现的其他部分按预期工作：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Back to `MarsBuilder::freeze(self) -> Mars`. This function creates a new `Mars`
    and then passes it immediately into `sim_alloc_bufs`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `MarsBuilder::freeze(self) -> Mars`。这个函数创建一个新的 `Mars`，然后立即将其传递给 `sim_alloc_bufs`：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`&mut mars` automatically coerces into `*mut mars` and, as we know from previous
    chapters, dereferencing a raw pointer is unsafe. The fact that it''s *C* dereferencing
    the raw pointer is icing on the cake. Now, let''s take a look at `sim_alloc_bufs`
    and get a sense of what''s going on. In `c_src/sim.c`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`&mut mars` 自动转换为 `*mut mars`，正如我们从前几章所知，解引用原始指针是不安全的。它是 *C* 解引用原始指针的事实更是锦上添花。现在，让我们看一下
    `sim_alloc_bufs` 并了解正在发生的事情。在 `c_src/sim.c` 中：'
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The three fields owned by C—`coreMem`, `queueMem`, and `warTab`—are allocated
    according to the size of the structs being stored and the return is a boolean-and
    of the `malloc` returns, a short way of determining whether `malloc` ever returned
    `NULL`, signaling that no more memory was available on-system. Had we decided
    to add a new field into the Rust struct and not updated the C struct to reflect
    this change, these stores would be too small. Eventually, some code somewhere
    would reach past the bounds of an array and crash. No good, that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C 拥有的三个字段——`coreMem`、`queueMem` 和 `warTab`——是根据存储的结构的尺寸分配的，返回值是 `malloc` 返回值的布尔与，这是一种确定
    `malloc` 是否曾经返回 `NULL` 的简便方法，这表示系统上没有更多的内存可用。如果我们决定向 Rust 结构体中添加一个新字段，而没有更新 C
    结构体以反映这一变化，这些存储空间就会太小。最终，某个地方的代码会超出数组边界并崩溃。这可不是什么好事。
- en: But! We've just called C code from Rust.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是！我们刚刚从 Rust 调用了 C 代码。
- en: 'Let''s talk about ownership for a second. `Mars` is a structure not wholly
    owned by Rust, and not wholly owned by C. That''s fine and is also not uncommon,
    especially if you''re partially (or completely) porting a C codebase into Rust.
    It does mean we''ve got to be careful about `Drop`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈所有权问题。`Mars` 是一个结构，它既不完全由 Rust 拥有，也不完全由 C 拥有。这是可以接受的，并且也不少见，尤其是如果你正在部分（或完全）将
    C 代码库移植到 Rust。这意味着我们必须小心处理 `Drop`：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we''ve seen in previous chapters, we have to arrange for explicit `Drop`
    when there''s raw memory in use. `Mars` is no exception. The call here to `sim_free_bufs`
    clears up the C-owned memory and Rust takes care of the rest. If cleanup were
    more difficult—as sometimes happens—you''d have to take care to avoid deferencing
    the C-owned pointers post-free. `sim_free_bufs` is a brief implementation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，当使用原始内存时，我们必须显式地进行 `Drop` 操作。`Mars` 也不例外。这里的 `sim_free_bufs`
    调用清理了 C 所拥有的内存，而 Rust 负责处理其余部分。如果清理更加困难——这种情况有时会发生——你必须小心避免在释放后解引用 C 所拥有的指针。`sim_free_bufs`
    的实现如下：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Running the simulation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行模拟
- en: All that's left to do is run warriors in simulation. In the previous chapter,
    an `Individual` was responsible for managing its own pmars process. Now, `Mars`
    will be responsible for hosting the competitors, which you may have gleaned from
    the C API. We simply don't have any space in `Individual` to store something,
    and by pushing competition into `Mars`, we can avoid allocation churn on temporary
    `Mars` structures.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是运行模拟中的战士。在上一章中，`Individual` 负责管理自己的 pmars 进程。现在，`Mars` 将负责托管竞争对手，你可能已经从
    C API 中了解到这一点。我们简单地没有在 `Individual` 中存储任何东西的空间，通过将竞争推入 `Mars`，我们可以避免在临时的 `Mars`
    结构上发生分配波动。
- en: 'The compete function that was formerly bound to `Individual` has now been moved
    to `Mars`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前绑定到 `Individual` 的完整函数现在已移动到 `Mars`：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The C API requires that we calculate the warrior offsets and take care to not
    overlap them. The approach taken here is to randomly place the left Individual,
    determine whether it''s in the upper or lower core, and then place the right Individual,
    taking care with both to not place them past the `end` of the core. The actual
    implementation of the competition is `compete_inner`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C API 要求我们计算战士的偏移量，并注意不要重叠它们。这里采取的方法是随机放置左边的 `Individual`，确定它是在核心的上部还是下部，然后放置右边的
    `Individual`，同时注意不要将它们放置在核心的 `end` 之后。竞争的实际实现是 `compete_inner`：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We call `Individual::as_ptr() -> (u16, *const Instruction)` to get a raw view
    of the chromosome of the Individual and its length. Without this, we''ve got nothing
    to pass down to the C functions. `warrior_position_table` informs MARS which instructions
    are the start of its competitors. We could search out the `START` flag in the
    warriors and place that in `warrior_position_table`. This is an improvement left
    for the reader. The deaths table will be populated by the simulator code. If both
    warriors die during competition, the array will be `[0, 1]`. The death table is
    populated with `u32::max_value()` to make distinguishing no-result from result
    easy enough. Before starting the competition, we have to clear the simulator—which
    might be filled with instructions from a previous bout:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `Individual::as_ptr() -> (u16, *const Instruction)` 来获取个体的染色体及其长度的原始视图。没有这个，我们就无法将任何内容传递给
    C 函数。`warrior_position_table` 通知 MARS 哪些指令是其竞争对手的起始点。我们可以在战士中搜索 `START` 标志，并将其放置在
    `warrior_position_table` 中。这是一个留给读者的改进。死亡表将由模拟器代码填充。如果两个战士在竞争中同时死亡，数组将是 `[0, 1]`。死亡表用
    `u32::max_value()` 填充，以便于区分无结果和结果。在开始竞争之前，我们必须清除模拟器——它可能充满了来自上次比赛的指令：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you pull up the `sim_clear_core` implementation, you''ll find a memset to
    0 over `core_mem`. Recall that `DAT` is the 0^(th) variant of the `Instruction`
    enumeration. Unlike `pmars`, this simulator must use `DAT` as a default instruction,
    but it does make resetting the field very fast. `sim_clear_core` also clears up
    the process queue and other C-owned storage. Loading the warriors is a matter
    of plugging in the information we''ve already computed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拉取 `sim_clear_core` 的实现，你会找到一个将 `core_mem` 设置为 0 的 memset 操作。回想一下，`DAT` 是
    `Instruction` 枚举的第 0 个变体。与 `pmars` 不同，这个模拟器必须使用 `DAT` 作为默认指令，但它确实使得重置字段非常快速。`sim_clear_core`
    还清理了进程队列和其他 C 所拥有的存储。加载战士的信息是一个将我们已计算的信息插入的过程：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the result is non-zero, that''s an indicator that some serious and non-recoverable
    fault has happened. `sim_load_warrior` is an array operation, writing the warrior
    Instructions into `core_mem` at the defined offsets. We could, very conceivably,
    rewrite the functions of `sim_clear_core` and `sim_load_warrior` in Rust if we
    wanted to. Finally, field cleared and warriors loaded, we are able to simulate:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果是非零的，这表明发生了某些严重且无法恢复的错误。`sim_load_warrior` 是一个数组操作，将战士指令写入 `core_mem` 中的定义偏移量。如果我们想的话，完全可以使用
    Rust 重新编写 `sim_clear_core` 和 `sim_load_warrior` 函数。最后，字段已清除且战士已加载，我们能够进行模拟：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `sim_mw` function returns the total number of warriors left alive at the
    end of the simulation run. If this value is `-1`, there's been some catastrophic,
    unrecoverable error.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`sim_mw` 函数返回模拟运行结束时剩余的战士总数。如果这个值是 `-1`，则表示发生了某些灾难性的、无法恢复的错误。'
- en: Now, because we have a nice type system to play with, we don't really want to
    signal results back to the user with a vector of integers. We preserve the `Winner`
    type seen
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们有一个很好的类型系统可以与之玩耍，我们并不想用整数向量向用户返回结果。我们保留了看到的 `Winner` 类型
- en: 'in the previous chapter, doing a quick conversion before returning:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，在返回之前进行快速转换：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You may have noticed that `Winner` implements `Add`, allowing compete to signal
    how many rounds the warriors won. `impl Add for Winner` is also in `src/mars.rs`,
    should you be curious to see it. As a final sanity test around `Mars`, we confirm
    that the Imp will lose to Dwarf more often than other outcomes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `Winner` 实现了 `Add`，允许竞争信号战士赢得了多少轮。`impl Add for Winner` 也在 `src/mars.rs`
    中，如果你好奇想看看它。作为对 `Mars` 的最终合理性测试，我们确认 Imp 会比其他结果更经常地输给 Dwarf：
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Recall that an Imp can't self-kill, only propagate. The Dwarf bombs core memory
    at regular, increasing offsets. An Imp versus Dwarf competition, then, is a race
    between Imp finding Dwarf's instructions and Dwarf dropping a `DAT` in the path
    of an Imp.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Imp 不能自杀，只能传播。Dwarf 以规律、递增的偏移量轰炸核心内存。因此，Imp 与 Dwarf 的竞争是一场 Imp 寻找 Dwarf
    指令和 Dwarf 在 Imp 的路径上放下 `DAT` 的赛跑。
- en: Fuzzing the simulation
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试模拟
- en: 'Feruscore has been changed in this chapter to include raw memory access in
    both Rust and through FFI. The responsible thing to do is fuzz `Mars` and make
    sure we''re not causing segmentation faults. We''ll use AFL, which we discussed
    back in [Chapter 2](8c61da2f-08c8-40be-89d4-d8afa8510850.xhtml), *Sequential Rust
    Performance and Testing*, and again in [Chapter 5](e2de1ba7-c291-494e-82da-37fee7323c1d.xhtml),
    *Locks – Mutex, Condvar, Barriers, and RWLock*. The fuzz target is `src/bin/fuzz_target.rs`.
    The trick with fuzzing is ensuring stability. That is, AFL can''t really do its
    work if for some input applied multiple times multiple paths come out. Fuzzing
    is more efficient in the case of a deterministic system. We were careful to make
    `Mars::compete_inner` deterministic, where `Mars::compete` uses randomness to
    determine warrior positions. Fuzzing, then, will go through `compete_inner` only.
    The preamble for `fuzz_target` doesn''t contain any new crates:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，Feruscore 已被修改以包括 Rust 和通过 FFI 的原始内存访问。应负责的事情是模糊测试 `Mars` 并确保我们没有造成段错误。我们将使用
    AFL，我们之前在 [第 2 章](8c61da2f-08c8-40be-89d4-d8afa8510850.xhtml) 和 [第 5 章](e2de1ba7-c291-494e-82da-37fee7323c1d.xhtml)
    中讨论过，分别是 *Sequential Rust Performance and Testing* 和 *Locks – Mutex, Condvar,
    Barriers, and RWLock*。模糊测试目标是 `src/bin/fuzz_target.rs`。模糊测试的技巧在于确保稳定性。也就是说，如果某些输入被多次应用，导致多个路径出现，那么
    AFL 真的无法完成其工作。在确定性系统中，模糊测试更有效率。我们小心地使 `Mars::compete_inner` 确定性，而 `Mars::compete`
    使用随机性来确定战士的位置。因此，模糊测试将只通过 `compete_inner`。`fuzz_target` 的前言不包含任何新的 crate：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Remember that AFL passes a byte slice through stdin and the fuzzing target
    is responsible for deserializing that array into something sensible for itself.
    We''ll build up a `Config` structure:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，AFL 通过 stdin 传递一个字节切片，模糊测试目标是负责将该数组反序列化为对自己有意义的某种形式。我们将构建一个 `Config` 结构体：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Hopefully, these fields are familiar. The `rounds`, `core_size`, `cycles`,
    and `processes` each affect the MARS environment. The `max_warrior_length`, `left_chromosome_size`,
    and `right_chromosome_size` affect the two individuals that will be made to compete.
    `left` and `right` are those `Individual` instances. `left_pos` and `right_pos`
    set where the warriors will be placed in the MARS core memory. The numbers that
    we''ll deserialize from the byte slice won''t always be entirely sensible, so
    there''ll be some cleanup needed, like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些领域对您来说都很熟悉。`rounds`、`core_size`、`cycles` 和 `processes` 每个都会影响 MARS 环境。`max_warrior_length`、`left_chromosome_size`
    和 `right_chromosome_size` 影响将要相互竞争的两个个体。`left` 和 `right` 是那些 `Individual` 实例。`left_pos`
    和 `right_pos` 设置战士将在 MARS 核心内存中的位置。我们从字节切片反序列化出的数字不一定总是完全合理，因此需要一些清理工作，如下所示：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It doesn''t make any sense for there to be 0 rounds, as an example, so we say
    thatthere must be at least one round. Likewise, we need two processes, desire
    at least four warrior instructions, and so forth. Creating the left and right
    warriors is a matter of passing the byte reader into `Config::mk_individual`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，0 轮次没有任何意义，所以我们说至少必须有一轮。同样，我们需要两个进程，至少希望有四个战士指令，等等。创建左右战士的问题在于将字节读取器传递给 `Config::mk_individual`：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Config::mk_individual` deserializes into `InstructionBuilder`. The whole thing
    is kind of awkward. While we can convert a field-less Enum into an integer, it''s
    not possible to go from an integer to a field-less Enum without some hairy match
    statements:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Config::mk_individual` 将反序列化到 `InstructionBuilder`。整个事情有点尴尬。虽然我们可以将无字段的枚举转换为整数，但无法在没有一些复杂的匹配语句的情况下，从整数转换到无字段的枚举：'
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we''ve established the `InstructionBuilder` and read the `Mode` for a-field
    and b-field out from the byte slice. If a field is added, we''ll have to come
    through here and update the fuzzing code. It''s a real pain. Reading the `Modifier`
    out works the same way:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经建立了 `InstructionBuilder` 并从字节切片中读取了 a 场和 b 场的 `Mode`。如果添加了字段，我们就必须通过这里来更新模糊测试代码。这真是个麻烦事。以相同的方式读取
    `Modifier`：
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As does reading out the `OpCode`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 `OpCode` 也是如此：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Producing an instruction is simple enough, thanks to the builder pattern in
    use here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 生成指令很简单，多亏了这里使用的构建器模式：
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Moving back up to `Config::new`, we create the left and right positions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `Config::new`，我们创建左右位置：
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `adjust_pos` function is a small thing, intended to keep warrior positions
    properly in bounds:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjust_pos` 函数是一件小事，目的是确保战士的位置在合理的范围内：'
- en: '[PRE39]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It''s entirely possible that the warriors will overlap with this calculation.
    That is okay. Our ambition with fuzzing is not to check the logic of the program,
    only to seek out crashes. In fact, if overlapping two warriors causes a crash,
    that''s a fact we need to know. The close of `Config::new` is fairly straightforward:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 战士与这个计算重叠是完全可能的。这是可以的。我们进行模糊测试的雄心壮志不是检查程序的逻辑，而是寻找崩溃。实际上，如果两个战士重叠导致崩溃，这是我们必须要知道的事实。`Config::new`
    的结束相当直接：
- en: '[PRE40]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After all that, the main function of `fuzz_target` is minimal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，`fuzz_target` 的主函数是最小的：
- en: '[PRE41]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`Stdin` is captured and a `Cursor` built from it, which we pass into `Config::new`,
    as explained earlier. The resulting `Config` is used to fuel `MarsBuilder`, and
    the `Mars` is then the arena for competition between the two fuzzing `Individual`
    instances that may or may not overlap. Remember, before running AFL, be sure to
    run `cargo afl build`—release and not cargo build —release. Both will work, but
    the first is significantly faster to discover crashes, as AFL''s instrumentation
    will be inlined in the executable. I''ve found that even a single instance of
    `cargo afl fuzz -i /tmp/in -o /tmp/out target/release/fuzz_target` will run through
    AFL cycles at a good clip. There aren''t many branches in the code and, so, few
    paths for AFL to probe.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stdin` 被捕获并从它构建了一个 `Cursor`，我们将其传递给 `Config::new`，如前所述。生成的 `Config` 用于驱动 `MarsBuilder`，然后
    `Mars` 就是两个可能重叠或可能不重叠的模糊测试 `Individual` 实例竞争的舞台。记住，在运行 AFL 之前，一定要运行 `cargo afl
    build`——发布版，而不是 cargo build ——发布版。两者都可以工作，但第一个在发现崩溃方面要快得多，因为 AFL 的仪器将内联在可执行文件中。我发现，即使是一个单独的实例
    `cargo afl fuzz -i /tmp/in -o /tmp/out target/release/fuzz_target` 也能以不错的速度完成
    AFL 循环。代码中分支不多，因此 AFL 要探索的路径也少。'
- en: The feruscore executable
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`feruscore` 可执行文件'
- en: 'The final thing left to cover is `src/bin/feruscore.rs`. The careful reader
    will have noted that there''s been a suspicious lack of rayon in the implementation
    so far. In fact, rayon is not in use in this version. Here''s the full `Cargo.toml`
    for the project:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要介绍的是`src/bin/feruscore.rs`。仔细的读者会注意到，到目前为止，实现中几乎没有使用rayon。实际上，在这个版本中并没有使用rayon。以下是项目的完整`Cargo.toml`：
- en: '[PRE42]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As mentioned at the start of the chapter, there were two issues with feruscore
    aside from calling out to an OS process: repeat allocation of similar structures
    and poor control over tournaments. Viewed a certain way, comparing `Individual`
    fitness is a sorting function. Rayon does have a parallel sorting capability,
    `ParallelSliceMut<T: Send>::par_sort(&mut self)`, where `T: Ord`. We could make
    use of that, defining an `Ord` for `Individual` that allocated a new `Mars` for
    every comparison. Many tiny allocations is a killer for speed, though. A thread-local
    `Mars` could reduce that to a single allocation per thread, but then we''re still
    giving up some control here. For instance, without inspecting rayon''s source,
    can we be sure that population chunks are going to be of roughly equal size? Usually,
    this is not a concern, but it is for us here. Rayon''s requiring that we perform
    a fold and then a reduce step is also extra work we don''t necessarily have to
    do if we adjust our ambitions some.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '如本章开头所述，feruscore除了调用操作系统进程外，还存在两个问题：相似结构的重复分配和对锦标赛的较差控制。从某种角度看，比较`Individual`的适应性是一个排序函数。Rayon确实具有并行排序能力，`ParallelSliceMut<T:
    Send>::par_sort(&mut self)`，其中`T: Ord`。我们可以利用这一点，为`Individual`定义一个`Ord`，每次比较都会分配一个新的`Mars`。然而，许多微小的分配会严重影响速度。一个线程本地的`Mars`可以将这个数量减少到每个线程一个分配，但这样我们仍然放弃了一些控制。例如，如果不检查rayon的源代码，我们能否确定种群块的大小大致相等？通常情况下，这并不是一个问题，但对我们来说却是。Rayon要求我们执行折叠和减少步骤，这也是我们不需要做的工作，如果我们调整我们的目标的话。'
- en: One common method to deal with parallelizing genetic algorithms, and the one
    we'll take now, is to make islands that undergo evolution in parallel. The user
    sets a global population, where  this population is split among islands, and threads
    are assigned an island to simulate for some number of generations. After that
    limit of generations is up, the island populations are merged, shuffled, and redistributed
    to islands. This has the benefit of reducing cross-thread communication, which
    potentially comes with cache locality issues.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 处理并行遗传算法的一种常见方法，也是我们现在要采用的方法，是创建岛屿，这些岛屿并行进行进化。用户设置一个全局种群，这个种群被分配到岛屿之间，线程被分配到岛屿以模拟一定数量的代。在达到这一代数的限制后，岛屿种群被合并、打乱并重新分配到岛屿。这有助于减少跨线程通信，这可能会带来缓存局部性问题。
- en: 'The preamble of `src/bin/feruscore.rs` is straightforward:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/bin/feruscore.rs`的序言部分很简单：'
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The configuration and reporting globals are somewhat reduced, compared to the
    last chapter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章相比，配置和报告的全局变量有所减少：
- en: '[PRE44]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `report` function is almost entirely the same as in last chapter, except there
    are a few less atomic variables to read from. checkpoint is also almost entirely
    the same. We''ll skip reprinting both functions in the interest of space. What
    is new is `sort_by_tournament`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`report`函数几乎与上一章相同，只是要读取的原子变量少了一些。检查点也几乎完全相同。为了节省空间，我们将跳过重新打印这两个函数。新的内容是`sort_by_tournament`：'
- en: '[PRE45]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This function sorts a population by fitness, based on the result of competition
    inside the passed `Mars`. The reader will note that it''s not a true sort in that
    the last element is the most fit, but that the last element is the winner of the
    first tournament, the second to last the winner of the second tournament, and
    so forth. Only `population.len() / 2` competitions are held and the resulting
    champions compare favorably to a population precisely sorted by fitness. The reader
    is encouraged to experiment with their own implementation of `sort_by_tournament`.
    Now, let''s look at the `main` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数根据传递的`Mars`内部竞争的结果对种群进行排序。读者会注意到，这并不是一个真正的排序，因为最后一个元素是最适应的，但最后一个元素是第一个锦标赛的获胜者，倒数第二个是第二个锦标赛的获胜者，以此类推。只有`population.len()
    / 2`个竞争进行，产生的冠军与精确按适应性排序的种群相比具有优势。鼓励读者尝试自己实现`sort_by_tournament`。现在，让我们看看`main`函数：
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The total number of islands in a feruscore run will vary by the number of CPUs
    available on-system. Each island causes two synchronous MPSC channels to be created,
    one for the main thread to push populations into the worker thread and one for
    the worker thread to push populations back to the main. The implementation refers
    to these as `in_*` and `out_*` senders and receivers. You can see again that we''re
    building up a population of random `Individual` warriors and pushing the ringers
    in, though the island population is not `POPULATION_SIZE`, but an even split of
    `POPULATION_SIZE` by the number of available CPUs. The reporting thread is started
    after the island threads have their populations, mostly just to avoid UI spam:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在feruscore运行中岛屿的总数将根据系统上可用的CPU数量而变化。每个岛屿都会创建两个同步的MPSC通道，一个用于主线程将种群推入工作线程，另一个用于工作线程将种群推回主线程。实现中称这些为`in_*`和`out_*`发送者和接收者。你可以再次看到，我们正在构建一个由随机`Individual`战士组成的种群并将他们推入其中，尽管岛屿种群不是`POPULATION_SIZE`，而是由可用CPU数量均匀分割的`POPULATION_SIZE`。在岛屿线程拥有种群后，启动报告线程，主要是为了避免UI垃圾信息：
- en: '[PRE47]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The report function is much the same as it was in the previous chapter's discussion
    of feruscore and I'll avoid listing it here for brievity's sake.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 报告函数与上一章中关于feruscore的讨论大致相同，为了简洁起见，这里不再列出。
- en: 'The final chunk of the `main` function is the recombining loop. When the island
    threads finish their competitions, they write into their out sender, which gets
    picked up by the recombination loop:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数的最后一段是重组循环。当岛屿线程完成竞赛后，它们将写入它们的输出发送者，该发送者会被重组循环拾取：'
- en: '[PRE48]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once all the islands have been merged together, the whole lot is shuffled:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有岛屿合并在一起，整个种群就会被打乱：
- en: '[PRE49]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'That''s one generation done. We `checkpoint`, this time doing an additional
    tournament to pull the save winners from the global population:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，一代就完成了。我们`checkpoint`，这次进行了一次额外的锦标赛，从全局种群中拉取保存的优胜者：
- en: '[PRE50]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, the population is split back up and sent to the island threads:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，种群被重新分割并发送到岛屿线程：
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, what is island doing? Well, it''s an infinite loop pulling from the population
    assignment receiver:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，岛屿在做什么？嗯，它是一个无限循环，从种群分配接收器中提取：
- en: '[PRE52]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now a `Mars` is allocated above the loop, meaning we''ll only ever do `num_cpu::get()`
    allocations of this structure per feruscore run. Also recall that `Receiver::recv`
    blocks when there is no data in the channel, so island threads don''t burn up
    CPU when there''s no work for them. The interior of the loop should be familiar.
    First, the `Individual` warriors are put into competition:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在循环上方分配了一个`Mars`，这意味着我们将在每个feruscore运行中只进行`num_cpu::get()`次这种结构的分配。也请记住，当通道中没有数据时，`Receiver::recv`会阻塞，因此岛屿线程在没有工作可做时不会消耗CPU。循环的内部应该很熟悉。首先，将`Individual`战士放入竞赛：
- en: '[PRE53]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Reproduction is done by taking high-ranking members of the population and producing
    two children into the low reaches of the population until the total number of
    children needed per generation is reached:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从种群中选取高排名成员并产生两个子代到种群的低端，直到达到每代所需子代总数，来完成繁殖：
- en: '[PRE54]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'New to this implementation, we also introduce random new population members
    just before the newly introduced children:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们还在新引入的子代之前引入了随机新的种群成员：
- en: '[PRE55]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Random infusion can help tamp down premature convergence in a population. Remember,
    simulated evolution is a kind of state-space search. Something else that has changed
    is that all members of the population have a chance of mutation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 随机注入可以帮助抑制种群中的过早收敛。记住，模拟进化是一种状态空间搜索。还有一点变化是，种群中的所有成员都有突变的机会：
- en: '[PRE56]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we push the population back up to the recombination thread, having
    worked the population over thoroughly:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将种群推回重组线程，对种群进行了彻底的处理：
- en: '[PRE57]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'With all the changes made here—cutting back on small allocations, reducing
    total number of competitions per generation, removing pmars parsing plus spawn
    overhead—the implementation is substantially faster. Recall that the implementation
    in the last chapter struggled to peak 500 competitions—or `BATTLES` as the UI
    has it—per second. Here''s a report diagnostic from a recent eight-hour run I
    did:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里进行的所有更改——减少小分配、每代减少竞赛总数、移除pmars解析及spawn开销——使得实现速度大幅提升。回想一下，上一章中的实现难以达到每秒500场竞赛——或者如UI所示为`BATTLES`——的峰值。以下是我在最近一次八小时运行中得到的报告诊断：
- en: '[PRE58]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: That's 14,000 battles per second on an 8,000-sized core memory, or around 650
    generations per hour. Still not blazingly fast, but enough that with some time
    you can start to get pretty mediocre players being produced. Reducing core memory
    size will improve the runtime, as will limiting the maximum length of the warriors.
    Those who are interested in building a better evolver would do well to investigate
    different ways of assessing fitness, of introducing more ringers, and seeing whether
    porting `sim_mw` into Rust wouldn't improve runtime some. This simulator doesn't
    support the full scope of instructions that pMARS does, so that's also an area
    for improvement.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在一个 8,000 大小核心内存上的每秒 14,000 次战斗，或者大约每小时 650 代。仍然不是特别快，但足够你在一段时间后开始产生相当平庸的玩家。减少核心内存大小将提高运行时间，限制战士的最大长度也是如此。对构建更好的进化器感兴趣的人应该调查不同的评估适应度的方式，引入更多的铃声，并看看将
    `sim_mw` 移植到 Rust 中是否会提高运行时间。这个模拟器不支持 pMARS 所有的指令范围，所以这也是一个改进的领域。
- en: I'd love to hear about what you come up with.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我很乐意听听你的想法。
- en: Embedding Lua into Rust
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Lua 集成到 Rust 中
- en: Many of the programs we've discussed in this book use a *report* thread to notify
    the user of the running behavior of the program. Each of these report functions
    have been coded in Rust, an unchanging part of the executable. What if, however,
    we wanted end-users to be able to supply their own reporting routine? Or, consider
    the cernan project ([https://crates.io/crates/cernan](https://crates.io/crates/cernan)),
    discussed previously in this book, which supports a *programmable filter*, an
    online data-stream filter that can be programmed by end-users without changing
    the cernan binary. How do you pull such a trick off?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本书讨论的许多程序都使用一个 *报告* 线程来通知用户程序的运行行为。这些报告函数都使用 Rust 编码，是可执行文件中不变的部分。但是，如果我们想让最终用户能够提供他们自己的报告例程呢？或者，考虑一下本书之前讨论过的
    cernan 项目 ([https://crates.io/crates/cernan](https://crates.io/crates/cernan))，它支持一个
    *可编程过滤器*，这是一个在线数据流过滤器，最终用户可以在不更改 cernan 二进制文件的情况下对其进行编程。你是如何完成这个技巧的？
- en: A common answer, not just in Rust but in many compiled languages, is to embed
    a Lua interpreter ([https://www.lua.org/](https://www.lua.org/)) and read user
    programs in at startup. It's such a common answer, in fact, that there are many
    Lua embeddings to choose from in the crates ecosystem. We'll use rlua ([https://crates.io/crates/rlua](https://crates.io/crates/rlua))
    here as it's a safe choice and the project documentation is very good. Other Lua
    embeddings suit different ambitions. Cernan uses a different, not necessarily
    safe embedding, for example, because we need to allow end-users to define their
    own functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的答案，不仅在 Rust 中，在许多编译语言中也是如此，就是嵌入一个 Lua 解释器 ([https://www.lua.org/](https://www.lua.org/))
    并在启动时读取用户程序。事实上，这是一个如此常见的答案，以至于在 crates 生态系统中有许多 Lua 集成可供选择。在这里我们将使用 rlua ([https://crates.io/crates/rlua](https://crates.io/crates/rlua))，因为它是一个安全的选择，并且项目文档非常好。其他
    Lua 集成适合不同的目标。例如，Cernan 使用不同的、不一定安全的嵌入，因为我们需要允许最终用户定义他们自己的函数。
- en: 'In the previous chapter, we wrote a project called `sniffer` whose purpose
    was threefold—collect Ethernet packets on an interface, report about them, and
    echo the Ethernet packet back. Let''s take that program and adapt it so that users
    can decide how to report with custom scripts. The `Cargo.toml` file of the project
    is a little different, including the rlua dependency and dropping the thread-hungry
    alternative executable:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写了一个名为 `sniffer` 的项目，其目的是三方面的——在接口上收集以太网数据包，报告它们，并将以太网数据包回显。让我们将这个程序改编一下，让用户能够通过自定义脚本来决定如何报告。项目的
    `Cargo.toml` 文件略有不同，包括包含 rlua 依赖项并删除了线程密集型替代可执行文件：
- en: '[PRE59]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preamble to the sniffer program, defined in `src/bin/sniffer.rs`, holds
    no surprises for us:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/bin/sniffer.rs` 中定义的 `sniffer` 程序的前置部分对我们来说并没有惊喜：
- en: '[PRE60]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''re importing `Function` and `Lua` from the rlua crate, but that''s about
    all that is new. The `SKIPPED_PACKETS` and `Payload` details are unchanged:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 rlua 库中导入 `Function` 和 `Lua`，但这基本上就是所有新内容。`SKIPPED_PACKETS` 和 `Payload`
    的细节没有改变：
- en: '[PRE61]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'I have removed the echoing of Ethernet packets in this example as it''s not
    necessarily a kind thing to do on a busy Ethernet network. `watch_interface`,
    as a result, is a little more svelte than it used to be:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在这个例子中移除了以太网数据包的回显，因为在繁忙的以太网网络上这样做并不一定是一件好事。因此，`watch_interface` 比以前更加简洁：
- en: '[PRE62]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `timer` function is also unchanged:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer` 函数也没有改变：'
- en: '[PRE63]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `main` function now picks up an additional argument, intended to be the
    on-disk path of a Lua function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数现在接收一个额外的参数，目的是要传递给Lua函数的磁盘路径：'
- en: '[PRE64]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The function is intended to handle the `Payload::Pulse` that comes in from
    the timer thread. The gather function from the previous chapter no longer exists.
    To actually do something with the user-supplied function, we''ll have to create
    a new Lua VM via `rlua::Lua::new()` and then load the function into it, like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数旨在处理从计时器线程传入的`Payload::Pulse`。上一章中的收集函数不再存在。为了实际使用用户提供的函数，我们必须通过`rlua::Lua::new()`创建一个新的Lua虚拟机，然后将函数加载到其中，如下所示：
- en: '[PRE65]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `eval` function is brief and mostly to do with reading from disk:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`函数简短，主要与从磁盘读取有关：'
- en: '[PRE66]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The lua-specific bit there is `lua.eval(s, name)`. This evaluates the Lua code
    read from disk and returns function, a Rust-callable bit of Lua. Any user-supplied
    name in the Lua source itself is ignored and the name exists to add context to
    error messages on the Rust side of things. rlua does not expose loadfile in its
    Rust API, though other Lua embeddings do.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那里的特定于Lua的部分是`lua.eval(s, name)`。它评估从磁盘读取的Lua代码，并返回一个函数，这是一个Rust可调用的Lua片段。Lua源中提供的任何用户名称都被忽略，名称的存在是为了在Rust端添加错误消息的上下文。rlua在其Rust
    API中不公开`loadfile`，尽管其他Lua嵌入确实如此。
- en: 'The next bit of the `main` function is mostly unchanged, though the packet
    buffer channel has been increased from 10 elements to `100`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数的下一部分基本上没有变化，尽管包缓冲通道已从10个元素增加到`100`：'
- en: '[PRE67]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, things are going to change. First, we create three Lua tables for storing
    the components of the `Payload::Packet`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，事情将要发生变化。首先，我们创建三个Lua表格来存储`Payload::Packet`的组件：
- en: '[PRE68]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the previous chapter, we used three `HashMap`s but, now, we need something
    we can easily pass into Lua. The main thread is responsible for the role that
    gather used to play: collecting `Payload` instances. This saves a thread and means
    we don''t have to carefully arrange for sending the Lua VM across thread boundaries:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了三个`HashMap`，但现在，我们需要能够轻松传递给Lua的东西。主线程负责收集`Payload`实例的角色，这是收集函数曾经扮演的角色：收集`Payload`实例。这节省了一个线程，意味着我们不需要仔细安排发送Lua虚拟机跨线程边界：
- en: '[PRE69]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, we''ve started pulling payloads from the receiver and have handled `Payload::Packets`
    coming across. Notice how the tables we created just before this loop are now
    being populated. The same basic aggregation is in play; keep a running tally of
    the `Packet` components coming in. A more adventurous reader might extend this
    program to allow for the Lua side to build its own aggregation. Now all that remains
    is to handle `Payload::Pulse`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经开始从接收器中提取有效载荷，并处理跨过来的`Payload::Packets`。注意我们在这个循环之前创建的表格现在正在被填充。同样的基本聚合操作正在发挥作用；持续计算进入的`Packet`组件。一个更有冒险精神的读者可能会扩展这个程序，允许Lua端构建自己的聚合。现在剩下的只是处理`Payload::Pulse`：
- en: '[PRE70]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `pulse_fn` created earlier is called with a four-tuple of arguments—the
    pulse ID, the `SKIPPED_PACKETS`, and the aggregation tables. We don''t expect
    `pulse_fn` to have any kind of return value, hence the `<_, ()>` bit. This version
    of sniffer includes an example packet function, defined in `examples/pulse.lua`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 之前创建的`pulse_fn`函数使用四个参数调用——脉冲ID、`SKIPPED_PACKETS`和聚合表格。我们预计`pulse_fn`不会有任何返回值，因此有`<_,
    ()>`部分。这个版本的嗅探器包括一个示例包函数，定义在`examples/pulse.lua`中：
- en: '[PRE71]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The reader will note that it does basically the same work as the former gather
    function once did. Running sniffer works the same way as before. Be sure to `cargo
    build --release` and then:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 读者会注意到它基本上与之前收集函数所做的工作相同。运行嗅探器的工作方式与之前相同。确保执行`cargo build --release`然后：
- en: '[PRE72]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The allocation-conscious reader will have noticed there's a lot of cloning going
    on here. That's true. The primary compilation is interop with Lua's GC. A safe
    Rust interface must assume that data passed down to Lua will be garbage-collected.
    But, Lua does support a concept of user data, in which the programmer associates
    opaque blobs with Lua functions to manipulate it. Lua also supports light user
    data, which is very similar to user data except that the light variant is associated
    with a pointer to memory. The UserData type in RLua is quite well done and the
    ambitious reader might do well to build a `PacketAggregation` type that implements
    `UserData` to avoid all the cloning.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意分配的读者会注意到这里有很多克隆操作。这是真的。主要的编译是Lua的GC的互操作性。安全的Rust接口必须假设传递给Lua的数据将被垃圾回收。但是，Lua支持用户数据的概念，程序员将不透明的数据块与Lua函数关联以操作它。Lua还支持轻量级用户数据，它与用户数据非常相似，只是轻量级变体与内存的指针相关联。RLua中的UserData类型做得相当不错，有雄心的读者可以构建一个实现`UserData`的`PacketAggregation`类型，以避免所有克隆操作。
- en: Combining a high-level language into a systems language is often a game of trade-offs
    between memory management complexity, end-user burden, and initial programming
    difficulty. rlua does an excellent job of landing on the safer side of these trade-offs.
    Something like mond, in use in cernan, less so, but with more flexibility in use.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将高级语言与系统语言结合通常是一场在内存管理复杂性、最终用户负担和初始编程难度之间的权衡游戏。rlua在这些权衡中做得非常出色。像mond这样的东西在cernan中使用，在这方面做得不那么好，但使用上更加灵活。
- en: Embedding Rust
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入Rust
- en: So far, we've seen how to embed C and Lua into Rust. But, what if you want to
    combine Rust into other programming languages? Doing so is a very handy technique
    for improving runtime performance in interpreted languages, making memory-safe
    extensions where once you might have been using C or C++. If your target high-level
    language has difficulty with concurrency embedding, Rust is a further win. Python
    programs suffer in this regard—at least those implemented on CPython or PyPy—because
    of the Global Interpreter Lock, an internal mutex that locks objects' bytecode.
    Offloading computation of large blocks of data into a Rust + Rayon extension,
    for example, can be both straightforward to program and improve computation speed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何将C和Lua嵌入Rust。但是，如果你想要将Rust与其他编程语言结合使用呢？这样做是一种非常实用的技术，可以提高解释型语言的运行时性能，实现内存安全的扩展，这在以前你可能需要使用C或C++。如果你的目标高级语言在并发嵌入方面有困难，Rust则是一个更大的优势。Python程序在这方面表现不佳——至少是那些在CPython或PyPy上实现的——因为全局解释器锁（一个内部互斥锁，锁定对象的字节码）。例如，将大量数据的计算任务卸载到Rust
    + Rayon扩展中，既可以简化编程，又可以提高计算速度。
- en: 'Well, great. How do we make this sort of thing happen? Rust''s approach is
    simple: if you can embed C, you can embed Rust.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，太棒了。我们如何实现这类事情呢？Rust的方法很简单：如果你可以嵌入C，你就可以嵌入Rust。
- en: Into C
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入C
- en: Let's embed some Rust into C. The quantiles library ([https://crates.io/crates/quantiles](https://crates.io/crates/quantiles))—discussed
    in [Chapter 4](5a332d94-37e4-4748-8920-1679b07e2880.xhtml), *Sync and Send – the
    Foundation of Rust Concurrency*—implements online summarization algorithms. These
    algorithms are easy to get wrong, in terms of producing incorrect results, but
    more often in storing more points than strictly necessary. A good deal of work
    has gone into quantiles to ensure the algorithms implemented there are near the
    theoretical minimum storage requirements, and so it makes sense to reuse this
    library for online summarization in C, rather than redo all that work.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在C中嵌入一些Rust。quantiles库（[https://crates.io/crates/quantiles](https://crates.io/crates/quantiles)）——在第4章中讨论过，*Sync和Send——Rust并发的基石*——实现了在线汇总算法。这些算法在产生错误结果方面很容易出错，但更常见的是存储比严格必要更多的点。在quantiles中投入了大量工作以确保实现的算法接近理论上的最小存储需求，因此对于C中的在线汇总重用这个库而不是重新做所有这些工作是有意义的。
- en: Specifically, let's expose a `quantiles::ckms::CKMS<f32>` to C ([https://docs.rs/quantiles/0.7.1/quantiles/ckms/struct.CKMS.html](https://docs.rs/quantiles/0.7.1/quantiles/ckms/struct.CKMS.html)).
    We have to make the type concrete as C lacks any manner of generics in its types,
    but that's okay.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，让我们将`quantiles::ckms::CKMS<f32>`暴露给C ([https://docs.rs/quantiles/0.7.1/quantiles/ckms/struct.CKMS.html](https://docs.rs/quantiles/0.7.1/quantiles/ckms/struct.CKMS.html))。由于C在类型中缺乏任何泛型方式，我们必须使类型具体化，但这没关系。
- en: The Rust side
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust方面
- en: 'There are new things in the `Cargo.toml` file that we need to discuss:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`文件中有一些新内容需要讨论：
- en: '[PRE73]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note specifically that we're building the embed_quantiles library with `crate-type
    = ["staticlib"]`. What does that mean? The Rust compiler is capable of making
    many kinds of linkages, and usually they're just implicit. For instance, a binary
    is `crate-type = ["bin"]`. There's a longish list of different link types, which
    I've included in the *Further reading* section. The interested reader is encouraged
    to look through them. What we'd like to produce here is a statically linked library,
    otherwise every C programmer that tries to make use of embed_quantiles is going
    to need Rust's shared libraries installed on their system. Not… not great. A staticlib
    crate will archive all the bits of the Rust standard library needed by the Rust
    code. The archive can then be linked to C as normal.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，我们正在构建`embed_quantiles`库，使用`crate-type = ["staticlib"]`。这意味着什么？Rust编译器能够进行许多种链接，通常它们都是隐式的。例如，二进制文件是`crate-type
    = ["bin"]`。有一个长长的不同链接类型的列表，我已经在*进一步阅读*部分中包含了它们。鼓励感兴趣的读者查阅。我们希望在这里生成一个静态链接库，否则每个试图使用`embed_quantiles`的C程序员都需要在他们的系统上安装Rust的共享库。这……并不理想。一个`staticlib`crate将存档Rust代码需要的Rust标准库的所有部分。然后，这个存档可以像平常一样链接到C。
- en: 'Okay, now, if we''re going to produce a static archive that C can call, we''ve
    got to export Rust functions with a C ABI. Put another way, we''ve got to put
    a C skin on top of Rust. C++ programmers will be familiar with this tactic. The
    sole Rust file in this project is `src/lib.rs` and its preamble is what you might
    expect:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，如果我们打算生成一个C可以调用的静态存档，我们必须导出Rust函数以C ABI。换句话说，我们必须在Rust之上套上一层C的皮肤。C++程序员会熟悉这种策略。这个项目中的唯一一个Rust文件是`src/lib.rs`，其前导部分可能正如你所预期的那样：
- en: '[PRE74]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We''ve pulled in the quantiles library and have imported `CKMS`. No big deal.
    Check this out, though:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经引入了分位数库并导入了`CKMS`。没什么大不了的。不过，看看这个：
- en: '[PRE75]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Hey! There's a bunch of new things. First, `#[no_mangle]`? A static library
    has to export a symbol for the linker to, well, link. These symbols are functions,
    static variables, and so forth. Now, usually Rust is free to fiddle with the names
    that go into a symbol to include information, such as module location or, really,
    whatever else the compiler wants to do. The exact semantics of mangling are undefined,
    as of this writing. If we're going to be calling a function from C, we have to
    have the exact symbol name to refer to. `no_mangle` turns off mangling, leaving
    us with our name as written. It does mean we have to be careful not to cause symbol
    collisions. Similar to importing functions, the `extern C` here means that this
    function should be written out to obey the C ABI. Technically, we could also have
    written this as `extern fn`, leaving the C off as the C ABI is the implicit default.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！有一大堆新东西。首先，`#[no_mangle]`？静态库必须导出一个符号供链接器使用，以便进行链接。这些符号是函数、静态变量等等。通常，Rust可以自由地篡改符号的名称以包含信息，比如模块位置，或者实际上，编译器想要做的任何事情。至于名称篡改的确切语义，截至本文写作时是未定义的。如果我们打算从C调用一个函数，我们必须有确切的符号名称来引用。`no_mangle`关闭了名称篡改，保留了我们书写的名称。这意味着我们必须小心不要造成符号冲突。类似于导入函数，这里的`extern
    C`意味着这个函数应该按照C ABI编写。技术上，我们也可以写成`extern fn`，省略C，因为C ABI是隐式的默认值。
- en: '`alloc_ckms` allocates a new `CKMS`, returning a mutable pointer to it. Interop
    with C requires raw pointers, which, you know, makes sense. We do have to be very
    conscious of memory ownership when embedding Rust—does Rust own the memory, implying
    we need to provide a free function? Or, does the other language own the memory?
    More often than not, it''s easier to keep ownership with Rust, because to free
    memory, the compiler will need to know the type''s size in memory. By passing
    a pointer out, as we''re doing here, we''ve kept C in the dark about the size
    of `CKMS`. All the C side of this project knows is that it has an *opaque struct* to
    deal with. This is a common tactic in C libraries, for good reason. Here''s freeing
    a `CKMS`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`alloc_ckms`分配一个新的`CKMS`，返回对其的可变指针。与C的互操作性需要原始指针，这是有道理的。我们在嵌入Rust时必须非常注意内存所有权——Rust拥有内存，这意味着我们需要提供一个释放函数？或者，其他语言拥有内存？大多数情况下，保持Rust的所有权更容易，因为为了释放内存，编译器需要知道类型的内存大小。通过传递指针出来，就像我们在这里做的那样，我们让C对`CKMS`的大小一无所知。这个项目的C部分只知道它有一个*不透明结构体*要处理。这是C库中常见的策略，有很好的理由。以下是释放`CKMS`的示例：'
- en: '[PRE76]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Notice that in `alloc_ckms`, we''re boxing the `CKMS`—forcing it to the heap—and
    in `free_ckms` we''re building a boxed `CKMS` from its pointer. We discussed boxing
    and freeing memory in the context of raw pointers extensively in [Chapter 3](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml),
    *The Rust Memory Model – Ownership, References and Manipulation*. Inserting a
    value into the `CKMS` is straightforward enough:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`alloc_ckms`中，我们正在装箱`CKMS`——强制将其放入堆中——而在`free_ckms`中，我们正在从其指针构建一个装箱的`CKMS`。我们在[第3章](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml)“Rust内存模型——所有权、引用和操作”的上下文中广泛讨论了装箱和释放内存。将值插入`CKMS`是足够直接的：
- en: '[PRE77]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Querying requires a little explanation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 查询需要一点解释：
- en: '[PRE78]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Signaling error conditions in a C API is tricky. In Rust, we return some kind
    of compound type, such as an `Option`. There's no such thing in C without building
    an error signaling struct for your API. In addition to the error-struct approach
    it's common to either write well-known nonsense into the pointer where the answer
    will be written or return a negative value. C expects to have its answer written
    into a 32-bit float being pointed to by quant, and there's no easy way to write
    nonsense into a numeric value. So, query returns an `i8`; zero on success, negative
    on a failure. A more elaborate API would differentiate failures by returning different
    negative values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在C API中发出错误条件是棘手的。在Rust中，我们返回某种复合类型，例如`Option`。在C中，没有为你的API构建错误信号结构体就没有这样的事情。除了错误结构体方法之外，通常会在写入答案的指针中写入已知的无意义内容，或者返回一个负值。C期望将答案写入由quant指向的32位浮点数中，但没有简单的方法可以将无意义的内容写入数值。因此，查询返回一个`i8`；成功时为零，失败时为负。更复杂的API会通过返回不同的负值来区分失败。
- en: That's it! When you run `cargo build --release`, a static library obeying the
    C ABI will get kicked out into `target/release`. We're ready to link it into a
    C program.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！当你运行`cargo build --release`时，一个遵循C ABI的静态库将被踢出到`target/release`目录。我们现在可以将其链接到一个C程序中。
- en: The C side
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C方面
- en: 'Our C program is `c_src/main.c`. We need a few system headers before we can
    define the `embed_quantiles` interface:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的C程序是`c_src/main.c`。在我们定义`embed_quantiles`接口之前，我们需要一些系统头文件：
- en: '[PRE79]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The only slightly unusual one is `time.h`. We pull that in because we''re going
    to be pushing random floats into the `CKMS` structure. Not cryptographically secure
    randomness, mind. Here''s the C view of the Rust API we just created:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一稍微不寻常的是`time.h`。我们引入它是因为我们将随机浮点数推入`CKMS`结构体。请注意，这不是加密安全的随机数。以下是C对刚刚创建的Rust
    API的视图：
- en: '[PRE80]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Notice the `CKMS` struct . That''s the opaque struct. C is now aware there
    is a structure but it doesn''t know how big it is. That''s okay. Each of our functions
    only operate on a pointer to this structure, which C does know the size of. The
    `main` function is brief:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`CKMS`结构体。这是一个不透明的结构体。C现在知道有一个结构体，但它不知道它有多大。这没关系。我们所有的函数都只对这个结构体的指针进行操作，而C知道这个指针的大小。`main`函数很简单：
- en: '[PRE81]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We allocate a `CKMS`, whose error bound is 0.001, load 1 million random floats
    into the `CKMS`, and then query for the 75th quantile, which should be around
    7,500\. Finally, the function frees the `CKMS` and exits. Short and sweet.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配一个`CKMS`，其误差界限为0.001，将100万个随机浮点数加载到`CKMS`中，然后查询第75百分位数，应该大约是7,500。最后，函数释放`CKMS`并退出。简短而直接。
- en: 'Now, building and linking `libembed_quantiles.a` is fairly easy with a clang
    compiler, and a little fiddly with GCC. I''ve gone ahead and included a Makefile,
    which has been tested on OS X and Linux:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用clang编译器构建和链接`libembed_quantiles.a`相当容易，而使用GCC则稍微麻烦一些。我已经包括了一个Makefile，它已经在OS
    X和Linux上进行了测试：
- en: '[PRE82]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'I don''t have a Windows machine to test with so, uh, when this inevitably doesn''t
    work I really do apologize. Hopefully there''s enough here to figure it out quickly.
    Once you have the Makefile in place, you should be able to run make run and see
    something similar to the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有Windows机器来测试，所以，嗯，当这不可避免地不起作用时，我真的很抱歉。希望这里的信息足够你快速解决问题。一旦你放好了Makefile，你应该能够运行make
    run并看到以下类似的内容：
- en: '[PRE83]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The percentile value will move around some, but it ought to be close to 7,500,
    as it is here.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 百分位数将会有所波动，但应该接近7,500，就像现在这样。
- en: Into Python
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入Python
- en: 'Let''s look at embedding Rust into Python. We''ll write a function to sum up
    the trailing zeros in a cytpes array, built by Python. We can''t link statically
    into Python as the interpreter is already compiled and linked, so we''ll need
    to create a dynamic library. The `Cargo.toml` project reflects this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将 Rust 集成到 Python 中。我们将编写一个函数来计算由 Python 构建的 cytpes 数组中尾随零的数量。由于解释器已经编译并链接，我们无法将
    Rust 静态链接到 Python，因此我们需要创建一个动态库。`Cargo.toml` 项目反映了这一点：
- en: '[PRE84]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The sole Rust file, `src/lib.rs`, has a single function in it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的 Rust 文件，`src/lib.rs`，其中只有一个函数：
- en: '[PRE85]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `tail_zero_count` function takes a pointer to an array of `u16`s and the
    length of that array. It zips through the array, calling `trailing_zeros()` on
    each `u16` and adding the value to a global sum: `zeros`. This global sum is then
    returned. In the top of the project, run `cargo build --release` and you''ll find
    the project''s dynamic library—possibly `libzero_count.dylib`, `libzero_count.dll`,
    or `libzero_count.so`, depending on your host—in `target/release`. So far, so
    good.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail_zero_count` 函数接受一个指向 `u16` 数组的指针以及该数组的长度。它遍历数组，对每个 `u16` 调用 `trailing_zeros()`
    并将值累加到全局变量 `zeros` 中：然后返回这个全局和。在项目的顶部运行 `cargo build --release`，你将在 `target/release`
    目录下找到项目的动态库——可能是 `libzero_count.dylib`、`libzero_count.dll` 或 `libzero_count.so`，具体取决于你的主机。到目前为止，一切顺利。'
- en: 'Calling this function is now up to Python. Here''s a small example, which lives
    at `zero_count.py` in the root of the project:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用此函数由 Python 负责。以下是一个小型示例，位于项目根目录下的 `zero_count.py`：
- en: '[PRE86]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We import the cytpes and random libraries, then load the shared library—here,
    pegged to OS X''s naming convention—and bind it to `lzc`. Do edit this to read
    `[so|dll]` if you''re running this on an operating system other than OS X. Once
    `lzc` is bound, we use the ctypes API to create a random array of `u16` values
    and call `tail_zero_count` on that array. Python is forced to allocate the full
    array before passing it into Rust using this approach, so don''t increase the
    length too much. Running the program is a matter of calling Python''s `zero_count.py`,
    like so:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 cytpes 和随机库，然后加载共享库——在这里，遵循 OS X 的命名约定——并将其绑定到 `lzc`。如果你在除 OS X 以外的操作系统上运行此代码，请编辑此代码以读取
    `[so|dll]`。一旦 `lzc` 被绑定，我们就使用 ctypes API 创建一个随机的 `u16` 值数组，并调用该数组上的 `tail_zero_count`。使用这种方法，Python
    被迫在将数组传递给 Rust 之前分配整个数组，所以不要增加太多长度。运行程序只需调用 Python 的 `zero_count.py`，如下所示：
- en: '[PRE87]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Coping with opaque struct pointers—as we did in the C example—is well-documented
    in the ctypes documentation. Rust will not know the difference; it's just kicking
    out objects conforming to the C ABI.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不透明结构指针——就像我们在 C 示例中所做的那样——在 ctypes 文档中有很好的记录。Rust 将不知道区别；它只是输出符合 C ABI 的对象。
- en: Into Erlang/Elixir
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入 Erlang/Elixir
- en: 'In this last section of the chapter, we''ll investigate embedding Rust into
    the BEAM, the virtual machine that underpins Erlang and Elixir. The BEAM is a
    sophisticated work-stealing scheduler system that happens to be programmable.
    Erlang processes are small C structs that bounce around between scheduler threads
    and carry enough internal information to allow interpretation for a fixed number
    of instructions. There''s no concept of shared memory in Erlang/Elixir: communication
    between different concurrent actors in the system *must* happen via message passing.
    There are many benefits to this and the VM does a great deal of work to avoid
    copying when possible. Erlang/Elixir processes receive messages into a message
    queue, a double-ended threadsafe queue of the kind we''ve discussed throughout
    the book.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将研究将 Rust 集成到 BEAM 中，这是支撑 Erlang 和 Elixir 的虚拟机。BEAM 是一个复杂的工作窃取调度系统，碰巧是可编程的。Erlang
    进程是小的 C 结构体，在调度线程之间弹跳，并携带足够的信息，允许对固定数量的指令进行解释。在 Erlang/Elixir 中没有共享内存的概念：系统中的不同并发演员之间的通信*必须*通过消息传递来实现。这样做有许多好处，并且虚拟机在可能的情况下会做大量工作以避免复制。Erlang/Elixir
    进程将消息接收到一个消息队列中，这是一个双端线程安全的队列，我们在整本书中讨论过。
- en: Erlang and Elixir are rightly known for their efficiency at handling high-scale
    IO in a real-time fashion. Erlang was invented at Ericsson to serve as telephony
    control software, after all. What these languages are not known for is serial
    performance. Sequential computations in Erlang are relatively slow, it's just
    that it's so *easy* to get concurrent computations going that this is sort of
    made up for. Sort of. Sometimes, you need raw, serial performance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Erlang和Elixir因其高效处理实时高规模IO而闻名。毕竟，Erlang是在爱立信发明的，作为电话控制软件。这些语言不为人所知的是串行性能。Erlang中的顺序计算相对较慢，只是因为它很容易启动并发计算，这某种程度上弥补了这一点。某种程度上。有时，你需要原始的串行性能。
- en: 'Erlang has a few answers for this. A *Port* opens up an external OS process
    with a bidirectional byte stream. We saw an approach much like this in the previous
    chapter with feruscore embedding pmars. A *Port Driver* is a linked shared object,
    often written in C. The Port Driver interface has facilities for giving interrupt
    hints to BEAM''s schedulers and has much to recommend it. A Port Driver *is* a
    process and must be able to handle the things an Erlang process normally does:
    servicing its message queue, dealing with special interrupt signals, cooperatively
    scheduling itself, and so on. These are non-trivial to write. Finally, Erlang
    supports a Natively Implemented Function (NIF) concept. These are simpler than
    Port Drivers and are synchronous, being simply callable functions that happen
    to be written in a language other than Erlang. NIFs are shared libraries and are
    often implemented in C. Both Port Drivers and NIFs have a serious downside: memory
    issues will corrupt the BEAM and knock your application offline. Erlang systems
    tend to be deployed where fault-tolerance is a major factor and segfaulting the
    VM is a big no-no.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Erlang对此有几个解决方案。一个*端口*通过双向字节流打开一个外部操作系统进程。我们在上一章中看到了一个类似的方法，即feruscore嵌入pmars。一个*端口驱动程序*是一个链接的共享对象，通常用C编写。端口驱动程序接口提供了向BEAM的调度器提供中断提示的功能，并且有很多优点。端口驱动程序*是一个进程，必须能够处理Erlang进程通常需要处理的事情：服务其消息队列，处理特殊的中断信号，协作地调度自己，等等。这些都是非平凡的编写。最后，Erlang支持原生实现函数（NIF）的概念。这些比端口驱动程序简单，并且是同步的，它们是简单地可调用的函数，碰巧是用除Erlang以外的语言编写的。NIF是共享库，通常用C实现。端口驱动程序和NIF都有一个严重的缺点：内存问题会破坏BEAM并使你的应用程序离线。Erlang系统通常部署在容错是一个重要因素的地方，而破坏虚拟机是一个大忌。
- en: As a result, there's a good deal of interest in the Erlang/Elixir communities
    towards Rust. The Rustler project ([https://crates.io/crates/rustler](https://crates.io/crates/rustler))
    aims to make combining Rust into an Elixir project as NIFs a simple matter. Let's
    take a look at a brief example project, presented by Sonny Scroggin at Code BEAM
    2018 in San Francisco—beamcoin ([https://github.com/blt/beamcoin](https://github.com/blt/beamcoin)).
    We'll discuss the project at SHA `3f510076990588c51e4feb1df990ce54ff921a06`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Erlang/Elixir社区对Rust有很大的兴趣。Rustler项目（[https://crates.io/crates/rustler](https://crates.io/crates/rustler)）旨在使将Rust结合到Elixir项目中作为NIF变得简单。让我们看看一个简短的示例项目，由Sonny
    Scroggin在2018年旧金山的Code BEAM上展示——beamcoin（[https://github.com/blt/beamcoin](https://github.com/blt/beamcoin)）。我们将在SHA
    `3f510076990588c51e4feb1df990ce54ff921a06`处讨论该项目。
- en: The beamcoin project is not listed in its entirety. We've mostly dropped the
    build configuration. You can find the full listing in this book's source repository.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: beamcoin项目并未全部列出。我们主要删除了构建配置。你可以在本书的源代码库中找到完整的列表。
- en: 'The build system for Elixir—the BEAM language that Rustler targets natively—is
    called Mix. Its configuration file is `mix.exs` at the root of the project:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Elixir的构建系统——Rustler原生目标语言的BEAM语言——被称为Mix。其配置文件位于项目的根目录下的`mix.exs`：
- en: '[PRE88]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'There''s a fair bit here that we won''t get into. Note, however, this section:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多我们不会涉及的内容。然而，请注意这个部分：
- en: '[PRE89]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Embedded in the project under `native/beamcoin` is the Rust library we''ll
    be exploring. Its cargo configuration, at `native/beamcoin/Cargo.toml`, is:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在`native/beamcoin`目录下嵌入的项目中，是我们将要探索的Rust库。其cargo配置文件位于`native/beamcoin/Cargo.toml`：
- en: '[PRE90]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Nothing too surprising here. A dynamic library, called libbeamcoin, will be
    produced when Rust compiles this and we've seen almost all the dependencies before.
    rustler and `rustler_codegen` are the interface and compiler generators for Rustler,
    respectively. `rustler_codegen` removes a lot of boilerplate C extern work we
    might otherwise have to do. sha2 is a crate from the RustCrypto project that,
    well, implements the sha2 hashing algorithm. Beamcoin is kind of a joke project.
    The idea is to distribute numbers between threads and count the zeros at the back
    of the sha2-256 hash, mining those with a pre-set number of zeros. This would
    be a *very* slow thing to do in Erlang but, as we'll see, is a relatively fast
    computation in Rust. The scoped-pool crate is a threadpooling library that is
    Sendable, meaning it can be placed in a `lazy_static!`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么太令人惊讶的。当 Rust 编译这个动态库（libbeamcoin）时，我们已经看到了几乎所有的依赖项。`rustler` 和 `rustler_codegen`
    分别是 Rustler 的接口和编译器生成器。`rustler_codegen` 去除了我们可能需要做的很多样板 C 外部工作。`sha2` 是来自 RustCrypto
    项目的 crate，它实现了 sha2 哈希算法。Beamcoin 是一个有点玩笑性质的项目。其想法是在线程之间分配数字，并计算 sha2-256 哈希的后面的零位数，用预设的零位数进行挖掘。在
    Erlang 中做这件事会非常慢，但正如我们将看到的，在 Rust 中这是一个相对快速的运算。`scoped-pool` crate 是一个线程池库，它是可发送的，这意味着它可以放在
    `lazy_static!` 中。
- en: 'The preamble for `src/lib.rs` is straightforward enough:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/lib.rs` 的前言足够简单：'
- en: '[PRE91]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We''ve seen much of this before. The Rustler imports are analogs of the Erlang
    C NIF API. The difficulty of mining is controlled by a top-level usize, called
    `DIFFICULTY`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到了很多这样的内容。Rustler 的导入是 Erlang C NIF API 的类似物。挖掘的难度由一个顶级 `usize` 控制，称为
    `DIFFICULTY`：
- en: '[PRE92]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This value controls the total number of zeros that are required to be found
    at the back of a hash before it is declared minable. Here''s our thread pool:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值控制了在声明可挖掘之前，需要在哈希的后面找到的总零位数。这是我们的线程池：
- en: '[PRE93]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'I mentioned earlier that the BEAM maintains its own scheduler threads. This
    is true. The beamcoin NIF also maintains its own, separate pool of threads to
    distribute mining over. Now, Rustler reduces boilerplate but cannot totally remove
    it. We must, for instance, tell BEAM which interpreted functions to associate
    with that symbol and pre-define *atoms* for use:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，BEAM 维护自己的调度线程。这是真的。beamcoin NIF 也维护了自己的线程池，以分配挖掘任务。现在，Rustler 减少了样板代码，但无法完全去除。例如，我们必须告诉
    BEAM 与哪个符号关联的解析函数，并预先定义 *原子* 以供使用：
- en: '[PRE94]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'An Erlang atom is a named constant. These are extremely common data types in
    Erlang/Elixir programs. The threads in the pool are each given a chunk of the
    positive integers to search, stripped according to their thread number. The pool
    workers use an MPSC channel to communicate back to the mining thread that a result
    has been found:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Erlang 原子是一个命名常量。这些是在 Erlang/Elixir 程序中极其常见的数据类型。池中的每个线程都会被分配到一段正整数以供搜索，根据它们的线程号进行剥离。池中的工作者使用
    MPSC 通道与挖掘线程通信，告知已找到结果：
- en: '[PRE95]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `search_for_solution` function is a small loop:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`search_for_solution` 函数是一个小循环：'
- en: '[PRE96]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'At the top of the loop, every thread in the pool checks to see whether any
    other thread has mined a beamcoin. If one has, the function exits and the thread
    is available for new work in the pool. Otherwise, `verify_number` is called. That
    function is:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的顶部，池中的每个线程都会检查是否有其他线程挖掘了 beamcoin。如果有，函数退出，线程在池中可用于新的工作。否则，调用 `verify_number`
    函数。该函数是：
- en: '[PRE97]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The number is passed in, transmuted into a byte array of 8 members, and hashed.
    If the hash has the appropriate number of trailing zero bytes, jackpot is true
    at the end of the function, and the number plus its hash are returned. The careful
    reader will have noted that the Rust module exports a NIF named `native_mine`.
    Erlang NIFs, generally speaking, have a system language component with a BEAM-native
    implementation as a fallback. The system language NIF implementation is called
    `native_*` by tradition.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 数字被传递进来，转换成一个包含 8 个成员的字节数组，并进行哈希。如果哈希具有适当数量的尾随零字节，函数结束时 jackpot 为真，并返回数字及其哈希。仔细的读者会注意到，Rust
    模块导出了一个名为 `native_mine` 的 NIF。一般来说，Erlang NIF 有一个系统语言组件，作为后备有一个 BEAM 原生实现。系统语言
    NIF 实现传统上被称为 `native_*`。
- en: 'The final piece here is the Elixir module to wrap the native NIF bits. This
    module is called `Beamcoin` and is `lib/beamcoin.ex`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是包装原生 NIF 位点的 Elixir 模块。这个模块被称为 `Beamcoin`，位于 `lib/beamcoin.ex`：
- en: '[PRE98]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'After installing Elixir ([https://elixir-lang.org/install.html](https://elixir-lang.org/install.html)),
    you can move to the root of the project, execute `mix deps.get` to get the project''s
    dependencies, and then use `MIX_ENV=prod iex -S mix` to bring up the Elixir repl.
    That latter command should look something like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 Elixir ([https://elixir-lang.org/install.html](https://elixir-lang.org/install.html))
    后，您可以移动到项目的根目录，执行 `mix deps.get` 以获取项目的依赖项，然后使用 `MIX_ENV=prod iex -S mix` 来启动
    Elixir repl。后者命令看起来可能像这样：
- en: '[PRE99]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'At the prompt, type `Beamcoin.mine` and hit *Enter*. After a few seconds, you
    should see:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符下，输入 `Beamcoin.mine` 并按 *Enter*。几秒钟后，您应该会看到：
- en: '[PRE100]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Or, something like it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，类似的东西。
- en: Building NIFs in the BEAM is a complicated topic, one we've hardly touched on
    here. Sonny Scroggin's talk, included in the *Further reading* section, covers
    that nuance in detail. If you're curious about how the BEAM functions, I've included
    a talk of mine on that subject in the *Further reading* section as well. Decades
    of careful effort have gone into the BEAM and it really shows.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BEAM 中构建 NIFs 是一个复杂的话题，我们在这里几乎没有涉及。Sonny Scroggin 的演讲，包含在 *进一步阅读* 部分，详细介绍了这个细微差别。如果您对
    BEAM 的工作原理感兴趣，我在 *进一步阅读* 部分也包含了我关于这个主题的演讲。数十年的精心努力都投入到了 BEAM 中，这确实有所体现。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed embedding languages in Rust and vice versa. Rust
    is an incredibly useful programming language in its own right, but has been designed
    with care to interoperate with the existing language ecosystem. Delegating difficult
    concurrency work in a memory-unsafe environment into Rust is a powerful model.
    Mozilla's work on Firefox has shown that path to be fruitful. Likewise, there
    are decades' worth of well-tested libraries niche domains—weather modeling, physics,
    amusing programming games from the 1980s—that could, theoretically, be rewritten
    in Rust but are probably better incorporated behind safe interfaces.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在 Rust 中嵌入语言以及反之亦然。Rust 是一种非常有用的编程语言，它本身就是一个强大的工具，但经过精心设计，可以与现有的语言生态系统互操作。将困难的并发工作委托给
    Rust 在一个内存不安全的环境中是一个强大的模型。Mozilla 在 Firefox 上的工作已经证明了这条道路是富有成效的。同样，有数十年的经过良好测试的库和特定领域——天气建模、物理学、20
    世纪 80 年代的有趣编程游戏——理论上可以用 Rust 重新编写，但可能更好地通过安全接口来整合。
- en: This chapter is the last that aims to teach you a new, broad skill. If you've
    made it this far in the book, thank you. It's been a real pleasure writing for
    you. You should, hopefully, now have a solid foundation for doing low-level concurrency
    in Rust and the confidence to read through most Rust codebases you come across.
    There's a lot going on in Rust and I hope it seems more familiar now. In the next,
    and last, chapter of the book, we'll discuss the future of Rust, what language
    features apropos this book are coming soon, and how they might bring new capabilities
    to us.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是最后一章，旨在教会您一项新的、广泛的技能。如果您已经读到这本书的这一部分，感谢您。为您写作是一段真正的乐趣。希望您现在对在 Rust 中进行底层并发有了坚实的基础，并且有信心阅读您遇到的绝大多数
    Rust 代码库。Rust 中有很多内容，希望现在看起来更熟悉了。在本书的下一章，也是最后一章中，我们将讨论 Rust 的未来，哪些语言特性与本书相关即将到来，以及它们如何为我们带来新的能力。
- en: Further reading
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*FFI examples written in Rust*, available at [https://github.com/alexcrichton/rust-ffi-examples](https://github.com/alexcrichton/rust-ffi-examples).
    This repository by Alex Crichton is a well-done collection of FFI examples in
    Rust. The documentation in this book on this topic is quite good, but it never
    hurts to pour through working code.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rust 编写的 FFI 示例*，可在 [https://github.com/alexcrichton/rust-ffi-examples](https://github.com/alexcrichton/rust-ffi-examples)
    找到。Alex Crichton 的这个仓库是一个 Rust 中 FFI 示例的良好集合。这本书中关于这个主题的文档相当不错，但仔细阅读工作代码总不会有害。'
- en: '*Hacker''s Delight*, Henry Warren Jr. If you enjoyed the bit fiddling present
    in this chapter''s take on feruscore, you''ll love Hacker''s Delight. It''s old
    now and some of its algorithms no longer function on 64-bit words, but it''s still
    well worth reading, especially if you, like me, work to keep fixed-width types
    as small as possible.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《黑客的乐趣》*，亨利·沃伦（小）。如果您喜欢本章对 feruscore 的处理中包含的位操作，您会喜欢《黑客的乐趣》。这本书现在已经过时了，其中一些算法在
    64 位字上不再工作，但它仍然值得一读，尤其是如果您像我一样，努力将固定宽度类型保持得尽可能小。'
- en: '*Foreign Function Interface*, available at [https://doc.rust-lang.org/nomicon/ffi.html](https://doc.rust-lang.org/nomicon/ffi.html).
    The Nomicon builds a higher-level wrapper for the compression library snappy.
    This wrapper is extended in ways we did not touch on here, specifically with regard
    to C callbacks and vardic function calls.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*外部函数接口*，可在[https://doc.rust-lang.org/nomicon/ffi.html](https://doc.rust-lang.org/nomicon/ffi.html)找到。Nomicon
    为压缩库 snappy 构建了一个高级包装器。这个包装器在以下方面进行了扩展，具体来说是与 C 回调和 vardic 函数调用相关。'
- en: '*Global Interpreter Lock*, available at [https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock). The
    GIL has long been the bane of multiprocessing software written in Python. This
    wiki entry discusses the technical details mandating the GIL and the historical
    attempts to remedy the situation.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全局解释器锁*，可在[https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock)找到。GIL
    长期以来一直是用 Python 编写的多进程软件的痛处。这篇维基百科条目讨论了强制执行 GIL 的技术细节以及历史上试图解决这个问题所做的尝试。'
- en: '*Guided Tour*, available at [https://github.com/chucklefish/rlua/blob/master/examples/guided_tour.rs](https://github.com/chucklefish/rlua/blob/master/examples/guided_tour.rs). The
    rlua crate includes a guided tour module, which is well-documented and runnable.
    I haven''t seen this approach to documentation in other projects and I warmly
    encourage you to check it out. First, it''s helpful for learning rlua. Second,
    it''s well-written and empathetic to the reader: a fine example of technical writing.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rust 之旅*，可在[https://github.com/chucklefish/rlua/blob/master/examples/guided_tour.rs](https://github.com/chucklefish/rlua/blob/master/examples/guided_tour.rs)找到。rlua
    crate 包含一个导游模块，该模块有很好的文档和可运行性。我在其他项目中没有看到过这种文档方法，我强烈建议你检查一下。首先，它对学习 rlua 很有帮助。其次，它写得很好，对读者有同情心：这是技术写作的一个很好的例子。'
- en: '*Linkage*, available at [https://doc.rust-lang.org/reference/linkage.html](https://doc.rust-lang.org/reference/linkage.html).
    This is the Rust Reference chapter on linking. The details here are very specific,
    but that''s often necessary when being explicit about linking. The common reader
    will more or less use the information we''ve covered in this chapter but there''s
    always some new domain requiring specific knowledge.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链接*，可在[https://doc.rust-lang.org/reference/linkage.html](https://doc.rust-lang.org/reference/linkage.html)找到。这是
    Rust 参考手册中的链接章节。这里的细节非常具体，但在明确链接时通常有必要。普通读者可能会或多或少地使用我们在这章中涵盖的信息，但总有一些新的领域需要特定的知识。'
- en: '*Rust Inside Other Languages*, available at [https://doc.rust-lang.org/1.2.0/book/rust-inside-other-languages.html](https://doc.rust-lang.org/1.2.0/book/rust-inside-other-languages.html).
    This chapter in the Rust Book covers similar ground to this chapter—embedding
    Rust—but at a faster clip and with different high-level languages. Specifically,
    The Book covers embedding Rust into both Ruby and NodeJS, which we did not.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rust 在其他语言中*，可在[https://doc.rust-lang.org/1.2.0/book/rust-inside-other-languages.html](https://doc.rust-lang.org/1.2.0/book/rust-inside-other-languages.html)找到。这本书的这一章与本章类似——嵌入
    Rust，但速度更快，并且使用了不同的高级语言。具体来说，本书涵盖了将 Rust 嵌入 Ruby 和 NodeJS，而我们没有涉及。'
- en: '*FFI in Rust - writing bindings for libcpuid*, available at [http://siciarz.net/ffi-rust-writing-bindings-libcpuid/](http://siciarz.net/ffi-rust-writing-bindings-libcpuid/).
    Zbigniew Siciarz has been writing about Rust and writing in Rust for a good while.
    You may know him from his *24 days of Rust* series. In this post, Sicarz documents
    the process of building a safe wrapper for libcpuid, a library whose job is to
    poll the OS for information about the user''s CPU.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rust 中的 FFI - 为 libcpuid 编写绑定*，可在[http://siciarz.net/ffi-rust-writing-bindings-libcpuid/](http://siciarz.net/ffi-rust-writing-bindings-libcpuid/)找到。Zbigniew
    Siciarz 已经撰写了关于 Rust 的文章，并用 Rust 进行写作有一段时间了。你可能知道他的 *24 天 Rust* 系列。在这篇文章中，Sicarz
    记录了为 libcpuid 构建安全包装器的过程，该库的职责是轮询操作系统以获取有关用户 CPU 的信息。'
- en: '*Taking Elixir to the Metal with Rust*, Sonny Scroggin, available at [https://www.youtube.com/watch?v=lSLTwWqTbKQ](https://www.youtube.com/watch?v=lSLTwWqTbKQ).
    In this chapter we demonstrated Beamcoin, a combination of Elixir and Rust in
    the same project. Integrating NIFs into a BEAM system is a complicated subject.
    This talk, presented at NDC London 2017, is warmly recommended as an introduction
    to the subject.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用 Rust 将 Elixir 带到金属上*，Sonny Scroggin，可在[https://www.youtube.com/watch?v=lSLTwWqTbKQ](https://www.youtube.com/watch?v=lSLTwWqTbKQ)找到。在这一章中，我们展示了
    Beamcoin，这是在同一项目中结合了 Elixir 和 Rust。将 NIFs 集成到 BEAM 系统是一个复杂的话题。这个在 2017 年 NDC London
    上发表的演讲强烈推荐作为该主题的介绍。'
- en: '*Piecemeal Into Space: Reliability, Safety and Erlang Principles*, Brian L.
    Troutwine, available at [https://www.youtube.com/watch?v=pwoaJvrJE_U](https://www.youtube.com/watch?v=pwoaJvrJE_U).
    There''s a great deal of work that''s gone into the BEAM over the decades, earning
    those languages a key place in fault-tolerant software deployments. Exactly how
    the BEAM functions is something of a mystery without inspection. In this talk,
    I cover the BEAM''s semantic model and then discuss it''s implementation at a
    high-level.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*零散拼凑至太空：可靠性、安全性与Erlang原则*，作者：Brian L. Troutwine，可在[https://www.youtube.com/watch?v=pwoaJvrJE_U](https://www.youtube.com/watch?v=pwoaJvrJE_U)找到。几十年来，在BEAM上投入了大量的工作，使得这些语言在容错软件部署中占据了关键位置。没有检查的情况下，BEAM是如何工作的，这本身就是一个谜。在这场演讲中，我介绍了BEAM的语义模型，然后从高层次上讨论了它的实现。'
