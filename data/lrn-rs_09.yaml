- en: Introducing Generics, Impl, and Traits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍泛型、实现和特性
- en: One of the key benefits of any modern language is the ability to be able to
    use a type which can be anything. Not only does this reduce the amount of code
    required, but it allows for greater flexibility in code creation. Rust not only
    allows for generic types and functions, but introduces traits; these can be considered
    as a logical extension of generics, as they tell the compiler the functionality
    the type must provide.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现代语言的关键优势之一是能够使用任何类型的类型。这不仅减少了所需的代码量，而且允许在代码创建中具有更大的灵活性。Rust 不仅允许使用泛型类型和函数，还引入了特性；这些可以被视为泛型的逻辑扩展，因为它们告诉编译器类型必须提供的功能。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Generics in Rust
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 中的泛型
- en: Impl and traits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和特性
- en: Generic types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Trait objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性对象
- en: Generics 101
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型 101
- en: For those coming from the likes of C++ and C#, generics will be nothing new
    to you. It is typically represented as `T`. It is used in the same way as a standard
    type. As `T` doesn't actually have a type, it's known a **polymorphic parameter**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自 C++ 和 C# 等语言的开发者来说，泛型将不会是陌生的。它通常表示为 `T`。它以与标准类型相同的方式使用。由于 `T` 实际上没有类型，它被称为**多态参数**。
- en: There's a simple rule regarding generic types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关于泛型类型有一个简单的规则。
- en: The types have to match—if we define `T` as being `f64` and attempt to assign
    a `String` to it, the compiler will fail to build that code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类型必须匹配——如果我们定义 `T` 为 `f64` 并尝试将其分配给一个 `String`，编译器将无法构建该代码。
- en: While `T` is also (probably) the most commonly used letter for a generic type,
    in reality you can have any letter, or even words.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `T` 也可能是最常用的通用类型字母，但实际上你可以使用任何字母，甚至单词。
- en: 'For example, this is perfectly acceptable code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码是完全可以接受的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Y` and `N` do not need to be the same type either; therefore, `Y` could be
    a `String` and `N` a `bool`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Y` 和 `N` 不需要是相同的类型；因此，`Y` 可以是一个 `String`，而 `N` 是一个 `bool`。'
- en: 'In practice, the following shows how the generic type works. `Option` is provided
    as part of the standard library:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，以下展示了泛型类型的工作方式。`Option` 是标准库的一部分：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Generics also provide another useful facility: they allow for the production
    of generic functions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型还提供了另一个有用的功能：它们允许生成泛型函数。
- en: 'Generic functions—the functions that you can throw anything at! A standard
    function may look like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数——你可以向其投掷任何东西的函数！一个标准函数可能看起来像这样：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The example code for this section can be found in `09/multiply_generic_return_t`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在 `09/multiply_generic_return_t` 中找到。
- en: The parameter being passed in is an `i32` and is called `x`. If we attempt to
    pass in a float, bool, string, or any other type that is not an `i32`, the compiler
    will fail the build as the types don't match.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正在被传递的参数是一个 `i32` 类型，并被称为 `x`。如果我们尝试传递一个浮点数、布尔值、字符串或任何其他不是 `i32` 类型的类型，编译器将因为类型不匹配而失败构建。
- en: 'The generic function looks very similar:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数看起来非常相似：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In style, this is very similar to how a generic method is written in C#:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在风格上，这与在 C# 中编写泛型方法非常相似：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This can be extended to take multiple parameters with the same type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以扩展为接受具有相同类型的多个参数：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or with multiple types and parameters:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用多种类型和参数：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we can use a generic as a return type. Recall that a standard function
    returns a value like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将泛型用作返回类型。回想一下，标准函数返回一个值如下：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The generic return would be as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通用返回值将是以下这样：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will only work for simplesome types; you cannot multiply string types,
    though you can concatenate them—this means you add one string to another. The
    problem though is we cannot do this... yet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这只适用于简单的类型；你不能乘以字符串类型，尽管你可以连接它们——这意味着你将一个字符串添加到另一个字符串上。但问题是，我们目前还不能这样做...
- en: 'When we attempt to build this, an error is generated:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试构建这个时，会生成一个错误：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's see if we can break this down a bit to see why we're getting the error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能否将其分解一下，看看为什么我们会得到错误。
- en: Understanding the error
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解错误
- en: We know that both `a` and `b` are of type `T`, but what is the *real* type of
    `a`?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `a` 和 `b` 都是 `T` 类型，但 `a` 的“真实”类型是什么？
- en: Here, `a` needs to be any type that implements `std::ops::Mul`—that is, the
    `*` operator. Moreover, the output of this function needs to be explicitly filled
    in also.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a` 需要是任何实现了 `std::ops::Mul` 的类型——也就是说，`*` 操作符。此外，这个函数的输出也需要明确指定。
- en: When you see something akin to `std::ops::Mul`, it is just saying we're going
    to use the equivalent of `namespace std.ops` (if we are using C#). It's just the
    library in use.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到类似 `std::ops::Mul` 的东西时，它只是说我们将使用 `namespace std.ops` 的等效物（如果我们使用 C#）。这只是正在使用的库。
- en: 'Let''s alter the type to tell the compiler that `T` needs to implement `Mul`
    and that we are going yield a result of type `T`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变类型，告诉编译器 `T` 需要实现 `Mul`，并且我们将产生一个类型为 `T` 的结果：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'All `<T: Mul<Output = T>>` means is that we''re going to use `Mul` and that
    the output is going to be of type `T`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`<T: Mul<Output = T>>` 实际上意味着我们将使用 `Mul`，并且输出将是类型 `T`。'
- en: 'This time, we can build and the code works fine, as shown in the following
    screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们可以构建代码，并且代码运行正常，如下面的截图所示：
- en: '![](img/00064.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.jpeg)'
- en: 'Pretty handy! By the way, there''s another way to declare this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 非常方便！顺便说一下，还有另一种声明它的方法：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Whichever is neater is up to the programmer, so you may see and use both styles.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 哪一种更整洁取决于程序员，因此你可能会看到并使用这两种风格。
- en: 'The question is: What happens if we do something like send in a string? Thankfully,
    in this form, the compiler throws an error and won''t allow the code to build:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：如果我们发送一个字符串会发生什么？幸运的是，在这个形式中，编译器会抛出一个错误，并且不允许代码构建：
- en: '![](img/00065.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: A generic problem
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个泛型问题
- en: An aspect of generics is the determination of what `T` is and therefore how
    we can handle it. In C#, we can use `System.Reflection` and use the `GetType`
    method to find the type or use `typeof` when comparing types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的一个方面是确定 `T` 是什么，因此我们可以如何处理它。在 C# 中，我们可以使用 `System.Reflection` 并使用 `GetType`
    方法来查找类型，或者在使用类型比较时使用 `typeof`。
- en: The source code for this part can be found in `09/generic_typeof`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分的源代码可以在 `09/generic_typeof` 中找到。
- en: 'In Rust, we use `std::any:Any`. This is a type to emulate dynamic typing:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，我们使用 `std::any:Any`。这是一个用于模拟动态类型的数据类型：
- en: '![](img/00066.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.jpeg)'
- en: 'Just by looking at this output, you may be thinking: *What on earth are those
    numbers? I expected something like f32*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 只看这个输出，你可能在想：*这些数字究竟是什么？我期望看到类似 f32* 的东西*。
- en: The associated code for this part can be found in `09/generic_typeof_print`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分的关联代码可以在 `09/generic_typeof_print` 中找到。
- en: 'What we''re seeing here is the *ID* for the type rather than the type. To actually
    show the variable type, we have do something slightly different:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是类型的 *ID* 而不是类型本身。要实际显示变量类型，我们需要做一些稍微不同的事情：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At the time of writing, this code will only build on the nightly branch. Chances
    are that by the time you read this book, it will be in the stable branch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，此代码仅能在夜间分支上构建。很可能在你阅读这本书的时候，它已经进入了稳定分支。
- en: 'When the preceding code is run on the Rust Playground website, the following
    results are obtained:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码在 Rust Playground 网站上运行时，会得到以下结果：
- en: '![](img/00067.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.jpeg)'
- en: While most of the code we have seen many times, we have not yet come across
    `unsafe` and the shebang (`#!`) in the code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经多次看到大部分代码，但我们还没有在代码中遇到 `unsafe` 和 shebang (`#!`)。
- en: The unsafe directive
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全指令
- en: We have seen many times so far the lengths to which the Rust compiler will go
    to ensure the code you have written will not only compile, but is also not going
    to do something stupid (such as exceed the bounds of an array, use the wrong type,
    or plain use a variable that has not been given a value first).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次看到，Rust 编译器会尽力确保你编写的代码不仅能够编译，而且不会做愚蠢的事情（例如超出数组的界限，使用错误的数据类型，或者使用未先赋予值的变量）。
- en: This is known as *safe* code. That's not to say that all safe code is good code—you
    can still end up with memory leaks, integer overflows, or threading deadlocks
    which you don't want, but aren't actually defined as unsafe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 *安全* 代码。这并不是说所有安全代码都是好代码——你仍然可能遇到内存泄漏、整数溢出或线程死锁，这些都是你不想要的，但实际上并没有定义为不安全的。
- en: In Rust, `unsafe` surrounding code means exactly that—you're telling the compiler
    that you know what you're writing is to be ignored by the inbuilt protection.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，`unsafe` 包围的代码确实意味着——你正在告诉编译器你写的代码将被内置保护忽略。
- en: Using `unsafe` should only be done with care. We will come across `unsafe` later.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `unsafe` 应该非常小心。我们稍后会遇到 `unsafe`。
- en: 'The whole #!'
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '整个 #!'
- en: For those used to Linux shell scripting, you will have certainly seen `#!`—in
    Rust, the `#` is a declaration with the name in `[]` an attribute. They can be
    written as either `#[attr]` or `#![attr]`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些习惯于 Linux Shell 脚本编写的人来说，你肯定见过 `#!`——在 Rust 中，`#` 是一个带有名称在 `[]` 中的声明属性。它们可以写成
    `#[attr]` 或 `#![attr]`。
- en: However, the meaning of `#[attr]` and `#![attr]` is different. `#[attr]` only
    applies directly to what comes after it. The `#!` changes what the attribute is
    applied to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`#[attr]` 和 `#![attr]` 的意义是不同的。`#[attr]` 仅直接应用于其后的内容。`#!` 改变了属性应用的对象。
- en: 'We have seen this back in Chapter 2, *Variables and Variable Types*, when we
    discussed writing tests. We would have something like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章，*变量和变量类型* 中看到过这个，当时我们讨论了编写测试。我们会有类似这样的内容：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `do_check` function will only be run when we're running the tests.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `do_check` 函数只有在运行测试时才会执行。
- en: Traits and Impl
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性和实现
- en: A very powerful feature of Rust that is commonly seen when dealing with generics
    is that it is possible to tell the compiler that a particular type will provide
    certain functionality. This is provided by a special feature known as a `trait`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中一个非常强大的特性，当处理泛型时通常可以看到，是能够告诉编译器特定类型将提供某些功能。这是通过一个称为 `trait` 的特殊功能提供的。
- en: However, to appreciate traits, we first have to look at the `impl` keyword (short
    for implement).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要欣赏特性，我们首先必须看看 `impl` 关键字（简称实现）。
- en: Impl
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'The `impl` keyword works in a very similar way to a function. The structure
    of an implementation needs to considered as being closer to a static class (in
    C#) or as a function within a function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`impl` 关键字的工作方式与函数非常相似。实现的结构需要被视为更接近静态类（在 C# 中）或函数中的函数：'
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This would be more for a non-generic type. For generics, the preceding code
    becomes the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更多适用于非泛型类型。对于泛型，前面的代码变为以下内容：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the `<T>` is required to tell the compiler that the `impl` is for
    a generic. `reference_name` is the name used to access the `impl` function. It
    can be anything you wish.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `<T>` 是必需的，以便告诉编译器 `impl` 是针对泛型的。`reference_name` 是用于访问 `impl` 函数的名称。它可以是你想要的任何名称。
- en: An example of `impl` can be found in `09/impl_example`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`impl` 的一个例子可以在 `09/impl_example` 中找到。'
- en: 'If you build and run the `impl_example` code, you will get a result like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建并运行 `impl_example` 代码，你将得到如下结果：
- en: '![](img/00068.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: The code creates two implementations for two functions that provide a defined
    functionality.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了两个函数的实现，这两个函数提供了定义的功能。
- en: The `impl_example` is a very simple example. An `impl` can be as complex as
    required.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`impl_example` 是一个非常简单的例子。`impl` 可以根据需要变得非常复杂。'
- en: The impl lifetime
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 lifetime
- en: 'As mentioned in Chapter 8, *The Rust Application Lifetime*, we can use a lifetime
    with an `impl`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 8 章，*Rust 应用程序生命周期* 中所述，我们可以使用 lifetime 与 `impl` 一起使用：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`''a` is denoted directly after both the `impl` and `MyFunction`. For the `impl`,
    it''s to say we''re using it, while after `MyFunction`, it''s to say we''re using
    it within `MyFunction`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`''a` 直接跟在 `impl` 和 `MyFunction` 之后。对于 `impl`，这是表示我们正在使用它，而在 `MyFunction` 之后，这是表示我们在
    `MyFunction` 中使用它。'
- en: And back to traits we go...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 然后我们回到特性上...
- en: 'The simplest way to think of a trait is that it creates a signature to the
    implementation. If you''re used to C (or C++), then you will have seen this in
    code akin to this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将特性视为创建实现签名的最简单方式。如果你习惯于 C（或 C++），那么你将在类似这样的代码中看到它：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The compiler accepts this code is correct as there is a signature in the `.h`
    file that says somewhere there is a compiled function that provides the implementation
    of this call. When the compiler comes to link everything together, the code that
    was promised by the signature is found and `myFunction` does whatever it's supposed
    to do and returns the `int`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器接受这段代码是正确的，因为 `.h` 文件中的签名在某处声明了一个编译函数，它提供了这个调用的实现。当编译器到达链接一切的时候，根据签名承诺的代码被找到，`myFunction`
    执行它应该执行的操作并返回 `int`。
- en: In C#, this would be supplied via an `interface`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，这将通过 `interface` 提供。
- en: With Rust, we have something very similar.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rust，我们有一些非常相似的东西。
- en: The `trait` supplies the signature, the `impl` supplies the implementation,
    and the code calls the `impl`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`trait` 提供了签名，`impl` 提供了实现，代码调用 `impl`。'
- en: Now this may seem somewhat like overkill. Why would you create a stub when the
    implementation is typically in the same source file? The answer is we can use
    traits in a Rust library known as a **crate**. The trait tells the compiler that
    somewhere the code is implemented and it will be linked at the last stage of the
    build.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这可能看起来有些过度。为什么要在实现通常在同一个源文件中的时候创建一个存根？答案是我们可以使用 Rust 库中的特性。特性告诉编译器某处有代码实现，它将在构建的最后阶段被链接。
- en: We will look at crates in the next chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中查看 crates。
- en: A simple crate example
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的 crate 示例
- en: 'In this example, we will create a trait that will contain the signature for
    two functions: `calc_perimeter` and `calc_area`. To start with, we construct a
    `struct`. In this case, we will have two `struct`s:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个特质，它将包含两个函数的签名：`calc_perimeter` 和 `calc_area`。首先，我们构建一个 `struct`。在这种情况下，我们将有两个
    `struct`：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to create a trait for each. The general format for a trait looks like
    this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个创建一个特质。特质的通用格式如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our case, we would have the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将有以下内容：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now need to create an implementation for both of these traits. The `impl`,
    though, will not look quite the same.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为这两个特质创建实现。然而，`impl` 的外观将不会完全相同。
- en: 'Before, we had the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，我们有以下内容：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, we have to give the name of the struct it relates to:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们必须给出与它相关的结构体的名称：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the `impl` defines the trait and the trait is just a stub, why do we need
    to say which struct it is for?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `impl` 定义了特质，而特质只是一个占位符，为什么我们还需要说明它对应的结构体？
- en: This is a fair question.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的问题。
- en: Without the trait, an `impl` operates in a similar way to a function. We supply
    the parameters to the `impl` via `&self`. When we have a trait, the `impl` has
    to say what `&self` refers to.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特质，`impl` 的操作方式类似于函数。我们通过 `&self` 向 `impl` 提供参数。当我们有一个特质时，`impl` 必须说明 `&self`
    指的是什么。
- en: The code for this can be found in `09/non_generic_trait`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码可以在 `09/non_generic_trait` 中找到。
- en: 'Our `impl` for the first trait will be as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个特质的 `impl` 将如下所示：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the function can access `side_one` and `side_two` from the `Perimeter
    struct`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该函数可以访问 `Perimeter struct` 中的 `side_one` 和 `side_two`。
- en: 'The second `impl` will look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `impl` 将看起来像这样：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, the calls to the implementations. Unlike previous examples, both of
    the structures have to be initialized and then the implementation call given:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对实现的调用。与之前的示例不同，这两个结构体都必须初始化，然后才能给出实现调用：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once the code has been compiled, the expected answer is as shown in the following
    screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码编译完成，预期的答案如下所示：
- en: '![](img/00069.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.jpeg)'
- en: Traits and generics
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质和泛型
- en: 'If we look at the code, we have two structures that effectively do the same
    thing, with the only difference being the types for the parameters aren''t the
    same. We can alter the member names for the structures without an issue to make
    life simpler:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看代码，我们有两个结构体实际上执行相同的功能，唯一的区别是参数的类型不相同。我们可以更改结构体的成员名称而不存在问题，以使生活更简单：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This would become the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变成以下内容：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The calculation cannot be altered as they are totally different, but will need
    the parameter names to be altered. The other aspect to alter will be the name
    for the functions. Let's create a version of the code that only uses part of the
    code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 计算不能改变，因为它们完全不同，但需要更改参数名称。需要更改的另一个方面是函数的名称。让我们创建一个只使用部分代码的代码版本。
- en: 'As we have the generic version of the `struct`, we next need to create the
    trait:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有 `struct` 的泛型版本，我们接下来需要创建一个特质：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have to use `<T>` as the `trait` has to take a generic.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `<T>`，因为特质必须接受一个泛型。
- en: The construction for the implementation can be achieved in one of two ways.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的构建可以通过两种方式之一实现。
- en: The code for this section can be found in `09/generic_traits_simple`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分的代码可以在 `09/generic_traits_simple` 中找到。
- en: Defining the impl for specific types
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为特定类型定义 impl
- en: 'This is by far the simplest way of creating the code. We define the types that
    `Shape` can take:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的方法之一来创建代码。我们定义 `Shape` 可以接受的数据类型：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Writing the code like this ensures that we cannot pass anything into the implementations
    that don't make any sense (for example, types that cannot have `+` or `*` applied
    to them).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方式编写代码可以确保我们不会将任何没有意义的东西传递给实现（例如，不能对它们应用 `+` 或 `*` 的类型）。
- en: Using where
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 where
- en: If you're used to programming using generics in C#, this should be familiar
    to you.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于使用 C# 中的泛型编程，这应该对你来说很熟悉。
- en: 'Rust contains an implementation of `where`, so we are able to define what `where`
    is. This means that, as we had in an earlier example for this chapter, the construct
    `<T: Mul<Output = T>>` can be used in a modified way:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rust 包含 `where` 的实现，因此我们能够定义 `where` 是什么。这意味着，正如我们在本章早期示例中看到的那样，构造 `<T: Mul<Output
    = T>>` 可以以修改后的方式使用：'
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This does, though, give rise to a number of other issues. Two simple ones are
    that we multiply by `2`—however, that value isn't clear if it's `2u8` or `2i32`.
    We also try to add values together, but as with multiplying `T` together, there
    is no guarantee you can add by `T`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，这确实引发了许多其他问题。其中两个简单的问题是，我们乘以`2`——然而，如果它是`2u8`还是`2i32`，这个值并不明确。我们还尝试将值相加，但与将`T`相乘一样，没有保证你可以通过`T`来相加。
- en: Making it work
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使其工作
- en: 'The final step is to add a `main` function. We can use the same function as
    was in the non-generic trait example but with the oval removed:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是添加一个`main`函数。我们可以使用之前非泛型特质示例中的相同函数，但要去掉椭圆：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When compiled, this gives the following output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，它给出了以下输出：
- en: '![](img/00070.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00070.jpeg)'
- en: As we have created the second implementation, extending the `main` function
    to include the second calculation should be trivial.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经创建了第二个实现，将`main`函数扩展以包括第二个计算应该是微不足道的。
- en: See `09/generic_trait_full` for the code files of this part.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这部分代码文件的详细信息，请参阅`09/generic_trait_full`。
- en: 'We also need to implement the `f32` calculation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现`f32`的计算：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When this is compiled, we see the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个文件被编译时，我们会看到以下内容：
- en: '![](img/00071.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00071.jpeg)'
- en: Something you may have noticed
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可能已经注意到了
- en: If we compare the two different implementations of the code (generic and non-generic),
    the main difference is that we have reduced the amount of code we need as the
    two structs were the same in all but the name. We have also simplified the code
    so that we have a single call to calc and allow the compiler to decide which one
    we need based on the type passed in.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较两种不同的代码实现（泛型和非泛型），主要区别在于我们减少了所需的代码量，因为这两个结构体在名称之外都是相同的。我们还简化了代码，以便我们只有一个对`calc`的调用，并允许编译器根据传入的类型来决定我们需要哪个。
- en: Generics - a small aside
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型 - 稍作补充
- en: Code reduction and simplification is always a good thing (well, mostly at least!).
    However, with generics, there is always a trade-off and it's not always apparent.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的缩减和简化始终是一件好事（至少大部分情况下是这样）。然而，在使用泛型时，总会有权衡，而且并不总是显而易见的。
- en: 'Let''s consider the following piece of code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码片段：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This returns a value of type `T` by multiplying two variables (of type `T`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过乘以两个变量（类型为`T`）返回一个`T`类型的值。
- en: 'The question is: You can send a number of types into that function - how will
    the compiler know what to do if it doesn''t know what type `T` is? The only safe
    way is to create a version of `my_multiply` for each possible type. Fortunately,
    the compiler does this automatically for you in a process called monomorphization.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：你可以向该函数发送多种类型——如果编译器不知道`T`的类型，它将如何知道该做什么？唯一安全的方法是为每种可能的类型创建一个`my_multiply`版本。幸运的是，编译器会自动为你完成这个过程，称为单形化。
- en: So what does happen?
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么到底发生了什么？
- en: To give all of these generated functions unique names, compilers that work with
    generics use a process called **name mangling** (or *name munging*). This creates
    a unique name for each internally created function that takes generic parameters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给所有这些生成的函数赋予独特的名称，与泛型一起工作的编译器使用了一个称为**名称混淆**（或*名称混淆*）的过程。这为每个内部创建的、带有泛型参数的函数创建了一个独特的名称。
- en: For which one to use, during linking, the linker analyzes the code *signatures* required.
    If the linker sees a signature requiring `f32` for `T`, that munged name object
    code is included in the final object list. Once the linker has finished with the
    analysis, the unused objects (those not on the final list) are stripped out. The
    final binary therefore only contains the required code and not every variation
    of the types possible.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接过程中，对于应该使用哪个版本，链接器会分析所需的代码`签名`。如果链接器看到一个需要`f32`作为`T`的签名，那么混淆后的名称对象代码将被包含在最终对象列表中。一旦链接器完成分析，未使用的对象（那些不在最终列表中的对象）将被剥离。因此，最终的二进制文件只包含所需的代码，而不是可能的所有类型变体。
- en: While different compilers treat generics differently, the process for compilation,
    name munging, and then final stripping is common among them all!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不同的编译器对泛型有不同的处理方式，但在编译、名称混淆以及最终剥离的过程中，它们之间是通用的！
- en: Back to the where version
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到`where`版本
- en: The `where` version of the code is more complex than the non-where version.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的`where`版本比非`where`版本更复杂。
- en: The source for this version can be found in `09/generic_trait_where`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的源代码可以在`09/generic_trait_where`中找到。
- en: 'Let''s examine the code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下代码：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have seen `std::ops::Mul` before in the generic multiplication example. If
    we need to include multiple items from `std::ops` (or indeed any library), they
    are held in curly braces; `{}`. Here, we include `Add` and `Mul`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在泛型乘法示例中见过 `std::ops::Mul`。如果我们需要从 `std::ops`（或者确实任何库）中包含多个项目，它们被放在花括号 `{}`
    中。这里，我们包含了 `Add` 和 `Mul`。
- en: Up until this point, we have not seen the `extern crate` directive. For now,
    it is enough to know that this will include an external library. Crates are covered
    in Chapter 9, *Generics and Traits*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有看到 `extern crate` 指令。现在，只需要知道这将包含一个外部库。Crates 在第 9 章，*泛型和特性* 中介绍。
- en: Finally, we use `FromPrimitive` from the `num` library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `num` 库的 `FromPrimitive`。
- en: 'Our `struct` and `trait` are the same as before. The implementation, though,
    is different:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `struct` 和 `trait` 和之前一样。不过，实现是不同的：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are two important lines in this code: `where T:Copy + FromPrimitive +
    Add<Output = T> + Mul<Output = T>` and `let two = T::from_u8(2).expect("Unable
    to create a value of 2");`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有两行很重要：`where T:Copy + FromPrimitive + Add<Output = T> + Mul<Output = T>`
    和 `let two = T::from_u8(2).expect("Unable to create a value of 2");`。
- en: Here, we are saying that we want to copy the type, we'll be using `FromPrimitive`
    to cast a primitive to `T`, and both the `Add` and `Mul` outputs will be of type
    `T`. Rust concatenates the parameters that a `where` uses using `+`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们说的是我们想要复制类型，我们将使用 `FromPrimitive` 来将原始类型转换为 `T`，并且 `Add` 和 `Mul` 的输出都将为类型
    `T`。Rust 使用 `+` 连接 `where` 使用的参数。
- en: The `let two` line creates a variable that takes an unsigned 8-bit value and
    casts that to `T`. If it fails, the error is thrown.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`let two` 行创建了一个变量，它接受一个无符号 8 位值并将其转换为 `T`。如果失败，则会抛出错误。'
- en: We have to use `Add<Output = T>` to ensure we can add the types together.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `Add<Output = T>` 来确保我们可以将类型相加。
- en: Try to compile
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试编译
- en: 'If you use the standard `cargo run`, you will be met with an error that the
    compiler is `unable to find extern crate num`. This is down to cargo not knowing
    where the dependencies are held. At the first time of grabbing an external reference,
    Rust will update the list of available crates (the registry) and then download
    the ones required. To do this, the `Cargo.toml` file needs to be edited and the
    following code inserted:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用标准的 `cargo run`，你会遇到一个错误，编译器 `无法找到 extern crate num`。这是由于 cargo 不知道依赖项在哪里。在第一次获取外部引用时，Rust
    将更新可用的 crate 列表（注册表），然后下载所需的 crate。为此，需要编辑 `Cargo.toml` 文件并插入以下代码：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once this has been saved and the `cargo run` executed, you will see output
    like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，执行 `cargo run`，你会看到如下输出：
- en: '![](img/00072.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: Trait bounds
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性限制
- en: A trait can also have a bound placed upon it. In effect, a bound is a rule that
    the trait has to abide by and is added to the declaring type parameter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特性也可以被施加一个限制。实际上，限制是一个特性必须遵守的规则，并且被添加到声明类型参数中。
- en: The source for this part is in `09/trait_bound_gen_struct`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的源代码在 `09/trait_bound_gen_struct`。
- en: In the code example, the `impl` has a `PartialEq` bound placed upon the generic
    type. Our `struct` contains four parameters within it and so we only want to test
    for partial equality within that `struct`. If we didn't have the `PartialEq` on
    the declared type parameter, the compilation would fail as we're not testing everything
    within that `struct`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，`impl` 对泛型类型放置了一个 `PartialEq` 限制。我们的 `struct` 内部包含四个参数，所以我们只想在该 `struct`
    内进行部分相等性测试。如果没有在声明的类型参数上有 `PartialEq`，编译将失败，因为我们没有测试该 `struct` 内部的所有内容。
- en: 'When the code is compiled, we get the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码编译时，我们得到以下输出：
- en: '![](img/00073.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: Can we reduce the amount of code further?
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们能否进一步减少代码量？
- en: 'Yes. It is possible to completely omit the requirement to create an implementation
    of a trait if that trait contains a default method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。如果特性包含默认方法，则可以完全省略创建特性实现的必要性：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`test_code` is just the stub which requires an implementation. The `self_test_code`
    function doesn''t need an implementation as it has a default method already.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_code` 只是一个需要实现的存根。`self_test_code` 函数不需要实现，因为它已经有了默认方法。'
- en: Can the default method be overridden?
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认方法可以被覆盖吗？
- en: It can.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以。
- en: The code for this section is in `09/override_default_method`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的代码在 `09/override_default_method`。
- en: 'Let''s start the code off by defining a `trait`. This has a default method
    for `is_not_done`. We will still need to implement `is_done` though, which we
    do for the `UseFirstTime` struct:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一个`trait`开始编写代码。这有一个`is_not_done`的默认方法。尽管如此，我们仍然需要实现`is_done`，我们为`UseFirstTime`结构体这样做：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We next want to override the default method for `is_not_done`. Again, we create
    an empty `struct` and write both the implementations for `is_done` and `is_not_done`.
    When we call `is_not_done` from the second `struct`, the `println!` from the second
    `struct` is shown and not the first:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要重写`is_not_done`的默认方法。同样，我们创建了一个空的`struct`并编写了`is_done`和`is_not_done`的实现。当我们从第二个`struct`中调用`is_not_done`时，显示的是第二个`struct`中的`println!`，而不是第一个：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When compiled, we get the following output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，我们得到以下输出：
- en: '![](img/00074.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: Rounding off traits
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质总结
- en: 'This has been a large topic, but we have two more aspects to consider for traits:
    inheritance and deriving. One that should be familiar if you''re used to any form
    of object-oriented programming.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很大的主题，但我们还有两个关于特质的方面需要考虑：继承和派生。如果你熟悉任何形式的面向对象编程，这应该很熟悉。
- en: Inheritance
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'This is very similar to inheritance within C++ and C#:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这与C++和C#中的继承非常相似：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Code for this part is in `09/inheritance`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的代码在`09/inheritance`中。
- en: 'The code that implements `OneTwo` must also implement `One` (the same as when
    we overrode the default method, we still had to define `is_done`), therefore:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`OneTwo`的代码也必须实现`One`（这与当我们重写默认方法时仍然需要定义`is_done`的情况相同），因此：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And the result is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/00075.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: If we omitted the `impl One` block, we would get a compilation error complaining
    that `impl OneTwo` requires `impl One` to exist.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略了`impl One`块，我们会得到一个编译错误，抱怨`impl OneTwo`需要`impl One`存在。
- en: Deriving
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Rust provides a handy attribute that allows you to access a number of commonly
    used traits without having to implement them yourself time and again. They are
    called using `#[derive(Trait_Name)]`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Rust提供了一个方便的属性，允许你访问许多常用特质，而无需自己重复实现。它们通过使用`#[derive(Trait_Name)]`来调用。
- en: 'The traits available are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的特性如下：
- en: '`Clone`: This creates a clone of the object'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clone`: 这创建了一个对象的副本'
- en: '`Copy`: This creates a copy of the object'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Copy`: 这创建了一个对象的副本'
- en: '`Debug`: This provides debugging code'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug`: 这提供了调试代码'
- en: '`Default`: This gives a useful default value for a type'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Default`: 这为类型提供了一个有用的默认值'
- en: '`Eq`: `Equality`, this is similar to `PartialEq` except for all parameters
    within a struct'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Eq`: `相等性`，这与`PartialEq`类似，但除了结构体内的所有参数'
- en: '`Hash`: This is a hashable type'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hash`: 这是一个可哈希的类型'
- en: '`Ord`: `Order`, these are the types that form a total order on all types'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ord`: `排序`, 这些是在所有类型上形成全序的类型'
- en: '`PartialEq`: `Partial Equality`, this only tests on a subset of the struct'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PartialEq`: `部分相等性`，这仅在结构体的子集上进行测试'
- en: '`PartialOrd`: `Partial Order`, values that can compared to create a sort order'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PartialOrd`: `部分排序`, 可以比较以创建排序顺序的值'
- en: Trait objects
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质对象
- en: 'Typically, when we call a function in Rust, we will have a line in the code
    similar to this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们调用Rust中的函数时，代码中会有一行类似于以下的内容：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When we have a `struct` in the code which has an `impl` attached to it, we
    will have this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在代码中有一个附加了`impl`的`struct`时，我们将有如下所示：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These are both fine.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都是可以的。
- en: If you recall, back in the `generic_trait_full` example, we had `Calc` defined
    and `T` could be either an `f32` or `i32`. We also talked about how the application
    knew what to include in the final binary. This is known as **static dispatch**
    (which Rust prefers).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在`generic_trait_full`示例中，我们定义了`Calc`，`T`可以是`f32`或`i32`。我们还讨论了应用程序如何知道在最终二进制文件中包含什么。这被称为**静态调度**（Rust所偏好的）。
- en: 'Rust uses a system called a **dispatch**, of which there are two types: static
    (favored by Rust) and dynamic. Dynamic dispatch relies on something called a **trait
    object**.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Rust使用一个称为**调度**的系统，其中有两种类型：静态（Rust所偏好的）和动态。动态调度依赖于称为**特质对象**的东西。
- en: Let's create a sample test setup
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们创建一个示例测试设置
- en: 'The test code is very simple. We have a trait with a function that returns
    a `String`. We then have a couple of implementations and a parameter bound function
    that will display the result from the implementations:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码非常简单。我们有一个具有返回`String`的函数的特质。然后我们有几个实现和一个参数限制函数，该函数将显示实现的结果：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The code for this part can be found in `09/trait_object_static`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的代码可以在`09/trait_object_static`中找到。
- en: 'When compiled and executed, we get the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行后，我们得到以下结果：
- en: '![](img/00076.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: From the previous explanation, we know that the compiler will generate the various
    types that `T` can be.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的解释中，我们知道编译器将生成 `T` 可以是的各种类型。
- en: Let's see dynamic dispatch
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们看看动态分派
- en: Dynamic dispatch uses trait objects. A trait object can store a value of any
    type that implements the `trait`. The actual type of the value is only known at
    runtime.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分派使用特征对象。特征对象可以存储任何实现了 `trait` 的类型的值。值的实际类型仅在运行时才知道。
- en: The code for this section can be found in `09/dynamic_dispatch`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该部分的代码可以在 `09/dynamic_dispatch` 中找到。
- en: Let's look at some code to explain how this works.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码来解释这是如何工作的。
- en: 'Previously, we had for `display_code` the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们为 `display_code` 有以下内容：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We now have this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有这个：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We no longer have the `T` parameter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再有 `T` 参数。
- en: 'In the static version, `display_code` was called like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态版本中，`display_code` 被调用如下：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For the dynamic version, we use the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态版本，我们使用以下内容：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The trait object has been obtained from the pointer (`&DynamicObject`) which
    implemented the trait by using the cast (`&test_one as &DynamicObject`). It is
    also acceptable to use `display_code(&test_one)`. This is known as coercion: `&test_one`
    has been used as an argument to a function that takes `&DynamicObject`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 特征对象是从指针（`&DynamicObject`）中获得的，该指针通过使用强制转换（`&test_one as &DynamicObject`）实现了特征。也可以使用
    `display_code(&test_one)`。这被称为强制转换：`&test_one` 被用作一个接受 `&DynamicObject` 参数的函数的参数。
- en: The only issue with dynamic dispatch is that it can be slower, as each time
    the code is run, the runtime *forgets* the type of the pointer and has to create
    a new implementation for the different type.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分派的唯一问题是它可能较慢，因为每次代码运行时，运行时都会*忘记*指针的类型，并必须为不同类型创建一个新的实现。
- en: Keeping your object safe
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持对象安全
- en: 'We can''t use all traits to create a trait object. Take the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用所有特征来创建特征对象。以下是一个例子：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will not compile as `Clone` is not object-safe as `Clone` contains `Self:
    Sized`, which a trait cannot have.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '这将无法编译，因为 `Clone` 不是对象安全的，因为 `Clone` 包含 `Self: Sized`，而特征不能有。'
- en: 'If the trait doesn''t require `Self: Sized` and all of the methods are object-safe,
    it is an object-safe trait. For a method to be object-safe, it must require `Self:
    Sized`. If the method doesn''t require `Self: Sized`, it can still be object-safe
    if the method doesn''t require any parameters and doesn''t use `Self`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '如果特征不需要 `Self: Sized` 并且所有方法都是对象安全的，则它是一个对象安全特征。为了使方法对象安全，它必须要求 `Self: Sized`。如果方法不需要
    `Self: Sized`，如果方法不需要任何参数并且不使用 `Self`，则即使方法不需要 `Self: Sized`，它仍然可以是对象安全的。'
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Traits and generics are a key feature for development and Rust is feature-rich
    for these. We have seen how to create implementations, how to use generics, how
    to ensure that the types can be bound, and the power of traits. Hopefully, you
    should be appreciating now the sheer power that generics provide to the developer
    in terms of flexibility. Generics also allow for reducing the amount of code we
    (as developers) have to write by essentially removing the need to worry too much
    about what the generic represents.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 特征和泛型是开发的关键特性，Rust在这些方面功能丰富。我们看到了如何创建实现，如何使用泛型，如何确保类型可以被绑定，以及特征的力量。希望你现在应该能够欣赏到泛型为开发者提供的纯粹的力量，在灵活性方面。泛型还允许通过本质上消除对泛型代表的过度担忧来减少我们（作为开发者）需要编写的代码量。
- en: In the next chapter, we will be looking at extending our Rust applications by
    the use of external libraries, known as crates.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨通过使用外部库（称为crate）来扩展我们的Rust应用程序。
