- en: Safe Programming for the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络安全编程
- en: Ever since the popular Rails framework for the Ruby programming language, creating
    backend web services seemed like a domain for dynamically typed languages. This
    trend was only reinforced by the rise of Python and JavaScript as primary languages
    for these tasks. After all, the nature of these technologies made creating these
    services especially fast and changes to services (for example, a new field in
    the JSON response) are simple to do. Returning to static types for web services
    feels strange for many of us; after all, it takes a lot longer to get *something* going.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Ruby 编程语言的流行框架 Rails 以来，创建后端网络服务似乎成了动态类型语言的领域。这一趋势随着 Python 和 JavaScript
    作为这些任务的主要语言的兴起而得到加强。毕竟，这些技术的本质使得创建这些服务特别快速，对服务的更改（例如，JSON 响应中的新字段）也简单易行。对我们许多人来说，回归静态类型进行网络服务感觉有些奇怪；毕竟，要启动“某种东西”需要更长的时间。
- en: 'However, there is a cost to these: many services are deployed in the cloud
    nowadays, which means that a pay-as-you-go model is employed together with (practically)
    infinite scalability. Since—most notably—Python is not known for its execution
    speed, we can now see the cost of this overhead on the bill from the cloud provider.
    A 10% faster execution time can mean serving 10% more customers on the same hardware
    at the same level of quality (for example, response time). Similarly, smaller
    devices benefit from lower resource usage, which translates into faster software
    and therefore less energy consumed. Rust, as a systems programming language, was
    built with zero overhead in mind and is a close rival to C in many aspects such
    as speed or efficiency. It is therefore not unreasonable for heavily used web
    services to write critical parts in Rust, a move that has famously been made by
    Dropbox to improve its service quality and save costs.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也有代价：如今，许多服务部署在云端，这意味着采用了按需付费的模式，并且（实际上）具有无限的扩展性。由于——最值得注意的是——Python 以其执行速度而闻名，我们现在可以在云服务提供商的账单上看到这种开销的成本。10%
    的更快执行时间意味着在相同硬件和相同质量水平上服务 10% 的更多客户（例如，响应时间）。同样，较小的设备从较低的资源使用中受益，这转化为更快的软件，因此消耗更少的能源。Rust
    作为一种系统编程语言，在设计时考虑了零开销，在速度或效率等方面与 C 语言非常接近。因此，对于大量使用的网络服务来说，在 Rust 中编写关键部分是合理的，Dropbox
    就曾著名地采取这一举措来提高其服务质量并节省成本。
- en: 'Rust is a great language for the web and, in this chapter, we are looking at
    creating a regular RESTful API using a framework that is in use at many different
    applications and developed at Microsoft. You can look forward to learning about
    the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种非常适合网络的语言，在本章中，我们将探讨使用在许多不同应用程序中使用的框架来创建常规 RESTful API。您可以期待学习以下内容：
- en: Setting up a web server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置网络服务器
- en: Designing a RESTful API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 RESTful API
- en: Handling JSON payloads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 JSON 有效载荷
- en: Web error handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络错误处理
- en: Rendering HTML templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染 HTML 模板
- en: Using an ORM to save data to a database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ORM 将数据保存到数据库
- en: Running advanced queries using an ORM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ORM 运行高级查询
- en: Authentication on the web
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络上的身份验证
- en: Setting up a web server
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置网络服务器
- en: Over the last few years, web servers have changed. Where early web applications
    have been deployed behind some sort of web server application such as Apache Tomcat
    ([http://tomcat.apache.org/](http://tomcat.apache.org/)), IIS ([https://www.iis.net/](https://www.iis.net/)),
    and nginx ([https://www.nginx.com/](https://www.nginx.com/)), it is now more common
    to embed the serving part into the application as well. Not only is this easier
    on the Ops people, it also allows developers to have tight control over the entire
    application. Let's see how we can get started and set up a basic static web server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，网络服务器已经发生了变化。早期网络应用程序通常部署在某种类型的网络服务器应用程序之后，如 Apache Tomcat ([http://tomcat.apache.org/](http://tomcat.apache.org/))、IIS
    ([https://www.iis.net/](https://www.iis.net/)) 和 nginx ([https://www.nginx.com/](https://www.nginx.com/))，但现在更常见的是将服务部分嵌入到应用程序中。这不仅对运维人员来说更容易，还允许开发者对整个应用程序有更紧密的控制。让我们看看如何开始并设置一个基本的静态网络服务器。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's set up a Rust binary project using `cargo new static-web`. Since we are
    going to serve stuff on local port `8081`, make sure that the port is accessible
    as well. Inside the newly created project folder, we need an additional folder, `static/`,
    where you can put an interesting `.jpg` image and serve it. We are going to assume
    that this image is called `foxes.jpg`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`cargo new static-web`设置一个Rust二进制项目。由于我们将在本地端口`8081`上提供服务，请确保该端口可访问。在新建的项目文件夹中，我们需要一个额外的文件夹`static/`，你可以在这里放置一个有趣的`.jpg`图像并提供服务。我们将假设这个图像叫做`foxes.jpg`。
- en: Finally, open the entire directory with VS Code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用VS Code打开整个目录。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We are going to set up and run our own web server in just a few steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在几个步骤中设置和运行我们自己的Web服务器：
- en: 'Open `src/main.rs` first, and let''s add some code. We will work our way down
    to the `main` function, starting with imports and a simple index handler:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`src/main.rs`，让我们添加一些代码。我们将从导入和简单的索引处理器开始，逐步向下到`main`函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is not going to be the only request handler, however, so let''s add a
    few more to see how request-handling works:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这不会是唯一的请求处理器，所以让我们添加一些更多，看看请求处理是如何工作的：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What''s missing is the `main` function. This `main` function starts the server
    and attaches the services we created in the previous step:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缺少的是`main`函数。这个`main`函数启动服务器并附加我们在上一步中创建的服务：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the first handler, we mention a static `index.html` handle, which we haven''t
    yet created. Add a simple `marquee` output to a new file and save it as `static/index.html`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个处理器中，我们提到了一个静态的`index.html`处理器，但我们还没有创建它。向一个新文件添加一个简单的`marquee`输出，并将其保存为`static/index.html`：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One important thing that we are still need to do is adjust `Cargo.toml`. Declare
    the dependencies in `Cargo.toml` as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要做的一件重要的事情是调整`Cargo.toml`。按照以下方式在`Cargo.toml`中声明依赖项：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use a Terminal to execute `cargo run` and run the code, then open a browser
    window at `http://localhost:8081/`, `http://localhost:8081/welcome`, `http://localhost:8081/foxes`,
    and `http://localhost:8081/somethingarbitrary/10`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用终端执行`cargo run`并运行代码，然后在浏览器窗口中打开`http://localhost:8081/`、`http://localhost:8081/welcome`、`http://localhost:8081/foxes`和`http://localhost:8081/somethingarbitrary/10`：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the output for `http://localhost:8081`, handled by the `index` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`http://localhost:8081`的输出，由`index`函数处理：
- en: '![](img/a7d7d636-1c6d-4374-9972-f8b2bcb88743.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7d7d636-1c6d-4374-9972-f8b2bcb88743.png)'
- en: 'You can also call the welcome handler at `http://localhost:8081/welcome`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在`http://localhost:8081/welcome`调用`welcome`处理器：
- en: '![](img/fd5b036f-2750-4554-a671-803761ba3eb0.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd5b036f-2750-4554-a671-803761ba3eb0.png)'
- en: 'Our static handler returns a photo of the Mozilla office in Berlin at `http://localhost:8081/foxes`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的静态处理器在`http://localhost:8081/foxes`返回柏林Mozilla办公室的照片：
- en: '![](img/a78dedb7-20a5-4320-ba71-134a7ac1947c.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a78dedb7-20a5-4320-ba71-134a7ac1947c.png)'
- en: 'Lastly, we added a path handler that parses a string and an integer from the
    path, only to return the values:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个路径处理器，它解析路径中的字符串和整数，只是为了返回这些值：
- en: '![](img/dd845229-2c6e-468d-a19a-3ec92867e03d.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd845229-2c6e-468d-a19a-3ec92867e03d.png)'
- en: 'To verify the requests were actually handled by our web server, you should
    view the individual requests in the log output of the Terminal running `cargo
    run`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证请求确实被我们的Web服务器处理，你应该查看在运行`cargo run`的终端中的日志输出中的单个请求：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解它。
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`actix-web` ([https://actix.rs](https://actix.rs)) is a versatile web framework
    and it—among other things—efficiently serves static files as well. In this recipe,
    we covered how to declare and register request handlers, as well as some ways
    to provide responses. In a typical web framework, there are several ways to achieve
    these tasks (declaring handlers, creating responses) and *steps 1 *to *3* show
    two ways to do this with `actix-web`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`actix-web` ([https://actix.rs](https://actix.rs))是一个多功能的Web框架，它——在许多其他事情中——高效地服务静态文件。在本教程中，我们介绍了如何声明和注册请求处理器，以及一些提供响应的方法。在典型的Web框架中，有几种方法可以实现这些任务（声明处理器、创建响应），*步骤1*到*3*展示了使用`actix-web`实现这两种方法的方式：'
- en: Using an attribute (`#[get("/foxes")]`)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性（`#[get("/foxes")]`）
- en: Via the service registration call (`.service(web::resource("/welcome").to(rust_cookbook)`)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过服务注册调用（`.service(web::resource("/welcome").to(rust_cookbook))`）
- en: Regardless of the way we associate a handler with a route, each of them is wrapped
    into a factory that creates new handler instances on demand, which is very visible
    when a compiler error points to the `#[get(...)]` attribute instead of the actual
    function. The paths include typed placeholders for passing data from the path
    into the handler function—but more on that in the next recipe (*Designing a RESTful
    API*).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们以何种方式将处理器与路由关联，每个处理器都被包装在一个工厂中，该工厂按需创建新的处理器实例，这在编译器错误指向`#[get(...)]`属性而不是实际函数时非常明显。路径包括用于从路径传递数据到处理器函数的带类型的占位符——但更多内容将在下一个菜谱（*设计RESTful
    API*）中介绍。
- en: In *step 3*, we also add logging middleware that logs the user agent, time,
    and IP address so we can see requests also on the server side. All of this is
    done using `actix-web` method chaining, which structures the calls nicely. The
    call to `run()` blocks the application and starts the actix main loop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们还添加了记录中间件，记录用户代理、时间和IP地址，这样我们也可以在服务器端看到请求。所有这些操作都是使用`actix-web`方法链来完成的，它很好地结构化了调用。对`run()`的调用会阻塞应用程序并启动actix主循环。
- en: The photo in *step 6* was taken in Mozilla's Berlin office during Rust All Hands
    2019\. Yes, those are Firefox pillows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤6*中的照片是在2019年Rust All Hands活动期间在Mozilla的柏林办公室拍摄的。是的，那些是Firefox枕头。'
- en: '*Step 4* adds a very basic `index.html` file to be served, while *step 5* declares
    the dependencies in `Cargo.toml` as we have done before.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*添加了一个非常基本的`index.html`文件以供服务，而*步骤5*则声明了`Cargo.toml`中的依赖项，就像我们之前做的那样。'
- en: In the last step, we are running the code and showing the output—both in the
    browser and the logging.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们运行代码并显示输出——在浏览器和日志中。
- en: We've successfully learned the basics of setting up a web server. Equipped with
    this knowledge of serving static files and images, as well as parsed path parameters,
    we can move on to the next recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了设置Web服务器的基础知识。掌握了服务静态文件和图片以及解析路径参数的知识，我们可以继续学习下一个菜谱。
- en: Designing a RESTful API
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计RESTful API
- en: Almost everything relies on web resources—from a single page application that
    dynamically fetches data via JavaScript and displays it in HTML to the app integration
    for a particular service. A resource on a web service can be anything but it's
    typically expressed using readable URIs so information is already transferred
    by using a specific path, which then only accepts the required information it
    needs to process. This allows structuring code internally and globally utilizes
    all `HTTP` methods to create an expressive interface that developers can use.
    RESTful APIs ([https://www.codecademy.com/articles/what-is-rest](https://www.codecademy.com/articles/what-is-rest))
    ideally capture all of these benefits.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有东西都依赖于Web资源——从通过JavaScript动态获取数据并在HTML中显示的单页应用程序，到特定服务的应用程序集成。Web服务上的资源可以是任何东西，但它通常使用可读的URI来表示，这样信息就已经通过使用特定的路径来传输，然后只接受它需要处理的信息。这允许在内部和全局结构化代码，并利用所有`HTTP`方法创建一个开发者可以使用的表达性接口。RESTful
    API([https://www.codecademy.com/articles/what-is-rest](https://www.codecademy.com/articles/what-is-rest))理想地捕捉了所有这些好处。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's set up a Rust binary project using `cargo new api`. Since we are going
    to serve stuff on local port `8081`, make sure that the port is accessible as
    well. Inside the newly created project folder, we need an additional `static/` folder, where
    you can put an interesting `.jpg` image to serve. Additionally, make sure that
    there is a program such as `curl` ([https://curl.haxx.se/](https://curl.haxx.se/)) available
    on your command line. Alternatively, Postman ([https://www.getpostman.com/](https://www.getpostman.com/))
    is a tool that does the same thing with a graphical interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo new api`创建一个Rust二进制项目。由于我们将在本地端口`8081`上提供服务，请确保该端口可访问。在新建的项目文件夹中，我们需要一个额外的`static/`文件夹，你可以在这里放置一个有趣的`.jpg`图片以供服务。此外，请确保命令行上有一个像`curl`([https://curl.haxx.se/](https://curl.haxx.se/))这样的程序。或者，Postman([https://www.getpostman.com/](https://www.getpostman.com/))是一个具有图形界面的工具，可以完成相同的功能。
- en: Finally, open the entire directory with VS Code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用VS Code打开整个目录。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s build an API with a few steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分几个步骤来构建一个API：
- en: 'Open `src/main.rs` to add the primary code for the server and handling requests.
    Let''s go step by step and start with the imports:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/main.rs`以添加服务器和请求处理的主要代码。让我们一步一步来，从导入开始：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we are defining a few handlers that take requests and use that data somehow.
    Add these lines to `main.rs`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一些处理器，它们接收请求并使用这些数据。将这些行添加到`main.rs`中：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we should also register the handlers with the web server. The following
    is the `main` function for `main.rs`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还应该将处理器注册到 web 服务器上。以下是 `main.rs` 的 `main` 函数：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, we should adapt `Cargo.toml` to include these new dependencies as well:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们应该将 `Cargo.toml` 适配以包含这些新的依赖项：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can build and run the app using `cargo run`. Then, let''s see whether
    we can reach the APIs using `curl` or Postman, which should result in a similar
    logging output to the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `cargo run` 构建并运行应用程序。然后，让我们看看是否可以使用 `curl` 或 Postman 来访问 API，这应该会产生以下类似的日志输出：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following are the `curl` requests—they should be easy to replicate with
    Postman:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `curl` 请求——它们应该很容易用 Postman 来复制：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That's it, but there is a lot to unpack so let's see why this works the way
    it does.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样了，但还有很多东西要解释，让我们看看为什么它会以这种方式工作。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Designing *good* APIs is hard and requires a good grasp of what's possible—especially
    with new frameworks and languages. `actix-web` has proven itself to be a versatile
    tool that proficiently uses types to achieve great results. *Step 1* sets this
    up by importing a few types and traits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 设计 *良好* 的 API 是困难的，并且需要很好地掌握可能发生的事情——特别是对于新的框架和语言。`actix-web` 已经证明了自己是一个多才多艺的工具，它有效地使用类型来取得很好的效果。*步骤
    1* 通过导入一些类型和特性来设置这一点。
- en: Only in *step 2* and *step 3* does it get more interesting. Here, we define
    the various handlers in almost all of the ways `actix-web` allows us to, by either
    using the attribute that wraps a function into a factory (underneath it's all
    asynchronous actors; check out *Handle asynchronous messages with actors* in [Chapter
    4](eb7f566a-00ca-4e6c-bc05-4e9d00bf8c56.xhtml), *Fearless Concurrency* ) or letting
    the `web::resource()` type do that. Either way, every handler function has a route
    associated with it and will be called in parallel. The routes also contain parameters
    that can be specified using a `{}` syntax that also allows regular expression
    (see the route containing `"{tail:.*}" - a` shorthand that receives the path's
    remainder under the `tail` key.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在 *步骤 2* 和 *步骤 3* 中，事情才会变得更有趣。在这里，我们通过使用将函数包装成工厂的属性（在其下方都是异步演员；查看 [第 4 章](eb7f566a-00ca-4e6c-bc05-4e9d00bf8c56.xhtml)，*无畏并发*
    中的 *使用演员处理异步消息*）或者让 `web::resource()` 类型来完成，几乎以 `actix-web` 允许的所有方式定义了各种处理器。无论哪种方式，每个处理器函数都有一个与之关联的路由，并且将并行调用。路由还包含可以使用
    `{}` 语法指定的参数，该语法还允许使用正则表达式（例如，包含 `"{tail:.*}"` 的路由 - 这是一个简写，它接收 `tail` 键下的路径剩余部分）。
- en: 'Don''t let users directly access files on your filesystem as we did here. This
    is a bad idea in many ways, but most importantly offers a way to execute potentially
    any file in the filesystem. A better way is to provide a white list of abstracted
    files—for example, Base64 ([https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding))-encoded—using
    an independent key: for example, a UUID ([https://tools.ietf.org/html/rfc4122](https://tools.ietf.org/html/rfc4122)).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让用户直接访问你的文件系统中的文件，就像我们在这里做的那样。这在很多方面都是个坏主意，但最重要的是它提供了一种执行文件系统中任何文件的方法。更好的方法是提供一个抽象文件的白名单——例如，Base64
    ([https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding))
    编码的——使用一个独立的关键字：例如，UUID ([https://tools.ietf.org/html/rfc4122](https://tools.ietf.org/html/rfc4122))。
- en: If a function provides an input parameter of the `Path<T>` type, then `T` is
    what's checked for in the corresponding path variable. Therefore, if a function
    header expects `i32`, the request will fail for anyone trying to pass a string.
    You can verify that yourself with the `bookmarks/by-id/{id}` path. As an alternative
    to `Path<T>`, you can also receive the entire `HttpRequest` ([https://docs.rs/actix-web/1.0.3/actix_web/struct.HttpRequest.html](https://docs.rs/actix-web/1.0.3/actix_web/struct.HttpRequest.html))
    as a parameter and extract the required information with the `.query()` function.
    Both the `echo_bookmark` and `bit_ly` functions demonstrate how to use these.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数提供了一个 `Path<T>` 类型的输入参数，那么 `T` 就是相应路径变量中检查的内容。因此，如果函数头期望 `i32`，那么尝试传递字符串的人的请求将会失败。你可以通过
    `bookmarks/by-id/{id}` 路径来验证这一点。作为 `Path<T>` 的替代方案，你也可以接收整个 `HttpRequest` ([https://docs.rs/actix-web/1.0.3/actix_web/struct.HttpRequest.html](https://docs.rs/actix-web/1.0.3/actix_web/struct.HttpRequest.html))
    作为参数，并通过 `.query()` 函数提取所需信息。`echo_bookmark` 和 `bit_ly` 函数展示了如何使用这些方法。
- en: The responses behave similarly. `actix-web` provides a `Responder` trait that
    is implemented for standard types such as `String` (along with the correct response
    content type as far as we saw), which makes the handler more readable. Again,
    returning an `HttpResponse` type provides more finely controllable returns. Additionally,
    there are results and similar types that are automatically converted into appropriate
    responses, but showing all of these would go beyond the scope of this book. Check
    out the `actix-web` documentation to find out more.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的行为类似。`actix-web` 提供了一个 `Responder` 特性，该特性为标准类型（如 `String`，以及我们看到的正确响应内容类型）实现了，这使得处理程序更易于阅读。同样，返回
    `HttpResponse` 类型提供了更精细的控制。此外，还有一些结果和类似类型会自动转换为适当的响应，但展示所有这些内容将超出本书的范围。请查阅 `actix-web`
    文档以获取更多信息。
- en: One downside to the attributes is the fact that only one of them can go on top
    of a function—so how can we reuse a function for two different `HTTP` methods?
    `echo_bookmark` is registered to respond to the input ID only on `PUT` and `POST`,
    not on `DELETE`, `HEAD`, `GET`, and more. This is done by guards that forward
    a request only if a condition is met. Check out the docs ([https://docs.rs/actix-web/1.0.3/actix_web/guard/index.html](https://docs.rs/actix-web/1.0.3/actix_web/guard/index.html))
    for more.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的一个缺点是只有一个可以放在函数的顶部——那么我们如何重用函数以处理两种不同的 `HTTP` 方法？`echo_bookmark` 仅在 `PUT`
    和 `POST` 上注册以响应输入 ID，而不是在 `DELETE`、`HEAD`、`GET` 以及更多方法上。这是通过守卫实现的，只有当条件满足时才会转发请求。查看文档
    ([https://docs.rs/actix-web/1.0.3/actix_web/guard/index.html](https://docs.rs/actix-web/1.0.3/actix_web/guard/index.html))
    以获取更多信息。
- en: '*Step 4* shows adaptations to `Cargo.toml` to make it all work and, in *step
    5**,* we get to try out the web service. If you take some time to observe the
    `curl` responses, we receive the expected results. `curl` also does not follow
    redirects by default, hence the `HTTP` response code, `302`, with the location
    header set pointing to where I would go. This redirect is provided by an external
    resource that `actix-web` provides, which is useful for these situations.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 4 步* 展示了如何修改 `Cargo.toml` 以使其正常工作，而在 *第 5 步* 中，我们可以尝试使用 Web 服务。如果你花点时间观察
    `curl` 的响应，我们会收到预期的结果。默认情况下，`curl` 不会跟随重定向，因此，带有位置头并指向我将去的地方的 `HTTP` 响应代码 `302`。这种重定向是由
    `actix-web` 提供的外部资源提供的，这对于这些情况很有用。'
- en: Now that we have learned more about designing APIs in `actix-web`, let's move
    on to the next recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在 `actix-web` 中设计 API，让我们继续到下一个配方。
- en: Handling JSON payloads
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 JSON 负载
- en: After learning how to create APIs, we need to pass data back and forth. While
    the path provides one method to do that, anything a little more sophisticated
    (for example, a long list of things) will quickly show the limitations of these
    methods. This is why other formats are typically used to structure the data—JSON
    ([http://json.org/](http://json.org/)) is the most popular for web services. In
    this chapter, we are going to use the previous API and enhance it by handling
    and returning JSON.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何创建 API 之后，我们需要传递数据。虽然路径提供了一种方法来做这件事，但任何稍微复杂一些的东西（例如，一个很长的项目列表）很快就会显示出这些方法的局限性。这就是为什么通常使用其他格式来结构化数据——JSON
    ([http://json.org/](http://json.org/)) 是 Web 服务中最受欢迎的。在本章中，我们将使用之前的 API 并通过处理和返回
    JSON 来增强它。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's set up a Rust binary project using `cargo new json-handling`. Since we
    are going to serve stuff on the local port `8081`, make sure that the port is
    accessible as well. Additionally, a program such as `curl` or Postman is required
    to test the web service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `cargo new json-handling` 设置一个 Rust 二进制项目。由于我们将在本地端口 `8081` 上提供服务，请确保该端口可访问。此外，还需要一个如
    `curl` 或 Postman 这样的程序来测试 Web 服务。
- en: Finally, open the entire directory with VS Code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 VS Code 打开整个目录。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to implement this recipe:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此配方：
- en: 'In `src/main.rs`, we are going to add the imports first:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中，我们首先添加导入：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let''s create some handler functions along with a serializable JSON type.
    Add the following code to `src/main.rs`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些处理函数以及一个可序列化的 JSON 类型。将以下代码添加到 `src/main.rs` 中：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, we are registering the handlers with the web server in the `main` function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在 `main` 函数中将处理程序注册到 Web 服务器上：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We also need to specify the dependencies in `Cargo.toml`. Replace the existing
    dependencies with the following:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在 `Cargo.toml` 中指定依赖项。用以下依赖项替换现有的依赖项：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we can see whether it works by running `cargo run` and issuing requests
    with `curl` from a different Terminal. The commands and their responses should
    look as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过运行 `cargo run` 并从不同的终端使用 `curl` 发送请求来测试它是否工作：命令及其响应应该如下所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Meanwhile, the logging output of `cargo run` shows the requests from the server
    side:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`cargo run` 的日志输出显示了来自服务器端的请求：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This was quick and easy, right? Let's see how it works.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这很快也很简单，对吧？让我们看看它是如何工作的。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Adding JSON handling to an `actix-web` web service is easy—thanks to the deep
    integration of the popular `serde` crate ([https://crates.io/crates/serde](https://crates.io/crates/serde)).
    After some imports in *step 1*, we declare a `Bookmark` struct as `Serialize`
    and `Deserialize` in *step 2*, which enables `serde` to generate and parse JSON
    for this data type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 处理添加到 `actix-web` 网络服务中很容易——归功于流行的 `serde` 包（[https://crates.io/crates/serde](https://crates.io/crates/serde)）的深度集成。在
    *步骤 1* 的一些导入之后，我们在 *步骤 2* 中声明一个 `Bookmark` 结构体作为 `Serialize` 和 `Deserialize`，这使得
    `serde` 能够为该数据类型生成和解析 JSON。
- en: The change in the handler functions is also minimal since returning and ingesting
    JSON is a very common task. The required function to return a JSON payload with
    the response is attached to the `HttpResponse` factory method that does everything,
    including setting the appropriate content type. On the ingest part, there is a
    `web::Json<T>` type to take care of deserializing and checking whatever is forwarded
    into the request handler. We can rely on the framework to do most of the heavy
    lifting here as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于返回和消费 JSON 是一个非常常见的任务，处理函数的变化也是最小的。返回 JSON 有效载荷所需的函数附加到 `HttpResponse` 工厂方法上，该方法执行所有操作，包括设置适当的内容类型。在消费部分，有一个
    `web::Json<T>` 类型来处理将转发到请求处理器的任何内容进行反序列化和检查。我们也可以依赖框架在这里做大部分的重活。
- en: The registering of the handlers in *step 3* is no different from previous recipes;
    the JSON input is only declared in the handler function. There are more variations
    in the `actix-web` docs ([https://actix.rs/docs/request/#json-request](https://actix.rs/docs/request/#json-request))
    and their examples ([https://github.com/actix/examples/tree/master/json](https://github.com/actix/examples/tree/master/json)).
    Similarly, *step 4* contains the required dependencies we have also used in other
    recipes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中注册处理器的操作与之前的菜谱没有不同；JSON 输入仅在处理函数中声明。`actix-web` 文档中有更多变体（[https://actix.rs/docs/request/#json-request](https://actix.rs/docs/request/#json-request)）及其示例（[https://github.com/actix/examples/tree/master/json](https://github.com/actix/examples/tree/master/json)）。同样，*步骤
    4* 包含了我们也在其他菜谱中使用过的必需依赖项。
- en: 'In *step 5*, we run the whole project and see how it works: if we pass JSON,
    the input `content-type` header has to be set to the appropriate mime type (`application/json`);
    the return values have this header set as well (and the `content-length` header)
    so browsers or other programs can easily work with the results.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们运行整个项目并查看其工作情况：如果我们传递 JSON，输入 `content-type` 标头必须设置为适当的 MIME 类型（`application/json`）；返回值也有这个头设置（以及
    `content-length` 头），这样浏览器或其他程序可以轻松地处理结果。
- en: Let's move on and look at another recipe.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，看看另一个菜谱。
- en: Web error handling
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络错误处理
- en: 'The various layers of web services make error handling tricky, even without
    security requirements: what to communicate and when? Should an error bubble up
    only to be handled at the last minute or earlier? What about cascades? In this
    recipe, we will uncover some options to do that elegantly in `actix-web`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务的各个层次使得错误处理变得复杂，即使没有安全要求：应该传达什么以及何时传达？错误是否应该只在最后一刻才冒泡出来处理，还是更早一些？关于级联处理呢？在这个菜谱中，我们将揭示一些在
    `actix-web` 中优雅处理这些问题的方法。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's set up a Rust binary project using `cargo new web-errors`. Since we are
    going to serve stuff on the local port `8081`, make sure that the port is accessible
    as well. Additionally, a program such as `curl` or Postman is required to test
    the web service.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `cargo new web-errors` 设置一个 Rust 二进制项目。由于我们将在本地端口 `8081` 上提供服务，请确保该端口可访问。此外，还需要一个程序，如
    `curl` 或 Postman，来测试网络服务。
- en: Finally, open the entire directory with VS Code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 VS Code 打开整个目录。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You are just a few steps away from understanding error handling with `actix-web`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需几个步骤就能理解 `actix-web` 的错误处理：
- en: 'In `src/main.rs`, we are going to add the basic imports:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中，我们将添加基本的导入：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As a next step, we are going to define our error types and augment them with
    attributes to make the types known to the framework:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为下一步，我们将定义我们的错误类型，并使用属性增强它们，以便框架知道这些类型：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we add the handler function to `src/main.rs` and register it in `main()`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将处理函数添加到 `src/main.rs` 中，并在 `main()` 中注册它：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To import the dependencies, we also have to adapt `Cargo.toml`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了导入依赖项，我们还需要调整 `Cargo.toml`：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To finish this recipe, let''s see how everything works together with `cargo
    run` and `curl`. Here is the server output after the requests have been handled:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个配方，让我们看看如何使用 `cargo run` 和 `curl` 一起工作。以下是请求处理后的服务器输出：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is what the requests look like with `curl`''s verbose mode:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用 `curl` 的详细模式显示的请求示例：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Requesting the wrong ID returns an appropriate HTTP status code as well:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请求错误的 ID 会返回适当的 HTTP 状态代码：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Just as expected, a request to `/underconstruction` yields an HTTP 500 error
    (internal server error):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，对 `/underconstruction` 的请求返回 HTTP 500 错误（内部服务器错误）：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since that worked well, let's see how it works.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这工作得很好，让我们看看它是如何工作的。
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`actix-web` uses an error trait to convert Rust errors into `HttpResponses`.
    This trait is automatically implemented for a range of default errors but only
    by responding with the default *Internal Server Error* message.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`actix-web` 使用一个错误特性和将 Rust 错误转换为 `HttpResponses`。这个特性和默认错误自动实现，但只响应默认的 *内部服务器错误*
    消息。'
- en: In *step 1* and *step 2*, we are setting up custom errors so that we can return
    messages that are relevant to what the user is currently doing (or trying to do).
    As with other errors (see [Chapter 5](898e8c94-b6e0-41d4-a06a-6fd95fb88466.xhtml),
    *Handling Errors and Other Results*), we are using enums to provide an umbrella
    to match error variations to. Each of the variants is augmented with an attribute
    that provides a corresponding error message with a format string—an ability provided
    by the `failure` crate ([https://crates.io/crates/failure](https://crates.io/crates/failure)).
    The message here is a last-resort type message for a response code 500 (the default).
    This HTTP response code, along with the body of the error—such as an HTML page—can
    be customized by implementing the `actix_web::error::ResponseError` trait. Whichever
    `HttpResponse` is supplied using the `error_response()` function will be returned
    to the client.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 和 *步骤 2* 中，我们正在设置自定义错误，以便我们可以返回与用户当前正在执行的操作（或尝试执行的操作）相关的消息。与其他错误一样（见[第
    5 章](898e8c94-b6e0-41d4-a06a-6fd95fb88466.xhtml)，*处理错误和其他结果*），我们使用枚举来提供一个伞状结构，以便将错误变体匹配起来。每个变体都增加了一个属性，它提供了一个带有格式字符串的相应错误消息——这是由
    `failure` crate（[https://crates.io/crates/failure](https://crates.io/crates/failure)）提供的功能。这里的消息是针对响应代码
    500（默认值）的最后一招类型消息。这个 HTTP 响应代码，连同错误体（如 HTML 页面）一起，可以通过实现 `actix_web::error::ResponseError`
    特性进行自定义。使用 `error_response()` 函数提供的任何 `HttpResponse` 都将返回给客户端。
- en: If you call the function yourself, then the `#[fail(display="...")]` message
    won't be attached. Always use Rust's `Result` enum to communicate errors to `actix_web`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您自己调用该函数，则不会附加 `#[fail(display="...")]` 消息。始终使用 Rust 的 `Result` 枚举将错误传达给 `actix_web`。
- en: '*Step 3* defines the handler functions of the web service and, since it uses
    a JSON response, a struct for serializing the information. In this example, we
    are also using the arbitrary number 10 as a cutoff point for returning an error—using
    a Rust `Result` enum. This provides a framework-agnostic way to handle bad outcomes
    just as if we were working with plain Rust. The second route, `/underconstruction`,
    provides an insight into how `actix-web` routes can be implemented: as a closure.
    Since this immediately returns an error, we have to explicitly tell the compiler
    about the return types and that it''s a `Result` enum that could either be `HttpResponse`
    or `WebError`. We then directly return the latter. *Step 4* shows the required
    dependencies and tells us we have to include the failure crate. In the last step,
    we are running the code and testing it by issuing `curl` requests and checking
    the logs on the server side. That''s nothing too complex, right? If you want to
    go deeper, also check out the `actix-web` docs ([https://actix.rs/docs/errors/](https://actix.rs/docs/errors/)).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 3 步* 定义了 web 服务的处理函数，并且由于它使用 JSON 响应，因此需要一个用于序列化信息的结构体。在这个例子中，我们还在使用任意数字
    10 作为返回错误的截止点——使用 Rust 的 `Result` 枚举。这提供了一个框架无关的方式来处理不良结果，就像我们使用纯 Rust 一样。第二个路由
    `/underconstruction` 展示了 `actix-web` 路由的实现方式：作为一个闭包。由于它立即返回一个错误，我们必须明确告诉编译器返回类型以及它是一个可能返回
    `HttpResponse` 或 `WebError` 的 `Result` 枚举。然后我们直接返回后者。*第 4 步* 展示了所需的依赖项，并告诉我们必须包含
    failure crate。在最后一步，我们运行代码并通过发出 `curl` 请求来测试它，并检查服务器端的日志。这并不复杂，对吧？如果您想深入了解，也可以查看
    `actix-web` 文档 ([https://actix.rs/docs/errors/](https://actix.rs/docs/errors/))。'
- en: Let's move on to the next recipe.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个步骤。
- en: Rendering HTML templates
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染 HTML 模板
- en: While JSON is a very human-readable format and easy to work with, many people
    still prefer a more interactive experience—such as websites. While this is not
    native to `actix-web`, some template engines provide seamless integration to minimize
    the calls required to assemble and output HTML. The major difference compared
    to simply delivering a static site is that template engines render variable output
    and Rust code into an augmented HTML page to produce content adapted to whatever
    the application's state is. In this recipe, we are taking a look at **Yet Another
    Rust Template Engine** (**Yarte**) ([https://crates.io/crates/yarte](https://crates.io/crates/yarte)) and
    its integration with `actix-web`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JSON 是一个非常易于阅读且易于处理的格式，但许多人仍然更喜欢更互动的体验——例如网站。虽然这并不是 `actix-web` 的原生功能，但一些模板引擎提供了无缝集成，以最小化组装和输出
    HTML 所需的调用。与简单地提供静态网站相比，主要区别在于模板引擎将变量输出和 Rust 代码渲染到增强的 HTML 页面中，以产生适应应用程序状态的任何内容。在本步骤中，我们将查看
    **另一个 Rust 模板引擎**（**Yarte**）([https://crates.io/crates/yarte](https://crates.io/crates/yarte))
    与 `actix-web` 的集成。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a Rust binary project using `cargo new html-templates` and make sure
    that port `8081` is accessible from the localhost. After creating the project
    directory, you''ll have to create some additional folders and files. The image
    files inside the static directory can be any image, as long as there is a Base64-encoded
    version of it available as a text file. Use an online service or the Base64 binary
    ([https://linux.die.net/man/1/base64](https://linux.die.net/man/1/base64) on Linux)
    to create your own (you''ll have to change the names in the code accordingly)
    or use ours from the repository. The `.hbs` files will be filled (created) in
    this recipe:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cargo new html-templates` 创建一个 Rust 二进制项目，并确保本地主机可以访问端口 `8081`。在创建项目目录后，您还需要创建一些额外的文件夹和文件。静态目录内的图像文件可以是任何图像，只要有一个
    Base64 编码的版本作为文本文件即可。您可以使用在线服务或 Linux 上的 Base64 二进制文件（[https://linux.die.net/man/1/base64](https://linux.die.net/man/1/base64)）来创建自己的（您需要相应地更改代码中的名称）或使用我们仓库中的版本。`.hbs`
    文件将在本步骤中填充（创建）：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, open the entire directory with VS Code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 VS Code 打开整个目录。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create templated web pages in just a few steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个步骤就可以创建模板化的网页：
- en: 'First, let''s add some code to `src/main.rs`. Replace the default snippet with
    the following (note: the Base64-encoded string in `PLACEHOLDER_IMG` is abbreviated
    here. Get the full Base64-encoded image at [https://blog.x5ff.xyz/other/placeholder.b64](https://blog.x5ff.xyz/other/placeholder.b64)):'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向 `src/main.rs` 添加一些代码。用以下内容替换默认片段（注意：`PLACEHOLDER_IMG` 中的 Base64 编码字符串在此处进行了缩写。获取完整的
    Base64 编码图像请访问 [https://blog.x5ff.xyz/other/placeholder.b64](https://blog.x5ff.xyz/other/placeholder.b64)）：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After adjusting `src/main.rs`, add the required dependencies to `Cargo.toml`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整 `src/main.rs` 之后，将所需的依赖项添加到 `Cargo.toml`：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After declaring the templates, we need to register a handler to serve them
    as well:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明模板之后，我们需要注册一个处理程序来提供服务：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'First, let''s add the bookmark data for the recognized user:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为已识别的用户添加书签数据：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For everyone else (unrecognized users), we can simply return an empty vector:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他所有人（未识别的用户），我们可以简单地返回一个空向量：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, let''s start the server in the `main` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在 `main` 函数中启动服务器：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The code is ready, but we still lack templates. This is where we add some content
    to the `.hbs` files. First, let''s add code to `templates/index.hbs`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码已经准备好了，但我们仍然缺少模板。这就是我们在 `.hbs` 文件中添加一些内容的地方。首先，让我们向 `templates/index.hbs`
    添加代码：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After the head, we need an HTML body that marks up the data:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部之后，我们需要一个 HTML 主体来标记数据：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are calling a partial inside this last template, so let''s add some code
    to it as well. Open `templates/partials/bookmark.hbs` and insert the following:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个最后的模板中调用了一个部分，所以让我们也向它添加一些代码。打开 `templates/partials/bookmark.hbs` 并插入以下内容：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It''s time to try this out! Use `cargo run` to start the server logging output
    and open a browser window at `localhost:8081/bookmarks/Hans` as well as `localhost:8081/bookmarks/Claus` to
    see whether it works. Here is what `cargo run` shows after the browser window
    has been opened at the URLs:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候尝试一下了！使用 `cargo run` 启动服务器并记录输出，同时打开浏览器窗口访问 `localhost:8081/bookmarks/Hans`
    以及 `localhost:8081/bookmarks/Claus`，以查看是否正常工作。以下是浏览器窗口在打开这些 URL 后 `cargo run`
    显示的内容：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following are the results for an unrecognized user:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个未识别用户的查询结果：
- en: '![](img/b92368b6-0067-49e0-863f-17be693eb176.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b92368b6-0067-49e0-863f-17be693eb176.png)'
- en: 'For a recognized user, the system returns the appropriate content:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已识别的用户，系统返回适当的内容：
- en: '![](img/ce12f078-f0c7-4980-ae72-957f06fd6698.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce12f078-f0c7-4980-ae72-957f06fd6698.png)'
- en: Let's find out why this works.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出这是为什么。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In many languages, creating a template engine is somewhat like an introduction
    tutorial—which is probably where the name Yarte comes from. While the choices
    are many, `actix-web` provides examples with three other engines as well; we recommend
    checking them out in their GitHub repository ([https://github.com/actix/examples](https://github.com/actix/examples)).
    *Step 1* of this recipe already covers some of the important work: importing stuff
    and declaring the view models (as in the MVVM pattern: [https://blogs.msdn.microsoft.com/msgulfcommunity/2013/03/13/understanding-the-basics-of-mvvm-design-pattern/](https://blogs.msdn.microsoft.com/msgulfcommunity/2013/03/13/understanding-the-basics-of-mvvm-design-pattern/)).
    Yarte provides macro attributes that associate a particular model with a template
    file—and it automatically finds the `templates` folder. If that does not suit
    your project, they allow you to configure the framework accordingly. Find out
    more on their website ([https://yarte.netlify.com/](https://yarte.netlify.com/)).
    We are using a nested model, where the inner struct does not need its own associated
    template.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，创建模板引擎有点像入门教程——这可能是 Yarte 这个名字的由来。虽然选择很多，但 `actix-web` 提供了三个其他引擎的示例；我们建议您在他们的
    GitHub 仓库中查看它们（[https://github.com/actix/examples](https://github.com/actix/examples)）。这个食谱的
    *第一步* 已经涵盖了某些重要的工作：导入内容并声明视图模型（如 MVVM 模式：[https://blogs.msdn.microsoft.com/msgulfcommunity/2013/03/13/understanding-the-basics-of-mvvm-design-pattern/](https://blogs.msdn.microsoft.com/msgulfcommunity/2013/03/13/understanding-the-basics-of-mvvm-design-pattern/)）。Yarte
    提供了宏属性，可以将特定的模型与模板文件关联起来——并且它会自动找到 `templates` 文件夹。如果这不适合您的项目，它们允许您相应地配置框架。更多详情请访问他们的网站（[https://yarte.netlify.com/](https://yarte.netlify.com/)）。我们使用的是嵌套模型，其中内部结构不需要自己的关联模板。
- en: In *step 2*, we are registering the handler function under the `/bookmarks`
    scope and the `/{name}` path, which leads to the URL: `/bookmarks/{name}`. `actix-web`
    is strict in checking the routes, so `/bookmarks/{name}**/**` is going to return
    an error (404). The handler function returns a small list of bookmarks for the
    name Claus but not for anyone else, which—in a more realistic scenario—would come
    out of a database. Regardless, we are using this hardcoded version, and we added
    the logger middleware so we can see what's going on. We are also using a constant
    for the placeholder image, which you can download at [https://blog.x5ff.xyz/other/placeholder.b64](https://blog.x5ff.xyz/other/placeholder.b64).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2步*中，我们在`/bookmarks`作用域下注册了处理函数，并指定了`/{name}`路径，这导致URL：`/bookmarks/{name}`。`actix-web`在检查路由方面非常严格，所以`/bookmarks/{name}**/**`将会返回一个错误（404）。处理函数返回一个包含Claus名字的小书签列表，但不为其他人返回，这在更现实的场景中会从数据库中获取。无论如何，我们使用这个硬编码的版本，并添加了日志中间件，以便我们可以看到发生了什么。我们还使用了一个常量作为占位符图片，您可以在[https://blog.x5ff.xyz/other/placeholder.b64](https://blog.x5ff.xyz/other/placeholder.b64)下载它。
- en: The templates we are defining in *step 3* are the main difference between engines.
    Using the well-known `{{ rust-code }}` notation, we can augment regular HTML to
    generate more sophisticated output. There are loops of all kinds, conditionals,
    variables, and partials. Partials are important because they let you split the
    view parts into reusable components, which don't even have to be HTML/Yarte templates
    but can be any text.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第3步中定义的模板是引擎之间主要的不同之处。使用众所周知的`{{ rust-code }}`符号，我们可以增强常规HTML以生成更复杂的输出。有各种类型的循环、条件、变量和部分。部分之所以重要，是因为它们允许你将视图部分拆分为可重用的组件，这些组件甚至不一定是HTML/Yarte模板，可以是任何文本。
- en: The compilation process pulls in these templates, combining them with the types
    we declared earlier—with an important consequence. Currently, changing the template
    requires the `main.rs` file to be recompiled, reflect the changes, so using touch
    or similar to set the modified date of `src/main.rs` is recommended. After that,
    `cargo` behaves as if there was a change to `src/main.rs`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程将这些模板拉入，将它们与我们之前声明的类型结合起来——有一个重要的后果。目前，更改模板需要重新编译`main.rs`文件，以反映更改，因此建议使用touch或类似的命令来设置`src/main.rs`的修改日期。之后，`cargo`的行为就像`src/main.rs`发生了变化一样。
- en: '*Step 4* implements the partial that shows each bookmark, similarly to the
    index template in *step 3*. Only in *step 5* do we run and look at the results:
    a simple website showing the list of associated bookmarks for when a user is recognized
    (read: has data associated with the name) and when a user is not recognized. The
    minimal design is achieved by using the popular Bootstrap CSS framework ([https://getbootstrap.com](https://getbootstrap.com)).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4步* 实现了显示每个书签的部分，类似于第3步中的索引模板。只有在*第5步*中，我们才会运行并查看结果：一个简单的网站，显示了当用户被识别（即：有与该名称相关联的数据）和当用户未被识别时的相关书签列表。通过使用流行的Bootstrap
    CSS框架（[https://getbootstrap.com](https://getbootstrap.com)），实现了最小化设计。'
- en: Now, let's move on to the next recipe.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱。
- en: Using an ORM to save data to a database
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ORM将数据保存到数据库
- en: 'Opinions about object-relational mappers vary considerably: their use was strongly
    encouraged when SQL databases stored all of the World''s data but they quickly
    fell out of favor when it was actually the whole World''s data. Typically these
    frameworks provide a trade-off between ease of use, language integration, and
    scalability. While it''s true that querying terabytes of data requires a fundamentally
    different approach, simple CRUD-type business applications work well with frameworks
    that do the heavy lifting for you and—most importantly—are somewhat independent
    of the actual database they connect to. Rust''s macros come in very handy here—they
    allow the ORM framework to do these things largely at compile time, so it''s memory-safe,
    type-safe, and fast. Let''s see how it''s done.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象关系映射器的看法差异很大：当SQL数据库存储了世界上所有的数据时，它们的用途被强烈鼓励，但随后当实际上整个世界的数据都如此时，它们很快就失去了青睐。通常这些框架在易用性、语言集成和可扩展性之间提供了一种权衡。虽然查询TB级的数据确实需要一种根本不同的方法，但简单的CRUD型业务应用程序与为你做繁重工作的框架配合得很好，而且——最重要的是——它们与它们连接的实际数据库多少是独立的。Rust的宏在这里非常有用——它们允许ORM框架在编译时做这些事情，因此它是内存安全的、类型安全的，并且速度快。让我们看看它是如何实现的。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a Rust binary project using `cargo new orm` and make sure that port
    `8081` is accessible from the localhost. To access the services, get a program
    such as `curl` or Postman to execute `POST`, `GET`, and more type web requests,
    as well as a program to create and manage SQLite ([https://www.sqlite.org/index.html](https://www.sqlite.org/index.html))
    databases (for example, sqlitebrowser: [https://github.com/sqlitebrowser/sqlitebrowser](https://github.com/sqlitebrowser/sqlitebrowser)).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `cargo new orm` 创建一个 Rust 二进制项目，并确保本地主机可以访问端口 `8081`。要访问服务，获取一个程序，例如 `curl`
    或 Postman，来执行 `POST`、`GET` 以及更多类型的网络请求，以及一个用于创建和管理 SQLite ([https://www.sqlite.org/index.html](https://www.sqlite.org/index.html))
    数据库的程序（例如，sqlitebrowser: [https://github.com/sqlitebrowser/sqlitebrowser](https://github.com/sqlitebrowser/sqlitebrowser))。'
- en: 'Using a SQLite database manager, create a new database, `bookmarks.sqlite`, in
    a folder, `db`. Then, add a table that follows this schema:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQLite 数据库管理器，在 `db` 文件夹中创建一个新的数据库，`bookmarks.sqlite`。然后，添加一个遵循此模式的表：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, we are going to use the `libsqlite3` library and headers in the project.
    On Linux, WSL, and macOS, install the appropriate packages from the package repository.
    On Ubuntu and the WSL, you can use something such as `apt-get install libsqlite3-dev`.
    For other distributions and macOS, please use your preferred package manager to
    install `libsqlite3` and its headers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在项目中使用 `libsqlite3` 库和头文件。在 Linux、WSL 和 macOS 上，从软件包仓库安装适当的软件包。在 Ubuntu
    和 WSL 上，您可以使用类似 `apt-get install libsqlite3-dev` 的命令。对于其他发行版和 macOS，请使用您首选的包管理器安装
    `libsqlite3` 及其头文件。
- en: Native Windows 10 users may have to download the `dll` binaries from [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)
    and place them into the project directory. However, using Linux/macOS is highly
    recommended.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 原生 Windows 10 用户可能需要从 [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)
    下载 `dll` 二进制文件并将它们放入项目目录中。然而，强烈推荐使用 Linux/macOS。
- en: Finally, open the entire directory with VS Code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 VS Code 打开整个目录。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Get your database queries running in just a few steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个步骤就可以运行数据库查询：
- en: 'In `src/main.rs`, we are going to add the basic imports:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中，我们将添加基本的导入：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s set up some more helper types and a constant for the connection string
    in `main.rs`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `main.rs` 中设置一些辅助类型和一个用于连接字符串的常量：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We are going to need some handlers as well, so let''s add them to the file,
    starting with retrieving bookmarks by their IDs:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一些处理器，所以让我们将它们添加到文件中，从通过 ID 获取书签开始：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To find out all IDs, we also want to have a handler that returns all bookmarks:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出所有 ID，我们还想有一个处理器，它返回所有书签：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, let''s see whether we can add some bookmarks:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看是否可以添加一些书签：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'What''s missing for almost full CRUD is the `delete` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎完整的 CRUD（创建、读取、更新、删除）操作还缺少 `delete` 函数：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Lastly, we tie them all together in the `main` function that starts the server
    and attaches these handlers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `main` 函数中将所有这些整合起来，该函数启动服务器并附加这些处理器：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So, where are the models? They are in their own file, `src/models.rs`. Create
    it and add the following content:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，模型在哪里？它们在自己的文件 `src/models.rs` 中。创建它并添加以下内容：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There is still another import that we have not yet created: `src/schema.rs`.
    Create that file as well with the following code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有另一个尚未创建的导入：`src/schema.rs`。同样创建该文件，并添加以下代码：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As usual, we need to adapt `Cargo.toml` to download the dependencies:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，我们需要调整 `Cargo.toml` 以下载依赖项：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This should set everything up to run the web service with `cargo run` and observe
    the logging output (after the requests):'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该设置好一切，以便使用 `cargo run` 运行网络服务并观察日志输出（在请求之后）：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can interact with the web service with `curl`, and here are the expected
    calls and output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `curl` 与网络服务交互，以下是一些预期的调用和输出：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let's see how this works.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`diesel-rs` is Rust''s most well-known database connection framework and provides
    a fast, type-safe, and easy-to-use experience with mapping database tables. This
    is, again, possible thanks to the power of macros, which enable the creation of
    zero-cost abstractions at compile time. However, there is a trade-off for a few
    things and it''s important to learn how to use the framework.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`diesel-rs` 是 Rust 最著名的数据库连接框架，它提供了快速、类型安全和易于使用的体验，用于映射数据库表。这再次得益于宏的强大功能，它能够在编译时创建零成本的抽象。然而，为了实现这一点，我们需要权衡一些事情，并且了解如何使用这个框架是很重要的。'
- en: SQLite does not have a very rigid type system. This is why we get away with
    using a generic type for strings called text. Other databases may have more nuanced
    types. Check out SQLite3 types ([https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html)) for
    more information.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有非常严格的类型系统。这就是为什么我们可以使用一个名为text的泛型类型来使用字符串。其他数据库可能有更细微的类型。查看SQLite3类型（[https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html)）以获取更多信息。
- en: In *step 1*, we are preparing the imports—nothing too interesting but you'll
    notice the declaration of `models.rs` and `schema.rs`. One step further, in *step
    2* we see a connection string (actually just a file path) constant that we'll
    use to connect to the database in the connect function. Additionally, we are making
    a JSON web service so we create the transfer object type, `WebBookmark`. We are
    creating these handlers in *step 3*, one for adding, retrieving (all and by ID),
    and deleting a bookmark entity.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们正在准备导入——没有什么特别有趣的内容，但你会注意到`models.rs`和`schema.rs`的声明。再进一步，在*步骤 2*中，我们看到一个连接字符串（实际上只是一个文件路径）常量，我们将使用它在连接函数中连接到数据库。此外，我们正在创建一个JSON网络服务，因此我们创建了传输对象类型`WebBookmark`。我们在*步骤
    3*中创建这些处理器，一个用于添加、检索（所有和按ID）以及删除书签实体。
- en: All of these handlers return a `Future` object and run asynchronously. While
    handlers always run asynchronously (they are actors), these return the type explicitly
    since they use a synchronous section to connect to the database—`diesel-rs` is
    not thread-safe right now. This synchronous section is implemented using a `web::block`
    statement that returns a result that is mapped onto `Future` and an appropriate
    `HttpResponse` type. In the case of the `bookmarks_add` handler, it returns the
    newly created ID as a JSON string, while `bookmarks_delete` returns the number
    of rows affected by the delete. All of the handlers return a 500 in the case of
    an error.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些处理器都返回一个`Future`对象并异步运行。虽然处理器总是异步运行的（它们是演员），但它们明确返回类型，因为它们使用同步部分连接到数据库——`diesel-rs`目前不是线程安全的。这个同步部分是通过使用`web::block`语句实现的，它返回一个映射到`Future`和适当的`HttpResponse`类型的结果。在`bookmarks_add`处理器的例子中，它返回新创建的ID作为JSON字符串，而`bookmarks_delete`返回删除影响的行数。所有处理器在发生错误时都返回500。
- en: If you want to know how to use connection pooling and properly manage those,
    check out the `actix-web` example for diesel ([https://github.com/actix/examples/tree/master/diesel](https://github.com/actix/examples/tree/master/diesel)).
    It uses Rust's `r2d2` crate ([https://github.com/sfackler/r2d2](https://github.com/sfackler/r2d2)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解如何使用连接池并正确管理它们，请查看`actix-web`示例中的diesel（[https://github.com/actix/examples/tree/master/diesel](https://github.com/actix/examples/tree/master/diesel)）。它使用了Rust的`r2d2`包（[https://github.com/sfackler/r2d2](https://github.com/sfackler/r2d2)）。
- en: '*Step 3* also registers these functions with their respective routes. The `by-id`
    route accepts two different methods (`GET` and `DELETE`) and, thanks to the asynchronous
    nature of the `bookmarks_add` function, the data has to be declared to explicitly
    declare `JsonConfig` to automatically parse JSON input. All of the registrations
    are done using the `to_async` method as well, which makes the attribute method
    impossible to use.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 3*还注册了这些函数及其相应的路由。`by-id`路由接受两种不同的方法（`GET`和`DELETE`），由于`bookmarks_add`函数的异步特性，数据必须显式声明`JsonConfig`以自动解析JSON输入。所有注册都使用`to_async`方法完成，这使得属性方法无法使用。'
- en: Only in *step 4* and *step 5* are we creating `diesel-rs`-specific code. `models.rs`
    is a file that contains all of our models, and both of them are abstractions for
    a row in the table, but the `NewBookmark` type takes care of inserting new objects
    (the `table_name` and `Insertable` attributes attach it to the DSL),  while `Bookmark`
    is returned to the user (diesel's `Queryable` and Serde's `Serialize` enable that).
    `schema.rs` contains a macro call declaring the table name (`bookmarks`), its
    primary key (`id`), and its columns (`id` and `url`) along with their datatypes
    as understood by diesel. There are many more types; check out diesel's in-depth
    explanation of `table!` ([https://diesel.rs/guides/schema-in-depth/](https://diesel.rs/guides/schema-in-depth/)).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在 *步骤 4* 和 *步骤 5* 中，我们才创建 `diesel-rs` 特定的代码。`models.rs` 是一个包含所有我们的模型文件的文件，它们都是表格中行的抽象，但
    `NewBookmark` 类型负责插入新对象（`table_name` 和 `Insertable` 属性将其附加到 DSL），而 `Bookmark`
    则返回给用户（diesel 的 `Queryable` 和 Serde 的 `Serialize` 使之成为可能）。`schema.rs` 包含一个宏调用，声明表名（`bookmarks`）、其主键（`id`）和列（`id`
    和 `url`）及其由 diesel 理解的数据类型。还有许多其他类型；查看 diesel 对 `table!` 的深入解释 ([https://diesel.rs/guides/schema-in-depth/](https://diesel.rs/guides/schema-in-depth/))。
- en: '*Step 6* shows how `diesel-rs` works with different databases; all of them
    are features that have to be declared. Additionally, diesel has a CLI for database
    migrations and other fun stuff, so check out its getting started guide ([https://diesel.rs/guides/getting-started/](https://diesel.rs/guides/getting-started/))
    for more information. In *step 7*, we finally get to run the web service and insert/query
    some of the data.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 6* 展示了 `diesel-rs` 与不同数据库的工作方式；所有这些都是必须声明的功能。此外，diesel 还有一个用于数据库迁移和其他有趣功能的
    CLI，因此请查看其入门指南 ([https://diesel.rs/guides/getting-started/](https://diesel.rs/guides/getting-started/))
    以获取更多信息。在 *步骤 7* 中，我们最终可以运行网络服务并插入/查询一些数据。'
- en: However, let's move on to do more advanced stuff with the ORM framework.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们继续使用 ORM 框架进行更高级的操作。
- en: Running advanced queries using an ORM
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ORM 运行高级查询
- en: One major downside of ORMs is typically the complexity of doing things that
    are outside the happy path. SQL—the language relational databases use—is standardized
    but its types are not always compatible with what the application is doing. In
    this recipe, we'll explore a few ways to run more advanced queries in Rust's `diesel-rs.`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 的一个主要缺点通常是执行非常规路径操作时的复杂性。SQL——关系数据库使用的语言——是标准化的，但其类型并不总是与应用程序所做的工作兼容。在本食谱中，我们将探讨在
    Rust 的 `diesel-rs` 中运行更高级查询的几种方法。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a Rust binary project using `cargo new advanced-orm` and make sure that
    port `8081` is accessible from the localhost. To access the services, get a program
    such as `curl` or Postman to execute `POST`, `GET`, and more type web requests,
    as well as a program to create and manage SQLite ([https://www.sqlite.org/index.html](https://www.sqlite.org/index.html)) databases
    (for example, sqlitebrowser: [https://github.com/sqlitebrowser/sqlitebrowser](https://github.com/sqlitebrowser/sqlitebrowser)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `cargo new advanced-orm` 创建一个 Rust 二进制项目，并确保本地主机可以访问端口 `8081`。要访问服务，可以使用
    `curl` 或 Postman 等程序执行 `POST`、`GET` 等类型的网络请求，以及用于创建和管理 SQLite ([https://www.sqlite.org/index.html](https://www.sqlite.org/index.html))
    数据库的程序（例如，sqlitebrowser: [https://github.com/sqlitebrowser/sqlitebrowser](https://github.com/sqlitebrowser/sqlitebrowser)）。'
- en: You can reuse and expand the code from the previous recipe (*Using an ORM to
    save data to a database*) if you ensure you update the database tables.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确保更新数据库表，则可以重用并扩展前一个食谱（*使用 ORM 将数据保存到数据库中*）中的代码。
- en: 'Using a SQLite database manager, create a new database, `bookmarks.sqlite`, in
    a folder, `db`. Then, add tables that follow these schemas:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQLite 数据库管理器，在文件夹 `db` 中创建一个新的数据库，名为 `bookmarks.sqlite`。然后，添加符合以下模式的表：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, we are going to use the `libsqlite3` library and headers in the project.
    On Linux, WSL, and macOS, install the appropriate packages from the package repository.
    On Ubuntu and the WSL, you can use something like `apt-get install libsqlite3-dev`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在项目中使用 `libsqlite3` 库和头文件。在 Linux、WSL 和 macOS 上，从软件包仓库安装适当的软件包。在 Ubuntu
    和 WSL 上，可以使用类似 `apt-get install libsqlite3-dev` 的命令。
- en: Native Windows 10 users may have to download the `dll` binaries from [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html) and
    place them into the project directory. However, using Linux/macOS is highly recommended.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 原生的 Windows 10 用户可能需要从 [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)
    下载 `dll` 二进制文件并将它们放置到项目目录中。然而，使用 Linux/macOS 被高度推荐。
- en: Finally, open the entire directory with VS Code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 VS Code 打开整个目录。
- en: How to do it...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use templates in just a few steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个步骤就可以使用模板：
- en: '`src/main.rs` is going to contain the handlers and main function. Let''s start
    by adding some helper types and functions:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`src/main.rs`将包含处理程序和主函数。让我们先添加一些辅助类型和函数：'
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After some imports, let''s set up the helpers:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些导入之后，让我们设置辅助工具：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A new handler will fetch bookmarks with a Julian date. Let''s add it along
    with some other, well-known handlers:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的处理程序将检索具有儒略日期的书签。让我们添加它以及一些其他众所周知的处理程序：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Adding bookmarks is one of these well-known handlers:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 添加书签是这些众所周知的处理程序之一：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, deleting bookmarks is an important handler:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，删除书签是一个重要的处理程序：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that we can add and delete comments and bookmarks, all we have to do is
    fetch them all at once:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们能够添加和删除评论和书签，我们只需要一次性检索它们：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Lastly, we wire everything up in `main()`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`main()`中连接一切：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To save comments alongside bookmarks, we had to expand the schema and models
    as well. Create (or edit) `src/schema.rs` with the following content:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将评论与书签一起保存，我们不得不扩展模式和模型。使用以下内容创建（或编辑）`src/schema.rs`：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, create or update `src/models.rs` to create the Rust representation of
    these types:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建或更新`src/models.rs`以创建这些类型的Rust表示：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To import the dependencies, we also have to adapt `Cargo.toml`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了导入依赖项，我们还需要调整`Cargo.toml`：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To finish this recipe, let''s see how everything works together with `cargo
    run` and `curl`. The requests should respond in line with the following logging
    output:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，让我们看看如何使用`cargo run`和`curl`一起工作。请求应该按照以下日志输出做出响应：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here are the server logs generated by the requests, printed to the Terminal
    that `cargo run` runs in:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是请求生成的服务器日志，打印到`cargo run`运行的终端中：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Behind the scenes, a lot is going on. Let's find out what.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，有很多事情在进行。让我们找出发生了什么。
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Working with `diesel-rs` requires a good understanding of how it works internally
    to achieve the desired results. Check out the previous recipe (*Using an ORM to
    save data to a database*) for some details on the basics. In this recipe, we are
    diving straight into the more advanced stuff.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`diesel-rs`需要很好地理解其内部工作原理，以实现预期的结果。查看之前的食谱（*使用ORM将数据保存到数据库中*）以了解基础知识的一些细节。在这个食谱中，我们直接深入更高级的内容。
- en: 'After some basic setup in *step 1*, *step 2* creates a new handler that fetches
    all bookmarks added on a particular day and returns the date as a Julian date
    ([https://en.wikipedia.org/wiki/Julian_day](https://en.wikipedia.org/wiki/Julian_day)).
    The calculation is done using one of SQLite''s few scalar functions: `juliandate()` ([https://www.sqlite.org/lang_datefunc.html](https://www.sqlite.org/lang_datefunc.html)).
    So, how did we get the function into Rust? *Step 4* shows the `diesel-rs` way:
    by using a `sql_function!` macro ([https://docs.diesel.rs/diesel/macro.sql_function.html](https://docs.diesel.rs/diesel/macro.sql_function.html))
    that maps the data types and output appropriately. Since we are mapping a pre-existing
    function here, there are no further steps required (this should work the same
    for stored procedures).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*的一些基本设置之后，*步骤2*创建了一个新的处理程序，该处理程序检索特定日期添加的所有书签，并返回儒略日期（[https://en.wikipedia.org/wiki/Julian_day](https://en.wikipedia.org/wiki/Julian_day)）。计算是使用SQLite的几个标量函数之一：`juliandate()`（[https://www.sqlite.org/lang_datefunc.html](https://www.sqlite.org/lang_datefunc.html)）。那么，我们是如何将这个函数引入Rust的呢？*步骤4*展示了`diesel-rs`的方式：通过使用`sql_function!`宏（[https://docs.diesel.rs/diesel/macro.sql_function.html](https://docs.diesel.rs/diesel/macro.sql_function.html)）来适当地映射数据类型和输出。由于我们在这里映射的是一个预存在的函数，因此不需要进一步的操作（这应该与存储过程相同）。
- en: 'Another aspect that *step 2* covers is inserting into and deleting from multiple
    tables, which is easy thanks to SQLite''s disabled referential integrity constraint
    ([https://www.w3resource.com/sql/joins/joining-tables-through-referential-integrity.php](https://www.w3resource.com/sql/joins/joining-tables-through-referential-integrity.php)).
    If this constraint is enforced, take a look at the `diesel-rs` transactions ([https://docs.diesel.rs/diesel/connection/trait.Connection.html#method.transaction](https://docs.diesel.rs/diesel/connection/trait.Connection.html#method.transaction)).
    *Step 3* goes on to show how to retrieve this data—using a left outer join. Left
    joins take every row from the left side (`bookmarks` if the join looks as follows: `bookmarks
    LEFT JOIN comments`) and try to match it to rows in the table on the right, which
    means we get every bookmark regardless of whether they have comments or not. To
    map this result set, we have to provide a corresponding data type to parse to,
    which `diesel-rs` expects to be `(Bookmark, Option<Comment>)`. Since the `left_join()`
    call does not mention which columns to join on, how does the framework know? Again,
    in *step 4*, we declare the two tables as `joinable` via two macros: `joinable`
    ([https://docs.diesel.rs/diesel/macro.joinable.html](https://docs.diesel.rs/diesel/macro.joinable.html))
    and `allow_tables_to_appear_in_same_query` ([https://docs.diesel.rs/diesel/macro.allow_tables_to_appear_in_same_query.html](https://docs.diesel.rs/diesel/macro.allow_tables_to_appear_in_same_query.html)). After
    the results are fetched, we map them to a `Serializable` combined type to hide
    this implementation detail from the user.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2**涵盖的另一个方面是向多个表插入和从多个表删除，这得益于SQLite禁用的引用完整性约束（[https://www.w3resource.com/sql/joins/joining-tables-through-referential-integrity.php](https://www.w3resource.com/sql/joins/joining-tables-through-referential-integrity.php)）。如果此约束被强制执行，请查看`diesel-rs`事务（[https://docs.diesel.rs/diesel/connection/trait.Connection.html#method.transaction](https://docs.diesel.rs/diesel/connection/trait.Connection.html#method.transaction)）。**步骤
    3**继续展示如何检索这些数据——使用左外连接。左连接从左侧（如果连接看起来如下：`bookmarks LEFT JOIN comments`则为`bookmarks`）的每一行开始，并尝试与右侧表中的行匹配，这意味着无论是否有评论，我们都会得到每个书签。为了映射这个结果集，我们必须提供一个相应的数据类型来解析，`diesel-rs`期望这个类型是`(Bookmark,
    Option<Comment>)`。由于`left_join()`调用没有提到要连接哪些列，框架是如何知道的？再次，在**步骤 4**中，我们通过两个宏声明这两个表为`joinable`：`joinable`（[https://docs.diesel.rs/diesel/macro.joinable.html](https://docs.diesel.rs/diesel/macro.joinable.html)）和`allow_tables_to_appear_in_same_query`（[https://docs.diesel.rs/diesel/macro.allow_tables_to_appear_in_same_query.html](https://docs.diesel.rs/diesel/macro.allow_tables_to_appear_in_same_query.html)）。结果检索后，我们将它们映射到一个`Serializable`组合类型，以隐藏从用户那里隐藏这个实现细节。'
- en: Only in *step 4* and *step 5* do we take care of mapping out the database tables
    and rows for diesel—nothing too surprising here. The `Queryable` attribute is
    important for `diesel-rs` to map tuples to types—regardless of the actual table.
    For more ad hoc queries, we could work with tuples directly as well. *Step 6*
    takes care of the dependencies.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在**步骤 4**和**步骤 5**中，我们才负责绘制柴油数据库表和行的映射——这里没有什么令人惊讶的。`Queryable`属性对于`diesel-rs`将元组映射到类型非常重要——无论实际表是什么。对于更具体的查询，我们也可以直接与元组一起工作。**步骤
    6**负责处理依赖关系。
- en: '*Step 7* runs the server and avid readers will have noticed one thing: compilation
    takes longer than usual. We suspect that `diesel-rs` is doing a lot of work behind
    the scenes, creating type-safe code to keep the dynamic runtime overhead low.
    However, this may significantly factor into bigger projects, but once compiled,
    the types help to avoid errors and make the service work smoothly.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 7**运行服务器，细心的读者会注意到一件事：编译时间比平时长。我们怀疑`diesel-rs`在幕后做了很多工作，创建了类型安全的代码，以保持动态运行时开销低。然而，这可能会显著影响更大的项目，但一旦编译，类型有助于避免错误并使服务顺利运行。'
- en: We formatted the `curl` output to make it more readable and the output works
    just as expected. `serde` provides consistent serialization and deserialization
    of JSON objects; thus, the `comment` field is optional on input but is rendered
    as `null` on output.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们格式化了`curl`输出，使其更易于阅读，并且输出工作正如预期。`serde`提供了JSON对象的持续序列化和反序列化；因此，输入时`comment`字段是可选的，但在输出时呈现为`null`。
- en: While `diesel-rs` tries to abstract many database operations, it uses a `sql_query`
    interface ([https://docs.diesel.rs/diesel/fn.sql_query.html](https://docs.diesel.rs/diesel/fn.sql_query.html))
    to work with other SQL statements as well. However, more complex group by aggregations
    are not yet supported—even in the raw SQL interface—which is unfortunate. You
    can follow the progress on GitHub ([https://github.com/diesel-rs/diesel/issues/210](https://github.com/diesel-rs/diesel/issues/210)).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `diesel-rs` 尝试抽象许多数据库操作，但它使用 `sql_query` 接口（[https://docs.diesel.rs/diesel/fn.sql_query.html](https://docs.diesel.rs/diesel/fn.sql_query.html)）与其他
    SQL 语句一起工作。然而，更复杂的分组聚合操作尚不支持——即使在原始 SQL 接口中——这是令人遗憾的。您可以在 GitHub 上跟踪进度（[https://github.com/diesel-rs/diesel/issues/210](https://github.com/diesel-rs/diesel/issues/210)）。
- en: Now that we know more about running queries with `diesel-rs`, let's move on
    to the next recipe.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对使用 `diesel-rs` 运行查询有了更多了解，让我们继续下一个菜谱。
- en: Authentication on the web
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络上的身份验证
- en: Running web services safely on public interfaces is itself challenge and a lot
    of things need to be taken care of. While many details fall within the job description
    of a security engineer, developers should adhere to at least a minimum set of
    best practices so they rightfully earn the trust of their users. At the start,
    there is transport encryption (TLS), which is something we did not include in
    any recipes in this chapter since reverse proxies and load balancers provide amazing
    and simple integration for this (and let's encrypt: [https://letsencrypt.org/](https://letsencrypt.org/) provides
    free certificates). This chapter focuses on using the `actix-web` middleware infrastructure
    to authenticate requests via JWT ([https://jwt.io/](https://jwt.io/)) at the application
    layer.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共接口上安全地运行网络服务本身就是一项挑战，需要考虑很多事情。虽然许多细节属于安全工程师的工作描述，但开发人员应至少遵守一组最佳实践，以便他们能够赢得用户的信任。一开始，是传输加密（TLS），由于反向代理和负载均衡器提供了惊人的简单集成（以及
    let's encrypt：[https://letsencrypt.org/](https://letsencrypt.org/) 提供免费证书），我们在这个章节中没有包含任何菜谱。本章重点介绍使用
    `actix-web` 中间件基础设施在应用层通过 JWT ([https://jwt.io/](https://jwt.io/)) 验证请求。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a Rust binary project using `cargo new authentication` and make sure
    that port `8081` is accessible from the localhost. To access the services, get
    a program such as `curl` or Postman to execute `POST`, `GET`, and more type web
    requests.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cargo new authentication` 创建一个 Rust 二进制项目，并确保端口 `8081` 可以从本地主机访问。要访问服务，获取一个程序，如
    `curl` 或 Postman，以执行 `POST`、`GET` 和更多类型的网络请求。
- en: Finally, open the entire directory with VS Code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 VS Code 打开整个目录。
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Authenticate your users in just a few steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个步骤即可验证用户身份：
- en: 'In `src/main.rs`, we start by declaring the required imports:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中，我们首先声明所需的导入：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With that out of the way, we can take care of the more relevant bits. Let''s
    declare a few basics for authentication and a handler that we want to access:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理完这些之后，我们可以关注更相关的部分。让我们声明一些用于身份验证和处理程序的基本内容，我们想要访问：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we need a handler to log users in and create the token if they provide
    the expected password, as well as the `main()` function to set everything up:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个处理程序来登录用户并在他们提供预期的密码时创建令牌，以及设置一切的 `main()` 函数：
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `wrap()` call in the `main()` function already gives away some details—we
    are going to need middleware to take care of authentication. Let''s create a new
    file, `src/middlewares.rs`, with the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()` 函数中的 `wrap()` 调用已经透露了一些细节——我们需要中间件来处理身份验证。让我们创建一个新文件，`src/middlewares.rs`，并包含以下代码：'
- en: '[PRE67]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the code in *step 4*, we see another struct that needs implementation: `JwtLoginMiddleware`.
    Let''s add it to `src/middlewares.rs`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 的代码中，我们看到另一个需要实现的 struct：`JwtLoginMiddleware`。让我们将其添加到 `src/middlewares.rs`：
- en: '[PRE68]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The most important code can be found in the call function implementation where
    the request is passed through to apply the middleware (and authenticate the token):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的代码可以在调用函数实现中找到，其中请求通过应用中间件（并验证令牌）传递：
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Before we can run the server, we also have to update `Cargo.toml` with the
    current dependencies:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以运行服务器之前，我们还需要更新 `Cargo.toml` 以包含当前依赖项：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Exciting—let''s try it out! Start the server with `cargo run` and issue some
    `curl` requests:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激动人心的——让我们试试吧！使用 `cargo run` 启动服务器并发出一些 `curl` 请求：
- en: '[PRE71]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The following is the `curl` output for each request. First, the unauthorized
    request:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对每个请求的 `curl` 输出。首先，未授权的请求：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we try to log in using an invalid password:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试使用无效的密码登录：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, we use the real password and receive a token back:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用真实密码并接收一个令牌回来：
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'With this token in the `authorization` header ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization)),
    we can then access the secret resource:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `authorization` 标头 ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization))
    中包含此令牌后，我们就可以访问秘密资源：
- en: '[PRE75]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Let's pull back the curtain and see how it works.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们揭开面纱，看看它是如何工作的。
- en: How it works...
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'JWTs are a great way to provide authentication combined with authorization
    in a web application. As demonstrated on the official website, a JWT consists
    of three parts:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 是在 Web 应用程序中提供身份验证和授权的绝佳方式。正如官方网站所示，JWT 由三部分组成：
- en: The header, providing meta-information about the token
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题，提供关于标记的元信息
- en: Its payload, which is where the information is sent (JSON-serialized)
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其负载，即信息被发送的地方（JSON 序列化）
- en: A signature to guarantee that the token wasn't changed in transport
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个签名来保证令牌在传输过程中未被更改
- en: These parts are Base64-encoded and joined with `.` to form a single string.
    This string is put into the `authorization` header of an HTTP request ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization)).
    One important remark is that TLS is mandatory for this kind of authentication
    since the headers as well as everything else are sent in plaintext—everyone would
    be able to see the token.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分是 Base64 编码的，并用 `.` 连接成一个字符串。这个字符串被放入 HTTP 请求的 `authorization` 标头 ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization))
    中。一个重要的注意事项是，对于这种身份验证，TLS 是强制性的，因为标头以及所有其他内容都是以明文发送的——每个人都能看到令牌。
- en: 'The payload can contain anything you wish to carry back and forth as user information.
    However, there are special fields as well: `iss`, `sub`, and `exp`. `iss` provides
    the issuer''s credentials (in whichever way), `sub` is the subject, and `exp`
    is the expiration timestamp. This is because JWTs can be used to authenticate
    via federation, that is, third-party services, as well. For this implementation,
    we are using a crate called `jsonwebtoken` ([https://github.com/Keats/jsonwebtoken](https://github.com/Keats/jsonwebtoken)).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 负载数据可以包含您希望携带来回的用户信息。然而，也有一些特殊字段：`iss`、`sub` 和 `exp`。`iss` 提供了发行者的凭证（以任何方式），`sub`
    是主题，而 `exp` 是过期时间戳。这是因为 JWT 可以用于通过联盟进行身份验证，即第三方服务。对于此实现，我们使用一个名为 `jsonwebtoken`
    的 crate ([https://github.com/Keats/jsonwebtoken](https://github.com/Keats/jsonwebtoken))。
- en: 'In *step 1*, we are simply setting up the imports—nothing special here. Only
    *step 2* provides something interesting: a hardcoded password (**BAD** security
    practice, but good enough for demonstration) as well as a hardcoded secret (also
    **BAD**). Real applications can use a secret store for the secret (for example,
    Azure Key Vault: [https://azure.microsoft.com/en-in/services/key-vault/](https://azure.microsoft.com/en-in/services/key-vault/))
    and a hash stored in a database for the password. In the same step, we are also
    declaring the input data structure for logging in—we care only about the password—as
    well as the handler for the path/secret, which should only work once we are logged
    in.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们只是设置导入——这里没有什么特别之处。只有 *步骤 2* 提供了一些有趣的内容：一个硬编码的密码（**不良**的安全实践，但足以用于演示）以及一个硬编码的秘密（也是
    **不良**）。真实的应用程序可以使用秘密存储库来存储秘密（例如，Azure Key Vault：[https://azure.microsoft.com/en-in/services/key-vault/](https://azure.microsoft.com/en-in/services/key-vault/))，并在数据库中存储密码的散列。在相同的步骤中，我们还声明了登录的输入数据结构——我们只关心密码——以及路径/秘密的处理程序，它应该在登录后才能工作。
- en: 'The following step creates the handler for logging in: if the password matches,
    the handler creates a new token containing the payload data (a struct called `Claims`)
    and the HMAC ([https://searchsecurity.techtarget.com/definition/Hash-based-Message-Authentication-Code-HMAC](https://searchsecurity.techtarget.com/definition/Hash-based-Message-Authentication-Code-HMAC)) algorithm
    (HS256 by default) used to sign the token, and returns it. The handlers are then
    registered with the `App` instance, together with the new JWT authentication middleware
    implemented in the following steps.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤创建登录处理程序：如果密码匹配，处理程序将创建一个新的包含有效载荷数据（一个名为 `Claims` 的结构体）和用于签名令牌的 HMAC（默认为
    HS256）算法的令牌，并将其返回。然后，处理程序与 `App` 实例一起注册，包括在以下步骤中实现的新的 JWT 认证中间件。
- en: '*Step 4* and *step 5* take care of creating the middleware for validating JWT
    tokens. *Step 4* contains the `Claims` type mentioned previously; however, the
    rest of the code is a largely required boilerplate if the request and response
    types remains default. If we wanted to retrieve user information to pass to the
    handlers, we would look into defining custom requests. Only in *step 5* are we
    implementing the important part: the `call()` function. This function is called
    before every request is processed and decides whether to continue or stop propagating
    it. Obviously, the `/login` route is the exception and will always be passed on
    the handlers.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 4 步* 和 *第 5 步* 负责创建用于验证 JWT 令牌的中间件。*第 4 步* 包含之前提到的 `Claims` 类型；然而，如果请求和响应类型保持默认，则其余代码主要是必需的样板代码。如果我们想检索用户信息传递给处理程序，我们将考虑定义自定义请求。只有在
    *第 5 步* 中，我们才实现重要的部分：`call()` 函数。这个函数在每次请求处理之前被调用，并决定是否继续或停止传播它。显然，`/login` 路由是例外，总是会传递给处理程序。'
- en: 'Every other route has to contain a header field called `authorization` and
    a type called `Bearer`, along with the token, for example, (truncated) `authorization:
    Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJ[...]8wcyELavx-c`. The `call()` function extracts
    the token and tries to decode it with its secret. If that works, the call is forwarded
    to the handler; if not, the user is clearly not authorized to access the resource—the
    same happens if there is no authorization header at all. `jsonwebtoken` validates
    the `exp` field by default as well (our `Claims` type does not have this), which
    is what we are turning off for this example. For brevity, we used `unwrap()` when
    parsing the header''s bytes into a string. However, this can crash the thread
    if unknown bytes are encountered.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '每个其他路由都必须包含一个名为 `authorization` 的头字段和一个名为 `Bearer` 的类型，以及令牌，例如，（截断）`authorization:
    Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJ[...]8wcyELavx-c`。`call()` 函数提取令牌并尝试使用其密钥对其进行解码。如果成功，则将调用传递给处理程序；如果不成功，则用户显然无权访问资源——如果没有授权头也会发生这种情况。`jsonwebtoken`
    默认验证 `exp` 字段（我们的 `Claims` 类型没有这个），这就是我们在这个示例中关闭的原因。为了简洁起见，我们在解析头字节的字符串时使用了 `unwrap()`。然而，如果遇到未知字节，这可能会使线程崩溃。'
- en: The return types here are imported from the `futures` library ([https://docs.rs/futures/](https://docs.rs/futures/)) and
    provide the `Either` type ([https://docs.rs/futures/0.1.28/futures/future/enum.Either.html](https://docs.rs/futures/0.1.28/futures/future/enum.Either.html))
    as well as the `ok()` function ([https://docs.rs/futures/0.1.28/futures/future/fn.ok.html](https://docs.rs/futures/0.1.28/futures/future/fn.ok.html)).
    Check their documentation to learn more.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里返回的类型是从 `futures` 库（[https://docs.rs/futures/](https://docs.rs/futures/)）导入的，并提供
    `Either` 类型（[https://docs.rs/futures/0.1.28/futures/future/enum.Either.html](https://docs.rs/futures/0.1.28/futures/future/enum.Either.html)）以及
    `ok()` 函数（[https://docs.rs/futures/0.1.28/futures/future/fn.ok.html](https://docs.rs/futures/0.1.28/futures/future/fn.ok.html)）。查看它们的文档以了解更多信息。
- en: '*Step 6* simply declares the additional dependencies, and in *step 7*, we get
    to run the server! Check the `curl` requests first—can you see what''s off? Requests
    without authorization are blocked *before* logging happens. Additionally, we have
    marked the important bits in bold.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 6 步* 仅声明额外的依赖项，而在 *第 7 步* 中，我们可以运行服务器！首先检查 `curl` 请求——你能看到什么问题吗？在记录发生之前，阻止未经授权的请求。此外，我们已用粗体标记了重要部分。'
- en: 'This concludes this chapter. We hope you enjoyed the web programming recipes.
    The next chapter covers something a lot closer to the metal: systems programming.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这一章。我们希望您喜欢网络编程食谱。下一章将涵盖更接近底层的内容：系统编程。
