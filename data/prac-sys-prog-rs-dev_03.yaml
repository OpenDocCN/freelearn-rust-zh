- en: '*Chapter 2*: A Tour of the Rust Programming Language'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：Rust 编程语言之旅'
- en: In the previous chapter, we looked at the Rust tooling ecosystem for build and
    dependency management, testing, and documentation. These are critical and highly
    developer-friendly tools that give us a strong foundation for starting to work
    on Rust projects. In this chapter, we will build a working example that will serve
    to act as a refresher, and also strengthen key Rust programming concepts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Rust 工具生态系统，包括构建和依赖管理、测试和文档。这些是关键且高度开发者友好的工具，为我们开始 Rust 项目提供了坚实的基础。在本章中，我们将构建一个工作示例，它将作为复习之用，并加强关键
    Rust 编程概念。
- en: The goal of this chapter is to get more proficient in core Rust concepts. This
    is essential before diving into the specifics of systems programming in Rust.
    We will achieve this by designing and developing a **command-line interface**
    (**CLI**) in Rust.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是提高对核心 Rust 概念的熟练程度。在深入 Rust 系统编程的细节之前，这是必不可少的。我们将通过设计和开发一个 **命令行界面** (**CLI**)
    来实现这一点。
- en: The application we will be building is an **arithmetic expression evaluator**.
    Since this is a mouthful, let's see an example.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序是一个 **算术表达式评估器**。由于这个名字有点长，让我们看看一个例子。
- en: 'Let''s assume the user enters the following arithmetic expression on the command
    line:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户在命令行中输入以下算术表达式：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The tool will print out the result **21.79**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 工具将打印出结果 **21.79**。
- en: For the user, it appears to be a calculator, but there is a lot involved to
    implement this. This example project will introduce you to the core computer science
    concepts used in parsers and compiler design. It is a non-trivial project that
    allows us to test the depths of core Rust programming, but is not so overly complex
    that it will intimidate you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，它看起来像是一个计算器，但实现它涉及很多内容。这个示例项目将向您介绍解析器和编译器设计中使用的核心计算机科学概念。这是一个非平凡的工程，它允许我们测试核心
    Rust 编程的深度，但又不至于过于复杂，让您感到畏惧。
- en: Before you continue reading, I would recommend that you clone the code repository,
    navigate to the `chapter2` folder, and execute the `cargo run` command. At the
    command-line prompt, enter a few arithmetic expressions and see the results returned
    by the tool. You can exit the tool with *Ctrl* + *C*. This would give you a better
    appreciation for what you are going to build in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，我建议您克隆代码仓库，导航到 `chapter2` 文件夹，并执行 `cargo run` 命令。在命令行提示符下，输入几个算术表达式，并查看工具返回的结果。您可以使用
    *Ctrl* + *C* 退出工具。这将使您更好地理解本章将要构建的内容。
- en: 'The following are the key learning steps for this chapter, which correspond
    to the various stages of building our project:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为本章定义的关键学习步骤，它们对应于构建我们项目的各个阶段：
- en: Analyzing the problem domain
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析问题域
- en: Modeling system behavior
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模系统行为
- en: Building the tokenizer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建分词器
- en: Building the parser
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建解析器
- en: Building the evaluator
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建评估器
- en: Dealing with errors
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误
- en: Building a command-line application
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建命令行应用程序
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should have Rustup and Cargo installed in your local development environment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在本地开发环境中安装 Rustup 和 Cargo。
- en: The GitHub repository for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter02](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter02).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的 GitHub 仓库可以在[https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter02](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter02)找到。
- en: Analyzing the problem domain
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析问题域
- en: In this section, we will define the scope of the project and the technical challenges
    that we need to address.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义项目的范围和我们需要解决的技术挑战。
- en: Understanding and analyzing the problem domain is the first step in building
    any system. It is important to unambiguously articulate the problem we are trying
    to solve, and the boundaries of the system. These can be captured in the form
    of system requirements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和分析问题域是构建任何系统的第一步。明确阐述我们试图解决的问题和系统的边界非常重要。这些可以以系统需求的形式捕捉。
- en: Let's look at the requirements for the CLI tool we are going to build.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将要构建的 CLI 工具的要求。
- en: The tool should accept an arithmetic expression as input, evaluate it, and provide
    the numerical output as a floating-point number. For example, the expression *1+2*3.2+(4/2-3/2)-2.11+2^4*
    should evaluate to *21.79*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 工具应接受一个算术表达式作为输入，评估它，并以浮点数的形式提供数值输出。例如，表达式 *1+2*3.2+(4/2-3/2)-2.11+2^4* 应评估为
    *21.79*。
- en: The arithmetic operations in scope are **addition** (**+**), **subtraction**
    (**-**), **multiplication** (*****), **division** (**/**), **power** (**^**),
    the **negative prefix** (**-**), and expressions enclosed in **parentheses** **()**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 范围内的算术运算包括**加法**（**+**）、**减法**（**-**）、**乘法**（*****）、**除法**（**/**）、**幂**（**^**）、**负号前缀**（**-**）以及括号内的表达式**()**。
- en: Mathematical functions such as trigonometric and logarithmic functions, absolute,
    square roots, and so on are *not* in scope.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数和对数函数、绝对值、平方根等数学函数**不在**范围内。
- en: 'With such an expression, the challenges that need to be resolved are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的表达式，需要解决的挑战如下：
- en: The user should be able to input an arithmetic expression as *free text* on
    the command line. Numbers, arithmetic operators, and parentheses (if any) should
    be segregated and processed with different sets of rules.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够在命令行上以**自由文本**的形式输入一个算术表达式。数字、算术运算符和括号（如果有）应该分开，并使用不同的规则集进行处理。
- en: The rules of *operator precedence* must be taken into account (for example,
    multiplication takes precedence over addition).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符优先级规则必须被考虑（例如，乘法优先于加法）。
- en: Expressions enclosed within *parentheses ()* must be given *higher precedence*.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号内的表达式必须给予**更高的优先级**。
- en: The user may not give spaces between the number and operator, but still the
    program must be capable of *parsing inputs with or without spaces* between the
    characters.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可能在数字和操作符之间不输入空格，但程序必须能够**解析带有或没有空格的字符输入**。
- en: If numbers contain a *decimal point*, continue reading the rest of the number
    until an operator or parenthesis is encountered.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字包含**小数点**，继续读取数字的其余部分，直到遇到运算符或括号。
- en: '*Invalid inputs* should be dealt with and the program should abort with a suitable
    error message. Here are some examples of invalid input:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无效输入**应该被处理，并且程序应该带合适的错误信息终止。以下是一些无效输入的例子：'
- en: '**Invalid input 1**: Since we don''t deal with variables in this program, if
    a character is entered, the program should exit with a suitable error message
    (for example, *2 ** *a* is invalid input).'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**无效输入 1**：由于我们在这个程序中不处理变量，如果输入了一个字符，程序应带合适的错误信息退出（例如，*2 ** *a* 是无效输入）。'
- en: '**Invalid input 2**: If only a single parenthesis is encountered (without a
    matching closing parenthesis), the program should exit with an error message.'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**无效输入 2**：如果只遇到一个括号（没有匹配的闭合括号），程序应带错误信息退出。'
- en: '**Invalid input 3**: If the arithmetic operator is not recognized, the program
    should exit with an error message.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**无效输入 3**：如果算术运算符不被识别，程序应带错误信息退出。'
- en: There are clearly other types of edge cases that can cause errors. But we will
    focus only on these. The reader is encouraged to implement other error conditions
    as a further exercise.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 显然还有其他类型的边缘情况可能导致错误。但我们只会关注这些。鼓励读者作为进一步练习实现其他错误条件。
- en: Now that we know the scope of what we are going to build, let's design the system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了将要构建的范围，让我们来设计系统。
- en: Modeling the system behavior
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模系统行为
- en: 'In the last section, we confirmed the system requirements. Let''s now design
    the logic for processing the arithmetic expression. The components of the system
    are shown in *Figure 2.1*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们确认了系统需求。现在让我们设计处理算术表达式的逻辑。系统的组件在*图 2.1*中显示：
- en: '![Figure 2.1 – Design of an arithmetic expression evaluator](img/Figure_2.1_B16405.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 算术表达式评估器的设计](img/Figure_2.1_B16405.jpg)'
- en: Figure 2.1 – Design of an arithmetic expression evaluator
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 算术表达式评估器的设计
- en: 'The components shown in the preceding figure work together as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中显示的组件如下协同工作：
- en: The user enters an arithmetic expression at the command-line input and presses
    the *Enter* key.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在命令行输入中输入一个算术表达式并按下**Enter**键。
- en: The user input is scanned in its entirety and stored in a local variable.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入将被整体扫描并存储在局部变量中。
- en: The arithmetic expression (from the user) is scanned. The numbers are stored
    as tokens of the `Numeric` type. Each arithmetic operator is stored as a token
    of that appropriate type. For example, the `+` symbol will be represented as a
    token of type `Add`, and the number `1` will be stored as a token of type `Num`
    with a value of `1`. This is done by the `Lexer` (or `Tokenizer`) module.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从用户那里扫描的算术表达式。数字存储为`Numeric`类型的标记。每个算术运算符都存储为相应类型的标记。例如，`+`符号将表示为类型为`Add`的标记，而数字`1`将存储为类型为`Num`的标记，其值为`1`。这是通过`Lexer`（或`Tokenizer`）模块完成的。
- en: An `1+2*3`, the product of `2` and `3` must be evaluated before the addition
    operator. Also, any sub-expressions enclosed within parentheses must be evaluated
    on a higher priority. The final AST will reflect all such processing rules. This
    is done by the `Parser` module.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于表达式`1+2*3`，必须先评估`2`和`3`的乘积，然后才是加法运算符。括号内包含的任何子表达式也必须按更高优先级进行评估。最终的AST将反映所有这些处理规则。这是通过`Parser`模块完成的。
- en: From the constructed AST, the last step is to evaluate each node of the AST
    in the right sequence, and aggregate them to arrive at the final value of the
    complete expression. This is done by the `Evaluator` module.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从构建的AST中，最后一步是按正确顺序评估AST中的每个节点，并将它们聚合以得到完整表达式的最终值。这是通过`Evaluator`模块完成的。
- en: The final computed value of the expression is displayed on the command line
    as a program output to the user. Alternatively, any error in processing is displayed
    as an error message.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式的最终计算值将显示在命令行上，作为程序输出给用户。或者，任何处理错误都将显示为错误消息。
- en: This is the broad sequence of steps for processing. We will now take a look
    at translating this design into Rust code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理步骤的广泛序列。现在我们将看看如何将这个设计转换为Rust代码。
- en: Differences between lexers, parsers, and ASTs
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器、解析器和AST之间的区别
- en: '*Lexers* and *parsers* are concepts used in computer science to build *compilers*
    and *interpreters*. A *lexer* (also called a *tokenizer*) splits text (source
    code) into words and assigns a *lexical* meaning to it such as *keyword*, *expression*,
    *operator*, *function call*, and so on. *Lexers* generate tokens (hence the name
    *tokenizer*).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*词法分析器*和*解析器*是计算机科学中用于构建*编译器*和*解释器*的概念。*词法分析器*（也称为*标记化器*）将文本（源代码）分割成单词，并为其分配一个*词法*意义，例如*关键字*、*表达式*、*运算符*、*函数调用*等。*词法分析器*生成标记（因此得名*标记化器*）。'
- en: A *parser* takes the output of the *lexer* and arranges the tokens into a tree
    structure (a tree is a type of data structure). Such a tree structure is also
    called an *AST*. With the *AST*, the compiler can generate machine code and the
    interpreter can evaluate an instruction. *Figure 2.7* of this chapter shows an
    illustration of an *AST*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*解析器*接受*词法分析器*的输出，并将标记排列成树结构（树是一种数据结构）。这种树结构也称为*AST*。有了*AST*，编译器可以生成机器代码，解释器可以评估指令。本章的*图2.7*展示了*AST*的示意图。'
- en: The lexing and parsing phases are two different steps in the compilation process,
    but in some cases they are combined. Note that concepts such as *lexers*, *parsers*,
    and *ASTs* have a broader range of applications beyond just compilers or interpreters,
    such as to render HTML web pages or SVG images.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析和解析阶段是编译过程中的两个不同步骤，但在某些情况下它们是合并的。请注意，诸如*词法分析器*、*解析器*和*AST*等概念的应用范围远不止编译器或解释器，例如用于渲染HTML网页或SVG图像。
- en: 'We''ve so far seen the high-level design of the system. Let''s now understand
    how the code will be organized. A visual representation of the project structure
    is shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了系统的整体设计。现在让我们了解代码是如何组织的。这里展示了项目结构的可视化表示：
- en: '![Figure 2.2 – Code structure for the project](img/Figure_2.2_B16405.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 项目的代码结构](img/Figure_2.2_B16405.jpg)'
- en: Figure 2.2 – Code structure for the project
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 项目的代码结构
- en: 'Let''s check each one of those paths:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这些路径中的每一个：
- en: '`src/parsemath`: The module containing the core processing logic'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/parsemath`: 包含核心处理逻辑的模块'
- en: '`src/parsemath/ast.rs`: Contains the AST code'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/parsemath/ast.rs`: 包含AST代码'
- en: '`src/parsemath/parser.rs`: Contains code for the parser'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/parsemath/parser.rs`: 包含解析器的代码'
- en: '`src/parsemath/tokenizer.rs`: Contains code for the tokenizer'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/parsemath/tokenizer.rs`: 包含标记化器的代码'
- en: '`src/parsemath/token.rs`: Contains the data structures for token and operator
    precedence'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/parsemath/token.rs`: 包含标记和运算符优先级的数据结构'
- en: '`src/main.rs`: The main command-line application'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main.rs`: 主命令行应用程序'
- en: 'Let''s now set up the project as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下方式设置项目：
- en: Create a new project with `cargo new chapter2 && cd chapter2`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new chapter2 && cd chapter2`创建一个新的项目。
- en: Create a folder named `parsemath` under the `src` folder.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹下创建一个名为`parsemath`的文件夹。
- en: 'Create the following files within the `src/parsemath` folder: `ast.rs`, `token.rs`,
    `tokenizer.rs`, `parser.rs`, and `mod.rs`.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/parsemath`文件夹中创建以下文件：`ast.rs`、`token.rs`、`tokenizer.rs`、`parser.rs`和`mod.rs`。
- en: 'Add the following to `src/parsemath/mod.rs`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`src/parsemath/mod.rs`中：
- en: '[PRE1]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the Rust module system was used to structure this project. All functionality
    related to parsing is in the `parsemath` folder. The `mod.rs` file in this folder
    indicates this is a Rust module. The `mod.rs` file exports the functions in the
    various files contained in this folder and makes it available to the `main()`
    function. In the `main()` function, we then register the `parsemath` module so
    that the module tree is constructed by the Rust compiler. Overall, the Rust module
    structure helps us organize code in different files in a way that is flexible
    and maintainable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本项目使用了Rust模块系统进行结构化。所有与解析相关的功能都在`parsemath`文件夹中。该文件夹中的`mod.rs`文件表明这是一个Rust模块。`mod.rs`文件导出该文件夹中包含的各个文件中的函数，并将其提供给`main()`函数。然后，我们在`main()`函数中注册`parsemath`模块，以便Rust编译器构建模块树。总的来说，Rust模块结构帮助我们以灵活和可维护的方式组织不同文件中的代码。
- en: Important note on code snippets in this chapter
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码片段的重要注意事项
- en: This chapter goes through the design of the command-line tool in detail, supplemented
    by illustrations with diagrams. The code snippets for all the key methods are
    also provided with explanations. However, in some places, a few elements to complete
    the code, such as module imports, test scripts, and definitions of `impl` blocks,
    are not included here but can be directly found in the GitHub repo. Please keep
    this in mind if you choose to code along. Otherwise, you can follow the explanations
    in this chapter in conjunction with the completed code in the code repository.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了命令行工具的设计，并辅以图表进行说明。所有关键方法的代码片段也提供了相应的解释。然而，在某些地方，一些用于完善代码的元素，例如模块导入、测试脚本和`impl`块的定义，并未在此处包含，但可以直接在GitHub仓库中找到。如果您选择跟随代码编写，请记住这一点。否则，您可以结合本章的解释和代码仓库中的完整代码进行学习。
- en: Also a heads-up that you will see usage of the `?` operator in the upcoming
    sections on building the tokenizer, parser, and evaluator. Just bear in mind that
    *?* is a shortcut for error handling, in order to propagate errors automatically
    from a given function to its calling function. This will be explained in the later
    *Dealing with errors* section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您将在构建词法分析器、解析器和评估器的下一节中看到`?`操作符的使用。请记住，*?*是错误处理的快捷方式，以便自动从给定函数传播错误到其调用函数。这将在稍后的*处理错误*部分进行解释。
- en: We're set now. Let's get started.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了。让我们开始吧。
- en: Building the tokenizer
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建词法分析器
- en: The **tokenizer** is the module in our system design that reads one or more
    characters from an arithmetic expression and translates it into a *token*. In
    other words, *input* is a set of characters and *output* is a set of tokens. In
    case you are wondering, examples of tokens are *Add*, *Subtract*, and *Num(2.0)*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**词法分析器**是我们系统设计中读取一个或多个字符从算术表达式并将其转换为*标记*的模块。换句话说，*输入*是一组字符，*输出*是一组标记。如果您想知道，标记的例子包括*加法*、*减法*和*Num(2.0)*。'
- en: 'We have to first create a data structure for two things:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要为两件事创建数据结构：
- en: To store the *input* arithmetic expression from the user
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了存储用户提供的*输入*算术表达式
- en: To represent the *output* tokens
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了表示*输出*标记
- en: In the following section, we will delve into how to determine the right data
    structures for the `tokenizer` module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨如何为`tokenizer`模块确定合适的数据结构。
- en: Tokenizer data structure
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 词法分析器数据结构
- en: 'To store the input arithmetic expression, we can choose among the following
    data types:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储输入的算术表达式，我们可以选择以下数据类型之一：
- en: String slice
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串切片
- en: String
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: We will choose the `&str` type, as we do not need to own the value or dynamically
    increase the size of the expression. This is because the user will provide the
    arithmetic expression once, and then the expression won't change for the duration
    of processing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择`&str`类型，因为我们不需要拥有值或动态增加表达式的尺寸。这是因为用户将一次性提供算术表达式，在处理过程中表达式不会改变。
- en: 'Here is one possible representation of the `Tokenizer` data structure:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Tokenizer`数据结构的一种可能表示：
- en: src/parsemath/tokenizer.rs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/tokenizer.rs
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we took this approach, we may run into a problem. To understand the problem,
    let's understand how tokenization takes place.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采取这种方法，我们可能会遇到问题。为了理解这个问题，让我们先了解分词是如何进行的。
- en: For the expression *1+21*3.2*, the individual characters scanned will appear
    as eight separate values, *1, +, 2, 1, *, 3, ., 2*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表达式`*1+21*3.2*`，扫描到的单个字符将出现为八个单独的值，*1, +, 2, 1, *, 3, ., 2*。
- en: 'From this, we will have to extract the following five tokens:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个迭代器中，我们将提取以下五个标记：
- en: '*Num(1.0)*, *Add*, *Num(21.0)*, *Multiply*, *Num(3.2)*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*Num(1.0)*, *Add*, *Num(21.0)*, *Multiply*, *Num(3.2)*'
- en: In order to accomplish this, we not only need to read a character to convert
    it into a token, but also take a look at the character beyond the next one. For
    example, given the input expression *1+21*3.2*, to tokenize number *21* into *Num(21)*,
    we need to read character *2*, followed by *1*, followed by *** in order to conclude
    that the second operand for the first addition operation has a value of *21*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们不仅需要读取一个字符将其转换为标记，还需要查看下一个字符。例如，给定输入表达式`*1+21*3.2*`，要将数字`21`标记为`Num(21)`，我们需要读取字符`2`，然后是`1`，然后是`*`，以便得出第一个加法操作的第二操作数值为`21`。
- en: In order to accomplish this, we have to convert the string slice into an iterator,
    which not only allows us to iterate through the string slice to read each character,
    but also allows us to *peek* ahead and see value of the character following that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们必须将字符串切片转换为迭代器，这不仅允许我们遍历字符串切片以读取每个字符，还允许我们`peek`查看下一个字符的值。
- en: Let's see how to implement an iterator over the string slice. Rust incidentally
    has a built-in type for this. It's a part of the `str` module in the standard
    library and the struct is called `Chars`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现字符串切片的迭代器。Rust意外地有一个内置类型用于此。它是标准库中`str`模块的一部分，结构体称为`Chars`。
- en: 'So, the definition of our `Tokenizer` struct could look as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`Tokenizer`结构体的定义可能如下所示：
- en: src/parsemath/tokenizer.rs
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/tokenizer.rs
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we have changed the type of the `expr` field from a string slice (`&str`)
    to an iterator type (`Chars`). `Chars` is an iterator over the characters of a
    string slice. This will allow us to do iterations on `expr` such as `expr.next()`,
    which will give the value of the next character in the expression. But we also
    need to take a peek at the character following the next character in the input
    expression, for reasons we mentioned earlier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将`expr`字段的类型从字符串切片（`&str`）更改为迭代器类型（`Chars`）。`Chars`是字符串切片字符的迭代器。这将允许我们在`expr`上执行迭代，例如`expr.next()`，这将给出表达式中的下一个字符的值。但我们也需要查看输入表达式中下一个字符后面的字符，原因我们之前提到过。
- en: 'For this, the Rust standard library has a struct called `Peekable` , which
    has a `peek()` method. The usage of `peek()` can be illustrated with an example.
    Let''s take the arithmetic expression `1+2`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，Rust标准库有一个名为`Peekable`的结构体，它有一个`peek()`方法。`peek()`的使用可以通过一个例子来说明。让我们取算术表达式`1+2`：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because we will store this expression in the `expr` field of `Tokenizer`, which
    is of the `peekable iterator` type, we can perform `next()` and `peek()` methods
    on it in sequence, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将把这个表达式存储在`Tokenizer`的`expr`字段中，它是一个`peekable iterator`类型，所以我们可以按顺序对其执行`next()`和`peek()`方法，如下所示：
- en: '`expression.next()` returns `1`. The iterator now points to character `1`.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`expression.next()`返回`1`。迭代器现在指向字符`1`。'
- en: Then, `expression.peek()` returns `+` but does not consume it, and the iterator
    still points to character `1`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`expression.peek()`返回`+`但不消耗它，迭代器仍然指向字符`1`。
- en: Then, `expression.next()` returns `+`, and the iterator now points to character
    `+`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`expression.next()`返回`+`，迭代器现在指向字符`+`。
- en: Then, `expression.next()` returns `2`, and the iterator now points to character
    `2`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`expression.next()`返回`2`，迭代器现在指向字符`2`。
- en: 'To enable such an iteration operation, we will define our `Tokenizer` struct
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这样的迭代操作，我们将定义我们的`Tokenizer`结构体如下：
- en: src/parsemath/tokenizer.rs
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/tokenizer.rs
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are still not done with the `Tokenizer` struct. The earlier definition would
    throw a compiler error asking to add a lifetime parameter. *Why is this?,* you
    may ask.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成`Tokenizer`结构体的定义。早期的定义会引发编译器错误，要求添加生命周期参数。*为什么是这样？*你可能想知道。
- en: 'Structs in Rust can hold references. But Rust needs explicit lifetimes to be
    specified when working with structs that contain references. That is the reason
    we get the compiler error on the `Tokenizer` struct. To fix this, let''s add lifetime
    annotation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的结构体可以持有引用。但是，当与包含引用的结构体一起工作时，Rust需要显式指定生命周期。这就是我们在`Tokenizer`结构体上得到编译器错误的原因。为了解决这个问题，让我们添加生命周期注解：
- en: src/parsemath/tokenizer.rs
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/tokenizer.rs
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see that the `Tokenizer` struct has been given a lifetime annotation
    of `'a`. We have done this by declaring the name of the generic lifetime parameter
    `'a` inside angle brackets after the name of the struct. This tells the Rust compiler
    that any reference to the Tokenizer struct cannot outlive the reference to the
    characters it contains.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，`Tokenizer`结构体被赋予了生命周期注解`'a`。我们通过在结构体名称后面使用尖括号声明泛型生命周期参数名称`'a`来做到这一点。这告诉Rust编译器，任何对`Tokenizer`结构体的引用都不能比它包含的字符引用存在时间更长。
- en: Lifetimes in Rust
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的生命周期
- en: In system languages such as C/C++, operations on references can lead to unpredictable
    results or failures, if the value associated with the reference has been freed
    in memory.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统语言如C/C++中，如果与引用相关的值在内存中已被释放，对引用的操作可能会导致不可预测的结果或失败。
- en: In Rust, every reference has a lifetime, which is the scope for which the lifetime
    is valid. The Rust compiler (specifically, the borrow checker) verifies that the
    lifetime of the reference is not longer than the lifetime of the underlying value
    pointed to by the reference.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，每个引用都有一个生命周期，这是生命周期有效的范围。Rust编译器（特别是借用检查器）会验证引用的生命周期不会比引用所指向的底层值的生命周期更长。
- en: How does the compiler know the lifetime of references? Most of the time, the
    compiler tries to infer the lifetime of references (called **elision**). But where
    this is not possible, the compiler expects the programmer to annotate the lifetime
    of the reference explicitly. Common situations where the compiler expects explicit
    lifetime annotations are in *function signatures* where two or more arguments
    are references, and in *structs* where one or more members of the struct are reference
    types.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是如何知道引用的生命周期的呢？大多数时候，编译器会尝试推断引用的生命周期（称为**省略**）。但是，当这不可能时，编译器期望程序员显式地注解引用的生命周期。编译器期望显式生命周期注解的常见情况包括*函数签名*中两个或多个参数是引用，以及在*结构体*中一个或多个成员是引用类型。
- en: More details can be found in the Rust documentation, at [https://doc.rust-lang.org/1.9.0/book/lifetimes.html](https://doc.rust-lang.org/1.9.0/book/lifetimes.html).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息可以在Rust文档中找到，请参阅[https://doc.rust-lang.org/1.9.0/book/lifetimes.html](https://doc.rust-lang.org/1.9.0/book/lifetimes.html)。
- en: As explained, the `Tokenizer` struct, we pass the string reference to it, which
    contains the arithmetic expression. As per the conventional rules of variable
    scoping (common to most programming languages), the `expr` variable needs to be
    valid for the duration that the `Tokenizer` object is in existence. If the value
    corresponding to the `expr` reference is deallocated while the `Tokenizer` object
    is in existence, then it constitutes a dangling (invalid) reference scenario.
    To prevent this, we tell the compiler through the lifetime annotation of `<'a>`
    that the `Tokenizer` object cannot outlive the reference it holds in the `expr`
    field.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如解释所述，我们传递包含算术表达式的字符串引用给`Tokenizer`结构体。根据变量作用域的常规规则（大多数编程语言都适用），`expr`变量需要在`Tokenizer`对象存在期间有效。如果在`Tokenizer`对象存在期间，与`expr`引用对应的值被释放，那么就构成了一个悬挂（无效）引用场景。为了防止这种情况，我们通过`<'a>`的生命周期注解告诉编译器，`Tokenizer`对象不能比它持有的`expr`字段中的引用存在时间更长。
- en: 'The following screenshot shows the `Tokenizer` data struct:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了`Tokenizer`数据结构：
- en: '![Figure 2.3 – The Tokenizer struct](img/Figure_2.3_B16405.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – Tokenizer结构体](img/Figure_2.3_B16405.jpg)'
- en: Figure 2.3 – The Tokenizer struct
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – Tokenizer结构体
- en: We've seen so far how to define the `Tokenizer` struct, which contains the reference
    to input arithmetic expression. We will next take a look at how to represent the
    tokens generated as output from the `Tokenizer`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何定义包含输入算术表达式引用的`Tokenizer`结构体，接下来我们将看看如何表示从`Tokenizer`生成的输出标记。
- en: To be able to represent the list of tokens that can be generated, we have to
    first consider the data type of these tokens. Since the tokens can be of the `Num`
    type or one of the operator types, we have to pick a data structure that can accommodate
    multiple data types. The data type options are tuples, HashMaps, structs, and
    enums. If we add the constraint that the type of data in a token can be one of
    many predefined *variants* (allowed values), that leaves us with just one option—*enums*.
    We will define the tokens using the `enum` data structure.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够表示可以生成的令牌列表，我们首先需要考虑这些令牌的数据类型。由于令牌可以是 `Num` 类型或运算符类型之一，我们必须选择一个可以容纳多种数据类型的数据结构。数据类型选项有元组、HashMaps、structs
    和 enums。如果我们添加一个约束，即令牌中的数据类型可以是许多预定义 *变体*（允许的值）之一，那么我们只剩下一种选择——*枚举*。我们将使用 `enum`
    数据结构来定义令牌。
- en: 'The representation of tokens in the `enum` data structure is shown in the following
    screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `enum` 数据结构中令牌的表示：
- en: '![Figure 2.4 – Token enum](img/Figure_2.4_B16405.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – Token enum](img/Figure_2.4_B16405.jpg)'
- en: Figure 2.4 – Token enum
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – Token enum
- en: 'Here is the explanation for what value gets stored in the `Token enum`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于 `Token enum` 中存储的值的解释：
- en: If the `+` character is encountered, the `Add` token is generated.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到 `+` 字符，将生成 `Add` 令牌。
- en: If the `-` character is encountered, the `Subtract` token is generated.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到 `-` 字符，将生成 `Subtract` 令牌。
- en: If the `*` character is encountered, the `Multiply` token is generated.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到 `*` 字符，将生成 `Multiply` 令牌。
- en: If the `/` character is encountered, the `Divide` token is generated.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到 `/` 字符，将生成 `Divide` 令牌。
- en: If the `^` character is encountered, the `Caret` token is generated.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到 `^` 字符，将生成 `Caret` 令牌。
- en: If the `(` character is encountered, the `LeftParen` token is generated.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到 `(` 字符，将生成 `LeftParen` 令牌。
- en: If the `)` character is encountered, the `RightParen` token is generated.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到 `)` 字符，将生成 `RightParen` 令牌。
- en: If any number `x` is encountered, the `Num(x)` token is generated.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到任何数字 `x`，将生成 `Num(x)` 令牌。
- en: If `EOF` is encountered (at the end of scanning the entire expression), the
    `EOF` token is generated.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到 `EOF`（扫描整个表达式的末尾），将生成 `EOF` 令牌。
- en: Now that we have defined the data structures to capture the *input* (arithmetic
    expression) and *outputs* (tokens) for the `Tokenizer` module, we now can write
    the code to do the actual processing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了数据结构来捕获 `Tokenizer` 模块的 *输入*（算术表达式）和 *输出*（令牌），我们现在可以编写实际处理的代码。
- en: Tokenizer data processing
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tokenizer 数据处理
- en: 'The following screenshot shows the `Tokenizer` with its data elements and methods:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `Tokenizer` 及其数据元素和方法：
- en: '![Figure 2.5 – The Tokenizer with its methods](img/Figure_2.5_B16405.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – Tokenizer 及其方法](img/Figure_2.5_B16405.jpg)'
- en: Figure 2.5 – The Tokenizer with its methods
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – Tokenizer 及其方法
- en: 'The `Tokenizer` has two public methods:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tokenizer` 有两个公共方法：'
- en: '`new()`: Creates a new tokenizer using the arithmetic expression provided by
    the user'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new()`: 使用用户提供的算术表达式创建一个新的分词器'
- en: '`next()`: Reads the characters in the expression and return the next token'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()`: 读取表达式中的字符并返回下一个令牌'
- en: 'The following screenshot shows the full design of the `Tokenizer` module:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `Tokenizer` 模块的全貌：
- en: '![Figure 2.6 – Tokenizer module design](img/Figure_2.6_B16405.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – Tokenizer 模块设计](img/Figure_2.6_B16405.jpg)'
- en: Figure 2.6 – Tokenizer module design
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – Tokenizer 模块设计
- en: 'The code for the `new()` method is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`new()` 方法的代码如下：'
- en: src/parsemath/tokenizer.rs
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/tokenizer.rs
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You'll notice that we are declaring a lifetime for `Tokenizer` in the `impl`
    line. We are repeating `'a` twice. `Impl<'a>` declares the lifetime `'a`, and
    `Tokenizer<'a>` uses it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在 `impl` 行中声明了 `Tokenizer` 的生命周期。我们重复了两次 `'a`。`Impl<'a>` 声明生命周期 `'a`，而
    `Tokenizer<'a>` 使用它。
- en: Observations on lifetimes
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于生命周期的观察
- en: 'You''ve seen that for `Tokenizer`, we declare its lifetime in three places:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，对于 `Tokenizer`，我们在三个地方声明了其生命周期：
- en: 1) The declaration of the `Tokenizer` struct
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 1) `Tokenizer` 结构体的声明
- en: 2) The declaration of the `impl` block for the `Tokenizer` struct
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 2) 为 `Tokenizer` 结构体声明 `impl` 块
- en: 3) The method signature within the `impl` block
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 3) `impl` 块内的方法签名
- en: This may seem verbose, but Rust expects us to be specific about lifetimes because
    that's how we can avoid memory-safety issues such as *dangling pointers* or *use-after-free*
    errors.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很冗长，但 Rust 期望我们关于生命周期要具体，因为这是我们避免内存安全问题，如 *悬垂指针* 或 *使用后释放* 错误的方法。
- en: The `impl` keyword allows us to add functionality to the `Tokenizer` struct.
    The `new()` method accepts a string slice as a parameter that contains a reference
    to the arithmetic expression input by the user. It constructs a new `Tokenizer`
    struct initialized with the supplied arithmetic expression, and returns it from
    the function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`impl`关键字允许我们向`Tokenizer`结构体添加功能。`new()`方法接受一个字符串切片作为参数，该参数包含用户输入的算术表达式的引用。它构建一个新的`Tokenizer`结构体，用提供的算术表达式初始化，并从函数中返回它。'
- en: Note that the arithmetic expression is not stored in the struct as a string
    slice, but as a peekable iterator over the string slice.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，算术表达式不是以字符串切片的形式存储在结构体中，而是以字符串切片的可预览迭代器形式存储。
- en: In this code, `new_expr` represents the string slice, `new_expr.chars()` represents
    an iterator over the string slice, and `new_expr.chars().peekable()` creates a
    peekable iterator over the string slice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`new_expr`代表字符串切片，`new_expr.chars()`代表字符串切片的迭代器，而`new_expr.chars().peekable()`创建了一个字符串切片的可预览迭代器。
- en: The difference between a regular iterator and peekable iterator is that in the
    former, we can consume the next character in the string slice using the `next()`
    method, while in the latter we can also optionally peek into the next character
    in the slice *without consuming it*. You will see how this works as we write the
    code for the `next()` method of the `Tokenizer`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正规迭代器和可预览迭代器之间的区别在于，在前者中，我们可以使用`next()`方法消耗字符串切片中的下一个字符，而在后者中，我们还可以选择性地预览切片中的下一个字符而不消耗它。您将在我们编写`Tokenizer`的`next()`方法代码时看到这一点。
- en: 'We will write the code for the `next()` method on the `Tokenizer` by implementing
    the `Iterator` trait on the `Tokenizer` struct. Traits enable us to add behaviors
    to structs (and enums). The `Iterator` trait in the standard library (`std::iter::Iterator`)
    has a method that is required to be implemented with the following signature:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在`Tokenizer`结构体上实现`Iterator`特质来编写`Tokenizer`上的`next()`方法代码。特质使我们能够向结构体（和枚举）添加行为。标准库中的`Iterator`特质（`std::iter::Iterator`）有一个必须按照以下签名实现的方法：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The method signature specifies that this method can be called on an instance
    of the `Tokenizer` struct and it returns `Option<Token>`. This means that it either
    returns `Some(Token)` or `None`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名指定，此方法可以在`Tokenizer`结构体的实例上调用，并返回`Option<Token>`。这意味着它要么返回`Some(Token)`，要么返回`None`。
- en: 'Here is the code to implement the `Iterator` trait on the `Tokenizer` struct:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现`Tokenizer`结构体上的`Iterator`特质的代码：
- en: src/parsemath/tokenizer.rs
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/tokenizer.rs
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice how there are two iterators at play here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里有两个迭代器在起作用：
- en: The `next()` method on `expr` (which is a field within the `Tokenizer` struct)
    returns the next character (we achieved this by assigning a type of `Peekable<Chars>`
    to the `expr` field ).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr`上的`next()`方法（它是`Tokenizer`结构体中的一个字段）返回下一个字符（我们通过将`Peekable<Chars>`类型分配给`expr`字段来实现这一点）。'
- en: The `next()` method on the `Tokenizer` struct returns a token (we achieved this
    by implementing the `Iterator` trait on the `Tokenizer` struct).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tokenizer`结构体上的`next()`方法返回一个标记（我们通过在`Tokenizer`结构体上实现`Iterator`特质来实现这一点）。'
- en: 'Let''s understand stepwise what happens when the `next()` method is called
    on `Tokenizer`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解当在`Tokenizer`上调用`next()`方法时会发生什么：
- en: The calling program instantiates the `Tokenizer` struct first by calling the
    `new()` method, and then invokes the `next()` method on it. The `next()` method
    on the `Tokenizer` struct reads the next character in the stored arithmetic expression
    by calling `next()` on the `expr` field, which returns the next character in the
    expression.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用程序首先通过调用`new()`方法实例化`Tokenizer`结构体，然后在该结构体上调用`next()`方法。`Tokenizer`结构体上的`next()`方法通过在`expr`字段上调用`next()`来读取存储的算术表达式中的下一个字符，从而返回表达式中的下一个字符。
- en: The returned character is then evaluated using a `match` statement. Pattern
    matching is used to determine what token to return, depending on what character
    is read from the string slice reference in the `expr` field.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后使用`match`语句评估返回的字符。模式匹配用于确定从`expr`字段中的字符串切片引用读取的字符后返回哪个标记。
- en: If the character returned from string slice is an arithmetic operator (*+*,
    *-*, ***, */*, *^*) or if it is a parenthesis, the appropriate `Token` from the
    `Token` `enum` is returned. There is a one-to-one correspondence between the *character*
    and `Token` here.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从字符串切片返回的字符是算术运算符（`*+*, *-*, ***, */*, *^*`）或者是一个括号，则返回相应的`Token`枚举值。在这里，*字符*和`Token`之间存在一对一的对应关系。
- en: If the character returned is a number, then there is some additional processing
    needed. The reason is, a number may have multiple digits. Also, a number may be
    decimal, in which case it could be of the form *xxx.xxx,* where the amounts of
    digits before and after the decimal are completely unpredictable. So, for numbers,
    we should use the `peekable` iterator on the arithmetic expression to consume
    the next character and *peek* into the character after that to determine whether
    to continue reading the number.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果返回的字符是数字，则需要一些额外的处理。原因是，一个数字可能有多个数字。此外，一个数字可能是小数，在这种情况下，它可能是*xxx.xxx*的形式，其中小数点前后数字的数量是完全不可预测的。因此，对于数字，我们应该使用算术表达式的`peekable`迭代器来消费下一个字符，并*窥视*下一个字符以确定是否继续读取数字。
- en: The complete code for the `Tokenizer` can be found in the `tokenizer.rs` file
    in the code folder on GitHub.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tokenizer`的完整代码可以在GitHub上代码文件夹中的`tokenizer.rs`文件中找到。'
- en: Building the parser
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建解析器
- en: The **parser** is the module in our project that constructs the AST, which is
    a tree of nodes with each node representing a token (a number or an arithmetic
    operator). The AST is a recursive tree structure of token nodes, that is, the
    root node is a token, which contains child nodes that are also tokens.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析器**是我们项目中构建AST的模块，AST是一个节点树，每个节点代表一个标记（一个数字或算术运算符）。AST是标记节点的递归树结构，即根节点是一个标记，它包含也是标记的子节点。'
- en: Parser data structure
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析器数据结构
- en: 'The `parser` is a higher-level entity compared to the `Tokenizer`. While the
    `Tokenizer` converts user input into fine-grained tokens (for example, various
    arithmetic operators), the parser uses the `Tokenizer` outputs to construct an
    overall AST, which is a hierarchy of nodes. The structure of the `AST` constructed
    from the parser is illustrated in the following diagram:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`parser`与`Tokenizer`相比是一个更高级的实体。虽然`Tokenizer`将用户输入转换为细粒度的标记（例如，各种算术运算符），但解析器使用`Tokenizer`的输出构建一个整体的AST，这是一个节点层次结构。从解析器构建的`AST`结构在以下图中展示：'
- en: '![Figure 2.7 – Our AST](img/Figure_2.7_B16405.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 我们的AST](img/Figure_2.7_B16405.jpg)'
- en: Figure 2.7 – Our AST
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 我们的AST
- en: 'In the preceding figure, each of the following are nodes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，以下每一项都是节点：
- en: '*Number(2.0)*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Number(2.0)*'
- en: '*Number(3.0)*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Number(3.0)*'
- en: '*Multiply(Number(2.0),Number(3.0))*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Multiply(Number(2.0),Number(3.0))* '
- en: '*Number(6.0)*'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Number(6.0)*'
- en: '*Add(Multiply(Number(2.0),Number(3.0)),Number(6.0))*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Add(Multiply(Number(2.0),Number(3.0)),Number(6.0))* '
- en: Each of these nodes is stored in a `Box` variable as part of the `Node` enum.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点中的每一个都作为`Node`枚举的一部分存储在`Box`变量中。
- en: 'The overall design of the `Parser` struct is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parser`结构体的整体设计如下：'
- en: '![Figure 2.8 – Design of the Parser struct](img/Figure_2.8_B16405.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 解析器结构体设计](img/Figure_2.8_B16405.jpg)'
- en: Figure 2.8 – Design of the Parser struct
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 解析器结构体设计
- en: 'As shown in the preceding figure, `Parser` will have two data elements: an
    instance of `Tokenizer` (that we built in the previous section), and the current
    token to indicate up to which point we have evaluated the arithmetic expression.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`Parser`将有两个数据元素：一个`Tokenizer`实例（我们在上一节中构建的），以及当前标记，表示我们已评估到算术表达式的哪个点。
- en: Parser methods
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析器方法
- en: 'The `Parser` struct will have two public methods:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parser`结构体将有两个公共方法：'
- en: '`new()`: To create a new instance of the parser. This `new()` method will create
    a tokenizer instance passing in the arithmetic expression, and then stores the
    first token (returned from `Tokenizer`) in its `current_token` field.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new()`：创建解析器的新实例。这个`new()`方法将创建一个传递算术表达式的标记化器实例，并将从`Tokenizer`返回的第一个标记存储在其`current_token`字段中。'
- en: '`parse()`: To generate the `AST` (the node tree) from the tokens, which is
    the main output of the parser.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parse()`：从标记生成`AST`（节点树），这是解析器的主要输出。'
- en: 'Here is the code for the `new()` method. The code is self-explanatory, it creates
    a new instance of `Tokenizer`, initializing it with the arithmetic expression,
    and then tries to retrieve the first token from the expression. If successful,
    the token is stored in the `current_token` field. If not, `ParseError` is returned:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`new()`方法的代码。代码是自我解释的，它创建了一个新的`Tokenizer`实例，用算术表达式初始化它，然后尝试从表达式中检索第一个标记。如果成功，标记将被存储在`current_token`字段中。如果不成功，则返回`ParseError`：
- en: src/parsemath/parser.rs
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE10]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the code for the public `parse()` method. It invokes a private
    `generate_ast()` method that does the processing recursively and returns an AST
    (a tree of nodes). If successful, it returns the Node tree; if not, it propagates
    the error received:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是公共 `parse()` 方法的代码。它调用一个私有 `generate_ast()` 方法，该方法递归地执行处理并返回一个 AST（节点树）。如果成功，则返回节点树；如果不成功，则传播接收到的错误：
- en: src/parsemath/parser.rs
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following image lists all the private and public methods in the `Parser`
    struct:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像列出了 `Parser` 结构体中的所有私有和公共方法：
- en: '![Figure 2.9 – Parser methods overview](img/Figure_2.9_B16405.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 解析器方法概述](img/Figure_2.9_B16405.jpg)'
- en: Figure 2.9 – Parser methods overview
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 解析器方法概述
- en: 'Let''s now look at the code for the `get_next_token()` method. This method
    retrieves the next token from the arithmetic expression using the `Tokenizer`
    struct and updates the `current_token` field of the `Parser` struct. If unsuccessful,
    it returns `ParseError`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看 `get_next_token()` 方法的代码。此方法使用 `Tokenizer` 结构体从算术表达式中检索下一个标记，并更新 `Parser`
    结构体的 `current_token` 字段。如果失败，则返回 `ParseError`：
- en: src/parsemath/parser.rs
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE12]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the empty tuple `()` returned in `Result<(),` `ParseError>`. This means
    if nothing goes wrong, no concrete value is returned.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `Result<(), ParseError>` 中返回的空元组 `()`。这意味着如果没有出错，则不返回任何具体值。
- en: 'Here''s the code for the `check_paren()` method. This is a helper method used
    to check whether there are matching pairs of parentheses in the expression. Otherwise,
    an error is returned:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `check_paren()` 方法的代码。这是一个辅助方法，用于检查表达式中是否存在匹配的括号对。如果没有，则返回错误：
- en: src/parsemath/parser.rs
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's now look at the remaining three private methods that do the bulk of the
    parser processing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看剩下的三个私有方法，它们负责大部分的解析器处理工作。
- en: 'The `parse_number()` method takes the current token, and checks for three things:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_number()` 方法接受当前标记，并检查三件事：'
- en: Whether the token is a number of the form *Num(i)*.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否是形式为 *Num(i)* 的数字。
- en: Whether the token has a sign, in case it is a negative number. For example,
    the expression *-2.2 + 3.4* is parsed into AST as *Add(Negative(Number(2.2)),
    Number(3.4))*.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有符号，如果是负数的话。例如，表达式 *-2.2 + 3.4* 被解析到 AST 中为 *Add(Negative(Number(2.2)), Number(3.4))*。
- en: 'Pairs of parenthesis: If an expression is found within pairs of parenthesis,
    it treats it as a multiplication operation. For example, *1*(2+3)* is parsed as
    *Multiply(Number(1.0), Add(Number(2.0), Number(3.0)))*.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号对：如果括号内找到一个表达式，它将其视为乘法操作。例如，*1*(2+3)* 被解析为 *Multiply(Number(1.0), Add(Number(2.0),
    Number(3.0)))*。
- en: In case of errors in any of the preceding operations, `ParseError` is returned.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前述操作中的任何操作出现错误，则返回 `ParseError`。
- en: 'Here is the code for the `parse_number()` method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `parse_number()` 方法的代码：
- en: src/parsemath/parser.rs
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `generate_ast()` method is the main workhorse of the module and is invoked
    recursively. It does its processing in the following sequence:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_ast()` 方法是该模块的主要工作马，它递归调用。它按照以下顺序进行处理：'
- en: It processes numeric tokens, negative number tokens, and expressions in parentheses
    using the `parse_number()` method.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `parse_number()` 方法处理数字标记、负数标记和括号内的表达式。
- en: It parses each token from the arithmetic expression in a sequence within a loop
    to check if the precedence of the next two operators encountered, and constructs
    `AST` by calling the `convert_token_to_node()` method in such a way that the expression
    containing an operator with higher precedence is executed before an expression
    containing an operator with lower precedence. For example, the expression *1+2*3*
    is evaluated as *Add(Number(1.0), Multiply(Number(2.0), Number(3.0)))*, whereas
    the expression *1*2+3* is evaluated as *Add(Multiply(Number(1.0), Number(2.0)),
    Number(3.0))*.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在循环中按顺序解析算术表达式中的每个标记，以检查遇到的下一个两个运算符的优先级，并通过以这种方式调用 `convert_token_to_node()`
    方法来构建 `AST`，使得具有较高优先级的运算符包含的表达式先于具有较低优先级的运算符包含的表达式执行。例如，表达式 *1+2*3* 被评估为 *Add(Number(1.0),
    Multiply(Number(2.0), Number(3.0)))*，而表达式 *1*2+3* 被评估为 *Add(Multiply(Number(1.0),
    Number(2.0)), Number(3.0))*。
- en: 'Let''s now look at the code for the `generate_ast()` method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看 `generate_ast()` 方法的代码：
- en: src/parsemath/parser.rs
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE15]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have seen the various methods associated with the parser. Let's now look
    at another key aspect when dealing with arithmetic operators—*operator precedence*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了与解析器相关的各种方法。现在让我们看看处理算术运算符时的另一个关键方面——*运算符优先级*。
- en: Operator precedence
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: '`enum` for operator precedence is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符优先级的 `enum` 如下所示：
- en: '![Figure 2.10 – Operator precedence enum](img/Figure_2.10_B16405.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 操作符优先级枚举](img/Figure_2.10_B16405.jpg)'
- en: Figure 2.10 – Operator precedence enum
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 操作符优先级枚举
- en: 'The operator precedence `enum` has the following values:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符优先级 `enum` 有以下值：
- en: '`DefaultZero`: The default precedence (lowest priority)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultZero`: 默认优先级（最低优先级）'
- en: '`AddSub`: The precedence applied if the arithmetic operation is addition or
    subtraction'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddSub`: 如果算术操作是加法或减法，则应用的优先级'
- en: '`MulDiv`: The precedence applied if the arithmetic operation is multiplication
    or division'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MulDiv`: 如果算术操作是乘法或除法，则应用的优先级'
- en: '`Power`: The precedence applied if the caret (`^`) operator is encountered'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Power`: 遇到 caret (`^`) 操作符时应用的优先级'
- en: '`Negative`: The precedence applied for the negative (`-`) prefix before a number'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Negative`: 在数字前负号 (`-`) 前应用的优先级'
- en: The precedence order increases from top to bottom, that is, `DefaultZero` <
    `AddSub` < `MulDiv` < `Power` < `Negative`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级顺序从上到下增加，即 `DefaultZero` < `AddSub` < `MulDiv` < `Power` < `Negative`。
- en: 'Define the operator precedence `enum` as shown:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 定义操作符优先级 `enum` 如下所示：
- en: src/parsemath/token.rs
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/token.rs
- en: '[PRE16]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `get_oper_prec()` method is used to get the operator precedence given an
    operator. The following is the code that shows this method in action. Define this
    method in the `impl` block of the `Token` struct:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `get_oper_prec()` 方法来获取给定操作符的操作符优先级。以下代码展示了此方法的作用。在 `Token` 结构体的 `impl` 块中定义此方法：
- en: src/parsemath/token.rs
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/token.rs
- en: '[PRE17]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s look at the code for `convert_token_to_node()`. This method basically
    constructs the operator-type `AST` nodes by checking whether the token is `Add`,
    `Subtract`, `Multiply`, `Divide`, or `Caret`. In the case of an error, `ParseError`
    is returned:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `convert_token_to_node()` 的代码。此方法基本上通过检查标记是否为 `Add`、`Subtract`、`Multiply`、`Divide`
    或 `Caret` 来构建操作符类型的 `AST` 节点。在出错的情况下，返回 `ParseError`：
- en: src/parsemath/parser.rs
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE18]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will look in detail at error handling later in the chapter in the *Dealing
    with errors* section. The complete code for `Parser` can be found in the `parser.rs`
    file in the GitHub folder for the chapter.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的 *处理错误* 部分详细讨论错误处理。`Parser` 的完整代码可以在 GitHub 章节文件夹中的 `parser.rs` 文件中找到。
- en: Building the evaluator
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建评估器
- en: Once the `AST` (node tree) is constructed in the parser, evaluating the numeric
    value from `AST` is a straightforward operation. The evaluator function parses
    each node in the `AST` tree recursively and arrives at the final value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在解析器中构建了 `AST`（节点树），从 `AST` 中评估数值就是一个简单的操作。评估函数递归地解析 `AST` 树中的每个节点，并得到最终值。
- en: For example, if the `AST` node is *Add(Number(1.0),Number(2.0))*, it evaluates
    to *3.0*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 `AST` 节点是 *Add(Number(1.0),Number(2.0))*，则计算结果为 *3.0*。
- en: 'If the `AST` node is *Add(Number(1.0),Multiply(Number(2.0),Number(3.0))*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `AST` 节点是 *Add(Number(1.0),Multiply(Number(2.0),Number(3.0))*：
- en: It evaluates value of *Number(1.0)* to *1.0*.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 *Number(1.0)* 的值计算为 *1.0*。
- en: Then it evaluates *Multiply(Number(2.0), Number(3.0))* to *6.0*.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将 *Multiply(Number(2.0), Number(3.0))* 计算为 *6.0*。
- en: It then adds *1.0* and *6.0* to get the final value of *7.0*.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将 *1.0* 和 *6.0* 相加，得到最终值 *7.0*。
- en: 'Let''s now look at the code for the `eval()` function:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 `eval()` 函数的代码：
- en: src/parsemath/ast.rs
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/ast.rs
- en: '[PRE19]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Trait objects
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 特性对象
- en: In the `eval()` method, you will notice that the method returns `Box<dyn error::Error>`
    in case of errors. This is an example of a **trait object**. We will explain this
    now.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `eval()` 方法中，你会注意到在出错的情况下，该方法返回 `Box<dyn error::Error>`。这是一个特性对象的例子。我们现在将解释这一点。
- en: In the Rust standard library, `error:Error` is a trait. Here, we are telling
    the compiler that the `eval()` method should return something that implements
    the `Error` trait. We don't know at compile time what the exact type being returned
    is; we just know that whatever is returned will implement the `Error` trait. The
    underlying error type is only known at runtime and is not statically determined.
    Here, `dyn error::Error` is a trait object. The use of the `dyn` keyword indicates
    it is a trait object.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 标准库中，`error:Error` 是一个特性。在这里，我们告诉编译器 `eval()` 方法应该返回实现 `Error` 特性的类型。我们不知道编译时返回的确切类型是什么；我们只知道返回的任何内容都将实现
    `Error` 特性。底层错误类型仅在运行时才知道，不是静态确定的。在这里，`dyn error::Error` 是一个特性对象。使用 `dyn` 关键字表示它是一个特性对象。
- en: When we use trait objects, the compiler does not know at compile time which
    method to call on which types. This is only known at runtime, hence it is called
    *dynamic-dispatch* (when the compiler knows what method to call at compile time,
    it is called *static dispatch*).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用特质对象时，编译器在编译时不知道应该调用哪种类型的哪个方法。这只有在运行时才知道，因此被称为*动态分发*（当编译器在编译时知道应该调用哪个方法时，它被称为*静态分发*）。
- en: Note also that we are boxing the error with `Box<dyn error::Error>`. This is
    because we don't know the size of the error type at runtime, so boxing is a way
    to get around this problem (`Box` is a reference type that has a known size at
    compile time). The Rust standard library helps in boxing our errors by having
    `Box` implement conversion from any type that implements the `Error` trait into
    the trait object `Box<Error>`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`Box<dyn error::Error>`来封装错误。这是因为我们在运行时不知道错误类型的尺寸，所以封装是一种绕过这个问题的方法（`Box`是一个在编译时具有已知尺寸的引用类型）。Rust标准库通过让`Box`实现从任何实现了`Error`特质的类型到特质对象`Box<Error>`的转换，帮助我们封装错误。
- en: More details can be found in the Rust documentation, at [https://doc.rust-lang.org/book/ch17-02-trait-objects.html](https://doc.rust-lang.org/book/ch17-02-trait-objects.html).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息可以在Rust文档中找到，请参阅[https://doc.rust-lang.org/book/ch17-02-trait-objects.html](https://doc.rust-lang.org/book/ch17-02-trait-objects.html)。
- en: Dealing with errors
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'Error handling deals with the question: *how do we communicate program errors
    to users?*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理处理的问题是：*我们如何将程序错误传达给用户？*
- en: In our project, errors can occur due to two main reasons—there could be a programming
    error, or an error could occur due to invalid inputs. Let's first discuss the
    Rust approach to error handling.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，错误可能由两个主要原因引起——可能是编程错误，或者可能是由于无效输入导致的错误。让我们首先讨论Rust的错误处理方法。
- en: 'In Rust, errors are first-class citizens in that an error is a data type in
    itself, just like an `integer`, `string`, or `vector`. Because `error` is a data
    type, type checking can happen at compile time. The Rust standard library has
    a `std::error::Error` trait implemented by all errors in the Rust standard library.
    Rust does not use exception handling, but a unique approach where a computation
    can return a `Result` type:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，错误是一等公民，因为错误本身就是一个数据类型，就像`整数`、`字符串`或`向量`一样。因为`error`是一个数据类型，类型检查可以在编译时发生。Rust标准库为Rust标准库中的所有错误实现了`std::error::Error`特质。Rust不使用异常处理，而是一种独特的计算可以返回`Result`类型的方法：
- en: '[PRE20]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Result<T, E>` is an `enum` with two variants, where `Ok(T)` represents *success*
    and `Err(E)` represents the *error* returned. Pattern matching is used to handle
    the two types of return values from a function.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result<T, E>`是一个包含两个变体的`enum`，其中`Ok(T)`表示*成功*，而`Err(E)`表示返回的*错误*。通过模式匹配来处理函数返回的两种类型的结果。'
- en: To gain greater control over error handling and to provide more user-friendly
    errors for application users, it is recommended to use a custom error type that
    implements the `std::error::Error` trait. All types of errors from different modules
    in the program can then be converted to this custom error type for uniform error
    handling. This is a very effective way to deal with errors in Rust.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地控制错误处理并提供更友好的错误信息给应用程序用户，建议使用实现了`std::error::Error`特质的自定义错误类型。这样，程序中不同模块的所有错误类型都可以转换为这种自定义错误类型，从而实现统一的错误处理。这是在Rust中处理错误的一种非常有效的方法。
- en: 'A lightweight approach to error handling could be to use `Option<T>` as the
    return value from a function, where `T` is any generic type:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一种轻量级的错误处理方法是将`Option<T>`用作函数的返回值，其中`T`是任何泛型类型：
- en: '[PRE21]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Option` type is an `enum` with two variants, `Some(T)` and `None`. If processing
    is successful, a `Some(T)` value is returned, otherwise, `None` is returned from
    the function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`类型是一个包含两个变体的`enum`，`Some(T)`和`None`。如果处理成功，则返回`Some(T)`值，否则从函数返回`None`。'
- en: We will use both the `Result` and `Option` types for error handling in our project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将使用`Result`和`Option`类型进行错误处理。
- en: 'The error handling approach chosen for our project is as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目选择的错误处理方法如下：
- en: '![Figure 2.11 – Error handling approach](img/Figure_2.11_B16405.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 错误处理方法](img/Figure_2.11_B16405.jpg)'
- en: Figure 2.11 – Error handling approach
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 错误处理方法
- en: 'For our project, the approach for the four modules that contain the core processing
    is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们项目中的包含核心处理的四个模块，其方法如下：
- en: '`new()` and `next()`. The `new()` method is fairly simple and just creates
    a new instance of the `Tokenizer` struct and initializes it. No error will be
    returned in this method. However, the `next()` method returns a `Token`, and if
    there is any invalid character in the arithmetic expression, we need to deal with
    this situation and communicate it to the calling code. We will use a lightweight
    error handling approach here, with `Option<Token>` as the return value from the
    `next()` method. If a valid `Token` can be constructed from the arithmetic expression,
    `Some(Token)` will be returned. In the case of invalid input, `None` will be returned.
    The calling function can then interpret `None` as an error condition and take
    care of the necessary handling.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new()`和`next()`。`new()`方法相当简单，只是创建一个新的`Tokenizer`结构体实例并初始化它。此方法不会返回任何错误。然而，`next()`方法返回一个`Token`，如果算术表达式中存在任何无效字符，我们需要处理这种情况并将信息传达给调用代码。在这里，我们将使用轻量级的错误处理方法，`next()`方法的返回值将使用`Option<Token>`。如果可以从算术表达式中构造一个有效的`Token`，则返回`Some(Token)`。在无效输入的情况下，返回`None`。调用函数可以将`None`解释为错误条件，并处理必要的操作。'
- en: '`eval()` function that computes a numeric value given a node tree. We will
    return a vanilla `std::error::Error` in case of an error during processing, but
    it will be a `Boxed` value because otherwise, the Rust compiler will not know
    the size of the error value at compile time. The return type from this method
    is `Result<f64, Box<dyn error::Error>>`. If processing is successful, a numeric
    value (`f64`) is returned, else a `Boxed` error is returned. We could have defined
    a custom error type for this module to avoid the complex `Boxed` error signature,
    but this approach has been chosen to showcase the various ways to do error handling
    in Rust.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval()`函数，它根据节点树计算数值。如果在处理过程中出现错误，我们将返回一个普通的`std::error::Error`，但由于否则Rust编译器将不知道错误值的编译时大小，它将是一个`Boxed`值。此方法的返回类型是`Result<f64,
    Box<dyn error::Error>>`。如果处理成功，将返回一个数值（`f64`），否则返回一个`Boxed`错误。我们本可以为此模块定义一个自定义错误类型以避免复杂的`Boxed`错误签名，但选择这种方法是为了展示在Rust中进行错误处理的各种方式。'
- en: '`get_oper_prec()`, which returns the operator precedence given an arithmetic
    operator as input. Since we do not see any possibility of errors in this simple
    method, there will be no error type defined in the return value of the method.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_oper_prec()`，它根据输入的算术运算符返回运算符优先级。由于我们在这个简单的方法中看不到任何错误的可能性，因此方法返回值中不会定义错误类型。'
- en: '`Parser` module contains the bulk of the processing logic. Here, a custom error
    type, `ParseError,` will be defined, which has the following structure:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parser`模块包含大部分处理逻辑。在这里，将定义一个自定义错误类型`ParseError`，其结构如下：'
- en: '![Figure 2.12 – Custom error type](img/Figure_2.12_B16405.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 自定义错误类型](img/Figure_2.12_B16405.jpg)'
- en: Figure 2.12 – Custom error type
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 自定义错误类型
- en: Our custom error type has two variants, `UnableToParse(String)` and `InvalidOperator(String)`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义错误类型有两个变体，`UnableToParse(String)`和`InvalidOperator(String)`。
- en: The first variant will be a generic error for any type of error during processing,
    and the second variant will be used specifically if there is an invalid arithmetic
    operator provided by the user; for example, *2=3*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变体将是一个通用的错误，用于处理处理过程中出现的任何类型的错误，第二个变体将专门用于用户提供了无效的算术运算符的情况；例如，*2=3*。
- en: 'Let''s define a custom error type for the parser:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为解析器定义一个自定义错误类型：
- en: src/parsemath/parser.rs
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE22]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To print errors, we also need to implement the `Display` trait:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印错误，我们还需要实现`Display`特质：
- en: src/parsemath/parser.rs
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE23]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since `ParseError` will be the main error type returned from processing, and
    because the `AST` module returns a `Boxed` error, we can write code to automatically
    convert any `Boxed` error from the `AST` module into `ParseError` that gets returned
    by `Parser`. The code is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ParseError`将是处理过程中返回的主要错误类型，并且因为`AST`模块返回一个`Boxed`错误，我们可以编写代码将`AST`模块中的任何`Boxed`错误自动转换为由`Parser`返回的`ParseError`。代码如下：
- en: src/parsemath/parser.rs
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: src/parsemath/parser.rs
- en: '[PRE24]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code allows us to write code such as the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许我们编写如下代码：
- en: '[PRE25]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note in particular the `?` operator. It is a shortcut for the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`?`运算符。它是以下内容的快捷方式：
- en: If `eval()` processing is successful, store the returned value in the `num_value`
    field.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`eval()`处理成功，将返回值存储在`num_value`字段中。
- en: If processing fails, convert the `Boxed` error returned by the `eval()` method
    into `ParseError` and propagate it further to the caller.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处理失败，将`eval()`方法返回的`Boxed`错误转换为`ParseError`，并将其进一步传播给调用者。
- en: This concludes the discussion on the arithmetic expression evaluator modules.
    In the next section, we will take a look at how to call this module from a `main()`
    function.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分讨论了算术表达式评估模块。在下一节中，我们将探讨如何从`main()`函数中调用此模块。
- en: Putting it all together
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: 'We have seen in previous sections how to design and write code for the various
    processing modules of our project. We will now tie all of them together in a `main()`
    function that serves as the command-line application. This `main()` function will
    do the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何设计和编写我们项目各种处理模块的代码。现在，我们将把它们全部整合到一个`main()`函数中，该函数作为命令行应用程序。此`main()`函数将执行以下操作：
- en: Display prompts with instructions for the user to enter an arithmetic expression.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示带有用户输入算术表达式的说明的提示。
- en: Accept an arithmetic expression in the command-line input from the user.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从用户那里接受命令行输入的算术表达式。
- en: Instantiate `Parser` (returns a `Parser` object instance).
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`Parser`（返回一个`Parser`对象实例）。
- en: Parse the expression (returns the AST representation of the expression).
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析表达式（返回表达式的AST表示）。
- en: Evaluate the expression (computes the mathematical value of the expression).
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估表达式（计算表达式的数学值）。
- en: Display the result to the user in the command-line output.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行输出中向用户显示结果。
- en: Invoke `Parser` and evaluate the mathematical expression.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Parser`并评估数学表达式。
- en: 'The code for the `main()` function is as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的代码如下：'
- en: src/main.rs
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: src/main.rs
- en: '[PRE26]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `main()` function displays a prompt to the user, reads a line from `stdin`
    (the command line), and invokes the `evaluate()` function. If the computation
    is successful, it displays the computed AST and the numerical value. If unsuccessful,
    it prints an error message.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数向用户显示提示，从`stdin`（命令行）读取一行，并调用`evaluate()`函数。如果计算成功，它将显示计算出的AST和数值。如果失败，它将打印错误信息。'
- en: 'The code for the `evaluate()` function is as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluate()`函数的代码如下：'
- en: src/main.rs
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: src/main.rs
- en: '[PRE27]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `evaluate()` function instantiates a new `Parser` with the provided arithmetic
    expression, parses it, and then invokes the `eval()` method on the `AST` module.
    Note the use of the `?` operator for automated propagation of any processing errors
    to the `main()` function, where they are handled with a `println!` statement.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluate()`函数使用提供的算术表达式实例化一个新的`Parser`，解析它，然后在`AST`模块上调用`eval()`方法。注意使用`?`运算符自动传播任何处理错误到`main()`函数，在那里它们通过`println!`语句进行处理。'
- en: 'Run the following command to compile and run the program:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以编译和运行程序：
- en: '[PRE28]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can try out various combinations of positive and negative numbers, decimals,
    arithmetic operators, and optional sub-expressions in parentheses. You can also
    check how an invalid input expression will produce an error message.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试各种正数和负数、小数、算术运算符和可选括号内子表达式的组合。您还可以检查无效输入表达式将产生错误信息。
- en: You can expand this project to add support for mathematical functions such as
    square roots, trigonometric functions, logarithmic functions, and so on. You can
    also add edge cases.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以扩展此项目以添加对平方根、三角函数、对数函数等数学函数的支持。您还可以添加边缘情况。
- en: With this, we conclude the first full-length project in this book. I hope this
    project has given you an idea not just of how idiomatic Rust code is written,
    but also of how to think in Rust terms while designing a program.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了本书的第一个完整项目。我希望这个项目不仅让您了解了惯用的Rust代码是如何编写的，而且还让您了解了在设计程序时如何以Rust的方式思考。
- en: The complete code for the `main()` function can be found in the `main.rs` file
    in the GitHub folder for this chapter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`main()`函数代码可以在GitHub文件夹中本章的`main.rs`文件中找到。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a command-line application from scratch in Rust, without
    using any third-party libraries, to compute the value of the arithmetic expressions.
    We covered many basic concepts in Rust, including data types, how to model and
    design an application domain with Rust data structures, how to split code across
    modules and integrate them, how to structure code within a module as functions,
    how to expose module functions to other modules, how to do pattern matching for
    elegant and safe code, how to add functionality to structs and enums, how to implement
    traits and annotate lifetimes, how to design and propagate custom error types,
    how to box types to make data sizes predictable for the compiler, how to construct
    a recursive node tree and navigate it, how to write code that recursively evaluates
    an expression, and how to specify lifetime parameters for structs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从头开始使用Rust构建了一个命令行应用程序，没有使用任何第三方库，来计算算术表达式的值。我们涵盖了Rust的许多基本概念，包括数据类型、如何使用Rust数据结构来建模和设计应用程序领域、如何在模块间分割代码并集成它们、如何在模块内以函数的形式组织代码、如何将模块函数暴露给其他模块、如何进行模式匹配以编写优雅和安全的代码、如何向结构和枚举添加功能、如何实现特性和注解生命周期、如何设计和传播自定义错误类型、如何装箱类型以使数据大小对编译器可预测、如何构建递归节点树并导航它、如何编写递归评估表达式的代码，以及如何为结构指定生命周期参数。
- en: Congratulations if you successfully followed along and got some working code!
    If you had any difficulties, you can refer to the final code in the GitHub repository.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你如果成功跟随着并得到了一些可工作的代码！如果你遇到了任何困难，你可以参考GitHub仓库中的最终代码。
- en: This example project establishes a strong foundation from which to dig into
    the details of system programming in the upcoming chapters. If you haven't fully
    understood every detail of the code, there is no reason to fret. We will be writing
    a lot more code and reinforcing the concepts of idiomatic Rust code as we go along
    in the coming chapters.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例项目为在接下来的章节中深入系统编程的细节提供了一个坚实的基础。如果你没有完全理解代码的每一个细节，没有必要担心。随着接下来的章节，我们将编写更多的代码，并逐步强化Rust惯用代码的概念。
- en: In the next chapter, we will cover the Rust standard library, and see how it
    supports a rich set of built-in modules, types, traits, and functions to perform
    systems programming.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Rust标准库，并了解它如何支持丰富的内置模块、类型、特性和函数，以执行系统编程。
