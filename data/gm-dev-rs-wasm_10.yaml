- en: '*Chapter 8*: Adding a UI'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：添加UI'
- en: It may appear that we've developed everything we need for a video game, and
    to some extent, we have, except for that annoyance where we need to hit refresh
    every time little **Red Hat Boy** (**RHB**) hits a rock. A real game has buttons
    for a "new game" or "high scores", and in this chapter, we'll be adding that UI.
    To do so may seem trivial, but event-driven UIs that you might be familiar with
    from web development are an odd fit with our game loop. To add a simple button,
    we'll need to make significant changes to our application and even write a little
    HTML.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来我们已经为视频游戏开发了一切所需，从某种程度上说，我们确实如此，除了每次小**红帽男孩**（**RHB**）撞到岩石时需要刷新页面的那个烦恼。一个真正的游戏有“新游戏”或“最高分”的按钮，在本章中，我们将添加这个UI。这样做可能看起来微不足道，但你可能从网络开发中熟悉的基于事件的UI与我们的游戏循环并不匹配。为了添加一个简单的按钮，我们需要对我们的应用程序进行重大更改，甚至需要写一点HTML。
- en: 'In this chapter, you''ll do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将执行以下操作：
- en: Design a new game button
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个新的游戏按钮
- en: Show the button on game over
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏结束时显示按钮
- en: Start a new game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: At the end of the chapter, you'll have the framework in place for a more full-featured
    UI and the skills to make it work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将拥有一个更完整功能的UI框架和使其工作的技能。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You'll need a few more assets, this time from the `ui` directory in the `assets`
    download at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
    The font is Kenny Future Narrow from [https://www.kenney.nl](https://www.kenney.nl).
    The button is from [https://www.gameart2d.com/](https://www.gameart2d.com/). Both
    are CC0-licensed. As before, the final code for this chapter is available on the
    corresponding branch at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一些额外的资源，这次来自[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)中的`assets`下载的`ui`目录。字体是来自[https://www.kenney.nl](https://www.kenney.nl)的Kenny
    Future Narrow。按钮来自[https://www.gameart2d.com/](https://www.gameart2d.com/)。两者都是CC0许可。和之前一样，本章的最终代码可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8)的相应分支上找到。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3DrEeNO](https://bit.ly/3DrEeNO)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3DrEeNO](https://bit.ly/3DrEeNO)
- en: Design a new game button
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个新的游戏按钮
- en: When RHB crashes into a rock, he falls over and… well, let's say he takes a
    nap. Unfortunately, at that point, the player has to refresh the page to start
    a new game. In most games, we'd see a series of buttons for a new game and high
    scores. For now, we'll just put in a new game button that will restart from the
    beginning. This might seem like a simple task, but in fact, we'll have quite a
    bit to do.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当RHB撞到岩石上时，他会倒下，嗯，让我们说他要小睡一会儿。不幸的是，到那时，玩家必须刷新页面才能开始新游戏。在大多数游戏中，我们会看到一系列用于新游戏和最高分的按钮。目前，我们只将添加一个新游戏按钮，它会从头开始重新开始。这看起来可能是一个简单的任务，但实际上，我们还有很多事情要做。
- en: First, we need to decide how we want to implement the button. We really have
    two choices. We can create a button in the engine, which would be a sprite that
    is rendered to the canvas, the same as everything else, or we can use an HTML
    button and position it over the canvas. The first option will look right and won't
    require any traditional web programming, but it will also require us to detect
    mouse clicks and handle a button-click animation. In other words, we'd have to
    implement a button. That's more than we want to implement to get our game working,
    so we're going to use a traditional HTML button and make it *look* like it's a
    game element.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要决定我们想要如何实现按钮。我们实际上有两个选择。我们可以在引擎中创建一个按钮，这将是一个渲染到画布上的精灵，就像其他所有东西一样，或者我们可以使用一个HTML按钮并将其定位在画布上。第一个选项看起来会正确，并且不需要任何传统的网络编程，但它也将要求我们检测鼠标点击和处理按钮点击动画。换句话说，我们可能需要实现一个按钮。这比我们想要实现来让游戏工作要多，所以我们打算使用传统的HTML按钮并使其*看起来*像是一个游戏元素。
- en: So, we're going to write some HTML and CSS, which we can use to make the button
    look like it's a part of the game engine. Then, we'll add the button to the screen
    with Rust and handle the click event. That will be the tough part.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将编写一些HTML和CSS，这样我们就可以让按钮看起来像是游戏引擎的一部分。然后，我们将使用Rust将按钮添加到屏幕上并处理点击事件。这将是难点部分。
- en: Preparing a UI
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备用户界面
- en: Conceptually, our UI will work like a HUD in a FPS or where a button is superimposed
    over the front of a game itself. Imagine that there is a perfectly clear pane
    of glass on top of the game, and the button is a sticker that's stuck to it. This
    means, in the context of a web page, that we need a div that is the same size
    and in the same place as the canvas.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，我们的用户界面将像FPS中的HUD或按钮叠加在游戏本身前面时的工作方式。想象一下，在游戏上方有一个完全透明的玻璃板，按钮就像是一张贴在玻璃上的贴纸。这意味着，在网页的上下文中，我们需要一个与canvas大小和位置相同的div。
- en: Tip
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: This isn't a book on HTML or CSS, so I'm not going to spend much time covering
    it, other than the canvas we've been using throughout. If web development isn't
    your forte, don't worry – a quick scan of [https://learnxinyminutes.com/docs/html/](https://learnxinyminutes.com/docs/html/)
    will cover more than enough. We'll also be using a little bit of CSS in this section,
    and you can get a similar cheat sheet for that syntax at [https://learnxinyminutes.com/docs/css/](https://learnxinyminutes.com/docs/css/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于HTML或CSS的书，所以我不会花太多时间来介绍它，除了我们一直在使用的canvas。如果你不是网页开发的专家，不用担心——快速浏览[https://learnxinyminutes.com/docs/html/](https://learnxinyminutes.com/docs/html/)就能了解足够多的内容。我们也会在这一节中使用一点CSS，你可以在[https://learnxinyminutes.com/docs/css/](https://learnxinyminutes.com/docs/css/)找到类似的速查表。
- en: 'We can start rather quickly by updating `index.html` to have the required div,
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速更新`index.html`以包含所需的div，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that the `ui` div is `position: absolute` so that it doesn''t "push" the
    `canvas` element below it. You can see how this will work by putting a standard
    HTML button in the `div` element, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，`ui` div是`position: absolute`，这样它就不会“推”下面的`canvas`元素。你可以通过将一个标准的HTML按钮放入`div`元素中来看如何实现，如下所示：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will produce a screen that looks like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个看起来如下所示的屏幕：
- en: '![Figure 8.1 – A New Game button!](img/Figure_8.01_B17151.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 新游戏按钮！](img/Figure_8.01_B17151.jpg)'
- en: Figure 8.1 – A New Game button!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 新游戏按钮！
- en: 'It won''t respond very well if you completely shrink the screen horizontally,
    but the game won''t work in that situation, so it should be fine. Now that we
    have a button, we''ll need to make it look like a game element, and for that,
    we''ll need styling. Go ahead and create a file named `styles.css` in the `static`
    directory, and add a link to it in `index.html`, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全水平缩小屏幕，它可能不会响应得很好，但游戏在那个情况下是无法工作的，所以应该没问题。现在我们有了按钮，我们需要让它看起来像是一个游戏元素，为此我们需要添加样式。请创建一个名为`styles.css`的文件在`static`目录下，并在`index.html`中添加对其的链接，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Of course, a link to an empty file doesn''t do much for us. To prove the link
    is working, go ahead and change the `index.html` file slightly, removing the inline
    style on the `ui` div so that it looks like `<div id="ui">`. This will cause the
    button to push the canvas element down, and your game will likely be slightly
    off:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个指向空文件的链接对我们来说并没有什么帮助。为了证明链接是有效的，请修改`index.html`文件，移除`ui` div上的内联样式，使其看起来像`<div
    id="ui">`。这将导致按钮将canvas元素向下推，你的游戏可能会稍微偏离：
- en: '![Figure 8.2 – New Game on top](img/Figure_8.02_B17151.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 新游戏在顶部](img/Figure_8.02_B17151.jpg)'
- en: Figure 8.2 – New Game on top
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 新游戏在顶部
- en: 'Now, in the CSS file, you''ll want to add a style for that div. It''s not really
    important that this style isn''t an inline one, except that this handily checks
    that our CSS file is being loaded. In the CSS file, insert the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在CSS文件中，你将为该div添加一个样式。这个样式不是内联的并不是很重要，除了它能方便地检查我们的CSS文件是否被加载。在CSS文件中，插入以下内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a CSS selector for any elements with the `ui` ID and sets their position
    to `absolute`. If your CSS file is being loaded, then the new game button should
    be over the top of the canvas again. Later, we'll programmatically add that button
    in our game code, but for now, we just want it to show up and look right. We'll
    want to give it a font that looks like a video game, and a background too. Let's
    start with the font. In your assets, you'll see there is a directory called `ui`,
    which contains a file named `kenney_future_narrow-webfont.woff2`. **WOFF** stands
    for **Web Open Font Format** and is a font format that will work in every modern
    browser.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个CSS选择器，用于任何具有`ui` ID的元素，并将它们的定位设置为`absolute`。如果你的CSS文件正在加载，那么新游戏按钮应该再次位于画布的顶部。稍后，我们将在游戏代码中程序化地添加该按钮，但现在我们只想让它显示出来，看起来正确。我们希望给它一个看起来像视频游戏的字体，以及背景。让我们从字体开始。在你的资源中，你会看到一个名为`ui`的目录，其中包含一个名为`kenney_future_narrow-webfont.woff2`的文件。**WOFF**代表**Web开放字体格式**，这是一种在所有现代浏览器中都能工作的字体格式。
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Whenever you''re unsure whether a feature will work with a browser, and sometimes
    when you are sure, check [https://caniuse.com/](https://caniuse.com/) to double-check.
    For WOFF files, you can see the results here: [https://caniuse.com/?search=woff](https://caniuse.com/?search=woff).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你不确定一个功能是否与浏览器兼容，有时即使你确定，也要检查[https://caniuse.com/](https://caniuse.com/)以进行双重确认。对于WOFF文件，你可以在这里看到结果：[https://caniuse.com/?search=woff](https://caniuse.com/?search=woff)。
- en: 'Copy `kenney_future_narrow-webfont.woff2` into the `static` directory in your
    application so that it gets picked up by the build process. Then, you need to
    specify `@font-face` in CSS so that elements can be rendered in it, which looks
    like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将`kenney_future_narrow-webfont.woff2`复制到应用程序的`static`目录中，以便它被构建过程选中。然后，你需要指定CSS中的`@font-face`，以便元素可以在此渲染，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What we''ve done here is load a new font face with the simple name ''`Ken Future`''
    so that we can reference it in other styles, and loaded it via the specified URL.
    Now, we can change all buttons to use that font with this additional CSS:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是加载一个名为`Ken Future`的简单名称的新字体，以便我们可以在其他样式中引用它，并通过指定的URL加载它。现在，我们可以使用这个额外的CSS将所有按钮更改为使用该字体：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you should see the button being rendered with a font that looks more like
    a game, as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能看到按钮以更像是游戏的字体渲染，如下所示：
- en: '![Figure 8.3 – New Game with the Kenney Future Font](img/Figure_8.03_B17151.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 使用Kenney Future字体的新游戏](img/Figure_8.03_B17151.jpg)'
- en: Figure 8.3 – New Game with the Kenney Future Font
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 使用Kenney Future字体的新游戏
- en: The button still looks a lot like an HTML button because of that traditional
    web background. To make it look more like a game button, we'll use a background
    and CSS Sprites to create a pretty button with rounded corners and hover colors.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于那个传统的网络背景，按钮仍然看起来非常像HTML按钮。为了使其看起来更像游戏按钮，我们将使用背景和CSS精灵来创建一个具有圆角和悬停颜色的漂亮按钮。
- en: CSS Sprites
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS精灵
- en: As a game developer, you already know what a sprite is; you haven't forgotten
    [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*,
    already, have you? In the case of **CSS Sprites**, the term as commonly used is
    a bit of a misnomer, as instead of referring to a sprite, it really refers to
    a sprite sheet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏开发者，你已经知道什么是精灵；你没有忘记[*第2章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)，*绘制精灵*，对吧？在**CSS精灵**的情况下，这个术语有点名不副实，因为它实际上并不是指精灵，而是指精灵图。
- en: Conceptually, CSS Sprites work the same way as rendering them with the canvas.
    You slice out a chunk of a larger sprite and only render that portion. We'll just
    do the entire thing in CSS instead of Rust. Since we're using CSS, we can change
    the background when the mouse is over the button and when it is clicked. This
    will make the button look correct, and we won't have to write Rust code to have
    the same effect. Clicking a button is something a browser is very good at, so
    we'll leverage it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，CSS精灵的工作方式与使用canvas渲染它们相同。你从更大的精灵中切出一块，并只渲染那一部分。我们将只使用CSS而不是Rust来完成整个操作。由于我们使用CSS，我们可以改变鼠标悬停在按钮上和点击按钮时的背景。这将使按钮看起来正确，我们不需要编写Rust代码就能达到相同的效果。点击按钮是浏览器非常擅长的事情，所以我们将利用它。
- en: 'We''ll use the `Button.svg` file from the `ui` directory in the downloaded
    assets, so you can copy that file to the `static` directory in your game''s project.
    The SVG file actually contains an entire library of buttons, which looks like
    this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用下载资源中`ui`目录下的`Button.svg`文件，因此你可以将该文件复制到游戏项目的`static`目录中。SVG文件实际上包含了一个完整的按钮库，看起来如下所示：
- en: '![Figure 8.4 – The top of Button.svg](img/Figure_8.04_B17151.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – Button.svg的顶部](img/Figure_8.04_B17151.jpg)'
- en: Figure 8.4 – The top of Button.svg
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – Button.svg的顶部
- en: 'We''ll want to slice out the wide blue, green, and yellow buttons to be the
    background for the button in various states. We''ll start by using the `background`
    attribute in CSS to set the button''s background to the SVG file. You''ll update
    the style as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望裁剪出宽的蓝色、绿色和黄色按钮，作为按钮在不同状态下的背景。我们将首先使用CSS中的`background`属性将按钮的背景设置为SVG文件。您将按照以下方式更新样式：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The pixel values in `background`, `-72px` and `-60px`, mean taking the background
    and shifting it `72` pixels to the left and `60` pixels upward to line it up with
    the blank blue button. You can get those values in a vector graphics editor such
    as `url` value specifies which file to load. Make those changes, and you'll see
    the button change to have a new background… well, sort of.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`background`中的像素值`-72px`和`-60px`表示将背景向左移动`72`像素，向上移动`60`像素以与空白蓝色按钮对齐。您可以在矢量图形编辑器中获取这些值，例如`url`值指定要加载的文件。进行这些更改后，您会看到按钮的背景变成了新的背景……嗯，差不多吧。
- en: '![Figure 8.5 – The button, but with a cut-off background](img/Figure_8.05_B17151.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 按钮及裁剪后的背景](img/Figure_8.05_B17151.jpg)'
- en: Figure 8.5 – The button, but with a cut-off background
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 按钮及裁剪后的背景
- en: 'As you can see, the background is cut off, so you only get half of it, and
    the button itself still has some of the effects of a default HTML button. We can
    get rid of those effects with a little more CSS to remove the border and resize
    the button to match the background, as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，背景被裁剪了，所以您只能看到一半，按钮本身仍然保留了一些默认HTML按钮的效果。我们可以通过添加更多的CSS来去除边框并将按钮大小调整为与背景匹配，如下所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `width` and `height` values were plucked from *Inkscape~ again, and that
    will set the button to be the same size as the button background in the source.
    As with the sprite sheets we used earlier, we need to cut out a slice from the
    original source, so in this case, there is a rectangle starting at `(72, 60)`
    with a width and height of `82x33`. With those changes, the button now looks like
    a game button instead of a web button.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`和`height`值是从*Inkscape~中提取的，这将使按钮与源中的按钮背景大小相同。与之前使用的精灵图一样，我们需要从原始源中裁剪出一个部分，所以在这种情况下，有一个从`(72,
    60)`开始的矩形，宽度和高度为`82x33`。进行这些更改后，按钮现在看起来像是一个游戏按钮而不是一个网页按钮。'
- en: '![Figure 8.6 – A New Game button'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 新的游戏按钮'
- en: '](img/Figure_8.6_B17151.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 8.6 – B17151](img/Figure_8.6_B17151.jpg)'
- en: Figure 8.6 – A New Game button
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 新的游戏按钮
- en: There are still a few problems. The button now doesn't visually interact with
    the user, so it just looks like a picture when you click it. We can address that
    with CSS pseudo-classes for `#active` and `#hover`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然还有一些问题。按钮现在在视觉上没有与用户交互，所以点击时它看起来就像一张图片。我们可以通过CSS伪类`#active`和`#hover`来解决这个问题。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some browsers, notably Firefox, will render **New Game** on one line instead
    of two.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器，特别是Firefox，会将**新游戏**渲染在一行上而不是两行。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on pseudo-classes, check the Mozilla documentation here:
    [https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于伪类的信息，请查看Mozilla文档：[https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes)。
- en: In each pseudo-class, we'll change the background attribute to line up with
    another background. Again, the numbers were pulled out of Inkscape, with a little
    tweaking once they were added to make sure that they lined up. First, we can handle
    the `hover` style, which is when the mouse is over the image.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个伪类中，我们将更改背景属性以与另一个背景对齐。同样，数字是从Inkscape中提取的，一旦添加到其中，就会进行一些调整以确保它们对齐。首先，我们可以处理`hover`样式，即鼠标悬停在图像上时。
- en: 'That produces a hover button that looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个看起来像这样的悬停按钮：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Figure 8.7 – Hover'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 悬停'
- en: '](img/Figure_8.7_B17151.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 8.7 – 悬停](img/Figure_8.7_B17151.jpg)'
- en: Figure 8.7 – Hover
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 悬停
- en: 'Then, we''ll add the `active` style, which is what the mouse will look like
    when clicked:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加`active`样式，这是鼠标点击时的样子：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That produces a clicked button like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个点击后的按钮，看起来像这样：
- en: '![Figure 8.8 – Active](img/Figure_8.8_B17151.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 激活状态](img/Figure_8.8_B17151.jpg)'
- en: Figure 8.8 – Active
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 激活状态
- en: 'The final issue is that our button is really small, for a game anyway, and
    is positioned at the upper-left corner. Making the button larger the traditional
    CSS way with width and height is problematic, as shown here when we change the
    width value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的问题是，我们的按钮真的很小，对于一个游戏来说，并且位于左上角。使用传统的 CSS 方法（宽度）和高度来放大按钮是有问题的，就像我们在这里改变宽度值时看到的那样：
- en: '![Figure 8.9 – That is not a button](img/Figure_8.09_B17151.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 那不是一个按钮](img/Figure_8.09_B17151.jpg)'
- en: Figure 8.9 – That is not a button
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 那不是一个按钮
- en: 'Changing the width or height will mean changing the "slice" that we''re taking
    from the sprite sheet, so we don''t want that. What we''ll use instead is the
    CSS `translate` property, with the `scale` function, which looks like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 改变宽度和高度将意味着改变我们从精灵图中取出的“切片”，所以我们不希望这样。我们将使用的是 CSS 的 `translate` 属性，配合 `scale`
    函数，看起来是这样的：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This gives us a nice large button with the right background, but it's not in
    the right spot.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个大小合适、背景正确的按钮，但它不在正确的位置。
- en: '![Figure 8.10 – The button with the left side cut off](img/Figure_8.10_B17151.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 按钮的左侧被切掉](img/Figure_8.10_B17151.jpg)'
- en: Figure 8.10 – The button with the left side cut off
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 按钮的左侧被切掉
- en: 'Now that the button is large and looks like a game button, we just need to
    put it in the right spot. You can do that by adding `translate` to the `transform`
    property, where `translate` is a fancy way of saying `move`. You can see that
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按钮变大了，看起来像是一个游戏按钮，我们只需要将其放置在正确的位置。你可以通过添加 `translate` 到 `transform` 属性来实现这一点，其中
    `translate` 是 `move` 的一个花哨说法。你可以如下看到：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will get the new game button into, roughly, the center of the screen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使新游戏按钮大致位于屏幕中央。
- en: '![Figure 8.11 – A New Game button!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11 – 新游戏按钮！](img/Figure_8.11_B17151.jpg)'
- en: '](img/Figure_8.11_B17151.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11 – 新游戏按钮！](img/Figure_8.11_B17151.jpg)'
- en: Figure 8.11 – A New Game button!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 新游戏按钮！
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Centering a button in a div requires a little more CSS than I want to cover
    in this book. Since we''re positioning things manually, we can go with "good enough"
    for now. If you''re more comfortable with web development, feel free to make it
    truly perfectly centered. If you''re interested in getting the perfect center
    with Flexbox, take a look here: [https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989](https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 div 中居中按钮需要比我在这本书中想要覆盖的 CSS 知识更多。由于我们正在手动定位事物，我们可以先“过得去”。如果你对 Web 开发更熟悉，请随意使其真正完美居中。如果你对使用
    Flexbox 实现完美居中感兴趣，请查看这里：[https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989](https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989)。
- en: The new game button now shows up, but it doesn't do anything because our code
    isn't doing anything with `onclick`. It's just a floating button, taunting us
    with its ineffectiveness. Go ahead and remove the `button` element from `index.html`,
    but keep `div` with the `ui` ID. Instead, we'll use Rust to dynamically add and
    remove the button when we need it and actually handle the clicks. For that, we'll
    want to make some additions to our `browser` and `engine` modules, so let's dig
    in.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 新的游戏按钮现在显示出来了，但它没有任何作用，因为我们的代码没有对 `onclick` 做任何处理。它只是一个悬浮的按钮，用它的无效性来挑衅我们。请继续从
    `index.html` 中移除 `button` 元素，但保留具有 `ui` ID 的 `div`。相反，我们将使用 Rust 在需要时动态添加和移除按钮，并实际处理点击事件。为此，我们需要对我们的
    `browser` 和 `engine` 模块做一些扩展，让我们深入研究。
- en: Showing the button with Rust
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Rust 显示按钮
- en: 'We''ve written HTML to show the button and it looks pretty good, but we''ll
    actually need to show it and hide it on command. This means interacting with the
    browser and using the `browser` module. We haven''t done this in a while, so let''s
    refresh our memory on how we translate from the JavaScript we''d write traditionally
    to the Rust with `web-sys` that we''ll be using. First, we''ll need code to insert
    the button into the `ui` div. There are lots of ways to do this; we''ll use `insertAdjacentHTML`
    so that we can just send a string from our code to the screen. In JavaScript,
    that looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了 HTML 代码来显示按钮，看起来相当不错，但实际上我们需要能够根据命令显示和隐藏它。这意味着我们需要与浏览器交互并使用 `browser`
    模块。我们有一段时间没有这样做过了，所以让我们回顾一下如何将我们传统上会写的 JavaScript 代码转换为我们将要使用的 `web-sys` 的 Rust
    代码。首先，我们需要代码来将按钮插入到 `ui` div 中。有好多方法可以做到这一点；我们将使用 `insertAdjacentHTML`，这样我们就可以直接从代码中将字符串发送到屏幕上。在
    JavaScript 中，它看起来是这样的：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the docs for this function at [https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML).
    When it comes to looking up browser APIs, the **Mozilla Developer Network** (**MDN**)
    is your friend.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML)找到这个函数的文档。当涉及到查找浏览器API时，**Mozilla开发者网络**（**MDN**）是你的朋友。
- en: 'We spent a lot of time translating this kind of code into Rust in [*Chapter
    2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*, and [*Chapter
    3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063), *Creating a Game Loop*, but
    let''s refresh our memory and appease any monsters who read books out of order.
    Any JavaScript function or method is likely to be found in the `web-sys` crate
    with the name converted from PascalCase to snake_case, and with most of the functions
    returning `Option`. Frequently, you can just try that out, and it will work. Let''s
    create a new function in `browser` and see whether that''s the case, as shown
    here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)“绘制精灵”和[*第3章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)“创建游戏循环”中花费了大量时间将此类代码转换为Rust，但让我们刷新一下记忆，安抚一下那些按顺序阅读书籍的怪物。任何JavaScript函数或方法都可能在`web-sys`包中找到，其名称已从PascalCase转换为snake_case，并且大多数函数返回`Option`。通常，你可以尝试一下，它就会工作。让我们在`browser`中创建一个新的函数，看看是否如此，如下所示：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `draw_ui` function assumes there is a div with the `ui` ID, just as the
    `canvas` function assumes an ID of `canvas`. This means it's not *incredibly*
    generic, but we don't need a more complex solution right now. If we do later,
    we'll write more functions. As always, we don't want to go too far with some idea
    of "perfect" code because we've got a game to finish.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`draw_ui`函数假设存在一个具有`ui` ID的div，就像`canvas`函数假设有一个`canvas` ID一样。这意味着它并不**非常**通用，但我们现在不需要更复杂的解决方案。如果我们以后需要，我们会编写更多的函数。一如既往，我们不希望因为“完美”代码的想法而走得太远，因为我们还有游戏要完成。
- en: 'Once again, the Rust version of the code is much longer, using `and_then` and
    mapping errors to make sure we handle the error cases instead of just crashing
    or halting the program as JavaScript would. This is another case where code is
    aesthetically less pleasing in Rust but, in my opinion, better because it highlights
    the possible causes of an error. The other function we''ll need right away is
    used to hide the `ui` element, which looks like this in JavaScript:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Rust版本的代码要长得多，使用`and_then`和映射错误来确保我们处理错误情况，而不是像JavaScript那样崩溃或停止程序。这是代码在Rust中在美学上不那么吸引人，但在我看来更好的一个案例，因为它突出了错误的可能原因。我们马上需要的另一个函数是用来隐藏`ui`元素，它在JavaScript中的样子如下：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function grabs the first child of the `ui` div and removes it with the
    `removeChild` method. To be completely thorough, we should loop through all the
    `ui` children and make sure they all get removed, but we don''t do that here because
    we already know there''s only one. We also remove the children (and don''t just
    set their visibility to hidden) so that they do not affect the layout, and any
    event listeners are removed. Once again, you''ll want to translate JavaScript
    to Rust. In this case, `firstChild` becomes the `first_child()` method and `removeChild`
    becomes `remove_child`, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数获取`ui` div的第一个子元素，并使用`removeChild`方法将其移除。为了彻底，我们应该遍历所有的`ui`子元素并确保它们都被移除，但我们在这里没有这么做，因为我们已经知道只有一个。我们还移除了子元素（而不仅仅是设置它们的可见性为隐藏），这样它们就不会影响布局，并且移除了任何事件监听器。再次强调，你将需要将JavaScript转换为Rust。在这种情况下，`firstChild`变为`first_child()`方法，`removeChild`变为`remove_child`，如下所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function is a little different than `draw_ui`, in part because `first_child`
    being missing isn't an error; it just means you called `hide_ui` on an empty UI,
    and we don't want that to error. That's why we use the `if let` construct and
    just return an `Ok(())` explicitly if it isn't present. The `ui` div was already
    empty, so it's fine. In addition, there's that weird call to `map(|_removed_child|
    ())`, which we call because `remove_child` returns the `Element` being removed.
    We don't care about it here, so we are, once again, explicitly mapping it to our
    expected value of unit. Finally, of course, we address the error with `anyhow!`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与 `draw_ui` 有点不同，部分原因是因为 `first_child` 缺失不是一个错误；它只是意味着你在一个空的 UI 上调用了 `hide_ui`，而我们不希望它出错。这就是为什么我们使用
    `if let` 构造，并在它不存在时显式地返回 `Ok(())`。`ui` div 已经是空的，所以这没问题。此外，还有那个奇怪的调用 `map(|_removed_child|
    ())`，我们之所以调用它是因为 `remove_child` 返回正在被移除的 `Element`。我们在这里不关心它，所以我们再次显式地将它映射到我们的单元值。最后，当然，我们使用
    `anyhow!` 处理错误。
- en: 'This function reveals some duplication, so let''s go ahead and refactor it
    out in the final version, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数揭示了一些重复，所以让我们在最终版本中继续重构它，如下所示：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we've replaced both of the repetitive `document().and_then` calls with
    calls to `find_ui`, which is a private function that ensures we always get the
    same error when UI isn't found. It streamlines a little bit of code and makes
    it possible to use the `try` operator in `draw_ui`. The `find_ui` function returns
    `Element`, so you need to make sure to import `web_sys::Element`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将两个重复的 `document().and_then` 调用替换为对 `find_ui` 的调用，这是一个私有函数，它确保我们在找不到 UI
    时总是得到相同的错误。这简化了一小部分代码，并使得在 `draw_ui` 中使用 `try` 操作符成为可能。`find_ui` 函数返回 `Element`，所以你需要确保导入
    `web_sys::Element`。
- en: We've got the tools we need to draw the button set up in `browser`. To show
    our button programmatically, we can just call `browser::draw_ui("<button>New Game</button>")`.
    That's great, but we can't actually handle doing anything on the button click
    yet. We have two choices. The first is to create the button with an `onclick`
    handler such as `browser::draw_ui("<button onclick='myfunc'>New Game</button>")`.
    This will require taking a function in our Rust package and exposing it to the
    browser. It would also require some sort of global variable that the function
    could operate on. If `myfunc` is going to operate on the game state, then it needs
    access to the game state. We could use something such as an event queue here,
    and that's a viable approach, but it's not what we'll be doing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `browser` 中设置了绘制按钮所需的工具。要程序化地显示我们的按钮，我们只需调用 `browser::draw_ui("<button>New
    Game</button>")`。这很好，但我们实际上还不能处理按钮点击事件。我们有两种选择。第一种是创建一个带有 `onclick` 处理程序的按钮，例如
    `browser::draw_ui("<button onclick='myfunc'>New Game</button>")`。这将需要将我们的 Rust
    包中的函数暴露给浏览器。它还需要某种类型的全局变量，该函数可以操作它。如果 `myfunc` 要操作游戏状态，那么它需要访问游戏状态。我们可以在事件队列中使用某种方法，这是一个可行的方案，但不是我们将要做的。
- en: 'What we''re going to do instead is set the `onclick` variable in Rust code,
    via the `web-sys` library, to a closure that writes to a channel. Other code can
    listen to this channel and see whether a click event has happened. This code will
    be very similar to the code we wrote in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*, for handling keyboard input. We''ll start with a function
    in the `engine` module that takes `HtmlElement` and returns `UnboundedReceiver`,
    as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的相反是，通过 `web-sys` 库在 Rust 代码中设置 `onclick` 变量，将其设置为写入通道的闭包。其他代码可以监听这个通道，看看是否发生了点击事件。这段代码将与我们在
    [*第 3 章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063) 中编写的代码非常相似，即 *创建游戏循环*，用于处理键盘输入。我们将在
    `engine` 模块中从一个函数开始，该函数接受 `HtmlElement` 并返回 `UnboundedReceiver`，如下所示：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Don''t forget to bring `HtmlElement` into scope with `use web_sys::HtmlElement`.
    This doesn''t do much, and it sure doesn''t seem to have anything to do with a
    click, and it''s not obvious why we need an `UnboundedReceiver`. When we add a
    click handler to the button, we don''t want to have to move anything about the
    game *into* the closure. Using a channel here lets us encapsulate the handling
    of the click and separate it from the reacting to click event. Let''s continue
    by creating the `on_click` handler, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用 `use web_sys::HtmlElement` 将 `HtmlElement` 带入作用域。这并不会做太多，而且看起来似乎与点击事件无关，而且我们也不明显地需要
    `UnboundedReceiver`。当我们给按钮添加点击处理程序时，我们不想移动任何关于游戏的元素到闭包中。在这里使用通道让我们能够封装点击处理并使其与对点击事件的响应分离。让我们继续创建
    `on_click` 处理程序，如下所示：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The changes we've made are to make `click_sender` mutable and then move it into
    the newly created closure called `on_click`. You may remember `closure_wrap` from
    the earlier chapters, which needs to take a heap-allocated closure, in other words
    a `Box`, which, in this case, will be passed a `mouse` event that we're not using
    so we can safely skip it. The casting to `Box<dyn FnMut()>` is necessary to appease
    the compiler and allow this function to be converted into `WasmClosure`. Inside
    that, we call the sender's `start_send` function and pass it a unit. Since we're
    not using any other parameters, we can just have the receiver check for any event.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的更改是将`click_sender`变为可变的，然后将其移动到新创建的闭包`on_click`中。你可能还记得前面章节中的`closure_wrap`，它需要接收一个堆分配的闭包，换句话说是一个`Box`，在这个例子中，它将传递一个我们未使用的`mouse`事件，这样我们就可以安全地跳过它。将类型转换为`Box<dyn
    FnMut()>`是必要的，以平息编译器并允许这个函数转换为`WasmClosure`。在这个内部，我们调用发送者的`start_send`函数并传递一个单位。由于我们没有使用任何其他参数，我们只需让接收者检查任何事件即可。
- en: 'Finally, we''ll need to take this closure and assign it to the `on_click` method
    on `elem` so that the button actually handles it, which looks as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将这个闭包分配给`elem`上的`on_click`方法，以便按钮实际上可以处理它，如下所示：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've added the call to `elem.set_onclick`, which corresponds to `elem.onclick
    =` in JavaScript. Note how we pass `set_onclick` a `Some` variant because `onclick`
    itself can be `null` or `undefined` in JavaScript and, therefore, can be `None`
    in Rust and is an `Option` type. We then pass it `on_click.as_ref().unchecked_ref()`,
    which is the pattern we've used several times to turn `Closure` into a function
    that `web-sys` can use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了对`elem.set_onclick`的调用，这对应于JavaScript中的`elem.onclick =`。注意我们如何将`set_onclick`传递一个`Some`变体，因为`onclick`本身在JavaScript中可以是`null`或`undefined`，因此，在Rust中可以是`None`，它是一个`Option`类型。然后我们传递`on_click.as_ref().unchecked_ref()`，这是我们多次使用来将`Closure`转换为`web-sys`可以使用函数的模式。
- en: Finally, we also make sure to forget the `on_click` handler. Without this, when
    we actually make this callback, the program will crash because `on_click` hasn't
    been properly handed off to JavaScript. We've done this a few times, so I won't
    belabor the point here. Now that we've written all the code, we'll need to show
    a button and handle the response to it, and we need to integrate it into our game.
    Let's figure out how to show the button.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还要确保忘记`on_click`处理程序。如果没有这个处理程序，当我们实际创建这个回调时，程序将会崩溃，因为`on_click`尚未正确地传递给JavaScript。我们这样做了几次，所以在这里我不会过多地强调这一点。现在我们已经编写了所有代码，我们需要显示一个按钮并处理对其的响应，并且我们需要将其集成到我们的游戏中。让我们弄清楚如何显示这个按钮。
- en: Show the button on game over
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束时显示按钮
- en: We can show and hide the button in the `Game` `update` method by checking on
    each frame if the game is over and if the button is present, ensuring that we
    only show or hide it once, and that would probably work, but I think you can sense
    the spaghetti code beginning to form if we do that. In general, it's best to avoid
    too much conditional logic in `update`, as it gets confusing and allows for logic
    bugs. Instead, we can think of every conditional check that looks like `if (state_is_true)`
    as two different states of the system. So, if the new game button is shown, that's
    one game state, and if it isn't, that's another game state. You know what that
    means – it's time for a state machine.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Game`的`update`方法中通过检查每一帧游戏是否结束以及按钮是否存在来显示和隐藏按钮，确保我们只显示或隐藏一次，这可能会工作，但我认为你可以感觉到如果这样做，面条代码开始形成。一般来说，最好在`update`中避免过多的条件逻辑，因为它会变得混乱并允许逻辑错误。相反，我们可以将每个看起来像`if
    (state_is_true)`的条件检查视为系统的两种不同状态。所以，如果新游戏按钮被显示，那就是一种游戏状态，如果它没有被显示，那就是另一种游戏状态。你知道这意味着什么——是时候使用状态机了。
- en: A state machine review
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机回顾
- en: 'In [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing
    Animations with State Machines*, we converted RHB to a state machine in order
    to make it change animations on events easily and, more importantly, correctly.
    For instance, when we wanted RHB to jump, we went from `Running` to `Jumping`
    via a typestate method, only changing the state one time and changing the velocity
    and playing the sound one time. That code is reproduced here for clarity:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093) *使用状态机管理动画*中，我们将RHB转换为状态机，以便在事件上轻松且更重要的是正确地更改动画。例如，当我们想让RHB跳跃时，我们通过类型状态方法从`Running`变为`Jumping`，只改变一次状态，只改变一次速度并播放一次声音。这段代码在此处重现以供清晰理解：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The typestates work great, but they are also noisy if we don''t need that kind
    of functionality. That''s why in that same chapter, we chose to model our game
    itself as a simple `enum`, like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类型状态工作得很好，但如果不需要那种功能，它们也会很嘈杂。这就是为什么在同一个章节中，我们选择将我们的游戏本身建模为一个简单的`enum`，如下所示：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is going to change significantly because we now have a problem that necessitates
    a state machine. When RHB is knocked out, the game is over, and the new game button
    should appear. That''s a side effect that needs to happen once, on a change of
    state, the perfect use case for our state machine. Unfortunately, refactoring
    to a state machine is going to require a not insignificant amount of code because
    our current method for implementing state machines is elegant but a little noisy.
    In addition, there''s actually two state machines at work here, which is not obvious
    at first. The first is the one we see at the beginning, moving from `Loading`
    to `Loaded`, which you can think of as when you don''t have `Walk` and when you
    do. The second is the state machine of `Walk` itself, which moves from `Ready`
    to `Walking` to `GameOver`. You can visualize it like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发生显著变化，因为我们现在有一个需要状态机的难题。当RHB被击倒时，游戏结束，新的游戏按钮应该出现。这是一个在状态改变时需要发生一次的副作用，这正是我们状态机的完美用例。不幸的是，将代码重构为状态机将需要相当数量的代码，因为我们的当前实现状态机的方法虽然优雅，但有点嘈杂。此外，实际上这里有两个状态机在工作，一开始并不明显。第一个是我们一开始看到的，从`Loading`到`Loaded`的状态机，你可以将其视为没有`Walk`和有`Walk`的情况。第二个是`Walk`本身的状态机，它从`Ready`移动到`Walking`再到`GameOver`。你可以这样可视化它：
- en: '![](img/Figure_8.12_B17151.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12](img/Figure_8.12_B17151.jpg)'
- en: Figure 8.12 – Nested state machines
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 嵌套状态机
- en: 'As you can see, we have two state machines here, one going from `Loading` to
    `Loaded` and the other representing the three game states of `Ready`, `Walking`,
    and `GameOver`. There is a third state machine, not pictured, the famous `RedHatBoyStateMachine`
    that manages the `RedHatBoy` animations. A couple of the states pictured mimic
    the states in `RedHatBoyStateMachine`, where `Idle` is `Ready` and `Walking` is
    `Running`, so there is a temptation to move `RedHatBoyStateMachine` into `WalkTheDogStateMachine`.
    This could work, but remember that `Walk` doesn''t have a "jumping" state and
    so, by doing that, you''ll need to start checking a Boolean, and the modeling
    starts to break down. It''s best to accept the similarity because the game is
    heavily dependent on what RHB is doing, but treat `RedHatBoyStateMachine` as having
    more fine-grained states. What *does* work is turning `Loading` and `Loaded` into
    `Option`. Specifically, we''ll model our game like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们这里有两个状态机，一个是从`Loading`到`Loaded`，另一个代表三个游戏状态`Ready`、`Walking`和`GameOver`。还有一个未画出的第三个状态机，著名的`RedHatBoyStateMachine`，它管理着`RedHatBoy`的动画。图中的一些状态模仿了`RedHatBoyStateMachine`中的状态，其中`Idle`是`Ready`，`Walking`是`Running`，因此有将`RedHatBoyStateMachine`移动到`WalkTheDogStateMachine`的诱惑。这可能可行，但请记住，`Walk`没有“跳跃”状态，所以这样做的话，你需要开始检查布尔值，模型开始崩溃。最好接受这种相似性，因为游戏很大程度上依赖于RHB的行为，但将`RedHatBoyStateMachine`视为具有更细粒度的状态。真正起作用的是将`Loading`和`Loaded`转换为`Option`。具体来说，我们将我们的游戏建模如下：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code isn''t meant to be written anywhere yet; it''s just here for clarity.
    There''s a big advantage to using `Option` here, and it has to do with the way
    our `update` function works. For clarity, I''m going to reproduce a section of
    our game loop here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码目前还没有打算在任何地方编写；它只是在这里为了清晰起见。在这里使用`Option`有一个很大的优势，这与我们的`update`函数的工作方式有关。为了清晰起见，我将在下面重现我们游戏循环的一部分：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The key part here is the `game.update` line, which performs a mutable borrow
    on the `game` object instead of moving it into `update`. This is because once
    `game` is owned by `FnMut`, it can''t be moved out. Trying to actually leads to
    this compiler error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的部分是`game.update`行，它对`game`对象执行可变借用，而不是将其移动到`update`中。这是因为一旦`game`被`FnMut`拥有，它就不能被移动出来。尝试这样做会导致以下编译器错误：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Mutable borrows such as this are tricky because they can make it more challenging
    to navigate the borrow checker as you proceed down the call stack. In this case,
    it becomes a problem if we try to implement another state machine in the same
    manner as `RedHatBoyStateMachine`. In our state machine implementation, each `typestate`
    method consumes the machine and returns a new one. Now, let''s imagine that we
    are modeling the entire game as `enum`, like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的可变借用很棘手，因为它们可能会使你在调用栈中向下导航时更难导航借用检查器。在这种情况下，如果我们尝试以与`RedHatBoyStateMachine`相同的方式实现另一个状态机，这会成为一个问题。在我们的状态机实现中，每个`typestate`方法消耗机器并返回一个新的。现在，让我们想象我们正在将整个游戏建模为`enum`，如下所示：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In order to make this work with the mutable borrow in `update`, we would have
    to clone the entire game on every state change because the `from` function couldn't
    take ownership of it. In other words, the closure in our `game.update` function
    *lends* `game` to the `update` function. This can't turn around and *give* it
    to the `from` function – it doesn't own it! Doing so requires cloning the entire
    game, potentially on every frame!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`update`中的可变借用工作，我们不得不在每次状态改变时克隆整个游戏，因为`from`函数无法获取其所有权。换句话说，我们`game.update`函数中的闭包是将`game`“借出”给`update`函数。这不能反过来“给予”`from`函数——它并不拥有它！这样做需要克隆整个游戏，这可能在每一帧都发生！
- en: 'Modeling the game as holding an optional `WalkTheDogStateMachine` has two advantages:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏建模为持有可选的`WalkTheDogStateMachine`有两个优点：
- en: We can call `take` on `Option` to get ownership of the state machine.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在`Option`上调用`take`来获取状态机的所有权。
- en: The type reflects that the state machine isn't available until the game is loaded.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型反映了状态机在游戏加载后才可用。
- en: Note
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: There are, naturally, many ways to model our game type, and some of them are
    going to be better than the one we'll choose here. However, before you start trying
    to do a "simpler" version of this type, let me warn you that I tried several different
    variations on this solution and ultimately found using `Option` to be the most
    straightforward choice. Several other implementations either ended with complex
    borrowing or unnecessary cloning. Be wary, but also be brave. You may find a better
    way than I did!
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自然，有许多方式可以建模我们的游戏类型，其中一些可能比我们在这里选择的更好。然而，在你开始尝试制作这个类型的“更简单”版本之前，让我提醒你，我已经尝试了这种解决方案的几种不同变体，并最终发现使用`Option`是最直接的选择。其他几种实现要么以复杂的借用结束，要么是不必要的克隆。要小心，但也要勇敢。你可能会找到比我更好的方法！
- en: Before we dig into the actual implementation, which is fairly long, let's go
    over the design we're implementing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实际实现之前，这个实现相当长，我们先了解一下我们要实现的设计。
- en: '![Figure 8.13 – Before](img/Figure_8.13_B17151.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 之前](img/Figure_8.13_B17151.jpg)'
- en: Figure 8.13 – Before
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 之前
- en: It's pretty simple, but it doesn't do all that we need it to. Now, let's redesign
    the state machine.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但它并没有做到我们需要的所有事情。现在，让我们重新设计状态机。
- en: '![Figure 8.14 – After'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 – 之后'
- en: '](img/Figure_8.14_B17151.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.14_B17151.jpg)'
- en: Figure 8.14 – After
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 之后
- en: Yeah, that's a lot more code, and it doesn't even reflect the details of the
    implementation, or the `From` traits we write to make it easy to convert between
    the `enum` values and structs. Writing some macros to handle state machine boilerplate
    is out of the scope of this book, but it's not a bad idea. You might wonder why
    every state holds its own `Walk` instance when every single state has it, and
    that's because we're going to change `Walk` on the transitions and the individual
    states don't have easy access to the parent `WalkTheDogState` container data.
    However, where possible, we'll move common data out of `Walk` and into `WalkTheDogState`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这需要更多的代码，甚至没有反映实现的细节，或者我们编写的`From`特质，这些特质使得在`enum`值和结构体之间转换变得容易。编写一些处理状态机模板代码的宏超出了本书的范围，但这不是一个坏主意。你可能会想知道为什么每个状态都持有自己的`Walk`实例，因为每个状态都有它，这是因为我们将在转换时改变`Walk`，而单个状态不容易访问父`WalkTheDogState`容器数据。然而，在可能的情况下，我们将将公共数据从`Walk`移动到`WalkTheDogState`。
- en: Tip
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: This section has a lot of code, and the snippets tend to only show a few lines
    at a time so that it's not too much to process. However, as you're following along,
    you may wish to reorganize the code to be easier to find. For instance, I prefer
    to work top-down in the `game` module, with constants at the top followed by the
    "biggest" `struct`, which is `WalkTheDog` in this case, followed by any code it
    depends on, so that the call stack flows down the page. This is how [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8)
    is organized. You're also welcome to start breaking this up into more files. I
    won't, to make it easier to explain in book form.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节有很多代码，片段通常一次只显示几行，这样就不会太多难以处理。然而，当你跟随时，你可能希望重新组织代码以便更容易找到。例如，我更喜欢在`game`模块中自上而下地工作，顶部是常量，然后是“最大的”`struct`，在这个例子中是`WalkTheDog`，然后是它所依赖的任何代码，这样调用栈就会沿着页面向下流动。这就是[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8)是如何组织的。你也可以开始将其拆分成更多的文件。我不会这样做，以便更容易以书籍的形式解释。
- en: Redesigning to a state machine
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新设计为状态机
- en: In a true refactoring, we would make sure the game was in a running state after
    each change, but our changes are going to cause cascading compiler errors, meaning
    we're going to be broken for a while, so this change isn't truly a refactoring
    but more of a redesign. When you make this kind of change, you should absolutely
    get to a compiling state as quickly as possible and stay there as long as possible,
    but while I did that when writing this chapter, I'm not going to put you through
    all the intermediate steps. We'll move forward as if we know in advance that our
    design is going to work because we do this time, but don't try this at home. If
    you're a regular Git user, now is an excellent time to create a branch, just in
    case.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正的重构中，我们会在每次更改后确保游戏处于运行状态，但我们的更改将导致级联编译错误，这意味着我们将会有一段时间无法工作，所以这个更改并不是真正的重构，而更像是一次重新设计。当你进行这种更改时，你应该尽可能快地进入编译状态，并尽可能长时间地保持在该状态，但尽管我在写这一章时做到了这一点，我并不会让你经历所有中间步骤。我们将继续前进，就好像我们事先就知道我们的设计将会成功一样，因为我们这次就是这样做的，但不要在家里尝试。如果你是Git的常规用户，现在是一个创建分支的绝佳时机，以防万一。
- en: 'We''ll start by replacing this code in the `game` module:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先替换`game`模块中的这段代码：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''ll replace it with the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下内容替换它：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will cause compiler errors all over the place. This is the section where
    we'll take the shortcut of letting the compiler be broken temporarily while we
    implement the state machine, if only to make sure this chapter isn't a thousand
    pages long. So, if you're uncomfortable working with a broken code base for a
    long time, that's good – just trust that I was *brilliant* and got this all right
    on the first try. Pretend – it'll be okay.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在各个地方引发编译错误。这是我们将采取捷径的章节，在实现状态机的同时暂时让编译器出错，只是为了确保这一章不会有一千页那么长。所以，如果你长时间与出错的代码库工作感到不舒服，那很好——只需相信我非常聪明，第一次就全部搞对了。假装一下——一切都会好起来的。
- en: 'Since we''re psychic and know exactly how this design is going to work out,
    we can go and push ahead, knowing that eventually, everything will come together
    without errors. This first change is exactly what we discussed earlier – `enum
    WalkTheDog` becomes a struct holding its `machine` instance, which is an `optional`
    field. Currently, `WalkTheDogStateMachine` doesn''t exist, so we''ll add that
    next, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们具有心灵感应能力，确切地知道这种设计将会如何发展，我们可以继续前进，知道最终一切都会顺利地结合在一起，不会出现错误。这次更改正是我们之前讨论过的内容——`enum
    WalkTheDog`变成了一个包含其`machine`实例的结构体，该实例是一个`optional`字段。目前，`WalkTheDogStateMachine`不存在，所以我们将添加它，如下所示：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we implement a state machine in Rust, we need `enum` as a container for
    states so that `WalkTheDog` doesn''t need to be a generic `struct`. We''ve moved
    the compiler errors down because there is no `WalkTheDogState` and no states defined.
    Let''s do that next:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Rust中实现状态机时，我们需要`enum`作为状态的容器，这样`WalkTheDog`就不需要是一个泛型`struct`。我们已经将编译错误向下移动，因为没有`WalkTheDogState`和定义的状态。让我们接下来这样做：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Right now, the various typestates, `Ready`, `Walking`, and `GameOver`, don''t
    store any data. This will change a little as we go on, but all of the typestates
    have `Walk` so that they can be saved in the common `WalkTheDogState` struct.
    Now that we''ve created the state machine, we need to look at where the old version
    of `WalkTheDog` was used. The first is in the small `impl` block for `WalkTheDog`,
    in the old code where we created `enum`, like so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，各种状态 `Ready`、`Walking` 和 `GameOver` 都不存储任何数据。随着我们的进行，这会有所改变，但所有状态都有 `Walk`，这样它们就可以保存在共同的
    `WalkTheDogState` 结构体中。现在我们已经创建了状态机，我们需要看看旧版本的 `WalkTheDog` 是在哪里被使用的。第一个是在 `WalkTheDog`
    的小型 `impl` 块中，在旧代码中我们创建了 `enum`，如下所示：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That''s not going to work, and it''s not compiling, so instead, let''s replace
    it with an empty `WalkTheDog` instance, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不起作用，并且无法编译，所以让我们用空的 `WalkTheDog` 实例来替换它，如下所示：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This change replaces the old, and not used, `enum` with `machine` set to `None`.
    You can now think of `None` as the `Loading` state, and when a machine is present,
    you are `Loaded`. Speaking of loading, the next logical place to make changes
    is in the `Game` implementation for `WalkTheDog`. Looking at the `initialize`
    function that we''ve been in so many times, you''ll see a compiler error here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改用 `machine` 设置为 `None` 的旧 `enum` 替换掉了。你现在可以将 `None` 视为 `Loading` 状态，当机器存在时，你就是
    `Loaded` 状态。说到加载，下一个逻辑上需要更改的地方是在 `WalkTheDog` 的 `Game` 实现中。查看我们多次遇到的 `initialize`
    函数，你将在这里看到一个编译器错误：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `match self` line is not going to work anymore because `self` isn''t `enum`.
    What we need to do instead is match `machine`, and if it''s `None`, then load
    the new machine, and if it''s present, then use `Err` in the same way we do now
    because `initialize` was somehow called twice. We can start by replacing both
    halves of the `match` statement, so the match should start as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`match self` 这一行将不再起作用，因为 `self` 不是 `enum`。我们需要的做法是匹配 `machine`，如果它是 `None`，那么加载新的机器；如果它存在，那么就使用
    `Err`，就像我们现在做的那样，因为 `initialize` 被以某种方式调用了两次。我们可以从替换 `match` 语句的两个部分开始，所以匹配应该从如下开始：'
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Look closely to see that we now match on `self.machine`, and we match against
    `None`. Before we dig into the `None` match arm, let''s quickly change the match
    on `WalkTheDog::Loaded(_)`, as shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们会发现我们现在匹配 `self.machine`，并且匹配 `None`。在我们深入 `None` 匹配分支之前，让我们快速更改 `WalkTheDog::Loaded(_)`
    的匹配，如下所示：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This simply changes `WalkTheDog::Loaded` to `Some`, using the same error message.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将 `WalkTheDog::Loaded` 改为 `Some`，使用相同的错误信息。
- en: Tip
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In order to get clearer error messages, you can `#[derive(Debug)]` on the `WalkTheDog`
    struct. Doing that has cascading effects because everything it depends on also
    has to `#[derive(Debug)]`, so we won't do that here, but it's a good idea, especially
    if you're running into issues here.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更清晰的错误信息，你可以在 `WalkTheDog` 结构体上使用 `#[derive(Debug)]`。这样做会产生级联效应，因为它所依赖的每一项也必须使用
    `#[derive(Debug)]`，所以我们在这里不会这样做，但这是一个好主意，尤其是如果你在这里遇到问题时。
- en: 'Now that both halves of the match properly match an `Option` type, we need
    to modify `initialization` to return the proper type. At the bottom of the `None`
    branch, you will want to create a state machine like the one shown here, right
    before returning the value:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在匹配语句的两个部分都正确地匹配了 `Option` 类型，我们需要修改 `initialization` 以返回正确的类型。在 `None` 分支的底部，你将想要创建一个类似于以下所示的状态机，在返回值之前：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is very similar to the code before; the construction of `Walk` is unchanged,
    but it's obscured by all the state machine noise. We are binding the `machine`
    variable to `WalkTheDogStateMachine::Ready` with the initialized `WalkTheDogState`
    instance, which, in turn, sets its internal `_state` value to `Ready`, and with
    the state getting to have `Walk`. It's noisy, and after we get this file back
    to compiling, we'll do true refactoring to make that line a little cleaner, but
    put a pin in that for now.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的代码非常相似；`Walk` 的构建没有改变，但它被所有状态机的噪音所掩盖。我们将 `machine` 变量绑定到 `WalkTheDogStateMachine::Ready`，使用初始化的
    `WalkTheDogState` 实例，这反过来又将其内部 `_state` 值设置为 `Ready`，并且状态具有 `Walk`。这很嘈杂，在我们将这个文件重新编译后，我们将进行真正的重构，使这一行更干净一些，但现在我们先把它放在一边。
- en: 'Now, we made it so that `initialize` returns a new `Result<Box<dyn Game>>`
    a while back, so we''ll need to return a new `Game` instance next. So, right after
    adding `machine`, add the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们之前让 `initialize` 返回一个新的 `Result<Box<dyn Game>>`，所以我们需要返回一个新的 `Game` 实例。所以，在添加
    `machine` 之后，添加以下内容：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Given that `initialize` takes `self` and doesn't really use it, it's debatable
    whether it should be in the `Game` trait. Creating a separate trait, such as `Initializer`,
    will require a lot of modifications and is an exercise for the reader.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `initialize` 接收 `self` 并实际上没有使用它，所以它在 `Game` 特质中是否应该存在是有争议的。创建一个单独的特质，例如
    `Initializer`，将需要大量的修改，这是一项留给读者的练习。
- en: This takes care of making sure `initialize` returns a game with a machine in
    the right state. We have two more big trait methods, `update` and `draw`, to take
    care of, and `update` is filled with compiler errors, so let's do that next.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了 `initialize` 返回一个机器处于正确状态的游戏。我们还有两个更大的特质方法，`update` 和 `draw`，需要处理，而 `update`
    填满了编译错误，所以让我们接下来处理它。
- en: Spreading update into the state machine
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将更新扩展到状态机
- en: 'The `update` function is filled with compiler errors, is the core of the game''s
    behavior, and has an additional challenge. Instinctively, you might think you
    can modify the beginning of the function like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 函数充满了编译错误，是游戏行为的核心，并且还有一个额外的挑战。直观地，你可能认为你可以像这样修改函数的开始部分：'
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `if let Some(machine) = self.machine` line will eventually fail to compile
    with the error:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`if let Some(machine) = self.machine` 这行代码最终会因以下错误而无法编译：'
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, you may try, as I did, to fix this by changing the line to `if let Some(machine)
    = &mut self.machine`. This will work until you try to implement a transition on
    `WalkTheDogState`. Because you have a borrowed machine, you''ll also have a borrowed
    state when you later match on the state, as with the following example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能尝试，就像我一样，通过将行更改为 `if let Some(machine) = &mut self.machine` 来修复这个问题。这会一直有效，直到你尝试在
    `WalkTheDogState` 上实现一个转换。因为你有一个借用的机器，当你后来在状态上匹配时，你也会有一个借用的状态，就像以下示例所示：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, the `state` value is borrowed, unlike in most other cases where the match
    arms take ownership of the value, and it''s not instantly obvious. It will be
    if we write a transition from `Ready` to `Walking`. In order to write `state._state.run_right()`
    and get to `Walking`, your transition will need to look like this in order to
    compile:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`state` 值是借用的，与大多数其他情况不同，其中匹配分支会接管值，并且这不是立即显而易见的。如果我们将从 `Ready` 转换到 `Walking`，它就会变得明显。为了编写
    `state._state.run_right()` 并到达 `Walking`，你的转换需要像下面这样才能编译：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that we are transitioning from `&mut WalkTheDogState<Ready>>` to `WalkTheDogState<Walking>`,
    which is an odd conversion and a hint that this is wrong. What you can''t see
    is that this code won''t compile. Returning the new `WalkTheDogState` with `walk`
    is a move that we cannot do because `state` is borrowed. The `start_running` method
    doesn''t own `state`, so it can''t take ownership of `state.walk` and, therefore,
    can''t return the new instance. The workaround for this is to clone the entire
    `Walk` each time we transition, but there''s no need for that inefficiency. We
    can, instead, take ownership of `machine` all the way back up in the `Game` implementation,
    through the aptly named `take` function. Instead of using a mutable borrow on
    the machine, we''ll call `take`, as shown here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在从 `&mut WalkTheDogState<Ready>>` 转换到 `WalkTheDogState<Walking>`，这是一个奇怪的转换，也是一个错误的提示。你看不见的是，这段代码无法编译。使用
    `walk` 返回新的 `WalkTheDogState` 是我们不能做的操作，因为 `state` 是借用的。`start_running` 方法不拥有
    `state`，因此它不能接管 `state.walk`，因此不能返回新的实例。这个问题的解决方案是在每次转换时克隆整个 `Walk`，但这样做效率低下。相反，我们可以在
    `Game` 实现中一直向上接管 `machine` 的所有权，通过名为 `take` 的合适函数。我们不会在机器上使用可变借用，而是像下面这样调用 `take`：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is the same code as earlier, but instead, we call the `take` method on
    `Option<WalkTheDogStateMachine>`. This replaces the state machine in `self` with
    `None` and binds the existing `machine` to the variable in `if let Some(machine)`.
    Now, inside that scope, we have complete ownership of `machine` and can do whatever
    we like to it, before eventually calling `replace` on the state machine in `self`
    to move it back in at the end of this function. It''s a little awkward, but it
    gets around mutable borrows. It *also* introduces a potential error in that when
    control exits the `update` function, `machine` could still be set to `None`, effectively
    halting the game by accident. In order to prevent that from happening, before
    we continue updating this function, we''ll add `assert` just outside the `if let`
    statement, as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前相同，但这次我们在 `Option<WalkTheDogStateMachine>` 上调用了 `take` 方法。这会将 `self`
    中的状态机替换为 `None`，并将现有的 `machine` 绑定到 `if let Some(machine)` 中的变量。现在，在这个作用域内，我们对
    `machine` 拥有完全的控制权，可以在最终调用 `self` 中状态机的 `replace` 方法将其移回函数末尾之前做任何我们想做的事情。这有点尴尬，但它可以绕过可变借用的问题。它还引入了一个潜在的错误，即当控制退出
    `update` 函数时，`machine` 可能仍然被设置为 `None`，这可能会意外地停止游戏。为了防止这种情况发生，在我们继续更新这个函数之前，我们将在
    `if let` 语句之外添加 `assert`，如下所示：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Unfortunately, this is a runtime error, not a compile-time one, but it''s going
    to let us know right away whether we mess up the next section. This `assert` may
    be overkill, because we are going to dramatically reduce the amount of code inside
    the `if let` block; in fact, it will be just one line. First, we''ll add a call
    to a non-existent function called `update` on our state machine, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这是一个运行时错误，而不是编译时错误，但它会立即让我们知道我们是否在下一部分中出错。这个 `assert` 可能有点过度，因为我们将在 `if
    let` 块内部显著减少代码量；事实上，它将只有一行。首先，我们将向我们的状态机添加一个对不存在函数 `update` 的调用，如下所示：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Immediately after `if let Some(machine)`, add the `self.machine.replace(machine.update(keystate))`
    line. All the code below `replace` in the `if let` block is going to become part
    of various `update` functions in the implemented states, so what you''ll want
    to do is either cut and paste that code to some place you can get it, or just
    comment it out. Next, we''ll create `impl` on `WalkTheDogStateMachine` with this
    new `update` method, which will return the new state. An empty version of that
    will look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if let Some(machine)` 之后立即添加 `self.machine.replace(machine.update(keystate))`
    这一行。`if let` 块中 `replace` 以下的全部代码将变成实现状态中的各种 `update` 函数的一部分，所以你想要做的是要么将这段代码复制粘贴到你可以获取它的某个地方，要么简单地注释掉它。接下来，我们将在
    `WalkTheDogStateMachine` 上创建一个 `impl`，使用这个新的 `update` 方法，它将返回新的状态。这个空的版本看起来像这样：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, you can call that from the the `update` method in `Game`, which looks
    like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从 `Game` 中的 `update` 方法调用它，它看起来像这样：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `update` method in `WalkTheDogStateMachine` is a little empty, and we should
    probably put some code in it. We could call `match self` in the update, and then
    write the behavior for each state in this `update` function, calling things such
    as `state._state.walk.boy.run_right()`, which would work but it is hideous. Instead,
    we''ll match on `self` and then delegate to the individual `state` types. This
    will result in a pretty redundant `match` statement, as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`WalkTheDogStateMachine` 中的 `update` 方法有点空，我们可能需要在里面放一些代码。我们可以在更新中调用 `match
    self`，然后在这个 `update` 函数中为每个状态编写行为，例如调用 `state._state.walk.boy.run_right()`，这会起作用，但看起来很糟糕。相反，我们将匹配
    `self` 并将任务委托给单个 `state` 类型。这将导致一个相当冗余的 `match` 语句，如下所示：'
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We saw a variation of this pattern before in `RedHatBoyStateMachine`, where
    we have to match on each variant of `enum` in order to delegate to the state,
    and unfortunately, there''s not a great way around it. Fortunately, it''s small.
    This little `match` statement won''t compile because none of the `typestates`
    types have an `update` method. In fact, there are no implementations for the typestates
    at all. Let''s continue our delegation by creating placeholder implementations
    for all three of them, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 `RedHatBoyStateMachine` 中看到了这个模式的变体，在那里我们必须匹配 `enum` 的每个变体才能将任务委托给状态，而且不幸的是，没有很好的解决办法。幸运的是，它很小。这个
    `match` 语句将无法编译，因为没有任何 `typestates` 类型有 `update` 方法。事实上，对于 `typestates` 没有任何实现。让我们通过为所有三个创建占位符实现来继续我们的委托，如下所示：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It's worth refreshing our memory on how typestates work. A typestate is a structure
    that is generic over a state. So `WalkTheDogState<T>` is the structure, and we
    implement transitions between states by adding methods to implementations of `WalkTheDogState<T>`,
    where `T` is one of the concrete states. These placeholders all just return `self`,
    so `update` isn't doing anything yet. Look closely and you'll notice that `GameOver`
    doesn't take `KeyState` because it won't need it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 值得我们回顾一下类型状态的工作方式。类型状态是一种泛型状态的结构。所以`WalkTheDogState<T>`是结构，我们通过向`WalkTheDogState<T>`的实现中添加方法来实现状态之间的转换，其中`T`是具体状态之一。所有这些占位符都只是返回`self`，所以`update`目前还没有做任何事情。仔细观察你会发现，`GameOver`不需要`KeyState`，因为它不需要它。
- en: 'The `update` method on `WalkTheDogStateMachine` tries to use `into` to convert
    each typestate back into `enum`, but we haven''t written those yet. Recalling
    [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing Animations
    with State Machines*, again, we need to implement `From` to convert back from
    the various states to the `enum` type. These are implemented here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`WalkTheDogStateMachine`上的`update`方法试图使用`into`将每个类型状态转换回`enum`，但我们还没有编写这些。回忆一下[*第4章*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093)，*使用状态机管理动画*，再次，我们需要实现`From`以将各种状态转换回`enum`类型。这些在这里实现：'
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is boilerplate just to get things started, but it demonstrates how each
    of these works. The `update` method on `WalkTheDogStateMachine` uses `match` to
    get the `state` value on each variant. Then, the `update` method is called on
    the various typestates. Each `update` method returns the state it transitions
    into, although right now, they all return `self`. Finally, back in the `update`
    method on `WalkTheDogStateMachine`s, we call `into` to convert the typestate back
    into an `enum` variant.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了开始而做的样板代码，但它展示了这些是如何工作的。`WalkTheDogStateMachine`上的`update`方法使用`match`获取每个变体的`state`值。然后，在各个类型状态上调用`update`方法。每个`update`方法都返回它转换到的状态，尽管现在它们都返回`self`。最后，回到`WalkTheDogStateMachine`的`update`方法中，我们调用`into`将类型状态转换回`enum`变体。
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might remember that for `RedHatBoyStateMachine`, we used a transition function
    and an `Event` `enum` to advance the state machine. The new `WalkTheDogStateMachine`
    enum has fewer events, so additional complexity isn't necessary.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，对于`RedHatBoyStateMachine`，我们使用了转换函数和`Event` `enum`来推进状态机。新的`WalkTheDogStateMachine`枚举有更少的事件，因此不需要额外的复杂性。
- en: 'It''s time to think about what each state should actually do. Previously, every
    one of these states was kind of shoved together in the `Game` `update` method
    – for instance, the following old code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候考虑每个状态实际上应该做什么了。以前，这些状态中的每一个都被推到了`Game` `update`方法中——例如，以下旧代码：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the old system, if the game was `Loaded`, then `boy` could `run_right` if
    you pressed the `ArrowRight` button and could jump if you pressed `Space`. This
    worked fine, but it''s worth noting the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧系统中，如果游戏是`Loaded`状态，那么按下`ArrowRight`键时，男孩可以`run_right`，按下`Space`键时可以跳跃。这工作得很好，但值得注意的是以下内容：
- en: The `run_right` function does nothing if RHB is already running.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果RHB已经在跑步，`run_right`函数将不起作用。
- en: The `jump` and `slide` functions do nothing if RHB isn't running.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果RHB没有在跑步，`jump`和`slide`函数将不起作用。
- en: We handle this quite well in our `RedHatBoyStateMachine`, and will continue
    to do so, but what this reveals is that once RHB starts moving to the right, we
    don't really care if the player has pushed the `WalkTheDogStateMachine`. When
    the game is `Ready`, we'll check whether the user has hit `ArrowRight` and transition
    the state. Otherwise, we'll just stay in the same state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`RedHatBoyStateMachine`中处理得相当好，并将继续这样做，但这也揭示了，一旦RHB开始向右移动，我们并不真的关心玩家是否推动了`WalkTheDogStateMachine`。当游戏处于`Ready`状态时，我们会检查用户是否按下了`ArrowRight`键并转换状态。否则，我们就会保持在同一状态。
- en: 'We can modify `WalkTheDogState<Ready>` to reflect this new reality. The first
    change to the function will be to do that check, as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改`WalkTheDogState<Ready>`以反映这一新现实。函数的第一个更改将是进行此检查，如下所示：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There's one type and one method that doesn't exist, so this code does not compile
    yet. The transition of `start_running` doesn't exist yet, although we discussed
    writing something like it. We also don't have the `ReadyEndState` type. Let's
    address that second one first.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种类型和一种方法不存在，因此这段代码目前无法编译。`start_running`的转换还不存在，尽管我们讨论了编写类似的内容。我们也没有`ReadyEndState`类型。让我们首先解决第二个问题。
- en: We used this pattern earlier for any `typestate` method that can return more
    than one state, such as the `update` method on `Jumping` or `Sliding`. We create
    a new `enum` that can represent either of the return states. In the case of the
    `update` method for `WalkTheDogState<Ready>`, the game can either still be `Ready`
    at the end of an update (`ReadyEndState::Continue`) or be done and transitioning
    to `Walking` (`ReadyEndState::Complete`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经使用过这种模式来处理任何可以返回多个状态的`typestate`方法，例如`Jumping`或`Sliding`上的`update`方法。我们创建了一个新的`enum`，它可以表示任一返回状态。在`WalkTheDogState<Ready>`的`update`方法的情况下，游戏在更新结束时可以是`Ready`（`ReadyEndState::Continue`）或者完成并转换到`Walking`（`ReadyEndState::Complete`）。
- en: 'Let''s start by implementing the `From` trait to convert from `ReadyEndState`
    to `WalkTheDogStateMachine`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现`From`特质，将`ReadyEndState`转换为`WalkTheDogStateMachine`：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is some boilerplate that you've seen before. We have two states for `ReadyEndState`
    because there are two states that the `WalkTheDogState<Ready>` `update` method
    can end in. In order to get from `ReadyEndState` to `WalkTheDogStateMachine`,
    we create a `From` trait and match on both variants of `ReadyEndState` and extract
    their fields from them. Those are both typestates, `WalkTheDogState<Ready>` and
    `WalkTheDogState<Walking>`, respectively, so we use their `into` methods to convert
    them into the `WalkTheDogStateMachine` type. Those traits were already written
    earlier.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些你之前已经见过的通用模板。对于`ReadyEndState`，我们有两种状态，因为`WalkTheDogState<Ready>`的`update`方法可以结束在两种状态中。为了从`ReadyEndState`转换到`WalkTheDogStateMachine`，我们创建了一个`From`特质，并在`ReadyEndState`的两个变体上匹配，并从中提取它们的字段。这两个都是类型状态，分别是`WalkTheDogState<Ready>`和`WalkTheDogState<Walking>`，因此我们使用它们的`into`方法将它们转换为`WalkTheDogStateMachine`类型。这些特质之前已经编写好了。
- en: 'The call to `self.start_running` is still not going to work because we haven''t
    written it yet! What happens when the player hits `typestate` method named after
    the transition, which looks like so:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对`self.start_running`的调用仍然不会工作，因为我们还没有编写它！当玩家调用一个以转换命名的`typestate`方法时会发生什么，看起来像这样：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let's refresh our memory on these. Every `state` transition is written as a
    method on the various typestates – in this case, `WalkTheDogState<Ready>`, where
    the source state is `self` and the return value is the destination state. Here,
    we transition from `Ready` to `Walking` by writing a method called `start_running`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这些内容。每个`状态`转换都作为各种类型状态上的一个方法来编写——在这个例子中，是`WalkTheDogState<Ready>`，其中源状态是`self`，返回值是目标状态。在这里，我们通过编写一个名为`start_running`的方法从`Ready`转换到`Walking`。
- en: 'The actual implementation isn''t doing much. We start by calling `self.run_right`,
    which doesn''t exist yet, so we have to write it. After sending RHB running, we
    transition into the `Walking` state by returning a new `WalkTheDogState` instance
    with `_state` of `Walking`. Take a close look at the function signature for `start_running`
    and you''ll notice it takes `mut state`. This means taking exclusive ownership
    over `self`, which we can do because we have complete ownership of everything
    in the state. That is one of the reasons we created `Option<WalkTheDogStateMachine>`
    originally! However, it''s not obvious why we take `mut state` here instead of
    `state`, in part because `run_right` doesn''t exist. When we add our new delegation
    method, that should become clear, so let''s do that right now with the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 实际实现并没有做太多。我们首先调用`self.run_right`，这个方法还不存在，所以我们必须编写它。在发送RHB开始跑之后，我们通过返回一个带有`_state`为`Walking`的新`WalkTheDogState`实例来进入`Walking`状态。仔细看看`start_running`函数的签名，你会发现它接受`mut
    state`。这意味着获取对`self`的独占所有权，我们可以这样做，因为我们拥有状态中的一切。这也是我们最初创建`Option<WalkTheDogStateMachine>`的原因之一！然而，为什么在这里我们取`mut
    state`而不是`state`并不明显，部分原因是因为`run_right`方法还不存在。当我们添加我们的新委托方法时，这应该会变得清晰，所以让我们立即用以下代码来做这件事：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This function on `WalkTheDogState<Ready>` calls `run_right` on `boy` through
    its walk field. The `run_right` method on `boy` requires a mutable borrow, and
    that's why we require a mutable borrow on the previous delegate. It's also why
    we needed to take `mut state` in the `start_running()` method earlier. You can't
    mutably borrow something that isn't mutable in the first place.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WalkTheDogState<Ready>`上的这个函数通过其`walk`字段调用`boy`的`run_right`方法。`boy`上的`run_right`方法需要一个可变借用，这就是为什么我们在之前的委托上要求一个可变借用。这也是为什么我们之前在`start_running()`方法中需要`mut
    state`的原因。你不能从最初不可变的事物上获取可变借用。
- en: In order to keep the code clean, we're doing a little more delegation now than
    we were earlier. This makes our methods smaller and easier to understand, but
    the trade-off is that the behavior will be spread across multiple places. I think
    in the end, this will make our code easier to think about, because we won't have
    to consider too much code at any one time, so the trade-off is worth it. We'll
    have to be careful that we don't lose track of any of our original code as we
    break it up into chunks and spread it around.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码整洁，我们现在比之前做了更多的委托。这使得我们的方法更小，更容易理解，但代价是行为将分散在多个地方。我认为最终，这将使我们的代码更容易思考，因为我们不必在任何时候考虑太多代码，所以这种权衡是值得的。我们必须小心，不要在我们将代码拆分成块并分散到各个地方时丢失任何原始代码。
- en: Re-implementing draw
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新实现draw
- en: Now, we've removed all the compiler errors in the original `update` method,
    in part by removing a large chunk of its functionality, and we can continue by
    updating the `Walking` state to ensure that it's working, but I believe that's
    a long time without any meaningful feedback from the game. After all, at this
    point, the game doesn't compile and doesn't draw. How do we know anything is working?
    Let's instead take a moment and update the `Game` `draw` method so that we can
    actually get the code to compile again and see how it's working.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经从原始的`update`方法中移除了所有编译错误，部分是通过移除其功能的一个大块，我们可以继续更新`Walking`状态以确保它正常工作，但我相信这已经有一段时间没有从游戏中得到任何有意义的反馈了。毕竟，在这个时候，游戏无法编译也无法绘制。我们如何知道任何东西在正常工作？让我们花点时间更新`Game`的`draw`方法，这样我们就可以真正编译代码并查看它的工作情况。
- en: 'The `draw` method will start by taking a page from the `update` method and
    replacing its current implementation with a delegation to `WalkTheDogStateMachine`,
    as shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`方法将首先借鉴`update`方法，并用对`WalkTheDogStateMachine`的委托来替换其当前实现，如下所示：'
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There are two things that are a little different from the changes we made to
    update. The first is that we only borrow `self.machine` because we don't need
    mutable access. We also still clear the screen at the top of `draw`. That happens
    on every state change, so there's no reason to not just do it then. Besides, it
    will help us debug if we make any mistakes, since the screen will turn white.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对`update`所做的更改相比，有两点略有不同。第一点是，我们只借用`self.machine`，因为我们不需要可变访问。我们还在`draw`的顶部清除了屏幕。这发生在每个状态变化时，所以没有理由不这么做。此外，如果我们犯了任何错误，这将帮助我们调试，因为屏幕会变白。
- en: 'Let''s continue the delegation by adding a `draw` method to `WalkTheDogStateMachine`
    that can extract the state from each case for drawing, as shown here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向`WalkTheDogStateMachine`添加一个`draw`方法来继续委托，该方法可以从每个案例中提取状态以进行绘制，如下所示：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is virtually identical to the `update` method we wrote earlier, except
    on a borrowed `self` instead of consuming `self`. The rest is just delegations
    to the various states. Unlike update, every state draws in the exact same way,
    so we can fill those in with one method, as shown here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与我们在之前写的`update`方法完全相同，只是使用了借用的`self`而不是消耗`self`。其余的都是对各种状态的委托。与`update`不同，每个状态都以完全相同的方式进行绘制，因此我们可以用一个方法来填充这些，如下所示：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Any state will delegate `draw` to `Walk` because the drawing doesn''t actually
    change based on state. We can finally go ahead and re-implement the `draw` method,
    this time on `Walk`, as shown here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 任何状态都会将`draw`委托给`Walk`，因为绘制实际上并不基于状态而改变。我们终于可以继续并重新实现`draw`方法，这次是在`Walk`上，如下所示：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code is not new, but I don't blame you if you forgot it. It's our old `draw`
    code from [*Chapter 6*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139), *Creating
    an Endless Runner*, only with the `walk` variable replaced by `self`. The rest
    is identical.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不新鲜，但如果你忘记了它，我也不怪你。这是我们旧的`draw`代码，来自[*第6章*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139)，*创建无限跑酷游戏*，只是将`walk`变量替换为`self`。其余的都是相同的。
- en: At this point, you'll notice something exciting – the code compiles again! But
    if you look closely at the game, you'll see that it's a little static.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你会注意到一些令人兴奋的事情——代码再次编译成功！但如果你仔细观察游戏，你会看到它有点静态。
- en: '![Figure 8.15 – Stand very still….](img/Figure_8.15_B17151.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – 站得非常稳……](img/Figure_8.15_B17151.jpg)'
- en: Figure 8.15 – Stand very still….
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 站得非常稳……
- en: Red Hat Boy has stopped animating! He doesn't do his little idle animation because
    we're not calling `update` like we used to; it's almost time to go back to fixing
    the `update` method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 红帽男孩已经停止了动画！他不会做他那个小小的空闲动画，因为我们不再像以前那样调用`update`；快到回去修复`update`方法的时候了。
- en: Refactoring initialize
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构初始化
- en: 'Before we proceed with restoring functionality, you might remember that I said
    the creation of `WalkTheDogStateMachine` was "obscured by all the state machine
    noise." Specifically, it looked like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续恢复功能之前，你可能记得我说过`WalkTheDogStateMachine`的创建是“被所有状态机噪音所掩盖”。具体来说，它看起来像这样：
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To create `WalkTheDogStateMachine` required creating its `Ready` variant and
    passing a `WalkTheDog` state with its `_state` variable set to `Ready`. In addition
    to being noisy, it requires you to remember the correct initial state of the state
    machine. That's what constructors are for!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`WalkTheDogStateMachine`需要创建它的`Ready`变体，并传递一个`WalkTheDog`状态，其`_state`变量设置为`Ready`。除了嘈杂之外，它还要求你记住状态机的正确初始状态。这正是构造函数的作用！
- en: 'Let''s create a constructor for `WalkTheDogState<Ready>`, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`WalkTheDogState<Ready>`创建一个构造函数，如下所示：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This makes it easier to create a new typestate of `WalkTheDogState<Ready>`;
    accepting `Walk`, it needs to be valid. Let''s also make it easier to create the
    entire machine, with a smaller constructor:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得创建一个新的`WalkTheDogState<Ready>`类型状态变得更容易；接受`Walk`，它需要是有效的。让我们也使创建整个机器更容易，使用更小的构造函数：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This constructor creates the entire machine with the right state and passes
    it `Walk`. Now that we''ve made these helper methods, we can make the change to
    the original initialize method, making it a little bit easier to read by using
    the `WalkTheDogStateMachine` constructor:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数使用正确的状态创建整个机器，并将`Walk`传递给它。现在我们已经创建了这些辅助方法，我们可以对原始的初始化方法进行更改，通过使用`WalkTheDogStateMachine`构造函数使其更容易阅读：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It's a small change, but makes it both easier to read and safer, too. Doing
    the right thing, creating `WalkTheDogStateMachine` in the `Ready` state is easy
    to do, and creating it in the wrong state is not.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小小的改动，但它既使阅读变得更轻松，也使操作更安全。在`Ready`状态下创建`WalkTheDogStateMachine`是容易做到的，而在错误的状态下创建它则不是。
- en: Now that we've finished that little digression, we can go back to finishing
    the update method as planned.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个小插曲，我们可以回到按计划完成更新方法。
- en: Finishing update
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成更新
- en: 'This segment of the *original* `update` function in `Game` reveals what is
    missing from our current code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这段在`Game`中的*原始* `update`函数揭示了我们的当前代码中缺少的内容：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Immediately after all the checks for button presses, we were updating `boy`.
    Let''s go ahead and add that to our new version of the `update` function in the
    `WalkTheDogState<Ready>` implementation, like so:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有按钮按下检查之后，我们正在更新`boy`。让我们继续在我们的`WalkTheDogState<Ready>`实现中的新版本的`update`函数中添加这个操作，如下所示：
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There are two changes here, so don't forget to change `update` to accept `mut
    self` now instead of `self`. It's hiding there in the function signature. Also,
    we've added a call to `self.walk.boy.update()` to start updating the boy again.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个改动，所以别忘了现在将`update`改为接受`mut self`而不是`self`。它在函数签名中隐藏着。此外，我们还添加了对`self.walk.boy.update()`的调用，以再次开始更新男孩。
- en: 'Do that and you''ll see RHB idling again, ready to start chasing down his invisible
    dog. But if you hit the right arrow, RHB freezes, one frame into his running animation.
    That is not what we want, and intriguingly, there are no errors in the console
    log because no exceptions are being thrown. It''s just that the `Walking` state
    doesn''t do anything in its `update` function. We can restore that code by putting
    back some of the code we earlier commented out/copied/deleted into the `Walking`
    state of the game, as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这件事，你会看到RHB再次空闲，准备开始追逐他的隐形狗。但如果你按下了右箭头，RHB会冻结，在他的跑步动画的第一帧。这不是我们想要的，而且有趣的是，控制台日志中没有错误，因为没有抛出异常。只是`Walking`状态在其`update`函数中没有做任何事情。我们可以通过将之前注释/复制/删除的一些代码放回游戏的`Walking`状态中，来恢复这段代码，如下所示：
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In `WalkTheDogState<Walking>`, we've modified the `update` method to take a
    `mut self` and then restored most of the old `Game` `update` code. Rather than
    showing the entire method, I've just reproduced the beginning and end of the code
    snippet and elided the middle; you can safely cut and paste all the original code.
    There are a few changes to make the code fit its new location. Where the original
    code would read `walk.boy`, it now reads `self.walk.boy`. I also took the opportunity
    to rename `velocity`, which is a little vague, to `walking_speed` to clarify that
    it refers to how fast RHB walks. The final change we've made is taking out the
    `if keystate.is_pressed("ArrowRight")` code because there's no reason to check
    for that keypress anymore. Lastly, we return `self` because there's not yet any
    way to transition out of `WalkTheDogState<Walking>`. If you do this all correctly,
    you'll find that your code compiles and runs! In fact, as of this moment, all
    of the behavior is restored, including the problem where we have to refresh to
    start a new game. How about we finally add a new game button right now, huh?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WalkTheDogState<Walking>`中，我们已经修改了`update`方法，使其接受一个`mut self`，然后恢复了大部分旧的`Game`
    `update`代码。由于篇幅原因，我没有展示整个方法，只是复制了代码片段的开始和结束部分，中间部分省略了；你可以安全地复制粘贴所有原始代码。我们做了一些修改，以使代码适应新的位置。原始代码中读取`walk.boy`的地方现在读取`self.walk.boy`。我还趁机将`velocity`重命名为`walking_speed`，以明确它指的是RHB行走速度。我们做的最后一个更改是移除了`if
    keystate.is_pressed("ArrowRight")`代码，因为现在没有必要检查这个按键了。最后，我们返回`self`，因为目前还没有从`WalkTheDogState<Walking>`中过渡出去的方法。如果你全部正确地完成这些，你会发现你的代码可以编译并运行！实际上，截至此刻，所有行为都已恢复，包括我们必须刷新才能开始新游戏的问题。那么，我们现在就添加一个新的游戏按钮，怎么样？
- en: Start a new Game
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: 'If you remember our originally planned behavior, and I don''t blame you if
    you don''t, we wanted to draw a new game button on the screen when RHB crashed
    and fell over. Then, when it''s clicked, we want to start a new game. For that
    to happen, we''ll need to do the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们最初计划的行为，如果你不记得，我也不怪你，我们想在RHB崩溃并倒下时在屏幕上绘制一个新的游戏按钮。然后，当它被点击时，我们希望开始一个新的游戏。为了实现这一点，我们需要做以下几步：
- en: Check whether `RedHatBoyStateMachine` is `KnockedOut`, and if so, transition
    from `Walking` to `GameOver`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`RedHatBoyStateMachine`是否处于`KnockedOut`状态，如果是，则从`Walking`状态过渡到`GameOver`状态。
- en: On that transition, draw the new game button.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个过渡过程中，绘制新的游戏按钮。
- en: Add an `onclick` handler so that when the button is clicked, we transition back
    to `Ready` with a new `Walk` instance.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`onclick`处理程序，以便当按钮被点击时，我们使用一个新的`Walk`实例过渡回`Ready`状态。
- en: On the transition to `Ready`, hide the button and restart the game.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在过渡到`Ready`状态时，隐藏按钮并重新开始游戏。
- en: 'All the code we wrote before was to make that change easier. Let''s see whether
    we were right about that:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的所有代码都是为了使这个更改更容易。让我们看看我们是否正确地做到了这一点：
- en: Transition from `Walking` to `GameOver`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Walking`状态过渡到`GameOver`状态。
- en: 'To transition from `Walking` to `GameOver`, we need to return the `GameOver`
    state from the `WalkTheDogState<Walking>` `update` method, but when should we
    do that? We''ll need to see whether the *boy* is knocked out and then make the
    change. We don''t have that capability yet, so we''ll need to create it, and let''s
    work top-down, as we have been this entire chapter. First, we''ll change the `WalkTheDogState<Walking>`
    `update` method to check the non-existing method:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Walking`状态过渡到`GameOver`状态，我们需要在`WalkTheDogState<Walking>`的`update`方法中返回`GameOver`状态，但我们应该在什么时候做这件事呢？我们需要查看男孩是否被击倒，然后进行相应的更改。我们目前还没有这个功能，所以我们需要创建它，并且让我们像本章一直做的那样自顶向下工作。首先，我们将修改`WalkTheDogState<Walking>`的`update`方法，以检查一个不存在的函数：
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, instead of always returning the `Walking` state, we return `WalkingEndState`,
    which doesn''t exist yet but will mimic the pattern we used in the `update` method
    on on `WalkTheDogState<Ready>`. When the current state is `knocked_out`, we will
    return the `Complete` variant holding an instance of the `WalkTheDogState<GameOver>`
    type. That will be the state returned from the `end_game` transition, which is
    also not written yet. Otherwise, we''ll return `Continue` with the current `WalkTheDogState<Walking>`
    state as its field. That''s two functions that don''t exist yet, `knocked_out`
    and `end_game`, along with a brand-new type. You can create the `WalkingEndState`
    type and its corresponding `From` trait to convert it into `WalkTheDogStateMachine`
    right now by following the same pattern we did for `ReadyEndState`. I won''t reproduce
    that code here. We''ll proceed from there by getting `knocked_out` working, which
    is going to be delegated from `Walk` to `RedHatBoyStateMachine` with some delegations
    in between:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再总是返回`Walking`状态，而是返回`WalkingEndState`，这个状态目前还不存在，但将模仿我们在`WalkTheDogState<Ready>`上的`update`方法中使用的模式。当当前状态是`knocked_out`时，我们将返回包含`WalkTheDogState<GameOver>`类型实例的`Complete`变体。这将是从`end_game`转换返回的状态，这个转换也还没有写。否则，我们将返回`Continue`，其字段为当前的`WalkTheDogState<Walking>`状态。这是两个还不存在的函数，`knocked_out`和`end_game`，以及一个全新的类型。你可以通过遵循与`ReadyEndState`相同的模式来创建`WalkingEndState`类型及其相应的`From`特质，将其转换为`WalkTheDogStateMachine`。我不会在这里重现那段代码。我们将从那里开始，通过使`knocked_out`工作来继续前进，这将从`Walk`委托给`RedHatBoyStateMachine`，中间有一些委托：
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We could pass `WalkTheDogState` to `RedHatBoyStateMachine` here to get the new
    state and follow the OO guideline of "tell, don't ask", but sometimes, you just
    want to check a Boolean. Here, we ask the `Walking` state, which asks `RedHatBoy`
    and finally `RedHatBoyStateMachine` whether it is knocked out. `RedHatBoyStateMachine`
    uses the handy `matches!` macro to check `self` against an `enum` variant, and
    return whether or not they match. Now that we can check whether Red Hat Boy is
    knocked out, we have just one compiler error – `` no method named `end_game` found
    for struct `WalkTheDogState` ``.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`WalkTheDogState`传递给`RedHatBoyStateMachine`以获取新状态，并遵循面向对象指导原则“告诉，不要询问”，但有时你只想检查一个布尔值。在这里，我们询问`Walking`状态，它询问`RedHatBoy`，最终询问`RedHatBoyStateMachine`是否被击倒。`RedHatBoyStateMachine`使用方便的`matches!`宏来检查`self`是否与`enum`变体匹配，并返回它们是否匹配。现在我们可以检查红帽男孩是否被击倒，我们只有一个编译错误——“在`WalkTheDogState`结构中找不到名为`end_game`的方法”。
- en: 'It''s time to implement the `end_game` transition method, which will represent
    our transition. We can start by implementing the transition to do nothing other
    than move `walk` from `Walking` to `GameOver`, as shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候实现`end_game`转换方法了，它将代表我们的转换。我们可以从实现一个什么也不做，只是将`walk`从`Walking`转换为`GameOver`的转换开始，如下所示：
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This returns us to a compiled state and means that when RHB crashes and is knocked
    out, the game is in the `GameOver` state. However, it does nothing, so it's time
    for *step 2* – draw the new game button.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们回到了编译状态，意味着当RHB崩溃并被击倒时，游戏处于`GameOver`状态。然而，它什么也不做，所以现在是*第二步*——绘制新的游戏按钮。
- en: Draw the new game button.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制新的游戏按钮。
- en: 'Many pages ago, I said: "To show our button programmatically, we can just call
    `browser::draw_ui("<button>New Game</button>")`." But when do we call it? Well,
    we call it now, right before creating the new state:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多页之前，我说：“为了以编程方式显示我们的按钮，我们只需调用`browser::draw_ui("<button>New Game</button>")`。”但我们在什么时候调用它？嗯，我们现在调用它，就在创建新状态之前：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If you add this one line of code to the transition, you'll see the new game
    button we wrote way back at the beginning when our RHB crashes into a rock. There's
    a warning on this line because we don't handle the result of `draw_ui`, which
    we'll ignore for the moment.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这条代码行中添加这一行，你将看到我们很久以前在RHB撞到岩石时编写的新的游戏按钮。这一行有一个警告，因为我们没有处理`draw_ui`的结果，我们暂时忽略它。
- en: Add the `onclick` handler to the button.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加`onclick`处理程序。
- en: 'In order to add the click handler to the button, we need to get a reference
    to the element we just drew. We don''t have that, as the `insert_adjacent_html`
    function doesn''t provide it, so we''ll need to find the button we just added
    to the screen so that we can attach an event handler to it. We''ve used `get_element_by_id`
    twice before on `document`, so it''s probably time to write a wrapper function
    in the `browser` module, as shown here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将点击处理程序添加到按钮，我们需要获取我们刚刚绘制的元素的引用。我们没有这个引用，因为`insert_adjacent_html`函数不提供它，所以我们需要找到我们刚刚添加到屏幕上的按钮，以便我们可以将其事件处理程序附加到它上。我们之前在`document`上使用了`get_element_by_id`两次，所以可能是时候在`browser`模块中编写一个包装函数，如下所示：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We've made a slight change to the way we've been finding elements in this function.
    Normally, we want `HtmlElement`, not a generic `Element` type, so in this function,
    we've gone ahead and added a call to `dyn_into` to make the conversion. Therefore,
    this function first gets the document, then gets the element, and finally, converts
    it into the `HtmlElement` type, all while normalizing the errors with `anyhow!`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个函数中查找元素的方式做了一些轻微的调整。通常，我们想要`HtmlElement`而不是通用的`Element`类型，所以在这个函数中，我们提前添加了一个调用`dyn_into`来执行转换。因此，这个函数首先获取文档，然后获取元素，最后将其转换为`HtmlElement`类型，同时使用`anyhow!`来规范化错误。
- en: 'Now that we have a way to find the element, we can return to the transition
    in `game`, find the newly added new game button, and then add a click handler
    to it, as shown in the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了查找元素的方法，我们可以回到`game`中的转换，找到新添加的新游戏按钮，然后向它添加一个点击处理程序，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We've reproduced the entire transition trait here, but there are three changes.
    The first is that we've added `id` to the new game button; naturally, that's `new_game`.
    Then, we find the element in the document in the `and_then` block and use `map`
    to take that element and pass it to the recently created `add_click_handler` function.
    Now, we've got a small problem. We will need `receiver` to get click messages
    when they happen, but the `add_click_handler` function returns `Result` with `UnboundedReceiver`.
    The challenge is that the `end_game` function doesn't return `Result`. In [*Chapter
    9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing, Debugging, and
    Performance*, we'll investigate how to debug this kind of condition, but for now,
    we'll just grit our teeth and add `unwrap`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里重现了整个转换特性，但有三个变化。第一个变化是我们向新游戏按钮添加了`id`；自然地，它是`new_game`。然后，我们在`and_then`块中找到文档中的元素，并使用`map`函数将这个元素传递给最近创建的`add_click_handler`函数。现在，我们遇到了一个小问题。我们需要`receiver`在点击事件发生时获取点击消息，但`add_click_handler`函数返回带有`UnboundedReceiver`的`Result`。挑战在于`end_game`函数不返回`Result`。在[*第9章*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203)，*测试、调试和性能*中，我们将探讨如何调试这类条件，但现在，我们只能咬紧牙关并添加`unwrap`。
- en: 'Now that we have `receiver` that will get a message whenever the player clicks
    `update` function for the `GameOver` state and when we receive the event transition
    to the `Ready` state. That''s going to mean adding the receiver to the `GameOver`
    struct, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`receiver`，它会在玩家点击`GameOver`状态的`update`函数以及我们接收到事件转换到`Ready`状态时接收消息。这意味着我们需要将`receiver`添加到`GameOver`结构体中，如下所示：
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will prompt you to add the `use` declaration for `futures::channel::mpsc::UnboundedReceiver`.
    Now that `GameOver` `struct` has the field, we''ll need to pass it along in the
    transition, as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示你添加`futures::channel::mpsc::UnboundedReceiver`的`use`声明。现在`GameOver`结构体有了这个字段，我们需要在转换中传递它，如下所示：
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is the final change to this method, and it's just adding the field to `GameOver`.
    Interestingly it's the first time we've added a field to any of our state structures,
    but it's something you're likely to do more of over time as you extend this game.
    Various states have data that's unique to them, and they belong in the `state`
    struct.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此方法的最终更改，只是将字段添加到`GameOver`中。有趣的是，这是我们第一次向任何状态结构体添加字段，但随着你扩展这个游戏，你很可能会做更多类似的事情。各种状态都有它们独有的数据，它们属于`state`结构体。
- en: 'It''s time to return to the `WalkTheDogState<GameOver>` implementation and
    its `update` method, which currently just returns the `GameOver` state, leaving
    the game in that state forever. Instead, we''ll want to check whether the new
    game event has happened (because the button was clicked) and then return the `Ready`
    state to start over again. That small bit of code is reproduced here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候回到`WalkTheDogState<GameOver>`的实现及其`update`方法了，它目前只是返回`GameOver`状态，使游戏永远处于该状态。相反，我们希望检查新游戏事件是否发生（因为按钮被点击），然后返回`Ready`状态以重新开始。这里复制的这段小代码如下：
- en: '[PRE73]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the `WalkTheDogState<GameOver>` implementation, we check the state to see
    whether the new game button has been pressed, and if it has, we return the `GameOverEndState::Complete`
    variant; otherwise, we return the `GameOverEndState::Continue` variant. This is
    the same pattern we've used in every other update method, and you can go ahead
    and reproduce the `GameOverEndState` enum and its corresponding `From` trait to
    convert the type to a `WalkTheDogStateMachine` enum. That code is not reproduced
    here, but remember that if you get stuck, you can find the sample code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WalkTheDogState<GameOver>`的实现中，我们检查状态以查看是否按下了新游戏按钮，如果是，则返回`GameOverEndState::Complete`变体；否则，返回`GameOverEndState::Continue`变体。这是我们已经在每个其他更新方法中使用的相同模式，你可以继续复制`GameOverEndState`枚举及其相应的`From`特质，以将类型转换为`WalkTheDogStateMachine`枚举。这段代码在此处未复制，但请记住，如果你遇到困难，可以在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8)找到示例代码。
- en: In the `GameOver` implementation, we have the details to check whether `new_game_event`,
    corresponding to the player's click, has happened. Calling `try_next` will return
    `Result` immediately, without blocking, or `Ok` if the channel is still open,
    regardless of whether anything is in it. Remember that we are running at 60 frames
    per second and cannot use the blocking calls. Finally, we use the handy matches!
    macro to check whether the channel was successfully sent a message of `unit`,
    or Ok(Some(())). If the event is there, `true`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameOver`的实现中，我们有检查`new_game_event`（对应玩家的点击）是否发生的详细信息。调用`try_next`将立即返回`Result`，不阻塞，或者如果通道仍然打开，则返回`Ok`，无论其中是否有内容。请记住，我们以每秒60帧的速度运行，不能使用阻塞调用。最后，我们使用方便的matches!宏来检查是否成功向通道发送了`unit`的消息或`Ok(Some(()))`。如果事件存在，则返回`true`。
- en: This code doesn't compile because we don't have a transition written from `GameOver`
    to `Ready`, which is what we'll write in the next step.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码无法编译，因为我们没有从`GameOver`到`Ready`的转换代码，这是我们将在下一步中编写的。
- en: Restart the game on **New Game**.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新游戏**上重新开始游戏。
- en: 'Restarting the game will mean doing two things on the `new_game` transition.
    The first is hiding the button or "UI," and the second is recreating `Walk` from
    scratch. The first is actually easier, so we''ll start with that:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 重新开始游戏意味着在`new_game`转换上执行两件事。第一是隐藏按钮或“UI”，第二是从头开始重新创建`Walk`。第一件事实际上更容易，所以我们将从这里开始：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is another transition, this time from `GameOver` to `Ready`, with the side
    effect of hiding the UI. It then moves to a new state with the same walk we ended
    with, which is not quite what we want.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个转换，这次是从`GameOver`到`Ready`，副作用是隐藏UI。然后它移动到一个新的状态，具有我们结束时的相同行走，这并不是我们想要的。
- en: '![Figure 8.16 – I hit New Game – run, boy, run!](img/Figure_8.16_B17151.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图8.16 – 我点击了新游戏 – 小伙子，快跑！](img/Figure_8.16_B17151.jpg)'
- en: Figure 8.16 – I hit New Game – run, boy, run!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 – 我点击了新游戏 – 小伙子，快跑！
- en: 'The button is hidden but RHB is still knocked out. Moving from `GameOver` to
    `Ready` means creating a new `Walk` instance from the old one, so the game starts
    over. This is a bit of a challenge because we no longer have access to the various
    images and sprite sheets we used to create `Walk` and `RedHatBoy` in the first
    place. What we''ll do is clone those from an existing one, via a constructor function
    on the `Walk` implementation. We won''t call this `clone` because that term means
    an identical copy, whereas this is really a reset. You can see the implementation
    here:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮被隐藏了，但RHB仍然被打败了。从`GameOver`到`Ready`的转换意味着从旧的一个创建一个新的`Walk`实例，因此游戏重新开始。这有点挑战性，因为我们不再能够访问我们最初创建`Walk`和`RedHatBoy`时使用的各种图像和精灵表。我们将通过`Walk`实现的构造函数从现有的一个克隆它们。我们不会调用这个`clone`，因为这个词意味着一个完全相同的副本，而实际上这是一个重置。你可以在下面看到实现：
- en: '[PRE75]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `reset` function consumes `Walk` and returns a new one. It recreates `starting_obstacles`
    the same way they are created in `initialize`, and then recalculates `timeline`.
    Then, it constructs a new `Walk`, moving all the values from `Walk` except `starting_obstacles`
    and `timeline`. This function is not quite right though, as it will reset `Walk`
    but leave `boy` in its `KnockedOut` state. We''ll need a similar `reset` function
    for `boy`, as shown here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset`函数消耗`Walk`并返回一个新的实例。它以与`initialize`中创建相同的方式重新创建`starting_obstacles`，然后重新计算`timeline`。然后，它构建一个新的`Walk`，将`Walk`中的所有值（除了`starting_obstacles`和`timeline`）移动到新实例中。不过，这个函数还不够正确，因为它会重置`Walk`，但会留下`boy`处于其`KnockedOut`状态。我们需要为`boy`提供一个类似的`reset`函数，如下所示：'
- en: '[PRE76]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Writing `reset` on `RedHatBoy` is a lot easier than it was on `Walk` because
    we created a constructor function, `new`, for `RedHatBoy` a long time ago. We
    should do the same for `Walk`, but that refactoring is up to you. Keep in mind
    that for this to compile, the `audio` and `jump_sound` fields on `RedHatBoyContext`
    need to be public.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RedHatBoy`上写`reset`要比在`Walk`上容易得多，因为我们很久以前就为`RedHatBoy`创建了一个构造函数，`new`。我们也应该为`Walk`做同样的事情，但这个重构取决于你。记住，为了编译通过，`RedHatBoyContext`上的`audio`和`jump_sound`字段需要是公开的。
- en: 'Now that we have a `reset` function for `RedHatBoy`, we can use it in the `Walk`
    `reset` function, like so:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`RedHatBoy`的`reset`函数，我们可以在`Walk`的`reset`函数中使用它，如下所示：
- en: '[PRE77]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We also need to call this in the original transition from `GameOver` to `Ready`,
    as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在从`GameOver`到`Ready`的原生转换中调用这个函数，如下所示：
- en: '[PRE78]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If you do all that, you'll find that when you click the new game button, the
    game resets and the player is back at the start. You should be able to hit the
    right arrow key and start walking again. You *should*, but it doesn't work because
    we haven't accounted for one feature of the UI – the focus.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做了所有这些，你会发现当你点击新游戏按钮时，游戏会重置，玩家会回到起点。你应该能够按下右箭头键并再次开始行走。你应该能这样做，但它不起作用，因为我们还没有考虑到UI的一个特性——焦点。
- en: Focus!
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意焦点！
- en: It turns out there's one more thing to do when we click the new game button
    to make the game ready to play again. When the game was started, we set up the
    canvas to have the focus so that it would receive keyboard input. We did this
    with the `tabIndex` field in the original HTML. When the player clicks **New Game**,
    they transfer the focus to the button and then hide the button, which means nothing
    will get the keyboard events we are listening to. You can see this effect by clicking
    **New Game** and then clicking the canvas after the button disappears. If you
    click the canvas, it regains the focus, and you can play the game again.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，当我们点击新游戏按钮使游戏准备好再次播放时，还有一件事要做。当游戏开始时，我们设置了画布以获得焦点，以便它能够接收键盘输入。我们使用原始HTML中的`tabIndex`字段做到了这一点。当玩家点击**新游戏**时，他们会将焦点转移到按钮上，然后隐藏按钮，这意味着没有任何东西会接收到我们正在监听的键盘事件。你可以通过点击**新游戏**然后点击按钮消失后的画布来看到这个效果。如果你点击画布，它会重新获得焦点，你就可以再次玩游戏了。
- en: 'We can transfer the focus back to the canvas automatically in the `hide_ui`
    function of the `browser` module. It''s debatable whether it belongs here, since
    you may have cases where you want to hide the UI but not reset the focus, but
    our game doesn''t have that case, so I think we''re safe. This change is here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`browser`模块的`hide_ui`函数中自动将焦点转回画布。是否应该在这里讨论这个问题是有争议的，因为可能存在你想要隐藏UI但不重置焦点的情况，但我们的游戏没有这种情况，所以我认为我们是安全的。这个更改如下所示：
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: After the first call to `map_err` for removing the child, we've added a second
    `and_then` call, which takes `unit` from the earlier `map` call, promptly ignores
    it, and then requests `focus` on `canvas`. The error from the `focus` call doesn't
    return an `anyhow!` type, so the compiler complains, and we fix that with a `map_err`
    call. The `focus` function is a JavaScript function we call through `web-sys`,
    which is documented on the MDN ([https://mzl.la/30YGOMm](https://mzl.la/30YGOMm)).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在对移除子项进行第一次`map_err`调用之后，我们添加了第二个`and_then`调用，它从早期的`map`调用中获取`unit`，立即忽略它，然后请求`canvas`上的`focus`。`focus`调用的错误不会返回`anyhow!`类型，所以编译器会报错，我们通过`map_err`调用解决这个问题。`focus`函数是我们通过`web-sys`调用的JavaScript函数，它在MDN上有文档（[https://mzl.la/30YGOMm](https://mzl.la/30YGOMm)）。
- en: With that change, you can click **New Game** and start another try. We did it!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，你可以点击**新游戏**并开始另一轮尝试。我们做到了！
- en: Pre-loading
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预加载
- en: 'You might notice that the button visibly loads when it shows up on screen –
    that is to say that the image and font aren''t downloaded to the browser yet,
    so it doesn''t appear instantaneously. This is standard behavior for web browsers.
    In order to make sure that you don''t have to wait for an entire page worth of
    images, fonts, and other assets to load before you see a page, browsers will load
    assets lazily. This is so common that your eyes may not have noticed it when the
    `Button.svg` and the `kenney_future_narrow-webfont.woff2` assets immediately when
    the page is loaded so that when the button appears, it''s instantaneous. Open
    the `index.html` file and make the changes shown here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到按钮在屏幕上显示时是可见地加载的——也就是说，图像和字体还没有下载到浏览器中，所以它不会立即出现。这是网络浏览器的标准行为。为了确保你不需要等待整个页面的图像、字体和其他资源加载完毕才能看到页面，浏览器会懒加载资源。这是如此常见，以至于你可能没有注意到当页面加载时`Button.svg`和`kenney_future_narrow-webfont.woff2`资源立即加载，以便当按钮出现时，它是瞬间的。打开`index.html`文件，并按照这里所示进行更改：
- en: '[PRE80]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `link` tag with the `preload` attribute will preload assets before rendering
    the page. You'll want to minimize this behavior generally because you don't want
    the user to have to wait a very long time with a blank screen, and if you were
    to make a very large game with many assets, you should probably use a more flexible
    solution in code with a loading screen. Our game is small right now, so this works
    perfectly well. With this change, the new game button not only appears but is
    snappy.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`preload`属性的`link`标签将在渲染页面之前预加载资源。你通常希望尽量减少这种行为，因为你不希望用户在空白屏幕上等待很长时间，如果你要制作一个非常大的游戏，包含许多资源，你可能需要在代码中使用更灵活的解决方案，并添加一个加载屏幕。我们的游戏目前很小，所以这完全适用。随着这个变化，新的游戏按钮不仅出现，而且响应迅速。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You can look at the end of this chapter in two ways. The first might be to say,
    "All that for a button?", and you would have a point. After all, our UI is only
    one new game button, and while that's true, we actually covered quite a bit. We
    have integrated the DOM into our app via `web-sys` and have, in turn, adjusted
    our game to handle it. By utilizing the DOM, we were able to leverage the browser
    for behavior such as clicks and hovers, without having to detect where within
    the canvas the mouse was and creating clickable areas. You can now create far
    more complex UIs using tools such as CSS Grid and Flexbox, so if you are familiar
    with web development, which you've been doing for this entire book, so you are,
    you'll be able to make quality UIs for your games. If you're looking for some
    place to start, try adding a score to this game. You can increment the score in
    the update, and show it at the end menu, or at the right corner during the game,
    or both! I look forward to seeing it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从两个角度来看本章的结尾。第一个可能是说，“就为了一个按钮？”你确实有这个疑问。毕竟，我们的用户界面（UI）只是一个新的游戏按钮，虽然这是事实，但我们实际上覆盖了很多内容。我们通过`web-sys`将DOM集成到我们的应用中，并相应地调整了我们的游戏以处理它。通过利用DOM，我们能够利用浏览器来实现点击和悬停等行为，而无需检测鼠标在画布中的位置并创建可点击区域。现在，你可以使用CSS
    Grid和Flexbox等工具创建更复杂的UI，所以如果你熟悉网络开发，你在这整本书中都在做，那么你将能够为你的游戏制作高质量的UI。如果你在寻找一个起点，尝试给这个游戏添加一个分数。你可以在更新时增加分数，并在游戏结束菜单中显示它，或者在游戏右下角显示，或者两者都要！我期待看到它。
- en: With that, we will move on from new feature development to making sure that
    our current features work, and work fast. It's now time to start doing some testing
    and debugging, so we'll dive into that in the next chapter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们将从新功能开发转移到确保我们的当前功能正常且运行快速。现在是时候开始进行一些测试和调试了，所以我们将在下一章深入探讨这一点。
