- en: '*Chapter 4*: Managing Environment, Command Line, and Time'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：管理环境、命令行和时间'
- en: In the previous chapter, we looked at how the Rust Standard Library is structured.
    We also wrote a portion of a basic template engine that can generate dynamic HTML
    page components given an HTML template and data. From here onward, we will start
    to deep-dive into specific modules of the standard library grouped by functional
    areas.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Rust 标准库的结构。我们还编写了一个基本模板引擎的部分代码，该引擎可以根据 HTML 模板和数据生成动态的 HTML 页面组件。从现在开始，我们将开始深入研究标准库的特定模块，这些模块按功能区域分组。
- en: In this chapter, we will look at Rust Standard Library modules that pertain
    to working with system environment, command-line, and time-related functions.
    The goal of this chapter is for you to gain more proficiency in working with *command-line
    parameters*, *path manipulation, environment variables*, and *time measurements.*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与处理系统环境、命令行和时间相关函数相关的 Rust 标准库模块。本章的目标是使你能够更熟练地使用 *命令行参数*、*路径操作、环境变量*
    和 *时间测量*。
- en: What is the benefit of learning about these?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些有什么好处？
- en: Working with *command-line arguments* is a required skill for writing any program
    that accepts user inputs from the command line.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *命令行参数* 一起工作是一项编写任何接受命令行用户输入的程序所必需的技能。
- en: Imagine how you would write a tool (such as **find** or **grep**) that deals
    with searching for files and patterns within folders and subfolders. This requires
    knowledge of *path manipulation*, including navigating paths and reading and manipulating
    path entries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你会如何编写一个工具（例如 **find** 或 **grep**），它能够处理在文件夹和子文件夹中搜索文件和模式。这需要了解 *路径操作*，包括导航路径和读取及操作路径条目。
- en: Learning to use *environment variables* is an essential part of separating the
    code from the configuration, which is a good practice for any kind of program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 学习使用 *环境变量* 是将代码与配置分离的必要部分，这对于任何类型的程序来说都是一种良好的实践。
- en: Learning to work with time is required for programs that deal with timestamps
    of resources and activities. Learning how to do *time measurements* to record
    time intervals between events is needed for benchmarking the time taken for various
    operations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理资源和时间戳的程序来说，学习如何与时间打交道是必要的。学习如何进行 *时间测量* 以记录事件之间的时间间隔，对于评估各种操作所需的时间是必要的。
- en: 'In this chapter, you will learn the following skills:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下技能：
- en: Writing Rust programs that can discover and manipulate the system environment
    and filesystem across Linux, Unix, and Windows platforms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写能够在 Linux、Unix 和 Windows 平台上发现和操作系统环境和文件系统的 Rust 程序
- en: Creating programs that can use command-line arguments to accept configuration
    parameters and user inputs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以使用命令行参数接受配置参数和用户输入的程序
- en: Capturing elapsed time between events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获事件之间的经过时间
- en: These are relevant skills to have for systems programming in Rust. We will learn
    these topics in a practical way by developing a command-line application for image
    processing. Along the way, we will see more details about the `path`, `time`,
    `env`, and `fs` modules of the Rust Standard Library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在 Rust 系统编程中需要的相关技能。我们将通过开发一个用于图像处理的命令行应用程序来以实际的方式学习这些主题。在这个过程中，我们将看到 Rust
    标准库中 `path`、`time`、`env` 和 `fs` 模块的更多细节。
- en: First, let's see what we will be building.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们将要构建的内容。
- en: Imagine that we had a tool for bulk image resizing – tool that would look through
    a filesystem directory on a desktop or server, pull out all the image files (for
    instance, `.png` and `.jpg`), and resize all of them to predefined sizes (for
    example, small, medium, or large).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个批量图像缩放的工具——这个工具会遍历桌面或服务器上的文件系统目录，提取所有图像文件（例如，`.png` 和 `.jpg`），并将它们全部缩放到预定义的大小（例如，小、中或大）。
- en: Think about how helpful such a tool would be for freeing up space on the hard
    disk, or for uploading pictures to show in a mobile or web app. We will be building
    such a tool. Fasten your seat belts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，这样的工具对于释放硬盘空间或上传图片到移动或网页应用中展示会有多有用。我们将构建这样的工具。请系好安全带。
- en: 'We will cover the topics in the following order:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下顺序介绍主题：
- en: Project scope and design overview
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目范围和设计概述
- en: Coding the image resizing library
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写图像缩放库的代码
- en: Developing the command-line application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发命令行应用程序
- en: Technical requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The GitHub repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的 GitHub 仓库可以在 [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04)
    找到。
- en: Project scope and design overview
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目范围和设计概述
- en: In this section, we will first define what we are going to build and look at
    the technical design. We will then code a Rust library for image processing. Finally,
    we will build a command-line application that accepts user inputs through the
    command line and uses the image resizing library we have built to perform user-specified
    commands.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先定义我们将要构建的内容，并查看技术设计。然后，我们将编写一个用于图像处理的 Rust 库。最后，我们将构建一个命令行应用程序，该应用程序通过命令行接受用户输入，并使用我们构建的图像调整库执行用户指定的命令。
- en: What will we build?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将构建什么？
- en: In this subsection, we will describe the functional requirements, technical
    requirements, and project structure for the tool we are building.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将描述我们正在构建的工具的功能需求、技术需求和项目结构。
- en: Functional requirements
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能需求
- en: 'We will build a command-line tool that performs the following two operations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个执行以下两个操作的命令行工具：
- en: '**Image resize**: Resizes one or more images in a source folder to a specified
    size'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像调整大小**：将源文件夹中的一个或多个图像调整到指定的大小'
- en: '**Image stats**: Provides some statistics on the image files present in the
    source folder'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像统计**：提供有关源文件夹中现有图像文件的某些统计信息'
- en: 'Let''s name the tool **ImageCLI**. *Figure 4.1* shows the two main features
    of the tool:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给这个工具命名为 **ImageCLI**。*图 4.1* 展示了该工具的两个主要功能：
- en: '![Figure 4.1 – Features of ImageCLI tool](img/Figure_4.1_B16405.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – ImageCLI 工具的功能](img/Figure_4.1_B16405.jpg)'
- en: Figure 4.1 – Features of ImageCLI tool
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – ImageCLI 工具的功能
- en: 'Users will be able to resize images using this tool. The user can ask to resize
    either a single image or multiple images. Supported *input* image formats are
    JPG and PNG. The supported *output* image format is PNG. The tool will accept
    three command-line parameters as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将能够使用此工具调整图像大小。用户可以要求调整单个图像或多个图像。支持的 *输入* 图像格式为 JPG 和 PNG。支持的 *输出* 图像格式为 PNG。该工具将接受以下三个命令行参数：
- en: '`size = small`, the output image will have *200* pixels of width; for `size
    = medium`, the output file will have *400* pixels of width; and for `size = large`,
    the output will have *800* pixels of width. For example, if the input image is
    a JPG file with a total size of 8 MB, it can be resized to approximately < 500
    KB in size by specifying `size = medium`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size = small`，输出图像的宽度将为 *200* 像素；对于 `size = medium`，输出文件的宽度将为 *400* 像素；而对于
    `size = large`，输出宽度将为 *800* 像素。例如，如果输入图像是一个总大小为 8 MB 的 JPG 文件，通过指定 `size = medium`，它可以被调整到大约
    < 500 KB 的大小。'
- en: '`mode = single` for resizing a single file, or `mode = all` for resizing all
    image files in a specified folder.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode = single` 用于调整单个文件，或 `mode = all` 用于调整指定文件夹中的所有图像文件。'
- en: '`mode = single` or `mode = all` is chosen. For `mode = single`, the user specifies
    the value of `srcfolder` as the full path of the image file with its filename.
    For `mode = all`, the user specifies, for the value of `srcfolder`, the full path
    of the folder (the one containing the image files) without any image filenames.
    For example, if `mode = single` and `srcfolder = /user/bob/images/image1.png`
    are used, the tool will resize the single image file of `image1.png`, contained
    in the `/user/bob/images` folder. If `mode = all` and `srcfolder = /user/bob/images`
    are used, the tool will resize *all* the image files contained in the `/user/bob/images`
    source folder.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 `mode = single` 或 `mode = all`。对于 `mode = single`，用户指定 `srcfolder` 的值为包含文件名的图像文件的完整路径。对于
    `mode = all`，用户指定 `srcfolder` 的值为（包含图像文件的）文件夹的完整路径，不包含任何图像文件名。例如，如果使用 `mode =
    single` 和 `srcfolder = /user/bob/images/image1.png`，则工具将调整 `/user/bob/images`
    文件夹中包含的 `image1.png` 单个图像文件的大小。如果使用 `mode = all` 和 `srcfolder = /user/bob/images`，则工具将调整
    `/user/bob/images` 源文件夹中包含的所有图像文件的大小。
- en: 'For our image stats functionality, users will also be able to specify a `srcfolder`
    containing the image files and get back the number of image files in that folder,
    along with the total size of all those image files. For example, if `srcfolder=/user/bob/images`
    is used, the `image stats` option will give a result similar to the following:
    **The folder contains 200 image files with total size 2,234 MB**.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的图像统计功能，用户还可以指定包含图像文件的`srcfolder`，并获取该文件夹中图像文件的数量以及所有这些图像文件的总大小。例如，如果使用`srcfolder=/user/bob/images`，则`image
    stats`选项将给出类似以下的结果：**该文件夹包含200个图像文件，总大小为2,234 MB**。
- en: Non-functional requirements
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非功能性需求
- en: 'The following are a list of non-functional (technical) requirements for the
    project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该项目的非功能性（技术）需求列表：
- en: 'The tool will be packaged and distributed as a binary and it should work on
    three platforms: Linux, Unix, and Windows.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具将被打包并作为二进制文件分发，它应在三个平台上运行：Linux、Unix和Windows。
- en: We should be able to measure the time taken to resize the images.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够测量图像缩放所需的时间。
- en: User inputs for specifying command-line flags must be *case-insensitive* for
    ease of use.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入用于指定命令行标志时必须**不区分大小写**，以便于使用。
- en: The tool must be able to display meaningful error messages to the user.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具必须能够向用户显示有意义的错误消息。
- en: The core functionality of image resizing must be separate from the **command-line
    interface** (**CLI**). This way, we have the flexibility of reusing the core functionality
    with a desktop graphical interface or as part of a web backend in a web application.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像缩放的核心功能必须与**命令行界面**（**CLI**）分离。这样，我们可以灵活地使用核心功能与桌面图形界面或作为Web应用程序的后端的一部分。
- en: The project will be organized as a **library** containing the image processing
    functionality and a **binary** that provides the CLI to read and parse user input,
    provide error messages, and display output messages to the user. The binary will
    make use of the library for core image processing.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该项目将组织为一个包含图像处理功能的**库**和一个提供CLI以读取和解析用户输入、提供错误消息并向用户显示输出消息的**二进制文件**。该二进制文件将利用库进行核心图像处理。
- en: Project structure
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'Let''s create the project skeleton so we can visualize the project structure
    better. Create a new `lib` project using `cargo`. Let''s name the CLI tool as
    `imagecli` using the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建项目骨架，以便更好地可视化项目结构。使用`cargo`创建一个新的`lib`项目。让我们使用以下命令将CLI工具命名为`imagecli`：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the project structure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是项目结构：
- en: '![Figure 4.2 – Cargo project structure](img/Figure_4.2_B16405.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – Cargo项目结构](img/Figure_4.2_B16405.jpg)'
- en: Figure 4.2 – Cargo project structure
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – Cargo项目结构
- en: 'Set up the project structure as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下结构设置项目：
- en: 'Under the `src` folder, create a subfolder called `imagix` (for image magic!)
    to host the library code. Under the `imagix` subfolder, create four files: `mod.rs`,
    which is the entry point into the `imagix` library, `resize.rs` to host the code
    related to image resizing, `stats.rs` to host the code for image file statistics,
    and `error.rs` to contain the custom error type and error handling code.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹下，创建一个名为`imagix`的子文件夹（用于图像魔法！）来存放库代码。在`imagix`子文件夹下，创建四个文件：`mod.rs`，它是进入`imagix`库的入口点，`resize.rs`用于存放与图像缩放相关的代码，`stats.rs`用于存放图像文件统计的代码，`error.rs`用于包含自定义错误类型和错误处理代码。
- en: Under the `src` folder, create a new file called `imagecli.rs`, which will contain
    the code for the CLI.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹下，创建一个名为`imagecli.rs`的新文件，其中将包含CLI的代码。
- en: In this subsection, we have seen the feature requirements for the tool and the
    desired project structure. In the next subsection, we will look at the design
    for the tool.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们看到了工具的功能需求以及期望的项目结构。在下一个小节中，我们将探讨工具的设计。
- en: Technical design
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术设计
- en: In this subsection, we will look at the high-level design of the tool, primarily
    focusing on the image processing feature. We will design the specifics of the
    CLI in the *Developing the command-line application and testing* section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将探讨工具的高级设计，主要关注图像处理功能。我们将在*开发命令行应用程序和测试*部分设计CLI的具体细节。
- en: 'Our project comprises our reusable `imagix` library containing the core functionality
    for image resizing and statistics, and a binary executable, `imagecli`, with a
    CLI. This is depicted in *Figure 4.3*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目包括我们的可重用`imagix`库，其中包含图像缩放和统计的核心功能，以及一个带有CLI的二进制可执行文件`imagecli`。这如图*图4.3*所示：
- en: '![Figure 4.3 – CLI tool with a reusable library](img/Figure_4.3_B16405.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 带有可重用库的CLI工具](img/Figure_4.3_B16405.jpg)'
- en: Figure 4.3 – CLI tool with a reusable library
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 带有可重用库的CLI工具
- en: If the library is designed right, it can be reused in the future for other types
    of clients; for example, the application can be provided with a graphical user
    interface (instead of a CLI) as a desktop application, or can even be made accessible
    from a browser-based HTML client app.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库设计得当，它可以在未来用于其他类型的客户端；例如，应用程序可以提供一个图形用户界面（而不是CLI）作为桌面应用程序，甚至可以使其通过基于浏览器的HTML客户端应用程序访问。
- en: 'Before we begin the design, let''s try to visualize a few of the key technical
    challenges we have to overcome and solve:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设计之前，让我们尝试可视化一些我们必须克服和解决的关键技术挑战：
- en: '`/tmp/` subfolder to store the resized images?'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp/` 子文件夹用于存储调整大小的图像？'
- en: How do we measure the time taken for image resizing?
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们如何测量图像调整大小所需的时间？
- en: '**Resizing multiple images**:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整多个图像的大小**：'
- en: How do we iterate through the source folder provided by the user to identify
    all the image files and invoke the image resizing function for each entry?
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们如何遍历用户提供的源文件夹以识别所有图像文件并为每个条目调用图像调整大小函数？
- en: '**Getting image statistics**:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取图像统计信息**：'
- en: How do we scan through the user-provided source folder, count only the number
    of image files, and get the aggregate file size of all image files in that folder?
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们如何扫描用户提供的源文件夹，仅计算图像文件的数量，并获取该文件夹中所有图像文件的总大小？
- en: '`tmp` subfolder?'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmp` 子文件夹？'
- en: 'The preceding points can be grouped into three broad categories of concerns
    for design purposes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的点可以根据设计目的分为三个广泛的关注点类别：
- en: Image resizing logic
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像调整大小逻辑
- en: Path manipulation and directory-iteration logic
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径操作和目录迭代逻辑
- en: Measuring time taken for image resizing
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量图像调整大小所需的时间
- en: Image processing is a highly-specialized domain in itself, and it is beyond
    the scope of this book to cover the techniques and algorithms involved. Given
    the complexity and scope of the image processing domain, we will use a third-party
    library that will implement the needed algorithms and provide us with a nice API
    to call.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理本身是一个高度专业化的领域，本书的范围不包括涉及的技术和算法。鉴于图像处理领域的复杂性和范围，我们将使用第三方库来实现所需的算法，并为我们提供一个良好的API进行调用。
- en: 'For this purpose, we will use the `image-rs/image` open source crate that is
    written in Rust. The crate docs are at the following link: [https://docs.rs/image/](https://docs.rs/image/)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将使用用Rust编写的开源crate `image-rs/image`。crate文档可以在以下链接找到：[https://docs.rs/image/](https://docs.rs/image/)
- en: Let's look at how we can design the `imagix` library using the `image` crate.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`image` crate设计`imagix`库。
- en: 'The `image` crate is fully featured and has many image processing functions.
    We will however use only a small subset of features for our project. Let''s recall
    our three key requirements for image processing: the ability to *open an image
    file and load it into memory*, the ability to *resize the image to a desired size*,
    and the ability to *write the resized image from memory into a file* on the disk.
    The following methods in the `image-rs/image` crate address our needs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`image` crate功能齐全，具有许多图像处理功能。然而，我们将仅使用我们项目所需的一小部分功能。让我们回顾一下我们对图像处理的三个关键要求：能够*打开图像文件并将其加载到内存中*，能够*将图像调整到所需的大小*，以及能够*将调整大小的图像从内存写入磁盘上的文件*。`image-rs/image`
    crate中的以下方法解决了我们的需求：'
- en: '`image::open()`: This function opens an image at the specified path. It automatically
    detects the format of the image from the image''s file extension. The image data
    is read from the file and converted into a `DynamicImage` type stored in memory.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image::open()`: 此函数在指定的路径打开一个图像。它自动从图像的文件扩展名检测图像的格式。图像数据从文件中读取，并转换为存储在内存中的
    `DynamicImage` 类型。'
- en: '`DynamicImage::thumbnail()`: This function scales an image down to a specified
    size (width and height) and returns a new image while preserving the aspect ratio.
    It uses a fast integer algorithm, which is a sinusoidal transformation technique.
    This is an **in-memory operation**.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DynamicImage::thumbnail()`: 此函数将图像缩放到指定的大小（宽度和高度），并返回一个新的图像，同时保持宽高比。它使用快速整数算法，这是一种正弦变换技术。这是一个**内存操作**。'
- en: '`DynamicImage::write_to()`: This function encodes an image and writes it to
    any object that implements the `std::io::write` trait, which in our case will
    be an output *file handle*. We will use this method to write the resized image
    to a file.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DynamicImage::write_to()`: 这个函数将图像编码并写入实现了`std::io::write`特质的任何对象，在我们的情况下将是一个输出*文件句柄*。我们将使用这个方法将调整大小的图像写入文件。'
- en: This should be adequate for our image processing requirements in this project.
    For the other two concerns around path manipulation and time measurements, we
    will use the Rust Standard Library, which is described in the next subsection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以满足我们在这个项目中的图像处理需求。对于路径操作和时间测量的其他两个问题，我们将使用Rust标准库，这将在下一小节中描述。
- en: Using the Rust Standard Library
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Rust标准库
- en: For developing the image resizing tool, we will be using both external crates
    and the Rust Standard Library. In the previous section, we saw how we plan to
    use the `image` crate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发图像调整大小工具时，我们将使用外部crate和Rust标准库。在前一节中，我们看到了我们计划如何使用`image`crate。
- en: 'In this section, we will cover the features of the Rust Standard Library that
    we will be using to build our project. There are three key areas where we will
    need the standard library:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍我们将使用Rust标准库构建项目时将使用的功能。我们需要标准库的三个关键领域：
- en: The *path manipulation and directory iteration* functionality is needed in order
    to search through a directory, locate the image files, and create a new subfolder.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在目录中搜索、定位图像文件并创建新的子目录，我们需要*路径操作和目录迭代*功能。
- en: We need to get tool configuration options from the user. We will evaluate two
    approaches – getting this information through *environment variables* and getting
    it through *command-line parameters*. We will choose one of the options.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要从用户那里获取工具配置选项。我们将评估两种方法——通过*环境变量*获取这些信息，以及通过*命令行参数*获取这些信息。我们将选择其中一个选项。
- en: We want to *measure the time taken* for the image resizing tasks.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望*测量图像调整大小任务所需的时间*。
- en: Let's take a look at each of these areas in detail.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些领域的每个部分。
- en: Path manipulation and directory iteration
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径操作和目录迭代
- en: For path manipulation, we will use the `std::path` module from the Rust Standard
    Library. For directory iteration, we will use the `std::fs` module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于路径操作，我们将使用Rust标准库中的`std::path`模块。对于目录迭代，我们将使用`std::fs`模块。
- en: Why do we need to manipulate paths?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要操作路径？
- en: The source image files for resizing are stored in the *source folder*. The destination
    path for the resized image files is the `tmp` subfolder (within the *source folder*).
    Before writing each resized image file to disk, we have to construct the path
    where the file is to be stored. For example, if the path for the source file is
    `/user/bob/images/image1.jpg`, the destination path for the resized image will
    be `/user/bob/images/tmp/image1.jpg`. We have to construct the destination path
    programmatically, and then call the method on the `image` crate to store the image
    on the destination path.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 调整大小图像的源图像文件存储在*源文件夹*中。调整大小图像文件的目标路径是`tmp`子文件夹（在*源文件夹*内）。在将每个调整大小的图像文件写入磁盘之前，我们必须构建文件存储的路径。例如，如果源文件的路径是`/user/bob/images/image1.jpg`，调整大小图像的目标路径将是`/user/bob/images/tmp/image1.jpg`。我们必须程序化地构建目标路径，然后调用`image`crate上的方法以在目标路径上存储图像。
- en: 'The Rust Standard Library supports path manipulation functionality through
    two data types: `Path` and `PathBuf`, both part of the `std::path` module. See
    the sidebar for more details on how to construct and manipulate `paths` using
    the standard library.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库通过两种数据类型支持路径操作功能：`Path`和`PathBuf`，它们都是`std::path`模块的一部分。有关如何使用标准库构建和操作`paths`的更多详细信息，请参阅侧边栏。
- en: The std::path module of the Rust Standard Library
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库的`std::path`模块
- en: This module provides cross-platform path manipulation functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块提供了跨平台的路径操作函数。
- en: A path points to a filesystem location by following a directory tree. An example
    of a path in Unix systems is `/home/bob/images/`. An example of a path on the
    Windows operating system could be `c:\bob\images\image1.png`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 路径通过遵循目录树来指向文件系统位置。Unix系统中的一个路径示例是`/home/bob/images/`。Windows操作系统上的一个路径示例可能是`c:\bob\images\image1.png`。
- en: There are two main types in the `std::path` module that are commonly used—`Path`
    and `PathBuf`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::path`模块中，有两个常用的主要类型——`Path`和`PathBuf`。
- en: For parsing the path and its components (read operations), `Path` is used. In
    Rust parlance, it is a **path slice** (like a string slice, which is a reference
    to a string).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解析路径及其组件（读取操作），使用 `Path`。在 Rust 术语中，它是一个 **路径切片**（类似于字符串切片，它是对字符串的引用）。
- en: For modifying existing paths or to construct new paths, `PathBuf` is used. `PathBuf`
    is an **owned**, **mutable path**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于修改现有路径或构建新路径，使用 `PathBuf`。`PathBuf` 是一个 **拥有者**、**可变**的路径。
- en: '`Path` is used for read operations and `PathBuf` for read and write operations
    on paths.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 用于路径的读取操作，而 `PathBuf` 用于路径的读取和写入操作。'
- en: 'Here is how to construct a new path from a string:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何从一个字符串构造新路径的方法：
- en: '`let path_name = Path::new("/home/alice/foo.txt");`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`let path_name = Path::new("/home/alice/foo.txt");`'
- en: In `path_name`, `/home/alice` represents the parent, `foo` is the file stem,
    and `txt` is the file extension. We will be making use of the `file_stem()` and
    `extension()` methods on the `Path` type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `path_name` 中，`/home/alice` 代表父目录，`foo` 是文件名，`txt` 是文件扩展名。我们将使用 `Path` 类型上的
    `file_stem()` 和 `extension()` 方法。
- en: The `pop()` and `push()` methods on the `PathBuf` type are used to truncate
    and append components to a path.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PathBuf` 类型上的 `pop()` 和 `push()` 方法用于截断和向路径添加组件。
- en: 'Let''s create a new `PathBuf` path with the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码创建一个新的 `PathBuf` 路径：
- en: '`let mut path_for_editing = PathBuf::from("/home/bob/file1.png")`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`let mut path_for_editing = PathBuf::from("/home/bob/file1.png")`'
- en: '`path_for_editing.pop()` truncates this path to its parent, that is, `"/home/bob"`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`path_for_editing.pop()` 将此路径截断到其父路径，即 `"/home/bob"`。'
- en: Now, `push()` can be used to append a new component to `PathBuf`. For example,
    continuing from `PathBuf` with the value `"/home/bob"`, `push("tmp")` will append
    `tmp` to `"/home/bob"` path and return `"/home/bob/tmp"`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`push()` 可以用来向 `PathBuf` 添加新组件。例如，从具有值 `"/home/bob"` 的 `PathBuf` 继续操作，`push("tmp")`
    将 `tmp` 添加到 `"/home/bob"` 路径，并返回 `"/home/bob/tmp"`。
- en: We will be using the `pop()` and `push()` methods in our project to manipulate
    paths.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将使用 `pop()` 和 `push()` 方法来操作路径。
- en: Let's next look at how to perform the directory operations needed for our project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何执行我们项目所需的目录操作。
- en: When the user specifies `mode=all`, our requirement is to iterate through all
    the files in the specified source folder and filter the list of image files for
    processing. For iterating over directory paths, we will use the `read_dir()` function
    in the `std::fs` module.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户指定 `mode=all` 时，我们的要求是遍历指定源文件夹中的所有文件，并过滤出图像文件进行处理。对于遍历目录路径，我们将使用 `std::fs`
    模块中的 `read_dir()` 函数。
- en: 'Let''s see an example of how to use this function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用此函数的示例：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the explanation for the preceding code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的解释：
- en: '`fs:read_dir()` takes a source folder path and returns `std::fs::ReadDir`,
    which is an iterator over entries in the directory.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fs:read_dir()` 函数接收一个源文件夹路径，并返回 `std::fs::ReadDir`，它是一个遍历目录条目的迭代器。'
- en: We then use a `for` loop to extract each directory entry (which is wrapped in
    a `Result` type), and print out its value.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `for` 循环提取每个目录条目（它被 `Result` 类型包裹），并打印其值。
- en: This is the code we will use to get entries in a directory and do further processing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用来获取目录条目并进行进一步处理的代码。
- en: Apart from reading a directory for its contents, we also need to check for the
    presence of a `tmp` subfolder under the source folder and create it if it does
    not already exist. We will use the `create_dir()` method from the `std::fs` module
    to create a new subdirectory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读取目录内容外，我们还需要检查源文件夹下是否存在 `tmp` 子文件夹，如果不存在则创建它。我们将使用 `std::fs` 模块中的 `create_dir()`
    方法来创建一个新的子目录。
- en: We will see more details of the `std::fs` module in a later chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中看到 `std::fs` 模块的更多细节。
- en: Time measurement
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间测量
- en: For measuring time, we can use the `std::time` module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测量时间，我们可以使用 `std::time` 模块。
- en: The `std::time` module in the Rust Standard Library has several time-related
    functions including getting the *current system time*, creating a *duration* to
    represent a span of time, and measuring the *time elapsed* between two specific
    time instants. Some examples of using the `time` module are provided in the following.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 标准库中的 `std::time` 模块包含几个与时间相关的函数，包括获取 *当前系统时间*、创建表示时间跨度的 *duration* 以及测量两个特定时间点之间的
    *时间流逝*。以下提供了使用 `time` 模块的一些示例。
- en: 'To get the current system time, we can write the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前系统时间，我们可以编写以下代码：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is how to get the elapsed time from a given point in time:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何从给定的时间点获取经过的时间的方法：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Instant::now()` is used to indicate the starting point of the time to be measured.
    The time duration between this point and the point at which `now.elapsed()` is
    called represents the time taken for the operation(s). Here, we are simulating
    a delay using the `sleep()` function from the `std::thread` module.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Instant::now()` 用于指示要测量的时间的起点。从这一点到调用 `now.elapsed()` 的点之间的时间间隔代表操作所花费的时间。在这里，我们使用
    `std::thread` 模块中的 `sleep()` 函数来模拟延迟。'
- en: Working with environment variables
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理环境变量
- en: 'In this subsection, we will learn how to use the Rust Standard Library, along
    with a third-party helper crate, to store the values in environment variables
    and use them in the program:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将学习如何使用 Rust 标准库以及第三方辅助包来存储环境变量中的值并在程序中使用它们：
- en: 'Create a new project with the following line of code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行创建一个新的项目：
- en: '[PRE4]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[dependencies]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[dependencies]'
- en: dotenv = "0.15.0"
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: dotenv = "0.15.0"
- en: '[PRE5]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `main.rs`, add the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.rs` 中添加以下代码：
- en: '[PRE6]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we import the `std::env` module and also the `dotenv::dotenv`
    module.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了 `std::env` 模块和 `dotenv::dotenv` 模块。
- en: 'The following statement loads the environment variables from an `.env` file:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下语句从 `.env` 文件中加载环境变量：
- en: '[PRE7]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `for` loop in the previous code block iterates through the environment variables
    in a loop and prints them to the console. `env:vars()` returns an iterator of
    key-value pairs for all environment variables of the current process.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码块中的 `for` 循环会循环遍历环境变量并打印到控制台。`env:vars()` 返回一个迭代器，包含当前进程所有环境变量的键值对。
- en: 'To test this, let''s create a new`.env` file in the project root and make the
    following entries:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这一点，让我们在项目根目录中创建一个新的 `.env` 文件，并添加以下条目：
- en: '[PRE8]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Replace the `srcfolder` value with your own. Run the program with the following
    command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `srcfolder` 值替换为你的值。使用以下命令运行程序：
- en: '[PRE9]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To access the value of any particular environment variable, the `std::env::var()`
    function can be used, which takes the key of the variable as a parameter. Add
    the following statement to the `main()` function and see the value of the `size`
    variable printed out:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问任何特定环境变量的值，可以使用 `std::env::var()` 函数，它将变量的键作为参数。将以下语句添加到 `main()` 函数中，并查看打印出的
    `size` 变量的值：
- en: '[PRE10]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have seen how to use *environment variables* to accept user inputs for image
    processing. Let's see how to accept user inputs with *command-line* parameters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 *环境变量* 接受图像处理中的用户输入。让我们看看如何使用 *命令行参数* 接受用户输入。
- en: Working with command-line parameters
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理命令行参数
- en: 'In this subsection, we will learn to read command-line parameters using the
    `std::env` module of the Rust Standard Library:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将学习如何使用 Rust 标准库的 `std::env` 模块读取命令行参数：
- en: 'The `std::env` module supports command-line parameters through `std::env::args()`.
    Create a new Cargo project. Add the following line to the `main()` function in
    `src/main.rs`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::env` 模块通过 `std::env::args()` 支持命令行参数。创建一个新的 Cargo 项目。将以下行添加到 `src/main.rs`
    中的 `main()` 函数：'
- en: '[PRE11]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Execute the code with `cargo run small all /tmp`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo run small all /tmp` 执行代码。
- en: 'The three parameters passed to the program will be printed out to the console.
    To access individual parameters by index, add the following code to `main.rs`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传递给程序的三个参数打印到控制台。要通过索引访问单个参数，请将以下代码添加到 `main.rs`：
- en: '[PRE12]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the program with `cargo run small all /tmp`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo run small all /tmp` 运行程序。
- en: 'The individual values for `size`, `mode`, and `source_folder` will be printed
    out as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`、`mode` 和 `source_folder` 的单个值将按以下方式打印出来：'
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of the two approaches we have seen – that is, using *environment variables*
    and *command-line parameters* – the latter is more suitable for accepting inputs
    from end users, while the environment variable approach is more suitable for developers
    configuring the tool.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到的两种方法中——即使用 *环境变量* 和 *命令行参数*——后者更适合接受最终用户的输入，而环境变量方法更适合开发者配置工具。
- en: However, for a user-friendly interface, the bare-bones functionality offered
    by `std::env::args` is inadequate. We will use a third-party crate called **StructOpt**
    to improve the user interaction with the CLI.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了提供用户友好的界面，`std::env::args` 提供的裸骨功能是不够的。我们将使用名为 **StructOpt** 的第三方包来改善与
    CLI 的用户交互。
- en: This concludes the deep dive into the Rust Standard Library modules for path
    manipulation, time measurement, and reading environment and command-line parameters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对 Rust 标准库中路径操作、时间测量和读取环境和命令行参数模块的深入研究。
- en: 'Here is a summary of the design approaches we have discussed, for the `imagix`
    library:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于 `imagix` 库的设计方法总结：
- en: '`image-rs/image` crate.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image-rs/image` 库。'
- en: How do we create a `/tmp/` subfolder to store the resized images?
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们如何创建一个 `/tmp/` 子文件夹来存储缩放后的图像？
- en: We will use the `std::fs::create_dir()` method.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用 `std::fs::create_dir()` 方法。
- en: '`std::fs::read_dir()` method.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs::read_dir()` 方法。'
- en: How do we manipulate paths so that the output file is stored in the `tmp` subfolder?
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们如何操作路径，以便输出文件存储在 `tmp` 子文件夹中？
- en: We will use the `std::path::Path` and `std::path::PathBuf` types.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用 `std::path::Path` 和 `std::path::PathBuf` 类型。
- en: '`std::path::Path` type and the `std::fs::read_dir()` method.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::path::Path` 类型以及 `std::fs::read_dir()` 方法。'
- en: '`std::time::Duration` and `std::time::Instant` modules.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::time::Duration` 和 `std::time::Instant` 模块。'
- en: '`StructOpt` crate.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StructOpt` 库。'
- en: With this, we conclude this section on addressing project scope and design for
    the `imagix` library. We are now ready to start writing the code for the image
    processing library in the next section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们得出本节关于 `imagix` 库的项目范围和设计的结论。我们现在可以开始编写下一节中图像处理库的代码了。
- en: Coding the imagix library
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 imagix 库
- en: In this section, we'll write the code for the image resizing and image statistics
    functionalities. Let's first look at the code structure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写图像缩放和图像统计功能的代码。让我们首先看看代码结构。
- en: 'The module structure of the `imagix` library is summarized in *Figure 4.4*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`imagix` 库的模块结构总结在 *图 4.4* 中：'
- en: '![Figure 4.4 – Modules of the imagix library](img/Figure_4.4_B16405.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – imagix 库的模块](img/Figure_4.4_B16405.jpg)'
- en: Figure 4.4 – Modules of the imagix library
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – imagix 库的模块
- en: The `imagix` library will consist of two modules, `resize.rs` and `stats.rs`
    respectively. There are two `enums`, `SizeOption` and `Mode`, for representing
    the variants for *size option* and *mode* respectively. The user will specify
    one of the variants of the `SizeOption` `enum` to indicate the desired output
    image size, and one of the variants of the `Mode` `enum` to indicate whether one
    or multiple images need to be resized. There is also `struct Elapsed` for capturing
    elapsed time of the image resizing operation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`imagix` 库将包括两个模块，分别是 `resize.rs` 和 `stats.rs`。有两个 `enum`，`SizeOption` 和 `Mode`，分别用于表示
    *大小选项* 和 *模式* 的变体。用户将指定 `SizeOption` `enum` 的一个变体来指示所需的输出图像大小，以及指定 `Mode` `enum`
    的一个变体来指示是否需要缩放一个或多个图像。还有一个 `struct Elapsed` 用于捕获图像缩放操作的耗时。'
- en: The `resize` module has the `process_resize_request()` public function, which
    is the main entry point into the `imagix` library for resizing images.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`resize` 模块有一个 `process_resize_request()` 公共函数，它是 `imagix` 库中图像缩放的主要入口点。'
- en: The `stats` module has a `get_stats()` public function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats` 模块有一个 `get_stats()` 公共函数。'
- en: 'An overview of the overall code organization of the project is shown in *Figure
    4.5*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 项目整体代码组织的概述显示在 *图 4.5* 中：
- en: '![Figure 4.5 – Code organization](img/Figure_4.5_B16405.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 代码组织](img/Figure_4.5_B16405.jpg)'
- en: Figure 4.5 – Code organization
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 代码组织
- en: '*Figure 4.5* shows the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.5* 展示了以下内容：'
- en: The configuration and dependency entries needed in the `Cargo.toml` file
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 文件中需要的配置和依赖项
- en: The Cargo project's code tree structure
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cargo 项目的代码树结构
- en: The list of source files of the `imagix` library along with a list of the key
    functions
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagix` 库的源文件列表以及关键函数列表'
- en: The `imagecli.rs` file, which represents the command-line wrapper over the `imagix`
    library, and the code execution entry point in our tool
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagecli.rs` 文件，它代表了 `imagix` 库的命令行包装，以及我们工具中的代码执行入口点'
- en: 'Let''s first add the two external crates to `Cargo.toml` in the `imagecli`
    project folder root:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在 `imagecli` 项目的根目录中的 `Cargo.toml` 中添加两个外部库：
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this section, we will walk through the code snippets for the following methods:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将遍历以下方法的代码片段：
- en: '`get_image_files()`, which demonstrates path navigation'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_image_files()`，演示路径导航'
- en: '`resize_image()`, which contains the core logic for image resizing using the
    image crate, and for time measurements'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize_image()`，它包含使用图像库进行图像缩放的核心逻辑，以及时间测量'
- en: '`get_stats()`, which returns the total count and the total size of image files
    in a folder'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_stats()`，它返回文件夹中图像文件的总数和总大小'
- en: Custom error handling methods
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义错误处理方法
- en: The rest of the code is standard Rust (not specific to the topics this chapter
    is focused on) and can be found in the code repository for this chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分是标准的 Rust 代码（不特定于本章关注的主题），可以在本章的代码仓库中找到。
- en: Iterating through directory entries
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历目录条目
- en: In this subsection, let's review the code for `get_image_files()`. This is the
    method that retrieves the list of image files contained in a source folder.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，让我们审查`get_image_files()`方法的代码。这是检索源文件夹中包含的图片文件列表的方法。
- en: 'The logic for this method is described here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的逻辑描述如下：
- en: We first retrieve the directory entries in the source folder and collect them
    in a *vector*.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检索源文件夹中的目录条目并将它们收集到一个*向量*中。
- en: We then iterate over entries in the vector and filter for only the image files.
    Note that we are only focusing on `PNG` and `JPG` files in this project, but it
    can be extended to other types of image files too.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历向量中的条目并筛选出仅包含图片文件。请注意，在这个项目中，我们只关注`PNG`和`JPG`文件，但也可以扩展到其他类型的图片文件。
- en: A list of image files is returned from this method.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法从该方法返回一个图片文件列表。
- en: 'The code listing is shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码列表如下所示：
- en: src/imagix/resize.rs
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: src/imagix/resize.rs
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code uses the `read_dir()` method to iterate through directory entries and
    collects the results in a `Vector`. The `Vector` is then converted into an iterator,
    and the entries are filtered to return only image files. This gives us the set
    of image files to work with, for resizing. In the next subsection, we will review
    the code to perform the actual resizing of the images.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`read_dir()`方法遍历目录条目并将结果收集到一个`Vector`中。然后，将`Vector`转换为迭代器，并筛选出仅包含图片文件的条目。这为我们提供了用于调整大小的图片文件集。在下一小节中，我们将审查执行实际图片调整大小的代码。
- en: Resizing images
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整图片大小
- en: In this subsection, we will review the code for `resize_image()`. This method
    performs the resizing of images.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将审查`resize_image()`方法的代码。此方法执行图片的调整大小。
- en: 'The logic for this method is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的逻辑如下：
- en: The method accepts a source image filename with the full source folder path,
    resizes it as a `.png` file, and stores the resized file in a `/tmp` subfolder
    under the source folder.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法接受一个包含完整源文件夹路径的源图片文件名，将其调整大小为`.png`文件，并将调整大小的文件存储在源文件夹下的`/tmp`子文件夹中。
- en: First, the source filename is extracted from the full path. The file extension
    is changed to `.png`. This is because our tool will only support output files
    in `.png` format. As an exercise, you can add support for other image format types.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从完整路径中提取源文件名。文件扩展名更改为`.png`。这是因为我们的工具将仅支持`.png`格式的输出文件。作为一个练习，你可以添加对其他图像格式类型的支持。
- en: Then the destination file path is constructed with the `/tmp` prefix, as the
    resized image will need to be stored in the `tmp` subfolder under the source folder.
    To achieve this, we first need to check whether the `tmp` folder already exists.
    If not, it has to be created. The logic for constructing the path with the `tmp`
    subfolder and for creating the `tmp` subfolder is shown in the previous code listing.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用`/tmp`前缀构建目标文件路径，因为调整大小的图片需要存储在源文件夹下的`tmp`子文件夹中。为了实现这一点，我们首先需要检查`tmp`文件夹是否已经存在。如果不存在，则需要创建它。构建带有`tmp`子文件夹的路径和创建`tmp`子文件夹的逻辑在之前的代码列表中已展示。
- en: Finally, we need to resize the image. For this, the source file is opened, the
    resize function is called with requisite parameters, and the resized image is
    written to the output file.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要调整图片的大小。为此，打开源文件，使用必要的参数调用调整大小函数，并将调整大小的图片写入输出文件。
- en: The time taken for image resizing is calculated using the `Instant::now()` and
    `Elapsed::from()` functions.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Instant::now()`和`Elapsed::from()`函数计算图片调整大小所需的时间。
- en: The code listing is shown here. For purposes of explanation, the code listing
    has been split into multiple snippets.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 代码列表如下所示。为了解释说明，代码列表已被拆分为多个片段。
- en: 'The code listed here accepts three input parameters – the size, source folder,
    and an entry of type `PathBuf` (which can refer to the full path of an image file).
    The file extension is changed to `.png` as this is the output format supported
    by the tool:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的代码接受三个输入参数——大小、源文件夹和一个类型为`PathBuf`的条目（它可以引用图片文件的完整路径）。文件扩展名更改为`.png`，因为这是工具支持的输出格式：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code snippet here appends the suffix `/tmp` to the file path entry in order
    to create the destination folder path. Note that due to a limitation in the standard
    library, the filename is first constructed as `tmp.png`, which is subsequently
    changed to reflect the final resized image filename:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将后缀`/tmp`追加到文件路径条目中，以创建目标文件夹路径。请注意，由于标准库的限制，首先将文件名构造为`tmp.png`，随后将其更改为反映最终调整大小的图片文件名：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code here opens the image file and loads the image data into memory. The
    `/tmp` subfolder is created under the source folder. Then, the image is resized
    and written to the output file in the destination folder. The time taken for the
    resizing operation is recorded and printed out:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码打开图像文件并将图像数据加载到内存中。在源文件夹下创建一个`/tmp`子文件夹。然后，将图像调整大小并写入目标文件夹的输出文件。记录并打印调整大小操作所需的时间：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have now seen the code for resizing images. Next, we will look at the code
    for generating image stats.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了调整图像的代码。接下来，我们将查看生成图像统计信息的代码。
- en: Image statistics
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像统计
- en: In the previous subsection, we looked at the code for image resizing. In this
    subsection, we will see the logic for generating image statistics. This method
    will count the number of image files in a specified source folder, and measure
    their total file size.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中，我们看到了调整图像的代码。在本节中，我们将看到生成图像统计信息的逻辑。此方法将计算指定源文件夹中的图像文件数量，并测量所有图像文件的总文件大小。
- en: 'The logic of the `get_stats()` method that we will use is described as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的`get_stats()`方法的逻辑描述如下：
- en: 'The `get_stats()` method takes a source folder as its input parameter and returns
    two values: the number of image files in the folder, and the total aggregate size
    of all image files in the folder.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_stats()`方法接受一个源文件夹作为其输入参数，并返回两个值：文件夹中的图像文件数量，以及文件夹中所有图像文件的总聚合大小。'
- en: Get a list of image files in the source folder by calling the `get_image_files()`
    method.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`get_image_files()`方法获取源文件夹中的图像文件列表。
- en: The `metadata()` function in the `std::path` module allows us to query a file
    or directory for its metadata information. In our code, as we iterate through
    the directory entries, we aggregate the sizes of all files in one variable, `sum`.
    The `sum` variable is returned from the function along with the count of image
    file entries.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::path`模块中的`metadata()`函数允许我们查询文件或目录的元数据信息。在我们的代码中，当我们遍历目录条目时，我们将所有文件的尺寸汇总到一个变量`sum`中。`sum`变量与图像文件条目的计数一起从函数返回。'
- en: 'The code listing is provided here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 代码列表如下所示：
- en: src/imagix/stats.rs
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: src/imagix/stats.rs
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have covered the code for the image processing functionality. We will now
    cover some details of our custom error handling for the project.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了图像处理功能的代码。现在，我们将介绍项目中自定义错误处理的细节。
- en: Error handling
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: Let's now take a look at our error handling design.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的错误处理设计。
- en: 'As a part of our project, there may be many failure conditions that we have
    to handle. Some of them are given here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们项目的一部分，我们可能需要处理许多故障条件。其中一些如下所示：
- en: The source folder given by the user may be invalid.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提供的源文件夹可能无效。
- en: The specified file may not be present in the source folder.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的文件可能不在源文件夹中。
- en: Our program may not have permission to read and write files.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们程序可能没有权限读取和写入文件。
- en: User inputs for size or mode may be incorrect.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入的大小或模式可能不正确。
- en: There may be errors during image resizing (for example, a corrupt file).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像调整大小过程中可能会出现错误（例如，文件损坏）。
- en: There may be other types of internal processing errors.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在其他类型的内部处理错误。
- en: 'Let''s define a custom error type to handle all these different types of errors
    in a unified manner, and provide the error as output to the users of our library:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个自定义错误类型，以统一方式处理所有这些不同类型的错误，并将错误作为库用户输出：
- en: src/imagix/error.rs
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: src/imagix/error.rs
- en: '[PRE20]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The names of the errors are mostly self-explanatory. `FormatError` is any error
    encountered while converting or printing values of parameters. The goal of defining
    this custom error type is that the various types of errors that may be encountered
    during processing, such as errors in user input, the inability to read through
    a directory or write to a file, an error in image processing, and so on, are converted
    into our custom error type.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的名称大多一目了然。`FormatError`是指在转换或打印参数值时遇到的任何错误。定义此自定义错误类型的目的是将处理过程中可能遇到的多种类型的错误，如用户输入错误、无法读取目录或写入文件、图像处理错误等，转换为我们的自定义错误类型。
- en: It is not enough to just define a custom error type. We also have to ensure
    that when errors happen in due course of the program's operation, these errors
    are translated into the custom error type. For example, an error in reading an
    image file raises an error defined in the `std::fs` module. This error should
    be caught and transformed into our custom error type. This way, regardless of
    whether there is an error in file operations or error processing, the program
    uniformly propagates the same custom error type for handling by the frontend interface
    to the user (in the case of this project, it is the command line).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 仅定义一个自定义错误类型是不够的。我们还需要确保在程序运行过程中发生错误时，这些错误被转换为自定义错误类型。例如，读取图像文件时出现的错误会触发`std::fs`模块中定义的错误。这个错误应该被捕获并转换为我们的自定义错误类型。这样，无论文件操作或错误处理中是否存在错误，程序都会统一传播相同的自定义错误类型，以便由前端界面（在这个项目中，是命令行）处理用户。
- en: For the conversion of various types of errors into `ImagixError`, we will implement
    the `From` trait. We will also implement the `Display` trait for our error type
    so that the errors can be printed out to the console.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将各种类型的错误转换为`ImagixError`，我们将实现`From`特性和`Display`特性，以便错误可以被打印到控制台。
- en: Within each of the methods in the project modules, at the failure points, you
    will notice that `ImagixError` is raised and propagated back to the calling function.
    The source code can be found in the source folder for this chapter in the Packt
    code repository.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目模块中的每个方法中，在失败点，你会注意到会抛出`ImagixError`并传播回调用函数。源代码可以在本章节的Packt代码仓库的源文件夹中找到。
- en: This concludes the error handling subsection of the code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着代码中错误处理的子节结束。
- en: This also concludes this section on coding the `imagix` library. We have only
    walked through key code snippets as it isn't practical to print out the entire
    code listing inline in the chapter. I would urge the reader to go through the
    entire source code to understand how the various features are translated into
    idiomatic Rust code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这也标志着本节关于`imagix`库编码的结束。我们只走过了关键代码片段，因为在本章中直接打印整个代码列表并不实用。我敦促读者阅读整个源代码，以了解各种功能是如何转换为惯用的Rust代码的。
- en: In the next section, we will build the command-line application that wraps this
    library and provides the user interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将构建一个命令行应用程序，它封装了这个库并提供用户界面。
- en: Developing the command-line application and testing
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发命令行应用程序并进行测试
- en: In the previous section, we built the library for image resizing. In this section,
    we will review the design and key parts of the code for the main command-line
    application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了图像调整大小的库。在本节中，我们将回顾主命令行应用程序的设计和关键代码部分。
- en: 'Let''s begin with some automated unit tests to test the image resizing functionality
    in `resize.rs`: This way we can confirm that the image resizing library works
    independently of any calling function.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些自动化的单元测试开始，以测试`resize.rs`中的图像调整大小功能：这样我们可以确认图像调整大小库可以独立于任何调用函数工作。
- en: 'Two test cases are shown here in the following code—one to resize a single
    image, and the other to resize multiple images. You can replace the source folder
    and filenames in the code with your own:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中展示了两个测试用例——一个用于调整单个图像的大小，另一个用于调整多个图像的大小。你可以将代码中的源文件夹和文件名替换为你自己的：
- en: src/imagix/resize.rs
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: src/imagix/resize.rs
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Place the `image1.jpg` and `image2.jpg` files in `/tmp/images` and execute
    the tests with the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将`image1.jpg`和`image2.jpg`文件放在`/tmp/images`中，并使用以下命令执行测试：
- en: '[PRE22]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see the tests pass successfully. You can also inspect the resized images.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到测试成功通过。你还可以检查调整大小的图像。
- en: As an exercise, you can add the test cases for the image stats function as well.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你也可以为图像统计功能添加测试用例。
- en: We can now conclude that the `imagix` library works as intended. Let's now move
    on to designing the command-line application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以得出结论，`imagix`库按预期工作。现在让我们继续设计命令行应用程序。
- en: We shall first look at the CLI requirements.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下命令行界面的要求。
- en: Designing the command-line interface
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计命令行界面
- en: In this subsection, we will look at the design of the CLI. By design, we mean
    finalizing the structure of the CLI that the user will use. The CLI should be
    intuitive to use for the end user. The CLI must also accommodate some flexibility
    in its performing of different types of operations.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将探讨CLI的设计。设计意味着确定用户将使用的CLI的结构。CLI应该对最终用户来说易于使用。CLI还必须在其执行不同类型的操作时具有一定的灵活性。
- en: The `imagecli` CLI will use a command-subcommand model like `git`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`imagecli` CLI 将使用类似于 `git` 的命令-子命令模型。'
- en: 'The CLI command structure is shown in *Figure 4.6*:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: CLI命令结构如图 *4.6* 所示：
- en: '![Figure 4.6 – Design of CLI commands](img/Figure_4.6_B16405.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – CLI命令设计](img/Figure_4.6_B16405.jpg)'
- en: Figure 4.6 – Design of CLI commands
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – CLI命令设计
- en: 'Here are some examples of commands with parameters that the user can specify:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些用户可以指定的带有参数的命令示例：
- en: For resizing images, the command is `cargo run –-release resize` with three
    parameters.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于调整图像，命令是 `cargo run –-release resize`，带有三个参数。
- en: For image statistics, the command is `cargo run –-release stats` with one parameter.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于图像统计，命令是 `cargo run –-release stats`，带有一个参数。
- en: For resizing a single image the command is `cargo run --release resize --size
    small --mode single --srcfolder <path-to-image-file/file-name.extn>`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于调整单个图像，命令是 `cargo run --release resize --size small --mode single --srcfolder
    <图像文件路径/文件名.extn>`。
- en: For resizing multiple images, we use the `cargo run --release resize --size
    medium --mode all --srcfolder <path-to-folder-containing-images>` command.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于调整多个图像的大小，我们使用 `cargo run --release resize --size medium --mode all --srcfolder
    <包含图像的文件夹路径>` 命令。
- en: For image statistics, the `cargo run --release stats --srcfolder <path-to-folder-containing-images>`
    command is used.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于图像统计，使用 `cargo run --release stats --srcfolder <包含图像的文件夹路径>` 命令。
- en: The `imagecli` `main()` function parses the command-line parameters, handles
    user and processing errors with suitable messages to the user, and invokes the
    respective functions from the `imagix` library.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`imagecli` 的 `main()` 函数解析命令行参数，通过向用户显示适当的错误消息来处理用户和加工错误，并调用 `imagix` 库中的相应函数。'
- en: 'Let''s do a quick recap. To resize images, we need to know the following from
    the user:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下。为了调整图像大小，我们需要从用户那里了解以下信息：
- en: The mode (single or multiple files)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式（单文件或多文件）
- en: The output size of the image file (small/medium/large)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像文件的大小输出（小/中/大）
- en: The source folder where the image file (or files) is located
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存放图像文件（或文件）的源文件夹
- en: In this section, we designed the CLI for the tool. In the previous sections,
    we built the `imagix` library to resize images. We will now move on to the last
    part of the project, which is to develop the main command-line binary application
    that ties all the pieces together and accepts user inputs from the command-line.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为工具设计了命令行界面（CLI）。在前几节中，我们构建了 `imagix` 库来调整图像大小。现在，我们将继续进行项目的最后一部分，即开发主要的命令行二进制应用程序，该应用程序将所有组件连接起来，并接受来自命令行的用户输入。
- en: Coding the command-line binary using structopt
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 structopt 编码命令行二进制
- en: In the previous section, we designed the interface for the command-line tool.
    In this section, we will see the code for the `main()` function that accepts user
    inputs from the command line and invokes the `imagix` library. This `main()` function
    will be compiled and built into the command-line binary tool. The user will invoke
    this executable for resizing images and provide the necessary command-line parameters.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们为命令行工具设计了界面。在本节中，我们将看到 `main()` 函数的代码，该函数接受来自命令行的用户输入并调用 `imagix` 库。这个
    `main()` 函数将被编译并构建成命令行二进制工具。用户将调用这个可执行文件来调整图像并提供必要的命令行参数。
- en: The `main()` function will be located in `src/imagecli.rs`, as we want the command-line
    tool binary name to be `imagecli`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数将位于 `src/imagecli.rs` 中，因为我们希望命令行工具的二进制名称为 `imagecli`。'
- en: 'Let''s now review the code snippets for the command-line application. The `main()`
    function is located in the `src/imagecli.rs` file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾命令行应用程序的代码片段。`main()` 函数位于 `src/imagecli.rs` 文件中：
- en: 'We will start with the imports section. Note the imports of the `imagix` library
    that we have written, and `structOpt` for command-line argument parsing:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从导入部分开始。注意我们编写的 `imagix` 库的导入，以及用于命令行参数解析的 `structOpt`：
- en: '[PRE23]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will now see the definition of the command-line parameters for the tool.
    For this we will use the `structopt` syntax. Refer to documentation at [https://docs.rs/structopt](https://docs.rs/structopt).
    Basically, we have defined an `enum` called `Commandline` and defined two subcommands,
    `Resize` and `Stats`. `Resize` takes three arguments: `size`, `mode` and `srcfolder`
    (the source folder). `Stats` takes one argument: `srcfolder`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将看到工具的命令行参数的定义。为此，我们将使用`structopt`语法。请参阅[https://docs.rs/structopt](https://docs.rs/structopt)中的文档。基本上，我们定义了一个名为`Commandline`的`enum`，并定义了两个子命令，`Resize`和`Stats`。`Resize`接受三个参数：`size`、`mode`和`srcfolder`（源文件夹）。`Stats`接受一个参数：`srcfolder`：
- en: '[PRE24]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can now review the code for the `main()` function. Here, we basically accept
    the command-line inputs (validated by `StructOpt`) and invoke the suitable methods
    from our `imagix` library. If the user specifies the `Resize` command, the `process_resize_request()`
    method of the `imagix` library is invoked. If the user specifies the `Stats` command,
    the `get_stats()` method of the `imagix` library is invoked. Any errors are handled
    with suitable messages:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以回顾`main()`函数的代码。在这里，我们基本上接受命令行输入（由`StructOpt`验证）并调用我们的`imagix`库中的合适方法。如果用户指定了`Resize`命令，将调用`imagix`库中的`process_resize_request()`方法。如果用户指定了`Stats`命令，将调用`imagix`库中的`get_stats()`方法。任何错误都通过合适的消息来处理：
- en: '[PRE25]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Build the app with the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建应用程序：
- en: '[PRE26]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The reason to use the release builds is that there is a considerable time difference
    in resizing images between the debug and release builds (the latter being much
    faster).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用发布构建的原因是在调试和发布构建之间调整图像大小存在相当大的时间差异（后者要快得多）。
- en: 'You can then execute and test the following scenarios at the Terminal. Ensure
    to place one or more `.png` or `.jpg` files in the folder that you specify in
    `--srcfolder` flag:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在终端执行并测试以下场景。请确保在`--srcfolder`标志指定的文件夹中放置一个或多个`.png`或`.jpg`文件：
- en: '**Resize a single image**:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整单个图像大小**：'
- en: '[PRE27]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Resize multiple files**:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整多个文件大小**：'
- en: '[PRE28]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Generate image stats**:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成图像统计**：'
- en: '[PRE29]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this section, we have built a tool for image resizing that works from a CLI.
    As an exercise, you can experiment by adding additional features, including adding
    support for more image formats, changing the size of the output file, or even
    providing the option to encrypt the generated image file for additional security.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们构建了一个从命令行界面（CLI）工作的图像调整大小工具。作为一个练习，您可以尝试添加额外的功能，包括添加对更多图像格式的支持、更改输出文件的大小，甚至提供加密生成的图像文件以提供额外安全性的选项。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned to write Rust programs that can discover and manipulate
    the system environment, directory structures, and filesystem metadata in a cross-platform
    manner, using the `std::env`, `std::path`, and `std::fs` modules. We looked at
    how to create programs that can use command-line arguments or environment variables
    to accept configuration parameters and user inputs. We saw the use of two third-party
    crates: the `StructOpt` crate to improve the user interface of the tool, and `image-rs/image`
    to do the image resizing.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何编写Rust程序，这些程序可以以跨平台的方式发现和操作系统环境、目录结构和文件系统元数据，使用`std::env`、`std::path`和`std::fs`模块。我们探讨了如何创建可以使用命令行参数或环境变量来接受配置参数和用户输入的程序。我们看到了两个第三方crate的使用：`StructOpt`crate来改进工具的用户界面，以及`image-rs/image`来进行图像调整大小。
- en: We also learned how to use the `std:time` module to measure the time taken for
    specific processing tasks. We defined a custom error type to unify error handling
    in the library. In this chapter, we were also introduced to file handling operations.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用`std:time`模块来测量特定处理任务所需的时间。我们定义了一个自定义错误类型以统一库中的错误处理。在本章中，我们还介绍了文件处理操作。
- en: In the next chapter, we will take a detailed look at doing advanced memory management
    with the standard library.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨使用标准库进行高级内存管理。
