- en: Reactive Microservices - Increasing Capacity and Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式微服务 - 提高容量和性能
- en: If you adhere to a microservices architecture for your application, you'll get
    the benefits of loose coupling, meaning that every microservice is standalone
    enough to be developed and maintained by separate teams. This is a kind of asynchronous
    approach to business tasks, but it's not the only benefit; there are others. You
    can increase your capacity and performance by only scaling the microservices that
    take a huge load. To achieve this, your microservice has to be reactive, and it
    has to be self-sustaining, interacting with other microservices via message passing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为您的应用程序采用微服务架构，您将获得松耦合的好处，这意味着每个微服务都足够独立，可以由不同的团队开发和维护。这是一种对业务任务的异步方法，但并非唯一的好处；还有其他好处。您可以通过仅扩展承担巨大负载的微服务来提高容量和性能。为了实现这一点，您的微服务必须是反应式的，并且必须是自维持的，通过消息传递与其他微服务进行交互。
- en: In this chapter, you will learn what a reactive microservice is, and how to
    use message passing to ensure the connectivity of microservices. Also, we will
    discuss whether reactive microservices can be asynchronous.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解什么是反应式微服务，以及如何使用消息传递来确保微服务的连通性。此外，我们还将讨论反应式微服务是否可以是异步的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a reactive microservice?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是反应式微服务？
- en: JSON-RPC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-RPC
- en: gRPC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will cover using **remote procedure calls** (**RPCs**) in Rust.
    You'll need a working Rust compiler, because we will create two examples with
    the `jsonrpc-http-server` and `grpc` crates.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍在Rust中使用**远程过程调用（RPCs**）。您需要一个工作的Rust编译器，因为我们将会使用`jsonrpc-http-server`和`grpc`包创建两个示例。
- en: If you want to test TLS connections, you'll need OpenSSL version 0.9, because
    the `grpc` crate doesn't support version 1.0 or higher yet. Most modern operating
    systems have switched to 1.0 already, but you can build the examples to a Docker
    image that supports version 0.9, or wait till the `grpc` crate is updated to the
    latest OpenSSL version. We will build test examples without TLS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试TLS连接，您需要OpenSSL版本0.9，因为`grpc`包目前还不支持1.0或更高版本。大多数现代操作系统已经切换到1.0，但您可以将示例构建到支持版本0.9的Docker镜像中，或者等待`grpc`包更新到最新的OpenSSL版本。我们将构建不带TLS的测试示例。
- en: You can find the sources of the examples from this chapter in the GitHub repository
    at, [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter06).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本章的GitHub仓库中找到示例的来源，网址为[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter06)。
- en: What is a reactive microservice?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是反应式微服务？
- en: A microservices architecture implies the presence of multiple parts in an application.
    In the past, most applications were monoliths, with all of the parts contained
    in a single code base. The microservices approach gives us the opportunity to
    split a code base between multiple teams and developers, to have an individual
    life cycle for every microservice, and for parts to interact with a common protocol.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构意味着应用程序中存在多个部分。在过去，大多数应用程序都是单体，所有部分都包含在单个代码库中。微服务方法为我们提供了将代码库分割到多个团队和开发者的机会，为每个微服务提供一个单独的生命周期，以及部分通过一个通用协议进行交互。
- en: Does this mean that your application will be free from all of the flaws of a
    monolithic application? No. You can write microservices that are so closely related
    to each other that you can't even properly update them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着您的应用程序将完全摆脱单体应用程序的所有缺陷？不。您可以编写相互之间如此紧密相关的微服务，以至于您甚至无法正确地更新它们。
- en: How is this possible? Imagine that you have a microservice that has to wait
    for the response of another microservice to send a response to a client. The other
    microservice, in turn, also has to wait for another microservice, and so on. If
    you closely link the microservices of an application, you will find the same drawbacks
    that you have with monoliths.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何实现的？想象一下，您有一个微服务需要等待另一个微服务的响应才能向客户端发送响应。反过来，另一个微服务也必须等待另一个微服务的响应，依此类推。如果您将应用程序的微服务紧密关联起来，您会发现与单体相同的缺点。
- en: You have to write microservices as independent applications that can be reused
    for multiple projects, not only yours. How can you achieve that? Develop a reactive
    microservice. Let's look at what that is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须编写微服务作为可以用于多个项目（而不仅仅是你的项目）的独立应用程序。你如何实现这一点？开发一个反应式微服务。让我们看看这是什么。
- en: Loose coupling
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合
- en: Loose coupling is a software design approach that implies every part of an application
    should know little information about the other parts. In traditional applications,
    if you write a GUI component, such as a button, it has to be possible to use it
    everywhere, for any application. As another example, if you develop a library
    to work with sound hardware, this also means you can use it with every application;
    the library is not limited to use in one kind of application. In microservices,
    however, loose coupling means that a microservice doesn't know anything about
    other microservices, or how many there are.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合是一种软件开发方法，意味着应用程序的每个部分应该对其他部分了解很少的信息。在传统应用程序中，如果你编写一个GUI组件，例如一个按钮，它必须可以在任何地方、任何应用程序中使用。作为另一个例子，如果你开发一个用于处理声音硬件的库，这也意味着你可以与每个应用程序一起使用；该库不限于在一种应用程序中使用。然而，在微服务中，松散耦合意味着一个微服务不知道其他微服务或它们的数量。
- en: If you develop an application, you should write parts of it—microservices—as
    standalone applications. For example, a notification service that sends push notifications
    to mobile platforms won't know about CRM, accounting, or even the users. Is it
    possible to do this? Yes! You can write a microservice that uses a common protocol
    and interacts with other services via message passing. This is called a **message-driven
    application**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开发一个应用程序，你应该将其部分——微服务——编写为独立的应用程序。例如，一个发送推送通知到移动平台的通告服务不会知道CRM、会计或甚至用户。这是否可能？是的！你可以编写一个使用通用协议并通过消息传递与其他服务交互的微服务。这被称为**消息驱动应用程序**。
- en: Message-driven applications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动应用程序
- en: Traditional microservices have an API that immediately returns a result and
    every participant of a working application has to know about the other parts.
    This approach keeps the relations of microservices close. Such an application
    is hard to maintain, update, and scale.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的微服务有一个立即返回结果的API，并且一个工作应用程序的每个参与者都必须了解其他部分。这种方法使微服务之间的关系保持紧密。这样的应用程序难以维护、更新和扩展。
- en: It is much more convenient if your application interacts via messages that are
    handled by other microservices. This approach is called **message-driven**, when
    you use messages as a unit of interaction. Messages help you to reduce the coupling
    of microservices, because you can process a message for multiple services simultaneously
    or add an extra processing message for a particular message type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序通过由其他微服务处理的消息进行交互，那就更加方便了。当你使用消息作为交互单元时，这种方法被称为**消息驱动**。消息帮助你减少微服务的耦合，因为你可以同时为多个服务处理一条消息，或者为特定消息类型添加额外的处理消息。
- en: To have totally uncoupled microservices, you should use a message queue or a
    message broker service. We will learn this approach in detail in [Chapter 12](98204850-538d-4a2b-9a77-23f85e716400.xhtml),
    [Scalable Microservices Architecture](https://cdp.packtpub.com/hands_on_microservices_with_rust_2018/wp-admin/post.php?post=405&action=edit), in
    which we talk about scalable architecture.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要有完全解耦的微服务，你应该使用消息队列或消息代理服务。我们将在[第12章](98204850-538d-4a2b-9a77-23f85e716400.xhtml)，[可扩展微服务架构](https://cdp.packtpub.com/hands_on_microservices_with_rust_2018/wp-admin/post.php?post=405&action=edit)中详细了解这种方法，其中我们讨论了可扩展架构。
- en: Asynchronous
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步
- en: Since reactive microservices use message passing, you have to process message
    asynchronously. This doesn't mean you have to use asynchronous crates such as `tokio`
    or `futures`. But it means no one message can block the service; every message
    is processed in a short period of time and if the service has to perform a long
    task it should do it as a background task and inform the thread issued that task
    about the result by sending a message with that result. To achieve this behavior,
    you can use multiple threads without asynchronous code. But what about using asynchronous
    code for reactive microservices?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反应式微服务使用消息传递，你必须异步处理消息。这并不意味着你必须使用异步crate，如`tokio`或`futures`。但这意味着没有任何一条消息可以阻塞服务；每条消息都在短时间内被处理，如果服务必须执行长时间的任务，它应该将其作为后台任务执行，并通过发送包含该结果的消息来通知执行该任务的线程。为了实现这种行为，你可以使用多个线程而不需要异步代码。但对于反应式微服务来说，使用异步代码又是怎样的情况呢？
- en: Should a reactive microservice be asynchronous?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式微服务应该是异步的吗？
- en: Very often, confusion is caused by asynchronous applications being called **reactive**,
    because their event loops wait for external events and don't waste server resources
    while they're waiting. Reactive microservices don't waste resources to keep incoming
    connection to return a result, because when a client connects to a reactive microservices
    for a short time, put the task and disconnects. After a client waits for asynchronous
    response from a microservice. Reactive microservices don't need to be asynchronous,
    but they can be.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的情况是，由于异步应用程序被错误地称为**反应式**，因为它们的事件循环等待外部事件，在等待时不会浪费服务器资源。反应式微服务不会为了保持传入连接以返回结果而浪费资源，因为当客户端短暂连接到反应式微服务时，它会提交任务并断开连接。在客户端等待微服务的异步响应后。反应式微服务不需要是异步的，但它们可以是。
- en: When you choose message passing for interaction, you have to take into account
    that microservices have to be asynchronous and can handle multiple messages simultaneously.
    Traditional synchronous code can't process as many messages as asynchronous code
    does, because synchronous code has to wait for I/O resources, but asynchronous
    code reacts to I/O events and utilizes as many resources as possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择消息传递进行交互时，你必须考虑到微服务必须是异步的，并且可以同时处理多个消息。传统的同步代码不能像异步代码那样处理那么多消息，因为同步代码必须等待I/O资源，而异步代码则对I/O事件做出反应，并尽可能利用资源。
- en: More simply, if your microservices have to process hundreds of thousands of
    messages, you should use asynchronous code. If your microservices do not have
    a heavy load, it's enough to use a modest synchronous algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单地说，如果你的微服务必须处理数十万条消息，你应该使用异步代码。如果你的微服务没有重负载，使用一个适度的同步算法就足够了。
- en: Reactive microservices with futures and streams
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于未来和流的反应式微服务
- en: If you have decided to implement a reactive microservice using asynchronous
    code, you can consider using a future crate as a basis. This crate provides you
    with types to construct reactive chains to process all messages asynchronously.
    But remember, it can be hard to write all `Future` instances manually. There is
    an upcoming feature in the Rust compiler that provides `async`/`await` operators,
    which simplifies the `Future` trait implementation by writing traditional functions
    with the `Result` return type. This feature is unstable and we won't consider
    it in this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经决定使用异步代码实现反应式微服务，你可以考虑使用未来库作为基础。这个库为你提供了构建反应式链的类型，以异步方式处理所有消息。但请记住，手动编写所有`Future`实例可能很困难。Rust编译器即将推出一个新功能，提供了`async`/`await`运算符，通过编写具有`Result`返回类型的传统函数来简化`Future`特质的实现。这个特性是不稳定的，我们不会在本书中考虑它。
- en: If you don't want to write low-level code, I recommend you use the `actix` crate.
    This is a really good framework that lets you write asynchronous code like synchronous
    code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想编写低级代码，我推荐你使用`actix`库。这是一个非常好的框架，让你可以像编写同步代码一样编写异步代码。
- en: If you need the lowest level of control, you can use the `mio` crate that's
    used as a base by the `futures` crate. It provides you with full control of I/O
    events, and you can squeeze the maximum speed from the resources of your server.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要最低级别的控制，你可以使用作为`futures`库基础的`mio`库。它为你提供了对I/O事件的完全控制，你可以从服务器的资源中榨取最大速度。
- en: Message brokers
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息代理
- en: Message brokers let you send all messages to a central point that routes and
    delivers messages to the necessary microservices. In some cases, this can be a
    bottleneck, because the full load will fall on a single application—the message
    broker. But in most cases, it's a great approach that helps you to decouple microservices
    and update any microservices imperceptibly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理让你可以将所有消息发送到中央点，该点路由和将消息传递到必要的微服务。在某些情况下，这可能会成为瓶颈，因为全部负载将落在单个应用程序——消息代理上。但在大多数情况下，这是一个很好的方法，可以帮助你解耦微服务，并几乎无感知地更新任何微服务。
- en: To use message brokers, it's sufficient to support the AMQP protocol. All popular
    message brokers are compatible with that protocol. The `lapin-futures` crate provides
    types and methods to use the AMQP protocol through the API of the `futures` crate.
    If you want to use the low-level control of the `mio` crate, there is the `lapin-async`
    crate.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用消息代理，只需要支持AMQP协议即可。所有流行的消息代理都与该协议兼容。`lapin-futures`库提供了类型和方法，通过`futures`库的API使用AMQP协议。如果你想要使用`mio`库的低级控制，可以使用`lapin-async`库。
- en: Remote procedure calls
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程过程调用
- en: If you want to connect microservices to each other directly, you can use RPCs
    to allow the functions of a service to be called remotely by another service.
    There are a lot of RPC frameworks with different formats and speed potential.
    Let's look at some popular protocols.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要直接连接微服务，你可以使用RPC来允许一个服务的功能被另一个服务远程调用。有许多RPC框架，它们具有不同的格式和速度潜力。让我们看看一些流行的协议。
- en: JSON-RPC
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-RPC
- en: 'The JSON-RPC protocol uses messages serialized to JSON format. It uses a special
    format for requests and responses, described here: [https://www.JSON-RPC.org/specification](https://www.jsonrpc.org/specification).
    The protocol can use different transports, such as, HTTP, Unix sockets, or even
    stdio. Later in this chapter, you will find an example of the usage of this protocol.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC协议使用序列化为JSON格式的消息。它使用一种特殊的请求和响应格式，这里进行了描述：[https://www.JSON-RPC.org/specification](https://www.jsonrpc.org/specification)。该协议可以使用不同的传输方式，例如HTTP、Unix套接字，甚至是stdio。在本章的后面，你会找到一个使用此协议的示例。
- en: gRPC
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC
- en: 'The gRPC protocol was created by Google and uses the Protocol Buffer serialization
    format for messages. Also, the protocol lies on benefits of the `HTTP/2` transport
    and allows you to achieve excellent performance. You can find more about the protocol
    here: [https://grpc.io/docs/](https://grpc.io/docs/). There is also an example
    of using this protocol later in this chapter.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC协议是由Google创建的，它使用Protocol Buffer序列化格式来处理消息。此外，该协议基于`HTTP/2`传输的优点，允许你实现卓越的性能。你可以在[https://grpc.io/docs/](https://grpc.io/docs/)找到更多关于该协议的信息。在本章的后面，你还会找到一个使用此协议的示例。
- en: Thrift
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thrift
- en: Apache Thrift is a binary communication protocol developed by Facebook. Despite
    the fact the protocol is binary, there are a lot of supported languages, such
    as C++, Go, and Java. Supported transports are file, memory, and socket.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Thrift是由Facebook开发的一种二进制通信协议。尽管该协议是二进制的，但它支持许多语言，如C++、Go和Java。支持的传输方式包括文件、内存和套接字。
- en: Other RPC frameworks
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他RPC框架
- en: There are other RPC protocols, such as Cap'n Proto, XML-RPC, and even vintage
    SOAP. Some have implementations for Rust, but I recommend considering choosing
    between JSON-RPC, gRPC, and Thrift, because they are the most commonly used for
    microservices.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他RPC协议，如Cap'n Proto、XML-RPC，甚至是古老的SOAP。有些为Rust提供了实现，但我建议在JSON-RPC、gRPC和Thrift之间进行选择，因为它们是最常用于微服务的。
- en: RPC and REST
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC和REST
- en: 'You may ask if it is possible to implement reactive microservices with a REST
    API or a traditional web API. Of course—yes! You can do it one of two ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，是否可以使用REST API或传统的Web API来实现反应式微服务。当然——可以！你可以有两种方式来做这件事：
- en: There are gateways that translate REST requests to JSON-RPC or other protocols.
    For example, gRPC has one ready to use: [https://github.com/grpc-ecosystem/grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway).
    You can even write your own gateway—it's not so hard for simple or specific cases.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有网关可以将REST请求转换为JSON-RPC或其他协议。例如，gRPC有一个现成的：[https://github.com/grpc-ecosystem/grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway)。你甚至可以编写自己的网关——对于简单或特定的情况来说并不难。
- en: You can use a Web API to send messages from one server to another. A microservice
    doesn't have to have a single API path, but you can add a special handler for
    messages in JSON or other formats. For transport, you can use not only HTTP, but
    also the WebSocket protocol.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Web API从一个服务器向另一个服务器发送消息。一个微服务不必只有一个API路径，但你可以为JSON或其他格式的消息添加一个特殊处理程序。对于传输，你不仅可以使用HTTP，还可以使用WebSocket协议。
- en: Reactive manifesto
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式宣言
- en: 'If you look at the reactive architecture as a standardized approach, you won''t
    find a guide or rules for how to turn your microservice reactive, but there is
    The Reactive Manifesto, which you can find here: [https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/).
    It contains a list of principles you can use to be inspired by ideas for the improvement
    of your application.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将反应式架构视为一种标准化方法，你不会找到一个指南或规则来指导如何让你的微服务变得反应式，但有一个《反应式宣言》，你可以在这里找到：[https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)。它包含了一系列原则，你可以使用这些原则来启发你改进应用程序的想法。
- en: Now we can create an example of a reactive microservice for the JSON-RPC procotol.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个针对JSON-RPC协议的反应式微服务的示例。
- en: Understanding JSON-RPC
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JSON-RPC
- en: There are some crates that provide functionality to support the JSON-RPC protocol.
    Mostly, crates support only the server or the client side, not both. Some crates
    don't support asynchronous computations either.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些crate提供了支持JSON-RPC协议的功能。大多数情况下，crate只支持服务器或客户端的一侧，而不是两者都支持。有些crate甚至不支持异步计算。
- en: How JSON-RPC works
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-RPC的工作原理
- en: 'The JSON-RPC protocol uses JSON messages in the following format for a request:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC协议使用以下格式的JSON消息来请求：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding JSON message calls the `substring` remote method of a server
    that can return a result like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的JSON消息调用了一个可以返回如下结果的服务器的`substring`远程方法：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's worth nothing that a client determines the identifier of the request and
    has to track those values. Servers are ID-agnostic and they use a connection to
    track requests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，客户端确定请求的标识符并必须跟踪这些值。服务器对ID不敏感，它们使用连接来跟踪请求。
- en: There are two versions of the protocol—1.0 and 2.0\. They are similar, but in
    the second version there is a separation of the client and the server. Also, it
    is transport independent, because the first version uses connection events to
    determine behavior. There are improvements for errors and parameters as well.
    You should use version 2.0 for new projects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议有两个版本——1.0和2.0。它们很相似，但在第二个版本中，客户端和服务器是分离的。此外，它是传输无关的，因为第一个版本使用连接事件来确定行为。错误和参数也有改进。你应该为新项目使用版本2.0。
- en: To support JSON-RPC, your server has to respond to these kind of JSON requests.
    The protocol is really simple to implement, but we will use the `jsonrpc-http-server`
    crate, which uses HTTP transport and provides types to bootstrap a server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持JSON-RPC，你的服务器必须响应这类JSON请求。该协议实现起来非常简单，但我们将使用`jsonrpc-http-server` crate，它使用HTTP传输并提供启动服务器所需的类型。
- en: Creating a microservice
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建微服务
- en: In this section, we will create an example of a microservice that supports the
    JSON-RPC protocol and has two methods. The microservice will support working as
    a part of a ring of microservices. We will send a message to one microservice,
    which will send a message to the next microservice in the ring, and that microservice
    will send the message further.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个支持JSON-RPC协议并具有两个方法的微服务示例。该微服务将支持作为微服务环的一部分工作。我们将向一个微服务发送消息，该微服务将向环形中的下一个微服务发送消息，然后该微服务将消息进一步传递。
- en: We will create a ring example, because if it is implemented incorrectly your
    microservice will be blocked, because they can't process requests in parallel
    like reactive services have to do.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个环形示例，因为如果实现不正确，你的微服务将被阻塞，因为它们不能像反应式服务那样并行处理请求。
- en: Dependencies
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'First, we need to import the necessary dependencies:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入必要的依赖项：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most likely, you are familiar with most crates except `jsonrpc` and `json-rpc-server`.
    The first is a JSON-RPC client that's based on the `hyper` crate. The second also
    uses the `hyper` crate and provides server functionality of JSON-RPC.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你对大多数crate都很熟悉，除了`jsonrpc`和`json-rpc-server`。第一个是基于`hyper` crate的JSON-RPC客户端。第二个也使用了`hyper`
    crate，并提供了JSON-RPC的服务器功能。
- en: 'Let''s import the necessary types and talk a little about them:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入必要的类型，并简要介绍一下它们：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The JSON-RPC crate has the `Client` type that we will use to call the remote
    methods of other services. We also imported `Error` from that crate as `ClientError`
    to avoid a name conflict with `Error` from the failure crate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC crate有一个`Client`类型，我们将使用它来调用其他服务的远程方法。我们还从该crate中导入`Error`作为`ClientError`以避免与来自`failure`
    crate的`Error`名称冲突。
- en: For the server side, we will use `ServerBuilder` from the `jsonrpc-http-server`
    crate. Also, we need `Error` to be renamed to `ServerError` from that crate. To
    implement function handlers, we need to import `IoHandler`, which can be used
    to attach functions as RPC methods. Also, we need a `Value` (actually, this type
    is reimported from the `serde_json` crate), which is used as a result type for
    RPC methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器端，我们将使用`jsonrpc-http-server` crate中的`ServerBuilder`。此外，我们需要将`Error`从该crate重命名为`ServerError`。为了实现函数处理器，我们需要导入`IoHandler`，它可以用来将函数附加为RPC方法。此外，我们还需要一个`Value`（实际上，这个类型是从`serde_json`
    crate重新导入的），它用作RPC方法的返回类型。
- en: 'To avoid mistakes in method names, because we will use them twice for the server
    implementation and then in a client, we declare names as string constants:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免方法名称的错误，因为我们将在服务器实现中使用它们两次，然后在客户端中再次使用，我们将名称声明为字符串常量：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first method will start sending messages from one microservice to the next.
    The second method is used to stop this roll-calling process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法将从微服务开始发送消息到下一个微服务。第二个方法用于停止这个点名过程。
- en: Client
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: 'To interact with other microservice instances and to call their remote methods,
    we will create a separate struct, because it''s more convenient than using the
    JSON-RPC `Cilent` directly. But in any case, we use this type internally in our
    struct:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与其他微服务实例交互并调用它们的远程方法，我们将创建一个单独的结构体，因为它比直接使用JSON-RPC的`Client`更方便。但在任何情况下，我们都在我们的结构体内部使用此类型：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will use the `Remote` struct to make calls to remote services. To create
    the struct, we will use the following constructor:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Remote`结构体来调用远程服务。为了创建这个结构体，我们将使用以下构造函数：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Client` struct expects the `String` URL as a parameter, but we will use `SocketAddr`
    to create a URL.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client`结构体期望一个`String` URL作为参数，但我们将使用`SocketAddr`来创建URL。'
- en: 'Also, we need a generic function that will use the `Client` instance to call
    remote methods. Add the `call_method` method to the implementation of the `Remote`
    struct:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要一个泛型函数，它将使用`Client`实例来调用远程方法。向`Remote`结构体的实现中添加`call_method`方法：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The calling of the JSON-RPC method using the JSON-RPC crate is simple. Use the `build_request`
    method of the `Client` instance to create a `Request` and send it using the `send_request`
    method of the same `Client`. There is a method called `do_rpc` that does this
    in a single call. We will use a more verbose approach to show that you can predefine
    requests and use them to speed up the preparation for calling. Also, it's more
    pleasant to use business-oriented struct methods instead of a raw `Client`. We
    isolate an implementation using a wrapper that hides the details of RPC calls.
    What if you decide to change to another protocol, such as gRPC?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON-RPC crate调用JSON-RPC方法很简单。使用`Client`实例的`build_request`方法创建一个`Request`，然后使用同一`Client`的`send_request`方法发送它。有一个名为`do_rpc`的方法可以在单个调用中完成这个操作。我们将使用更详细的方法来展示你可以预先定义请求并使用它们来加速调用准备。此外，使用面向业务的struct方法而不是原始的`Client`更令人愉快。我们使用包装器隔离实现，以隐藏RPC调用的细节。如果你决定改为其他协议，比如gRPC，会怎样呢？
- en: 'Add special methods to the `Remote` struct implementation to make calls using
    the `call_method` method. First, we need the `start_roll_call` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Remote`结构体的实现中添加特殊方法，使用`call_method`方法进行调用。首先，我们需要`start_roll_call`函数：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It won't pass any parameters with a call, but it expects the `bool` type of
    the result. We used a constant for the remote method's name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 调用时不会传递任何参数，但它期望结果是`bool`类型。我们使用一个常量作为远程方法的名字。
- en: 'Add the `mark_itself` method to the `Remote` struct:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Remote`结构体添加`mark_itself`方法：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It doesn't send any parameters either and returns the `bool` value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它也不发送任何参数，并返回`bool`值。
- en: Now we can add a worker to separate outgoing method calls from incoming calls.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个工作者来将传入调用与传出调用分开。
- en: Worker
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作者
- en: 'Since we have two methods, we will add a struct to perform remote calls of
    these methods from a worker thread. Add the `Action` enumeration to the code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两种方法，我们将添加一个结构体以从工作线程执行这些方法的远程调用。向代码中添加`Action`枚举：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It has two variants: `StartRollCall` to perform the remote `start_roll_call`
    method call, and the `MarkItself` variant to call the remote `mark_itself` method.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个变体：`StartRollCall`用于执行远程`start_roll_call`方法调用，以及`MarkItself`变体用于调用远程`mark_itself`方法。
- en: Now we can add a function to spawn a worker in a separate thread. If we will
    perform outgoing calls immediately in incoming method handlers, we can block the
    execution, because we have a ring of microservices and blocking one microservice
    will block the whole ring's interaction.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个函数在单独的线程中创建一个工作者。如果我们将在传入方法处理程序中立即执行传出调用，我们可以阻塞执行，因为我们有一个微服务环，阻塞一个微服务将阻塞整个环的交互。
- en: No blocking is an important property of a reactive microservice. The microservices
    have to process all calls in parallel or asynchronously, but never block execution
    for a long time. They should work like actors in the actors model we have discussed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无阻塞是反应式微服务的一个重要属性。微服务必须并行或异步处理所有调用，但永远不应该长时间阻塞执行。它们应该像我们在讨论的演员模型中的演员一样工作。
- en: 'Look at the `spawn_worker` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`spawn_worker`函数：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function creates a channel and spawns a new thread with a routine that
    processes all received messages from a channel. We create the `Remote` instance
    with the address extracted from the `NEXT` environment variable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建一个通道并使用从 `NEXT` 环境变量中提取的地址启动一个新的线程，该线程使用一个例程处理从通道接收到的所有消息。我们使用从 `NEXT`
    环境变量中提取的地址创建 `Remote` 实例。
- en: There is a flag that shows that the `start_roll_call` method has been called.
    We set it to `true` when the `StartRollCall` message is received and the `start_roll_call`
    method of the remote server is called. If the flag is already set to `true` and
    the routine received the `StartRollCall` message, the thread will call the `mark_itself`
    remote method. In other words, we will call the `start_roll_call` methods of all
    running service instances. When all services set the flag to `true`, we will call
    the `mark_itself` methods of all services.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个标志表示已调用 `start_roll_call` 方法。当接收到 `StartRollCall` 消息并调用远程服务器的 `start_roll_call`
    方法时，我们将它设置为 `true`。如果标志已经设置为 `true`，并且常规收到 `StartRollCall` 消息，则线程将调用 `mark_itself`
    远程方法。换句话说，我们将调用所有运行服务实例的 `start_roll_call` 方法。当所有服务都将标志设置为 `true` 时，我们将调用所有服务的
    `mark_itself` 方法。
- en: Let's start a server and run a ring of services.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个服务器并运行一个服务环。
- en: Server
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: 'The `main` function activates a logger and spawns a worker. Then, we extract
    the `ADDRESS` environment variable to use this address value to bind a socket
    of a server. Loot at the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数激活一个记录器并启动一个工作进程。然后，我们提取 `ADDRESS` 环境变量以使用此地址值来绑定服务器的套接字。看看以下代码：'
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To implement JSON-RPC methods, we use the `IoHandler` struct. It has the `add_method`
    method, which expects the name of the method and needs a closure with an implementation
    of this method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 JSON-RPC 方法，我们使用 `IoHandler` 结构体。它有一个 `add_method` 方法，该方法期望方法名称，并需要一个包含此方法实现的闭包。
- en: 'We added two methods, `start_roll_call` and `mark_itself`, using constants
    as names for these methods. The implementation of these methods is simple: we
    only prepare the corresponding `Action` messages and send them to the worker''s
    thread.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个方法，`start_roll_call` 和 `mark_itself`，使用常量作为这些方法的名称。这些方法的实现很简单：我们只准备相应的
    `Action` 消息并将它们发送到工作线程。
- en: 'The JSON-RPC method implementation has to return the `Result<Value, ServerError>`
    value. To convert any other errors to `ServerError` we use the following function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC 方法实现必须返回 `Result<Value, ServerError>` 值。要将任何其他错误转换为 `ServerError`，我们使用以下函数：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function only prints the current error message and creates an error with
    the `InternalError` code using the `internal_error` method of the `ServerError`
    type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅打印当前错误消息，并使用 `ServerError` 类型的 `internal_error` 方法创建一个带有 `InternalError`
    代码的错误。
- en: At the end of main function, we create a new `ServerBuilder` instance with the
    created `IoHandler` and start the HTTP server to listen for JSON-RPC requests
    with the `start_http` server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数的末尾，我们使用创建的 `IoHandler` 创建一个新的 `ServerBuilder` 实例，并启动 HTTP 服务器以监听带有 `start_http`
    服务器的 JSON-RPC 请求。
- en: Now we can start a ring of services to test it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动一个服务环来测试它。
- en: Compiling and running
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行
- en: 'Compile this example with the `cargo build` subcommand, and let''s start three
    instances of the service using the following commands (run every command in a
    separate terminal window to see the logs):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cargo build` 子命令编译此示例，并使用以下命令启动三个服务实例（在每个单独的终端窗口中运行每个命令以查看日志）：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the three services are started, prepare and send a JSON-RPC call request
    with `curl` from another terminal window:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当三个服务启动时，从另一个终端窗口使用 `curl` 准备并发送一个 JSON-RPC 调用请求：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this command, we start the interaction of all services, and they will
    call each other in a ring. You will see the logs of every service. The first prints
    something like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们启动所有服务的交互，它们将在环中相互调用。您将看到每个服务的日志。第一个将打印如下内容：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second will print something like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个将打印如下内容：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And the third will output the following logs:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个将输出以下日志：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All services works as independent participants of the process, react to incoming
    messages, and send messages to other services when there is something to send.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务作为过程的独立参与者工作，对传入的消息做出反应，并在有消息要发送时向其他服务发送消息。
- en: Learning about gRPC
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 gRPC
- en: In this section, we will rewrite the JSON-RPC ring example to gRPC. This protocol
    differs from JSON-RPC because it requires a protocol declaration—a predefined
    interaction schema. This restriction is good for large projects, because you can't
    make a mistake in a message's layout, but with Rust, JSON-RPC is also reliable
    because you have to declare all structs exactly and you will get an error if you
    take an incorrect JSON message. With gRPC, you don't have to care about it at
    all.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把 JSON-RPC 环形示例重写为 gRPC。这个协议与 JSON-RPC 不同，因为它需要一个协议声明——预定义的交互模式。这种限制对大型项目来说是有益的，因为你不能在消息布局中犯错误，但使用
    Rust，JSON-RPC 也是可靠的，因为你必须精确地声明所有结构体，如果你接收到一个不正确的 JSON 消息，你会得到一个错误。使用 gRPC，你根本不必关心这一点。
- en: How gRPC works
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC 的工作原理
- en: The benefit of gRPC in comparison with JSON-RPC is speed. gRPC can work faster,
    because it uses a fast serialization format—Protocol Buffers. Both gRPC and Protocol
    Buffers were originally developed by Google and are proven in high-performance
    cases.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JSON-RPC 相比，gRPC 的优点在于速度。gRPC 可以更快地工作，因为它使用了一种快速的序列化格式——Protocol Buffers。gRPC
    和 Protocol Buffers 都最初由 Google 开发，并在高性能案例中得到了验证。
- en: 'gRPC uses `HTTP/2` for transport. It''s a really fast and good transport protocol.
    First, it''s binary: all requests and responses are squeezed into a compact portion
    of bytes and compressed. It''s multiplexed: you can send a lot of requests simultaneously,
    but `HTTP/1` demands respect for the order of requests.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用 `HTTP/2` 进行传输。它是一个非常快且优秀的传输协议。首先，它是二进制的：所有请求和响应都被压缩成一个紧凑的字节部分并压缩。它是多路复用的：你可以同时发送很多请求，但
    `HTTP/1` 要求请求的顺序。
- en: gRPC needs a scheme and uses Protocol Buffers as the **Interface Definition
    Language** (**IDL**). Before you start writing an implementation of a service,
    you have to write the `proto` file that contains a declaration of all types and
    services. After that, you need to compile the declaration to sources (in the Rust
    programming language in our case) and use them to write the implementation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 需要一个方案，并使用 Protocol Buffers 作为 **接口定义语言**（**IDL**）。在开始编写服务的实现之前，你必须编写包含所有类型和服务的声明的
    `proto` 文件。之后，你需要将声明编译成源代码（在我们的案例中是 Rust 编程语言），并使用它们来编写实现。
- en: 'The `protobuf` crate and the common gRPC crates use that crate as a basis.
    Actually, there are not many crates; just two: the `grpcio` crate, which is a
    wrapper over the original gRPC core library, and the `grpc` crate, which is the
    pure Rust implementation of the protocol.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`protobuf` crate 和常见的 gRPC crate 以该 crate 为基础。实际上，crate 并不多；只有两个：`grpcio` crate，它是对原始
    gRPC 核心库的包装，以及 `grpc` crate，它是协议的纯 Rust 实现。'
- en: Now we can rewrite the previous example from JSON-RPC protocol to gRPC. At first,
    we have to add all the necessary dependencies and write a declaration of our service.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将之前的示例从 JSON-RPC 协议重写为 gRPC。首先，我们必须添加所有必要的依赖项并编写我们服务的声明。
- en: Creating a microservice
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建微服务
- en: The gRPC example is very complex, because we have to declare an interaction
    protocol. We also have to add the `build.rs` file to generate Rust sources from
    a protocol description.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 示例非常复杂，因为我们必须声明一个交互协议。我们还需要添加 `build.rs` 文件，从协议描述生成 Rust 源代码。
- en: Since it's hard to make a gRPC call from curl, we will also add a client that
    helps us to test services. You can also use other tools that are available for
    debugging gRPC applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从 curl 调用 gRPC 很困难，我们还将添加一个客户端，帮助我们测试服务。你也可以使用其他可用于调试 gRPC 应用程序的工具。
- en: Dependencies
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'Create a new `binary` crate and open `Cargo.toml` in an editor. We will explore
    every section of this file, because building a gRPC example is more complex than
    services that use flexible interaction protocols such as JSON-RPC. We''ll use
    Edition 2018, as we do for most examples in this book:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `binary` crate 并在编辑器中打开 `Cargo.toml` 文件。我们将探索这个文件的每一个部分，因为构建 gRPC 示例比使用灵活交互协议（如
    JSON-RPC）的服务更复杂。我们将使用 Edition 2018，正如我们在本书中的大多数示例中所做的那样：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In dependencies, we need a basic set of crates—`failure`, `log`, and `env_logger`.
    Also, we add the `protobuf` crate. We won''t use it directly, but it''s used by
    generated Rust sources that we will get from a protocol description later in this
    section. The most important crate from the current example is grpc. We will use
    a version from GitHub, because the crate is in active development:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖项中，我们需要一组基本的 crate——`failure`、`log` 和 `env_logger`。此外，我们添加了 `protobuf` crate。我们不会直接使用它，但它在稍后本节中从协议描述生成的
    Rust 源代码中会被使用。当前示例中最重要的 crate 是 grpc。我们将使用 GitHub 上的版本，因为该 crate 正在积极开发中：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Actually, the GitHub repository of the `grpc` crate is a workspace and also
    contains the `protoc-rust-grpc` crate, which we will use to generate a protocol
    declaration in Rust using the `build.rs` file. Add this dependency to the `[build-dependencies]`
    section of `Cargo.toml`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`grpc` crate 的 GitHub 仓库是一个工作区，并且还包含 `protoc-rust-grpc` crate，我们将使用它通过 `build.rs`
    文件在 Rust 中生成协议声明。将此依赖项添加到 `Cargo.toml` 的 `[build-dependencies]` 部分：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `example` crate we create will produce two binary files—server and client.
    As I said, we need a client, because it's simpler than preparing calls manually,
    and use curl to call gRPC methods.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 `example` crate 将生成两个二进制文件——服务器和客户端。正如我所说的，我们需要一个客户端，因为它比手动准备调用更简单，并且使用
    curl 调用 gRPC 方法。
- en: 'The first binary is a server built from the `src/server.rs` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个二进制文件是由 `src/server.rs` 文件构建的服务器：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second binary uses the `src/client.rs` file to build a client:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个二进制文件使用 `src/client.rs` 文件构建客户端：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We also have `src/lib.rs` for common parts, but we have to describe a protocol
    and create the `build.rs` file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有 `src/lib.rs` 用于通用部分，但我们必须描述一个协议并创建 `build.rs` 文件。
- en: Protocol
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议
- en: 'gRPC uses a special language for protocol declarations.There are two versions
    of the language—`proto2` and `proto3`. We will use the second as it''s more modern.
    Create a `ring.proto` file and add the following declaration:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用一种特殊的语言进行协议声明。该语言有两种版本——`proto2` 和 `proto3`。我们将使用第二种，因为它更现代。创建一个 `ring.proto`
    文件并添加以下声明：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, we specified the syntax as `proto3`. Options give you the ability
    to set the properties for the generation of source files for different languages
    if you will interact with a service from other applications or other microservices.
    We don't need to set these options for our example, but you might have this part
    in a file if you take it from another developer.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们指定了 `proto3` 语法。选项为您提供了设置不同语言源文件生成属性的能力，如果您将与其他应用程序或其他微服务交互服务，您可能需要设置这些选项。对于我们的示例，我们不需要设置这些选项，但如果您从其他开发者那里获取它，您可能需要在文件中包含这部分。
- en: The protocol declaration contains a package name set with the `package` specifier
    and a package name that we set to `ringproto`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 协议声明包含一个使用 `package` 修饰符设置的包名和我们将它设置为 `ringproto` 的包名。
- en: Also, we added the `Empty` message with no fields. We will use this type as
    the input and output parameter for all methods, but it's better to use different
    types for real microservices. Firstly, you can't have methods without input and
    output parameters. The second reason is future service improvements. If you want
    to add extra fields to the protocol later, you can do it. Moreover, the protocol
    can easily cope with different versions of the protocol; often you can use both
    new and old microservices, because Protocol Buffers work fine with extra fields,
    and you can extend the protocol later when you need it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还添加了一个没有字段的 `Empty` 消息。我们将使用此类型作为所有方法的输入和输出参数，但对于实际的微服务来说，使用不同的类型会更好。首先，您不能没有输入和输出参数的方法。第二个原因是未来的服务改进。如果您想在以后添加额外的字段到协议中，您可以这样做。此外，协议可以轻松地处理协议的不同版本；通常，您可以同时使用新旧微服务，因为
    Protocol Buffers 与额外字段配合良好，并且您可以在需要时扩展协议。
- en: The service declaration is contained in the `service` section. You can have
    multiple services' declarations in a protocol declaration file and use only the
    necessary declared services in an implementation. But we need only one service
    declaration for our ring example. Add the `Ring` service and include two RPC methods
    with the `rpc` specifier. We added the `StartRollCall` method and `MakeItself`.
    The same as we did in the previous example. Both take the `Empty` value as an
    input argument and return `Empty` as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 服务声明包含在 `service` 部分。您可以在协议声明文件中拥有多个服务的声明，并在实现中仅使用必要的声明服务。但我们的环形示例只需要一个服务声明。添加
    `Ring` 服务并包含两个带有 `rpc` 修饰符的 RPC 方法。我们添加了 `StartRollCall` 方法和 `MakeItself`。与上一个示例相同。两者都接受
    `Empty` 值作为输入参数，并返回 `Empty`。
- en: The name of a service is important, because it will be used as a prefix for
    multiple types in generated Rust sources. You can create sources using the `protoc`
    tool, but it's more convenient to create a build script that will generate sources
    with protocol types during compilation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 服务名称很重要，因为它将被用作生成 Rust 源代码中多个类型的名称前缀。您可以使用 `protoc` 工具创建源代码，但创建一个在编译期间生成带有协议类型的源代码的构建脚本会更方便。
- en: Generating interfaces
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成接口
- en: Rust build scripts let you implement a function that will do some additional
    preparation for project compilation. In our case, we have the `ring.proto` file
    with a protocol definition and we want to convert it to Rust sources using the `protoc-rust-grpc`
    crate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Rust构建脚本允许你实现一个函数，该函数将为项目编译做一些额外的准备。在我们的例子中，我们有一个`ring.proto`文件，其中包含协议定义，我们希望使用`protoc-rust-grpc`包将其转换为Rust源代码。
- en: 'Create the `build.rs` file in the project and add the following content:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中创建`build.rs`文件并添加以下内容：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Build scripts use the `main` function as an entry point, in which you can implement
    any activities you want. We used the run function of the `protoc-rust-grpc` crate
    with `Args`—we set the output directory in the `out_dir` field, set the `ring.proto`
    file as input declaration with the `input` field, activate the `rust_protobuf` Boolean
    flag to generate sources for the `rust**-**protobuf` crate (you don't need it
    if you are already using the `protobuf` crate and generating types with it), then
    set the `includes` field to an empty array.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 构建脚本使用`main`函数作为入口点，在其中你可以实现任何想要的活动。我们使用了`protoc-rust-grpc`包的run函数与`Args`——我们在`out_dir`字段中设置了输出目录，将`ring.proto`文件作为输入声明设置在`input`字段中，激活了`rust_protobuf`布尔标志以生成`rust**-**protobuf`包的源代码（如果你已经使用`protobuf`包并使用它生成类型，则不需要它），然后设置`includes`字段为一个空数组。
- en: 'Then, when you run `cargo build`, it will produce two modules in the `src`
    folder: `ring.rs` and `ring_grpc.rs`. I don''t put its sources here, because generated
    files are large, but we will use it to create a wrapper for a gRPC client, as
    we did in the previous example.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你运行`cargo build`时，它将在`src`文件夹中生成两个模块：`ring.rs`和`ring_grpc.rs`。我不会在这里放置其源代码，因为生成的文件很大，但我们将使用它来创建一个gRPC客户端的包装器，就像我们在前面的例子中所做的那样。
- en: Shared client
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享客户端
- en: 'Open the `lib.rs` source file and add two generated modules:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`lib.rs`源文件并添加两个生成的模块：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Import some types we need to create a wrapper for a gRPC client:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 导入我们需要创建gRPC客户端包装器的类型：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the generated modules contain types we declared in the `ring.proto`
    file. The `ring` module contains the `Empty` struct, and the `ring_grpc` module
    contains the `Ring` trait, which represents an interface of a remote service.
    Also, `protoc_rust_grpc` in the build script generated the `RingClient` type.
    This type is a client that can be used to call remote methods. We wrap it with
    our own struct, because `RingClient` generates `Future` instances and we will
    use the `Remote` wrapper to perform them and get the result.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，生成的模块包含我们在`ring.proto`文件中声明的类型。`ring`模块包含`Empty`结构体，而`ring_grpc`模块包含`Ring`特质，它表示远程服务的接口。此外，`protoc_rust_grpc`在生成的构建脚本中创建了`RingClient`类型。此类型是一个可以用来调用远程方法的客户端。我们用我们自己的结构体包装它，因为`RingClient`生成`Future`实例，我们将使用`Remote`包装器来执行它们并获取结果。
- en: We also use types from the `grpc` crate. The `Error` type is imported as `GrpcError`;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用来自`grpc`包的类型。`Error`类型被导入为`GrpcError`；
- en: '`RequestOptions`, which is necessary to prepare method call requests; `ClientConf`,
    which is used to add extra configuration parameters for the `HTTP/2` connection
    (we will use the default values); and `ClientStubExt`, which provides connection
    methods for clients.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestOptions`，它是准备方法调用请求所必需的；`ClientConf`，用于为`HTTP/2`连接添加额外的配置参数（我们将使用默认值）；以及`ClientStubExt`，它为客户端提供连接方法。'
- en: 'Add the `Remote` struct holding the `RingClient` instance inside:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部添加持有`RingClient`实例的`Remote`结构体：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We use this struct for both client and server. Add a new method to construct
    new instances of `Remote` from the provided `SocketAddr`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个结构体来创建客户端和服务器。添加一个新的方法从提供的`SocketAddr`构建新的`Remote`实例：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since generated clients expect separate host and port values, we extract them
    from the `SocketAddr` value. Also, we create the default `ClientConf` configuration
    and use all these values to create the `RingClient` instance to put it to the
    new `Remote` instance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成的客户端期望有单独的主机和端口值，我们从`SocketAddr`值中提取它们。此外，我们创建默认的`ClientConf`配置，并使用所有这些值来创建`RingClient`实例，并将其放入新的`Remote`实例中。
- en: 'We create the `Remote` struct to have simple methods to call remote methods.
    Add the `start_roll_call` method to the `Remote` implementation to call the `StartRollCall`
    gRPC method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`Remote`结构体以拥有调用远程方法的基本方法。向`Remote`实现中添加`start_roll_call`方法以调用`StartRollCall`
    gRPC方法：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`RingClient` already has this method, but it expects parameters that we want
    to hide, and returns a `Future` instance that we want to perform immediately using
    the wait method call. The `Future` returns a tuple with three items, but we need
    only one value, because other values contain metadata that we don''t need.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`RingClient`已经具有此方法，但它期望我们想要隐藏的参数，并返回一个我们想要立即使用`wait`方法调用的`Future`实例。`Future`返回一个包含三个项目的元组，但我们只需要一个值，因为其他值包含我们不需要的元数据。'
- en: 'Implement the `mark_itself` method in a similar way to call the `MarkItself`
    gRPC method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式实现`mark_itself`方法来调用`MarkItself` gRPC方法：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we can implement a client and a server, because both need the `Remote` struct
    to perform RPC calls.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现客户端和服务器，因为两者都需要`Remote`结构体来执行RPC调用。
- en: Client
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: 'Add the `src/client.rs` file and import a few types:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`src/client.rs`文件并导入一些类型：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We need a generic `Error` from the `failure` crate, because it's a universal
    type for most error handling cases, and import the `Remote` struct we created
    before.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`failure` crate中获取一个通用的`Error`类型，因为它是最常用的错误处理类型，并且导入我们之前创建的`Remote`结构体。
- en: 'The client is an extremely simple tool. It calls the `StartRollCall` remote
    gRPC method of a service with the address provided in the `NEXT` environment variable:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端是一个非常简单的工具。它使用在`NEXT`环境变量中提供的地址调用服务的`StartRollCall`远程gRPC方法：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Create the `Remote` instance with the parsed `SocketAddr` value and perform
    a call. This is it. The server is very complex. Let's implement it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解析的`SocketAddr`值创建`Remote`实例并执行调用。就是这样。服务器非常复杂。让我们来实现它。
- en: Server implementation
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器实现
- en: 'Add the `src/server.rs` source file and add generated modules to it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`src/server.rs`源文件并将其添加到其中：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We need these modules because we will implement the `Ring` trait for our RPC
    handler. Look at the types we will use:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些模块，因为我们将为我们的RPC处理程序实现`Ring`特质。看看我们将使用的类型：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The types you are not familiar with yet are `ServerBuilder`, which is used to
    create a server instance and fill it with service implementations, and `SingleResponse`
    is the result of handler calls. The other types you already know.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还不熟悉的一些类型是`ServerBuilder`，它用于创建服务器实例并填充服务实现，以及`SingleResponse`是处理程序调用的结果。其他类型你已经知道了。
- en: Service implementation
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现
- en: 'We need our own type that will implement the `Ring` trait to implement RPC
    interface of a service. But we also have to keep a `Sender` for a worker to send
    actions to it. Add the `RingImpl` struct with a `Sender` of `Action` wrapped with
    `Mutex`, because the `Ring` trait requires the `Sync` trait implementation as
    well:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个自己的类型来实现`Ring`特质以实现服务的RPC接口。但我们还必须保留一个`Sender`以供工作进程发送动作。添加带有`Action`的`Sender`和`Mutex`包装的`RingImpl`结构体，因为`Ring`特质还要求实现`Sync`特质：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will construct an instance from the `Sender` instance:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`Sender`实例构建一个实例：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For every incoming method call, we need to send `Action` to a worker and we
    can add a method to the `RingImpl` implementation to reuse it in all handlers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个传入的方法调用，我们需要向工作进程发送`Action`，我们可以在`RingImpl`实现中添加一个方法来在所有处理程序中重用它：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `send_action` function takes the `Action` value and locks a `Mutex` to use
    a `Sender`. At the end, it creates an `Empty` value and returns it as a `SingleResponse`
    instance. If you have noticed, we used the `try_or_response!` macro that we defined,
    because `SingleResponse` is a `Future` instance and we have to return this type
    in any success or failure cases.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_action`函数接收一个`Action`值，并锁定一个`Mutex`来使用`Sender`。最后，它创建一个`Empty`值并将其作为`SingleResponse`实例返回。如果你注意到了，我们使用了我们定义的`try_or_response!`宏，因为`SingleResponse`是一个`Future`实例，我们必须在任何成功或失败的情况下返回此类型。'
- en: 'This macro works like the `try!` macro of the standard library. It uses match
    to extract a value or return a result if there is an error value:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏类似于标准库中的`try!`宏。它使用match来提取值或在没有错误值的情况下返回结果：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding macro creates the `SingleResponse` instance with the `Panic` variant
    of `GrpcError`, but uses a description of an error from the existing error value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的宏使用`GrpcError`的`Panic`变体创建`SingleResponse`实例，但使用现有错误值的错误描述。
- en: Handlers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理程序
- en: 'Now we can implement gRPC methods of the `Ring` service we declared in the `ring.proto`
    file before. We have the `Ring` trait with the same names of the methods. Every
    method expects the `Empty` value and has to return this type, because we defined
    this in the declaration. Also, every method has to return the `SingleResponse`
    type as a result. We already defined the `send_action` method that sends the `Action`
    value to a worker and returns the `SingleResponse` response with the `Empty` value.
    Let''s use the `send_action` method for both methods we have to implement:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现我们在`ring.proto`文件中声明的`Ring`服务的gRPC方法。我们有与方法相同名称的`Ring`特质。每个方法都期望一个`Empty`值并必须返回此类型，因为我们已经在声明中定义了它。此外，每个方法都必须返回作为结果的`SingleResponse`类型。我们已经定义了发送`Action`值到工作线程并返回带有`Empty`值的`SingleResponse`响应的`send_action`方法。让我们使用`send_action`方法来实现我们必须要实现的方法：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have a pretty simple implementation of gRPC methods handlers, but you can
    also add more sensible implementations and produce `SingleResponse` from a Future
    asynchronously.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对gRPC方法处理器的实现相当简单，但你也可以添加更合理的实现，并从Future异步地生成`SingleResponse`。
- en: The main function
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'Everything is ready for the implementation of the `main` function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都为`main`函数的实现准备好了：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We initialized a logger and created a channel that we will use to send actions
    from `RingImpl` to a worker. We extracted `SocketAddr` from the `ADDRESS` environment
    variable and used this value to bind a server to the provided address.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了一个日志记录器，并创建了一个通道，我们将使用它从`RingImpl`向工作线程发送动作。我们从`ADDRESS`环境变量中提取了`SocketAddr`，并使用这个值将服务器绑定到提供的地址。
- en: We created a `ServerBuilder` instance with the `new_plain` method. It creates
    a server without TLS, since gRPC supports secure connections and we have to provide
    a type parameter for `ServerBuilder` that implements the `TlcAcceptor` trait.
    But with `new_plain` we use the `TlasAcceptor` stub from the `tls_api_stub` crate.
    The `ServerBuilder` struct contains the `http` field of the `httpbis::ServerBuilder`
    type. We can use this file to set the address to which to bind the server's socket.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`new_plain`方法创建了一个`ServerBuilder`实例。它创建了一个没有TLS的服务器，因为gRPC支持安全连接，我们必须为`ServerBuilder`提供一个实现`TlcAcceptor`特质的类型参数。但是使用`new_plain`，我们使用来自`tls_api_stub`包的`TlasAcceptor`存根。`ServerBuilder`结构体包含了`httpbis::ServerBuilder`类型的`http`字段。我们可以使用这个文件来设置服务器套接字的绑定地址。
- en: After, we create the `RingImpl` instance and use the `add_service` method of
    `ServiceBuilder` to attach a service implementation, but we have to provide the
    generic `grpc::rt::ServerServiceDefinition` definition of the service and we use
    `new_service_def` of the `RingServer` type to create it for the `RingImpl` instance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了`RingImpl`实例，并使用`ServiceBuilder`的`add_service`方法附加一个服务实现，但我们必须提供服务的泛型`grpc::rt::ServerServiceDefinition`定义，并使用`RingServer`类型的`new_service_def`来为`RingImpl`实例创建它。
- en: At the end, we set the quantity of threads in the pool that will be used to
    handle incoming requests and call the `build` method of `ServiceBuilder` to start
    a server. But wait—if you leave the `build` call method, the main thread will
    be terminated and you will have to add a loop or other routine to keep the main
    thread alive.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置处理传入请求的线程池中线程的数量，并调用`ServiceBuilder`的`build`方法来启动服务器。但是等等——如果你不调用`build`方法，主线程将被终止，你必须添加一个循环或其他例程来保持主线程活跃。
- en: Luckily, we need a worker and we can use the main thread to run it. If you only
    need to run the gRPC server, you can use a `loop` with the `thread::park` method
    call, which will block the thread till it is unblocked by the `unpark` method
    call. This approach is used internally by asynchronous runtimes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们需要一个工作线程，我们可以使用主线程来运行它。如果你只需要运行gRPC服务器，你可以使用一个带有`thread::park`方法调用的`loop`，这将阻塞线程，直到它被`unpark`方法调用解除阻塞。这种方法被异步运行时内部使用。
- en: We will use the `worker_loop` function call, but we have not implemented this
    function yet.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`worker_loop`函数调用，但我们还没有实现这个函数。
- en: Worker
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作线程
- en: 'We already implemented the worker in the JSON-RPC example. In the gRPC version,
    we use have same code, but expect a `Receiver` value and don''t spawn a new thread:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在JSON-RPC示例中实现了工作线程。在gRPC版本中，我们使用相同的代码，但期望一个`Receiver`值，并且不创建新的线程：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's compile and run this example.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行这个示例。
- en: Compiling and running
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行
- en: Build both the server and the client with the `cargo build` subcommand.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo build`子命令构建服务器和客户端。
- en: If you want to specify binary, use the --bin parameter with the name of a binary.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要指定二进制文件，请使用带有二进制文件名的--bin参数。
- en: Also, you can use `cargo watch` tool for building.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用`cargo watch`工具进行构建。
- en: If you use the `cargo watch` tool, then the `build.rs` script will generate
    files with gRPC types and `watch` will continuously restart the build. To prevent
    this, you can set the `--ignore` argument to the command with a pattern of files'
    names to ignore. For our example, we have to run the `cargo watch --ignore 'src/ring*'`
    command.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`cargo watch`工具，那么`build.rs`脚本将生成带有gRPC类型的文件，并且`watch`将不断重启构建。为了防止这种情况，你可以设置命令的`--ignore`参数，使用文件名模式的忽略。在我们的例子中，我们必须运行`cargo
    watch --ignore 'src/ring*'`命令。
- en: 'When both binaries are built, run three instances in separate terminals:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个二进制文件都构建完成后，在三个不同的终端中运行三个实例：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When all of the services start, use a client to send a request to the first
    service:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有服务启动后，使用客户端向第一个服务发送请求：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command will call a remote method, `start_roll_call`, and you will see
    similar server logs to what you saw in the preceding JSON-RPC example.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将调用远程方法`start_roll_call`，你将看到与前面JSON-RPC示例中类似的服务器日志。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered good practices for creating reactive microservices architecture.
    We started our learning from basic concepts: what a reactive approach is, how
    to implement it, and how remote procedure calls helps to implement message-driven
    architecture. Also, we discussed existing RPC frameworks and crates that you can
    use simply with Rust.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了创建响应式微服务架构的良好实践。我们从基本概念开始学习：什么是响应式方法，如何实现它，以及远程过程调用如何帮助实现消息驱动架构。此外，我们还讨论了你可以用Rust简单使用的现有RPC框架和crate。
- en: To demonstrate how reactive applications work, we created two examples of microservices
    that use RPC methods to interact with each other. We created an application that
    uses a ring of running microservices that send requests to each other in a loop
    till every instance is informed about an event.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示响应式应用程序的工作原理，我们创建了两个使用RPC方法相互交互的微服务示例。我们创建了一个应用程序，它使用一组正在运行的微服务，这些微服务在一个循环中相互发送请求，直到每个实例都了解一个事件。
- en: We also created an example that uses the JSON-RPC protocol for instance interaction
    and used the `jsonrpc-http-server` crate for the server side and the JSON-RPC
    crate for the client side.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个示例，它使用JSON-RPC协议进行实例交互，并使用`jsonrpc-http-server`crate作为服务器端，使用JSON-RPCcrate作为客户端。
- en: After that, we created an example that uses the gRPC protocol for microservice
    interaction, and we used the `grpc` crate, which covers both the client and server
    sides.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了一个示例，它使用gRPC协议进行微服务交互，并使用了`grpc`crate，该crate涵盖了客户端和服务器端。
- en: 'In the next chater we will start to integrate microservices with database and
    explore available crates to interact with the follwoing databases: PostgreSQL,
    MySQL, Redis, MongoDB, DynamoDB.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始将微服务与数据库集成，并探索可用于与以下数据库交互的crate：PostgreSQL、MySQL、Redis、MongoDB、DynamoDB。
