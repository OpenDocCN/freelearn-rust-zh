- en: Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络编程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up a basic HTTP server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基本HTTP服务器
- en: Configuring an HTTP server to perform echoing and routing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置HTTP服务器以执行回声和路由
- en: Configuring an HTTP server to perform file serving
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置HTTP服务器以执行文件服务
- en: Making requests to APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向API发送请求
- en: Setting up a basic UDP Socket
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基本的UDP套接字
- en: Configuring a UDP socket to perform echoing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置UDP套接字以执行回声
- en: Setting up a secure connection via TLS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TLS设置安全连接
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Through the internet, the world is getting smaller every day. The web connects
    people in amazing ways. Countless services are available at your fingertips for
    free. Millions of people can use your apps without even installing it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过互联网，世界每天都在变得更小。网络以惊人的方式连接着人们。无数服务免费供您使用。数百万的人可以免费使用您的应用程序，甚至不需要安装它。
- en: As a developer wanting to take advantage of this, porting your app to the internet
    can be quite easy if you have set your architecture up in a clean way. The only
    thing you need to change is the layer that interacts with the outside world.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为想要利用这一点的开发者，如果您以干净的方式设置了您的架构，将您的应用程序移植到互联网上可以非常简单。您唯一需要更改的是与外界交互的层。
- en: This chapter is going to show you how to create this layer by allowing your
    application to accept requests, respond to them, and show you how to create requests
    to other web services on your own.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何通过允许您的应用程序接受请求、响应它们，并展示如何创建对其他Web服务的请求来创建这一层。
- en: Setting up a basic HTTP server
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本HTTP服务器
- en: Let's start our chapter by bringing the famous Hello World program into the
    21^(st) century by hosting it on a server. We are going to use the `hyper` crate
    for this, which is a strongly typed wrapper around all things HTTP. In addition
    to being one of the fastest HTTP implementations in the world ([https://www.techempower.com/benchmarks/#section=data-r15&hw=ph&test=plaintext](https://www.techempower.com/benchmarks/#section=data-r15&hw=ph&test=plaintext)),
    it is used by nearly *all* major high-level frameworks ([https://github.com/flosse/rust-web-framework-comparison#high-level-frameworks](https://github.com/flosse/rust-web-framework-comparison#high-level-frameworks)),
    the only exception being the ones that reimplemented it all on the extremely basic
    *stringly-typed* TCP library that Rust provides under `std::net::TcpStream`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将著名的Hello World程序带入21世纪，通过在服务器上托管它来开始我们的章节。我们将使用`hyper` crate来完成这个任务，它是一个围绕所有HTTP事物的强类型包装器。除了是世界上速度最快的HTTP实现之一（[https://www.techempower.com/benchmarks/#section=data-r15&hw=ph&test=plaintext](https://www.techempower.com/benchmarks/#section=data-r15&hw=ph&test=plaintext)），它还被几乎所有主要的高级框架使用（[https://github.com/flosse/rust-web-framework-comparison#high-level-frameworks](https://github.com/flosse/rust-web-framework-comparison#high-level-frameworks)），唯一的例外是那些在Rust提供的`std::net::TcpStream`极其基本的*字符串类型*库上重新实现了它的框架。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: All `hyper` recipes work with `futures`, so you should read all of [Chapter
    8](dccc0c20-85ff-46a7-a1b8-463a5dd92ba0.xhtml), *Working with Futures*, before
    continuing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`hyper`食谱都与`futures`兼容，因此在继续之前，您应该阅读所有[第8章](dccc0c20-85ff-46a7-a1b8-463a5dd92ba0.xhtml)，*与Futures一起工作*。
- en: 'At the time of writing, `hyper` has not yet upgraded to `futures v0.2` (tracking
    issue: [https://github.com/hyperium/hyper/issues/1448](https://github.com/hyperium/hyper/issues/1448)),
    so we going to use `futures v0.1`. This should be no problem in the future (no
    pun intended), as all relevant code is written in a way that should be compatible
    with `0.2` when it''s released.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`hyper`尚未升级到`futures v0.2`（跟踪问题：[https://github.com/hyperium/hyper/issues/1448](https://github.com/hyperium/hyper/issues/1448)），因此我们将使用`futures
    v0.1`。这应该在未来没有问题（没有打趣的意思），因为所有相关代码都是按照应该与`0.2`兼容的方式编写的。
- en: If some unexpected API change breaks the recipes, you will be able to find a
    fixed version of them at the book's GitHub repository ([https://github.com/jnferner/rust-standard-library-cookbook/tree/master/chapter-nine/src/bin](https://github.com/jnferner/rust-standard-library-cookbook/tree/master/chapter-nine/src/bin)),
    which will always be updated in order to work with the newest versions of all
    libraries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些意外的API更改破坏了食谱，您可以在本书的GitHub仓库中找到它们的修复版本（[https://github.com/jnferner/rust-standard-library-cookbook/tree/master/chapter-nine/src/bin](https://github.com/jnferner/rust-standard-library-cookbook/tree/master/chapter-nine/src/bin)），它将始终更新以与所有库的最新版本兼容。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a Rust project to work on during this chapter with `cargo new chapter-nine`
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new chapter-nine`创建一个Rust项目，在本章中对其进行工作。
- en: Navigate into the newly created `chapter-nine` folder. For the rest of this
    chapter, we will assume that your command line is currently in this directory
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的 `chapter-nine` 文件夹。在本章的其余部分，我们将假设您的命令行当前位于此目录
- en: Open the `Cargo.toml` file that has been generated for you
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开为您生成的 `Cargo.toml` 文件
- en: 'Under `[dependencies]`, add the following lines:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下，添加以下行：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you want, you can go to futures' ([https://crates.io/crates/futures](https://crates.io/crates/futures))
    and hyper's ([https://crates.io/crates/hyper](https://crates.io/crates/hyper))
    *crates.io* pages to check for the newest version and use that one instead
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您愿意，可以访问 futures' ([https://crates.io/crates/futures](https://crates.io/crates/futures))
    和 hyper's ([https://crates.io/crates/hyper](https://crates.io/crates/hyper)) 的
    *crates.io* 页面，检查最新版本并使用它
- en: Inside the folder `src`, create a new folder called `bin`
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹 `src` 内，创建一个名为 `bin` 的新文件夹
- en: Delete the generated `lib.rs` file, as we are not creating a library
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的 `lib.rs` 文件，因为我们没有创建库
- en: In the folder `src/bin`, create a file called `hello_world_server.rs`
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹 `src/bin` 中，创建一个名为 `hello_world_server.rs` 的文件
- en: 'Add the following code and run it with `cargo run --bin hello_world_server`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用 `cargo run --bin hello_world_server` 运行它：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run a server by creating a service with `service_fn`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `service_fn` 创建服务来运行服务器：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run a server by manually creating a `struct` that implements `Service`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过手动创建一个实现 `Service` 的 `struct` 来运行服务器：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In `main`, we first parse a string representing our IPv6 loopback address (think
    `localhost`) as an `std::net::SocketAddr`, which is a type holding an IP address
    and a port [13]. Granted, we could have used a constant for our address, but we
    are showing how to parse it from a string, because in a real application you will
    probably fetch the address from an environment variable, as shown in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*; *Interacting
    with environment variables*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，我们首先将表示我们的 IPv6 回环地址（例如 `localhost`）的字符串解析为 `std::net::SocketAddr`，这是一个包含
    IP 地址和端口的类型 [13]。当然，我们可以使用一个常量作为我们的地址，但我们展示的是如何从字符串中解析它，因为在实际应用中，您可能需要从环境变量中获取地址，正如在
    [第 1 章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml) *学习基础知识*；*与环境变量交互* 中所示。
- en: We then run our `hyper` server, which we create in `run_with_service_function`
    [17]. Let's take a look at that function by learning a bit about `hyper`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行在 `run_with_service_function` [17] 中创建的 `hyper` 服务器。让我们通过了解一下 `hyper`
    来看看这个函数。
- en: 'The most fundamental trait in `hyper` is the `Service`. It is defined as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`hyper` 中最基础的特质是 `Service`。它被定义为如下：'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It should be easy to read the signature of `call`: It takes a `Request` and
    returns a `Future` of a `Response`. `hyper` uses this trait to answer to an incoming
    request. We generally have two ways to define a `Service`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很容易阅读 `call` 的签名：它接受一个 `Request` 并返回一个 `Response` 的 `Future`。`hyper` 使用这个特质来响应传入的请求。我们通常有两种方式来定义一个
    `Service`：
- en: Manually create a `struct` that implements `Service`, explicitly setting its
    associated types to whatever `call` returns
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动创建一个实现 `Service` 的 `struct`，显式设置其关联类型为 `call` 返回的类型
- en: Let a `Service` be built for you by passing a closure that returns a `Result`
    to `service_fn`, which you wrap in a `const_service`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传递一个返回 `Result` 的闭包给 `service_fn`，并使用 `const_service` 包装它，让 `Service` 为您构建
- en: Both variants result in the exact same thing, so this example contains both
    versions to give you a taste of them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种变体都会产生完全相同的结果，所以这个例子包含了两种版本，以便您尝尝它们的味道。
- en: '`run_with_service_function` uses the second style [22]. It returns a `Result`
    of a `Response`, which `service_fn` converts to a `Future` of `Response` because
    `Result` implements `Future`. `service_fn` then does some type deduction for us
    and creates a kind of `Service`. But we aren''t done yet. You see, when `hyper`
    receives a new connection, it will not call our `Service` directly with the `Request`,
    but first makes a copy of it in order to handle every connection with its very
    own `Service`. This means that our `Service` must have the ability to create new
    instances of itself, which is indicated by the `NewService` trait. Luckily, we
    don''t need to implement it ourselves either. The closure at the heart of our `Service`
    doesn''t manage any state, so we can call it a constant function. Constants are
    very easy to copy, as all copies are guaranteed to be identical. We can mark our
    `Service` as constant by calling `const_service` on it, which basically just wraps
    the `Service` in an `Arc` and then implements `NewService` by simply returning
    a copy of it. But what exactly is our `Service` returning anyways?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`run_with_service_function`使用第二种风格[22]。它返回一个`Response`的`Result`，`service_fn`将其转换为`Response`的`Future`，因为`Result`实现了`Future`。`service_fn`然后为我们进行一些类型推导并创建一种`Service`。但我们的任务还没有完成。您可以看到，当`hyper`接收到一个新的连接时，它不会直接用`Request`调用我们的`Service`，而是首先复制它，以便为每个连接使用其自己的`Service`。这意味着我们的`Service`必须具有创建自身新实例的能力，这由`NewService`特质表示。幸运的是，我们也不需要自己实现它。我们`Service`核心的闭包不管理任何状态，所以我们可以称它为一个常量函数。常量非常容易复制，因为所有副本都保证是相同的。我们可以通过调用`const_service`来标记我们的`Service`为常量，这基本上只是将`Service`包装在一个`Arc`中，然后通过简单地返回其副本来实现`NewService`。但我们的`Service`究竟返回了什么呢？'
- en: '`Response<hyper::Body>` creates a new HTTP response [25] and manages its body
    as a `hyper::Body`, which is a future `Stream<Chunk>`. A `Chunk` is just a piece
    of an HTTP message. This `Response` is a builder, so we can change the contents
    of it by calling various methods. In our code, we set its `Content-Type` header
    to `plaintext`, which is a `hyper` shortcut for the MIME type `text/plain` [27].'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response<hyper::Body>`创建一个新的HTTP响应[25]，并管理其体作为`hyper::Body`，这是一个未来的`Stream<Chunk>`。`Chunk`只是HTTP消息的一部分。这个`Response`是一个构建器，所以我们可以通过调用各种方法来更改其内容。在我们的代码中，我们将其`Content-Type`标题设置为`plaintext`，这是`hyper`对MIME类型`text/plain`的快捷方式[27]。'
- en: 'A MIME type is a label for data served over HTTP. It tells the client how to
    treat the data it receives. For example, most browsers will not render the message
    `<p>Hello World!</p>` as HTML unless it comes with the header `Content-Type: text/html`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 'MIME类型是用于通过HTTP服务的数据的标签。它告诉客户端如何处理它接收到的数据。例如，大多数浏览器不会将消息`<p>Hello World!</p>`作为HTML渲染，除非它带有标题`Content-Type:
    text/html`。'
- en: We also set its `Content-Length` header to the length (in bytes) of our message
    so the client knows how much data they should expect [29]. Finally, we set the
    message's body to the message, which then gets sent to the client as `"Hello World!"`
    [31].
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将其`Content-Length`标题设置为消息的长度（以字节为单位），以便客户端知道他们应该期望多少数据[29]。最后，我们将消息体设置为消息，然后将其作为`"Hello
    World!"`发送到客户端[31]。
- en: Our service can now be bound to a new instance of `hyper::server::Http`, which
    we then run [34 and 35]. You can now open your browser of choice and point it
    to `http://localhost:3000`. If everything went right, you should be greeted by
    a `Hello World!` message.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务现在可以绑定到一个新的`hyper::server::Http`实例上，然后我们运行它[34和35]。现在您可以使用您选择的浏览器，将其指向`http://localhost:3000`。如果一切顺利，您应该会看到一个`Hello
    World!`消息。
- en: 'The same thing would happen if we called `run_with_service_struct` instead,
    which uses a manually created `Service` instead [40]. A quick inspection of its
    implementation shows us the key differences to the last approach [45 to 63]:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`run_with_service_struct`而不是这个，它使用手动创建的`Service`，也会发生同样的事情[40]。快速检查其实现显示给我们与最后一种方法[45到63]的关键区别：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we need to explicitly specify the concrete type of basically
    everything [48 to 52]. We also can't simply return a `Result` in our `call` method
    and need to return the actual `Future`, wrapped in a `Box` [56], so we don't need
    to think about which exact flavor of `Future` we are using.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要明确指定基本上所有东西的具体类型[48到52]。我们也不能简单地在我们的`call`方法中返回一个`Result`，而需要返回实际的`Future`，并用`Box`[56]包装它，这样我们就不需要考虑我们正在使用哪种具体的`Future`类型了。
- en: 'On the other hand, this approach has one big advantage over the other: It can
    manage state in the form of members. Because all `hyper` recipes in this chapter
    work with constant Services, that is Services that will return the same `Response`
    to equal Requests, we will use the first variant to create Services. This is simply
    a stylistic decision based on simplicity, as they are all small enough that it
    wouldn''t be worth it to extract them into an own `struct`. In your projects,
    use whichever form suits the current use case best.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这种方法与另一种方法相比有一个很大的优点：它可以以成员的形式管理状态。因为本章中所有的 `hyper` 菜谱都使用常量服务，即对等请求将返回相同的
    `Response` 的服务，我们将使用第一个变体来创建服务。这仅仅是一个基于简单性的风格选择，因为它们都足够小，不值得提取到自己的 `struct` 中。在你的项目中，使用最适合当前用例的形式。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using the builder pattern* and *Interacting with environment variables* recipe
    in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用构建器模式* 和 [第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml) 中的 *与环境变量交互*
    菜单，*学习基础知识*'
- en: Configuring an HTTP server to perform echoing and routing
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置一个执行回声和路由的 HTTP 服务器
- en: We learned how to serve the same response forever, but that would get pretty
    dull after a while. In this recipe, you are going to learn how to read requests
    and respond to them individually. For this, we will use routing to differentiate
    between requests to different endpoints.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何永久地提供相同的响应，但过一段时间后这会变得相当无聊。在这个菜谱中，你将学习如何读取请求并单独对它们进行响应。为此，我们将使用路由来区分对不同端点的请求。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To test this recipe, you will need a way to easily send HTTP requests. An excellent
    free tool for this is Postman ([https://www.getpostman.com/](https://www.getpostman.com/)),
    which features a nice and self-explanatory UI. If you''d rather not download anything,
    you can use your terminal for this. If you''re on Windows, you can open PowerShell
    and enter the following to do an HTTP request:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个菜谱，你需要一种轻松发送 HTTP 请求的方法。一个出色的免费工具是 Postman ([https://www.getpostman.com/](https://www.getpostman.com/))，它具有一个友好且易于理解的界面。如果你不想下载任何东西，你可以使用终端来做这个。如果你在
    Windows 上，你可以打开 PowerShell 并输入以下命令来进行 HTTP 请求：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, if you wanted to POST the message `hello there, my echoing friend` to `http://localhost:3000/echo`,
    as you will be asked to later in the recipe, you''d need to enter the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想将消息 `hello there, my echoing friend` POST 到 `http://localhost:3000/echo`，正如菜谱中稍后所要求的那样，你需要输入以下命令：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On Unix systems, you can use cURL for that ([https://curl.haxx.se/](https://curl.haxx.se/)).
    The analog command is the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 系统上，你可以使用 cURL 来做这个 ([https://curl.haxx.se/](https://curl.haxx.se/))。相应的命令如下：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'cURL will resolve `localhost` to its entry in `/etc/hosts`. In some configurations,
    this will only be the IPv4 loopback address (`127.0.0.1`). In some others, you
    will have to use `ip6-localhost`. Check your `/etc/hosts` to find out what to
    use. In any case, an explicit `[::1]` will always work. As an example, the following
    command will again POST the message `hello there, my echoing friend` to `http://localhost:3000/echo`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: cURL 将将 `localhost` 解析为其 `/etc/hosts` 中的条目。在某些配置中，这将是 IPv4 环回地址 (`127.0.0.1`)。在其他一些配置中，你必须使用
    `ip6-localhost`。检查你的 `/etc/hosts` 以确定使用什么。在任何情况下，显式的 `[::1]` 总是有效的。例如，以下命令将再次将消息
    `hello there, my echoing friend` POST 到 `http://localhost:3000/echo`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open the `Cargo.toml` file that has been generated for you
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开为你生成的 `Cargo.toml` 文件
- en: 'Under `[dependencies]`, if you didn''t do so in the last recipe, add the following
    lines:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下，如果你在上一个菜谱中没有这样做，请添加以下行：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you want, you can go to futures' ([https://crates.io/crates/futures](https://crates.io/crates/futures))
    and hyper's ([https://crates.io/crates/hyper](https://crates.io/crates/hyper))
    *crates.io* pages to check for the newest version and use that one instead
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以访问 futures' ([https://crates.io/crates/futures](https://crates.io/crates/futures))
    和 hyper's ([https://crates.io/crates/hyper](https://crates.io/crates/hyper)) 的
    *crates.io* 页面，检查最新版本并使用它。
- en: In the folder `src/bin`, create a file called `echo_server_with_routing.rs`
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中创建一个名为 `echo_server_with_routing.rs` 的文件
- en: 'Add the following code and run it with `cargo run --bin echo_server_with_routing`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin echo_server_with_routing` 运行它：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The functions are handling the routes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数处理路由：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe begins like the last one, so let''s skip straight into the definition
    of our `Service`[14 to 22]:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱与上一个菜谱类似，所以让我们直接跳到 `Service` 的定义[14到22]：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are now using the `Request` parameter that the last recipe simply ignored.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用的是 `Request` 参数，而上一个菜谱只是简单地忽略了它。
- en: Because Rust allows us to pattern match on tuples, we can directly differentiate
    between HTTP methods and path combinations. We then pass on the control flow of
    our program to dedicated route handlers, which in turn are responsible for returning
    the response.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Rust 允许我们在元组上使用模式匹配，所以我们可以直接区分 HTTP 方法与路径组合。然后我们将程序的控制流传递给专门的路线处理程序，它们反过来负责返回响应。
- en: In bigger programs with tons of routes, we would not specify them all in one
    function, but spread them across namespaces and split them into subrouters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有大量路由的大程序中，我们不会在一个函数中指定所有这些，而是将它们分散在命名空间中，并将它们分成子路由器。
- en: The code for `handle_root` [29] looks nearly identical to the hello world `Service`
    from the last chapter, but instructs the caller to POST at the `/post` route.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_root` [29] 的代码看起来几乎与上一章的 hello world `Service` 相同，但指示调用者向 `/post` 路由发送
    POST 请求。'
- en: Our match for said POST leads to `handle_echo` [37], which simply returns the
    request's body as the response's body [40]. You can try this for yourself by POSTing
    a message to `http://localhost:3000/echo`, as described in the *Getting ready*
    section. If everything goes right, your message will come right back at you.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所说的 POST，我们的匹配会导致 `handle_echo` [37]，它简单地返回请求体作为响应体 [40]。你可以通过在 *准备就绪* 部分描述的方式将消息
    POST 到 `http://localhost:3000/echo` 来尝试它。如果一切顺利，你的消息会直接返回给你。
- en: 'Last, but not least, `handle_not_found` [43] is called when no routes matched.
    This time, we don''t send a message back, but instead, return the possible most
    famous status code of the world: `404 Not Found` [45].'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，当没有路由匹配时，会调用 `handle_not_found` [43]。这次，我们不发送消息，而是返回世界上可能最著名的状态码：`404
    Not Found` [45]。
- en: Configuring an HTTP server to perform file serving
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 HTTP 服务器以执行文件服务
- en: 'The last recipes were really useful for building web services, but let''s take
    a look at how to do the thing HTTP was originally created for: serving HTML files
    to the web.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上一系列的菜谱对于构建网络服务非常有用，但让我们看看如何做 HTTP 最初创建的事情：向网络提供 HTML 文件。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `Cargo.toml` file that has been generated for you.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开为你生成的 `Cargo.toml` 文件。
- en: 'Under `[dependencies]`, if you didn''t do so in the last recipe, add the following
    lines:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下，如果你在上一个菜谱中没有这样做，请添加以下行：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you want, you can go to futures' ([https://crates.io/crates/futures](https://crates.io/crates/futures))
    and hyper's ([https://crates.io/crates/hyper](https://crates.io/crates/hyper))
    *crates.io* pages to check for the newest version and use that one instead.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想的话，你可以访问 futures' ([https://crates.io/crates/futures](https://crates.io/crates/futures))
    和 hyper's ([https://crates.io/crates/hyper](https://crates.io/crates/hyper)) 的
    *crates.io* 页面，检查最新版本并使用它。
- en: In the folder `chapter-nine`, create a folder called `files`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `chapter-nine` 文件夹中创建一个名为 `files` 的文件夹。
- en: 'In the folder `files`, create a file called `index.html` and add the following
    code to it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `files` 文件夹中创建一个名为 `index.html` 的文件，并将以下代码添加到其中：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the folder `files`, create a file called `foo.html` and add the following
    code to it:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `files` 文件夹中创建一个名为 `foo.html` 的文件，并将以下代码添加到其中：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the folder `files`, create a file called `bar.html` and add the following
    code to it:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `files` 文件夹中创建一个名为 `bar.html` 的文件，并将以下代码添加到其中：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the folder `files`, create a file called `not_found.html` and add the following
    code to it:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `files` 文件夹中创建一个名为 `not_found.html` 的文件，并将以下代码添加到其中：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the folder `files`, create a file called `invalid_method.html` and add the
    following code to it:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `files` 文件夹中创建一个名为 `invalid_method.html` 的文件，并将以下代码添加到其中：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the folder `src/bin`, create a file called `file_server.rs`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中创建一个名为 `file_server.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin echo_server_with_routing`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并使用 `cargo run --bin echo_server_with_routing` 运行它：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following are the route handlers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些路由处理程序：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the code for the functions returning the futures with our
    files:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为返回我们的文件的函数编写的代码：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following are some helper functions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些辅助函数：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Wow! That was a lot of files. Of course, the exact content of the HTML and CSS
    doesn't matter for this recipe, as we're going to be focused on Rust. We've put
    them all in the `files` folder because we are going to make its contents publicly
    accessible by name for any client.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！文件太多了。当然，对于这个菜谱来说，HTML 和 CSS 的确切内容并不重要，因为我们将要专注于 Rust。我们已经把它们都放在了 `files`
    文件夹中，因为我们打算通过名称使任何客户端都可以公开访问其内容。
- en: 'The basics of the server setup are the same as with the echoing recipe: create
    a `Service` with `const_service` and `service_fn` [21], match the request''s method
    and path, and then handle the routes in different functions. When looking at our
    return type, however, we can notice a difference [36]:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器设置的基本原理与回声食谱相同：使用 `const_service` 和 `service_fn` [21] 创建一个 `Service`，匹配请求的方法和路径，然后在不同的函数中处理路由。然而，当我们查看返回类型时，我们可以注意到一个差异
    [36]：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are no longer returning a `Response` directly, but instead, wrapping it in
    a `Future`. This allows us to not block the server when loading a file into memory;
    we can continue handling requests in the main thread while the file serving `Future`
    is run in the background.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再直接返回一个 `Response`，而是将其封装在一个 `Future` 中。这允许我们在将文件加载到内存时不会阻塞服务器；我们可以在主线程中继续处理请求，同时文件服务的
    `Future` 在后台运行。
- en: 'When looking at our route handlers, you can see that they all use the `send_file_or_404`
    function. Let''s take a look at it [56]:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看我们的路由处理程序时，你可以看到它们都使用了 `send_file_or_404` 函数。让我们看看它 [56]：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, the function sanitizes our input. The implementation of `sanitize_path`
    [130 to 141] should be pretty straightforward. It filters out potential troublemakers
    so that a malicious client cannot do any shenanigans, such as requesting the file
    `localhost:3000/../../../../home/admin/.ssh/id_rsa`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该函数清理我们的输入。`sanitize_path` [130 到 141] 的实现应该是相当直接的。它过滤掉潜在的麻烦制造者，这样恶意客户端就不能进行任何恶作剧，例如请求文件
    `localhost:3000/../../../../home/admin/.ssh/id_rsa`。
- en: We then call `try_to_send_file` on the sanitized path [72]. We are going to
    look at that function in a minute, but for now, it's enough to look at its signature.
    It tells us that it returns a `Future` of a `Result` that can be a `Response`
    or an `io::Error`, as that's the error encountered on invalid filesystem access.
    We cannot return this `Future` directly, since we already told `hyper` that we
    are going to return a `Future` of `Response`, so we need to convert the types.
    If the file retrieving `Future` generated from `try_to_send_file` succeeded, we
    act on its item, which is a `Result<Response, io::Error>`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在清理后的路径上调用 `try_to_send_file` [72]。我们将在下一分钟查看该函数，但就现在而言，查看其签名就足够了。它告诉我们它返回一个
    `Result` 的 `Future`，这个 `Result` 可以是一个 `Response` 或一个 `io::Error`，因为这是在无效文件系统访问中遇到的错误。我们不能直接返回这个
    `Future`，因为我们已经告诉 `hyper` 我们将返回一个 `Response` 的 `Future`，所以我们需要转换类型。如果从 `try_to_send_file`
    生成的文件检索 `Future` 成功，我们就对其项目进行操作，该项目是一个 `Result<Response, io::Error>`。
- en: Because `hyper::Error` implements `From<io::Error>`, we can convert them easily
    by calling `.into()` [63] (see [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*; *Converting types*, for an introduction to the `From`
    trait). This will return a `Result<Response, hyper::Error>`. Because a `Future`
    is constructable from a `Result`, it will be implicitly converted to a `Future<Response,
    hyper::Error>` for us, which is exactly what we want. A little cherry on top is
    our handling of `try_to_send_file` returning an error, in which case we can safely
    assume that the file doesn't exist, so we return a `Future` with a custom `404
    Not Found` page by calling `send_404()` [65]. Before looking at its implementation,
    let's check out `try_to_send_file` first [72].
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `hyper::Error` 实现了 `From<io::Error>`，我们可以通过调用 `.into()` [63]（参见 [第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*；*类型转换*，了解
    `From` 特质的介绍）。这将返回一个 `Result<Response, hyper::Error>`。因为 `Future` 可以从 `Result`
    构造，所以它将隐式地转换为 `Future<Response, hyper::Error>`，这正是我们想要的。额外的一点是，我们处理 `try_to_send_file`
    返回错误的情况，在这种情况下，我们可以安全地假设文件不存在，因此我们通过调用 `send_404()` [65] 返回一个自定义的 `404 Not Found`
    页面。在查看其实现之前，我们先看看 `try_to_send_file` [72]。
- en: 'First, we convert the requested path into a local filesystem path with `path_on_disk`
    [74], which is simply implemented as follows [144]:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `path_on_disk` [74] 将请求的路径转换为本地文件系统路径，其实现如下 [144]：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We created an own function for this so it will be easy for you to extend the
    filesystem logic. For example, for Unix systems, it is usual to put all static
    HTML in `/var/www/`, while Windows web servers usually put all of their data in
    their own installation folder. Or you may want to read a configuration file provided
    by the user and store its value in a `lazy_static`, as shown in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*; *Using lazy static variable*, and use that path instead.
    You can implement all of those rules in this function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此创建了一个自定义函数，这样你就可以轻松扩展文件系统逻辑。例如，对于 Unix 系统，通常会将所有静态 HTML 放在 `/var/www/`，而
    Windows 网络服务器通常将它们的所有数据放在它们自己的安装文件夹中。或者你可能想读取用户提供的配置文件，并将其值存储在 `lazy_static` 中，如
    [第 5 章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*；*使用懒静态变量*，并使用该路径。你可以在该函数中实现所有这些规则。
- en: Back in `try_to_send_file`, we create a `oneshot::channel` to send data as a
    `Future` [77]. This concept is explained in detail in [Chapter 8](dccc0c20-85ff-46a7-a1b8-463a5dd92ba0.xhtml),
    *Working with Futures*; *Using the* *oneshot channel*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `try_to_send_file` 函数中，我们创建了一个 `oneshot::channel` 来以 `Future` 的形式发送数据 [77]。这个概念在
    [第 8 章](dccc0c20-85ff-46a7-a1b8-463a5dd92ba0.xhtml)，*使用 Future*；*使用 oneshot 通道*
    中有详细的解释。
- en: 'The rest of the function now creates a new thread to load the file into memory
    in the background [78]. We first open the file [79] and return an error through
    the channel if it doesn''t exist. We then copy the entire file into a local vector
    of bytes [91] and again propagate any error that might occur [107]. If the process
    of copying into RAM succeeded, we return a `Response` with the content of the
    file as its body [100]. Along the way, we have to figure out the file''s appropriate
    MIME type [96], as promised in the recipe *Setting up a basic HTTP server*. For
    that, we simply match the extension of the file [147 to 158]:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分现在创建了一个新线程，在后台将文件加载到内存中 [78]。我们首先打开文件 [79]，如果文件不存在，则通过通道返回错误。然后我们将整个文件复制到一个本地的字节数组中
    [91]，并再次传播可能发生的任何错误 [107]。如果将数据复制到 RAM 的过程成功，我们返回一个包含文件内容的 `Response` [100]。在这个过程中，我们必须确定文件的适当
    MIME 类型 [96]，正如在 *设置基本 HTTP 服务器* 的配方中所承诺的。为此，我们只需匹配文件的扩展名 [147 到 158]。
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You may think this implementation is pretty lazy and that there should be a
    better way, but, trust me, this is exactly how all big web servers do it. Case
    in point, you can find `nginx` ([https://nginx.org/en/](https://nginx.org/en/))
    mime detection algorithm here: [https://github.com/nginx/nginx/blob/master/conf/mime.types](https://github.com/nginx/nginx/blob/master/conf/mime.types).
    If you plan on serving new file types, you can extend the `match` for their extensions.
    The `nginx` source is a good resource for this.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这种实现相当懒惰，应该有更好的方法，但请相信我，这正是所有大型网络服务器所做的方式。以 `nginx` 为例，([https://nginx.org/en/](https://nginx.org/en/))，你可以在这里找到
    mime 检测算法：[https://github.com/nginx/nginx/blob/master/conf/mime.types](https://github.com/nginx/nginx/blob/master/conf/mime.types)。如果你计划提供新的文件类型，你可以扩展它们的扩展名的
    `match`。`nginx` 源代码是这方面的良好资源。
- en: '`get_content_type` returns `None` if there was no match [155] instead of a
    default content type, so that every caller can decide on a default for themselves.
    In `try_to_send_file`, we use `.unwrap_or_else(ContentType::plaintext);` [96]
    to set the fallback MIME type to `text/plain`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_content_type` 如果没有匹配项 [155] 则返回 `None` 而不是默认内容类型，这样每个调用者都可以为自己决定一个默认值。在
    `try_to_send_file` 中，我们使用 `.unwrap_or_else(ContentType::plaintext);` [96] 将回退
    MIME 类型设置为 `text/plain`。'
- en: The last unexplained function left in our example is `send_404`, which we use
    a lot as a fallback. You can see that all it really does is call `try_to_send_file`
    on the 404 page [117] and on error send a static message instead [124].
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，最后剩下的未解释的函数是 `send_404`，我们经常将其用作回退。你可以看到它实际上只是对 404 页面 [117] 调用 `try_to_send_file`，并在出错时发送一个静态消息
    [124]。
- en: The fallback in `send_404` really shows us the beauty in Rust's error handling
    concept. Because strongly typed errors are part of a function's signature, as
    opposed to languages such as C++, where you never know who might throw an exception,
    you are forced to consciously handle the error cases. Try to remove `and_then`
    and its associated closure and you'll see that the compiler doesn't let you compile
    your program because you didn't handle the `Result` of `try_to_send_file` in any
    way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `send_404` 中的回退实际上展示了 Rust 错误处理概念的美丽。因为强类型错误是函数签名的一部分，与像 C++ 这样的语言不同，在 C++
    中你永远不知道谁可能会抛出异常，你必须有意识地处理错误情况。尝试移除 `and_then` 及其关联的闭包，你就会看到编译器不会让你编译程序，因为你没有以任何方式处理
    `try_to_send_file` 的 `Result`。
- en: Go ahead now and see the results of our file server with your own eyes by pointing
    your browser to `http://localhost:3000/`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就打开您的浏览器，通过指向`http://localhost:3000/`来亲眼看看我们的文件服务器的结果。
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Despite being relatively easy to understand, our implementation of `try_to_send_file`
    is not endlessly scalable. Imagine serving and loading huge files into memory
    for millions of clients at the same time. That would bring your RAM to its limits
    pretty quickly. A more scalable solution is to send the file in chunks, that is
    part by part, so that you only need to hold a small part of it in memory at any
    given time. To implement this, you'll need to copy the contents of your file to
    a limited `[u8]` buffer with a fixed size and send that through an additional
    channel as an instance of `hyper::Chunk`, which implements `From<Vec<T>>`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相对容易理解，但我们的`try_to_send_file`实现并不是无限可扩展的。想象一下同时为成百万的客户端提供和加载大量文件到内存中。这会很快让你的RAM达到极限。一个更可扩展的解决方案是分块发送文件，即部分一部分，这样你只需要在任何给定时间保持文件的一小部分在内存中。要实现这一点，你需要将文件内容复制到一个固定大小的有限`[u8]`缓冲区中，并通过一个额外的通道作为`hyper::Chunk`的实例发送，它实现了`From<Vec<T>>`。
- en: See also
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Converting types into each other* and *Creating* *lazy static variables *recipe
    in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced Data Structures*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将类型相互转换*和*创建* *懒静态变量*的配方在[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*中。'
- en: '*Using the oneshot channel* recipe in [Chapter 8](dccc0c20-85ff-46a7-a1b8-463a5dd92ba0.xhtml),
    *Working with Futures*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用第8章中的oneshot通道*配方[第8章](dccc0c20-85ff-46a7-a1b8-463a5dd92ba0.xhtml)，*与Futures一起工作*。'
- en: Making requests to APIs
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向API发送请求
- en: 'Our last destination in this chapter brings us away from the server in favor
    of the other party participating in internet communication: the client. We will
    use `reqwest`, which is built around `hyper`, to create HTTPS requests to web
    services and parse their data into nicely usable Rust structures. You can also
    use the content of this recipe to write integration tests for your own web services.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个目的地将我们带离服务器，转向参与互联网通信的另一方：客户端。我们将使用`reqwest`，它是围绕`hyper`构建的，来创建对Web服务的HTTPS请求并将它们的数据解析成可用的Rust结构。您也可以使用这个配方的内容来编写您自己的Web服务的集成测试。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Open the `Cargo.toml` file that has been generated for you
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开为您生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, if you didn''t do so in the last recipe, add the following
    lines:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`下，如果您在上一个配方中没有这样做，请添加以下行：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you want, you can go to `request`'s ([https://crates.io/crates/reqwest](https://crates.io/crates/reqwest)),
    `serde`'s ([https://crates.io/crates/serde](https://crates.io/crates/serde)),
    and `serde_derive`'s ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive))
    *crates.io* pages to check for the newest versions and use those ones instead
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以去`request`的([https://crates.io/crates/reqwest](https://crates.io/crates/reqwest))，`serde`的([https://crates.io/crates/serde](https://crates.io/crates/serde))，和`serde_derive`的([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive))
    *crates.io*页面检查最新版本，并使用这些版本代替。
- en: In the folder `src/bin`, create a file called `making_requests.rs`
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`making_requests.rs`的文件。
- en: 'Add the following code and run it with `cargo run --bin making_requests`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin making_requests`运行它：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code shows the requests being implemented:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了正在实现的请求：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code shows us using our CRUD client:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何使用我们的CRUD客户端：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At the top, we define our structures. `Post`[11], `NewPost` [20], and `UpdatedPost`
    [29] all just represent convenient ways to handle the different requirements of
    the API. The particular JSON API we are interacting with uses camelCase variables,
    so we need to specify this on every `struct`, otherwise `serde` won't be able
    to parse them correctly [10, 19 and 27].
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们定义了我们的结构。`Post`[11]，`NewPost` [20]，和`UpdatedPost` [29]都只是处理API不同需求的便捷方式。我们正在与之交互的特定JSON
    API使用camelCase变量，因此我们需要在每一个`struct`上指定这一点，否则`serde`将无法正确解析它们[10，19和27]。
- en: 'Because the `PATCH` method we''re communicating with doesn''t accept null values
    on unchanged variables, we mark them all in `UpdatedPost` as not serialized when
    equal to `None` [30, 32 and 34]:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为与我们通信的`PATCH`方法不接受未更改变量的null值，所以我们把所有在`UpdatedPost`中等于`None`的标记为未序列化[30，32和34]：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Additionally, we implement the `fmt::Display` trait on `Post`, so we can print
    it nicely [43 to 51].
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在`Post`上实现了`fmt::Display`特性，这样我们就可以很好地打印它了[43到51]。
- en: But enough about our models; let's take a look at `PostCrud` [53]. Its purpose
    is to abstract a CRUD (Create, Read, Update, Delete) service. For this, it is
    equipped with a reusable HTTP client via `reqwest::Client` [57] and a mock JSON
    API endpoint from [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于我们的模型就先说到这里；让我们来看看`PostCrud` [53]。它的目的是抽象化一个 CRUD（创建、读取、更新、删除）服务。为此，它通过`reqwest::Client`
    [57]提供了一个可重用的 HTTP 客户端，以及来自[https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)的模拟
    JSON API 端点。
- en: 'Its methods show you how easy `reqwest` is to use: you simply use the required
    HTTP method directly as a function on the client, pass optional data to it, which
    it will automatically deserialize for you with `.json()`, `.send()` the request,
    and then parse the response again as JSON with a second call to  `.json()` [64].'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它的方法展示了`reqwest`的使用是多么简单：你只需直接将所需的 HTTP 方法作为客户端上的一个函数使用，向它传递可选的数据，它将自动使用`.json()`为你反序列化，然后使用`.send()`发送请求，并通过第二次调用`.json()`再次将响应解析为
    JSON [64]。
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Of course, `reqwest` is able to work with non-JSON-based web services as well.
    It has various methods for this such as `query`, which adds an array of key-value
    queries to the URL, or `form`, which will add `url-encoded` form bodies to the
    request. While using all these methods, `reqwest` will manage the headers for
    you, but you can manage them however explicitly you want using the `headers` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`reqwest`也能够与非基于 JSON 的网络服务一起工作。为此它有多种方法，例如`query`，它将键值查询数组添加到 URL 中，或者`form`，它将`url-encoded`表单体添加到请求中。在使用所有这些方法时，`reqwest`会为你管理头部信息，但你也可以使用`headers`方法以任何你想要的方式显式地管理它们。
- en: See also
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using the builder pattern* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)中的“使用构建器模式”配方，*学习基础知识*'
- en: '*Serialization basics with Serde* recipe in [Chapter 4](c9c593dc-fc0e-4305-b819-4b112cb98684.xhtml),
    *Serialization*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 4 章](c9c593dc-fc0e-4305-b819-4b112cb98684.xhtml)中的“使用 Serde 的序列化基础知识”配方，*序列化*'
