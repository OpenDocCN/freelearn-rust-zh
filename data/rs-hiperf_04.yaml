- en: Lints and Clippy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lint 和 Clippy
- en: Up until now, we needed to check all the details of the code by ourselves. This
    can often get out of control, since we cannot be checking each line of code. In
    this chapter, you will learn about the lints Rust brings us, both the ones enabled
    by default and the ones you can enable yourself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要自己检查代码的所有细节。这往往难以控制，因为我们无法检查每一行代码。在本章中，你将了解 Rust 带给我们的 lint，包括默认启用的和你可以自己启用的。
- en: Moreover, you will learn about a great tool, Clippy, that will give you many
    more lints you can use, and that can help you write much better code. In many
    cases, it will lint about performance pitfalls. In other cases, they will be potential
    errors or idiomatic conventions. It will also help you clean your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将了解一个伟大的工具 Clippy，它将为你提供更多可用的 lint，并帮助你编写更好的代码。在许多情况下，它会对性能陷阱进行 lint。在其他情况下，它们将是潜在的错误或惯用约定。它还将帮助你清理代码。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Linting in Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 中的 linting
- en: Default lints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认 lint
- en: Using and configuring Clippy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和配置 Clippy
- en: Extra Clippy lints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的 Clippy lint
- en: Using Rust compiler lints
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 编译器 lint
- en: The Rust compiler, at the time of writing, has 70 lints. We will not check all
    70, but we will take a look at the most relevant ones. Let's first start by learning
    how to configure a lint. We will take `unused_imports` as an example. The compiler
    will warn you for this lint by default. The compilation will continue, but it
    will show a warning in the command line, or in the editor if it's configured to
    show Rust compilation warnings.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Rust 编译器有 70 个 lint。我们不会检查所有 70 个，但我们会查看其中最相关的几个。让我们首先从学习如何配置 lint 开始。我们将以
    `unused_imports` 为例。默认情况下，编译器会为此 lint 提醒你。编译将继续，但会在命令行中显示警告，或者在配置了显示 Rust 编译器警告的编辑器中显示。
- en: We can change this behavior, and we can change it for each scope. The options
    are `allow`, `warn`, `deny`, and `forbid` the lint. If we allow the lint, no more
    warnings will appear. If we warn, compilation warnings will appear, and if we
    deny or forbid, the program won't compile if it finds something that triggers
    the lint. The difference between `deny` and `forbid` is that the former can be
    overridden down the line, while the latter can't. So we can have a module that
    denies one behavior, but in one particular function, we want to allow it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改变这种行为，并且我们可以为每个作用域改变它。选项是 `allow`、`warn`、`deny` 和 `forbid` lint。如果我们允许
    lint，则不会出现更多警告。如果我们警告，则编译时会出现警告，如果我们拒绝或禁止，如果找到触发 lint 的内容，程序将无法编译。`deny` 和 `forbid`
    之间的区别在于前者可以在后续被覆盖，而后者则不能。因此，我们可以有一个拒绝一种行为的模块，但在一个特定的函数中，我们希望允许它。
- en: This configuration can be applied at crate level, by putting  `#![deny(unused_imports)]`,
    for example, at the top of the `lib.rs` or `main.rs` file. It can also be applied
    to any scope, even scopes you might create inside functions. If it has an exclamation
    mark (`!`) after the hash, it will affect the current scope; if not, it will affect
    the scope just next to it. Let's see what lints the Rust compiler gives us.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置可以在 crate 级别应用，例如，在 `lib.rs` 或 `main.rs` 文件的顶部放置 `#![deny(unused_imports)]`。它也可以应用于任何作用域，甚至是你可能在函数内部创建的作用域。如果它在
    hash 后面有一个感叹号（`!`），它将影响当前作用域；如果没有，它将影响紧邻的作用域。让我们看看 Rust 编译器提供了哪些 lint。
- en: Lints
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lint
- en: In this section, we will check the lints that allow the behavior by default,
    and that you will probably want to add at least a warning for in most cases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查允许默认行为的 lint，你可能会在大多数情况下至少添加一个警告。
- en: Avoiding anonymous parameters
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免匿名参数
- en: 'Anonymous parameters have been deprecated. This allowed you to specify traits
    without requiring binding names in traits:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名参数已被弃用。这允许你在不要求在 traits 中绑定名称的情况下指定 traits：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a deprecated legacy feature that might get removed in future versions,
    so you should probably avoid using this syntax. In order to warn or deny this
    syntax in your code base, you will need to use this syntax: `#![warn(anonymous_parameters)]`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个已弃用的遗留功能，可能在未来的版本中被移除，所以你可能应该避免使用这种语法。为了在你的代码库中警告或拒绝这种语法，你需要使用以下语法：`#![warn(anonymous_parameters)]`。
- en: Avoiding heap allocated box pointers
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免堆分配的 box 指针
- en: Rust allocates space in the stack by default, since it's much faster than using
    the heap. Nevertheless, sometimes, when we do not know the size of objects at
    compile time, we need to use the heap to allocate new structures. Rust makes this
    explicit by using the `Vec`, `String`, and `Box` types, for example. The last
    one allows us to put in the heap any kind of object, which is usually a bad idea,
    but sometimes it's a must.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rust默认在栈上分配空间，因为它比使用堆快得多。尽管如此，有时，当我们不知道对象的大小在编译时，我们需要使用堆来分配新的结构体。Rust通过使用`Vec`、`String`和`Box`等类型来明确这一点。最后一个允许我们将任何类型的对象放入堆中，这通常是一个坏主意，但有时这是必需的。
- en: 'Check out, for example, the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看以下代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code compiles perfectly, and it tells us that the integer is `10 (5 + 5)`.
    The main issue with this is that it does a heap allocation, doing a system call
    that needs to find the space in the heap and so on. But we already know that an
    integer has a fixed size at compile time, so we should be using the stack for
    this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码编译得非常完美，它告诉我们整数是`10 (5 + 5)`。这个问题的主要问题是它执行了堆分配，进行了一个需要找到堆中空间的系统调用等。但我们已经知道整数在编译时具有固定的大小，所以我们应该使用栈来完成这个操作。
- en: 'These kinds of errors can be avoided by warning every `Box` usage using `#![warn(box_pointers)]`.
    But beware: this will warn every usage of a boxed type, so you probably want to
    allow this in many places explicitly.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`#![warn(box_pointers)]`警告每个`Box`的使用，可以避免这类错误。但请注意：这将警告所有boxed类型的用法，所以你可能希望在许多地方明确允许它。
- en: Avoiding missing implementations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免缺失的实现
- en: There are a couple of traits we probably want many of our types to implement.
    The first of them is the `Debug` trait. The `Debug` trait should probably be implemented
    by all of our types, since it enables a developer to print debug information about
    our structures, enumerations, and so on. Moreover, it allows a user of our API
    to derive the `Debug` trait in structures using our API types by only adding an
    attribute.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望许多类型实现一些特性。其中第一个是`Debug`特性。`Debug`特性可能应该由我们所有的类型实现，因为它使得开发者能够打印出关于我们的结构体、枚举等调试信息。此外，它还允许API用户通过仅添加一个属性，使用我们的API类型在结构体中推导出`Debug`特性。
- en: We can enforce the implementation of this trait for all of our types by adding
    `#![warn(missing_debug_implementations)]`. The only detail is that this trait
    will only check for types exposed in our API. So, it will only work for `pub`
    types.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`#![warn(missing_debug_implementations)]`来强制实现这个特性对所有我们的类型。唯一的细节是，这个特性将只检查API中暴露的类型。所以，它只适用于`pub`类型。
- en: 'Another interesting trait is the `Copy` trait. Sometimes, we create a small
    structure with a couple of integers that would work best if copied in certain
    cases, as we saw in the previous chapters. The problem is that if we forget about
    implementing it, we might end up doing excessive referencing, making our code
    slower. We can solve this by adding this lint: `#![warn(missing_copy_implementations)]`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的特性是`Copy`特性。有时，我们会创建一个包含几个整数的简单结构体，在某些情况下最好是通过复制来实现，正如我们在前面的章节中看到的。问题是如果我们忘记实现它，我们可能会进行过多的引用，使我们的代码变慢。我们可以通过添加这个lint来解决：`#![warn(missing_copy_implementations)]`。
- en: This lint has a couple of caveats though. It will only work for `pub` types,
    as in the case for the `Debug` implementation lint, and it will lint all structures
    that all of its members are `Copy` types. This means that if we have a really
    big structure that we wouldn't like to copy around, we will need to allow the
    lint for that particular structure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个lint有几个限制。它只适用于`pub`类型，就像`Debug`实现lint的情况一样，并且它会lint所有所有成员都是`Copy`类型的结构体。这意味着如果我们有一个非常大的结构体，我们不想复制它，我们可能需要为该特定结构体允许这个lint。
- en: Enforcing documentation
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制文档
- en: This is arguably the most important lint of all, and it's a pity that it's `allow`
    by default. Whenever we create an API, we must document what the API does. This
    will make it much, much easier for new developers to use it. The `#![warn(missing_docs)]`
    lint will make sure that at least all of your public API has some documentation.
    I personally usually have this as a warning during the development and change
    it to `deny` or even `forbid` once the project enters into production.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以说是最重要的lint，遗憾的是它默认是`allow`。每当创建一个API时，我们必须记录API的功能。这将使新开发者更容易使用它。`#![warn(missing_docs)]`
    lint将确保至少所有公共API都有一些文档。我个人通常在开发期间将其设置为警告，一旦项目进入生产阶段，就将其更改为`deny`甚至`forbid`。
- en: Pointing out trivial casts
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指出平凡的转换
- en: 'Sometimes, we might explicitly cast an element to a type that the compiler
    should cast automatically. This sometimes happens when we use traits, but it can
    also happen because we changed the type of an element to a new type and we didn''t
    change the castings. To clean these kinds of behavior, we have the `trivial_casts`
    and `trivial_numeric_casts` lints. Let''s see it as an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会明确地将一个元素转换为编译器应该自动转换的类型。这通常发生在我们使用特质时，但也可能是因为我们将一个元素的类型更改为新类型，而没有更改转换。为了清理这类行为，我们有`trivial_casts`和`trivial_numeric_casts`代码审查。让我们用一个例子来看看：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we first cast `test` as a `MyStruct`, but it's already a `MyStruct`,
    so this is redundant and makes the code much less readable, and in consequence,
    more error-prone. Then we cast its `a` attribute as an `i32`, but it's already
    an `i32`, so once again, redundant information. The first is not common, but the
    second could be found if we use this parameter for a function that only accepts
    an `i32`, and our structure had `i16` in a previous implementation, for example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们首先将`test`转换为`MyStruct`，但它已经是`MyStruct`了，所以这是多余的，并且使代码的可读性大大降低，从而增加了出错的可能性。然后我们将它的`a`属性转换为`i32`，但它已经是`i32`了，所以再次是冗余信息。第一种情况不常见，但第二种情况如果我们将这个参数用于只接受`i32`的函数，并且我们的结构在之前的实现中包含`i16`，例如，可能会被发现。
- en: In any case, these kinds of castings are not good practice, since it could be
    that we had changed the `a` attribute for an `i64`, and we would be silently losing
    precision. We should use `i32::from()` so that if we change it for an `i64`, it
    will simply stop compiling. This gets automatically linted with the Clippy tool
    we will see later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，这类铸造都不是好的实践，因为我们可能已经将`a`属性从`i64`更改为`i32`，并且我们会在无声中丢失精度。我们应该使用`i32::from()`，这样如果我们将它更改为`i64`，它将简单地停止编译。这将在我们稍后看到的Clippy工具中自动进行代码审查。
- en: It is a good idea to enable these two lints anyway, since it will help us find
    these kinds of errors. The `trivial_casts` lint will lint us for non-numeric type/trait
    casts, while `trivial_numeric_casts` will lint the numeric casts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，启用这两个代码审查是个好主意，因为它将帮助我们找到这类错误。`trivial_casts`代码审查会审查非数值类型/特质的转换，而`trivial_numeric_casts`将审查数值转换。
- en: Linting unsafe code blocks
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查不可安全代码块
- en: In some situations, especially if we are using extremely low-level programming,
    sometimes used for high-performance computing, we will need to perform some pointer
    arithmetics or even **Single Instruction, Multiple Data** (**SIMD**) intrinsics
    that will require unsafe scopes. This might be the case in some specific functions
    or pieces of code, but in general, we should avoid unsafe scopes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，特别是如果我们使用的是极低级别的编程，有时用于高性能计算，我们可能需要进行一些指针算术，甚至**单指令多数据**（**SIMD**）内联，这需要不可安全的作用域。这可能在某些特定的函数或代码片段中是这种情况，但一般来说，我们应该避免不可安全的作用域。
- en: 'A rule of thumb is this: if you are not working on performance-critical code,
    do not use them. If you are, use them very carefully and only in places where
    there is no other option to improve performance. This means that usually intrinsic
    code can be wrapped in one module or function.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是这样的：如果你不是在处理性能关键代码，不要使用它们。如果你是，请非常小心地使用，并且只在没有其他改进性能的选项的地方使用。这意味着通常内联代码可以封装在一个模块或函数中。
- en: 'To make sure nobody uses unsafe code outside the scope where we want it to
    be shown, we can lint all unsafe scopes by using the `unsafe_code` lint. Let''s
    see it as an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保没有人使用我们希望在显示范围之外使用的不可安全代码，我们可以使用`unsafe_code`代码审查来审查所有不可安全的作用域。让我们用一个例子来看看：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you remember from [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml),
    *Common Performance Pitfalls*, the `get_unchecked()` function in a slice will
    get the element at the given index without checking the bounds of the slice, making
    it go faster. This also means that if the index is out of bounds, you could get
    from a memory leak to a segmentation fault.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第1章](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml)中的*常见性能陷阱*，切片中的`get_unchecked()`函数将获取给定索引处的元素，而不会检查切片的边界，这使得它运行得更快。这也意味着如果索引超出范围，你可能会从内存泄漏到段错误。
- en: 'In this example, when compiling this piece of code, a warning will tell us
    that we are using unsafe code. We can allow it for this particular function if
    it''s 100% required, or we can change the code. An example fixing the issue above
    while still using unsafe code can be seen here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当编译这段代码时，一个警告会告诉我们我们正在使用不可安全代码。如果它对于这个特定的函数是100%必需的，我们可以允许它，或者我们可以更改代码。一个修复上述问题同时仍然使用不可安全代码的例子可以在这里看到：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the crate won't compile if we add an unsafe scope outside the
    `get_second()` function. In any case, this function is not safe, as it will not
    check any bounds of the slice being sent to it; we should probably add an `assert!()`,
    or at least a `debug_assert!()`, to the length of the slice at the beginning of
    the function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果我们将不安全的范围添加到`get_second()`函数外部，crate将无法编译。无论如何，这个函数是不安全的，因为它不会检查发送给它的切片的任何边界；我们可能应该在函数开始时添加一个`assert!()`，或者至少一个`debug_assert!()`，来检查切片的长度。
- en: Unused lints
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未使用的代码风格检查
- en: Let's face it, we sometimes forget to remove a dependency we are no longer using,
    or we forget that the `write()` method returns the number of bytes written. This
    usually is not a big deal. The first will simply make our compilation slower,
    while the second, in most cases, will simply not change our code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实地讲，我们有时会忘记移除不再使用的依赖项，或者忘记`write()`方法返回写入的字节数。这通常不是什么大问题。第一个只会使我们的编译速度变慢，而第二个，在大多数情况下，将不会改变我们的代码。
- en: But since we do not want to have unused dependencies, or we don't want to forget
    that we might not have written the whole buffer to a file, that's where the next
    lints come to help us. Let's start with the first one, the `unused_extern_crates`
    lint. This lint will mark the external crates that are not being used in our code.
    This can be useful to remove dependencies we are no longer using, so I usually
    configure it to `warn` while I'm starting the development and change it to `forbid`
    once my crates go to production or the dependencies are not changing in every
    commit.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于我们不希望有未使用的依赖项，或者我们不希望忘记我们可能没有将整个缓冲区写入文件，这就是下一个代码风格检查帮助我们的地方。让我们从第一个开始，即`unused_extern_crates`代码风格检查。这个代码风格检查将标记未在我们的代码中使用的外部crate。这可以用来移除不再使用的依赖项，所以我通常在开始开发时将其配置为`warn`，一旦我的crate进入生产或依赖项在每次提交中都没有变化，就将其更改为`forbid`。
- en: The second lint you should know about is the `unused_results` lint. By default,
    the compiler will warn about unused results for `Result<T, E>` return values.
    That is an important detail because it could be that an I/O operation failed,
    for example, and you should act accordingly. There are other cases, though, where
    the Rust compiler won't warn, but that can be almost as dangerous as the previous
    ones. The `Write` and `Read` traits, for example, will return the number of bytes
    written and read, respectively, and you should probably be aware of that number.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解的第二个代码风格检查是`unused_results`。默认情况下，编译器将警告`Result<T, E>`返回值中未使用的返回值。这是一个重要的细节，因为可能是一个I/O操作失败了，例如，你应该相应地采取行动。尽管如此，还有其他情况下Rust编译器不会警告，但这可能和之前的一样危险。例如，`Write`和`Read`特质分别返回写入和读取的字节数，你应该可能对此数字有所了解。
- en: 'This lint will make sure you always take into account any return value, except
    for the empty tuple `()`. This can sometimes be annoying, but you can explicitly
    discard a result by using the underscore binding, which is shown as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码风格检查将确保你始终考虑任何返回值，除了空元组`()`。这有时可能有些烦人，但你可以通过使用下划线绑定显式地丢弃结果，如下所示：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are also a couple of lints that will make your code much more readable:
    `unused_qualifications` and `unused_import_braces`. The first will detect places
    where you are using extra qualifications for some elements:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些代码风格检查可以使你的代码更加易于阅读：`unused_qualifications`和`unused_import_braces`。第一个将检测你为某些元素使用额外限定符的地方：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example of code will warn us that in the first `println!()` we do not need
    to use the `Test::` qualification, as we are already importing all values inside
    the `Test` enumeration. The second `println!()` will not warn us since we are
    not specifying any extra qualifications. This will make the code more readable,
    potentially reducing errors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例将警告我们在第一个`println!()`中不需要使用`Test::`限定符，因为我们已经导入了`Test`枚举中的所有值。第二个`println!()`不会警告我们，因为我们没有指定任何额外的限定符。这将使代码更易于阅读，可能减少错误。
- en: 'The second lint, the `unused_import_braces` lint, will check for places where
    we are importing only one element with import braces:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码风格检查，`unused_import_braces`，将检查我们只使用导入花括号导入一个元素的地方：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even though the Rust formatter will automatically remove the braces around the
    C variant of the `Test2` import, if we do not use the formatter, this is an interesting
    lint that will alert that we do not require those braces and that removing them
    we will make the code cleaner.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Rust 格式化器会自动移除 `Test2` 导入的 C 变体的括号，如果我们不使用格式化器，这是一个有趣的 lint，会提醒我们不需要这些括号，并且移除它们会使代码更简洁。
- en: Variant size differences
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变体大小差异
- en: 'As we saw in the previous chapters, the size of an enumeration will be the
    size of the biggest element plus the tag, but, as we discussed, this can be troublesome
    if we have many small variants and one has a bigger size: all variants will occupy
    the whole space for the biggest one. We saw that an option would be to move the
    big variant to a heap allocation.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，枚举的大小将是最大元素的大小加上标签，但是，正如我们讨论的，如果我们有很多小的变体，而其中一个变体的大小更大，这可能会很麻烦：所有变体都将占用最大变体的整个空间。我们看到一个选择是将大变体移动到堆分配。
- en: 'We can detect enumerations with variants significantly bigger than the rest
    with the `variant_size_differences` lint. It will check for enumerations where
    a variant is at least three times bigger than the rest:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `variant_size_differences` lint 来检测具有明显大于其他变体的枚举。它将检查至少有三个倍数大于其他变体的枚举：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that it will not work for unions and that if we have middle-sized variants,
    even if the difference between the biggest one and the smallest one is more than
    three times, the lint will not alert us.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它不适用于联合，并且如果我们有中等大小的变体，即使最大变体和最小变体之间的差异超过三倍，lint 也不会提醒我们。
- en: Lint groups
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lint 组
- en: The Rust compiler lets us configure some of the aforementioned lints in groups.
    For example, the `unused` group will contain many of the `unused_` kind of lints.
    The `warnings` group will contain all the lints that have been configured to warn,
    and so on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器允许我们按组配置一些上述 lint。例如，`unused` 组将包含许多 `unused_` 类型的 lint。`warnings` 组将包含所有被配置为警告的
    lint，等等。
- en: 'Lint groups can be used the same way as lints, by specifying what you want
    to happen when the compiler catches that behavior:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Lint 组可以使用与 lint 相同的方式使用，通过指定当编译器捕获到该行为时你希望发生什么：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can check out the rest of the built-in lints by running `rustc -W help`.
    It will show the ones we have talked about and the other lints that are `warn`
    or `deny` by default.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行 `rustc -W help` 来查看其余的内置 lint。它将显示我们讨论过的 lint 以及默认情况下会警告或拒绝的其他 lint。
- en: Clippy
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clippy
- en: If there is a tool that will help you sanitize your code the most, it is Clippy.
    At the time of writing, Clippy provides 208 extra lints, most of them really useful
    to avoid interesting pitfalls such as the `unwrap_or()` usage that we discussed
    in [Chapter 2](da2d0480-3314-408b-9cad-60987754f45d.xhtml), *Extra Performance
    Enhancements*, or to avoid non-idiomatic code. Of course, we will not see all
    of them here, and you will find a comprehensive list of all of them in the Clippy
    lint documentation at [https://rust-lang-nursery.github.io/rust-clippy/master/.](https://rust-lang-nursery.github.io/rust-clippy/master/)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个工具能帮助你最大程度地清理你的代码，那就是 Clippy。在撰写本文时，Clippy 提供了 208 个额外的 lint，其中大多数都非常有用，可以避免一些有趣的陷阱，例如我们在[第
    2 章](da2d0480-3314-408b-9cad-60987754f45d.xhtml)“额外的性能提升”中讨论的 `unwrap_or()` 使用，或者避免非惯用代码。当然，我们在这里不会看到所有这些，你可以在
    Clippy lint 文档的[https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/)中找到它们的完整列表。
- en: Since many of them already warn or even deny by default, we will check some
    of the ones that are allowed by default but that could be really useful to improve
    the code quality of your application and even its performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其中许多默认情况下会警告甚至拒绝，我们将检查一些默认允许但实际上可以极大地提高你的应用程序代码质量甚至性能的 lint。
- en: Installation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Installing Clippy is pretty easy: you will need to install Rust nightly by
    running `rustup toolchain install nightly`, then you can install Clippy by running
    `cargo +nightly install clippy`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Clippy 非常简单：你需要通过运行 `rustup toolchain install nightly` 来安装 Rust 夜间版本，然后你可以通过运行
    `cargo +nightly install clippy` 来安装 Clippy。
- en: 'Note that since Clippy requires a nightly compiler to build, and since it uses
    compiler intrinsics, some Rust nightly compiler updates make it unusable. Those
    issues are usually fixed in a couple of days and a new Clippy version gets released,
    but meanwhile, you can select a previous nightly version by appending a previous
    date to the nightly toolchain: `rustup toolchain install nightly-YYYY-MM-DD`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 Clippy 需要使用 nightly 编译器来构建，并且它使用编译器内建函数，一些 Rust nightly 编译器的更新可能会使其无法使用。这些问题通常在几天内得到修复，并且会发布一个新的
    Clippy 版本，但在此期间，你可以通过向 nightly 工具链添加一个以前的日期来选择以前的 nightly 版本：`rustup toolchain
    install nightly-YYYY-MM-DD`。
- en: Once the correct toolchain is installed, Clippy will be installed perfectly.
    To use it, you will need to go to your project and run `cargo clippy` instead
    of the usual `cargo check` or `cargo build` commands. This will run all Clippy
    lints and show you the results.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了正确的工具链，Clippy 将会完美安装。要使用它，你需要进入你的项目并运行 `cargo clippy` 命令，而不是通常的 `cargo
    check` 或 `cargo build` 命令。这将运行所有 Clippy 检查并显示结果。
- en: Configuration
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: Even if we will check individual lints in the next section, we will now see
    how we can configure the whole Clippy execution. Clippy will read the `clippy.toml`
    file at the same level as the `Cargo.toml` file and act accordingly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在下一节将检查单个检查，我们现在将看到如何配置整个 Clippy 执行。Clippy 将读取与 `Cargo.toml` 文件同一级别的 `clippy.toml`
    文件并根据其内容执行。
- en: Some lints have configuration parameters. For instance, the cyclomatic complexity
    lint will alert you whenever a function has more than 25 branches. As we saw in
    [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml), *Common Performance Pitfalls*,
    this is bad practice, since it will make the optimizations of the code much harder
    for the compiler, creating less performant code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些检查具有配置参数。例如，循环复杂度检查会在函数有超过 25 个分支时提醒你。正如我们在 [第 1 章](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml)
    中看到的，*常见性能陷阱*，这是不好的做法，因为它会使编译器对代码的优化变得更加困难，从而产生性能较差的代码。
- en: 'However, you can change the threshold that creates the warning. 25 is a fair
    amount of branches, but depending on your product, you would prefer not to have
    more than 20 branches or to be able to have up to 30, for example. The setting
    that changes this behavior in the `clippy.toml` is the `cyclomatic-complexity-threshold`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以更改创建警告的阈值。25 个分支是一个合理的数量，但根据你的产品，你可能希望不超过 20 个分支，或者能够达到 30 个分支，例如。在 `clippy.toml`
    中更改此行为的设置是 `cyclomatic-complexity-threshold`：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Clippy will also warn you, for example, when it finds names that could be the
    name of a structure or enumeration in the documentation without the proper (``
    ` ``) characters showing that they are code. This can have false positives in
    cases such as your software being called `MyCompanyInc`, for example, where Clippy
    will think it's a `struct` or an `enum`. There is a configuration parameter for
    this case too. You can check all of them in the Clippy wiki at [https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当 Clippy 发现文档中缺少适当（`` ` ``）字符来显示它们是代码的结构或枚举名称时，它也会警告你。例如，如果你的软件被命名为 `MyCompanyInc`，Clippy
    会认为它是一个 `struct` 或一个 `enum`。对于这种情况也有配置参数。你可以在 Clippy 维基页面上检查所有这些配置：[https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/)。
- en: 'If we want to add Clippy lints to our project, when we compile without Clippy,
    Rust will warn us that those lints are unknown. Of course, those have been defined
    by Clippy, but the compiler does not know this. Clippy sets a `cargo-clippy` feature
    by default, and when configuring the lints, we can use it to remove the unknown
    lints warning:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在项目中添加 Clippy 检查，当我们不使用 Clippy 编译时，Rust 会警告我们那些检查是未知的。当然，这些是由 Clippy 定义的，但编译器并不知道这一点。Clippy
    默认设置了一个 `cargo-clippy` 功能，当配置检查时，我们可以使用它来消除未知检查的警告：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This way, when we run `cargo clippy`, the lint will be taken into account, but
    when running `cargo check`, it won't.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们运行 `cargo clippy` 时，检查将被考虑，但在运行 `cargo check` 时则不会。
- en: Lints
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查
- en: From those 208 lints currently available in Clippy, we will analyze only some
    of them that are configured as `allow` by default. The rest can be checked at
    the Clippy wiki at [https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/),
    but you should take note of these ones, since they will not show an alert by default.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clippy目前可用的208个lints中，我们将仅分析那些默认配置为`allow`的一些。其余的可以在Clippy wiki上检查[https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/)，但你应该注意这些，因为它们默认不会显示警报。
- en: Casting
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影
- en: Casting numbers is sometimes a dangerous operation. We could lose precision,
    lose sign, truncate numbers, and so on. Clippy gives us some very useful lints
    that can avoid these situations. Of course, often you do not care about these
    behaviors since you might know they won't happen or they could be intended behavior.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 投影数字有时是一项危险的操作。我们可能会丢失精度，丢失符号，截断数字等等。Clippy为我们提供了一些非常有用的lints，可以避免这些情况。当然，通常你并不关心这些行为，因为你可能知道它们不会发生，或者它们可能是预期的行为。
- en: Nevertheless, I have found these lints useful even if you only activate them
    on one occasion to check the places where these casts take place and set them
    to allow by default when usual testing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我发现即使只激活一次以检查这些cast发生的地方并将它们设置为默认允许，这些lints也是有用的。
- en: 'The lints are the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些lints如下：
- en: '`cast_possible_truncation`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cast_possible_truncation`'
- en: '`cast_possible_wrap`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cast_possible_wrap`'
- en: '`cast_precision_loss`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cast_precision_loss`'
- en: '`cast_sign_loss`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cast_sign_loss`'
- en: Bad practice
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不良实践
- en: Clippy also gives us lints that will detect bad coding practices. You should,
    for example, not import enumeration variants, since enumeration variants should
    always be prefixed with the actual enumeration. To lint against this practice,
    you can use the `enum_glob_use` lint.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Clippy还提供了可以检测不良编码实践的lints。例如，你不应该导入枚举变体，因为枚举变体应该始终以实际的枚举为前缀。为了对此实践进行lint，你可以使用`enum_glob_use`
    lint。
- en: Other code practices that might create issues are the panicking `From` and `Into`
    trait implementations. By definition, these traits must never fail, and using
    `unwrap()`, `expect()`, `panic!()`, or `assert!()` functions and macros can panic
    the function. This can be the desired behavior in an application, even though
    it's bad practice (you should use `TryInto` and `TryFrom` traits, or create a
    new function if developing with the stable compiler).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会引发问题的其他代码实践是`From`和`Into`特质的恐慌实现。根据定义，这些特质永远不应该失败，使用`unwrap()`、`expect()`、`panic!()`或`assert!()`函数和宏可能会使函数恐慌。尽管这可能是应用程序中期望的行为，但这是一种不良实践（你应该使用`TryInto`和`TryFrom`特质，或者在稳定编译器开发时创建一个新函数）。
- en: But the main issue is when developing software such as kernels that could cause
    the whole OS to panic. You can detect these issues by using the `fallible_impl_from`
    lint.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但主要问题是当开发可能导致整个操作系统恐慌的软件，如内核时。你可以通过使用`fallible_impl_from` lint来检测这些问题。
- en: We talked about iterators in [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml), *Common
    Performance Pitfalls*, and as we saw, we sometimes have useful functions to wrap
    `filter()` and `map()`. This improves readability, and concatenations of these
    functions can be detected by using the `filter_map` lint.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml)，“常见性能陷阱”中讨论了迭代器，我们看到，我们有时有有用的函数来包装`filter()`和`map()`。这提高了可读性，并且可以使用`filter_map`
    lint来检测这些函数的连接。
- en: 'Sometimes, we write conditionals that might not be straightforward to understand,
    sometimes because we do negations in conditions with `else` branches or because
    we add lots of conditions that mess up our comparisons. We have two Clippy lints
    that will point out these situations: `if_not_else` and `nonminimal_bool`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们编写的条件可能不容易理解，有时是因为我们在带有`else`分支的条件中使用否定，或者是因为我们添加了太多的条件，这会搞乱我们的比较。我们有两个Clippy
    lint会指出这些情况：`if_not_else`和`nonminimal_bool`。
- en: The first will detect a negation in a conditional, and suggest changing the
    condition to a positive one and changing the `else` and the `if` code sections.
    The second will check for Booleans that can be simplified to remove redundancy
    and clean up the code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将检测条件中的否定，并建议将条件改为正条件，并更改`else`和`if`代码部分。第二个将检查可以简化以去除冗余并清理代码的布尔值。
- en: Some `match` statements can also be improved when there are only two branches
    and one of them does not require any parameters, such as when dealing with `Option`
    types. In this case, it's cleaner to change them for an `if let` expression with
    an `else` that will also reduce the indenting of the comparison. These points
    of failure can be shown by using the `single_match_else` lint.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有两个分支且其中一个不需要任何参数时，例如处理`Option`类型时，一些`match`语句也可以得到改进。在这种情况下，将它们改为带有`else`的`if
    let`表达式会更简洁，这也会减少比较的缩进。这些失败点可以通过使用`single_match_else` lint来显示。
- en: 'Another interesting couple of lints will check for places where you might be
    adding `1` to an integer just to make comparisons or ranges inclusive. Let''s
    see an example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个有趣的lint会检查你可能只是为了使比较或范围包含而向整数添加`1`的地方。让我们看看一个例子：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That code only adds `1` to be able to print the `10` too. You can create an
    inclusive range of nightly Rust by using an equals symbol after the two range
    periods (`..=`):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码只加`1`是为了能够打印出`10`。你可以通过在两个范围符号之后使用等号（`..=`）来创建nightly Rust的包含范围：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The lint that will point out this error is called `range_plus_one`, while the
    one that will detect comparisons such as `a < b+1`, that can be replaced by `a
    <= b`, is called `int_plus_one`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 指出这种错误的lint叫做`range_plus_one`，而用于检测诸如`a < b+1`这样的比较，这些比较可以用`a <= b`来替换的lint叫做`int_plus_one`。
- en: There are also times where we might change the name of a variable or misspell
    it and break our code, even if it seems to compile. Other times, we might create
    variables with too similar names and end up mixing them up. This can be avoided
    by using the `similar_names` lint.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 也有时候，我们可能会更改变量的名称或拼错它，从而破坏我们的代码，即使它看起来可以编译。其他时候，我们可能会创建名称过于相似的变量，最终将它们混淆。这可以通过使用`similar_names`
    lint来避免。
- en: Another bad practice is to include the name of an enumeration in a variant of
    the enumeration, or a structure containing the name of the current module. Since
    names can be qualified, repetition is not required and adds a lot of text. This
    will be warned by default, but not in public APIs. You can control that with the
    `stutter` and the `pub_enum_variant_names` lints.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个坏习惯是将枚举的名称包含在枚举的变体中，或者包含当前模块名称的结构中。由于名称可以有资格，因此不需要重复，这会增加很多文本。这默认会发出警告，但在公共API中不会。你可以通过`stutter`和`pub_enum_variant_names`
    lint来控制这一点。
- en: Finally, the same way the Rust compiler gave us a `missing_docs` lint that would
    point out missing public documentation, the `missing_docs_in_private_items` Clippy
    lint will do the same for private items. This is great to enforce documentation
    of the whole code base.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像Rust编译器给了我们一个`missing_docs` lint来指出缺失的公共文档一样，`missing_docs_in_private_items`
    Clippy lint也会对私有项做同样的事情。这对于强制整个代码库的文档化来说是非常好的。
- en: Performance lints
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能lint
- en: 'If you are reading this book, these two lints will probably be the ones you
    will find more important than the ones Clippy does not warn by default. The first
    is pretty simple: if you want to share an integer between threads, using a `Mutex`
    is a really bad idea if you do not need to use it as a synchronization variable.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，这两条lint可能比Clippy默认不警告的lint更重要。第一条相当简单：如果你想在多个线程之间共享一个整数，而你不需要将其用作同步变量时，使用`Mutex`是一个非常糟糕的主意。
- en: Usually, things such as counters will be much faster by using atomic types.
    Only pointer-sized atomics and booleans are stable at the time of writing, but
    the rest are also coming and can now be used in nightly Rust. You can spot this
    issue with the `mutex_integer` lint.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用原子类型的事物，如计数器，会快得多。在撰写本文时，只有指针大小的原子和布尔值是稳定的，但其余的也在路上，现在可以在nightly Rust中使用。你可以通过`mutex_integer`
    lint来发现这个问题。
- en: Also, you might be tempted to use `std::mem::forget()` to enable sending data
    to C APIs, or to be able to do some strange memory tricks. This can be fine (even
    though it can lead to memory leaks), but can sometimes prevent running destructors.
    If you want to make sure that your `Drop` types never get forgotten, use the `mem_forget`
    lint.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能会被诱惑使用`std::mem::forget()`来启用向C API发送数据，或者能够做一些奇怪的内存技巧。这可能是可以的（尽管它可能导致内存泄漏），但有时会阻止运行析构函数。如果你想确保你的`Drop`类型永远不会被遗忘，请使用`mem_forget`
    lint。
- en: If you are worried about infinite iterators that could hang your applications,
    you should use the `maybe_infinite_iter` lint, which will find those. It will
    not detect stopping conditions, so it could show too many false positives.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心无限迭代器可能会挂起你的应用程序，你应该使用 `maybe_infinite_iter` 检查项，它会找到这些迭代器。它不会检测停止条件，因此可能会显示过多的误报。
- en: We might also find ourselves adding debug information when developing by using
    `print!()` macros and debug formatting. Once the application goes into production,
    a good way to avoid these logs staying in the code base is to use the `print_stdout`
    and `use_debug` lints.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们可能会使用 `print!()` 宏和调试格式添加调试信息。一旦应用程序进入生产环境，避免这些日志留在代码库中的好方法就是使用 `print_stdout`
    和 `use_debug` 检查。
- en: Unwraps
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解包
- en: Rust allows you to unwrap `Result`s and `Option`s, at the cost of panicking
    if they are `Err(_)` or `None` respectively. This should be avoided in any production
    code, and either use `expect()` to add an information message or use error chaining
    with the `?` operator, for example. You can also match them and control the error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许你解包 `Result`s 和 `Option`s，但代价是如果它们分别是 `Err(_)` 或 `None`，则会引发恐慌。在任何生产代码中都应该避免这样做，可以使用
    `expect()` 添加信息消息，或者使用带有 `?` 操作符的错误链，例如。你也可以对它们进行匹配并控制错误。
- en: To avoid those unnecessary panics, you can use the `result_unwrap_used`, `option_unwrap_used`,
    `option_map_unwrap_or_else`, `option_map_unwrap_or`, and `result_map_unwrap_or_else`
    lints.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些不必要的恐慌，你可以使用 `result_unwrap_used`、`option_unwrap_used`、`option_map_unwrap_or_else`、`option_map_unwrap_or`
    和 `result_map_unwrap_or_else` 检查项。
- en: Shadowing
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖
- en: In Rust, you can shadow a variable by creating another `let` binding with the
    same name. This is usually okay, except when we maybe only wanted to mutate a
    variable, for example. In general, you should avoid this practice and only use
    it where it helps readability.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，你可以通过创建另一个具有相同名称的 `let` 绑定来覆盖一个变量。这通常是可以接受的，除非我们可能只想修改一个变量，例如。一般来说，你应该避免这种做法，只在有助于可读性的情况下使用它。
- en: You can use the `shadow_unrelated`, `shadow_same`, and `shadow_reuse` lints
    and warn this behavior by default, then allow it for specific situations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `shadow_unrelated`、`shadow_same` 和 `shadow_reuse` 检查项，并默认警告这种行为，然后在特定情况下允许它。
- en: Integer overflow
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数溢出
- en: Sometimes, when we do operations with integers, we do not take overflows, underflows,
    and wrappings into account. C will let you do this by default, while Rust will
    panic when running in debug mode. In release mode, though, these integer overflows
    can be a big problem.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们对整数进行操作时，我们没有考虑到溢出、下溢和覆盖。C 语言默认允许这样做，而 Rust 在调试模式下运行时会引发恐慌。然而，在发布模式下，这些整数溢出可能成为一个大问题。
- en: You can use the `integer_arithmetic` lint that will suggest using one of the
    `wrapping_...()` or `saturating_...()` methods of the integer to make sure you
    know what the outcomes of the operation are.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `integer_arithmetic` 检查项，它会建议使用 `wrapping_...()` 或 `saturating_...()`
    方法之一，以确保你知道操作的结果。
- en: Lint groups
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查项组
- en: There are two lint groups in Clippy. The `clippy` lint group will control all
    the lints that warn by default, and you can, for example, deny all of them. The
    `clippy_pedantic` group will control the rest of the lints as a group, but making
    all of them warn, for example, will make your compilation results full of warnings,
    due to false positives.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Clippy 中有两个检查项组。`clippy` 检查项组将控制默认警告的所有检查项，例如，你可以拒绝所有这些检查项。`clippy_pedantic`
    组将作为一个组控制其余的检查项，但将所有这些检查项设置为警告，例如，会导致你的编译结果充满警告，因为存在误报。
- en: 'To use them, you simply need to use the group of lints as a lint:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它们，你只需将一组检查作为检查项使用：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can check the rest of the lints and configuration options in the Clippy
    wiki at [https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Clippy 的维基百科中查看其余的检查项和配置选项：[https://rust-lang-nursery.github.io/rust-clippy/master/](https://rust-lang-nursery.github.io/rust-clippy/master/)。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to configure the different lints that Rust
    and the Clippy tool give us. With them, you can get warnings of much more specific
    grain options that affect performance and code quality.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何配置 Rust 和 Clippy 工具提供的不同检查项。通过它们，你可以获得更多具体粒度的警告选项，这些选项会影响性能和代码质量。
- en: We covered the lints that you will not see by default, making your exploration
    journey much easier. In [Chapter 5](f8df2811-838d-40e2-970d-f50b909252f1.xhtml), *Profiling
    Your Rust Application*, we will learn about other tools; in this case, to profile
    your application and find performance bottlenecks that are not straightforward
    to see.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了默认情况下您看不到的代码检查，这使得您的探索之旅变得更加容易。在[第五章](f8df2811-838d-40e2-970d-f50b909252f1.xhtml)，*分析您的Rust应用程序*，我们将了解其他工具；在这种情况下，用于分析您的应用程序并找到那些不太容易直接看到的性能瓶颈。
