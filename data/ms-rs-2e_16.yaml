- en: Building Desktop Applications with Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rust构建桌面应用程序
- en: If your software only supports a terminal or command-line-based interface, your
    target audience is likely limited to only people who know how to use the command
    line. Providing a **Graphical User Interface** (**GUI**) for your software widens
    your target audience and gives users a friendly and intuitive interface so that
    they can use the software effortlessly. For building GUIs, most languages provide
    frameworks that consist of several native libraries that are composed together
    and can access the graphics and the I/O interfaces of the platform. This enables
    developers to easily build GUIs for their applications without worrying about
    the low-level details.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的软件只支持终端或基于命令行的界面，你的目标受众可能仅限于那些知道如何使用命令行的人。为你的软件提供一个**图形用户界面**（**GUI**）可以扩大你的目标受众，并为用户提供一个友好且直观的界面，使他们能够轻松地使用软件。对于构建GUI，大多数语言都提供了框架，这些框架由几个原生库组成，可以访问平台的图形和I/O接口。这使得开发者可以轻松地为他们的应用程序构建GUI，而无需担心底层细节。
- en: There are quite a few popular GUI frameworks targeting desktop platforms such
    as Qt, GTK+, and ImGUI, which are available for mainstream languages. At the time
    of writing this book, Rust doesn't have a mature ecosystem of GUI frameworks,
    but fortunately we have the convenient FFI mechanism through which it can piggyback
    onto the native GUI frameworks provided by languages such as C/C++. In this chapter,
    we'll go through one such crate that provides native bindings to the GTK+ framework
    for doing GUI development and build our ownnews reading desktop app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多流行的GUI框架针对桌面平台，如Qt、GTK+和ImGUI，这些框架适用于主流语言。在撰写本书时，Rust还没有成熟的GUI框架生态系统，但幸运的是，我们有方便的FFI机制，可以通过它利用C/C++等语言提供的原生GUI框架。在本章中，我们将介绍这样一个crate，它提供了对GTK+框架的本地绑定，用于进行GUI开发，并构建我们自己的新闻阅读桌面应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to GUI development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI开发简介
- en: GTK+ framework and the `gtk` crate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GTK+框架和`gtk`crate
- en: Building a hacker news desktop app in Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rust构建黑客新闻桌面应用程序
- en: Other emerging frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他新兴框架
- en: Introduction to GUI development
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI开发简介
- en: '"In programming, the hard part isn''t about solving problems, but deciding
    what problems to solve."'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “在编程中，困难的部分不在于解决问题，而在于决定要解决什么问题。”
- en: – *Paul Graham*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: – *保罗·格雷厄姆*
- en: The advent of GUI-based software started with GUI operating systems. The first
    GUI operating system was the Alto Executive, which ran on the Xerox Alto computer
    that was developed in 1973\. Since then, many operating systems followed suit
    and came with their own GUI-based interface. Today, the most famous GUI-based
    operating systems are macOS, Windows, and Linux-based distributions such as Ubuntu
    and KDE. With users interacting with the OS via a visual point and click interface,
    demand for GUI-based applications increased and a lot of software started shipping
    with GUIs to provide users with a visual way of interacting with their software,
    similar to how they do with their OS. But the early days of GUI development were
    a lot of manual work and due to hardware constraints, different applications had
    specialized implementations and performance characteristics in their GUIs. Eventually,
    GUI frameworks started to proliferate, which provided developers with a common
    baseline and an abstraction layer from all the low-level details of the underlying
    OS, while also being cross-platform.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基于GUI的软件的出现始于GUI操作系统。第一个GUI操作系统是1973年开发的Xerox Alto计算机上的Alto Executive。从那时起，许多操作系统效仿并附带了自己的基于GUI的界面。如今，最著名的基于GUI的操作系统是macOS、Windows以及基于Linux的发行版，如Ubuntu和KDE。随着用户通过视觉点按界面与操作系统交互，对基于GUI的应用程序的需求增加，许多软件开始附带GUI，为用户提供了一种与软件交互的视觉方式，类似于他们与操作系统交互的方式。但GUI开发的早期阶段有很多手动工作，由于硬件限制，不同的应用程序在其GUI中都有专门的实现和性能特征。最终，GUI框架开始普及，这为开发者提供了一个共同的基线和从底层操作系统的所有底层细节中的抽象层，同时也实现了跨平台。
- en: 'Before we build our app, it is important for us to have a brief idea about
    the general design guidelines that are followed in integrating a GUI or a frontend
    to an application. We''ll be focusing our discussion from a Linux OS perspective,
    but there are similarities in the ideas on other platforms, too. A typical GUI
    application architecture is usually split into two components: the frontend and
    the backend. The frontend is the GUI thread or the main thread that the user interacts
    with. It is composed of interactive visual units called **widgets** that are contained
    in a parent container window. An example of a widget is a button that you click
    to perform a task, or a list view that can display multiple items in sequence.
    The GUI thread is mainly concerned with presenting visual information to the user
    and is also responsible for propagating any event that occurs when the user interacts
    with the widgets.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建应用程序之前，了解在将GUI或前端集成到应用程序中时遵循的一般设计指南对我们来说非常重要。我们将从Linux操作系统角度进行讨论，但其他平台上的理念也有相似之处。典型的GUI应用程序架构通常分为两个组件：前端和后端。前端是用户与之交互的GUI线程或主线程。它由包含在父容器窗口中的交互式视觉单元**小部件**组成。小部件的一个例子是点击执行任务的按钮，或者可以按顺序显示多个项目的列表视图。GUI线程主要关注向用户展示视觉信息，并且负责传播用户与这些小部件交互时发生的任何事件。
- en: The backend is a separate thread and contains event handlers or event emitters
    for propagating state changes, and is mainly used for performing compute heavy
    tasks. Processing inputs from the GUI layer is often offloaded to background threads
    as performing compute heavy tasks on the main thread blocks the user from interacting
    with the application frontend, which is not a good user experience. Also, for
    maintainability and separation of concerns, it is often desirable that we keep
    the frontend and the backend separate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 后端是一个独立的线程，包含用于传播状态变化的事件处理程序或事件发射器，主要用于执行计算密集型任务。从GUI层处理输入通常被卸载到后台线程，因为如果在主线程上执行计算密集型任务会阻止用户与应用程序的前端交互，这不是一个好的用户体验。此外，为了维护性和关注点的分离，我们通常希望保持前端和后端分离。
- en: Building a GUI-based application without a dedicated framework can be a very
    cumbersome process, as without them we might need to handle a lot of details in
    our application code. GUI frameworks abstract all the details for the developer,
    such as drawing the widgets and the windows to the video memory or GPU's frame
    buffer, reading events from input devices, re-drawing and refreshing windows,
    and much more. With that said, let's look at one such framework called the Gimp
    toolkit or GTK+, which is a very mature and cross-platform solution for building
    scalable GUI applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有专用框架的情况下构建基于GUI的应用程序可能是一个非常繁琐的过程，因为没有它们，我们可能需要在应用程序代码中处理很多细节。GUI框架为开发者抽象了所有这些细节，例如将小部件和窗口绘制到视频内存或GPU的帧缓冲区，从输入设备读取事件，重新绘制和刷新窗口等等。话虽如此，让我们看看这样一个框架，即Gimp工具包或GTK+，它是一个构建可扩展GUI应用程序的非常成熟和跨平台的解决方案。
- en: GTK+ framework
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GTK+ 框架
- en: 'GTK+ (hereafter gtk) is a cross-platform GUI framework that was created in
    C. Being cross-platform, applications that are developed using gtk can run on
    all major platforms, such as Windows, Linux, or MacOS*.* The gtk project was originally
    created to develop GIMP, image manipulation software for Linux, and was later
    open sourced. gtk is also used by many other software projects, such as the Gnome
    desktop environment on many Linux distributions, which uses it for building its
    utility software. Architecture-wise, gtk is composed of several libraries that
    work together to handle various details that are needed to render and facilitate
    interaction with windows and widgets by the user in the application. Some of these
    components are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GTK+（以下简称gtk）是一个用C语言编写的跨平台GUI框架。由于其跨平台性，使用gtk开发的应用程序可以在所有主要平台上运行，例如Windows、Linux或MacOS*.*
    gtk项目最初是为了开发Linux的图像处理软件GIMP而创建的，后来被开源。gtk也被许多其他软件项目使用，例如许多Linux发行版上的Gnome桌面环境，它使用gtk来构建其实用软件。在架构上，gtk由几个库组成，这些库协同工作以处理渲染和促进用户与应用程序中的窗口和小部件交互所需的各种细节。以下是一些这些组件的例子：
- en: '**GLib**: This is the basic core library and provides several data structures,
    wrappers for portability, and interfaces for runtime functionality such as the
    event loop, thread support, dynamic loading, and an object system. Glib itself
    is composed of components such as **GObject**, which provides an object model,
    and **GIO**, which provides high-level abstractions for I/O**.**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GLib**: 这是基本的核心库，提供了多种数据结构、用于可移植性的包装器以及运行时功能（如事件循环、线程支持、动态加载和对象系统）的接口。Glib
    本身由组件组成，例如 **GObject**，它提供了一个对象模型，以及 **GIO**，它提供了对 I/O 的高级抽象**。'
- en: '**Pango**: Pango is a library that provides text rendering and internationalization
    capabilities.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pango**: Pango 是一个提供文本渲染和国际化的库。'
- en: '**Cairo**: This is a 2D graphics library that takes care of drawing things
    on-screen and, tries to be as consistent across multiple devices, and handles
    details such as hardware acceleration.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cairo**: 这是一个 2D 图形库，负责在屏幕上绘制事物，并试图在多个设备之间保持一致性，同时处理硬件加速等细节。'
- en: '**ATK**: ATK is the accessibility toolkit library that takes care of providing
    accessibility to input devices such as screen readers, magnifiers, and alternative
    input devices.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ATK**: ATK 是一个辅助功能工具包库，负责为屏幕阅读器、放大镜和替代输入设备等输入设备提供辅助功能。'
- en: gtk also has an interface builder called **Glade**, which generates a gtk source
    code skeleton for rapid application development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: gtk 还有一个名为 **Glade** 的界面构建器，它可以生成用于快速应用程序开发的 gtk 源代码框架。
- en: gtk uses the object-oriented model for representing widgets and windows. It
    leverages the GObject library to provide this abstraction. To use the gtk framework
    from Rust, we have the gtk-rs project, which contains many crates that follow
    the same naming convention as libraries that exist in gtk and provides native
    C bindings to these libraries. Among all the crates that the gtk-rs project contains,
    we'll be using the `gtk` crate to build our app.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: gtk 使用面向对象模型来表示小部件和窗口。它利用 GObject 库来提供这种抽象。要从 Rust 使用 gtk 框架，我们有 gtk-rs 项目，该项目包含许多遵循与
    gtk 中存在的库相同命名约定的 crate，并为这些库提供原生 C 绑定。在 gtk-rs 项目包含的所有 crate 中，我们将使用 `gtk` crate
    来构建我们的应用程序。
- en: The `gtk` crate provides the window and widget system for building GUIs and
    tries to model the same API as the native C library, though there are differences
    as Rust does not have an object-oriented type system. Widgets in the `gtk` crate
    are smart pointer types. To allow for flexibility when using the API, you can
    have many mutable references, similar to the one provided by interior mutability
    in Rust. Any non-trivial widget in `gtk` inherits from some base widget type.
    Rust supports this inheritance in widgets via the `IsA<T>` trait. For instance,
    the `gtk::Label` widget has an `impl` of `impl IsA<Widget> for Label`. Also, most
    widgets in `gtk` share functionality with each other—the `gtk` crate implements
    this with the idea of extension traits, such as the `WidgetExt` trait, for all
    widget types. Most widgets such as `gtk::Button` and `gtk::ScrollableWindow` implement
    the `WidgetExt` trait. A widget can also be downcast or upcast to other widgets
    in its hierarchy using the `Cast` trait. With that brief introduction aside, let's
    get into writing a desktop app in Rust.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`gtk` 包提供了构建 GUI 的窗口和小部件系统，并试图模拟与原生 C 库相同的 API，尽管 Rust 没有面向对象的类型系统，因此存在一些差异。`gtk`
    包中的小部件是智能指针类型。为了在使用 API 时提供灵活性，你可以拥有许多可变引用，类似于 Rust 中的内部可变性提供的引用。`gtk` 中的任何非平凡小部件都继承自某种基本小部件类型。Rust
    通过 `IsA<T>` 特性支持小部件的继承。例如，`gtk::Label` 小部件有一个 `impl` 为 `impl IsA<Widget> for Label`。此外，`gtk`
    中的大多数小部件都相互共享功能——`gtk` 包通过扩展特性（如 `WidgetExt` 特性）为所有小部件类型实现这一点。大多数小部件，如 `gtk::Button`
    和 `gtk::ScrollableWindow`，都实现了 `WidgetExt` 特性。小部件还可以使用 `Cast` 特性将其向下转换为层次结构中的其他小部件。在简要介绍之后，让我们开始编写一个桌面应用程序。'
- en: Building a hacker news app using gtk-rs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 gtk-rs 构建 hacker news 应用程序
- en: 'We''ll use the `gtk` crate to build a simple hacker news app that fetches the
    top 10 trending stories from the [https://news.ycombinator.com/](https://news.ycombinator.com/)
    website. Hacker News is a website focusing on digital technologies and tech news
    from around the world. To start with, we have created a basic wireframe model
    of our app:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `gtk` crate 来构建一个简单的 hacker news 应用程序，该程序从 [https://news.ycombinator.com/](https://news.ycombinator.com/)
    网站获取前 10 个热门故事。Hacker News 是一个专注于全球数字技术和科技新闻的网站。首先，我们为我们的应用程序创建了一个基本的线框模型：
- en: '![](img/49b70584-a277-4793-8126-dc4419548ec4.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49b70584-a277-4793-8126-dc4419548ec4.png)'
- en: 'At the very top, we have the app header bar, which has a Refresh button on
    the left that can update our stories on demand. A story is a news entry that''s
    posted by users on the Hacker News website. The header bar also contains the app
    title at the center and the usual window controls on the right. Below that, we
    have our main scrollable window where our stories will be rendered vertically
    as a story widget. The story widget is made up of two widgets: a widget for displaying
    the story''s name and its score, and another for rendering a link to the story
    that can be clicked on in the user''s default browser. Pretty simple!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们有应用标题栏，其中左侧有一个刷新按钮，可以按需更新我们的故事。故事是用户在Hacker News网站上发布的新闻条目。标题栏还包含居中的应用标题和右侧的常规窗口控制按钮。下面是我们的主要可滚动窗口，我们的故事将垂直渲染为故事小部件。故事小部件由两个小部件组成：一个用于显示故事的名称和分数的小部件，另一个用于渲染可以点击在用户默认浏览器中打开的故事链接。非常简单！
- en: '**Note**: As we are using the `gtk` crate, which binds to native C libraries,
    we need to install the developmental C libraries for the gtk framework. For Ubuntu
    and Debian platforms, we can install these dependencies by running the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：由于我们使用的是绑定到原生C库的`gtk`crate，我们需要安装gtk框架的开发C库。对于Ubuntu和Debian平台，我们可以通过运行以下命令来安装这些依赖项：'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please refer to the gtk-rs documentation page at [http://gtk-rs.org/docs/requirements.html](http://gtk-rs.org/docs/requirements.html)
    for information on setting gtk up on other platforms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考gtk-rs文档页面[http://gtk-rs.org/docs/requirements.html](http://gtk-rs.org/docs/requirements.html)，以获取有关在其他平台上设置gtk的信息。
- en: To start things off, we'll create a new cargo project by running `cargo new
    hews`. We have creatively named our app **Hews**, which is short for **H** in
    hacker + **ews** from news.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将通过运行`cargo new hews`来创建一个新的cargo项目。我们创造性地将我们的应用命名为**Hews**，它是**H**（hacker的首字母）和**ews**（news的缩写）的组合。
- en: 'The following are the dependencies that we''ll need in our `Cargo.toml` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在`Cargo.toml`文件中需要的依赖项：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are using a bunch of crates here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一堆crate：
- en: '`gtk`: This is used to build the GUI of the app. We use the bindings for gtk
    version `3.18` here.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gtk`：这是用于构建应用的GUI。我们在这里使用的是gtk版本`3.18`的绑定。'
- en: '`reqwest`: This is used for fetching stories from the Hacker News API. `reqwest`
    is a high-level wrapper over the `hyper` crate. We are using the `reqwest` synchronous
    API for simplicity.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqwest`：这是用于从黑客新闻API获取故事的。`reqwest`是`hyper`crate的高级包装器。我们为了简单起见使用`reqwest`的同步API。'
- en: '`serde_json`: This is used for seamlessly converting the fetched JSON response
    from the network to a strongly typed `Story` struct.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serde_json`：这是用于无缝地将从网络获取的JSON响应转换为强类型的`Story`结构体。'
- en: '`serde`, `serde_derive`: These provide traits and implementations for automatically
    deriving serialization code for built-in Rust types. By using the `Serialize` and `Deserialize`
    traits from `serde_derive`, we can serialize and deserialize any native Rust type
    into a given format. `serde_json` relies on the same functionality to convert
    a `serde_json::Value` type into a Rust type.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serde`，`serde_derive`：这些提供了用于自动派生内置Rust类型序列化代码的特性和实现。通过使用`serde_derive`中的`Serialize`和`Deserialize`特性，我们可以将任何原生Rust类型序列化和反序列化到给定的格式。`serde_json`依赖于相同的功能将`serde_json::Value`类型转换为Rust类型。'
- en: To show news articles in our app, we'll fetch them by making HTTP requests to
    the official hacker news API, which is documented at [https://github.com/HackerNews/API](https://github.com/HackerNews/API).
    We have divided our app into two modules. First, we have the `app` module, which
    contains all the UI-related functionality for rendering the app on-screen and
    handling UI state updates from the user. Second, we have the `hackernews` module,
    which provides APIs for fetching stories from the network. It runs in a separate
    thread so not block the GUI thread when network requests happen, which is a blocking
    I/O operation. From the hacker news API, a story is an item containing a news
    title and a link to the news, along with other properties such as how popular
    the story is and a list of comments on the story.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用中显示新闻文章，我们将通过向官方黑客新闻API发起HTTP请求来获取它们，该API的文档位于[https://github.com/HackerNews/API](https://github.com/HackerNews/API)。我们将我们的应用分为两个模块。首先，我们有`app`模块，它包含所有与UI相关的功能，用于在屏幕上渲染应用和处理用户对UI状态的更新。其次，我们有`hackernews`模块，它提供从网络获取故事的API。它在一个单独的线程中运行，这样在发生网络请求时不会阻塞GUI线程，因为这是一个阻塞的I/O操作。从黑客新闻API获取的故事是一个包含新闻标题和新闻链接的项目，以及其他属性，如故事的流行程度和评论列表。
- en: To make this example simpler and easier to follow, our app does not have proper
    error handling and includes many `unwrap()` calls, which is a bad practice from
    an error handling perspective. After you are done exploring the demo, you are
    encouraged to integrate a better error handling strategy in the app. With that
    said, let's go through the code step by step.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子更简单、更容易理解，我们的应用程序没有适当的错误处理，并包含许多 `unwrap()` 调用，这在错误处理方面是一种不良做法。在您完成探索演示后，我们鼓励您在应用程序中集成更好的错误处理策略。话虽如此，让我们一步一步地通过代码。
- en: 'First, we''ll look at the entry point of our app in `main.rs`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看我们的应用程序在 `main.rs` 中的入口点：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our `main` function, we call `App::new()`, which returns an `App` instance,
    along with `rx`, which is a `mpsc::Receiver`. To keep our GUI decoupled from network
    requests, all state updates in hews are handled asynchronously via channels. The
    `App` instance internally invokes `mpsc::channel()`, giving back `tx` and `rx`.
    It stores the `tx` with it and also passes it to the network thread, allowing
    it to notify the UI of any new story. Following the `new` method call, we invoke
    `launch` on `app`, passing in the `rx`, which is used to listen for events from
    the network thread in the GUI thread.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `main` 函数中，我们调用 `App::new()`，它返回一个 `App` 实例，以及 `rx`，它是一个 `mpsc::Receiver`。为了使我们的
    GUI 与网络请求解耦，所有状态更新在 hews 中都是通过通道异步处理的。`App` 实例内部调用 `mpsc::channel()`，返回 `tx` 和
    `rx`。它将 `tx` 与其存储，并将其传递给网络线程，允许它通知 UI 任何新的故事。在 `new` 方法调用之后，我们在 `app` 上调用 `launch`，传入
    `rx`，这在 GUI 线程中用于监听来自网络线程的事件。
- en: Next, let's go through our `app` module in the `app.rs` module, which handles
    most of the orchestration needed to render our app on-screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过 `app.rs` 模块中的 `app` 模块来了解我们的应用程序，它处理将我们的应用程序渲染到屏幕上所需的大部分编排工作。
- en: If you want to find out more about the widget explanation that follows, look
    for gtk-rs's excellent documentation at [https://gtk-rs.org/docs/gtk/](https://gtk-rs.org/docs/gtk/),
    where you can search for any widget and explore more about its properties.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于以下小部件的解释，请查找 gtk-rs 的优秀文档在 [https://gtk-rs.org/docs/gtk/](https://gtk-rs.org/docs/gtk/)，您可以在那里搜索任何小部件并探索更多关于其属性的信息。
- en: 'First, we have our `App` struct, which is the entry point for all things GUI:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们的 `App` 结构体，它是所有 GUI 事物的入口点：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This struct contains a bunch of fields:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体包含了一堆字段：
- en: '`window`: This contains the base `gtk::Window` widget. Every gtk application
    starts with a window to which we can add child widgets in different layouts to
    design our GUI.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window`: 这包含基本的 `gtk::Window` 小部件。每个 gtk 应用程序都以一个窗口开始，我们可以向其中添加子小部件以不同的布局来设计我们的
    GUI。'
- en: '`header`: This is a struct that''s defined by us and wraps a `gtk::HeaderBar`
    widget, which acts as the title bar for our app window.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header`: 这是一个我们定义的结构体，它包装了一个 `gtk::HeaderBar` 小部件，该小部件充当我们应用程序窗口的标题栏。'
- en: '`stories`: This is a container `gtk::Box` widget that will store our stories
    vertically.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stories`: 这是一个存储我们的故事的垂直容器 `gtk::Box` 小部件。'
- en: '`spinner`: This is a `gtk::Spinner` widget that provides a visual cue for loading
    stories.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spinner`: 这是一个 `gtk::Spinner` 小部件，为加载故事提供视觉提示。'
- en: '`tx`: This is an mpsc `Sender` to send events from the GUI to the network thread.
    The messages are of type `Msg`, which is an enum:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tx`: 这是一个 mpsc `Sender`，用于从 GUI 发送事件到网络线程。消息的类型是 `Msg`，它是一个枚举：'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our app starts with the initial state as `Loading` when the `fetch_posts` method
    is called from the `hackernews` module. We'll see that later. `NewStory` is the
    state that occurs when a new story is fetched. `Loaded` is the state that occurs
    when all of the stories are loaded and `Refresh` is sent when the user wants to
    reload the stories.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `hackernews` 模块调用 `fetch_posts` 方法时，我们的应用程序以初始状态 `Loading` 开始。我们稍后会看到这一点。`NewStory`
    是在获取新故事时发生的状态。`Loaded` 是在所有故事都加载时发生的状态，当用户想要重新加载故事时，会发送 `Refresh`。
- en: 'Let''s move on to the methods on the `App` struct. Here''s our `new` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到 `App` 结构体上的方法。这是我们的 `new` 方法：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `new` method first starts the gtk event loop using `gtk::init()`. If that
    fails, we exit, printing a message to the console:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 方法首先使用 `gtk::init()` 启动 gtk 事件循环。如果失败，我们将退出，并在控制台打印一条消息：'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we create our `tx` and `rx` channel endpoints for communicating between
    the network thread and the GUI thread. Next, we create our `window`, which is
    a `TopLevel` window. Now, multiple stories might not fit into our app window if
    the window is resized, so we need a scrollable window here. For that, we will
    create a `ScrolledWindow` instance as `sw`. However, a gtk `ScrolledWindow` accepts
    only a single child within it and we need to store multiple stories, which is
    a problem. Fortunately, we can use the `gtk::Box` type, which is a generic container
    widget that''s used to lay out and organize child widgets. Here, we create a `gtk::Box`
    instance as `stories` with the `Orientation::Vertical` orientation so that each
    of our stories renders vertically on top of each other. We also want to show a
    spinner at the top of our scroll widget when the stories are being loaded, so
    we will create a `gtk::Spinner` widget and add it to `stories` to render it at
    the very top. We will also create our `Header` bar and pass a reference to `stories`
    as well as `tx`. Our header contains the refresh button and has a click handler,
    which needs the `stories` container to clear items within it, allowing us to load
    new stories:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为网络线程和 GUI 线程之间的通信创建 `tx` 和 `rx` 通道端点。接下来，我们创建我们的 `window`，它是一个 `TopLevel`
    窗口。现在，如果窗口被调整大小，多个故事可能不会适合我们的应用程序窗口，因此我们需要一个可滚动的窗口。为此，我们将创建一个 `ScrolledWindow`
    实例作为 `sw`。然而，gtk 的 `ScrolledWindow` 只接受其内部的单个子小部件，而我们需要存储多个故事，这是一个问题。幸运的是，我们可以使用
    `gtk::Box` 类型，它是一个通用的容器小部件，用于布局和组织子小部件。在这里，我们创建一个具有 `Orientation::Vertical` 方向的
    `gtk::Box` 实例作为 `stories`，这样我们的每个故事都会垂直堆叠渲染。我们还想在故事正在加载时在滚动小部件的顶部显示一个旋转器，因此我们将创建一个
    `gtk::Spinner` 小部件并将其添加到 `stories` 中以在顶部渲染它。我们还将创建我们的 `Header` 栏，并将 `stories`
    的引用以及 `tx` 传递给它。我们的标题栏包含刷新按钮，并有一个点击处理程序，该处理程序需要 `stories` 容器来清除其内部的项目，这样我们就可以加载新的故事：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we start composing our widgets. First, we add the `spinner` to `stories`.
    Then, we add the `stories` container widget to our scroll widget, `sw`, which
    is then added to our parent `window`. We also set the `window` size with `set_default_size`.
    We then set its title bar with `set_titlebar`, passing in our `header`. Following
    that, we attach a signal handler to our window:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始组合我们的小部件。首先，我们将 `spinner` 添加到 `stories` 中。然后，我们将 `stories` 容器小部件添加到我们的滚动小部件
    `sw` 中，然后将其添加到我们的父 `window` 中。我们还使用 `set_default_size` 设置窗口大小。然后我们使用 `set_titlebar`
    并传递我们的 `header` 来设置其标题栏。随后，我们向我们的窗口附加一个信号处理程序：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will quit the app if we call `main_quit()`. The `Inhibit(false)` return
    type does not stop the signal from propagating to the default handler for `delete_event`.
    All widgets have a default signal handler. The signal handlers on the widgets
    in the gtk crate follow the naming convention of `connect_<event>` and take in
    a closure with the widget as their first parameter and the event object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `main_quit()`，这将退出应用程序。`Inhibit(false)` 的返回类型不会阻止信号传播到 `delete_event`
    的默认处理程序。所有小部件都有一个默认的信号处理程序。在 gtk crate 中的小部件上的信号处理程序遵循 `connect_<event>` 的命名约定，并接受一个闭包作为它们的第一个参数，该闭包以小部件作为其第一个参数和事件对象。
- en: 'Next, let''s look at the `launch` method on `App`, which is called in `main.rs`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `App` 上的 `launch` 方法，它在 `main.rs` 中被调用：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we enable the `window` widget, along with its child widgets. We make
    them visible by calling the `show_all` method as widgets in gtk are invisible
    by default. Next, we create our HTTP `Client` and wrap it in an `Arc` as we want
    to share it with our network thread. We then call `fetch_posts`, passing our client.
    Following that, we run our event loop by calling `run_event_loop`, passing in
    `rx`. The `fetch_posts` method is defined like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们启用 `window` 小部件及其子小部件。我们通过调用 `show_all` 方法使它们可见，因为 gtk 中的小部件默认是不可见的。接下来，我们创建我们的
    HTTP `Client` 并将其包装在 `Arc` 中，因为我们想与我们的网络线程共享它。然后我们调用 `fetch_posts`，传递我们的客户端。随后，我们通过调用
    `run_event_loop` 并传递 `rx` 来运行我们的事件循环。`fetch_posts` 方法定义如下：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It starts our spinner animation by calling its `start` method, and sends the
    `Loading` message as the initial state. It then calls the `top_stories` function
    from the `hackernews` module, passing `10` as the number of stories to fetch and
    a `Sender` to notify the GUI thread of new stories.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过调用其 `start` 方法启动旋转器动画，并发送 `Loading` 消息作为初始状态。然后它调用 `hackernews` 模块中的 `top_stories`
    函数，传递 `10` 作为要获取的故事数量和一个 `Sender` 来通知 GUI 线程有新的故事。
- en: 'After calling `fetch_posts`, we call the `run_event_loop` method on `App`,
    which is defined like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `fetch_posts` 之后，我们在 `App` 上调用 `run_event_loop` 方法，该方法的定义如下：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we get references to a bunch of objects that we'll use. Following that,
    we call `gtk::timeout_add`, which runs the given closure every 100 milliseconds.
    Within the closure, we poll on `rx` in a non-blocking way using `try_recv()` for
    events from the network or GUI thread. When we get a `NewStory` message, we call
    `render_story`. When we receive a `Loading` message, we disable the refresh button.
    In the case of the `Loaded` message, we stop our spinner and enable the refresh
    button so that the user can reload stories again. Finally, in the case of receiving
    a `Refresh` message, we start the spinner again and send the `Loading` message
    to the GUI thread itself, followed by calling the `top_stories` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取我们将要使用的一堆对象的引用。随后，我们调用 `gtk::timeout_add`，它每 100 毫秒运行一次给定的闭包。在闭包内部，我们以非阻塞方式对
    `rx` 进行轮询，使用 `try_recv()` 获取来自网络或 GUI 线程的事件。当我们收到 `NewStory` 消息时，我们调用 `render_story`。当我们收到
    `Loading` 消息时，我们禁用刷新按钮。在 `Loaded` 消息的情况下，我们停止我们的旋转器并启用刷新按钮，以便用户可以再次重新加载故事。最后，在收到
    `Refresh` 消息的情况下，我们再次启动旋转器，并将 `Loading` 消息发送到 GUI 线程本身，随后调用 `top_stories` 方法。
- en: 'Our `render_story` method is defined as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `render_story` 方法定义如下：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `render_story` method gets the `Story` instance as `s` and the `stories`
    container widget as arguments before creating two labels: `title_with_score`,
    which holds the story title along with its score, and `link_label`, which holds
    the link to the story. For the `link_label`, we will add a custom markup that
    contains an `<a>` tag with the URL. Finally, we put both these labels onto our
    `stories` container and call `show_all` at the end to make those labels visible
    on the screen.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`render_story` 方法在创建两个标签之前，将 `Story` 实例作为 `s` 和 `stories` 容器小部件作为参数获取：`title_with_score`，它包含故事标题及其评分，以及
    `link_label`，它包含故事的链接。对于 `link_label`，我们将添加一个包含 `<a>` 标签的 URL 的自定义标记。最后，我们将这两个标签放入我们的
    `stories` 容器中，并在最后调用 `show_all` 以使这些标签在屏幕上可见。'
- en: 'Our `Header` struct and its methods, which we mentioned previously, are part
    of the `App` struct and are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的 `Header` 结构体及其方法，是 `App` 结构体的一部分，具体如下：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This struct contains the following fields:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体包含以下字段：
- en: '`header`: A gtk `HeaderBar`, which is like a horizontal gtk `Box` that''s suitable
    for title bars for a window'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header`: 一个 gtk `HeaderBar`，类似于一个适合窗口标题栏的水平 gtk `Box`'
- en: '`refresh_btn`: A gtk `Button` that is used to reload stories on demand'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh_btn`: 一个用于按需重新加载故事的 gtk `Button`'
- en: '`Header` also has three methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Header` 还有三个方法：'
- en: '`new`: This creates a new `Header` instance. Within the new method, we create
    a new gtk `HeaderBar`, set its close button to show, and add a title. Then, we
    create a Refresh button and attach a click handler to it using the `connect_clicked`
    method, which takes in a closure. Within this closure, we iterate over all of
    the children of the scrolled window container, which are passed to this method
    as `story_container`. However, we skip the first one because the first widget
    is a `Spinner` and we want to keep it across multiple reloads to show its progress.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`: 这将创建一个新的 `Header` 实例。在 `new` 方法内部，我们创建一个新的 gtk `HeaderBar`，将其关闭按钮设置为显示，并添加一个标题。然后，我们创建一个刷新按钮，并使用
    `connect_clicked` 方法将其附加到它上面，该方法接受一个闭包。在这个闭包内部，我们遍历滚动窗口容器的所有子项，这些子项作为 `story_container`
    传递给此方法。然而，我们跳过了第一个，因为第一个小部件是一个 `Spinner`，我们希望它在多次重新加载之间保持显示其进度。'
- en: '`disable_refresh`: This disables the refresh button, setting its sensitivity
    to `false`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disable_refresh`: 这将禁用刷新按钮，将其灵敏度设置为 `false`。'
- en: '`enable_refresh`: This enables the refresh button, setting its sensitivity
    to `true`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable_refresh`: 这将启用刷新按钮，将其灵敏度设置为 `true`。'
- en: 'Next, let''s go through our `hackernews` module, which does all the heavy lifting
    of getting the stories as json from the API endpoint and parsing it as a `Story`
    instance using `serde_json`. Here''s the first piece of content of `hackernews.rs`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的 `hackernews` 模块，它负责从 API 端点获取故事作为 json 并使用 `serde_json` 解析为 `Story`
    实例的所有繁重工作。以下是 `hackernews.rs` 的第一部分内容：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we have a declaration of the base URL endpoint, `HN_BASE_URL`, for the
    hackernews API that's hosted on firebase. Firebase is a real-time database from
    Google. Then, we have the `Story` struct declaration, annotated with the `Deserialize`
    and `Debug` traits. The `Deserialize` trait comes from the `serde_derive` crate,
    which provides a derive macro to convert any value into a native Rust type. We
    need it because want to be able to parse the incoming json reply from the network
    as a `Story` struct.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个为托管在 Firebase 上的 hackernews API 声明的基 URL 端点 `HN_BASE_URL`。Firebase 是来自
    Google 的实时数据库。然后，我们有 `Story` 结构体的声明，并带有 `Deserialize` 和 `Debug` 特性的注解。`Deserialize`
    特性来自 `serde_derive` 包，它提供了一个 derive 宏，可以将任何值转换为原生 Rust 类型。我们需要它，因为我们希望能够将来自网络的
    json 响应解析为 `Story` 结构体。
- en: 'The `Story` struct contains the same fields as the ones that are found in the
    json reply from the stories endpoint. For more information on the json structure,
    refer to [https://github.com/HackerNews/API#items](https://github.com/HackerNews/API#items).
    Also, among all our fields in the `Story` struct, we have one field named `type`.
    However, `type` is also a keyword in Rust for declaring type aliases and it''s
    invalid for `type` to be a field of a struct, so we will name it `_type` instead.
    However, this wouldn''t parse as our json reply as a field named `type`. To solve
    this conflict, `serde` provides us with a field-level attribute to allow us to
    parse values, even in the case of such conflicts when using the `#[serde(rename
    = "type")]` attribute on the field. The value of `rename` should match whatever
    the value is in the incoming json response''s field name. Next, let''s look at
    the set of methods that are provided by this module:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Story` 结构体包含与在 stories 端点返回的 json 响应中找到的相同字段。有关 json 结构的更多信息，请参阅 [https://github.com/HackerNews/API#items](https://github.com/HackerNews/API#items)。此外，在
    `Story` 结构体的所有字段中，我们有一个名为 `type` 的字段。然而，`type` 也是 Rust 中用于声明类型别名的关键字，将 `type`
    作为结构体的字段是不合法的，因此我们将它命名为 `_type`。但是，这不会解析为我们的 json 响应中的 `type` 字段。为了解决这种冲突，`serde`
    为我们提供了一个字段级别的属性，允许我们在使用 `#[serde(rename = "type")]` 属性的字段上，即使在存在此类冲突的情况下也能解析值。`rename`
    的值应与传入的 json 响应的字段名称中的值相匹配。接下来，让我们看看这个模块提供的方法集：'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our only public function that's been exposed by this module is `top_stories`.
    This function takes a reference to `Client`, which comes from the `reqwest` crate,
    then a `count` parameter specifying how many stories to retrieve, and a `Sender`
    instance `tx`, which can send messages of type `Msg`, an enum. `tx` is used to
    communicate to the GUI thread about the state of our network request. Initially,
    the GUI starts in the `Msg::Loading` state, which keeps the refresh button disabled.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块公开的唯一函数是 `top_stories`。这个函数接受一个来自 `reqwest` 包的 `Client` 引用，然后是一个 `count`
    参数，指定要检索的故事数量，以及一个 `Sender` 实例 `tx`，它可以发送类型为 `Msg` 的消息，`Msg` 是一个枚举。`tx` 用于将有关我们的网络请求状态的消息传达给
    GUI 线程。最初，GUI 以 `Msg::Loading` 状态启动，这会禁用刷新按钮。
- en: Within this function, we first clone our copy of the `tx` sender and then spawn
    a thread where we'll use this `tx`. We spawn a thread so not to block the UI thread
    when the network request is in progress. Within the closure, we call `fetch_stories_parsed()`.
    In this method, we first construct our `/top_stories.json` endpoint by concatenating
    it with `HN_BASE_URL` using the `format!` macro. We then make a request to the
    constructed endpoint to get a list of all stories. We call the `text()` method
    to convert the response into a json string. The returned json response is a list
    of story IDs, each of which can be used to make another set of requests, which
    gives us detailed information on the story as another json object. We then parse
    this response using `serde_json::from_str(&body)`. This gives us a `Value` enum
    value, which is a parsed json array containing a list of story IDs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先克隆了我们的 `tx` 发送者，然后在一个线程中使用了这个 `tx`。我们创建一个线程是为了在网络请求进行时不会阻塞 UI 线程。在闭包中，我们调用
    `fetch_stories_parsed()`。在这个方法中，我们首先使用 `format!` 宏将 `/top_stories.json` 端点与 `HN_BASE_URL`
    连接起来。然后，我们向构建的端点发送请求以获取所有故事列表。我们调用 `text()` 方法将响应转换为 json 字符串。返回的 json 响应是一个包含故事
    ID 的列表，每个 ID 都可以用来发起另一组请求，从而提供关于故事的详细信息，作为另一个 json 对象。然后我们使用 `serde_json::from_str(&body)`
    解析这个响应。这给我们一个 `Value` 枚举值，它是一个解析后的 json 数组，包含故事 ID 列表。
- en: 'So, once we have the story IDs stored in `story_ids`, we explicitly convert
    it into an array by calling `as_array()` and then we `iter()` on it and limit
    the stories we want by calling `take(count)`, followed by calling `collect()`
    on it, which gives us back a `Vec<Story>`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们将故事ID存储在`story_ids`中，我们就通过调用`as_array()`显式地将其转换为数组，然后对其`iter()`并调用`take(count)`来限制我们想要的条目数，最后调用`collect()`，这将返回一个`Vec<Story>`：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we check whether our filtered story ID is empty. If it is, we set the
    `loaded` variable to `false`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查过滤后的故事ID是否为空。如果是，我们将`loaded`变量设置为`false`：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `loaded` boolean value is used to send a notification to the main GUI thread
    if any of our story was loaded. Next, if the `filtered` list is not empty, we
    iterate over our `filtered` stories and construct a `story_url` :'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`loaded`布尔值用于在加载我们的任何故事时向主GUI线程发送通知。接下来，如果`filtered`列表不为空，我们遍历我们的`filtered`故事并构建一个`story_url`：'
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We make get requests for each constructed `story_url ` from the story `id`,
    take the json response, and parse it as a `Story` struct using the `serde_json::from_str`
    function. Following that, we send the story by wrapping it in `Msg::NewStory(story)`
    to the GUI thread using `tx_clone`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对每个构造的`story_url`从故事`id`发起GET请求，获取JSON响应，并使用`serde_json::from_str`函数将其解析为`Story`结构体。之后，我们通过`tx_clone`将包装在`Msg::NewStory(story)`中的故事发送到GUI线程。
- en: Once we have sent all the stories, we send a `Msg::Loaded` message to the GUI
    thread, which enables the refresh button so that the user can reload the stories
    again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 发送所有故事后，我们向GUI线程发送一个`Msg::Loaded`消息，这启用了刷新按钮，以便用户可以再次重新加载故事。
- en: 'All right! It''s time for us to read popular news stories on our app. After
    running `cargo run`, we can see our stories being pulled and rendered in the window:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！是时候在我们的应用程序上阅读流行的新闻故事了。运行`cargo run`后，我们可以在窗口中看到我们的故事被拉取并渲染：
- en: '![](img/226a3f3d-1e2b-4998-9308-607251bb4cf4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/226a3f3d-1e2b-4998-9308-607251bb4cf4.png)'
- en: Upon clicking the link of any for the stories, hews will open in your default
    browser. That's about it. We've made our GUI application in Rust using very few
    lines of code. Now, it's time for you to explore and experiment with the app.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何故事的链接时，它将在你的默认浏览器中打开。这就是全部。我们已经使用非常少的代码在Rust中制作了我们的GUI应用程序。现在，是时候探索和实验这个应用程序了。
- en: Exercise
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Our app works great, but there are lots of ways we can improve it. If you are
    feeling ambitious, you can take a look at the following challenges:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序运行得很好，但我们可以从很多方面来改进它。如果你有雄心壮志，可以查看以下挑战：
- en: Improve error handling in the app and handle cases where the network is slow
    by adding retry mechanisms.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进应用程序的错误处理，通过添加重试机制来处理网络缓慢的情况。
- en: Customize the number of stories that get loaded by placing an input field widget
    on the header bar, and parse and pass that number to the network thread.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在标题栏上放置一个输入字段小部件来自定义要加载的故事数量，并将该数字解析并传递给网络线程。
- en: Add a button to each story to view comments. When the user clicks on the comments
    button, the app should open a scrollable widget on the right and populate the
    comments in that story, one by one.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个故事添加一个按钮来查看评论。当用户点击评论按钮时，应用程序应在右侧打开一个可滚动的窗口并逐个填充该故事的评论。
- en: Widgets can be styled using CSS. Try adding colors to the story container, depending
    on the popularity of posts, using the `gtk::StyleProvider` APIs.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件可以使用CSS进行样式化。尝试使用`gtk::StyleProvider` API根据帖子的流行度给故事容器添加颜色。
- en: Other emerging GUI frameworks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他新兴的GUI框架
- en: As we have already seen, the APIs exposed by the `gtk` crate can be a bit uncomfortable
    to write complex GUIs with. Fortunately, we have a wrapper crate called `relm`.
    The relm crate is inspired by the *Elm* language's architecture of `Model-View-Update`,
    which provides a simplistic approach for building reactive GUIs. Apart from relm,
    there are many other standalone GUI toolkits and crates in the works by the Rust
    community. One of the new and promising ones is `Azul`, which can be found at
    [https://azul.rs/](https://azul.rs/). It is a functional GUI framework that supports
    async I/O, along with features such as two-way data binding, which allows you
    to build reactive widgets and employs the principle of composition for building
    widgets, as opposed to the object-oriented model, which we explored in the gtk
    framework when building hews. As the rendering backend, Azul uses the performant
    Webrender rendering engine that's used in Servo from Mozilla.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，`gtk` 包暴露的 API 在编写复杂的 GUI 时可能会有些不舒服。幸运的是，我们有一个名为 `relm` 的包装包。`relm`
    包受到了 Elm 语言 `Model-View-Update` 架构的启发，它为构建反应式 GUI 提供了一种简单的方法。除了 relm 之外，Rust 社区还在开发许多其他独立的
    GUI 工具包和包。其中之一是新的、有希望的 `Azul`，可以在 [https://azul.rs/](https://azul.rs/) 找到。它是一个支持异步
    I/O 的功能 GUI 框架，还具备双向数据绑定等特性，允许你构建反应式小部件，并采用组合原则来构建小部件，而不是我们在构建 hews 时在 gtk 框架中探索的对象模型。作为渲染后端，Azul
    使用了 Mozilla 的 Servo 中使用的性能优异的 Webrender 渲染引擎。
- en: Other notable mentions are `conrod` from the Piston Developers organization
    at [https://github.com/PistonDevelopers/conrod](https://github.com/PistonDevelopers/conrod),
    and `imgui-rs` at [https://github.com/Gekkio/imgui-rs](https://github.com/Gekkio/imgui-rs),
    which is a bindings library for the popular immediate mode ImGUI framework in
    C++.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得注意的提及包括来自 Piston 开发者组织在 [https://github.com/PistonDevelopers/conrod](https://github.com/PistonDevelopers/conrod)
    的 `conrod`，以及 [https://github.com/Gekkio/imgui-rs](https://github.com/Gekkio/imgui-rs)
    的 `imgui-rs`，这是一个为流行的即时模式 ImGUI 框架在 C++ 中的绑定库。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That was a very brief tour of GUI development with Rust. This chapter gave us
    a glimpse into the current experience of developing GUI applications. At the time
    of writing, the experience isn't all that great, but there are emerging frameworks,
    such as Azul, that aim to take this experience to the next level.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对使用 Rust 进行 GUI 开发的简要概述。本章让我们窥见了当前开发 GUI 应用程序的经验。在撰写本文时，这种体验并不算很好，但有一些新兴的框架，例如
    Azul，旨在将这种体验提升到新的水平。
- en: The next chapter will be about finding and fixing bugs in your program using
    debuggers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何使用调试器查找和修复程序中的错误。
