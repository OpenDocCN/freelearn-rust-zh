- en: Managing Projects with Cargo
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cargo 管理项目
- en: '`cargo` is one of the unique selling points of Rust. It makes a developer''s
    life easy by making the creating, developing, packaging, maintaining, testing,
    and deploying of application code or tools to production considerably more enjoyable. `cargo` is
    designed to be the single go-to tool for working on any type of Rust project across
    multiple stages such as the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo` 是Rust的独特卖点之一。它通过使创建、开发、打包、维护、测试和部署应用程序代码或工具到生产环境变得相当愉快，从而简化了开发者的生活。`cargo`
    被设计成是跨多个阶段（如下所示）工作的任何类型Rust项目的单一首选工具：'
- en: Project creation and management
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目创建和管理
- en: Configuring and executing builds
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和执行构建
- en: Dependency installation and maintenance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖安装和维护
- en: Testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Benchmarking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试
- en: Interfacing with other tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他工具接口
- en: Packaging and publishing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包和发布
- en: 'Especially in the domain of systems programming, tools such as `cargo` are
    still rare—which is why many large-scale users developed their own versions. As
    a young language, Rust draws from the aspects that other tools got right: the
    versatility and central repository of `npm` (for Node.js), the ease of use of `pip`
    (for Python), and many more. In the end, `cargo` provides many great ways to enhance
    the Rust experience and has been cited as a major influence for developers who
    want to adopt the language.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在系统编程领域，像 `cargo` 这样的工具仍然很少见——这就是为什么许多大型用户开发了他们自己的版本。作为一种年轻的语言，Rust 从其他工具的正确方面汲取了灵感：`npm`（用于Node.js）的通用性和中央仓库、`pip`（用于Python）的易用性，以及许多其他方面。最终，`cargo`
    提供了许多增强Rust体验的绝佳方式，并被引用为希望采用该语言的开发者的主要影响因素。
- en: In this chapter, we cover recipes that enable developers to utilize all of the
    features of `cargo` to create production-grade Rust projects. These fundamental
    recipes serve as building blocks for referencing dependencies, adjusting compiler
    behavior, customizing tools, and many more things that are common in everyday
    Rust development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些配方，使开发者能够利用 `cargo` 的所有功能来创建生产级别的Rust项目。这些基本的配方作为参考依赖项、调整编译器行为、自定义工具以及许多在日常Rust开发中常见的其他事物的构建块。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Organizing large projects with workspaces
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作区组织大型项目
- en: Uploading to `crates.io` ([https://crates.io](https://crates.io))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传到 `crates.io` ([https://crates.io](https://crates.io))
- en: Using dependencies and external crates
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖项和外部crate
- en: Extending `cargo` with sub-commands
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过子命令扩展 `cargo`
- en: Testing your project with `cargo`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cargo` 测试你的项目
- en: Continuous integration with `cargo`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `cargo` 的持续集成
- en: Customizing the build
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义构建
- en: Organizing large projects with workspaces
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工作区组织大型项目
- en: 'Creating a single project is easy: run `cargo new my-crate` and it''s done.
    `cargo` creates everything from folder structure to a small source file (or unit
    test) in a breeze. However, what about larger projects consisting of multiple
    smaller crates and an executable? Or just a collection of related libraries? The `cargo` tool''s
    answer to this is called **workspaces**.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单个项目很简单：运行 `cargo new my-crate` 即可完成。`cargo` 会轻松创建从文件夹结构到一个小源文件（或单元测试）的所有内容。然而，对于由多个较小的crate和一个可执行文件组成的大型项目呢？或者只是一系列相关的库？`cargo`
    工具对此的答案是**工作区**。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create your own workspace to manage multiple projects:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建自己的工作区来管理多个项目：
- en: 'In a Terminal window (Windows PowerShell or a Terminal on macOS/Linux), change
    to a directory that will hold the workspace by running these commands:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个终端窗口（Windows PowerShell 或 macOS/Linux 上的终端），通过运行以下命令切换到将包含工作区的目录：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the `cargo new` command followed by its name to create a project:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new` 命令并跟其名称来创建一个项目：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since we are talking about multiple projects, let''s add another library project
    that we can use:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在讨论多个项目，让我们添加另一个库项目，我们可以使用它：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Edit `a-project/src/main.rs` to contain the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `a-project/src/main.rs` 以包含以下代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, add some code to `a-lib/src/lib.rs` that will `stringify` (using the
    `Debug` trait) an incoming variable. Obviously, that also needs some tests to
    show that the function works. Let''s add some tests to compare the outputs of
    number formatting and sequence formatting with `stringify`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向 `a-lib/src/lib.rs` 添加一些代码，该代码将使用 `Debug` 特性对传入的变量进行 `stringify`。显然，这也需要一些测试来显示该函数的功能。让我们添加一些测试来比较使用
    `stringify` 的数字格式化和序列格式化的输出：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s add some configuration to the `Cargo.toml` files of each project to
    reference dependencies:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在每个项目的`Cargo.toml`文件中添加一些配置来引用依赖项：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`a-project` now makes use of the `a-lib` library, but if we are developing
    these at the same time, the switching back and forth (for example, for testing
    `a-lib` after changes) will soon become cumbersome. This is where workspaces come
    in.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`a-project`现在使用了`a-lib`库，但如果我们同时开发这些项目，来回切换（例如，在更改后测试`a-lib`）将很快变得繁琐。这就是工作区发挥作用的地方。'
- en: 'To use `cargo` on both projects at the same time, we have to create `Cargo.toml`
    in `my-workspace`, the parent directory of `a-lib` and `a-project`. It only contains
    two lines:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要同时使用`cargo`处理两个项目，我们必须在`a-lib`和`a-project`的父目录`my-workspace`中创建`Cargo.toml`文件。它只包含两行：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this file in place, `cargo` can execute commands on both projects simultaneously
    and thereby make handling them easier. Let''s compile `cargo test` and see which
    tests are run, along with their (test) results:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个文件，`cargo`可以同时执行两个项目的命令，从而简化处理。让我们编译`cargo test`并查看哪些测试被执行，以及它们的（测试）结果：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As there is only one project that has tests (`a-lib`), it runs those. Let''s
    compile `cargo run` to see the output of running the binary executable project:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于只有一个项目有测试（`a-lib`），它运行了这些测试。让我们编译`cargo run`来查看二进制可执行项目的输出：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解幕后，更好地理解代码。
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a simple binary project (*step 2* and *step 4*) together
    with a library project (*step 3* and *step 5*) that depend on each other. We simply
    specify these dependencies in their `Cargo.toml` files in *step 6* and the workspace
    we created in *step 7* helps us to join the projects together. Now, any commands
    are run on the projects that support them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了一个简单的二进制项目（步骤2和步骤4）以及一个依赖彼此的库项目（步骤3和步骤5）。我们只需在步骤6中指定这些依赖项，并在步骤7中创建的工作区帮助我们将这些项目联合起来。现在，任何命令都在支持它们的项上运行。
- en: 'By building this project (with `cargo run`, `cargo test`, or `cargo build`),
    the tool creates a file containing the current dependency tree (called `Cargo.lock`).
    As a workspace, the output directory for the binaries (`target/`) is also located in
    the workspace directory instead of the individual projects'' directories. Let''s
    check the contents of the directories to see what that looks like and where the
    compiled output can be found (emphasis has been added to the code):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建此项目（使用`cargo run`、`cargo test`或`cargo build`），工具会创建一个包含当前依赖树（称为`Cargo.lock`）的文件。作为工作区，二进制文件的输出目录（`target/`）也位于工作区目录中，而不是单个项目的目录中。让我们检查目录内容，看看它看起来像什么，以及编译输出可以在哪里找到（代码中的重点已被添加）：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another aspect of workspaces is its dependency management. `cargo` synchronizes
    the external project dependencies inside the `Cargo.lock` file for every project
    contained within that workspace. As a result, any external crate will have the
    same version across every project whenever possible. When we added the `rand` crate
    as a dependency, it picked the same version for both projects (because of the
    `*` version in `a-lib`). Here''s part of the resulting `Cargo.lock` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 工作区的一个方面是其依赖项管理。`cargo`同步工作区内每个项目的`Cargo.lock`文件中的外部项目依赖项。因此，任何外部crate都将在可能的情况下在每个项目中具有相同的版本。当我们添加`rand`crate作为依赖项时，它为两个项目选择了相同的版本（因为`a-lib`中的`*`版本）。以下是生成的`Cargo.lock`文件的部分内容：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`cargo` workspaces are a way to handle larger projects by bundling some operations
    at a higher level while leaving most configurations to the individual crates and
    applications. The configuration is simple and results in predictable behavior
    that lets the user build processes around it (for example, collecting all binaries
    from the workspace''s `target/` directory).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo`工作区是一种通过在更高层次捆绑一些操作来处理大型项目的方法，同时将大多数配置留给单个crate和应用程序。配置简单，结果产生可预测的行为，使用户可以围绕它构建构建过程（例如，从工作区的`target/`目录收集所有二进制文件）。'
- en: Another interesting aspect is that `cargo` travels upward to find the most parental
    `Cargo.toml` file before executing a command. Therefore, what seems like the running
    of the tests of a specific project from within its directory results in the running
    of *all*tests of that workspace. Consequently, the commands have to be more specific
    now, for example, by using `cargo test -p a-lib`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的方面是，`cargo` 在执行命令之前会向上查找最父级的 `Cargo.toml` 文件。因此，看起来像是在目录内运行特定项目的测试实际上是在运行该工作空间的所有测试。因此，现在命令必须更加具体，例如，使用
    `cargo test -p a-lib`。
- en: We've successfully learned how to organize large projects with workspaces. Now,
    let's move on to the next recipe!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用工作空间组织大型项目。现在，让我们继续下一个菜谱！
- en: Uploading to crates.io
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传到 crates.io
- en: '`crates.io` ([https://crates.io](https://crates.io)) is Rust''s public repository
    for community crates. This links dependencies together, enables discovery, and
    lets users search for packages. For crate maintainers, it offers usage statistics
    and a place to host a `readme` file. `cargo` makes it possible to publish crates
    quickly and easily, as well as to handle updates. Let''s see how.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`crates.io` ([https://crates.io](https://crates.io)) 是 Rust 的公共仓库，用于社区 crate。它将依赖项链接在一起，启用发现，并允许用户搜索包。对于
    crate 维护者，它提供使用统计信息和托管 `readme` 文件的地方。`cargo` 使得快速轻松地发布 crate 以及处理更新成为可能。让我们看看如何操作。'
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we are going to publish a crate with minimal functionality.
    If you already have source code to work on (that is, your own project), feel free
    to use it. If not, create a new library project using `cargo new public-crate
    --lib` and open it in VS Code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将发布一个具有最小功能性的 crate。如果您已经有了可以工作的源代码（即您自己的项目），请随意使用它。如果没有，请使用 `cargo
    new public-crate --lib` 创建一个新的库项目，并在 VS Code 中打开它：
- en: '![](img/b58444be-9d0c-4649-acaf-818c87121c82.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b58444be-9d0c-4649-acaf-818c87121c82.png)'
- en: 'Go to [https://crates.io](https://crates.io) and log in to your account (using
    [https://github.com](https://github.com)). Then, go to the Account Settings page
    to create a new token (follow the instructions on the page). Log in on the command
    line using your own token:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://crates.io](https://crates.io) 并登录您的账户（使用 [https://github.com](https://github.com)）。然后，转到账户设置页面创建一个新的令牌（按照页面上的说明操作）。使用您自己的令牌在命令行上登录：
- en: '![](img/9708bf28-ce3c-45cf-926c-5883bbb35916.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9708bf28-ce3c-45cf-926c-5883bbb35916.png)'
- en: Let's take a look at the steps we need to perform to upload to `crates.io` ([https://crates.io](https://crates.io)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要执行哪些步骤才能上传到 `crates.io` ([https://crates.io](https://crates.io))。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'With `cargo` logged in and ready to go, follow these steps to publish the library
    to the repository:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cargo` 登录并准备就绪后，按照以下步骤将库发布到仓库：
- en: Open `src/lib.rs` and add some code. The crate in our recipe is only going to
    publish the infamous bubble sort algorithm!
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/lib.rs` 并添加一些代码。我们菜谱中的 crate 只会发布臭名昭著的冒泡排序算法！
- en: At the moment, `crates.io` only uses names as identifiers, which means that
    you can't use the name `bubble-sort` any longer. However, instead of choosing
    a new name, we ask you not to publish a copy of this crate under a different name
    but focus your efforts on crates that are useful to the community.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`crates.io` 只使用名称作为标识符，这意味着您不能再使用 `bubble-sort` 这个名称了。然而，我们不是要求您选择一个新名称，而是要求您不要用不同的名称发布这个
    crate 的副本，而是将精力集中在对社区有用的 crate 上。
- en: 'Here is an implementation from the book *Hands-On Data Structures and Algorithms
    with Rust* ([https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust](https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust)):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自书籍《动手学习 Rust 数据结构和算法》(*Hands-On Data Structures and Algorithms with Rust*)
    ([https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust](https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust))
    的一个实现：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: //!# use bubble_sort::bubble_sort;
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`!# use bubble_sort::bubble_sort;`'
- en: //! let v = vec![2, 2, 10, 1, 5, 4, 3];
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`!# let v = vec![2, 2, 10, 1, 5, 4, 3];`'
- en: //! assert_eq!(bubble_sort(&v), vec![1, 2, 2, 3, 4, 5, 10]);
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`!# assert_eq!(bubble_sort(&v), vec![1, 2, 2, 3, 4, 5, 10]);`'
- en: //![PRE12]
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`!#[PRE12]`'
- en: 'This implementation also comes with tests:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现还附带测试：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, `cargo` makes it possible to customize the landing page on `crates.io`
    using various fields in `Cargo.toml`. The landing page should inform the crate''s
    users about the license (no license means everybody has to get your permission
    to use the code), where to find more information, and maybe even an example. On
    top of that, (quite fancy) badges provide information about the crate''s build
    status, test coverage, and so on. Replace the content of `Cargo.toml` with the
    following snippet (and customize it if you want):'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`cargo` 允许使用 `Cargo.toml` 中的各种字段来自定义 `crates.io` 上的着陆页。着陆页应告知crate的用户关于许可证（没有许可证意味着每个人都必须得到你的许可才能使用代码）、如何找到更多信息，甚至可能是一个示例。除此之外，（相当花哨）徽章提供了关于crate构建状态、测试覆盖率等信息。用以下片段替换
    `Cargo.toml` 中的内容（并根据需要自定义）：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that all of the metadata is sorted out, let''s run `cargo package` to see
    whether the package fulfills the formal criteria:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有元数据都已整理好，让我们运行 `cargo package` 来查看该包是否满足正式标准：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As a friendly reminder, `cargo` makes sure that only committed changes are
    packaged, so the repository and `crates.io` are in sync. Commit the changes (read
    up on Git if you don''t know how: [https://git-scm.com](https://git-scm.com))
    and re-run `cargo package`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为友好的提醒，`cargo` 确保只打包已提交的更改，因此仓库和 `crates.io` 保持同步。提交更改（如果你不知道如何使用 Git，请阅读相关资料：[https://git-scm.com](https://git-scm.com)）并重新运行
    `cargo package`：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, with an authorized `cargo`, let''s make our crate public and run `cargo
    publish`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用授权的 `cargo`，让我们将我们的crate公开并运行 `cargo publish`：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once successful, check out your page at [https://crates.io/crates/bubble-sort](https://crates.io/crates/bubble-sort):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功，查看你的页面 [https://crates.io/crates/bubble-sort](https://crates.io/crates/bubble-sort)：
- en: '![](img/be51839e-e481-488c-b536-9b8fbb9b3e4a.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be51839e-e481-488c-b536-9b8fbb9b3e4a.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Publishing crates is a great way to get recognized by the Rust community and
    make whatever you are creating available to a wider audience. For the community
    to be able to quickly adapt your crate, be sure to use appropriate keywords and
    categories, as well as examples and tests to make it clear and easy to use, something
    that we did in *step 1* and *step 2*. `Cargo.toml` provides many more options
    than specified previously, so check out the documentation, [https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata](https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata), to
    find out more.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 发布crate是让Rust社区认可你的好方法，并让你的作品对更广泛的受众开放。为了使社区能够快速适应你的crate，请确保使用适当的关键词和类别，以及示例和测试来使其清晰易用，这是我们已经在
    *步骤1* 和 *步骤2* 中做到的。`Cargo.toml` 提供了比之前指定的更多选项，因此请查看文档，[https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata](https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata)，以获取更多信息。
- en: The most important property in that file is the package name, which uniquely
    identifies the crate. While there have been incidents on name squatting and selling
    names, this is generally frowned upon and the community strives to find a solution
    to that.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件中最重要的属性是包名，它唯一地标识了crate。虽然曾经发生过名称抢注和出售名称的事件，但这通常是不被赞同的，社区也在努力寻找解决方案。
- en: Once packaged (*step 3* and *step 4*), `cargo` creates a `target/package` directory, which
    contains everything that will be uploaded to `crates.io`. Inside, there is not
    only the source code but also an additional binary file named `project_name-version.crate`.
    If you don't want to upload everything—for example, leaving out videos or large
    example data—`Cargo.toml` allows for exclusion filters as well. By default, everything
    in the directory is included, but it is good practice to keep the size to a minimum!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打包（*步骤3* 和 *步骤4*），`cargo` 会创建一个 `target/package` 目录，其中包含将被上传到 `crates.io`
    的所有内容。在目录中，不仅有源代码，还有一个名为 `project_name-version.crate` 的附加二进制文件。如果你不想上传所有内容——例如，省略视频或大型示例数据——`Cargo.toml`
    允许使用排除过滤器。默认情况下，目录中的所有内容都被包含在内，但将大小保持在最小是良好的实践！
- en: Keep your API tokens secret and out of source control. If you are not sure whether
    a token has been compromised, revoke it!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 保持你的API令牌的秘密，并使其不在源控制中。如果你不确定一个令牌是否已被泄露，请撤销它！
- en: 'In *step 5*, we are uploading the new crate. However, `crates.io` does not
    accept just any upload; here are some examples of the errors you might encounter
    (observe the error messages to fix them):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤5* 中，我们正在上传新的crate。然而，`crates.io` 并不接受任何上传；以下是一些你可能会遇到的错误示例（观察错误信息以修复它们）：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These are actually great notifications since these barriers help programmers
    to avoid simple mistakes, reduce spam, and thereby raise quality. If you follow
    those terms, you'll easily see a version of the step 6 page for your own project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实际上是非常好的通知，因为这些障碍帮助程序员避免简单的错误，减少垃圾邮件，从而提高质量。如果你遵循这些条款，你将很容易看到你自己的项目步骤6页面的一个版本。
- en: We've successfully learned how to upload to [https://crates.io](https://crates.io).
    Now, let's move on to the next recipe!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学会了如何上传到[https://crates.io](https://crates.io)。现在，让我们继续下一个菜谱！
- en: Using dependencies and external crates
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖和外部crate
- en: Reusing other libraries is a common task in software engineering, which is why
    easy dependency management was built into `cargo` from the start. Third-party
    dependencies (called **crates**) are stored in a registry called `crates.io` ([https://crates.io](https://crates.io)),
    a public platform for users to find and discover crates. Private registries are
    also available, starting with Rust 1.34\. With `Cargo.toml` as a central point
    in this process, let's dive into specifying those dependencies well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中重用其他库是一个常见的任务，这就是为什么从开始就内置了`cargo`的简单依赖管理。第三方依赖（称为**crate**）存储在一个名为`crates.io`（[https://crates.io](https://crates.io)）的注册表中，这是一个用户可以找到和发现crate的公共平台。从Rust
    1.34开始，也提供了私有注册表。以`Cargo.toml`作为这个过程的核心点，让我们深入了解如何指定这些依赖。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how dependency management works in these steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在这些步骤中依赖管理是如何工作的：
- en: As we are going to print on the command line, let's create a new binary application
    using `cargo new external-deps` and open it in VS Code.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在命令行上打印，让我们使用`cargo new external-deps`创建一个新的二进制应用程序，并在VS Code中打开它。
- en: 'Open the `Cargo.toml` file to add some dependencies:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Cargo.toml`文件以添加一些依赖：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these added, we need to add some code to the `src/main.rs` file as well:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了这些之后，我们还需要在`src/main.rs`文件中添加一些代码：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, there is `dev-dependency`, which we can use to create benchmarks with
    the stable Rust compiler. For that, create a new folder on the same level as `src/`
    and add a file, `cooking_with_rust.rs`, there. Open it in VS Code and add the
    following code to run a benchmark:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，还有`dev-dependency`，我们可以用它来使用稳定的Rust编译器创建基准测试。为此，在`src/`同一级别创建一个新的文件夹，并在其中添加一个文件，`cooking_with_rust.rs`。在VS
    Code中打开它，并添加以下代码以运行基准测试：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s use these dependencies and see how `cargo` integrates them. Let''s
    execute `cargo run` first:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用这些依赖并看看`cargo`是如何集成它们的。让我们首先执行`cargo run`：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It downloaded and compiled various crates (the download part was omitted as
    it is only done once)—but can you spot what''s missing? It''s the `criterion`
    crate that was specified as `dev-dependency`, and it''s only required for development
    (`test/bench/..`) operations. Let''s run `cargo bench` to see benchmark results
    of the crate, including some basic trends provided by `criterion` (output redacted):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它下载并编译了各种crate（下载部分被省略，因为它只做一次）——但你能否发现缺少了什么？是作为`dev-dependency`指定的`criterion`
    crate，它仅用于开发（`test/bench/..`）操作。让我们运行`cargo bench`来查看crate的基准测试结果，包括由`criterion`提供的一些基本趋势（输出已省略）：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码的更好。
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By specifying the version and name in `Cargo.toml`, `cargo` can download and
    compile the required crates and link them into the project as needed. In fact,
    `cargo` maintains a cache for both crates on `crates.io` and raw `git` dependencies
    (check the `~/.cargo` directory), where it puts recently used crates. This is
    exactly what we did in the first steps by adding dependencies of mixed origin
    to the crate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Cargo.toml`中指定版本和名称，`cargo`可以下载和编译所需的crate，并根据需要将它们链接到项目中。实际上，`cargo`维护了`crates.io`上的crate和原始`git`依赖的缓存（检查`~/.cargo`目录），其中放置了最近使用的crate。这正是我们在第一步中通过向crate添加混合来源的依赖所做的事情。
- en: One of these origins is a  `git` repository, but can alternatively take the
    shape of local paths to directories. Additionally, by passing an object (as seen
    in the `regex` crate in *step 1*), we can specify features for a crate (as shown
    in the `serde` dependency in *step 1*) or use an entire section called `dev-dependencies` for
    dependencies that are not shipped in the target output. The result is a dependency
    tree that is serialized in `Cargo.lock`. The use of the `dev-dependency` criterion
    is shown in *step 6*. The remaining steps show how to use external dependencies
    and the various versions downloaded and compiled by `cargo`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些来源之一是一个`git`仓库，但也可以是目录的本地路径。此外，通过传递一个对象（如在*步骤1*中看到的`regex` crate），我们可以指定crate的功能（如在*步骤1*中显示的`serde`依赖项）或使用名为`dev-dependencies`的整个部分来指定不包含在目标输出中的依赖项。结果是序列化在`Cargo.lock`中的依赖项树。`dev-dependency`准则的使用在*步骤6*中显示。其余步骤显示了如何使用外部依赖项以及`cargo`下载和编译的各种版本。
- en: 'The version specification in `Cargo.toml` is its own mini-language, and it
    will only upgrade with certain restrictions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo.toml`中的版本规范是其自己的迷你语言，并且它只会根据某些限制进行升级：'
- en: A single number specifies the major version (a pattern of `<major>.<minor>.<patch>`
    is mandatory in Rust) but leaves the others open for `cargo` to decide (usually
    the latest version)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单独的数字指定主版本（在Rust中，`<major>.<minor>.<patch>`模式是强制性的）但其他版本留给`cargo`决定（通常是最新版本）
- en: More accurate versions leave less room for interpretation
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更精确的版本留下了更少的解释空间
- en: '`*` means any available version, with the latest preferred'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`表示任何可用版本，最新版本优先'
- en: There are more characters and symbols to put into the version string, yet these
    will typically suffice. Check out [https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html)
    for more examples. The `cargo upgrade` command will also check for the latest
    versions the specification allows and update them accordingly. If you plan to
    build a crate that is used by others, it's recommended to run `cargo upgrade` every
    once in a while to see it didn't miss any security/patch updates. The Rust project
    even recommends putting the `Cargo.lock` file in source control to avoid unintentionally
    breaking the crate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 版本字符串中可以包含更多字符和符号，但通常这些就足够了。更多示例请查看[https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html)。`cargo
    upgrade`命令也会检查规范允许的最新版本，并相应地更新它们。如果你计划构建其他人使用的crate，建议偶尔运行`cargo upgrade`以查看是否遗漏了任何安全/补丁更新。Rust项目甚至建议将`Cargo.lock`文件放入源代码控制中，以避免意外破坏crate。
- en: It is good practice to minimize the number of required crates and to keep them
    as up to date as possible. Your users will want to do the same.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最好尽量减少所需的crate数量，并尽可能保持它们是最新的。你的用户也会希望这样做。
- en: See also...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容...
- en: With 1.34, Rust also allows private repositories. Read more about this on the
    following blog post: [https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#alternative-cargo-registries](https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#alternative-cargo-registries). We've
    now successfully learned how to use dependencies and external crates. Now, let's
    move on to the next recipe!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 1.34 版本也允许私有仓库。有关更多信息，请参阅以下博客文章：[https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#alternative-cargo-registries](https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#alternative-cargo-registries)。我们现在已经成功学习了如何使用依赖项和外部crate。现在，让我们继续下一个菜谱！
- en: Extending cargo with sub-commands
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过子命令扩展cargo
- en: 'These days, everything is extensible. Whether they are called plugins, extensions,
    add-ons, or sub-commands—everything is about customizing the (developer) experience.
    `cargo` provides a very easy path to achieve this: by using a binary''s name.
    This allows for quickly extending the `cargo` base to include functions that are
    specific to your own use case or way of working. In this recipe, we are going
    to build our own extension.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，一切都可以扩展。无论是称为插件、扩展、附加组件还是子命令——一切都是为了定制（开发者）体验。`cargo`提供了一个非常简单的方法来实现这一点：通过使用二进制文件名。这允许快速扩展`cargo`基础，包括针对你自己的用例或工作方式特定的功能。在这个菜谱中，我们将构建自己的扩展。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will stay on the command line and we will use a sample code
    for a simple binary, so open a Terminal/PowerShell (we are using PowerShell features
    on Windows) to run the commands in this recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将停留在命令行，并使用一个简单的二进制示例代码，因此请打开终端/PowerShell（我们在Windows上使用PowerShell功能）以运行这个菜谱中的命令。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Extending `cargo` is surprisingly easy. To do this, perform the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `cargo` 意外地简单。要完成此操作，请执行以下步骤：
- en: 'Create a new Rust binary application project with the following command: `cargo
    new cargo-hello`.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个新的 Rust 二进制应用程序项目：`cargo new cargo-hello`。
- en: Change into the directory with `cd cargo-hello` and build it using `cargo build`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `cargo-hello` 目录，并使用 `cargo build` 构建它。
- en: 'Add the `target/debug` folder of the current project that is located at your
    `PATH` variable. On Linux and Mac (using bash), it''s simply as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前项目位于您的 `PATH` 变量中的 `target/debug` 文件夹添加到您的 `PATH` 变量中。在 Linux 和 Mac（使用 bash）上，操作如下：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On Windows, you can use PowerShell to achieve the same goal with this code
    script:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，您可以使用 PowerShell 通过以下代码脚本达到相同的目的：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Within the same window, you should now be able to run `cargo-hello` (`cargo-hello.exe`
    on Windows) from any directory on the computer.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个窗口中，您现在应该能够在计算机上的任何目录中运行 `cargo-hello`（Windows 上的 `cargo-hello.exe`）。
- en: 'Additionally, `cargo` can now run `hello` as a sub-command. Try running `cargo
    hello` in any directory on the computer. From here, you will see the following
    output:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`cargo` 现在可以将 `hello` 作为子命令运行。尝试在计算机上的任何目录中运行 `cargo hello`。从这里，您将看到以下输出：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now let's go behind the scenes to understand the code better.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`cargo` picks up any executable starting with `cargo-` that''s available in
    the `PATH` environment variable. Directories listed in there are used to discover
    command-line executables in *nix systems.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo` 会拾取任何以 `cargo-` 开头且在 `PATH` 环境变量中可用的可执行文件。在 *nix 系统中，列出的目录用于发现命令行可执行文件。'
- en: 'For `cargo` to integrate these extensions seamlessly, their names have to meet
    a few conditions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `cargo` 无缝集成这些扩展，它们的名称必须满足一些条件：
- en: These binaries have to be executable on the current platform
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些二进制文件必须在当前平台上可执行
- en: The name starts with `cargo-`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称以 `cargo-` 开头
- en: The containing folder is listed in the `PATH` variable
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含的文件夹列在 `PATH` 变量中
- en: On Linux/macOS, these executables can also be shell scripts—something that's
    very useful for improving the developer workflow. However, these scripts have
    to look just like a binary and therefore have no file ending. Then, instead of
    running several commands, such as `cargo publish`, `git tag`, and `git push`, `cargo
    shipit` can significantly improve speed and consistency.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux/macOS 上，这些可执行文件也可以是 shell 脚本——这对于提高开发者工作流程非常有用。然而，这些脚本必须看起来像二进制文件，因此没有文件扩展名。然后，而不是运行多个命令，例如
    `cargo publish`、`git tag` 和 `git push`，`cargo shipit` 可以显著提高速度和一致性。
- en: Additionally, any `cargo` sub-command can take command-line arguments that are
    passed after the command, and the working directory is the directory the command
    is run from by default. With that knowledge, we hope that you can now add to `cargo` features!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何 `cargo` 子命令都可以接受命令行参数，这些参数是在命令之后传递的，并且默认情况下工作目录是命令运行的目录。有了这些知识，我们希望您现在可以向
    `cargo` 功能添加更多内容！
- en: We've successfully learned how to extend cargo with sub-commands. Now, let's
    move on to the next recipe!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何通过子命令扩展 cargo。现在，让我们继续下一个菜谱！
- en: Testing your project with cargo
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 cargo 测试项目
- en: While in a previous recipe we focused on writing tests, this recipe is about
    *running *them. Tests are an important part of software engineering since it ensures
    that we put ourselves in the user's shoes and double-checked to see whether what
    we created is working. While many other languages require a separate test-runner, `cargo` comes
    with this functionality included!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们专注于编写测试，而这个菜谱则是关于*运行*它们。测试是软件工程的重要组成部分，因为它确保我们站在用户的角度，并再次检查我们所创建的内容是否正常工作。虽然许多其他语言需要单独的测试运行器，但
    `cargo` 内置了这一功能！
- en: Let's explore how `cargo` helps with this process in this recipe.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这个菜谱中探索 `cargo` 如何帮助这个过程。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To explore `cargo` testing capabilities, follow these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索 `cargo` 测试功能，请按照以下步骤操作：
- en: Create a new project on the command line with `cargo new test-commands --lib`
    and open the resulting folder in VS Code.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new test-commands --lib` 在命令行中创建一个新的项目，并在 VS Code 中打开生成的文件夹。
- en: 'Next, replace the content in `src/lib.rs` with the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `src/lib.rs` 中的内容替换为以下内容：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we did in other recipes, we can execute all tests with the `cargo test`
    command:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在其他菜谱中所做的那样，我们可以使用 `cargo test` 命令执行所有测试：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To iterate quickly, `cargo` allows us to carry out a specific test as well
    by using `cargo test <test-name>`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了快速迭代，`cargo` 允许我们通过使用 `cargo test <test-name>` 来执行特定的测试：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another useful way to run tests is without capturing their output. By default,
    the testing harness won''t print anything from inside the tests. Sometimes, it''s
    useful to have some testing output, so let''s use `cargo test -- --nocapture`
    to see the output:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试的另一种有用方法是不要捕获它们的输出。默认情况下，测试框架不会从测试内部打印任何内容。有时，有一些测试输出是有用的，所以让我们使用`cargo
    test -- --nocapture`来查看输出：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All tests are run in parallel, which sometimes leads to unexpected results.
    To adjust this behavior, we can use `cargo test -- --test-threads <no-of-threads>`
    to control the number of threads. Let''s compare using four threads and one thread
    to see the difference. We will use the `time` program to show the runtime in seconds
    (this is optional if you don''t have `time`). Let''s start with four:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有测试都是并行运行的，这有时会导致意外结果。为了调整这种行为，我们可以使用`cargo test -- --test-threads <线程数>`来控制线程数。让我们比较使用四个线程和一个线程的差异。我们将使用`time`程序来显示运行时间（如果你没有`time`，这是可选的）。让我们从四个线程开始：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is fast, compared to a single thread:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与单线程相比，这要快得多：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, we can also filter multiple tests as well, such as all tests starting
    with `wait`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还可以过滤多个测试，例如所有以`wait`开头的测试：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码以更好地理解它。
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Rust's built-in testing library is called `libtest` and it is what's invoked
    by `cargo`. Regardless of the type of project created (binary application or library),
    `libtest` runs the associated test and outputs the result. In this recipe, we
    are examining running the tests of a previously created project—however, these
    steps obviously work for any project with tests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的内置测试库称为 `libtest`，它是通过 `cargo` 调用的。无论创建的项目类型（二进制应用程序或库）如何，`libtest`都会运行相关的测试并输出结果。在这个菜谱中，我们正在检查运行之前创建的项目中的测试——然而，这些步骤显然适用于任何有测试的项目。
- en: In *step 2*, we created a small library that features four tests, two of which
    print things to the command line just after waiting for a few seconds (five and
    ten seconds). This allows us to show threaded test running and that the test harness
    captures the output by default.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们创建了一个包含四个测试的小型库，其中两个测试在等待几秒钟（五秒和十秒）后向命令行打印内容。这使我们能够展示线程化测试运行，并且测试框架默认会捕获输出。
- en: Other than filtering the list of available tests (we do that in *step 4* and
    *step 7*) in the project, `libtest` takes command-line arguments to customize
    the output, logging, threads, and many more things. Find out more by invoking
    `cargo test -- --help`. Note the double dashes (`--`), which tell `cargo` to pass
    any following arguments into `libtest`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在项目中过滤可用的测试列表（我们在*步骤 4*和*步骤 7*中这样做）之外，`libtest`还接受命令行参数来自定义输出、日志、线程以及许多其他事情。通过调用`cargo
    test -- --help`来了解更多信息。注意双横线（`--`），这告诉`cargo`将任何后续参数传递给`libtest`。
- en: 'As the options already indicate: all tests are run in parallel unless stated
    otherwise, an option that we change in *step 6* with noticeable results (15 seconds
    with a single thread versus 10 seconds multi-threaded—just like the longest sleep
    time). Use this option to debug race conditions or other runtime behavior.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如选项所表明的：除非另有说明，否则所有测试都是并行运行的，我们在*步骤 6*中更改了此选项，并取得了显著的效果（单线程时为 15 秒，多线程时为 10
    秒——就像最长的睡眠时间一样）。使用此选项来调试竞态条件或其他运行时行为。
- en: '*Step 5* uses an option to show the standard output, which appears in a different
    order than how we wrote the test functions. This is the result of concurrent execution,
    so combining the options to limit the number of threads with the output capture
    will linearly execute the tests. We conclude the steps by filtering for multiple
    tests in *step 7*.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 5*使用一个选项来显示标准输出，其顺序与我们编写的测试函数不同。这是并发执行的结果，因此结合限制线程数的选项和输出捕获将线性执行测试。我们通过在*步骤
    7*中过滤多个测试来结束步骤。'
- en: We've successfully learned how to test our project with `cargo`. Now, let's
    move on to the next recipe!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用`cargo`测试我们的项目。现在，让我们继续下一个菜谱！
- en: Continuous integration with cargo
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 cargo 的持续集成
- en: Automation is an important aspect of today's software engineering. Whether it
    is infrastructure as code or functions as a service, many things are expected
    to automatically work as expected. However, the notion of a central testing and
    deployment infrastructure based on certain rules is much older (called **ALM**—**Application
    Lifecycle Management**) and with modern tools, it is incredibly easy. `cargo`
    was built to support this stateless infrastructure with reasonable defaults and
    an easy interface to customize them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是当今软件工程的一个重要方面。无论是基础设施即代码还是函数即服务，许多事情都期望自动按预期工作。然而，基于某些规则的中心测试和部署基础设施的概念要古老得多（称为
    **ALM**—**应用生命周期管理**），并且使用现代工具，它变得极其简单。`cargo` 是为了支持这种无状态基础设施而构建的，它具有合理的默认值和易于定制的用户界面。
- en: In this recipe, we will take a look at how to build Rust applications using
    Microsoft's Azure DevOps platform as an example.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将以 Microsoft 的 Azure DevOps 平台为例，看看如何构建 Rust 应用程序。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: While the Azure DevOps repository ([https://azure.microsoft.com/en-us/services/devops/?nav=min](https://azure.microsoft.com/en-us/services/devops/?nav=min))
    is accessible for anyone, it is highly recommended to create a Microsoft account
    and make use of the free tier to reproduce the example. Go to [https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/) and
    follow the instructions to get started.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Azure DevOps 仓库 ([https://azure.microsoft.com/en-us/services/devops/?nav=min](https://azure.microsoft.com/en-us/services/devops/?nav=min))
    对任何人都是可访问的，但强烈建议创建一个 Microsoft 账户并利用免费层来重现示例。访问 [https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)
    并按照说明开始操作。
- en: To have a ready-made project to work on, we are re-using the `bubble-sort` crate
    from the *Uploading to crates.io* recipe earlier in this chapter and uploading
    it to a source code hosting service such as Azure DevOps or GitHub.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个现成的项目来工作，我们正在重用本章前面提到的 *Uploading to crates.io* 菜单中的 `bubble-sort` crate，并将其上传到源代码托管服务，如
    Azure DevOps 或 GitHub。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open a browser window and navigate to [https://dev.azure.com](https://dev.azure.com),
    sign in, and find the project you created. Then, follow these steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器窗口，导航到[https://dev.azure.com](https://dev.azure.com)，登录，并找到您创建的项目。然后，按照以下步骤操作：
- en: Azure DevOps is an all-in-one solution for project management, so we are pushing
    our source code to the available repository. Follow the repository setup guide
    to do that.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure DevOps 是项目管理的一站式解决方案，因此我们将源代码推送到可用的仓库。遵循仓库设置指南来完成此操作。
- en: 'Pipelines are the continuous integration part of Azure DevOps. They orchestrate
    build agents (machines to run the build on) and provide a visual interface to
    put together a step-by-step build process. Create a new pipeline from an empty
    job template:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道是 Azure DevOps 的持续集成部分。它们编排构建代理（运行构建的机器）并提供一个可视化界面来逐步构建过程。从空作业模板创建一个新的管道：
- en: '![](img/a59bb95c-6db6-42ee-b3e4-2d2513b95f69.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a59bb95c-6db6-42ee-b3e4-2d2513b95f69.png)'
- en: 'Inside each pipeline, there are several jobs—several steps that run on the
    same agent, but we only need one. Click on the + symbol on the right of the predefined
    Agent job 1 and search for a build task named `rust`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个管道内部，有几个作业——几个在同一代理上运行的步骤，但我们只需要一个。点击预定义代理作业 1 右侧的 + 符号，搜索名为 `rust` 的构建任务：
- en: '![](img/33bd03de-388b-418e-ac46-0766828371ea.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33bd03de-388b-418e-ac46-0766828371ea.png)'
- en: 'Since that particular build task is available on the Marketplace (thanks to
    Sylvain Pontoreau: [https://github.com/spontoreau/rust-azure-devops](https://github.com/spontoreau/rust-azure-devops)),
    we have to add it to our project.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '由于特定的构建任务在市场（归功于 Sylvain Pontoreau: [https://github.com/spontoreau/rust-azure-devops](https://github.com/spontoreau/rust-azure-devops)）上可用，我们必须将其添加到我们的项目中。'
- en: 'After *purchasing* (it''s free) the task blueprint, we can add and configure
    it in our pipeline. It''s useful to have a build that runs tests, but CI systems
    are very flexible and you can get very creative. Your screen should now look like
    this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *购买*（它是免费的）任务蓝图后，我们可以在管道中添加和配置它。有一个运行测试的构建非常有用，但 CI 系统非常灵活，你可以非常富有创意。现在，您的屏幕应该看起来像这样：
- en: '![](img/b6da739c-d057-4c0f-8309-6eb649c9192b.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6da739c-d057-4c0f-8309-6eb649c9192b.png)'
- en: 'Use the first task as it is (no configuration needed) since it is only installing
    the tools using `rustup`. The second task simply runs `cargo test`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第一个任务（无需配置），因为它只是使用 `rustup` 安装工具。第二个任务简单地运行 `cargo test`：
- en: '![](img/ae7d5606-cbb9-4d1b-a3c8-62d1eea983b8.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae7d5606-cbb9-4d1b-a3c8-62d1eea983b8.png)'
- en: 'As the last step, queue the build and check its progress. If you followed the
    recipe, it will result in a successful build and you can start using it to check
    pull requests, add badges on `crates.io`, and much more:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，排队构建并检查其进度。如果你遵循了配方，它将导致构建成功，你可以开始使用它来检查拉取请求，在 `crates.io` 上添加徽章，以及更多：
- en: '![](img/73371632-2ab6-4bf1-b5ee-6b1a60e760e6.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73371632-2ab6-4bf1-b5ee-6b1a60e760e6.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以便更好地理解它。
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Azure DevOps is a fully integrated solution for project management, issue tracking,
    source code hosting, and building and deploying solutions. Similar offerings are
    GitHub (also owned by Microsoft), GitLab ([https://about.gitlab.com](https://about.gitlab.com)),
    or Atlassian's Bitbucket ([https://bitbucket.org](https://bitbucket.org)). Together
    with CircleCI ([https://circleci.com](https://circleci.com)) or Travis CI ([https://travis-ci.org/](https://travis-ci.org/)),
    these platforms offer powerful tools for teams to make sure that every new deployment
    reliably meets their goals without large management overhead.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps 是一个集成的项目管理、问题跟踪、源代码托管、构建和部署解决方案的解决方案。类似的产品还有 GitHub（也由微软拥有）、GitLab
    ([https://about.gitlab.com](https://about.gitlab.com)) 或 Atlassian 的 Bitbucket
    ([https://bitbucket.org](https://bitbucket.org))。与 CircleCI ([https://circleci.com](https://circleci.com))
    或 Travis CI ([https://travis-ci.org](https://travis-ci.org/)) 一起，这些平台为团队提供了强大的工具，以确保每次新部署都能可靠地达到他们的目标，而无需大量管理开销。
- en: 'The basic idea is simple: by making the build work on a neutral platform, most
    of the obvious mistakes (missing dependencies or relying on environment specifics)
    can easily be avoided while running the same tests that have to run locally. On
    top of that, running every test might be demanding on large projects, and dedicated
    infrastructure takes care of that.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想很简单：通过使构建在中立平台上工作，大多数明显的错误（缺少依赖项或依赖于环境特定性）可以很容易地避免，同时运行必须在本地上运行的相同测试。除此之外，对于大型项目来说，运行每个测试可能要求很高，而专用基础设施则负责处理这一点。
- en: Since computers are notoriously picky, the results of running tests are also
    visible and can be used to prohibit certain actions, such as deploying to production
    with failing tests. In a way, a continuous integration system holds the developer
    accountable to their own rules (tests).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算机非常挑剔，测试运行的结果也是可见的，并且可以用来禁止某些操作，例如在测试失败的情况下部署到生产环境。从某种意义上说，持续集成系统使开发者对其自己的规则（测试）负责。
- en: '`cargo` support is implicit by being a good citizen in stateless systems. Instead
    of failing if certain conditions are not met, it tries to mitigate late terminations
    and requires little configuration to begin with. Its ability to handle dependencies
    easily and well adds to that and the support for sub-commands makes it a great
    way to build across platforms.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo` 支持是通过在无状态系统中成为良好公民来隐式实现的。它不会因为某些条件未满足而失败，而是试图减轻晚期终止，并且一开始只需要很少的配置。它处理依赖关系轻松且良好的能力，加上对子命令的支持，使其成为跨平台构建的绝佳方式。'
- en: 'Here are some ideas of what you can do besides running `cargo test`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于除了运行 `cargo test` 之外你可以做的事情的想法：
- en: Run benchmarks
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: Run integration tests
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行集成测试
- en: Format code
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化代码
- en: Accept PRs only on successful tests
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在测试成功时接受 PR
- en: Generate documentation
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文档
- en: Do static code analysis
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行静态代码分析
- en: Azure DevOps also supports release pipelines, which should be used for tasks
    such as publishing to `crates.io` (or other package repositories), updating the
    hosted documentation, and more. Read the Azure DevOps documentation ([https://docs.microsoft.com/en-us/azure/devops/?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/?view=azure-devops))
    on how to do that. For anyone who prefers YAML ([https://yaml.org/](https://yaml.org/)) files
    to configure CI pipelines, Azure DevOps supports these as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps 还支持发布管道，这些管道应用于诸如发布到 `crates.io`（或其他软件包仓库）、更新托管文档等任务。有关如何操作的说明，请参阅
    Azure DevOps 文档（[https://docs.microsoft.com/en-us/azure/devops/?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/?view=azure-devops)）。对于更喜欢
    YAML ([https://yaml.org/](https://yaml.org/)) 文件来配置 CI 管道的用户，Azure DevOps 也支持这些文件。
- en: Thanks to Sylvain Pontoreau's work ([https://twitter.com/bla](https://twitter.com/bla))
    on creating easy-to-use task templates, we can quickly set build, test, or other
    pipelines. Doing it manually can be tricky to get right for every platform and
    maintaining downloads and shell scripts is a hassle for most developers. If you
    are using his work, he is happy to hear about it as well—for example, on Twitter
    ([https://twitter.com/spontoreau](https://twitter.com/spontoreau)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Sylvain Pontoreau在创建易于使用的任务模板方面的工作([https://twitter.com/bla](https://twitter.com/bla))，我们可以快速设置构建、测试或其他流水线。手动操作对于每个平台来说可能很棘手，对于大多数开发者来说，维护下载和shell脚本也是一件麻烦事。如果你在使用他的工作，他也很乐意听到这个消息——例如，在Twitter([https://twitter.com/spontoreau](https://twitter.com/spontoreau))上。
- en: We've successfully learned how to continuously integrate with `cargo`. Now,
    let's move on to the next recipe!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何与`cargo`进行持续集成。现在，让我们继续下一道菜谱！
- en: Customizing the build
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义构建
- en: '`cargo` is versatile—something that we have already established in the previous
    recipes in this chapter. However, we did not touch configuring the tools `cargo`
    uses to compile and run Rust projects. For this, there are multiple ways, as they
    apply to different domains.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo`是多功能的——这是我们在这个章节的前几道菜谱中已经确立的。然而，我们没有触及配置`cargo`用于编译和运行Rust项目的工具。为此，有多种方法，因为它们适用于不同的领域。'
- en: In this recipe, we are going to explore two ways by customizing the build of
    a new project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过自定义新项目的构建来探索两种方法。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here''s how to customize a build:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何自定义构建：
- en: Create a new binary project using `cargo new custom-build` and open the project
    folder using VS Code.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new custom-build`创建一个新的二进制项目，并使用VS Code打开项目文件夹。
- en: 'Open `src/main.rs` and replace the hello world code with the following:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/main.rs`并将hello world代码替换为以下内容：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The code in our binary is now creating an overflow situation that a compiler
    can easily catch. However, the default release build has that feature turned off.
    Run `cargo run --release` to see it in action:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们二进制中的代码现在正在创建一个编译器可以轻松捕获的溢出情况。然而，默认的发布构建已经关闭了该功能。运行`cargo run --release`来查看其效果：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we wanted to change the fact that the compiler verifies overflow errors
    at compile time in release mode (even though overflows can be *useful*, for example,
    in hardware drivers), we have to edit `Cargo.toml` and customize the profile for
    `release` (there are others as well, for example, `dev` and `test`). While we
    are there we can change a few other options for faster builds (important for larger
    projects):'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要改变编译器在发布模式下在编译时验证溢出错误的事实（即使溢出在硬件驱动程序中可能是有用的），我们必须编辑`Cargo.toml`并自定义`release`配置文件（还有其他配置，例如`dev`和`test`）。当我们到达那里时，我们可以更改一些其他选项以加快构建速度（这对于大型项目来说很重要）：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we run `cargo run --release` now, the output has changed:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们运行`cargo run --release`，输出已经改变：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That was easy—but there is more! Create a `.cargo` directory at the root of
    the project and add a `config` file inside. Since the file (and directory) is
    inside the project, that''s its scope. However, it''s possible to make it valid
    for a larger number of projects by moving the `.cargo` directories up several
    levels. Be aware that the user''s home directory represents *global scope*, which
    means the `cargo` configuration applies to all of the user''s projects. The following
    settings switch the default build target to WASM output ([https://webassembly.org/](https://webassembly.org/))
    and rename the build artifact directory `out` (the default is `target`):'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很简单——但还有更多！在项目的根目录下创建一个`.cargo`目录，并在其中添加一个`config`文件。由于文件（和目录）位于项目内部，这就是它的作用域。然而，通过将`.cargo`目录向上移动几个级别，可以使它对更多的项目有效。请注意，用户的家目录代表*全局作用域*，这意味着`cargo`配置适用于用户的所有项目。以下设置将默认构建目标切换为WASM输出([https://webassembly.org/](https://webassembly.org/))并将构建工件目录重命名为`out`（默认为`target`）：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s remove the overflow from `src/main.rs`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们从`src/main.rs`中移除溢出：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Compile with `cargo build` and `cargo run` to see what''s happening:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo build`和`cargo run`进行编译以查看发生了什么：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are many aspects of a project that can be configured, most of which are
    not needed for smaller programs and libraries (unless it's for special architectures).
    This recipe can only show a few—easy—examples of what's possible, but there is
    more in the `cargo` book about configuration ([https://doc.rust-lang.org/cargo/reference/config.html](https://doc.rust-lang.org/cargo/reference/config.html))
    and the manifest ([https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections](https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 项目有许多方面可以进行配置，其中大多数对于较小的程序和库来说并不需要（除非是为了特殊架构）。这个配方只能展示一些——简单的——可能的例子，但在`cargo`手册中关于配置([https://doc.rust-lang.org/cargo/reference/config.html](https://doc.rust-lang.org/cargo/reference/config.html))和清单([https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections](https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections))有更多内容。
- en: In the first steps, `cargo` is configured to overlook overflow errors by changing
    a flag in the `cargo` configuration. While it might seem a foolish step at first,
    it is sometimes necessary to allow overflows for drivers or other low-level electronics
    to operate.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，通过更改`cargo`配置中的一个标志来配置`cargo`以忽略溢出错误。虽然一开始这可能看起来是一个愚蠢的步骤，但有时为了允许驱动程序或其他低级电子设备运行，这是必要的。
- en: Many other options customize the developer experience (for example, setting
    the name and email address for new projects, aliases, and many more) or prove
    useful in non-standard settings, for example, when creating device drivers, operating
    systems, or real-time software for specialized hardware. We might use some of
    these later on in [Chapter 9](d229ae85-1922-45fc-ab87-b1de7a533f9b.xhtml), *Systems
    Programming Made Easy*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他选项定制了开发者的体验（例如，为新项目设置名称和电子邮件地址、别名等）或在非标准设置中很有用，例如，在创建设备驱动程序、操作系统或为专用硬件的实时软件时。我们可能在[第9章](d229ae85-1922-45fc-ab87-b1de7a533f9b.xhtml)，《系统编程变得简单》中稍后使用其中的一些。
- en: However, changing the `build` section (as in `cargo build`) has grave consequences
    as it represents the standard output format for the project. It might seem arbitrary
    to change it to something like WASM, but as a default, it can save many steps
    for the developer to set up the development environment—or to simply make CI build
    scripts less verbose.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更改`build`部分（如在`cargo build`中）有严重的后果，因为它代表了项目的标准输出格式。将其更改为类似WASM的东西可能看起来很随意，但作为默认设置，它可以节省开发者设置开发环境的许多步骤——或者简单地使CI构建脚本不那么冗长。
- en: In any case, `cargo` is very flexible and easy to configure, but it's tailored
    to each project individually. Check out the manifest and documentation to find
    out how it can make your project (and your life) easier.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，`cargo`非常灵活且易于配置，但它针对每个项目单独定制。查看清单和文档，了解它如何使你的项目（以及你的生活）变得更简单。
