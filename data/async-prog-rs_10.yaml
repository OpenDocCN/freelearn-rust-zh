- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Creating Your Own Runtime
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的自己的运行时
- en: In the last few chapters, we covered a lot of aspects that are relevant to asynchronous
    programming in Rust, but we did that by implementing alternative and simpler abstractions
    than what we have in Rust today.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几章中，我们涵盖了与 Rust 的异步编程相关的许多方面，但我们是通过实现比 Rust 当前的抽象更替代和更简单的抽象来做到这一点的。
- en: This last chapter will focus on bridging that gap by changing our runtime so
    that it works with Rust futures and async/await instead of our own futures and
    coroutine/wait. Since we’ve pretty much covered everything there is to know about
    coroutines, state machines, futures, wakers, runtimes, and pinning, adapting what
    we have now will be a relatively easy task.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章将专注于通过改变我们的运行时，使其与 Rust 的 futures 和 async/await 一起工作，而不是我们自己的 futures 和
    coroutine/wait 来弥合这个差距。由于我们已经几乎涵盖了关于协程、状态机、futures、wakers、运行时和 pinning 的所有知识，因此调整我们现在所拥有的将是一个相对简单的任务。
- en: When we get everything working, we’ll do some experiments with our runtime to
    showcase and discuss some of the aspects that make asynchronous Rust somewhat
    difficult for newcomers today.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切正常工作时，我们将对我们的运行时进行一些实验，以展示和讨论一些使异步 Rust 对新用户来说有些困难的方面。
- en: We’ll also take some time to discuss what we might expect in the future with
    asynchronous Rust before we summarize what we’ve done and learned in this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结本书中我们所做和所学的内容之前，我们将花一些时间讨论在异步 Rust 中我们可能期待的未来。
- en: 'We’ll cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: Creating our own runtime with futures and async/await
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 futures 和 async/await 创建我们的运行时
- en: Experimenting with our runtime
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们的运行时进行实验
- en: Challenges with asynchronous Rust
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步 Rust 的挑战
- en: The future of asynchronous Rust
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步 Rust 的未来
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples in this chapter will build on the code from the last chapter, so
    the requirements are the same. The example is cross-platform and will work on
    all platforms that Rust ([https://doc.rust-lang.org/beta/rustc/platform-support.html#tier-1-with-host-tools](https://doc.rust-lang.org/beta/rustc/platform-support.html#tier-1-with-host-tools))
    and `mio` (https://github.com/tokio-rs/mio#platforms) support.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将基于上一章的代码，因此要求相同。示例是跨平台的，将在所有 Rust ([https://doc.rust-lang.org/beta/rustc/platform-support.html#tier-1-with-host-tools](https://doc.rust-lang.org/beta/rustc/platform-support.html#tier-1-with-host-tools))
    和 `mio` (https://github.com/tokio-rs/mio#platforms) 支持的平台上运行。
- en: The only thing you need is Rust installed and the book’s repository downloaded
    locally. All the code in this chapter can be found in the `ch10` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您唯一需要的是安装 Rust 并下载本书的存储库。本章中的所有代码都可以在 `ch10` 文件夹中找到。
- en: We’ll use `delayserver` in this example as well, so you need to open a separate
    terminal, enter the `delayserver` folder at the root of the repository, and type
    `cargo run` so it’s ready and available for the examples going forward.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们也将使用 `delayserver`，因此您需要打开一个单独的终端，进入存储库根目录下的 `delayserver` 文件夹，并输入
    `cargo run` 以确保它已准备好并可供后续示例使用。
- en: Remember to change the ports in the code if for some reason you have to change
    what port `delayserver` listens on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因您需要更改 `delayserver` 监听的端口，请记住在代码中更改端口。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Okay, so we’re in the home stretch; the last thing we’ll do is change our runtime
    so it uses the Rust `Future` trait, `Waker`, and `async/await`. This will be a
    relatively easy task for us now that we’ve pretty much covered the most complex
    aspects of asynchronous programming in Rust by building everything up ourselves.
    We have even gone into quite some detail on the design decisions that Rust had
    to make along the way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们已经到了最后阶段；我们最后要做的就是改变我们的运行时，使其使用 Rust 的 `Future` 特性、`Waker` 和 `async/await`。现在我们已经通过自己构建一切来覆盖了
    Rust 异步编程的几乎所有复杂方面，这将对我们来说是一个相对简单的任务。我们甚至对 Rust 在此过程中不得不做出的设计决策进行了相当详细的探讨。
- en: The asynchronous programming model Rust has today is the result of an evolutionary
    process. Rust started in its early stages with green threads, but this was before
    it reached version 1.0\. At the point of reaching version 1.0, Rust didn’t have
    the notion of futures or asynchronous operations in its standard library at all.
    This space was explored on the side in the futures-rs crate ([https://github.com/rust-lang/futures-rs](https://github.com/rust-lang/futures-rs)),
    which still serves as a nursery for async abstractions today. However, it didn’t
    take long before Rust settled around a version of the `Future` trait similar to
    what we have today, often referred to as *futures 0.1*. Supporting coroutines
    created by async/await was something that was in the works already at that point
    but it took a few years before the design reached its final stage and entered
    the stable version of the standard library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 当前的异步编程模型是经过演化过程的结果。Rust 在其早期阶段开始使用绿色线程，但那时它还没有达到 1.0 版本。在达到 1.0 版本时，Rust
    的标准库中根本就没有 futures 或异步操作的概念。这个空间在 futures-rs crate ([https://github.com/rust-lang/futures-rs](https://github.com/rust-lang/futures-rs))
    中得到了探索，这个 crate 仍然是异步抽象的摇篮。然而，不久 Rust 就围绕一个类似于我们今天的 `Future` 特征的版本稳定下来，通常被称为 *futures
    0.1*。支持由 async/await 创建的协程已经在进行中，但设计达到最终阶段并进入标准库的稳定版本还需要几年时间。
- en: So, many of the choices we had to make with our async implementation are real
    choices that Rust had to make along the way. However, it all brings us to this
    point, so let’s get to it and start adapting our runtime so it works with Rust
    futures.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在异步实现中做出的许多选择都是 Rust 在实现过程中必须做出的真实选择。然而，这一切都把我们带到了这个点，所以让我们开始适应我们的运行时，使其与
    Rust 的 futures 兼容。
- en: 'Before we get to the example, let’s cover the things that are different from
    our current implementation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入示例之前，让我们了解一下与我们的当前实现不同的地方：
- en: The `Future` trait Rust uses is slightly different from what we have now. The
    biggest difference is that it takes something called `Context` instead of `Waker`.
    The other difference is that it returns an enum called `Poll` instead of `PollState`.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 使用的 `Future` 特征与我们现在的有所不同。最大的不同是它使用 `Context` 而不是 `Waker`。另一个不同之处在于它返回一个名为
    `Poll` 的枚举，而不是 `PollState`。
- en: '`Context` is a wrapper around Rust’s `Waker` type. Its only purpose is to future-proof
    the API so it can hold additional data in the future without having to change
    anything related to `Waker`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context` 是 Rust 的 `Waker` 类型的包装器。它的唯一目的是为了使 API 兼容未来，以便将来可以持有额外的数据，而无需更改与
    `Waker` 相关的任何内容。'
- en: The `Poll` enum returns one of two states, `Ready(T)` or `Pending`. This is
    slightly different from what we have now with our `PollState` enum, but the two
    states mean the same as `Ready(T)/NotReady` in our current implementation.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Poll` 枚举返回两种状态之一，`Ready(T)` 或 `Pending`。这与我们当前的 `PollState` 枚举略有不同，但这两个状态在我们的当前实现中与
    `Ready(T)/NotReady` 意义相同。'
- en: '`Wakers` in Rust is slightly more complex to create than what we’re used to
    with our current `Waker`. We’ll go through how and why later in the chapter.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中创建 `Wakers` 比我们当前的 `Waker` 要复杂一些。我们将在本章后面讨论如何以及为什么。
- en: Other than the differences outlined above, everything else can stay pretty much
    as is. For the most part, we’re renaming and refactoring this time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述的不同之处，其他所有内容都可以保持原样。大部分情况下，我们这次只是进行了重命名和重构。
- en: Now that we’ve got an idea of what we need to do, it’s time to set everything
    up so we can get our new example up and running.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了需要做什么的想法，现在是时候设置一切，以便我们可以启动我们的新示例。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even though we create a runtime to run futures properly in Rust, we still try
    to keep this simple by avoiding error handling and not focusing on making our
    runtime more flexible. Improving our runtime is certainly possible, and while
    it can be a bit tricky at times to use the type system correctly and please the
    borrow checker, it has relatively little to do with *async* Rust and more to do
    with Rust being Rust.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在 Rust 中创建了一个运行时来正确运行 futures，但我们仍然通过避免错误处理和不专注于使运行时更加灵活来保持其简单性。改进我们的运行时当然是有可能的，而且虽然有时正确使用类型系统并取悦借用检查器可能有点棘手，但这与
    *异步* Rust 的关系相对较小，而更多的是与 Rust 本身有关。
- en: Setting up our example
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置示例
- en: Tip
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You’ll find this example in the book’s repository in the `ch1``0``/a-rust-futures`
    folder.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书的仓库中找到这个示例，在 `ch1``0``/a-rust-futures` 文件夹中。
- en: 'We’ll continue where we left off in the last chapter, so let’s copy everything
    we had over to a new project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在上一个章节中留下的地方继续，所以让我们将我们拥有的所有内容复制到一个新项目中：
- en: Create a new folder called `a-rust-futures`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `a-rust-futures` 的新文件夹。
- en: Copy everything from the example in the previous chapter. If you followed the
    naming I suggested, it would be stored in the `e-coroutines-pin` folder.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一章中的示例中的所有内容复制过来。如果你遵循了我建议的命名规则，它将存储在 `e-coroutines-pin` 文件夹中。
- en: You should now have a folder containing a copy of our previous example, so the
    last thing to do is to change the project name in `Cargo.toml` to `a-rust-futures`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该有一个包含我们之前示例副本的文件夹，所以最后要做的就是将 `Cargo.toml` 中的项目名称更改为 `a-rust-futures`。
- en: Okay, so let’s start with the program we want to run. Open `main.rs`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们从我们想要运行的程序开始。打开 `main.rs`。
- en: main.rs
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: main.rs
- en: 'We’ll go back to the simplest version of our program and get it running before
    we try anything more complex. Open `main.rs` and replace all the code in that
    file with this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试任何更复杂的事情之前，我们先回到程序最简单的版本，并让它运行起来。打开 `main.rs` 并用以下代码替换该文件中的所有代码：
- en: ch10/a-rust-futures/src/main.rs
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/main.rs
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: No need for `corofy` or anything special this time. The compiler will rewrite
    this for us.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不需要 `corofy` 或任何特殊的东西。编译器会为我们重写这些。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we’ve removed the declaration of the `future` module. That’s because
    we simply don’t need it anymore. The only exception is if you want to retain and
    use the `join_all` function we created to join multiple futures together. You
    can either try to rewrite that yourself or take a look in the repository and locate
    the `ch1``0``/a-rust-futures-bonus/src/future.rs` file, where you’ll find the
    same version of our example, only this version retains the future module with
    a `join_all` function that works with Rust futures.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经移除了 `future` 模块的声明。这是因为我们根本不再需要它了。唯一的例外是，如果你想要保留并使用我们创建的用于将多个 future
    连接起来的 `join_all` 函数。你可以尝试自己重写它，或者查看仓库并定位到 `ch1``0``/a-rust-futures-bonus/src/future.rs`
    文件，在那里你可以找到我们示例的相同版本，只是这个版本保留了带有与 Rust futures 一起工作的 `join_all` 函数的 future 模块。
- en: future.rs
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: future.rs
- en: You can delete this file altogether as we don’t need our own `Future` trait
    anymore.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以完全删除这个文件，因为我们不再需要我们自己的 `Future` trait 了。
- en: Let’s move right along to `http.rs` and see what we need to change there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入 `http.rs` 并看看我们需要在那里做哪些更改。
- en: http.rs
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: http.rs
- en: 'The first thing we need to change is our dependencies. We’ll no longer rely
    on our own `Future`, `Waker`, and `PollState`; instead, we’ll depend on `Future`,
    `Context`, and `Poll` from the standard library. Our dependencies should look
    like this now:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改的第一件事是我们的依赖项。我们将不再依赖于我们自己的 `Future`、`Waker` 和 `PollState`；相反，我们将依赖于标准库中的
    `Future`、`Context` 和 `Poll`。我们的依赖项现在应该看起来像这样：
- en: ch10/a-rust-futures/src/http.rs
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/http.rs
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have to do some minor refactoring in the `poll` implementation for `HttpGetFuture`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在 `HttpGetFuture` 的 `poll` 实现中进行一些小的重构。
- en: 'First, we need to change the signature of the `poll` function so it complies
    with the new `Future` trait:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更改 `poll` 函数的签名，使其符合新的 `Future` trait：
- en: ch10/a-rust-futures/src/http.rs
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/http.rs
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'runtime::reactor().set_waker(Poll instead of PollState. To do that, locate
    the poll method and start by changing the signature so it matches the Future trait
    from the standard library:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: runtime::reactor().set_waker(Poll instead of PollState. 要做到这一点，找到 poll 方法，并首先更改签名，使其与标准库中的
    Future trait 匹配：
- en: ch10/a-rust-futures/src/http.rs
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/http.rs
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to change our return types wherever we return from the function
    (I’ve only presented the relevant part of the function body here):'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们需要更改函数返回类型的地方（我在这里只展示了函数体的相关部分）：
- en: ch10/a-rust-futures/src/http.rs
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/http.rs
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That’s it for this file. Not bad, huh? Let’s take a look at what we need to
    change in our executor and open `executor.rs`.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个文件就到这里。不错吧？让我们看看在 executor 中我们需要做哪些更改，并打开 `executor.rs`。
- en: executor.rs
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: executor.rs
- en: 'The first thing we need to change in `executor.rs` is our dependencies. This
    time, we only rely on types from the standard library, and our `dependencies`
    section should now look like this:'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `executor.rs` 中，我们需要更改的第一件事是我们的依赖项。这次，我们只依赖于标准库中的类型，并且我们的 `dependencies` 部分现在应该看起来像这样：
- en: ch10/a-rust-futures/src/runtime/executor.rs
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/runtime/executor.rs
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our coroutines will no longer be limited to only output String, so we can safely
    use a more sensible `Output` type for our top-level futures:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的任务不再局限于仅输出 String，因此我们可以安全地为我们顶级 future 使用更合理的 `Output` 类型：
- en: ch10/a-rust-futures/src/runtime/executor.rs
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/runtime/executor.rs
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#[derive(Clone)]'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '#[derive(Clone)]'
- en: pub struct MyWaker {
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: pub struct MyWaker {
- en: 'thread: Thread,'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'thread: Thread,'
- en: 'id: usize,'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'id: usize,'
- en: 'ready_queue: Arc<Mutex<Vec<usize>>>,'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'ready_queue: Arc<Mutex<Vec<usize>>>,'
- en: '}'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: impl Wake for MyWaker {
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: impl Wake for MyWaker {
- en: 'fn wake(self: Arc<Self>) {'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn wake(self: Arc<Self>) {'
- en: self.ready_queue
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: self.ready_queue
- en: .lock()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: .lock()
- en: .map(|mut q| q.push(self.id))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: .map(|mut q| q.push(self.id))
- en: .unwrap();
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: .unwrap();
- en: self.thread.unpark();
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: self.thread.unpark();
- en: '}'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'fn get_waker(&self, id: usize) -> Arc<MyWaker> {'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn get_waker(&self, id: usize) -> Arc<MyWaker> {'
- en: Arc::new(MyWaker {
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Arc::new(MyWaker {
- en: id,
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: id,
- en: 'thread: thread::current(),'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'thread: thread::current(),'
- en: 'ready_queue: CURRENT_EXEC.with(|q| q.ready_queue.clone()),'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'ready_queue: CURRENT_EXEC.with(|q| q.ready_queue.clone()),'
- en: '})'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '})'
- en: '}'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'pub fn block_on<F>(&mut self, future: F)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'pub fn block_on<F>(&mut self, future: F)'
- en: where
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: where
- en: 'F: Future<Output = ()> + ''static,'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'F: Future<Output = ()> + ''static,'
- en: '{'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '...'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: // guard against false wakeups
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: // 防止假唤醒
- en: None => continue,
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: None => continue,
- en: '};'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'let waker: Waker = self.get_waker(id).into();'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'let waker: Waker = self.get_waker(id).into();'
- en: let mut cx = Context::from_waker(&waker);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: let mut cx = Context::from_waker(&waker);
- en: match future.as_mut().poll(&mut cx) {
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: match future.as_mut().poll(&mut cx) {
- en: '...'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'pub fn spawn<F>(future: F)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'pub fn spawn<F>(future: F)'
- en: where
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: where
- en: 'F: Future<Output = reactor.rs.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'F: Future<Output = reactor.rs.'
- en: reactor.rs
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: reactor.rs
- en: 'The first thing we do is to make sure our dependencies are correct. We have
    to remove the dependency on our old `Waker` implementation and instead pull in
    these types from the standard library. The `dependencies` section should look
    like this:'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先确保我们的依赖项是正确的。我们必须删除对旧 `Waker` 实现的依赖，而是从标准库中引入这些类型。`dependencies` 部分应该看起来像这样：
- en: ch10/a-rust-futures/src/runtime/reactor.rs
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/runtime/reactor.rs
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are two minor changes we need to make. The first one is that our `set_waker`
    function now accepts `Context` from which it needs to get a `Waker` object:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要做出两个小的更改。第一个更改是我们的 `set_waker` 函数现在接受 `Context`，它需要从中获取一个 `Waker` 对象：
- en: ch10/a-rust-futures/src/runtime/reactor.rs
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/runtime/reactor.rs
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last change is that we need to call a slightly different method when calling
    `wake` in the `event_loop` function:'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后的更改是在调用 `event_loop` 函数中的 `wake` 时需要调用一个稍微不同的方法：
- en: ch10/a-rust-futures/src/runtime/reactor.rs
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/a-rust-futures/src/runtime/reactor.rs
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since calling `wake` now consumes `self`, we call the version that takes `&self`
    instead since we want to hold on to that waker for later.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于现在调用 `wake` 会消耗 `self`，因此我们调用接受 `&self` 的版本，因为我们想保留这个 `waker` 以供以后使用。
- en: That’s it. Our runtime can now run and take advantage of the full power of asynchronous
    Rust. Let’s try it out by typing `cargo run` in the terminal.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样。我们的运行时现在可以运行并充分利用异步 Rust 的全部功能。让我们在终端中输入 `cargo run` 来试试。
- en: 'We should get the same output as we’ve seen before:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该得到之前看到过的相同输出：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That’s pretty neat, isn’t it?
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这非常不错，不是吗？
- en: So, now we have created our own async runtime that uses Rust’s `Future`, `Waker`,
    `Context`, and `async/await`.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，现在我们已经创建了自己的异步运行时，它使用 Rust 的 `Future`、`Waker`、`Context` 和 `async/await`。
- en: Now that we can pride ourselves on being runtime implementors, it’s time to
    do some experiments. I’ll choose a few that will also teach us a few things about
    runtimes and futures in Rust. We’re not done learning just yet.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以自豪地称自己是运行时实现者，是时候做一些实验了。我会选择几个实验，这些实验也会让我们了解 Rust 中的运行时和 futures。我们还没有学完。
- en: Experimenting with our runtime
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的运行时中进行实验
- en: Note
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll find this example in the book’s repository in the `ch1``0``/b-rust-futures-experiments`
    folder. The different experiments will be implemented as different versions of
    the `async_main` function numbered chronologically. I’ll indicate which function
    corresponds with which function in the repository example in the heading of the
    code snippet.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在书的存储库中找到这个示例，在 `ch1``0``/b-rust-futures-experiments` 文件夹中。不同的实验将作为 `async_main`
    函数的不同版本按时间顺序实现。我将在代码片段的标题中指示哪个函数对应于存储库示例中的哪个函数。
- en: 'Before we start experimenting, let’s copy everything we have now to a new folder:'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们开始实验之前，让我们把我们现在拥有的所有内容复制到一个新的文件夹中：
- en: Create a new folder called `b-rust-futures-experiments`.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `b-rust-futures-experiments` 的新文件夹。
- en: Copy everything from the `a-rust-futures` folder to the new folder.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `a-rust-futures` 文件夹中的所有内容复制到新文件夹中。
- en: Open `Cargo.toml` and change the `name` attribute to `b-rust-futures-experiments`.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Cargo.toml` 并将 `name` 属性更改为 `b-rust-futures-experiments`。
- en: The first experiment will be to exchange our very limited HTTP client with a
    proper one.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个实验将是用合适的 HTTP 客户端替换我们非常有限的 HTTP 客户端。
- en: The easiest way to do that is to simply pick another production-quality HTTP
    client library that supports async Rust and use that instead.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 做这件事最简单的方法是简单地选择另一个支持异步 Rust 的生产级 HTTP 客户端库，并使用它代替。
- en: So, when trying to find a suitable replacement for our HTTP client, we check
    the list of the most popular high-level HTTP client libraries and find `reqwest`
    at the top. That might work for our purposes, so let’s try that first.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，当我们试图找到我们 HTTP 客户端的合适替代品时，我们检查了最受欢迎的高级 HTTP 客户端库列表，并发现 `reqwest` 排在首位。这可能适用于我们的目的，所以让我们先尝试一下。
- en: 'The first thing we do is add `reqwest` as a dependency in `Cargo.toml` by typing
    the following:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先做的事情是在 `Cargo.toml` 中将 `reqwest` 添加为依赖项，通过输入以下内容：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, let’s change our `async_main` function so we use `reqwest` instead of
    our own HTTP client:'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，让我们更改我们的 `async_main` 函数，以便我们使用 `reqwest` 而不是我们自己的 HTTP 客户端：
- en: ch10/b-rust-futures-examples/src/main.rs (async_main2)
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/b-rust-futures-examples/src/main.rs (async_main2)
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Besides using the `reqwest` API, I also changed the message we send. Most HTTP
    clients don’t return the raw HTTP response to us and usually only provide a convenient
    way to get the *body* of the response, which up until now was similar for both
    our requests.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了使用 `reqwest` API 之外，我还更改了我们发送的消息。大多数 HTTP 客户端不会返回原始 HTTP 响应给我们，通常只提供一种方便的方式来获取响应的
    *body*，直到现在，我们的请求对此都是类似的。
- en: 'That should be all we need to change, so let’s try to run our program by writing
    `cargo run`:'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该就是我们需要更改的所有内容，所以让我们尝试通过编写 `cargo run` 来运行我们的程序：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Okay, so the error tells us that there is no reactor running and that it must
    be called from the context of a Tokio 1.x runtime. Well, we know there is a reactor
    running, just not the one `reqwest` expects, so let’s see how we can fix this.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好吧，所以错误告诉我们没有运行反应器，并且它必须从 Tokio 1.x 运行时的上下文中调用。我们知道有一个反应器正在运行，只是不是 `reqwest`
    期望的那个，所以让我们看看我们如何解决这个问题。
- en: 'We obviously need to add Tokio to our program, and since Tokio is heavily feature-gated
    (meaning that it has very few features enabled by default), we’ll make it easy
    on ourselves and enable all of them:'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们显然需要将 Tokio 添加到我们的程序中，由于 Tokio 严重功能受限（这意味着默认情况下只有很少的功能被启用），我们将简化操作，并启用所有功能：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: According to the documentation, we need to start a Tokio runtime and explicitly
    enter it to enable the reactor. The `enter` function will return `EnterGuard`
    to us that we can hold on to it as long as we need the reactor up and running.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据文档，我们需要启动一个 Tokio 运行时，并显式进入它以启用反应器。`enter` 函数将返回 `EnterGuard` 给我们，只要我们需要反应器运行，我们就可以持有它。
- en: 'Adding this to the top of our `async_main` function should work:'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将此添加到我们的 `async_main` 函数顶部应该可以工作：
- en: ch10/b-rust-futures-examples/src/main.rs (async_main2)
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/b-rust-futures-examples/src/main.rs (async_main2)
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'Calling `Runtime::new` creates a multithreaded Tokio runtime, but Tokio also
    has a single-threaded runtime that you can create by using the runtime builder
    like this: `Builder::new_current_thread().enable_all().build().unwrap()`. If you
    do that, you end up with a peculiar problem: a deadlock. The reason for that is
    interesting and one that you should know about.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用 `Runtime::new` 创建一个多线程的 Tokio 运行时，但 Tokio 也有一个单线程的运行时，你可以通过使用运行时构建器来创建，如下所示：`Builder::new_current_thread().enable_all().build().unwrap()`。如果你这样做，你最终会遇到一个奇特的问题：死锁。这个原因很有趣，你应该知道。
- en: Tokio’s single-threaded runtime uses only the thread it’s called on for both
    the executor and the reactor. This is very similar to what we did in the first
    version of our runtime in [*Chapter 8*](B20892_08.xhtml#_idTextAnchor138). We
    used the `Poll` instance to park our executor directly. When both our reactor
    and executor execute on the same thread, they must have the same mechanism to
    park themselves and wait for new events, which means there will be a tight coupling
    between them.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Tokio 的单线程运行时只使用它被调用的线程来执行执行器和反应器。这与我们在运行时的第一个版本中做的事情非常相似。[第 8 章](B20892_08.xhtml#_idTextAnchor138)。我们使用了
    `Poll` 实例直接挂起我们的执行器。当我们的反应器和执行器在同一个线程上执行时，它们必须具有相同的机制来自动挂起并等待新事件，这意味着它们之间将存在紧密的耦合。
- en: When handling an event, the reactor has to wake up first to call `Waker::wake`,
    but the executor is the last one to park the thread. If the executor parked itself
    by calling `thread::park` (like we do), the reactor is parked as well and will
    never wake up since they’re running on the same thread. The only way for this
    to work is that the executor parks on something shared with the reactor (like
    we did with `Poll`). Since we’re not tightly integrated with Tokio, all we get
    is a deadlock.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在处理事件时，反应器必须首先唤醒以调用`Waker::wake`，但执行器是最后一个调用`thread::park`（就像我们做的那样）的。如果执行器通过调用`thread::park`（就像我们做的那样）自己挂起，那么反应器也会挂起，并且由于它们在同一个线程上运行，将永远不会唤醒。使这一切正常工作的唯一方法就是执行器挂起与反应器共享的东西（就像我们用`Poll`做的那样）。由于我们与Tokio没有紧密集成，我们得到的只是一个死锁。
- en: 'Now, if we try to run our program once more, we get the following output:'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果我们再次尝试运行我们的程序，我们会得到以下输出：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Okay, so now everything works as expected. The only difference is that we get
    woken up a few extra times, but the program finishes and produces the expected
    result.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好吧，所以现在一切如预期工作。唯一的区别是我们被唤醒了几次，但程序完成了并产生了预期的结果。
- en: Before we discuss what we just witnessed, let’s do one more experiment.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们讨论我们刚才看到的情况之前，让我们再做一个实验。
- en: '**Isahc** is an HTTP client library that promises to be *executor agnostic*,
    meaning that it doesn’t rely on any specific executor. Let’s put that to the test.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Isahc**是一个承诺为*执行器无关*的HTTP客户端库，这意味着它不依赖于任何特定的执行器。让我们来测试一下。'
- en: 'First, we add a dependency on `isahc` by typing the following:'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们通过输入以下内容添加对`isahc`的依赖：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we rewrite our `main` function so it looks like this:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们重写我们的`main`函数，使其看起来像这样：
- en: ch10/b-rust-futures-examples/src/main.rs (async_main3)
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch10/b-rust-futures-examples/src/main.rs (async_main3)
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, if we run our program by writing `cargo run`, we get the following output:'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果我们通过编写`cargo run`来运行我们的程序，我们会得到以下输出：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, we get the expected output without having to jump through any hoops.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们得到了预期的输出，而无需跳过任何障碍。
- en: '*Why does all this have to be* *so unintuitive?*'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*为什么这一切都必须如此不直观？*'
- en: The answer to that brings us to the topic of common challenges that we all face
    when programming with async Rust, so let’s cover some of the most noticeable ones
    and explain the reason they exist so we can figure out how to best deal with them.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那个问题的答案把我们带到了我们所有人编程时都会遇到的一些常见挑战的话题，所以让我们来谈谈其中一些最明显的挑战，并解释它们存在的原因，这样我们就可以找出如何最好地处理它们。
- en: Challenges with asynchronous Rust
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 异步Rust的挑战
- en: So, while we’ve seen with our own eyes that the executor and reactor could be
    loosely coupled, which in turn means that you could in theory mix and match reactors
    and executors, the question is why do we encounter so much friction when trying
    to do just that?
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以，虽然我们亲眼看到执行器和反应器可以被松散耦合，这反过来意味着理论上你可以混合匹配反应器和执行器，但问题是为什么我们在尝试这样做时会遇到如此多的摩擦？
- en: Most programmers that have used async Rust have experienced problems caused
    by incompatible async libraries, and we saw an example of the kind of error message
    you would get previously.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数使用过异步Rust的程序员都经历过由不兼容的异步库引起的问题，我们之前看到了你可能会得到的错误消息的例子。
- en: To understand this, we have to dive a little bit deeper into the existing async
    runtimes in Rust, specifically those we typically use for desktop and server applications.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要理解这一点，我们必须稍微深入了解一下Rust中现有的异步运行时，特别是那些我们通常用于桌面和服务器应用程序的。
- en: Explicit versus implicit reactor instantiation
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显式与隐式反应器实例化
- en: Info
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: The type of future we’ll talk about going forward is leaf futures, the kind
    that actually represents an I/O operation (for example, `HttpGetFuture`).
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的未来类型是叶子未来，这种类型实际上代表了一个I/O操作（例如，`HttpGetFuture`）。
- en: When you create a runtime in Rust, you also need to create non-blocking primitives
    of the Rust standard library. Mutexes, channels, timers, TcpStreams, and so on
    are all things that need an async equivalent.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在Rust中创建运行时，你还需要创建Rust标准库的非阻塞原语。互斥锁、通道、计时器、TcpStreams等等都是需要异步等价物的东西。
- en: 'Most of these can be implemented as different kinds of reactors, but the question
    that then comes up is: how is that reactor started?'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些大多数都可以实现为不同类型的反应器，但随之而来的问题是：那个反应器是如何启动的？
- en: In both our own runtime and in Tokio, the reactor is started as part of the
    runtime initialization. We have a `runtime::init()` function that calls `reactor::start()`,
    and Tokio has a `Runtime::new()` and `Runtime::enter()` function.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们自己的运行时和Tokio中，反应器作为运行时初始化的一部分启动。我们有一个`runtime::init()`函数，它调用`reactor::start()`，而Tokio有一个`Runtime::new()`和`Runtime::enter()`函数。
- en: If we try to create a leaf future (the only one we created ourselves is `HttpGetFuture`)
    without the reactor started, both our runtime and Tokio will panic. The reactor
    has to be instantiated *explicitly*.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们尝试在没有启动反应器的情况下创建一个叶子future（我们创建的唯一一个是`HttpGetFuture`），那么我们的运行时和Tokio都会崩溃。反应器必须**显式**实例化。
- en: Isahc, on the other hand, brings its own kind of reactor. Isahc is built on
    `libcurl`, a highly portable C library for `libcurl` accepts a callback that is
    called when an operation is ready. So, Isahc passes the waker it receives to this
    callback and makes sure that `Waker::wake` is called when the callback is executed.
    This is a bit oversimplified, but it’s essentially what happens.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，Isahc带来了它自己的一种反应器。Isahc建立在`libcurl`之上，这是一个高度可移植的C库，`libcurl`接受一个在操作准备就绪时被调用的回调。因此，Isahc将接收到的唤醒器传递给这个回调，并确保在回调执行时调用`Waker::wake`。这有点过于简化，但基本上就是这样发生的。
- en: In practice, that means that Isahc brings its own reactor since it comes with
    the machinery to store wakers and call `wake` on them when an operation is ready.
    The reactor is started *implicitly*.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，这意味着Isahc带来了它自己的反应器，因为它带有存储唤醒器并在操作准备就绪时对它们调用`wake`的机制。反应器是**隐式**启动的。
- en: Incidentally, this is also one of the major differences between `async_std`
    and Tokio. Tokio requires *explicit* instantiation, and `async_std` relies on
    *implicit* instantiation.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 偶然的是，这也是`async_std`和Tokio之间的一大主要区别。Tokio需要**显式**实例化，而`async_std`则依赖于**隐式**实例化。
- en: I’m not going into so much detail on this just for fun; while this seems like
    a minor difference, it has a rather big impact on how intuitive asynchronous programming
    in Rust is.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我并不是为了好玩而深入探讨这个问题；虽然这似乎是一个微小的差异，但它对Rust中异步编程的直观性有着相当大的影响。
- en: This problem mostly arises when you start programming using a different runtime
    than Tokio and then have to use a library that internally relies on a Tokio reactor
    being present.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个问题主要在你开始使用不同于Tokio的其他运行时编程时出现，然后必须使用内部依赖于Tokio反应器存在的库。
- en: Since you can’t have two Tokio instances running on the same thread, the library
    can’t implicitly start a Tokio reactor. Instead, what often happens is that you
    try to use that library and get an error like we did in the preceding example.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于你无法在同一个线程上运行两个Tokio实例，因此库不能隐式启动一个Tokio反应器。相反，通常会发生的情况是，你尝试使用那个库，并得到一个像我们在前面的例子中遇到的那种错误。
- en: Now, you have to solve this by starting a Tokio reactor yourself, use some kind
    of compatibility wrapper created by someone else, or seeing whether the runtime
    you use has a built-in mechanism for running futures that rely on a Tokio reactor
    being present.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你必须自己启动一个Tokio反应器，使用其他人创建的某种兼容包装器，或者查看你使用的运行时是否有内置机制来运行依赖于Tokio反应器的future。
- en: For most people who don’t know about reactors, executors, and different kinds
    of leaf futures, this can be quite unintuitive and cause quite a bit of frustration.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于大多数不了解反应器、执行器和不同类型的叶子future的人来说，这可能会相当不直观，并造成相当多的挫败感。
- en: Note
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The problem we describe here is quite common, and it’s not helped by the fact
    that async libraries rarely explain this well or even try to be explicit about
    what kind of runtime they use. Some libraries might only mention that they’re
    built on top of Tokio somewhere in the `README` file, and some might simply state
    that they’re built on top of Hyper, for example, assuming that you know that Hyper
    is built on top of Tokio (at least by default).
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里描述的问题相当常见，而且由于异步库很少很好地解释这一点，甚至很少尝试明确说明它们使用的运行时类型，这并没有得到帮助。一些库可能在`README`文件中某处提到它们是建立在Tokio之上的，而一些库可能只是简单地声明它们是建立在Hyper之上的，例如，假设你知道Hyper是建立在Tokio之上的（至少默认情况下是这样）。
- en: But now, you know that you should check this to avoid any surprises, and if
    you encounter this issue, you know exactly what the problem is.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是现在，你知道你应该检查这一点以避免任何惊喜，如果你遇到这个问题，你就知道确切的问题是什么。
- en: Ergonomics versus efficiency and flexibility
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 人体工程学 versus 效率和灵活性
- en: Rust is good at being ergonomic *and* efficient, and that almost makes it difficult
    to remember that when Rust is faced with the choice between being efficient *or*
    ergonomic, it will choose to be efficient. Many of the most popular crates in
    the ecosystem echo these values, and that includes async runtimes.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rust擅长于易用性和效率，这几乎让人难以忘记，当Rust面临在效率*或*易用性之间做出选择时，它将选择效率。生态系统中最受欢迎的许多crate都反映了这些价值观，这包括异步运行时。
- en: Some tasks can be more efficient if they’re tightly integrated with the executor,
    and therefore, if you use them in your library, you will be dependent on that
    specific runtime.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果任务与执行者紧密集成，它们可以更有效率，因此，如果你在库中使用它们，你将依赖于那个特定的运行时。
- en: Let’s take **timers** as an example, but task notifications where *Task A* notifies
    *Task B* that it can continue is another example with some of the same trade-offs.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以**计时器**为例，但任务通知，其中*任务A*通知*任务B*它可以继续，这也是另一个具有一些相同权衡的例子。
- en: Tasks
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任务
- en: We’ve used the terms tasks and futures without making the difference explicitly
    clear, so let’s clear that up here. We first covered tasks in [*Chapter 1*](B20892_01.xhtml#_idTextAnchor014),
    and they still retain the same general meaning, but when talking about runtimes
    in Rust, they have a more specific definition. A task is a *top-level future*,
    the one that we spawn onto our executor. The executor schedules between different
    tasks. Tasks in a runtime in many ways represent the same abstraction that threads
    do in an OS. Every task is a future in Rust, but every future is not a task by
    this definition.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在未明确区分任务和未来的情况下使用了这些术语，所以让我们在这里澄清一下。我们首先在[*第一章*](B20892_01.xhtml#_idTextAnchor014)中介绍了任务，它们仍然保留着相同的一般含义，但当我们谈论Rust中的运行时，它们有一个更具体的定义。任务是一个*顶级未来*，是我们向执行者播种的那个。执行者在不同任务之间进行调度。在运行时中，任务在很多方面代表了与操作系统中的线程相同的抽象。每个任务在Rust中都是一个未来，但根据这个定义，每个未来并不都是一个任务。
- en: You can think of `thread::sleep` as a timer, and we often need something like
    this in an asynchronous context, so our asynchronous runtime will therefore need
    to have a `sleep` equivalent that tells the executor to park this task for a specified
    duration.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将`thread::sleep`视为一个计时器，在异步环境中我们经常需要这样的东西，因此我们的异步运行时将需要有一个`sleep`等效功能，告诉执行者将这个任务休眠指定的时间。
- en: We could implement this as a reactor and have separate OS-thread sleep for a
    specified duration and then wake the correct `Waker`. That would be simple and
    executor agnostic since the executor is oblivious to what happens and only concern
    itself with scheduling the task when `Waker::wake` is called. However, it’s also
    not optimally efficient for all workloads (even if we used the same thread for
    all timers).
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将其实现为一个反应器，并为指定的持续时间让单独的操作系统线程休眠，然后唤醒正确的`Waker`。这将很简单，并且与执行者无关，因为执行者对发生的事情一无所知，它只关心在`Waker::wake`被调用时调度任务。然而，对于所有工作负载来说，这也不是最优效的（即使我们为所有计时器使用相同的线程）。
- en: Another, and more common, way to solve this is to delegate this task to the
    executor. In our runtime, this could be done by having the executor store an ordered
    list of instants and a corresponding `Waker`, which is used to determine whether
    any timers have expired before it calls `thread::park`. If none have expired,
    we can calculate the duration until the next timer expires and use something such
    as `thread::park_timeout` to make sure that we at least wake up to handle that
    timer.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种，且更为常见的方法是委托这个任务给执行者。在我们的运行时中，这可以通过让执行者存储一个有序的瞬间列表和相应的`Waker`来实现，这个`Waker`用于确定在它调用`thread::park`之前是否有任何计时器已过期。如果没有过期，我们可以计算出下一个计时器过期前的持续时间，并使用类似`thread::park_timeout`的东西来确保我们至少醒来处理那个计时器。
- en: The algorithms used to store the timers can be heavily optimized and you avoid
    the need for one extra thread just for timers with the additional overhead of
    synchronization between these threads just to signal that a timer has expired.
    In a multithreaded runtime, there might even be contention when multiple executors
    frequently add timers to the same reactor.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于存储计时器的算法可以高度优化，并且你可以避免仅为了计时器而需要额外线程的需求，以及这些线程之间同步的额外开销，仅为了通知一个计时器已过期。在多线程运行时中，当多个执行者频繁地向同一反应器添加计时器时，甚至可能会出现竞争。
- en: Some timers are implemented reactor-style as separate libraries, and for many
    tasks, that will suffice. The important point here is that by using the defaults,
    you end up being tied to one specific runtime, and you have to make careful considerations
    if you want to avoid your library being tightly coupled to a specific runtime.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些计时器以反应器风格作为独立的库实现，对于许多任务来说，这已经足够了。这里的关键点是，通过使用默认设置，你最终会绑定到一个特定的运行时，如果你想要避免你的库与特定的运行时紧密耦合，就必须进行仔细的考虑。
- en: Common traits that everyone agrees about
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个人都同意的常见特质
- en: The last topic that causes friction in async Rust is the lack of universally
    agreed-upon traits and interfaces for typical async operations.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 异步Rust中引起摩擦的最后一个话题是缺乏普遍认可的特质和接口，用于典型的异步操作。
- en: I want to preface this segment by pointing out that this is one area that’s
    improving day by day, and there is a nursery for the traits and abstractions for
    asynchronous Rust in the `futures-rs` crate ([https://github.com/rust-lang/futures-rs](https://github.com/rust-lang/futures-rs)).
    However, since it’s still early days for async Rust, it’s something worth mentioning
    in a book like this.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我想通过指出这一点来为这一部分内容做开场白：这是一个每天都在不断改进的领域，在`futures-rs`包中有一个异步Rust的特性和抽象的苗圃（[https://github.com/rust-lang/futures-rs](https://github.com/rust-lang/futures-rs)）。然而，由于异步Rust还处于早期阶段，在这样一本书中提及这一点是值得的。
- en: Let’s take spawning as an example. When you write a high-level async library
    in Rust, such as a web server, you’ll likely want to be able to spawn new tasks
    (top-level futures). For example, each connection to the server will most likely
    be a new task that you want to spawn onto the executor.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们以创建任务为例。当你用Rust编写一个高级异步库，比如一个网络服务器时，你可能会希望能够创建新的任务（顶级未来）。例如，服务器上的每个连接很可能是你想要在执行器上创建的新任务。
- en: Now, spawning is specific to each executor, and Rust doesn’t have a trait that
    defines how to spawn a task. There is a trait suggested for spawning in the `future-rs`
    crate, but creating a spawn trait that is both zero-cost and flexible enough to
    support all kinds of runtimes turns out to be very difficult.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，创建任务对每个执行器都是特定的，Rust没有定义如何创建任务的特质。在`future-rs`包中建议了一个用于创建任务的特质，但创建一个既无成本又足够灵活以支持所有运行时的创建特质非常困难。
- en: 'There are ways around this. The popular HTTP library Hyper ([https://hyper.rs/](https://hyper.rs/)),
    for example, uses a trait to represent the executor and internally uses that to
    spawn new tasks. This makes it possible for users to implement this trait for
    a different executor and hand it back to Hyper. By implementing this trait for
    a different executor, Hyper will use a different spawner than its default option
    (which is the one in Tokio’s executor). Here is an example of how this is used
    for `async_std` with Hyper: [https://github.com/async-rs/async-std-hyper](https://github.com/async-rs/async-std-hyper).'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一些方法可以绕过这个问题。例如，流行的HTTP库Hyper ([https://hyper.rs/](https://hyper.rs/))使用一个特质来表示执行器，并在内部使用它来创建新任务。这使得用户能够为不同的执行器实现这个特质并将其返回给Hyper。通过为不同的执行器实现这个特质，Hyper将使用一个与默认选项不同的创建者（默认选项是Tokio的执行器）。以下是如何使用Hyper与`async_std`一起使用的一个例子：[https://github.com/async-rs/async-std-hyper](https://github.com/async-rs/async-std-hyper)。
- en: 'However, since there is no universal way of making this work, most libraries
    that rely on executor-specific functionality do one of two things:'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，由于没有一种通用的方法来实现这一点，大多数依赖于特定执行器功能的库会做以下两件事之一：
- en: Choose a runtime and stick with it.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个运行时并坚持下去。
- en: Implement two versions of the library supporting different popular runtimes
    that users choose by enabling the correct features.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现两个版本的库，支持用户通过启用正确的功能选择的不同流行运行时。
- en: Async drop
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 异步释放
- en: Async drop, or async destructors, is an aspect of async Rust that’s somewhat
    unresolved at the time of writing this book. Rust uses a pattern called RAII,
    which means that when a type is created, so are its resources, and when a type
    is dropped, the resources are freed as well. The compiler automatically inserts
    a call to drop on objects when they go out of scope.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 异步释放，或者说异步析构函数，是异步Rust在撰写本书时尚未完全解决的问题。Rust使用一种称为RAII的模式，这意味着当类型被创建时，它的资源也会被创建，当类型被销毁时，资源也会被释放。编译器会自动在对象超出作用域时插入一个释放调用的调用。
- en: If we take our runtime as an example, when resources are dropped, they do so
    in a blocking manner. This is normally not a big problem since a drop likely won’t
    block the executor for too long, but it isn’t always so.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以我们的运行时为例，当资源被释放时，它们以阻塞的方式释放。这通常不是一个大问题，因为释放不太可能长时间阻塞执行器，但并不总是这样。
- en: If we have a drop implementation that takes a long time to finish (for example,
    if the drop needs to manage I/O, or makes a blocking call to the OS kernel, which
    is perfectly legal and sometimes even unavoidable in Rust), it can potentially
    block the executor. So, an async drop would somehow be able to yield to the scheduler
    in such cases, and this is not possible at the moment.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们有一个需要很长时间才能完成的释放实现（例如，如果释放需要管理I/O，或者需要对操作系统内核进行阻塞调用，这在Rust中是合法的，有时甚至不可避免），它可能会阻塞执行器。所以，在这种情况下，异步释放应该能够以某种方式向调度器让步，但目前这是不可能的。
- en: Now, this isn’t a rough edge of async Rust you’re likely to encounter as a user
    of async libraries, but it’s worth knowing about since right now, the only way
    to make sure this doesn’t cause issues is to be careful what you put in the drop
    implementation for types that are used in an async context.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，这并不是作为异步库用户你可能会遇到的异步Rust的粗糙边缘，但了解这一点是值得的，因为目前，确保这不会引起问题的唯一方法是在类型中使用异步上下文时，小心地将内容放入释放实现中。
- en: So, while this is not an extensive list of everything that causes friction in
    async Rust, it’s some of the points I find most noticeable and worth knowing about.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，虽然这不是异步Rust中所有导致摩擦因素的详尽列表，但它是我认为最明显且值得了解的一些点。
- en: Before we round off this chapter, let’s spend a little time talking about what
    we should expect in the future when it comes to asynchronous programming in Rust.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，让我们花一点时间谈谈在Rust中进行异步编程时，我们应该期待未来有什么。
- en: The future of asynchronous Rust
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 异步Rust的未来
- en: Some of the things that make async Rust different from other languages are unavoidable.
    Asynchronous Rust is very efficient, has low latency, and is backed by a very
    strong type system due to how the language is designed and its core values.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使异步Rust与其他语言不同的某些特性是不可避免的。异步Rust非常高效，延迟低，由于语言的设计和其核心价值，它背后有一个非常强大的类型系统。
- en: However, much of the perceived complexity today has more to do with the ecosystem
    and the kind of issues that result from a lot of programmers having to agree on
    the best way to solve different problems without any formal structure. The ecosystem
    gets fragmented for a while, and together with the fact that asynchronous programming
    is a topic that’s difficult for a lot of programmers, it ends up adding to the
    cognitive load associated with asynchronous Rust.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，今天感知到的许多复杂性更多与生态系统有关，以及大量程序员在没有正式结构的情况下必须就解决不同问题的最佳方式达成一致所导致的问题。生态系统在一段时间内变得碎片化，再加上异步编程对许多程序员来说是一个难以理解的话题，这最终增加了与异步Rust相关的认知负荷。
- en: All the issues and pain points I’ve mentioned in this chapter are constantly
    getting better. Some points that would have been on this list a few years ago
    are not even worth mentioning today.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我在本章中提到的所有问题和痛点都在不断改进。一些几年前可能出现在这个列表上的点现在甚至不值得提及。
- en: More and more common traits and abstractions will end up in the standard library,
    making async Rust more ergonomic since everything that uses them will “just work.”
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 越来越多的常见特性和抽象将最终出现在标准库中，这使得异步Rust更加易用，因为使用它们的任何东西都将“直接工作”。
- en: As different experiments and designs gain more traction than others, they become
    the de facto standard, and even though you will still have a lot of choices when
    programming asynchronous Rust, there will be certain paths to choose that cause
    a minimal amount of friction for those that want something that “just works.”
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着不同的实验和设计比其他设计获得更多的关注，它们成为了事实上的标准，尽管在编写异步Rust时，你仍然有很多选择，但将会有一些路径可供选择，这些路径对那些想要“直接工作”的人来说摩擦最小。
- en: With enough knowledge about asynchronous Rust and asynchronous programming in
    general, the issues I’ve mentioned here are, after all, relatively minor, and
    since you know more about asynchronous Rust than most programmers, I have a hard
    time imagining that any of these issues will cause you a lot of trouble.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在对异步Rust和异步编程有足够的了解之后，我提到的这些问题毕竟相对较小，而且由于你对异步Rust的了解比大多数程序员都要多，我很难想象这些问题会给你带来很多麻烦。
- en: That doesn’t mean it’s not something worth knowing about since chances are your
    fellow programmers will struggle with some of these issues at some point.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这并不意味着它不是一些值得了解的事情，因为你的同行程序员可能会在某个时刻遇到这些问题。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要
- en: So, in this chapter, we did two things. First, we made some rather minor changes
    to our runtime so it works as an actual runtime for Rust futures. We tested the
    runtime using two external HTTP client libraries to learn a thing or two about
    reactors, runtimes, and async libraries in Rust.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们做了两件事。首先，我们对我们的运行时进行了一些相当小的修改，使其能够作为Rust futures的实际运行时。我们使用两个外部HTTP客户端库测试了运行时，以了解Rust中的reactors、运行时和异步库。
- en: The next thing we did was to discuss some of the things that make asynchronous
    Rust difficult for many programmers coming from other languages. In the end, we
    also talked about what to expect going forward.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们接下来讨论了一些使异步Rust对许多来自其他语言的程序员来说困难的事情。最后，我们也讨论了未来可以期待什么。
- en: Depending on how you’ve followed along and how much you’ve experimented with
    the examples we created along the way, it’s up to you what project to take on
    yourself if you want to learn more.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据你如何跟随学习以及你对所创建的示例进行了多少实验，如果你想要学习更多，你可以自己承担任何项目。
- en: There is an important aspect of learning that only happens when you experiment
    on your own. Pick everything apart, see what breaks, and how to fix it. Improve
    the simple runtime we created to learn new stuff.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学习的一个重要方面只在你自己进行实验时才会发生。拆解一切，看看什么会出错，以及如何修复它。改进我们创建的简单运行时，以学习新知识。
- en: 'There are enough interesting projects to pick from, but here are some suggestions:'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有足够有趣的项目可以选择，但这里有一些建议：
- en: Change out the parker implementation where we used `thread::park` with a proper
    parker. You can choose one from a library or create a parker yourself (I added
    a small bonus at the end of the `ch1``0` folder called `parker-bonus` where you
    get a simple parker implementation).
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们使用`thread::park`实现的parker替换为合适的parker。你可以从库中选择一个，或者自己创建一个parker（我在`ch1``0`文件夹的末尾添加了一个名为`parker-bonus`的小奖励，其中包含一个简单的parker实现）。
- en: Implement a simple `delayserver` using the runtime you’ve created yourself.
    To do this, you have to be able to write some raw HTTP responses and create a
    simple server. If you went through the free introductory book called *The Rust
    Programming Language*, you created a simple server in one of the last chapters
    ([https://doc.rust-lang.org/book/ch20-02-multithreaded.html](https://doc.rust-lang.org/book/ch20-02-multithreaded.html)),
    which gives you the basics you need. You also need to create a timer as we discussed
    above or use an existing crate for async timers.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你自己创建的运行时实现一个简单的`delayserver`。为此，你必须能够编写一些原始的HTTP响应并创建一个简单的服务器。如果你阅读了名为《Rust编程语言》的免费入门书籍，你就在最后一章中创建了一个简单的服务器（[https://doc.rust-lang.org/book/ch20-02-multithreaded.html](https://doc.rust-lang.org/book/ch20-02-multithreaded.html)），这为你提供了所需的基础。你还需要创建一个计时器，就像我们上面讨论的那样，或者使用现有的异步计时器crate。
- en: You can create a “proper” multithreaded runtime and explore the possibilities
    that come with having a global task queue, or as an alternative, implement a work-stealing
    scheduler that can steal tasks from other executors’ local queues when they’re
    done with their own.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建一个“正确”的多线程运行时，探索拥有全局任务队列的可能性，或者作为替代方案，实现一个可以当其他执行器完成自己的任务后从它们本地队列中窃取任务的work-stealing调度器。
- en: Only your imagination sets the limits on what you can do. The important thing
    to note is that there is a certain joy in doing something just because you can
    and just for fun, and I hope that you get some of the same enjoyment from this
    as I do.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有你的想象力才能设定你能做到的界限。重要的是要注意，仅仅因为你可以并且只是为了乐趣而做某件事情，这本身就是一种乐趣，我希望你能从中获得和我一样的乐趣。
- en: I’ll end this chapter with a few words on how to make your life as an asynchronous
    programmer as easy as possible.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我将以几句话结束本章，谈谈如何使异步程序员的日常生活尽可能轻松。
- en: The first thing is to realize that an async runtime is not just another library
    that you use. It’s extremely invasive and impacts almost everything in your program.
    It’s a layer that rewrites, schedules tasks, and reorders the program flow from
    what you’re used to.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一件事是意识到异步运行时不仅仅是一个你使用的库。它非常侵入性，几乎影响你程序中的每一件事。它是一个层，它重写、调度任务，并重新排序你习惯的程序流程。
- en: My clear recommendation if you’re not specifically into learning about runtimes,
    or have very specific needs, is to pick one runtime and stick to it for a while.
    Learn everything about it – not necessarily *everything* from the start, but as
    you need more and more functionality from it, you will learn everything eventually.
    This is almost like getting comfortable with everything in Rust’s standard library.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不是特别想学习运行时，或者有非常具体的需求，我的明确建议是选择一个运行时，并坚持使用一段时间。了解它的所有内容——不一定一开始就了解所有内容，但随着你需要越来越多的功能，你最终会了解所有内容。这几乎就像在Rust的标准库中熟悉所有内容一样。
- en: What runtime you start with depends a bit on what crates you’re using the most.
    Smol and `async-std` share a lot of implementation details and will behave similarly.
    Their big selling point is that their API strives to stay as close as possible
    to the standard library. Combined with the fact that the reactors are instantiated
    implicitly, this can result in a slightly more intuitive experience and a more
    gentle learning curve. Both are production-quality runtimes and see a lot of use.
    Smol was originally created with the goal of having a code base that’s easy for
    programmers to understand and learn from, which I think is true today as well.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你开始使用哪个运行时取决于你使用最多的crates。Smol和`async-std`共享许多实现细节，并且行为相似。它们的主要卖点在于它们的API力求尽可能接近标准库。结合反应器隐式实例化的事实，这可以带来略微更直观的体验和更平缓的学习曲线。两者都是生产级运行时，并且得到了广泛的应用。Smol最初创建的目的是为了拥有一个程序员易于理解和学习的代码库，我认为这一点在今天仍然适用。
- en: With that said, the most popular alternative for users looking for a general-purpose
    runtime at the time of writing is **Tokio** ([https://tokio.rs/](https://tokio.rs/)).
    Tokio is one of the oldest async runtimes in Rust. It is actively developed and
    has a welcoming and active community. The documentation is excellent. Being one
    of the most popular runtimes also means there is a good chance that you’ll find
    a library that does exactly what you need with support for Tokio out of the box.
    Personally, I tend to reach for Tokio for the reasons mentioned, but you can’t
    really go wrong with either of these runtimes unless you have very specific requirements.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 话虽如此，截至写作时，对于寻找通用运行时的用户来说，最受欢迎的替代方案是**Tokio**([https://tokio.rs/](https://tokio.rs/))。Tokio是Rust中最古老的异步运行时之一。它正在积极开发中，拥有一个友好且活跃的社区。文档非常出色。作为最受欢迎的运行时之一，这也意味着你很可能找到一个库，它正好满足你的需求，并且默认支持Tokio。就我个人而言，我倾向于选择Tokio，原因如上所述，但除非你有非常具体的需求，否则你不会选择这两个运行时中的任何一个出错。
- en: Finally, let’s not forget to mention the `futures-rs` crate ([https://github.com/rust-lang/futures-rs](https://github.com/rust-lang/futures-rs)).
    I mentioned this crate earlier, but it’s really useful to know about as it contains
    several traits, abstractions, and executors ([https://docs.rs/futures/latest/futures/executor/index.html](https://docs.rs/futures/latest/futures/executor/index.html))
    for async Rust. It serves the purpose of an async toolbox that comes in handy
    in many situations.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们不要忘记提到`futures-rs`crate([https://github.com/rust-lang/futures-rs](https://github.com/rust-lang/futures-rs))。我之前提到过这个crate，但了解它非常有用，因为它包含了一些特质、抽象和异步Rust的执行器([https://docs.rs/futures/latest/futures/executor/index.html](https://docs.rs/futures/latest/futures/executor/index.html))。它充当一个异步工具箱，在许多情况下都很有用。
- en: Epilogue
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后记
- en: So, you have reached the end. First of all, congratulations! You’ve come to
    the end of quite a journey!
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，你已经走到了尽头。首先，恭喜！你已经完成了一段相当漫长的旅程！
- en: We started by talking about concurrency and parallelism in [*Chapter 1*](B20892_01.xhtml#_idTextAnchor014).
    We even covered a bit about the history, CPUs and OSs, hardware, and interrupts.
    In [*Chapter 2*](B20892_02.xhtml#_idTextAnchor043), we discussed how programming
    languages modeled asynchronous program flow. We introduced coroutines and how
    stackful and stackless coroutines differ. We discussed OS threads, fibers/green
    threads, and callbacks and their pros and cons.
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先在[*第一章*](B20892_01.xhtml#_idTextAnchor014)中讨论了并发和并行。我们甚至简要地介绍了历史、CPU和操作系统、硬件以及中断。在[*第二章*](B20892_02.xhtml#_idTextAnchor043)中，我们讨论了编程语言如何模拟异步程序流程。我们介绍了协程以及堆栈式和堆栈无关协程的区别。我们还讨论了操作系统线程、纤程/绿色线程和回调及其优缺点。
- en: Then, in [*Chapter 3*](B20892_03.xhtml#_idTextAnchor063), we took a look at
    OS-backed event queues such as `epoll`, `kqueue`, and IOCP. We even took quite
    a deep dive into syscalls and cross-platform abstractions.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在 *第 3 章*（[B20892_03.xhtml#_idTextAnchor063](B20892_03.xhtml#_idTextAnchor063)）中，我们研究了基于操作系统的事件队列，如
    `epoll`、`kqueue` 和 IOCP。我们甚至深入研究了系统调用和跨平台抽象。
- en: In [*Chapter 4*](B20892_04.xhtml#_idTextAnchor081), we hit some quite difficult
    terrain when implementing our own mio-like event queue using epoll. We even had
    to learn about the difference between edge-triggered and level-triggered events.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *第 4 章*（[B20892_04.xhtml#_idTextAnchor081](B20892_04.xhtml#_idTextAnchor081)）中，当我们使用
    epoll 实现自己的类似 mio 的事件队列时，遇到了一些相当困难的地形。我们甚至不得不学习边缘触发和电平触发事件之间的区别。
- en: If [*Chapter 4*](B20892_04.xhtml#_idTextAnchor081) was somewhat rough terrain,
    [*Chapter 5*](B20892_05.xhtml#_idTextAnchor092) was more like climbing Mount Everest.
    No one expects you to remember everything covered there, but you read through
    it and have a working example you can use to experiment with. We implemented our
    own fibers/green threads, and while doing so, we learned a little bit about processor
    architectures, ISAs, ABIs, and calling conventions. We even learned quite a bit
    about inline assembly in Rust. If you ever felt insecure about the stack versus
    heap difference, you surely understand it now that you’ve created stacks that
    we made our CPU jump to ourselves.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 *第 4 章*（[B20892_04.xhtml#_idTextAnchor081](B20892_04.xhtml#_idTextAnchor081)）有些艰难，那么
    *第 5 章*（[B20892_05.xhtml#_idTextAnchor092](B20892_05.xhtml#_idTextAnchor092)）就像是攀登珠穆朗玛峰。没有人期望你记住那里涵盖的所有内容，但你阅读了它，并有一个可以用来实验的工作示例。我们实现了自己的纤程/绿色线程，在这个过程中，我们了解了一些关于处理器架构、ISAs、ABIs
    和调用约定。我们甚至在 Rust 中学习了内联汇编。如果你曾经对栈与堆的区别感到不安全，那么在你创建了我们让 CPU 跳转到的栈之后，你现在肯定理解了。
- en: In *Chapter 6*, we got a high-level introduction to asynchronous Rust, before
    we took a deep dive from [*Chapter 7*](B20892_07.xhtml#_idTextAnchor122) and onward,
    starting with creating our own coroutines and our own `coroutine/wait` syntax.
    In [*Chapter 8*](B20892_08.xhtml#_idTextAnchor138), we created the first versions
    of our own runtime while discussing basic runtime design. We also deep-dived into
    reactors, executors, and wakers.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *第 6 章* 中，我们在深入探讨 *第 7 章*（[B20892_07.xhtml#_idTextAnchor122](B20892_07.xhtml#_idTextAnchor122)）及以后的内容之前，对异步
    Rust 进行了高级介绍，其中包括创建我们自己的协程和 `coroutine/wait` 语法。在 *第 8 章*（[B20892_08.xhtml#_idTextAnchor138](B20892_08.xhtml#_idTextAnchor138)）中，我们在讨论基本运行时设计的同时创建了我们自己的运行时版本。我们还深入研究了反应器、执行器和唤醒器。
- en: In [*Chapter 9*](B20892_09.xhtml#_idTextAnchor156), we improved our runtime
    and discovered the dangers of self-referential structs in Rust. We then took a
    thorough look at pinning in Rust and how that helped us solve the problems we
    got into.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *第 9 章*（[B20892_09.xhtml#_idTextAnchor156](B20892_09.xhtml#_idTextAnchor156)）中，我们改进了我们的运行时，并发现了
    Rust 中自引用结构体的危险。然后我们彻底研究了 Rust 中的 pinning 以及它如何帮助我们解决遇到的问题。
- en: Finally, in [*Chapter 10*](B20892_10.xhtml#_idTextAnchor178), we saw that by
    making some rather minor changes, our runtime became a fully functioning runtime
    for Rust futures. We rounded everything off by discussing some well-known challenges
    with asynchronous Rust and some expectations for the future.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在 *第 10 章*（[B20892_10.xhtml#_idTextAnchor178](B20892_10.xhtml#_idTextAnchor178)）中，我们看到了通过进行一些相当小的改动，我们的运行时变成了一个完整的
    Rust futures 运行时。我们通过讨论异步 Rust 的一些已知挑战和对未来的期望来结束一切。
- en: The Rust community is very inclusive and welcoming, and we’d happily welcome
    you to engage and contribute if you find this topic interesting and want to learn
    more. One of the ways asynchronous Rust gets better is through contributions by
    people with all levels of experience. If you want to get involved, then the async
    work group ([https://rust-lang.github.io/wg-async/welcome.html](https://rust-lang.github.io/wg-async/welcome.html))
    is a good place to start. There is also a very active community centered around
    the Tokio project ([https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md](https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md)),
    and many, many more depending on what specific area you want to dive deeper into.
    Don’t be afraid to join the different channels and ask questions.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rust 社区非常包容和欢迎，如果你对这个主题感兴趣并想了解更多，我们很乐意欢迎你参与和贡献。异步 Rust 变得更好的一个方式是通过不同经验水平的人的贡献。如果你想参与其中，那么异步工作组（[https://rust-lang.github.io/wg-async/welcome.html](https://rust-lang.github.io/wg-async/welcome.html)）是一个不错的起点。还有一个围绕
    Tokio 项目（[https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md](https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md)）的非常活跃的社区，以及许多其他社区，具体取决于你想深入研究哪个特定领域。不要害怕加入不同的频道并提问。
- en: Now that we’re at the end I want to thank you for reading all the way to the
    end. I wanted this book to feel like a journey we took together, not like a lecture.
    I wanted you to be the focus, not me.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经到了最后，我想感谢你一直读到最后一页。我希望这本书能感觉像是我们共同经历的一次旅行，而不是一场讲座。我希望你是焦点，而不是我。
- en: I hope I succeeded with that, and I genuinely hope that you learned something
    that you find useful and can take with you going forward. If you did, then I’m
    sincerely happy that my work was of value to you. I wish you the best of luck
    with your asynchronous programming going forward.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我希望我做到了这一点，并且我真诚地希望你学到了一些你认为有用并且可以继续前进的知识。如果你做到了，那么我真心地为我所做的对你有价值而感到高兴。我祝愿你在异步编程的道路上一切顺利。
- en: Until the next time!
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下次再会！
- en: Carl Fredrik
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 卡尔·弗雷德里克
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
