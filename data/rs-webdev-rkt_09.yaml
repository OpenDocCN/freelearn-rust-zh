- en: '*Chapter 7*: Handling Errors in Rust and Rocket'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：Rust和Rocket中的错误处理'
- en: In the previous chapter, we learned about creating endpoints and SQL queries
    to handle the management of the `User` entity. In this chapter, we are going to
    learn more about error handling in Rust and Rocket. After learning the concepts
    in this chapter, you will be able to implement error handling in a Rocket application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建端点和SQL查询来处理`User`实体的管理。在本章中，我们将学习更多关于Rust和Rocket中的错误处理。学习本章的概念后，你将能够实现Rocket应用程序中的错误处理。
- en: We are also going to discuss more common ways to handle errors in Rust and Rocket,
    including signaling unrecoverable errors using the `panic!` macro and catching
    the `panic!` macro, using `Option`, using `Result`, creating a custom `Error`
    type, and logging the generated error.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论更多在Rust和Rocket中处理错误的方法，包括使用`panic!`宏来指示不可恢复的错误，以及使用`Option`、`Result`、创建自定义`Error`类型和记录生成的错误来捕获`panic!`宏。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Using panic!
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用panic!
- en: Using Option
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Option
- en: Returning Result
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回Result
- en: Creating a custom error type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义错误类型
- en: Logging errors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录错误
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们与上一章有相同的技术要求。我们需要一个Rust编译器、一个文本编辑器、一个HTTP客户端和一个PostgreSQL数据库服务器。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07)找到本章的源代码。
- en: Using panic!
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用panic!
- en: To understand error handling in Rust, we need to begin with the `panic!` macro.
    We can use the `panic!` macro when the application encounters an unrecoverable
    error and there's no purpose in continuing the application. If the application
    encounters `panic!`, the application will emit the backtrace and terminate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Rust中的错误处理，我们需要从`panic!`宏开始。当应用程序遇到不可恢复的错误且继续应用程序没有意义时，我们可以使用`panic!`宏。如果应用程序遇到`panic!`，应用程序将发出后迹并终止。
- en: Let's try using `panic!` on the program that we created in the previous chapter.
    Suppose we want the application to read a secret file before we initialize Rocket.
    If the application cannot find this secret file, it will not continue.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在上一章创建的程序中使用`panic!`。假设我们希望在初始化Rocket之前让应用程序读取一个秘密文件。如果应用程序找不到这个秘密文件，它将不会继续。
- en: 'Let''s get started:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Add the following line in `src/main.rs`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main.rs`中添加以下行：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the same file in the `rocket()` function, prepend the following lines:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`rocket()`函数中的同一文件，添加以下行：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Afterward, try executing `cargo run` without creating an empty file named `secret_file`
    inside the working directory. You should see the output as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，尝试在当前工作目录下不创建名为`secret_file`的空文件的情况下执行`cargo run`。你应该看到以下输出：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, try running the application again with `RUST_BACKTRACE=1 cargo run`. You
    should see the backtrace output in the terminal similar to the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用`RUST_BACKTRACE=1 cargo run`再次运行应用程序。你应该在终端中看到类似于以下的后迹输出：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Sometimes, we don''t want to deallocate after panicking using the `panic!`
    macro because we want the application to exit as soon as possible. We can skip
    deallocating by setting `panic = "abort"` in `Cargo.toml` under the profile we
    are using. Setting that configuration will make our binary smaller and exit faster,
    and the operating system will need to clean it later. Let''s try doing that. Set
    the following lines in `Cargo.toml` and run the application again:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候，我们不想在`panic!`宏中恐慌后进行资源释放，因为我们希望应用程序尽快退出。我们可以通过在`Cargo.toml`中设置`panic = "abort"`来跳过释放，在使用的配置文件下。设置此配置将使我们的二进制文件更小，退出更快，操作系统将在稍后清理它。让我们尝试这样做。在`Cargo.toml`中设置以下行并再次运行应用程序：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we know how to use `panic!`, let's see how we can catch it in the next
    section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用`panic!`，让我们看看如何在下一节中捕获它。
- en: Catching panic!
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获panic!
- en: As well as using `panic!`, we can also use the `todo!` and `unimplemented!`
    macros in Rust code. Those macros are very useful for prototyping because they
    will call `panic!` while also allowing the code to type-check at compile time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `panic!`，我们还可以在 Rust 代码中使用 `todo!` 和 `unimplemented!` 宏。这些宏在原型设计时非常有用，因为它们会在调用
    `panic!` 的同时允许代码在编译时进行类型检查。
- en: 'But, why does Rocket not shut down when we are calling a route with `todo!`?
    If we check the Rocket source code, there''s a `catch_unwind` function in `src::panic`
    that can be used to capture a panicking function. Let''s see that code in the
    Rocket source code, `core/lib/src/server.rs`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '但是，为什么当我们使用 `todo!` 调用一个路由时，Rocket 不会关闭呢？如果我们检查 Rocket 的源代码，会发现 `src::panic`
    中有一个 `catch_unwind` 函数，它可以用来捕获抛出异常的函数。让我们看看 Rocket 源代码中的这段代码，`core/lib/src/server.rs`:'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `run()` is a route handling function. Each time we call a route that is
    panicking, the preceding routine will convert the panic into the result's `Err`
    variant. Try removing the `secret_file_path` routine we added before and running
    the application. Now, create a user and try going into user posts. For example,
    create a user with the `95a54c16-e830-45c9-ba1d-5242c0e4c18f` UUID. Try opening
    `http://127.0.0.1/users/95a54c16-e830-45c9-ba1d-5242c0e4c18f/posts`. Since we
    only put `todo!("will implement later")` in the function body, the application
    will panic, but the preceding `catch_unwind` function will catch the panic and
    convert it into an error. Please note that `catch_unwind` will not work if we
    set `panic = "abort"` in `Cargo.toml`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`run()` 是一个路由处理函数。每次我们调用一个抛出异常的路由时，前面的程序会将异常转换为结果的 `Err` 变体。尝试移除我们之前添加的
    `secret_file_path` 程序并运行应用程序。现在，创建一个用户并尝试进入用户帖子。例如，创建一个具有 `95a54c16-e830-45c9-ba1d-5242c0e4c18f`
    UUID 的用户。尝试打开 `http://127.0.0.1/users/95a54c16-e830-45c9-ba1d-5242c0e4c18f/posts`。由于我们只在函数体中放置了
    `todo!("will implement later")`，应用程序将抛出异常，但前面的 `catch_unwind` 函数将捕获这个异常并将其转换为错误。请注意，如果我们在
    `Cargo.toml` 中设置 `panic = "abort"`，则 `catch_unwind` 将不会工作。
- en: In a regular workflow, we don't usually want to use `panic!`, because panicking
    interrupts everything, and the program will not be able to continue. If the Rocket
    framework does not catch `panic!` and one of the route handling functions is panicking,
    then that single error will close the application and there will be nothing to
    handle the other requests. But, what if we want to terminate the Rocket application
    when we encounter an unrecoverable error? Let's see how we can do it in the next
    section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规的工作流程中，我们通常不希望使用 `panic!`，因为抛出异常会中断一切，程序将无法继续。如果 Rocket 框架没有捕获 `panic!`，并且其中一个路由处理函数抛出异常，那么这个单独的错误将关闭应用程序，并且将没有东西来处理其他请求。但是，如果我们想在遇到不可恢复的错误时终止
    Rocket 应用程序，我们应该如何做呢？让我们看看下一节如何实现。
- en: Using shutdown
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关闭
- en: To shut down smoothly if the application encounters an unrecoverable error in
    the route handling function, we can use the `rocket::Shutdown` request guard.
    Remember, the request guard is a parameter we are supplying to the route handling
    functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在路由处理函数遇到不可恢复的错误时平稳关闭，我们可以使用 `rocket::Shutdown` 请求守卫。记住，请求守卫是我们提供给路由处理函数的参数。
- en: 'To see the `Shutdown` request guard in action, let''s try implementing it in
    our application. Using the previous application, add a new route in `src/routes/mod.rs`
    called `/shutdown`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '要查看 `Shutdown` 请求守卫的实际效果，让我们尝试在我们的应用程序中实现它。使用之前的应用程序，在 `src/routes/mod.rs`
    中添加一个新的路由 `/shutdown`:'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Try adding the `shutdown()` function in `src/main.rs`. After that, rerun the
    application and send an HTTP request to `/shutdown` while monitoring the output
    of the application on the terminal. The application should shut down smoothly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 `src/main.rs` 中添加 `shutdown()` 函数。之后，重新运行应用程序，并向 `/shutdown` 发送 HTTP 请求，同时监控终端上的应用程序输出。应用程序应该能够平稳关闭。
- en: In the next two sections, let's see how we can use `Option` and `Result` as
    an alternative way to handle errors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将看看如何使用 `Option` 和 `Result` 作为处理错误的替代方法。
- en: Using Option
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Option
- en: In programming, a routine might produce a correct result or encounter a problem.
    One classical example is division by zero. Dividing something by zero is mathematically
    undefined. If the application has a routine to divide something, and the routine
    encounters zero as input, the application cannot return any number. We want the
    application to return another type instead of a number. We need a type that can
    hold multiple variants of data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，一个例程可能会产生正确的结果或遇到问题。一个经典的例子是除以零。在数学上，除以零是未定义的。如果一个应用程序有一个除以某物的例程，并且该例程遇到零作为输入，则应用程序不能返回任何数字。我们希望应用程序返回另一种类型而不是数字。我们需要一种可以持有多种数据变体的类型。
- en: 'In Rust, we can define an `enum` type, a type that can be different variants
    of data. An `enum` type might be as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，我们可以定义一个 `enum` 类型，这是一种可以有不同的数据变体的类型。一个 `enum` 类型可能如下所示：
- en: '[PRE21]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Point` and `Line` are said to have `Rectangle` is said to have `Rectangle`
    can also be called a **struct-like enum** variant.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point` 和 `Line` 被说成有 `Rectangle`，而 `Rectangle` 也可以称为 **类似结构体的枚举** 变体。'
- en: 'If all members of `enum` have no data, we can add a discriminant on the member.
    Here is an example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `enum` 的所有成员都没有数据，我们可以在成员上添加一个区分符。以下是一个例子：
- en: '[PRE31]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can assign `enum` to a variable, and use the variable in a function as in
    the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `enum` 赋值给一个变量，并在函数中使用该变量，如下所示：
- en: '[PRE36]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Going back to error handling, we can use `enum` to communicate that there''s
    something wrong in our code. Going back to division by zero, here is an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回到错误处理，我们可以使用 `enum` 来传达我们的代码中存在错误。回到除以零的情况，这里有一个例子：
- en: '[PRE48]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding pattern returning something or not returning something is very
    common, so Rust has its own enum to show whether we have something or not in the
    standard library, called `std::option::Option`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前模式返回或不返回内容的情况非常常见，因此 Rust 在标准库中有一个自己的枚举来表示我们是否有内容，称为 `std::option::Option`：
- en: '[PRE58]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`Some(T)` is used to communicate that we have `T`, and `None` is obviously
    used to communicate that we don''t have `T`. We used `Option` in some of the previous
    code. For example, we used it in the `User` struct:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Some(T)` 用于传达我们拥有 `T`，而 `None` 显然用于传达我们没有 `T`。我们在之前的代码中使用了 `Option`。例如，我们在
    `User` 结构体中使用了它：'
- en: '[PRE62]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We also used `Option` as a function parameter or return type:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了 `Option` 作为函数参数或返回类型：
- en: '[PRE67]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'There are many useful things we can use with `Option`. Suppose we have two
    variables, `we_have_it` and `we_do_not_have_it`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Option` 做很多事情。假设我们有两个变量，`we_have_it` 和 `we_do_not_have_it`：
- en: '[PRE68]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'One thing we can do is pattern matching and use the content:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以做的事情之一是模式匹配并使用其内容：
- en: '[PRE70]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can process it in a more convenient way if we care about the content of
    `we_have_it`:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们关心 `we_have_it` 的内容，我们可以以更方便的方式处理它：
- en: '[PRE71]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`Option` can be compared if the inner type implements `std::cmp::Eq` and `std::cmp::Ord`,
    that is, the inner type can be compared using `==`, `!=`, `>`, and other comparison
    operators. Notice that we use `assert!`, a macro used for testing:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果内部类型实现了 `std::cmp::Eq` 和 `std::cmp::Ord`，则 `Option` 可以进行比较，即内部类型可以使用 `==`、`!=`、`>`
    等比较运算符进行比较。注意我们使用了 `assert!`，这是一个用于测试的宏：
- en: '[PRE72]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can check whether a variable is `Some` or `None`:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以检查一个变量是 `Some` 还是 `None`：
- en: '[PRE73]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can also get the content by unwrapping `Option`. But, there''s a caveat;
    unwrapping `None` will cause panic, so be careful when unwrapping `Option`. Notice
    we use `assert_eq!`, which is a macro used for testing to ensure equality:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以通过展开 `Option` 来获取内容。但是，有一个注意事项；展开 `None` 将会引发恐慌，所以在展开 `Option` 时要小心。注意我们使用了
    `assert_eq!`，这是一个用于测试的宏，用于确保相等性：
- en: '[PRE74]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can also use the `expect()` method. This method will work the same with
    `unwrap()` but we can use a custom message:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用 `expect()` 方法。此方法与 `unwrap()` 的行为相同，但我们可以使用自定义消息：
- en: '[PRE75]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can unwrap and set the default value so it will not panic if we unwrap `None`:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以展开并设置默认值，这样在展开 `None` 时就不会引发恐慌：
- en: '[PRE76]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can unwrap and set the default value with a closure:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用闭包展开并设置默认值：
- en: '[PRE77]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can convert the value contained to something else using `map()`, `map_or()`,
    or `map_or_else()`:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `map()`、`map_or()` 或 `map_or_else()` 将包含的值转换为其他类型：
- en: '[PRE78]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: There are other important methods, which you can check in the documentation
    for `std::option::Option`. Even though we can use `Option` to handle a situation
    where there's something or nothing, it does not convey a message of *something
    went wrong*. We can use another type similar to `Option` in the next part to achieve
    this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他重要的方法，你可以在 `std::option::Option` 的文档中查看。尽管我们可以使用 `Option` 来处理有或没有某种情况的情况，但它并不能传达“出了问题”的消息。我们可以在下一部分使用与
    `Option` 类似的另一个类型来实现这一点。
- en: Returning Result
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回 Result
- en: 'In Rust, we have the `std::result::Result` enum that works like `Option`, but
    instead of saying *we have it* or *we don''t have it*, the `Result` type is more
    about saying *we have it* or *we have this error*. Just like `Option`, `Result`
    is an `enum` type of the possible `T` type or possible `E` error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，我们有 `std::result::Result` 枚举，它的工作方式类似于 `Option`，但 `Result` 类型更多的是说“我们有它”或“我们有这个错误”。就像
    `Option` 一样，`Result` 是可能的 `T` 类型或可能的 `E` 错误的枚举类型：
- en: '[PRE79]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Going back to the division by zero problem, take a look at the following simple
    example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回到除以零的问题，看看以下简单的例子：
- en: '[PRE83]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We don't want division by `0`, so we return an error for the preceding function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望除以 `0`，所以我们在前面的函数中返回一个错误。
- en: 'Similar to `Option`, `Result` has many convenient features we can use. Suppose
    we have the `we_have_it` and `we_have_error` variables:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Option` 类似，`Result` 有许多方便的特性我们可以使用。假设我们有 `we_have_it` 和 `we_have_error` 变量：
- en: '[PRE89]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can get the value or the error using pattern matching:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用模式匹配来获取值或错误：
- en: '[PRE91]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Or, we can use `if let` to destructure and get the value or the error:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `if let` 来解构并获取值或错误：
- en: '[PRE92]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can compare the `Ok` variant and the `Err` variant:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以比较 `Ok` 变体和 `Err` 变体：
- en: '[PRE93]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can check whether a variable is an `Ok` variant or an `Err` variant:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以检查一个变量是 `Ok` 变体还是 `Err` 变体：
- en: '[PRE94]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can convert `Result` to `Option`:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将 `Result` 转换为 `Option`：
- en: '[PRE95]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Just like `Option`, we can use `unwrap()`, `unwrap_or()`, or `unwrap_or_else()`:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像 `Option` 一样，我们可以使用 `unwrap()`、`unwrap_or()` 或 `unwrap_or_else()`：
- en: '[PRE96]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And, we can use `map()`, `map_err()`, `map_or()`, or `map_or_else()`:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们可以使用 `map()`、`map_err()`、`map_or()` 或 `map_or_else()`：
- en: '[PRE97]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: There are other important methods besides those methods in the `std::result::Result`
    documentation. Do check them because `Option` and `Result` are very important
    in Rust and Rocket.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `std::result::Result` 文档中的这些方法之外，还有其他重要的方法。请务必查看它们，因为 `Option` 和 `Result`
    在 Rust 和 Rocket 中非常重要。
- en: Returning a string or numbers as an error might be acceptable in some cases,
    but most likely, we want a real error type with a message and possible backtrace
    that we can process further. In the next section, we are going to learn about
    (and use) the `Error` trait and return the dynamic error type in our application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串或数字作为错误返回在某些情况下可能是可接受的，但大多数情况下，我们希望有一个真实的错误类型，包括错误信息和可能的回溯，这样我们就可以进一步处理。在下一节中，我们将学习（并使用）`Error`特质，并在我们的应用程序中返回动态错误类型。
- en: Creating a custom error type
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义错误类型
- en: 'Rust has a trait to unify propagating errors by providing the `std::error::Error`
    trait. Since the `Error` trait is defined as `pub trait Error: Debug + Display`,
    any type that implements `Error` should also implement the `Debug` and `Display`
    traits.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rust 有一个特质来统一通过提供 `std::error::Error` 特质来传播错误。由于 `Error` 特质被定义为 `pub trait
    Error: Debug + Display`，任何实现了 `Error` 的类型也应该实现 `Debug` 和 `Display` 特质。'
- en: 'Let''s see how we can create a custom error type by creating a new module:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过创建一个新的模块来创建自定义错误类型：
- en: 'In `src/lib.rs`, add the new `errors` module:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/lib.rs` 中，添加新的 `errors` 模块：
- en: '[PRE98]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'After that, create a new folder, `src/errors`, and add the `src/errors/mod.rs`
    and `src/errors/our_error.rs` files. In `src/errors/mod.rs`, add this line:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新的文件夹，`src/errors`，并添加 `src/errors/mod.rs` 和 `src/errors/our_error.rs`
    文件。在 `src/errors/mod.rs` 中，添加以下行：
- en: '[PRE99]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In `src/errors/our_error.rs`, add the custom type for `error`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/errors/our_error.rs` 中，为 `error` 添加自定义类型：
- en: '[PRE100]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then, we can implement the `Error` trait for `OurError`. In `src/errors/our_error.rs`,
    add the following lines:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以为 `OurError` 实现 `Error` 特质。在 `src/errors/our_error.rs` 中，添加以下行：
- en: '[PRE101]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Currently, for the `User` module, we return a `Result<..., Box<dyn Error>>`
    dynamic error for each method. This is a common pattern of returning an error
    by using any type that implements `Error` and then putting the instance in the
    heap using `Box`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，对于 `User` 模块，我们为每个方法返回一个 `Result<..., Box<dyn Error>>` 动态错误。这是一个使用任何实现了 `Error`
    的类型来返回错误，然后使用 `Box` 将实例放入堆中的常见模式。
- en: The problem with this approach is we can only use methods provided by the `Error`
    trait, that is, `source()`. We want to be able to use the `OurError` status, message,
    and debug information.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是我们只能使用 `Error` 特性提供的方法，即 `source()`。我们希望能够使用 `OurError` 的状态、消息和调试信息。
- en: 'So, let''s add a couple of builder methods to `OurError`. In `src/errors/our_error.rs`,
    add the following lines:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们给 `OurError` 添加几个构建方法。在 `src/errors/our_error.rs` 文件中添加以下行：
- en: '[PRE102]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'If we take a look at `src/models/user.rs`, there are three sources of errors:
    `sqlx::Error`, `uuid::Error`, and `argon2`. Let''s create a conversion for `sqlx::Error`
    and `uuid::Error` to `OurError`. Add the following `use` directive in `src/errors/our_error.rs`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看 `src/models/user.rs` 文件，有三个错误来源：`sqlx::Error`、`uuid::Error` 和 `argon2`。让我们为
    `sqlx::Error` 和 `uuid::Error` 创建到 `OurError` 的转换。在 `src/errors/our_error.rs` 文件中添加以下
    `use` 指令：
- en: '[PRE103]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Inside the same file, `src/errors/our_error.rs`, add the following lines:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件 `src/errors/our_error.rs` 中，添加以下行：
- en: '[PRE104]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'For `sqlx::Error`, we want to convert `not_found` error to HTTP status `404`
    and duplicate index error to an HTTP status 400bad request. Add the following
    lines to `src/errors/our_error.rs`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `sqlx::Error`，我们希望将 `not_found` 错误转换为 HTTP 状态 `404`，并将重复索引错误转换为 HTTP 状态 400bad
    request。在 `src/errors/our_error.rs` 文件中添加以下行：
- en: '[PRE105]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We need to do one more thing before we modify our `User` entity. Some crates
    in Rust do not compile the `std` library by default to make the resulting binary
    smaller and embeddable in IoT (Internet of Things) devices or WebAssembly. For
    example, the `argon2` crate does not include the `Error` trait implementation
    by default, so we need to enable the `std` feature. In `Cargo.toml`, modify the
    `argon2` dependencies to enable the `std` library features:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在修改我们的 `User` 实体之前，我们需要做一件事。Rust 中的某些 crate 默认不编译 `std` 库，以使生成的二进制文件更小，并嵌入到物联网（IoT）设备或
    WebAssembly 中。例如，`argon2` crate 默认不包含 `Error` 特性的实现，因此我们需要启用 `std` 功能。在 `Cargo.toml`
    中，修改 `argon2` 依赖项以启用 `std` 库功能：
- en: '[PRE106]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In `src/models/user.rs`, delete `use std::error::Error;` and replace it with
    `use crate::errors::our_error::OurError;`. Then, we can replace the methods for
    `User` to use `OurError` instead. Here is an example:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/models/user.rs` 文件中，删除 `use std::error::Error;` 并将其替换为 `use crate::errors::our_error::OurError;`。然后，我们可以将
    `User` 的方法替换为使用 `OurError`。以下是一个示例：
- en: '[PRE107]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'For the `argon2` error, we can create a function or method, or convert it manually.
    For example, in `src/models/user.rs`, we can do this:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `argon2` 错误，我们可以创建一个函数或方法，或者手动转换。例如，在 `src/models/user.rs` 文件中，我们可以这样做：
- en: '[PRE108]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Change all the methods to use `OurError`. Just a reminder: you can find the
    complete source code for `src/models/user.rs` in the GitHub repository at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有方法更改为使用 `OurError`。提醒一下：你可以在 GitHub 仓库中找到 `src/models/user.rs` 的完整源代码。[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07)。
- en: 'We will then use the `OurError` status and message in `src/routes/user.rs`.
    Because the `Error` type already implements the `Display` trait, we can use `e`
    directly inside `format!()`. Here is an example:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `src/routes/user.rs` 文件中，我们将使用 `OurError` 的状态和消息。因为 `Error` 类型已经实现了 `Display`
    特性，我们可以在 `format!()` 中直接使用 `e`。以下是一个示例：
- en: '[PRE109]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: You can find the complete source code for `src/routes/user.rs` in the GitHub
    repository. Now that we have implemented errors, it might be a good time to try
    to implement the catchers that we defined before in `src/catchers/mod.rs` to show
    default errors for the user. You can also see the example of the default catchers
    in the source code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中找到 `src/routes/user.rs` 的完整源代码。[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07)。现在我们已经实现了错误处理，可能是一个尝试实现之前在
    `src/catchers/mod.rs` 中定义的捕获器的良好时机，以显示默认错误给用户。你还可以在源代码中查看默认捕获器的示例。
- en: In an application, tracking and logging errors are an important part of maintaining
    the application. Since we implemented the `Error` trait, we can log the `source()`
    of an error in our application. Let's take a look at how to do that in the next
    section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用程序中，跟踪和记录错误是维护应用程序的重要部分。由于我们实现了 `Error` 特性，我们可以在应用程序中记录错误的 `source()`。让我们在下一节中看看如何做到这一点。
- en: Logging errors
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录错误
- en: 'In Rust, there''s a log crate that provides a facade for application logging.
    The log provides five macros: `error!`, `warn!,` `info!`, `debug!`, and `trace!`.
    An application can then create a log based on the severity and filter what needs
    to be logged, also based on the severity. For example, if we filter based on `warn`,
    then we only log `error!` and `warn!` and ignore the rest. Since the log crate
    does not implement the logging itself, people often use another crate to do the
    actual implementation. In the documentation for the log crate, we can find examples
    of other logging crates that can be used: `env_logger`, `simple_logger,` `simplelog`,
    `pretty_env_logger`, `stderrlog`, `flexi_logger`, `log4rs`, `fern`, `syslog`,
    and `slog-stdlog`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，有一个日志 crate 提供了应用程序日志的接口。日志提供了五个宏：`error!`、`warn!`、`info!`、`debug!`
    和 `trace!`。应用程序可以根据严重性创建日志并过滤需要记录的内容，同样也基于严重性。例如，如果我们基于 `warn` 过滤，那么我们只记录 `error!`
    和 `warn!` 并忽略其余内容。由于日志 crate 并没有实现日志记录本身，人们通常使用另一个 crate 来进行实际的实现。在日志 crate 的文档中，我们可以找到其他可用的日志
    crate 的示例：`env_logger`、`simple_logger`、`simplelog`、`pretty_env_logger`、`stderrlog`、`flexi_logger`、`log4rs`、`fern`、`syslog`
    和 `slog-stdlog`。
- en: 'Let''s implement custom logging in our application. We will use the `fern`
    crate for logging and wrap that in `async_log` to make logging asynchronous:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中实现自定义日志记录。我们将使用 `fern` crate 进行日志记录，并将其包装在 `async_log` 中以实现异步日志记录：
- en: 'First, add these crates in `Cargo.toml`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `Cargo.toml` 中添加以下这些 crate：
- en: '[PRE110]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'In `Rocket.toml`, add the config for `log_level`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Rocket.toml` 中添加 `log_level` 的配置：
- en: '[PRE111]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We can then create the function to initialize a global logger in our application.
    In `src/main.rs`, create a new function called `setup_logger`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在应用程序中创建一个初始化全局日志记录器的函数。在 `src/main.rs` 中，创建一个名为 `setup_logger` 的新函数：
- en: '[PRE112]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Inside the function, let''s initialize the logger:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，让我们初始化日志记录器：
- en: '[PRE113]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: First, we create a new instance of `fern::Dispatch`. After that, we configure
    the output format using the `format()` method. After setting the output format,
    we set the log level using the `level()` method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `fern::Dispatch` 的新实例。之后，我们使用 `format()` 方法配置输出格式。设置输出格式后，我们使用 `level()`
    方法设置日志级别。
- en: For the logger, we want to not only output the log to the operating system `stdout`,
    but we also want to write to a log file. We can do it using the `chain()` method.
    To avoid panicking, don't forget to create a `logs` folder in the application
    directory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日志记录器，我们不仅希望将日志输出到操作系统的 `stdout`，还希望写入日志文件。我们可以使用 `chain()` 方法来实现。为了避免恐慌，别忘了在应用程序目录中创建一个
    `logs` 文件夹。
- en: 'After we set up the level and logger, we wrap it inside `async_log`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好日志级别和日志记录器后，我们将其包装在 `async_log` 中：
- en: '[PRE114]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We will log `OurError` when it''s created. Inside `src/errors/our_error.rs`,
    add the following lines:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `OurError` 被创建时，我们将记录它。在 `src/errors/our_error.rs` 中添加以下行：
- en: '[PRE115]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Add the `setup_logger()` function to `src/main.rs`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `setup_logger()` 函数添加到 `src/main.rs` 中：
- en: '[PRE116]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now, let''s try to see `OurError` inside the application log. Try creating
    users with the same username; the application should emit a duplicate username
    error in the terminal and `logs/application.log` similar to the following:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在应用程序日志中查看 `OurError`。尝试创建具有相同用户名的用户；应用程序应该在终端和 `logs/application.log`
    中发出类似以下的重名用户错误：
- en: '[PRE117]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Now that we have learned how to log errors, we can implement logging functionalities
    to improve the application. For example, we might want to create server-side analytics,
    or we can combine the logs with third-party monitoring as a service to improve
    the operations and create business intelligence.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何记录错误，我们可以实现日志功能来改进应用程序。例如，我们可能想要创建服务器端分析，或者我们可以将日志与第三方监控服务结合，以改进操作并创建商业智能。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have learned some ways to handle errors in Rust and Rocket
    applications. We can use `panic!`, `Option`, and `Result` as a way to propagate
    errors and create handling for the errors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些在 Rust 和 Rocket 应用程序中处理错误的方法。我们可以使用 `panic!`、`Option` 和 `Result`
    来传播错误并创建错误处理。
- en: We have also learned about creating a custom type that implements the `Error`
    trait. The type can store another error, creating an error chain.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何创建一个实现 `Error` 特质的自定义类型。该类型可以存储另一个错误，创建一个错误链。
- en: Finally, we learned ways to log errors in our application. We can also use log
    capability to improve the application itself.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了在应用程序中记录错误的方法。我们还可以使用日志功能来改进应用程序本身。
- en: Our user pages are looking good, but using `String` all over the place is cumbersome,
    so in the next chapter, we are going to learn more about templating using CSS,
    JavaScript, and other assets in our application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户页面看起来不错，但到处使用`String`显得有些繁琐，所以在下章中，我们将学习如何使用CSS、JavaScript以及应用中的其他资源进行模板化。
