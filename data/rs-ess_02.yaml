- en: Chapter 2. Using Variables and Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 使用变量和类型
- en: 'In this chapter, we look at the basic building blocks of a Rust program: variables
    and their types. We discuss variables of primitive types, whether their type has
    to be declared or not, and the scope of variables. Immutability, one of the cornerstones
    of Rust''s safety strategy, is also discussed and illustrated.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨Rust程序的基本构建块：变量及其类型。我们讨论原始类型的变量，是否需要声明其类型，以及变量的作用域。不可变性是Rust安全策略的基石之一，也将被讨论并举例说明。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Comments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释
- en: Global constants
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局常量
- en: Values and primitive types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值和原始类型
- en: Binding variables to values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量绑定到值
- en: Scope of a variable and shadowing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的作用域和阴影
- en: Type checking and conversions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查和转换
- en: Expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式
- en: The stack and the heap
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和堆
- en: Our code examples will center on building a text-based game called Monster Attack.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码示例将集中在构建一个名为“Monster Attack”的基于文本的游戏。
- en: Comments
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Ideally, a program should be self-documenting by using descriptive variable
    names and easy to read code, but there are always cases where additional comments
    about a program''s structure or algorithms are needed. Rust follows the C convention
    and has the following convention for marking comments:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，一个程序应该通过使用描述性的变量名和易于阅读的代码来自我说明，但总有一些情况下需要关于程序结构或算法的额外注释。Rust遵循C语言约定，并具有以下注释标记约定：
- en: '**Line comments** (`//`): Everything on the line after `//` is commentary and
    not compiled'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行注释** (`//`): `//`之后行上的所有内容都是注释，不会被编译'
- en: '**Block or multi-line comments** (`/* */`): Everything between the start `/*`
    and the end `*/` is not compiled'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块或多行注释** (`/* */`): 从开始`/*`到结束`*/`之间的所有内容都不会被编译'
- en: 'However, the preferred Rust style is to use only line comments even for multiple
    lines, like the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Rust推荐的风格是即使对于多行，也只使用行注释，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Use the block comments only to comment out code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用块注释来注释掉代码。
- en: Rust also has a doc comment (`///`) that is useful in larger projects that require
    an official documentation for customers and developers. Such comments have to
    appear before an item (like a function) on a separate line to document that item.
    In these comments, you can use Markdown formatting syntax; for more information,
    go to [https://en.wikipedia.org/wiki/Markdown](https://en.wikipedia.org/wiki/Markdown).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rust还有一个有用的文档注释（`///`），适用于需要为客户和开发者提供官方文档的大型项目。这样的注释必须出现在单独一行上的项目（如函数）之前，以记录该项目。在这些注释中，你可以使用Markdown格式化语法；有关更多信息，请访问[https://en.wikipedia.org/wiki/Markdown](https://en.wikipedia.org/wiki/Markdown)。
- en: 'Here is a `doc` comment:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`doc`注释：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll see more relevant uses of doc comments in later code snippets. The rustdoc
    tool can compile these comments into a project's documentation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的代码片段中看到更多关于文档注释的相关用法。`rustdoc`工具可以将这些注释编译成项目的文档。
- en: Global constants
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局常量
- en: 'Often, an application needs a few values that are in fact constants; they do
    not change in the course of the program. For example: the name of our game, which
    is "Monster Attack", is a constant, as is the maximum value of health, which is
    the number 100\. We must be able to use them in `main()` or any other function
    in our program, so they are placed at the top of the code file. They live in the
    global scope of the program. Such constants are declared with the `static` keyword
    as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个应用程序需要一些实际上是不变的值；它们在程序执行过程中不会改变。例如：我们游戏的名字“Monster Attack”是一个常量，同样，最大生命值，即数字100，也是一个常量。我们必须能够在`main()`或程序中的任何其他函数中使用它们，因此它们被放置在代码文件的最顶部。它们存在于程序的全球范围内。这样的常量使用`static`关键字声明，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Names of constants must be in uppercase and underscores can be used to separate
    words. Their type must also be indicated; `MAX_HEALTH` is a 32-bit integer (`i32`)
    and `GAME_NAME` is a string (`str`). As we will discuss further, the declaration
    of types for variables is done in exactly the same way although this is often
    optional when the compiler can infer the type from the code's context.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 常量的名称必须全部大写，可以使用下划线来分隔单词。它们的类型也必须指明；`MAX_HEALTH`是一个32位整数（`i32`），而`GAME_NAME`是一个字符串（`str`）。正如我们进一步讨论的那样，变量的类型声明方式与这完全相同，尽管当编译器可以从代码上下文中推断类型时，这通常是可选的。
- en: 'Don''t worry too much about the `&''static` indication for now. Remember that
    Rust is a low-level language, so many things must be specified in detail. The
    `&` annotation is a reference to something (it contains the memory address of
    a value); here it contains the reference to the string. However, if we only use
    `&str` and compile, we get an error for that line. Have a look at the following
    snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必太担心 `'&static'` 指示。记住，Rust 是一种底层语言，所以许多事情必须详细指定。`&` 注解是对某个东西的引用（它包含值的内存地址）；在这里，它包含对字符串的引用。然而，如果我们只使用
    `&str` 并编译，我们会得到该行的错误。看看下面的片段：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will give you the following error:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下错误：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `2:22` means that we have an error on line 2 and position 22, so we must
    set the line numbering in our editor. We must add the lifetime specifier `'static`
    to the type annotation so that we get `&'static str`. The lifetime of an object
    in Rust is very important because it says how long the object will live in the
    program's memory. The Rust compiler adds the code to remove an object when its
    lifetime is over, freeing the memory that it occupied. The `'static` lifetime
    is the longest possible lifetime; such an object stays alive throughout the entire
    application, and so it is available to all of its code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`2:22` 表示我们在第2行第22个位置有一个错误，因此我们必须在编辑器中设置行号。我们必须将 `'static` 生命周期指定符添加到类型注解中，以便得到
    `&'static str`。在 Rust 中，对象的生存期非常重要，因为它说明了对象将在程序的内存中存活多久。Rust 编译器会在对象的生存期结束时添加代码来移除对象，释放它所占用的内存。`'static`
    生命周期是最长可能的生存期；这样的对象在整个应用程序中保持存活，因此它对所有代码都是可用的。
- en: 'Even when we add this specifier, the compiler gives us the ``warning: static
    item is never used: `MAX_HEALTH`, #[warn(dead_code)] on by default`` warning and
    an analogous warning for `GAME_NAME`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使添加了这个指定符，编译器也会给出“警告：静态项从未使用：`MAX_HEALTH`，默认开启 `#[warn(dead_code)]`”警告以及针对
    `GAME_NAME` 的类似警告。
- en: These warnings do not prevent the compilation, so at this stage, we have an
    executable. However, the compiler is right. These objects are never used in the
    program's code; so, in a complete program, you should either use them or throw
    them out.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些警告并不能阻止编译，因此在这个阶段，我们有一个可执行的程序。然而，编译器是对的。这些对象在程序的代码中从未被使用；所以，在一个完整的程序中，你应该要么使用它们，要么将它们丢弃。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It takes a while before an aspiring Rust developer starts to regard the Rust
    compiler as his or her friend and not an annoying machine that keeps spitting
    out errors and warnings. As long as you see this message at the end of the compiler
    output, `error: aborting due to previous errors`, no (new) executable is made.
    But remember, correcting the errors eliminates runtime problems, so this can save
    you a lot of time that would be otherwise wasted tracking nasty bugs. Often, the
    error messages are accompanied with helpful notes on how to eliminate the error.
    Even the warnings can point you to flaws in your code. Rust also warns us when
    something is declared but not used in the code that follows, such as unused variables,
    functions, imported modules, and so on. It even warns us if we make a variable
    mutable (which means that its value can be changed) when it should not be or when
    code doesn''t get executed. The compiler does such a good job that when you reach
    the stage where all errors and warnings are eliminated, your program will most
    likely run correctly!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个有抱负的 Rust 开发者开始将 Rust 编译器视为他的或她的朋友，而不是一个不断吐出错误和警告的讨厌的机器之前，需要一段时间。只要你在编译器输出的末尾看到这条消息，“错误：由于之前的错误而中止”，就不会生成（新的）可执行文件。但请记住，纠正错误可以消除运行时问题，因此这可以节省你大量本可以浪费在追踪讨厌的虫子上的时间。通常，错误消息会附带有关如何消除错误的帮助性说明。甚至警告也可以指出你代码中的缺陷。Rust
    还会在代码中声明但未使用某些内容时警告我们，例如未使用的变量、函数、导入的模块等。它甚至会在我们不应该改变变量值时警告我们，或者当代码没有执行时。编译器的工作如此出色，以至于当你达到所有错误和警告都已消除的阶段时，你的程序很可能运行正确！
- en: 'Besides static values, we can also use simple constant values whose value never
    changes. Constants always have to be typed, for example, `const PI: f32 = 3.14;`
    they are more local in scope than static values.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '除了静态值之外，我们还可以使用简单的常量值，其值永远不会改变。常量总是需要指定类型，例如，`const PI: f32 = 3.14;` 它们的范围比静态值更局部。'
- en: The compiler automatically substitutes the value of the constant everywhere
    in the code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动在代码的每个地方替换常量的值。
- en: Printing with string interpolation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符串插值打印
- en: 'An obvious way to use variables is to print out their values, as we have done
    here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量的一个明显方式是打印它们的值，就像我们在这里所做的那样：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This gives the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The constant PI exists in the standard library, to use this value insert this
    statement at the top: use `std::f32::consts;` and then use the PI value as follows:
    `println!("{}", consts::PI);`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 常量 PI 存在于标准库中，要使用此值，请将以下语句插入顶部：`use std::f32::consts;` 然后如下使用 PI 值：`println!("{}",
    consts::PI);`
- en: 'The first argument of `println!` is a literal format string that contains a
    `{}` placeholder. The value of the constant or variable after the comma is converted
    to a string and replaces the {}. There can be more than one placeholder, and they
    can be numbered in order so that they can be used repeatedly, as shown in the
    following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`println!` 的第一个参数是一个包含 `{}` 占位符的文本格式字符串。逗号后面的常量或变量的值被转换为字符串并替换 `{}`。可以有多个占位符，并且它们可以按顺序编号，以便可以重复使用，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The placeholder can also contain one or more named arguments, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符也可以包含一个或多个命名参数，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will give you the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Special ways of formatting can be indicated inside `{}` after a colon (`:`),
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在冒号（`:`）之后的大括号（`{}`）内可以指示特殊的格式化方式，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following formatting possibilities exist according to the type that must
    be printed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据必须打印的类型，存在以下格式化可能性：
- en: '`o` for octal'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o` 表示八进制'
- en: '`x` for lower hexadecimal'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` 表示小写十六进制'
- en: '`X` for upper hexadecimal'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X` 表示大写十六进制'
- en: '`p` for a pointer'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p` 表示指针'
- en: '`b` for binary'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b` 表示二进制'
- en: '`e` for lower exponential notation'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e` 表示小数指数表示法'
- en: '`E` for upper exponential notation'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E` 表示大写指数表示法'
- en: '`?` for debugging purposes'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 用于调试目的'
- en: The `format!` macro has the same parameters and works in the same way as `println!`,
    but it returns a string instead of printing out.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`format!` 宏具有相同的参数，并且与 `println!` 以相同的方式工作，但它返回一个字符串而不是打印出来。'
- en: Go to [http://doc.rust-lang.org/std/fmt/](http://doc.rust-lang.org/std/fmt/)
    for an overview of all the possibilities.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [http://doc.rust-lang.org/std/fmt/](http://doc.rust-lang.org/std/fmt/) 了解所有可能性的概述。
- en: Values and primitive types
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值和原始类型
- en: 'Constants that have been initialized have a value. Values exist in different
    types: `70` is an integer, `3.14` is a float, and `Z` and `q` are of the `char`
    type (they are characters). Characters are unicode values that take 4 bytes of
    memory each. `Godzilla` is a string of type `&str` (which is a Unicode UTF8 by
    default), `true` and `false` are of the `bool` type; they are Boolean values.
    Integers can be written in different formats:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 已经初始化的常量具有值。值存在于不同的类型中：`70` 是整数，`3.14` 是浮点数，而 `Z` 和 `q` 是 `char` 类型（它们是字符）。字符是占用每个
    4 字节内存的 Unicode 值。`Godzilla` 是类型为 `&str`（默认为 Unicode UTF8）的字符串，`true` 和 `false`
    是 `bool` 类型；它们是布尔值。整数可以以不同的格式书写：
- en: Hexadecimal format with `0x` (for example, `0x46` for `70`)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `0x` 开头的十六进制格式（例如，`0x46` 表示 `70`）
- en: Octal format with `0o`, (for example, `0o106` for `70`)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `0o` 开头的八进制格式（例如，`0o106` 表示 `70`）
- en: Binary format with `0b`, (for example, `0b1000110`)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `0b` 开头的二进制格式（例如，`0b1000110`）
- en: 'Underscores can be used for readability, as in `1_000_000`. Sometimes, the
    compiler will urge you to indicate more explicitly the type of number with a suffix.
    For example, the number after `u` or `i` is the number of memory bits used, namely
    `8`, `16`, `32`, or `64`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线可用于提高可读性，例如 `1_000_000`。有时，编译器会敦促你通过后缀更明确地指示数字的类型。例如，`u` 或 `i` 后的数字是使用的内存位数，即
    `8`、`16`、`32` 或 `64`：
- en: '`10usize` denotes an unsigned integer of machine word size `usize`, which can
    be any of the `u8`, `u16`, `u32`, or `u64` types'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10usize` 表示机器字大小的无符号整数 `usize`，可以是 `u8`、`u16`、`u32` 或 `u64` 中的任何一种类型'
- en: '`10isize` denotes a signed integer of machine word size `isize`, which can
    be any of the types among `i8`, `i16`, `i32`, and `i64`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10isize` 表示机器字大小的有符号整数 `isize`，可以是 `i8`、`i16`、`i32` 和 `i64` 中的任何一种类型'
- en: In the preceding cases, for a 64-bit operating system `usize` is in fact `u64`
    and `isize` is equivalent to `i64`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的情况下，对于 64 位操作系统，`usize` 实际上是 `u64`，而 `isize` 等同于 `i64`。
- en: '`3.14f32` denotes a 32-bit floating point number'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3.14f32` 表示 32 位浮点数'
- en: '`3.14f64` denotes a 64-bit floating point number'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3.14f64` 表示 64 位浮点数'
- en: 'The numeric types `i32` and `f64` are the defaults if no suffix is given, but
    in that case, to differentiate between them, you must end an `f64` value with
    `.0`, like this: `let e = 7.0;`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有给出后缀，则数字类型 `i32` 和 `f64` 是默认值，但在此情况下，为了区分它们，必须在 `f64` 值的末尾加上 `.0`，如下所示：`let
    e = 7.0;`。
- en: Indicating a specific type is only needed when the compiler signals that it
    cannot infer the type of the variable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当编译器指示它无法推断变量的类型时，才需要指定特定类型。
- en: Rust is like any other C-like language when it comes to the different operators
    that exist on values and their precedence (go to [http://doc.rust-lang.org/reference.html#binary-operator-expressions](http://doc.rust-lang.org/reference.html#binary-operator-expressions)
    for more information on this). However, note that Rust does not have increment
    (`++`) or decrement (`--`) operators. To compare two values for equality, use
    `==` and to test whether they are different use `!=`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Rust在值上存在的不同运算符及其优先级方面，与其他C语言类似（有关更多信息，请参阅[http://doc.rust-lang.org/reference.html#binary-operator-expressions](http://doc.rust-lang.org/reference.html#binary-operator-expressions)）。然而，请注意，Rust没有自增（`++`）或自减（`--`）运算符。要比较两个值是否相等，请使用`==`，要测试它们是否不同，请使用`!=`。
- en: There is even the empty value `()` of zero size, which is the only value of
    the so-called unit type `()`. This is used to indicate the return value when an
    expression or a function returns nothing (no value), as is the case for a function
    that only prints to the console. `()` is not the equivalent of a null value in
    other languages; `()` means no value, whereas null is a value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有空值`()`，它的大小为零，是所谓的单元类型`()`的唯一值。这用于表示表达式或函数返回无值（没有值）时的返回值，例如仅向控制台打印的函数。`()`在其他语言中不是null值的等价物；`()`表示没有值，而null是一个值。
- en: Consulting Rust documentation
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查阅Rust文档
- en: 'The quickest way to find more detailed information about a Rust topic is to
    browse the documentation screen of the standard library at [http://doc.rust-lang.org/std/](http://doc.rust-lang.org/std/).
    On its left-hand side, you can find a listing of all the available crates that
    you can browse for more details. However, the most useful feature is the search
    box at the top; you can type in a few letters or a word to get a number of useful
    references. Have a look at the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到有关Rust主题的更详细信息，最快的方法是浏览标准库的文档屏幕[http://doc.rust-lang.org/std/](http://doc.rust-lang.org/std/)。在其左侧，您可以找到所有可用的crate列表，您可以浏览以获取更多详细信息。然而，最有用的功能是顶部的搜索框；您可以输入几个字母或一个单词来获取多个有用的参考。请看以下截图：
- en: '![Consulting Rust documentation](img/image00174.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![查阅Rust文档](img/image00174.jpeg)'
- en: 'The following is an exercise for you:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个练习：
- en: Try to change the value of a constant. This is of course not allowed. What error
    do you get? Have a look at `Chapter2/exercises/change_constant.rs`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试更改常量的值。这当然是不允许的。你会得到什么错误？请看`Chapter2/exercises/change_constant.rs`。
- en: Look up the `println!` macro in the documentation.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文档中查找`println!`宏。
- en: Read the `fmt` specification and write a program that will print the `3.2f32`
    value as `+003.20`. Refer to `Chapter2/exercises/formatting.rs`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读关于`fmt`规范的说明，并编写一个程序，该程序将`3.2f32`值打印为`+003.20`。请参阅`Chapter2/exercises/formatting.rs`。
- en: Binding variables to values
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将变量绑定到值
- en: 'Storing all values in constants is not an option. It is not good because constants
    live as long as the program and therefore be changed, and often we want to change
    values. In Rust, we can bind a value to a variable by using a `let` binding:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有值存储在常量中不是一个选择。这样做不好，因为常量会随着程序的生命周期而存在，因此可以被更改，而我们通常希望更改值。在Rust中，我们可以通过使用`let`绑定来将值绑定到变量：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Unlike many other languages such as Python or Go, the semicolon (`;`) is needed
    here to end the statement. Otherwise, the compiler will throw the `` error: expected
    one of `.`, `;`, or an operator, found `}` `` error at us.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言（如Python或Go）不同，这里需要分号（`;`）来结束语句。否则，编译器会抛出错误：期望的是`.`、`;`或运算符，但找到的是`}`。
- en: 'We also want to create bindings only when they are used in the rest of the
    program, but you needn''t worry because the Rust compiler warns us about that:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望在程序的其他部分使用绑定时才创建绑定，但您不必担心，因为Rust编译器会警告我们：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For prototyping purposes, you can suppress the warning by prefixing the variable
    name with a `_` , like in `let _ energy = 5;`. In general, `_` is used for variables
    that we don't need.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了原型设计的目的，您可以通过在变量名前加一个下划线`_`来抑制警告，例如`let _ energy = 5;`。通常，`_`用于我们不需要的变量。
- en: Note that in the preceding declaration, we didn't need to indicate the type;
    Rust inferred the type of `energy` to be an integer, which the `let` binding triggered.
    If the type is not obvious, the compiler searches in the code context to check
    from where the variable gets a value or how it is used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的声明中，我们不需要指示类型；Rust通过`let`绑定推断出`energy`的类型是整数。如果类型不明显，编译器会在代码上下文中搜索，以检查变量从哪里获得值或如何使用。
- en: However, giving type hints like `let energy = 5u16;` is also okay; this way
    you help the compiler a bit by indicating the type of energy, which is a 2-byte
    unsigned integer in this case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用如`let energy = 5u16;`这样的类型提示也是可以的；这样你通过指示`energy`的类型（在这种情况下是一个2字节的无符号整数）来帮助编译器。
- en: 'We can use the `energy` variable by using it in an expression; for example,
    by assigning it to another variable or by printing it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在表达式中使用它来使用`energy`变量；例如，通过将其赋值给另一个变量或打印它：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are some other declarations:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他的声明：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The value of `magic_number` could also be written as `3.14_f32`; the `_` separates
    the digits from the type to improve readability.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`magic_number`的值也可以写成`3.14_f32`；下划线`_`将数字与类型分开，以提高可读性。'
- en: Declarations can replace previous declarations of the same variable. A statement
    like `let energy = "Abundant";` would now bind energy to the value `Abundant`
    of string type. The old declaration can no longer be used and its memory is freed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 声明可以替换相同变量的先前声明。例如，`let energy = "Abundant";`这样的语句现在会将`energy`绑定到字符串类型的值`Abundant`。旧的声明将不能再使用，并且其内存将被释放。
- en: Mutable and immutable variables
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变和不可变变量
- en: 'Suppose we get a boost from swallowing a health pack and our energy rises to
    value 25\. However, if we write `energy = 25;`, we get an `` error: re-assignment
    of immutable variable `energy` `` error. So, what is wrong here?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们通过吞下一个健康包获得提升，我们的能量值上升到25。然而，如果我们写`energy = 25;`，我们会得到一个错误：`error: re-assignment
    of immutable variable `energy``。那么这里有什么问题？'
- en: Well, Rust applies a programmer's wisdom here; a lot of bugs come from inadvertent
    or wrong changes made to variables, so don't let the code change a value unless
    you have deliberately allowed it!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Rust在这里应用了程序员的智慧；很多错误都来自对变量进行的意外或错误更改，所以不要让代码更改值，除非你明确允许它！
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Variables are by default **immutable** in Rust, which is very similar to what
    functional languages do. In pure functional languages, mutability is not even
    allowed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，变量默认是**不可变的**，这与函数式语言非常相似。在纯函数式语言中，甚至不允许可变性。
- en: 'If you want a mutable variable because its value can change during code execution,
    you have to indicate that explicitly with `mut`. Have a look at the following
    code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个值在代码执行期间可以改变的变量，你必须通过`mut`显式地指出。看看下面的代码片段：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Simply declaring a variable as `let n;` is also not enough. If we do this,
    we will get ``error: unable to infer enough type information about `_`; type annotations
    required``. The compiler needs a value to infer its type.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '仅通过声明变量为`let n;`也是不够的。如果我们这样做，我们会得到`error: unable to infer enough type information
    about `_`; type annotations required`。编译器需要一个值来推断其类型。'
- en: 'We can give the compiler this information by assigning a value to `n`, like
    `n = -2;`, but as the message says, we could also indicate its type as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将值赋给`n`来给编译器提供这个信息，例如`n = -2;`，但正如消息所说，我们也可以如下指示其类型：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, you can even use the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你甚至可以使用以下方法：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The type (here `i32`) follows the variable name after a colon (`:`) (as we
    already showed for global constants), optionally followed by an initialization.
    In general, the type is indicated like `n: T`, where `n` is a variable and `T`
    is a type, and it is read as variable `n` is of the type `T`. So, this is the
    inverse of what is done in C/C++, Java, or C#, where one would write `T n`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '类型（在这里是`i32`）跟在变量名后面一个冒号（`:`）之后（正如我们之前为全局常量所展示的），可选地后面跟着一个初始化。一般来说，类型是这样表示的`n:
    T`，其中`n`是变量，`T`是类型，它被读作变量`n`是类型`T`。所以，这与C/C++、Java或C#中的做法相反，在那里人们会写`T n`。'
- en: 'For primitive types, this can be done simply with a suffix, like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始类型，这可以通过后缀简单地完成，如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Trying to use an uninitialized variable results in the `error: use of possibly
    uninitialized variable` error (try it out). Local variables have to be initialized
    before they can be used in order to prevent undefined behavior.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试使用未初始化的变量会导致`error: use of possibly uninitialized variable`错误（试试看）。局部变量在使用之前必须初始化，以防止未定义的行为。'
- en: You can experiment with a mutable global constant. What do you have to do to
    allow it? Why would that be? (For an example code, see `mutable_constant.rs`.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试一个可变的全局常量。你必须做什么才能允许它？为什么会这样？（有关示例代码，请参阅 `mutable_constant.rs`。）
- en: When the compiler does not recognize a name in your code, you will get an `unresolved
    name` error. This may probably be just a typo, but it will be caught early on
    at compilation and not at runtime!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器无法识别你代码中的名称时，你会得到一个 `unresolved name` 错误。这可能是仅仅是一个拼写错误，但它会在编译时而不是运行时被捕获！
- en: Scope of a variable and shadowing
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的作用域和阴影
- en: All variables defined in `bindings.rs` have local scope delimited by `{ }` of
    the function, which happens to be `main()` here, and this applies to any function.
    After the ending `}`, they go out of scope and their memory allocation is freed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bindings.rs` 中定义的所有变量都具有局部作用域，由函数的 `{ }` 分隔，这里恰好是 `main()` 函数，并且这适用于任何函数。在
    `}` 结束后，它们的作用域结束，并且它们的内存分配被释放。
- en: 'We can even make a more limited scope inside a function by defining a code
    block that contains all the code within a pair of curly braces (`{ }`), as in
    the following snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在函数内部定义一个包含所有代码的代码块，以创建一个更有限的作用域，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This gives the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A variable defined in the block (like `inner`) is only known inside that block.
    A variable in the block can also have the same name as a variable in an enclosing
    scope (like `outer`), which is replaced (shadowed) by the block variable until
    the block ends. What do you think will happen when you try to print `inner` after
    the block? Try it out.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块（如 `inner`）中定义的变量仅在代码块内部已知。代码块中的变量也可以与封装作用域中的变量（如 `outer`）具有相同的名称，该名称在代码块结束时被替换（阴影）为代码块变量。当你尝试在代码块之后打印
    `inner` 时会发生什么？试一试。
- en: So, why would you want to use a code block? In the *Expressions* section, we
    will see that a code block can return a value that can be bound to a variable
    with let. A code block can also be empty (`{ }`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么你想使用代码块呢？在 *表达式* 部分，我们将看到代码块可以返回一个值，该值可以用 `let` 绑定到一个变量上。代码块也可以为空（`{ }`）。
- en: Type checking and conversions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检查和转换
- en: Rust has to know the type of each variable so that it can check (at compile
    time) whether they are only used in the manner in which their type permits. This
    way programs are type safe and a whole range of bugs can be avoided.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 必须知道每个变量的类型，以便在编译时检查它们是否仅以允许的方式使用。这样程序就是类型安全的，并且可以避免一系列错误。
- en: 'This also means that we cannot change the type of a variable during its lifetime
    because of static typing; for example, the score variable in the following snippet
    cannot change from an integer to a string:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着由于静态类型，我们无法在变量的生命周期内更改其类型；例如，以下代码片段中的 `score` 变量不能从整数变为字符串：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We get the compiler error, ``error: mismatched types: expected `int`, found
    `&''static str` (expected int, found &-ptr``.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '我们得到编译器错误，`error: mismatched types: expected `int`, found `&''static str` (expected
    int, found &-ptr)`。'
- en: 'However, we are allowed to write the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以编写以下代码：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Rust lets us redefine variables; each `let` binding creates a new variable score
    that hides the previous one, which is freed from memory. This is actually quite
    useful because variables are immutable by default.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许我们重新定义变量；每个 `let` 绑定都会创建一个新的变量 `score`，它隐藏了之前的变量，之前的变量将从内存中释放。这实际上非常有用，因为变量默认是不可变的。
- en: 'Adding strings with `+` (like the players in the following code) is not defined
    in Rust:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `+` 运算符（如以下代码中的玩家）在 Rust 中未定义：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then get `` error: binary operation `+` cannot be applied to type `&str`
    ``.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们得到 `error: binary operation `+` cannot be applied to type `&str``。'
- en: 'In Rust, you can use the `to_string()` method to convert the value to a String
    type like this: `let player3 = player1.to_string() + player2;`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，你可以使用 `to_string()` 方法将值转换为 String 类型，如下所示：`let player3 = player1.to_string()
    + player2;`。
- en: 'Otherwise, you could use the `format!` macro:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以使用 `format!` 宏：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In both the cases, `player3` has the value `"RobJane"`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`player3` 的值都是 `"RobJane"`。
- en: 'Let''s find out what happens when you assign a value from a variable of a certain
    type to another variable of a different type:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出当你将一个变量的值赋给另一个不同类型的变量时会发生什么：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is again not allowed; we get the same error (``error: mismatched types:
    expected `u32`, found `i32` (expected u32, found i32)``). To enable maximal type
    checking, Rust does not permit automatic (or implicit) conversions of one type
    to another like C++ does; therefore, it avoids a lot of hard-to-find bugs. For
    example, the numbers after the decimal point are lost when a `f32` value is converted
    to an `i32` value; this could lead to errors when done automatically.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '这同样是不允许的；我们会得到相同的错误（`error: mismatched types: expected `u32`, found `i32` (expected
    u32, found i32)`）。为了启用最大化的类型检查，Rust 不允许像 C++ 那样自动（或隐式）地将一个类型转换为另一个类型；因此，它避免了大量难以发现的错误。例如，当
    `f32` 值转换为 `i32` 值时，小数点后的数字会丢失；这可能导致自动转换时出现错误。'
- en: 'We can, however, do an explicit conversion (a casting) with the `as` keyword:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `as` 关键字进行显式转换（类型转换）：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When points contain a negative value, the sign would be lost after conversion.
    Similarly, when casting from a wider value like a float to an integer, the decimal
    part is truncated:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当点包含负值时，符号在转换后会丢失。同样，当从更宽的值（如浮点数）转换为整数时，小数部分会被截断：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In addition, the value must be convertible to the new type as a string cannot
    be converted to an integer, as shown in the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值必须可以转换为新类型，因为字符串不能转换为整数，如下面的例子所示：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Aliasing
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名
- en: 'It can be useful sometimes to give a new, more descriptive or a shorter name
    to an existing type. This can be done with the `type` keyword, as in the following
    example where we needed a specific (but size-limited) variable for `MagicPower`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时给现有的类型起一个新名字，使其更具描述性或更短，是有用的。这可以通过 `type` 关键字来完成，如下面的例子中，我们需要一个特定的（但大小有限的）变量用于
    `MagicPower`：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A type name starts with a capital letter, as does each word that is part of
    the name. What happens when we change the value `7800` to `78000`? The compiler
    detects this with the following warning, `warning: literal out of range for its
    type`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '类型名称以大写字母开头，每个作为名称一部分的单词也是如此。当我们把值 `7800` 改为 `78000` 时会发生什么？编译器会通过以下警告来检测这一点，`warning:
    literal out of range for its type`。'
- en: Expressions
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: Rust is an **expression-oriented** language, which means that most pieces of
    code are in fact expressions, that is, they compute a value and return that value
    (in that sense, values are also expressions). However, expressions by themselves
    do not form meaningful code; they must be used in statements.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种**表达式导向**的语言，这意味着大多数代码片段实际上都是表达式，也就是说，它们计算一个值并返回这个值（在这个意义上，值也是表达式）。然而，仅凭表达式本身并不能构成有意义的代码；它们必须被用在语句中。
- en: 'The `let` bindings like the following are declaration statements; they are
    not expressions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `let` 绑定是声明语句；它们不是表达式：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, `a + b` is an expression, and if we omit the semicolon at the end,
    the resulting value (here `7`) is returned. This is often used when a function
    needs to return its value (see examples in the next chapter). Ending an expression
    with a semicolon like `a + b;` suppresses the value of an expression, thereby
    throwing away the return value and making it an expression statement that returns
    the unit value `()`. A code is usually a sequence of statements, one on each code
    line, and Rust has to know when a statement ends; this is why nearly every Rust
    code line ends with a semicolon.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`a + b` 是一个表达式，如果我们省略末尾的分号，那么得到的值（这里 `7`）就会被返回。这通常在函数需要返回其值时使用（参见下一章的例子）。以分号结束表达式，如
    `a + b;`，会抑制表达式的值，从而丢弃返回值，使其成为一个返回单位值 `()` 的表达式语句。代码通常是一系列语句的序列，每个代码行一个，Rust 必须知道何时一个语句结束；这就是为什么几乎每一行
    Rust 代码都以分号结束。
- en: 'What do you think the assignment `m = 42;` is? This is not a binding because
    there is no `let`. That should have happened on a previous code line. It is an
    expression that returns the unit value `()`. A compound binding like `let p =
    q = 3;` is not allowed in Rust; it returns the `error: unresolved name q` error.
    However, you can chain `let` bindings like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '你认为赋值 `m = 42;` 是什么？这不是一个绑定，因为没有 `let`。这应该在之前的代码行上发生。这是一个返回单位值 `()` 的表达式。在
    Rust 中不允许复合绑定，如 `let p = q = 3;`，它会返回 `error: unresolved name q` 错误。然而，你可以像这样链式使用
    `let` 绑定：'
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is an exercise for you. Print out the values of a, b, and n after this
    code snippet and explain the value of `a` (for example code, see `compound_let.rs`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个练习给你。在以下代码片段之后打印出 a、b 和 n 的值，并解释 `a` 的值（例如代码，请参阅 `compound_let.rs`）：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A code block is also an expression, which will return the value of its last
    expression if we omit the semicolon. For example, in the following code snippet,
    `n1` gets the value `7`, but `n2` gets no value (or rather the unit value `()`)
    because the return value of the second code block was suppressed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块也是一个表达式，如果我们省略分号，它将返回其最后一个表达式的值。例如，在以下代码片段中，`n1` 获取值 `7`，但 `n2` 获取不到值（或者更确切地说，是单位值
    `()`)，因为第二个代码块的返回值被抑制了：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the variables `a` and `b` are declared in a code block and live only as
    long as the block itself lives as they are local to the block. Note that the semicolon
    after the closing brace of the block (`};`) is needed. To print the unit value
    `()`, we need {`:?`} as the format specifier.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量 `a` 和 `b` 在代码块中声明，并且它们只存在于代码块的生命周期内，因为它们是局部的。注意，在代码块结束括号后面的分号（`;`）是必需的。要打印单位值
    `()`，我们需要 `{`:?`}` 作为格式说明符。
- en: The stack and the heap
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈和堆
- en: 'Since memory allocation is very important in Rust, we must have a good picture
    of what is going on. A program''s memory is divided into the stack and heap memory
    parts; to get more background on these concepts, read the information on the classic
    web page at [https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap).
    Primitive values such as numbers (like 32 in the figure), characters, and true/false
    values are stored on the stack, while the value of more complex objects that could
    grow in size are stored in the heap memory. Heap values are referenced by a variable
    on the stack, which contains the memory address of the object on the heap:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存分配在 Rust 中非常重要，我们必须对正在发生的事情有一个清晰的了解。程序内存被分为栈和堆内存部分；要了解更多关于这些概念的信息，请阅读经典网页上的信息
    [https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap)。原始值，如数字（如图中的
    32）、字符和真/假值存储在栈上，而更复杂且可能增长大小的对象的值存储在堆内存中。堆值通过栈上的变量引用，该变量包含堆上对象的内存地址：
- en: '![The stack and the heap](img/image00175.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![栈和堆](img/image00175.jpeg)'
- en: While the stack has a limited size, the size of the heap can grow as and when
    more space is needed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然栈的大小有限，但堆的大小可以根据需要增长。
- en: 'Now, we will run the following program and try to visualize the program''s
    memory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行以下程序并尝试可视化程序的内存：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Values are stored in memory and so they have memory addresses. The `health`
    variable contains an integer value `32` that is stored in the stack at location
    `0x23fba4`, while the variable game contains a string, which is stored in the
    heap starting at location `0x23fb90`. (These were the addresses when I executed
    the program, but they will be different when you run the program.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 值存储在内存中，因此它们有内存地址。`health` 变量包含一个整数值 `32`，它存储在栈上的位置 `0x23fba4`，而 `game` 变量包含一个字符串，它存储在从位置
    `0x23fb90` 开始的堆中。（这些是在我执行程序时的地址，但当你运行程序时它们将是不同的。）
- en: The variables to which the values are bound are pointers or references to the
    values. They point to them; `game` is a reference to Space Invaders. The address
    of a value is given by the `&` operator. So, `&health` is the address where value
    `32` is stored, and `&game` is the address where the Space Invaders' value is
    stored.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定值的变量是指针或值的引用。它们指向它们；`game` 是 Space Invaders 的引用。值的地址由 `&` 操作符给出。因此，`&health`
    是存储值 `32` 的地址，而 `&game` 是存储 Space Invaders 值的地址。
- en: 'We can print these addresses by using the format string `{:p}` for pointers
    like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用格式字符串 `{:p}` 来打印这些地址，如下所示：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we have the following situation in memory (memory addresses will be different
    at each execution):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，内存中的情况如下（每次执行时的内存地址将不同）：
- en: '![The stack and the heap](img/image00176.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![栈和堆](img/image00176.jpeg)'
- en: 'We can make an alias, which is another reference that points to the same place
    in memory, like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个别名，它是另一个指向内存相同位置的引用，如下所示：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To get the value that is being referred to rather than the `game2` reference
    itself, dereference it with the asterisk `*` operator like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所引用的值而不是 `game2` 引用本身，可以使用星号 `*` 操作符进行解引用，如下所示：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `(println! is clever, so println!("{}", game2);` line will also print the
    same value as `println!("game: {}", &game);`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`(println! is clever, so println!("{}", game2);` 这一行也会打印与 `println!("game:
    {}", &game);` 相同的值。'
- en: The preceding code is a bit simplified because Rust will allocate values to
    the stack that will not change in size as much as it is possible, but this is
    meant to give you a better idea of what a reference to a value means.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码略有简化，因为Rust会分配值到栈上，其大小变化不会像可能的那样大，但这是为了更好地让你了解值引用的含义。
- en: 'We know already that a `let` binding is immutable, so the value cannot be changed:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道`let`绑定是不可变的，因此值不能被改变：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If `y` is declared with `let y = &health;`, then `*y` is the value `32`. Reference
    variables can also be given a type like `let x: &i64;` and such references can
    be passed around in code. After this `let` binding, `x` does not really point
    yet to a value and it does not contain a memory address. In Rust, there is no
    way to create a null pointer as you can in other languages; if you try to assign
    a nil, null, or even a unit value `()` to x, this will result in an error. This
    feature alone saves Rust programmers from countless bugs. Furthermore, trying
    to use `x` in an expression; for example, `println!("{:?}", x);` will result in
    the ``error: use of possibly uninitialized variable: `x`error`` error.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`y`被声明为`let y = &health;`，那么`*y`的值是`32`。引用变量也可以被赋予类型，如`let x: &i64;`，这样的引用可以在代码中传递。在此`let`绑定之后，`x`实际上还没有指向一个值，它不包含内存地址。在Rust中，没有创建空指针的方法，就像在其他语言中那样；如果你尝试将nil、null或单位值`()`分配给`x`，这将导致错误。仅此一项特性就使Rust程序员免于无数错误。此外，尝试在表达式中使用`x`，例如`println!("{:?}",
    x);`将导致“错误：使用可能未初始化的变量：`x`”错误。'
- en: 'A mutable reference to an immutable variable is forbidden; otherwise, the immutable
    variable could be changed through its mutable reference:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变变量的可变引用是被禁止的；否则，不可变变量可以通过其可变引用被改变：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This gives the ``error: cannot borrow immutable local variable `tricks` as
    mutable`` error.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这会抛出“错误：不能将不可变局部变量`tricks`作为可变引用借用”的错误。
- en: 'A reference to a mutable score variable can either be immutable or mutable
    respectively, such as `score2` and `score3` in the following example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可变分数变量的引用可以是不可变的或可变的，例如以下示例中的`score2`和`score3`：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The value of `score` can be only changed through a mutable reference such as
    `score3`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`score`的值只能通过可变引用，如`score3`来改变。'
- en: 'For reasons that we will see later, you can only make one mutable reference
    to a mutable variable:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在后面看到的原因，你只能对一个可变变量创建一个可变引用：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This throws the ``error: cannot borrow `score` as mutable more than once at
    a time`` error.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这会抛出“错误：一次不能多次借用`score`作为可变引用”的错误。
- en: Here, we touch the heart of Rust's memory safety system, where borrowing a variable
    is one of its key concepts. We will explore this in more detail in [Chapter 6](part0056.xhtml#aid-1LCVG2
    "Chapter 6. Pointers and Memory Safety"), *Pointers and Memory Safety*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们触及了Rust内存安全系统的核心，其中借用变量是其关键概念之一。我们将在[第6章](part0056.xhtml#aid-1LCVG2 "第6章。指针和内存安全")，*指针和内存安全*中更详细地探讨这一点。
- en: 'The heap is a much larger memory part than the stack, so it is important that
    memory locations are freed as soon as they are no longer needed. The Rust compiler
    sees when a variable ends its lifetime (or in other words, goes out of scope)
    and inserts a code at compile time to free its memory when the code is executed.
    This behavior is unique to Rust and is not present in other commonly used languages.
    Stack values can be boxed, that is, allocated in the heap by creating a `Box`
    around them, as is the case for the value of `x` in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 堆比栈大得多，因此，一旦不再需要内存位置，就很重要。Rust编译器会在变量结束其生命周期（换句话说，超出作用域）时看到，并在编译时插入代码，在代码执行时释放其内存。这种行为是Rust独有的，在其他常用语言中不存在。栈值可以被装箱，即通过围绕它们创建`Box`来在堆上分配，就像以下代码中的`x`值一样：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`Box` is an object that references a value on the heap. We''ll also look at
    this more closely in the *Boxes* section of [Chapter 6](part0056.xhtml#aid-1LCVG2
    "Chapter 6. Pointers and Memory Safety"), *Pointers and Memory Safety*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box`是一个引用堆上值的对象。我们还会在[第6章](part0056.xhtml#aid-1LCVG2 "第6章。指针和内存安全")的*盒子*部分更详细地探讨这一点，*指针和内存安全*。'
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to work with variables in Rust and got acquainted
    with many of the common compiler error messages. We explored types and the default
    immutability of variables that are the cornerstones of Rust's safety behavior.
    In the following chapter, we will start writing some useful code by using program
    logic and functions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Rust 中使用变量，并熟悉了许多常见的编译器错误信息。我们探讨了类型和变量的默认不可变性，这是 Rust 安全行为的基础。在下一章中，我们将通过使用程序逻辑和函数来编写一些有用的代码。
