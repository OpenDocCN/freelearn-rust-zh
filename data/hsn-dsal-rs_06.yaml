- en: Exploring Maps and Sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索映射和集合
- en: 'Up until this chapter, data structures have only become faster for searching,
    and this chapter is no different. What makes it different is why and how data
    can be found in two higher-level data structures: maps and sets. While the former
    is also known as dictionary, associative array, object, or hash table, the latter
    commonly crosses people''s minds as a mathematical concept. Both can rely on hashing,
    a technique that allows for constant (or close to constant) time retrieval of
    items, checking whether they are contained in a set, or routing requests in distributed
    hash tables.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，数据结构在搜索方面只变得更快速，本章也不例外。使其不同之处在于为什么以及如何在两种高级数据结构中找到数据：映射和集合。前者也被称为字典、关联数组、对象或哈希表，而后者通常被看作是一个数学概念。两者都可以依赖于哈希技术，这是一种允许以常数（或接近常数）时间检索项目、检查它们是否包含在集合中或在分布式哈希表中路由请求的技术。
- en: 'These data structures are also one level higher than the previous ones, since
    all of them build on existing structures, such as dynamic arrays or trees, and
    to top things off, the chapter starts with an algorithm. Understanding this chapter
    will be great preparation heading into the second part of the book, where algorithms
    are the main focus. Topics learned in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据结构也比之前的数据结构高一个层次，因为它们都是建立在现有结构之上的，例如动态数组或树，而且更不用说本章从算法开始。理解本章将为进入书的第二部分做好很好的准备，在那里算法是主要焦点。本章学习的内容包括以下：
- en: Hashing functions and what they are good for
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数及其用途
- en: How to implement a set based on different data structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何基于不同的数据结构实现集合
- en: What makes maps special
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使映射特殊的原因
- en: Hashing
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希
- en: The birthday paradox is a well-known phenomenon; two people share this special
    day that year, seemingly often, and we still get excited when it happens. Statistically
    speaking, the probability of meeting someone like this is really high, since in
    a room of just 23 people, the probability is already at 50%. While this may be
    an interesting fact, why is this introducing a section about hashing?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 生日悖论是一个众所周知的现象；两个人在这一年共享这个特殊的日子，似乎很常见，而且当它发生时我们仍然会感到兴奋。从统计学的角度来看，遇到这样的人的概率实际上非常高，因为在只有23人的房间里，概率就已经达到了50%。虽然这可能是一个有趣的事实，但为什么要在介绍哈希函数的章节中提到这一点呢？
- en: 'Birthdays can be considered a hash function—although a bad one. Hash functions
    are functions that map one value onto another value of a fixed size, like combining
    the day and month of a birthday into `u64`, shown as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 生日可以被视为一个哈希函数——尽管不是一个好的哈希函数。哈希函数是映射一个值到另一个固定大小的值的函数，例如将生日日期和月份组合成`u64`，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This function will prove very ineffective indeed, shown as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数实际上将证明非常无效，如下所示：
- en: It is very hard to find out someone's birthday deterministically without asking
    them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不询问某人，很难确定性地知道他们的生日
- en: The space is limited to 366 unique values, which also makes collisions very
    likely
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间限制在366个唯一值内，这也使得冲突非常可能
- en: They are not evenly distributed across the year
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不是均匀分布在整个年份中
- en: 'What makes a good hash function? It depends on the use case. There are many
    properties that can be associated with a hash function, such as the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 什么使一个好的哈希函数？这取决于用例。可以与哈希函数相关联的属性有很多，如下所示：
- en: One way or two way (that is, given a hash, can one get the original value back?)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向或双向（即，给定一个哈希值，能否得到原始值？）
- en: Deterministic
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性
- en: Uniform
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均匀
- en: Fixed or variable range
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定或可变范围
- en: Designing good hash functions is a *very* hard task in any field; there are
    countless algorithms that have been shown to be too weak for their designed purpose
    after several years of use, with SHA-1 being the latest prominent victim.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何领域设计好的哈希函数都是一个**非常**困难的任务；在经过几年的使用后，无数算法被证明对于它们设计的目的是过于薄弱的，SHA-1就是最新的显眼受害者。
- en: There is a wide variety of hashing algorithms for all kinds of use cases available,
    ranging from cryptographically secure to something akin to a parity bit to mitigate
    tampering. This section will focus on a few areas that we deemed interesting;
    for a wider picture, Wikipedia ([https://en.wikipedia.org/wiki/List_of_hash_functions](https://en.wikipedia.org/wiki/List_of_hash_functions))
    provides a list that shows a number of available hashing algorithms and their
    articles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种用例，都有各种各样的哈希算法可用，从加密安全的到类似于奇偶校验位以减轻篡改的算法。本节将重点介绍我们认为有趣的几个领域；对于更全面的了解，维基百科([https://en.wikipedia.org/wiki/List_of_hash_functions](https://en.wikipedia.org/wiki/List_of_hash_functions))提供了一个显示可用哈希算法及其文章的列表。
- en: '**Signatures** are one of the most important fields for hashing algorithms
    and they can be as simple as the last digit on a credit card number (to validate
    the number) to 512-bit strong cryptographic digest functions, where a single collision
    is the end of that particular algorithm.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**是哈希算法中最重要的领域之一，它们可以像信用卡号码的最后一位数字（用于验证号码）一样简单，也可以是512位的强大加密摘要函数，其中单个冲突就是该特定算法的终结。'
- en: Outside of cryptography, hashing is used in completely different areas as well,
    such as peer-to-peer routing or encoding information in a tree-like structure.
    **GeoHashes** are a great example; instead of comparing longitude and latitude,
    these GeoHashes allow to quickly check if an area is located close to (or within)
    another area by comparing the first few characters of the hash. The algorithm
    was put into the public domain and can be found under [http://geohash.org/](http://geohash.org/).
    Collisions in this space can be ruled out since the entire space of possible input
    variations (coordinates on planet Earth) is known beforehand.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学之外，哈希还应用于完全不同的领域，例如对等路由或以树状结构编码信息。**地理哈希**是一个很好的例子；这些地理哈希不是通过比较经纬度，而是通过比较哈希值的前几个字符来快速检查一个区域是否靠近（或位于）另一个区域。该算法已被纳入公共领域，可以在[http://geohash.org/](http://geohash.org/)找到。由于在事先已知整个可能的输入空间（地球上的坐标）的情况下，可以排除该空间中的冲突。
- en: What are **collisions**? A collision occurs when two different input parameters
    lead to the same output, making the hash ambiguous. In cryptography, this fact
    will lead to a large scale crisis, just like it would if you found another key
    that matches your door lock. The main difference being that in the physical world,
    trying every door in your neighborhood is highly impractical, but with fully connected
    computers, this can be done in a matter of seconds. This means that the potential
    inputs are just as important as the quality of the hashing function itself—be
    it time and practicality (like physical items), or the applicable range (Earth
    coordinates, maximum number of nodes in a cluster)—transferring a function to
    a domain with a larger range leads to unexpected outcomes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**冲突**？当两个不同的输入参数导致相同的输出时，就会发生冲突，使得哈希变得模糊。在密码学中，这一事实将导致大规模危机，就像你找到了另一个匹配你门锁的钥匙一样。主要区别在于，在物理世界中，尝试你邻居家的每一扇门是非常不切实际的，但使用完全连接的计算机，这可以在几秒钟内完成。这意味着潜在的输入与哈希函数本身的质量一样重要——无论是时间与实践（如物理物品），还是适用范围（地球坐标，集群中的最大节点数）——将一个函数转移到更大范围的领域会导致意想不到的结果。
- en: To summarize, collisions appear when the potential space of a key is either
    not large enough to withstand a full enumeration (brute force), or the outputs
    of the hash function are unevenly distributed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当键的潜在空间不足以承受全面枚举（暴力破解）时，或者当哈希函数的输出分布不均匀时，就会发生冲突。
- en: Create your own
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的
- en: For the purpose of representing an object as a number (for use in a hash map
    or for comparison), most languages' built-in types come with a solid hash function
    for exactly that purpose, so building your own is almost never a good idea, unless
    a lot of time and effort goes into it. The better choice is to use what's built-in,
    or use a library that provides tested and proven methods.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将对象表示为数字（用于哈希表或比较），大多数语言的内置类型都带有用于此目的的可靠哈希函数，因此几乎从不建议自己构建，除非投入大量时间和精力。更好的选择是使用内置的，或者使用提供经过测试和验证方法的库。
- en: 'It is important though to know how those functions are built, so let''s create
    a trivial implementation to analyze the basic principles. The following example
    is one that uses the XOR operation on the previous and current byte to save their
    binary differences, then shifts it to the left up to four times (to fill up the
    `u32` type):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解这些函数是如何构建的很重要，所以让我们创建一个简单的实现来分析基本原理。以下是一个使用前一个和当前字节进行异或操作以保存它们的二进制差异的例子，然后将它左移四次（以填充`u32`类型）：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When this function is applied to a range of repeated letter strings, how are
    the values distributed? A histogram and a scatter plot tell the story, shown as
    follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个函数应用于一系列重复字母字符串时，这些值是如何分布的？直方图和散点图讲述了这个故事，如下所示：
- en: '![](img/9a669b5e-197c-458e-a30f-6af514eaca50.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a669b5e-197c-458e-a30f-6af514eaca50.png)'
- en: The output chart of the XOR Hasher
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: XOR哈希器的输出图表
- en: This histogram shows the distribution of the hash output, when the function
    is applied to all combinations of ten `AA`-`ZZ`, but each letter repeated ten
    times, so the first string is `AAAAAAAAAAAAAAAAAAAA` (20 letters), the last string
    is `ZZZZZZZZZZZZZZZZZZZZ`, yielding 675 combinations of 20 letter "words." This
    leads to a less optimal distribution, where the highest frequency is five times
    as high as the lowest. While speed can be a factor in using that function, it
    will clearly produce suboptimal results for cryptography.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个直方图显示了当函数应用于所有`AA`-`ZZ`的组合时哈希输出的分布，但每个字母重复十次，所以第一个字符串是`AAAAAAAAAAAAAAAAAAAA`（20个字母），最后一个字符串是`ZZZZZZZZZZZZZZZZZZZZ`，产生了675种20个字母“单词”的组合。这导致了一个不太理想的分布，其中最高频率是最低频率的五倍。虽然速度可能是使用该函数的一个因素，但它显然会对密码学产生次优结果。
- en: 'In a scatter plot, this looks like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在散点图中，它看起来如下：
- en: '![](img/2d6b5bb2-22e5-4a17-bfbd-70218b754f4c.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d6b5bb2-22e5-4a17-bfbd-70218b754f4c.png)'
- en: The output graph of the scatter plot
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图的输出图表
- en: The scatter plot shows a different story. On the *x* axis, the index of each
    combination is shown, the *y* axis shows the hash output. Therefore, horizontal
    lines mean collisions, and they are all over the place! It can be interesting
    to explore further properties of a function like this, but the first results look
    quite dire, and searching for a better algorithm is the best use of anyone's time.
    Let's move on to checksums and digests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图显示了一个不同的故事。在*x*轴上，显示每个组合的索引，在*y*轴上显示哈希输出。因此，水平线表示冲突，它们无处不在！探索这种函数的进一步特性可能很有趣，但最初的结果看起来相当糟糕，寻找更好的算法是任何人最好的时间利用方式。让我们继续讨论校验和与摘要。
- en: Message digestion
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息摘要
- en: Message digests are created as a way to guarantee authenticity; if a message
    was sent, a digest or signature of this message provides an ability to check whether
    the message has been tampered with. Typically, the signature will therefore be
    transmitted differently than the original message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 消息摘要的创建是为了保证真实性；如果一条消息被发送，这条消息的摘要或签名提供了一种检查消息是否被篡改的能力。因此，签名通常会以不同于原始消息的方式传输。
- en: 'Obviously, this requires the hashing function to adhere to some basic rules
    to be considered good, listed as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个哈希函数必须遵循一些基本规则才能被认为是好的，如下列所示：
- en: A signature has to be quick and easy to obtain regardless of message size
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论消息大小如何，签名都必须快速且易于获取
- en: The signature can only have a fixed length
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名只能有固定长度
- en: The function has to minimize collisions
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须最小化冲突
- en: 'The hash functions contained in this group are the most popular ones and are
    the objective of many security researchers: MD5, SHA-1/2/3, or Adler 32\. Adler
    32 is prominently used in the `zlib` library to ensure the file''s integrity,
    but should not be used to authenticate messages, thanks to the limited output
    space of 32-bit. However, it is easy to implement and understand, which makes
    it great for the purposes of this book:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组包含的哈希函数是最受欢迎的，也是许多安全研究人员的目标：MD5、SHA-1/2/3或Adler 32。Adler 32在`zlib`库中被广泛使用以确保文件完整性，但不应用于验证消息，因为32位输出空间有限。然而，它易于实现和理解，这使得它非常适合本书的目的：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The algorithm sums up the bytes of any byte stream, and avoids an overflow by
    applying the modulo operation, using a large prime number (`65521`), which makes
    it harder for a byte to change without changing the final result. The algorithm
    has considerable weaknesses since there are many ways to change the operands of
    a sum without affecting the outcome!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法对任何字节流的字节进行求和，并通过应用模运算来避免溢出，使用一个大质数（`65521`），这使得字节在不改变最终结果的情况下更难改变。由于有许多方法可以改变求和的运算数而不影响结果，该算法有相当大的弱点！
- en: Additionally, rolling over (after the modulo is applied) gives some weight to
    the order of bytes, so if the sum of bytes is not large enough, the algorithm
    is expected to produce even more collisions. Generally, this algorithm primarily
    protects against random transmission errors that cause bits to change, and is
    not useful in authenticating messages.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在模运算应用后进行回绕（滚动）会给字节顺序赋予一些权重，所以如果字节的和不够大，算法预计会产生更多的碰撞。通常，此算法主要保护随机传输错误导致的位变化，在验证消息方面并不实用。
- en: Wrap up
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Hashing is a very useful tool that developers use every day—knowingly or unknowingly.
    Integer comparisons are fast, so checking the equality of two strings can be improved
    by comparing their hashes. Diverse keys can be made comparable by hashing—a method
    that is used in distributed databases to assign a partition to a row.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一种非常实用的工具，开发者每天都在使用——无论是自觉还是不自觉。整数比较速度快，因此可以通过比较它们的哈希值来提高检查两个字符串相等性的效率。通过哈希，可以使得不同的键变得可比较——这是分布式数据库用来为行分配分区的方法。
- en: '**Modulo hashing** is a technique that lets a distributed database assign a
    row to a partition deterministically. Hash the row''s key, then use the modulo
    operator with the maximum number of partitions to receive a destination to store
    the row.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**模运算哈希**是一种技术，允许分布式数据库确定性地将一行数据分配到分区。首先对行的键进行哈希处理，然后使用最大分区数与模运算符相结合，以获得存储该行的目标位置。'
- en: Earlier, we explored some hash functions (XOR-based and Adler 32), but we never
    compared them. Additionally, Rust's standard library offers a hash function (built
    for `HashSet<K,V>`/`HashMap<K,V>`, and implemented for all standard types), which
    is a good baseline.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们探索了一些哈希函数（基于XOR和Adler 32），但我们从未比较过它们。此外，Rust的标准库提供了一个哈希函数（为`HashSet<K,V>`/`HashMap<K,V>`构建，并为所有标准类型实现），这是一个很好的基准。
- en: 'First, histograms—to show how many occurrences each hash has. As mentioned
    before, the XOR-based approach yields a very strange distribution, where some
    hashes clearly appear more often than others, shown as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，直方图——显示每个哈希出现的次数。如前所述，基于XOR的方法产生一个非常奇怪的分布，其中一些哈希明显比其他哈希出现得更频繁，如下所示：
- en: '![](img/7cc10d71-afea-442e-abe4-05f40b742a5e.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cc10d71-afea-442e-abe4-05f40b742a5e.png)'
- en: The output chart of the XOR Hasher
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: XOR Hasher的输出图表
- en: 'The Adler checksum creates a normal distribution in this case, which is probably
    due to the repetitive content, and the commutative nature of summing up numbers
    (*2 + 1 = 1 + 2*). Considering that transmission errors in compressed files are
    probably creating repetition, it looks like a solid choice for that use case.
    It would not do well in most other scenarios though:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Adler校验和创建了一个正态分布，这可能是由于重复的内容，以及求和的交换性质（*2 + 1 = 1 + 2*）。考虑到压缩文件中的传输错误可能产生重复，它似乎是一个针对该用例的合理选择。但在大多数其他场景中，它可能表现不佳：
- en: '![](img/ffeb7cb5-8ac8-4035-ba7f-0fab812a6107.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffeb7cb5-8ac8-4035-ba7f-0fab812a6107.png)'
- en: The output chart of Adler 32
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Adler 32的输出图表
- en: 'The following is Rust''s default choice, the `SipHash` based `DefaultHasher`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容是Rust的默认选择，基于`SipHash`的`DefaultHasher`：
- en: '![](img/6c686356-d22a-4834-ade0-4582e766951f.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c686356-d22a-4834-ade0-4582e766951f.png)'
- en: The output chart of the Rust DefaultHasher
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Rust DefaultHasher的输出图表
- en: Seeing the three distributions, their use in a hash table, where the frequency
    directly translates to the length of the lists at each bucket, becomes obvious.
    While it's best to have a length of one, lists of the same length at least yield
    the best performance if there is *any* collision. The Rust standard library clearly
    made a great choice with the `SipHash` based ([https://link.springer.com/chapter/10.1007/978-3-642-34931-7_28](https://link.springer.com/chapter/10.1007/978-3-642-34931-7_28))
    implementation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察三个分布，它们在哈希表中的应用变得明显，其中频率直接转换为每个桶中列表的长度。虽然长度为一是最佳选择，但如果发生任何碰撞，相同长度的列表至少能提供最佳性能。Rust标准库显然做出了一个很好的选择，即基于`SipHash`的实现（[https://link.springer.com/chapter/10.1007/978-3-642-34931-7_28](https://link.springer.com/chapter/10.1007/978-3-642-34931-7_28)）。
- en: 'A comparative scatter plot also sheds some light on the behavior of hash functions.
    Be aware that it is log-scaled to fit the results into a manageable plot, shown
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 比较散点图也揭示了散列函数的行为。请注意，它已按对数刻度缩放，以便将结果放入可管理的图中，如下所示：
- en: '![](img/26552fa7-52f4-4792-99dd-273042acc591.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26552fa7-52f4-4792-99dd-273042acc591.png)'
- en: The comparison plot for XOR, Adler 32, and DefaultHasher
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: XOR、Adler 32 和 DefaultHasher 的比较图
- en: While the scale does not allow for a detailed judgment, what appears to be a
    line is always a collision-heavy behavior. As expected from the histograms, the
    Adler 32 and XOR-based approach both do not show a cloud. Since the *y* axis shows
    the actual hash (log-scaled), the more vertically spread it is, the better the
    distribution. Ideally, there would be a unique hash for each *x* value, but roughly
    the same number of dots for each *y* value predict a uniform hash function. Again,
    Rust's `DefaultHasher` looks very good in this plot, while both contenders show
    less optimal behaviors when used in similar cases.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比例尺不允许进行详细的判断，但看起来像一条线的总是碰撞密集的行为。正如从直方图所预期的那样，Adler 32 和基于 XOR 的方法都没有显示出云状。由于
    *y* 轴显示实际的散列值（对数刻度），它越垂直分布，分布就越好。理想情况下，每个 *x* 值都有一个唯一的散列值，但每个 *y* 值大致相同的点数预示着均匀的散列函数。再次强调，Rust
    的 `DefaultHasher` 在这个图中看起来非常好，而两个竞争者当在类似情况下使用时都显示出不太理想的行为。
- en: 'A word of caution in the end. This is a software developer''s perspective on
    hashing: security researchers and professionals know *a lot* more about hashing.
    It should be left to them to come up with new ways to create message signatures,
    so we can focus on building great software and use the best possible components
    to do that. In short: *do not build your own hash function for any production
    system.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后提醒一句。这是软件开发者对散列的看法：安全研究人员和专业人士对散列的了解要多得多。他们应该负责提出创建消息签名的新方法，这样我们就可以专注于构建优秀的软件，并使用最好的可能组件来完成这项工作。简而言之：*不要为任何生产系统构建自己的散列函数。*
- en: 'Now, for some practical application of hashing in a data structure: the map.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在数据结构中散列的实际应用：映射。
- en: Maps
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'Index operations in arrays are fast, simple, and easy to understand, with one
    drawback: they only work with integers. Since an **array** is a continuous portion
    in memory that can be accessed by dividing it evenly, which makes the jumps between
    the elements easy, can this work with arbitrary keys as well? Yes! Enter maps.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的索引操作快速、简单且易于理解，但有一个缺点：它们只适用于整数。由于 **数组** 是内存中连续的部分，可以通过均匀分割来访问，这使得元素之间的跳跃变得容易，那么这也可以用于任意键吗？是的！这就是映射的用武之地。
- en: '**Maps** (also called dictionaries or associative arrays), are data structures
    that store and manage unique key-value pairs in an efficient way. These structures
    aim to quickly provide access to the values associated with the keys that are
    typically stored in one of the following two ways:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**（也称为字典或关联数组），是一种以高效方式存储和管理唯一键值对的数据结构。这些结构旨在快速提供对与键相关联的值的访问，这些键通常以下两种方式之一存储：'
- en: A hashtable
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个散列表
- en: A tree
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一棵树
- en: 'When key-value pairs are stored in a tree, the result is very similar to what
    was discussed in the previous chapter: self-balancing trees will provide consistent
    performance, avoiding the worst-case cost of a hash map.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当键值对存储在树中时，结果与上一章讨论的非常相似：自平衡树将提供一致的性能，避免散列表的最坏情况成本。
- en: Since trees have been discussed extensively in the previous chapter, the hash
    map is the main focus in this section. It uses a hashing function to translate
    the provided key into a number of some sort, which is in turn "mapped" on array
    buckets. This is where the entire pair is typically stored as a list (or tree)
    to deal with collisions effectively. Whenever a key is looked up, the map can
    search the associated bucket for the exact key. A key-value pair is inserted by
    hashing the key, using the modulo operation to find a spot in the array, and appending
    the pair to the list at the bucket.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在前一章中已经广泛讨论了树，因此本节主要关注散列表。它使用散列函数将提供的键转换为某种数字，然后将其“映射”到数组桶中。这就是整个键值对通常作为列表（或树）存储以有效地处理冲突的地方。每当查找键时，映射可以搜索相关的桶以找到确切的键。通过散列键插入键值对，使用模运算在数组中找到一个位置，并将对追加到桶中的列表。
- en: 'If two or more elements are in that list, one or more collisions have occurred:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中有两个或更多元素，则发生了一个或多个冲突：
- en: '![](img/aff5dc8b-2f6c-4d11-943a-94de51c78130.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aff5dc8b-2f6c-4d11-943a-94de51c78130.png)'
- en: 'While this usually results in great access times, whenever similar hashes have
    to be stored (due to a bad hash function), the worst case scenario will be a search
    through an unordered list—with linear performance. This results in a boxed slice
    that holds all the data in the form of an `Entry` type, a vector of tuples. In
    this case, the implementation is even using generics:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这通常会导致很好的访问时间，但每当需要存储相似哈希值（由于哈希函数不好）时，最坏的情况将是搜索一个无序列表——具有线性性能。这导致了一个包含所有数据的`Entry`类型的boxed切片，它是一个元组的向量。在这种情况下，实现甚至使用了泛型：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Additionally, the hash function can be freely chosen and is stored as a boxed
    function, which makes it handy to store within the object, and call whenever required.
    This also lets users customize the type of hashing for a particular use case.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，哈希函数可以自由选择，并存储为boxed函数，这使得在对象内部存储并随时调用变得方便。这也允许用户为特定用例自定义哈希类型。
- en: By associating an index with a certain hash, a map lacks the ability to traverse
    its content in any kind of order. Therefore, keys and values cannot be iterated
    over in any kind of order, requiring sorting before any operation happens.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将索引与某个哈希值关联，映射缺乏以任何顺序遍历其内容的能力。因此，键和值不能以任何顺序迭代，需要在任何操作发生之前进行排序。
- en: 'Once again, the product team is innovating and another feature would really
    add a lot of value to customers: associating postcodes with their factual data
    about the location. This way, a web service can cache commonly used data and reduce
    the load on the database, while serving customers a lot quicker! Since these locations
    are updated manually, an expiration is not required and the map can be filled
    on startup.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，产品团队正在创新，另一个功能真的可以为客户带来很多价值：将邮编与其关于位置的实际情况关联起来。这样，网络服务可以缓存常用数据，减少数据库的负载，同时更快地为客户提供服务！由于这些位置是手动更新的，因此不需要过期，地图可以在启动时填充。
- en: 'Customers provided a list of concise requirements as well to assist, shown
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 客户还提供了一份简明的要求列表以供协助，如下所示：
- en: Insert location information under their unique name
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其唯一名称下插入位置信息
- en: Quickly retrieve information using their name
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用名称快速检索信息
- en: Fetch all location names and associated information
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有位置名称及其相关信息
- en: Update locations using their name
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用名称更新位置
- en: A hash table would do a great job here, would it not?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个哈希表在这里会做得很好，不是吗？
- en: A location cache
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置缓存
- en: Caching values is a typical use case for maps because even a large number of
    items won't affect the performance much, since the keys are always distinct. These
    keys can even carry information themselves!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存值是映射的典型用例，因为即使有大量项目，也不会对性能产生太大影响，因为键总是唯一的。这些键甚至可以携带自己的信息！
- en: For the use case defined in the last section, each customer uses postcodes within
    a country to identify locations; they typically cover an area that only holds
    a single office. Postal codes are stored as strings to cover the real world's
    wide variety of systems, and they are unique per country.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上一节中定义的用例，每个客户使用一个国家的邮编来识别位置；它们通常覆盖的区域只包含一个办公室。邮政编码以字符串形式存储，以涵盖现实世界中广泛的系统，并且每个国家都是唯一的。
- en: 'Thanks to a previous generic implementation, the entire `LocationCache` type
    can be an alias to a specialized `HashMap`, only requiring the hash function to
    be supplied on creation, shown as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了之前的通用实现，整个`LocationCache`类型可以是一个专门的`HashMap`的别名，只需要在创建时提供哈希函数，如下所示：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `HashMap` itself is a custom implementation that contains a key of type
    `K`, which has to also implement `PartialEq` (for comparing key instances directly),
    and `Clone` (for practical reasons).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap`本身是一个自定义实现，它包含一个类型为`K`的键，该键必须还实现`PartialEq`（用于直接比较键实例），以及`Clone`（出于实际原因）。'
- en: The hash function
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希函数
- en: In addition to providing a generic data structure, the implementation lets the
    user supply a custom hash function that only maps a reference to the key type
    to a `usize` return type. The choice for the return type is arbitrary, and was
    chosen to avoid overflows.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供通用的数据结构外，该实现允许用户提供一个自定义的哈希函数，该函数仅将键类型的引用映射到`usize`返回类型。返回类型的选择是任意的，并且是为了避免溢出而选择的。
- en: 'Since the previously implemented hash function performed better than the Adler
    32 checksum algorithm, the location cache will use this. To recall, the algorithm
    applies XOR between a byte and its predecessor and then bit shifts to the left,
    based on the byte''s index. Alternatively, Rust''s `DefaultHasher` is available
    as well:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前实现的哈希函数比Adler 32校验和算法表现更好，位置缓存将使用这个。回想一下，该算法在字节与其前驱之间应用XOR操作，然后根据字节索引进行左移位。或者，Rust的`DefaultHasher`也是可用的：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Choosing a hashing algorithm is an important decision, as we will see in the
    *Wrap up* section. But first, locations need to be added!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个哈希算法是一个重要的决定，正如我们将在*总结*部分看到的那样。但首先，需要添加位置！
- en: Adding locations
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加位置
- en: 'In order to add a location, there are two important steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加位置，有两个重要的步骤：
- en: Compute the hash
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算哈希
- en: Choose a bucket
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个桶
- en: Further operations, such as doing a sorted insert, will improve performance
    too, but they can be omitted by using a tree instead of a list within each bucket.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的操作，例如进行排序插入，也会提高性能，但可以通过在每个桶中使用树而不是列表来省略这些操作。
- en: The location cache implementation uses a simple modulo operation between the
    hash and the length of the array to choose a bucket, which means that on top of
    regular hash collisions, choosing the size of the internal storage has a major
    influence on the performance as well. Choose a size too small and the buckets
    will overlap, regardless of the hash function!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 位置缓存实现使用哈希与数组长度之间的简单模运算来选择桶，这意味着除了常规的哈希冲突之外，选择内部存储的大小也会对性能产生重大影响。选择太小的大小，桶将重叠，不管哈希函数如何！
- en: 'In Rust code, the first part is done in the first line using the provided boxed
    `hashcode` function to create a hash. What follows is finding a bucket by applying
    something akin to the modulo operation (a binary AND operation between the hash
    and the highest index of the storage array) and a linear search of the attached
    list. If the key is found, the attached pair is updated and if not, it is added
    to the vector:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust代码中，第一部分是在第一行使用提供的boxed `hashcode`函数创建哈希。接下来是找到桶，通过应用类似于模运算的操作（哈希与存储数组最高索引之间的二进制AND操作）以及附加列表的线性搜索。如果找到键，则更新附加对；如果没有找到，则将其添加到向量中：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once a location and the matching hash is stored, it can be retrieved again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存储了位置和匹配的哈希值，就可以再次检索。
- en: Fetching locations
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取位置
- en: 'Just like inserting, the retrieval process has the same steps. Whether the
    `get()` function to return a value or the `remove()` function, both go through
    the same steps: hash, match a bucket, do a linear search, and lastly, match with
    the expected return type. The `get()` function can utilize Rust''s powerful iterators
    by using `find` to match the predicate within a bucket''s vector and, since an
    `Option<Item>` is returned, its `map` function to extract the value instead of
    returning the entire pair:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像插入一样，检索过程也有相同的步骤。无论是`get()`函数返回一个值还是`remove()`函数，两者都经过相同的步骤：哈希、匹配桶、进行线性搜索，最后与预期的返回类型匹配。`get()`函数可以利用Rust强大的迭代器通过使用`find`在桶的向量内匹配谓词，并且由于返回的是`Option<Item>`，可以使用其`map`函数提取值而不是返回整个对：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `remove` function is literally the inversion of an `insert` function; instead
    of updating the key-value pair if found, it is removed from the bucket and returned
    to the caller.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`函数实际上是`insert`函数的逆操作；如果找到，不是更新键值对，而是从桶中移除并返回给调用者。'
- en: Wrap up
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Hash maps are a great data structure, and often their value cannot be overstated,
    especially in caching or to simplify code that would otherwise have to match labels
    (or keys) to values using array indices. Their key breaking points are the hash
    function itself, and the bucket selection and organization, all of which warrant
    entire PhD theses and papers in computer science.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是一个非常好的数据结构，它们的值往往无法过高估计，尤其是在缓存或简化代码时，否则可能需要使用数组索引将标签（或键）与值匹配。它们的关键突破点是哈希函数本身，以及桶的选择和组织，所有这些都值得在计算机科学中撰写整个博士论文和论文。
- en: 'While a hash map is quick and easy to implement, the real question is: how
    does it perform? This is a valid question! Software engineers are prone to prefer
    their own implementation over learning what others already created, and while
    this is the premise for this entire book, benchmarks keep us honest and help us
    to appreciate the work that others have done.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然哈希表快速且易于实现，但真正的问题是：它的性能如何？这是一个有效的问题！软件工程师倾向于更喜欢自己的实现，而不是学习别人已经创建的内容，尽管这是本书的整个前提，但基准测试让我们保持诚实，并帮助我们欣赏别人所做的工作。
- en: 'How did this `HashMap` do, especially compared to `std::collections::HashMap<K,V>`?
    We have seen the hash function is far from ideal in some histograms, but what
    are the performance implications? Here is a scatter plot to answer all of these
    questions; it shows the `HashMap` implemented here with different hashing functions
    (Adler 32, `DefaultHasher`, XOR-based) compared to the `HashMap<K,V>` from the
    standard library (which uses `DefaultHasher` exclusively). The following benchmarks
    were performed on the same 1,000 to 10,000 randomly permuted strings between *A*
    and *Z* of lengths of 10 to 26 characters. The *y* axis shows the time required
    for a `get()` operation in nanoseconds, the *x* axis shows the number of items
    in the map. The sizes represent the deviation of the result:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`HashMap`的表现如何，特别是与`std::collections::HashMap<K,V>`相比？我们已经看到在某些直方图中，哈希函数远非理想，但性能影响是什么？这里有一个散点图来回答所有这些问题；它显示了这里实现的`HashMap`与使用`DefaultHasher`的`HashMap<K,V>`（标准库中的唯一选择）的不同哈希函数（Adler
    32、`DefaultHasher`、基于XOR的）进行了比较。以下基准测试是在相同长度为10到26个字符、在*A*到*Z*之间随机排列的1,000到10,000个字符串上进行的。*y*轴显示`get()`操作所需的时间（纳秒），*x*轴显示映射中的项目数量。大小表示结果的偏差：
- en: '![](img/5aab1392-5007-4192-a2ca-0a8de69dc326.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5aab1392-5007-4192-a2ca-0a8de69dc326.png)'
- en: The scatter plot of the deviation of the result in Adler 32, DefaultHasher,
    XOR-based, collections-HashMap
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Adler 32、DefaultHasher、基于XOR的、collections-HashMap的结果偏差散点图
- en: This plot shows the real value and use of the particular hash functions, as
    they were all applied to this `HashMap`, and the work of the amazing Rust community
    with `std::collections::HashMap<K,V>`, which uses the `DefaultHasher`. Adler 32,
    as a checksum algorithm, did rather badly, which was expected, with even an increasing
    variance as the number of inserted items increased. Surprisingly, the XOR-based
    algorithm was not as bad as expected, but still had a high variance compared to
    the `DefaultHasher`, which performed consistently well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图显示了特定哈希函数的实际价值和用途，因为它们都应用到了这个`HashMap`上，以及与使用`DefaultHasher`的`std::collections::HashMap<K,V>`的惊人的Rust社区的工作，Adler
    32作为一个校验和算法，表现相当糟糕，这是预期的，随着插入项数量的增加，甚至方差还在增加。令人惊讶的是，基于XOR的算法并没有像预期的那样糟糕，但与表现一致的`DefaultHasher`相比，仍然有较高的方差。
- en: All of them are a far cry off the `HashMap<K,V>` that comes with the standard
    library. This is great news, because the performance of this hash map implementation
    is also worse than the trees and skip lists presented in [Chapter 5](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml),
    *Robust Trees* and [Chapter 4](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml), *Lists,
    Lists, More Lists*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都与标准库中提供的`HashMap<K,V>`有很大差距。这是一个好消息，因为这种哈希表实现的性能也比第5章中介绍的树和跳表差，第5章是*健壮树*，第4章是*列表，列表，更多列表*。
- en: This is proof that while the theory sounds great (constant time retrieval, best
    case)—implementation details can make or break a particular data structure, which
    is why we suspect that `collections::HashMap` sorts and inserts and use of traits
    instead of a boxed (hash) function to significantly improve performance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了虽然理论听起来很棒（恒定时间检索，最佳情况）——实现细节可以决定一个特定数据结构的成败，这就是为什么我们怀疑`collections::HashMap`排序、插入以及使用特质而不是boxed（哈希）函数可以显著提高性能。
- en: Upsides
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'The hash map provides a great way to do key-value associations, which are highlighted
    as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表提供了一种很好的键值关联方式，如下所示：
- en: Low overhead storage
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低开销存储
- en: Hashed complex keys by default thanks to hashing
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认通过哈希对复杂键进行哈希处理
- en: Easy to understand
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于理解
- en: Constant time retrieval
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恒定时间检索
- en: Yet, there are a few things that may be troublesome when compared to trees,
    or other efficient retrieval structures.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与树或其他高效检索结构相比，可能还有一些令人烦恼的事情。
- en: Downsides
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'Even though constant time retrieval sounds nice, the benchmarks show that it''s
    not that simple. The downsides are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管常数时间检索听起来很吸引人，但基准测试显示这并不那么简单。缺点如下：
- en: Performance highly depends on the hash function and application
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能高度依赖于哈希函数和应用
- en: Easy to implement naively, hard to get right
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单，但难以正确实现
- en: Unordered storage
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序存储
- en: 'Some of these downsides could be mitigated by using a tree-based map, but that
    would be a tree as described in the previous chapter, and there is one data structure
    left to discuss here: the set.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用基于树的映射可以减轻一些这些缺点，但那将是前一章中描述的树，这里还有一个数据结构需要讨论：集合。
- en: Sets
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: '**Structured Query Language** (**SQL**), is a declarative language invented
    to perform database operations. Its primary qualities are the ability to express
    *what* you want, rather than *how* you want it ("I want a set of items that conform
    to a predicate X" versus "Filter every item using predicate X"); this also allows
    non-programmers to work with databases, which is an aspect that today''s NoSQL
    databases often lack.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化查询语言** (**SQL**) 是一种声明性语言，旨在执行数据库操作。它的主要特点是能够表达你想要什么，而不是如何实现（“我想得到一组符合谓词X的项”与“使用谓词X过滤每个项”）；这也使得非程序员能够与数据库交互，这是今天许多NoSQL数据库所缺乏的一个方面。'
- en: 'You may think: how is that relevant? SQL allows us to think of the data as
    sets linked together with relations, which is what makes it so pleasant to work
    with. Understanding sets as a distinct collection of objects is sufficient to
    understand the language and how to manipulate the results. While this definition
    is also called the naive set theory, it is a useful definition for most purposes.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：这有什么相关？SQL允许我们将数据视为通过关系链接在一起的集合，这使得它非常易于使用。将集合视为一个独特的对象集合就足以理解语言以及如何操作结果。虽然这个定义也被称为朴素集合论，但它对大多数目的来说是一个有用的定义。
- en: 'In general, a set has elements as members that can be described using a sentence
    or rule, like all positive integers, but it would contain every element only once
    and allow several basic operations: unions, intersections, differences, and the
    Cartesian product, which is the combination of two sets so that elements are combined
    in every possible way:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个集合具有作为成员的元素，可以使用句子或规则来描述，例如所有正整数，但它只会包含每个元素一次，并允许执行几个基本操作：并集、交集、差集和笛卡尔积，即两个集合的组合，使得元素以每种可能的方式组合：
- en: '![](img/4557c684-c99f-4c75-bb82-29d9df532471.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4557c684-c99f-4c75-bb82-29d9df532471.png)'
- en: Since set elements are unique, any implementation of a set, therefore, has to
    make sure that each element is unique within the data structure, which is what
    makes the actual data structure special; it optimizes for uniqueness and retrieval.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合元素是唯一的，因此任何集合的实现都必须确保每个元素在数据结构中是唯一的，这就是实际数据结构特殊的地方；它优化了唯一性和检索。
- en: What about using linear search on a vector to guarantee uniqueness? It works,
    but inserting in a populated set is going to take a lot longer than a new one.
    Additionally, the previous chapters talked about how trees are much better at
    finding things than lists, which is also why no good set implementation should
    use them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在向量上使用线性搜索来保证唯一性怎么样？它是可行的，但在已填充集合中插入将比新集合花费更长的时间。此外，前几章讨论了树在查找事物方面比列表更好，这也是为什么一个好的集合实现不应该使用它们的原因。
- en: 'The Rust collections in the standard library know two types of sets: `BTreeSet<K,V>`
    and `HashSet<K,V>`, both names that hint at their implementations. As mentioned
    in [Chapter 5](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml), *Robust Trees*, the
    B-Tree is a generic, self-balancing tree implementation that allows an arbitrary
    number of children per node, and makes search within its keys very efficient.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库中的集合知道两种类型的集合：`BTreeSet<K,V>` 和 `HashSet<K,V>`，这两个名称都暗示了它们的实现。如[第5章](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml)中所述，*鲁棒树*，B-树是一种通用的、自平衡的树实现，允许每个节点有任意数量的子节点，并在其键的搜索中非常高效。
- en: '`HashSet<K,V>` is different. By storing a hash representation of the key, lookup
    can be done in constant time if the hashes are distributed uniformly. Since hash
    sets and hash maps have the same inner workings, this section will focus on a
    tree-based implementation and another section goes further into the depths of
    a hash map.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet<K,V>` 是不同的。通过存储键的哈希表示，如果哈希分布均匀，则可以在常数时间内完成查找。由于哈希集合和哈希映射有相同的内部机制，本节将重点介绍基于树的实现，另一节将进一步深入探讨哈希映射的深度。'
- en: Other than inserting and checking whether a set contains a certain element,
    the main operations that a set should provide are union, intersect, and difference,
    as well as an iterator. Having these operations available will provide an efficient
    way to combine multiple sets in various ways, which is part of why they are useful.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了插入和检查集合是否包含某个元素之外，集合应该提供的主要操作还包括并集、交集和差集，以及迭代器。这些操作的存在将提供一种有效的方法来以各种方式组合多个集合，这也是它们有用的原因之一。
- en: 'In Rust code, a trie-based set could look like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 代码中，基于 trie 的集合可能看起来如下：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This the trie implementation of [Chapter 5](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml),
    *Robust Trees*, with generics added and using a `BTreeMap<K,V>` root node to avoid
    creating too many trait dependencies. This allows arbitrary chains of simple data
    types to be stored as a trie, a highly efficient data structure where overlaps
    are kept together only to branch off once they diverge (read more on tries in
    [Chapter 5](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml), *Robust Trees*).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第 5 章（84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml）的 trie 实现版本，*鲁棒树*，增加了泛型，并使用
    `BTreeMap<K,V>` 作为根节点来避免创建过多的 trait 依赖。这允许任意链的简单数据类型作为 trie 存储起来，这是一个高度有效的数据结构，其中重叠仅在它们分叉时才被保留（关于
    trie 的更多信息，请参阅第 5 章（84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml），*鲁棒树*）。
- en: Can this store numbers? Yes, although they have to be converted to a byte array,
    but then anything can be stored in this set.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储器能存储数字吗？是的，尽管它们必须转换成字节数组，但这样就可以在这个集合中存储任何东西。
- en: '*The product team has had an idea: they want to store network addresses for
    a network analysis software. They want to store these addresses in order to run
    some basic analysis on top of them: which network devices are in both networks,
    gathering all the addresses that are in either all or not in some specified networks.
    Since IP addresses are unique and consist of individual bytes that have to have
    common prefixes, wouldn''t this be a great opportunity to use that trie set?*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*产品团队有一个想法：他们想存储网络分析软件的网络地址。他们想存储这些地址，以便在上面运行一些基本分析：哪些网络设备同时存在于两个网络中，收集所有在所有或不在某些指定网络中的地址。由于
    IP 地址是唯一的，并且由必须具有共同前缀的单独字节组成，这不是使用 trie 集合的绝佳机会吗？*'
- en: Storing network addresses
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储网络地址
- en: Storing network addresses is not a hard problem and there are many solutions
    out there. Their binary structure provides an opportunity to create something
    really specific—if time is not an issue.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 存储网络地址不是一个难题，而且有很多人都在寻找解决方案。它们的二进制结构提供了一个机会来创建一些非常具体的东西——如果时间不是问题的话。
- en: 'In many cases, however, an off-the-shelf implementation of a data structure
    is enough to cover most basic use cases when that isn''t your main concern. Hence,
    the network address storage can simple be a type alias that specifies the key
    type for the trie set, shown as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，一个现成的数据结构实现已经足够覆盖大多数基本用例，尤其是当这并不是你的主要关注点时。因此，网络地址存储可以简单地是一个类型别名，它指定了
    trie 集合的键类型，如下所示：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Slight modifications to the `insert` (former `add`) function of the trie allows
    users to simply pass a slice of the key type into the function, shown in the following
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对 trie 的 `insert`（以前的 `add`）函数的轻微修改允许用户简单地将键类型的切片传递给该函数，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This implementation differs only in a few details from what was done in the
    previous chapter. Firstly, it's important to avoid incrementing the length twice,
    which is avoided by checking if a key ends at the last node of the new key. This
    flag is also a new addition since the other implementation was specifically implemented
    to store instances of the `IoTDevice` type, and each node would have an optional
    device attached to it to signal the completion of a key.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一章所做的工作相比，这个实现只在几个细节上有所不同。首先，重要的是要避免两次增加长度，这可以通过检查键是否以新键的最后一个节点结束来避免。这个标志也是新增的，因为其他实现是专门为了存储
    `IoTDevice` 类型的实例而实现的，每个节点都会有一个可选的设备附加到它，以表示键的完成。
- en: A similar reasoning was applied to the `walk` and `contains` functions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的推理也应用于 `walk` 和 `contains` 函数。
- en: Networked operations
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络操作
- en: One key requirement of the product team was the ability to run simple analytics
    on top of this set. As a first step, these analytics can be comprised of set operations
    and comparing their lengths in order to create simple indicators.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 产品团队的一个关键要求是能够在该集合上运行简单的分析。作为第一步，这些分析可以由集合操作和比较它们的长度来组成，以便创建简单的指标。
- en: 'One thing that is important, however, is to also get the addresses back out.
    For that, the implementation this time provides an iterator implementation that
    consumes the trie and stores it as a `Vec<T>`, shown as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一件重要的事情是要也能获取回地址。为此，这次实现提供了一个迭代器实现，它消耗了字典树并将其存储为`Vec<T>`，如下所示：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the vector is created, an index will do for keeping track of moving the
    iterator around. The set operations are actually not much more complex than that.
    However, all of them use the `walk()` function, which requires us to provide mutability
    in a lambda expression (or closure), and consequently a `RefCell` to take care
    of mutability management dynamically.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了向量，一个索引就可以用来跟踪迭代器的移动。集合操作实际上并不比这复杂多少。然而，它们实际上都使用了`walk()`函数，这要求我们在lambda表达式（或闭包）中提供可变性，因此需要一个`RefCell`来动态处理可变性管理。
- en: Union
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并集
- en: The definition of a set union is that every element that occurs in either set
    is required to occur in the result. Therefore, the challenge is to insert elements
    from both sets into the resulting set, without creating duplicates.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 集合并集的定义是，在任一集合中出现的每个元素都必须出现在结果中。因此，挑战是从两个集合中插入元素到结果集中，而不创建重复项。
- en: 'Since this is handled by the `insert` process, a naive implementation could
    look like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是由`insert`过程处理的，一个简单的实现可能如下所示：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This consumes both sets, returning only the result. The next operation, the
    intersection, looks very similar.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这消耗了两个集合，只返回结果。下一个操作，交集，看起来非常相似。
- en: Intersection
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交集
- en: 'To find the common elements of two sets, the intersection is a way of doing
    that. The definition also describes exactly that, which is why the naive implementation
    in Rust also follows that pattern, shown as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到两个集合的共同元素，交集是完成这个任务的一种方法。定义也正好描述了这一点，这就是为什么Rust中的简单实现也遵循这个模式，如下所示：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a last function, the difference is important, since it excludes common elements
    from the result set.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个函数，差异很重要，因为它从结果集中排除了共同元素。
- en: Difference
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 差异
- en: 'Instead of common elements, sometimes the opposite is required—removing elements
    that occur in both sets. This operation is also referred to as the complement
    of two sets, which only inserts elements into the result if they don''t occur
    in the other set:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，不是需要公共元素，而是需要移除两个集合中出现的元素。这个操作也被称为两个集合的补集，它只在元素不在另一个集合中出现时才将元素插入到结果中：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With that, the set is finished, and all the desired functionality can be provided.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，集合就完成了，并且可以提供所有所需的功能。
- en: Wrap up
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Sets are not complicated, but are useful. While database indices might be B-Trees,
    the result sets are the sets of primary keys that get moved around and operated
    on until the very last step, when the associated row information is fetched from
    disk. These are the moments when set data structures come in handy and provide
    a simple solution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 集合并不复杂，但很有用。虽然数据库索引可能是B树，但结果集是主键集合，在最后一步之前被移动和操作，最后从磁盘检索相关的行信息。这些就是集合数据结构派上用场并提供简单解决方案的时刻。
- en: Similarly to everyday tasks, creating a list of unique elements can be very
    inefficient when a list is used; storing them in a set, however, requires no extra
    effort. In fact, most elements can then just be thrown into the set, which won't
    insert duplicates anyway.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于日常任务，当使用列表时，创建唯一元素列表可能非常低效；然而，将它们存储在集合中则不需要额外努力。实际上，大多数元素可以直接扔进集合中，而集合本身也不会插入重复项。
- en: Upsides
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'The set is a higher-level data structure that does the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个高级数据结构，它执行以下操作：
- en: provides a simple interface for unique lists
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为唯一列表提供了一个简单的接口
- en: Implements a mathematical concept
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了一个数学概念
- en: Has a very efficient way of storing and retrieving its elements
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个非常高效的存储和检索其元素的方式
- en: Downsides
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'The set has some downsides as well, primarily the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 集合也有一些缺点，主要是以下这些：
- en: Element order determinism depends on the implementation
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素顺序的确定性取决于实现
- en: Does not always add a lot of value compared to maps
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与映射相比，并不总是增加很多价值
- en: Limited use cases
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限的使用场景
- en: Since maps will be used a lot more often, let's dive into those.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将更频繁地使用映射，让我们深入了解那些。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: '**Hashing** is the art (and science) of creating a single representation (typically
    a number) from an arbitrary object, be it strings, `type` instances, or collections;
    there is a way to break them down into a number that should reflect a particular
    use case. The real question is what you want to achieve and what characteristics
    are expected from the outcome. Cryptographic hashing deals with minimizing collisions
    and creating signatures that create a very different hash from minor modifications,
    whereas GeoHashes are a way to hierarchically structure Earth''s coordinates into
    a string. Whenever two (or more) inputs to a hash function lead to the same output,
    this is called a collision—a bad sign for any cryptographic hashing, but fine
    if it''s mostly about storing something in a hash map, as long as the collisions
    are evenly distributed. Most importantly, however, software engineers should *never*
    come up with their own hash functions, especially if security is a concern.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希**艺术（以及科学）在于从任意对象（无论是字符串、`类型`实例还是集合）创建一个单一表示（通常是数字）；有一种方法可以将它们分解成数字，这些数字应该反映特定的用例。真正的问题是你想实现什么，以及期望从结果中获得哪些特性。加密哈希处理的是最小化冲突并创建签名，这些签名在轻微修改后会产生非常不同的哈希值，而地理哈希则是将地球坐标分层结构化为字符串的一种方法。当两个（或更多）输入到一个哈希函数中导致相同的输出时，这被称为冲突——对于任何加密哈希来说都是不好的信号，但如果主要是存储在哈希映射中，只要冲突均匀分布，那就没问题。然而，最重要的是，软件工程师**永远**不应该自己设计哈希函数，尤其是如果安全性是一个关注点的话。'
- en: '**Maps** store and manage key-value pairs in an underlying data structure,
    which is typically either a tree or an array that maps hashes to key-value pairs
    called hash maps. By using a hash function to describe the key and sort the pair
    into buckets (array elements), hash maps are a great use case for hashing. These
    buckets are basically indices on an array that stores a list (or tree) for whenever
    different inputs lead to the same bucket. Consequently, the best case performance
    of a hash map is constant time (*O(1)*) to retrieve any value, whereas the worst
    case is linear time (*O(n)*) if the hash function returns a constant number. In
    reality, there are other uses that might be beneficial, such as caching, where
    the use case limits the potential inputs, and best case performance is always
    achieved.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**在底层数据结构中存储和管理键值对，这通常是树或数组，将哈希映射到称为哈希映射的键值对。通过使用哈希函数来描述键并将对排序到桶中（数组元素），哈希映射是哈希的绝佳用例。这些桶基本上是存储列表（或树）的数组的索引，当不同的输入导致相同的桶时。因此，哈希映射的最佳性能是常数时间（*O(1)*）检索任何值，而最坏情况是线性时间（*O(n)*），如果哈希函数返回一个常数。在现实中，还有其他可能有益的用途，例如缓存，其中用例限制了潜在的输入，并且始终实现最佳性能。'
- en: 'Contrary to maps, **sets** are great data structures to store a unique collection
    of elements to perform set operations on. They can be implemented just like a
    hash map, using a hash function or a tree. In this chapter, we implemented a set
    based on a modified trie data structure from the previous chapter (*Robust Trees*),
    as well as the basic three operations: union, intersection, and difference.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与映射不同，**集合**是存储唯一元素集合以执行集合操作的优秀数据结构。它们可以像哈希映射一样实现，使用哈希函数或树。在本章中，我们基于前一章（*鲁棒树*）修改后的
    trie 数据结构实现了一个集合，以及基本的三种操作：并集、交集和差集。
- en: In the next chapter, we will continue to explore Rust's `std::collections` library
    and its contents. This will include some benchmarking and looking into more implementation
    details, since these are the best implementations of all the concepts discussed
    in the book so far.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索Rust的`std::collections`库及其内容。这包括一些基准测试和查看更多实现细节，因为这些是实现书中迄今为止讨论的所有概念的最好实现。
- en: Questions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What makes a good hash function?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么使一个好的哈希函数？
- en: How can you estimate the suitability of a hash function for a particular task?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何估计一个哈希函数对特定任务的适用性？
- en: Is a checksum hash useful in other ways?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 校验和哈希在其他方面有用吗？
- en: What are two ways to implement a map?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现映射的两种方法是什么？
- en: What are buckets?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桶是什么？
- en: Can a set replace a list?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个集合能否替代列表？
- en: What makes a set useful?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么使集合有用？
- en: Further reading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Refer to the following links for more information:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下链接获取更多信息：
- en: '[http://geohash.org/](http://geohash.org/)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://geohash.org/](http://geohash.org/)'
- en: '*Fletcher''s checksum* ([https://en.wikipedia.org/wiki/Fletcher%27s_checksum](https://en.wikipedia.org/wiki/Fletcher%27s_checksum))'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fletcher校验和* ([https://en.wikipedia.org/wiki/Fletcher%27s_checksum](https://en.wikipedia.org/wiki/Fletcher%27s_checksum))'
- en: Rust's `HashMap` implementation reasoning ([https://www.reddit.com/r/rust/comments/52grcl/rusts_stdcollections_is_absolutely_horrible/d7kcei2](https://www.reddit.com/r/rust/comments/52grcl/rusts_stdcollections_is_absolutely_horrible/d7kcei2))
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust的`HashMap`实现原理([https://www.reddit.com/r/rust/comments/52grcl/rusts_stdcollections_is_absolutely_horrible/d7kcei2](https://www.reddit.com/r/rust/comments/52grcl/rusts_stdcollections_is_absolutely_horrible/d7kcei2))
- en: '[https://doc.rust-lang.org/std/hash/](https://doc.rust-lang.org/std/hash/)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rust标准库中的哈希函数文档](https://doc.rust-lang.org/std/hash/)'
- en: Wikipedia's list of hash functions ([https://en.wikipedia.org/wiki/List_of_hash_functions](https://en.wikipedia.org/wiki/List_of_hash_functions))
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科的哈希函数列表([https://en.wikipedia.org/wiki/List_of_hash_functions](https://en.wikipedia.org/wiki/List_of_hash_functions))
