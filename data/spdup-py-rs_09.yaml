- en: '*Chapter 9*: Structuring a Python Flask App for Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：为 Rust 结构化 Python Flask 应用程序'
- en: In the previous chapter, we managed to solve a real-world problem with Rust.
    However, we also learned an important lesson, that is, the good implementation
    of code, such as adding vectors or merging dataframes, along with third-party
    modules, such as `NumPy`, can outperform badly implemented self-coded Rust solutions.
    However, we know that comparing implementation to implementation, Rust is a lot
    faster than Python. We already understand how to fuse Rust with a standard Python
    script. However, Python is used for more than just running scripts. A popular
    use for Python is in web applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们成功使用 Rust 解决了一个实际问题。然而，我们也学到了一个重要的教训，那就是良好的代码实现，例如添加向量或合并数据框，以及第三方模块，如
    `NumPy`，可以比糟糕的自编 Rust 解决方案表现得更好。然而，我们知道在实现与实现之间比较，Rust 的速度远快于 Python。我们已经了解了如何将
    Rust 与标准 Python 脚本融合。然而，Python 的用途远不止运行脚本。Python 的一个流行用途是用于 Web 应用程序。
- en: In this chapter, we will build a Flask web application with NGINX, a database,
    and a message bus implemented by the `Celery` package. This message bus will allow
    our application to process heavy tasks in the background while we return a web
    HTTP request. The web application and message bus will be wrapped in Docker containers
    and deployed to `docker-compose`. However, nothing is preventing us from deploying
    the application onto a cloud platform if desired.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 NGINX、数据库和由 `Celery` 包实现的信使总线来构建一个 Flask Web 应用程序。这个信使总线将允许我们的应用程序在处理重任务的同时返回
    Web HTTP 请求。Web 应用程序和信使总线将被封装在 Docker 容器中，并部署到 `docker-compose`。然而，如果需要，我们也可以将应用程序部署到云平台。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building a basic Flask application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基本的 Flask 应用程序
- en: Defining a database access layer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据库访问层
- en: Building a message bus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建消息总线
- en: This chapter will enable us to build a foundation for deployable Python web
    applications that have a range of features and services. This foundation allows
    us to discover how to fuse Rust with Python web applications that are wrapped
    in Docker containers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使我们能够为具有各种功能和服务的可部署 Python Web 应用程序打下基础。这个基础使我们能够发现如何将 Rust 与封装在 Docker 容器中的
    Python Web 应用程序融合。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code and data for this chapter can be found at [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_nine](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_nine).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码和数据可以在[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_nine](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_nine)找到。
- en: In addition to this, we will be using `docker-compose` on top of Docker to orchestrate
    our Docker containers. This can be installed by following the instructions at
    [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在 Docker 的基础上使用 `docker-compose` 来编排我们的 Docker 容器。可以通过遵循[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)中的说明来安装。
- en: In this chapter, we will be building a Docker-contained Flask application, which
    is available via the GitHub repository at [https://github.com/maxwellflitton/fib-flask](https://github.com/maxwellflitton/fib-flask).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个 Docker 容器中的 Flask 应用程序，该应用程序可在 GitHub 仓库[https://github.com/maxwellflitton/fib-flask](https://github.com/maxwellflitton/fib-flask)中找到。
- en: Building a basic Flask application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基本的 Flask 应用程序
- en: 'Before we begin adding any additional features such as a database to an application,
    we have to ensure that that we can get a basic Flask application up and running
    with everything that we need. This application will take in a number and return
    a Fibonacci number. Additionally, we will need to make sure that this application
    can run in its own Docker container if we were to deploy it. By the end of this
    section, our application should have the following structure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向应用程序添加任何其他功能，如数据库之前，我们必须确保我们可以运行一个基本的 Flask 应用程序，并包含我们所需的一切。这个应用程序将接受一个数字并返回一个斐波那契数。此外，我们还需要确保如果我们要部署它，这个应用程序可以在自己的
    Docker 容器中运行。在本节结束时，我们的应用程序应该具有以下结构：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, you can see that the application is housed in the `src` directory. When
    running our application, we must ensure that the `PYTHONPATH` path is set to `src`.
    The code required for our deployment exists in the `deployment` directory. To
    build an application so that it can run in Docker, perform the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到应用程序位于`src`目录中。在运行我们的应用程序时，我们必须确保`PYTHONPATH`路径设置为`src`。我们部署所需的代码位于`deployment`目录中。为了构建一个可以在Docker中运行的应用程序，请执行以下步骤：
- en: Build an entry point for our application.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的应用程序构建一个入口点。
- en: Build a Fibonacci number calculation module.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建斐波那契数计算模块。
- en: Build a Docker image for our application.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的应用程序构建一个Docker镜像。
- en: Build our NGINX service.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们的NGINX服务。
- en: Once we have completed all of these steps, we will have a basic Flask application
    that can be run on a server. Now, let's explore each of these steps in detail
    in the following subsections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些步骤后，我们将拥有一个可以在服务器上运行的基本Flask应用程序。现在，让我们在以下子节中详细探讨这些步骤。
- en: Building an entry point for our application
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序的入口点
- en: 'Here are the steps to perform:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行步骤：
- en: 'Before we can build our entry point, we need to install the Flask module using
    the following command:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以构建入口点之前，我们需要使用以下命令安装Flask模块：
- en: '[PRE13]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once this is done, we have all we need to create a basic Flask application
    by defining the entry point in the `src/app.py` file using the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们就有了创建基本Flask应用程序所需的一切，通过在`src/app.py`文件中定义入口点来创建它，如下所示：
- en: '[PRE14]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, observe that we can define a basic route with the decorator. We can run
    our application by running the `src/app.py` script; this will run our server locally,
    enabling us to access all of the routes that we have defined. Passing the `http://127.0.0.1:5002`
    URL into our browser will give us the following view:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，观察我们可以使用装饰器定义一个基本路由。我们可以通过运行`src/app.py`脚本来运行我们的应用程序；这将使我们的服务器在本地运行，使我们能够访问我们定义的所有路由。将`http://127.0.0.1:5002`
    URL传递到我们的浏览器中，将给出以下视图：
- en: '![Figure 9.1 – The main view of our local Flask server'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 我们本地Flask服务器的主视图'
- en: '](img/Figure_9.01_B17720.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B17720.jpg)'
- en: Figure 9.1 – The main view of our local Flask server
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 我们本地Flask服务器的主视图
- en: Now that our basic server is running, we can move on to build a Fibonacci number
    calculator module.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们基本的服务器正在运行，我们可以继续构建斐波那契数计算器模块。
- en: Building our Fibonacci number calculator module
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的斐波那契数计算器模块
- en: 'Here are the steps to perform:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行步骤：
- en: 'In this example, our application is simple. As a result, we can define our
    module''s functionality within one file in one class. We define it within the
    `src/fib_calcs/fib_calculation.py` file using the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的应用程序很简单。因此，我们可以在一个文件中的一个类中定义我们模块的功能。我们使用以下代码在`src/fib_calcs/fib_calculation.py`文件中定义它：
- en: '[PRE15]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, notice that our class merely takes in an input number and automatically
    populates the `self.fib_number` attribute with the calculated Fibonacci number.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，请注意，我们的类仅仅接受一个输入数字，并自动将计算出的斐波那契数填充到`self.fib_number`属性中。
- en: 'Once that is done, we can define a view that accepts an integer through the
    URL, passes it to our `FibCalculation` class, and returns the calculated Fibonacci
    number as a string to the user in our `src/app.py` file using the following code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们就可以定义一个视图，它通过URL接受一个整数，将其传递给我们的`FibCalculation`类，并使用以下代码将计算出的斐波那契数作为字符串返回给用户在`src/app.py`文件中：
- en: '[PRE16]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Rerunning our server and passing the `http://127.0.0.1:5002/calculate/10` URL
    into our browser will give us the following view:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行我们的服务器，并将`http://127.0.0.1:5002/calculate/10` URL传递到我们的浏览器中，将给出以下视图：
- en: '![Figure 9.2 – Calculating the view of our local Flask server'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 计算我们本地Flask服务器的视图'
- en: '](img/Figure_9.02_B17720.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B17720.jpg)'
- en: Figure 9.2 – Calculating the view of our local Flask server
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 计算我们本地Flask服务器的视图
- en: 'Now our application performs its intended purpose: it calculates a Fibonacci
    number based on the input. There is more to views with Flask; however, this book
    is not a web development textbook. If you want to learn how to build more comprehensive
    API endpoints, we advise that you look into the Flask API and `Marshmallow` packages.
    References to both are available in the *Further reading* section. Now, we need
    to make our application deployable so that we can use it in a range of settings
    for our next step.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序执行其预期功能：它根据输入计算斐波那契数。Flask的视图还有更多功能；然而，这本书不是一本网络开发教科书。如果您想学习如何构建更全面的API端点，我们建议您查看Flask
    API和`Marshmallow`包。这两个包的参考信息可以在*进一步阅读*部分找到。现在，我们需要使我们的应用程序可部署，以便我们可以在各种设置中使用它作为下一步。
- en: Building a Docker image for our application
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的应用程序构建Docker镜像
- en: 'For our application to be usable, we must build a Docker image of our application
    that accepts requests. Then, we must protect it with another container call that
    acts as an ingress. NGINX performs load balancing, caching, streaming, and the
    redirecting of traffic. Our application will be run using the Gunicorn package,
    which, essentially, runs multiple workers of our application at the same time.
    For each request, NGINX asks which Gunicorn worker the request should go to and
    redirects it, as shown in the following diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序可用，我们必须构建一个接受请求的应用程序Docker镜像。然后，我们必须使用另一个充当入口的容器调用来保护它。NGINX执行负载均衡、缓存、流式传输和流量重定向。我们的应用程序将使用Gunicorn包运行，该包本质上同时运行多个应用程序工作进程。对于每个请求，NGINX询问请求应该发送到哪个Gunicorn工作进程，并将其重定向，如下面的图所示：
- en: '![Figure 9.3 – The flow of requests for our application'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 我们应用程序请求的流程]'
- en: '](img/Figure_9.03_B17720.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B17720.jpg)'
- en: Figure 9.3 – The flow of requests for our application
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 我们应用程序请求的流程
- en: 'We can achieve the layout defined in the preceding diagram by performing the
    following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下步骤来实现前面图中定义的布局：
- en: 'Before we build a Docker image, we must make sure the requirements for our
    application are handled. Therefore, we must install Gunicorn using `pip` with
    the following command:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们构建Docker镜像之前，我们必须确保处理我们应用程序的要求。因此，我们必须使用以下命令使用`pip`安装Gunicorn：
- en: '[PRE17]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We must make sure that we are in the `src` directory because we are going to
    dump all of our application dependencies into a file called `requirements.txt`
    using the following command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保我们处于`src`目录，因为我们将要使用以下命令将所有应用程序依赖项放入一个名为`requirements.txt`的文件中：
- en: '[PRE18]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This gives us a text file with a list of all the dependencies that our application
    needs in order to run. Right now, all we need is Flask and Gunicorn.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这为我们提供了一个包含所有应用程序运行所需依赖项列表的文本文件。目前，我们只需要Flask和Gunicorn。
- en: 'With this, we can start coding our Docker file so that we can build application
    images of our application. First, in our `src/Dockerfile` file, we should define
    the operating system that is required with the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个方法，我们可以开始编写我们的Dockerfile，以便构建我们应用程序的应用程序镜像。首先，在我们的`src/Dockerfile`文件中，我们应该使用以下代码定义所需的操作系统：
- en: '[PRE19]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This means that our image is running a stripped-down version of Linux with Python
    installed.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们的镜像正在运行一个安装了Python的简化版Linux。
- en: 'Now that we have the correct operating system, we should define our app''s
    directory and copy all of our application files into the image using the following
    code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了正确的操作系统，我们应该定义我们的应用程序目录，并使用以下代码将所有应用程序文件复制到镜像中：
- en: '[PRE20]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that all of our application files are in the image, we install system updates
    and then install the `python-dev` package. This is so that we can include extensions
    with the code given here:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们所有的应用程序文件都在镜像中，我们安装系统更新，然后安装`python-dev`包。这是为了我们可以包含以下代码中的扩展：
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will enable us to compile our Rust code in our application and use database
    binaries.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使我们能够在应用程序中编译我们的Rust代码并使用数据库二进制文件。
- en: 'Our system has now been set up, so we can move on to install our requirements
    using the following code:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的系统现在已经设置好了，我们可以继续使用以下代码安装我们的需求：
- en: '[PRE22]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Everything is in place to define our system. Nothing is stopping us from running
    our application.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一切准备就绪，我们可以定义我们的系统。没有任何东西阻止我们运行我们的应用程序。
- en: 'To do this, we expose the port and run our application using the following
    code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要公开端口并使用以下代码运行我们的应用程序：
- en: '[PRE23]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that when we create a container from the image, we run `CMD` with the parameters
    defined in the list. We state that we have four workers with the `-w 4` parameter.
    Then, we define the URL and port that we are listening to. Our final parameter
    is `app:app`. This states that our application is housed in the `app.py` file,
    and our application in that file is the `Flask` object under the variable name
    of `app`.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，当我们从镜像创建容器时，我们使用列表中定义的参数运行 `CMD`。我们声明我们有四个工作进程，使用 `-w 4` 参数。然后，我们定义我们正在监听的
    URL 和端口。我们的最后一个参数是 `app:app`。这表示我们的应用程序位于 `app.py` 文件中，并且在该文件中的应用程序是名为 `app` 的
    `Flask` 对象。
- en: 'We can now build our application image using the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令构建我们的应用程序镜像：
- en: '[PRE24]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then inspect our images using the following command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查我们的镜像：
- en: '[PRE25]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running this command gives us an image that has been created in the following
    form:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此命令会给我们一个以下形式的镜像：
- en: '[PRE26]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is important. We will need to reference our image later when we are running
    our application with NGINX, which we will define next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要。我们将在运行应用程序时需要引用我们的镜像，我们将在下一部分定义它。
- en: Building our NGINX service
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的 NGINX 服务
- en: When it comes to Docker and NGINX, we are lucky in that we do not have to build
    a Dockerfile that defines our NGINX image. NGINX has released an official image
    that we can download and use for free. However, we do have to alter its configuration.
    NGINX is fairly important; this is because it gives us the ability to control
    how incoming requests are processed. We can redirect the requests to different
    services depending on parts of the URL. Additionally, we can control the size
    of the data, the duration of the connection, and configure HTTPS traffic. NGINX
    can also act as a load balancer. In this example, we are going to configure NGINX
    in the simplest format to get it running. However, it must be noted that NGINX
    is a vast topic in itself; a reference to a useful NGINX book is provided in the
    *Further reading* section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 Docker 和 NGINX 时，我们很幸运，因为我们不需要构建一个定义 NGINX 镜像的 Dockerfile。NGINX 已经发布了一个官方镜像，我们可以免费下载和使用。然而，我们确实需要修改其配置。NGINX
    非常重要；这是因为它赋予我们控制如何处理传入请求的能力。我们可以根据 URL 的部分将请求重定向到不同的服务。此外，我们可以控制数据的大小、连接的持续时间并配置
    HTTPS 流量。NGINX 还可以作为负载均衡器。在这个例子中，我们将以最简单的格式配置 NGINX 以使其运行。然而，必须注意的是，NGINX 本身是一个庞大的主题；在
    *进一步阅读* 部分提供了一个有用的 NGINX 书籍的参考。
- en: 'We can build our NGINX service and connect it to our Flask application by performing
    the following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤构建我们的 NGINX 服务并将其连接到我们的 Flask 应用程序：
- en: 'We will configure our NGINX container with what we code in the `deployment/nginx/nginx.conf`
    file. In this file, we declare our worker processes and error log, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `deployment/nginx/nginx.conf` 文件中的代码配置我们的 NGINX 容器。在这个文件中，我们声明我们的工作进程和错误日志，如下所示：
- en: '[PRE27]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we have defined `worker_processes` as `auto`. This is where we automatically
    detect the number of CPU cores available, setting the number of processes to the
    number of CPU cores.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们已将 `worker_processes` 定义为 `auto`。这是自动检测可用的 CPU 核心数，将进程数设置为 CPU 核心数。
- en: 'Now, we have to define the maximum number of connections that a worker can
    entertain at a time using the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须使用以下代码定义一个工作进程一次可以处理的最大连接数：
- en: '[PRE28]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It must be noted that the number that is chosen here is the default number for
    NGINX.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须注意的是，这里选择的是 NGINX 的默认端口号。
- en: 'All that is now left for us to do is to define our HTTP listener. This can
    be achieved with the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们所剩下的只是定义我们的 HTTP 监听器。这可以通过以下代码实现：
- en: '[PRE29]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, observe that we listen to port `80`, which is the standard outside listening
    port. Then, we state that if there is any pattern to our URL, we pass it to our
    `flask_app` container at port `5002`. We can stack multiple locations in the `http`
    section if we wish. For instance, if we have another app, we can route the request
    to the other application if the URL tail starts with `/another_app/` using the
    following code:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，请注意我们监听的是端口 `80`，这是标准的对外监听端口。然后，我们声明如果我们的 URL 有任何模式，我们就将其传递到端口 `5002` 的
    `flask_app` 容器。如果我们愿意，可以在 `http` 部分堆叠多个位置。例如，如果我们有另一个应用，我们可以使用以下代码将请求路由到其他应用，如果
    URL 尾部以 `/another_app/` 开头：
- en: '[PRE30]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our configuration file for our NGINX is complete. Again, there are many more
    configuration parameters; we are just running the bare minimum. More resources
    on these parameters are signposted in the *Further reading* section. Considering
    that our NGINX configuration file is complete, for the next step, we have to run
    it alongside our Flask application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 NGINX 的配置文件已经完成。再次强调，还有很多其他的配置参数；我们只是运行了最基本的部分。更多关于这些参数的资源在 *进一步阅读* 部分中有所说明。考虑到我们的
    NGINX 配置文件已经完成，对于下一步，我们必须在 Flask 应用程序旁边运行它。
- en: Connecting and running our Nginx service
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接并运行我们的 Nginx 服务
- en: 'To run our application and NGINX together, we will be using `docker-compose`.
    This allows us to define multiple Docker containers at the same time that can
    talk to each other. Nothing is stopping us from running `docker-compose` on a
    server to achieve a basic setup. However, more advanced systems such as Kubernetes
    can help with the orchestration of Docker containers across multiple servers if
    needed. In addition to this, different cloud platforms offer out-of-the-box load
    balancers. Perform the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要一起运行我们的应用程序和 NGINX，我们将使用 `docker-compose`。这允许我们同时定义多个 Docker 容器，这些容器可以相互通信。没有什么阻止我们在服务器上运行
    `docker-compose` 来实现基本设置。然而，如果需要，更高级的系统如 Kubernetes 可以帮助跨多个服务器对 Docker 容器进行编排。此外，不同的云平台提供开箱即用的负载均衡器。执行以下步骤：
- en: 'In our `deployment/docker-compose.yml` file, we state what version of `docker-compose`
    we are using with the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `deployment/docker-compose.yml` 文件中，我们使用以下代码声明我们正在使用的 `docker-compose`
    版本：
- en: '[PRE31]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that this has been implemented, we can define our services along with our
    first service, which is our Flask application. This is defined with the following
    code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实施完成后，我们可以定义我们的服务，包括我们的第一个服务，即我们的 Flask 应用程序。这是以下代码定义的：
- en: '[PRE32]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we reference the image that we built with the latest
    release. For instance, if we changed the image and rebuilt it, then our `docker-compose`
    setup would use this. We also give it a container name, so we know the container
    status when checking the running containers. Additionally, we state that we accept
    traffic through port `5002`, and we route it to our container's port `5002`. Because
    we have chosen this path, we also expose port `5002`. If we run our `docker-compose`
    setup now, we could access our application with the `http://localhost:5002` URL.
    However, if this was running on a server and port `5002` was not accessible to
    outside traffic, then we would not be able to access it.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们引用了我们使用最新版本构建的镜像。例如，如果我们更改了镜像并重新构建它，那么我们的 `docker-compose` 设置将使用这个镜像。我们还给它一个容器名称，这样我们就可以在检查正在运行的容器时知道容器状态。此外，我们声明我们通过端口
    `5002` 接受流量，并将其路由到我们的容器端口 `5002`。因为我们选择了这条路径，所以我们还暴露了端口 `5002`。如果我们现在运行我们的 `docker-compose`
    设置，我们可以通过 `http://localhost:5002` URL 访问我们的应用程序。然而，如果它在服务器上运行，并且端口 `5002` 对外部流量不可访问，那么我们就无法访问它。
- en: 'Considering this, we can define our NGINX in our `deployment/docker-compose.yml`
    file using the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以在 `deployment/docker-compose.yml` 文件中使用以下代码定义我们的 NGINX：
- en: '[PRE33]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, you can see that we rely on the third-party NGINX image and that we route
    the outside port of `80` to port `80`. Also, we link to our Flask application,
    and we depend on it, meaning that `docker-compose` will ensure that our Flask
    application is up and running before we run our NGINX service. In the `volumes`
    section, we replace the standard configuration file with the configuration file
    that we defined in the previous step. As a result, our NGINX service will run
    the configuration that we defined. It must be noted that this configuration switch
    will happen every time we run `docker-compose`. This means that if we change our
    configuration file and then run `docker-compose` again, we will see the changes.
    So, we have done everything to get our application up and running. Now we can
    test it.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们依赖于第三方 NGINX 镜像，并且我们将外部端口 `80` 路由到端口 `80`。我们还链接到我们的 Flask 应用程序，并依赖于它，这意味着
    `docker-compose` 将确保在我们的 NGINX 服务运行之前，我们的 Flask 应用程序已经启动并运行。在 `volumes` 部分中，我们用我们在上一步定义的配置文件替换了标准配置文件。因此，我们的
    NGINX 服务将运行我们定义的配置。必须注意的是，每次我们运行 `docker-compose` 时，这个配置切换都会发生。这意味着如果我们更改了配置文件然后再次运行
    `docker-compose`，我们会看到变化。所以，我们已经做了所有事情来让我们的应用程序启动并运行。现在我们可以测试它了。
- en: 'Testing our application is as easy as running the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试我们的应用程序就像运行以下命令一样简单：
- en: '[PRE34]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Figure 9.4 – Interacting with our fully containerized Flask application'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4 – 与我们的完全容器化的 Flask 应用程序交互'
- en: '](img/Figure_9.04_B17720.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.04_B17720.jpg)'
- en: Figure 9.4 – Interacting with our fully containerized Flask application
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 与我们的完全容器化 Flask 应用程序交互
- en: Now we have a fully containerized application that runs. This is at a ready
    state, so in the next chapter, we can test to see whether our Rust integration
    with our application will actually work in a real-life scenario. Now that we have
    gotten our application running, we can move on to build our data access layer.
    This will allow us to store and get data from a database.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全容器化的应用程序正在运行。这处于就绪状态，因此在下章中，我们可以测试我们的 Rust 与应用程序的集成是否在实际场景中真正有效。现在我们的应用程序已经运行起来，我们可以继续构建我们的数据访问层。这将使我们能够从数据库存储和获取数据。
- en: Defining our data access layer
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们的数据访问层
- en: 'Now we have an application that takes in a number and calculates a Fibonacci
    number based on it. However, a database lookup is quicker than a calculation.
    We will use this fact to optimize our application by initially performing a database
    lookup when a number is submitted. If it is not there, we calculate the number,
    store it in the database, and then return it to the user. Before we start building,
    we will have to install the following packages using `pip`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个应用程序，它接受一个数字并基于它计算斐波那契数。然而，数据库查找比计算更快。我们将利用这个事实通过最初在提交数字时执行数据库查找来优化我们的应用程序。如果它不在那里，我们将计算这个数字，将其存储在数据库中，然后将其返回给用户。在我们开始构建之前，我们必须使用
    `pip` 安装以下包：
- en: '`pyml`: This package helps in loading parameters for our application from a
    `.yml` file.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyml`：这个包帮助我们从 `.yml` 文件中加载应用程序的参数。'
- en: '`sqlalchemy`: This package enables our application to map Python objects to
    databases for storing and querying.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlalchemy`：这个包使我们的应用程序能够将 Python 对象映射到数据库以存储和查询。'
- en: '`alembic`: This package helps in tracking and applying changes to the database
    from the application.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alembic`：这个包帮助跟踪和将应用程序对数据库的更改应用到数据库中。'
- en: '`psycopg2-binary`: This is the binary that will enable our application to connect
    to the database.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psycopg2-binary`：这是将使我们的应用程序能够连接到数据库的二进制文件。'
- en: 'Now that we have installed all that we need, we can enable our application
    to store and get Fibonacci numbers by performing the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有需要的，我们可以通过以下步骤使我们的应用程序能够存储和获取斐波那契数：
- en: Define a PostgreSQL database in `docker-compose`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `docker-compose` 中定义一个 PostgreSQL 数据库。
- en: Build a config loading system.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个配置加载系统。
- en: Define a data access layer.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个数据访问层。
- en: Build database models.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建数据库模型。
- en: Set up the application database migration system.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置应用程序数据库迁移系统。
- en: Apply the database access layer to the fib calculation view.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据库访问层应用到斐波那契计算视图。
- en: 'Once we have completed these steps, our application will take the following
    form:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们的应用程序将呈现以下形式：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our deployment file structure has not changed. We have added a `docker-compose.yml`
    file to our root as it will enable us to access the database when we are developing
    our application. In addition to this, we have added a data access file to enable
    us to connect to the database along with a `models` module to enable mapping objects
    to the database. This structure will result in a containerized Flask application
    that has access to a database. Next, we will begin defining our Docker container
    for our database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的部署文件结构没有改变。我们已经在根目录中添加了一个 `docker-compose.yml` 文件，这样我们就可以在我们开发应用程序时访问数据库。除此之外，我们还添加了一个数据访问文件，使我们能够连接到数据库，以及一个
    `models` 模块，使我们能够将对象映射到数据库。这种结构将导致一个具有数据库访问权限的容器化 Flask 应用程序。接下来，我们将开始定义我们的数据库
    Docker 容器。
- en: Defining a PostgreSQL database in docker-compose
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 docker-compose 中定义一个 PostgreSQL 数据库
- en: 'To define our database container, we apply the following code to both the `deployment/docker-compose.yml`
    file and the `docker-compose.yml` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义我们的数据库容器，我们将以下代码应用到 `deployment/docker-compose.yml` 文件和 `docker-compose.yml`
    文件中：
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, you can observe that we are relying on the official third-party Postgres
    image. Instead of defining a configuration file, as we did with the NGINX service,
    we define the password, database name, and user using the environment variables.
    When we are running our local environment and developing our application, we will
    run our `docker-compose` file in the root. Now we have defined our database; in
    the next section, we can build our config system.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以观察到我们依赖于官方的第三方Postgres镜像。与我们在NGINX服务中定义配置文件的方式不同，我们使用环境变量来定义密码、数据库名和用户。当我们运行本地环境并开发我们的应用程序时，我们将在根目录下运行我们的`docker-compose`文件。现在我们已经定义了数据库；在下一节中，我们可以构建我们的配置系统。
- en: Building a config loading system
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建配置加载系统
- en: 'Essentially, our configuration system loads parameters from a `.yml` file inside
    the Flask application by performing these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们的配置系统通过以下步骤在Flask应用程序内部从`.yml`文件加载参数：
- en: 'Our application might require different parameters depending on the system.
    Because of this, we must build an object that loads parameters from a `.yml` file
    and serves them as a dictionary throughout the application. In our `src/config.py`
    file, first, we import what we need with the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据系统不同，我们的应用程序可能需要不同的参数。因此，我们必须构建一个对象，该对象从`.yml`文件中加载参数，并在整个应用程序中以字典的形式提供服务。在我们的`src/config.py`文件中，首先，我们使用以下代码导入所需的模块：
- en: '[PRE61]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We will be using the `sys` module to take in the arguments that were passed
    into our application while running it. We use the `os` module to check whether
    the config file that we have specified in the arguments exists.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`sys`模块来接收在运行应用程序时传递给我们的参数。我们使用`os`模块来检查我们指定的配置文件是否存在。
- en: 'Our global parameters object can be built using the following code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码构建全局参数对象：
- en: '[PRE62]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, you can observe that our `GlobalParams` class directly inherits from the
    dictionary class. This means that we have all the functionality of a dictionary.
    In addition to this, note that we do not pass any arguments into our Python program
    specifying which `.yml` file to load; instead, we simply revert to the standard
    `config.yml` file. This is because we will use our configuration file for migrations
    to the database. It will be difficult to pass in our parameters when performing
    database migrations. If we want to change the configuration, it is best to get
    the new data and write it to the config file.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以观察到我们的`GlobalParams`类直接继承自字典类。这意味着我们拥有了字典的所有功能。除此之外，请注意，我们并没有在我们的Python程序中传递任何参数来指定要加载哪个`.yml`文件；相反，我们简单地回退到标准的`config.yml`文件。这是因为我们将使用我们的配置文件进行数据库迁移。在执行数据库迁移时，传递我们的参数将会很困难。如果我们想更改配置，最好是获取新数据并将其写入配置文件。
- en: 'Now that our config parameters class has been defined, we can add the database
    URL to our `src/config.yml` file using the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了配置参数类，我们可以使用以下代码将数据库URL添加到我们的`src/config.yml`文件中：
- en: '[PRE63]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that we have access to our database URL, in the next step, we can build
    our database access layer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问数据库URL，在下一步中，我们可以构建我们的数据库访问层。
- en: Building our data access layer
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的数据访问层
- en: 'Our database access will be defined in the `src/data_access.py` file. Once
    this is done, we can import the data access layer from the `src/data_access.py`
    file anywhere in the Flask application. This is so that we can access the database
    anywhere inside the Flask application. We can build this by performing the following
    steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对数据库的访问定义在`src/data_access.py`文件中。一旦完成，我们就可以在任何Flask应用程序的位置导入数据访问层。这样我们就可以在Flask应用程序的任何地方访问数据库。我们可以通过以下步骤构建它：
- en: 'First of all, we have to import what we need using the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使用以下代码导入所需的模块：
- en: '[PRE64]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we will use the `_app_ctx_stack` object to ensure that our session is
    in the context of the Flask request. Following this, we import all of the other
    `sqlalchemy` dependencies to ensure that our access has a session maker and an
    engine. We have to avoid going into excessive detail with database management
    as this book focuses on fusing Rust with Python and we are merely using SQLAlchemy
    to explore database integration with Rust. However, we should be able to get a
    feel for what the session, engine, and base do.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`_app_ctx_stack`对象来确保我们的会话处于Flask请求的上下文中。在此之后，我们导入所有其他的`sqlalchemy`依赖项，以确保我们的访问有一个会话创建者和一个引擎。由于这本书的重点是融合Rust和Python，我们只是使用SQLAlchemy来探索Rust与数据库的集成，所以我们必须避免对数据库管理进行过多的细节描述。然而，我们应该能够感受到会话、引擎和基的作用。
- en: 'Now that we have imported everything we need, we can build our database engine
    using the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所有需要的，我们可以使用以下代码构建我们的数据库引擎：
- en: '[PRE65]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now we have a class that can give us database sessions, a database connection,
    and a base. However, it must be noted that we initiated the `DbEngine` class and
    assigned it to the `dal` variable; however, we didn't import the `DbEngine` class
    outside of this file. Instead, we import the `dal` variable to be used for interactions
    with the database. If we import the `DbEngine` class outside of this file during
    initiation and use it whenever we want to interact with the database, we will
    create multiple database sessions per request and these sessions will struggle
    to close. Even something as small as a couple of users will grind your database
    to a halt with too many hanging connections. Now that our database connection
    has been defined, in the next step, we can move on to build our database models.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个可以给我们数据库会话、数据库连接和基的类。然而，必须注意的是，我们初始化了`DbEngine`类并将其分配给`dal`变量；然而，我们没有在这个文件外部导入`DbEngine`类。相反，我们导入`dal`变量以用于与数据库的交互。如果我们在这个文件外部初始化时导入`DbEngine`类，并在需要与数据库交互时使用它，我们将为每个请求创建多个数据库会话，并且这些会话将难以关闭。现在我们的数据库连接已经定义，在下一步中，我们可以继续构建我们的数据库模型。
- en: 'In our database model, we can have a unique ID, input number, and fib number.
    Our model is defined in the `src/models/database/fib_entry.py` file with the following
    code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的数据库模型中，我们可以有一个唯一的ID、输入数字和斐波那契数字。我们的模型在`src/models/database/fib_entry.py`文件中定义，以下代码所示：
- en: '[PRE66]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, you can see that the code is straightforward. We pass `dal.base` through
    our model to add the model to the metadata. Then, we define the table name that
    will be in the database and model fields, which are `id`, `input_number`, and
    `calculated_number`. Our database model has now been defined, so we can import
    and use it throughout our application. Additionally, we will use this in the next
    step to manage the database migrations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到代码非常直接。我们将`dal.base`传递到我们的模型中，以便将模型添加到元数据中。然后，我们定义将在数据库中的表名以及模型字段，它们是`id`、`input_number`和`calculated_number`。我们的数据库模型现在已经定义好了，因此我们可以在整个应用程序中使用它。此外，我们将在下一步中使用这个来管理数据库迁移。
- en: Setting up the application database migration system
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序数据库迁移系统
- en: 'Migrations are a useful tool for keeping track of all the changes made to our
    database. If we make a change in a database model or define one, we need to translate
    those changes to our database. We can achieve this by performing the following
    steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是跟踪我们对数据库所做的所有更改的有用工具。如果我们对数据库模型进行更改或定义一个模型，我们需要将这些更改翻译到我们的数据库中。我们可以通过执行以下步骤来实现这一点：
- en: 'For our database management, we are going to lean on the `alembic` package.
    Once we have navigated inside the `src/` directory, we run the following command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的数据库管理，我们将依赖`alembic`包。一旦我们导航到`src/`目录内部，我们运行以下命令：
- en: '[PRE67]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we must import the `os` and `sys` modules, as we will be using them to
    import our models and load our configuration file. We import the modules using
    the following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须导入`os`和`sys`模块，因为我们将会使用它们来导入我们的模型和加载我们的配置文件。我们使用以下代码导入模块：
- en: '[PRE68]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Following this, we use the `os` module to append the path that is in the `src/`
    directory with the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们使用`os`模块将`src/`目录中的路径附加到以下代码：
- en: '[PRE69]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now that we have configured our import path, we can import our parameters and
    database engine. Then, we add our database URL to our `alembic` database URL using
    the following code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经配置了导入路径，我们可以导入我们的参数和数据库引擎。然后，我们使用以下代码将我们的数据库URL添加到`alembic`数据库URL中：
- en: '[PRE70]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'With this, you can observe that the autogenerated function gets our config,
    which then executes the migrations with the following code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以观察到自动生成的函数获取了我们的配置，然后执行以下代码进行迁移：
- en: '[PRE71]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now that we have our configuration system linked up to our database migrations,
    we have to make sure `docker-compose` is running because our database has to be
    live. We can generate a migration using the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将配置系统链接到我们的数据库迁移，我们必须确保 `docker-compose` 正在运行，因为我们的数据库必须是活跃的。我们可以使用以下命令生成迁移：
- en: '[PRE72]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: revision identifiers, used by Alembic.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修订标识符，由 Alembic 使用。
- en: Revision = '40b83d85c278'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Revision = '40b83d85c278'
- en: down_revision = None
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: down_revision = None
- en: branch_labels = None
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: branch_labels = None
- en: depends_on = None
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: depends_on = None
- en: 'def upgrade():'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def upgrade():'
- en: op.create_table('fib_entries',
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: op.create_table('fib_entries',
- en: sa.Column('id', sa.Integer(), nullable=False),
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sa.Column('id', sa.Integer(), nullable=False),
- en: sa.Column('input_number', sa.Integer(),\
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sa.Column('input_number', sa.Integer(),\
- en: nullable=True),
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nullable=True),
- en: sa.Column('calculated_number', sa.Integer(), \
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sa.Column('calculated_number', sa.Integer(), \
- en: nullable=True),
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nullable=True),
- en: sa.PrimaryKeyConstraint('id')
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sa.PrimaryKeyConstraint('id')
- en: )
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: 'def downgrade():'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def downgrade():'
- en: op.drop_table('fib_entries')
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: op.drop_table('fib_entries')
- en: '[PRE73]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: alembic upgrade head
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: alembic upgrade head
- en: '[PRE74]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: INFO  [alembic.runtime.migration] Context impl
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: INFO  [alembic.runtime.migration] Context impl
- en: PostgresqlImpl.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PostgresqlImpl.
- en: INFO  [alembic.runtime.migration] Will assume
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: INFO  [alembic.runtime.migration] 将假设
- en: transactional DDL.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事务性DDL。
- en: INFO  [alembic.runtime.migration] Running upgrade  ->
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: INFO  [alembic.runtime.migration] 正在运行升级 ->
- en: 40b83d85c278, create-fib-entry
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 40b83d85c278, create-fib-entry
- en: '[PRE75]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Our migration has worked. In the next step, we will interact with the database
    in our application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的迁移已成功。在下一步中，我们将在应用程序中与数据库进行交互。
- en: Building database models
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建数据库模型
- en: 'Now that we have a database that has our application models applied to it,
    we can interact with our database in the application. This can be done by importing
    our data access layer and data model into the view that is using them and, well,
    use them:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个应用了我们的应用程序模型的数据库，我们可以在应用程序中与之交互。这可以通过将数据访问层和数据模型导入使用它们的视图来完成，并且，嗯，使用它们：
- en: 'For our example, we will be implementing our view inside the `src/app/app.py`
    file. First, we import the data access layer and model using the following code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将在 `src/app/app.py` 文件中实现我们的视图。首先，我们使用以下代码导入数据访问层和模型：
- en: '[PRE76]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With these imports, we can alter our calculation view to check whether the number
    exists in the database and return the number from the database if it does.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这些导入，我们可以修改我们的计算视图以检查数字是否存在于数据库中，如果存在，则从数据库中返回该数字。
- en: 'If it is not available in the database, then we calculate it, save the result
    in the database, and return the result using the following code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数据库中没有可用，那么我们计算它，将结果保存到数据库中，并使用以下代码返回结果：
- en: '[PRE77]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, you can observe that our interactions with the database are straightforward.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以观察到我们与数据库的交互非常直接。
- en: 'Now we have to make sure that when our request has finished, our database sessions
    are expired, closed, and removed using the following code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须确保当我们的请求完成后，我们的数据库会话已过期、关闭并删除，使用以下代码：
- en: '[PRE78]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'So, we have a safe and fully functioning interaction with our database. You
    are now aware of the fundamentals of interacting with a database using our application.
    You can achieve other, more complex database queries by reading the SQLAlchemy
    documentation about the specifics of the database, other database queries, and
    insertions as a way to map syntax. If we run our application locally and hit our
    calculation view twice, we will get the first and second results, as shown in
    the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们与数据库的交互是安全且完全正常的。你现在已经了解了使用我们的应用程序与数据库交互的基础。你可以通过阅读 SQLAlchemy 文档中关于数据库、其他数据库查询和插入的特定语法来达到其他更复杂的数据库查询。如果我们在本地上运行我们的应用程序并两次点击计算视图，我们将得到第一次和第二次的结果，如下面的截图所示：
- en: '![Figure 9.5 – The top part is the first request (calculated), and the'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.5 – The top part is the first request (calculated), and the'
- en: bottom part is the second request (database call)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 底部部分是第二个请求（数据库调用）
- en: '](img/Figure_9.05_B17720.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.05_B17720.jpg)'
- en: Figure 9.5 – The top part is the first request (calculated), and the bottom
    part is the second request (database call)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.5 – 顶部部分是第一次请求（计算），底部部分是第二次请求（数据库调用）
- en: Our database is working the way we expect it to. Now the application is fully
    functioning, and you can move on to the next section if you wish, as this is enough
    to test Rust code in a Flask application, which we will do in the next chapter.
    However, if you want to understand how we apply the database in our deployment
    section, we will cover this next.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库正在按照我们预期的样子工作。现在应用程序已经完全运行，如果你愿意的话，可以继续到下一节，因为这样已经足够测试 Flask 应用程序中的 Rust
    代码了，我们将在下一章中这样做。然而，如果你想了解我们如何在部署部分应用数据库，我们将在下一节中介绍这一点。
- en: Applying the database access layer to the fib calculation view
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据库访问层应用于 fib 计算视图
- en: 'Adding a database to our deployment is a matter of adding it to our `docker-compose`
    deployment and updating our configuration file to map to the database service
    in the `docker-compose` deployment. We can achieve this by performing the following
    steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库添加到我们的部署中，就是将其添加到我们的 `docker-compose` 部署中，并更新我们的配置文件以映射到 `docker-compose`
    部署中的数据库服务。我们可以通过以下步骤实现这一点：
- en: 'First, we have to refactor our `deployment/docker-compose.yml` file using the
    following code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使用以下代码重构我们的 `deployment/docker-compose.yml` 文件：
- en: '[PRE79]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You can observe that we have a slightly different name for our database container.
    This is to ensure that there are no clashes with our development database. Additionally,
    we have declared that our Flask application is dependent on and linked to our
    database.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以观察到我们为数据库容器取了一个稍微不同的名字。这是为了确保不会与我们的开发数据库发生冲突。此外，我们还声明我们的 Flask 应用程序依赖于并链接到我们的数据库。
- en: 'We also have to point our Flask application to the Docker database. To do this,
    we have to have a different configuration file for our Flask application. We can
    manage the configuration file switch in `src/Dockerfile` for the Flask application.
    This can be done using the following code:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须将我们的 Flask 应用程序指向 Docker 数据库。为此，我们必须为 Flask 应用程序有一个不同的配置文件。我们可以通过在 Flask
    应用的 `src/Dockerfile` 中管理配置文件切换。这可以通过以下代码完成：
- en: '[PRE80]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we remove the `config.yml` file and then change the filename of the `live_config.yml`
    file to `config.yml`.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们删除了 `config.yml` 文件，然后将 `live_config.yml` 文件的名称更改为 `config.yml`。
- en: 'Then, we have to make our `src/live_config.yml` file with the following content:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须创建我们的 `src/live_config.yml` 文件，内容如下：
- en: '[PRE81]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, we have changed `@localhost` to `@postgres` because the classification
    of our service is called `postgres`.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将 `@localhost` 改为 `@postgres`，因为我们的服务分类名为 `postgres`。
- en: 'Following this, we can rebuild our Flask image using the following command:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们可以使用以下命令重新构建我们的 Flask 镜像：
- en: '[PRE82]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now we can run our `docker-compose` deployment, but we will have to run our
    migrations while our `docker-compose` deployment is running. This is because our
    Flask application will not cause an error if it is out of sync with the database
    until we try and make a query to the database, so running `docker-compose` before
    migrating is fine if we make no requests. When we make the migration, we must
    do this while the database in `docker-compose` is running; otherwise, the migration
    will not be able to connect to the database. We can run the migration while `docker-compose`
    is running using the following command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的 `docker-compose` 部署，但我们必须在 `docker-compose` 部署运行时运行我们的迁移。这是因为我们的
    Flask 应用程序在尝试对数据库进行查询之前不会引发错误，所以如果我们不发出请求，在迁移之前运行 `docker-compose` 是可以的。当我们进行迁移时，我们必须在
    `docker-compose` 运行时进行；否则，迁移将无法连接到数据库。我们可以在 `docker-compose` 运行时使用以下命令运行迁移：
- en: '[PRE83]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This runs the migrations on our Flask container. It is not advised that you
    only have your live configuration files within your application code. A favorite
    method of mine is to upload an encrypted configuration file in AWS S3 and pull
    it in Kubernetes as it starts up a pod. This is beyond the scope of this book,
    as this is not a web development book. However, it is important to keep methods
    such as this in mind for further reading if needed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的 Flask 容器上运行迁移。不建议你只将实时配置文件放在你的应用程序代码中。我偏爱的方法是将加密的配置文件上传到 AWS S3，并在 Kubernetes
    启动 pod 时拉取它。这超出了本书的范围，因为这不是一本关于网络开发的书籍。然而，如果需要的话，重要的是要记住这种方法，以便进一步阅读。
- en: Right now, there is not much to complain about when it comes to calculating
    Fibonacci numbers with our Flask application. However, when we try and calculate
    a large number, we will be waiting for a long time, and this will keep the request
    hanging. To prevent this from occurring, in the next section, we are going to
    implement a message bus. This is so that while our application is processing large
    numbers in the background, we can return a message telling the users to be patient.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，使用我们的Flask应用程序计算斐波那契数并没有太多可抱怨的。然而，当我们尝试计算一个大数时，我们将等待很长时间，这将使请求挂起。为了防止这种情况发生，在下一节中，我们将实现一个消息总线。这样，当我们的应用程序在后台处理大数时，我们可以返回一个消息告诉用户耐心等待。
- en: Building a message bus
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建消息总线
- en: 'For this section, we will be using the `Celery` and `Redis` packages to build
    and run our message bus. Once we have completed this section, our mechanism will
    take a form that is similar to the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将使用`Celery`和`Redis`包来构建和运行我们的消息总线。一旦我们完成本节，我们的机制将采取以下类似的形式：
- en: '![Figure 9.6 – A message bus with Flask and Celery'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.6 – A message bus with Flask and Celery]'
- en: '](img/Figure_9.06_B17720.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.06_B17720.jpg]'
- en: Figure 9.6 – A message bus with Flask and `Celery`
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 带有Flask和`Celery`的消息总线
- en: 'As shown in the preceding diagram, we have two processes running. One is running
    our Flask application, while the other is running `Celery`, which handles queuing
    and processing tasks. To make this work, we are going to perform the following
    steps:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有两个进程正在运行。一个是运行我们的Flask应用程序，另一个是运行`Celery`，它处理队列和任务处理。为了使这一切工作，我们将执行以下步骤：
- en: Build a `Celery` broker for Flask.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Flask构建`Celery`代理。
- en: Build a Fibonacci calculation task for **Celery**.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**Celery**构建一个斐波那契计算任务。
- en: Update our calculation view with `Celery`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Celery`更新我们的计算视图。
- en: Define our `Celery` service in Docker.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker中定义我们的`Celery`服务。
- en: 'Before we embark on these steps, we have to install the following packages
    using `pip`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始这些步骤之前，我们必须使用`pip`安装以下包：
- en: '`Celery`: This is the message bus broker that we are going to use.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Celery`：这是我们将要使用的消息总线代理。'
- en: '`Redis`: This is the storage system that `Celery` is going to use.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Redis`：这是`Celery`将要使用的存储系统。'
- en: Now that we have installed the requirements, we have to remember to update the
    `src/requirements.txt` file with `Celery` and Redis for our Docker builds. Now
    that we have all of our dependencies installed, we can start building our `Celery`
    broker, as demonstrated next.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有需求，我们必须记得使用`Celery`和Redis更新`src/requirements.txt`文件以供我们的Docker构建使用。现在我们已经安装了所有依赖项，我们可以开始构建我们的`Celery`代理，如下所示。
- en: Building a Celery broker for Flask
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Flask构建Celery代理。
- en: 'Essentially, our `Celery` broker is a storage system that will store data concerning
    the tasks we have sent to it. We can set up our storage system and connect it
    to our `Celery` system using the following steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们的`Celery`代理是一个存储系统，它将存储我们发送给它的任务相关数据。我们可以通过以下步骤设置我们的存储系统并将其连接到我们的`Celery`系统：
- en: 'We are going to build our own module when building our task queue. Inside the
    `src/` directory, our task queue module will take the following structure:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建我们的任务队列时，我们将构建自己的模块。在`src/`目录内，我们的任务队列模块将具有以下结构：
- en: '[PRE84]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Our `engine.py` file will host a constructor for `Celery` that considers the
    context of the Flask application.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`engine.py`文件将托管一个考虑Flask应用程序上下文的`Celery`构造函数。
- en: 'We will build our Fibonacci calculation `Celery` task in the `fib_calc_task.py`
    file. In our `engine.py` file, we can build our constructor using the following
    code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`fib_calc_task.py`文件中构建我们的斐波那契计算`Celery`任务。在我们的`engine.py`文件中，我们可以使用以下代码构建构造函数：
- en: '[PRE85]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `backend` and `broker` parameters will point to the storage; we will define
    them later. Here, you can observe that we must pass the Flask application into
    the function, construct the `Celery` class, and fuse a `Celery` task object with
    the Flask application context and then return it. When it comes to defining an
    entry point for running our `Celery` process, we should place it in the same file
    as our Flask application. This is because we want to use the same Docker build
    and, thus, image for the Flask application and `Celery` process.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`backend`和`broker`参数将指向存储；我们将在稍后定义它们。在这里，你可以观察到我们必须将Flask应用程序传递给函数，构建`Celery`类，并将`Celery`任务对象与Flask应用程序上下文融合，然后返回它。当涉及到定义运行我们的`Celery`进程的入口点时，我们应该将其放置在与我们的Flask应用程序相同的文件中。这是因为我们希望使用相同的Docker构建和图像来构建Flask应用程序和`Celery`进程。'
- en: 'To achieve this, we import our `Celery` constructor and pass the Flask application
    through it, in the `src/app.py` file, using the following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现这一点，我们在`src/app.py`文件中导入我们的`Celery`构造函数，并通过它传递Flask应用程序，使用以下代码：
- en: '[PRE86]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, when we run our `Celery` broker, we will point it at our `src/app.py`
    file and the `Celery` object inside it. Additionally, we must define our backend
    storage system. Because we are using Redis, we can define these parameters in
    our `src/config.yml` file using the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们运行我们的`Celery`代理时，我们将将其指向我们的`src/app.py`文件以及其中的`Celery`对象。此外，我们必须定义我们的后端存储系统。因为我们使用Redis，我们可以在`src/config.yml`文件中使用以下代码定义这些参数：
- en: '[PRE87]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now that we have defined our `Celery` broker, in the next step, we can build
    our Fibonacci calculation task.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的`Celery`代理，在下一步中，我们可以构建我们的Fibonacci计算任务。
- en: Building a Fibonacci calculation task for Celery
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Celery构建Fibonacci计算任务
- en: 'When it comes to running our `Celery` task, we need to build another constructor.
    However, instead of passing in our Flask application, we pass in our `Celery`
    broker. We can achieve this in the `src/task_queue/fib_calc_task.py` file using
    the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到运行我们的`Celery`任务时，我们需要构建另一个构造函数。然而，我们不是传递我们的Flask应用程序，而是传递我们的`Celery`代理。我们可以在`src/task_queue/fib_calc_task.py`文件中使用以下代码实现这一点：
- en: '[PRE88]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The preceding logic is like our standard calculation view. We can import it
    into our `src/app.py` file and pass our `Celery` broker to it using the following
    code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 上述逻辑类似于我们的标准计算视图。我们可以将其导入到我们的`src/app.py`文件中，并使用以下代码将我们的`Celery`代理传递给它：
- en: '[PRE102]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Now that we have our task defined and fused with our `Celery` broker and Flask
    application, in the next step, we can add our `Celery` task to the calculation
    view if the number is too large.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了任务，并将其与`Celery`代理和Flask应用程序融合，在下一步中，我们可以将我们的`Celery`任务添加到计算视图中，如果输入的数字太大。
- en: Updating our calculation view
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的计算视图
- en: 'With our view, we must check to see whether our input number is less than `31`
    and not in the database. If it is, we run our standard existing code. However,
    if the input number is `30` or above, we will send the calculation to the `Celery`
    broker and return a message telling the user that it has been sent to the queue.
    We can do this using the following code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的视图中，我们必须检查输入的数字是否小于`31`且不在数据库中。如果是这样，我们运行我们现有的标准代码。然而，如果输入的数字是`30`或更高，我们将计算发送到`Celery`代理，并返回一条消息告诉用户它已被发送到队列。我们可以使用以下代码完成此操作：
- en: '[PRE109]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Now our `Celery` process with our task has been fully built. In the next step,
    we will define our Redis service in `docker-compose`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全构建了带有任务的`Celery`进程。在下一步中，我们将在`docker-compose`中定义我们的Redis服务。
- en: Defining our Celery service in Docker
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Docker中定义我们的Celery服务
- en: 'When it comes to our `Celery` service, remember that we used Redis as a storage
    mechanism. Considering this, we define our Redis service in our developed `docker-compose.yml`
    file using the following code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到我们的`Celery`服务时，请记住我们使用了Redis作为存储机制。考虑到这一点，我们在开发的`docker-compose.yml`文件中定义我们的Redis服务，使用以下代码：
- en: '[PRE130]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Now running our whole system in develop mode requires running our developed
    `docker-compose` file at the root of our project. Additionally, we run the Flask
    application by running our `app.py` file with Python, where `PYTHONPATH` is set
    to `src`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以开发模式运行整个系统需要运行我们项目根目录下的开发`docker-compose`文件。此外，我们通过运行Python中的`app.py`文件来运行Flask应用程序，其中`PYTHONPATH`设置为`src`。
- en: 'Following this, we open another Terminal window, navigate the Terminal inside
    the `src` directory, and run the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们打开另一个终端窗口，导航到`src`目录内的终端，并运行以下命令：
- en: '[PRE136]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'This is where we point `Celery` to the `app.py` file. We state that the object
    is called `Celery`, that it is a worker, and that the logging is at the `info`
    level. Running this gives us the following printout:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将`Celery`指向`app.py`文件的地方。我们声明对象名为`Celery`，它是一个工作进程，日志级别为`info`。运行此命令会给出以下输出：
- en: '[PRE137]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The preceding printout shows us that our task has been registered and that
    four processes have been spun up. Hitting the calculation view with our `Celery`
    processes using a number higher than `30` gives us the following view:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示我们的任务已被注册，并且启动了四个进程。使用大于`30`的数字点击计算视图，我们得到以下视图：
- en: '![Figure 9.7 – The bottom shows the first request with Celery, and the top
    shows the'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.7 – 底部显示使用Celery的第一个请求，顶部显示使用Celery的请求]'
- en: second request with Celery
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Celery的第二次请求
- en: '](img/Figure_9.07_B17720.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.07_B17720.jpg](img/Figure_9.07_B17720.jpg)'
- en: Figure 9.7 – The bottom shows the first request with `Celery,` and the top shows
    the second request with `Celery`
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 底部显示的是使用 `Celery` 的第一个请求，顶部显示的是使用 `Celery` 的第二个请求
- en: Our Flask application with a database and `Celery` message bus is now fully
    working locally. You can stop here if you wish, as this is enough to test Rust
    code in `Celery` in the next chapter. However, if you want to learn how to apply
    `Celery` to the deployment section, continue with this section.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 Flask 应用程序与数据库和 `Celery` 消息总线完全在本地运行。如果您愿意，可以在这里停止，因为这对于在下一章测试 `Celery`
    中的 Rust 代码已经足够了。但是，如果您想学习如何将 `Celery` 应用于部署部分，请继续本节。
- en: 'Applying `Celery` to our `docker-compose` deployment is straightforward. Remember
    that we have the same entry point, so there is no need for a new image. Instead,
    all we have to do is change the command that we run when spinning up our `Celery`
    container. This can be done in our `deployment/docker-compose.yml` file using
    the following code:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Celery` 应用于我们的 `docker-compose` 部署很简单。记住，我们有一个相同的入口点，因此不需要新的镜像。我们只需更改启动我们的
    `Celery` 容器时运行的命令。这可以在我们的 `deployment/docker-compose.yml` 文件中使用以下代码完成：
- en: '[PRE164]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Here, you can observe that we pull the same image for our `queue_worker` service.
    However, we change the `CMD` tag in our Docker build using the `entrypoint` tag
    in `docker-compose`. So, when our `queue_worker` service is built, it will run
    the `Celery` command running the `Celery` workers, as opposed to running the Flask
    web application. Following this, we need to add some more parameters to our `live_config.yml`
    file using the following code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以观察到我们为我们的 `queue_worker` 服务拉取了相同的镜像。然而，我们使用 `docker-compose` 中的 `entrypoint`
    标签更改了 Docker 构建中的 `CMD` 标签。因此，当我们的 `queue_worker` 服务构建时，它将运行 `Celery` 命令来运行 `Celery`
    工作器，而不是运行 Flask 网络应用程序。在此之后，我们需要在 `live_config.yml` 文件中添加一些更多参数，如下所示：
- en: '[PRE183]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Here, we have named our Redis service as opposed to the localhost. This is so
    that our packaged `Celery` worker and Flask application will connect to our Redis
    service in the `docker-compose` deployment. After running the `docker-compose`
    deployment, we can repeat the requests demonstrated in *Figure 9.6* with `localhost`
    as opposed to `127.0.0.1:5002`. With this, our Flask application is ready to deploy
    with a database and task queue. Technically, our setup can be deployed and used
    on a server. I have done this, and it works just fine. However, for more advanced
    systems and control, it is advised that you carry out some further reading. Additional
    references about deploying Flask applications in Docker to cloud services such
    as Amazon Web Services are listed in the *Further reading* section.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的 Redis 服务命名为不同于 localhost。这样做是为了确保我们的打包 `Celery` 工作器和 Flask 应用程序在
    `docker-compose` 部署中连接到我们的 Redis 服务。运行 `docker-compose` 部署后，我们可以用 `localhost`
    代替 `127.0.0.1:5002` 重复 *图 9.6* 中展示的请求。有了这个，我们的 Flask 应用程序就准备好与数据库和任务队列一起部署了。技术上讲，我们的设置可以在服务器上部署和使用。我已经这样做过，并且一切正常。然而，对于更高级的系统和控制，建议您进行一些进一步的阅读。关于在
    Docker 中部署 Flask 应用程序到云服务（如 Amazon Web Services）的附加参考资料列在 *进一步阅读* 部分。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a Python Flask application that had access to a database
    and message bus to allow the queuing of heavy tasks in the background. Following
    this, we wrapped our services in Docker containers and deployed them in a simple
    `docker-compose` file with NGINX. Additionally, we learned how to build our `Celery`
    worker and Flask application in the same Dockerfile using the same build. This
    made our code easier to maintain and deploy. We also managed our migrations for
    our database using `alembic` and a configuration file, which was then switched
    to another configuration file when we were deploying our application. While this
    is not a web development textbook, we have covered all of the essentials when
    it comes to structuring a Flask web application.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个 Python Flask 应用程序，该应用程序可以访问数据库和消息总线，以便在后台排队处理重任务。在此之后，我们将我们的服务封装在
    Docker 容器中，并通过一个简单的 `docker-compose` 文件与 NGINX 部署。此外，我们还学会了如何使用相同的构建在同一 Dockerfile
    中构建我们的 `Celery` 工作器和 Flask 应用程序。这使得我们的代码更容易维护和部署。我们还使用 `alembic` 和配置文件管理我们的数据库迁移，然后在部署我们的应用程序时切换到另一个配置文件。虽然这不是一本网络开发教科书，但我们已经涵盖了构建
    Flask 网络应用程序的所有基本要素。
- en: Further details regarding database queries, data serialization, or HTML and
    CSS rendering are covered, in a straightforward manner, in the Flask documentation.
    We have covered all of the difficult stuff. Now, we can experiment with Rust and
    how it can be fused with a Python web application, not just in a development setting
    but a live setting where the application is running in a Docker container while
    communicating with other Docker containers. In the next chapter, we will fuse
    Rust with our Flask application. This is so that it can work with the development
    and deployment settings.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据库查询、数据序列化或 HTML 和 CSS 渲染的更多细节，在 Flask 文档中以简单的方式进行了介绍。我们已经涵盖了所有困难的部分。现在，我们可以尝试
    Rust 以及它如何与 Python 网络应用程序融合，不仅限于开发环境，还包括应用程序在 Docker 容器中运行并与其他 Docker 容器通信的实时环境。在下一章中，我们将
    Rust 与我们的 Flask 应用程序融合。这样，它就可以与开发和部署设置一起工作。
- en: Questions
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What do we change in the URI when we switch from development to deployment on
    `docker-compose` to communicate with another service?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们从开发环境切换到 `docker-compose` 上的部署环境以与另一个服务通信时，我们在 URI 中做了什么改变？
- en: Why do we use configuration files?
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么使用配置文件？
- en: Do we really need `alembic` to manage the database?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们真的需要 `alembic` 来管理数据库吗？
- en: What do we have to do to our database engine to ensure our database does not
    get flooded with hanging sessions?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对我们的数据库引擎做些什么，以确保数据库不会因悬挂会话而充满？
- en: Do we need Redis for our `Celery` worker process?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否需要 Redis 来管理我们的 `Celery` 工作进程？
- en: Answers
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We switch the `localhost` part of the URI to the tag of the `docker-compose`
    service.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 URI 中的 `localhost` 部分切换到 `docker-compose` 服务的标签。
- en: Configuration files enable us to switch contexts easily; for instance, switching
    from development to live. Additionally, if our `Celery` service needs to talk
    to a different database for some reason, this can be done with minimal effort;
    simply changing the configuration file will work. It is also a security issue.
    Hardcoding database URIs will expose these credentials to anyone who has access
    to the code and will be in the GitHub repository history. Store the configuration
    file in a different space such as AWS S3, which gets pulled when the service is
    deployed.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件使我们能够轻松切换上下文；例如，从开发环境切换到实时环境。此外，如果我们的 `Celery` 服务需要出于某种原因与不同的数据库通信，这可以以最小的努力完成；只需更改配置文件即可。这还是一个安全问题。硬编码数据库
    URI 将将这些凭证暴露给任何有权访问代码并位于 GitHub 仓库历史记录中的人。将配置文件存储在不同的空间，如 AWS S3，当服务部署时会被拉取。
- en: Technically, no. We can simply write SQL scripts and run them in sequence. When
    I was working in financial technology, this was actually a thing that we had to
    do. While this can give you more freedom, it does take more time and is more error-prone.
    Using `alembic` will save you time, errors, and work for pretty much most of your
    needs.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 技术上，不是的。我们只需简单地编写 SQL 脚本并按顺序运行它们。当我从事金融科技工作时，这实际上是我们必须做的事情。虽然这可以给你更多的自由，但它确实需要更多的时间，并且更容易出错。使用
    `alembic` 将为你节省时间、错误和大部分工作。
- en: We initiate our database engine once in the same file where our engine is defined.
    We never initiate it again, and we import this initiated engine anywhere we need.
    Not doing so will lead to our database to a grinding halt with dangling sessions
    and not very helpful error messages that will have you running around in circles
    on the internet with vague half-baked answers. Additionally, we have to close
    our sessions in the Flask teardown function for all requests.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在定义引擎的同一文件中初始化我们的数据库引擎一次。我们永远不会再次初始化它，并且在我们需要的地方导入这个初始化的引擎。不这样做会导致我们的数据库因悬挂会话而陷入停滞，并且会显示一些不太有帮助的错误信息，这些信息会让你在互联网上四处奔波，寻找模糊的半成品答案。此外，我们必须在
    Flask 的 teardown 函数中关闭所有请求的会话。
- en: Yes and no. We require a storage mechanism such as Redis; however, we can also
    use RabbitMQ or MongoDB instead of Redis if needed.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，也不是。我们需要一种存储机制，例如 Redis；然而，如果需要，我们也可以使用 RabbitMQ 或 MongoDB 来代替 Redis。
- en: Further reading
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Nginx HTTP Server – Fourth Edition: Harness the power of Nginx* by Fjordvald
    M. and Nedelcu C. (2018) (Packt)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Nginx HTTP 服务器 - 第四版：利用 Nginx 的力量》* by Fjordvald M. and Nedelcu C. (2018)
    (Packt)'
- en: 'The official Flask documentation – Pallets (2021): [https://flask.palletsprojects.com/en/2.0.x/](https://flask.palletsprojects.com/en/2.0.x/%0D)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Flask 文档 – Pallets (2021)：[https://flask.palletsprojects.com/en/2.0.x/](https://flask.palletsprojects.com/en/2.0.x/%0D)
- en: '*Hands-On Docker for Microservices with Python* by Jaime Buelta (2019) (Packt)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 实战 Docker 微服务》* by Jaime Buelta (2019) (Packt)'
- en: '*AWS Certified Developer – Associate Guide – Second Edition* by Vipul Tankariya
    and Bhavin Parmar (2019) (Packt)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS认证开发者 - 助理指南 - 第二版* 由Vipul Tankariya和Bhavin Parmar著（2019年）（Packt）'
- en: 'The SQLAlchemy query reference documentation (2021): [https://docs.sqlalchemy.org/en/14/orm/loading_objects.html](https://docs.sqlalchemy.org/en/14/orm/loading_objects.html%0D)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy查询参考文档（2021年）：[https://docs.sqlalchemy.org/en/14/orm/loading_objects.html](https://docs.sqlalchemy.org/en/14/orm/loading_objects.html%0D)
