- en: Packing Servers to Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务器打包到容器中
- en: 'Microservices created with Rust are pretty simple to deploy: it''s sufficient
    to build a binary for your server, upload that binary to your server, and start
    it. But that''s not a flexible approach for real applications. Firstly, your microservice
    may need files, templates, and configuration. On the other hand, you may want
    to use servers with different operating systems. In that case, you would have
    to build a binary for every system. To reduce the amount of issues with deployment,
    modern microservices are packed to containers and use virtualization to launch.
    Virtualization helps to simplify the deployment of a set of microservices. Also,
    it can help to scale a microservice, because to run an extra instance of a microservice
    you should only start another copy of the container.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rust 创建的微服务部署起来相当简单：只需为你的服务器构建一个二进制文件，将该二进制文件上传到服务器，然后启动它即可。但这并不是真实应用中的灵活方法。首先，你的微服务可能需要文件、模板和配置。另一方面，你可能希望使用不同操作系统的服务器。在这种情况下，你将不得不为每个系统构建一个二进制文件。为了减少部署中出现的问题，现代微服务被打包到容器中，并使用虚拟化来启动。虚拟化有助于简化一组微服务的部署。此外，它还可以帮助扩展微服务，因为要运行微服务的额外实例，你只需启动另一个容器副本即可。
- en: 'This chapter will immerse you in building Docker images with Rust microservices.
    We will look at the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带你沉浸于使用 Rust 微服务构建 Docker 镜像的过程。我们将探讨以下内容：
- en: Compiling microservices with Docker.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 编译微服务。
- en: Preparing a necessary Rust version in a container.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中准备必要的 Rust 版本。
- en: Reducing time spent building images with a Rust microservice. After we have
    prepared an image, we will create images for multiple microservices.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少使用 Rust 微服务构建镜像的时间。在我们准备好镜像后，我们将为多个微服务创建镜像。
- en: Creating a compose file for the Docker Compose utility to bootstrap a set of
    microservices to show how to run a complex project consisting of multiple microservices
    that interact with each other.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Docker Compose 工具创建一个 compose 文件，以引导一组微服务，展示如何运行由多个相互交互的微服务组成的复杂项目。
- en: Configuring a set of microservices and adding a database instance to let those
    microservices store persistent state to a database.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一组微服务并添加一个数据库实例，以便这些微服务可以将持久状态存储到数据库中。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires a full Docker installation with the Docker Compose utility.
    It doesn't require the Rust compiler, since we will build microservices with Docker
    containers, but it's good to have the nightly Rust compiler if you want to build
    and test any microservices locally or play with configuration parameters without
    patching the `docker-cocmpose.yml` file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要完整安装 Docker 并使用 Docker Compose 工具。由于我们将使用 Docker 容器构建微服务，因此不需要 Rust 编译器，但如果你想在本地构建和测试任何微服务或在不修改
    `docker-compose.yml` 文件的情况下调整配置参数，拥有 nightly Rust 编译器会更好。
- en: 'To install Docker, follow the instructions for your operating system here:
    [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Docker，请遵循此处针对您操作系统的说明：[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)。
- en: 'To install the Docker Compose utility, look at these docs: [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Docker Compose 工具，请查看以下文档：[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)。
- en: 'You can find the examples for this chapter in the `Chapter15` folder of the
    GitHub project: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 项目的 `Chapter15` 文件夹中找到本章的示例：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/)。
- en: Building a Docker image with a microservice
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用微服务构建 Docker 镜像
- en: In the first part of this chapter, we will build a Docker image with the necessary
    version of the Rust compiler and build an image with a compiled microservice.
    We will use a set of microservices from other chapters to show how to join microservices
    created with different frameworks. We will use the *users*, *emails*, and *content*
    microservices from [Chapter 9](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml),  *Simple
    REST Definition and Request Routing with Frameworks*and the *router* microservice
    from [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *In**volving Concurrency
    with Actors and Actix Crate*, and we'll also tune them to be configurable. Also,
    we will add a `dbsync` microservice, which will do all of the necessary migrations
    to a database, because we will use two microservices that use the database with
    the `diesel` crate and there will be a conflict if both microservices try to apply
    migrations for their own schema. That's because we'll use a single database, but
    if you use separate databases (not necessarily different database management applications,
    but only database files) for every microservice, you can use an individual migration
    set for every database. It's time to prepare an image with the nightly Rust compiler.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将构建一个带有必要版本的 Rust 编译器的 Docker 镜像，并构建一个带有编译微服务的镜像。我们将使用来自其他章节的一组微服务来展示如何将使用不同框架创建的微服务连接起来。我们将使用来自
    [第 9 章](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml) 的 *Simple REST Definition
    and Request Routing with Frameworks* 和 *emails*、*content* 微服务，以及来自 [第 11 章](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml)
    的 *Involving Concurrency with Actors and Actix Crate* 的 *router* 微服务，并且我们将调整它们以使其可配置。此外，我们还将添加一个
    `dbsync` 微服务，它将对数据库执行所有必要的迁移，因为我们将会使用两个使用 `diesel` crate 的数据库的微服务，如果两个微服务都尝试为其自己的模式应用迁移，将会发生冲突。那是因为我们将使用单个数据库，但如果你为每个微服务使用单独的数据库（不一定是不同的数据库管理应用程序，但只是数据库文件），你可以为每个数据库使用单独的迁移集。现在是准备带有夜间
    Rust 编译器的镜像的时候了。
- en: Creating an image with the Rust compiler
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 编译器创建镜像
- en: 'There are many ready-to-use images on Docker Hub. You can also find an official
    image here: [https://hub.docker.com/_/rust/](https://hub.docker.com/_/rust/).
    But we will create our own image since official images contain a stable compiler
    version only. If it''s enough for you, it''s better to use official images, but
    if you use crates such as `diesel`, which need the nightly version of the Rust
    compiler, you will have to build your own image to build microservices.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 上有许多现成的镜像。你还可以在这里找到官方镜像：[https://hub.docker.com/_/rust/](https://hub.docker.com/_/rust/)。但我们将创建自己的镜像，因为官方镜像只包含稳定的编译器版本。如果你觉得足够用，使用官方镜像会更好，但如果你使用像
    `diesel` 这样的需要 Rust 编译器夜间版本的 crate，你将不得不构建自己的镜像来构建微服务。
- en: 'Create a new `Dockerfile` and add the following content to it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `Dockerfile` 并向其中添加以下内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I''ve borrowed this `Dockerfile` from the official Rust Docker image located
    here: [https://github.com/rust-lang-nursery/docker-rust-nightly/blob/master/nightly/Dockerfile](https://github.com/rust-lang-nursery/docker-rust-nightly/blob/master/nightly/Dockerfile).
    This file is a good starting point for good practices when creating images with
    the Rust compiler.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我从官方的 Rust Docker 镜像中借用了这个 `Dockerfile`，位于此处：[https://github.com/rust-lang-nursery/docker-rust-nightly/blob/master/nightly/Dockerfile](https://github.com/rust-lang-nursery/docker-rust-nightly/blob/master/nightly/Dockerfile)。这个文件是使用
    Rust 编译器创建镜像时良好实践的起点。
- en: Our Rust image is based on the `buildpack-deps` image, which contains all of
    the necessary dependencies commonly used by developers. This dependency is indicated
    in the first line with the `FROM` command.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Rust 镜像是基于 `buildpack-deps` 镜像的，它包含了开发者常用到的所有必要依赖。这个依赖在第一行通过 `FROM` 命令指示。
- en: '`buildpack-deps` is an official Docker image based on Ubuntu (a free open-source
    Linux distribution based on Debian). The image includes a lot of headers for libraries
    such as OpenSSL and curl, and packages with all of the necessary certificates,
    and so on. It''s very useful as a build environment for your Docker images.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildpack-deps` 是基于 Ubuntu（基于 Debian 的免费开源 Linux 发行版）的官方 Docker 镜像。该镜像包含 OpenSSL
    和 curl 等库的大量头文件，以及包含所有必要证书的软件包等。它作为 Docker 镜像的构建环境非常有用。'
- en: 'The next line, which contains the `ENV` command, sets three environment variables
    in the image:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个包含 `ENV` 命令的行，在镜像中设置了三个环境变量：
- en: '`RUSTUP_HOME`: Sets the root folder of the `rustup` utility, which contains
    a configuration and installs toolchains'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUSTUP_HOME`：设置 `rustup` 工具的根文件夹，其中包含配置并安装工具链'
- en: '`CARGO_HOME`: Contains cached files used by the `cargo` utility'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CARGO_HOME`：包含 `cargo` 工具使用的缓存文件'
- en: '`PATH`: The system environment variable that contains paths to executable binaries'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH`：包含可执行二进制文件路径的系统环境变量'
- en: We target all utilities to the `/usr/local` folder by setting these environment
    variables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置这些环境变量将所有实用程序目标文件夹设置为`/usr/local`。
- en: We use the `rustup` utility here to bootstrap the Rust environment. It's an
    official Rust installation tool that helps you to maintain and keep multiple Rust
    installations up-to-date. In my opinion, using `rustup` is the best way to install
    Rust locally or in a container.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`rustup`实用程序来初始化Rust环境。它是一个官方的Rust安装工具，可以帮助您维护和保持多个Rust安装的更新。在我看来，使用`rustup`是本地或容器中安装Rust的最佳方式。
- en: 'The last `Dockerfile` command, `RUN`, is complex and we will analyze this set
    of commands line by line. The first shell command is the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个`Dockerfile`命令，`RUN`，很复杂，我们将逐行分析这组命令。第一个shell命令如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since the default shell in Ubuntu is the Bash shell, we can set three useful
    flags:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ubuntu的默认shell是Bash shell，我们可以设置三个有用的标志：
- en: '`-e`: This flag tells the shell to run the next line (command) only if the
    previous one finished successfully'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`：此标志告诉shell仅在上一条命令成功完成后才运行下一条（命令）'
- en: '`-u`: With this flag, the shell will print an error to `stderr` if the command
    tries to expand a variable that is not set'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`：使用此标志，如果命令尝试展开未设置的变量，shell将打印错误到`stderr`'
- en: '`-x`: With this flag, the shell will print every command to `stderr` before
    running it'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`：使用此标志，shell将在运行之前将每个命令打印到`stderr`'
- en: 'The next three lines download the `rustup-init` binary and set the executable
    flag to the downloaded file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行下载`rustup-init`二进制文件，并将可执行标志设置为下载的文件：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next pair runs the`rustup-init` command with parameters and removes the
    binary after running:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个对运行`rustup-init`命令带有参数，并在运行后删除二进制文件的配对：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following flags were used:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标志被使用：
- en: '`-y`: Suppresses any confirmation prompts'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-y`：抑制任何确认提示'
- en: '`--no-modify-path`: Won''t modify the `PATH` environment variable (we set it
    manually before, for the image)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-modify-path`：不会修改`PATH`环境变量（我们之前手动设置过，用于镜像）'
- en: '`--default-toolchain`: The type of the default toolchain (we will use `nightly`)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--default-toolchain`：默认工具链的类型（我们将使用`nightly`）'
- en: 'The remaining lines set write permissions to the `RUSTUP_HOME` and `CARGO_HOME`
    folders and print the version for all the installed tools:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的行设置`RUSTUP_HOME`和`CARGO_HOME`文件夹的写权限，并打印所有已安装工具的版本：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now you can build the `Dockerfile` to get an image that contains the preconfigured
    Rust compiler:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以构建`Dockerfile`以获取包含预配置Rust编译器的镜像：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This command takes some time to complete, but after it has finished, you will
    have an image that you can use as a base for building images for microservices.
    If you type the `docker images` command, you will see something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令需要一些时间才能完成，但完成后，您将拥有一个可以用于构建微服务镜像的镜像。如果您输入`docker images`命令，您将看到如下内容：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we will use the image tagged as `rust:nightly` and create images for microservices
    from it. Let's start by creating an image for the users microservice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用标记为`rust:nightly`的镜像，并从中创建微服务的镜像。让我们先为用户微服务创建一个镜像。
- en: Users microservice image
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户微服务镜像
- en: The users microservice provides users with registration capabilities. This chapter
    contains a modified version of the users microservice from [Chapter 9](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml), 
    *Simple REST Definition and Request Routing with Frameworks*. Since this service
    requires a database and uses the `diesel` crate to interact with it, we need to
    use the `diesel.toml` config in the process of building the image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户微服务为用户提供注册功能。本章包含来自[第9章](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml)的修改版用户微服务，*使用框架进行简单的REST定义和请求路由*。由于此服务需要数据库并使用`diesel`包与之交互，我们需要在构建镜像的过程中使用`diesel.toml`配置文件。
- en: .dockerignore
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .dockerignore
- en: 'Since Docker copies all files from the building folder, we have to add the `.dockerignore`
    file that contains the patterns of paths to avoid copying these files. It''s useful,
    for example, to skip the `target` building folder, because it may contain gigabytes
    of data for large projects, but in any case, we don''t need all of them since
    we''ll build a microservice using the image with the Rust compiler. Add the `.dockerignore`
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker会复制构建文件夹中的所有文件，我们必须添加包含要避免复制的路径模式的`.dockerignore`文件。例如，跳过`target`构建文件夹是有用的，因为它可能包含大型项目数GB的数据，但无论如何，我们不需要所有这些，因为我们将会使用带有Rust编译器的镜像来构建微服务。添加`.dockerignore`文件：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will ignore all Rust''s build artifacts (such as the `target`, `Cargo.lock`,
    and `*.bk` files that are produced by the `rustfmt` tool that we will use later)
    in the next chapter, where we will explore continuous integration tools. We also
    included two patterns: `files`—this folder will be created by this microservice
    to store files if you try to run it locally, and `*.db`—not a necessary pattern
    for SQLite Database, because this version uses PostgreSQL instead of SQLite, but
    useful if you want to support both databases for testing reasons later.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将忽略所有Rust的构建工件（例如`target`、`Cargo.lock`和`rustfmt`工具产生的`*.bk`文件等），我们将探索持续集成工具。我们还包含了两个模式：`files`——如果尝试在本地运行，这个文件夹将由微服务创建来存储文件，`*.db`——对于SQLite数据库来说，这不是一个必要的模式，因为此版本使用的是PostgreSQL而不是SQLite，但如果以后出于测试原因想要支持两种数据库，则很有用。
- en: Dockerfile
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile
- en: 'Now everything is ready to build and pack the microservice to an image. To
    do this, add the `Dockerfile` file to the folder with the microservice and add
    the following lines to it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以构建并将微服务打包到镜像中。为此，将`Dockerfile`文件添加到包含微服务的文件夹中，并在其中添加以下行：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We created the image based on the `rust:nightly` images that we created earlier
    in this chapter. We set it using the `FROM` command. The next line creates a new
    crate:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于本章早期创建的`rust:nightly`镜像创建了该镜像。我们使用`FROM`命令设置了它。下一行创建了一个新的crate：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You might ask why we did that and didn''t use an existing crate. That''s because
    we will reproduce the creation of the crate inside the container to build dependencies
    first, to avoid the lengthy process of rebuilding them, when you would add any
    tiny change to the source code of the microservice. This approach will save you
    a lot of time. Copy `Cargo.toml` to the image and build all of the dependencies
    without the sources of the microservice (since we have not copied them yet):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我们为什么这样做而没有使用现有的crate。那是因为我们将在容器内部重现crate的创建过程，首先构建依赖项，以避免在添加任何微服务源代码的微小更改时重建它们的漫长过程。这种方法将为你节省大量时间。将`Cargo.toml`复制到镜像中，并构建所有依赖项，而不包括微服务的源代码（因为我们还没有复制它们）：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next set of commands adds sources and the `diesel.toml` file to the image,
    removes previous build results, and builds the crate again with the new sources:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令集将源代码和`diesel.toml`文件添加到镜像中，删除之前的构建结果，并使用新源代码重新构建crate：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At this moment, the image contains a binary of a microservice that we can use
    as a starting command for containers:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时刻，这个镜像包含了一个微服务的二进制文件，我们可以将其用作启动容器的起始命令：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, a container doesn''t open a port and you can''t connect to it with
    another container or forward the port of a container to a local port. Since our
    microservice starts at port 8000, we have to expose it using the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器不会打开端口，你不能通过另一个容器连接到它，也不能将容器的端口转发到本地端口。由于我们的微服务从端口8000开始，我们必须使用以下命令来暴露它：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The image is ready to build and run a container. Let's do it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像已准备好构建和运行容器。让我们开始吧。
- en: Building an image
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'We have prepared the Dockerfile to build an image that first builds all the
    dependencies for our microservice and then builds all the source code. To start
    this process, you have to use the Docker `build` command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了Dockerfile来构建一个镜像，该镜像首先构建我们微服务的所有依赖项，然后构建所有源代码。要启动这个过程，你必须使用Docker的`build`命令：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you run this command, you will see how Docker prepares files to build
    an image and builds all the dependencies, but only for the empty crate without
    the sources of a microservice:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，你会看到Docker如何准备文件来构建镜像，并构建所有依赖项，但只针对没有微服务源代码的空crate：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our image needs 12 steps in total to build the microservice. As you can see,
    the building of dependencies takes two and a half minutes. It''s not fast. But
    we don''t need to repeat this step till `Cargo.toml` has changed. The next steps
    copy the source code of the microservices into a container and build them with
    prebuit dependencies:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的镜像总共需要12个步骤来构建微服务。正如你所见，依赖项的构建需要两分半钟。这并不快。但我们不需要重复这个步骤，直到`Cargo.toml`发生变化。接下来的步骤将微服务的源代码复制到容器中，并使用预构建的依赖项构建它们：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see in the output, building the microservice takes just 5 seconds.
    It's fast enough and you can rebuild it as many times as you want. Since the image
    has been built, we can start a container with our microservice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，构建微服务只需5秒钟。这足够快，你可以根据需要重新构建它多次。由于镜像已经构建，我们可以启动一个包含微服务的容器。
- en: Starting a container
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动容器
- en: 'The image we built has been stored in Docker and we can see it using the `docker
    images` command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的镜像已经存储在Docker中，我们可以使用`docker images`命令查看它：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To start the microservice from an image, use the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要从镜像中启动微服务，请使用以下命令：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The container with the microservice instance will start but it won't work since
    we haven't run a container with a database instance. We won't connect containers
    manually, since it's part of the subtleties of Docker usage, and you can read
    about that in Docker's documentation; however, we will learn how to connect containers
    with the Docker Compose tool later in this chapter, in the *Composing a microservice
    set* section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 带有微服务实例的容器将启动，但它不会工作，因为我们还没有运行一个带有数据库实例的容器。我们不会手动连接容器，因为这属于Docker使用的细微之处，你可以在Docker的文档中了解更多信息；然而，我们将在本章后面的*组合微服务集*部分学习如何使用Docker
    Compose工具连接容器。
- en: 'You might also ask: Why is our microservice so big? We will try to reduce it
    later in this chapter. But now we should pack other microservices to images.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会问：为什么我们的微服务这么庞大？我们将在本章后面尝试减小它。但现在我们应该将其他微服务打包到镜像中。
- en: Content microservice image
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容微服务镜像
- en: 'The second microservice we will use is the content microservice that we created
    in [Chapter 9,](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml) *Simple REST Definition
    and Request Routing with Frameworks*. We also prepared this service for use with
    the PostgreSQL database. We borrowed the `dockerignore` file from the previous
    example and adapted the `Dockerfile` file for this microservice. Look at the following
    code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的第二个微服务是我们在[第9章](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml)，*使用框架进行简单的REST定义和请求路由*中创建的内容微服务。我们还为使用PostgreSQL数据库准备了这项服务。我们从上一个示例中借用了`dockerignore`文件，并为此微服务修改了`Dockerfile`文件。请看以下代码：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, this `Dockerfile` is the same as the `Dockerfile` of the previous
    image, but it has one difference: it doesn''t copy any configuration files. We''ll
    are using the Rocket framework, but we will set all the parameters using the environment
    variables in the Docker Compose file.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个`Dockerfile`与上一个镜像的`Dockerfile`相同，但它有一个区别：它没有复制任何配置文件。我们将使用Rocket框架，但我们将使用Docker
    Compose文件中的环境变量设置所有参数。
- en: 'You can build this image with the following command to check how it works:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令构建此镜像以检查其工作情况：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But it's not necessary to build this image, because we won't start containers
    manually—we will use Docker Compose. Let's pack an email microservice to an image
    too.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但构建这个镜像并不是必要的，因为我们不会手动启动容器——我们将使用Docker Compose。让我们也将一个邮件微服务打包到镜像中。
- en: Email microservice image
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件微服务镜像
- en: 'The email microservice doesn''t use the `diesel` crate and we can use the official
    Rust image to build a microservice. Also, the email microservice has templates
    that are used to prepare the contents of emails. We will use the same `.dockerignore`
    file, but will copy `Dockerfile` from the previous example and add some changes
    related to the email microservice:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件微服务不使用`diesel`crate，我们可以使用官方的Rust镜像来构建微服务。此外，邮件微服务有模板，用于准备电子邮件的内容。我们将使用相同的`.dockerignore`文件，但会从上一个示例中复制`Dockerfile`并添加一些与邮件微服务相关的更改：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We created this image from the `rust:1.30.1` image. The stable version of the
    compiler is suitable to compile this simple microservice. We also added a command
    to copy all the templates into the image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是从`rust:1.30.1`镜像创建了这个镜像。编译器的稳定版本适合编译这个简单的微服务。我们还添加了一个命令，将所有模板复制到镜像中：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we can prepare the image with the router microservice.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以准备带有路由微服务的镜像。
- en: Router microservice image
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由微服务镜像
- en: 'If you remember, we created the router microservice in [Chapter 11,](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml) *Involving
    Concurrency with Actors and the Actix Crate, *where we explored features of the
    Actix framework. We adapted the router microservice to work with other microservices—we
    added a `Config` and a `State` that share configuration values with handlers.
    Also, the improved router microservice serves assets that are in the static folder.
    We also have to copy this folder to an image. Look at the `Dockerfile` of the
    router microservice:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们在[第11章](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml)，*使用Actors和Actix
    Crate涉及并发*中创建了路由微服务，我们探索了Actix框架的功能。我们将路由微服务修改为与其他微服务一起工作——我们添加了一个`Config`和一个`State`，它们与处理器共享配置值。此外，改进后的路由微服务还服务于静态文件夹中的资源。我们还需要将这个文件夹复制到镜像中。请看路由微服务的`Dockerfile`：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We also used the official Rust image with the stable compiler. The one difference
    you will notice in comparison with the previous example is copying the `static`
    folder into an image. We use the same `.dockerignore` file as we used for the
    previous examples.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了官方的Rust镜像和稳定的编译器。与之前的例子相比，你将注意到的唯一区别是将`static`文件夹复制到镜像中。我们使用了与之前例子相同的`.dockerignore`文件。
- en: We have built images for all of the microservices, but the last element we need
    to add is a worker that will apply migrations to a database. We will use it with
    Docker Compose later to apply all migrations automatically. Let's create this
    Docker image.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为所有微服务构建了镜像，但我们还需要添加一个将迁移应用到数据库的工作者。我们稍后将会使用Docker Compose来自动应用所有迁移。让我们创建这个Docker镜像。
- en: DBSync worker image
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DBSync工作者镜像
- en: The DBSync worker has only one function—waiting for a connection with the database
    and applying all migrations. We'll also pack this worker to a Docker image to
    use it in a compose file that we will create in the next section of this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: DBSync工作者的唯一功能是等待与数据库的连接并应用所有迁移。我们也将这个工作者打包到Docker镜像中，以便在下一节中我们将创建的compose文件中使用。
- en: Dependencies
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'The worker needs the following dependencies:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者需要以下依赖项：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We need the `diesel` crate with `diesel_migrations` to embed all the migrations
    into the code. It's not necessary, but useful. We need the `config` and `serde`
    crates to configure the worker. The other crates are more common and you can see
    how we used them in the previous chapters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`diesel` crate的`diesel_migrations`来将所有迁移嵌入到代码中。这不是必需的，但很有用。我们需要`config`和`serde`
    crate来配置工作者。其他crate更常见，你可以在之前的章节中看到我们如何使用它们。
- en: 'Add those dependencies to `Cargo.toml` and import the types that we will use
    in the `main` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些依赖项添加到`Cargo.toml`并导入在`main`函数中将使用的类型：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now let's create code that will wait for a connection to the database and apply
    all embedded migrations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一段代码，它将等待数据库连接并应用所有嵌入的迁移。
- en: The main function
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'Before we create the main function, we have to embed migrations using the `embed_migrations!`
    macro call:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建主函数之前，我们必须使用`embed_migrations!`宏调用嵌入迁移：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This call creates an `embedded_migrations` module, which contains the `run`
    function, which applies all migrations to a database. But before we use it, let''s
    add the `Config` struct to read the database connection link from a configuration
    file or an environment variable using the `config` crate:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用创建了一个`embedded_migrations`模块，其中包含一个`run`函数，该函数将所有迁移应用到数据库。但在我们使用它之前，让我们添加`Config`结构体来从配置文件或环境变量中读取数据库连接链接，使用`config`
    crate：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This struct contains only a single parameter—the optional `String` with a connection
    link to the database. We will set this parameter later with Docker Compose using
    the `DBSYNC_DATABASE` environment variable. We have added the `DBSYNC` prefix
    in the `main` function. Look at the full code of the `main` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体只包含一个参数——一个可选的`String`类型的数据库连接链接。我们稍后将会使用Docker Compose设置这个参数，通过`DBSYNC_DATABASE`环境变量。我们在`main`函数中添加了`DBSYNC`前缀。查看`main`函数的完整代码：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we initialized `env_logger` to print information to strerr.
    After, we created a generic `Config` instance from the `config` module and merged
    environment variables with the `DBSYNC` prefix. If the config merged successfully,
    we try to convert it to a value of our own `Config` type that we declared before.
    We'll use a config to extract a link of a connection to the database. If the value
    is not provided, we will use the `postgres://localhost/` link.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们初始化了`env_logger`以将信息打印到stderr。之后，我们从一个`config`模块创建了一个通用的`Config`实例，并使用`DBSYNC`前缀合并环境变量。如果配置合并成功，我们尝试将其转换为之前声明的我们自己的`Config`类型的值。我们将使用配置来提取数据库连接的链接。如果没有提供值，我们将使用`postgres://localhost/`链接。
- en: When a connection link is ready, we use a loop to try to connect to the database.
    We will try to connect to it until it succeeds, because we will use this worker
    with Docker Compose, and despite the fact we will start a container with the database,
    it can be unavailable when a database instance is starting. We use a loop to wait
    for the connection to be ready.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接链接就绪时，我们使用循环尝试连接到数据库。我们将尝试连接，直到成功为止，因为我们将会使用这个工作者与Docker Compose一起使用，尽管我们将启动一个包含数据库的容器，但在数据库实例启动时，它可能不可用。我们使用循环等待连接就绪。
- en: When the connection is ready, we use it to apply embedded migrations with the `run`
    method of the `embedded_migrations` module. After the migrations have been applied,
    we break the loop and stop the worker.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接就绪时，我们使用它通过`embedded_migrations`模块的`run`方法应用内嵌迁移。在迁移应用后，我们打破循环并停止工作进程。
- en: We have all the microservices ready to launch, but their disadvantage is that
    their source code also remains in the image. This is not good if we want to hide
    the implementation details of our microservices. Let's explore a technique that
    hides the sources of microservices using the image building cache.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了所有微服务以供启动，但它们的缺点是它们的源代码也保留在镜像中。如果我们想隐藏微服务的实现细节，这就不太好了。让我们探索一种使用镜像构建缓存隐藏微服务源的技术。
- en: Hiding microservice source code
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏微服务源代码
- en: The main drawback of building microservices inside an image is that all of the
    sources and build artifacts will be available for anyone who has access to a Docker
    image. If you want to remove sources and other building artifacts, you can use
    one of two approaches.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像内构建微服务的主要缺点是，所有源代码和构建工件都将对任何有权访问Docker镜像的人可用。如果你想删除源代码和其他构建工件，你可以使用两种方法之一。
- en: The first approach is to build all sources using a Docker image with the Rust
    compiler, providing access to sources through a linked virtual volume. In Docker,
    you can map any local folder to a volume inside a container using the `-v` argument
    of the `docker run` command. The disadvantage of this approach is that Docker
    uses another ID inside the container that you have in your local session. It can
    create files you can't delete without changing the user ID. Also, this approach
    is harder to maintain. But it's useful if you need the result of compilation only.
    If you plan to run a microservice inside a container, it's better to build everything
    inside an image.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一种方法是通过带有Rust编译器的Docker镜像构建所有源代码，通过链接虚拟卷提供对源代码的访问。在Docker中，你可以使用`docker run`命令的`-v`参数将任何本地文件夹映射到容器内的一个卷。这种方法的不利之处在于，Docker在容器内使用另一个ID，这与你在本地会话中的ID不同。它可能会创建你无法删除的文件，除非更改用户ID。此外，这种方法更难维护。但如果只需要编译结果，它是有用的。如果你计划在容器内运行微服务，最好在镜像内构建一切。
- en: 'The second approach involves building everything with Docker, but using a building
    cache to get the compilation result and putting it into a newly created container.
    Let''s explore the `Dockerfile` that implements this approach:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种方法涉及使用Docker构建一切，但使用构建缓存来获取编译结果并将其放入新创建的容器中。让我们探索实现此方法的`Dockerfile`：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We used the `Dockerfile` of the dbsync microservice and the first part of the
    file was the same as the original with one small improvement—we set that name
    as an image we built in the first line:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了dbsync微服务的`Dockerfile`，文件的第一部分与原始文件相同，但有一个小的改进——我们将该名称设置为我们在第一行构建的镜像：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now we can use the cached data of the image using the `builder` name.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`builder`名称来使用镜像的缓存数据。
- en: 'After this section, we start a new empty image from the `buildpack-deps` image
    that was originally used to build the preceding `rust:nightly` image. We copy
    a binary executable file from the builder image using the `COPY` command with
    the `--from` parameter where we set the name of the image:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节之后，我们从一个原本用于构建前面的`rust:nightly`镜像的`buildpack-deps`镜像开始创建一个新的空镜像。我们使用带有`--from`参数的`COPY`命令从构建镜像中复制一个可执行二进制文件，其中我们设置了镜像的名称：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This command copies the binary to the `/app` folder inside the image and we
    can use it as the entry point of the container:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将二进制文件复制到镜像内部的`/app`文件夹中，我们可以将其用作容器的入口点：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We also set the `RUST_LOG` environment variable and expose the port. Build this
    image by passing the name of this `Dockerfile` with the `-f` argument of the Docker
    build command and you will get an image with a single binary of the microservice
    inside. In other words, this approach allows us to build a microservice and reuse
    the compiled binary for a new image. You now know enough to pack your microservices
    to an image and now we can explore Docker Compose's ability to start a set of
    microservices and connect all launched containers to each other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了`RUST_LOG`环境变量并公开了端口。通过传递此`Dockerfile`的名称并使用Docker构建命令的`-f`参数来构建此镜像，你将得到一个包含微服务单个二进制文件的镜像。换句话说，这种方法允许我们构建微服务并重新使用编译的二进制文件来创建新镜像。你现在已经知道足够的信息来将微服务打包到镜像中，现在我们可以探索Docker
    Compose启动一组微服务并将所有启动的容器相互连接的能力。
- en: Composing a microservice set
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合微服务集
- en: Docker Compose is an awesome tool for deploying and running a set of microservices
    that can be connected each other. It helps you to define a multi-container application
    with configuration parameters in a human-readable YAML file. You are not limited
    to local deployment only and you can deploy it on a remote server on which the
    Docker daemon is also running.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是一个部署和运行一组可以相互连接的微服务的出色工具。它帮助你在可读的YAML文件中定义具有配置参数的多容器应用程序。你不仅限于本地部署，还可以在Docker守护进程也在运行的远程服务器上部署它。
- en: In this section of the chapter, we will pack all our microservices with a database
    into a single application. You will learn how to set variables for Rust frameworks
    and loggers, how to connect microservices, how to define the order to start containers,
    how to read the logs of a running application, and how to use different configurations
    for testing and production.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一节中，我们将所有包含数据库的微服务打包成一个单一的应用程序。你将学习如何为Rust框架和日志记录器设置变量，如何连接微服务，如何定义启动容器的顺序，如何读取运行中的应用程序的日志，以及如何为测试和生产使用不同的配置。
- en: Application definition
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序定义
- en: 'Docker Compose is a tool that works with the YAML definition of an application.
    A YAML file can contain a declaration of containers, networks, and volumes. We
    will use version `3.6`. Create a `docker-compose.test.yml` file and add the following
    sections:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是一个与应用程序的YAML定义一起工作的工具。一个YAML文件可以包含容器、网络和卷的声明。我们将使用版本`3.6`。创建一个`docker-compose.test.yml`文件并添加以下部分：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `services` section, we will add all our microservices. Let's look at
    each container configuration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`services`部分，我们将添加所有我们的微服务。让我们看看每个容器配置。
- en: Database container
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库容器
- en: 'Our application needs a database instance. Both user and content microservices
    use the PostgreSQL database, and the dbsync worker applies all migrations if necessary.
    Look at these settings:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要一个数据库实例。用户和内容微服务都使用PostgreSQL数据库，dbsync工作器在必要时应用所有迁移。查看以下设置：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use the official PostgreSQL image. If the database fails, it will have to
    be restarted. We set the `restart` policy to `always`, which means the container
    will be restarted if it fails. We also set the user and password with environment
    variables.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用官方的PostgreSQL镜像。如果数据库失败，它也需要重启。我们将`restart`策略设置为`always`，这意味着如果容器失败，它将被重启。我们还使用环境变量设置了用户名和密码。
- en: Since we created a compose file for testing purposes, we forward a port of the
    container outside to connect to the database using the local client.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了用于测试目的的compose文件，我们将容器的一个端口转发到外部，以便使用本地客户端连接到数据库。
- en: A container with an email server
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个带有电子邮件服务器的容器
- en: 'We need the SMTP server for our mailer service. We use the `juanluisbaptiste/postfix`
    image with the Postfix mail server. The server also has to be restarted if it
    fails and we set the `restart` policy to `always`. Look at the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要SMTP服务器来为我们的邮件服务。我们使用带有Postfix邮件服务器的`juanluisbaptiste/postfix`镜像。如果服务器失败，它也需要重启，我们将`restart`策略设置为`always`。查看以下代码：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We also configure the server using the environment variables and set the server
    name, username, password, and a hostname. To test the mail server, we forward
    port `25` of the mail server to a local `2525` port.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用环境变量配置服务器，并设置了服务器名称、用户名、密码和主机名。为了测试邮件服务器，我们将邮件服务器的端口`25`转发到本地的`2525`端口。
- en: DBSync worker container
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DBSync工作容器
- en: Now we can add the dbsync worker that applies migrations to a database instance.
    We use a local image that will be built with `Dockerfile` from the `./microservices/dbsync`
    folder that we used as a value for the `build` parameter. This worker depends
    on a database container (called `db`) and we set this dependency with the `depends_on`
    parameter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加应用到数据库实例的dbsync工作器。我们使用一个本地镜像，该镜像将使用`./microservices/dbsync`文件夹中的`Dockerfile`构建，我们将其用作`build`参数的值。这个工作器依赖于一个数据库容器（称为`db`），我们使用`depends_on`参数设置这个依赖关系。
- en: Dependencies don't mean the dependant container will be started when the necessary
    application is ready to work. It only refers to the order in which containers
    are started; the application that your microservice needs might not be ready.
    You have to control the readiness of the application, as we did for dbsync, with
    a loop that tries to connect to a database till it is available.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系并不意味着当必要的应用程序准备好工作时，依赖的容器将被启动。它仅指容器启动的顺序；你的微服务需要的应用程序可能尚未准备好。你必须控制应用程序的可用性，就像我们对dbsync所做的那样，通过一个尝试连接到数据库直到其可用的循环。
- en: 'Also, we set the `RUST_LOG` variable with the filtering of messages with one
    level less than `debug` and printed messages related to the `dbsync_worker` module
    only:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还设置了`RUST_LOG`变量，以过滤比`debug`级别低一级的消息，并且只打印与`dbsync_worker`模块相关的消息：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We also activated backtrace printing by setting the `RUST_BACKTRACE` variable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过设置`RUST_BACKTRACE`变量激活了回溯打印功能。
- en: The last variable sets a connection link to a database. As you can see, we use
    the `db` name of the host since Docker configures containers to resolve names
    and match the names of other containers, so you don't need to set or remember
    the IP address of the container. You can use the names of containers as host names.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个变量设置了一个连接到数据库的连接链接。正如你所见，我们使用主机的`db`名称，因为Docker配置容器以解析名称并匹配其他容器的名称，所以你不需要设置或记住容器的IP地址。你可以使用容器的名称作为主机名。
- en: Mails microservice container
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件微服务容器
- en: 'The microservice that sends emails to users builds on the image from the `Dockerfile`
    stored in the `./microservices/mails` folder. This microservice depends on the `smtp`
    container, but this microservice doesn''t check that the mail service is ready
    for work. If you want to check that the mail server is ready, add a piece of code
    that will try to connect to the SMTP server before starting any activity. Look
    at the following settings:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户发送邮件的微服务是基于存储在`./microservices/mails`文件夹中的`Dockerfile`镜像构建的。此微服务依赖于`smtp`容器，但此微服务不会检查邮件服务是否已准备好工作。如果你想要检查邮件服务器是否已准备好，请在开始任何活动之前添加一段尝试连接到SMTP服务器的代码。查看以下设置：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We also configure a microservice with environment variables and forward port
    `8002` to port `8000` of the container. You  can use port `8002` to check that
    the microservice started and works.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过环境变量配置了一个微服务，并将端口`8002`映射到容器的`8000`端口。你可以使用端口`8002`来检查微服务是否启动并正常工作。
- en: Users microservice container
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户微服务容器
- en: 'The users microservice is built from the `Dockerfile` we created before. This
    microservice depends on two other containers—dbsync and mails. First, we need
    to have a table of users in the database to keep user records in; secondly, we
    need to have the ability to send email notifications to a user. We also set the
    address of the socket in the `USERS_ADDRESS` variable and the link for the connection
    in the `USERS_DATABASE` variable:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 用户微服务是由我们之前创建的`Dockerfile`构建的。此微服务依赖于两个其他容器——dbsync和mails。首先，我们需要在数据库中有一个用户表来保存用户记录；其次，我们需要有能力向用户发送电子邮件通知。我们还设置了`USERS_ADDRESS`变量中的套接字地址和`USERS_DATABASE`变量中的连接链接：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Also, there is a setting to forward port `8000` of the container to the local
    port, `8001`, which you can use to access the microservice for testing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个设置，将容器的端口`8000`映射到本地端口`8001`，你可以使用这个端口来测试访问微服务。
- en: Content microservice container
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容微服务容器
- en: 'The content microservice is built with the `Dockerfile` file in the `./microservices/content`
    folder. We also created this file earlier in this chapter. Since the content microservice
    is based on the Rocket framework, we can use the environment variables with the `ROCKET`
    prefix to configure the microservice:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 内容微服务是用`./microservices/content`文件夹中的`Dockerfile`文件构建的。我们也在本章的早期创建了此文件。由于内容微服务基于Rocket框架，我们可以使用带有`ROCKET`前缀的环境变量来配置微服务：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This microservice uses the database and depends on the `dbsync` container, which
    in turn depends on the `db` container with a database instance. We open port `8003`
    to access this microservice outside Docker.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此微服务使用数据库，并依赖于`dbsync`容器，而`dbsync`容器又依赖于包含数据库实例的`db`容器。我们打开端口`8003`以在Docker外部访问此微服务。
- en: Router microservice container
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由微服务容器
- en: 'The last service we''ll configure before we start the whole application is
    the router microservice. This service depends on the users and content microservices,
    because router proxies request these microservices:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动整个应用程序之前，我们将配置最后一个服务，即路由微服务。此服务依赖于用户和内容微服务，因为路由代理请求这些微服务：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We also configured logging with the `debug` level for the `router_microservice`
    namespace, turned on backtrace printing, set the socket address to bind this microservice
    to, and set paths to the users and content microservices with environment variables
    supported by the configuration. We used container names as host names, since Docker
    Compose configures containers to reach each other by name. We also forwarded port
    `8000` to the same system port. Now we can start the application with all of the
    containers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还配置了`router_microservice`命名空间的`debug`级别日志，开启了回溯打印，设置了绑定此微服务的套接字地址，并使用配置支持的变量设置了用户和内容微服务的路径。我们使用容器名称作为主机名，因为Docker
    Compose配置容器通过名称相互访问。我们还转发端口`8000`到相同的系统端口。现在我们可以启动包含所有容器的应用程序。
- en: Running the application
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'To run the application, we will use the Docker Compose tool, which has to be
    installed (you can find useful links in the Technical Requirements section of
    this chapter). If the utility installed successfully, you''ll have the `docker-compose`
    command. Change the directory to a directory called `docker-compose.test.yml`
    and run the `up` subcommand:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，我们将使用Docker Compose工具，该工具必须已安装（你可以在本章的技术要求部分找到有用的链接）。如果实用工具安装成功，你将拥有`docker-compose`命令。将目录更改为名为`docker-compose.test.yml`的目录，并运行`up`子命令：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Thus, it will build all the images if necessary and start the application:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果需要，它将构建所有镜像并启动应用程序：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When all the containers are started, you will see the logs of all the containers
    in the terminal, prefixed by the name of the container:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有容器启动后，你将在终端中看到所有容器的日志，日志前缀为容器名称：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now the application is started and you can connect to it with the browser using
    this link: `http://localhost:8000`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已启动，你可以使用此链接通过浏览器连接到它：`http://localhost:8000`。
- en: 'To stop the application, use the *Ctrl+C* key combination. That will start
    the termination process and you will see it reflected in the Terminal:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止应用程序，使用*Ctrl+C*键组合。这将启动终止过程，你将在终端中看到它：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you restart the application, the database will be empty. Why? Because we
    stored the database on a temporary filesystem of the container. If you need persistence,
    you can attach a local folder to the container as a virtual volume. Let's explore
    this feature.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新启动应用程序，数据库将是空的。为什么？因为我们把数据库存储在容器的临时文件系统中。如果你需要持久性，你可以将本地文件夹附加到容器作为虚拟卷。让我们探索这个功能。
- en: Adding persistent state to the application
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向应用程序添加持久状态
- en: 'We created an application that consists of microservices, and that doesn''t
    have a persistent state – the application is empty on every restart. Fixing this
    is simple: map the persistent volume to a folder of the container. Since no one
    microservice of our application keeps the data in files, but the PostgreSQL database
    does, we only need to attach a folder to a database container. Copy `docker-compose.test.yml`
    to `docker-compose.prod.yml` and add the following changes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个由微服务组成的应用程序，并且没有持久状态——每次重启时应用程序都是空的。解决这个问题很简单：将持久卷映射到容器的文件夹。由于我们应用程序的没有任何微服务将数据保存在文件中，但PostgreSQL数据库是，我们只需要将一个文件夹附加到数据库容器。将`docker-compose.test.yml`复制到`docker-compose.prod.yml`，并添加以下更改：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We attached a volume with the name `database_data` to the `/var/lib/postgresql/data`
    path of the database container. PostgreSQL uses this path by default to store
    database files. To declare a persistent volume, we use the `volume` section with
    the name of the volume. We set the `driver` parameter to `local` to keep the data
    on the local hard drive. Now the data is saved between restarts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将名为`database_data`的卷附加到数据库容器的`/var/lib/postgresql/data`路径。PostgreSQL默认使用此路径来存储数据库文件。要声明持久卷，我们使用名为卷的`volume`部分。我们将`driver`参数设置为`local`以将数据保留在本地硬盘上。现在数据在重启之间保存。
- en: We also removed port forwarding for all of the microservices, excluding the
    router microservice, since all of the microservices are available via the inner
    virtual network of Docker and only the router has to be available outside the
    container.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还移除了所有微服务的端口转发，除了路由微服务，因为所有微服务都可通过Docker的内部虚拟网络访问，只有路由器需要在外部容器中可用。
- en: Running the application in the background
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台运行应用程序
- en: 'We started the application by attaching the terminal to the output of the containers,
    but that''s inconvenient if you want to deploy an application to a remote server.
    To detach the terminal, use the `-d` parameter when you start:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将终端附加到容器的输出启动了应用程序，但如果您想将应用程序部署到远程服务器，这就不方便了。要分离终端，请在启动时使用`-d`参数：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will start the application with a persistent state, and print something
    like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动具有持久状态的应用程序，并打印如下内容：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It also detaches from the Terminal. You might ask: How can I read the logs
    that microservices print using `env_logger` and the `log` crate? Use the following
    command with the name of the service at the end:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它也会从终端分离。您可能会问：我如何使用`env_logger`和`log`crate读取微服务打印的日志？请使用以下命令，并在末尾加上服务名称：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This command will print the logs of the `users_1` container, which represents
    the users service of the application. You can use the `grep` command to filter
    unnecessary records in logs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将打印`users_1`容器的日志，它代表应用程序的用户服务。您可以使用`grep`命令过滤日志中的不必要记录。
- en: 'Since the application detached from the terminal, you should use the down command
    to stop the application:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序已从终端分离，您应该使用向下命令来停止应用程序：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will stop all containers and finish with the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止所有容器并输出以下内容：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The application has stopped and now you know how to use the Docker Compose tool
    to run a multi-container application. If you want to learn more about using Docker
    Compose on local and remote machines, read this book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已停止，现在您知道如何使用Docker Compose工具运行多容器应用程序。如果您想了解更多关于在本地和远程机器上使用Docker Compose的信息，请阅读这本书。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to how to build images and run containers with your
    own microservices using Docker. We packed all of the microservices we created
    in [Chapter 9](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml), *Simple REST Definition
    and Request Routing with Frameworks**,* and [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *Involving
    Concurrency with Actors and the Actix Crate*, and learned how to build images
    manually and start a container. We also added the dbsync worker, which applied
    all necessary migrations and prepared a database for use with the users and content
    microservices.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了如何使用Docker构建图像并运行自己的微服务容器。我们将我们在[第9章](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml)，*使用框架进行简单的REST定义和请求路由*，和[第11章](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml)，*使用Actors和Actix
    Crate处理并发*中创建的所有微服务打包在一起，并学习了如何手动构建图像和启动容器。我们还添加了dbsync工作进程，它应用了所有必要的迁移，并为用户和内容微服务准备了数据库。
- en: Also, we considered approaches to hiding the source code of a microservice and
    used the cache of a container to copy a compiled binary to an empty image without
    building artifacts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还考虑了隐藏微服务源代码的方法，并使用容器的缓存将编译的二进制文件复制到空镜像中，而不构建工件。
- en: In the second half of the chapter, we learned how to run multiple microservices
    with necessary dependencies (such as databases and mail servers) at once. We used
    the Docker Compose tool to describe the configuration of a microservice set with
    a running order and port forwarding. We also learned how to attach volumes to
    services (containers), to store persistent data, and to allow you to restart an
    application without any risk of losing data.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们学习了如何一次性运行多个具有必要依赖项（如数据库和邮件服务器）的微服务。我们使用Docker Compose工具描述了具有运行顺序和端口转发的微服务集的配置。我们还学习了如何将卷附加到服务（容器）上，以存储持久数据，并允许您在没有任何数据丢失风险的情况下重新启动应用程序。
- en: In the next chapter, we will learn how to automate building microservices using
    continuous integration tools, helping you deliver the latest release of your product
    faster.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用持续集成工具自动化构建微服务，帮助您更快地交付产品的最新版本。
