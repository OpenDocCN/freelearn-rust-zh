- en: '*Chapter 2*: Structuring Code in Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：在 Rust 中结构化代码'
- en: Now that we have gotten to grips with the basics of Rust, we can move on to
    structuring code over several files so we can actually solve problems with Rust.
    In order to do this, we will have to understand how to manage dependencies as
    well as how to compile a basic and structured application. We also have to consider
    the isolation of code so we can reuse it and keep the development of the application
    agile, enabling us to make changes quickly without much pain. After covering this,
    we will also get the application to interact with the user directly by accepting
    user commands. We will also utilize Rust crates. A crate is a binary or library
    that we import and use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了 Rust 的基础知识，我们可以继续学习如何在多个文件中结构化代码，以便我们实际上可以用 Rust 解决问题。为了做到这一点，我们必须了解如何管理依赖项以及如何编译一个基本和结构化的应用程序。我们还必须考虑代码的隔离，以便我们可以重用它并保持应用程序开发的敏捷性，使我们能够快速做出更改而不会造成太多痛苦。完成这些后，我们还将使应用程序能够通过接受用户命令直接与用户交互。我们还将利用
    Rust crates。Crate 是我们导入并使用的二进制文件或库。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Managing our code with crates and Cargo instead of `pip`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 crates 和 Cargo 而不是 `pip` 来管理我们的代码
- en: Structuring code over multiple files and modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个文件和模块中结构化代码
- en: Building module interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模块接口
- en: Interacting with the environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与环境交互
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We are no longer going to be implementing simple single-page applications that
    do not rely on any third-party dependencies as we did in the first chapter. As
    a result, you will have to directly install Rust onto your computer. We will also
    be managing third-party dependencies through Cargo. You can install Rust and Cargo
    on your computer here: https://www.rust-lang.org/tools/install.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再实现像第一章中那样不依赖任何第三方依赖的简单单页应用程序。因此，您将不得不直接在您的计算机上安装 Rust。我们还将通过 Cargo 管理第三方依赖项。您可以在以下链接中安装
    Rust 和 Cargo：[https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install)。
- en: 'At the time of writing this, the best **integrated development environment**
    (**IDE**) by far for writing Rust is Visual Studio Code. It has a range of Rust
    plugins that can help you keep track of and check your Rust code. It can be installed
    using this link: [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，对于编写 Rust 而言，迄今为止最好的**集成开发环境**（**IDE**）是 Visual Studio Code。它有一系列 Rust
    插件，可以帮助您跟踪和检查您的 Rust 代码。您可以使用此链接安装它：[https://code.visualstudio.com/download](https://code.visualstudio.com/download)。
- en: 'You can find all the code files in the GitHub repository for this chapter:
    [https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_two](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_two).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章的 GitHub 仓库中找到所有代码文件：[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_two](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_two)。
- en: Managing our code with crates and Cargo instead of pip
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 crates 和 Cargo 而不是 pip 来管理我们的代码
- en: 'Building our own application is going to involve the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 构建我们自己的应用程序将涉及以下步骤：
- en: Create a simple Rust file and run it.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的 Rust 文件并运行它。
- en: Create a simple application using Cargo.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 创建一个简单的应用程序。
- en: Run our application using Cargo.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 运行我们的应用程序。
- en: Manage dependencies with Cargo.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 管理依赖项。
- en: Use a third-party crate to serialize JSON.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第三方 crate 序列化 JSON。
- en: Document our application with Cargo.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 记录我们的应用程序。
- en: 'Before we start structuring our program with Cargo, we should compile a basic
    Rust script and run it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 Cargo 结构化程序之前，我们应该编译一个基本的 Rust 脚本并运行它：
- en: 'To do this, make a file called `hello_world.rs` with the main function housing
    the `println!` function with a string, as we can see here:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，创建一个名为 `hello_world.rs` 的文件，其中包含主函数，并使用字符串调用 `println!` 函数，就像我们在这里看到的那样：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once this is done, we can navigate to the file and run the `rustc` command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以导航到文件并运行 `rustc` 命令：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command compiles the file into a binary to be run. If we compile on Windows,
    we can run the binary with the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令将文件编译成可运行的二进制文件。如果我们是在 Windows 上编译，我们可以使用以下命令运行二进制文件：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we compile it on Linux or Mac, we can run it with the following command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在 Linux 或 Mac 上编译它，我们可以使用以下命令运行它：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The console should then print out the string. While this can come in useful
    when building a standalone file, it is not recommended for managing programs spanning
    multiple files. It is not even recommended when relying on dependencies. This
    is where Cargo comes in. Cargo manages everything – the running, testing, documentation,
    building, and dependency out of the box – with a few simple commands.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 控制台应该会打印出字符串。虽然当构建独立文件时这很有用，但不建议用于管理跨多个文件的程序。即使在依赖项上，也不建议这样做。这就是Cargo发挥作用的地方。Cargo通过一些简单的命令管理一切——运行、测试、文档、构建和依赖项。
- en: 'Now that we have a basic understanding of how to compile a basic file, we can
    move on to building a fully fledged application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何编译基本文件有了基本的了解，我们可以继续构建一个完整的应用程序：
- en: 'In your terminal, navigate to where you want your application to sit, and create
    a new project called `wealth_manager` as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，导航到您希望应用程序所在的位置，并创建一个名为`wealth_manager`的新项目，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: /target
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /target
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Right now, all we have is the main file that has a printout to the console
    saying *"hello world."* We can run this with the following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们只有一个主文件，该文件在控制台打印出“hello world.”。我们可以用以下命令运行它：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this command, we get the following output in the terminal:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令，我们在终端中会得到以下输出：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we want to run a release, we simply run the following command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们要运行一个发布版本，我们只需运行以下命令：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have got our application running, let''s explore how we manage
    the metadata around it. This can all be done by editing the `Cargo.toml` file.
    When we open this, we get the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使应用程序运行起来，让我们探索如何管理其周围的元数据。这可以通过编辑`Cargo.toml`文件来完成。当我们打开它时，我们会看到以下内容：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The name, version, and authors are fairly straightforward. Here are the effects
    each section has on the project:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 名称、版本和作者相对简单。以下是每个部分对项目的影响：
- en: If we change the `name` value in the `Cargo.toml` file, then new binaries with
    that name will be made when we build or run our application. The old ones will
    still be there too.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在`Cargo.toml`文件中更改`name`值，那么在构建或运行我们的应用程序时，将生成具有该名称的新二进制文件。旧的二进制文件仍然存在。
- en: '`version` is for distribution on services such as `crates.io` if we want to
    open source our application for others to use. The authors are required for this
    as well, and our application will still compile and run locally if it''s not there.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`用于在`crates.io`等服务上分发，如果我们想开源我们的应用程序供他人使用。作者也需要提供，即使没有它，我们的应用程序也可以在本地编译和运行。'
- en: '`edition` is the edition of Rust that we are using. Rust gets updated frequently.
    These updates accumulate through time, and every two to three years, the smoothed-out
    new features are packaged, documented, and added to a new edition. The latest
    edition (2021) is available at [https://devclass.com/2021/10/27/rust-1-56-0-arrives-delivering-rust-2021-edition-support/](https://devclass.com/2021/10/27/rust-1-56-0-arrives-delivering-rust-2021-edition-support/).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edition`代表我们正在使用的Rust版本。Rust会频繁更新。这些更新随着时间的积累，每两到三年，新的平滑特性会被打包、文档化，并添加到新的版本中。最新的版本（2021）可以在[https://devclass.com/2021/10/27/rust-1-56-0-arrives-delivering-rust-2021-edition-support/](https://devclass.com/2021/10/27/rust-1-56-0-arrives-delivering-rust-2021-edition-support/)找到。'
- en: We also have `dependencies`. This is where we can import third-party crates.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有`dependencies`。这是我们导入第三方crate的地方。
- en: 'To see how this works, let''s use a crate to convert a data structure of stock
    into JSON and then print it. Writing the code ourselves would be a bit of a headache.
    Luckily, we can install the `serde` crate and use the `json!` macro. In order
    for Cargo to download and install the crate, we fill our dependencies section
    in our `Cargo.toml` file with the code given here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这是如何工作的，让我们使用一个crate将股票的数据结构转换为JSON，然后打印出来。自己编写代码会有些头疼。幸运的是，我们可以安装`serde`
    crate并使用`json!`宏。为了让Cargo下载并安装crate，我们在`Cargo.toml`文件中的依赖关系部分填写以下代码：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In our `main.rs` file, we then import the macro and struct needed to convert
    data about a stock into JSON and then print it out in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main.rs`文件中，我们随后导入将股票数据转换为JSON并打印出来的宏和结构体所需的代码：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It is important to note that we are returning a `Value` struct from the `serde_json`
    value. In order to see how we can use the return value, we can explore the documentation
    of the struct. This is when we get to see that Rust''s documentation system is
    very comprehensive. We can find the documentation of the struct here: [https://docs.rs/serde_json/1.0.64/serde_json/enum.Value.html](https://docs.rs/serde_json/1.0.64/serde_json/enum.Value.html).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们从 `serde_json` 值返回一个 `Value` 结构体。为了了解我们如何使用返回值，我们可以探索该结构体的文档。这时我们会看到
    Rust 的文档系统非常全面。我们可以在以下位置找到该结构体的文档：[https://docs.rs/serde_json/1.0.64/serde_json/enum.Value.html](https://docs.rs/serde_json/1.0.64/serde_json/enum.Value.html)。
- en: 'We can see in *Figure 2.1* that the documentation covers all of the functions
    that the struct supports. Our `json!` macro is returning `Object(Map<String, Value>)`.
    We also have a range of other values, depending on how we call the `json!` macro.
    The documentation also covers a range of functions that we can exploit to check
    what type the value is, whether the JSON value is `null`, and ways in which we
    can cast the JSON value as a particular type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *图 2.1* 中看到，文档涵盖了该结构体支持的所有函数。我们的 `json!` 宏返回 `Object(Map<String, Value>)`。我们还有一系列其他值，这取决于我们如何调用
    `json!` 宏。文档还涵盖了一系列我们可以利用的函数，以检查值的类型，判断 JSON 值是否为 `null`，以及将 JSON 值转换为特定类型的方法：
- en: '![Figure 2.1 – Documentation of the serde_json value'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – serde_json 值的文档'
- en: '](img/Figure_2.01_B17720.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.01_B17720.jpg)'
- en: Figure 2.1 – Documentation of the serde_json value
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – serde_json 值的文档
- en: 'When we perform a Cargo `run` command, we will see Cargo compiling the crates
    that we defined in the dependencies. We then see the compilation of our own app,
    and the printout of the price and the data related to the stock, as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 Cargo `run` 命令时，我们会看到 Cargo 编译我们在依赖中定义的 crate。然后我们看到我们自己的应用的编译，以及价格和与股票相关的数据的打印输出，如图所示：
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Going back to the documentation, we can create our own. This is straightforward;
    we do not have to install anything. All we have to do is create documentation
    in the code, like **docstrings** in Python. In order to demonstrate this, we can
    create a function that adds two variables together and defines the docstring,
    as seen in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回到文档，我们可以创建自己的。这很简单；我们不需要安装任何东西。我们只需要在代码中创建文档，就像 Python 中的 **docstrings** 一样。为了演示这一点，我们可以创建一个函数，将两个变量相加并定义文档字符串，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can see that this documentation is Markdown! This example is overkill for
    this type of function. A standard developer should be able to implement this function
    without any examples. For more complex functions and structs, it is worth noting
    that there is nothing stopping us from documenting code examples on how to implement
    what we are documenting. Building the documentation only requires the command
    here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这份文档是 Markdown 格式的！这个例子对于这种类型的函数来说有点过度。标准开发者应该能够在没有任何示例的情况下实现这个函数。对于更复杂的函数和结构体，值得注意的是，没有任何阻止我们记录如何实现我们所记录内容的代码示例。构建文档只需要以下命令：
- en: '[PRE49]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After the process has finished, we can open the documentation with the following
    command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程完成后，我们可以使用以下命令打开文档：
- en: '[PRE50]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This opens up the documentation in a web browser, as shown in *Figure 2.2*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在网页浏览器中打开文档，如图 *图 2.2* 所示：
- en: '![Figure 2.2 – Documentation view of our module'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 我们模块的文档视图'
- en: '](img/Figure_2.02_B17720.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.02_B17720.jpg)'
- en: Figure 2.2 – Documentation view of our module
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 我们模块的文档视图
- en: 'What we can see here is that our `main` and `add_numbers` functions are available.
    We can also see on the left that the dependencies that were installed are also
    available. If we click on our `add_numbers` function, we get to see the Markdown
    that we wrote, as shown in *Figure 2.3*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到，我们的 `main` 和 `add_numbers` 函数都是可用的。我们还可以在左侧看到安装的依赖项也是可用的。如果我们点击我们的
    `add_numbers` 函数，我们可以看到我们编写的 Markdown，如图 *图 2.3* 所示：
- en: '![Figure 2.3 – Documentation view of our add_numbers function'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 我们 add_numbers 函数的文档视图'
- en: '](img/Figure_2.03_B17720.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.03_B17720.jpg)'
- en: Figure 2.3 – Documentation view of our add_numbers function
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 我们 add_numbers 函数的文档视图
- en: Here we have it – we can create interactive documentation of our code as we
    build our application. It has to be noted that the rest of the book will not have
    Markdown in the code snippets; otherwise, this would simply extend the book to
    an unnecessary length. However, it is good practice to document all structs and
    functions as you code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是它——我们可以在构建应用程序的同时创建我们代码的交互式文档。需要注意的是，本书的其余部分将不会在代码片段中使用Markdown；否则，这只会使本书变得过于冗长。然而，在编写代码时记录所有结构和函数是一个好的实践。
- en: Now that we have run our code, set up a basic application structure, and documented
    our code, we are ready to move on to the next section of structuring our application
    over multiple files.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了代码，设置了基本的应用程序结构，并记录了我们的代码，我们就可以继续到下一个部分，即如何在多个文件中组织我们的应用程序。
- en: Structuring code over multiple files and modules
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个文件和模块中组织代码
- en: 'In order to build our module, we are going to carry out the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的模块，我们将执行以下步骤：
- en: Map out our file and folder structure.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制我们的文件和文件夹结构。
- en: Create our `Stock` structs.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`Stock`结构体。
- en: Link our `Stock` struct to the main file.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的`Stock`结构体链接到主文件。
- en: Use our `stocks` module in the main file.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主文件中使用我们的`stocks`模块。
- en: Add code from another module.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从另一个模块添加代码。
- en: 'Now that we are at the stage of building out our application over multiple
    files, we have to define our first module in our application, which is the **stocks
    module**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到了在多个文件中构建应用程序的阶段，我们必须在我们的应用程序中定义我们的第一个模块，即**股票模块**：
- en: 'We can make our module have the structure defined as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使我们的模块具有以下定义的结构：
- en: '[PRE51]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have taken this structure to enable flexibility; if we need to add more structs,
    we can do so in the `structs` directory. We can also add other directories alongside
    the `structs` directory. For instance, we might want to build a mechanism for
    storing the data for our stocks. This can be achieved by adding a `storage` directory
    in the `stocks` directory and using this throughout the module as and when it
    is needed.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们采用这种结构是为了实现灵活性；如果我们需要添加更多的结构体，我们可以在`structs`目录中这样做。我们还可以在`structs`目录旁边添加其他目录。例如，我们可能想要为我们的股票构建一个存储数据的机制。这可以通过在`stocks`目录中添加一个`storage`目录并在此模块中根据需要使用它来实现。
- en: 'For now, we simply want to create a stock struct in our `stocks` module, import
    it into our `main.rs` file, and use it. Our first step is to define our `Stock`
    struct in our `stock.rs` file with this code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们只想在我们的`stocks`模块中创建一个股票结构体，将其导入到`main.rs`文件中，并使用它。我们的第一步是在`stock.rs`文件中用以下代码定义我们的`Stock`结构体：
- en: '[PRE52]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This looks familiar, as it is the same as the `Stock` struct that we defined
    in the previous chapter. However, there is a slight difference. We must note that
    there is a `pub` keyword before the struct definition and each field definition.
    This is because we have to declare them public before we can use them outside
    the file. This also applies to functions implemented in the same file, as shown
    in the following code:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这看起来很熟悉，因为它与我们之前章节中定义的`Stock`结构体相同。然而，有一个细微的差别。我们必须注意，在结构体定义和每个字段定义之前有一个`pub`关键字。这是因为我们必须在文件外部使用它们之前声明它们为公共的。这同样适用于在同一文件中实现的函数，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can see that we now have a public struct that is available with all its functions.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，我们现在有一个公开的结构体，其中包含所有函数都可以使用。
- en: 'We now have to enable our struct to be used in the `main.rs` file. This is
    where the `mod.rs` files come in. `mod.rs` files are essentially `__init__.py`
    files in Python. They show that the directory is a module. However, unlike Python,
    Rust data structures need to be publicly declared in order to be accessed from
    other files. We can see how the struct is passed through our `stocks` module to
    our `main.rs` file in *Figure 2.4*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须使我们的结构体能够在`main.rs`文件中使用。这就是`mod.rs`文件的作用所在。`mod.rs`文件在Python中相当于`__init__.py`文件。它们表明目录是一个模块。然而，与Python不同，Rust数据结构需要公开声明才能从其他文件访问。我们可以在*Figure
    2.4*中看到结构体是如何通过我们的`stocks`模块传递到`main.rs`文件的：
- en: '![Figure 2.4 – How a struct is passed through modules'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.4 – 结构体如何在模块间传递'
- en: '](img/Figure_2.04_B17720.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.04 – B17720.jpg](img/Figure_2.04_B17720.jpg)'
- en: Figure 2.4 – How a struct is passed through modules
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.4 – 结构体如何在模块间传递
- en: 'Here, we can see that we are merely publicly declaring the struct in the module
    furthest away from `main.rs` in the `mod.rs` file belonging to that directory.
    We then publicly declare the `structs` module in the `stocks` `mod.rs` file. Here
    is a good time to explore the `mod` expression that declares modules. If we want
    to, we can declare multiple modules in a single file. It must be stressed that
    this is not happening in our example. We could declare module one and module two
    in a single file with the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们只是在最远离 `main.rs` 的模块中公开声明了结构体，在所属目录的 `mod.rs` 文件中。然后我们在 `stocks`
    的 `mod.rs` 文件中公开声明了 `structs` 模块。现在是探索声明模块的 `mod` 表达式的好时机。如果我们想，我们可以在单个文件中声明多个模块。必须强调的是，这在我们示例中并没有发生。我们可以在单个文件中使用以下代码声明模块一和模块二：
- en: '[PRE54]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now that we have defined our modules in our main example project, we just declare
    the `stocks` module in the `main.rs` file. The reason why this is not a public
    declaration is that the `main.rs` file is the entry point of our application;
    we will not be importing this module into anything else:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的主要示例项目中定义了我们的模块，我们只需在 `main.rs` 文件中声明 `stocks` 模块。这不是公开声明的原因是，`main.rs`
    文件是应用程序的入口点；我们不会将此模块导入到任何其他地方：
- en: 'Now that our struct is available, we can simply use it as we would if it was
    defined in the same file with the following:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经使结构体可用，我们可以像它定义在同一个文件中一样简单地使用它，如下所示：
- en: '[PRE60]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Running this code unsurprisingly gives us this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码不出所料给出了以下结果：
- en: '[PRE61]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now that we have the basics of using structs from different files covered,
    we can move on to exploring other pathways of accessing data structures from other
    files in order to be more flexible:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了使用不同文件中的结构体的基础知识，我们可以继续探索从其他文件访问数据结构的其他途径，以便更加灵活：
- en: 'The first concept we have to explore is accessing from files in the same directory.
    In order to demonstrate this, we can do a throwaway example of building a print
    function in the structs. In a new file with the `src/stocks/structs/utils.rs`
    path, we can create a toy function that merely prints out that the constructor
    for the struct is firing, as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须探索的第一个概念是从同一目录的文件中访问。为了演示这一点，我们可以在结构体中创建一个打印函数的废弃示例。在一个新的文件 `src/stocks/structs/utils.rs`
    路径中，我们可以创建一个玩具函数，它仅仅打印出结构体的构造函数正在触发，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We then declare it in our `src/stocks/structs/mod.rs` file with the following
    code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码在 `src/stocks/structs/mod.rs` 文件中声明它：
- en: '[PRE63]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It must be noted that we are not making it public; we just declare it instead.
    Nothing is stopping us from making it public; however, with the non-public approach,
    we only allow files within the directory of `src/stocks/structs/` to access it.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要注意的是，我们并没有将其设置为公开；我们只是声明了它。没有任何东西阻止我们将其设置为公开；然而，使用非公开方法，我们只允许 `src/stocks/structs/`
    目录内的文件访问它。
- en: 'We now want our `Stock` struct to access it and use it in our constructor,
    which can be done with an import in `src/stocks/structs/stock.rs` with the following
    line:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在希望我们的 `Stock` 结构体能够访问它并在我们的构造函数中使用它，这可以通过在 `src/stocks/structs/stock.rs`
    文件中使用以下行来实现：
- en: '[PRE64]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we want to move our reference to the `src/stocks/` directory, we can use
    `super::super`. We can chain as many supers as we want, depending on how deep
    the tree is. It has to be noted that we can only access what is declared in the
    `mod.rs` file of the directory. In our `src/stocks/structs/stock.rs` file, we
    can now use the function in our constructor with the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想将我们的引用移动到 `src/stocks/` 目录，我们可以使用 `super::super`。我们可以根据树的深度链式调用任意多个 `super`。需要注意的是，我们只能访问在目录的
    `mod.rs` 文件中声明的部分。在我们的 `src/stocks/structs/stock.rs` 文件中，我们现在可以在构造函数中使用以下代码：
- en: '[PRE65]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, if we run our application, we will get the following printout in the terminal:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的应用程序，我们将在终端中得到以下打印输出：
- en: '[PRE66]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: While we have managed to access data structures from different files and modules,
    this is not very scalable, and there are going to be some rules in which we implement
    stocks. In order to enable us to write scalable safe code, we need to lock down
    the functionality with interfaces in the next section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经能够从不同的文件和模块中访问数据结构，但这并不非常可扩展，我们将有一些规则来实施股票。为了使我们能够编写可扩展的安全代码，我们需要在下一节中使用接口锁定功能。
- en: Building module interfaces
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模块接口
- en: Unlike Python, where we can import anything we want from anywhere and at the
    most our IDE will just give us a syntax highlight, Rust will actively not compile
    if we try and access data structures that have not explicitly been made public.
    This gives us an opportunity to really lock down our modules and enforce functionality
    through an interface.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python不同，我们可以从任何地方导入我们想要的任何东西，最多我们的IDE只会给我们语法高亮，而Rust会主动不编译，如果我们尝试访问未明确公开的数据结构。这给了我们一个真正锁定我们的模块并通过接口强制功能的机会。
- en: However, before we get started with this, let's fully explore what functionality
    we will be locking down. It is good practice to keep modules as isolated as possible.
    In our `stocks` module, the logic should only be around how to handle stocks and
    nothing else. This might seem a little overkill, but when we think about it, we
    quickly realize that this module is going to scale when it comes to complexity.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，在我们开始之前，让我们完全探索我们将要锁定哪些功能。保持模块尽可能隔离是一个好习惯。在我们的`stocks`模块中，逻辑应该只围绕如何处理股票，而不是其他任何事情。这看起来可能有点过度，但当我们思考时，我们很快就会意识到这个模块在复杂性方面将会扩展。 '
- en: For the demonstrative purposes of this chapter, let's just build the functionality
    for a stock order. We can either buy or sell a stock. These stock orders come
    in multiples. It's fairly common to buy *n* stocks of a company. We will also
    have to check to see whether the stock order is short or long. With a short order,
    we borrow money from the broker, buy stocks with that money, sell them instantly,
    and then buy the stocks back at a later date. If the stock price goes down, we
    make money, as we keep the difference when repaying to the broker. If we go long,
    we just buy the stock and hold it. If it goes up, we make money, so depending
    on the order, there will be different outcomes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的演示目的，让我们只构建股票订单的功能。我们可以买入或卖出股票。这些股票订单以倍数出现。购买公司股票的*n*股是非常常见的。我们还需要检查股票订单是空头还是多头。在空头订单中，我们从经纪人那里借钱，用这笔钱买股票，立即卖出，然后在以后某个时间点买回股票。如果股价下跌，我们就能赚钱，因为我们保留在偿还给经纪人时的差额。如果我们做多，我们只是买入并持有股票。如果它上涨，我们就能赚钱，所以根据订单的不同，会有不同的结果。
- en: 'We have to remember that this is not a book for developing software around
    stock markets, so we need to keep the details simple to avoid losing ourselves.
    A simple approach for us to take to demonstrate interfaces is to take a layered
    approach, as described in *Figure 2.5*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，这不是一本关于围绕股票市场开发软件的书，所以我们需要保持细节简单，以避免迷失方向。为了演示接口，我们可以采取分层的方法，如*图 2.5*所示：
- en: '![Figure 2.5 – Approach to a simple module interface'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – 简单模块接口的方法'
- en: '](img/Figure_2.05_B17720.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 2.05_B17720.jpg](img/Figure_2.05_B17720.jpg)'
- en: Figure 2.5 – Approach to a simple module interface
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 简单模块接口的方法
- en: 'In order to achieve this approach, we can carry out the following steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种方法，我们可以执行以下步骤：
- en: Structure the module layout with the right files.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正确的文件结构来构建模块布局。
- en: Create an enum for the different types of orders.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为不同类型的订单创建一个枚举。
- en: Build an order struct.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个订单结构体。
- en: Install the `chrono` crate needed for `datetime` objects.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装用于`datetime`对象的`chrono`包。
- en: Create an order constructor that utilizes the `chrono` crate.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个利用`chrono`包的订单构造函数。
- en: Create dynamic values for the struct.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为结构体创建动态值。
- en: Create a close order interface.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个关闭订单接口。
- en: Create an open order interface.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个开放订单接口。
- en: Use the order interfaces in the main file.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主文件中使用订单接口。
- en: 'Let''s get started:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Here, we only allow ourselves to access the stock struct through the order
    struct. Again, there are other ways to approach this problem, which is a demonstration
    of how to build interfaces in Rust. In order to achieve this in the code, we have
    the file structure defined as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们只允许通过订单结构体访问股票结构体。再次强调，还有其他方法可以解决这个问题，这展示了如何在Rust中构建接口。为了在代码中实现这一点，我们定义了以下文件结构：
- en: '[PRE67]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'First of all, we can define our enum order types in our `enums/order_types.rs`
    file with the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以在`enums/order_types.rs`文件中使用以下代码定义我们的枚举顺序类型：
- en: '[PRE68]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will use this in our order and interfaces. In order to make this enum type
    available to the rest of the module, we have to declare it in our `enums/mod.rs`
    file with the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在订单和接口中使用这个。为了使这种枚举类型对模块的其余部分可用，我们必须在`enums/mod.rs`文件中声明它，以下代码：
- en: '[PRE69]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now that we have built our enum type, it is time to put it to work. We can
    now build our order struct in our `stocks/structs/order.rs` file with the following
    code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经构建了枚举类型，现在是时候将其投入使用。现在我们可以在`stocks/structs/order.rs`文件中使用以下代码构建我们的订单结构体：
- en: '[PRE70]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, we use the `chrono` crate to define when the order was placed; we also
    have to note what stock the order is for, the number of stocks that we are buying,
    and the type of order. We have to remember to define our `chrono` dependency on
    our `Cargo.toml` file with the following code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用`chrono`包来定义订单何时被放置；我们还要注意订单是为哪种股票，我们购买了多少股票，以及订单的类型。我们必须记住在`Cargo.toml`文件中定义我们的`chrono`依赖项，以下代码：
- en: '[PRE71]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The reason why we have kept our stock struct separate from the order struct
    is to allow flexibility. For instance, there are other things that we can do with
    stock data that is not an order. We may want to build a struct that houses stocks
    on the user watch list and the user hasn't actually bought anything, but they
    still want to see the stocks available.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将股票结构体与订单结构体分开的原因是为了提供灵活性。例如，我们还可以对非订单的股票数据进行其他操作。我们可能想要构建一个结构体来存放用户股票观察列表中的股票，而用户实际上并没有购买任何东西，但他们仍然想看到可用的股票。
- en: 'There are other use cases for stock data, however. Considering this, we can
    see that keeping the data and methods around a stock in an individual stock struct
    helps to not only reduce the amount of code we have to write if we add more features
    but also standardizes the data around a stock. This also makes it easier for us
    to maintain the code. If we add or delete a field, or change a method for stock
    data, we only have to change it in one place as opposed to multiple places. Our
    constructor for our order struct can be made in the same file with the following
    code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 股票数据还有其他用途。考虑到这一点，我们可以看到，将围绕股票的数据和方法保存在单独的股票结构体中，不仅有助于减少我们添加更多功能时需要编写的代码量，而且还可以标准化围绕股票的数据。这也使得我们更容易维护代码。如果我们添加或删除字段，或者更改股票数据的方法，我们只需要在一个地方更改，而不是多个地方。我们的订单结构体构造函数也可以在同一个文件中用以下代码创建：
- en: '[PRE72]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here we create an `Order` struct by accepting `stock`, `number`, and `order_type`
    arguments and creating a `datetime` struct.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们通过接受`stock`、`number`和`order_type`参数并创建一个`datetime`结构体来创建一个`Order`结构体。
- en: 'Because our order focuses on the logic around pricing the order as it houses
    the number of stocks brought in an order, in our `impl` block, we can build our
    current value of the order with the following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的订单专注于围绕定价的逻辑，因为它包含了订单中引入的股票数量，在我们的`impl`块中，我们可以使用以下代码构建订单的当前价值：
- en: '[PRE73]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It has to be noted that we have used `&self` as a parameter instead of just
    using `self`. This enables us to use the function multiple times. If the parameter
    was not a reference, then we would move the struct into the function. We would
    not be able to calculate the value multiple times, and it's going to be useful
    to do so unless the type is `Copy`.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须注意的是，我们使用了`&self`作为参数，而不是仅仅使用`self`。这使我们能够多次使用该函数。如果参数不是一个引用，那么我们将结构体移动到函数中。我们就无法多次计算值，而且如果类型不是`Copy`，这将非常有用。
- en: 'We can also build on this function to calculate the current profit in the `impl`
    block with the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以在此基础上构建函数来计算`impl`块中的当前利润，以下代码：
- en: '[PRE74]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here, we get the current price and the initial price. We then match the order
    type, as this will change how the profit is calculated. Now our structs are complete,
    we have to ensure that the structs are available by defining them in the `stocks/structs/mod.rs`
    file with the following code:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们获取当前价格和初始价格。然后匹配订单类型，因为这会改变利润的计算方式。现在我们的结构体已经完成，我们必须确保结构体在`stocks/structs/mod.rs`文件中可用，通过以下代码定义它们：
- en: '[PRE75]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We are now ready to create our interfaces. In order to build our interface
    in our `stocks` `/mod.rs` file, we initially have to import everything that we
    need, as shown in the following code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建我们的接口。为了在我们的`stocks` `/mod.rs`文件中构建接口，我们最初必须导入我们需要的所有内容，如下所示：
- en: '[PRE76]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now that we have everything to build our interface, we can build our close
    order interface with the following code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了构建界面的所有要素，我们可以使用以下代码构建我们的紧密订单界面：
- en: '[PRE77]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This is a fairly simple interface; we could do more, such as a database or
    API call, but for this demonstration, we merely print that the stock is being
    sold and return the current profit that we have made. With this in mind, we can
    build our more complex interface by opening an order in the same file with the
    following code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个相当简单的接口；我们可以做更多，比如数据库或API调用，但在这个演示中，我们只是打印股票正在被出售并返回我们目前所获得的利润。考虑到这一点，我们可以通过在同一个文件中打开一个订单来构建更复杂的接口以下代码：
- en: '[PRE78]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, we take in all of the parameters that we need. We have also introduced
    the `Option<f32>` argument type, which is implemented as an enum type. This allows
    us to pass in a `None` value. We then create a mutable stock (as the price will
    vary and we will have to update it), and then check to see whether the `stop_loss`
    value is provided; if it is, we then add the stop loss to the stock. We then check
    to see whether the `take_profit` value is provided, updating the stock with this
    if it is.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们接收所有需要的参数。我们还引入了`Option<f32>`参数类型，它被实现为一个枚举类型。这允许我们传递一个`None`值。然后我们创建一个可变的股票（因为价格会变动，我们需要更新它），然后检查是否提供了`stop_loss`值；如果是，我们就将止损添加到股票中。然后我们检查是否提供了`take_profit`值，如果提供了，我们就用这个值更新股票。
- en: 'Now that we have built all our interfaces, all we need to do is to use them
    in the `main.rs` file. In the main file, we need to import the needed structs
    and interfaces to utilize them with the following code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经构建了所有的接口，我们只需要在`main.rs`文件中使用它们。在主文件中，我们需要导入所需的structs和interfaces以便使用以下代码：
- en: '[PRE79]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In our main function, we can start putting these interfaces to work by creating
    a new mutable order with the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们可以通过创建一个新的可变订单来开始使用这些接口以下代码：
- en: '[PRE80]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, we have set `take_profit` and `stop_loss` to `None`, but we can add them
    if we need to. To clarify what we have just bought, we can print out the current
    value and profit with the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将`take_profit`和`stop_loss`设置为`None`，但如果我们需要，我们可以添加它们。为了明确我们刚刚购买了什么，我们可以使用以下代码打印出当前价值和利润：
- en: '[PRE81]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We then get some movement in the stock market, which we can simulate by updating
    the price and printing the value of our investment at each change with the following
    code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，股票市场出现了一些波动，我们可以通过更新价格并打印每次变化时我们的投资价值来模拟它以下代码：
- en: '[PRE82]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We now have a profit, and we will sell our stock to close the order and print
    out the profit with the following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有了利润，我们将出售我们的股票以关闭订单并打印以下代码的利润：
- en: '[PRE83]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, our interfaces, module, and main file are built. Running the Cargo `run`
    command gives us the following printout:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的接口、模块和主文件都构建完成了。运行Cargo `run`命令会给出以下输出：
- en: '[PRE84]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'As we can see, our module works and it has a clean interface. For this book,
    our example stops here, as we have shown how we can build modules in Rust with
    interfaces. However, if you want to go further with building out the application,
    we can take the approach seen in *Figure 2.6*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的模块工作正常，并且有一个干净的接口。对于这本书，我们的例子就到这里，因为我们已经展示了如何使用接口在Rust中构建模块。然而，如果你想进一步构建应用程序，我们可以采取*图2.6*中看到的方法：
- en: '![Figure 2.6 – Building out our application'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – 构建我们的应用程序'
- en: '](img/Figure_2.06_B17720.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.06_B17720.jpg)'
- en: Figure 2.6 – Building out our application
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 构建我们的应用程序
- en: In the account module, we would build data structures around keeping track of
    the amount the user has through trades. We would then build a storage module that
    has read and write interfaces for accounts and stocks. The reason why storage
    is a separate module is that we can keep the interfaces the same, and chop and
    change the storage logic under the hood.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在账户模块中，我们会围绕跟踪用户通过交易获得的金额来构建数据结构。然后我们会构建一个存储模块，它为账户和股票提供读写接口。存储是一个单独的模块的原因是我们可以保持接口不变，而在底层更改存储逻辑。
- en: For instance, we could start with a simple JSON file storage system for development
    and local usage; however, the application then gets put onto a server, and loads
    of users start making trades and accessing their accounts. We can switch the file
    reading and write for a database driver with database model mapping. The system
    then gets a lot of traffic and the application gets split into a cluster of microservices.
    One application would still be talking to a database, while another one for frequently
    requested stocks/accounts could be talking to a Redis cache.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以从简单的 JSON 文件存储系统开始，用于开发和本地使用；然而，当应用程序部署到服务器上时，大量的用户开始进行交易和访问他们的账户。我们可以切换文件读取和写入，使用数据库驱动程序和数据库模型映射。然后系统会承受大量的流量，应用程序被分割成一组微服务。一个应用程序仍然会与数据库通信，而另一个用于频繁请求的股票/账户的应用程序可能会与
    Redis 缓存通信。
- en: Considering this, keeping the storage separate keeps us flexible. Changing the
    requirements for the storage is not going to break the build. In fact, a configuration
    file could enable the switching of different methods, depending on the environment.
    As long as the interfaces remain the same, refactoring will not be a huge task.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，将存储保持独立使我们保持灵活性。更改存储的要求不会破坏构建。事实上，一个配置文件可以启用根据环境切换不同的方法。只要接口保持不变，重构就不会是一项巨大的任务。
- en: Benefits of documentation when coding
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码时文档化的好处
- en: 'As our module spans multiple files, we are now referencing functions and structs
    that are in different files. This is where the importance of documentation can
    be seen. We can revisit our point in the technical requirements of using Visual
    Studio Code. The code in GitHub is fully documented. If the Rust plugins are installed,
    merely hovering the mouse over the struct or function will pop up the documentation,
    allowing us to see what is needed in our interface, as shown in *Figure 2.7*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模块跨越多个文件，我们现在正在引用不同文件中的函数和结构体。这就是文档重要性的体现。我们可以回顾一下使用 Visual Studio Code
    的技术要求。GitHub 上的代码已经完全文档化。如果安装了 Rust 插件，只需将鼠标悬停在结构体或函数上，就会弹出文档，使我们能够看到接口中需要的内容，如图
    *2.7* 所示：
- en: '![Figure 2.7 – Popup documentation in Visual Studio Code'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – Visual Studio Code 中的弹出文档'
- en: '](img/Figure_2.07_B17720.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.07 – 图像](img/Figure_2.07_B17720.jpg)'
- en: Figure 2.7 – Popup documentation in Visual Studio Code
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – Visual Studio Code 中的弹出文档
- en: There is a reason why badly structured code that isn't documented is referred
    to as *tech debt*, and this is because it collects interest over time. Poorly
    structured code with no documentation is quick to develop, however, and as the
    size of the application grows, it's going to get harder to change things and understand
    what is going on. A well-structured module with good Markdown Rust documentation
    is a great way to keep you and your team's productivity high.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个原因，为什么结构不良且未记录的代码被称为 *技术债务*，这是因为它会随着时间的推移积累利息。没有文档的糟糕结构代码虽然开发起来很快，但随着应用程序规模的扩大，更改事物和理解正在发生的事情会变得更加困难。一个结构良好且具有良好
    Markdown Rust 文档的模块是保持您和您的团队生产力高的好方法。
- en: We now have a functioning application that spans multiple pages and is clean
    and scalable. However, a user cannot dynamically use it, as everything has to
    be hardcoded. This is not practical. In the next section, we interact with the
    environment so we can pass arguments into the program.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个功能齐全的应用程序，它跨越多个页面，既干净又可扩展。然而，用户无法动态地使用它，因为一切都需要硬编码。这是不实用的。在下一节中，我们将与环境交互，以便我们可以将参数传递到程序中。
- en: Interacting with the environment
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与环境交互
- en: We are at the stage in which the only thing that is holding us back from building
    a fully functioning command-line application is interacting with the environment.
    As stated in the previous section, this is an open-ended subject that spans anything
    from taking command-line arguments to interacting with servers and databases.
    As in the previous section, we will cover enough in order to get an understanding
    of how to structure Rust code that accepts data from the outside and processes
    it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前处于这样一个阶段，唯一阻碍我们构建一个完全功能化的命令行应用程序的是与环境交互。正如前文所述，这是一个开放性的主题，涵盖了从接受命令行参数到与服务器和数据库交互的任何内容。正如前文所述，我们将涵盖足够的内容，以便了解如何构建接受外部数据并对其进行处理的
    Rust 代码的结构。
- en: In order to explore this, we are going to get our stock application to take
    in command-line arguments from the user so that we can either buy or sell a stock.
    We will not over-complicate things by choosing whether to go short or go long,
    and we will not introduce storage.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这一点，我们将使我们的股票应用程序能够从用户那里接收命令行参数，这样我们就可以买卖股票。我们不会通过选择做空或做多来使事情复杂化，我们也不会引入存储。
- en: However, by the end of this section, we will be equipped to approach building
    code that scales and accepts data from the outside world. With this, further reading
    on crates that connect to databases or read/write files will enable us to seamlessly
    add them to our well-structured code. In terms of databases, we will cover how
    to mirror the schema of a database and connect to it in [*Chapter 10*](B17720_10__Final_SK_ePub.xhtml#_idTextAnchor182),
    *Injecting Rust into a Python Flask App*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到本节结束时，我们将能够构建可扩展且能从外部世界接受数据的代码。有了这个，进一步阅读连接到数据库或读写文件的crate，将使我们能够无缝地将它们添加到我们结构良好的代码中。在数据库方面，我们将在[*第10章*](B17720_10__Final_SK_ePub.xhtml#_idTextAnchor182)中介绍如何镜像数据库模式并连接到它，*将Rust注入Python
    Flask应用*。
- en: 'For our toy example, we will be generating a random number for our sale stock
    price in order to calculate whether we sell at a profit or loss. We will do this
    by adding the `Cargo.toml` file with `rand="0.8.3"`. We can interact with our
    environment by carrying out the following steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的玩具示例，我们将生成一个随机数作为我们的销售库存价格，以便计算我们是盈利还是亏损。我们将通过添加带有`rand="0.8.3"`的`Cargo.toml`文件来实现这一点。我们可以通过以下步骤与环境交互：
- en: Import all the required crates.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有必需的crate。
- en: Collect the inputs from the environment.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从环境中收集输入。
- en: Process our inputs with orders.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用订单处理我们的输入。
- en: 'Let''s get started:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Now that our `rand` crate has been added, we can add all the extra imports
    that we need in the `main.rs` file with the following code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经添加了`rand` crate，我们可以在`main.rs`文件中使用以下代码添加我们需要的所有额外导入：
- en: '[PRE85]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We are using `env` to get the arguments passed into Cargo. We import everything
    from the prelude of the `rand` crate so that we can generate random numbers, and
    we import `FromStr` trait so that we can convert strings passed in from the command-line
    arguments into numbers.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`env`来获取传递给Cargo的参数。我们从`rand` crate的预导入中导入一切，以便我们可以生成随机数，并导入`FromStr`特质，以便我们可以将命令行参数中传递的字符串转换为数字。
- en: 'In our main function, we initially collect the arguments passed in from the
    command line with the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们最初使用以下代码从命令行收集传递的参数：
- en: '[PRE86]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We state that we are going to collect the command-line arguments in a vector
    of strings. We do this because pretty much everything can be represented as a
    string. We then define all the parameters that we need. We have to note that we
    start at index `1` instead of `0`. This is because index `0` is populated with
    the `run` command. We can also see that we are converting the strings into numbers
    when we need them and directly unwrapping them. This is a little dangerous; we
    should ideally match the result of the `from_str` function and give better information
    to the user if we were building a proper production command-line tool.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们声明我们将收集命令行参数到一个字符串向量中。我们这样做是因为几乎所有东西都可以表示为字符串。然后我们定义我们需要的所有参数。我们必须注意，我们从索引`1`开始，而不是`0`。这是因为索引`0`被`run`命令填充。我们还可以看到，当我们需要时，我们会将字符串转换为数字，并直接解包它们。这有点危险；如果我们正在构建一个真正的生产命令行工具，我们应该理想地匹配`from_str`函数的结果，并向用户提供更好的信息。
- en: 'Now that we have everything we need, we create a new order with the data we
    collected using the following code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的东西，我们使用以下代码创建一个新的订单，使用我们收集的数据：
- en: '[PRE87]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We are creating a new order every time even if it is a sell because we do not
    have storage, and we need to have all the structured data and logic around our
    stock position. We then match our actions. If we are going to sell our stock,
    we generate a new price for the stock before selling. Considering this, we can
    see whether we make a profit or not with the following code:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们每次都会创建一个新的订单，即使它是卖出，因为我们没有存储，我们需要所有关于我们股票头寸的结构化数据和逻辑。然后我们匹配我们的操作。如果我们打算卖出股票，我们会在卖出之前为股票生成一个新的价格。考虑到这一点，我们可以使用以下代码查看我们是否盈利：
- en: '[PRE88]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It must be noted that we have a `_` at the end of the match expression. This
    is because the string could theoretically be anything and Rust is a safe language.
    It will not allow us to compile the code if we did not account for every outcome.
    The `_` is a catch-all pattern. If not all of the match patterns are made, then
    this is executed. For us, we merely raise an error, stating that only sell and
    buy are supported.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须指出的是，我们在匹配表达式的末尾有一个`_`。这是因为字符串理论上可以是任何东西，而Rust是一种安全语言。如果我们没有考虑到每一种结果，它将不允许我们编译代码。`_`是一个通配符模式。如果并非所有的匹配模式都被使用，那么就会执行这个。对我们来说，我们只是抛出一个错误，指出只支持买卖。
- en: 'In order to run this program, we perform the following command:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行此程序，我们执行以下命令：
- en: '[PRE89]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Running this will give us the following outcome:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令将给出以下结果：
- en: '[PRE90]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The profit you make will be different, as the number generated will be random.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你获得的利润将不同，因为生成的数字将是随机的。
- en: Here we have it – our application is interactive and scalable. If you want to
    build more comprehensive command-line interfaces with help menus, it is recommended
    that you read and utilize the `clap` crate.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是我们的应用程序——它是交互式和可扩展的。如果你想构建带有帮助菜单的更全面的命令行界面，建议你阅读并使用`clap`crate。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the basics of Cargo. With Cargo, we managed
    to build basic applications, document them, compile them, and run them. Looking
    at how clean and easy this implementation was, it is clear to see why Rust is
    one of the most favored languages. Managing all the functionality, documentation,
    and dependencies in one file with a few lines of code speeds up the whole process.
    Combining this with a strict, helpful compiler makes Rust a no-brainer when it
    comes to managing complex projects. We managed our complexity by wrapping our
    module in easy-to-use interfaces and interacting with the user's inputs through
    the command line.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Cargo的基础知识。通过Cargo，我们成功地构建了基本的应用程序，对它们进行了文档化，编译并运行了它们。看到这种实现是多么干净和简单，很明显为什么Rust是最受欢迎的语言之一。通过一个文件中的几行代码管理所有功能、文档和依赖项，加快了整个过程。结合严格的、有帮助的编译器，使得Rust在管理复杂项目时成为不二之选。我们通过将模块包装在易于使用的接口中，并通过命令行与用户的输入交互来管理复杂性。
- en: Right now, as you stand, you can start building Rust code to solve a range of
    problems. If you want to build an application that interacts as a Rust web server
    with a frontend and database, I recommend that you read my other book on web development
    in Rust, *Rust Web Programming*, and start at [*Chapter 3*](B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046),
    as you have now covered enough Rust fundamentals to start building Rust servers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所站立的此刻，你可以开始编写Rust代码来解决一系列问题。如果你想构建一个作为Rust网络服务器与前端和数据库交互的应用程序，我建议你阅读我关于Rust网络开发的另一本书籍《Rust
    Web编程》，并从[*第3章*](B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046)开始，因为你已经掌握了足够的Rust基础知识，可以开始构建Rust服务器。
- en: In the next chapter of this book, we will cover how to exploit Rust's concurrency.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章中，我们将介绍如何利用Rust的并发性。
- en: Questions
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: As we continue to code, how do we document it?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着我们继续编码，我们如何对其进行文档化？
- en: Why is it important to keep modules isolated to a single concept?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么保持模块独立于单一概念很重要？
- en: How do we enable our modules to keep the advantages of isolated modules?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使我们的模块保持独立模块的优势？
- en: How do we manage dependencies in our application?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何管理应用程序中的依赖项？
- en: How do we ensure that all outcomes in a match expression are accounted for when
    there is theoretically an infinite number of outcomes, such as matching different
    strings?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当理论上存在无限多种结果时，例如匹配不同的字符串，我们如何确保在匹配表达式中所有结果都被考虑到？
- en: Let's say that we have a struct called `SomeStruct` in a `some_file/some_struct.rs`
    file. How do we make this available outside of the directory that it is in?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们在`some_file/some_struct.rs`文件中有一个名为`SomeStruct`的结构体。我们如何使其在它所在的目录之外可用？
- en: Let's say that we have changed our mind about our `SomeStruct` struct in question
    6 and we want it only available in the `some_file/` directory. How would we do
    this?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们改变了关于第6个问题中提到的`SomeStruct`结构体的想法，我们只想在`some_file/`目录中可用。我们该如何做？
- en: How can we access our `SomeStruct` struct in the `some_file/another_struct.rs`
    file?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在`some_file/another_struct.rs`文件中访问我们的`SomeStruct`结构体？
- en: Answers
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Our docstrings can support Markdown while we are building our structs and functions.
    Because it's Markdown, we can document ways in which we can implement the struct
    or function. If we are using Visual Studio Code, this also helps our productivity,
    as merely hovering the mouse over the function or struct throws up the documentation.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的文档字符串在构建结构和函数时可以支持 Markdown。因为它是 Markdown，所以我们可以记录实现结构或函数的方法。如果我们使用 Visual
    Studio Code，这也有助于提高我们的生产力，因为只需将鼠标悬停在函数或结构上就会弹出文档。
- en: Keeping our modules constrained to a single concept increases the flexibility
    of the application, enabling us to chop and change modules as and when they are
    needed.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的模块限制在单一概念内可以增加应用程序的灵活性，使我们能够根据需要切割和更改模块。
- en: In order to keep our modules isolated, we need to keep the interfaces of the
    module the same; this means that we can change logic inside the module without
    having to alter anything in the rest of the application. If we delete the module,
    we only have to look for implementations of the interface throughout the application
    as opposed to the implementation of all functions and structs in the module.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持我们的模块隔离，我们需要保持模块的接口不变；这意味着我们可以在不改变应用程序其余部分的情况下更改模块内部的逻辑。如果我们删除模块，我们只需要在整个应用程序中查找接口的实现，而不是模块中所有函数和结构的实现。
- en: We manage our dependencies in the `Cargo.toml` file. Just running Cargo will
    install the requirements we have when it is compiling before running.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `Cargo.toml` 文件中管理我们的依赖。只需运行 Cargo 就会在编译前安装我们所需的依赖。
- en: We can account for everything by catching anything that hasn't satisfied all
    our matches. This is done by implementing a `_` pattern at the end of our match
    expression, executing the code attached to that.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在匹配表达式的末尾实现一个 `_` 模式来捕捉任何未满足所有匹配条件的内容。这样做是通过执行附加到该模式的代码来完成的。
- en: We make it publicly available by writing `pub mod some_struct;` in the `some_file/mod.rs`
    file.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在 `some_file/mod.rs` 文件中写入 `pub mod some_struct;` 使其公开可用。
- en: We make it available only in the `some_file/` directory by writing `mod some_struct;`
    in the `some_file/mod.rs` file.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在 `some_file/mod.rs` 文件中写入 `mod some_struct;` 使其仅在 `some_file/` 目录中可用。
- en: We can access the `SomeStruct` by typing `use super::some_struct::SomeStruct;`
    in the `some_file/another_struct.rs` file.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在 `some_file/another_struct.rs` 文件中键入 `use super::some_struct::SomeStruct;`
    来访问 `SomeStruct`。
- en: Further reading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Rust Web Programming*, *Maxwell Flitton*, *Packt Publishing* (2021)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rust 网络编程*，Maxwell Flitton，Packt Publishing (2021)'
- en: '*Mastering Rust*, *Rahul Sharma and Vesa Kaihlavirta*, *Packt Publishing* (2019)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通 Rust*，Rahul Sharma 和 Vesa Kaihlavirta，Packt Publishing (2019)'
- en: '*The Rust Programming Language*, Rust Foundation: [https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
    (2018)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rust 编程语言*，Rust 基金会：[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
    (2018)'
- en: '*The Clap documentation*, Clap Docs: [https://docs.rs/clap/2.33.3/clap/](https://docs.rs/clap/2.33.3/clap/)
    (2021)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Clap 文档*，Clap Docs：[https://docs.rs/clap/2.33.3/clap/](https://docs.rs/clap/2.33.3/clap/)
    (2021)'
- en: '*The standard file documentation*, Rust Foundation: [https://doc.rust-lang.org/std/fs/struct.File.html](https://doc.rust-lang.org/std/fs/struct.File.html)
    (2021)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准文件文档*，Rust 基金会：[https://doc.rust-lang.org/std/fs/struct.File.html](https://doc.rust-lang.org/std/fs/struct.File.html)
    (2021)'
- en: '*The chrono DateTime documentation*, Rust Foundation: ,https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html
    (2021)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*chrono DateTime 文档*，Rust 基金会：[https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html](https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html)
    (2021)'
