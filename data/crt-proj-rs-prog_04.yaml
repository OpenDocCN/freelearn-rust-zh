- en: Creating a Full Server-Side Web App
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个完整的后端网页应用
- en: In the previous chapter, we saw how to build a REST web service using the Actix
    web framework. A REST web service must be used by a client app in order for it
    to be useful to us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用 Actix web 框架构建 RESTful 网络服务。为了对我们有用，RESTful 网络服务必须被客户端应用使用。
- en: In this chapter, we'll see how to build a very small but complete web app using
    the Actix web framework. We will use HTML code to be formatted in a web browser,
    JavaScript code to be executed in the same web browser, and the Tera crate to
    perform HTML templating. This is useful for embedding dynamic data inside HTML
    pages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何使用 Actix web 框架构建一个非常小但完整的网页应用。我们将使用 HTML 代码在网页浏览器中格式化，使用 JavaScript
    代码在同一网页浏览器中执行，以及使用 Tera crate 进行 HTML 模板化。这对于在 HTML 页面中嵌入动态数据非常有用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding what a classical web app is and what its HTML templates are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解经典网页应用及其 HTML 模板是什么
- en: Using the Tera template engine with Rust and Actix web
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 和 Actix web 中使用 Tera 模板引擎
- en: Using Actix web to handle requests of web pages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Actix web 处理网页请求
- en: Handling authentication and authorization in web pages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网页中处理身份验证和授权
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To best understand this chapter, you will need to have read the previous chapter.
    In addition, basic knowledge of HTML and JavaScript is assumed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地理解本章内容，你需要阅读上一章。此外，还假设你具备基本的 HTML 和 JavaScript 知识。
- en: The complete source code for this chapter can be found in the `Chapter04` folder of
    the repository at [https://github.com/PacktPublishing/Rust-2018-Projects](https://github.com/PacktPublishing/Rust-2018-Projects).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Rust-2018-Projects](https://github.com/PacktPublishing/Rust-2018-Projects)存储库的`Chapter04`文件夹中找到。
- en: Definition of a web app
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页应用的定义
- en: Everyone knows what a web page or a website is, and everyone knows that some
    web pages are quite static, while others have more dynamic behavior. The definition
    of a web app, however, is more subtle and controversial.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道什么是网页或网站，也知道有些网页相当静态，而有些则具有更多动态行为。然而，网页应用的定义却更为微妙且具有争议性。
- en: We will start with an operational definition of a web app; that is, looking
    at the appearance and behavior of web apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网页应用的运行定义开始；也就是说，观察网页应用的外观和行为。
- en: 'For our purposes, a web app is a website that has the following behavior:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，一个网页应用是一个具有以下行为的网站：
- en: It appears as one or more web pages in a web browser. On these pages, the user
    can interact with the page by pressing keys on a keyboard, clicking with a mouse,
    tapping on a touchscreen, or using another input device. For some user interactions,
    these web pages send requests to a server and receive data from that site as a
    response.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在网页浏览器中表现为一个或多个网页。在这些页面上，用户可以通过按键盘上的键、用鼠标点击、触摸屏上的点击或使用其他输入设备与页面进行交互。对于某些用户交互，这些网页会向服务器发送请求，并从该网站接收作为响应的数据。
- en: In the case of a *static* web page, the data received is always the same for
    the same request; but for a web app, the data received depends on the current
    state of the server, which can change with time. Upon receipt of the data, the
    web page shows other HTML code, either as a new full page or as a portion of the
    current page.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个*静态*网页，接收到的数据对于相同的请求始终相同；但对于网页应用，接收到的数据取决于服务器当前的状态，这可能会随时间变化。在接收到数据后，网页会显示其他
    HTML 代码，要么是新的完整页面，要么是当前页面的部分。
- en: Classic web apps receive HTML code from the server only, so all the browser
    must do is display the HTML code when it arrives. Modern apps more often receive
    raw data from the server and use JavaScript code within the browser to create
    the HTML code that displays the data.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的网页应用只从服务器接收 HTML 代码，因此浏览器在收到 HTML 代码时只需显示它。现代应用更常从服务器接收原始数据，并在浏览器中使用 JavaScript
    代码创建显示数据的 HTML 代码。
- en: Here, we are going to develop a rather classical web app, as our app receives
    mainly HTML code from the server. Some JavaScript code will be used to improve
    the structure of the app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将开发一个相当经典的网页应用，因为我们的应用主要从服务器接收 HTML 代码。一些 JavaScript 代码将被用来改进应用的结构。
- en: Understanding the behavior of a web app
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解网页应用的行为
- en: When a user navigates to a website by using the address bar of the browser or
    by clicking on a link in a page, the browser sends an HTTP `GET` request, with
    the URI specified in the address field or in the link element, such as `http://hostname.domainname:8080/dir/file?arg1=value1&arg2=value2`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过浏览器的地址栏或点击页面中的链接来导航到网站时，浏览器会发送一个HTTP `GET`请求，其中URI指定在地址字段或链接元素中，例如`http://hostname.domainname:8080/dir/file?arg1=value1&arg2=value2`。
- en: This address is commonly named **Uniform Resource Locator** (**URL**) or **Uniform
    Resource Identifier **(**URI**). The difference between these two acronyms is
    that a URI is something that uniquely identifies a resource without necessarily
    specifying *where* it can be found; a URL, however, specifies exactly *where* a
    resource can be found. In doing this, it also identifies the resource because
    there can be only one resource in a single place.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个地址通常被称为**统一资源定位符**（**URL**）或**统一资源标识符**（**URI**）。这两个缩写之间的区别在于，URI是唯一标识资源的东西，不一定指定它可以在哪里找到；而URL则精确指定了资源可以找到的位置。在这个过程中，它也标识了资源，因为单个位置只能有一个资源。
- en: So, every URL is also a URI, but an address can be a URI without being a URL.
    For example, an address that specifies the pathname of a file is a URL (and also
    a URI) because it specifies the path to the file. However, an address specifying
    a filter condition on files is a URI, but not a URL because it does not explicitly specify
    which file satisfies that condition.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个URL也是URI，但一个地址可以是URI而不一定是URL。例如，指定文件路径名的地址是URL（也是URI），因为它指定了文件的路径。然而，指定文件过滤条件的地址是URI，但不是URL，因为它没有明确指定哪个文件满足该条件。
- en: The first part of an address (such as `http://hostname.domainname:8080`), up
    to the (optional) port number, is needed to route the request to the server process
    that should handle it. This server must be running on the host computer and it
    must be waiting for incoming requests addressed at that port; or, as it is usually
    said, it must be listening on that port.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 地址的第一部分（如`http://hostname.domainname:8080`），直到（可选的）端口号，是必要的，以便将请求路由到应该处理它的服务器进程。这个服务器必须在主机计算机上运行，并且它必须等待针对该端口的传入请求；或者，通常的说法是，它必须在该端口上监听。
- en: The subsequent portion of the URI (such as `/dir/file`) is the so-called **path**,
    which always starts with a slash and ends at the first question mark character
    or at the end of the URI. The possible subsequent part (such as `?arg1=value1&arg2=value2`)
    is the so-called **query**, which has one or more fields separated by an ampersand.
    Any field of the query has a name, followed by an equals sign, followed by a value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: URI的后续部分（如`/dir/file`）被称为**路径**，它始终以斜杠开头，以第一个问号字符或URI的结尾为结束。可能的后续部分（如`?arg1=value1&arg2=value2`）被称为**查询**，它由一个或多个用与号分隔的字段组成。查询的任何字段都有一个名称，后面跟着一个等号，然后是值。
- en: When a request is made, the server should reply by sending an HTTP response,
    which contains the HTML page to display in the browser as its body.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当发起请求时，服务器应通过发送HTTP响应来回复，其中包含在浏览器中显示的HTML页面作为其主体。
- en: After the display of the initial page, any further interaction usually happens
    when the user operates on the page by using the keyboard, the mouse, or other
    input devices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始页面显示后，任何进一步的交互通常发生在用户通过键盘、鼠标或其他输入设备在页面上操作时。
- en: 'Notice that the effect of any user actions on a page can be classified in the
    following ways:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何用户操作对页面产生的影响可以分为以下几种方式：
- en: '**No code**: Some user actions are handled only by the browser, with no invoked application
    code. For example, when hovering the mouse over a widget, the mouse cursor shape
    changes; when typing in a text widget, the text inside that widget changes; and
    when clicking on a checkbox, the box is selected or deselected. Usually, this
    behavior is not controlled by the application code.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无代码**：某些用户操作仅由浏览器处理，没有调用应用程序代码。例如，当鼠标悬停在控件上时，鼠标光标形状会改变；当在文本控件中输入时，该控件内的文本会改变；当点击复选框时，框会被选中或取消选中。通常，这种行为不受应用程序代码的控制。'
- en: '**Frontend only**: Some user actions (such as the pressing of a key) trigger
    the execution of the client-side JavaScript code associated with these actions,
    but no client-server communication is performed and so no server-side code is
    invoked as a consequence of these user actions. Typically, any push button is
    associated (using the `onclick` attribute of the button element) to JavaScript
    code that is executed any time the user clicks that button. This code could, for
    example, enable or disable other widgets or copy data from a widget to another
    widget of the same page.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅前端**：某些用户操作（如按键按下）会触发与这些操作关联的客户端JavaScript代码的执行，但不会执行客户端-服务器通信，因此不会调用服务器端代码。通常，任何按钮都与（使用按钮元素的`onclick`属性）任何时间用户点击该按钮时执行的JavaScript代码相关联。此代码可以，例如，启用或禁用其他小部件或将数据从一个小部件复制到同一页面的另一个小部件。'
- en: '**Backend only**: Some user actions trigger client-server communication without
    using any JavaScript code. There are only two examples of these actions:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅后端**：某些用户操作会触发客户端-服务器通信，而不使用任何JavaScript代码。这些操作的例子只有两个：'
- en: Clicking on a `submit` input element inside an HTML `form` element
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML `form`元素内部点击一个`submit`输入元素
- en: Clicking on an `a` HTML element, better known as a **link**
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击一个**a** HTML元素，更广为人知的是**链接**
- en: '**Full-stack**: Some user actions trigger the execution of the client-side
    JavaScript code associated with that action. This JavaScript code sends one or
    more requests to the backend process and receives the responses sent as replies
    to these requests. The backend process receives the requests and responds properly
    to them. So, both the client-side application code and server-side application code
    is run.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全栈**：某些用户操作会触发与该操作关联的客户端JavaScript代码的执行。此JavaScript代码向后端进程发送一个或多个请求，并接收作为对这些请求的回复发送的响应。后端进程接收请求并适当地对它们做出响应。因此，客户端应用程序代码和服务器端应用程序代码都会运行。'
- en: Now, let's examine the advantages and disadvantages of these four cases. The
    *no code *case is the default one. If the basic behavior of the browser is good
    enough, there is no need to customize it. Some behavior customization can be performed
    using HTML or CSS.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨这四种情况的优势和劣势。**无代码**的情况是默认的。如果浏览器的基本行为足够好，就没有必要对其进行自定义。可以使用HTML或CSS执行一些行为自定义。
- en: The *frontend only* and the *full-stack* cases require JavaScript to be supported
    and enabled in the browser. This was once a problem because some people or platforms
    couldn't or wouldn't support it. Nowadays, something that wishes to be called
    a **web app**, and not simply a web page or website, cannot do so without the
    use of some kind of client-side processing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅前端**和**全栈**的情况需要浏览器支持并启用JavaScript。这曾经是一个问题，因为有些人或平台无法或不愿意支持它。如今，任何想要被称为**Web应用**而不是仅仅是一个网页或网站的东西，如果没有使用某种形式的客户端处理，就无法做到。'
- en: The frontend only case does not interact with the server, and so it may be useful
    and is recommended for any processes that do not need to send data outside of
    the current computer or do not need to receive data from another computer. For
    example, a calculator can be implemented in JavaScript with no communication with
    a server. However, most web apps need this communication.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 仅前端的情况不与服务器交互，因此对于不需要将数据发送到当前计算机之外或不需要从另一台计算机接收数据的任何过程可能很有用，并建议使用。例如，可以使用JavaScript实现计算器，而不与服务器通信。然而，大多数Web应用都需要这种通信。
- en: The backend only case was the original type of web communication available before
    JavaScript was invented. It is quite limited, though.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript发明之前，只有后端的情况是可用的Web通信类型。尽管如此，它相当有限。
- en: The concept of a link is useful for websites that are meant to be hypertext,
    not apps. Remember that **HT **in HTML and in HTTP stands for **Hypertext**. That
    was the original purpose of the web, but nowadays, web apps are meant to be general-purpose
    applications, not just hypertexts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的概念对于旨在成为超文本的网站是有用的，而不是应用。记住，HTML和HTTP中的**HT**代表**超文本**。这是网络的原始目的，但如今，Web应用旨在成为通用应用程序，而不仅仅是超文本。
- en: The concept of a form containing a submit button also limits the interaction
    to a rigid protocol—some fields are filled in and a button is pressed to send
    all of the data to the server. The server processes the request and sends back
    a new page that replaces the current page. In many cases, this can be done, but
    it is not a very pleasant experience for the user.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 包含提交按钮的表单概念也限制了交互到一个固定的协议——一些字段被填写，然后按下一个按钮将所有数据发送到服务器。服务器处理请求并发送一个新的页面来替换当前页面。在许多情况下，这可以完成，但对于用户来说，这并不是一个愉快的体验。
- en: The fourth case is called full-stack because, for these apps, there are both
    application frontend code and application backend code. As the frontend code needs
    the backend code to work properly, it can be seen as stacked on it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种情况被称为全栈，因为这些应用程序既有前端应用代码，也有应用后端代码。由于前端代码需要后端代码才能正常工作，因此它被视为堆叠在其上。
- en: Notice that *any* web interaction must have some machine code running on the
    frontend and some machine code running on the backend. On the frontend, there
    can be the web browser, the `curl` utility, or some other kind of HTTP client.
    On the backend, there can be a web server, such as **Internet Information Services**
    (**IIS**), Apache, or NGINX, or an application that acts as an HTTP server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*任何* Web交互都必须在前端和后端运行一些机器代码。在前端，可能有网络浏览器、`curl`实用程序或其他类型的HTTP客户端。在后端，可能有Web服务器，如**互联网信息服务**（**IIS**）、Apache或NGINX，或者一个充当HTTP服务器的应用程序。
- en: So, for any web app, there is client-server communication using the HTTP protocol.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于任何Web应用程序，都存在使用HTTP协议的客户端-服务器通信。
- en: The term *full-stack* means that, in addition to system software, there is also
    some application software running on the frontend (acting as an HTTP client) and
    some application software running on the backend (acting as an HTTP server).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*全栈*意味着，除了系统软件之外，还有一些应用软件在前端（作为HTTP客户端）运行，以及一些应用软件在后台（作为HTTP服务器）运行。
- en: In a typical full-stack application running on a browser, there are no links
    or forms, just the typical widgets of a GUI. Usually, these widgets are fixed
    text, editable fields, drop-down lists, check buttons, and push buttons. When
    the user presses any push button, a request is sent to the server, possibly using
    the values contained in the widgets, and when the server sends back an HTML page,
    that page is used to replace the current page or a portion of it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的在浏览器上运行的完整栈应用程序中，没有链接或表单，只有GUI的典型小部件。通常，这些小部件是固定文本、可编辑字段、下拉列表、复选按钮和推送按钮。当用户按下任何推送按钮时，会向服务器发送一个请求，可能使用小部件中包含的值，当服务器发送回一个HTML页面时，该页面用于替换当前页面或其部分。
- en: Project overview
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: The sample web app that we are going to build has the purpose of managing a
    list of people contained in a database. It is an extremely simple database as
    it only has one table with two columns—one for a numeric ID and one for a name.
    To keep the project simple, the database is actually a vector of struct objects kept
    in memory; but of course, in a real-world application, it would be stored in a
    **Database Management System** (**DBMS**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的示例Web应用程序的目的是管理数据库中包含的人员列表。这是一个极其简单的数据库，因为它只有一个表，有两列——一列是数字ID，另一列是名称。为了使项目简单，数据库实际上是一个存储在内存中的结构对象向量；但在现实世界的应用程序中，它当然会被存储在一个**数据库管理系统**（**DBMS**）中。
- en: 'The project will be built in steps, creating four projects that are progressively
    more complex, that can be downloaded from the GitHub repository linked in the
    *Technical requirements* section of this chapter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 项目将分步骤构建，创建四个逐渐变得更加复杂的项目，这些项目可以从本章*技术要求*部分中链接的GitHub仓库下载：
- en: The `templ` project is a collection of code snippets that shows how to use the
    Tera template engine for the projects of this chapter.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templ`项目是一系列代码片段，展示了如何为本章的项目使用Tera模板引擎。'
- en: The `list` project is a simple list of records about people that can be filtered
    by name. These records are actually contained in the database code and cannot
    be changed by the user.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`项目是一个关于人员的简单记录列表，可以根据名称进行筛选。这些记录实际上包含在数据库代码中，用户无法更改。'
- en: The `crud` project contains the features to add, change, and delete people.
    They are the so-called **Create, Retrieve, Update****, and** **Delete** (**CRUD**)
    basic functions.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crud`项目包含添加、更改和删除人员的功能。它们是所谓的**创建、检索、更新**和**删除**（**CRUD**）基本功能。'
- en: The `auth` project adds a login page and ensures that only authorized users
    can read or change the database. The list of users and their privileges cannot
    be changed, however.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth`项目添加了一个登录页面，并确保只有授权用户可以读取或更改数据库。然而，用户列表及其权限不能更改。'
- en: The `templ` project, which does not use the Actix web framework, can be compiled
    in 1 to 3 minutes the first time, and in a few seconds after any changes to the
    code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`templ`项目，它不使用Actix Web框架，第一次编译需要1到3分钟，而在代码有任何更改后，只需几秒钟。'
- en: Any of the other projects will take around 3 to 9 minutes to compile the first
    time, then 8 to 20 seconds after any changes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其他任何项目第一次编译大约需要3到9分钟，而在代码有任何更改后，大约需要8到20秒。
- en: When you run any of the preceding projects (except the first one), all you will
    see is `Listening at address 127.0.0.1:8080` printed on the console. To view anything
    more, you will need a web browser.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行上述任何项目（除了第一个）时，你将在控制台上看到`Listening at address 127.0.0.1:8080`打印出来。要查看更多内容，你需要一个网页浏览器。
- en: Using the Tera template engine
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tera模板引擎
- en: Before starting to develop our web app, we will examine the concept of a **template
    engine**—in particular, the Tera crate, one of the many template engines available
    for Rust.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发我们的Web应用之前，我们将检查**模板引擎**的概念——特别是Tera crate，这是Rust可用的众多模板引擎之一。
- en: Template engines can have several applications, but they are mostly used for
    web development.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎可以有几种应用，但它们主要用于网页开发。
- en: 'A typical problem in web development is knowing how to generate HTML code containing
    some constants parts written by hand and some dynamic parts generated by application
    code. In general, there are two ways to obtain this kind of effect:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 网页开发中一个典型的问题是知道如何生成包含一些手动编写的常量部分和由应用程序代码生成的动态部分的HTML代码。一般来说，有两种方法可以获得这种效果：
- en: You have a programming language source file that contains a lot of statements
    that print strings to create the desired HTML page. These `print` statements mix
    string literals (that is, strings enclosed in quotation marks) and variables formatted
    as strings. This is what you'd do in Rust if you didn't have a template engine.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个包含大量打印字符串语句的编程语言源文件，以创建所需的HTML页面。这些`print`语句混合了字符串字面量（即用引号括起来的字符串）和格式化为字符串的变量。如果你没有模板引擎，你会在Rust中这样做。
- en: You write an HTML file containing the desired constant HTML elements and the
    desired constant text, but it also contains some statements enclosed in specific
    markers. The evaluation of these statements generates the variable parts of the
    HTML file. This is what you'd do in PHP, JSP, ASP, and ASP.NET.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你编写一个包含所需常量HTML元素和所需常量文本的HTML文件，但它还包含一些用特定标记包围的语句。这些语句的评估生成了HTML文件的变量部分。这就是你在PHP、JSP、ASP和ASP.NET中会做的事情。
- en: However, there is also a compromise, which is to write both application code
    files and HTML code containing statements to evaluate. You can then choose the
    best tool for the job. This is the paradigm used by template engines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在一种折衷方案，即编写包含评估语句的应用程序代码文件和HTML代码。然后你可以选择最适合这项工作的工具。这是模板引擎使用的范式。
- en: Imagine you have some Rust code files and some HTML files that must cooperate
    with one another. The tool to make the two worlds communicate is a template engine.
    The HTML files with embedded statements are named **templates** and the Rust application
    code calls the template engine functions to manipulate these templates.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些Rust代码文件和一些必须相互协作的HTML文件。使这两个世界通信的工具是模板引擎。包含嵌入式语句的HTML文件被称为**模板**，Rust应用程序代码调用模板引擎函数来操作这些模板。
- en: 'Now, let''s see the code in the `templ` example project. The first statement
    creates an instance of the engine:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`templ`示例项目中的代码。第一条语句创建了一个引擎实例：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second statement loads one simple template into the engine by calling the `add_raw_template`
    function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条语句通过调用`add_raw_template`函数将一个简单的模板加载到引擎中：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first argument is the name that will be used to refer to this template and
    the second argument is the template itself. It is a normal reference to a string
    slice, but it contains the `{{id}}` placeholder. This symbol qualifies it as a
    **Tera** **expression**. In particular, this expression contains just a Tera variable,
    but it could contain a more complex expression.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要用来引用此模板的名称，第二个参数是模板本身。这是一个对字符串切片的正常引用，但它包含`{{id}}`占位符。这个符号使其成为**Tera**
    **表达式**。特别是，这个表达式只包含一个Tera变量，但它可以包含更复杂的表达式。
- en: A constant expression is also allowed, such as `{{3+5}}`, even if there is no
    point in using constant expressions. A template can contain several expressions
    or none at all.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 允许使用常量表达式，例如 `{{3+5}}`，即使使用常量表达式没有意义。一个模板可以包含多个表达式，也可以一个都不包含。
- en: 'Notice that the `add_raw_template` function is fallible, so `unwrap` is called
    on its result. This function, before adding the template received as an argument,
    analyzes it to see whether it is well-formed. For example, if it read `"Identifier:
    {{id}."` (with a missing brace), it would generate an error, and so the call to
    `unwrap` would panic.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，`add_raw_template` 函数是可能失败的，所以对其结果调用了 `unwrap`。在将作为参数接收的模板添加之前，此函数会分析它以查看其是否格式正确。例如，如果它读取
    `"Identifier: {{id}."`（缺少大括号），它将生成一个错误，因此对 `unwrap` 的调用将导致恐慌。'
- en: When you have a Tera template, you can **render** it; that is, generate a string
    that replaces the expressions with some specified strings, in a similar way to
    how a macro processor does.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个 Tera 模板时，你可以**渲染**它；也就是说，生成一个字符串，用一些指定的字符串替换表达式，这与宏处理器的做法类似。
- en: 'To evaluate an expression, the Tera engine has to first replace all of the
    variables used in it with their current value. To do that, a collection of Tera
    variables—each one associated with its current value—must be created. This collection
    is named a context. A context is created and populated by the following two statements:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估一个表达式，Tera 引擎必须首先用其当前值替换其中使用的所有变量。为此，必须创建一个 Tera 变量的集合——每个变量都与它的当前值相关联——这个集合被称为上下文。上下文是通过以下两个语句创建和填充的：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first one creates a mutable context and the second one inserts a key-value
    association into it. Here, the value is a reference to a number, but other types
    are also allowed as values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个创建了一个可变上下文，第二个将键值对插入其中。在这里，值是一个数字的引用，但也可以作为值使用其他类型。
- en: Of course, in a real-world example, the value would be a Rust variable, not
    a constant.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实世界的例子中，值将是一个 Rust 变量，而不是一个常量。
- en: 'Now, we can render it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以渲染它：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `render` method gets a template named `"id_template"` in the `tera_engine`
    object and applies the substitutions specified by the `numeric_id` context.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 方法从 `tera_engine` 对象中获取一个名为 `"id_template"` 的模板，并应用由 `numeric_id`
    上下文指定的替换。'
- en: 'This can fail if the specified template is not found, if variables in the template
    have not been substituted, or if an evaluation has failed for some other reason.
    If the result is okay, `unwrap` gets the string. Therefore, it should print the
    following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的模板未找到，如果模板中的变量未替换，或者由于其他原因评估失败，这可能会失败。如果结果正常，`unwrap` 获取字符串。因此，它应该打印以下内容：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next three Rust statements in the example are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的下一个三个 Rust 语句如下：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'They do the same thing, but with a literal string, showing that the same template
    variable can be replaced with both a number and a string. The printed line should
    be as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它们做的是同一件事，但使用一个字面字符串，表明相同的模板变量可以用数字和字符串替换。打印的行应该是这样的：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next statement is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个语句如下：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It adds a new template to the engine containing the `{{person.id}}` expression.
    This Tera dot notation has the same function as the Rust dot notation—it allows
    us to access a field of a struct. Of course, it only works if the `person` variable
    is replaced by an object with an `id` field.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它向引擎添加了一个包含 `{{person.id}}` 表达式的模板。这个 Tera 点符号与 Rust 点符号具有相同的功能——它允许我们访问结构体的一个字段。当然，它只在我们用具有
    `id` 字段的对象替换 `person` 变量时才有效。
- en: 'So, a `Person` struct is defined in the following way:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Person` 结构体定义如下：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The struct has an `id` field but also derives the `Serialize` trait. This is
    a requirement for any object that must be passed to a Tera template.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体有一个 `id` 字段，但也派生了 `Serialize` 特性。这是任何必须传递给 Tera 模板的对象的必要条件。
- en: 'The statement to define the `person` variable in the context is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 定义上下文中的 `person` 变量的语句如下：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, the printed string will be as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打印的字符串将是以下内容：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, there is a more complex template:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个更复杂的模板：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The template is one-line long, but it has been split into three lines in Rust
    source code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是一行长的，但在 Rust 源代码中已被拆分为三行。
- en: In addition to the `{{person.id}}` expression, there are three markers of another
    kind; they are **Tera statements**. Tera statements differ from Tera expressions
    because they are enclosed by the `{%` and `%}` signs, instead of double braces.
    While Tera expressions are similar to C preprocessor macros (that is, `#define`),
    Tera statements are similar to the conditional compilation directives of the C
    preprocessor (that is, `#if`, `#else`, and `#endif`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `{{person.id}}` 表达式之外，还有三种其他类型的标记；它们是 **Tera 语句**。Tera 语句与 Tera 表达式不同，因为它们被
    `{%` 和 `%}` 符号包围，而不是双大括号。虽然 Tera 表达式类似于 C 预处理器宏（即 `#define`），但 Tera 语句类似于 C 预处理器的条件编译指令（即
    `#if`、`#else` 和 `#endif`）。
- en: The expression after the `if` statement is evaluated by the `render` function.
    If the expression is not defined or its value is either `false`, `0`, an empty
    string, or an empty collection, the expression is considered false. The text part—up
    to the `{%else%}` statement—is then discarded. Otherwise, the part after that
    statement, up to the `{%endif%}` statement, is discarded.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句之后的表达式由 `render` 函数进行评估。如果该表达式未定义或其值为 `false`、`0`、空字符串或空集合，则该表达式被视为
    `false`。然后，从 `{%else%}` 语句开始的部分文本将被丢弃。否则，从该语句之后到 `{%endif%}` 语句的部分将被丢弃。'
- en: 'This template is rendered with two different contexts—one in which the `person`
    variable is defined and the other in which no variable is defined. The two printed lines
    are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板使用两种不同的上下文进行渲染——一种是在其中定义了 `person` 变量的上下文，另一种是没有定义变量的上下文。打印出的两行如下：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the first case, the `id` value of the person is printed; in the second case,
    the `No person` text is printed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，打印出人的 `id` 值；在第二种情况下，打印出 `No person` 文本。
- en: 'Then, another complex template is created:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建了一个更复杂的模板：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the template contains two other kinds of statements—`{%for p in persons%}`
    and `{%endfor%}`. They enclose a loop where the newly created `p` variable iterates
    over the `persons` collection, which must belong to the context used by `render`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模板包含两种其他类型的语句——`{%for p in persons%}` 和 `{%endfor%}`。它们包含一个循环，新创建的 `p` 变量遍历
    `persons` 集合，该集合必须属于 `render` 所使用的上下文。
- en: 'Then, there is the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有以下的代码：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This adds a Tera variable named `persons` to the `three_persons` Tera context.
    This variable is a vector containing three people.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这向 `three_persons` Tera 上下文添加了一个名为 `persons` 的 Tera 变量。该变量是一个包含三个人的向量。
- en: 'Because the `persons` variable can be iterated, it is possible to evaluate
    the template, thereby obtaining the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `persons` 变量可以遍历，所以可以评估模板，从而获得以下结果：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that any `Id` object is in a distinct line because the template contains
    a new-line character (through the `\n` escape sequence); otherwise, they would
    have been printed in a single line.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何 `Id` 对象都位于单独的一行，因为模板包含一个换行符字符（通过 `\n` 转义序列）；否则，它们将打印在同一行。
- en: So far, we have used templates in string literals. This becomes difficult for
    long templates, though. Therefore, templates are usually loaded from separate
    files. This is advisable because the **Integrated Development Environment** (**IDE**)
    can help the developer (if it knows which language it is processing) and so it
    is better to keep HTML code in files with a `.html` suffix, CSS code in files
    with a `.css` suffix, and so on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在字符串字面量中使用了模板。但是，对于长模板来说，这会变得很困难。因此，模板通常是从单独的文件中加载的。这是可取的，因为 **集成开发环境**（**IDE**）可以帮助开发者（如果它知道正在处理哪种语言）因此，最好将
    HTML 代码保存在以 `.html` 后缀的文件中，CSS 代码保存在以 `.css` 后缀的文件中，等等。
- en: 'The next statement loads a Tera template from a file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个语句从文件中加载一个 Tera 模板：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first argument of the `add_template_file` function is the path of the template
    file, relative to the root of the project. It is good practice to put all the
    template files in a separate folder or in its subfolders.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_template_file` 函数的第一个参数是模板文件的路径，相对于项目的根目录。将所有模板文件放在单独的文件夹或其子文件夹中是一种良好的做法。'
- en: The second argument allows us to specify the name of the new template. If the
    value of that argument is `None`, the name of the new template is the first argument.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数允许我们指定新模板的名称。如果该参数的值为 `None`，则新模板的名称是第一个参数。
- en: 'So, the statement is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该语句如下：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will print the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code will have similar results:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将产生类似的结果：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Lastly, let's talk about a convenient feature that can be used to load all of
    the templates with a single statement.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们谈谈一个方便的功能，它可以用来通过单个语句加载所有模板。
- en: 'Instead of loading the templates one at a time, where they are needed, it is
    possible to load all of the templates at once and store them in a global dictionary.
    This makes them available to the entire module. To do so, it is convenient to
    use the `lazy_static` macro, described in [Chapter 1](91f1fe5a-241f-48e3-b16d-5110dcccd597.xhtml), *Rust
    2018 – Productivity!*, to write outside of any function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是逐个加载模板，在需要的地方加载，可以一次性加载所有模板并将它们存储在全局字典中。这使得它们在整个模块中可用。为此，可以使用在[第1章](91f1fe5a-241f-48e3-b16d-5110dcccd597.xhtml)
    *Rust 2018 – Productivity!* 中描述的`lazy_static`宏，在函数外部编写：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This statement defines the `TERA` static variable as a global template engine.
    It will be initialized automatically when some Rust code of your app uses it first.
    This initialization will search all of the files in the specified subtree of folders
    and will load them, giving each of them the name of the file itself and omitting
    the name of its folder.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句定义了`TERA`静态变量作为一个全局模板引擎。当你的应用中的某些Rust代码首次使用它时，它将自动初始化。这个初始化将在指定的文件夹子树中的所有文件中进行搜索，并将它们加载，给每个文件赋予文件名本身，并省略其文件夹名称。
- en: 'The last feature of the Tera engine to be presented in this section is the
    `include` statement. The last line of the `templ_names.txt` file is the following
    one:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后要介绍的Tera引擎的功能是`include`语句。`templ_names.txt`文件的最后一行是以下内容：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It will load the contents of the specified file and will expand it inline, replacing
    the statement itself. It is similar to the `#include` directive of the C preprocessor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它将加载指定文件的内容并将其内联展开，替换掉原语句。这类似于C预处理器中的`#include`指令。
- en: A simple list of persons
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的个人列表
- en: 'Now, we can examine the `list` project. If you run the server in a console
    and you access the `localhost:8080` address from a web browser, you will see the
    following page in the browser:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查`list`项目。如果你在控制台中运行服务器，并通过网页浏览器访问`localhost:8080`地址，你将在浏览器中看到以下页面：
- en: '![](img/25e04587-5149-4f67-8d6b-5c9b5ace7d9a.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25e04587-5149-4f67-8d6b-5c9b5ace7d9a.png)'
- en: There is a heading, a label, a text field, a push button, and a table containing
    a list of three people.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个标题，一个标签，一个文本字段，一个推送按钮，以及一个包含三个人名单的表格。
- en: 'The only thing you can do on this page is type something into the text field
    and then click on the button to apply the typed text as a filter. For example,
    if you type `l` (that is, a lowercase *L*), only the Hamlet and Othello lines
    will appear as they are the only two people whose name contains this letter. If
    the filter is `x`, the result will be the No persons text as none of the three
    people has a name containing this letter. The page will look as in the following
    screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，你可以做的唯一一件事是在文本字段中输入一些内容，然后点击按钮将输入的文本作为过滤器应用。例如，如果你输入`l`（即小写的*L*），只有哈姆雷特和奥赛罗的台词会出现，因为他们是唯一两个名字中包含这个字母的人。如果过滤器是`x`，结果将是“无人员”文本，因为这三个人中没有一个人的名字包含这个字母。页面看起来如下截图所示：
- en: '![](img/26f2dd2b-1014-4dc7-924a-76d853a01643.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26f2dd2b-1014-4dc7-924a-76d853a01643.png)'
- en: 'Before explaining how it all works, let''s see the dependencies of this project;
    that is, the external crates used by it. They are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释这一切是如何工作的之前，让我们看看这个项目的依赖项；即它使用的外部crate。它们如下所示：
- en: '`actix-web`: This is the web framework, also used in [Chapter 3](febceb22-18dd-437f-bd27-9895aef47384.xhtml),
    *Creating a REST Web Service*.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actix-web`：这是一个Web框架，也在[第3章](febceb22-18dd-437f-bd27-9895aef47384.xhtml) *创建RESTful
    Web服务* 中使用。'
- en: '`tera`: This is the Tera template engine.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tera`：这是Tera模板引擎。'
- en: '`serde` and `serde_derive`: These are the serialization crates used by the
    Tera engine to pass whole struct objects to a template context.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serde`和`serde_derive`：这些是Tera引擎使用的序列化crate，用于将整个结构体对象传递到模板上下文中。'
- en: '`lazy_static`: This contains the macro to initialize the Tera engine.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lazy_static`：这包含初始化Tera引擎的宏。'
- en: 'Now, let''s take a glimpse at the source code. For this project, the `src`
    folder contains the following files:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下源代码。对于这个项目，`src`文件夹包含以下文件：
- en: '`main.rs`: This is the whole server-side application, excluding the database.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.rs`：这是整个服务器端应用程序，不包括数据库。'
- en: '`db_access.rs`: This is the mock database with some mock data.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db_access.rs`：这是一个包含一些模拟数据的模拟数据库。'
- en: '`favicon.ico`: This is the icon that any website should have as it is automatically
    downloaded by the browser to display it in the browser tab.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`favicon.ico`: 这是任何网站都应该有的图标，因为它会被浏览器自动下载并在浏览器标签中显示。'
- en: 'There is also a `templates` folder, containing the following files:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 `templates` 文件夹，包含以下文件：
- en: '`main.html`: This is the Tera/HTML template of the whole web page with an empty
    body.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.html`: 这是整个网页的 Tera/HTML 模板，其中包含一个空白的主体。'
- en: '`persons.html`: This is the Tera/HTML template of a partial web page, containing
    only the body of our web app.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persons.html`: 这是部分网页的 Tera/HTML 模板，仅包含我们 Web 应用的主体。'
- en: '`main.js`: This is the JavaScript code to be included in the HTML page.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.js`: 这是需要包含在 HTML 页面中的 JavaScript 代码。'
- en: Now, let's examine the mechanics of this web app.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查这个 Web 应用的机制。
- en: 'When the user navigates to the `http://localhost:8080/` URI, the browser sends a
    `GET` HTTP request (that has only a slash as its path) to our process, with no
    query and empty body, and it expects an HTML page to be displayed. As described
    in the previous chapter, the server—using the Actix web framework—can respond
    to the request if its `main` function contains the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航到 `http://localhost:8080/` URI 时，浏览器向我们的进程发送一个 `GET` HTTP 请求（其路径只有一个斜杠），没有查询和空主体，并期望显示一个
    HTML 页面。正如前一章所述，服务器——使用 Actix Web 框架——如果其 `main` 函数包含以下代码，则可以响应请求：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we have a web app whose state is only a shared reference to a database
    connection (that is actually a mock database). This app accepts only one kind
    of request—those using the root path (`/`) and the `GET` method. These requests
    are routed to the `get_main` function. The function should return an HTTP response
    containing the initial HTML page to display.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个 Web 应用，其状态仅是一个对数据库连接（实际上是一个模拟数据库）的共享引用。这个应用只接受一种类型的请求——使用根路径 (`/`)
    和 `GET` 方法的请求。这些请求被路由到 `get_main` 函数。该函数应返回一个包含要显示的初始 HTML 页面的 HTTP 响应。
- en: 'Here is the body of the `get_main` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `get_main` 函数的主体：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function does not use the request at all because it always returns the
    same result.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数根本不使用请求，因为它总是返回相同的结果。
- en: To return a successful response (that is, with status code `200`), the `HttpResponse::Ok()`
    function is called. To specify that the body of the response is HTML code, the `content_type("text/html")`
    method is called on the response. To specify the content of the body of the response,
    the `body` method is called on the response.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回一个成功的响应（即状态码 `200`），调用 `HttpResponse::Ok()` 函数。要指定响应的主体是 HTML 代码，在响应上调用 `content_type("text/html")`
    方法。要指定响应主体的内容，在响应上调用 `body` 方法。
- en: 'The argument of the `body` function must be a string containing the HTML code
    to display. It is possible to write all of that code here, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`body` 函数的参数必须是一个包含要显示的 HTML 代码的字符串。可以像下面这样在这里编写所有代码：'
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, for more complex pages, it is better to keep all the HTML code in
    a separate file, with the `.html` filename extension, and to load the contents
    of this file into a string to pass as an argument to the `body` function. This
    can be done using the following expression:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更复杂的页面，最好将所有 HTML 代码保存在一个单独的文件中，使用 `.html` 文件名扩展名，并将该文件的内容加载到一个字符串中，作为
    `body` 函数的参数传递。这可以通过以下表达式完成：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This would work well if the `main.html` file was static; that is, it wouldn''t
    need to change at runtime. However, this solution would be too limiting for two
    reasons:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `main.html` 文件是静态的；也就是说，它不需要在运行时更改，这将工作得很好。然而，这个解决方案有两个原因过于限制：
- en: We want our initial page to be a *dynamic* page. It should show the list of
    people that are in the database when the page is opened.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望我们的初始页面是一个 *动态* 页面。当页面打开时，它应该显示数据库中的人名单。
- en: We want our initial page, and also all of the other possible pages, to be composed
    of several parts: metadata elements, JavaScript routines, styles, a page header,
    a page central part, and a page footer. All of these parts, except for the central
    part, are to be shared by all of the pages to avoid repeating them in source code.
    So, we need to keep these parts in separate files and then splice them together
    before the HTML page is sent to the browser. In addition, we want to keep JavaScript
    code in separate files with the `.js` file extension and style code in separate
    files with the `.css` file extension so that our IDE recognizes their language.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望我们的初始页面，以及所有其他可能的页面，由几个部分组成：元数据元素、JavaScript程序、样式、页面标题、页面主体部分和页面页脚。所有这些部分（除了主体部分）都应由所有页面共享，以避免在源代码中重复它们。因此，我们需要将这些部分保存在单独的文件中，然后在将HTML页面发送到浏览器之前将它们拼接在一起。此外，我们希望将JavaScript代码保存在具有`.js`文件扩展名的单独文件中，将样式代码保存在具有`.css`文件扩展名的单独文件中，以便我们的IDE能够识别它们的语言。
- en: A solution to these problems is to use the Tera template engine, which we will
    see in the next section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法之一是使用Tera模板引擎，我们将在下一节中看到。
- en: The templates folder
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板文件夹
- en: It is best to put all deliverable application text files in the `templates`
    folder (or in some of its subfolders). So, this subtree should contain all the
    HTML, CSS, and JS files, even if, at the moment, they may contain no Tera statements
    or expressions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将所有可交付的应用程序文本文件放在`templates`文件夹中（或其子文件夹中的某些文件夹）。因此，这个子树应该包含所有的HTML、CSS和JS文件，即使目前它们可能不包含任何Tera语句或表达式。
- en: Instead, non-textual files (such as pictures, audio, video, and many others),
    user-uploaded files, documents that are to be downloaded explicitly, and databases
    should be kept elsewhere.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，非文本文件（如图片、音频、视频等）、用户上传的文件、需要明确下载的文档以及数据库应保存在其他地方。
- en: The loading of all template files happens at runtime, but usually only once
    in the process life. The fact that the loading happens at runtime implies that
    the `templates` subtree must be deployed and that to deploy a new or changed version
    of one of those files, a rebuild of the program is not required. The fact that
    this loading usually happens once in the process life implies that the template
    engine is quite fast at processing the templates after the first time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模板文件的加载发生在运行时，但通常只在进程生命周期中发生一次。加载发生在运行时的这一事实意味着`templates`子树必须部署，并且要部署这些文件的新版本或更改版本，不需要重新构建程序。这一加载通常只在进程生命周期中发生一次的事实意味着模板引擎在第一次之后处理模板的速度相当快。
- en: 'The preceding body statement has the following argument:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的body语句具有以下参数：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This expression renders the template contained in the `main.html` file using
    a Tera context contained in the `context` Rust variable. This kind of variable
    has been initialized by the `tera::Context::new()` expression and so it is an
    empty context.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此表达式使用`context` Rust变量中包含的Tera上下文来渲染`main.html`文件中包含的模板。此类变量已通过`tera::Context::new()`表达式初始化，因此它是一个空上下文。
- en: 'The HTML file is very small and it has two noteworthy snippets. The first one
    is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件非常小，它有两个值得注意的片段。第一个如下：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This uses the `include` Tera statement to incorporate the JavaScript code into
    the HTML page. Having it incorporated into the server means that no further HTTP
    requests will be needed to load it. The second snippet is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`include` Tera语句将JavaScript代码合并到HTML页面中。这意味着将其合并到服务器意味着不需要进一步的HTTP请求来加载它。第二个片段如下：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This causes the invocation of the `getPage` JavaScript function as soon as the
    page is loaded. This function is defined in the `main.js` file and, as its name
    suggests, it causes the loading of the specified page.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致页面加载时立即调用`getPage` JavaScript函数。此函数定义在`main.js`文件中，正如其名称所暗示的，它会导致指定页面的加载。
- en: So, when the user navigates to the root of the website, the server prepares
    an HTML page containing all the required JavaScript code, but almost no HTML code,
    and sends it to the browser. As soon as the browser has loaded the empty page,
    it requests another page, which will become the body of the first page.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户导航到网站的根目录时，服务器准备了一个包含所有必需的JavaScript代码但几乎不含HTML代码的HTML页面，并将其发送到浏览器。一旦浏览器加载了空页面，它就会请求另一个页面，该页面将成为第一个页面的主体。
- en: This may sound complicated, but you can look at it as the page being split into
    two parts—the metadata, the scripts, the styles, and possibly the page header
    and footer are the common parts, which do not change during the session. The central
    part (which here is the `body` element, but may also be an inner element) is the
    variable part, which changes with any click from the user.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但你可以把它看作页面被分成两部分——元数据、脚本、样式，以及可能还有页面头部和页脚是公共部分，这些在会话期间不会改变。中心部分（在这里是`body`元素，但也可能是一个内部元素）是变量部分，它会随着用户的任何点击而改变。
- en: By reloading only part of the page, the app has better performance and usability.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过只重新加载页面的一部分，应用程序具有更好的性能和可用性。
- en: 'Let''s look at the contents of the `main.js` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`main.js`文件的内容：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code creates an `XMLHttpRequest` object that, in spite of its name, does
    not use XML, but it is actually used to send an HTTP request. This object is set
    to process the response when it arrives by assigning an anonymous function to
    the `onreadystatechange` field. Then, the specified URI is opened with a `GET`
    method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个`XMLHttpRequest`对象，尽管它的名字叫XML，但实际上并不使用XML，而是用来发送HTTP请求。此对象被设置为在响应到达时通过将匿名函数分配给`onreadystatechange`字段来处理响应。然后，使用`GET`方法打开指定的URI。
- en: When a response arrives, the code checks whether the message is complete (`readystate
    == 4`) and valid (`state == 200`). In this case, the text of the response that
    is assumed to be valid HTML is assigned as the content of the element that has
    `body` as its unique ID.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应到达时，代码会检查消息是否完整（`readystate == 4`）和有效（`state == 200`）。在这种情况下，假设为有效HTML的响应文本被分配为具有`body`唯一ID的元素的内容。
- en: The last file in the `templates` folder is the `persons.html` file. It is a
    partial HTML file—that is, a file containing HTML elements, but without the `<html>`
    element itself—and so its purpose is to be included in another HTML page. This
    small app has only one page and so it only has one partial HTML file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`templates`文件夹中的最后一个文件是`persons.html`文件。它是一个部分HTML文件——也就是说，一个包含HTML元素但不含`<html>`元素的文件——因此它的目的是被包含在另一个HTML页面中。这个小应用程序只有一个页面，所以它只有一个部分HTML文件。'
- en: 'Let''s look at some interesting parts of this file. The following is an element
    to let the user type in some text (a so-called **edit box**):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个文件的一些有趣的部分。以下是一个允许用户输入文本的元素（所谓的**编辑框**）：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Its initial value—that is, the text that is shown to the user when the page
    is opened—is a **Tera variable**. Rust code should assign a value to the variable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 它的初始值——即在页面打开时显示给用户的文本——是一个**Tera变量**。Rust代码应该给这个变量赋值。
- en: 'Then, there is the `Filter` push button:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这里有`Filter`按钮：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When the user clicks on it and the preceding edit box contains the word `Ham`, the `'/page/persons?partial_name=Ham'` argument is
    passed to the JavaScript `getPage` functions. So, the function sends the `GET`
    request to the backend and replaces the body of the page with whatever is returned
    by the backend, so long as it is a complete and valid response.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击它，并且前面的编辑框包含单词`Ham`时，`'/page/persons?partial_name=Ham'`参数会被传递给JavaScript的`getPage`函数。因此，该函数向后端发送`GET`请求，并将页面的主体替换为后端返回的任何内容，只要它是一个完整且有效的响应。
- en: 'Then, there is the following Tera statement:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这里有以下的Tera语句：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the `persons` Tera variable is evaluated. According to the Rust program,
    the variable can only be a collection. If the variable is a non-empty collection,
    a table is inserted into the HTML page; if instead the variable is not defined
    or it is an empty collection, the `No persons.` text will be shown.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`persons` Tera变量被评估。根据Rust程序，变量只能是一个集合。如果变量是一个非空集合，则会在HTML页面中插入一个表格；如果变量未定义或它是一个空集合，则显示`No
    persons.`文本。
- en: 'Within the HTML code defining the table, there is the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义表格的HTML代码中，有如下内容：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is an iteration over the items contained in `persons` (which we know is
    non-empty).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对`persons`（我们知道它是非空的）中包含的项目进行迭代。
- en: In each iteration, the `p` variable will contain the data of a specific person.
    This variable is used in two expressions. The first one shows the value of the
    `id` field of the variable. The second one shows the value of its `name` field.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，`p`变量将包含一个特定人的数据。这个变量在两个表达式中使用。第一个表达显示了变量的`id`字段的值。第二个表达显示了其`name`字段的值。
- en: The other Rust handlers
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他Rust处理器
- en: We have only seen the routing and handling of the root of the site—the `/` path.
    This happens when the user opens the page.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只看到了网站根部的路由和处理——即`/`路径。这发生在用户打开页面时。
- en: 'There are four other requests that can be sent by the browser to this app:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器可以向该应用程序发送四种其他请求：
- en: When the root path is accessed, the page loaded by this request automatically
    sends—using JavaScript code—another request to load the body of the page.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问根路径时，由该请求加载的页面会自动使用JavaScript代码发送另一个请求以加载页面主体。
- en: When the user presses the Filter button, the frontend should send the text contained
    in the edit box to the backend, and then the backend should respond by sending
    back the list of the people satisfying this filter.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户按下筛选按钮时，前端应将编辑框中包含的文本发送到后端，然后后端应通过发送满足此筛选条件的人员列表进行响应。
- en: The browser automatically requests the `favicon.ico` app icon.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器自动请求`favicon.ico`应用图标。
- en: Any other requests should be treated as errors.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他请求都应被视为错误。
- en: Actually, the first and second of these requests can be handled in the same
    way, because the initial state can be generated by a filter where an empty string
    is specified. So, three different kinds of requests remain.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些请求中的第一和第二条可以以相同的方式处理，因为初始状态可以通过指定空字符串的筛选生成。因此，剩下三种不同类型的请求。
- en: 'To route these requests, the following code is inserted into the `main` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了路由这些请求，以下代码被插入到`main`函数中：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first route redirects any `GET` requests to the `/page/persons` path to
    the `get_page_persons` function. These requests come when the user clicks on the
    Filter button, but also indirectly when the `/` path is requested.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条路由将任何`GET`请求重定向到`/page/persons`路径的`get_page_persons`函数。这些请求发生在用户点击筛选按钮时，也间接发生在请求`/`路径时。
- en: The second route redirects any `GET` requests to the `/favicon.ico` path to
    the `get_favicon` function. These requests come from the browser when it receives
    a complete HTML page, not a partial page.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条路由将任何`GET`请求重定向到`/favicon.ico`路径的`get_favicon`函数。这些请求来自浏览器，当它收到完整的HTML页面而不是部分页面时。
- en: The call to `default_resource` redirects any other requests to the `invalid_resource` function.
    These requests cannot come with proper use of the app, but may come under specific
    conditions or when the user types an unexpected path into the address bar of the
    browser. For example, this request occurs if you type in `http://127.0.0.1:8080/abc`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对`default_resource`的调用将任何其他请求重定向到`invalid_resource`函数。这些请求不能通过正确使用应用程序进行，但在特定条件下或当用户在浏览器的地址栏中输入意外的路径时可能会发生。例如，当你输入`http://127.0.0.1:8080/abc`时，就会发生这种请求。
- en: Now, let's look at the handler's functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看处理器的函数。
- en: 'The `get_page_persons` function has two arguments:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_page_persons`函数有两个参数：'
- en: '`web::Query<Filter>` is used to pass the optional filter condition.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`web::Query<Filter>`传递可选的筛选条件。
- en: '`web::Data<Mutex<AppState>>` is used to pass the database connection.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`web::Data<Mutex<AppState>>`传递数据库连接。
- en: 'The parameter of the `Query` type is defined as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query`类型的参数定义如下：'
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This specifies the possible arguments of the *query*, which is the part of the
    URI following the question mark. Here, there is only one argument and it is optional
    as it is typical of HTTP queries. A possible query is `?partial_name=Jo`, but
    also an empty string is a valid query in this case.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了查询的可能参数，即问号之后URI的部分。在这里，只有一个参数，它是可选的，因为这在HTTP查询中很典型。一个可能的查询是`?partial_name=Jo`，但在这种情况下，一个空字符串也是有效的查询。
- en: To be able to receive the `Filter` structure from the request, it must implement
    the `Deserialize` trait.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从请求中接收`Filter`结构，它必须实现`Deserialize`特质。
- en: 'The body of the `get_page_persons` function is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_page_persons`函数的主体如下：'
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first statement gets the query from the request. If the `partial_name` field is
    defined, it is extracted; otherwise, an empty string is generated.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句从请求中获取查询。如果定义了`partial_name`字段，则提取它；否则，生成一个空字符串。
- en: The second statement extracts the connection to the database from the shared
    state.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个语句从共享状态中提取数据库连接。
- en: The third statement uses this connection to get an iterator on the people satisfying
    the criteria. See the subsection, *Implementing the database* in the section *Building
    a stateful server* in the previous chapter. See the previous chapter to understand
    these two lines.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条语句使用这个连接来获取满足条件的人员的迭代器。参见前一章“构建有状态服务器”部分中的*实现数据库*子节。参见前一章以了解这两行。
- en: 'Then, an empty Tera context is created and two Tera variables are added to
    it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个空的Tera上下文，并向其中添加两个Tera变量：
- en: '`partial_name` is used to keep the typed characters that otherwise would disappear
    when the page is reloaded in the edit box.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partial_name`用于在编辑框中保留在页面重新加载时通常会消失的输入字符。'
- en: '`persons` is the vector containing the people collected from the database.
    To make this possible, the `Person` type must implement the `Serialize` trait.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persons`是包含从数据库收集的人员的向量。为了实现这一点，`Person`类型必须实现`Serialize`特质。'
- en: Finally, the Tera engine can render the `persons.html` template using the *context*,
    because all the variables used in the template have been defined. The result of
    this rendering is passed as the body of the successful HTTP response. When the
    JavaScript code inside the browser receives that HTML code, it will use it to
    replace the contents of the body of the current page.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Tera引擎可以使用上下文渲染`persons.html`模板，因为模板中使用的所有变量都已定义。渲染的结果作为成功HTTP响应的主体传递。当浏览器内的JavaScript代码接收到该HTML代码时，它将使用它来替换当前页面主体的内容。
- en: 'Now, let''s see the body of the `get_favicon` function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`get_favicon`函数的主体：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is simply a successful HTTP response whose content is of the `image` HTTP
    type and the `x-icon` subtype, and whose body is a slice of bytes containing the
    icon. This binary object is constructed at compile time from the bytes contained
    in the `favicon.ico` file. The content of this file is embedded in the executable
    program, so it is not required to deploy this file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的成功HTTP响应，其内容是`image` HTTP类型和`x-icon`子类型，其主体是包含图标的字节数据。这个二进制对象在编译时从`favicon.ico`文件中包含的字节构建。这个文件的内容嵌入到可执行程序中，因此不需要部署此文件。
- en: 'Finally, let''s look at the body of the `invalid_resource` function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`invalid_resource`函数的主体：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a failing response (as `NotFound` generates the `404` status code),
    which should contain a complete HTML page. For simplicity, a straightforward message
    has been returned.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个失败的响应（因为`NotFound`生成`404`状态码），它应该包含一个完整的HTML页面。为了简单起见，返回了一个直接的消息。
- en: We have now looked at a very simple web app. Many of the concepts seen in this
    section will be used in the following sections, where the database will be modified
    by user actions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经查看了一个非常简单的Web应用。本节中看到的大多数概念将在下一节中使用，其中数据库将通过用户操作进行修改。
- en: A CRUD application
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个CRUD应用
- en: 'The web app shown in the previous section allowed us to view filtered data
    in a single page. If you now run the project in the `crud` folder, you will see
    a much more rich and useful web page:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中显示的Web应用允许我们在单个页面上查看筛选后的数据。如果您现在在`crud`文件夹中运行项目，您将看到一个更加丰富和有用的网页：
- en: '![](img/2174b90a-27d2-4afc-8af0-d4a17da515cf.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2174b90a-27d2-4afc-8af0-d4a17da515cf.png)'
- en: The Id edit box and the Find button to its right are used to open a page that
    allows you to view or edit the data of a person with a specific ID.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Id编辑框和其右侧的查找按钮用于打开一个页面，允许您查看或编辑具有特定ID的人员数据。
- en: The Name portion edit box and the Filter button to its right are for filtering
    the table below it, in a similar way as in the `list` project.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 名称部分编辑框和其右侧的筛选按钮用于筛选下方的表格，方式与`list`项目类似。
- en: Then, there are two buttons—one for deleting data and one for adding data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两个按钮——一个用于删除数据，一个用于添加数据。
- en: Lastly, there is the filtered table of the people. In this app, the initial
    state of the database is an empty list of people and so no HTML table is shown.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有人员的过滤表格。在这个应用中，数据库的初始状态是空的人员列表，因此不显示HTML表格。
- en: Let's create some people.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些人。
- en: 'Click on the Add New Person push button. You will see the following window:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加新人员”按钮。您将看到以下窗口：
- en: '![](img/f38e5c37-ec8c-4ca4-82ef-a000de08ecf4.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f38e5c37-ec8c-4ca4-82ef-a000de08ecf4.png)'
- en: This is the page used to create a person and insert them into the database.
    The Id field is disabled because its value will be generated automatically. To
    insert a person, type in a name for them—for example, Juliet—and click on the
    Insert button. The main page will appear again, but with a small table containing
    only Juliet, preceded by 1 as its ID.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于创建人员并将其插入数据库的页面。Id 字段被禁用，因为其值将自动生成。要插入人员，为他们输入一个名字——例如，Juliet——然后点击插入按钮。主页将再次出现，但前面有一个包含只有
    Juliet 的小表格，其 ID 为 1。
- en: 'If you repeat these steps, inserting Romeo and Julius, you''ll have the results
    shown in the following picture:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重复这些步骤，插入 Romeo 和 Julius，你将看到以下图片中的结果：
- en: '![](img/67aef1c7-8686-4cb0-9e13-b4c569d27af0.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67aef1c7-8686-4cb0-9e13-b4c569d27af0.png)'
- en: 'The push buttons near any listed person allow us to open a page related to
    that person. For example, if the button near Julius is clicked, the following
    page will appear:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 任何列出的人员附近的按钮允许我们打开与该人员相关的页面。例如，如果点击 Julius 附近的按钮，将出现以下页面：
- en: '![](img/9e7382e0-36d8-46e4-8dea-787cb4ee178b.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e7382e0-36d8-46e4-8dea-787cb4ee178b.png)'
- en: 'This page is very similar to the page used to insert people, but with the following
    differences:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面与用于插入人员的页面非常相似，但有以下区别：
- en: The Id field now contains a value.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Id 字段现在包含一个值。
- en: The Name field now contains an initial value.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Name 字段现在包含一个初始值。
- en: Instead of the Insert button, now there is an Update button.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在没有了插入按钮，而是有一个更新按钮。
- en: If you change the Julius value to Julius Caesar and click on Update, you will
    see the updated list on the main page.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 Julius 的值更改为 Julius Caesar 并点击更新，你将在主页上看到更新的列表。
- en: 'Another way to open the page relating to a single person is to type the ID
    of that person into the Id field and then click on the Find button. If you click
    on this button when that field is empty or when it contains a value that no person
    has as its ID, a red error message appears on the page:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 打开与单个人员相关的页面的另一种方法是，在 Id 字段中输入该人员的 ID，然后点击查找按钮。如果你在字段为空或包含没有人员作为其 ID 的值时点击此按钮，页面上将出现红色错误消息：
- en: '![](img/8f13d161-e9c9-4df8-a61e-6486c50bf70c.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f13d161-e9c9-4df8-a61e-6486c50bf70c.png)'
- en: The final feature of this app allows us to delete records. To do that, click
    on the checkboxes to the left of the lines of the people you want to delete, and
    then click on the Delete Selected Persons button. The list is immediately updated.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的最后一个功能允许我们删除记录。要这样做，点击要删除的人员所在行的左侧复选框，然后点击删除选定人员按钮。列表将立即更新。
- en: Notice that the database is stored in the memory of the backend process. You
    will see the same list of people if you close the browser and reopen it or if
    you open another browser. You can even open the page from another computer, as
    long as you insert the appropriate name or IP address of the computer where the
    backend process is running. However, if you terminate the backend process by pressing
    the *Ctrl* + *C* key combination (or in any other way) and then re-run it, all
    of the browsers will display no people when the page is reloaded.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，数据库存储在后端进程的内存中。如果你关闭浏览器并重新打开，或者打开另一个浏览器，你将看到相同的人员列表。你甚至可以从另一台计算机打开页面，只要你在后端进程运行的计算机上插入适当的名称或IP地址。然而，如果你通过按
    *Ctrl* + *C* 键组合（或任何其他方式）终止后端进程，然后重新运行它，当页面重新加载时，所有浏览器都将显示没有人员。
- en: The JavaScript code
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 代码
- en: We are now going to look at what makes this project different from the one described
    in the previous section.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨使此项目与上一节中描述的项目不同的因素。
- en: 'First of all, the `main.js` file is much larger because it contains three additional
    functions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`main.js` 文件要大得多，因为它包含三个额外的函数：
- en: '`sendCommand`: This is quite a generic routine used to send HTTP requests to
    a server and to process the received response asynchronously. It accepts five
    arguments:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendCommand`：这是一个相当通用的例程，用于向服务器发送HTTP请求，并异步处理接收到的响应。它接受五个参数：'
- en: '`method` is the HTTP command to use, such as `GET`, `PUT`, `POST`, or `DELETE`.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method` 是要使用的HTTP命令，例如 `GET`、`PUT`、`POST` 或 `DELETE`。'
- en: '`uri` is the path and possible query to send to the server.'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri` 是发送到服务器的路径和可能的查询。'
- en: '`body` is the possible body of the request, used to send data larger than 2
    KB.'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body` 是请求的可能正文，用于发送大于 2 KB 的数据。'
- en: '`success` is a reference to a function that will be called after receiving
    a successful response (`status == 200`).'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`success` 是一个函数的引用，该函数将在接收到成功响应（`status == 200`）后被调用。'
- en: '`failure` is a reference to a function that will be called after receiving
    any failure response (`status != 200`).'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failure` 是一个在接收到任何失败响应（`status != 200`）后将被调用的函数的引用。'
- en: This function is used to access a REST service as it allows any HTTP method,
    but it doesn't automatically change the current HTML page. Instead, the `getPage`
    function can only use the `GET` method, but it replaces the current HTML page
    with the HTML code received.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数用于访问REST服务，因为它允许任何HTTP方法，但它不会自动更改当前的HTML页面。相反，`getPage` 函数只能使用 `GET` 方法，但它会替换当前HTML页面为接收到的HTML代码。
- en: '`delete_selected_persons`: This scans the items whose checkboxes are selected
    and sends a `DELETE` command to the server with the `/persons?id_list=` URI followed
    by a comma-separated list of the IDs of the selected items. The server should
    delete these records and return a successful state. If the deletion is successful,
    this JavaScript function reloads the main page with no filter; otherwise, an error
    message is shown in a message box and the current page is not changed. It should
    be called when the Delete Selected Persons button is clicked.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_selected_persons`：这个函数会扫描复选框被选中的项目，并使用 `/persons?id_list=` URI发送一个
    `DELETE` 命令到服务器，后面跟着一个由逗号分隔的选定项目ID列表。服务器应该删除这些记录并返回一个成功状态。如果删除成功，这个JavaScript函数将不带过滤器重新加载主页面；否则，在消息框中显示错误消息，并且当前页面不会改变。应该在点击删除选定人员按钮时调用此函数。'
- en: '`savePerson`: This receives an HTTP method, which can be `POST` (to insert)
    or `PUT` (to update). It sends a command to the server, using the method received
    as an argument, and a URI that depends on the method. For a `POST` request, the
    URI is `/one_person?name=NAME`, while for a `PUT` request, the URI is `/one_person?id=ID&name=NAME`,
    wherein `ID` and `NAME` are actually the values of the `id` and `name` fields
    of the record to create or update. This function should be called with a `POST`
    argument when the Insert button is clicked and with a `PUT` argument when the
    Update button is clicked.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`savePerson`：这个函数接收一个HTTP方法，可以是 `POST`（用于插入）或 `PUT`（用于更新）。它使用作为参数接收的方法和一个依赖于方法的URI向服务器发送命令。对于
    `POST` 请求，URI是 `/one_person?name=NAME`，而对于 `PUT` 请求，URI是 `/one_person?id=ID&name=NAME`，其中
    `ID` 和 `NAME` 实际上是创建或更新记录的 `id` 和 `name` 字段的值。当点击插入按钮时，应该使用 `POST` 参数调用此函数，当点击更新按钮时，应该使用
    `PUT` 参数调用此函数。'
- en: Now, let's check the HTML code of the application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查应用的HTML代码。
- en: The HTML code
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML代码
- en: Of course, many HTML elements have been added to the `persons.html` file to
    create the additional widgets.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，已经向 `persons.html` 文件添加了许多HTML元素来创建额外的控件。
- en: First, there is the `<label class="error">{{id_error}}</label>` element, used
    to display error messages caused by the Find button. To correctly process this
    element, the `id_error` Tera variable needs to be defined in the current Tera
    context.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个 `<label class="error">{{id_error}}</label>` 元素，用于显示由查找按钮引起的错误消息。为了正确处理此元素，需要在当前的Tera上下文中定义
    `id_error` Tera变量。
- en: 'Then, there is the following element:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有以下元素：
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When the Find button is clicked, a page is requested at the `/page/edit_person/` URI, followed
    by the typed ID.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击查找按钮时，会请求位于 `/page/edit_person/` URI的页面，后面跟着输入的ID。
- en: 'Then, there are two push buttons:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两个按钮：
- en: '[PRE40]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first one simply delegates all the work to the `delete_selected_persons` function,
    while the second one gets the page at the `/page/new_person` URI.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个简单地将所有工作委托给 `delete_selected_persons` 函数，而第二个则获取位于 `/page/new_person` URI的页面。
- en: 'Finally, two columns are added to the HTML table containing the list of people.
    They are found on the left side of the table:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在包含人员列表的HTML表中添加了两列。它们位于表的左侧：
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first column is the checkbox to select the record to delete and the second
    one is the Edit button. The value of the HTML `id` attribute of the checkbox element
    is the `{{p.id}}` Tera expression, which will be replaced by the ID of the record
    of the current line. So, this attribute can be used to prepare the request to
    send it to the server to delete the selected items.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是用于选择要删除的记录的复选框，第二列是编辑按钮。复选框元素的HTML `id` 属性的值是 `{{p.id}}` Tera表达式，它将被当前行的记录ID所替换。因此，这个属性可以用来准备请求，将其发送到服务器以删除选定的项目。
- en: The Edit button will get the page at the `/page/edit_person/` URI, followed
    by the ID of the current record.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑按钮将获取位于 `/page/edit_person/` URI的页面，后面跟着当前记录的ID。
- en: 'In addition, there is another HTML partial file, `one_person.html`. This is
    the page used both to insert a new person and to view/edit an existing person.
    Its first part is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个另一个HTML部分文件，`one_person.html`。这个页面用于插入新的人和查看/编辑现有的人。其第一部分如下：
- en: '[PRE42]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For both of the `input` elements, the `value` attribute is set to a Tera expression;
    for the first one, it is the `person_id` Tera variable and for the second, it
    is the `person_name` Tera variable. When inserting a person, these variables will
    be empty and when editing a person, these variables will contain the current values
    of the database fields.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个`input`元素，`value`属性被设置为Tera表达式；对于第一个，它是`person_id` Tera变量，对于第二个，它是`person_name`
    Tera变量。当插入一个人时，这些变量将是空的，而当编辑一个人时，这些变量将包含数据库字段的当前值。
- en: 'The last part of the file is as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的最后部分如下：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This page must show the Insert button when it has been opened for inserting
    a person, and the Update button when it has been opened for viewing or editing
    a person. So, the `inserting` Tera variable is used. Its value will be `true`
    when in insert mode and `false` when in edit mode.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面用于插入一个人时，它必须显示插入按钮；当用于查看或编辑一个人时，它必须显示更新按钮。因此，使用`inserting` Tera变量。当处于插入模式时，其值将为`true`，而在编辑模式时为`false`。
- en: Finally, the Cancel button opens the `/page/persons` page, with no filtering.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，取消按钮打开没有过滤的`/page/persons`页面。
- en: That's all we need to know about the `templates` folder.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`templates`文件夹，我们所需了解的就是这些。
- en: The Rust code
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust代码
- en: In the `src` folder, both the `db_access.rs` and the `main.rs` files have many
    changes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，`db_access.rs`和`main.rs`文件都有很多更改。
- en: The db_access.rs changes
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`db_access.rs`文件更改'
- en: The `persons` vector is initially empty because users can insert records into
    it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`persons`向量最初是空的，因为用户可以将其中的记录插入进去。'
- en: 'The following functions have been added:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加以下函数：
- en: '`get_person_by_id`: This searches the vector for a person with a specified
    ID. It returns the person if found or `None`, otherwise.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_person_by_id`：这个函数在向量中搜索具有指定ID的人。如果找到，则返回该人，否则返回`None`。'
- en: '`delete_by_id`: This searches the vector for a person with the specified ID;
    if found, it is removed from the vector and `true` is returned. Otherwise, `false`
    is returned.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_by_id`：这个函数在向量中搜索具有指定ID的人；如果找到，则从向量中删除并返回`true`。否则，返回`false`。'
- en: '`insert_person`: A `Person` object is received as an argument to insert into
    the database. However, before inserting it into the vector, its `id` field is
    overwritten by a unique ID value. This value is an integer larger than the largest
    ID present in the vector if the vector is not empty, or `1`, otherwise.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert_person`：接收一个`Person`对象作为参数以将其插入数据库。然而，在将其插入向量之前，其`id`字段被一个唯一的ID值覆盖。如果向量不为空，则此值是向量中最大ID的整数加一，否则为`1`。'
- en: '`update_person`: This searches the vector for a person that has the specified
    ID; if found, this person is replaced by the specified person and `true` is returned.
    Otherwise, `false` is returned.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_person`：这个函数在向量中搜索具有指定ID的人；如果找到，则用指定的人替换这个人并返回`true`。否则，返回`false`。'
- en: Nothing web-specific is contained in these functions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中没有包含任何特定的网络内容。
- en: The main.rs changes
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`main.rs`文件更改'
- en: 'For the `main` function, there are many kinds of requests to the route. The
    new routes are as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`main`函数，有各种对该路由的请求。新的路由如下：
- en: '[PRE44]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first route is used to delete the selected people.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条路径用于删除选定的个人。
- en: The second route is used to get the page to allow the user to insert a new person—that
    is, the `one_person.html` page—in insert mode.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条路径用于获取页面，允许用户以插入模式插入一个新的人——即`one_person.html`页面。
- en: The third route is used to get the page to allow the user to view or edit a
    new person—that is, the `one_person.html` page—in edit mode.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条路径用于获取页面，允许用户查看或编辑一个新的人——即`one_person.html`页面——在编辑模式下。
- en: For the fourth resource, there are two possible routes. Actually, this resource
    can be accessed using the `POST` method or the `PUT` method. The first method
    is used to insert a new record into the database. The second method is used to
    update the specified record using the specified data.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第四个资源，有两条可能的路径。实际上，这个资源可以通过使用`POST`方法或`PUT`方法来访问。第一种方法用于将新记录插入数据库。第二种方法用于使用指定数据更新指定的记录。
- en: Now, let's see the handlers. With respect to the previous project, some of them
    are new, some are old but have been changed, and some are unmodified.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看处理程序。与之前的项目相比，其中一些是新的，一些是旧的但已更改，还有一些是未修改的。
- en: 'The new handlers are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 新的处理程序如下：
- en: '`delete_persons` is used to delete the selected people.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_persons`用于删除选定的人员。'
- en: '`get_page_new_person` is used to get the page to create a new person.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_page_new_person`用于获取创建新人员的页面。'
- en: '`get_page_edit_person` is used to get the page to edit an existing person.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_page_edit_person`用于获取编辑现有人员的页面。'
- en: '`insert_person` is used to insert a new person into the database.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert_person`用于将新人员插入到数据库中。'
- en: '`update_person` is used to update an existing person in the database.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_person`用于更新数据库中的现有人员。'
- en: The changed handlers are `get_page_persons` and `invalid_resource`. The unmodified
    handlers are `get_main` and `get_favicon`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 改变的处理程序是`get_page_persons`和`invalid_resource`。未修改的处理程序是`get_main`和`get_favicon`。
- en: 'These handlers can be grouped into three logical kinds:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些处理程序可以分为三种逻辑类型：
- en: The ones whose job it is to generate HTML code to replace part of a web page
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些负责生成HTML代码以替换网页部分的任务
- en: The ones whose job it is to return non-HTML data
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些负责返回非HTML数据的任务
- en: The ones that do some work and then return status information regarding the
    job that has been done
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些执行一些工作然后返回关于已完成工作的状态信息的任务
- en: The HTML-returning functions are `get_main`, `get_page_persons`, `get_page_new_person`, `get_page_edit_person`,
    and `invalid_resource`. `get_favicon` is the only data-returning function; the
    other three are data-manipulating functions.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 返回HTML的函数有`get_main`、`get_page_persons`、`get_page_new_person`、`get_page_edit_person`和`invalid_resource`。`get_favicon`是唯一的数据返回函数；其他三个是数据处理函数。
- en: It is logically possible to have a single handler that first does some work
    and then returns the HTML page to be shown. However, it is better to separate
    these logically different features into two distinct functions—first, the function
    that manipulates data is executed, and then the function that returns the HTML
    code is run. This separation can happen on the backend or on the frontend.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，可以有一个单独的处理程序，首先执行一些工作，然后返回要显示的HTML页面。然而，最好将这些逻辑上不同的功能分离成两个不同的函数——首先，执行数据处理函数，然后运行返回HTML代码的函数。这种分离可以在后端或前端发生。
- en: In this project, it is the frontend that does the separation. First, JavaScript
    code sends a request to manipulate data (for example, to insert a record in the
    database) and then, if the operation was successful, some other JavaScript code
    requests the HTML code to show up next in the browser.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，前端负责分离。首先，JavaScript代码发送请求来操作数据（例如，在数据库中插入记录），然后，如果操作成功，其他JavaScript代码请求HTML代码在浏览器中显示出来。
- en: 'An alternative architecture is to have the following sequence of calls:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代架构是以下调用序列：
- en: The user performs an action on the web page.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在网页上执行一个操作。
- en: That action causes a JavaScript routine to be executed.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该操作会导致执行一个JavaScript程序。
- en: That routine sends a request from the browser to the server.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该程序从浏览器向服务器发送请求。
- en: The server routes that request to a backend handler function.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将请求路由到后端处理程序函数。
- en: The backend handler first calls a routine to manipulate data and then waits
    for its completion.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后端处理程序首先调用一个程序来处理数据，然后等待其完成。
- en: If the backend routine is successful, the backend calls another routine to generate
    and return the next HTML page to the browser. If the backend routine fails, the
    backend generates and returns another HTML page to the browser, describing the
    failure.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果后端程序成功，后端将调用另一个程序来生成并返回下一个HTML页面给浏览器。如果后端程序失败，后端将生成并返回另一个HTML页面给浏览器，描述失败情况。
- en: The JavaScript routine receives the HTML page and displays it to the user.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript程序接收HTML页面并将其显示给用户。
- en: Now, let's look at the body of the `get_page_edit_person` function one piece
    at a time.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐个查看`get_page_edit_person`函数的主体。
- en: Remember that the purpose of this routine is to generate the HTML code of a
    web page to edit the name of a person. The current name of the person to edit
    is to be found in the database and the constant HTML code is to be found in the
    `one_person.html` template.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个程序的目的生成网页的HTML代码以编辑一个人的名字。要编辑的人的当前名字应在数据库中找到，而常量HTML代码应在`one_person.html`模板中找到。
- en: 'The first five statements define and initialize as many local variables:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 前五条语句定义并初始化了尽可能多的局部变量：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first statement gets the `id` variable from the path as a string. For this
    function, the routing was `/page/edit_person/{id}`, and so the `id` variable is
    available to be extracted.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句从路径中获取`id`变量作为字符串。对于这个函数，路由是`/page/edit_person/{id}`，因此`id`变量可用于提取。
- en: The second statement gets and locks the database connection.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条语句获取并锁定数据库连接。
- en: The third statement creates an empty Tera context.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条语句创建一个空的Tera上下文。
- en: The fourth statement tries to parse the `id` Rust variable into an integer.
    If the conversion is successful, the condition of the `if` statement is satisfied
    and so the next statement is executed.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 第四条语句尝试将`id` Rust变量解析为整数。如果转换成功，`if`语句的条件得到满足，因此执行下一条语句。
- en: The fifth statement searches the database for a person identified by this ID by
    calling the `get_person_by_id` method.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第五条语句通过调用`get_person_by_id`方法在数据库中搜索由该ID标识的人。
- en: 'Now that the required information is available, the Tera context can be filled
    in:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所需信息可用，Tera上下文可以填充：
- en: '[PRE46]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s see what the purpose of these variables is:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些变量的目的是什么：
- en: The `person_id` Tera variable allows us to show the current (disabled) ID of
    the person on the page.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person_id` Tera变量允许我们在页面上显示当前（禁用）的ID。'
- en: The `person_name` Tera variable allows us to show the current (editable) name of
    the person on the page.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person_name` Tera变量允许我们在页面上显示当前（可编辑）的人名。'
- en: The `inserting` Tera variable allows us (through a conditional Tera statement)
    to set the page as an edit page, instead of as an insert page.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inserting` Tera变量允许我们（通过条件Tera语句）将页面设置为编辑页面，而不是插入页面。'
- en: 'Then, we can call the `render` Tera method with this context to get the HTML
    page and send the resulting page as the HTML body of the response:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这个上下文调用`render` Tera方法来获取HTML页面，并将生成的页面作为响应的HTML主体发送：
- en: '[PRE47]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we have considered the cases where every statement was successful. In
    cases where the typed ID is not a number or it does not exist in the database,
    the function carries out the following code. This happens when the user types
    a wrong number in the Id field of the main page and then clicks on Find:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们考虑了每个语句都成功的案例。在类型ID不是数字或它不在数据库中存在的情况下，函数执行以下代码。这发生在用户在主页的ID字段中输入错误数字然后点击查找时：
- en: '[PRE48]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The last line shows that the template we will use is `persons.html`, so we are
    going to the main page. The Tera variables of that template are `id_error`, `partial_name`,
    and `persons`. We want a specific error message in the first variable, nothing
    as the `filter` condition, and a list of all the people. This can be obtained
    by filtering all the people whose name contains an empty string.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行显示我们将使用的模板是`persons.html`，因此我们将转到主页。该模板的Tera变量是`id_error`、`partial_name`和`persons`。我们希望在第一个变量中有一个特定的错误消息，没有任何`filter`条件，以及所有人的列表。这可以通过过滤所有名字包含空字符串的人来实现。
- en: When the user presses the Update button, the `update_person` function is called.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下更新按钮时，调用`update_person`函数。
- en: 'This function has the following arguments:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有以下参数：
- en: '[PRE49]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The second is a query using a type defined by the following structure:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是使用以下结构定义的类型查询：
- en: '[PRE50]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'So, this query allows two optional keywords: `id` and `name`. The first keyword
    must be an integer number. Here are some valid queries:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此查询允许两个可选关键字：`id`和`name`。第一个关键字必须是一个整数。以下是一些有效的查询：
- en: '`?id=35&name=Jo`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?id=35&name=Jo`'
- en: '`?id=-2`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?id=-2`'
- en: '`?name=Jo`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?name=Jo`'
- en: No query
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无查询
- en: 'The following are invalid queries for that structure:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对该结构的无效查询：
- en: '`?id=x&name=Jo`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?id=x&name=Jo`'
- en: '`?id=2.4`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?id=2.4`'
- en: 'Here is the first part of the body of the function:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数体第一部分的内容：
- en: '[PRE51]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first statement gets and locks the database connection.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句获取并锁定数据库连接。
- en: A count of the records to update is defined by the second statement. This routine
    can update only one record, and so this count will be `0` or `1` only.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 更新记录的计数由第二条语句定义。此例程只能更新一条记录，因此此计数只能是`0`或`1`。
- en: Then, the `id` variable is extracted from the query, if present and valid, or
    otherwise, `0` is considered as a substitute.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果存在且有效，从查询中提取`id`变量，否则，将`0`视为替代。
- en: Notice that because the type of the query variable defines which fields are
    defined (whether they are optional or required and what is their type), the Actix
    web framework can perform a strict parsing of the URI query. If the URI query
    is not valid, the handler is not invoked and the `default_service` routine will
    be chosen. On the other side, in the handler, we can be sure that the query is
    valid.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于查询变量的类型定义了哪些字段被定义（它们是否为可选或必需以及它们的类型），Actix Web框架可以对URI查询执行严格的解析。如果URI查询无效，则不会调用处理器，并将选择`default_service`例程。另一方面，在处理器中，我们可以确信查询是有效的。
- en: 'The last part of the body of the function is as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体的最后一部分如下：
- en: '[PRE52]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, the `name` variable is extracted from the query, or an empty string is
    considered if that variable is not contained in the query. This name is cloned
    as the database operations take ownership of their arguments and we cannot yield
    the ownership of a field of the query.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从查询中提取`name`变量，如果没有包含该变量，则考虑为空字符串。这个名称被克隆，因为数据库操作对其参数拥有所有权，我们不能放弃查询字段的拥有权。
- en: Then, the `update_person` method of the database connection is called. This
    method receives a new `Person` object constructed with the `id` and `name` values
    that were just extracted. If this method returns `true`, the count of the processed record
    is set to `1`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用数据库连接的`update_person`方法。此方法接收一个使用刚刚提取的`id`和`name`值构造的新`Person`对象。如果此方法返回`true`，则将处理过的记录数设置为`1`。
- en: Finally, the count of the processed record is returned as a response.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，处理过的记录数作为响应返回。
- en: The other routines are conceptually similar to the one described here.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 其他例程在概念上与这里描述的类似。
- en: Handling an application with authentication
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理具有身份验证的应用程序
- en: All of the features of the previous apps were accessible to everyone that could
    create an HTTP connection with our server. Usually, a web app should behave differently
    depending on who is currently using it. Typically, some users are authorized to
    carry out some important operations, such as adding or updating records, while
    other users are authorized only to read these records. Sometimes, user-specific
    data must be recorded.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 之前所有应用程序的功能都对能够与我们的服务器建立HTTP连接的每个人开放。通常，一个Web应用程序应该根据当前使用它的人的行为不同。通常，一些用户被授权执行一些重要操作，例如添加或更新记录，而其他用户仅被授权读取这些记录。有时，必须记录特定用户的数据。
- en: This opens up the vast world of authentication, authorization, and security.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这打开了身份验证、授权和安全的广阔世界。
- en: 'Let''s imagine a simplified scenario. There are two users whose profiles are
    wired-in to the mock database:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个简化的场景。有两个用户的配置文件连接到了模拟数据库：
- en: '`joe`, whose password is `xjoe`, can *only read* the database of people.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joe`，其密码为`xjoe`，只能**读取**人员数据库。'
- en: '`susan`, whose password is `xsusan`, can *read and write* the database of people—that
    is, she can do what the app in the previous section allowed.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`susan`，其密码为`xsusan`，可以**读取和写入**人员数据库——也就是说，她可以执行前一个章节中应用程序允许的操作。'
- en: The application starts with a login page. If the user does not insert an existing
    username and its matching password, they cannot access the other pages. Even if the
    username and password are valid, the widgets that the user is not authorized for
    are disabled.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序从登录页面开始。如果用户没有插入现有的用户名及其匹配的密码，他们将无法访问其他页面。即使用户名和密码有效，用户无权访问的小部件也会被禁用。
- en: For these situations, some applications create a server-side user session. This
    may be appropriate to use when there are a limited number of users, but it may
    overload the server if there are many users. Here, we'll show a solution without server-side
    sessions.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，一些应用程序创建一个服务器端用户会话。当用户数量有限时，这可能是一个合适的选择，但如果用户数量很多，可能会使服务器过载。在这里，我们将展示一个不使用服务器端会话的解决方案。
- en: 'If you run the `auth` project and access the site from a browser, you will
    see the following page:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`auth`项目并通过浏览器访问网站，你将看到以下页面：
- en: '![](img/6a209eca-a7bc-4860-a7bf-5cf1efe3bb59.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a209eca-a7bc-4860-a7bf-5cf1efe3bb59.png)'
- en: It shows that there is no current users and two fields allow us to type in a
    username and password. If you type `foo` into the User name field and then click
    on Log in, the red User "foo" not found. message will appear. If you type in `susan` and
    then click on Log in, the message will be Invalid password for user "susan".
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明没有当前用户，并且有两个字段允许我们输入用户名和密码。如果您在用户名字段中输入`foo`然后点击登录，将会出现红色消息“用户“foo”未找到”。如果您输入`susan`然后点击登录，消息将是“用户“susan”的密码无效”。
- en: 'Instead, if you type in the correct password for that user, `xsusan`, the following
    page will appear:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果您输入了该用户的正确密码`xsusan`，将会出现以下页面：
- en: '![](img/73a1f6eb-efe0-4ed7-b2d7-ba40187e9a47.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73a1f6eb-efe0-4ed7-b2d7-ba40187e9a47.png)'
- en: 'This is the same main page as the `crud` project, with an added line of widgets:
    the name of the current user shown in blue and a button to change it. If you click
    on the Change User button, you go back to the login page. Also, the page to view,
    edit, or insert a person has the same widgets just under the page heading.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`crud`项目的首页相同，增加了一行小部件：在蓝色中显示当前用户的名字和一个更改按钮。如果您点击更改用户按钮，您将返回到登录页面。此外，查看、编辑或添加人的页面在页面标题下方也有相同的小部件。
- en: 'If on the login page you insert `joe` as the username and `xjoe` as the password,
    the following page will appear:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在登录页面您输入`joe`作为用户名，`xjoe`作为密码，将会出现以下页面：
- en: '![](img/8d2829e0-7823-4a0f-835c-7353bddc0ce2.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d2829e0-7823-4a0f-835c-7353bddc0ce2.png)'
- en: This has the same widgets that appeared for `susan`, but the Delete Selected
    Persons button and the Add New Person button now are disabled.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`susan`出现的小部件相同，但删除选定人员按钮和添加新人员按钮现在被禁用。
- en: 'To see how `joe` sees the people, first, you need to log in as `susan`, insert
    some people, and then change the user to `joe`, because `joe` cannot insert people.
    If you do this and then you click on the Edit button of a person, you will see
    the following page, where the Name field is read-only and the Update button is
    disabled:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到`joe`如何看待人们，首先，您需要以`susan`的身份登录，添加一些人，然后将用户更改为`joe`，因为`joe`不能添加人。如果您这样做，然后点击一个人的编辑按钮，您将看到以下页面，其中姓名字段为只读，更新按钮被禁用：
- en: '![](img/579cb170-8a21-4c31-8c0e-b5a68968c7ac.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/579cb170-8a21-4c31-8c0e-b5a68968c7ac.png)'
- en: Let's start with understanding the nitty-gritty of the application we just did.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解我们刚刚所做应用的细节开始。
- en: The implementation
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: This project adds some code with respect to the `crud` project.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目在`crud`项目的基础上添加了一些代码。
- en: The first difference is in the `Cargo.toml` file, where the `actix-web-httpauth
    = "0.1"` dependency has been added. This crate handles the encoding of the username
    and password in the HTTP request.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别在于`Cargo.toml`文件，其中添加了`actix-web-httpauth = "0.1"`依赖项。这个crate处理HTTP请求中用户名和密码的编码。
- en: The HTML code
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML代码
- en: 'The `main.html` page, instead of opening the `/page/persons` URI, opens `/page/login` to
    show the login page, initially. So, this project adds a new TERA template for
    the login page. This is the `login.html` partial HTML page, shown as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.html`页面，而不是打开`/page/persons` URI，最初打开`/page/login`以显示登录页面。因此，这个项目为登录页面添加了一个新的TERA模板。这是以下所示的`login.html`部分HTML页面：'
- en: '[PRE53]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Its noteworthy points are underlined: the `{{error_message}}` Tera variable,
    the call to `login()` when the Log in button is clicked, and three elements whose
    IDs are `current_user`, `username`, and `password`.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 其值得注意的点已用下划线标出：`{{error_message}}` Tera变量，当点击登录按钮时调用`login()`，以及三个ID分别为`current_user`、`username`和`password`的元素。
- en: 'Both the `persons.html` and `one_person.html` templates have the following
    section just below the heading:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`persons.html`和`one_person.html`模板在标题下方都有以下部分：'
- en: '[PRE54]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will show the current user, or `---`, followed by the Change User button.
    Clicking on this will load the `/page/login` page.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示当前用户，或`---`，然后是更改用户按钮。点击此按钮将加载`/page/login`页面。
- en: 'The app contains four buttons that must be disabled for unauthorized users—two
    in the `persons.html` template and two in the `one_person.html` template. They
    now contain the following attribute:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包含四个按钮，必须禁用未授权用户的按钮——两个在`persons.html`模板中，两个在`one_person.html`模板中。它们现在包含以下属性：
- en: '[PRE55]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It assumes that the `can_write` Tera variable is defined as `true`, or any non-null
    value, if—and only if—the current user has the authorization to modify the content
    of the database.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 它假设`can_write` Tera变量定义为`true`，或任何非空值，如果——并且仅当——当前用户有修改数据库内容的授权。
- en: 'There is also an edit box element in the `one_person.html` template that must
    be made read-only for users that are not authorized to change that data; so, it
    contains the following attribute:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在`one_person.html`模板中还有一个编辑框元素，必须将其设置为只读，以便未经授权更改数据的用户；因此，它包含以下属性：
- en: '[PRE56]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You should be aware that these checks are not an ultimate security guard. The
    checks of authorization in frontend software can always be bypassed, and so the
    ultimate security guards are those performed by the DBMS.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 应该意识到，这些检查并不是最终的安全保障。前端软件中的授权检查总是可以被绕过的，因此最终的安全保障是由DBMS执行的那些。
- en: However, it is good to always carry out an early check to make that the user
    experience is more intuitive and the error messages are helpful.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，始终进行早期检查以使用户体验更加直观，错误信息更有帮助是很好的。
- en: For example, if an attribute of an entity shouldn't be modifiable by the current
    user, this constraint can be specified in a solid way using the DBMS.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果实体的某个属性不应由当前用户修改，则可以使用DBMS以可靠的方式指定此约束。
- en: However, if the user interface allows this kind of change, the user could try
    to change this value and they will be disappointed when they find out that this
    change is not allowed.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果用户界面允许此类更改，用户可能会尝试更改此值，当他们发现这种更改不允许时，他们会感到失望。
- en: In addition, when a forbidden change is attempted, an error message is issued
    by the DBMS. The message is probably not internationalized and makes reference
    to DBMS concepts such as tables, columns, rows, and the names of objects that
    are unfamiliar to the user. So, this message can be obscure for the user.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当尝试进行禁止的更改时，DBMS会发出错误信息。该消息可能没有国际化，并引用了用户不熟悉的DBMS概念，例如表、列、行和对象名称。因此，此消息对用户来说可能是模糊的。
- en: The JavaScript code
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript代码
- en: The `main.js` file has the following additions with respect to the `crud` project.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js`文件相对于`crud`项目有以下新增：'
- en: The `username` and `password` global variables have been added and initialized
    as empty strings.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加并初始化为空字符串的全局变量`username`和`password`。
- en: 'The following statement has been added to both the `sendCommand` function and
    the `getPage` function:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句已添加到`sendCommand`函数和`getPage`函数中：
- en: '[PRE57]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This sets the `Authorization` header for the HTTP request that is about to be
    sent. The format of that header is standard HTTP.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这为即将发送的HTTP请求设置了`Authorization`头。该头的格式是标准的HTTP。
- en: 'In the `getPage` function, after the statement that assigns the HTML code that
    is received to the current body, the following three lines are inserted:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getPage`函数中，在将接收到的HTML代码分配给当前主体后的语句之后，插入以下三行：
- en: '[PRE58]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: They set the content of the element whose `id` attribute has `current_user` as
    its value if the current page contains such an element. This content is the value
    of the `username` global JavaScript variable if it is defined and not empty, or
    `---`, otherwise.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前页面包含具有`current_user`值的`id`属性元素，它们将设置该元素的内容。如果定义了`username`全局JavaScript变量且不为空，则该内容是该变量的值，否则为`---`。
- en: 'Another addition is the definition of the new `login` function. Its body is
    as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新增的是新`login`函数的定义。其主体如下：
- en: '[PRE59]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This gets the values of the `username` and `password` elements of the page and
    saves them to the global variables with the same names, and then opens the main
    page. Of course, this should only be called in the `login.html` page as other
    pages are not likely to have a `password` element.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取页面中`username`和`password`元素的价值，并将它们保存到具有相同名称的全局变量中，然后打开主页面。当然，这应该在`login.html`页面中调用，因为其他页面不太可能有`password`元素。
- en: The mock database code
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟数据库代码
- en: 'The mock database has one more table: `users`. So, the type of its elements
    must be defined:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟数据库中还有一个表：`users`。因此，其元素类型必须被定义：
- en: '[PRE60]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Any user has a username, a password, and a set of privileges. A **privilege**
    has a custom type, which is defined in the same file:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用户都有一个用户名、一个密码和一组权限。**权限**有一个自定义类型，该类型在同一个文件中定义：
- en: '[PRE61]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, there are only two possible privileges: to be able to read the database
    or to be able to write the database. A real-world system would have more granularity.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只有两种可能的权限：能够读取数据库或能够写入数据库。现实世界的系统会有更多的粒度。
- en: The `DbConnection` struct now also contains the `users` field, which is a vector
    of `Users`. Its content (the records about `joe` and `susan`) is specified inline.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbConnection`结构现在也包含`users`字段，它是一个`Users`向量的集合。其内容（关于`joe`和`susan`的记录）在行内指定。'
- en: 'The following function has been added:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加以下函数：
- en: '[PRE62]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This searches the `users` vector for a user with the specified username. If
    it is found, it is returned; otherwise, `None` is returned.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`users`向量中搜索具有指定用户名的用户。如果找到，则返回；否则，返回`None`。
- en: The main function
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主函数
- en: The `main` function has just two small changes. The first change is to call `data(Config::default().realm("PersonsApp"))` on
    the `App` object. This invocation is required to get the authentication context
    from the HTTP requests. It specifies the context using the `realm` call.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数只有两个小的更改。第一个更改是在`App`对象上调用`data(Config::default().realm("PersonsApp"))`。这个调用是为了从HTTP请求中获取认证上下文。它使用`realm`调用指定上下文。'
- en: 'The second change is the addition of the following routing rule:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更改是添加以下路由规则：
- en: '[PRE63]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This path is used to open the login page. It is used by the main page as the
    entry point of the app and by the two Change User buttons.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 此路径用于打开登录页面。它被主页用作应用的入口点，以及两个更改用户按钮。
- en: The `get_page_login` function is the only new handler. It just calls the `get_page_login_with_message` function, which
    has a string argument, to be shown as an error message. When this function is
    called by `get_page_login`, an empty string is specified as an argument because
    no error has happened yet on this page. However, this function is called in six other places,
    where various error messages are specified. The purpose of this function is to
    go to the login page and display the message received as an argument in red.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_page_login`函数是唯一的新处理器。它只是调用`get_page_login_with_message`函数，该函数有一个字符串参数，用作错误消息显示。当此函数被`get_page_login`调用时，指定一个空字符串作为参数，因为在此页面上还没有发生错误。然而，此函数在其他六个地方被调用，其中指定了各种错误消息。此函数的目的是转到登录页面并显示作为参数接收到的消息。'
- en: 'The login page is obviously accessible to every user, as the favicon resource
    is, but all of the other handlers have been modified to ensure that only authorized
    users can access those resources. The bodies of the handlers that manipulate data
    have the following structure:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面显然对所有用户都是可访问的，就像favicon资源一样，但所有其他处理器都已修改，以确保只有授权用户才能访问这些资源。处理数据的处理器体具有以下结构：
- en: '[PRE64]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: First, the `check_credentials` function checks whether the credentials specified
    by the `auth` argument identify a user that has the `CanWrite` privilege. Only
    users allowed to write should manipulate the data. For them, the function returns
    as `Ok` and so they can change the database and return the result of these changes
    in a plaintext format.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`check_credentials`函数检查由`auth`参数指定的凭据是否标识了一个具有`CanWrite`权限的用户。只有被允许写入的用户应该操作数据。对于他们，函数返回`Ok`，因此他们可以更改数据库，并以纯文本格式返回这些更改的结果。
- en: Users that are not allowed to write are redirected to the login page, which
    shows the error message returned by `check_credentials`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许写入的用户将被重定向到登录页面，该页面显示`check_credentials`返回的错误消息。
- en: 'Instead, the bodies of the handlers that get HTML pages have the following
    structure:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，获取HTML页面的处理器体具有以下结构：
- en: '[PRE65]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, as is typical, any user that can read the data can also access the web
    page. In this case, the `check_credentials` function is successful and it returns
    the complete set of privileges of that user. Matching these results with the `Ok(privileges)` pattern causes
    the privileges of that user to be used to initialize the `privileges` Rust variable.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就像典型情况一样，任何可以读取数据的用户也可以访问网页。在这种情况下，`check_credentials`函数成功并返回该用户的完整权限集。将这些结果与`Ok(privileges)`模式匹配会导致使用该用户的权限初始化`privileges`
    Rust变量。
- en: If the user has the `CanWrite` privilege, that information is passed to the
    `can_write` Tera variable as a `true` value and to `false`, otherwise. In this
    way, the page can enable or disable the HTML widgets in accordance with the user's
    privileges.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户具有`CanWrite`权限，则该信息以`true`值传递给`can_write` Tera变量，否则传递给`false`。这样，页面可以根据用户的权限启用或禁用HTML小部件。
- en: Finally, let's look at the `check_credentials` function.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`check_credentials`函数。
- en: 'Among its arguments, there is `auth: BasicAuth`. Thanks to the `actix_web_httpauth` crate
    and to the call to `data` in the main function, this argument allows access to
    the authorization HTTP header for basic authentication. The objects of the `BasicAuth` type
    have the `user_id` and `password` methods, which return the optional credential
    specified by the HTTP client.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '在其参数中，有 `auth: BasicAuth`。多亏了 `actix_web_httpauth` 包和主函数中对 `data` 的调用，此参数允许访问基本认证的授权
    HTTP 头部。`BasicAuth` 类型的对象具有 `user_id` 和 `password` 方法，它们返回由 HTTP 客户端指定的可选凭据。'
- en: 'These methods are invoked with the following snippet:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法使用以下代码片段调用：
- en: '[PRE66]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code gets the user from the database through their username and checks
    that the stored password matches the password coming from the browser.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过用户的用户名从数据库中获取用户信息，并检查存储的密码是否与来自浏览器的密码匹配。
- en: This is quite basic. A real-world system would store an encrypted password;
    it would encrypt the specified password using the same one-way encryption and
    it would compare the encrypted strings.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当基础。现实世界的系统会存储加密的密码；它会使用相同的单向加密来加密指定的密码，并比较加密后的字符串。
- en: 'Then, the routine discriminates between the different kinds of errors:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该程序会区分不同类型的错误：
- en: The HTTP request does not contain credentials, or the credentials exist but
    the specified user does not exist in the user's table.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 请求不包含凭据，或者凭据存在但指定的用户不在用户表中。
- en: The user exists, but the stored password is different from that specified in
    the received credentials.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户存在，但存储的密码与接收到的凭据中指定的密码不同。
- en: The credentials are valid, but that user hasn't got the required privileges
    (for example, they only have the `CanRead` access but `CanWrite` is required).
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凭据有效，但该用户没有所需的权限（例如，他们只有 `CanRead` 访问权限，但需要 `CanWrite`）。
- en: So, we have now covered a simple authenticated web app.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经涵盖了一个简单的认证 Web 应用程序。
- en: Summary
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to use the Tera template engine to create
    text strings or files (not just in HTML format) containing variable parts, conditional
    sections, repeated sections, and sections included from another file.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 Tera 模板引擎创建包含可变部分、条件部分、重复部分和从另一个文件中包含的部分的文本字符串或文件（而不仅仅是 HTML
    格式）。
- en: Then, we saw how Actix web—together with HTML code, JavaScript code, CSS styles,
    and the Tera template engine—can be used to create a complete web app with CRUD
    capabilities, authentication (to prove who is the current user), and authorization
    (to forbid some operations to the current user).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了如何使用 Actix web——结合 HTML 代码、JavaScript 代码、CSS 样式和 Tera 模板引擎——创建一个具有 CRUD
    功能、认证（以证明当前用户是谁）和授权（禁止对当前用户执行某些操作）的完整 Web 应用程序。
- en: This project showed us how to create a single application that performs both
    client-side code and server-side code.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目向我们展示了如何创建一个执行客户端代码和服务器端代码的单个应用程序。
- en: In the next chapter, we will see how to create a client-side web app using WebAssembly
    technology and the Yew framework.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用 WebAssembly 技术和 Yew 框架创建客户端 Web 应用程序。
- en: Questions
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the possible strategies for creating HTML code containing variable
    parts?
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含可变部分的 HTML 代码的可能策略有哪些？
- en: What is the syntax to embed a Tera expression into a text file?
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Tera 表达式嵌入到文本文件中的语法是什么？
- en: What is the syntax to embed a Tera statement into a text file?
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Tera 语句嵌入到文本文件中的语法是什么？
- en: How are the values of variables in a Tera rendering operation specified?
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Tera 渲染操作中，如何指定变量的值？
- en: How can the requests to a web server be classified?
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何对发送到 Web 服务器的请求进行分类？
- en: Why may it be useful to split a web page into parts?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么将网页拆分成部分可能有用？
- en: Should HTML templates and JavaScript files be deployed separately or are they
    linked into the executable program?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML 模板和 JavaScript 文件应该单独部署还是链接到可执行程序中？
- en: Which JavaScript object can be used to send HTTP requests?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 JavaScript 对象可以用来发送 HTTP 请求？
- en: Where should the current username be stored when the server does not store user
    sessions?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务器不存储用户会话时，当前用户名应该存储在哪里？
- en: How are credentials extracted from an HTTP request?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从 HTTP 请求中提取凭据？
- en: Further reading
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Additional information regarding Tera can be found at [https://tera.netlify.app/](https://tera.netlify.app/).
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Tera 的更多信息可以在 [https://tera.netlify.app/](https://tera.netlify.app/) 找到。
- en: Additional information regarding Actix web can be found at [https://actix.rs/docs/](https://actix.rs/docs/).
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Actix web 的更多信息可以在 [https://actix.rs/docs/](https://actix.rs/docs/) 找到。
- en: The status of web development libraries and frameworks can be found at [https://www.arewewebyet.org/](https://www.arewewebyet.org/).
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页开发库和框架的状态可以在[https://www.arewewebyet.org/](https://www.arewewebyet.org/)找到。
