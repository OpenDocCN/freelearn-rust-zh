- en: Must-Have Macro Crates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必备的宏crate
- en: 'One of the most useful features of Rust is its crate ecosystem. In languages
    such as C/C++, it''s sometimes troublesome to find the proper library to use,
    and then it can be difficult to actually use it. This is almost straightforward
    in Rust, and in this  chapter, we will see some of the most interesting crates,
    which give us great metaprogramming primitives:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust最有用的特性之一是其crate生态系统。在C/C++等语言中，有时很难找到合适的库来使用，而且实际上使用它可能也很困难。在Rust中这几乎是直截了当的，在本章中，我们将看到一些最有趣的crate，它们为我们提供了强大的元编程原语：
- en: '**Serde**: Data serialization and deserialization support'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Serde**: 数据序列化和反序列化支持'
- en: '**Nom**: Zero-copy byte-level parser creation'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nom**: 创建零拷贝的字节级解析器'
- en: '**Lazy static**: Lazily initialized static variables'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lazy static**: 惰性初始化的静态变量'
- en: '**Derive builder**: Derive the common builder pattern for your structures'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**派生构建器**: 为你的结构派生出常见的构建器模式'
- en: '**Failure**: Easy error handling'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失败**: 简单的错误处理'
- en: '**Log and env_logger**: Logging for your software'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Log和env_logger**: 为你的软件进行日志记录'
- en: '**CLAP**: Creating command-line interfaces'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLAP**: 创建命令行界面'
- en: '**Maud**: Compile-time templates with huge performance'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maud**: 编译时模板，具有巨大的性能'
- en: '**Diesel**: MySQL/MariaDB, PostgreSQL, and SQLite database management, and
    ORM'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Diesel**: MySQL/MariaDB、PostgreSQL和SQLite数据库管理以及ORM'
- en: '**Rocket**: Nightly only high-performance web framework'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rocket**: 仅Nightly版本的高性能Web框架'
- en: Working with external data
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与外部数据交互
- en: Sometimes, we do not have complete control of our software stack. Usually, if
    you want to create a project, you will need to contact external data sources,
    which can lead to many issues, since achieving compatibility between your code
    and external APIs or sources can be difficult. Moreover, it can lead to performance
    loss, which we should avoid as much as possible. Let's check some efficient and
    easy-to-use solutions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们无法完全控制我们的软件栈。通常，如果你想创建一个项目，你将需要联系外部数据源，这可能导致许多问题，因为使你的代码与外部API或源兼容可能很困难。此外，它可能导致性能损失，我们应该尽可能避免。让我们检查一些高效且易于使用的解决方案。
- en: Data serialization and deserialization
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据序列化和反序列化
- en: When it comes to data serialization and deserialization in Rust, there is no
    doubt we are talking about serde ([https://crates.io/crates/serde](https://crates.io/crates/serde)).
    Serde, from *serialization and deserialization*, gives us a unique tool to be
    able to transform our data structures to JSON, TOML, XML, or any other serializable
    format. Let's see how it works.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到Rust中的数据序列化和反序列化时，毫无疑问我们是在谈论serde ([https://crates.io/crates/serde](https://crates.io/crates/serde))。Serde，从*序列化和反序列化*中，为我们提供了一个独特的工具，能够将我们的数据结构转换为JSON、TOML、XML或任何其他可序列化格式。让我们看看它是如何工作的。
- en: 'We start with a simple structure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的结构开始：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And we add `serde` and `serde_derive` as dependencies to our `Cargo.toml` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`Cargo.toml`文件中添加`serde`和`serde_derive`作为依赖项：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, in our `main.rs` file, we just need to import the crates using `extern
    crate` and derive the `Serialize` trait for our structure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`main.rs`文件中，我们只需要使用`extern crate`导入crate并为我们的结构派生`Serialize`特质：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we will need a *frontend* for our serializable structure. This is because
    `serde` by itself only gives our structure the ability to be serialized, but not
    the language into which it will get serialized. Let''s use JSON as an example,
    since it''s a very well-known object notation language. We first add the dependency
    to the `Cargo.toml` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的可序列化结构提供一个*前端*。这是因为`serde`本身只给了我们的结构序列化的能力，但没有给出它将要序列化的语言。让我们以JSON为例，因为它是一个非常著名的对象表示语言。我们首先在`Cargo.toml`文件中添加依赖项：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we import it in our `main.rs` file and check the data serialization:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`main.rs`文件中导入它并检查数据序列化：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we execute `cargo run`, we will see that the output of this code is the
    following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`cargo run`，我们将看到这段代码的输出如下：
- en: '![](img/a73ee9dc-390d-42d1-9736-d48313fb7755.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a73ee9dc-390d-42d1-9736-d48313fb7755.png)'
- en: 'This is a perfectly formatted and prettified JSON structure. OK, so how can
    we convert that string back into our data structure? We need to derive `Deserialize`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个格式完美且美观的JSON结构。好的，那么我们如何将这个字符串转换回我们的数据结构呢？我们需要派生`Deserialize`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will give us this output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '![](img/71155785-3f5e-49bc-97e7-b49549eacd88.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71155785-3f5e-49bc-97e7-b49549eacd88.png)'
- en: This means that we can go back and forward, from JSON to a memory structure,
    really easily! But, of course this only works for direct structure `<->` object
    serialization/deserialization. It won't work if any of them have different fields
    or names for fields. Or does it?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以轻松地在JSON和内存结构之间来回转换！但，当然，这仅适用于直接的`<->`对象序列化/反序列化。如果它们中的任何一个有不同的字段或字段名称，则不会工作。或者，它真的不会工作吗？
- en: Well, not directly of course, but we can ask `serde` to modify some parameters
    of our structure when serializing or deserializing it. For example, since in Rust
    we should use snake case for our structure fields, and *pascal* case for enumeration
    and structure names, we might think it's not possible to deserialize structures
    with pascal case fields or enumerations with snake case variants.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不是直接这样做，但我们可以请求`serde`在序列化或反序列化我们的结构时修改一些参数。例如，由于在Rust中我们应该使用snake case来表示结构字段，以及*pascal*
    case来表示枚举和结构名称，我们可能会认为无法反序列化具有pascal case字段的结构或具有snake case变体的枚举。
- en: 'Thankfully, the `serde` crate provides some attributes to personalize this
    behaviour. For example, let''s suppose we want to represent the following structure
    in Rust:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`serde` crate提供了一些属性来自定义这种行为。例如，假设我们想在Rust中表示以下结构：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have to first create a Rust structure that will hold this information, like
    this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个Rust结构来保存这些信息，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And then, we derive the appropriate traits. To rename the fields, we need to
    use the `#[serde]` attribute with the `rename_all` directive at the structure
    level, as you can see in the following code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们派生适当的特质。为了重命名字段，我们需要在结构级别使用`#[serde]`属性和`rename_all`指令，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you run it, you will see that the output is exactly as expected:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你会看到输出正好符合预期：
- en: '![](img/ccb30b4f-49aa-46cc-832b-db6e1d11355c.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ccb30b4f-49aa-46cc-832b-db6e1d11355c.png)'
- en: You can choose between `"lowercase"`, `"PascalCase"`, `"camelCase"`, `"snake_case"`,
    `"SCREAMING_SNAKE_CASE"`, and `"kebab-case"`. You can also rename one particular
    field, which is especially useful if the original structure has a reserved keyword
    (such as `type`). In this case, you can use `#[serde(rename = "type")]` in the
    field and use the name you want in your Rust structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择`"lowercase"`、`"PascalCase"`、`"camelCase"`、`"snake_case"`、`"SCREAMING_SNAKE_CASE"`和`"kebab-case"`。你也可以重命名特定的字段，这在原始结构有保留关键字（如`type`）时特别有用。在这种情况下，你可以在字段上使用`#[serde(rename
    = "type")]`，并在你的Rust结构中使用你想要的名称。
- en: Serializing and deserializing complex structures
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化和反序列化复杂结构
- en: In some cases, you might want to serialize or deserialize complex data structures.
    Most of the time, you will have a crate that does this for you (such as the *chrono*
    crate for dates and times). But in some cases this is not enough. Suppose you
    have a data structure that has a field that can take a value of either 1 or 2,
    and that each of them means something different. In Rust, you would use an enumeration
    for it, but we may not always have control of external APIs, for example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要序列化或反序列化复杂的数据结构。大多数时候，你会有一个为你做这件事的crate（例如，用于日期和时间的*chrono* crate）。但在某些情况下，这还不够。假设你有一个数据结构，它有一个字段可以取1或2的值，并且每个值都代表不同的含义。在Rust中，你会使用枚举来处理它，但我们可能并不总是能控制外部API，例如。
- en: 'Let''s look at this structure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个结构：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And let''s say we have some code, almost ready to compile, which represents
    this structure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些代码，几乎可以编译，它代表了这个结构：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, we will need to define that `NaiveDateTime` structure. We will
    need to add the following to our `Cargo.toml` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们需要定义`NaiveDateTime`结构。我们需要在`Cargo.toml`文件中添加以下内容：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And then add the imports at the top of the `main.rs` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`main.rs`文件的顶部添加导入：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The only thing left is to implement `Serialize` and `Deserialize` for `DateType`.
    But what if this enumeration is not part of our crate and we cannot modify it?
    We can, in this case, specify a way of making it work by using a function in our
    crate, adding the function name as a serde `deserialize_with` attribute in the
    `MyDate` type:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是为`DateType`实现`Serialize`和`Deserialize`。但如果这个枚举不是我们crate的一部分，我们无法修改它怎么办？在这种情况下，我们可以通过在我们的crate中使用一个函数来指定一种使其工作的方式，将函数名称作为`serde`的`deserialize_with`属性添加到`MyDate`类型中：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we will need to implement that function. It is required that the function
    has the following signature:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现这个函数。该函数需要有以下的签名：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, it''s as simple as using the `Deserializer` and `Serializer` traits.
    You can get the full API documentation by running `cargo doc`, but we will find
    out how to do it for this particular case. Let''s start with the `Serialize` implementation,
    since it''s simpler than the `Deserialize` implementation. You will just need
    to call the `serialize_u8()` (or any other integer) method with the appropriate
    value, as you can see in the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`Deserializer`和`Serializer`特性就变得非常简单。您可以通过运行`cargo doc`来获取完整的API文档，但我们将了解如何针对这个特定情况进行操作。让我们从`Serialize`实现开始，因为它比`Deserialize`实现简单。您只需调用带有适当值的`serialize_u8()`（或任何其他整数）方法，就像您在下面的代码片段中看到的那样：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, we just serialize an integer depending on the variant of the
    date type. To select which integer to serialize, we just match the enumeration.
    The `Deserializer` trait uses the visitor pattern, though, so we also need to implement
    a small structure that implements the `Visitor` trait. This is not very difficult,
    but can be a bit complex the first time we do it. Let''s check it out:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是根据日期类型的变体序列化一个整数。要选择要序列化的整数，我们只需匹配枚举。但是，`Deserializer`特性使用访问者模式，因此我们还需要实现一个小结构，该结构实现了`Visitor`特性。这并不难，但第一次做时可能会有些复杂。让我们来看看：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, I implemented the `visit_u64()` function for `Visitor`. This
    is because `serde_json` seems to use that function when serializing and deserializing
    integers. You can implement the rest if you want `Visitor` to be compatible with
    other serialization and deserialization frontends (such as XML, TOML, and others).
    You can see that the structure and the `Visitor` trait implementations are defined
    inside the function, so we do not pollute the namespace outside the function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我为`Visitor`实现了`visit_u64()`函数。这是因为`serde_json`似乎在序列化和反序列化整数时使用该函数。如果您想让`Visitor`与其他序列化和反序列化前端（如XML、TOML等）兼容，您可以实现其余部分。您可以看到，结构和`Visitor`特性实现是在函数内部定义的，所以我们不会污染函数外部的命名空间。
- en: 'You will be able to test it with a new `main()` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用新的`main()`函数来测试它：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It should show the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应该显示以下输出：
- en: '![](img/e541b3dd-ef75-4e98-98ad-eb5e59060045.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e541b3dd-ef75-4e98-98ad-eb5e59060045.png)'
- en: You can of course implement the `Serialize` and `Deserialize` traits for full
    structures and enumerations, if the `serde` attributes are not enough for your
    needs. Their implementation is close to the ones seen in these functions, but
    you will need to check the API for more complex data serialization and deserialization.
    You can find a great guide at [https://serde.rs/](https://serde.rs/) explaining
    the specific options for this crate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您需要，可以为您需要的完整结构和枚举实现`Serialize`和`Deserialize`特性，如果`serde`属性不足以满足您的需求。它们的实现与这些函数中看到的大致相同，但您需要检查API以获取更复杂的数据序列化和反序列化。您可以在[https://serde.rs/](https://serde.rs/)找到一个很好的指南，解释了这个crate的具体选项。
- en: Parsing byte streams
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析字节流
- en: Sometimes, you might want to parse byte streams or byte slices to get valuable
    data. An example could be parsing a TCP byte stream to get HTTP data. Thanks to
    `Rust` and the `Nom` crate, we have an extremely efficient parser generator, which
    will not add extra overhead by copying data within your crate.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能想要解析字节流或字节切片以获取有价值的数据。一个例子可能是解析TCP字节流以获取HTTP数据。多亏了`Rust`和`Nom` crate，我们有一个非常高效的解析生成器，它不会在您的crate内部复制数据时添加额外的开销。
- en: With the `Nom` crate, you create functions that will read the input data byte
    by byte and return the parsed data. The aim in this section is not to master the
    `Nom` crate, but to understand its power and point you to the appropriate documentation.
    So, let's see the adapted example from Zbigniew Siciarz's 24 days of Rust ([https://siciarz.net/24-days-rust-nom-part-1/](https://siciarz.net/24-days-rust-nom-part-1/)),
    where he showed a short example of how to parse the first line of the HTTP protocol.
    You can read more complex tutorials on his blog.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Nom` crate，您创建函数来逐字节读取输入数据并返回解析后的数据。本节的目标不是掌握`Nom` crate，而是理解它的强大功能，并指向适当的文档。所以，让我们看看Zbigniew
    Siciarz的24天Rust([https://siciarz.net/24-days-rust-nom-part-1/](https://siciarz.net/24-days-rust-nom-part-1/))中改编的示例，他在其中展示了如何解析HTTP协议的第一行的一个简短示例。您可以在他的博客上阅读更复杂的教程。
- en: 'Let''s first define what the first line of the protocol looks like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义协议的第一行看起来是什么样子：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the `first_line` variable is a byte array (denoted by the `b`
    before the string). It just has the method as the first word, in this case `GET`,
    but it could be `POST`, `PUT`, `DELETE`, or any of the rest methods. We will stick
    to these four for simplicity. Then, we can read the URL the client is trying to
    get, and finally, the HTTP protocol version which will be `1.1` in this case.
    The line ends with a carriage return and a new line.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`first_line`变量是一个字节数组（在字符串前用`b`表示）。它只包含第一个单词作为方法，在这个例子中是`GET`，但可能是`POST`、`PUT`、`DELETE`或其他任何方法。我们将坚持使用这四种方法以保持简单。然后，我们可以读取客户端试图获取的URL，最后是HTTP协议版本，在这个例子中将是`1.1`。这一行以回车符和换行符结束。
- en: '`Nom` uses a macro called `named!()`, where you define a parser function. The
    name of the macro comes from the fact that you are giving a name to the function
    and then its implementation.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nom`使用一个名为`named!()`的宏，其中你定义一个解析函数。宏的名字来源于你为函数命名，然后是它的实现。'
- en: 'If we want to start checking the first HTTP line, we will need to parse the
    `request` method. To do that, we have to tell the parser that the first line can
    be any of the possible `request` methods. We can do this by using the `alt!()`
    macro with multiple `tag!()` macros, one per protocol. Let''s add `Nom` to our
    `Cargo.toml` file and start coding the method parsing:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要开始检查第一条HTTP行，我们需要解析`request`方法。为了做到这一点，我们必须告诉解析器第一条行可以是任何可能的`request`方法之一。我们可以通过使用带有多个`tag!()`宏的`alt!()`宏来实现这一点，每个宏对应一个协议。让我们将`Nom`添加到我们的`Cargo.toml`文件中，并开始编写方法解析代码：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will output the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What is happening here? This seems like just a bunch of numbers, one after the
    other. Well, as we mentioned earlier, `Nom` works byte by byte, and does not care
    (unless we tell it) about the string representation of things. In this case, it
    has correctly found a `GET`, bytes 71, 69, and 84 in ASCII, and the rest is still
    not parsed. It returns a tuple with the unparsed data first and the parsed data
    second.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？这似乎只是一串数字，一个接一个。好吧，正如我们之前提到的，`Nom`按字节工作，并且不关心（除非我们告诉它）事物的字符串表示。在这种情况下，它已经正确地找到了`GET`，ASCII中的字节71、69和84，其余的尚未解析。它返回一个元组，首先是未解析的数据，然后是解析的数据。
- en: 'We can tell `Nom` that we want to read the actual `GET` string by mapping the
    result to the `str::from_utf8` function. Let''s change the parser accordingly:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以告诉`Nom`我们想要读取实际的`GET`字符串，通过将结果映射到`str::from_utf8`函数。让我们相应地更改解析器：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, apart from adding the `map_res!()` macro, I had to specify
    that the `parse_method` returns `&str` after parsing the input, since `Nom` assumes
    that your parsers will return byte slices by default. This will output the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，除了添加`map_res!()`宏之外，我还必须指定`parse_method`在解析输入后返回`&str`，因为`Nom`默认假设你的解析器将返回字节切片。这将输出以下内容：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can even create an enumeration and map it directly, as you can see here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以创建一个枚举并将其直接映射，就像你在这里看到的：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can combine multiple parsers and create variables in one parser that will
    be reused in the next one. This is useful, for example, when some parts of the
    data contain information for parsing the rest. This is the case with the HTTP
    content length header, which lets you know how much you should parse later. Let''s
    use it to parse the complete request:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个解析器组合在一起，在一个解析器中创建变量，这些变量将在下一个解析器中重用。这在某些数据部分包含用于解析其余部分的信息时非常有用。这是HTTP内容长度头的情况，它告诉你应该解析多少数据。让我们用它来解析完整的请求：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's see what's happening here. We created the structure to store the line
    data and then we created a parser by using the `ws!()` macro (which will automatically
    consume spacers between tokens). The `do_parse!()` macro allows us to create a
    sequence of many parsers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。我们创建了用于存储行数据的结构，然后通过使用`ws!()`宏（它将自动消费令牌之间的空格）创建了一个解析器。`do_parse!()`宏允许我们创建多个解析器的序列。
- en: 'We call the `parse_method()` parser we just created for the request method
    and then we just store the other two strings as variables. We then just need to
    create the structure with the variables. Note that I also changed the call in
    the `main()` function. Let''s see the result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用我们刚刚为请求方法创建的`parse_method()`解析器，然后我们只需将其他两个字符串作为变量存储。然后我们只需要用这些变量创建结构。注意，我也在`main()`函数中更改了调用。让我们看看结果：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, there are no more bytes to parse, and the `Request` structure
    has been properly generated. You can generate parsers for extremely complex structures
    and you could, for example, parse the URL to get the segments, or the version
    number to get the major and minor version numbers, and so on. The only limitations
    are your needs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，没有更多的字节需要解析，`Request` 结构体已经被正确生成。你可以为极其复杂的结构体生成解析器，例如，你可以解析 URL 来获取段，或者版本号来获取主版本号和次版本号，等等。唯一的限制是你的需求。
- en: In this case, we did some copying when calling `to_owned()` for the two strings,
    but we needed it if we wanted to generate an owned field. You can use explicit
    lifetimes to avoid a lot of copying if you require faster processing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当我们调用 `to_owned()` 为两个字符串进行复制时，我们确实需要这样做，如果我们想要生成一个拥有字段。如果你需要更快的处理速度，可以使用显式生命周期来避免大量复制。
- en: Learning about useful small crates
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解有用的小型 crate
- en: While data handling probably creates some of the most bug-prone code, we should
    also learn about some small libraries that make our lives much easier. This is
    the case for the following crates, where some macros can prevent us from writing
    lots of error-prone or potentially non-optimal code, making our final executables
    faster and easier to develop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据处理可能产生一些最易出错的代码，但我们也应该了解一些使我们的生活更加轻松的小型库。以下是一些 crate，其中一些宏可以防止我们编写大量易出错或可能非最优的代码，使我们的最终可执行文件更快、更易于开发。
- en: Creating lazily evaluated statics
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建懒加载的静态变量
- en: We have seen in previous chapters how, in nightly Rust, it is possible to call
    some trivial constant functions that are evaluated at compile time. Nevertheless,
    this might not be enough for our needs, and we might not even want to use nightly
    Rust.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到在夜间 Rust 中，可以调用一些在编译时评估的平凡常量函数。然而，这可能不足以满足我们的需求，我们甚至可能不想使用夜间 Rust。
- en: 'In this case, we can use a great crate, and the macro with the same name—`lazy_static`.
    This macro allows us to create static variables that will run the code to be generated
    on their first use. Let''s check it, for example, for a `HashMap`. Creating a
    `HashMap` or adding values to it cannot be done during compile time. As we saw
    in previous chapters, this can be improved by using the `phf` crate. But what
    if we want to add values to the `HashMap` based on some environment variable?
    This is where `lazy_static!{}` comes in:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用一个很棒的 crate，以及具有相同名称的宏——`lazy_static`。这个宏允许我们创建在首次使用时运行生成代码的静态变量。让我们以
    `HashMap` 为例检查它，创建一个 `HashMap` 或向其中添加值不能在编译时完成。正如我们在前面的章节中看到的，这可以通过使用 `phf` crate
    来改进。但如果我们想根据某些环境变量向 `HashMap` 添加值怎么办？这就是 `lazy_static!{}` 发挥作用的地方：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, we create a `HashMap` at runtime the first time we use it, so
    it will not be defined until we call `MyMap.iter()`, and if we were to use it
    again, it wouldn't need to be recreated. Not only that, it depends on the `GEN_MAP`
    environment variable. So, if we run the program with `cargo run`, it won't show
    anything; but if we run it with `GEN_MAP=true cargo run`, it will show the two
    key-values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们首次使用时在运行时创建了一个 `HashMap`，因此它将不会定义，直到我们调用 `MyMap.iter()`，如果我们再次使用它，它就不需要重新创建。不仅如此，它还依赖于
    `GEN_MAP` 环境变量。所以，如果我们用 `cargo run` 运行程序，它不会显示任何内容；但如果我们用 `GEN_MAP=true cargo
    run` 运行它，它将显示两个键值对。
- en: Under the hood, this will create a new type that implements `Deref` to `HashMap`.
    This will call to the `initialize()` function the first time it tries to get to
    the underlying type, generating the actual `HashMap`. This is very efficient if
    you only want one initialization of something you will be using more than once.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，这将创建一个新的类型，该类型实现了对 `HashMap` 的 `Deref`。这将首次尝试访问底层类型时调用 `initialize()` 函数，生成实际的
    `HashMap`。如果你只想初始化一次将多次使用的东西，这非常高效。
- en: Avoiding boilerplate code for the builder pattern
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免构建模式的样板代码
- en: 'This one is pretty straightforward. If you know about the builder pattern,
    you will know that it''s a very useful pattern to create structures. We can avoid
    writing the whole new builder structure by using the `derive_builder` crate. So,
    let''s add it to our `Cargo.toml` file and check how it works:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单。如果你了解构建模式，你就会知道它是一个非常有用的模式来创建结构。我们可以通过使用 `derive_builder` crate 来避免编写整个新的构建结构。所以，让我们将它添加到我们的
    `Cargo.toml` 文件中，并检查它是如何工作的：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we just added `#[derive(Build)]` to the structure and added
    some extra parameters, such as allowing the use of default values for non-initialized
    fields and allowing generic parameters (`Into<T>`) for setters. Note that it requires
    the structure to implement the `Default` trait.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们只是在这个结构中添加了`#[derive(Build)]`，并添加了一些额外的参数，例如允许非初始化字段使用默认值，并允许设置器使用泛型参数（`Into<T>`)。请注意，这要求结构实现`Default`特质。
- en: This enables us to initialize the structure with mere `&str` variables, for
    example, and then the builder will do the rest. As you can see, it will create
    a `{your_structure}Builder` structure that you will use to build the main one.
    Make sure you check all the little options that let you adapt the builder to your
    needs on the crate page at [crates.io](https://crates.io/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们可以使用简单的`&str`变量来初始化结构，例如，然后构建器会完成剩下的工作。正如你所看到的，它会创建一个`{your_structure}Builder`结构，你将使用它来构建主要的结构。确保你在[crates.io](https://crates.io/)的crate页面上检查所有让你能够根据需要调整构建器的选项。
- en: Managing errors
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理错误
- en: If you have used multiple libraries in Rust, you will probably have noticed
    that managing errors is not straightforward. We have the awesome `?` operator,
    but if a function has multiple errors, it's not so easy to use. We can create
    our own error types, have variants for each of them, and have an `Into` trait
    implementation for each of the errors we might encounter. This is a tedious approach,
    but until recently it was the only way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在Rust中使用过多个库，你可能已经注意到管理错误并不简单。我们有一个很棒的`?`操作符，但如果一个函数有多个错误，使用起来就不那么容易了。我们可以创建自己的错误类型，为每个错误提供变体，并为可能遇到的每个错误实现一个`Into`特质。这是一个繁琐的方法，但直到最近，这是唯一的方法。
- en: 'Luckily, we have a crate that can help us with that. This crate provides us
    with a `Fail` trait, which already guarantees thread safety and already provides
    default conversion implementations from all standard library error types. It also
    gives us some macros that help us with some boilerplate code. Let''s see an example
    of how this would work:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一个可以帮我们处理这个问题的crate。这个crate为我们提供了一个`Fail`特质，它已经保证了线程安全，并且已经为所有标准库错误类型提供了默认的转换实现。它还提供了一些宏，帮助我们处理一些样板代码。让我们看看一个例子，看看它是如何工作的：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this simple example, we get the first characters of the `Cargo.toml` file.
    As you can see, we are returning `std::io::Errors` converted into `failure::Errors`
    with the `?` operator. Then, we can iterate over the errors if they exist. If
    something goes wrong, this will be the output of the code. We have added some
    context for each of the potential errors, so that the output gets properly printed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们获取`Cargo.toml`文件的前几个字符。正如你所看到的，我们使用`?`操作符将`std::io::Errors`转换为`failure::Errors`。然后，我们可以遍历错误（如果存在的话）。如果出现问题，这将输出代码。我们为每个潜在的错误添加了一些上下文，以便输出得到正确打印：
- en: '![](img/0894515a-9967-4fbd-9b0b-14375bcd09ec.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0894515a-9967-4fbd-9b0b-14375bcd09ec.png)'
- en: You can also create your error traits and derive the `Fail` trait, thanks to
    the `failure_derive` crate. I recommend checking the complete documentation and
    using it for all your new projects. It brings many advantages over doing it yourself
    and even using the predecessor `error-chain` crate.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建自己的错误特质，并使用`failure_derive` crate来推导`Fail`特质。我建议查看完整的文档，并在所有新的项目中使用它。它带来了许多自己实现或使用前驱`error-chain`
    crate所没有的优势。
- en: Logging efficiently in Rust
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rust中高效地记录日志
- en: Logging is one of the most important parts of many applications and it's good
    to know that Rust has us covered in this regard. The default go-to crate should
    be the `log` crate, which provides us with useful macros for logging. Then, you
    can use the backend you want for the loggers, such as the `env_logger` crate or
    the `log4rs` crate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是许多应用程序最重要的部分之一，而且很高兴知道Rust在这方面为我们提供了保障。默认的goto crate应该是`log` crate，它为我们提供了有用的宏来记录。然后，你可以使用你想要的日志记录器后端，例如`env_logger`
    crate或`log4rs` crate。
- en: The `log` crate gives us some macros, mainly `trace!()`, `debug!()`, `info!()`,
     `warn!()`, and `error!()`, in ascending order of relevance, which we can use
    to log events that happen in our application. It provides some more boilerplate,
    but that is basically it, you will now have to configure how those macros behave.
    For that, you have the actual implementations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` crate为我们提供了一些宏，主要是`trace!()`、`debug!()`、`info!()`、`warn!()`和`error!()`，按照相关性的升序排列，我们可以使用它们来记录应用程序中发生的事件。它提供了一些样板代码，但基本上就是这样，你现在需要配置这些宏的行为。为此，你有实际的实现。'
- en: 'If you want an easy to use, common logger, you should go for `env_logger`.
    It has a small footprint and can be configured with environment variables. If
    you need extra configuration for things such as multiple outputs, both console
    and files, and extra configuration, you should go for an alternative such as `log4rs`.
    Let''s check a small `env_logger` example to see the power of this logging mechanism.
    You will need to add `log` and `env_logger` to your `Cargo.toml` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个易于使用、通用的日志记录器，你应该选择`env_logger`。它占用空间小，可以通过环境变量进行配置。如果你需要为诸如多个输出、控制台和文件以及额外配置等额外配置，你应该选择一个替代方案，例如`log4rs`。让我们检查一个小的`env_logger`示例，看看这种日志记录机制的力量。你需要在你的`Cargo.toml`文件中添加`log`和`env_logger`：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we run that using `cargo run`, we will see this output, since errors are
    shown by default:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`cargo run`运行它，我们将看到以下输出，因为默认情况下会显示错误：
- en: '![](img/5f1c3606-53c0-41c1-8fa4-1be168be5de5.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f1c3606-53c0-41c1-8fa4-1be168be5de5.png)'
- en: 'But we can run it with a different `RUST_LOG` environment variable, such as
    `RUST_LOG=trace cargo run`. This should show the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以用不同的`RUST_LOG`环境变量来运行它，例如`RUST_LOG=trace cargo run`。这将显示以下内容：
- en: '![](img/fb3286b2-07a9-4f1f-a77e-3a898745014f.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb3286b2-07a9-4f1f-a77e-3a898745014f.png)'
- en: As you can see, colors denote the importance of the message. Note that running
    `cargo` with the `RUST_LOG` variable will show a lot of extra output, since cargo
    itself uses `env_logger`. I recommend you read the full documentation of this
    crate, since it enables you to change formatters, loggers, and much more besides
    the default behavior.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，颜色表示消息的重要性。请注意，使用带有`RUST_LOG`变量的`cargo`运行将显示大量的额外输出，因为cargo本身使用`env_logger`。我建议你阅读这个crate的完整文档，因为它允许你更改格式化程序、日志记录器以及更多默认行为之外的功能。
- en: Creating command-line interfaces
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令行界面
- en: Creating a command-line interface is not always easy. In C/C++, you need to
    start parsing arguments and then decide which flags are set and whether they comply
    with all the conditions. This is a non-issue in Rust thanks to **Command-Line
    Argument Parser** (**CLAP**). The CLAP crate, enables us to create very complex
    command-line interfaces with just a bit of code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命令行界面并不总是容易。在C/C++中，你需要开始解析参数，然后决定哪些标志被设置，以及它们是否满足所有条件。在Rust中，这并不是一个问题，多亏了**命令行参数解析器**（**CLAP**）。CLAP
    crate使我们能够仅用一点代码就创建非常复杂的命令行界面。
- en: Not only that; it will create the help menus for us and it will also be maintainable
    since it will be easy to add or remove parameters and flags. It will ensure that
    the input we receive is valid and it will even create command-line completion
    scripts for the most-used shells.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此；它还会为我们创建帮助菜单，并且由于它易于添加或删除参数和标志，因此它将是可维护的。它将确保我们接收到的输入是有效的，甚至为最常用的shell创建命令行完成脚本。
- en: 'You can generate the complete CLI with macros, but I personally prefer to use
    simple Rust code. It has a few `helper` macros, though, to gather some information.
    Remember to add `clap` to your `Cargo.toml` file and let''s see how we would create
    a simple command-line interface:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用宏生成完整的CLI，但我个人更喜欢使用简单的Rust代码。尽管如此，它有几个`helper`宏来收集一些信息。请记住将`clap`添加到你的`Cargo.toml`文件中，并让我们看看我们如何创建一个简单的命令行界面：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, we defined a CLI with the crate name, description, version,
    and authors, which will be taken from the `Cargo.toml` file at compile time so
    that we do not need to update it for every change. It then defines a required
    `user` argument, which takes a value and uses it to print the value. The `expect()`
    here is safe because `clap` makes sure that the argument is provided, since we
    asked it to with `required(true)`. If we simply execute `cargo run`, we will see
    the following error:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们定义了一个带有crate名称、描述、版本和作者的CLI，这些将在编译时从`Cargo.toml`文件中获取，这样我们就不需要为每次更改更新它。然后它定义了一个必需的`user`参数，它接受一个值并使用它来打印该值。这里的`expect()`是安全的，因为`clap`确保了提供了参数，因为我们要求它使用`required(true)`。如果我们简单地执行`cargo
    run`，我们将看到以下错误：
- en: '![](img/4ac17912-ba27-4605-9f41-23b2b5caa043.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ac17912-ba27-4605-9f41-23b2b5caa043.png)'
- en: 'It tells us that it needs the `username` parameter and points us to the `--help`
    flag, automatically added by `clap` along with the `-V` flag, to show the crate
    version information. If we run it with `cargo run -- --help`, we will see the
    `help` output. Note that any argument to cargo after a double dash will be passed
    as an argument to the executable. Let''s check it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们需要 `username` 参数，并指向由 `clap` 自动添加的 `--help` 标志，以及 `-V` 标志，以显示 crate 版本信息。如果我们用
    `cargo run -- --help` 运行它，我们将看到 `help` 输出。请注意，任何在 cargo 后面跟双横线的参数都将作为参数传递给可执行文件。让我们检查一下：
- en: '![](img/821db47c-3714-4b34-949b-8475481ee21b.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821db47c-3714-4b34-949b-8475481ee21b.png)'
- en: 'As we can see, it shows really well-formatted help text. If we want to actually
    see the result of passing a proper username, we can execute it with `cargo run
    -- -u {username}`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它显示了格式良好的帮助文本。如果我们想真正看到传递正确用户名后的结果，我们可以用 `cargo run -- -u {username}`
    来执行它：
- en: '![](img/ae79cfa0-f144-4de3-bd1f-1aa8db50ad1e.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae79cfa0-f144-4de3-bd1f-1aa8db50ad1e.png)'
- en: Using Rust for web development
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 进行 Web 开发
- en: You might think that Rust is only meant to be used for complex system development,
    or that it should be used where security is the number one concern. Thinking of
    using it for web development might sound to you like huge overkill. We already
    have proven web-oriented languages that have worked until now, such as PHP or
    JavaScript, right?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为 Rust 只适用于复杂系统开发，或者它应该用于安全是首要关注的地方。考虑将其用于 Web 开发可能对你来说听起来像是过度杀鸡用牛刀。我们已经有了一些证明有效的面向
    Web 的语言，比如 PHP 或 JavaScript，对吧？
- en: This is far from true. Many projects use the web as their platform and for them,
    it's sometimes more important to be able to receive a lot of traffic without investing
    in expensive servers rather than using legacy technologies, especially in new
    products. This is where Rust comes in handy. Thanks to its speed and some really
    well thought out web-oriented frameworks, Rust performs even better than the legacy
    web programming languages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这远非事实。许多项目将 Web 作为他们的平台，对于他们来说，有时能够处理大量流量而不需要投资昂贵的服务器，比使用过时的技术更重要，尤其是在新产品中。这就是
    Rust 发挥作用的地方。多亏了它的速度和一些真正深思熟虑的面向 Web 的框架，Rust 的表现甚至比传统的 Web 编程语言还要好。
- en: Rust is even trying to replace some of the JavaScript on the client side of
    applications, since Rust can compile to WebAssembly, making it extremely powerful
    for heavy client-side web workloads. We will not learn how to compile for web
    clients in this book, but we will learn about some crates that allow you work
    on efficient web development with Rust.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 甚至试图取代应用程序客户端的一些 JavaScript，因为 Rust 可以编译成 WebAssembly，这使得它在处理重客户端 Web 工作负载时非常强大。我们在这本书中不会学习如何为
    Web 客户端编译，但我们将了解一些允许你使用 Rust 进行高效 Web 开发的 crate。
- en: Creating extremely efficient templates
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建极其高效的模板
- en: We have seen that Rust is a really efficient language and as you have seen in
    the last two chapters, metaprogramming allows for the creation of even more efficient
    code. Rust has great templating language support, such as Handlebars and Tera.
    Rust's Handlebars implementation is much faster than the JavaScript implementation,
    while Tera is a template engine created for Rust based on Jinja2.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Rust 是一种非常高效的编程语言，正如你在前两章中看到的，元编程允许创建更加高效的代码。Rust 拥有强大的模板语言支持，例如 Handlebars
    和 Tera。Rust 的 Handlebars 实现比 JavaScript 实现要快得多，而 Tera 是基于 Jinja2 为 Rust 创建的模板引擎。
- en: In both cases, you define a template file and then you use Rust to parse it.
    Even though this will be reasonable for most web development, in some cases, it
    might be slower than pure Rust alternatives. This is where the Maud crate comes
    in. We will see how it works and how it achieves orders of magnitude faster performance
    than its counterparts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你定义一个模板文件，然后使用 Rust 来解析它。尽管这对于大多数 Web 开发来说可能是合理的，但在某些情况下，它可能比纯 Rust
    替代方案要慢。这就是 Maud crate 发挥作用的地方。我们将看到它是如何工作的，以及它是如何实现比其竞争对手快几个数量级的性能的。
- en: 'To use Maud, you will need nightly Rust, since it uses procedural macros. As
    we saw in previous chapters, if you are using `rustup` you can simply run `rustup
    override set nightly`. Then, you will need to add Maud to your `Cargo.toml` file
    in the `[dependencies]` section:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Maud，你需要 nightly Rust，因为它使用过程宏。正如我们在前面的章节中看到的，如果你使用 `rustup`，你可以简单地运行 `rustup
    override set nightly`。然后，你需要在 `Cargo.toml` 文件的 `[dependencies]` 部分添加 Maud：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Maud brings an `html!{}` procedural macro that enables you to write HTML in
    Rust. You will therefore need to import the necessary crate and macro in your
    `main.rs` or `lib.rs` file, as you will see in the following code. Remember to
    also add the procedural macro feature at the beginning of the crate:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Maud 引入了一个 `html!{}` 过程宏，它允许你在 Rust 中编写 HTML。因此，你需要在 `main.rs` 或 `lib.rs` 文件中导入必要的
    crate 和宏，正如你将在下面的代码中看到的那样。记得在 crate 的开头添加过程宏功能：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You will now be able to use the `html!{}` macro in your `main()` function.
    This macro will return a `Markup` object, which you can then convert to a `String`
    or return to Rocket or Iron for your website implementation (you will need to
    use the relevant Maud features in that case). Let''s see what a short template
    implementation looks like:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将能够在 `main()` 函数中使用 `html!{}` 宏。这个宏将返回一个 `Markup` 对象，然后你可以将其转换为 `String`
    或返回给 Rocket 或 Iron 以实现你的网站（在这种情况下，你需要使用相关的 Maud 功能）。让我们看看一个简短的模板实现看起来像什么：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It seems like a complex template, but it contains just the basic information
    a new website should have. We first add a doctype, making sure it will not escape
    the content (that is what the `PreEscaped` is for) and then we start the HTML
    document with two parts: the `head` and the `body`. In the `head`, we add the
    required title and the `charset` `meta` element to tell the browser that we will
    be using UTF-8.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板看起来很复杂，但它只包含了一个新网站应该有的基本信息。我们首先添加 doctype，确保它不会逃逸内容（这就是 `PreEscaped` 的作用），然后我们以两个部分开始
    HTML 文档：`head` 和 `body`。在 `head` 中，我们添加必要的标题和 `charset` `meta` 元素，告诉浏览器我们将使用 UTF-8。
- en: Then, the `body` contains the three usual sections, even though this can of
    course be modified. One `header`, one `main` section, and one `footer`. I added
    some example information in each of the sections and showed you how to add a dynamic
    variable in the `main` section inside a paragraph.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`body` 包含了三个常用的部分，尽管当然可以对其进行修改。一个 `header`，一个 `main` 部分，和一个 `footer`。我在每个部分中添加了一些示例信息，并展示了如何在
    `main` 部分内的段落中添加动态变量。
- en: The interesting syntax here is that you can create elements with attributes,
    such as the `meta` element, even without content, by finishing it early with a
    semicolon. You can use any HTML tag and add variables. The generated code will
    be escaped, except if you ask for non-escaped data, and it will be minified so
    that it occupies the least space when being transmitted.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的有趣语法是，你可以创建带有属性的元素，例如 `meta` 元素，即使没有内容，也可以通过提前使用分号来结束。你可以使用任何 HTML 标签并添加变量。生成的代码将被转义，除非你要求非转义数据，并且它将被压缩，以便在传输时占用最少的空间。
- en: Inside the parentheses, you can call any function or variable that returns a
    type that implements the `Display` trait and you can even add any Rust code if
    you add braces around it, with the last statement returning a `Display` element.
    This works on attributes too.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内，你可以调用任何返回实现 `Display` 特性的类型的功能或变量，如果你在它周围添加大括号，甚至可以添加任何 Rust 代码，最后一条语句将返回一个
    `Display` 元素。这也适用于属性。
- en: This gets processed at compile time, so that at runtime it will only need to
    perform the minimum possible amount of work, making it extremely efficient. And
    not only that; the template will be typesafe thanks to Rust's compile-time guarantees,
    so you won't forget to close a tag or an attribute. There is a complete guide
    to the templating engine that can be found at [https://maud.lambda.xyz/](https://maud.lambda.xyz/).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在编译时进行处理，因此运行时只需执行最小的工作量，使其非常高效。不仅如此；由于 Rust 的编译时保证，模板将是类型安全的，所以你不会忘记关闭一个标签或属性。可以在
    [https://maud.lambda.xyz/](https://maud.lambda.xyz/) 找到关于模板引擎的完整指南。
- en: Connecting with a database
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: If we want to use SQL/relational databases in Rust, there is no other crate
    to think about than Diesel. If you need access to NoSQL databases such as Redis
    or MongoDB, you will also find proper crates, but since the most used databases
    are relational databases, we will check Diesel here.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 Rust 中使用 SQL/关系数据库，除了 Diesel 没有其他 crate 值得考虑。如果你需要访问 Redis 或 MongoDB
    等非关系数据库，你也会找到合适的 crate，但由于最常用的数据库是关系数据库，我们在这里将检查 Diesel。
- en: Diesel makes working with MySQL/MariaDB, PostgreSQL, and SQLite very easy by
    providing a great ORM and typesafe query builder. It prevents all potential SQL
    injections at compile time, but is still extremely fast. In fact, it's usually
    faster than using prepared statements, due to the way it manages connections to
    databases. Without entering into technical details, we will check how this stable
    framework works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Diesel 通过提供出色的 ORM 和类型安全的查询构建器，使得与 MySQL/MariaDB、PostgreSQL 和 SQLite 一起工作变得非常容易。它在编译时防止所有潜在的
    SQL 注入，但仍然非常快速。实际上，它通常比使用预处理语句更快，因为它管理数据库连接的方式。不深入技术细节，我们将检查这个稳定框架是如何工作的。
- en: The development of Diesel has been impressive and it's already working in stable
    Rust. It even has a stable 1.x version, so let's check how we can map a simple
    table. Diesel comes with a command-line interface program, which makes it much
    easier to use. To install it, run `cargo install diesel_cli`. Note that, by default, this will
    try to install it for PostgreSQL, MariaDB/MySQL, and SQLite.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Diesel 的发展令人印象深刻，它已经在稳定的 Rust 中运行。它甚至有一个稳定的 1.x 版本，所以让我们看看我们如何映射一个简单的表。Diesel
    附带一个命令行界面程序，这使得它更容易使用。要安装它，运行 `cargo install diesel_cli`。请注意，默认情况下，这将尝试为 PostgreSQL、MariaDB/MySQL
    和 SQLite 安装它。
- en: 'For this short tutorial, you need to have SQLite 3 development files installed,
    but if you want to avoid installing all MariaDB/MySQL or PostgreSQL files, you
    should run the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简短的教程，您需要安装 SQLite 3 开发文件，但如果您想避免安装所有 MariaDB/MySQL 或 PostgreSQL 文件，您应该运行以下命令：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, since we will be using SQLite for our short test, add a file named `.env`
    to the current directory, with the following content:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于我们将使用 SQLite 进行我们的短期测试，请在当前目录中添加一个名为 `.env` 的文件，内容如下：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now run `diesel setup` and `diesel migration generate initial_schema`.
    This will create the `test.sqlite` SQLite database and a `migrations` folder,
    with the first empty initial schema migration. Let''s add this to the initial
    schema `up.sql` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行 `diesel setup` 和 `diesel migration generate initial_schema`。这将创建 `test.sqlite`
    SQLite 数据库和一个 `migrations` 文件夹，以及第一个空的初始模式迁移。让我们将其添加到初始模式 `up.sql` 文件中：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In its counterpart `down.sql` file, we will need to drop the created table:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在其对应的 `down.sql` 文件中，我们需要删除创建的表：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we can execute `diesel migration run` and check that everything went
    smoothly. We can execute `diesel migration redo` to check that the rollback and
    recreation worked properly. We can now start using the ORM. We will need to add
    diesel, `diesel_infer_schema`, and `dotenv` to our `Cargo.toml`. The `dotenv`
    crate will read the `.env` file to generate the environment variables. If you
    want to avoid using all the MariaDB/MySQL or PostgreSQL features, you will need
    to configure `diesel` for it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行 `diesel migration run` 并检查一切是否顺利。我们可以执行 `diesel migration redo` 来检查回滚和重新创建是否正常工作。我们现在可以开始使用
    ORM。我们需要将 diesel、`diesel_infer_schema` 和 `dotenv` 添加到我们的 `Cargo.toml` 中。`dotenv`
    crate 将读取 `.env` 文件以生成环境变量。如果您想避免使用所有 MariaDB/MySQL 或 PostgreSQL 功能，您需要为 `diesel`
    进行配置：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s now create a structure that we will be able to use to retrieve data
    from the database. We will also need some boilerplate code to make everything
    work:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个结构，我们将能够用它从数据库中检索数据。我们还需要一些样板代码来使一切正常工作：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, the `establish_connection()` function will call `dotenv()` so that the
    variables in the `.env` file get to the environment, and then it uses that `DATABASE_URL`
    variable to establish the connection with the SQLite database and returns the
    handle.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`establish_connection()` 函数将调用 `dotenv()`，以便 `.env` 文件中的变量进入环境，然后它使用该 `DATABASE_URL`
    变量与 SQLite 数据库建立连接并返回句柄。
- en: The schema module will contain the schema of the database. The `infer_schema!()`
    macro will get the `DATABASE_URL` variable and connect to the database at compile
    time to generate the schema. Make sure you run all the migrations before compiling.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 模式模块将包含数据库的模式。`infer_schema!()` 宏将获取 `DATABASE_URL` 变量并在编译时连接到数据库以生成模式。确保在编译前运行所有迁移。
- en: 'We can now develop a small `main()` function with the basics to list all of
    the users from the database:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开发一个简单的 `main()` 函数，使用基础功能来列出数据库中的所有用户：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will just load all of the users from the database into a list. Notice the
    `use` statement at the beginning of the function. This retrieves the required
    information from the schema for the `users` table so that we can then call `users.load()`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只是将数据库中的所有用户加载到一个列表中。注意函数开始处的 `use` 语句。这从 `users` 表的模式中检索所需信息，以便我们随后可以调用 `users.load()`。
- en: As you can see in the guides at [diesel.rs](http://diesel.rs/guides/), you can
    also generate `Insertable` objects, which might not have some of the fields with
    default values, and you can perform complex queries by filtering the results in
    the same way you would write a `SELECT` statement.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[diesel.rs](http://diesel.rs/guides/)指南中看到的那样，你还可以生成`Insertable`对象，这些对象可能没有一些具有默认值的字段，并且你可以通过以与编写`SELECT`语句相同的方式过滤结果来执行复杂查询。
- en: Creating a complete web server
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个完整的网络服务器
- en: There are multiple web frameworks for Rust. Some of them work in stable Rust,
    such as Iron and Nickel Frameworks, and some don't, such as Rocket. We will talk
    about the latter since, even if it forces you to use the latest nightly branch,
    it's so much more powerful than the rest that it really makes no sense to use
    any of the others if you have the option to use Rust nightly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有多种网络框架。其中一些在稳定版Rust中工作，例如Iron和Nickel框架，而另一些则不行，例如Rocket。我们将讨论后者，因为即使它迫使你使用最新的夜间分支，它也比其他框架强大得多，如果你有选择使用Rust夜间版本，那么使用其他任何框架都没有意义。
- en: Using Diesel with Rocket, apart from the funny wordplay joke, works seamlessly.
    You will probably be using the two of them together, but in this section we will
    learn how to create a small Rocket server without any further complexity. There
    are some boilerplate code implementations that add database, cache, OAuth, templating,
    response compression, JavaScript minification, and SASS minification to the website,
    such as my Rust web template ([https://github.com/Razican/Rust-web-template](https://github.com/Razican/Rust-web-template))
    in GitHub if you need to start developing a real-life Rust web application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用柴油与火箭结合，除了有趣的文字游戏玩笑外，工作起来无缝衔接。你可能经常会将这两个一起使用，但在这个部分，我们将学习如何创建一个没有额外复杂性的小型火箭服务器。有一些模板代码实现为网站添加数据库、缓存、OAuth、模板、响应压缩、JavaScript压缩和SASS压缩，例如GitHub上的我的Rust网络模板([https://github.com/Razican/Rust-web-template](https://github.com/Razican/Rust-web-template))，如果你需要开始开发一个真实的Rust网络应用程序。
- en: Rocket trades that nightly instability, which will break your code more often
    than not, for simplicity and performance. Developing a Rocket application is really
    easy and the performance of the results is astonishing. It's even faster than
    using some other, seemingly simpler frameworks, and of course, it's much faster
    than most of the frameworks in other languages. So, how does it feel to develop
    a Rocket application?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket以夜间不稳定为代价，这会频繁地破坏你的代码，换取简单性和性能。开发Rocket应用程序非常容易，结果性能令人惊叹。它甚至比使用一些看似更简单的框架还要快，当然，它比大多数其他语言的框架快得多。那么，开发Rocket应用程序的感觉如何？
- en: 'We start by adding the latest `rocket` and `rocket_codegen` crates to our `Cargo.toml`
    file and adding a nightly override to our current directory by running `rustup
    override set nightly`. The `rocket` crate contains all the code to run the server,
    while the `rocket_codegen` crate is actually a compiler plugin that modifies the
    language to adapt it for web development. We can now write the default `Hello,
    world!` Rocket example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过在`Cargo.toml`文件中添加最新的`rocket`和`rocket_codegen`crate，并通过运行`rustup override
    set nightly`为当前目录添加夜间覆盖来开始。`rocket`crate包含运行服务器的所有代码，而`rocket_codegen`crate实际上是一个编译器插件，它修改语言以适应Web开发。我们现在可以编写默认的`Hello,
    world!`Rocket示例：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, we can see how we ask Rust to let us use plugins to then import
    the `rocket_codegen` plugin. This will enable us to use attributes such as `#[get]`
    or `#[post]` with request information that will generate boilerplate code when
    compiled, leaving our code fairly simple for our development. Also, note that
    this code has been checked with Rocket 0.3 and it might fail in a future version,
    since the library is not stable yet.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以看到我们如何请求Rust让我们使用插件，然后导入`rocket_codegen`插件。这将使我们能够在编译时使用`#[get]`或`#[post]`等属性，这些属性将生成模板代码，使我们的代码在开发中保持相对简单。此外，请注意，此代码已与Rocket
    0.3进行了检查，它可能在未来的版本中失败，因为该库尚不稳定。
- en: In this case, you can see that the `index()` function will respond to any `GET`
    request with a base URL. This can be modified to accept only certain URLs, or
    to get the path of something from the URL. You can also have overlapping routes
    with different priorities, so that if one is not taken for a request guard, the
    next will be tried.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以看到`index()`函数将响应任何带有基本URL的`GET`请求。这可以被修改为只接受某些URL，或者从URL中获取某个路径。你也可以有具有不同优先级的重叠路由，这样如果请求保护器没有选择一个，下一个将被尝试。
- en: And, talking about request guards, you can create objects that can be generated
    when processing a request that will only let the request process a given function
    if they are properly built. This means that you can, for example, create a `User`
    object that will get generated by checking the cookies in the request and comparing
    them in a Redis database, only allowing the execution of the function for logged-in
    users. This easily prevents many logic flaws.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，谈到请求守卫，你可以创建在处理请求时可以生成的对象，这些对象只有在正确构建的情况下才会允许请求执行给定的函数。这意味着，例如，你可以创建一个`User`对象，该对象将通过检查请求中的cookie并在Redis数据库中进行比较来生成，仅允许登录用户执行函数。这可以轻松防止许多逻辑错误。
- en: 'The `main()` function ignites the Rocket and mounts the index route at `/`.
    This means that you can have multiple routes with the same path mounted at different
    route paths and they do not need to know about the whole path in the URL. In the
    end, it will launch the Rocket server and if you run it with `cargo run`, it will
    show the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数点燃火箭并将索引路由挂载到`/`。这意味着你可以有多个具有相同路径的路由挂载到不同的路由路径，它们不需要知道URL中的整个路径。最后，它将启动Rocket服务器，如果你使用`cargo
    run`运行它，它将显示以下内容：'
- en: '![](img/7c271111-1912-48b4-812f-e78e5fb32511.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c271111-1912-48b4-812f-e78e5fb32511.png)'
- en: If you go to the URL, you will see the `Hello, World!` message. Rocket is highly
    configurable. It has a `rocket_contrib` crate which offers templates and further
    features, and you can create responders to add GZip compression to responses.
    You can also create your own error responders when an error occurs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问URL，你会看到`Hello, World!`消息。Rocket高度可配置。它有一个`rocket_contrib` crate，它提供模板和更多功能，你可以创建响应者以向响应添加GZip压缩。当发生错误时，你还可以创建自己的错误响应者。
- en: You can also configure the behavior of Rocket by using the `Rocket.toml` file
    and environment variables. As you can see in this last output, it is running in
    development mode, which adds some debugging information. You can configure different
    behaviors for staging and production modes and make them perform faster. Also,
    make sure that you compile the code in `--release` mode in production.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用`Rocket.toml`文件和环境变量来配置Rocket的行为。正如你可以在最后一个输出中看到的那样，它正在开发模式下运行，这添加了一些调试信息。你可以为预发布和生产模式配置不同的行为，并使它们运行得更快。此外，请确保在生产中用`--release`模式编译代码。
- en: If you want to develop a web application in Rocket, make sure you check [https://rocket.rs/](https://rocket.rs/)
    for further information. Future releases also look promising. Rocket will implement
    native CSRF and XSS prevention, which, in theory, should prevent all XSS and CSRF
    attacks at compile time. It will also make further customizations to the engine
    possible.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Rocket中开发Web应用程序，请确保检查[https://rocket.rs/](https://rocket.rs/)以获取更多信息。未来的版本也很有希望。Rocket将实现本机CSRF和XSS防护，理论上应在编译时防止所有XSS和CSRF攻击。它还将使对引擎的进一步定制成为可能。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about many crates that will make your life writing
    Rust code much easier. You learned how they can not only allow you to write less
    code, but that they can help you write faster code. We also saw how easy it is
    to use a crate from [https://crates.io/](https://crates.io/), which gives us superpowers
    when using code written by others.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了许多将使你编写Rust代码的生活更加轻松的crate。你学习了它们不仅允许你编写更少的代码，而且可以帮助你编写更快的代码。我们还看到了如何轻松地使用来自[https://crates.io/](https://crates.io/)的crate，这在使用他人编写的代码时赋予我们超级能力。
- en: In the next chapter, you will learn how to develop your own macros, similar
    to the ones seen here, and you will also learn how to create your own procedural
    macros and plugins.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何开发自己的宏，类似于这里看到的，你还将学习如何创建自己的过程宏和插件。
