- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Implementing Actors and Async with the Hyper Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hyper框架实现演员和异步
- en: The actor model has shown us that we can build async code that is safe and easy
    to maintain. In this chapter, we take the actor model a little further by building
    a caching mechanism with a background task that keeps running while we accept
    incoming HTTP requests using the **Hyper** framework. It must be noted that a
    Hyper framework is a low-level approach to processing HTTP requests. This enables
    us to build web applications where we have fine grain control over how the HTTP
    server handles HTTP requests. For instance, if we do not code how to handle **Universal
    Resource Identifiers** (**URIs**) and methods, the HTTP server built in Hyper
    will handle all requests, in the same way, no matter the method or URI passed
    in. Hyper is useful for building custom network applications such as caching mechanisms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 演员模型向我们展示了我们可以构建既安全又易于维护的异步代码。在本章中，我们通过构建一个具有后台任务的缓存机制，该任务在我们使用**Hyper**框架接受传入的HTTP请求的同时持续运行，将演员模型推进了一步。必须注意的是，Hyper框架是处理HTTP请求的低级方法。这使得我们能够构建具有细粒度控制HTTP服务器如何处理HTTP请求的Web应用程序。例如，如果我们没有编写如何处理**统一资源标识符**（**URIs**）和方法，Hyper内置的HTTP服务器将处理所有请求，无论传入的方法或URI是什么。Hyper对于构建自定义网络应用程序，如缓存机制非常有用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Breaking down the actor async project and requirements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解演员异步项目和需求
- en: Defining channel messages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义通道消息
- en: Building a runner actor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建运行器演员
- en: Building a state actor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建状态演员
- en: Handling HTTP requests using Hyper
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hyper处理HTTP请求
- en: Building an HTTP server using Hyper
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hyper构建HTTP服务器
- en: Running our Hyper HTTP server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行我们的Hyper HTTP服务器
- en: By the end of this chapter, you will be able to build a low-level HTTP server
    that runs clean-up processes in the background while accepting HTTP requests.
    However, it must be noted that in previous chapters, we have built fully functioning
    applications using frameworks such as Rocket and Actix. It took multiple chapters
    to build a fully functioning application in Actix. It would not be possible to
    cover everything needed to build a fully functioning web application in a lower-level
    framework such as Hyper in one chapter. We are merely using Hyper to set up and
    receive HTTP requests. However, with what we cover in this chapter, you should
    be able to build out a fully functioning web application with examples from online
    Hyper docs as we cover the core concepts of what gets a Hyper HTTP server running.
    It is advised that if you require a fully functioning web application that supports
    loads of views and authentication, then it makes sense to go for a higher-level
    framework such as Actix or Rocket.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够构建一个低级HTTP服务器，它在接受HTTP请求的同时在后台运行清理过程。然而，必须注意的是，在前面的章节中，我们已经使用像Rocket和Actix这样的框架构建了完整功能的应用程序。在Actix中构建一个完整功能的应用程序需要多个章节。在一个章节中不可能涵盖在像Hyper这样的低级框架中构建完整功能Web应用程序所需的所有内容。我们只是在Hyper的帮助下设置和接收HTTP请求。然而，通过本章所涵盖的内容，你应该能够使用在线Hyper文档中的示例构建一个完整功能的Web应用程序，因为我们涵盖了使Hyper
    HTTP服务器运行的核心概念。如果你需要一个支持大量视图和身份验证的完整功能Web应用程序，那么选择像Actix或Rocket这样的高级框架是有意义的。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be purely focusing on how to build a server using the
    Hyper framework. Therefore, we will not be relying on any previous code as we
    are building our own new server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将纯粹关注如何使用Hyper框架构建服务器。因此，我们不会依赖任何之前的代码，因为我们正在构建自己的新服务器。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter17](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter17).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter17](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter17)找到。
- en: Breaking down our project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解我们的项目
- en: We are building a simulation platform where users can log in and interact with
    fake simulated people via chatbots to see what they say to the fake people. We
    want to see what the users say to the fake people at the end of the simulation
    session. The problem is that there are a lot of messages being sent to a fake
    person in a short amount of time. If we hit the database every time a message
    is sent, then we will put our database under a lot of strain. Let us say that
    a user asks a question every 20 seconds; this means we will be hitting the database
    6 times per minute as there is a question and an answer per interaction. If we
    have 800 users running a session at the same time, then we can have up to 4,800
    hits a minute. This can put a strain on the database. To reduce the strain on
    the database, we can build a server in Hyper that caches the chats and periodically
    sends multiple questions and answers to the database. Before moving forward, this
    is a chance for you to think back at all the chapters that we have covered and
    think of a high-level solution to building this caching mechanism.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个模拟平台，用户可以通过聊天机器人登录并与模拟人物互动，以查看他们对模拟人物说了什么。我们希望在模拟会话结束时看到用户对模拟人物说了什么。问题是，在短时间内会有很多消息发送给一个模拟人物。如果我们每次发送消息时都击中数据库，那么我们将使数据库承受很大的压力。让我们假设一个用户每20秒问一个问题；这意味着我们每分钟将击中数据库6次，因为每次交互都有一个问题和答案。如果我们有800个用户同时运行会话，那么我们每分钟可以有高达4,800次击中。这可能会对数据库造成压力。为了减轻数据库的压力，我们可以在Hyper中构建一个服务器来缓存聊天信息，并定期向数据库发送多个问题和答案。在继续前进之前，这是一个让你回顾我们已经涵盖的所有章节并思考构建此缓存机制的高级解决方案的机会。
- en: 'There are multiple approaches to building the caching server, but to improve
    our understanding of async programming, we will solve our problem with the actor
    model. Our approach will have an actor that accepts a chat log and caches it under
    an ID. We then have another actor that periodically gets message data from the
    cache actor and sends it to another server. The data flow of our server takes
    the following form:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 建立缓存服务器有多种方法，但为了提高我们对异步编程的理解，我们将使用演员模型来解决问题。我们的方法将有一个演员接受聊天日志并将其缓存在一个ID下。然后我们还有一个演员定期从缓存演员获取消息数据并将其发送到另一个服务器。我们服务器中的数据流采用以下形式：
- en: '![Figure 17.1 – Layers in our app](img/Figure_17.1_B18722.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图17.1 – 我们应用程序的层](img/Figure_17.1_B18722.jpg)'
- en: Figure 17.1 – Layers in our app
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – 我们应用程序的层
- en: 'With this approach, we will need the following file layout for our server:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们服务器需要以下文件布局：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will define our actors in the individual files in the `actors` directory.
    All our code that handles HTTP requests will be defined in the `main.rs` file.
    We now have all the files that we need. When it comes to our dependencies, we
    know that we are accepting HTTP requests, sending HTTP requests, serializing data,
    and running our program in an async manner. With what we are doing in our application,
    it should not be a surprise that we have the following dependencies in the `Cargo.toml`
    file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`actors`目录下的单独文件中定义我们的演员。处理HTTP请求的所有代码都将定义在`main.rs`文件中。我们现在有了所有需要的文件。当我们谈到依赖项时，我们知道我们正在接受HTTP请求、发送HTTP请求、序列化数据和以异步方式运行我们的程序。鉴于我们在应用程序中所做的工作，我们不应该对`Cargo.toml`文件中以下依赖项感到惊讶：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The dependencies should not be a surprise at this stage, apart from the `reqwest`
    dependency, which we use to send HTTP requests. Now that we have defined the outline
    of our project, we can move on to building the first part of our system, which
    is defining the messages for our system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，除了用于发送HTTP请求的`reqwest`依赖项外，依赖项不应该令人惊讶。现在我们已经定义了项目的轮廓，我们可以继续构建系统的第一部分，即定义系统的消息。
- en: Defining channel messages
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义通道消息
- en: 'Our runner actor needs to periodically send messages to our state actor and
    then send a batch of chats to a server. Considering the functionality of our runner
    actor, we can see that it does not need a state but does need to send messages.
    Before building our runner actor, we must build the messages that will be sent
    to actors and servers. In the `src/actors/messages.rs` file, we start by importing
    what we need with the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行演员需要定期向我们的状态演员发送消息，然后将一批聊天信息发送到服务器。考虑到运行演员的功能，我们可以看到它不需要状态，但需要发送消息。在构建运行演员之前，我们必须构建将被发送到演员和服务器上的消息。在`src/actors/messages.rs`文件中，我们首先使用以下代码导入所需的模块：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will be using the `Serialize` trait to enable us to process the body data
    from HTTP requests. Now that we have imported what we need, we can define the
    type of messages that are being sent to actors. If we think about what we need,
    we will be sending messages to the state actor to either get cached data or insert
    data. The state actor can return data and return empty data if there are no chats
    cached. Considering that we have three different types of messages, we have the
    following enum to define the type of message being sent with the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Serialize`特质来使我们能够处理来自HTTP请求的正文数据。现在我们已经导入了所需的模块，我们可以定义发送给演员的消息类型。如果我们考虑我们需要什么，我们将向状态演员发送消息以获取缓存数据或插入数据。状态演员可以返回数据，如果没有缓存的聊天记录，则返回空数据。考虑到我们有三种不同类型的消息，我们有以下枚举来定义发送的消息类型，以下代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then have the struct for our messages that will be sent to and from actors,
    which takes the following form:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有用于发送和接收给演员的消息的结构体，其形式如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see that we must define what type of message is being sent. Everything
    else is optional. For instance, if the state actor finds that there are no cached
    chats, then the state actor cannot populate any other fields apart from the message
    type saying that the message is empty.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们必须定义正在发送的消息类型。其他一切都是可选的。例如，如果状态演员发现没有缓存的聊天记录，那么状态演员就不能填充除消息类型之外的其他字段，表示消息为空。
- en: 'Remember that we must send blocks of cached chat messages to a server. We can
    implement the functionality of sending the data to the server for the `StateActorMessage`
    struct with the following code. We must note that we have not made the `PostBody`
    struct yet, but we will do this straight afterward:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们必须将缓存的聊天消息块发送到服务器。我们可以使用以下代码实现将数据发送到服务器的`StateActorMessage`结构体的功能。我们必须注意，我们还没有创建`PostBody`结构体，但我们将立即进行此操作：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see that we merely get the server URL from the environment, create one
    large string with `$` as a delimiter separating the pairs of questions and answers,
    and then send it to another server. We could make an actor handling the message
    send data to the server. However, coupling the sending of data to the server with
    the message struct gives more flexibility as any actor that handles the message
    can send the data in the message to the server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们只是从环境中获取服务器URL，创建一个由`$`作为分隔符的大字符串，分隔问题和答案对，然后将其发送到另一个服务器。我们可以创建一个处理消息并将数据发送到服务器的演员。然而，将数据发送到服务器的操作与消息结构体耦合提供了更大的灵活性，因为任何处理消息的演员都可以将消息中的数据发送到服务器。
- en: 'When it comes to the `PostBody` struct, it should be no surprise that it takes
    the following form:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到`PostBody`结构体时，它应该采取以下形式：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our messages for our entire application are now defined. We can now move on
    to building our runner actor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整个应用程序的消息现在已定义。我们现在可以继续构建我们的运行演员。
- en: Building our runner actor
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的运行演员
- en: 'Our runner actor consistently loops, sending messages to the state actor, asking
    for batched data, and sending the batched data to the server if the batched data
    is present. This means that our actor will be sending and receiving messages throughout
    the lifetime of the program. With the behavior of the runner actor in mind, it
    should not be a shock that we need the following imports in the `src/actors/runner.rs`
    file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行演员持续循环，向状态演员发送消息，请求批量数据，如果存在批量数据，则将其发送到服务器。这意味着我们的演员将在整个程序生命周期中发送和接收消息。考虑到运行演员的行为，我们不需要在`src/actors/runner.rs`文件中需要以下导入：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have imported the messages and the modules required to sleep for a period
    of seconds. We have also used type aliases to define the type of channels our
    runner actor will be supporting. We can now define the runner actor with the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了所需的模块和用于暂停几秒钟的消息。我们还使用了类型别名来定义运行演员将支持的通道类型。我们现在可以定义运行演员，以下代码：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we are merely defining the number of seconds our actor will wait before
    making another request for data. We then have a sender and receiver to send and
    receive messages. With the fields defined, we then need to move on to defining
    the constructor and run function for our `RunnerActor` struct with the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅仅定义了我们的演员在再次请求数据之前将等待的秒数。然后，我们有一个发送者和接收者用于发送和接收消息。定义了字段后，我们接下来需要使用以下代码定义我们的`RunnerActor`结构体的构造函数和运行函数：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that our constructor function (`new`) is not really needed. In our
    `new` function, we are merely passing arguments directly into the fields of the
    `RunnerActor` struct. However, for the effort exerted, it is nice to have. For
    instance, if we need to add some checks later or send a message to the state actor
    saying that the `RunnerActor` struct has been constructed, all we need to do is
    change the behavior in the `new` function, and this behavior will propagate throughout
    the program where the `new` function is used.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的构造函数（`new`）实际上并不是必需的。在我们的`new`函数中，我们只是直接将参数传递到`RunnerActor`结构体的字段中。然而，考虑到所付出的努力，它还是很有用的。例如，如果我们以后需要添加一些检查或者向状态演员发送消息，说明`RunnerActor`结构体已经被构建，我们只需要更改`new`函数中的行为，这种行为将会在整个程序中使用`new`函数的地方传播。
- en: 'For our `run` function, we run an infinite loop. Inside this loop, we send
    a message to the state actor. Each iteration of the loop is broken with a sleep
    function with the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`run`函数，我们运行一个无限循环。在这个循环内部，我们向状态演员发送消息。每次循环迭代都通过以下代码中的睡眠函数来中断：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have sent the message, we must wait for a response and send the batched
    data to a server if the response is not empty, which can be done with the following
    code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们发送了消息，我们必须等待响应，如果响应不为空，则需要将批处理数据发送到服务器，这可以通过以下代码完成：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we can see that, by now, the logic is not too confusing. With that, we
    will be able to speed through our state actor and then finally get to creating
    an HTTP server in Hyper.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，到目前为止，逻辑并不太复杂。有了这个，我们将能够快速通过我们的状态演员，然后最终在Hyper中创建一个HTTP服务器。
- en: Building our state actor
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的状态演员
- en: 'When it comes to our state actor, we must send and receive messages. Our state
    actor will also have a state where the actor will store the chat logs to be referenced.
    With the state actor mechanisms in mind, it will not be surprising that we have
    the following imports in the `src/actors/state.rs` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到我们的状态演员时，我们必须发送和接收消息。我们的状态演员还将有一个状态，其中演员将存储要引用的聊天记录。考虑到状态演员的机制，我们不会对在`src/actors/state.rs`文件中以下导入感到惊讶：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only difference in the imports is the `mem` module. The `mem` module will
    enable us to allocate memory. We will cover how we use the `mem` module when we
    get the message from the state of the actor. We can also see that we have imported
    `HashMap` and `VecDeque` to handle the state of the actor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 导入中唯一的区别是`mem`模块。`mem`模块将使我们能够分配内存。当我们从演员的状态获取消息时，我们将介绍如何使用`mem`模块。我们还可以看到，我们导入了`HashMap`和`VecDeque`来处理演员的状态。
- en: 'Now that we have imported what we need, we can define our actor struct with
    the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所需的模块，我们可以使用以下代码定义我们的演员结构体：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `chat_queue` is where we perform a first-in-first-out queue using the `VecDeque`
    struct implementation from the standard collections library. We are assuming that
    the oldest chat logs will generally have more chats than later chat logs, and
    therefore, we should cache the older chats. The reason we are not merely using
    a vector as opposed to a queue is that popping off the first element of a queue
    does not require reallocating all the other elements. If we were to remove the
    first element of a vector, we would have to reallocate all the other elements
    in the vector. When it comes to storing the chat logs, we have the chat ID as
    the key and the question and answers under the chat ID.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`chat_queue`是我们使用标准集合库中的`VecDeque`结构体实现执行先进先出队列的地方。我们假设最老的聊天记录通常比后来的聊天记录包含更多的聊天内容，因此，我们应该缓存较老的聊天记录。我们之所以没有仅仅使用向量而不是队列，是因为从队列中弹出第一个元素不需要重新分配所有其他元素。如果我们从向量中移除第一个元素，我们就必须重新分配向量中的所有其他元素。当涉及到存储聊天记录时，我们使用聊天ID作为键，以及聊天ID下的问题和答案。'
- en: 'Now that we have defined our state actor, we can define the functions needed
    for our actor with the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的状态演员，我们可以定义演员所需的函数，以下代码展示了这些函数：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we can see that we have a constructor, an extraction of chat data, an
    insertion of a chat log, the handling of a message based on the type of message
    being received, and a `run` function to wait for incoming messages sent to the
    state actor.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们有一个构造函数、提取聊天数据、插入聊天记录、根据接收到的消息类型处理消息，以及一个`run`函数来等待发送到状态演员的传入消息。
- en: We are now ready to shoot through the logic implemented by the functions for
    the `StateActor` struct. At this stage of the book, you should be able to implement
    these functions by yourself, which will be good practice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好通过函数实现的`StateActor`结构体的逻辑。在本书的这个阶段，你应该能够自己实现这些函数，这将是一个很好的实践。
- en: 'For our constructor function, we have the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的构造函数，我们有以下代码：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The constructor is merely creating an empty queue and HashMap and accepts the
    channels that send and receive messages. For our `get_message` function, we have
    the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数仅仅创建一个空的队列和HashMap，并接受发送和接收消息的通道。对于我们的`get_message`函数，我们有以下代码：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see that we get the chat data based on the chat ID from the chat logs.
    We then transfer ownership from the HashMap chat logs to the `reference` variable,
    delete the chat ID key, and then return the data. This enables us to remove and
    return message data from our state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们根据聊天ID从聊天记录中获取聊天数据。然后，我们将HashMap聊天记录的所有权从`reference`变量中转移，删除聊天ID键，然后返回数据。这使得我们可以从我们的状态中删除并返回消息数据。
- en: 'For our `insert_message` function, we utilize the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`insert_message`函数，我们使用以下代码：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we can see that we merely insert the new message data into the vector associated
    with the chat ID. If the chat ID is not present, we attach the chat ID to the
    queue and create a new vector under the chat ID.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们仅仅将新的消息数据插入与聊天ID关联的向量中。如果聊天ID不存在，我们将聊天ID附加到队列中，并在聊天ID下创建一个新的向量。
- en: 'We can now move on to our function that handles the message with the following
    code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到处理消息的函数，以下是其代码：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, if the message is input, we merely insert the message into our state.
    If the message is empty, we panic the thread as there should not be any empty
    messages being sent to the state actor. If we have an output message, this means
    that we must get the oldest chats located down the bottom of the queue, which
    takes the following form:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果消息是输入，我们仅仅将消息插入到我们的状态中。如果消息为空，我们将使线程恐慌，因为不应该有任何空消息发送到状态演员。如果我们有一个输出消息，这意味着我们必须获取队列底部最老的聊天，其形式如下：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we can see that if there is nothing in the queue, then we have no chats;
    thus we return an empty message. If there is a chat ID in the queue, we get the
    message data and send that data via a message to the runner.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如果没有队列中的内容，那么我们就没有聊天；因此我们返回一个空消息。如果队列中有聊天ID，我们获取消息数据并通过消息发送给运行者。
- en: 'Finally, the `run` function takes the following form:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`run`函数的形式如下：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This `run` function merely waits for incoming messages and processes those incoming
    messages. We have now defined all our actors and can now move on to building our
    HTTP server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`run`函数仅仅等待接收到的消息并处理这些接收到的消息。我们现在已经定义了所有的演员，现在可以继续构建我们的HTTP服务器。
- en: Handling HTTP requests using Hyper
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hyper处理HTTP请求
- en: 'When it comes to building our HTTP server, we will implement all the server
    logic in the `src/main.rs` file. First, we import what we need with the following
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构建我们的HTTP服务器时，我们将把所有的服务器逻辑实现到`src/main.rs`文件中。首先，我们使用以下代码导入所需的模块：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this stage in the book, these imports should not be confusing to you. Even
    though we have imported from the `hyper` module, the imports are self-explanatory.
    We will extract data from a request, create a service to process our request,
    and create an HTTP server to listen to incoming requests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这个阶段，这些导入应该不会让你感到困惑。尽管我们从`hyper`模块中导入了，但导入是自解释的。我们将从请求中提取数据，创建一个服务来处理我们的请求，并创建一个HTTP服务器来监听传入的请求。
- en: 'We will also need to utilize the actors that we have created. Our actors can
    be imported using the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用我们创建的演员。我们可以使用以下代码导入我们的演员：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With all these actors imported, we can work towards accepting requests. Incoming
    HTTP requests insert new chat logs into our state actor. To achieve inserting
    the chat log, we will require a chat ID, inputs (a question), and an output (an
    answer). It would also be good to have a timestamp but to simplify the example,
    we will use a turn number to denote the time when the chat log was created. To
    extract all the data that we have just listed from the request, we will need the
    following struct:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 导入所有这些演员后，我们可以着手接受请求。传入的HTTP请求将新的聊天记录插入到我们的状态演员中。为了实现插入聊天记录，我们需要一个聊天ID、输入（一个问题）和输出（一个答案）。也最好有一个时间戳，但为了简化示例，我们将使用回合数来表示聊天记录创建的时间。为了从请求中提取我们刚刚列出的所有数据，我们需要以下结构体：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The approach we have taken in processing the body of an incoming request is
    the same as when we built servers with Rocket and Actix. This is because we are
    relying on `serde`. The fact that the implementation of processing a body of an
    incoming request is the same is a testament to the flexibility of implementing
    traits in Rust.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在处理传入请求正文时所采取的方法与使用 Rocket 和 Actix 构建服务器时相同。这是因为我们依赖于 `serde`。处理传入请求正文实现相同的事实是对在
    Rust 中实现特质的灵活性的证明。
- en: 'Seeing as we are accepting incoming requests, we must handle them. We can define
    the logic of how to handle a request in a function with the following outline:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在接受传入的请求，我们必须处理它们。我们可以在一个函数中定义如何处理请求的逻辑，以下是一个概要：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this `handle` function, we are accepting a request with a body and a channel
    where we can send our messages to our actors. If we were not applying the actor
    model approach, we could get away with merely accepting requests. We must remember
    that we handle our requests through a function, and therefore nothing stops us
    from passing in a database connection or anything else for that matter. Our `handle`
    function is essentially acting as middleware.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `handle` 函数中，我们接受一个带有正文和通道的请求，我们可以通过该通道向我们的演员发送消息。如果我们没有应用演员模型方法，我们只需接受请求即可。我们必须记住，我们通过一个函数来处理我们的请求，因此没有什么可以阻止我们传递数据库连接或其他任何东西。我们的
    `handle` 函数本质上充当着中间件的角色。
- en: 'For this example, we are just supporting one view. However, to get a feel for
    what we can do with Hyper, we might as well print out some basic information about
    the incoming request with the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们只支持一个视图。然而，为了了解我们可以用 Hyper 做什么，我们不妨使用以下代码打印出一些关于传入请求的基本信息：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we were to support multiple views, we could implement a `match` statement
    on the URI of the incoming request, passing the request into another function
    that housed multiple views for a particular theme, such as authentication or chat
    logging. Another `match` statement could then pass the request into the correct
    view function, which processes the request and returns an HTTP response, which
    the `handle` function would return.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要支持多个视图，我们可以在传入请求的 URI 上实现一个 `match` 语句，将请求传递给另一个函数，该函数包含特定主题（如身份验证或聊天记录）的多个视图。然后另一个
    `match` 语句可以将请求传递到正确的视图函数，该函数处理请求并返回 HTTP 响应，`handle` 函数将返回该响应。
- en: 'Again, because we are merely supporting one view, we will process the request
    directly in the `handle` function. We do this by extracting the body data from
    the request with the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，因为我们只支持一个视图，所以我们将直接在 `handle` 函数中处理请求。我们通过以下代码从请求中提取正文数据来完成这项工作：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now have all the data that we need to send a chat log to our state actor
    and return an HTTP response that everything is OK with the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了发送聊天记录到我们的状态演员并返回一切正常的 HTTP 响应所需的所有数据，以下是一个代码示例：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this our `handle` function is complete. Considering what we have done in
    this section, we can appreciate how low level Hyper is in terms of implementing
    HTTP. While we have printed out the URI and method, we have not done anything
    with it. It doesn’t matter what method or URI is passed into our server; if the
    body has the correct data, our server will work. So, let us get our server working
    in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们的 `handle` 函数就完成了。考虑到我们在本节中所做的工作，我们可以欣赏到 Hyper 在实现 HTTP 时的底层性。虽然我们已经打印出了
    URI 和方法，但我们并没有对它们做任何事情。无论传入服务器的是什么方法或 URI，只要正文有正确的数据，我们的服务器就会工作。因此，让我们在下一节中让我们的服务器工作起来。
- en: Building an HTTP server using Hyper
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hyper 构建 HTTP 服务器
- en: 'When it comes to running an HTTP server with Hyper, we will be using Tokio.
    We have two actors running and two channels to facilitate the communication between
    actors and requests. First, in the `main` function, we define the address of the
    server with the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用 Hyper 运行 HTTP 服务器时，我们将使用 Tokio。我们有两个演员正在运行，以及两个通道来促进演员和请求之间的通信。首先，在 `main`
    函数中，我们使用以下代码定义服务器的地址：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After the address is defined, we define the two channels for messages with
    the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 地址定义后，我们使用以下代码定义两个消息通道：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We clone the sender for the state actor because we will pass the sender through
    the `handle` function with the incoming request. Now that we have our channels,
    we can spin off two threads to run our actors with the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们克隆了状态演员的发送者，因为我们将通过 `handle` 函数将发送者与传入的请求一起传递。现在我们有了我们的通道，我们可以使用以下代码启动两个线程来运行我们的演员：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here we must be careful to pass the sender of the other actor into the actor
    we are creating as the actors send messages to each other; they are not sending
    messages to themselves.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须小心地将另一个 actor 的发送者传递给我们要创建的 actor，因为 actors 互相发送消息；它们不是给自己发送消息。
- en: 'Everything for our caching mechanism is now running. All we need now is to
    accept incoming HTTP requests, which we can achieve with the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缓存机制的 everything 现在都在运行。我们现在需要做的是接受传入的 HTTP 请求，我们可以通过以下代码实现：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It must be noted that we are returning a future with an async syntax, which
    is required for the `service_fn` function. Here we can see that we bind our address
    to the server and then call the `serve` function. Inside this `serve` function,
    we pass in the `make_service_fn` function, which wraps whatever executable we
    pass into the `make_service_fn` function in a `MakeServiceFn` struct. The executable
    we pass into the `make_service_fn` function is a closure that passes in `_conn`,
    which is an `AddrStream` struct. With the `AddrStream` struct, we can get the
    address of the peer making the connection to the server. We can also consume the
    `AddrStream` struct and extract the underlying TCP stream using the `into_inner`
    method of the `AddrStream` struct. We are not going to play with the `AddrStream`
    struct in this chapter, as we are keeping it simple by just processing standard
    HTTP requests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，我们正在返回一个使用异步语法的 future，这是 `service_fn` 函数所必需的。在这里，我们可以看到我们将我们的地址绑定到服务器，然后调用
    `serve` 函数。在这个 `serve` 函数内部，我们传递 `make_service_fn` 函数，它将我们传递给 `make_service_fn`
    函数的可执行程序包装在一个 `MakeServiceFn` 结构体中。我们传递给 `make_service_fn` 函数的可执行程序是一个闭包，它传递 `_conn`，这是一个
    `AddrStream` 结构体。使用 `AddrStream` 结构体，我们可以获取连接到服务器的对等方的地址。我们还可以消耗 `AddrStream`
    结构体，并使用 `AddrStream` 结构体的 `into_inner` 方法提取底层的 TCP 流。在本章中，我们不会与 `AddrStream` 结构体玩耍，因为我们通过仅处理标准
    HTTP 请求来保持简单。
- en: Inside the closure, we clone the sender again. We need to do this here because
    we need to clone the channel for every request coming in, as every request will
    need to send a message to the state actor. We then create a future with the `async`
    block returning an `Ok` enum, which wraps around the `service_fn` function, where
    we insert another closure that processes the incoming request. This is where we
    clone the channel again and return a future of our `handle` function that accepts
    the incoming request and channel to be processed and an HTTP response to be returned.
    We can see that it takes more steps to get an HTTP server running compared to
    other frameworks such as Rocket. However, we also get a lot of fine-grain control.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包内部，我们再次克隆发送者。我们需要在这里这样做，因为我们需要为每个进入的请求克隆通道，因为每个请求都需要向状态 actor 发送消息。然后我们使用
    `async` 块创建一个 future，返回一个 `Ok` 枚举，它围绕 `service_fn` 函数，其中我们插入另一个闭包来处理传入的请求。这就是我们再次克隆通道并返回一个
    future 的地方，我们的 `handle` 函数接受要处理的传入请求和通道以及要返回的 HTTP 响应。我们可以看到，与 Rocket 等其他框架相比，运行
    HTTP 服务器需要更多的步骤。然而，我们也获得了更多的细粒度控制。
- en: 'Now that our server block is complete, we can implement a last piece of logic
    in the `main` function, which prints out the error if there is a problem with
    the server by implementing the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了服务器块，我们可以在 `main` 函数中实现最后一段逻辑，通过以下代码打印出服务器的问题错误：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this, our simple HTTP server should work.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的简单 HTTP 服务器应该可以工作了。
- en: Running our Hyper HTTP server
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的 Hyper HTTP 服务器
- en: 'When we run our server, we first need to export the URL that we are going to
    send batched chat logs to with the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的服务器时，我们首先需要使用以下命令导出我们将要发送批量聊天日志的 URL：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This means that we just need to send our HTTP requests to an HTTPBin and get
    a standard response back. We can then run our server with the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们只需要将我们的 HTTP 请求发送到 HTTPBin，并得到一个标准的响应。然后我们可以使用以下命令运行我们的服务器：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our server is now running with the following printouts:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器现在正在以下打印输出中运行：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our intervals are every 30 seconds for the runner actor to send a message to
    the state actor. If we just leave our server running, we will get the following
    printout:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间间隔是每 30 秒，runner actor 向状态 actor 发送一条消息。如果我们只是让我们的服务器运行，我们会得到以下打印输出：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here we can see that the chat state and queue are empty and that both of our
    actors are running in their threads! We can then get our Postman application and
    send the following HTTP request:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到聊天状态和队列都是空的，并且我们的两个 actor 都在各自的线程中运行！然后我们可以获取我们的 Postman 应用程序，发送以下
    HTTP 请求：
- en: '![Figure 17.2 – HTTP request for our server](img/Figure_17.2_B18722.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图17.2 – 服务器HTTP请求](img/Figure_17.2_B18722.jpg)'
- en: Figure 17.2 – HTTP request for our server
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – 服务器HTTP请求
- en: 'Sending the previous request will give the following printout:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 发送之前的请求将给出以下输出：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here we can see that the state and queue have been populated. If we press the
    **Send** button in Postman another 2 times before the initial 30 seconds is up,
    we get the following printout:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到状态和队列已经被填充。如果我们再在最初的30秒内按下Postman的**发送**按钮两次，我们会得到以下输出：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can see that the queue is not increasing as we are sending the same chat
    ID. We then increase the ID of the chat log and send another request resulting
    in the following printout:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，随着我们发送相同的聊天ID，队列并没有增加。然后我们增加聊天日志的ID，发送另一个请求，结果如下输出：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can see that the new ID has been inserted into the queue and state. We have
    managed to make all these requests before the 30 seconds is up, then we can simply
    wait until we get the following printout:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到新的ID已经被插入到队列和状态中。我们设法在30秒内完成了所有这些请求，然后我们可以简单地等待，直到我们得到以下输出：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What has happened here is that the runner has sent a message to the state getting
    the oldest chat ID and then sent it to the server we defined in our environment
    variables. We can see that the state has been updated, and the response is OK.
    Some of the HTTP response has been omitted to avoid printout bloat on the page.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里发生的情况是，跑步者向获取最老聊天ID的状态发送了一条消息，然后将其发送到我们在环境变量中定义的服务器。我们可以看到状态已经更新，响应是OK。为了防止页面打印输出膨胀，省略了一些HTTP响应。
- en: We can conclude that our caching system built with actors on Hyper HTTP is working
    as we expected! With this, we have come to the end of this chapter, exploring
    enough about Hyper to get a server up and running with async actors and channels.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，我们使用Hyper HTTP上的actor构建的缓存系统正如我们所期望的那样工作！有了这个，我们就结束了本章，对Hyper进行了足够的探索，以使用异步actor和通道启动服务器。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a network application that cached chat logs. Our network
    application also has a background task continuously running to periodically clean
    up the cache by sending the cached data to a server. We broke down and created
    our background task runner into an actor system with a queue and then implemented
    it. This gives you a whole new toolset to solve problems with. Background running
    actors are not just for running on a server for caching. You can run background
    runner actors for normal programs too if you build your program on a Tokio runtime.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个缓存聊天记录的网络应用程序。我们的网络应用程序还有一个后台任务持续运行，定期通过将缓存数据发送到服务器来清理缓存。我们将后台任务运行器分解为一个具有队列的actor系统，然后实现了它。这为您提供了一个全新的工具集来解决这些问题。后台运行的actor不仅适用于在服务器上运行以进行缓存。如果您在Tokio运行时上构建程序，您也可以为常规程序运行后台运行actor。
- en: In the next chapter, we will use Redis persistent storage to manage multiple
    workers and network applications to transfer messages across multiple network
    applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Redis持久存储来管理多个工作进程和网络应用程序，以在多个网络应用程序之间传输消息。
- en: Further reading
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Hyper documentation: [https://hyper.rs/guides](https://hyper.rs/guides)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 超级文档：[https://hyper.rs/guides](https://hyper.rs/guides)
