- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Handling HTTP Requests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求
- en: So far, we have structured our to-do module in a flexible, scalable, and reusable
    manner. However, this can only get us so far in terms of web programming. We want
    our to-do module to reach multiple people quickly without the user having to install
    Rust on their own computers. We can do this with a web framework. Rust has plenty
    to offer. Initially, we will build our main server in the **Actix Web** framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经以灵活、可扩展和可重用的方式构建了待办事项模块。然而，在网页编程方面，这只能带我们走这么远。我们希望待办事项模块能够快速地触达多人，而无需用户在自己的电脑上安装
    Rust。我们可以通过一个网络框架来实现这一点。Rust 有很多可以提供的。最初，我们将使用 **Actix Web** 框架构建我们的主要服务器。
- en: To achieve this, we will be building the views of the server in a modular fashion;
    we can slot our to-do module into our web application with minimal effort. It
    must be noted that the Actix Web framework defines views using `async` functions.
    Because of this, we will also cover asynchronous programming to get a better understanding
    of how the Actix Web framework works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将以模块化的方式构建服务器的视图；我们可以轻松地将待办事项模块插入到我们的网络应用程序中。必须注意的是，Actix Web 框架使用
    `async` 函数来定义视图。正因为如此，我们还将介绍异步编程，以便更好地理解 Actix Web 框架的工作原理。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the Actix Web framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Actix Web 框架
- en: Launching a basic Actix Web server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动基本的 Actix Web 服务器
- en: Understanding closures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解闭包
- en: Understanding asynchronous programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解异步编程
- en: Understanding `async` and `await` with web programming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络编程理解 `async` 和 `await`
- en: Managing views using the Actix Web framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Actix Web 框架管理视图
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As we move toward building web apps in Rust, we are going to have to start
    relying on third-party packages to do some of the heavy lifting for us. Rust manages
    dependencies through a package manager called **Cargo**. To use Cargo, we are
    going to have to install Rust on our computer from the following URL: [https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们转向使用 Rust 构建网络应用，我们将不得不开始依赖第三方包来为我们做一些繁重的工作。Rust 通过一个名为 **Cargo** 的包管理器来管理依赖项。要使用
    Cargo，我们不得不从以下网址安装 Rust 到我们的电脑上：[https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install)。
- en: This installation delivers the Rust programming language and Cargo. You can
    find all the code files on GitHub at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此安装提供了 Rust 编程语言和 Cargo。你可以在 GitHub 上找到所有代码文件，网址为 [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03)。
- en: Introducing the Actix Web framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Actix Web 框架
- en: At the time of writing, Actix Web is the most popular Rust web framework as
    can be seen from the activity on the GitHub page. You might be tempted to jump
    into another framework that looks more ergonomic, such as Rocket, or one that
    is faster and more lightweight, such as Hyper. We will be covering these frameworks
    later in this book over various different chapters; however, we must remember
    that we are trying to get our heads around web programming in Rust first. Considering
    that we are new to Rust and web programming, Actix Web is a great start. It is
    not too low-level that we will get caught up with just trying to get a server
    to handle a range of views, database connections, and authentication. It is also
    popular, stable, and has a lot of documentation. This will facilitate a pleasant
    programming experience when trying to go beyond the book and develop your own
    web application. It is advised that you get comfortable with Actix Web before
    moving on to other web frameworks. This is not to say that Actix Web is the best
    and that all other frameworks are terrible; it is just to facilitate a smooth
    learning and development experience. With this in mind, we can now move on to
    the first section, where we set up a basic web server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Actix Web 是 GitHub 页面上活动最频繁的 Rust 网络框架，如我们所见。你可能会想跳入另一个看起来更直观的框架，比如 Rocket，或者一个更快更轻量级的框架，比如
    Hyper。我们将在本书的后续章节中覆盖这些框架；然而，我们必须记住，我们首先试图在 Rust 和网络编程中弄清楚我们的思路。考虑到我们是 Rust 和网络编程的新手，Actix
    Web 是一个很好的起点。它不是太底层，以至于我们只会陷入仅仅尝试让服务器处理一系列视图、数据库连接和认证。它也很受欢迎、稳定，并且有大量的文档。这将有助于在尝试超越本书并开发自己的网络应用程序时获得愉快的编程体验。建议你在转向其他网络框架之前先熟悉
    Actix Web。这并不是说 Actix Web 是最好的，而其他所有框架都很糟糕；这只是为了方便一个平稳的学习和开发体验。考虑到这一点，我们现在可以继续到第一部分，在那里我们设置了一个基本的网络服务器。
- en: Launching a basic Actix Web server
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动一个基本的 Actix Web 服务器
- en: 'Building with Cargo is straightforward. All we need to do is navigate to a
    directory where we want to build our project and run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cargo 构建很简单。我们只需要导航到我们想要构建项目的目录，并运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command builds a basic Cargo Rust project. When we explore this
    application, we get the following structure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令构建了一个基本的 Cargo Rust 项目。当我们探索这个应用程序时，我们得到以下结构：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now define our Actix Web dependency in our `Cargo.toml` file with the
    following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `Cargo.toml` 文件中使用以下代码定义我们的 Actix Web 依赖项：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As a result of the preceding code, we can now move on to building the web application.
    For now, we will put it all in our `src/main.rs` file with the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的代码，我们现在可以继续构建网络应用程序。现在，我们将所有内容都放在我们的 `src/main.rs` 文件中，以下代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we can see that we import the required structs and traits
    from the `actix_web` crate. We can see that we have used several different ways
    to define a view. We defined a view by building a function. This takes in an `HttpRequest`
    struct. It then gets `name` from the request and then returns a variable that
    can implement the `Responder` trait from the `actix_web` crate. The `Responder`
    trait converts our type into an HTTP response. We assign this `greet` function
    that we have created for our application server as the route view, with the `.route("/",
    web::get().to(greet))` command. We can also see that we can pass in the name from
    the URL to our `greet` function with the `.route("/{name}", web::get().to(greet))`
    command. Finally, we pass a closure into the final route. With our configuration,
    let’s run the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们导入了来自 `actix_web` crate 所需的结构体和特性。我们可以看到我们使用了多种不同的方式来定义一个视图。我们通过构建一个函数来定义一个视图。这个函数接收一个
    `HttpRequest` 结构体。然后从请求中获取 `name`，然后返回一个可以实现来自 `actix_web` crate 的 `Responder`
    特性的变量。`Responder` 特性将我们的类型转换为 HTTP 响应。我们将我们为应用程序服务器创建的 `greet` 函数分配为路由视图，使用 `.route("/",
    web::get().to(greet))` 命令。我们还可以看到，我们可以使用 `.route("/{name}", web::get().to(greet))`
    命令将 URL 中的名称传递给我们的 `greet` 函数。最后，我们将闭包传递给最终的路线。根据我们的配置，让我们运行以下命令：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will get the following printout:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下打印输出：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see in the preceding output that, right now, there is no logging. This
    is expected, and we will configure logging later. Now that our server is running,
    for each of the following URL inputs, we should expect the corresponding outputs
    in the browser:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到，目前还没有日志记录。这是预期的，我们将在稍后配置日志。现在我们的服务器正在运行，对于以下每个 URL 输入，我们应该在浏览器中期望得到相应的输出：
- en: '`http://127.0.0.1:8080/`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8080/`'
- en: '`Hello World!`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hello World!`'
- en: '`http://127.0.0.1:8080/maxwell`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8080/maxwell`'
- en: '`Hello maxwell!`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hello maxwell!`'
- en: '`http://127.0.0.1:8080/say/hello`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8080/say/hello`'
- en: '`Hello Again!`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hello Again!`'
- en: In the preceding code in the `src/main.rs` file, we can see that there is some
    new syntax that we have not come across before. We have decorated our `main` function
    with the `#[actix_web::main]` macro. This marks our `async` `main` function as
    the Actix Web system entry point. With this, we can see that our functions are
    `async` and that we are using closures to build our server. We will go through
    both concepts in the next couple of sections. In the next section, we will investigate
    closures to truly understand what is happening.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main.rs`文件中的前面代码中，我们可以看到一些我们之前没有遇到的新语法。我们用`#[actix_web::main]`宏装饰了`main`函数。这标志着我们的`async`
    `main`函数是Actix Web系统的入口点。有了这个，我们可以看到我们的函数是`async`的，我们正在使用闭包来构建我们的服务器。在接下来的几个部分中，我们将探讨这两个概念。在下一个部分中，我们将调查闭包，以真正理解正在发生的事情。
- en: Understanding closures
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解闭包
- en: 'Closures are, essentially, functions, but they are also anonymous, meaning
    that they do not have names. This means that closures can be passed around into
    functions and structs. However, before we delve into passing closures around,
    let us explore closures by defining a basic closure in a blank Rust program (you
    can use the Rust playground if you prefer) with the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包本质上来说是函数，但它们也是匿名的，这意味着它们没有名字。这意味着闭包可以被传递到函数和结构体中。然而，在我们深入探讨传递闭包之前，让我们通过在空白Rust程序（如果你更喜欢，可以使用Rust
    playground）中定义一个基本的闭包来探索闭包，以下代码：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running the preceding code will give us the following printout:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将给出以下输出：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding output, we can see that our closure behaves like a function.
    However, instead of using curly brackets to define the inputs, we use pipes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到我们的闭包表现得像函数一样。然而，我们使用管道而不是花括号来定义输入，而不是使用花括号。
- en: 'You might have noticed in the preceding closure that we have not defined the
    data type for the `string_input` parameter; however, the code still runs. This
    is different from a function that needs to have the parameter data types defined.
    This is because functions are part of an explicit interface that is exposed to
    users. A function could be called anywhere in the code if the code can access
    the function. Closures, on the other hand, have a short lifetime and are only
    relevant to the scope that they are in. Because of this, the compiler can infer
    the type being passed into the closure from the use of the closure in the scope.
    Because we are passing in `&str` when we call the closure, the compiler knows
    that the `string_input` type is `&str`. While this is convenient, we need to know
    that closures are not generic. This means that a closure has a concrete type.
    For instance, after defining our closure, let’s try and run the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在前面的闭包中，我们没有为`string_input`参数定义数据类型；然而，代码仍然可以运行。这与需要定义参数数据类型的函数不同。这是因为函数是暴露给用户的显式接口的一部分。如果代码可以访问函数，函数可以在代码的任何地方被调用。另一方面，闭包具有短暂的生存期，并且只与其所在的作用域相关。正因为如此，编译器可以从作用域中闭包的使用推断出传递给闭包的类型。因为我们调用闭包时传递了`&str`，编译器知道`string_input`的类型是`&str`。虽然这很方便，但我们需要知道闭包不是泛型的。这意味着闭包有一个具体类型。例如，在定义我们的闭包之后，让我们尝试运行以下代码：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will get the following error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下错误：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The error occurs because the first call to our closure tells the compiler that
    we are expecting `&str`, so the second call breaks the compilation process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为我们对闭包的第一个调用告诉编译器我们期望`&str`，所以第二个调用打破了编译过程。
- en: 'Scopes do not just affect closures. Closures adhere to the same scope rules
    that variables do. For instance, let’s say we were going to try and run the following
    code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域不仅影响闭包。闭包遵循与变量相同的范围规则。例如，假设我们打算尝试运行以下代码：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It would refuse to compile because when we try and call the closure, it is not
    in the scope of the call. Considering this, you would be right to assume that
    other scope rules apply to closures. For instance, if we tried to run the following
    code, what do you think would happen?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它将拒绝编译，因为当我们尝试调用闭包时，它不在调用的作用域内。考虑到这一点，你可能会正确地假设其他作用域规则也适用于闭包。例如，如果我们尝试运行以下代码，你认为会发生什么？
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you thought that we would get the following output, you would be right:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为我们会得到以下输出，你是正确的：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unlike functions, closures can access variables in their own scope. So, to try
    and describe closures in a simplistic way that we can understand, they are kind
    of like dynamic variables in a scope that we call to perform a computation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数不同，闭包可以访问它们自己的作用域中的变量。所以，为了以我们能够理解的方式简单描述闭包，它们有点像我们在作用域中调用以执行计算的动态变量。
- en: 'We can take ownership of the outside variables used in the closure by utilizing
    `move`, as seen with the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`move`来获取闭包中使用的外部变量的所有权，就像以下代码所示：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because `move` is utilized in the closure defined here, the `another_str` variable
    cannot be used after `test_closure` is declared because `test_closure` took ownership
    of `another_str`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在此处定义的闭包中使用了`move`，因此`another_str`变量在`test_closure`声明后不能使用，因为`test_closure`获取了`another_str`的所有权。
- en: 'We can also pass closures into a function; however, it must be noted that we
    can also pass functions into other functions. We can achieve passing functions
    into other functions with the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将闭包传递给函数；然而，必须注意的是，我们也可以将函数传递给其他函数。我们可以通过以下代码实现将函数传递给其他函数：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we can see that we define a closure that doubles an
    integer that is passed in and returned. We then pass this into our `add_doubles`
    function with the notation of `fn(i32)-> i32`, which is known as a function pointer.
    When it comes to closures, we can implement one of the following traits:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们定义了一个闭包，该闭包接受一个整数并将其加倍，然后我们将其传递给`add_doubles`函数，使用`fn(i32)->
    i32`的表示法，这被称为函数指针。当涉及到闭包时，我们可以实现以下特质之一：
- en: '`Fn`: Immutably borrows variables'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn`：不可变借用变量'
- en: '`FnMut`: Mutably borrows variables'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FnMut`：可变借用变量'
- en: '`FnOnce`: Takes ownership of variables so it can only be called once'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FnOnce`：获取变量的所有权，因此只能调用一次'
- en: 'We can pass a closure that has one of the preceding traits implemented into
    our `add_doubles` function with the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将实现了前面特质的闭包传递给我们的`add_doubles`函数，如下所示：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we can see that the `closure` function parameter has the `Box<dyn Fn(i32)
    -> i32>` signature. This means that the `add_doubles` function is accepting closures
    that have implemented the `Fn` trait that accepted `i32`, and returned `i32`.
    The `Box` struct is a smart pointer where we have put the closure on the heap
    because we do not know the closure’s size at compile time. You can also see that
    we have utilized `move` when defining the closure. This is because we are using
    the `one` variable, which is outside the closure. The `one` variable may not live
    long enough; therefore, the closure takes ownership of it because we used `move`
    when defining the closure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`closure`函数参数具有`Box<dyn Fn(i32) -> i32>`签名。这意味着`add_doubles`函数正在接受实现了`Fn`特质且接受`i32`作为输入并返回`i32`的闭包。`Box`结构体是一个智能指针，我们将闭包放在堆上，因为我们不知道闭包的大小在编译时。您还可以看到我们在定义闭包时使用了`move`。这是因为我们正在使用`one`变量，它位于闭包外部。`one`变量可能存活时间不够长；因此，闭包通过我们在定义闭包时使用`move`来获取其所有权。
- en: 'With what we have covered about closures in mind, we can have another look
    at the `main` function in our server application with the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们已经讨论过的闭包，我们可以再次查看我们的服务器应用程序中的`main`函数，如下所示：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we can see that we are running our `HttpServer` after
    constructing it using the `HttpServer::new` function. Knowing what we know now,
    we can see that we have passed in a closure that returns the `App` struct. Based
    on what we know about closures, we can be more confident with what we do with
    this code. We can essentially do what we like within the closure if it returns
    the `App` struct. With this in mind, we can get some more information about the
    process with the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们在使用`HttpServer::new`函数构建`HttpServer`之后运行它。考虑到我们现在所知道的内容，我们可以看到我们传递了一个返回`App`结构的闭包。基于我们对闭包的了解，我们可以对我们所做的事情更有信心。如果我们返回`App`结构，我们基本上可以在闭包内做我们想做的事情。有了这个想法，我们可以通过以下代码获取更多关于此过程的信息：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we can see that we have added a `print` statement to
    tell us that the closure is firing. We also added another function called `workers`.
    This means we can define how many workers are being used to create our server.
    We also print out that the server factory is firing in our closure. Running the
    preceding code gives us the following printout:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们添加了一个`print`语句来告诉我们闭包正在触发。我们还添加了另一个名为`workers`的函数。这意味着我们可以定义用于创建我们的服务器的工作者数量。我们还打印出服务器工厂在我们的闭包中正在触发。运行前面的代码会给我们以下输出：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding result tells us that the closure was fired three times. Altering
    the number of workers shows us that there is a direct relationship between this
    and the number of times the closure is fired. If the `workers` function is left
    out, then the closure is fired in relation to the number of cores your system
    has. We will explore how these workers fit into the server process in the next
    section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结果告诉我们闭包被触发了三次。改变工作者的数量显示，这与闭包被触发的次数有直接关系。如果省略`workers`函数，那么闭包的触发将与系统核心的数量成比例。我们将在下一节中探讨这些工作者如何适应服务器进程。
- en: Now that we understand the nuances around the building of the `App` struct,
    it is time to look at the main change in the structure of a program, asynchronous
    programming.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了构建`App`结构体周围的细微差别，是时候看看程序结构的主要变化了，那就是异步编程。
- en: Understanding asynchronous programming
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异步编程
- en: Up until this chapter, we have been writing code in a sequential manner. This
    is good enough for standard scripts. However, in web development, asynchronous
    programming is important, as there are multiple requests to servers, and API calls
    introduce idle time. In some other languages, such as Python, we can build web
    servers without touching any asynchronous concepts. While asynchronous concepts
    are utilized in these web frameworks, the implementation is defined under the
    hood. This is also true for the Rust framework Rocket. However, as we have seen,
    it is directly implemented in Actix Web.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直以顺序方式编写代码。这对于标准脚本来说已经足够好了。然而，在Web开发中，异步编程很重要，因为服务器有多个请求，API调用引入了空闲时间。在其他一些语言中，如Python，我们可以构建Web服务器而不需要接触任何异步概念。虽然在这些Web框架中使用了异步概念，但实现是在幕后定义的。这对于Rust框架Rocket也是正确的。然而，正如我们所看到的，它直接在Actix
    Web中实现。
- en: 'When it comes to utilizing asynchronous code, there are two main concepts we
    must understand:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到利用异步代码时，有两个主要概念我们必须理解：
- en: '**Processes**: A process is a program that is being executed. It has its own
    memory stack, registers for variables, and code.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程**：进程是一个正在执行的程序。它有自己的内存栈、变量的寄存器和代码。'
- en: '`main` program. However, threads do not share the stack.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`程序。然而，线程不共享栈。'
- en: 'This is demonstrated in the following classic diagram:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下经典图中得到了体现：
- en: '![Figure 3.1 – Relationship between threads and processes [source: Cburnett
    (2007) (https://commons.wikimedia.org/wiki/File:Multithreaded_process.svg), CC
    BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0/deed.en)]](img/Figure_3.1_B18722.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 线程和进程之间的关系 [来源：Cburnett (2007) (https://commons.wikimedia.org/wiki/File:Multithreaded_process.svg)，CC
    BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0/deed.en)]](img/Figure_3.1_B18722.jpg)'
- en: 'Figure 3.1 – Relationship between threads and processes [source: Cburnett (2007)
    (https://commons.wikimedia.org/wiki/File:Multithreaded_process.svg), CC BY-SA
    3.0 (https://creativecommons.org/licenses/by-sa/3.0/deed.en)]'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 线程和进程之间的关系 [来源：Cburnett (2007) (https://commons.wikimedia.org/wiki/File:Multithreaded_process.svg)，CC
    BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0/deed.en)]
- en: 'Now that we understand what threads are and what relation they have to our
    code on a high-level basis, we can play with a toy example to understand how to
    utilize threads in our code and see the effects of these threads firsthand. A
    classic example is to build a basic function that merely sleeps, blocking time.
    This can simulate a time-expensive function such as a network request. We can
    run it sequentially with the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从高层次上理解了线程是什么以及它们与我们的代码有什么关系，我们可以通过一个玩具示例来了解如何在代码中利用线程，并亲眼看到这些线程的效果。一个经典的例子是构建一个简单的函数，它只是休眠，阻止时间流逝。这可以模拟一个耗时的函数，如网络请求。我们可以用以下代码按顺序运行它：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Running the preceding code will give us the following printout:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会给我们以下输出：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding output, we can see that our time-expensive functions run in
    the order that we expect them to. It also takes just over 6 seconds to run the
    entire program, which makes sense since we are running three expensive functions
    that sleep at 2 seconds each. Our expensive function also returns the value `2`.
    When we add the results of all three expensive functions together, we are going
    to get a result of  the value `6`, which is what we have. We speed up our program
    to roughly 2 seconds for the entire program, by spinning up three threads at the
    same time and waiting for them to complete before moving on. Waiting for the threads
    to complete before moving on is called *joining*. So, before we start spinning
    off threads, we must import the `join` handler with the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到我们的耗时函数按照我们预期的顺序运行。整个程序运行也正好超过6秒，这是有道理的，因为我们正在运行三个耗时的函数，每个函数休眠2秒。我们的耗时函数还返回值`2`。当我们把所有三个耗时函数的结果相加时，我们将得到一个值为`6`的结果，这正是我们所得到的。我们通过同时启动三个线程并将它们完成后再继续，将整个程序的速度加快到大约2秒。在继续之前等待线程完成的过程称为*连接*。因此，在我们开始启动线程之前，我们必须使用以下代码导入`join`处理程序：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now spin up threads in our `main` function with the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`main`函数中使用以下代码启动线程：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running the preceding code gives us the following printout:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码给出了以下输出：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, the whole process took just over 2 seconds to run. This is because
    all three threads are running concurrently. Note also that thread three is fired
    before thread two. Do not worry if you get a sequence of `1`, `2`, and `3`. Threads
    finish in an indeterminate order. The scheduling is deterministic; however, there
    are thousands of events happening under the hood that require the CPU to do something.
    As a result, the exact time slices that each thread gets are never the same. These
    tiny changes add up. Because of this, we cannot guarantee that the threads will
    finish in a determinate order.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，整个过程运行时间正好超过2秒。这是因为所有三个线程都是并发运行的。注意，线程三在线程二之前启动。如果你得到`1`、`2`和`3`的序列，请不要担心。线程的完成顺序是不确定的。调度是确定的；然而，在底层有成千上万个事件需要CPU进行处理。因此，每个线程得到的精确时间片永远不会相同。这些微小的变化会累积起来。正因为如此，我们无法保证线程将以确定的顺序完成。
- en: Looking back at how we spin off threads, we can see that we pass a closure into
    our thread. If we try and just pass the `do_something` function through the thread,
    we get an error complaining that the compiler expected an `FnOnce<()>` closure
    and found `i8` instead. This is because a standard closure implements the `FnOnce<()>`
    public trait, whereas our `do_something` function simply returns `i8`. When `FnOnce<()>`
    is implemented, the closure can only be called once. This means that when we create
    a thread, we can ensure that the closure can only be called once, and then when
    it returns, the thread ends. As our `do_something` function is the final line
    of the closure, `i8` is returned. However, it has to be noted that just because
    the `FnOnce<()>` trait is implemented, it does not mean that we cannot call it
    multiple times. This trait only gets called if the context requires it. This means
    that if we were to call the closure outside of the thread context, we could call
    it multiple times.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们启动线程的方式，我们可以看到我们向线程传递了一个闭包。如果我们尝试只通过线程传递`do_something`函数，我们会得到一个错误，抱怨编译器期望一个`FnOnce<()>`闭包，而找到的是`i8`。这是因为标准闭包实现了`FnOnce<()>`公共特质，而我们的`do_something`函数只是简单地返回`i8`。当`FnOnce<()>`被实现时，闭包只能被调用一次。这意味着当我们创建一个线程时，我们可以确保闭包只能被调用一次，然后当它返回时，线程结束。由于我们的`do_something`函数是闭包的最后一行，所以返回`i8`。然而，必须注意的是，尽管实现了`FnOnce<()>`特质，并不意味着我们不能多次调用它。这个特质只有在上下文需要时才会被调用。这意味着如果我们要在线程上下文之外调用闭包，我们可以多次调用它。
- en: 'Note also that we directly unwrap our results. From what we know, we can deduce
    that the `join` function on the `JoinHandle` struct returns `Result`, which we
    also know can be `Err` or `Ok`. We know it is going to be okay to unwrap the result
    directly because we are merely sleeping and then returning an integer. We also
    printed out the results, which were indeed integers. However, our error is not
    what you would expect. The full `Result` type we get is `Result<i8, Box<dyn Any
    + Send>>`. We already know what `Box` is; however, `dyn Any + Send` seems new.
    `dyn` is a keyword that we use to indicate what type of trait is being used. `Any`
    and `Send` are two traits that must be implemented. The `Any` trait is for dynamic
    typing, meaning that the data type can be anything. The `Send` trait means that
    it is safe to be moved from one thread to another. The  `Send` trait also means
    that it is safe to copy from one thread to another. So, what we are sending has
    implemented the `Copy` trait as what we are sending can be sent between threads.
    Now that we understand this, we can handle the results of the threads by merely
    matching the `Result` outcome, and then downcasting the error into a string to
    get the error message with the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们直接解包了我们的结果。根据我们所知，我们可以推断出 `JoinHandle` 结构体上的 `join` 函数返回 `Result`，我们也知道它可以返回
    `Err` 或 `Ok`。我们知道直接解包结果是安全的，因为我们只是在睡眠然后返回一个整数。我们还打印出了结果，这些结果确实是整数。然而，我们的错误并不是你所期望的。我们得到的完整
    `Result` 类型是 `Result<i8, Box<dyn Any + Send>>`。我们已经知道 `Box` 是什么；然而，`dyn Any +
    Send` 看起来很新。`dyn` 是一个关键字，我们用它来指示正在使用的特质的类型。`Any` 和 `Send` 是必须实现的两个特质。`Any` 特质用于动态类型，意味着数据类型可以是任何类型。`Send`
    特质意味着它可以从一个线程安全地移动到另一个线程。`Send` 特质还意味着它可以从一个线程安全地复制到另一个线程。所以，我们要发送的内容已经实现了 `Copy`
    特质，因为我们发送的内容可以在线程之间传递。现在我们理解了这一点，我们只需通过匹配 `Result` 的结果来处理线程的结果，然后将错误向下转换为字符串以获取错误信息，以下代码展示了如何操作：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code enables us to manage the results of threads gracefully. Now,
    there is nothing stopping you from logging failures of threads or spinning up
    new threads based on the outcomes of previous threads. Thus, we can see how powerful
    the `Result` struct is. There is more we can do with threads, such as give them
    names or pass data between them with channels. However, the focus of this book
    is web programming, not advanced concurrency design patterns and concepts. However,
    further reading on the subject is provided at the end of the chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使我们能够优雅地管理线程的结果。现在，没有任何阻止你记录线程失败或根据先前线程的结果启动新线程的事情。因此，我们可以看到 `Result` 结构体是多么强大。我们还可以对线程做更多的事情，例如给它们命名或通过通道在它们之间传递数据。然而，本书的重点是网络编程，而不是高级并发设计模式和概念。不过，本章末尾提供了关于该主题的进一步阅读材料。
- en: We now understand how to spin up threads in Rust, what they return, and how
    to handle them. With this information, we can move on to the next section about
    understanding the `async` and `await` syntax, as this is what will be used in
    our Actix Web server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在 Rust 中启动线程，它们返回什么，以及如何处理它们。有了这些信息，我们可以继续下一节，了解 `async` 和 `await`
    语法，因为这是我们将在我们的 Actix Web 服务器中使用的内容。
- en: Understanding async and await
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `async` 和 `await`
- en: The `async` and `await` syntax manages the same concepts covered in the previous
    section; however, there are some nuances. Instead of simply spawning off threads,
    we create **futures** and then manipulate them as and when needed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 语法管理了上一节中涵盖的相同概念；然而，也有一些细微差别。我们不是简单地生成线程，而是创建**未来**对象，并在需要时对其进行操作。'
- en: In computer science, a future is an unprocessed computation. This is where the
    result is not yet available, but when we call or wait, the future will be populated
    with the result of the computation. Another way of describing this is that a future
    is a way of expressing a value that is not yet ready. As a result, a future is
    not exactly a thread. In fact, threads can use futures to maximize their potential.
    For instance, let us say that we have several network connections. We could have
    an individual thread for each network connection. This is better than sequentially
    processing all connections, as a slow network connection would prevent other faster
    connections from being processed down the line until it itself is processed, resulting
    in a slower processing time overall. However, spinning up threads for every network
    connection is not free. Instead, we can have a future for each network connection.
    These network connections can be processed by a thread from a thread pool when
    the future is ready. Therefore, we can see why futures are used in web programming,
    as there are a lot of concurrent connections.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，期货是一个未处理的计算。这意味着结果尚未可用，但当我们调用或等待时，期货将被计算的结果填充。另一种描述方式是，期货是一种表达尚未准备好的值的方式。因此，期货并不完全等同于线程。实际上，线程可以使用期货来最大化其潜力。例如，假设我们有几个网络连接。我们可以为每个网络连接分配一个单独的线程。这比顺序处理所有连接要好，因为慢速网络连接会阻止其他更快连接的处理，直到它本身被处理，从而导致整体处理时间变慢。然而，为每个网络连接启动线程并不是免费的。相反，我们可以为每个网络连接创建一个期货。这些网络连接可以在期货准备好时由线程池中的线程进行处理。因此，我们可以看到为什么期货在Web编程中被使用，因为存在大量的并发连接。
- en: 'Futures can also be referred to as *promises*, *delays*, or *deferred*. To
    explore futures, we will create a new Cargo project and utilize the futures created
    in the `Cargo.toml` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 期货也可以被称为*承诺*、*延迟*或*延期*。为了探索期货，我们将创建一个新的Cargo项目并利用在`Cargo.toml`文件中创建的期货：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the preceding crate installed, we can import what we need in our `main.rs`
    using the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了前面的crate之后，我们可以在`main.rs`中使用以下代码导入所需的模块：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can define futures by merely using the `async` syntax. The `block_on` function
    will block the program until the future we defined has been executed. We can now
    define the `do_something` function with the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过仅使用`async`语法来定义期货。`block_on`函数将阻塞程序，直到我们定义的期货被执行。现在我们可以使用以下代码定义`do_something`函数：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `do_something` function essentially does what the code says it does, which
    is print out what number it is, sleep for 2 seconds, and then return an integer.
    However, if we were to directly call it, we would not get `i8`. Instead, calling
    the `do_something` function directly will give us `Future<Output = i8>`. We can
    run our future and time it in the main function with the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_something`函数基本上做的是代码所说的，即打印出它是哪个数字，休眠2秒，然后返回一个整数。然而，如果我们直接调用它，我们将不会得到`i8`。相反，直接调用`do_something`函数将给我们`Future<Output
    = i8>`。我们可以在主函数中运行我们的期货并对其进行计时，以下代码：'
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the preceding code will give us the following printout:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将给出以下输出：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is what is expected. However, let’s see what happens if we enter an extra
    `sleep` function before we call the `block_on` function with the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的结果。然而，让我们看看如果我们调用`block_on`函数之前输入一个额外的`sleep`函数会发生什么：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will get the following printout:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Thus, we can see that our future does not execute until we apply an executor
    using the `block_on` function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到我们的期货只有在应用了`block_on`函数并使用它来执行后才会执行。
- en: 'This can be a bit laborious, as we may just want a future that we can execute
    later in the same function. We can do this with the `async`/`await` syntax. For
    instance, we can call the `do_something` function and block the code until it
    is finished using the `await` syntax inside the `main` function, with the following
    code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点费时，因为我们可能只想在同一个函数中稍后执行一个期货。我们可以使用`async`/`await`语法来实现这一点。例如，我们可以在`main`函数中使用`await`语法调用`do_something`函数并阻塞代码，直到它完成，以下代码：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What the `async` block does is return a future. Inside this block, we call the
    `do_something` function blocking the `async` block until the `do_something` function
    is resolved, by using the `await` expression. We then apply the `block_on` function
    on the `future_two` future.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`块所做的就是返回一个期货。在这个块内部，我们调用`do_something`函数，通过使用`await`表达式阻塞`async`块，直到`do_something`函数解决。然后我们对`future_two`期货应用`block_on`函数。'
- en: 'Looking at our preceding code block, this might seem a little excessive, as
    it can be done with just two lines of code that call the `do_something` function
    and pass it to the `block_on` function. In this case, it is excessive, but it
    can give us more flexibility on how we call futures. For instance, we can call
    the `do_something` function twice and add them together as a return with the following
    code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们前面的代码块，这可能会显得有些过度，因为它可以用调用`do_something`函数并将其传递给`block_on`函数的两行代码来完成。在这种情况下，它是过度的，但它可以给我们更多的灵活性来调用未来。例如，我们可以调用`do_something`函数两次，并将它们作为返回值相加，如下所示：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Adding the preceding code to our `main` function will give us the following
    printout:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码添加到我们的`main`函数中，将给出以下输出：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Whilst the preceding output is the result that we are expecting, we know that
    these futures will run sequentially and that the total time for this block of
    code will be just above 4 seconds. Maybe we can speed this up by using `join`.
    We have seen `join` speed up threads by running them at the same time. It does
    make sense that it will also work to speed up our futures. First, we must import
    the `join` macro with the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的输出是我们预期的结果，但我们知道这些未来将按顺序运行，而这块代码的总时间将略高于4秒。也许我们可以通过使用`join`来加快这个速度。我们已经看到`join`可以通过同时运行线程来加速线程。它确实有道理认为它也可以加速我们的未来。首先，我们必须使用以下代码导入`join`宏：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can now utilize `join` for our futures and time the implementation with
    the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以利用`join`来处理我们的未来，并使用以下代码来计时实现：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding code, we can see that the `join` macro returns a tuple of
    the results and that we unpack the tuple to give us the same result. However,
    if we do run the code, we can see that although we get the result that we want,
    our future execution does not speed up and is still stuck at just above 4 seconds.
    This is because a future is not being run using an `async` task. We will have
    to use `async` tasks to speed up the execution of our futures. We can achieve
    this by carrying out the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到`join`宏返回一个包含结果的元组，并且我们解包这个元组以得到相同的结果。然而，如果我们实际运行这段代码，我们可以看到尽管我们得到了想要的结果，但我们的未来执行并没有加速，仍然停滞在4秒以上。这是因为未来并没有使用`async`任务来运行。我们必须使用`async`任务来加速我们未来的执行。我们可以通过以下步骤实现这一点：
- en: Create the futures needed.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的未来。
- en: Put them into a vector.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们放入一个向量中。
- en: Loop through the vector, spinning off tasks for each future in the vector.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历向量，为向量中的每个未来启动任务。
- en: Join the `async` tasks and sum the vector.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接`async`任务并求和向量。
- en: 'This can be visually mapped out with the following figure:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下图示来直观地表示：
- en: '![Figure 3.2 – The steps to running multiple futures at once](img/Figure_3.2_B18722.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 同时运行多个未来的步骤](img/Figure_3.2_B18722.jpg)'
- en: Figure 3.2 – The steps to running multiple futures at once
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 同时运行多个未来的步骤
- en: 'To join all our futures at the same time, we will have to use another crate
    to create our own asynchronous `join` function by using the `async_std` crate.
    We define this crate in the `Cargo.toml` file with the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同时连接所有我们的未来，我们必须使用另一个crate通过使用`async_std` crate创建我们自己的异步`join`函数。我们在`Cargo.toml`文件中使用以下代码定义这个crate：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that we have the `async_std` crate, we can import what we need to carry
    out the approach laid out in *Figure 3**.2*, by importing what we need at the
    top of the `main.rs` file with the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`async_std` crate，我们可以通过在`main.rs`文件顶部导入所需的内容来执行*图3.2*中概述的方法，如下所示：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `main` function, we can now define our future with the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们现在可以使用以下代码定义我们的未来：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we can see that we define our futures (*1*), and then we add them to
    our vector (*2*). We then loop through our futures in our vector using the `into_iter`
    function. We then spawn a thread on each future using `async_std::task::spawn`.
    This is similar to `std::task::spawn`. So, why bother with all this extra headache?
    We could just loop through the vector and spawn a thread for each task. The difference
    here is that the `async_std::task::spawn` function is spinning off an `async`
    task in the same thread. Therefore, we are concurrently running both futures in
    the same thread! We then join all the handles, `await` for these tasks to finish,
    and then return the sum of all these threads. Now that we have defined our `async_outcome`
    future, we can run and time it with the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们定义了我们的未来（*1*），然后我们将它们添加到我们的向量（*2*）。然后我们使用`into_iter`函数在我们的向量中遍历我们的未来。然后我们使用`async_std::task::spawn`在每个未来上启动一个线程。这类似于`std::task::spawn`。那么，为什么要费这么多的额外麻烦呢？我们只需遍历向量并为每个任务启动一个线程。这里的区别在于`async_std::task::spawn`函数在同一线程中生成一个`async`任务。因此，我们在同一线程中并发运行这两个未来！然后我们连接所有句柄，`await`等待这些任务完成，然后返回所有这些线程的总和。现在我们已经定义了我们的`async_outcome`未来，我们可以用以下代码运行并计时：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running our additional code will give the following additional printout:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的附加代码将给出以下附加打印输出：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It’s working! We have managed to get two `async` tasks running at the same time
    in the same thread, resulting in both futures being executed in just over 2 seconds!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在工作！我们已经成功地在同一线程中同时运行了两个`async`任务，导致这两个未来在2秒多一点的时间内执行完成！
- en: 'As we can see, spawning threads and `async` tasks in Rust is straightforward.
    However, we must note that passing variables into threads and `async` tasks is
    not. Rust’s borrowing mechanism ensures memory safety. We must go through extra
    steps when passing data into a thread. Further discussion on the general concepts
    behind sharing data between threads is not conducive to our web project. However,
    we can briefly signpost what types allow us to share data:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在Rust中启动线程和`async`任务很简单。然而，我们必须注意，将变量传递到线程和`async`任务中并不是。Rust的借用机制确保了内存安全。当我们向线程传递数据时，我们必须采取额外的步骤。关于线程间共享数据的一般概念的进一步讨论不利于我们的Web项目。然而，我们可以简要地指出哪些类型允许我们共享数据：
- en: '`std::sync::Arc`: This type enables threads to reference outside data:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sync::Arc`：此类型使线程能够引用外部数据：'
- en: '[PRE42]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`std::sync::Mutex`: This type enables threads to mutate outside data:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sync::Mutex`：此类型使线程能够修改外部数据：'
- en: '[PRE49]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Inside the thread here, we dereference the result of the lock, unwrap it, and
    mutate it. It must be noted that the shared state can only be accessed once the
    lock is held.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个线程内部，我们取消引用锁的结果，解包它，并修改它。必须注意的是，共享状态只能在持有锁的情况下访问。
- en: We have now covered enough of async programming to return to our web programming.
    Concurrency is a subject that can be covered in an entire book, one of which is
    referenced in the *Further reading* section. For now, we must get back to exploring
    Rust in web development to see how our knowledge of Rust async programming affects
    how we understand the Actix Web server.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了足够的异步编程知识，可以回到我们的网络编程。并发是一个可以涵盖整本书的主题，其中之一在*进一步阅读*部分有引用。现在，我们必须回到探索Rust在Web开发中的应用，看看我们对Rust异步编程的了解如何影响我们对Actix
    Web服务器的理解。
- en: Exploring async and await with web programming
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Web编程中的异步和await
- en: 'Knowing what we know about async programming, we can now see the `main` function
    in our web application in a different light, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们所了解的异步编程，我们现在可以以不同的方式看待我们的Web应用程序中的`main`函数，如下所示：
- en: '[PRE55]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We know that our `greet` function is an `async` function and thus a future.
    We can also see that the closure we pass into the `/say/hello` view also utilizes
    the `async` syntax. We can also see that the `HttpServer::new` function utilized
    the `await` syntax in `async fn main()`. Therefore, we can deduce that our `HttpServer::new`
    function is an executor. However, if we were to remove the `#[actix_web::main]`
    macro, we would get the following error:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的`greet`函数是一个`async`函数，因此是一个未来。我们还可以看到我们传递给`/say/hello`视图的闭包也使用了`async`语法。我们还可以看到`HttpServer::new`函数在`async
    fn main()`中使用了`await`语法。因此，我们可以推断出我们的`HttpServer::new`函数是一个执行器。然而，如果我们移除`#[actix_web::main]`宏，我们会得到以下错误：
- en: '[PRE56]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is because our `main` function, which is our entry point, would return
    a future as opposed to running our program. `#[actix_web::main]` is a runtime
    implementation and enables everything to be run on the current thread. The `#[actix_web::main]`
    macro marks the `async` function (which, in this case, is the `main` function)
    to be executed by the Actix system.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的 `main` 函数，也就是我们的入口点，会返回一个 future 而不是运行我们的程序。`#[actix_web::main]` 是一个运行时实现，它使得所有内容都可以在当前线程上运行。`#[actix_web::main]`
    宏标记了 `async` 函数（在这种情况下是 `main` 函数）由 Actix 系统执行。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the risk of getting into the weeds here, the Actix crate runs concurrent
    computation based on the actor model. This is where an actor is a computation.
    Actors can send and receive messages to and from each other. Actors can alter
    their own state, but they can only affect other actors through messages, which
    removes the need for lock-based synchronization (the mutex we covered is lock-based).
    Further exploration of this model will not help us to develop basic web apps.
    However, the Actix crate does have good documentation on coding concurrent systems
    with Actix at [https://actix.rs/book/actix](https://actix.rs/book/actix).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里冒险深入探讨一下，Actix crate 基于actor模型运行并发计算。在这里，actor 是一个计算。Actors 可以互相发送和接收消息。Actors
    可以改变自己的状态，但它们只能通过消息影响其他actor，这消除了基于锁的同步（我们之前提到的互斥锁是锁基础的）。对这个模型的进一步探索不会帮助我们开发基本的Web应用。然而，Actix
    crate 在[https://actix.rs/book/actix](https://actix.rs/book/actix)上对使用Actix进行并发系统编码有很好的文档。
- en: We have covered a lot here. Do not feel stressed if you do not feel like you
    have retained all of it. We’ve briefly covered a range of topics around asynchronous
    programming. We do not need to understand it inside out to start building applications
    based on the Actix Web framework.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里已经涵盖了大量的内容。如果你觉得自己没有完全记住所有内容，请不要感到有压力。我们简要地介绍了一系列关于异步编程的话题。我们不需要完全理解它就可以开始基于
    Actix Web 框架构建应用程序。
- en: 'You may also feel like we have been excessive in what we have covered. For
    instance, we could have spun up a server and used the `async` syntax when needed
    to merely punch out views without really knowing what is going on. Not understanding
    what is going on but knowing where to put `async` would not have slowed us down
    when building our toy application. However, this whistle-stop tour is invaluable
    when it comes to debugging and designing applications. To establish this, we can
    look at an example in the wild. We can look at this smart *Stack Overflow* solution
    to running multiple servers in one file: [https://stackoverflow.com/questions/59642576/run-multiple-actix-app-on-different-ports](https://stackoverflow.com/questions/59642576/run-multiple-actix-app-on-different-ports).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会觉得我们涵盖的内容过多。例如，我们可以在需要时启动服务器并使用 `async` 语法来简单地生成视图，而不必真正了解发生了什么。在构建我们的玩具应用时，不了解发生了什么但知道在哪里放置
    `async` 并不会减慢我们的速度。然而，这种快速浏览对于调试和设计应用来说是非常宝贵的。为了建立这一点，我们可以看看现实世界中的一个例子。我们可以看看这个聪明的
    *Stack Overflow* 解决方案，它在一个文件中运行多个服务器：[https://stackoverflow.com/questions/59642576/run-multiple-actix-app-on-different-ports](https://stackoverflow.com/questions/59642576/run-multiple-actix-app-on-different-ports)。
- en: 'The code in the *Stack Overflow* solution involves basically running two servers
    at one runtime. First, they define the views with the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*Stack Overflow* 中的代码基本上是在一个运行时运行了两个服务器。首先，它们使用以下代码定义了视图：'
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once the views are defined, the two servers are defined in the `main` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 视图定义完毕后，在 `main` 函数中定义了两个服务器：
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'I have not added any notation to this code, but it should not intimidate you.
    We can confidently deduce that `s1` and `s2` are futures that the `run` function
    returns. We then join these two futures together and `await` for them to finish.
    There is also a slight difference between our code and the code in the *Stack
    Overflow* solution. Our solution utilizes `await?` and then returns `Ok` with
    the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有给这段代码添加任何注释，但它不应该让你感到害怕。我们可以自信地推断出 `s1` 和 `s2` 是 `run` 函数返回的 futures。然后我们将这两个
    futures 合并，并 `await` 它们完成。我们的代码和 *Stack Overflow* 中的代码有一点细微的差别。我们的解决方案使用了 `await?`
    并随后返回以下代码片段的 `Ok`：
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is because a `?` operator is essentially a `try` match. `join(s1, s2).await?`
    expands roughly to the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `?` 操作符本质上是一个 `try` 匹配。`join(s1, s2).await?` 大概等价于以下代码：
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Whereas `join(s1, s2).await.unwrap()` expands roughly to the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `join(s1, s2).await.unwrap()` 大概等价于以下代码：
- en: '[PRE61]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Because of the `?` operator, the person providing the solution has to insert
    `Ok` at the end because the `main` function returns `Result`, and this was taken
    away by implementing the `?` operator.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`?`操作符，提供解决方案的人必须在末尾插入`Ok`，因为`main`函数返回`Result`，而这被实现`?`操作符时移除了。
- en: Thus, in the wild solution, *Stack Overflow* has demonstrated the importance
    of covering async programming. We can look at code in the wild and work out what
    is going on and how the posters on *Stack Overflow* managed to achieve what they
    did. This can also mean that we can get creative ourselves. There is nothing stopping
    us from creating three servers and running them in the `main` function. This is
    where Rust really shines. Taking the time to learn Rust gives us the ability to
    safely dive into low-level territory and have more fine-grain control over what
    we do. You will find this is true in any field of programming done with Rust.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在野外的解决方案中，*Stack Overflow*展示了涵盖异步编程的重要性。我们可以查看野外的代码，弄清楚发生了什么，以及*Stack Overflow*上的发帖者是如何实现他们的目标的。这也意味着我们可以自己发挥创意。没有什么阻止我们创建三个服务器并在`main`函数中运行它们。这正是Rust真正闪耀的地方。花时间学习Rust让我们能够安全地深入到底层，并对我们所做的事情有更精细的控制。你会发现这在用Rust做的任何编程领域都是真实的。
- en: 'There is one more concept that we should investigate before trying to build
    our application, and this is `main` function to be a future. If we look at the
    **Tokio** crate, we can see that it is an asynchronous runtime for the Rust programming
    language by providing the building blocks needed to write network applications.
    The workings of Tokio are complex; however, if we look at the Tokio documentation
    on speeding up the runtime, we can add diagrams like the following one:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试构建我们的应用程序之前，还有一个概念我们应该调查，那就是将`main`函数作为一个未来。如果我们看看**Tokio**库，我们可以看到它是一个通过提供编写网络应用程序所需的构建块来为Rust编程语言提供异步运行时的库。Tokio的工作原理很复杂；然而，如果我们查看关于加快Tokio运行时的Tokio文档，我们可以添加如下所示的图表：
- en: '![Figure 3.3 – Speeding up the Tokio runtime [source: Tokio Documentation (2019)
    (https://tokio.rs/blog/2019-10-scheduler)]](img/Figure_3.3_B18722.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 加快Tokio运行时 [来源：Tokio文档（2019）](https://tokio.rs/blog/2019-10-scheduler)](img/Figure_3.3_B18722.jpg)'
- en: 'Figure 3.3 – Speeding up the Tokio runtime [source: Tokio Documentation (2019)
    ([https://tokio.rs/blog/2019-10-scheduler](https://tokio.rs/blog/2019-10-scheduler))]'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 加快Tokio运行时 [来源：Tokio文档（2019）](https://tokio.rs/blog/2019-10-scheduler)]
- en: 'In the preceding figure, we can see that there are tasks queued up and processors
    processing them. We processed our tasks earlier, so this should look familiar.
    Considering this, it might not be too shocking to know that we can use Tokio instead
    of the Actix Web macro to run our server. To do this, we define our Tokio dependency
    in the `Cargo.toml` file with the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到有一些任务被排队，处理器正在处理它们。我们之前已经处理了我们的任务，所以这应该看起来很熟悉。考虑到这一点，我们可能不会对可以使用Tokio而不是Actix
    Web宏来运行我们的服务器感到太惊讶。为此，我们在`Cargo.toml`文件中定义我们的Tokio依赖项，如下所示：
- en: '[PRE62]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'With the preceding code, we can now switch our macro in the `main.rs` file
    with the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们现在可以在`main.rs`文件中的宏切换到以下代码：
- en: '[PRE63]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Running the preceding code will give us the same outcome as running a server.
    There might be some inconsistencies when using Tokio instead of our Actix runtime
    macro. While this is an interesting result that demonstrates how we can confidently
    configure our server, we will use the Actix runtime macro for the rest of the
    book when it comes to developing the to-do application in Actix. We will revisit
    Tokio in [*Chapter 14*](B18722_14.xhtml#_idTextAnchor279), *Exploring the Tokio
    Framework*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将给我们与运行服务器相同的输出。当使用Tokio而不是我们的Actix运行时宏时，可能会有一些不一致。虽然这是一个有趣的结果，展示了我们可以如何自信地配置我们的服务器，但当我们谈到在Actix中开发待办事项应用程序时，我们将在这本书的其余部分使用Actix运行时宏。我们将在[*第14章*](B18722_14.xhtml#_idTextAnchor279)
    *探索Tokio框架*中重新审视Tokio。
- en: We have now covered enough of server configuration and how the server processes
    requests to be productive. We can now move on to defining our views and how they
    are handled in the next section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了足够的服务器配置和服务器如何处理请求的内容，可以变得高效。现在我们可以继续定义我们的视图以及它们在下一节中的处理方式。
- en: Managing views using the Actix Web framework
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Actix Web框架管理视图
- en: 'So far, we have defined all our views in the `main.rs` file. This is fine for
    small projects; however, as our project grows, this will not scale well. Finding
    the right views can be hard, and updating them can lead to mistakes. It also makes
    it harder to remove modules from or insert them into your web application. Also,
    if we have all the views being defined on one page, this can lead to a lot of
    merge conflicts if a bigger team is working on the application, as they will all
    want to alter the same file if they are altering the definitions of views. Because
    of this, it is better to keep the logic of a set of views contained in a module.
    We can explore this by building a module that handles authentication. We will
    not be building the logic around authentication in this chapter, but it is a nice
    straightforward example to use when exploring how to manage the structure of a
    views module. Before we write any code, our web application should have the following
    file layout:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在`main.rs`文件中定义了所有我们的视图。这对于小型项目来说是可以的；然而，随着我们的项目增长，这不会很好地扩展。找到正确的视图可能很困难，更新它们可能会导致错误。这也使得从你的Web应用程序中移除或插入模块变得更加困难。此外，如果我们把所有的视图定义在一个页面上，如果一个大团队正在开发应用程序，这可能会导致很多合并冲突，因为他们都会想要更改相同的文件，如果他们正在更改视图的定义。正因为如此，最好将一组视图的逻辑包含在一个模块中。我们可以通过构建一个处理认证的模块来探索这一点。我们不会在本章中构建围绕认证的逻辑，但它是一个很好的简单示例，用于探索如何管理视图模块的结构。在我们编写任何代码之前，我们的Web应用程序应该有以下文件布局：
- en: '[PRE64]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The code inside each file can be described as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件中的代码可以描述如下：
- en: '`main.rs`: The entry point for the server where the server is defined'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.rs`: 服务器定义的入口点'
- en: '`views/auth/login.rs`: The code defining the view for logging in'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/auth/login.rs`: 定义登录视图的代码'
- en: '`views/auth/logout.rs`: The code defining the view for logging out'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/auth/logout.rs`: 定义登出视图的代码'
- en: '`views/auth/mod.rs`: The factory that defines the views for `auth`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/auth/mod.rs`: 定义`auth`视图的工厂'
- en: '`views/mod.rs`: The factory that defines all the views for the whole app'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/mod.rs`: 定义整个应用程序所有视图的工厂'
- en: 'First, let us start off our entry point with a basic web server with no extras
    in the `main.rs` file, with the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从`main.rs`文件中的基本Web服务器开始，不添加任何额外的功能，以下代码：
- en: '[PRE65]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This preceding code is straightforward and there should be no surprises. We
    will alter the code later, and we can move on to defining the views. For this
    chapter, we just want to return a string saying what the view is. We will know
    that our application structure works. We can define our basic login view in the
    `views/auth/login.rs` file with the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码简单明了，不应该有任何惊喜。我们稍后会修改代码，然后我们可以继续定义视图。对于本章，我们只想返回一个字符串，说明视图是什么。我们将知道我们的应用程序结构是可行的。我们可以在`views/auth/login.rs`文件中使用以下代码定义我们的基本登录视图：
- en: '[PRE66]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, it will not be surprising that the logout view in the `views/auth/logout.rs`
    file takes the following form:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`views/auth/logout.rs`文件中的登出视图是这样的，这并不会让人感到惊讶：
- en: '[PRE67]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that our views have been defined, all we need to do is define the factories
    in the `mod.rs` files to enable our server to serve them. Our factories give the
    data flow of our app, taking the following form:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了视图，我们只需要在`mod.rs`文件中定义工厂，以便我们的服务器能够提供它们。我们的工厂提供了我们应用程序的数据流，其形式如下：
- en: '![Figure 3.4 – The data flow of our application](img/Figure_3.4_B18722.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 我们应用程序的数据流](img/Figure_3.4_B18722.jpg)'
- en: Figure 3.4 – The data flow of our application
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 我们应用程序的数据流
- en: 'We can see in *Figure 3**.4* that chaining factories gives us a lot of flexibility.
    If we wanted to remove all the `auth` views from our application, we would be
    able to do this by simply removing one line of code in our main view factory.
    We can also reuse our modules. For instance, if we were to use the `auth` module
    on multiple servers, we could merely have a git submodule for the `auth` views
    module and use it on other servers. We can build our `auth` module factory view
    in the `views/auth/mod.rs` file with the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图3**.4*中看到，链式工厂给我们带来了很多灵活性。如果我们想从我们的应用程序中移除所有的`auth`视图，我们只需在我们的主视图工厂中删除一行代码就能做到这一点。我们还可以重用我们的模块。例如，如果我们想在多个服务器上使用`auth`模块，我们只需为`auth`视图模块创建一个git子模块，并在其他服务器上使用它。我们可以在`views/auth/mod.rs`文件中使用以下代码构建我们的`auth`模块工厂视图：
- en: '[PRE68]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding code, we can see that we pass in a mutable reference of a
    `ServiceConfig` struct. This enables us to define things such as views on the
    server in different fields. The documentation on this struct states that it is
    to allow bigger applications to split up a configuration into different files.
    We then apply a service to the `ServiceConfig` struct. The service enables us
    to define a block of views that all get populated with the prefix defined in the
    scope. We also state that we are using `get` methods, for now, to make it easily
    accessible in the browser. We can now plug the `auth` views factory into the `main`
    views factory in the `views/mod.rs` file with the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们传递了一个`ServiceConfig`结构体的可变引用。这使得我们能够在服务器上的不同字段中定义诸如视图之类的事物。该结构体的文档说明，它是为了允许更大的应用程序将配置拆分到不同的文件中。然后我们将服务应用于`ServiceConfig`结构体。该服务使我们能够定义一个视图块，所有这些视图都将填充在作用域中定义的前缀。我们还声明，目前我们使用`get`方法，以便在浏览器中易于访问。现在，我们可以使用以下代码将`auth`视图工厂插入到`views/mod.rs`文件中的`main`视图工厂：
- en: '[PRE69]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the preceding code, we have been able to chop our entire views modules with
    just one line of code. We can also chain the modules as much as we like. For instance,
    if we wanted to have submodules within the `auth` views module, we could, and
    we merely feed the factories of those `auth` submodules into the `auth` factory.
    We can also define multiple services in a factory. Our `main.rs` file remains
    pretty much the same with the addition of a `configure` function, as seen with
    the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只需一行代码就能将整个视图模块切割。我们还可以按需链式调用模块。例如，如果我们想在`auth`视图模块中添加子模块，我们可以这样做，只需将那些`auth`子模块的工厂传递给`auth`工厂即可。我们还可以在工厂中定义多个服务。我们的`main.rs`文件在添加了一个`configure`函数后基本保持不变，如下所示：
- en: '[PRE70]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When we call the `configure` function on the `App` struct, we pass the views
    factory into the `configure` function, which will pass the `config` struct into
    our factory function for us. As the `configure` function returns `Self`, meaning
    the `App` struct, we can return the result at the end of the closure. We can now
    run our server, resulting in the following outcome:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`App`结构体上调用`configure`函数时，我们将视图工厂传递给`configure`函数，它会自动将`config`结构体传递给我们的工厂函数。由于`configure`函数返回`Self`，即`App`结构体，我们可以在闭包的末尾返回结果。现在我们可以运行我们的服务器，得到以下结果：
- en: '![Figure 3.5 – The login view](img/Figure_3.5_B18722.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 登录视图](img/Figure_3.5_B18722.jpg)'
- en: Figure 3.5 – The login view
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 登录视图
- en: We can see that our application with the expected prefix works! With this, we
    have covered all the basics to handle HTTP requests with confidence.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的应用程序带有预期的前缀可以正常工作！通过这一点，我们已经涵盖了处理HTTP请求的所有基础知识。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of threading, futures, and `async` functions.
    As a result, we were able to look at a multi-server solution in the wild and understand
    confidently what was going on. With this, we built on the concepts we learned
    in the previous chapter to build modules that define views. In addition, we chained
    factories to enable our views to be constructed on the fly and added to a server.
    With this chained factory mechanism, we can slot entire view modules in and out
    of a configuration when the server is being built.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了线程、未来和`async`函数的基础知识。因此，我们能够自信地查看野外的多服务器解决方案并理解其工作原理。基于上一章学到的概念，我们构建了定义视图的模块。此外，我们通过链式调用工厂，使视图能够即时构建并添加到服务器中。通过这种链式工厂机制，我们可以在构建服务器时将整个视图模块插入或移除配置。
- en: We also built a utility struct that defines a path, standardizing the definition
    of a URL for a set of views. In future chapters, we will use this approach to
    build authentication, JSON serialization, and frontend modules. With what we’ve
    covered, we’ll be able to build views that extract and return data from the user
    in a range of different ways in the next chapter. With this modular understanding,
    we have a strong foundation that enables us to build real-world web projects in
    Rust where logic is isolated and can be configured, and where code can be added
    in a manageable way.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还构建了一个实用结构体，它定义了一个路径，标准化了一组视图的URL定义。在未来的章节中，我们将使用这种方法构建认证、JSON序列化和前端模块。基于我们已经覆盖的内容，我们将在下一章中构建能够以多种不同方式从用户那里提取和返回数据的视图。有了这种模块化理解，我们有了强大的基础，使我们能够用Rust构建真实的网络项目，其中逻辑是隔离的，可以配置，代码可以以可管理的方式添加。
- en: In the next chapter, we will work on processing requests and responses. We will
    learn how to pass params, bodies, headers, and forms to views and process them
    by returning JSON. We will be using these new methods with the to-do module we
    built in the previous chapter to enable our interaction with to-do items through
    server views.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理请求和响应。我们将学习如何传递参数、主体、头和表单到视图中，并通过返回JSON来处理它们。我们将使用上一章中构建的待办事项模块，通过服务器视图来启用我们对待办事项的交互。
- en: Questions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What parameter is passed into the `HttpServer::new` function and what does the
    parameter return?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HttpServer::new`函数传递了什么参数，该参数返回什么？'
- en: How is a closure different from a function?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闭包与函数的区别是什么？
- en: What is the difference between a process and a thread?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程和线程之间的区别是什么？
- en: What is the difference between an `async` function and a normal one?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async`函数和普通函数之间的区别是什么？'
- en: What is the difference between `await` and `join`?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`await`和`join`之间的区别是什么？'
- en: What is the advantage of chaining factories?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接工厂的优势是什么？
- en: Answers
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A closure is passed into the `HttpServer::new` function. The `HttpServer::new`
    function has to return the `App` struct so that the `bind` and `run` functions
    can be acted on them after the `HttpServer::new` function has fired.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闭包被传递到`HttpServer::new`函数中。`HttpServer::new`函数必须返回`App`结构体，这样在`HttpServer::new`函数执行后，`bind`和`run`函数才能对其执行操作。
- en: A closure can interact with variables outside of its scope.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闭包可以与其作用域之外的变量交互。
- en: A process is a program that is being executed with its own memory stack, registers,
    and variables, whereas a thread is a lightweight process that is managed independently
    but shares data with other threads and the main program.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程是一个具有自己的内存栈、寄存器和变量的正在执行的程序，而线程是一个轻量级的进程，它可以独立管理但与其他线程和主程序共享数据。
- en: A normal function executes as soon as it is called, whereas an `async` function
    is a promise and must be executed with a blocking function.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 普通函数在调用时立即执行，而`async`函数是一个承诺，必须使用阻塞函数来执行。
- en: '`await` blocks a program to wait for a future to be executed; however, the
    `join` function can run multiple threads or futures concurrently. `await` can
    also be executed on a `join` function.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`await`会阻塞程序以等待未来执行；然而，`join`函数可以并发运行多个线程或未来。`await`也可以在`join`函数上执行。'
- en: Chaining factories gives us flexibility on how individual modules are constructed
    and orchestrated. A factory inside a module focuses on how the module is constructed,
    and the factory outside the module focuses on how the different modules are orchestrated.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接工厂使我们能够在构建和编排各个模块方面具有灵活性。模块内部的工厂专注于模块的构建方式，而模块外部的工厂专注于不同模块的编排方式。
- en: Further reading
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Hands-On Concurrency with Rust* (2018) by *Brian Troutwine*, *Packt Publishing*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Rust并发实战》（2018）*，作者：*布赖恩·特劳特温*，*Packt出版社*'
