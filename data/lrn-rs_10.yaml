- en: Creating Your Own Crate
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的自己的箱子
- en: Most languages allow for external libraries to be created. These typically contain
    commonly used pieces of code that are for general use. For example, libraries
    for deserializing JSON are fairly common, as are math libraries. Rust is no exception.
    It allows for the creation of libraries (known as **crates**). These crates can
    be kept to yourself or distributed however you see fit. The metadata about crates
    is stored on a public service, at [https://crates.io/](https://crates.io/).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '大多数语言都允许创建外部库。这些库通常包含通用代码片段，用于通用用途。例如，用于反序列化 JSON 的库相当常见，数学库也是如此。Rust 也不例外。它允许创建库（称为**箱子**）。这些箱子可以保留给自己或以您认为合适的方式分发。箱子的元数据存储在公共服务上，在
    [https://crates.io/](https://crates.io/)。 '
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How crates are created
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箱子的创建方式
- en: How the directory structure is used
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录结构的使用方式
- en: How crates are made up of modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箱子由模块组成的方式
- en: How to include your crate within your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在您的代码中包含您的箱子
- en: How scopes are used with your modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用模块的范围
- en: What exactly is a crate?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箱子究竟是什么？
- en: As with all languages, Rust can use external libraries that, we've established
    are called crates. But what are they?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有语言一样，Rust 可以使用外部库，我们已知这些库被称为箱子。但它们是什么？
- en: If we think about a crate, we think either of something we use to hold lots
    of other things. Software developers like to keep their code clean and if they
    know what they're doing, they tend to keep their libraries fairly specialized.
    These specialisms within a crate are known as modules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑一个箱子，我们会想到用来存放很多东西的东西。软件开发者喜欢保持他们的代码整洁，如果他们知道自己在做什么，他们往往会保持他们的库相当专业化。箱子内的这些专业化被称为模块。
- en: A crate is a container with one or more modules within it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 箱子是一个容器，其中包含一个或多个模块。
- en: Looking at modules
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看模块
- en: To show how crates are put together, we are going to create one. In this case,
    it will be a simple math crate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示箱子是如何组合起来的，我们将创建一个。在这种情况下，它将是一个简单的数学箱子。
- en: 'Before we consider this, let''s consider something we all know: a car. We will
    consider the car a crate, as everything to do with the car is held within it.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑这一点之前，让我们考虑一下我们所有人都知道的东西：汽车。我们将汽车视为箱子，因为与汽车有关的一切都包含在其中。
- en: To start, let's think about the main parts of the car: the engine, fuel, interior, wheels
    and movement, and electrics.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑汽车的主要部分：发动机、燃料、内饰、车轮和运动，以及电气部分。
- en: 'There are more but, for now, we will ignore them. Let''s represent this as
    a block diagram to make the relationship clearer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多，但现在我们将忽略它们。让我们用一个方块图来表示，以便更清晰地展示它们之间的关系：
- en: '![](img/00077.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: We can, of course, split up each of these blocks (for example, we can split
    the electrics into ignition, audio, windows, heated windscreens, lights, and interior
    fan).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将这些块分开（例如，我们可以将电气部分分为点火、音频、窗户、加热挡风玻璃、灯光和内饰风扇）。
- en: The car is the crate. Each block is a module. Each split is a submodule. It's
    now quite simple to see how crates can be visualized.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车是箱子。每个块是一个模块。每个分割是一个子模块。现在很容易看出箱子是如何可视化的。
- en: I can see a problem with this analogy
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我可以看到这个类比存在一个问题
- en: There was a reason I chose a car. If we think about it, all of the parts aren't
    really that discrete; the engine requires fuel, the electrics are needed by the
    engine, but the engine also generates electricity, and so on. In terms of programming,
    this will lead to a horrid mess.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择汽车是有原因的。如果我们想想，所有的部件并不是真的那么离散；发动机需要燃料，电气部分需要发动机，但发动机也产生电力，等等。从编程的角度来看，这会导致一团糟。
- en: How can we keep them apart?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将它们分开？
- en: The answer is that we use a scope for each. For example, the top level for this
    crate would be **Car**. We then add **::** followed by the module name (**Car::Engine**,
    **Car::Fuel**, and so on.). If a module requires access to another module, it
    can be included using the usual `use` directive.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，我们为每个模块使用一个范围。例如，这个箱子的顶层是**Car**。然后我们添加**::**，后面跟着模块名称（**Car::Engine**、**Car::Fuel**等等）。如果一个模块需要访问另一个模块，可以使用通常的`use`指令来包含它。
- en: 'The name of the crate is the name used when the library is created using cargo.
    In this example, the command line to create this crate will be as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 箱子的名称是在使用 cargo 创建库时使用的名称。在这个例子中，创建此箱子的命令行如下：
- en: '**cargo new Car**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**cargo new Car**'
- en: Note that we do not use the `--bin` flag.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不使用`--bin`标志。
- en: 'Consider the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we break the modules down further, we extend the scope in the same way as
    we did previously in order to access them:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步分解模块，我们将以与之前相同的方式扩展作用域以便访问它们：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Back to our math library
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的数学库
- en: Now that we know how crates and modules go together and how their scope allows
    for the modules to not become confused if they function with the same name (`Car::Engine`
    and `Car::Electics` can both have a function called `voltage_to_earth`, for example,
    each does a different action), let's consider our math library.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了crates和模块是如何结合在一起的，以及它们的作用域如何允许模块在具有相同名称的情况下（例如，`Car::Engine`和`Car::Electics`都可以有一个名为`voltage_to_earth`的函数，每个都执行不同的操作）不会混淆，让我们考虑我们的数学库。
- en: 'The library will have four modules with a number of submodules:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该库将包含四个模块和多个子模块：
- en: 'Trigonometry:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角学：
- en: Sin/Cos/Tan
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正弦/余弦/正切
- en: Arcsin, Arccos, and Arctan
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反正弦、反余弦和反正切
- en: 'Regression analysis:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归分析：
- en: Intercept on a straight line
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直线上的截距
- en: Standard deviation and r² value
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准差和r²值
- en: 'Conversions:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换：
- en: Temperature, pressure, and volume
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度、压力和体积
- en: 'Base functions:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本函数：
- en: Base *n* to base 10 conversions
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*进制到十进制转换'
- en: Base 10 to base *n* conversions
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制到*n*进制转换
- en: Base *m* to base *n* addition, subtraction, multiplication, and division
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m*进制到*n*进制加、减、乘、除'
- en: Using a useful name
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有用的名称
- en: Naming within a module is very important; it is going to be visible to anyone
    using it and should therefore describe what it does. The same applies to function
    names. For example, *f_to_c* is fine, but the whole point of a library is that
    you can get what you are after without having to second-guess what the author
    meant. A function name such as *fahrenheit_to_celcius* makes much more sense.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 模块内的命名非常重要；它将可见于任何使用它的人，因此应该描述它所做的工作。函数名称也是如此。例如，*f_to_c*是可以的，但库的整个目的就是你可以得到你想要的东西，而无需猜测作者的意图。一个名为*fahrenheit_to_celcius*的函数名称更有意义。
- en: The same applies to modules. If I were to use *ra* for regression analysis,
    it might seem like a reasonable name to use, but is it clear? The name can mean
    anything here. It may seem like a lot of effort to create a module called *regression_analysis*,
    but it will help other users know what to expect.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于模块。如果我要用*ra*进行回归分析，这个名字可能看起来合理，但它是否清晰？这里的名字可以代表任何东西。创建名为*regression_analysis*的模块可能看起来很费力，但它将帮助其他用户了解可以期待什么。
- en: Let's create!
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始创建！
- en: To start, we need to create the crate itself.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建crate本身。
- en: 'To do this, instead of writing the following, we need to tell cargo that we
    are creating a library:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们不需要写以下内容，而是需要告诉cargo我们正在创建一个库：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To do this, we simply omit the `-bin` flag:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需省略`-bin`标志：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows this, followed by the tree structure for the
    module. You''ll notice that `main.rs` has been replaced by `lib.rs`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这一点，随后是模块的树结构。你会注意到`main.rs`已被替换为`lib.rs`：
- en: '![](img/00078.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00078.jpeg)'
- en: Figure 1
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: Creating top-level modules
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建顶级模块
- en: 'To create a module, we first need to tell the compiler that the code is held
    in a module. In this example, I will use the `Trigonometry` module:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个模块，我们首先需要告诉编译器代码存储在模块中。在这个例子中，我将使用`Trigonometry`模块：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we compile this using `cargo build` (not `cargo run`; there is no `main`
    function within the library) and examine the tree, we''ll see the library (highlighted):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`cargo build`（而不是`cargo run`；库中没有`main`函数）编译并检查树结构时，我们会看到库（高亮显示）：
- en: '![](img/00079.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00079.jpeg)'
- en: Figure 2
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: The structure for this section can be found in `Chapter10/MathsLibStucture`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分的架构可以在`第10章/数学库结构`中找到。
- en: We can't do very much with it currently as all it contains are placeholders
    that do very little. Before this goes any further, have a look at the `lib.rs`
    source file. With nothing in except for the module names, it hits 62 lines. Let's
    think of a very simple example for the `Conversion` module, *fahrenheit_to_celcius*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们无法用它做太多，因为它只包含一些几乎不起作用的占位符。在继续之前，先看看`lib.rs`源文件。除了模块名称外，它已经有62行。让我们为`Conversion`模块想一个非常简单的例子，*华氏度转摄氏度*。
- en: 'The formula to do this is *(F - 32) * 5/9*. Our function will therefore be
    the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的公式是*(F - 32) * 5/9*。因此，我们的函数将是以下内容：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That was just four lines of code. We also need ones to go from C to F, K to
    C, C to K, F to K, and K to F (K is Kelvin, which denotes absolute temperature,
    that is, 0K = -273.15^oC , also known as absolute zero). Including these will
    take it to a total of around 24 lines of code. This is a simple module. The ones
    for regression analysis run to around 100.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是四行代码。我们还需要从C到F、从K到C、从C到K、从F到K以及从K到F（K代表开尔文，表示绝对温度，即0K = -273.15^oC，也称为绝对零度）的转换。包括这些将使代码行数达到大约24行。这是一个简单的模块。回归分析的模块代码行数大约有100行。
- en: Our source file is going to be huge. As we want to keep our modules manageable,
    we are going to need to break the `lib.rs` file down a bit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标源文件将会非常大。由于我们希望保持模块的可管理性，我们需要将`lib.rs`文件分解一下。
- en: The multifile module
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多文件模块
- en: In order to break our current `lib.rs` file down, we are going to have to change
    how we declare modules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分解我们当前的`lib.rs`文件，我们需要改变声明模块的方式。
- en: The source for this section is in `Chapter10/MathsLibMultiFile and Chapter10/MathsLibMultiFileDirs`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的内容源文件位于`Chapter10/MathsLibMultiFile`和`Chapter10/MathsLibMultiFileDirs`。
- en: 'Currently, we have this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有以下内容：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To break this into separate files, we need to declare only the top-level modules
    in `lib.rs`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其分解为单独的文件，我们只需要在`lib.rs`中声明顶级模块：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What about submodules?
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子模块怎么办？
- en: When we declare top-level modules like this, Rust will expect there to be either
    a directory for each of these modules or four source files (`Trigonometry.rs`,
    `RegressionAnalysis.rs`, `Conversions.rs`, and `Bases.rs`). If the directory structure
    is used, Rust will expect a file called `mod.rs` in each directory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种方式声明顶级模块时，Rust会期望每个模块都有一个目录，或者有四个源文件（`Trigonometry.rs`、`RegressionAnalysis.rs`、`Conversions.rs`和`Bases.rs`）。如果使用目录结构，Rust会期望每个目录中都有一个名为`mod.rs`的文件。
- en: 'Let''s compare how these two systems look, and then we can examine the relative
    benefits of each. The structure of `MathsLibMultiFile` will be as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较这两个系统的外观，然后我们可以检查每个系统的相对优势。`MathsLibMultiFile`的结构将如下所示：
- en: '![](img/00080.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: Figure 3a
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图3a
- en: 'The structure of `MathsLibMultiFileDirs` will be as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`MathsLibMultiFileDirs`的结构将如下所示：'
- en: '![](img/00081.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: Figure 3b
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图3b
- en: At first glance, they seem to be very similar; the only difference is that multifiledir
    (*Fig 3b*) has modules broken down into separate files whereas multifile (*Fig
    3a*) only has a single file for each module. This is a limitation of the non-directory
    structure; the submodules are kept in a single file, which is fine for a very
    small module but no good for larger modules.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，它们似乎非常相似；唯一的区别是多文件目录（*图3b*）将模块分解为单独的文件，而多文件（*图3a*）每个模块只有一个文件。这是非目录结构的限制；子模块被保存在一个文件中，这对于非常小的模块来说是可以的，但对于较大的模块来说就不太好了。
- en: In the directory structure version, there is a `mod.rs` file. This is completely
    empty but is there to let the compiler know that we have submodules. If (say)
    `RegressionAnalysis::Statistics` were to be further broken down, it would be a
    case of creating a new directory within the `RegressionAnalysis` directory called
    `Statistics` (the directory must have the same name as the module) and adding
    a new `mod.rs` file as well as new submodules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录结构版本中，有一个`mod.rs`文件。这个文件完全是空的，但它的存在是为了让编译器知道我们有了子模块。如果（比如说）`RegressionAnalysis::Statistics`需要进一步分解，那么它将是在`RegressionAnalysis`目录内创建一个新的名为`Statistics`的目录（目录必须与模块同名），并添加一个新的`mod.rs`文件以及新的子模块。
- en: The mod.rs file
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`mod.rs`文件'
- en: This file should include an interface to the module itself. The name of the
    module will point to a file with the same name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件应包含对模块本身的接口。模块的名称将指向具有相同名称的文件。
- en: 'Consider the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding line will point to `mycode.rs`. You will need to include an interface
    to each file in that module directory (with the exception of `mod.rs`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行将指向`mycode.rs`。您需要在该模块目录中的每个文件中包含接口（`mod.rs`除外）。
- en: Let's add some code
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们添加一些代码
- en: 'We now have the structure in place and our basic framework; we can start adding
    some code to the library. In this case, it will be the `Conversions::Temperature`
    part. We have already seen the function for Fahrenheit to Celcius, so let''s add
    the other functions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经建立了结构并拥有了基本框架；我们可以开始向库中添加一些代码。在这种情况下，将是`Conversions::Temperature`部分。我们已经看到了华氏到摄氏的温度转换函数，所以让我们添加其他函数：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is nothing earth-shattering about this code, but we do have to stop for
    a second to think about this. The Kelvin scale goes from 0 to *n*; it never goes
    below zero. It's entirely possible for the user to want to use `celcius_to_kelvin`
    and pass -274 instead. This would mean that the answer from the function would
    be mathematically correct but physically incorrect.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并没有什么惊人的地方，但我们确实需要停下来思考一下。开尔文温度从0到*n*；它永远不会低于零。用户完全可能想要使用`celcius_to_kelvin`并传入-274。这意味着函数的答案在数学上是正确的，但在物理上是不正确的。
- en: The code for this section is in `Chapter10/MathsLib`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分的代码在`Chapter10/MathsLib`。
- en: We could return `-1` but then, for some of the functions, that answer is fine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以返回`-1`，但对于某些函数，这个答案是可以接受的。
- en: What we need to return here is a tuple with the first parameter being a Boolean,
    signifying whether the calculation is valid or not (`true` = valid). If it's `true`,
    the answer is in the second parameter; otherwise, pass back the original value
    passed in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要返回的是一个元组，第一个参数是一个布尔值，表示计算是否有效（`true` = 有效）。如果是`true`，答案在第二个参数中；否则，返回原始传入的值。
- en: 'As a quick test, the following code can be run:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速测试，以下代码可以运行：
- en: See `Chapter10/QuickTest` for the source.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有关源代码，请参阅`Chapter10/QuickTest`。
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is convenient here to use the indexed form of the tuple rather than destructuring
    it into two variables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用元组的索引形式而不是将其解构为两个变量是很方便的。
- en: 'When compiled, we get the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时，我们得到以下输出：
- en: '![](img/00082.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00082.jpeg)'
- en: Figure 4
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图4
- en: This is exactly what was expected. It does also show a need for a set of unit
    tests to be added into the library to determine the validity (or not) of the data
    being fed in.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是预期的结果。这也表明需要在库中添加一组单元测试，以确定输入数据的有效性（或无效性）。
- en: Beware of double name scopes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小心双重名称作用域
- en: 'It is quite a common problem to create a crate that may run into an issue known
    as double name scope. Consider the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可能遇到双重名称作用域问题的crate是一个相当常见的问题。考虑以下示例：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Writing the preceding line instead of the following line causes a major problem:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为后面的行会导致一个主要问题：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The problem is down to the mod.rs and the temperature file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在`mod.rs`和`temperature`文件上。
- en: If you look at `lib.rs`, it has in it the name of the module that has to marry
    up with the name of the directory, which, in turn, contains the `mod.rs` file.
    The `mod.rs` file (as we have seen) needs to contain a public interface to the
    module. Now, following this logic, the code in the `temperature.rs` file should
    also have `pub mod temperature { ... }`. It is this final `pub mod` that gives
    the double name scope.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`lib.rs`，它包含必须与目录名称匹配的模块名称，该目录反过来包含`mod.rs`文件。`mod.rs`文件（如我们所见）需要包含模块的公共接口。现在，按照这个逻辑，`temperature.rs`文件中的代码也应该有`pub
    mod temperature { ... }`。正是这个最后的`pub mod`导致了双重名称作用域。
- en: To avoid this problem, just leave the `pub mod temperature` line out. As long
    as the filename matches the `pub mod` name in `mod.rs`, the compiler will consider
    that code as belonging to the named mod from `mod.rs`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，只需省略`pub mod temperature`行。只要文件名与`mod.rs`中的`pub mod`名称匹配，编译器就会认为该代码属于`mod.rs`中命名的模块。
- en: 'Check out the following code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码片段：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding unit tests to the library
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向库中添加单元测试
- en: 'We can create tests in one of the two ways: either by adding a `tests` directory
    with a `lib.rs` file or by simply adding a file with the tests for that module.
    As we are already using a directory structure, let''s stay with that for the unit
    tests.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式之一创建测试：要么添加一个包含`lib.rs`文件的`tests`目录，要么简单地添加一个包含该模块测试的文件。由于我们已经在使用目录结构，让我们继续使用它来编写单元测试。
- en: 'As previously discussed in [Chapter 1](part0021.html#K0RQ0-a5175cb437d742a9aed0ea574000ee2d),
    *Introducing and Installing Rust*, to add a unit test, we precede the code with
    the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在[第1章](part0021.html#K0RQ0-a5175cb437d742a9aed0ea574000ee2d)中，*介绍和安装Rust*，为了添加单元测试，我们在代码前添加以下内容：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then to build, we need to do the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了构建，我们需要做以下操作：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we do this, though, we hit a problem. Our unit test file looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们这样做的时候，我们遇到了一个问题。我们的单元测试文件看起来是这样的：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On the face of it, this should work, but it comes back with something that
    is somewhat perplexing:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这似乎应该可行，但它返回的结果有些令人困惑：
- en: '![](img/00083.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00083.jpeg)'
- en: Figure 5
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图5
- en: This doesn't make sense; we know there is a module called `Temperature`, so
    why are we getting this message? The answer is that it's all down to the privacy
    of the module and functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有意义；我们知道有一个名为`Temperature`的模块，那么为什么我们会收到这条消息？答案是，这完全取决于模块和函数的隐私性。
- en: Making something public
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公开某些内容
- en: We saw in [Chapter 7](part0143.html#48C0E0-a5175cb437d742a9aed0ea574000ee2d),
    *Matching and Structures*, how Rust, by default, sets all the functions, `structs`,
    and so on to be private. This is fine, as it prevents some of the nuts and bolts
    of the code from being exposed to the public interface.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 7 章](part0143.html#48C0E0-a5175cb437d742a9aed0ea574000ee2d)中，我们了解到，Rust
    默认将所有函数、`structs`等设置为私有。这是可以的，因为它防止了代码的一些细节暴露给公共接口。
- en: 'This does mean, though, that we have to explicitly set the module, and all
    of the functions we want the user to have access to, to be `pub` (public). Therefore,
    our functions for the temperature conversion will be as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着我们必须明确地将模块以及我们希望用户可以访问的所有函数设置为`pub`（公共）。因此，我们的温度转换函数将如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next time we come to run the unit tests, we should not have this issue,
    except for the following snag:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下次我们运行单元测试时，应该不会出现这个问题，除了以下问题：
- en: '![](img/00084.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00084.jpeg)'
- en: Figure 6
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6
- en: 'We have definitely got a `pub` function in the `Temperature` module called
    `kelvin_to_celcius`. The issue is the following line:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实在`Temperature`模块中有一个名为`kelvin_to_celcius`的`pub`函数。问题是以下这一行：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What this does is import only the module and none of the symbols (the functions).
    We can fix this in one of the following four ways:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的只是导入模块，而不是任何符号（函数）。我们可以通过以下四种方式中的任何一种来修复这个问题：
- en: 'We can use the following:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用以下方法：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We use the following:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用以下方法：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We use the following:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用以下方法：
- en: '`use mathslib::conversions::temperature;` then precede `kelvin_to_celcius`
    with `temperature::`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`use mathslib::conversions::temperature;`然后在`kelvin_to_celcius`前加上`temperature::`'
- en: 'We remove the `use mathslib` line and add the following line inside `mod temperature_tests`:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们删除了`use mathslib`行，并在`mod temperature_tests`内部添加以下行：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using any of these should allow the tests to compile and run. The output you
    will see should be something like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些中的任何一个都应该允许测试编译和运行。您将看到的输出应该类似于以下内容：
- en: '![](img/00085.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00085.jpeg)'
- en: 'Fig 7: chap10_unittest'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '图 7: chap10_unittest'
- en: Let's give our crate a quick run out
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们快速运行我们的crate
- en: As it stands, our crate is far from finished. However, there is enough code
    in there to see whether it actually runs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的crate还远未完成。然而，其中包含足够的代码来查看它是否真的能运行。
- en: Code for this section is in `Chapter10/first_run_out`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码位于`Chapter10/first_run_out`。
- en: 'Our initial code looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的代码如下所示：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we build this, we get the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建这个项目时，我们得到以下结果：
- en: '![](img/00086.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00086.jpeg)'
- en: Figure 7
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7
- en: This stands to reason; we're asking the code to include a library that it has
    no clue about.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的；我们要求代码包含一个它一无所知的库。
- en: External dependencies
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部依赖项
- en: 'Normally, if a dependency is outside the application, we would add something
    like this to the `Cargo.toml` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果一个依赖项在应用程序外部，我们会在`Cargo.toml`文件中添加如下内容：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, we're not able to use cargo to make the build; instead, we need
    to compile using `rustc`. The way cargo works is it recompiles the dependencies
    for each project (there is no guarantee that each project will use the same set
    of features for a given crate).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们无法使用cargo来构建；相反，我们需要使用`rustc`来编译。cargo的工作方式是它会为每个项目重新编译依赖项（没有保证每个项目都会为给定的crate使用相同的特征集）。
- en: 'We can simulate a cargo run with the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令模拟cargo运行：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `-L` links any libraries in `.` (the root directory, where you find `Cargo.toml`)
    to the sources after the `.` . The `/main` part essentially tells the command-line
    interpreter to execute the binary called `./main` in the root directory (the name
    comes from the file compiled).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`-L`选项将`.`（根目录，其中包含`Cargo.toml`文件）中的任何库链接到`.`之后的源代码。`/main`部分实际上告诉命令行解释器在根目录（编译文件的名称）中执行名为`./main`的二进制文件。'
- en: 'Once we have executed this, we can see our application in all its glory:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作后，我们可以看到我们的应用程序的全貌：
- en: '![](img/00087.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00087.jpeg)'
- en: Figure 8
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8
- en: We now know that our crate (as-is) is running as it should do.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，我们的crate（现状）正在按预期运行。
- en: Changing the scope
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变作用域
- en: One of the more interesting features that we can perform with our scope names
    is to change them. We can also customize which modules to include on our use lines.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的作用域名称执行的一些更有趣的功能之一是更改它们。我们还可以自定义在用法行上包含哪些模块。
- en: Altering the crate name
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 crate 名称
- en: 'Normally, when we import a crate, we use the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们导入一个 crate 时，我们使用以下内容：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, to avoid confusion with something in your code, you may want to refer
    to the crate with a different name:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了避免与代码中的某些内容混淆，你可能希望用不同的名称来引用 crate：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It looks very similar to casting, which is because it casts the name `my_crate`
    to be `crate_name`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与铸造非常相似，这是因为它将名称 `my_crate` 铸造为 `crate_name`。
- en: 'When we now refer to the crate we don''t use the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在提到 crate 时，我们不使用以下内容：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We rather use the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更愿意使用以下内容：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Optimizing your use statements
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化你的用法语句
- en: One of the very few things Java has done correctly is the degree of granularity
    in the way it imports libraries; it pushes the developer to only include the parts
    of the library actually required by the application. This is down to the history
    of Java, but it's something that should be encouraged. Rust does something similar.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Java 做得正确的一件非常少的事情是它在导入库的方式上的粒度程度；它促使开发者只包含应用程序实际需要的库的部分。这归因于 Java 的历史，但这是应该被鼓励的。Rust
    也做了类似的事情。
- en: The `use` statement can take a number of different styles.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 语句可以采用多种不同的样式。'
- en: The use-everything approach
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用所有内容的做法
- en: 'This takes the following form:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有以下形式：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is often referred to as the sledgehammer approach, as it makes available
    all the symbols (the functions, traits, and so on that are public) within the
    `module_name` scope. There is nothing wrong with this approach, but it ends up
    with a larger binary (which may slow down the final application and will certainly
    require more memory to run the code).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被称为大锤做法，因为它使得 `module_name` 范围内的所有符号（公共函数、特性和等等）都可用。这种做法没有问题，但最终会导致更大的二进制文件（这可能会减慢最终应用程序的速度，并且运行代码时肯定会需要更多的内存）。
- en: The you-decide approach
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你决定的做法
- en: 'This is the very minimum required to use the `module_name` scope:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `module_name` 范围所需的最小内容：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, you are telling the compiler that `module_name` exists and that, as long
    as the function name exists in the symbols, it can be used. However, in order
    to use `module_name`, the function will need to be preceded by `module_name`.
    For example, to use the `print_me(f32)` function, which exists in `module_name`,
    you will have the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在告诉编译器 `module_name` 存在，并且只要函数名称存在于符号中，它就可以被使用。然而，为了使用 `module_name`，函数需要以
    `module_name` 开头。例如，要使用存在于 `module_name` 中的 `print_me(f32)` 函数，你将会有以下内容：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `module_name::` has to be added to tell the compiler to use the `module_name`
    scope rather than the current scope of the application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`module_name::` 必须添加到编译器，以便使用 `module_name` 范围而不是应用程序的当前作用域。'
- en: The use-me approach
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我的做法
- en: 'Here, we tell the compiler that we are only allowing the current scope to use
    a specific function from within the `module_name` scope:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉编译器我们只允许当前作用域使用 `module_name` 范围内的特定函数：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The use-me-but-call-me-something-else approach
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我但叫其他名字的做法
- en: 'This is very similar to referring to the crate by another name:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这与通过另一个名称引用 crate 非常相似：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This doesn't mean what you probably think it means. With the crate example,
    we said that we are going to use `my_crate`, which is the cast of `crate_name`.
    In this case, what we're saying is that `mod_name` is a cast of `my_crate::module_name`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你可能认为的意思。在 crate 示例中，我们说我们将使用 `my_crate`，这是 `crate_name` 的铸造。在这种情况下，我们说的是
    `mod_name` 是 `my_crate::module_name` 的铸造。
- en: 'Let''s use the following after the preceding line:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行之后，让我们使用以下内容：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we do so, we now use the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们现在使用以下内容：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It looks the same, but really it means the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来一样，但实际上意味着以下内容：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The use-glob approach
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全局匹配的做法
- en: 'This approach is similar to the use-me approach, with the exception of using
    `{}` around what we want the code to have access to (known as a **glob**):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与使用我的方法类似，但有一个例外，即我们在想要代码可以访问的内容周围使用 `{}`（称为 **glob**）：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The line means that the code can access `module_name::print_me` and `module_name::calculate_time`
    but nothing else from the `module_name` scope.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行意味着代码可以访问 `module_name::print_me` 和 `module_name::calculate_time`，但不能访问 `module_name`
    范围内的其他内容。
- en: The use-glob-self approach
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全局匹配自我做法
- en: 'Here, the first parameter of the glob is `self`. In this context, `self` refers
    back to the root context:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，glob的第一个参数是`self`。在这个上下文中，`self`指的是根上下文：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In an expanded form, this will equate to the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以扩展形式，这相当于以下内容：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of ground in this chapter and saw that, for most of the time,
    cargo makes building a Rust application simple. When testing your own crates outside
    the project it was originally created in, we need to use `rustc` in order to compile.
    We saw how to create our own libraries, how to add unit tests, how to effectively
    utilize the use statement, and how to call crates and scopes by different names.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容，并看到，在大多数情况下，货物使得构建Rust应用程序变得简单。当在最初创建项目之外测试自己的crate时，我们需要使用`rustc`来编译。我们看到了如何创建自己的库，如何添加单元测试，如何有效地利用use语句，以及如何用不同的名称调用crate和作用域。
- en: In our next chapter, we will be looking at how we can really make use of Rust's
    in-built memory protection system to fully utilize concurrency and parallelism.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何真正利用Rust内置的内存保护系统，以充分利用并发性和并行性。
