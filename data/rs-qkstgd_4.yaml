- en: Making Decisions by Pattern Matching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过模式匹配进行决策
- en: We already saw Rust's `if` expressions, but those make decisions based on data
    values. Rust is a very type-conscious language, and so it's very important to
    be able to make decisions based on data types as well. Rust's `match` and `if
    let` expressions let us do that, comparing complex data types and allowing us
    to extract data values for further processing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Rust的`if`表达式，但那些是基于数据值进行决策的。Rust是一种非常注重类型的语言，因此能够基于数据类型进行决策也非常重要。Rust的`match`和`if
    let`表达式允许我们这样做，比较复杂的数据类型，并允许我们从匹配的模式中提取数据值以进行进一步处理。
- en: 'In this chapter, we''re going to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Learn how to use pattern matching in the context of variable assignment using
    the `let` statement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在`let`语句的上下文中使用模式匹配进行变量赋值
- en: Take what we've learned about pattern matching and apply it to decision making
    with the `if let` expression
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们关于模式匹配的知识应用到使用`if let`表达式进行决策中
- en: Use the `match` expression to choose exactly one of many possible patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`match`表达式来选择众多可能模式中的确切一个
- en: Use don't care values in pattern matching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模式匹配中使用无关紧要的值
- en: See how borrowing interacts with pattern matching
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看借用如何与模式匹配交互
- en: Learn how to match complex, nested data structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何匹配复杂、嵌套的数据结构
- en: Variable assignment with pattern matching
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模式匹配进行变量赋值
- en: 'We''ve seen many times how to assign a variable in Rust: we do something like
    `let x = y;`, which tells Rust to create a new variable named `x` and move or
    copy the value stored in `y` into it, as appropriate to the data type.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次看到如何在Rust中分配变量：我们做类似`let x = y;`的事情，这告诉Rust创建一个名为`x`的新变量，并将存储在`y`中的值移动或复制到它里面，具体取决于数据类型。
- en: 'However, that''s actually just a simplified case of what Rust is really doing,
    which is matching a pattern to a value and extracting data values from that matched
    pattern to store in the target variables, as in the following example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这实际上只是Rust真正所做事情的一个简化案例，即匹配一个模式到一个值，并从匹配的模式中提取数据值以存储在目标变量中，如下例所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Okay, what just happened? First of all, we have a structure definition. We've
    seen those before, and the only new thing here is that we're using the `String`
    data type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，刚才发生了什么？首先，我们有一个结构定义。我们之前见过这些，这里唯一的新东西就是我们正在使用`String`数据类型。
- en: '`String` has an interesting relationship with `str`. When we''re using `str`,
    we almost always actually use a borrow such as `&str` or `&''static str`, rather
    than plain `str`. That''s because plain `str` doesn''t have a fixed size in the
    stack, which makes a lot of the things we''d want to do impossible to compile.
    So, we use `&str` instead, which does have a fixed size. *But*, using a reference
    as a contained value in a data structure also opens the door to all sorts of lifetime-based
    restrictions, so we don''t really want to use `pub name: &str` here. Fortunately,
    we can use `String` instead.`String` can masquerade as an `&str` when we need
    it to, but it''s not actually a borrow, so the ownership is straightforward. It
    is, however, slightly less efficient to use, so the general rule is to use `String`
    when it solves a problem and use `&str` the rest of the time.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`与`str`有一个有趣的关系。当我们使用`str`时，我们几乎总是实际上使用一个借用，比如`&str`或`&''static str`，而不是普通的`str`。这是因为普通的`str`在栈中没有固定的大小，这使得我们想要做的许多事情都无法编译。因此，我们使用`&str`，它确实有一个固定的大小。但是，使用引用作为数据结构中的包含值也打开了基于生命周期的所有
    sorts 的限制，所以我们并不真的想在这里使用`pub name: &str`。幸运的是，我们可以使用`String`代替。当需要时，`String`可以伪装成`&str`，但它实际上不是一个借用，所以所有权是直接的。然而，使用`String`稍微低效一些，所以一般规则是当`String`解决问题时使用它，其余时间使用`&str`。'
- en: After that, we create a new data value with the `DemoStruct` type, with its
    three contained values. We've seen that before, too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`DemoStruct`类型创建一个新的数据值，包含其三个包含值。我们也见过这种情况。
- en: 'What on Earth are we doing in the last line of the example? `DemoStruct{ id:
    x, name: y, probability: z }` is a pattern. We''re telling Rust that we expect
    the assigned value to be a `DemoStruct`, and that its contained values should
    in turn be matched with the `x`, `y`, and `z` sub-patterns.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '在示例的最后一行我们究竟在做什么？`DemoStruct{ id: x, name: y, probability: z }`是一个模式。我们正在告诉Rust我们期望分配的值是一个`DemoStruct`，并且它的包含值应该依次与`x`、`y`和`z`子模式匹配。'
- en: When we use a variable name as a pattern, it matches any value and that value
    is assigned to that name, which is what is happening here. It's also what's happening
    with a simple `let x = 5`. So, `x`, `y`, and `z` end up being new variables containing
    the values that were previously stored in `source.id`, `source.name`, and `source.probability`,
    respectively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用变量名作为模式时，它会匹配任何值，并将该值分配给该名称，这正是这里发生的事情。这也是简单的 `let x = 5` 发生的事情。因此，`x`、`y`
    和 `z` 最终成为包含之前存储在 `source.id`、`source.name` 和 `source.probability` 中的值的新的变量。
- en: 'We didn''t have to use variable names for the sub-patterns, though. We could,
    for example, have tried this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不需要为子模式使用变量名。例如，我们可以尝试这样做：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we do that, however, the compiler will report an error. The error is not
    because `31` is an invalid pattern. It's a perfectly good pattern and even happens
    to match the value we would actually find. The compiler will refuse to compile
    it, though, because it doesn't match all of the possibilities for the source value,
    and Rust doesn't allow `let` statements that might fail just because a variable's
    value got changed. Imagine of all the trouble that it could cause!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们这样做，编译器将报告一个错误。错误不是因为 `31` 是一个无效的模式。这是一个非常好的模式，并且恰好匹配我们实际上会找到的值。不过，编译器会拒绝编译它，因为它没有匹配源值的所有可能性，而
    Rust 不允许可能因为变量值改变而失败的 `let` 语句。想象一下这可能会造成多大的麻烦！
- en: The Rust compiler refers to being able to handle all of the possibilities when
    pattern matching as **covering**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器将模式匹配时能够处理所有可能性称为 **覆盖**。
- en: For patterns that might or might not match the input value, we can use `if let`
    expressions instead.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能匹配或不匹配输入值的模式，我们可以使用 `if let` 表达式。
- en: Using if let expressions to test whether a pattern matches
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `if let` 表达式来测试模式是否匹配
- en: 'Using pattern matching to unpack values into multiple variables can be useful,
    but using pattern matching to make decisions is where this functionality really
    shines, as in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配将值解包到多个变量中可能很有用，但使用模式匹配来做决策才是这个功能真正发光的地方，如下面的例子所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we've defined two more variables containing `DemoStruct` values, and then
    used pattern matching to pull them back apart and assign their contained values
    to individual variables. This time, though, we did it in an `if let` expression
    instead of a `let` expression. That makes a world of difference, because now the
    pattern doesn't have to cover the whole domain of possible input values. If the
    pattern matches, the `if let` expression runs the code in its block. If the pattern
    doesn't match, then the `if let` expression doesn't run the code. It's conditional.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了包含 `DemoStruct` 值的两个更多变量，然后使用模式匹配将它们拆分开来，并将它们的值分配给单独的变量。不过，这次我们在 `if
    let` 表达式中而不是在 `let` 表达式中这样做。这有很大的不同，因为现在模式不需要覆盖所有可能的输入值域。如果模式匹配成功，`if let` 表达式就会运行其块中的代码。如果模式不匹配，那么
    `if let` 表达式就不会运行代码。它是条件性的。
- en: Since the pattern doesn't have to cover the domain, it means we can use `63`
    as a pattern to match against the `id` value, and there's nothing wrong with that.
    The same principle applies to more complex patterns or any pattern that only matches
    a subset of the values that might be represented by the data type it's matched
    against.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模式不需要覆盖整个域，这意味着我们可以使用 `63` 作为模式来匹配 `id` 值，这没有什么问题。同样的原则适用于更复杂的模式或任何只匹配可能由其匹配的数据类型表示的值的子集的模式。
- en: We can combine `if let` with normal `if` and `else` expressions, to create more
    complex decision-making structures, in a couple of ways.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `if let` 与正常的 `if` 和 `else` 表达式结合，以创建更复杂的决策结构，有几种方法可以实现。
- en: First, we can put an `if let` expression inside the block of an `if`, `else
    if`, or `else` expression, and vice versa. That comes naturally, since there's
    nothing unusual about those block expressions—no special restrictions are placed
    on them just because they're inside a conditional expression.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以在 `if`、`else if` 或 `else` 表达式的块中放置一个 `if let` 表达式，反之亦然。这是自然而然的，因为那些块表达式没有什么不寻常的地方——并没有因为它们在条件表达式中而被放置特殊的限制。
- en: 'Second, we can combine `if let` or `else if let` into the same chain of options
    as `if`, `else if`, and `else`. That looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以将 `if let` 或 `else if let` 与 `if`、`else if` 和 `else` 结合到同一个选项链中。这看起来是这样的：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The chain has to start with an `if` or `if let` expression (whichever one we
    need), and can then have any number of `else if` or `else if let`, and finally
    an `else if` expression we need one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 链必须以`if`或`if let`表达式（ whichever one we need）开始，然后可以有任意数量的`else if`或`else if
    let`，最后是一个我们需要的`else if`表达式。
- en: We're still just pulling data values out of our structures with the pattern
    matching, though. We can do more when the pattern is matched against other kinds
    of data type. An important one is the `Result` data type we've talked about previously.
    Remember that `Result` can be either `Ok` or `Err`, and either way it contains
    a value, either a result value or an error value of some sort. We saw before how
    to use the `?` or assorted functions to deal with `Result`, but we can also handle
    it with pattern matching, and that's often going to be the way we'll choose.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然只是使用模式匹配从我们的结构中提取数据值。当模式与其他数据类型匹配时，我们可以做更多的事情。一个重要的是我们之前讨论过的`Result`数据类型。记住，`Result`可以是`Ok`或`Err`，无论哪种方式，它都包含一个值，要么是结果值，要么是某种错误值。我们之前看到如何使用`?`或各种函数来处理`Result`，但我们也可以使用模式匹配来处理它，这通常是我们选择的方式。
- en: 'So, here''s a function that constructs a `DemoStruct` value for us, but it
    only does it if the `id` value we ask for is even (the remainder when divided
    by two is zero). This function gives us a `Result` containing the created `DemoStruct`
    value or an error message:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有一个函数为我们构建`DemoStruct`值，但它只在我们请求的`id`值是偶数（除以二的余数为零）时才这样做。这个函数给我们一个包含创建的`DemoStruct`值或错误信息的`Result`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we then call that function, we can use pattern matching to figure out if
    it succeeded or failed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用该函数，我们可以使用模式匹配来确定它是否成功或失败：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we're calling `might_fail` twice, once with an odd number as the parameter
    value, and once with an even one. Both times, we use pattern matching to check
    whether the result is `Ok` and assign the contained value to a variable called
    `x` if it is.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们两次调用`might_fail`，一次使用奇数作为参数值，一次使用偶数。两次都使用模式匹配来检查结果是否为`Ok`，如果是，就将包含的值赋给一个名为`x`的变量。
- en: '`Ok` is not a data structure and neither is `Err`. We''ll learn more about
    what they are in the next chapter. The point for now is that pattern matching
    gives us a simple way to check whether `Result` represents a success or a failure,
    and to handle one or both cases easily.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ok`不是一个数据结构，`Err`也不是。我们将在下一章中了解更多关于它们的信息。现在重要的是，模式匹配给我们提供了一个简单的方法来检查`Result`是否表示成功或失败，并且可以轻松地处理一个或两个情况。'
- en: Using match to choose one of several patterns
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`match`选择多个模式之一
- en: 'You might have noticed in our previous example that we did not handle the case
    where the function returned an error value. In part, that''s because handling
    that situation with `if let` is a little bit awkward. We could do this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在我们的前一个例子中，我们没有处理函数返回错误值的情况。部分原因是使用`if let`处理这种情况有点尴尬。我们可以这样做：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But that runs the function twice when it doesn''t have to, so it''s inefficient.
    We could fix that by doing this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样会不必要地运行函数两次，所以这是低效的。我们可以通过这样做来修复它：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's better, but variables are for storing information and we don't really
    need the `result` value anymore once we've checked for the success or failure
    of the function, so there's no reason to keep storing it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好，但变量是用来存储信息的，一旦我们检查了函数的成功或失败，就不再需要`result`值了，所以没有必要继续存储它。
- en: 'We can use a `match` expression for situations like this, for the best results:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`match`表达式来处理这种情况，以获得最佳结果：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A `match` expression matches a single value (in this case, the result of calling
    `might_fail(39)`) against multiple patterns, until it finds a pattern that successfully
    matches the value, then runs the code block associated with that particular pattern.
    The patterns are matched from top to bottom so, normally, we put the most specific
    patterns first and the most generic patterns last.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`表达式会将单个值（在这种情况下，调用`might_fail(39)`的结果）与多个模式进行匹配，直到找到一个成功匹配该值的模式，然后运行与该特定模式关联的代码块。模式是从上到下进行匹配的，因此通常我们将最具体的模式放在前面，最通用的模式放在后面。'
- en: Individual patterns in a `match` expression don't have to cover all of the possibilities
    for the value, but all of them together need to. If `Result` had three possibilities
    instead of two (
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`表达式中的单个模式不需要涵盖所有可能的价值，但所有模式加在一起需要涵盖。'
- en: '`Ok`, `Err`, and a hypothetical `Dunno`, for example), then our previous match
    expression would not compile, because we hadn''t told it what to do in the case
    of `Dunno`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ok`、`Err`以及假设的`Dunno`（例如），那么我们之前的匹配表达式将无法编译，因为我们没有告诉它在`Dunno`的情况下应该做什么。'
- en: That's a difference from a series of `if let` and `el`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这与一系列的`if let`和`el`不同
- en: '`se if let`, which are free to ignore as many possibilities as they want. If
    we use `match`, the compiler will tell us if we''ve missed a possibility, so we
    should always use `match` when we intend to handle all of the options. On the
    other hand, `if let` is for cherry-picking one or a few special cases.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`se if let`，可以自由忽略他们想要的任何可能性。如果我们使用`match`，编译器会告诉我们是否遗漏了可能性，所以当我们打算处理所有选项时，我们应该始终使用`match`。另一方面，`if
    let`用于挑选一个或几个特殊情况。'
- en: Using don't care in patterns
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模式中使用“无关紧要”
- en: 'Sometimes, the trick that variable''s names have of matching any value in a
    pattern would be useful, but we don''t actually need the information that would
    be stored in the variable. For example, we might not care about the error value
    when matching `Result`, just the fact that there was an error. In that situation,
    we can use an `_` symbol to indicate *I don''t care what this value is*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，变量的名称在模式中匹配任何值的技巧可能很有用，但我们实际上并不需要存储在变量中的信息。例如，在匹配`Result`时，我们可能不在乎错误值，只在乎确实发生了错误。在这种情况下，我们可以使用`_`符号来表示“我不在乎这个值是什么”：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That''s the reason why `_` by itself can not be used as a variable name: it
    has a special meaning of its own. We can match `_` against any data value of any
    data type, even multiple times in the same expression, and the matched values
    will simply be ignored.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`_`本身不能用作变量名的原因：它有自己的特殊含义。我们可以将`_`与任何数据类型的任何数据值匹配，甚至在同一个表达式中多次匹配，匹配的值将被简单地忽略。
- en: Matching a value to `_` does not even move or copy the value. When we tell the
    compiler that we don't care about a value, it believes us. However, there's an
    intermediate level between a full variable and a *don't care.* If we start a variable
    name with an `_` but continue on after that with a valid variable name, the named
    variable isn't a *don't car*e but it *is* exempt from some compiler warnings.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将值匹配到`_`上甚至不会移动或复制该值。当我们告诉编译器我们不在乎一个值时，它会相信我们。然而，在完整变量和“无关紧要”之间有一个中间级别。如果我们从一个以`_`开头的变量名开始，但在之后继续使用有效的变量名，那么这个命名变量不是一个“无关紧要”的变量，但它确实可以免于一些编译器的警告。
- en: For example, normally, the compiler would warn us if we received a value into
    a variable but then did nothing with it. Putting an `_` at the start of the variable
    name means the compiler will not complain about that. Where `_` by itself means
    *I don't care about this value*, starting a variable name with `_` means *it's
    okay if I don't use this value.*
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通常情况下，如果我们将一个值放入变量中但随后没有对其进行任何操作，编译器会警告我们。将`_`放在变量名开头意味着编译器不会对此提出异议。当`_`单独使用时意味着“我不在乎这个值”，而以`_`开头的变量名意味着“即使我不使用这个值也行”。
- en: A common use for that is when we are designing for the future. We might anticipate
    that a function parameter or structure member will be useful in the future, so
    we put it in now, but don't use it yet. If we prefix the name with `_`, the compiler
    won't yell at us about it. Then, when the time comes to actually use it, we remove
    the `_` so we benefit from all of the compiler's checks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法的一个常见场景是我们为未来设计。我们可能预计一个函数参数或结构成员将在未来变得有用，所以我们现在就把它放进去，但还没有使用它。如果我们用`_`作为名称的前缀，编译器就不会为此而对我们大喊大叫。然后，当真正需要使用它的时候，我们移除`_`，这样我们就可以从编译器的所有检查中受益。
- en: 'In the previous example, we used `_` to match against the error value, meaning
    we don''t care what the error value actually is, as long as it''s an error. However,
    `_` can match *anything*, which means we can also do this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`_`来匹配错误值，这意味着我们不在乎错误值实际上是什么，只要它是错误即可。然而，`_`可以匹配任何东西，这意味着我们也可以这样做：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the last pattern in our `match` is an `_`, which matches anything while
    capturing no data at all. This is very much like putting `else` at the end of
    an `if` chain. Any match expression containing an `_` pattern automatically covers
    the entire space of possible values, too, which means that, as long as there *is*
    a reasonable fallback action to take when none of the more precise patterns match,
    Rust won't complain to us that we're not covering all of the possibilities.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们`match`中的最后一个模式是一个`_`，它匹配任何东西，但根本不捕获任何数据。这非常类似于在`if`链的末尾放置`else`。任何包含`_`模式的匹配表达式也会自动覆盖所有可能值的整个空间，这意味着只要存在一个合理的回退操作来处理没有更精确的模式匹配的情况，Rust就不会向我们抱怨我们没有覆盖所有可能性。
- en: By the way, if we put a plain `_` pattern anywhere but at the bottom of the
    `match` expression, Rust will warn us. This is a good thing, because any patterns
    under it will never, ever get a chance to match.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果我们不在`match`表达式的底部而是其他任何地方放置一个普通`_`模式，Rust会警告我们。这是好事，因为其下的任何模式永远不会有机会匹配。
- en: Moving and borrowing in pattern matches
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配中的移动和借用
- en: 'When we match a pattern that contains variables, the matching data values are
    moved into the variables (unless their data type has the `Copy` trait). For example,
    this will cause the compiler to report an error, even though at first glance it
    seems reasonable, especially for people who are used to other programming languages:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们匹配包含变量的模式时，匹配的数据值会被移动到变量中（除非它们的类型具有`Copy`特性）。例如，这会导致编译器报告错误，尽管乍一看这似乎是合理的，尤其是对于习惯于其他编程语言的人来说：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The problem is that, after the `if let`, `source5.name` does not (or at least
    might not) contain a value anymore, because that value was moved to the `x` variable.
    The compiler can't be sure that the final `println!` command will always be valid,
    which is a problem because it happens whether the `if let` block gets run or not.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，在`if let`之后，`source5.name`不再（或者至少可能不再）包含一个值，因为那个值已经被移动到`x`变量中。编译器不能确定最终的`println!`命令始终有效，这是一个问题，因为无论`if
    let`块是否运行，都会发生。
- en: 'Can we borrow the value in `if let`, instead of moving it? That way, future
    uses of the value would still be valid. The answer is yes, but there''s a problem
    we need to get a handle on. We can try this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否在`if let`中借用值，而不是移动它？这样，未来对该值的任何使用仍然有效。答案是肯定的，但我们需要解决一个问题。我们可以尝试这样做：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But what we find is that the compiler complains that it expected `String` in
    the pattern, and found a reference instead. That's because using an `&` in the
    pattern this way doesn't mean we want to borrow the value; it means we expect
    the value to *already be a borrow* in the source data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们发现编译器抱怨它期望在模式中是`String`，而找到的是一个引用。这是因为以这种方式在模式中使用`&`并不意味着我们想要借用值；这意味着我们期望该值在源数据中已经是一个借用。
- en: 'To tell Rust that we want to borrow a value that is matched by a variable in
    a pattern, we need to use a new keyword: `ref`. That looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉Rust我们想要借用一个由模式中的变量匹配的值，我们需要使用一个新的关键字：`ref`。它看起来是这样的：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At last, the compiler is happy, and so are we. The value in `source5.name` is
    not a borrow, but when we match `source5` to our pattern, we borrow it into the
    `x` variable, which means it is *not* moved out of `source5`, and the final `println!`
    will always work.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编译器很高兴，我们也很高兴。`source5.name`中的值不是一个借用，但当我们将`source5`与我们的模式匹配时，我们将其借入`x`变量，这意味着它*不是*从`source5`中移出，并且最终的`println!`将始终有效。
- en: 'The `ref` keyword and the `&` symbol are closely related. These two lines of
    code do exactly the same thing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`关键字和`&`符号密切相关。这两行代码完全做同样的事情：'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The difference between them is syntactic: we apply the `ref` keyword to the
    variable where the borrow *will be stored*, while we apply the `&` symbol to the
    variable where the value to be borrowed *is already stored*. We choose which one
    to use based on which end of the borrow we''re writing, and we don''t need both.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的区别在于语法：我们将`ref`关键字应用于借用*将要存储*的变量，而我们将`&`符号应用于值*已经存储*的变量。我们根据我们正在编写的借用的哪一端来选择使用哪一个，我们不需要两者都使用。
- en: 'In fact, using both creates a borrow *of a borrow* of the original value, which
    is not usually what we want. The Rust compiler can automatically dereference any
    number of layers of borrowing in order to find the value it needs for a function
    parameter, so something like this works fine without causing any errors:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，同时使用这两种模式会创建原始值的借用借用，这通常不是我们想要的。Rust编译器可以自动解引用任意层次的借用，以找到函数参数所需的价值，因此像这样的事情可以正常工作而不会引起任何错误：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The compiler sees that the `borrow_demostruct` function wants a borrow of `DemoStruct`,
    and that the value we're trying to send it is a borrow of a borrow of a `DemoStruct`,
    so it dereferences that value once and passes that to the function parameter.
    Everything works.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器看到`borrow_demostruct`函数需要`DemoStruct`的借用，而我们试图传递给它的值是`DemoStruct`的借用借用，因此它对该值进行了一次解引用，并将其传递给函数参数。一切正常。
- en: '*What does a borrow of a borrow* means? Well, first of all, we had a `DemoStruct`
    value. Then, we borrowed it, giving us an `&DemoStruct` value. Then, we borrowed
    *that* value, giving us an `&&DemoStruct` value.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*“借用借用”是什么意思？好吧，首先，我们有一个`DemoStruct`值。然后，我们借用了它，得到了一个`&DemoStruct`值。然后，我们又借用了*那个*值，得到了一个`&&DemoStruct`值。'
- en: However, the computer had to put in a little more effort than was necessary
    to achieve the same result. Multiple levels of borrowing should only be used when
    they solve a problem, because using them when we don't need them is just wasteful.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，计算机必须付出比必要的更多努力才能达到相同的结果。多层借用只有在解决问题时才应该使用，因为在不必要的时候使用它们只是浪费。
- en: Also, `&&DemoStruct` is not actually the same data type as `&DemoStruct`, despite
    the fact that the Rust compiler can figure out how to treat the former as the
    latter when it's used as a function parameter. Sometimes, that matters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`&&DemoStruct`实际上并不与`&DemoStruct`是相同的数据类型，尽管Rust编译器可以在将其用作函数参数时将其视为后者。有时这很重要。
- en: Matching tuples and other more complex patterns
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配元组和更复杂的模式
- en: Matching simple patterns is very useful, but there's more that we can do. Patterns
    can be more complex, consisting of representations of several layers of nested
    data structures and other data types. Patterns can assign to a variable name while
    still looking deeper into the structure to make sure the contained information
    matches what we want. Or patterns can be simplified, checking only a few parts
    of the data structure and ignoring the rest.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配简单模式非常有用，但我们还能做更多。模式可以更复杂，由多层嵌套数据结构和其他数据类型的表示组成。模式可以在深入结构的同时将变量名分配给变量，以确保包含的信息符合我们的要求。或者模式可以被简化，只检查数据结构的一小部分，忽略其余部分。
- en: Nested patterns
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套模式
- en: 'We can use pattern matching to pull a value out of a complex data structure.
    As long as the pattern matches the data value, it doesn''t matter how complex
    the pattern and value are. If we want to match a tuple of tuples and extract one
    particular value from one of the inner tuples, we can do it like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模式匹配从复杂的数据结构中提取值。只要模式匹配数据值，模式和价值有多复杂就无关紧要。如果我们想匹配元组元组并从内部元组中提取一个特定的值，我们可以这样做：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This pattern matches any tuple of three elements, where the second element is
    a nested tuple of four elements, and stores the second element of that nested
    tuple in the `x` variable, then prints out the value of `x`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图案匹配任何有三个元素的元组，其中第二个元素是一个包含四个元素的嵌套元组，并将嵌套元组的第二个元素存储在`x`变量中，然后打印出`x`的值。
- en: We could have been even more specific, and replaced some of those `_` with more
    detailed sub-patterns to match. That would have given us a pattern that paid more
    attention to the first and/or last elements out the outer tuple, or the other
    elements of the inner tuple.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更加具体，将一些`_`替换为更详细的子模式以匹配。这将给我们一个更加关注外部元组的第一个和/或最后一个元素，或者内部元组的其他元素的图案。
- en: 'We can use the same technique to dig into other data types, too; it''s not
    limited to tuples. For example, earlier we used pattern matching to check whether
    a function had succeeded or failed to run properly:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用同样的技术来深入其他数据类型，这不仅仅限于元组。例如，之前我们使用模式匹配来检查一个函数是否成功或失败地正确运行：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In that code, we just match the success value to the `x` variable, but what
    if we wanted to handle things differently depending on the details of the success
    value? We can do that by making the contained value match a more detailed sub-pattern:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在那段代码中，我们只是将成功值匹配到`x`变量，但如果我们想根据成功值的细节以不同的方式处理事情怎么办？我们可以通过使包含的值匹配一个更详细的子模式来实现这一点：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have a pattern that matches when the function returns a success *and*
    the success values is a `DemoStruct` with the proper ID, a second pattern that
    matches when the function return a success and the success value is a `DemoStruct`
    no matter what the ID is, and a third pattern that matches any error the function
    might return.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个模式，当函数返回成功并且成功值是一个具有正确ID的`DemoStruct`时匹配，第二个模式匹配当函数返回成功并且成功值是一个无论ID是什么的`DemoStruct`时，第三个模式匹配函数可能返回的任何错误。
- en: The first pattern matches the expected case. If it doesn't match, the second
    pattern matches, allowing us to deal with an unexpected result that is still technically
    reported as a success. If neither of those patterns match, the third one handles
    explicit errors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模式匹配预期的情况。如果它不匹配，第二个模式匹配，允许我们处理技术上报告为成功但意外的结果。如果这两个模式都不匹配，第三个模式处理显式错误。
- en: 'If we compile this example, it works fine, but the compiler warns us that the
    `name:` in the first pattern and the `id:` and `name:` in the second pattern are
    redundant. That''s because, when we are initializing a data structure or data
    structure pattern in Rust, we can leave out the destination name if it''s the
    same as the source name. In other words, the second pattern could have been written
    like `Ok(DemoStruct {ref id, ref name, probability: _})` and Rust still would
    have understood it, because `id` and `name` are the names of two of the structure''s
    contained variables. The redundancy warning is just telling us that we wrote more
    than we needed to.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们编译这个示例，它将正常工作，但编译器会警告我们第一个模式中的`name:`和第二个模式中的`id:`和`name:`是冗余的。这是因为当我们初始化Rust中的数据结构或数据结构模式时，如果目标名称与源名称相同，我们可以省略目标名称。换句话说，第二个模式可以写成`Ok(DemoStruct
    {ref id, ref name, probability: _})`，Rust仍然会理解它，因为`id`和`name`是结构包含的变量的名称之一。冗余警告只是告诉我们我们写多了。'
- en: Storing a matched value and comparing it to a pattern
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储匹配的值并将其与模式进行比较
- en: Normally, we either use a variable name to match part of a data value, or we
    use a structural pattern to check that it's the right "shape" and use variable
    names inside that structural pattern to match and extract the parts of it we're
    interested in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们要么使用变量名来匹配数据值的一部分，要么使用结构模式来检查它是否是正确的“形状”，并在该结构模式内部使用变量名来匹配和提取我们感兴趣的该结构的一部分。
- en: 'We can do both at the same time, though, by using the `@` symbol:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过使用`@`符号同时进行这两项操作：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, here we have a pattern that matches a 3-tuple that has `1` as its first
    item, a 2-tuple as its second item, and anything as its third item, and stores
    the second item (which it has confirmed is a 2-tuple) in a variable called `x`.
    The variable name to store into came before the `@`, and the pattern to check
    the match against came after.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们有一个匹配3元组且第一个元素为`1`，第二个元素为2元组，第三个元素为任何内容的模式，并将第二个元素（它已确认是一个2元组）存储在名为`x`的变量中。要存储的变量名在`@`之前，要检查匹配的模式在`@`之后。
- en: Ignoring most of a data structure
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略数据结构的大部分内容
- en: Some data structures contains a great many data values, and it would be inconvenient
    to have to go through and list each one of them in each pattern we want to match
    against. Fortunately, Rust has a shorthand syntax that means *everything else
    is a don't care.*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据结构包含大量数据值，如果需要在每个我们想要匹配的模式中逐一列出它们，将会非常不方便。幸运的是，Rust有一个简写语法，意味着“其他所有内容都是无关紧要的”。
- en: 'To do that, we can include `..` at the end of the pattern, like so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以在模式的末尾包含`..`，如下所示：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That has the same effect as listing out all of the structure's contained variables,
    *except* the ones we've explicitly described in the pattern, and matching each
    one to an `_`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '这与列出结构中包含的所有变量具有相同的效果，*除了*我们在模式中明确描述的那些，并将每个与`_`匹配。 '
- en: Gotchas
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意事项
- en: There are some seemingly reasonable things we might try to do with pattern matching
    that don't work as we might expect. We're going to take a look at those, and work
    out what they're actually doing and why Rust works that way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式匹配中，我们可能会尝试一些看似合理的事情，但它们可能不会像我们预期的那样工作。我们将查看这些情况，弄清楚它们实际上在做什么以及为什么Rust会那样工作。
- en: Not all values can be matched against a literal pattern
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并非所有值都可以与字面量模式匹配
- en: In all of our examples so far, when we matched `DemoStruct` in a pattern, we
    matched `probability` to a variable or to `_`. That's because `probability` is
    a floating point number, which means that two values that are functionally identical
    might not compare as exactly equal.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的所有例子中，当我们在一个模式中匹配 `DemoStruct` 时，我们将 `probability` 匹配到一个变量或 `_`。这是因为 `probability`
    是一个浮点数，这意味着两个在功能上相同的值可能不会完全相等。
- en: 'If we try to use a floating-point literal in a pattern (in Rust 1.29), we see
    a warning like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在模式中使用浮点数字面量（在 Rust 1.29 中），我们会看到一个像这样的警告：
- en: '![](img/d802e4d9-ae92-440e-be76-4bd0f24fff56.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d802e4d9-ae92-440e-be76-4bd0f24fff56.png)'
- en: It's just a warning but, as the warning says, it's going to become an error
    as Rust evolves. We should treat it as an error, regardless, because the pattern
    will likely not work properly even though it (currently) compiles.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个警告，但正如警告所说，随着 Rust 的发展，它将成为一个错误。无论如何，我们都应该将其视为错误，因为即使它（目前）可以编译，模式可能也无法正常工作。
- en: The reason for that, in this case, is that floating point numbers are approximate.
    They have to fit into a finite number of bits, so they have to be rounded sometimes.
    That can result in numbers that should be identical in a purely mathematical sense
    being different because their representations differ in the least significant
    bits. The least significant bits usually make such a tiny difference that rounding
    errors don't much matter, but they can throw off an equality comparison.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，原因是因为浮点数是近似的。它们必须适应有限数量的位，所以有时必须进行舍入。这可能导致在纯粹数学意义上应该相同的数字因为它们在最低有效位上的表示不同而不同。最低有效位通常造成的差异非常小，以至于舍入误差并不重要，但它们可能会破坏相等比较。
- en: The upshot is that if we try to use a literal in a pattern that isn't safe to
    use, Rust will warn us or give us an error. As usual, Rust isn't willing to let
    a potential problem go unremarked.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，如果我们试图在一个不安全的模式中使用字面量，Rust 将会警告我们或给出错误。像往常一样，Rust 不愿意让潜在的问题不被注意。
- en: If we need to do something like this, we can use match guards to work around
    the limitation. We're about to learn about them, so keep reading!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要做类似的事情，我们可以使用匹配守卫来绕过限制。我们即将学习它们，所以请继续阅读！
- en: Patterns assign values to variable names
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式将值分配给变量名
- en: 'When we use a variable name in a pattern, it matches any value and the matched
    value is stored in the variable. That means that if we were to try this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在模式中使用变量名时，它会匹配任何值，并且匹配的值会被存储在变量中。这意味着如果我们尝试这样做：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We do not get a pattern that compares the `source6.id` value to the value of
    `x` (five in this case), we don't get what we expect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有得到一个将 `source6.id` 的值与 `x` 的值（在这个例子中是五个）进行比较的模式，我们没有得到我们期望的结果。
- en: 'Instead, we get an error saying that the pattern is irrefutable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们会得到一个错误，说模式是不可反驳的：
- en: '![](img/26141fa5-0377-47e6-b6f0-27d06a006fe6.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26141fa5-0377-47e6-b6f0-27d06a006fe6.png)'
- en: Irrefutable means the pattern will never fail to match, which is a problem in
    an `if let` expression.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不可反驳意味着模式永远不会失败匹配，这在 `if let` 表达式中是一个问题。
- en: 'If we try a similar pattern that it is refutable, but still uses the `x` variable,
    the program compiles, but the pattern matches when we didn''t want it to:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试一个类似的模式，它是可反驳的，但仍然使用 `x` 变量，程序可以编译，但模式匹配时我们并不希望它匹配：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Both of these situations arise because of a rule we already talked about: variable
    names used in patterns match any value, and store the matched value into a new
    variable with the given name. If we think about it, that implies that if there''s
    already a variable with that name, its current value doesn''t matter.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都源于我们之前提到的一条规则：在模式中使用的变量名匹配任何值，并将匹配的值存储为具有给定名称的新变量。如果我们仔细想想，这意味着如果已经存在具有该名称的变量，其当前值并不重要。
- en: 'That doesn''t mean we''re entirely out of luck, though. We can use an extension
    of the `match` syntax to involve existing variables in the decision:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不意味着我们完全无望，但我们可以使用 `match` 语法的扩展来涉及现有变量在决策中：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What we're doing here is applying a **match guard** to the pattern. We do that
    by putting the `if` keyword after the pattern, but before the `=>`, and following
    it up with a Boolean expression. This lets us add non-pattern matching criteria
    to a match branch. In this case, we're saying that if the pattern matches and the
    ID (stored in `y`) matches the value stored in `x`, we should run that block of
    code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将**匹配守卫**应用于模式。我们通过在模式之后但在`=>`之前放置`if`关键字，并随后跟上一个布尔表达式来实现这一点。这让我们能够向匹配分支添加非模式匹配标准。在这种情况下，我们说如果模式匹配并且ID（存储在`y`中）与存储在`x`中的值匹配，我们应该运行那块代码。
- en: There has been talk of creating a similar feature for `if let`, but mostly people
    just use nested `if` expressions or `match`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关于为`if let`创建类似功能的讨论，但大多数人只是使用嵌套的`if`表达式或`match`。
- en: When we use a match guard, we need to be especially careful that our pattern
    doesn't shadow any variable names we want to use in the guard. That's why, in
    this example, we matched the `id` of `DemoStruct` to a variable named `y` instead
    of `x`. We needed to keep `x` around so our match guard could use it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用匹配守卫时，我们需要特别注意我们的模式不要遮蔽我们想要在守卫中使用的任何变量名。这就是为什么在这个例子中，我们将`DemoStruct`的`id`与一个名为`y`的变量匹配，而不是`x`。我们需要保留`x`，以便我们的匹配守卫可以使用它。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we''ve seen how to use pattern patching to enhance our ability
    to make decisions and assign variables. In particular, we''ve learned the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用模式修补来增强我们做决策和分配变量的能力。特别是，我们学习了以下内容：
- en: How to assign *part* of a data value to a variable by matching the whole value
    to a pattern that matches the part we're interested in to a variable name
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过将整个值与一个模式匹配，该模式匹配我们感兴趣的特定部分到一个变量名，将数据值的一部分分配给一个变量
- en: How to use `if let` and `else if let` to decide whether a particular branch
    of an `if` chain should run
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`if let`和`else if let`来决定一个`if`链的特定分支是否应该运行
- en: How to use `match` to check a single value against multiple patterns
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`match`来检查单个值与多个模式
- en: How to use `_` as a *don't care* in patterns
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在模式中使用`_`作为*无关紧要*的元素
- en: The difference between a pattern that matches a borrowed value and a pattern
    that borrows a matched value
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配借用值和借用匹配值的模式之间的区别
- en: How to match patterns for complex, nested data structures
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何匹配复杂、嵌套的数据结构中的模式
- en: Surprises that can arise when we use pattern matching, and how to deal with
    them
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用模式匹配时可能出现的惊喜，以及如何处理它们
- en: We'll be seeing more pattern matching in the next chapter, when we look at enumerations,
    traits, and trait objects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我们查看枚举、特性和特对象时，我们将看到更多的模式匹配。
