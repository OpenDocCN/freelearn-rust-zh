- en: Starting Off with Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 入门
- en: The Rust ecosystem has grown considerably over the last year, and the 2018 edition,
    in particular, brought a significant push toward stabilization. The tooling is
    developing and important libraries are maturing to a point where many bigger companies
    use Rust in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去一年中，Rust 的生态系统有了显著的增长，特别是 2018 版本，它推动了稳定性的重大推进。工具正在发展，重要的库正在成熟到许多大型公司将其用于生产的程度。
- en: One of the features of Rust is a steep learning curve—which is mostly due to
    a fundamental change in how to think about memory allocation. It is not uncommon
    for experienced programmers in other languages (such as C#) to feel overwhelmed
    with the way things are done in Rust. In this chapter, we will try to overcome
    this and lower the bar to get started!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的一个特点是学习曲线陡峭——这主要归因于对内存分配方式的根本性改变。对于其他语言（如 C#）中的经验丰富的程序员来说，对 Rust 中的做法感到不知所措并不罕见。在本章中，我们将尝试克服这一点，降低入门门槛！
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Getting everything ready
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备一切就绪
- en: Working with the command line I/O
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与命令行 I/O 一起工作
- en: Creating and using data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用数据类型
- en: Controlling execution flow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制执行流程
- en: Splitting your code with crates and modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 crates 和模块拆分你的代码
- en: Writing tests and benchmarks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试和基准测试
- en: Documenting your code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录你的代码
- en: Testing your documentation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的文档
- en: Sharing code among types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同类型之间共享代码
- en: Sequence types in Rust
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 中的序列类型
- en: Debugging Rust
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 Rust
- en: Setting up your environment
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置你的环境
- en: Since the programming language comes with a variety of toolchains, tools, linkers,
    and compiler versions, choosing the best-fitting variation is not easy. Additionally,
    Rust works on all major operating systems—which adds another variable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编程语言附带各种工具链、工具、链接器和编译器版本，因此选择最适合的变体并不容易。此外，Rust 适用于所有主要操作系统——这又增加了一个变量。
- en: However, installing Rust has become a trivial task when using `rustup` ([https://rustup.rs/](https://rustup.rs/)). On
    the website, a helpful script (or installer on Windows) that takes care of retrieving
    and installing the required components can be downloaded. The same tool lets you
    switch between and update (and uninstall) these components as well. This is the
    recommended way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用 `rustup` ([https://rustup.rs/](https://rustup.rs/)) 时，安装 Rust 已经变成了一件
    trivial 的事情。在网站上，可以下载一个有用的脚本（或 Windows 上的安装程序），它会负责检索和安装所需的组件。同样的工具还允许你在这些组件之间切换、更新（以及卸载）它们。这是推荐的方式。
- en: Choosing to use the **Microsoft Visual Studio Compiler** (**MSVC**) together
    with Rust requires that you install additional software such as the Visual C++
    runtime and compiler tools.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用 **Microsoft Visual Studio Compiler**（**MSVC**）与 Rust 一起使用时，需要安装额外的软件，例如
    Visual C++ 运行时和编译器工具。
- en: 'To write code, an editor is also required. Since Visual Studio Code sports
    some Rust parts, it is a great choice together with the Rust extension. It''s
    an open source editor developed by Microsoft and is well received across the world
    and the Rust community. In this recipe, we will install the following components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写代码，还需要一个编辑器。由于 Visual Studio Code 拥有一些 Rust 功能，因此与 Rust 扩展一起使用是一个很好的选择。它是由微软开发的开源编辑器，在全球和
    Rust 社区中广受欢迎。在本食谱中，我们将安装以下组件：
- en: Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
- en: '`rustup` ([https://rustup.rs](https://rustup.rs))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustup` ([https://rustup.rs](https://rustup.rs))'
- en: '`rustc` (and the rest of the compiler toolchains)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustc`（以及编译器工具链的其他部分）'
- en: '`cargo`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo`'
- en: '**RLS** (short for **Rust Language Server**—this is for autocompletion)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RLS**（代表 **Rust Language Server**——这是用于自动完成的）'
- en: Rust language support for Visual Studio Code
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code 对 Rust 语言的支持
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: On a computer running either macOS, Linux, or Windows, only a web browser and
    internet connection are required. Bear in mind that the Windows installation works
    a little bit different from the ***nix** systems (Linux and macOS), which use
    scripts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 macOS、Linux 或 Windows 的计算机上，只需要一个网络浏览器和互联网连接。请注意，Windows 的安装方式与使用脚本的 ***nix
    系统（Linux 和 macOS）略有不同。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Each of the parts requires us to navigate to their respective websites, download
    the installer, and follow their instructions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都需要我们导航到它们各自的网站，下载安装程序，并遵循它们的说明：
- en: Open the browser and navigate to [https://rustup.rs](https://rustup.rs) and [https://code.visualstudio.com/](https://code.visualstudio.com/).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并导航到[https://rustup.rs](https://rustup.rs)和[https://code.visualstudio.com/](https://code.visualstudio.com/)。
- en: Choose the installers fit for your operating system.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择适合您操作系统的安装程序。
- en: After downloading, run the installers and follow their instructions, choosing
    the `stable` branches.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后，运行安装程序并按照它们的说明进行操作，选择`stable`分支。
- en: Once successfully installed, we'll go deeper into each installation.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功安装，我们将更深入地探讨每个安装过程。
- en: Now, let's go behind the scenes to understand the installation better
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解安装过程。
- en: Managing the Rust installation with rustup.rs
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用rustup.rs管理Rust安装
- en: 'To test whether the installation of the Rust toolchain with `rustup` was successful,
    the `rustc` command is available to run in Terminal (or PowerShell on Windows):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试使用`rustup`安装Rust工具链是否成功，可以在终端（或在Windows上的PowerShell）中运行`rustc`命令：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that you will have a later version when you are running this. It doesn't
    matter if you stick to the 2018 edition for your code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当您运行此命令时，您将有一个较新的版本。如果您坚持使用2018版代码，这无关紧要。
- en: Rust requires a native linker to be available on your system. On Linux or Unix
    systems (such as macOS), Rust calls `cc` for linking, whereas on Windows, the
    linker of choice is Microsoft Visual Studio's linker, which depends on having
    Microsoft Visual C++ Build Tools installed. While it's possible to use an open
    source toolchain on Windows as well, this exercise is left for more advanced users.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Rust需要在您的系统上安装本机链接器。在Linux或Unix系统（如macOS）上，Rust调用`cc`进行链接，而在Windows上，首选的链接器是Microsoft
    Visual Studio的链接器，这取决于是否已安装Microsoft Visual C++构建工具。虽然Windows上也可以使用开源工具链，但这种练习留给更高级的用户。
- en: 'Even with the 2018 edition, some useful features are still only available on
    `nightly`. To install the nightly edition of `rustc`, perform these steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是2018版，一些有用的功能仍然只在`nightly`版本中可用。要安装`rustc`的nightly版本，请执行以下步骤：
- en: Run `rustup install nightly` (use `nightly-msvc` on Windows if you are not using
    the GNU toolchain) in a Terminal or PowerShell window.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端或PowerShell窗口中运行`rustup install nightly`（如果您不使用GNU工具链，则在Windows上使用`nightly-msvc`）。
- en: After the command finishes, the default toolchain (used in `cargo`) can be switched
    using `rustup default nightly`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令完成后，默认工具链（在`cargo`中使用）可以使用`rustup default nightly`进行切换。
- en: Installing Visual Studio Code and extensions
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio Code和扩展
- en: 'In its vanilla version, Visual Studio Code comes with syntax highlighting for
    many languages. However, for autocompletion or/and checking syntax, an extension
    is required. The Rust project supplies this extension:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在其原始版本中，Visual Studio Code为许多语言提供了语法高亮。然而，为了自动完成或/和检查语法，需要一个扩展。Rust项目提供了这个扩展：
- en: Open Visual Studio Code.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio Code。
- en: 'Use *Ctrl* + *P* (*cmd* + *P* on macOS) to open the command-line interface,
    then type `ext install rust-lang.rust` to install the extension. The process should
    look like this:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *P* (*cmd* + *P*在macOS上)打开命令行界面，然后输入`ext install rust-lang.rust`来安装扩展。过程应如下所示：
- en: '![](img/dc247be2-1a02-41f7-9177-8f0bbc864424.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc247be2-1a02-41f7-9177-8f0bbc864424.png)'
- en: 'The extension uses RLS to do static code analysis and provide completion and
    syntax checking. The extension *should* install the RLS component automatically,
    but sometimes it will fail to do this. One solution is to add the following configuration
    to Visual Studio Code''s `settings.json` file (use *Ctrl* *+* *P*/*cmd* *+* *P*
    to find it):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展使用RLS进行静态代码分析并提供自动完成和语法检查。扩展*应该*自动安装RLS组件，但有时它将无法完成此操作。一种解决方案是将以下配置添加到Visual
    Studio Code的`settings.json`文件中（使用*Ctrl* *+* *P*/*cmd* *+* *P*来查找它）：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Alternatively, `rustup` will also install RLS with the `rustup component add
    rls` command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`rustup`也会通过`rustup component add rls`命令安装RLS。
- en: Troubleshooting
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'Occasionally, updating the tools will lead to errors that files are missing
    or cannot be overwritten. This can be for a wide range of reasons, but a full
    reset of the installations can help. On Linux or macOS systems, the following
    command takes care of deleting anything `rustup` installed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，更新工具会导致错误，例如文件丢失或无法覆盖。这可能是由多种原因造成的，但完全重置安装可以帮助解决问题。在Linux或macOS系统上，以下命令负责删除`rustup`安装的所有内容：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Windows''s PowerShell now supports many Linux-like commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Windows的PowerShell现在支持许多类似Linux的命令：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This leads to the same result. After deleting the current installation, install
    `rustup` from scratch—this should install the latest version.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致相同的结果。在删除当前安装后，从头开始安装`rustup`——这应该会安装最新版本。
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码背后的原理。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The shell script, `rustup.sh`, is a great way to install Rust and it is the
    primary way to install Rust and other components today. In fact, it is common
    to use the script also in CI systems to install the compiler and other tools.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本`rustup.sh`是安装 Rust 的好方法，也是今天安装 Rust 和其他组件的主要方式。实际上，在 CI 系统中通常也会使用这个脚本安装编译器和其它工具。
- en: '`rustup` is an open source project maintained by the Rust project and can be
    found on GitHub: [https://github.com/rust-lang/rustup.rs](https://github.com/rust-lang/rustup.rs).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustup`是一个由 Rust 项目维护的开源项目，可以在 GitHub 上找到：[https://github.com/rust-lang/rustup.rs](https://github.com/rust-lang/rustup.rs)。'
- en: We've successfully learned how to set up our environment. Now let's move on
    to the next recipe.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何设置我们的环境。现在让我们继续到下一个菜谱。
- en: Working with the command line I/O
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行 I/O
- en: The traditional way of communicating with the user on the command line is using
    standard streams. Rust includes helpful macros to deal with these simple cases.
    In this recipe, we will explore the basic workings of the classic `Hello World` program.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上与用户通信的传统方式是使用标准流。Rust 包含了一些有用的宏来处理这些简单情况。在这个菜谱中，我们将探索经典`Hello World`程序的基本工作原理。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In just five steps, we will explore command line I/O and formatting:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 只需五步，我们将探索命令行 I/O 和格式化：
- en: Open a Terminal window (PowerShell on Windows) and run the `cargo new hello-world`
    command, which creates a new Rust project in a `hello-world` folder.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口（Windows上的 PowerShell）并运行`cargo new hello-world`命令，它将在`hello-world`文件夹中创建一个新的
    Rust 项目。
- en: 'Once created, change into the directory with `cd hello-world` and open `src/main.rs`
    with a Visual Studio Code. The default code generated by `cargo` looks like this:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建，使用`cd hello-world`切换到目录，并用 Visual Studio Code 打开`src/main.rs`。`cargo`默认生成的代码如下：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s expand it! These are variations on the preceding traditional `print`
    statement, showing some formatting options, parameters, and writing on streams,
    among other things. Let''s start with some common prints (and imports):'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们扩展它！这些是前面传统`print`语句的变体，展示了格式化选项、参数和写入流等。让我们从一些常见的打印（和导入）开始：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, we can do much more complex argument combinations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以做更多复杂的参数组合：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This should provide several variations of reading and writing to the console.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该提供了几种读取和写入控制台的不同变体。
- en: Go back to Terminal and navigate to the directory where `Cargo.toml` is located.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到终端并导航到`Cargo.toml`所在的目录。
- en: 'Use `cargo run` to see the snippet''s output:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo run`来查看代码片段的输出：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each line in the output represents a way to print text to the console! We recommend
    playing with the variations and seeing how it changes the result. On a side note, `rustc`
    will check for the correct number of arguments in any `println!()` or `format!()` call.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的每一行都代表了一种将文本打印到控制台的方法！我们建议尝试不同的变体，看看它是如何改变结果的。顺便说一下，`rustc`会在任何`println!()`或`format!()`调用中检查正确的参数数量。
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码背后的原理。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's go through the code to understand the execution flow.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析代码以了解执行流程。
- en: '`cargo` is described in depth in [Chapter 2](cdcbf36d-9343-4b7b-ace1-b4c570dab62c.xhtml), *Managing
    Projects with Cargo*, in this book.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo`在本书的[第 2 章](cdcbf36d-9343-4b7b-ace1-b4c570dab62c.xhtml)，*使用 Cargo 管理项目*中进行了深入描述。'
- en: 'The initial snippet is generated when `cargo new hello-world` is executed in
    *step 1*. As a project of type binary, a `main` function is required and `rustc` will
    be looking for it. Upon calling `cargo run`, `cargo` orchestrates compilation
    (with `rustc`) and linking (`msvc` on Windows, `cc` on *nix) and runs the resultant
    binary via its entry point: the `main` function (*step 5*).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 初始片段是在*步骤 1*中执行`cargo new hello-world`时生成的。作为一个二进制类型的项目，需要一个`main`函数，`rustc`将会寻找它。在调用`cargo
    run`时，`cargo`会协调编译（使用`rustc`）和链接（在 Windows 上是`msvc`，在*nix*上是`cc`），并通过其入口点：`main`函数运行生成的二进制文件（*步骤
    5*）。
- en: In the function we create in *step 3*, we write a series of `print!`/`println!`/`eprintln!`
    statements, which are Rust macros. These macros facilitate the writing to the
    standard output or standard error channels of a command-line application and include
    additional arguments. In fact, if arguments are missing, the compiler won't compile
    the program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的*步骤3*中的函数中，我们编写了一系列`print!`/`println!`/`eprintln!`语句，这些是Rust宏。这些宏简化了写入命令行应用程序的标准输出或标准错误通道的编写，并包括额外的参数。实际上，如果缺少参数，编译器将不会编译程序。
- en: Rust's macros work directly on the syntax tree of the language, providing type
    safety and the ability to check the parameters and arguments. Therefore, they
    can be seen as a function call with a few special abilities—but more on that in
    [Chapter 6](a8fae7de-6021-4d6e-9c75-e24288bc92e7.xhtml), *Expressing Yourself
    with Macros*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的宏直接作用于语言的语法树，提供类型安全和检查参数和参数的能力。因此，它们可以被视为具有一些特殊能力的函数调用——更多关于这一点将在[第6章](a8fae7de-6021-4d6e-9c75-e24288bc92e7.xhtml)中介绍，*使用宏表达自己*。
- en: The various arguments and the template string are combined using formatters,
    a powerful way to add real variables to the output without the need of concatenations
    or similar workarounds. This will reduce the number of allocations, considerably
    improving performance and memory efficiency. There is a wide range of how to format
    data types; to understand it more deeply, check out Rust's excellent documentation
    ([https://doc.rust-lang.org/std/fmt/](https://doc.rust-lang.org/std/fmt/)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 各种参数和模板字符串通过格式化器组合，这是一种强大的方法，可以在不需要连接或类似解决方案的情况下将实际变量添加到输出中。这将减少分配的数量，显著提高性能和内存效率。格式化数据类型的方法有很多；要深入了解，请查看Rust的优秀文档([https://doc.rust-lang.org/std/fmt/](https://doc.rust-lang.org/std/fmt/))。
- en: The last step then shows the output that the various combinations produced.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步展示了各种组合产生的输出。
- en: We've successfully learned to work with the command line I/O. Now, let's move
    on to the next recipe.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用命令行I/O。现在，让我们继续到下一个菜谱。
- en: Creating and using data types
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用数据类型
- en: 'Rust features all of the basic types: signed and unsigned integers up to 64
    bits in width; floating-point types up to 64 bits; character types; and Booleans.
    Of course, any program will need more complex data structures to remain readable.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Rust具有所有基本类型：64位宽度的有符号和无符号整数；64位浮点类型；字符类型；以及布尔类型。当然，任何程序都需要更复杂的数据结构以保持可读性。
- en: If you are unfamiliar with unit tests in Rust (or in general), we suggest going
    through the *Writing tests and benchmarks* recipe here in this chapterfirst.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Rust中的单元测试（或一般而言）不熟悉，我们建议您首先阅读本章中的*编写测试和基准*菜谱。
- en: In this recipe, we'll look at good basic practices to create and use data types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨创建和使用数据类型的一些良好基本实践。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s use Rust''s unit tests as a playground for some data type experiments:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Rust的单元测试作为一些数据类型实验的游乐场：
- en: Create a new project using `cargo new data-types -- lib` and use an editor to
    open the `projects` directory.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new data-types -- lib`创建一个新的项目，并使用编辑器打开`projects`目录。
- en: Open `src/lib.rs` in your favorite text editor (Visual Studio Code).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您最喜欢的文本编辑器（Visual Studio Code）中打开`src/lib.rs`。
- en: 'In there, you will find a small snippet to run a test:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那里，您将找到一个运行测试的小片段：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s replace the default test to play with various standard data types. This
    test uses a few ways to work with data types and their math functions, as well
    as mutability and overflows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们替换默认测试，以玩转各种标准数据类型。这个测试使用了几种处理数据类型及其数学函数的方法，以及可变性和溢出：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Having the basic numeric types covered, let''s check a major limitation: overflows!
    Rust panics when an overflow occurs, so we are going to expect that with the `#[should_panic]`
    attribute (the test will actually fail if it doesn''t panic):'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在覆盖了基本的数值类型之后，让我们检查一个主要限制：溢出！当发生溢出时，Rust会恐慌，因此我们将期望使用`#[should_panic]`属性（如果它没有恐慌，测试实际上会失败）：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, let''s create a custom type as well. Rust''s types are `structs` and
    they add no overhead in memory. The type features a `new()` (constructor by convention)
    and a `sum()` function, both of which we''ll call in a test function:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个自定义类型。Rust的类型是`struct`，它们在内存中不增加开销。该类型具有一个`new()`（按惯例的构造函数）和一个`sum()`函数，我们将在测试函数中调用这两个函数：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To see the new `struct` function in action, let''s add a test to do some and
    clone memory tricks with types (note: pay attention to the asserts):'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看到新的`struct`函数的实际应用，让我们添加一个测试来对类型进行一些操作并克隆内存技巧（注意：请注意断言）：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, let''s see whether all of that works. Run `cargo test` in the `data-types`
    directory and you should see the following output:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们看看所有这些是否都有效。在`data-types`目录中运行`cargo test`，你应该会看到以下输出：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解它。
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe played with several concepts, so let's unpack them here. After setting
    up a library to work with unit tests as our playground in *step 1* to *step 3*,
    we create a first test to work on some built-in data types to go through the basics
    in *step 4* and *step 5*. Since Rust is particularly picky about type conversions,
    the test applies some math functions on the outcomes and inputs of different types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱涉及了几个概念，所以让我们在这里逐一解释。在*步骤 1*到*步骤 3*中，我们设置了一个库来处理单元测试作为我们的实验场，然后创建第一个测试来处理一些内置数据类型，以便在*步骤
    4*和*步骤 5*中了解基础知识。由于Rust对类型转换特别挑剔，测试对不同类型的输出和输入应用了一些数学函数。
- en: For experienced programmers, there is nothing new here, except for the fact
    that there is an `overflow_sub()` type operation that allows for overflowing operations.
    Other than that, Rust might be a bit more verbose thanks to the (intentional)
    lack of implicit casting. In *step 5*, we intentionally provoke an overflow, which
    leads to a runtime panic (and is the test result we are looking for).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经验丰富的程序员来说，这里没有什么新东西，除了有一个`overflow_sub()`类型操作允许溢出操作之外。除此之外，由于（故意的）缺乏隐式转换，Rust可能有点冗长。在*步骤
    5*中，我们故意引发溢出，这会导致运行时恐慌（这是我们想要的测试结果）。
- en: 'As shown in *step 5*, Rust offers `struct` as the foundation for complex types,
    which can have attached implementation blocks as well as derived (`#[derive(Clone,
    Copy, Debug)]`) implementations (such as the `Debug` and `Copy` traits). In *step
    6*, we go through using the type and its implications:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如*步骤 5*所示，Rust提供`struct`作为复杂类型的基础，它可以附加实现块以及派生（`#[derive(Clone, Copy, Debug)]`）实现（如`Debug`和`Copy`特性）。在*步骤
    6*中，我们将探讨使用该类型及其含义：
- en: No overhead on custom types: `struct` has exactly the size that the sum of its
    properties has
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义类型没有开销：`struct`的大小正好等于其属性总和
- en: Some operations implicitly invoke a trait implementation—such as the assignment
    operator or the `Copy` trait (which is essentially a shallow copy)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些操作隐式调用特性实现——例如赋值运算符或`Copy`特性（本质上是一种浅拷贝）
- en: Changing property values requires the mutability of the entire `struct` function
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变属性值需要整个`struct`函数的可变性
- en: There are a few aspects that work like that because the default allocation strategy
    is to prefer the stack whenever possible (or if nothing else is mentioned). Therefore,
    a shallow copy of the data performs a copy of the actual data as opposed to a
    reference to it, which is what happens with heap allocations. In this case, Rust
    forces an explicit call to `clone()` so the data behind the reference is copied
    as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认的分配策略是尽可能使用栈（或者如果没有提到其他东西），因此这种工作方式有几个方面。因此，数据的浅拷贝执行的是实际数据的拷贝，而不是对其的引用，这与堆分配发生的情况不同。在这种情况下，Rust强制显式调用`clone()`，以便将引用后面的数据也进行拷贝。
- en: We've successfully learned how to create and use data types. Now, let's move
    on to the next recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何创建和使用数据类型。现在，让我们继续下一个菜谱。
- en: Controlling execution flow
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制执行流程
- en: In Rust, controlling the execution flow of a program goes beyond simple `if`
    and `while` statements. We will see how to do that in this recipe.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，控制程序的执行流程不仅限于简单的`if`和`while`语句。我们将在这个菜谱中看到如何做到这一点。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this recipe, the steps are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，步骤如下：
- en: Create a new project using `cargo new execution-flow -- lib` and open the project
    in an editor.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new execution-flow -- lib`创建一个新的项目，并在编辑器中打开该项目。
- en: 'Basic conditionals such as `if` statements work just like in any other language,
    so let''s start with those and replace the default `mod tests { ... }` statement
    in the file:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本条件语句，如`if`语句，在其他任何语言中工作方式相同，所以让我们从这些开始，并替换文件中的默认`mod tests { ... }`语句：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Conditionals in Rust can do much more! Here is an additional test to show what
    they can do—add it before the last closing parenthesis:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rust中的条件语句可以做更多的事情！这里有一个额外的测试来展示它们能做什么——在最后一个闭括号之前添加它：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A conditional isn''t the only statement that can be used to change the flow
    of execution. There is, of course, also the loop and its variations. Let''s add
    another test for those as well, starting with a few basics:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件语句并不是唯一可以用来改变执行流程的语句。当然，还有循环及其变体。让我们也为它们添加另一个测试，从一些基础知识开始：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will add more code to the test to see that loops are regular statements
    that can return values and that ranges can be used in `for` loops as well:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向测试中添加更多代码，以查看循环是常规语句，可以返回值，并且范围可以在 `for` 循环中使用：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With these three tests prepared, let''s run `cargo test` to see them working:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好这三个测试后，让我们运行 `cargo test` 来看看它们是如何工作的：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后看看，以便更好地理解代码。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Although not vastly different from many languages' control statements, the basic
    constructs in Rust can change the way you think about variable assignments. It
    certainly transformed our mental models to be more data-focused. This means that
    instead of thinking *if this condition is reached, assign this other value to
    a variable*, a reversed *assign this other value to a variable if this condition
    is reached*—or shorter *transform this variable if this condition applies—*may
    take over.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与许多语言的控制语句没有太大差异，但 Rust 的基本结构可以改变你对变量赋值的思考方式。它确实改变了我们的思维模式，使其更加关注数据。这意味着，与其思考“如果这个条件成立，将这个其他值赋给变量”，不如反过来“如果这个条件成立，将这个其他值赋给变量”——或者更简洁地说，“如果这个条件适用，就转换这个变量”——可能会更加流行。
- en: This is the functional stream in the Rust programming language and it lends
    itself well to shortening and focusing the important parts of a piece of code.
    Similar implications can be made from the loop constructs since everything is
    a scope and has a return value. Using these capabilities will make every program
    a lot more readable and shorter, especially if it's just simple operations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Rust 编程语言中的函数流，它非常适合缩短和聚焦代码中的重要部分。从循环结构中也可以得出类似的结论，因为一切都是作用域，并且有返回值。使用这些功能将使每个程序都更加可读和简短，尤其是如果只是简单的操作。
- en: We've successfully learned how to control execution flow. Now, let's move on
    to the next recipe.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何控制执行流程。现在，让我们继续到下一个菜谱。
- en: Splitting your code with crates and modules
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 crates 和模块拆分你的代码
- en: 'Rust knows two types of code units: crates and modules. A crate is an external
    library, complete with its own `Cargo.toml` configuration file, dependencies,
    tests, and code. Modules, on the other hand, split the crate into logical parts
    that are only visible to the user if they import specific functions. Since the
    2018 edition of Rust, the difference in using these structural encapsulations
    has been minimized.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 知道两种代码单元：crates 和 modules。一个 crate 是一个外部库，包括它自己的 `Cargo.toml` 配置文件、依赖项、测试和代码。另一方面，modules
    将 crate 拆分成逻辑部分，只有当用户导入特定函数时才对用户可见。自从 Rust 2018 版本以来，使用这些结构封装的差异已经最小化。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This time, we are going to create two projects: one that offers some type of
    function and another one to use it. Therefore, use `cargo` to create both projects:
    `cargo new rust-pilib --lib` and `cargo new pi-estimator`. The second command
    creates a binary executable so we can run the compilation result, while the former
    is a library (crate).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将创建两个项目：一个提供某种类型的函数，另一个用于使用它。因此，使用 `cargo` 创建这两个项目：`cargo new rust-pilib
    --lib` 和 `cargo new pi-estimator`。第二个命令创建了一个二进制可执行文件，这样我们就可以运行编译结果，而前者是一个库（crate）。
- en: This recipe is going to create a small program that prints out estimations of
    pi (![](img/b35a6d88-0e56-4570-baee-314330859f14.png)) and rounds them to two
    decimal places. It's nothing fancy and easy for anyone to understand.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将创建一个小程序，打印出 π 的估计值（![](img/b35a6d88-0e56-4570-baee-314330859f14.png)）并将它们四舍五入到两位小数。这并不复杂，任何人都能理解。
- en: Naming crates is hard. The main repository ([https://crates.io/](https://crates.io/))
    is very permissive and has already seen name squatting (where people reserve names
    with the intent to sell them—think of names such as *YouTube* or *Facebook*, which
    would make nice API client names for these companies), and many crates are re-implementations
    of C libraries or wrap them. A good practice is to call the repository or directory
    `rust-mycoolCwrapper` and use `mycoolCwrapper` to name the crate itself. This
    way, only issues specific to your crate come in while the name is easy to guess
    in people's dependencies!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 给出 crate 的名字很难。主要仓库 ([https://crates.io/](https://crates.io/)) 非常宽容，并且已经看到了名称占用（人们保留名称的目的是为了出售——想想像
    *YouTube* 或 *Facebook* 这样的名字，这些名字可以成为这些公司的优秀 API 客户端名称），许多 crate 是 C 库的重新实现或包装。一个好的做法是将存储库或目录命名为
    `rust-mycoolCwrapper`，并使用 `mycoolCwrapper` 来命名 crate 本身。这样，只有与你的 crate 相关的问题会进来，而名称在人们的依赖中又很容易猜测！
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In just a few steps, we will be working with different modules:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个步骤之后，我们将与不同的模块一起工作：
- en: 'First, we are going to implement the `rust-pilib` crate. As a simple example,
    it estimates the constant pi using the Monte Carlo method. This method is somewhat
    similar to throwing darts at a dartboard and counting the hits. Read more on Wikipedia
    ([https://en.wikipedia.org/wiki/Monte_Carlo_method](https://en.wikipedia.org/wiki/Monte_Carlo_method)).
    Add to the `tests` submodule this snippet:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现 `rust-pilib` crate。作为一个简单的例子，它使用蒙特卡洛方法估计常数 pi。这种方法与向飞镖板投掷飞镖并计算命中次数有些相似。在维基百科上了解更多信息（[https://en.wikipedia.org/wiki/Monte_Carlo_method](https://en.wikipedia.org/wiki/Monte_Carlo_method)）。将以下片段添加到
    `tests` 子模块中：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Additionally, the Monte Carlo method uses a random number generator. Since
    Rust doesn''t come with one in its standard library, an external crate is required!
    Modify `Cargo.toml` of the `rust-pilib` project to add the dependency:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，蒙特卡洛方法使用随机数生成器。由于 Rust 的标准库中没有提供，因此需要外部 crate！修改 `rust-pilib` 项目的 `Cargo.toml`
    以添加依赖项：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As good engineers, we are also going to add tests to our new library. Replace
    the original `test` module with the following tests to approximate `pi` using
    the Monte Carlo method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为优秀的工程师，我们也会为我们的新库添加测试。用以下测试替换原始的 `test` 模块，以使用蒙特卡洛方法近似计算 `pi`：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can even go beyond 500 iterations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以超过 500 次迭代：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, let''s run the tests so we are certain of the quality of our product.
    Run `cargo test` in the root of the `rust-pilib` project. The output should be
    somewhat like this:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行测试，以确保我们产品的质量。在 `rust-pilib` 项目的根目录中运行 `cargo test`。输出应该类似于这样：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we want to offer the crate''s feature(s) to the user, which is why we created
    a second project for the user to execute. Here, we declare to use the other library
    as an external crate first. Add the following to `Cargo.toml` in the `pi-estimator`
    project:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们希望向用户提供 crate 的功能，这就是为什么我们为用户创建了一个第二个项目来执行。在这里，我们声明首先使用其他库作为外部 crate。在 `pi-estimator`
    项目中的 `Cargo.toml` 文件中添加以下内容：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, let''s take a look at the `src/main.rs` file. Rust looks there to find
    a `main` function to run and, by default, it simply prints `Hello, World!` to
    standard output. Let''s replace that with a function call:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们看一下 `src/main.rs` 文件。Rust 会在这里查找一个 `main` 函数来运行，并且默认情况下，它简单地输出 `Hello,
    World!` 到标准输出。让我们用一个函数调用替换它：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, where does this new function live? It has its own module:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这个新函数在哪里呢？它有自己的模块：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This module was implemented inline, which is common for tests—but works almost
    like it was its own file. Looking at the `use` statements, we are still missing
    a module, however: `rounding`. Create a file in the same directory as `main.rs`
    and name it `rounding.rs`. Add this public function and its test to the file:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此模块是内联实现的，这在测试中很常见——但几乎就像它是一个自己的文件一样。查看 `use` 语句，我们仍然缺少一个模块：“rounding”。在 `main.rs`
    相同目录下创建一个名为 `rounding.rs` 的文件。将此公共函数及其测试添加到文件中：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So far, the module is ignored by the compiler since it was never declared.
    Let''s do just that and add two lines at the top of `main.rs`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，编译器忽略了该模块，因为它从未被声明。让我们这样做，并在 `main.rs` 的顶部添加两行：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Lastly, we want to see whether everything worked. `cd` into the root directory
    of the `pi-estimator` project and run `cargo run`. The output should look similar
    to this (note that the library crate and dependencies are actually built with
    `pi-estimator`):'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们想看看一切是否正常工作。切换到 `pi-estimator` 项目的根目录，并运行 `cargo run`。输出应该类似于这样（注意，库 crate
    和依赖项实际上是用 `pi-estimator` 构建的）：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Library crates are not the only ones to have tests. Run `cargo test` to execute
    the tests in the new `pi-estimator` project:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库的包不是唯一需要测试的。运行 `cargo test` 来执行新 `pi-estimator` 项目中的测试：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we explored the relationship between crates and modules. Rust
    supports several ways of encapsulating code into units, and the 2018 edition has
    made it a lot easier to do. Seasoned Rust programmers will miss the `extern crate`
    declaration(s) at the top of the files, which is nowadays only necessary in special
    cases. Instead, the crate's contents can be used right away in a `use` statement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们探讨了包和模块之间的关系。Rust 支持将代码封装成单元的几种方式，2018 版本使得这变得更加容易。经验丰富的 Rust 程序员可能会怀念文件顶部的
    `extern crate` 声明（s），这在当今只有特殊情况下才是必要的。相反，可以直接在 `use` 语句中使用包的内容。
- en: In this way, the line between modules and crates is now blurred. However, modules
    are much simpler to create since they are part of the project and only need to
    be declared in the root module to be compiled. This declaration is done using
    the `mod` statement, which also supports implementation in its body—something
    that is used a lot in testing. Regardless of the implementation's location, using
    an external or internal function requires a `use` statement, often prefixed with `crate::`
    to hint toward its location.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，模块和包之间的界限现在变得模糊。然而，由于模块是项目的一部分，只需要在根模块中声明即可编译，因此创建模块要简单得多。这个声明是通过 `mod` 语句完成的，它还支持在主体中实现——这在测试中经常使用。无论实现的位置如何，使用外部或内部函数都需要一个
    `use` 语句，通常以 `crate::` 为前缀，以提示其位置。
- en: Alternatively to simple files, a module can also be a directory that contains
    at least a `mod.rs` file. This way, large code bases can nest and structure their
    traits and structs accordingly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的文件外，模块也可以是一个包含至少一个 `mod.rs` 文件的目录。这样，大型代码库可以相应地嵌套和结构化它们的特性和结构体。
- en: 'A note on function visibility: Rust''s default parameter is module visibility.
    Hence, a function declared and implemented in a module can only be seen from within
    that module. Contrary to that, the `pub` modifier exports the function to outside
    users. The same goes for properties and functions attached to a struct.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数可见性的说明：Rust 的默认参数是模块可见性。因此，在模块中声明和实现的函数只能在模块内部看到。与这相反，`pub` 修饰符将函数导出给外部用户。这同样适用于附加到结构体的属性和函数。
- en: We've successfully learned how to split our code with crates and modules. Now,
    let's move on to the next recipe.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用包和模块来分割我们的代码。现在，让我们继续下一个菜谱。
- en: Writing tests and benchmarks
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试和基准测试
- en: When we start developing, tests take a backseat more often than not. There are
    several reasons why this might be necessary at the time, but the inability to
    set up a testing framework and surroundings is not one of them. Unlike many languages,
    Rust supports testing right out of the box. This recipe covers how to use these
    tools.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始开发时，测试往往不是首要任务。当时可能有必要这样做的原因有很多，但无法设置测试框架和环境不是其中之一。与许多语言不同，Rust 支持开箱即用的测试。这个菜谱涵盖了如何使用这些工具。
- en: Although we mostly talk about unit testing here, that is, tests on a function/`struct`
    level, the tools remain the same for integration tests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这里主要讨论单元测试，即对函数/`struct`级别的测试，但集成测试的工具仍然是相同的。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Again, this recipe is best worked on in its own project space. Use `cargo new
    testing --lib` to create the project. Inside the project directory, create another
    folder and call it `tests`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个菜谱最好在自己的项目空间中完成。使用 `cargo new testing --lib` 创建项目。在项目目录内，创建另一个文件夹并命名为
    `tests`。
- en: Additionally, the benchmarks feature is still only available on the `nightly`
    branch of Rust. It is required to install the `nightly` build of Rust: `rustup
    install nightly`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，基准测试功能仍然只在 Rust 的 `nightly` 分支上可用。需要安装 Rust 的 `nightly` 版本构建：`rustup install
    nightly`。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行...
- en: 'Follow these steps to learn more about creating a test suite for your Rust
    projects:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解如何为您的 Rust 项目创建测试套件：
- en: 'Once created, a library project already contains a very simple test (probably
    to encourage you to write more). The `cfg(test)` and `test` attributes tell `cargo`
    (the test runner) how to deal with the module:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建，库项目就已经包含了一个非常简单的测试（可能是为了鼓励你编写更多）。`cfg(test)` 和 `test` 属性告诉 `cargo`（测试运行器）如何处理模块：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Before we add further tests, let''s add a subject that needs testing. In this
    case, let''s use something interesting: a singly linked list from our other book (*Hands-On
    Data Structures and Algorithms with Rust*) made generic. It consists of three
    parts. First is a node type:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加更多测试之前，让我们添加一个需要测试的主题。在这种情况下，让我们使用一些有趣的东西：从我们的另一本书（*Hands-On Data Structures
    and Algorithms with Rust*）中改编的单链表，使其泛型化。它由三部分组成。首先是节点类型：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Second, we have a `Link` type to make writing easier:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们有一个`Link`类型，使编写更简单：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last type is the list complete with functions to add and remove nodes.
    First, we have the type definition:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型是包含添加和删除节点功能的完整列表。首先，我们有类型定义：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `impl` block, we can then specify the operations for the type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`impl`块中，我们可以指定类型的操作：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With the list ready to be tested, let''s add some tests for each function,
    starting with a benchmark:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表准备好测试后，让我们为每个函数添加一些测试，从基准测试开始：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add some more tests for basic list functionality inside the `test` module:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test`模块内部添加更多基本列表功能的测试：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It''s also a good idea to have an integration test that tests the library from
    end to end. For that, Rust offers a special folder in the project called `tests`,
    which can house additional tests that treat the library as a black box. Create
    and open the `tests/list_integration.rs` file to add a test that inserts 10,000
    items into our list:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也有一个很好的主意，即进行一个端到端测试来测试库。为此，Rust在项目中提供了一个特殊的文件夹，称为`tests`，可以存放将库视为黑盒的附加测试。创建并打开`tests/list_integration.rs`文件，添加一个测试，将10,000个项目插入我们的列表：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Great, now each function has one test. Try it out by running `cargo +nightly
    test` in the `testing/` root directory. The result should look like this:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了，现在每个函数都有一个测试。通过在`testing/`根目录中运行`cargo +nightly test`来尝试它。结果应该看起来像这样：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To run the benchmark, issue `cargo +nightly bench`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行基准测试，请执行`cargo +nightly bench`：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解一下代码。
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Testing frameworks are a third-party library in many programming languages although
    well-tested code should be the default! By providing a (tiny) testing framework
    along with a test runner and even a small benchmarking framework (only on `nightly`
    as of this writing), the barrier for testing your Rust code is significantly lower.
    Although there are still some missing features (for example, mocking), the community
    is working on providing many of these things via external crates.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架在许多编程语言中是第三方库，尽管经过良好测试的代码应该是默认的！通过提供（微小的）测试框架、测试运行器和甚至一个小型的基准测试框架（截至本文写作时仅在`nightly`上提供），测试Rust代码的门槛显著降低。尽管还有一些缺失的功能（例如，模拟），但社区正在通过外部crate提供许多这些功能。
- en: 'After setting everything up in *step 1*, *step 2* creates a singly linked list
    as the test subject. A singly linked list is a series of the same node types,
    connected with some sort of pointer. In this recipe, we decided to use the interior
    mutability pattern, which allows for borrowing mutably at runtime to modify the
    node it points to. The attached operations (`append()` and `pop()`) make use of
    this pattern. *Step 3* then creates the tests that we can use to verify that our
    code does what we think it should. These tests cover the basic workings of the
    list: create an empty list, append a few items, and remove them again using `pop`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成*步骤 1*的所有设置后，*步骤 2*创建了一个单链表作为测试对象。单链表是一系列相同节点类型，通过某种指针连接起来的。在这个菜谱中，我们决定使用内部可变性模式，这允许在运行时以可变借用方式修改它所指向的节点。附加的操作（`append()`和`pop()`）就是利用这个模式。然后*步骤
    3*创建了我们用来验证代码是否按预期工作的测试。这些测试涵盖了列表的基本功能：创建一个空列表，添加一些项目，然后使用`pop`再次移除它们。
- en: Tests can be failed using a variety of `assert!` macros. They cover equals (`assert_eq!`),
    not equals (`assert_ne!`), Boolean conditions (`assert!`), and non-release mode
    compilation only (`debug_assert!`). With these available and attributes such as `#[should_panic]`, there
    is no case that cannot be covered. Additionally, this great Rust book offers an
    interesting read as well: [https://doc.rust-lang.org/book/ch11-01-writing-tests.html](https://doc.rust-lang.org/book/ch11-01-writing-tests.html).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用各种`assert!`宏来失败测试。它们包括等于（`assert_eq!`）、不等于（`assert_ne!`）、布尔条件（`assert!`）和非发布模式编译（仅`debug_assert!`）。有了这些可用，以及如`#[should_panic]`这样的属性，就没有任何情况无法覆盖。此外，这本优秀的Rust书还提供了一些有趣的阅读材料：[https://doc.rust-lang.org/book/ch11-01-writing-tests.html](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)。
- en: '*Step 4* adds a special integration test in a separate file. This restricts
    programmers to think like the user of the crate, without access to internal modules
    and functions that can be available in the nested `tests` module. As a simple
    test, we insert 10,000 items into the list to see whether it can handle the volume.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4步*在一个单独的文件中添加了一个特殊的集成测试。这限制了程序员像crate的用户一样思考，没有访问内部模块和函数，这些模块和函数可以在嵌套的`tests`模块中可用。作为一个简单的测试，我们向列表中插入10,000个条目，看看它是否能够处理这个量级。'
- en: The `+nightly` parameter instructs `cargo` to use the `nightly` toolchain for
    this command.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`+nightly`参数指示`cargo`使用`nightly`工具链执行此命令。'
- en: Only in *step 5* are we ready to run the benchmarks using `cargo +nightly test`,
    but tests are not automatically benchmarked. On top of that, benchmarks (`cargo
    +nightly bench`) compile the code using `--release` flags, thereby adding several
    optimizations that could lead to different outcomes from `cargo +nightly test`
    (including a headache for debugging those).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在*第5步*中，我们才准备好使用`cargo +nightly test`运行基准测试，但测试不是自动基准化的。更不用说，基准测试（`cargo +nightly
    bench`）使用`--release`标志编译代码，从而添加了可能导致与`cargo +nightly test`不同结果（包括调试时的头疼）的几个优化。
- en: '*Step 6* shows the output of the benchmarking harness with nanosecond precision
    for each loop execution (and the standard deviation). Whenever doing any kind
    of performance optimization, have a benchmark ready to show that it actually worked!'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*第6步*显示了基准测试工具的输出，每个循环执行的纳秒级精度（以及标准差）。在进行任何类型的性能优化时，都要准备好基准测试来证明它确实有效！'
- en: Other nice things that the Rust documentation tool adds to testing are `doctests`.
    These are snippets that are compiled and executed as well as rendered as documentation.
    We were so delighted, we gave it its own recipe! So, let's move on to the next
    recipe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其他Rust文档工具添加到测试中的不错功能是`doctests`。这些是编译并执行，同时作为文档渲染的代码片段。我们非常高兴，甚至为它专门制定了一个食谱！所以，让我们继续下一个食谱。
- en: Documenting your code
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录你的代码
- en: 'Documentation is an important part of software engineering. Instead of simply
    writing up some functions and chaining them together on a hunch, we like to promote
    writing reusable and readable code. Part of this is also writing sensible documentation—which,
    in ideal cases, can be rendered into other formats such as HTML or PDF. As many
    languages do by default, Rust provides a tool and language support as well: `rustdoc`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是软件工程的重要组成部分。我们不喜欢仅仅编写一些函数，然后凭直觉将它们串联起来，我们更喜欢编写可重用和可读的代码。这其中的一个部分也是编写合理的文档——在理想情况下，它可以渲染成其他格式，如HTML或PDF。像许多默认提供语言支持的编程语言一样，Rust提供了一个工具和语言支持：`rustdoc`。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Failing our high standards of software engineering, we did not document the
    code from the last recipe! To change that, let's load a project with code to be
    documented (such as the previous recipe, *Writing tests and benchmarks*) into
    an editor.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有达到软件工程的高标准，我们没有记录上一个食谱中的代码！为了改变这一点，让我们将一个包含要记录的代码的项目（如上一个食谱中的*编写测试和基准测试*）加载到编辑器中。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Compile your code comments to a shiny HTML in just a few steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个步骤就能将代码注释编译成闪亮的HTML：
- en: 'Rust''s docstrings (strings that explicitly are documentation to be rendered)
    are denoted by `///` (instead of the regular `//`). Within these sections, markdown—a
    shorthand language for HTML—can be used to create full documentation. Let''s add
    the following before the `List<T>` declaration:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rust的文档字符串（明确表示为要渲染的文档的字符串）由`///`表示（而不是常规的`//`）。在这些部分中，可以使用markdown——HTML的简写语言——来创建完整的文档。让我们在`List<T>`声明之前添加以下内容：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: /// let list = List::new_empty();
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: /// let list = List::new_empty();
- en: /// [PRE42]
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE42]
- en: 'This makes the code a lot more verbose, but is this worth it? Let''s see with
    `cargo doc`, a subcommand that runs `rustdoc` on the code and outputs HTML in
    the `target/doc` directory of the project. When opened in a browser, the `target/doc/testing/index.html`
    page shows the following (and more):'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使得代码变得更加冗长，但这是否值得？让我们用`cargo doc`来看看，这是一个子命令，它会在代码上运行`rustdoc`并输出项目`target/doc`目录中的HTML。在浏览器中打开，`target/doc/testing/index.html`页面显示了以下内容（还有更多）：
- en: '![](img/fe7c8e34-1c9e-445f-ac33-ad9809066e35.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe7c8e34-1c9e-445f-ac33-ad9809066e35.png)'
- en: Replace `testing` with the name of your project!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将`testing`替换为你的项目名称！
- en: 'Great, let''s add more documentation in the code. There are even special sections
    that are recognized by the compiler (by convention):'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了，让我们在代码中添加更多文档。甚至有一些特殊的部分，编译器（按照惯例）会识别：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: /// use testing::List;
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// use testing::List;
- en: ///
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ///
- en: /// let mut list = List::new_empty();
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// let mut list = List::new_empty();
- en: /// list.append(10);
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// list.append(10);
- en: /// [PRE44]
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// [PRE44]
- en: 'The `///` comments add documentation for expressions that follow it. This is
    going to be a problem for modules: should we put the documentation outside of
    the current module? No. Not only will this make the maintainers confused, but
    it also has a limit. Let''s use `//!` to document the module from within:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`///`注释为随后的表达式添加了文档。这对于模块来说可能是个问题：我们应该在当前模块外部放置文档吗？不。这不仅会让维护者感到困惑，而且也有局限性。让我们使用`//!`从模块内部进行文档说明：'
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A quick `cargo doc` run reveals whether it worked:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速运行一次`cargo doc`就可以揭示它是否工作：
- en: '![](img/6ab5a1ad-2ec2-4956-be4e-5bc3e6087d7d.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ab5a1ad-2ec2-4956-be4e-5bc3e6087d7d.png)'
- en: 'While there is some benefit in having similar-looking documentation in any
    Rust project, corporate marketing often likes to have things such as logos or
    a custom favicon to stand out. `rustdoc` supports that with attributes on the
    module level—they can be added right below the module documentation (note: this
    is the logo of my Rust blog, [https://blog.x5ff.xyz](https://blog.x5ff.xyz)):'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然在任何Rust项目中拥有类似外观的文档有一些好处，但企业营销通常喜欢有一些像标志或自定义favicon这样的东西来脱颖而出。`rustdoc`通过模块级别的属性来支持这一点——它们可以直接添加到模块文档下方（注意：这是我的Rust博客的标志，[https://blog.x5ff.xyz](https://blog.x5ff.xyz)）：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To see whether it worked, let''s run `cargo doc` again:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看它是否工作，让我们再次运行`cargo doc`：
- en: '![](img/740bd4e6-4c7c-4972-8134-44fbff08e29c.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/740bd4e6-4c7c-4972-8134-44fbff08e29c.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解幕后，以便更好地理解代码。
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Markdown is a great language that allows for creating formatted documentation
    quickly. However, feature support is typically tricky, so check out Rust's RFC
    for supported formatting ([https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md](https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md)) to
    find out whether some more advanced statements can be used. In general, writing
    documentation is dreaded by most developers, which is why it's very important
    to make it as simple and effortless as possible. The `///` pattern is quite common
    and has been expanded in Rust so that the documentation can apply to the code
    that follows (`///`) or that contains it (`//!`). Examples can be seen in *step
    1* and *step 4*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown是一种非常好的语言，它允许快速创建格式化的文档。然而，功能支持通常很棘手，所以请查看Rust的RFC以了解支持的格式化（[https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md](https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md)），以了解是否可以使用一些更高级的语句。一般来说，编写文档是大多数开发者所厌恶的，这就是为什么让它尽可能简单和容易是至关重要的。`///`模式相当常见，并且在Rust中得到了扩展，以便文档可以应用于随后的代码（`///`）或包含它的代码（`//!`）。示例可以在
    *步骤 1* 和 *步骤 4* 中看到。
- en: 'The approach the Rust project chose allows for a few lines explaining the (`public`)
    function, and then the `rustdoc` compiler (invoked in *step 2* with `cargo doc`)
    does the rest: exposing public members, cross-linking, listing all of the available
    types and modules, and much more. While the output is fully customizable (*step
    6*), the default is already visually quite appealing (we think).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Rust项目选择的方法允许有几行来解释（`public`）函数，然后`rustdoc`编译器（在 *步骤 2* 中通过`cargo doc`调用）完成其余工作：暴露公共成员、交叉链接、列出所有可用的类型和模块，等等。虽然输出是完全可定制的（*步骤
    6*），但默认设置已经非常吸引人（我们认为）。
- en: By default, `cargo doc` builds the documentation for the entire project—including
    dependencies.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`cargo doc`为整个项目构建文档——包括依赖项。
- en: 'Special sections (*step 3*) add another dimension to the documentation output:
    they allow for IDEs or editors to make some sense of the provided information
    and highlight, for example, that (and when) a function may panic. The examples
    section in your newly generated documentation will even compile and run code in
    the form of `doctests` (see the *Testing your documentation* recipe) so you will
    be notified when your examples become invalid.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊部分（*步骤 3*）为文档输出添加了另一个维度：它们允许集成开发环境（IDE）或编辑器对提供的信息有所理解，并突出显示，例如，一个函数可能崩溃的情况。在你新生成的文档中的示例部分甚至可以编译并运行以`doctests`形式存在的代码（参见
    *测试你的文档* 菜谱），这样你将在示例变得无效时得到通知。
- en: The `rustdoc` output is also independent of a web server, which means that it
    can be used wherever static hosting is supported. In fact, the Rust project builds
    and serves every crate's documentation that is hosted on [https://crates.io](https://crates.io),
    on [https://docs.rs](https://docs.rs).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustdoc`的输出也与网络服务器无关，这意味着它可以在支持静态托管的地方使用。事实上，Rust项目构建并服务于托管在[https://crates.io](https://crates.io)和[https://docs.rs](https://docs.rs)上的每个crate的文档。'
- en: Now that we can create documentation successfully, we should move on to the
    next recipe.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了文档，我们应该继续到下一个食谱。
- en: Testing your documentation
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的文档
- en: Out-of-date documentation and examples that aren't working as promised are an
    unfortunate truth of many technologies. However, these examples can be valuable
    (black box) regression tests to make sure that we didn't break anything while
    improving the code, so how can they be used as such? Rust's documentation strings
    (`///`) can include executable code snippets—and they can be seen all over the
    place on [https://www.rust-lang.org/learn](https://www.rust-lang.org/learn)!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 过时的文档和无法按承诺工作的示例是许多技术的遗憾事实。然而，这些示例可以作为（黑盒）回归测试来确保我们在改进代码的过程中没有破坏任何东西，那么它们如何被用作这样的测试呢？Rust的文档字符串（`///`）可以包含可执行代码片段——它们可以在[https://www.rust-lang.org/learn](https://www.rust-lang.org/learn)的各个地方看到！
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll continue to improve the linked list from a previous recipe but focus some
    more on the documentation. However, the added code will work in any project, so
    pick one that you want to add documentation to and open it in your favorite editor.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续改进之前食谱中的链表，但更多地关注文档。然而，添加的代码将在任何项目中工作，所以选择一个你想添加文档的项目，并在你喜欢的编辑器中打开它。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are the steps for this recipe:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的步骤如下：
- en: 'Find a function or `struct` (or module) to add a documentation string, for
    example, the `new_empty()` function of `List<T>`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个函数或`struct`（或模块）来添加文档字符串，例如，`List<T>`的`new_empty()`函数：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Use the special (`H1`) section `# Example` to provide a cue for the compiler
    to run any snippet contained in that section:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用特殊的（`H1`）部分`# 示例`为编译器提供一个提示，以运行该部分中包含的任何代码片段：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now let''s add a code example. Since `doctests` are considered black box tests,
    we import the `struct` (only if it''s public, of course) and show what we want
    to show:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个代码示例。由于`doctests`被认为是黑盒测试，我们导入`struct`（当然，只有它是公开的）并展示我们想要展示的内容：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: /// use testing::List;
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// use testing::List;
- en: ///
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ///
- en: '/// let mut list: List<i32> = List::new_empty();'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '/// let mut list: List<i32> = List::new_empty();'
- en: /// [PRE50]
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// [PRE50]
- en: 'With that ready, let''s see whether the tests work: run `cargo +nightly test`
    in the project''s root directory. You can see that we cheated a little bit and
    added tests to the other functions as well:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备就绪后，让我们看看测试是否工作：在项目的根目录中运行`cargo +nightly test`。你可以看到我们稍微作弊了一下，还向其他函数添加了测试：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The code obviously has been augmented with several examples that have been
    run in this case—is that always what we want? Sometimes, it''s all about the output,
    and adding all of the required imports for the test to successfully run is a pain.
    Hence, there are options to add to the *fenced* area ([PRE52] inside the fence
    [PRE53]`), and `ignore` will neither compile nor run the code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码显然已经增加了几个在此情况下运行的示例——这总是我们想要的吗？有时，一切都关乎输出，添加所有必要的导入以使测试成功运行是一件痛苦的事情。因此，有选项可以添加到*围栏*区域（[PRE52]围栏内[PRE53]`），而`ignore`将不会编译也不会运行代码：
- en: '[PRE54]ignore'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE54]ignore'
- en: ///
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: /// let list = List::new_empty();
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: /// let list = List::new_empty();
- en: /// [PRE55]
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE55]
- en: 'By running `cargo test` again, we see the changes reflected in the output:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`cargo test`，我们可以看到输出中的变化：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s check the HTML output as well: run `cargo doc` to generate a `target/doc/`
    directory containing all of the `CSS/HTML/JavaScript/...` required to show the
    documentation in a local browser. Open `target/doc/testing/index.html` with your
    favorite browser:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下HTML输出：运行`cargo doc`以生成一个包含所有显示文档所需的`CSS/HTML/JavaScript/...`的`target/doc/`目录。使用你喜欢的浏览器打开`target/doc/testing/index.html`：
- en: '![](img/02f40760-8124-4075-97e4-f98dace48423.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02f40760-8124-4075-97e4-f98dace48423.png)'
- en: 'Note: Replace `testing` with the name of your project.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：将`testing`替换为你的项目名称。
- en: 'Let''s remove the ugly `use` statement at the top of the snippet. At that point,
    it doubles the lines displayed without adding anything—and `rustdoc` provides
    a simple way to do that, too. Add `#` in front of the offending line:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们移除片段顶部的丑陋的 `use` 语句。到那时，它增加了显示的行数，但没有添加任何内容——`rustdoc` 也提供了一个简单的方法来做这件事。在问题行前添加
    `#`：
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '/// # use testing::List;'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '/// # use testing::List;'
- en: '/// let list: List<i32> = List::new_empty();'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '/// let list: List<i32> = List::new_empty();'
- en: /// [PRE58]
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// [PRE58]
- en: 'Lastly, there are additional ways to configure the testing behavior of `doctests`.
    In this case, let''s change warnings to errors by *denying* the warning while
    ignoring (allowing) unused variables:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，还有其他方法可以配置 `doctests` 的测试行为。在这种情况下，让我们通过 *拒绝* 警告（同时忽略（允许）未使用的变量）将警告更改为错误：
- en: '[PRE59]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'One last time, let''s check whether the output is what we expect and run `cargo
    doc`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再一次，让我们检查输出是否符合我们的预期，并运行 `cargo doc`：
- en: '![](img/94438ebb-bd22-4720-b1ec-1a8fc65c8bd5.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94438ebb-bd22-4720-b1ec-1a8fc65c8bd5.png)'
- en: Now, let's see whether we can find out more about how the code works.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们能否了解更多关于代码是如何工作的。
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Rust's documentation is very versatile and allows for variations on `doctests`
    that would not be possible to cover in a single recipe. However, the documentation
    of these tools is also excellent, so, for more details, check out [https://doc.rust-lang.org/rustdoc/documentation-tests.html](https://doc.rust-lang.org/rustdoc/documentation-tests.html).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的文档非常灵活，允许在单个菜谱中不可能涵盖的 `doctests` 变体。然而，这些工具的文档也非常出色，所以，要了解更多细节，请查看 [https://doc.rust-lang.org/rustdoc/documentation-tests.html](https://doc.rust-lang.org/rustdoc/documentation-tests.html)。
- en: What we covered in this recipe is a great way to document `structs` and functions
    in your code by adding examples that will be compiled and run on every test run.
    Not only will these be helpful for your readers and regression testing, but they
    also require you to think about how the code works as a black box. These tests
    are executed whenever code ([PRE60] in a fence [PRE61]`) is encountered in the
    `Example` section of the documentation. In *step 2* and *step 3*, we create these
    examples and see the result in *step 4* and *step 10*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中我们涵盖的内容是一个很好的方法，通过添加将在每次测试运行时编译和运行的示例来在代码中记录 `structs` 和函数。这不仅对读者和回归测试有帮助，而且也要求你思考代码作为一个黑盒是如何工作的。这些测试在文档的
    `Example` 部分遇到代码 ([PRE60] 在一个围栏 [PRE61]`) 时执行。在 *步骤 2* 和 *步骤 3* 中，我们创建这些示例，并在
    *步骤 4* 和 *步骤 10* 中查看结果。
- en: 'If you are now wondering how some documentation can show a fraction of the
    code required while it is supposed to be run, *step 8* shows the resolution to
    this riddle: `#` can hide individual lines while executing them. However, sometimes
    the code is not executed at all, as *step 5* shows. We can declare a section as
    `ignore` and this code won''t be run (without any visual indication in the output).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在想知道为什么某些文档在代码应该运行时却只显示了代码的一部分，*步骤 8* 展示了解决这个谜题的方法：`#` 可以在执行时隐藏单独的行。然而，有时代码根本不会执行，正如
    *步骤 5* 所示。我们可以将一个部分声明为 `ignore`，这样代码就不会执行（输出中没有任何视觉指示）。
- en: Furthermore, these tests can fail just like any other test by panicking (which
    can be allowed as well) or falling through an `assert!` macro. All in all, by
    hiding away boilerplate or other non-essential code, the reader can focus on the
    important bits, while the test still covers everything.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些测试可以像任何其他测试一样失败，通过恐慌（这也可以允许）或通过 `assert!` 宏跳过。总的来说，通过隐藏样板代码或其他非必要代码，读者可以专注于重要的部分，同时测试仍然覆盖了所有内容。
- en: We've successfully tested our documentation—we can sleep easy and move on to
    the next recipe.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功测试了我们的文档——我们可以安心地继续到下一个菜谱。
- en: Sharing code among types
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同类型之间共享代码
- en: 'An unusual feature of the Rust programming language is the decision to use
    traits over interfaces. The latter is very common across modern object-oriented
    languages and unifies the API of a class (or similar) to the caller, making it
    possible to switch the entire implementation without the caller''s knowledge.
    In Rust, the separation is a bit different: traits are more akin to abstract classes
    since they provide the API aspect as well as default implementations. `struct`
    can implement various traits, thereby offering the same behavior with other structs
    that implement the same traits.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编程语言的一个不寻常的特性是决定使用特质而不是接口。后者在现代面向对象语言中非常常见，它将类的 API（或类似）统一到调用者，使得在不让调用者知道的情况下切换整个实现成为可能。在
    Rust 中，这种分离略有不同：特质更像是抽象类，因为它们不仅提供了 API 方面，还提供了默认实现。`struct` 可以实现各种特质，从而与其他实现相同特质的结构体提供相同的行为。
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s go through the following steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下步骤进行：
- en: Use `cargo` to create a new project, `cargo new traits --lib`, or clone it from this
    book's GitHub repository ([https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)).
    Use Visual Studio Code and Terminal to open the project's directory.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo` 创建一个新的项目，`cargo new traits --lib`，或者从本书的 GitHub 仓库克隆它（[https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)）。使用
    Visual Studio Code 和终端打开项目的目录。
- en: 'Implement a simple configuration management service. To do that, we need some
    structs to work with:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个简单的配置管理服务。为此，我们需要一些结构体来工作：
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Additionally, some constructors make them easier to use:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些构造函数使它们更容易使用：
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To use a unified interface with other potential implementations, we have some
    traits to share the interface:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用与其他潜在实现统一的接口，我们有一些特质来共享接口：
- en: '[PRE64]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Rust demands its own implementation block for each trait:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rust 对每个特质都要求有一个自己的实现块：
- en: '[PRE65]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we need some tests to show it in action. To cover some basics, let''s
    add best-case unit tests:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些测试来展示其功能。为了涵盖一些基础知识，让我们添加最佳情况单元测试：
- en: '[PRE66]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Lastly, we run `cargo test` and see that everything works out:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行 `cargo test` 并看到一切正常：
- en: '[PRE67]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works...
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Using traits instead of interfaces and other object-oriented constructs has
    many implications for the general architecture. In fact, common architectural
    thinking will likely lead to more complex and verbose code that may perform worse
    on top of that! Let''s examine popular object-oriented principles from the Gang
    of Four''s book, *Design Patterns* (1994):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特质而不是接口和其他面向对象结构对整体架构有许多影响。实际上，常见的架构思维可能会导致代码更加复杂和冗长，而且性能可能更差！让我们从《设计模式》（1994年，四人帮所著）一书中考察流行的面向对象原则：
- en: '**Program to an interface not to an implementation**: This principle requires
    some thinking in Rust. With the 2018 edition, functions can accept an `impl MyTrait`
    parameter, where earlier versions had to use `Box<MyTrait>` or `o: T` and later
    `where T: MyTrait`, all of which have their own issues. It''s a trade-off for
    every project: either less complex abstractions with the concrete type or more
    generics and other complexity for cleaner encapsulation.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向接口而非实现编程**：这个原则在 Rust 中需要一些思考。在 2018 版本中，函数可以接受一个 `impl MyTrait` 参数，而早期版本必须使用
    `Box<MyTrait>` 或 `o: T`，后来是 `where T: MyTrait`，所有这些都存在他们自己的问题。这是每个项目的权衡：要么使用具体类型获得更简单的抽象，要么为了更干净的封装而使用更多的泛型和复杂性。'
- en: '**Favor object composition over class inheritance**: While this only applies
    to some extent (there is no inheritance in Rust), object composition is still
    something that seems like a good idea. Add trait type properties to your struct
    instead of the actual type. However, unless it''s a boxed trait (that is, slower
    dynamic dispatch), there is no way for the compiler to know exactly the size it
    should reserve—a type instance could have 10 times the size of the trait from
    other things. Therefore, a reference is required. Unfortunately, though, that
    introduces explicit lifetimes—making the code a lot more verbose and complex to
    handle.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先使用对象组合而非类继承**：虽然这仅在一定程度上适用（Rust 中没有继承），但对象组合仍然是一个看起来不错的想法。在你的结构体中添加特质类型属性而不是实际类型。然而，除非它是一个boxed特质（即，较慢的动态分发），否则编译器无法确切知道应该预留多少空间——一个类型实例的大小可能是其他特质大小的10倍。因此，需要一个引用。不幸的是，这引入了显式的生命周期——使得代码变得更加冗长和复杂。'
- en: Rust clearly favors splitting off behavior from data, where the former goes
    into a trait and the latter remains with the original struct. In this recipe, `KeyValueConfigService`
    did not have to manage any data—its task was to read and write `Config` instances.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 明显倾向于将行为从数据中分离出来，其中前者进入特质，而后者保留在原始结构体中。在本菜谱中，`KeyValueConfigService`不需要管理任何数据——它的任务是读取和写入`Config`实例。
- en: After creating these structs in *step 2*, we created the behavior traits in
    *step 3*. There, we split the tasks off into two individual traits to keep them
    small and manageable. Anything can implement these traits and thereby acquire
    the capabilities of writing or reading config files or retrieving a specific value
    by its key.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中创建这些结构体之后，我们在**步骤 3**中创建了行为特性。在那里，我们将任务拆分为两个单独的特性，以保持它们的小巧和易于管理。任何东西都可以实现这些特性，从而获得编写或读取配置文件或通过其键检索特定值的能力。
- en: We kept the functions on the trait generic as well to allow for easy unit testing
    (we can use `Vec<T>` instead of faking files). Using Rust's `impl` trait feature,
    we only care about the fact that `std::io::Read` and `std::io::Write` have been
    implemented by whatever is passed in.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将特质上的函数保持泛型，以便进行简单的单元测试（我们可以使用`Vec<T>`而不是伪造文件）。使用 Rust 的`impl`特质功能，我们只关心传递进来的任何东西是否实现了`std::io::Read`和`std::io::Write`。
- en: '*Step 4* implements the traits in an individual `impl` block for the structs.
    The `ConfigReader` strategy is naive: split into lines, split those lines at the
    first `=` character, and declare the left- and right-hand parts key and value
    respectively. The `ValueGetter` implementation then walks through the key-value
    pairs to find the requested key. We preferred `Vec` with `String` tuples here
    for simplicity, for example, `HashMap` can improve performance substantially.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4**在单个`impl`块中为结构体实现特质。`ConfigReader`策略是简单的：按行分割，在第一个`=`字符处分割这些行，并分别声明左右部分为键和值。然后`ValueGetter`实现遍历键值对以找到请求的键。我们在这里选择了`Vec`与`String`元组，以保持简单，例如，`HashMap`可以显著提高性能。'
- en: The tests implemented in *step 5* provide an overview of how the system works
    and how we seamlessly use the types by the traits they implement. `Vec` doubles
    as a read/write stream, no type-casting required. To make sure the tests actually
    run through, we run `cargo test` in *step 6*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 5**中实现的测试提供了系统工作方式和如何通过它们实现的特质无缝使用类型的概述。`Vec`作为读写流，无需类型转换。为了确保测试实际运行，我们在**步骤
    6**中运行`cargo test`。
- en: After this lesson on structuring code, let's move on to the next recipe.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课关于代码结构之后，让我们继续下一个菜谱。
- en: Sequence types in Rust
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 中的序列类型
- en: 'Sequences are supported in many forms in Rust. The regular array is strictly
    implemented: it has to be defined at compile time (using literals) and be of a
    single data type, and cannot change in size. Tuples can have members of different
    types, but cannot change in size either. `Vec<T>` is a generic sequence type (of
    whatever you define as type `T`) that provides dynamic resizing—but `T` can only
    be of a single type. All in all, each of them has its purpose and, in this recipe,
    we will explore each.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 支持多种形式的序列。常规数组是严格实现的：它必须在编译时定义（使用字面量）并且只能为单一数据类型，并且不能改变大小。元组可以有不同类型的成员，但也不能改变大小。`Vec<T>`是一个泛型序列类型（无论你定义为什么类型`T`），它提供动态调整大小——但`T`只能为单一类型。总的来说，它们各自都有其用途，在本菜谱中，我们将探索每一个。
- en: How to do it...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps for this recipe are as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的步骤如下：
- en: Use `cargo` to create a new project, `cargo new sequences --lib`, or clone it
    from this book's GitHub repository ([https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)).
    Use Visual Studio Code and Terminal to open the project's directory.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo`创建一个新的项目，`cargo new sequences --lib`，或者从本书的 GitHub 仓库克隆它（[https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)）。使用
    Visual Studio Code 和终端打开项目的目录。
- en: 'With the test module ready, let''s start with arrays. Arrays in Rust have a
    familiar syntax but they follow a stricter definition. We can try out various
    abilities of the Rust array in a test:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试模块准备就绪后，让我们从数组开始。Rust 中的数组有熟悉的语法，但它们遵循更严格的定义。我们可以尝试 Rust 数组的各种能力：
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Users of more recent programming languages and data science/math environments
    will also be familiar with the tuple, a fixed-size variable type collection. Add
    a test for working with tuples:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新编程语言和数据科学/数学环境的使用者也会熟悉元组，这是一种固定大小的变量类型集合。添加一个测试来处理元组：
- en: '[PRE69]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As the last collection, the vector is the basis for all of the other quick
    and expandable data types. Create the following test with several assertions that
    show how to use the `vec!` macro and the vector''s memory usage:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一个集合，向量是所有其他快速可扩展数据类型的基础。创建以下测试，其中包含几个断言，展示了如何使用 `vec!` 宏和向量的内存使用：
- en: '[PRE70]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The remainder of the test shows how to modify and read the vector:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的其余部分展示了如何修改和读取向量：
- en: '[PRE71]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run `cargo test` to see the working tests run:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `cargo test` 来查看正在运行的测试：
- en: '[PRE72]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Sequence types are compound types that allocate a continuous part of the memory
    for faster and easier access. `Vec<T>` creates a simple, heap-allocated version
    of an array that grows (and shrinks) dynamically (*step 4*).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 序列类型是复合类型，它们为更快、更易于访问而分配内存的连续部分。`Vec<T>` 创建了一个简单、堆分配的数组版本，它可以动态地增长（和缩小）(*步骤
    4*)。
- en: The original array (*step 2*) allocates memory on the stack and has to have
    a known size at compile time, which is a significant factor in using it. Both
    can be iterated and viewed using slices ([https://doc.rust-lang.org/book/ch04-03-slices.html](https://doc.rust-lang.org/book/ch04-03-slices.html)).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数组 (*步骤 2*) 在栈上分配内存，并且必须在编译时有一个已知的大小，这是使用它的一个重要因素。两者都可以使用切片迭代和查看 ([https://doc.rust-lang.org/book/ch04-03-slices.html](https://doc.rust-lang.org/book/ch04-03-slices.html))。
- en: Tuples (*step 3*) are a different beast since they don't lend themselves to
    slices and are more a group of variables that have a semantic relationship—like
    a point in a two-dimensional space. Another use case is to return more than one
    variable to the caller of a function without the use of an additional struct or
    misusing a collection type.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 元组 (*步骤 3*) 是一种不同的生物，因为它们不适合切片，而更像是一组具有语义关系的变量——就像二维空间中的一个点。另一个用例是在不使用额外的结构体或误用集合类型的情况下，将多个变量返回给函数的调用者。
- en: Sequences in Rust are special because of the low overhead they produce. The
    size of `Vec<T>` is a pointer to an `n * size of T` memory on the heap, along
    with the size of the allocated memory, and how much of that is used. For arrays,
    the capacity is the current size (which the compiler can fill in during compilation),
    and tuples are more or less syntactic sugar on top of three distinct variables.
    Each of the three types provides convenience functions to change the contents—and,
    in the case of `Vec<T>`, the size of the collection. We recommend taking a close
    look at the tests and their comments to find out more about each type.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的序列之所以特殊，是因为它们产生的开销很低。`Vec<T>` 的大小是指向堆上 `n * size of T` 内存的一个指针，以及分配的内存大小和使用了多少。对于数组，容量是当前的大小（编译器可以在编译期间填充），而元组在三个不同的变量之上几乎是语法糖。这三种类型都提供了方便的函数来更改内容——在
    `Vec<T>` 的情况下，还可以更改集合的大小。我们建议仔细查看测试及其注释，以了解更多关于每种类型的信息。
- en: We have covered the basics of sequences in Rust, so let's move on to the next
    recipe.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 Rust 中序列的基础知识，所以让我们继续到下一个菜谱。
- en: Debugging Rust
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 的调试
- en: Debugging has been a notoriously difficult topic in Rust, but still, it pales
    in comparison to Visual Studio debugging or IntelliJ IDEA's ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/))
    capabilities in the Java world. However, debugging capabilities go beyond simple
    `println!` statements nowadays.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 调试在 Rust 中一直是一个棘手的话题，但与 Visual Studio 调试或 IntelliJ IDEA 在 Java 世界中的能力相比，它仍然相形见绌。然而，调试能力现在已经超越了简单的
    `println!` 语句。
- en: Getting ready
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Debugging Rust is available via an additional extension in Visual Studio Code.
    Install it by running `ext install vadimcn.vscode-lldb` in the command window
    (*Ctrl* + *P*/*cmd* + *P*).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，可以通过额外的扩展来调试 Rust。通过在命令窗口中运行 `ext install vadimcn.vscode-lldb`
    来安装它 (*Ctrl* + *P*/*cmd* + *P*).
- en: On Windows, debugging is limited thanks to its incomplete LLVM support. However,
    the extension will prompt you to automatically install several things. Additionally,
    install **Python 3.6** and add it to `%PATH%`. With these dependencies installed,
    it worked well for us (in March 2019).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，由于其不完整的 LLVM 支持，调试受到限制。然而，扩展会提示您自动安装几个东西。此外，安装 **Python 3.6** 并将其添加到
    `%PATH%`。在这些依赖项安装后，它在我们这里工作得很好（2019 年 3 月）。
- en: Read more at [https://github.com/vadimcn/vscode-lldb/wiki/Setup](https://github.com/vadimcn/vscode-lldb/wiki/Setup).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://github.com/vadimcn/vscode-lldb/wiki/Setup](https://github.com/vadimcn/vscode-lldb/wiki/Setup)
    阅读更多内容。
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following steps for this recipe:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个菜谱：
- en: Create a new binary project to debug: `cargo new debug-me`. Open this project
    in Visual Studio Code with the new extension loaded.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的二进制项目进行调试：`cargo new debug-me`。使用新扩展打开此项目在 Visual Studio Code 中。
- en: 'Before anything can happen, Visual Studio Code needs a launch configuration
    to recognize Rust''s LLVM output. First, let''s create this launch configuration;
    for that, add a `.vscode` directory containing a `launch.json` file to the project
    directory. This can be autogenerated, so make sure that `launch.json` contains
    the following:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何事情发生之前，Visual Studio Code 需要一个启动配置来识别 Rust 的 LLVM 输出。首先，让我们创建这个启动配置；为此，在项目目录中添加一个包含`launch.json`文件的`.vscode`目录。这可以自动生成，所以请确保`launch.json`包含以下内容：
- en: '[PRE73]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, let''s open `src/main.rs` and add some code to debug:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开`src/main.rs`并添加一些代码进行调试：
- en: '[PRE74]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Save and add a breakpoint in VS Code''s user interface. Click left of the line
    numbers and a red dot should appear there. This is a breakpoint:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 的用户界面中保存并添加断点。点击行号左侧，应该会出现一个红色圆点。这是一个断点：
- en: '![](img/b1131a2d-2e04-44c4-b77f-2bcfb2ad2df9.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1131a2d-2e04-44c4-b77f-2bcfb2ad2df9.png)'
- en: 'Having set a breakpoint, we expect the program to pause there and give us some
    insights into the current memory layout, that is, the state of any variables at
    that particular point in time. Run the debug launch configuration with *F5* (or
    Debug *|* Start Debugging). The window configuration should change slightly and
    a panel on the left-hand side of the window shows local variables (among other
    things):'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置了断点后，我们期望程序在那里暂停，并给我们一些关于当前内存布局的见解，即在那个特定时间点的任何变量的状态。使用*F5*（或调试*|*开始调试）运行调试启动配置。窗口配置应该略有变化，窗口左侧的一个面板显示了局部变量（以及其他内容）：
- en: '![](img/a2e8a80c-fc38-45cc-bb91-0d2220b3ff7e.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2e8a80c-fc38-45cc-bb91-0d2220b3ff7e.png)'
- en: Using the small control panel on top, you can then control the execution flow
    and watch the stack and memory on the left change accordingly. Note also the difference
    between an array and a (heap-allocated) vector!
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用顶部的这个小控制面板，您可以控制执行流程，并观察左侧的堆栈和内存相应地变化。注意数组与（堆分配的）向量的区别！
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Rust is built on the LLVM compiler toolkit that comes with a range of features
    out of the box. When a Rust program compiles, it only gets translated into an
    intermediate language, from which the LLVM compiler creates native bytecode.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是建立在带有各种内置功能的 LLVM 编译器工具包之上的。当 Rust 程序编译时，它只被转换成中间语言，然后 LLVM 编译器创建原生字节码。
- en: This is also the reason why debugging can work in this case—it builds on the
    LLVM debug symbols. While it clearly lacks the convenience of modern IDEs, it's
    a large step forward and allows users to inspect types. Future development of
    the tools will hopefully improve this situation as well; for now, the general
    debugger, GDB ([https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)),
    handles most of the cases where debug symbols are compiled into the program. The
    configuration for connecting the debugger with the code in the IDE can be found
    in *step 2* and, by setting the breakpoint in *step 4*, it can track the relationship
    between lines of code and output. With the default setting to compile to debug,
    the debugger can then stop at this exact point. While it's not perfect (on the
    UX side), its capabilities are amazing.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么在这种情况下调试可以工作——它基于 LLVM 调试符号。虽然它显然缺乏现代 IDE 的便利性，但它是一个巨大的进步，并允许用户检查类型。希望工具的未来发展也能改善这种情况；目前，通用的调试器
    GDB ([https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)) 处理了大多数将调试符号编译到程序中的情况。在
    IDE 中连接调试器的配置可以在*步骤 2*中找到，通过在*步骤 4*中设置断点，它可以追踪代码行与输出之间的关系。使用默认设置编译为调试，调试器就可以在这一点上停止。虽然它不是完美的（在用户体验方面），但它的功能是惊人的。
- en: Even this simple connection to a (UX-wise) very basic debugger can have great
    benefits for developers and represents a huge step up from `println!()` statements
    to inspect the current value of a variable.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是这种与（从用户体验角度）非常基础的调试器的简单连接，也能为开发者带来巨大的好处，并且是从`println!()`语句到检查变量当前值的巨大进步。
- en: We hope that you can use the debugger's capabilities in the remainder of this
    book. With this knowledge, you can now move on to the next chapter.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您能在这本书的剩余部分使用调试器的功能。有了这些知识，您现在可以继续到下一章。
