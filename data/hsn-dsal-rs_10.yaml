- en: Finding Stuff
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找东西
- en: 'The issue with searching for *something* is always directly related to the
    space in which you are searching. You will certainly have experienced looking
    for your keys in your house: the search space contains anything from jackets worn
    the previous day to the sock drawer into which the key might have slipped the
    last time you did the washing. Upon finding the item (and after a lot of wasted
    time spent running up and down stairs and searching in various rooms), you then
    swear to keep things tidier in the future....'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索“某物”的问题始终与您正在搜索的空间直接相关。您肯定经历过在家里找钥匙的经历：搜索空间包含从前一天穿过的夹克到钥匙可能滑入的袜子抽屉中的任何东西。在找到物品（以及花费大量时间上楼下楼和在不同房间中搜索之后），您会发誓将来要使东西更整齐……
- en: 'We have encountered this issue more often than we are comfortable with admitting,
    but it illustrates a fundamental issue that we can solve algorithmically without
    any particular order to build on. In this chapter, we''ll explore how to do the
    following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的这个问题比我们愿意承认的要多，但它说明了我们可以通过算法解决的一个基本问题，而不需要任何特定的顺序来构建。在本章中，我们将探讨如何做到以下几点：
- en: Finding items in an unordered array of chaos
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在混乱的无序数组中寻找项目
- en: Making a trade-off between preparation and search
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在准备和搜索之间做出权衡
- en: Finding the best
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最佳
- en: 'The search domain is present on various levels of abstraction: finding a word
    in a body of text is typically more complex than simply calling the `contains()`
    function, and if there are several results, which is the one that was searched
    for? This entire class of problem is summed up under the umbrella of **information
    retrieval**, where problems of ranking, indexing, understanding, storing, and
    searching are solved in order to retrieve the optimum result (for all definitions).
    This chapter focuses only on the latter part, where we actually look through a
    collection of items (for example, an index) in order to find a match.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索域存在于多个抽象级别：在文本中找到一个词通常比简单地调用`contains()`函数要复杂，如果有多个结果，哪个是您要找的？这一类问题都归纳在**信息检索**的范畴下，其中通过排名、索引、理解、存储和搜索等问题来解决，以检索最佳结果（对于所有定义）。本章仅关注后者，即我们实际上查看一系列项目（例如，索引）以找到匹配项。
- en: This means that we will compare items directly (*a == b*) to determine closeness,
    rather than using something such as a distance - or locally-sensitive hashing
    function. These can be found in more specific domains such as a fuzzy search or
    matching bodies of text, which is a field of its own. To learn more about hashing,
    please check out [Chapter 6](95653045-6e1c-4ef7-bd0c-8e45b1ccfa1d.xhtml), *Exploring
    Maps and Sets* or the *Further reading* section in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将直接比较项目（*a == b*）以确定接近度，而不是使用诸如距离或局部敏感哈希函数之类的工具。这些可以在更具体的领域找到，如模糊搜索或匹配文本体，这是一个独立的领域。要了解更多关于哈希的信息，请参阅第6章*探索映射和集合*或本章的*进一步阅读*部分。
- en: Starting off with the most naive implementation, let's look at linear searches.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的实现开始，让我们看看线性搜索。
- en: Linear searches
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性搜索
- en: 'Linear searching is a fancy name for something that we do in almost every program
    and our everyday lives: going through a collection of items to find the first
    match. There is no need for any preprocessing or similar steps; the collection
    can be used as-is, which means that standard libraries commonly provide a generic
    implementation already. In Rust''s case, the iterator trait offers this feature
    with functions called `position()` (or `rposition()`), `find()`, `filter()`, or
    even `any()`. `fold()` can also be used to find the thing you are looking for.
    The following is a diagram of the process:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索是一个听起来很高级的名字，我们在几乎每一个程序和日常生活中都会这样做：遍历一系列项目以找到第一个匹配项。不需要任何预处理或类似步骤；集合可以原样使用，这意味着标准库通常已经提供了通用的实现。在Rust的情况下，迭代器特质通过名为`position()`（或`rposition()`）、`find()`、`filter()`或甚至`any()`的函数提供了这个功能。`fold()`也可以用来找到你要找的东西。以下是一个流程图的示例：
- en: '![](img/b0e2e878-c1f8-48ee-a94f-b4222c8b5f1f.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0e2e878-c1f8-48ee-a94f-b4222c8b5f1f.png)'
- en: 'Fundamentally, however, it''s a loop over each item that either exits or collects
    all items where a predicate (an evaluation function that takes in an item of a
    type to return a Boolean value) matches:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从根本上说，这是一个遍历每个项目的循环，该循环要么退出，要么收集所有与谓词（一个评估函数，它接受一个类型的项目并返回一个布尔值）匹配的项目：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This algorithm obviously exhibits *O(n)* runtime complexity, growing with the
    collection size. Iterating over 10,000 items will take a while, even if the predicate
    executes quickly, so how can this strategy be improved?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法显然表现出 *O(n)* 的时间复杂度，随着集合大小的增长而增长。迭代 10,000 个项目会花费一些时间，即使谓词执行得很快，那么这种策略应该如何改进呢？
- en: Jump search
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳跃查找
- en: Going linearly over a collection one-by-one is only efficient if you are already
    close to a potential match, but it is very hard to determine—what does *close
    to a match* mean? In unordered collections, this is indeed impossible to know
    this since any item can follow. Consequently, what about sorting the collection
    first? As discussed in [Chapter 9](a9ba9f9e-59a2-411f-8998-831fe4e69266.xhtml),
    *Ordering Things*, sorting at quasi-linear runtime complexity can be significantly
    faster than going over each item of a long collection past a certain size.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 线性地逐个遍历一个集合只有在接近潜在匹配项时才是有效的，但很难确定——“接近匹配”是什么意思？在无序集合中，这确实是不可能知道的，因为任何项目都可以跟随。因此，先对集合进行排序怎么样？如第
    9 章[排序事物](a9ba9f9e-59a2-411f-8998-831fe4e69266.xhtml)中讨论的那样，排序在准线性时间复杂度下可以比遍历超过一定大小的长集合中的每个项目要快得多。
- en: 'A jump search makes use of knowing about the range it jumps over, not unlike
    a skip list:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃查找利用了对它跳过的范围的了解，就像跳表一样：
- en: '![](img/bb372dc5-b290-4553-92cf-5d71d9621ef3.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb372dc5-b290-4553-92cf-5d71d9621ef3.png)'
- en: 'After sorting, a search can be significantly faster and a number of elements
    can be skipped in order to search in a linear fashion once the algorithm is close
    to a match. How many elements can be skipped at each jump? This is something to
    be tested, but first here is the code that does the work:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序后，搜索可以显著更快，并且一旦算法接近匹配项，可以跳过一定数量的元素以线性方式搜索。每次跳跃可以跳过多少个元素？这是一件需要测试的事情，但首先这里是完成这项工作的代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The API expects a pre-sorted slice, which means that sorting, strictly speaking,
    is not part of the algorithm's runtime. Without the sorting, the runtime complexity
    might be something around *O(n / k + k)*, with k being the step size, which can
    be reduced to *O(n)* in a worst-case scenario.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: API 预期一个预排序的切片，这意味着严格来说，排序不是算法运行时间的一部分。没有排序，时间复杂度可能大约是 *O(n / k + k)*，其中 k 是步长，在最坏的情况下可以减少到
    *O(n)*。
- en: Including the sorting mechanism, the sorting algorithm will trump the search's
    runtime complexity easily, raising it to *O(n log n)*. While various choices for
    the jumps can improve the absolute runtime of this search algorithm by a significant
    amount, it will not perform as well as something like a tree structure. Binary
    searching as a strategy achieves that nicely, however.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 包括排序机制，排序算法将轻松超越搜索的时间复杂度，将其提高到 *O(n log n)*。虽然跳跃的选择可以显著提高这种搜索算法的绝对运行时间，但它不会像树结构那样表现良好。然而，作为策略，二分查找做得很好。
- en: Binary searching
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分查找
- en: Binary trees greatly reduce the number of comparison operations by creating
    branches from the collection, just like a binary tree would. This creates a tree
    on-the-fly, resulting in superior search performance. The significance is predictability,
    which allows us to build the tree and provides the options for what branch the
    algorithm can expect the result in.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树通过从集合中创建分支来大大减少比较操作的次数，就像二叉树一样。这会即时创建一个树，从而实现更好的搜索性能。其重要性在于可预测性，这允许我们构建树，并为算法可以期望的结果分支提供选项。
- en: 'A binary search, just like a jump search, requires the incoming slice to be
    ordered for it to work. Then the algorithm splits the array in half and chooses
    the side that will most likely contain the item. Once there are two collections,
    the behavior is very similar to that of a binary tree walk, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找，就像跳跃查找一样，需要输入的切片是有序的才能工作。然后算法将数组分成两半，并选择最有可能包含该元素的一侧。一旦有两个集合，其行为与二叉树遍历非常相似，如下所示：
- en: '![](img/3a76371f-cf74-4e75-915c-3c4793b9bf10.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a76371f-cf74-4e75-915c-3c4793b9bf10.png)'
- en: 'Again, given that the sorting effort trumps the algorithm''s runtime complexity,
    it''s that of the sorting algorithm that will be considered the outcome: *O(n
    log n)*. However, we should also be interested in the real performance, if the
    collection is already sorted; it''s significantly lower! First, let''s look at
    some code to make this easier to understand:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于排序的努力超过了算法的时间复杂度，因此将考虑排序算法的结果：*O(n log n)*。然而，我们也应该对实际性能感兴趣，如果集合已经排序；它将显著降低！首先，让我们看看一些代码，以便更容易理解：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While the recursive implementation of the algorithm would have worked too, though
    it is not significantly shorter it harbors the risk of a stack overflow, hence
    the iterative approach.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然算法的递归实现也可以工作，尽管它并不显著更短，但它包含了栈溢出的风险，因此采用了迭代方法。
- en: 'After choosing a pivot (center) element, the algorithm has to determine the
    collection for the next iteration by one of the following three scenarios:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择枢轴（中心）元素后，算法必须通过以下三种情况之一来确定下一次迭代的集合：
- en: The left part containing smaller values
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含较小值的左侧部分
- en: The right chunk with larger values
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含较大值的右侧部分
- en: Not at all; the pivot element is the result too
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全不是；枢轴元素也是结果
- en: This tree-like behavior allows for a great runtime complexity of *O(log n)*,
    since the number of items searched keeps halving until the desired element has
    been found. However, how does all this compare?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种树状行为允许运行时间复杂度达到*O(log n)*，因为搜索的项目数量会一直减半，直到找到所需的元素。然而，这一切是如何比较的呢？
- en: Wrap up
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The three approaches differ somewhat, with the binary search being the established
    state-of-the-art type algorithm. In fact, it can be used on any Rust slices (if
    they are sorted, of course) and used to find whatever is required.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法有所不同，二分搜索是当前最先进的算法类型。实际上，它可以用于任何已排序的Rust切片（当然，如果它们已排序的话），并用于查找所需的内容。
- en: 'Comparing these algorithms is tricky: a linear search works well on unordered
    datasets and is the only way to search those if sorting is not an option. If sorting
    is an option, then a binary search is faster by a large margin (`asc` is the sorting
    direction: ascending):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这些算法比较棘手：线性搜索在无序数据集上效果很好，如果排序不是可选项，那么它是唯一可以搜索这些数据集的方法。如果排序是可选项，那么二分搜索会快得多（`asc`是排序方向：升序）：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When plotted, the difference is clearly visible, with the linear search showing
    its linear characteristics. Taking the absolute runtime out of the game will show
    the runtime complexity as well, as demonstrated in the following chart:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制时，差异明显可见，线性搜索显示出其线性特征。将绝对运行时间排除在外将显示运行时间复杂度，如下面的图表所示：
- en: '![](img/25c07135-7660-498b-8709-5bfab286bfee.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25c07135-7660-498b-8709-5bfab286bfee.png)'
- en: 'This chart shows the relative behavior of each algorithm in order to show its
    runtime complexities: a binary search with *O(log n)*, a linear search with *O(n)*,
    and a jump search, which is almost linear because of the parameter choice (the
    jump size is one-third of the length of the array):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表显示了每种算法的相对行为，以显示其运行时间复杂度：二分搜索为*O(log n)*，线性搜索为*O(n)*，以及跳转搜索，由于参数选择（跳转大小是数组长度的三分之一），几乎呈线性：
- en: '![](img/4ab2b266-cb10-45c6-b21a-adbece5d85bd.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ab2b266-cb10-45c6-b21a-adbece5d85bd.png)'
- en: And that is it—a short introduction to search algorithms. Typically, it's more
    about the data, and having some way to sort beforehand creates a powerful opportunity
    to quickly find the item you are looking for.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容——搜索算法的简要介绍。通常，这更多是关于数据，并且事先有一些排序方法可以创建一个快速找到所需项的强大机会。
- en: Summary
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Search, as a part of the information retrieval (among others) process, is an
    elementary way of finding something independently of the data structure being
    used. There are three popular types of algorithm: linear search, jump search,
    and binary search. Completely different approaches (such as locally-sensitive
    hashing) have been discussed in an earlier chapter about maps and sets, but they
    still need a mechanism to compare quickly.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索作为信息检索（以及其他）过程中的一个基本方法，是一种独立于所使用的数据结构来查找东西的方式。有三种流行的算法类型：线性搜索、跳转搜索和二分搜索。在关于映射和集合的早期章节中已经讨论了完全不同的方法（如局部敏感哈希），但它们仍然需要一个快速比较的机制。
- en: 'A linear search is the least complex approach: iterate over a collection and
    compare the items with the element that is to be found. This has also been implemented
    in Rust''s iterator and exhibits *O(n)* runtime complexity.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索是最简单的方法：遍历一个集合，并将元素与要查找的元素进行比较。这也在Rust的迭代器中得到了实现，并表现出*O(n)*的运行时间复杂度。
- en: Jump searches are superior. By operating on a sorted collection, they can use
    a step size that is greater than 1 (like a linear search) in order to skip to
    the required parts faster by checking whether the relevant section has already
    passed. While faster in absolute terms, the worst-case runtime complexity is still
    *O(n)*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转搜索更优越。通过在已排序的集合上操作，它们可以使用大于1的步长（就像线性搜索一样）来更快地跳转到所需部分，通过检查相关部分是否已经通过。虽然绝对速度更快，但最坏情况下的运行时间复杂度仍然是*O(n)*。
- en: The (at the time of writing) fastest approach is a binary search, which also
    operates on a sorted collection and repeatedly splits the desired sections in
    half to work with a tree-like strategy. In fact, the runtime complexity of the
    algorithm itself is *O(log n)* as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: （在撰写本文时）最快的方法是二分查找，它也作用于有序集合，并反复将所需部分一分为二，采用树状策略进行操作。实际上，该算法本身的运行时间复杂度也是 *O(log
    n)*。
- en: 'In the next chapter, we will explore some more exotic algorithms: backtracking,
    random number generation, and more!'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些更奇特算法：回溯、随机数生成等！
- en: Questions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is information retrieval?
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是信息检索？
- en: Do modern search engines and databases use simple search algorithms?
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现代搜索引擎和数据库是否使用简单的搜索算法？
- en: Why do linear searches have *O(n)* runtime complexity?
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么线性搜索的运行时间复杂度是 *O(n)*？
- en: What does a jump search do better than a linear search?
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳查比线性查找做得更好是什么？
- en: What is a binary search and why is it comparable to a tree?
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是二分查找，为什么它与树形结构相似？
- en: Further reading
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here is some additional reference material that you may refer to regarding
    what has been covered in this chapter: [https://www.aaai.org/ocs/index.php/AAAI/AAAI14/paper/view/8357/8643](https://www.aaai.org/ocs/index.php/AAAI/AAAI14/paper/view/8357).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的参考资料，您可能需要参考本章所涵盖的内容：[https://www.aaai.org/ocs/index.php/AAAI/AAAI14/paper/view/8357/8643](https://www.aaai.org/ocs/index.php/AAAI/AAAI14/paper/view/8357)。
