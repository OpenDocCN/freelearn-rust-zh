- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: A Quick Introduction to Rust
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 快速入门
- en: '**Rust** is growing in popularity, but it has a steep learning curve. By covering
    the basic rules around Rust, as well as learning how to manipulate a range of
    data types and variables, we will be able to write simple programs in the same
    fashion as dynamically-typed languages using a similar number of lines of code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rust** 正在变得越来越受欢迎，但它的学习曲线很陡峭。通过了解 Rust 的基本规则，以及学习如何操作各种数据类型和变量，我们将能够以与动态类型语言相似的方式，使用相同数量的代码编写简单的程序。'
- en: The goal of this chapter is to cover the main differences between Rust and generic
    dynamic languages and to provide you with a quick understanding of how to utilize
    Rust.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是介绍 Rust 与通用动态语言之间的主要区别，并快速让你了解如何利用 Rust。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why is Rust revolutionary?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 Rust 是革命性的？
- en: Reviewing data types and variables in Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 Rust 中的数据类型和变量
- en: Controlling variable ownership
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制变量所有权
- en: Building structs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 struct
- en: Metaprogramming with macros
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用宏进行元编程
- en: Once we have covered the main concepts in this chapter, you will be able to
    code basic programs in Rust that will run. You will also be able to debug your
    programs and understand the error messages that are thrown by the Rust compiler.
    As a result, you will have the foundations to be productive in Rust. You will
    also be able to move on to structuring Rust code over multiple files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们掌握了本章的主要概念，你将能够编写能在 Rust 中运行的简单程序。你还将能够调试你的程序并理解 Rust 编译器抛出的错误信息。因此，你将拥有在
    Rust 中高效工作的基础。你还将能够将 Rust 代码组织到多个文件中。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we only need access to the internet as we will be using the
    online Rust playground to implement the code. The code examples provided can be
    run in the online Rust playground at [https://play.rust-lang.org/](https://play.rust-lang.org/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们只需要访问互联网，因为我们将在在线 Rust 操场中实现代码。提供的代码示例可以在在线 Rust 操场中运行。[https://play.rust-lang.org/](https://play.rust-lang.org/)
- en: 'For detailed instructions, please refer to the file found here: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter01](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter01)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于详细说明，请参阅以下文件：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter01](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter01)
- en: Why is Rust revolutionary?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么 Rust 是革命性的？
- en: With programming, there is usually a trade-off between speed and resources and
    development speed and safety. Low-level languages such as C/C++ can give the developer
    fine-grained control over the computer with fast code execution and minimal resource
    consumption. However, this is not free. Manual memory management can introduce
    bugs and security vulnerabilities. A simple example of this is a buffer overflow
    attack. This occurs when the programmer does not allocate enough memory. For instance,
    if the buffer only has a size of 15 bytes, and 20 bytes are sent, then the excess
    5 bytes might be written past the boundary. An attacker can exploit this by passing
    in more bytes than the buffer can handle. This can potentially overwrite areas
    that hold executable code with their own code. There are other ways to exploit
    a program that does not have correctly managed memory. On top of increased vulnerabilities,
    it takes more code and time to solve a problem in a low-level language. As a result
    of this, C++ web frameworks do not take up a large share of web development. Instead,
    it usually makes sense to go for high-level languages such as Python, Ruby, and
    JavaScript. Using such languages will generally result in the developer solving
    problems safely and quickly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，通常需要在速度和资源、开发速度和安全之间做出权衡。像 C/C++ 这样的低级语言可以给开发者提供对计算机的精细控制，代码执行速度快，资源消耗最小。然而，这并非没有代价。手动内存管理可能会引入错误和安全漏洞。一个简单的例子是缓冲区溢出攻击。这发生在程序员没有分配足够内存的情况下。例如，如果缓冲区只有
    15 字节大，而发送了 20 字节，那么额外的 5 字节可能会超出边界。攻击者可以通过传递比缓冲区能处理的更多字节来利用这一点。这可能会覆盖包含可执行代码的区域，并用自己的代码覆盖它们。还有其他方法可以攻击没有正确管理内存的程序。除了增加了漏洞之外，解决低级语言中的问题需要更多的代码和时间。因此，C++
    网络框架并没有占据网络开发的大份额。相反，通常选择使用像 Python、Ruby 和 JavaScript 这样的高级语言更有意义。使用这些语言通常会导致开发者安全且快速地解决问题。
- en: However, it must be noted that this memory safety comes at a cost. These high-level
    languages generally keep track of all the variables defined and their references
    to a memory address. When there are no more variables pointing to a memory address,
    the data in that memory address gets deleted. This process is called garbage collection
    and consumes extra resources and time as a program must be stopped to clean up
    the variables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，必须指出的是，这种内存安全是有代价的。这些高级语言通常跟踪所有定义的变量及其对内存地址的引用。当没有更多的变量指向内存地址时，该内存地址中的数据就会被删除。这个过程称为垃圾回收，它消耗额外的资源和时间，因为程序必须停止以清理变量。
- en: With Rust, memory safety is ensured without the costly garbage collection process.
    Rust ensures memory safety through a set of ownership rules checked at compile
    time with a borrow checker. These rules are the quirks mentioned in the following
    section. Because of this, Rust enables rapid, safe problem-solving with truly
    performant code, thus breaking the speed/safety trade-off.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Rust，内存安全无需昂贵的垃圾回收过程。Rust通过在编译时使用借用检查器检查的一组所有权规则来确保内存安全。这些规则是下一节中提到的怪癖。正因为如此，Rust能够通过真正高效的代码实现快速、安全的解决问题，从而打破了速度/安全性的权衡。
- en: Memory safety
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 内存安全
- en: Memory safety is the property of programs having memory pointers that always
    point to valid memory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 内存安全是程序具有始终指向有效内存的内存指针的特性。
- en: 'With more data processing, traffic, and complex tasks lifted into the web stack,
    Rust, with its growing number of web frameworks and libraries, has now become
    a viable choice for web development. This has led to some truly amazing results
    in the web space for Rust. In 2020, Shimul Chowdhury ran a series of tests against
    servers with the same specs but different languages and frameworks. The results
    can be seen in the following figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据处理、交通和复杂任务被提升到网络堆栈中，Rust凭借其不断增长的Web框架和库的数量，现在已成为Web开发的可行选择。这为Rust在Web领域带来了真正惊人的成果。在2020年，Shimul
    Chowdhury对具有相同规格但不同语言和框架的服务器进行了一系列测试。结果可以在以下图表中看到：
- en: '![Figure 1.1 – Results of different frameworks and languages by Shimul Chowdhury
    (found at https://www.shimul.dev/posts/06-04-2020-benchmarking-flask-falcon-actix-web-rocket-nestjs/)](img/Figure_1.1_B18722.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – Shimul Chowdhury对不同框架和语言的结果（可在https://www.shimul.dev/posts/06-04-2020-benchmarking-flask-falcon-actix-web-rocket-nestjs/找到）](img/Figure_1.1_B18722.jpg)'
- en: Figure 1.1 – Results of different frameworks and languages by Shimul Chowdhury
    (found at https://www.shimul.dev/posts/06-04-2020-benchmarking-flask-falcon-actix-web-rocket-nestjs/)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Shimul Chowdhury对不同框架和语言的结果（可在https://www.shimul.dev/posts/06-04-2020-benchmarking-flask-falcon-actix-web-rocket-nestjs/找到）
- en: 'In the preceding figure, we can see that there are some variations in the languages
    and frameworks. However, we must note that the Rust frameworks comprise Actix
    Web and Rocket. These Rust servers are in a completely different league when it
    comes to total requests handled and data transferred. Other languages, such as
    Golang, have come onto the scene, but the lack of garbage collection in Rust has
    managed to outshine Golang. This was demonstrated in Jesse Howarth’s blog post
    *Why Discord is switching from Go to Rust*, where the following graph was published:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到语言和框架之间存在一些差异。然而，我们必须注意，Rust框架包括Actix Web和Rocket。在处理总请求和数据传输方面，这些Rust服务器完全处于不同的水平。其他语言，如Golang，已经进入市场，但Rust中缺乏垃圾回收功能却成功地超越了Golang。这可以在Jesse
    Howarth的博客文章《Why Discord is switching from Go to Rust》中得到证明，其中发布了以下图表：
- en: '![Figure 1.2 – Discord’s findings => Golang is spikey and Rust is smooth (found
    at https://discord.com/blog/why-discord-is-switching-from-go-to-rust)](img/Figure_1.2_B18722.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – Discord的发现 => Golang波动较大，Rust则平滑（可在https://discord.com/blog/why-discord-is-switching-from-go-to-rust找到）](img/Figure_1.2_B18722.jpg)'
- en: Figure 1.2 – Discord’s findings => Golang is spikey and Rust is smooth (found
    at https://discord.com/blog/why-discord-is-switching-from-go-to-rust)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – Discord的发现 => Golang波动较大，Rust则平滑（可在https://discord.com/blog/why-discord-is-switching-from-go-to-rust找到）
- en: The garbage collection that Golang was implementing to keep the memory safe
    resulted in 2-minute spikes. This is not to say that we should use Rust for everything.
    It is best practice to use the right tool for the job. All these languages have
    different merits. What we have done in the preceding figure is merely display
    Rust’s merits.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Golang为了保持内存安全而实施的垃圾回收导致2分钟的峰值。这并不是说我们应该用Rust来做所有事情。最佳实践是使用适合工作的正确工具。所有这些语言都有不同的优点。我们在前面的图表中所做的是仅仅展示Rust的优点。
- en: The lack of need for garbage collection is because Rust uses enforced rules
    to ensure memory safety using the borrow checker. Now that we have understood
    why we want to code in Rust, we can move on to reviewing data types in the next
    section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无需垃圾回收的需求是因为 Rust 使用强制规则通过借用检查器来确保内存安全。既然我们已经了解了为什么想要用 Rust 编码，我们就可以继续到下一节检查数据类型。
- en: Reviewing data types and variables in Rust
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 Rust 中的数据类型和变量
- en: If you have coded in another language before, you will have used variables and
    handled different data types. However, Rust does have some quirks that can put
    off developers. This is especially true if the developer has come from a dynamic
    language, as these quirks mainly revolve around memory management and reference
    to variables. These can be intimidating initially, but when you get to understand
    them, you will learn to appreciate them. Some people might hear about these quirks
    and wonder why they should bother with the language at all. This is understandable,
    but these quirks are why Rust is such a paradigm-shifting language. Working with
    borrow checking and wrestling with concepts such as lifetimes and references gives
    us the high-level memory safety of a dynamic language such as Python. However,
    we can also get memory safe low-level resources such as those delivered by C and
    C++. This means that we do not have to worry about dangling pointers, buffer overflows,
    null pointers, segmentation faults, data races, and other issues when coding in
    Rust. Issues such as null pointers and data races can be hard to debug. With this
    in mind, the rules enforced are a good trade-off as we must learn about Rust’s
    quirks to get the speed and control of non-memory safe languages, but we do not
    get the headaches these non-memory-safe languages introduce.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在其他语言中编码过，你将使用变量并处理不同的数据类型。然而，Rust 确实有一些可能会让开发者感到沮丧的特点。这尤其适用于那些来自动态语言的开发者，因为这些特点主要围绕内存管理和变量的引用。这些特点一开始可能会让人感到害怕，但当你理解它们时，你会学会欣赏它们。有些人可能会听说这些特点，并想知道为什么他们应该费心学习这门语言。这是可以理解的，但正是这些特点让
    Rust 成为了一个范式转变的语言。与借用检查和与诸如生命周期和引用等概念作斗争，使我们能够获得像 Python 这样的动态语言的高级内存安全性。然而，我们也可以获得像
    C 和 C++ 提供的低级内存安全资源。这意味着在 Rust 中编码时，我们不必担心悬垂指针、缓冲区溢出、空指针、段错误、数据竞争和其他问题。像空指针和数据竞争这样的问题可能很难调试。考虑到这一点，强制执行的规则是一个很好的权衡，因为我们必须了解
    Rust 的特点，以获得非内存安全语言的速度和控制，但我们不会遇到这些非内存安全语言带来的头痛。
- en: Before we do any web development, we need to run our first program. We can do
    this in the Rust playground at [https://play.rust-lang.org/](https://play.rust-lang.org/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何网络开发之前，我们需要运行我们的第一个程序。我们可以在 Rust 操场中这样做，网址是 [https://play.rust-lang.org/](https://play.rust-lang.org/)。
- en: 'If you have never visited the Rust playground before, you will see the following
    layout once you are there:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未访问过 Rust 操场，当你到达那里时，你会看到以下布局：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code will look like the following screenshot when it comes to
    using the online Rust playground:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用在线 Rust 操场时，前面的代码将看起来像以下截图：
- en: '![Figure 1.3 – View of the online Rust playground](img/Figure_1.3_B18722.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 在线 Rust 操场视图](img/Figure_1.3_B18722.jpg)'
- en: Figure 1.3 – View of the online Rust playground
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 在线 Rust 操场视图
- en: 'In our `hello world` code, what we have is a `main` function, which is our
    entry point. This function fires when we run our program. All programs have entry
    points. If you have not heard of the concept before, due to coming from a dynamic
    language, the entry point is the script file that you point your interpreter at.
    For Python, a closer analogy would be the `main` block that runs if the file is
    directly run by the interpreter, denoted as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `hello world` 代码中，我们有一个 `main` 函数，这是我们的入口点。当运行我们的程序时，这个函数会被触发。所有程序都有入口点。如果你之前没有听说过这个概念，那可能是因为你来自动态语言，入口点是你指向解释器的脚本文件。对于
    Python 来说，一个更接近的类比是当文件直接由解释器运行时运行的 `main` 块，如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you were to code in Python, you would probably see this used in a Flask
    application. Right now, we have not done anything new. This is a standard *Hello
    World* example with a little change in syntax; however, even with this example,
    the string that we are printing is not all that it seems. For instance, let us
    write our own function that accepts a string and prints it out with the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用Python编写代码，你可能会在Flask应用程序中看到这种用法。目前，我们并没有做任何新的东西。这是一个标准的*Hello World*示例，只是语法上有一点变化；然而，即使在这个例子中，我们打印的字符串也不像看起来那么简单。例如，让我们编写自己的函数，该函数接受一个字符串并使用以下代码打印它：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code should just work. We pass it into our function and print it. However,
    if we do print it, we get the following printout:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该可以正常工作。我们将其传递给我们的函数并打印它。然而，如果我们打印它，我们会得到以下输出：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is not very straightforward, but it brings us to the first area we must
    understand if we are to code in Rust, and this is strings. Don’t worry, strings
    are the quirkiest variable that you need to get your head around to write functional
    Rust code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很直接，但它带我们来到了我们必须理解的第一块领域，那就是字符串。别担心，字符串是编写功能性Rust代码时你需要弄清楚的最古怪变量。
- en: Using strings in Rust
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Rust中使用字符串
- en: 'Before we explore the error in the previous section, let us rectify it, so
    we know what to work toward. We can get the `print` function to work without any
    errors with the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索上一节中的错误之前，让我们先纠正它，这样我们才知道我们要努力的方向。我们可以用以下代码让`print`函数在没有错误的情况下工作：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What we did was create a `String` from `"hello world"` and passed the `String`
    into the `print` function. This time the compiler did not throw an error because
    we always know the size of a `String`, so we can keep the right amount of memory
    free for it. This may sound counterintuitive because strings are usually of different
    lengths. It would not be a very flexible programming language if we were only
    allowed to use the same length of letters for every string in our code. This is
    because strings are essentially pointers implemented as a vector of bytes, which,
    in Rust, is denoted as `Vec<u8>`. This holds a reference to the string content
    (`str`, also known as a string slice) in the heap memory, as seen in the following
    figure:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是从`"hello world"`创建了一个`String`，并将其传递给`print`函数。这次编译器没有抛出错误，因为我们始终知道`String`的大小，因此我们可以保留足够的内存空间。这听起来可能有些反直觉，因为字符串通常有不同的长度。如果我们只能使用相同长度的字母来编写代码中的每个字符串，那么这将不是一个非常灵活的编程语言。这是因为字符串本质上是由字节向量实现的指针，在Rust中用`Vec<u8>`表示。它持有对堆内存中字符串内容（`str`，也称为字符串切片）的引用，如下面的图所示：
- en: '![](img/Figure_1.4_B18722.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_1.4_B18722.png)'
- en: Figure 1.4 – A string’s relationship to str “one”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 字符串与str“one”的关系
- en: 'We can see, in *Figure 1**.4*, that a string is a vector of three numbers.
    One is the actual memory address of the `str` it is referencing. The second number
    is the size of the memory allocated, and the third is the length of the string
    content. Therefore, we can access string literals in our code without having to
    pass variables of various sizes around our code. We know that `String` has a set
    size and, therefore, can allocate this size in the `print` function. It also must
    be noted that `String` is on the stack memory while our string literal is on the
    heap memory. Considering that we know that `String` has a set size while our string
    literal varies, we can deduce that the stack memory is used for predictable memory
    sizes and is allocated ahead of time when the program runs. Our heap memory is
    dynamic, and therefore memory is allocated when it is needed. Now that we know
    the basics of strings, we can use the different ways in which they are created,
    as seen in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**图1.4**中看到，字符串是一个包含三个数字的向量。第一个数字是它所引用的`str`的实际内存地址。第二个数字是分配的内存大小，第三个是字符串内容长度。因此，我们可以在代码中访问字符串字面量，而无需在代码中传递各种大小的变量。我们知道`String`有一个固定的大小，因此可以在`print`函数中分配这个大小。还必须注意的是，`String`位于栈内存中，而我们的字符串字面量位于堆内存中。考虑到我们知道`String`有一个固定的大小，而我们的字符串字面量是可变的，我们可以推断出栈内存用于可预测的内存大小，并且在程序运行时提前分配。我们的堆内存是动态的，因此当需要时才分配内存。现在我们知道了字符串的基本知识，我们可以使用它们创建的不同方式，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We must note, however, that creating `string_three` is expensive as we must
    copy the underlying data in the heap, and heap operations are expensive. This
    is not a unique quirk of Rust. In our example, we are just experiencing what happens
    under the hood. For instance, if we alter strings in Python, we will have different
    outcomes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意，然而，创建`string_three`是昂贵的，因为我们必须在堆中复制底层数据，而堆操作是昂贵的。这并不是Rust特有的怪癖。在我们的例子中，我们只是在体验底层发生了什么。例如，如果我们修改Python中的字符串，我们将会得到不同的结果：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Looping through and adding the strings is slower because Python must allocate
    new memory and copy the entire string to that new memory address. The `join` method
    is faster because Python can allocate the memory of all the data of the list and
    then copy over the strings in the array, meaning the string must only be copied
    once. This shows us that although high-level languages like Python may not force
    you to think about the memory allocation of strings, you will still end up paying
    the price if you don’t acknowledge it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过循环添加字符串会更慢，因为Python必须分配新的内存并将整个字符串复制到新的内存地址。`join`方法更快，因为Python可以分配列表中所有数据的内存，然后复制数组中的字符串，这意味着字符串只需复制一次。这表明，尽管像Python这样的高级语言可能不会强迫你考虑字符串的内存分配，但如果你不承认这一点，你仍然会付出代价。
- en: 'We can also pass a string literal into the `print` function by borrowing it,
    as seen in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过借用，将字符串字面量传递给`print`函数，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The borrow is denoted by `&`. We will go into borrowing later in the chapter.
    For now, however, we can deduce that the borrow is only a fixed-size reference
    to a variable-sized string slice. If the borrow was a fixed size, we would not
    be able to pass it into the `print` function because we would not know the size.
    At this point, we can comfortably use strings in Rust productively. The next concept
    that we must understand before we start writing Rust programs is integers and
    floats.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 借用用`&`表示。我们将在本章的后面讨论借用。现在，我们可以推断出借用只是一个固定大小的变量大小字符串切片的引用。如果借用是固定大小，我们就不能将其传递给`print`函数，因为我们不知道大小。在这个时候，我们可以舒适地在Rust中使用字符串。在我们开始编写Rust程序之前，我们必须理解的概念是整数和浮点数。
- en: Using integers and floats
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用整数和浮点数
- en: 'In most high-level web programming languages, we merely assign a float or integer
    to a variable name and move on with the program. However, from what we have been
    exposed to in the previous section on strings, we now understand that we must
    worry about memory size when using strings in Rust. This is no different with
    integers and floats. We know that integers and floats have a range of sizes. Therefore,
    we must tell Rust what we are passing around our code. Rust supports signed integers,
    which are denoted by `i`, and unsigned integers, which are denoted by `u`. These
    integers consist of 8, 16, 32, 64, and 128 bits. Exploring the math behind numbers
    being represented in binary is not relevant for this book; however, we do need
    to understand the range of numbers that can be represented with several bits,
    as this will help us understand what the different types of floats and integers
    in Rust denote. Because binary is either a 0 or a 1, we can calculate the range
    of integers that can be represented by the bits by raising 2 to the power of the
    number of bits we have. For example, if we have an integer that is represented
    by 8 bits, 2 to the power of 8 equates to 256\. We must remember that 0 is also
    represented. Considering this, an integer of 8 bits has a range of 0 to 255\.
    We can test this calculation with the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数高级Web编程语言中，我们只是将浮点数或整数赋给变量名，然后继续程序。然而，根据我们在字符串部分之前所接触到的内容，我们现在理解，在使用Rust中的字符串时，我们必须担心内存大小。整数和浮点数也是如此。我们知道整数和浮点数有大小范围。因此，我们必须告诉Rust我们在代码中传递了什么。Rust支持有符号整数，用`i`表示，和无符号整数，用`u`表示。这些整数由8、16、32、64和128位组成。探索数字在二进制表示背后的数学并不适用于这本书；然而，我们需要了解使用几个位可以表示的数字范围，因为这将帮助我们理解Rust中不同类型的浮点数和整数表示什么。因为二进制要么是0要么是1，我们可以通过将2的位数次幂来计算可以表示的整数范围。例如，如果我们有一个由8位表示的整数，2的8次幂等于256。我们必须记住0也是被表示的。考虑到这一点，8位的整数范围是0到255。我们可以用以下代码测试这个计算：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is one higher than the range that we calculated. As a result, we should
    not be surprised to see the overflow error as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们计算的范围高一个。因此，我们不应该对看到以下溢出错误感到惊讶：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, we can deduce that if we lower the unsigned integer to `255`, it will pass.
    However, let’s say we change the unsigned integer into a signed integer with the
    following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以推断，如果我们把无符号整数降低到 `255`，它将可以通过。但是，假设我们用以下代码将无符号整数转换为有符号整数：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will see that we get a helpful error message as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到我们得到以下有用的错误信息：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this helpful error message, we can see that a signed integer considers
    negative numbers, so the absolute value that a signed integer can take is roughly
    half. Therefore, we can increase the range by assigning the number as a 16-bit
    signed integer with the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于的这条错误信息，我们可以看到有符号整数考虑了负数，因此有符号整数可以取的绝对值大约是二分之一。因此，我们可以通过以下代码将数字作为 16 位有符号整数来增加范围：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This would work. However, let us add our 16-bit integer with our 8-bit integer
    using the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效。然而，让我们用以下代码将我们的 16 位整数与 8 位整数相加：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The previous code might look a little different to you. All we have done in
    the preceding code is define the data type with a suffix instead. So, `number`
    has a value of `255` and a type of `i16`, and `number_two` has a value of `5`
    and a type of `i8`. If we run the previous code, we get the following error:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可能看起来有些不同。在前面的代码中，我们只是用后缀定义了数据类型。所以，`number` 的值是 `255`，类型是 `i16`，而 `number_two`
    的值是 `5`，类型是 `i8`。如果我们运行前面的代码，我们会得到以下错误：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will cover traits later in this chapter. For now, all we must understand
    is that we cannot add the two different integers. If they were both the same type,
    then we could. We can change the integer type through casting using `as`, as seen
    in the following line of code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论特质。现在，我们必须理解的是，我们不能将两个不同类型的整数相加。如果它们都是同一类型，那么我们可以。我们可以通过类型转换使用 `as`
    来更改整数类型，如下面的代码行所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This means that `number_two` is now a 16-bit integer, and `result` will be
    260\. However, we must be careful with casting because if we were to do it the
    wrong way, we could end up with a silent bug, which is unusual for Rust. If we
    cast `number` as `i8` instead of casting `number_two` as `i16`, then `result`
    would equate to 4, which does not make sense because 255 + 5 equals 260\. This
    is because `i8` is smaller than `i16`. So, if we cast an `i16` integer as an `i8`
    integer, we are essentially chopping off some of the data, by just taking the
    lower bits of the number and disregarding the upper bits. Therefore, `number`
    ends up being -1 if we cast it to an `i8` integer. To be safer, we can use the
    `i8::from` function, as seen in the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `number_two` 现在是一个 16 位整数，而 `result` 将是 260。然而，我们必须小心类型转换，因为如果我们以错误的方式执行，我们可能会遇到一个静默的错误，这在
    Rust 中是不常见的。如果我们将 `number` 转换为 `i8` 类型而不是将 `number_two` 转换为 `i16` 类型，那么 `result`
    将等于 4，这没有意义，因为 255 + 5 等于 260。这是因为 `i8` 类型小于 `i16` 类型。因此，如果我们把 `i16` 整数转换为 `i8`
    整数，我们实际上是在截断一些数据，只取数字的低位，而忽略高位。因此，如果我们把 `number` 转换为 `i8` 整数，它最终会变成 -1。为了更安全，我们可以使用
    `i8::from` 函数，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running this will give us the following error:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将给出以下错误：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again, we will go over traits later on in the chapter, but we can see in the
    preceding code that because the `From<i16>` trait is not implemented for an `i8`
    integer, we cannot cast an `i8` integer into an `i16` integer. With this understood,
    we are free to work with integers safely and productively. One last point about
    integer sizes in Rust is that they are not continuous. The supported sizes are
    shown in the following table:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将在本章后面讨论特质，但我们可以看到在前面的代码中，由于 `From<i16>` 特质没有为 `i8` 整数实现，我们不能将 `i8` 整数转换为
    `i16` 整数。理解了这一点，我们可以自由地安全且高效地处理整数。关于 Rust 中整数大小的最后一个要点是，它们不是连续的。支持的大小如下表所示：
- en: '| **Bits** | **Calculation** | **Size** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **计算** | **大小** |'
- en: '| 8 | 2^8 | 256 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 2^8 | 256 |'
- en: '| 16 | 2^16 | 65536 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 2^16 | 65536 |'
- en: '| 32 | 2^32 | 4294967296 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 2^32 | 4294967296 |'
- en: '| 64 | 2^64 | 1.8446744e+19 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 2^64 | 1.8446744e+19 |'
- en: '| 128 | 2^128 | 3.4028237e+38 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 2^128 | 3.4028237e+38 |'
- en: Table 1.1 – Size of integer types
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 整数类型的大小
- en: 'When it comes to floats, Rust accommodates `f32` and `f64` floating-point numbers.
    Both these floating-point types support negative and positive values. Declaring
    a floating-point variable requires the same syntax as integers, as seen in the
    following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到浮点数时，Rust 支持浮点数 `f32` 和 `f64`。这两种浮点类型都支持负数和正数。声明浮点变量需要与整数相同的语法，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this, we can comfortably work with integers and floats in our Rust code.
    However, we know as developers that just declaring floats and integers is not
    very useful. We want to be able to contain and loop through them. In the next
    section, we will do just that with vectors and arrays.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以在Rust代码中舒适地处理整数和浮点数。然而，作为开发者，我们知道仅仅声明浮点数和整数并不是非常有用。我们希望能够包含并遍历它们。在下一节中，我们将使用向量和数组来实现这一点。
- en: Storing data in vectors and arrays
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在向量和数组中存储数据
- en: 'In Rust, we can store our floats, integers, and strings in arrays and vectors.
    First, we will focus on arrays. Arrays are stored on stack memory. Knowing this,
    and remembering what we learned about strings, we can deduce that arrays are of
    a fixed size. This is because, as we remember, if the variable is stored on the
    stack, then the memory is allocated and loaded into the stack when the program
    starts. We can define an array of integers, loop through it, print each integer,
    and then access an integer by index with the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们可以将我们的浮点数、整数和字符串存储在数组和向量中。首先，我们将专注于数组。数组存储在栈内存中。了解这一点，并记住我们学到的关于字符串的知识，我们可以推断出数组的大小是固定的。这是因为，正如我们记得的，如果变量存储在栈上，那么内存将在程序开始时分配并加载到栈中。我们可以定义一个整数数组，遍历它，打印每个整数，然后通过索引访问一个整数，以下代码可以做到这一点：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the previous code, we define the type and size by wrapping them in square
    brackets. For instance, if we were going to create an array of floats with a length
    of 4, we would use `int_array: [f32; 4] = [1.1, 2.2, 3.3, 4.4]`. Running the preceding
    code will give you the following printout:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '使用前面的代码，我们通过将它们括在方括号中来定义类型和大小。例如，如果我们打算创建一个长度为4的浮点数数组，我们会使用`int_array: [f32;
    4] = [1.1, 2.2, 3.3, 4.4]`。运行前面的代码将给出以下打印输出：'
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding printout, we see that the loop works and that we can access
    the second integer with square brackets. Although the memory size of the array
    is fixed, we can still change it. This is where mutability comes in. When we define
    a variable as mutable, this means that we can mutate it. In other words, we can
    alter the value of the variable after it has been defined if it is mutable. If
    you tried to update any of the variables in the code that we have written in this
    chapter, you will have realized that you can’t. This is because all variables
    in Rust are immutable by default. We can make any variable in Rust mutable by
    putting a `mut` tag in front of the variable name. Going back to the fixed array,
    we cannot change the size of the array, meaning we cannot append/push new integers
    to it due to it being stored on stack memory. However, if we define a mutable
    array, we can update parts of it with other integers that are the same memory
    size. An example of this is the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的打印输出中，我们看到循环是有效的，并且我们可以通过方括号访问第二个整数。尽管数组的内存大小是固定的，我们仍然可以改变它。这就是可变性的作用所在。当我们定义一个变量为可变时，这意味着我们可以对其进行修改。换句话说，如果变量是可变的，我们可以在定义之后改变其值。如果你尝试更新本章中编写的代码中的任何变量，你会发现你无法这样做。这是因为Rust中的所有变量默认都是不可变的。我们可以在变量名前加上`mut`标签来使任何变量在Rust中变为可变。回到固定数组，我们无法改变数组的大小，这意味着由于它存储在栈内存中，我们无法向其中追加/推送新的整数。然而，如果我们定义一个可变数组，我们可以使用相同内存大小的其他整数来更新其部分。以下代码是一个例子：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we can see that the last integer in our array is updated
    to `3`. We then print out the full array and then print out the length. You may
    have also noted that the first print statement of the preceding code now employs
    `{:?}`. This calls the `Debug` trait. If `Debug` is implemented for the thing
    that we are trying to print, then the full representation of the thing we are
    printing is then displayed in the console. You can also see that we print out
    the result of the length of the array. Running this code will give the following
    printout:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到数组中的最后一个整数被更新为`3`。然后我们打印出整个数组，然后打印出长度。你可能也注意到，前面代码的第一个打印语句现在使用了`{:?}`。这调用了`Debug`特质。如果我们为要打印的东西实现了`Debug`，那么打印的东西的完整表示将在控制台显示。你还可以看到我们打印出了数组长度的结果。运行此代码将给出以下打印输出：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the preceding printout, we can confirm that the array is now updated.
    We can also access slices with our arrays. To demonstrate this, we can create
    an array of 100 zeros. We can then take a slice of this and print it out with
    the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的打印输出，我们可以确认数组现在已更新。我们还可以使用数组访问切片。为了演示这一点，我们可以创建一个包含100个零的数组。然后我们可以从这个数组中取一个切片，并使用以下代码打印它：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running the preceding code will result in the following printout:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将产生以下输出：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are now able to be productive with arrays. Arrays can be useful for caching.
    For instance, if we know the amount that we need to store, then we can use arrays
    effectively. However, we have only managed to store one type of data in the array.
    If we tried to store strings and integers in the same array, we would have a problem.
    How would we define the type? This problem goes for all collections, such as vectors
    and **HashMaps**. There are multiple ways to do this, but the most straightforward
    is using enums. Enums are, well, enums. In dynamic languages such as Python, you
    may not have had to use them due to being able to pass any type anywhere you want.
    However, they are still available. Enum is short for enumerated type and basically
    defines a type with possible variants. In our case, we want our array to store
    strings and integers in the same collection. We can do this by initially defining
    our enum with the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够使用数组进行生产。数组对于缓存很有用。例如，如果我们知道需要存储的量，那么我们可以有效地使用数组。然而，我们只成功地在数组中存储了一种类型的数据。如果我们试图在同一个数组中存储字符串和整数，我们会遇到问题。我们如何定义类型？这个问题适用于所有集合，如向量、**HashMaps**。有多种方法可以做到这一点，但最直接的方法是使用枚举。枚举就是枚举。在像Python这样的动态语言中，你可能不需要使用它们，因为你可以将任何类型传递到任何你想去的地方。然而，它们仍然可用。枚举是枚举类型的简称，基本上定义了一个具有可能变体的类型。在我们的情况下，我们希望我们的数组能够在同一个集合中存储字符串和整数。我们可以通过以下代码初始化我们的枚举来实现这一点：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, we can see that we defined an enum with the name of
    `SomeValue`. We then denoted that `StringValue` holds the value of a string and
    that `IntValue` holds the value of an integer. We can then define an array with
    a length of `4`, consisting of 2 strings and 2 integers, with the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们定义了一个名为`SomeValue`的枚举。然后我们表示`StringValue`存储字符串值，而`IntValue`存储整数值。然后我们可以定义一个长度为`4`的数组，包含2个字符串和2个整数，以下代码所示：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, we can see that we wrap our strings and integers in
    our enum. Now, looping through and getting it out is going to be another task.
    For instance, there are things that we can do to an integer that we cannot do
    to a string and vice versa. Considering this, we are going to have to use a `match`
    statement when looping through the array, as seen in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们将字符串和整数包裹在我们的枚举中。现在，在循环中获取它们将是一项额外的任务。例如，我们可以对整数执行的操作，而对字符串则不能，反之亦然。考虑到这一点，在循环数组时，我们需要使用`match`语句，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, we can see that if `i` is `SomeValue::StringValue`,
    we then assign the data wrapped in `SomeValue::StringValue` to the variable named
    `data`. We then pass `data` into the inner scope to be printed. We use the same
    approach with our integer. Even though we are merely printing to demonstrate the
    concept, we can do anything in these inner scopes to the `data` variable that
    the type allows us to. Running the preceding code gives the following printout:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到如果`i`是`SomeValue::StringValue`，我们就将包裹在`SomeValue::StringValue`中的数据分配给名为`data`的变量。然后我们将`data`传递到内部作用域以进行打印。我们以相同的方式处理整数。尽管我们只是在打印以演示概念，但我们可以在这些内部作用域中对`data`变量执行类型允许的任何操作。运行前面的代码将产生以下输出：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using enums to wrap data and `match` statements to handle them can be applied
    to HashMaps and vectors. Also, what we have covered with arrays can be applied
    to vectors. The only difference is that we do not have to define the length and
    that we can increase the size of the vector if needed. To demonstrate this, we
    can create a vector of strings and then add a string to the end with the following
    code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用枚举包裹数据和`match`语句处理数据的方法可以应用于HashMaps和向量。此外，我们用数组涵盖的内容也可以应用于向量。唯一的区别是我们不需要定义长度，并且如果需要，我们可以增加向量的大小。为了演示这一点，我们可以创建一个字符串向量，然后添加一个字符串到末尾，以下代码所示：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we can see that we use the `vec!` macro to create the
    vector of strings. You may have noticed with macros such as `vec!` and `println!`
    that we can vary the number of inputs. We will cover macros later in the chapter.
    Running the preceding code will result in the following printout:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们使用`vec!`宏来创建字符串向量。你可能已经注意到，像`vec!`和`println!`这样的宏可以改变输入的数量。我们将在本章后面介绍宏。运行前面的代码将产生以下输出：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also create an empty vector with the `new` function from the `Vec` struct
    with `let _empty_vector: Vec<&str> = Vec::new();`. You may be wondering when to
    use vectors and when to use arrays. Vectors are more flexible. You may be tempted
    to reach for arrays for performance gains. At face value, this seems logical as
    it is stored in the stack. Accessing the stack is going to be quicker because
    the memory sizes can be computed at compile time, making the allocation and deallocation
    simpler compared to the heap. However, because it is on the stack it cannot outlive
    the scope that it is allocated. Moving a vector around would merely require moving
    a pointer around. However, moving an array requires copying the whole array. Therefore,
    copying fixed-size arrays is more expensive than moving a vector. If you have
    a small amount of data that you only need in a small scope and you know the size
    of the data, then reaching for an array does make sense. However, if you’re going
    to be moving the data around, even if you know the size of the data, using vectors
    is a better choice. Now that we can be productive with basic collections, we can
    move on to a more advanced collection, a HashMap.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以使用 `Vec` 结构的 `new` 函数创建一个空向量，代码如下：`let _empty_vector: Vec<&str> = Vec::new();`。你可能想知道何时使用向量，何时使用数组。向量更加灵活。你可能为了性能提升而倾向于使用数组。从表面上看，这似乎是合理的，因为它存储在栈上。访问栈将会更快，因为内存大小可以在编译时计算出来，这使得分配和释放比堆简单。然而，因为它在栈上，所以它不能超出其分配的作用域。移动向量只需要移动指针。然而，移动数组需要复制整个数组。因此，复制固定大小的数组比移动向量更昂贵。如果你只有少量数据，你只需要在小的作用域中使用这些数据，并且你知道数据的大小，那么使用数组是有意义的。然而，如果你将要移动数据，即使你知道数据的大小，使用向量也是一个更好的选择。现在我们可以使用基本的集合进行生产，我们可以继续到更高级的集合，即
    HashMap。'
- en: Mapping data with HashMaps
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 HashMap 映射数据
- en: 'In some other languages, HashMaps are referred to as dictionaries. They have
    a key and a value. We can insert and get values using the key. Now that we have
    learned about handling collections, we can get a little more adventurous in this
    section. We can create a simple profile of a game character. In this character
    profile, we are going to have a name, age, and a list of items that they have.
    This means that we need an enum that houses a string, an integer, and a vector
    that also houses strings. We will want to print out the complete HashMap to see
    whether our code is correct in one glance. To do this, we are going to implement
    the `Debug` trait for our enum, as seen in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些其他语言中，HashMaps 被称为字典。它们有一个键和一个值。我们可以使用键来插入和获取值。现在我们已经学习了如何处理集合，我们可以在本节中稍微大胆一些。我们可以创建一个游戏角色的简单档案。在这个角色档案中，我们将有一个名字、年龄以及他们拥有的物品列表。这意味着我们需要一个枚举来容纳一个字符串、一个整数以及一个也容纳字符串的向量。我们希望打印出完整的
    HashMap 来查看我们的代码是否正确。为此，我们将为我们的枚举实现 `Debug` 特性，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we can see that we have annotated our enum with the
    `derive` attribute. An attribute is metadata that can be applied to the `CharacterValue`
    enum in this case. The `derive` attribute tells the compiler to provide a basic
    implementation of a trait. So, in the preceding code, we are telling the compiler
    to apply the basic implementation of `Debug` to the `CharacterValue` enum. With
    this, we can then create a new HashMap that has keys pointing to the values we
    defined with the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们对枚举使用了 `derive` 属性。在这种情况下，属性是应用于 `CharacterValue` 枚举的元数据。`derive`
    属性告诉编译器提供一个特性的基本实现。因此，在前面的代码中，我们告诉编译器将 `Debug` 特性的基本实现应用于 `CharacterValue` 枚举。有了这个，我们就可以创建一个新的
    HashMap，其键指向我们定义的值，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We stated that it is mutable because we are going to insert values with the
    following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说它是可变的，因为我们将要使用以下代码插入值：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can see that we have inserted all the data that we need. Running this would
    give us the following printout:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们已经插入了所有需要的数据。运行此代码将给出以下输出：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding output, we can see that our data is correct. Inserting it
    is one thing; however, we now must get it out again. We can do this with a `get`
    function. The `get` function returns an `Option` type. The `Option` type returns
    either `Some` or `None`. So, if we were to get `name` from our HashMap, we would
    need to do two matches, as seen in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到我们的数据是正确的。插入它是另一回事；然而，我们现在必须再次获取它。我们可以使用一个`get`函数来完成这个操作。`get`函数返回一个`Option`类型。`Option`类型返回`Some`或`None`。所以，如果我们从我们的HashMap中获取`name`，我们需要进行两次匹配，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, we can check to see if there is a name in the keys.
    If there is not, then we just print out that it was not present. If the `name`
    key is present, we then move on to our second check, which prints out the name
    if it is `CharacterValue::Name`. However, there is something wrong if the `name`
    key is not housing  `CharacterValue::Name`. So, we add only one more check in
    `match`, which is `_`. This is a catch meaning `anything else`. We are not interested
    in anything other than `CharacterValue::Name`. Therefore, the `_` catch maps to
    a `panic!` macro, which essentially throws an error. We could make this shorter.
    If we know that the `name` key is going to be in the HashMap, we can employ the
    `unwrap` function with the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以检查键中是否有名称。如果没有，我们就打印出它不存在。如果`name`键存在，我们就继续进行第二个检查，如果它是`CharacterValue::Name`，就打印出名称。然而，如果`name`键没有包含`CharacterValue::Name`，那么就会有问题。所以，我们在`match`中添加了一个额外的检查，即`_`。这是一个捕获，意味着“任何其他东西”。我们只对`CharacterValue::Name`以外的任何东西不感兴趣。因此，`_`捕获映射到`panic!`宏，这本质上会抛出一个错误。我们可以使这个更短。如果我们知道`name`键将存在于HashMap中，我们可以使用以下代码来使用`unwrap`函数：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `unwrap` function directly exposes the result. However, if the result is
    `None`, then it will directly result in an error terminating the program, which
    would look like the following printout:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`unwrap`函数直接暴露了结果。然而，如果结果是`None`，那么它将直接导致程序终止的错误，如下面的打印输出所示：'
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This might seem risky, but in practice, you will end up using the `unwrap` function
    a lot because you need direct access to the result, and you cannot carry on the
    program without it anyway. A prime example is connecting to a database. In a lot
    of web programming, if the database connection is not successful, then you cannot
    carry on with the API call. Therefore, it makes sense to just allow an error like
    most other web languages would. Now that we have been exposed to errors terminating
    the program, we might as well learn how to handle errors in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些冒险，但在实践中，你最终会大量使用`unwrap`函数，因为你需要直接访问结果，而且无论如何你都无法继续程序。一个典型的例子是连接到数据库。在许多Web编程中，如果数据库连接不成功，那么你无法继续进行API调用。因此，允许错误就像大多数其他Web语言一样是有意义的。既然我们已经了解了终止程序的错误，那么我们不妨在下一节学习如何处理错误。
- en: Handling results and errors
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理结果和错误
- en: 'In the previous section, we learned that directly unwrapping `Option` resulting
    in `None` panics a thread. There is another outcome that can also throw an error
    if unsuccessfully unwrapped, and this is `Result`. The `Result` type can return
    either `Ok` or `Err`. To demonstrate this, we can create a basic function that
    returns a `Result` type based on a simple Boolean we pass into it with the following
    code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到直接解包`Option`并返回`None`会导致线程恐慌。还有另一种情况，如果无法成功解包，它也会引发错误，那就是`Result`。`Result`类型可以返回`Ok`或`Err`。为了演示这一点，我们可以创建一个基本的函数，该函数返回一个基于我们传递给它的简单布尔值的`Result`类型，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding code, we can see that we return `Result<i8, &''static str>`.
    This means that we return an integer if `Result` is `Ok`, or we return an integer
    if `Result` is `Err`. The `&''static str` variable is basically our error string.
    We can tell it’s a reference because of `&`. The `''static` part means that the
    reference is valid for the entire lifetime of the running program. If this does
    not make sense now, do not worry, we will be covering lifetimes later in the chapter.
    Now that we have created our error-checking function, we can test to see what
    these outcomes look like with the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们返回`Result<i8, &'static str>`。这意味着如果`Result`是`Ok`，我们返回一个整数；如果`Result`是`Err`，我们也返回一个整数。`&'static
    str`变量基本上是我们的错误字符串。我们可以通过`&`知道它是一个引用。`'static`部分意味着这个引用在整个程序的运行期间都是有效的。如果现在这还不清楚，不要担心，我们将在本章后面的部分介绍生命周期。现在我们已经创建了一个错误检查函数，我们可以使用以下代码来测试这些结果看起来像什么：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running the preceding code gives us the following printout:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding output, we can see that it returned exactly what we wanted.
    We can also note that we can run the `is_err()` function on the `Result` variable,
    resulting in `false` if returning `Ok` or `true` if returning `Err`. We can also
    directly unwrap but add extra tracing to the stack trace with the following `expect`
    function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到它确实返回了我们想要的结果。我们还可以注意到，我们可以在`Result`变量上运行`is_err()`函数，如果返回`Ok`则结果为`false`，如果返回`Err`则结果为`true`。我们还可以直接解包，但使用以下`expect`函数添加额外的跟踪到堆栈跟踪中：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding function will result in the following printout:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将产生以下输出：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Through the preceding example, we can see that we get the message from the `expect`
    function first, and then the error message returned in `Result`. With this understanding,
    we can throw, handle, and add extra tracing to errors. However, we are getting
    more exposed to lifetimes and borrow references as we move forward. Now is the
    time to address this by understanding variable ownership.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的示例，我们可以看到我们首先收到`expect`函数的消息，然后是`Result`返回的错误消息。有了这个理解，我们可以抛出、处理并添加额外的跟踪到错误中。然而，随着我们继续前进，我们更多地暴露于生命周期和借用引用。现在是时候通过理解变量所有权来解决这个问题。
- en: Controlling variable ownership
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制变量所有权
- en: 'As we remember from the beginning of the chapter, Rust does not have a garbage
    collector. However, it has memory safety. It achieves this by having strict rules
    around variable ownership. These rules are enforced when Rust is being compiled.
    If you are coming from a dynamic language, then this can initially lead to frustration.
    This is known as *fighting the borrow checker*. Sadly, this unjustly gives Rust
    the false *steep learning curve* reputation, as when you are fighting the borrow
    checker without knowing what is going on, it can seem like an impossible task
    to get even the most basic programs written. However, if we take the time to learn
    the rules before we try and code anything too complex, the knowledge of the rules
    and the helpfulness of the compiler will make writing code in Rust fun and rewarding.
    Again, I take the time to remind you that Rust has been the most favorited language
    7 years in a row. This is not because it’s impossible to get anything done in
    it. The people who vote for Rust in these surveys understand the rules around
    ownership. Rust’s compiling, checking, and enforcing of these rules protect against
    the following errors:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从本章的开头所记得的，Rust没有垃圾回收器。然而，它具有内存安全。它是通过在变量所有权周围有严格的规则来实现的。这些规则在Rust编译时得到执行。如果你来自动态语言，那么这可能会最初导致挫败感。这被称为*与借用检查器斗争*。遗憾的是，这无端地给Rust带来了虚假的*陡峭的学习曲线*声誉，因为当你不知道发生了什么而与借用检查器斗争时，编写甚至最基本的程序似乎是一项不可能的任务。然而，如果我们花时间在学习规则之前尝试编写任何过于复杂的代码，那么对规则的了解和编译器的帮助将使在Rust中编写代码变得有趣且有益。再次提醒，Rust已经连续7年是最受欢迎的语言。这并不是因为它不可能完成任何事情。在这些调查中为Rust投票的人理解所有权规则。Rust的编译、检查和执行这些规则可以防止以下错误：
- en: '**Use after frees**: This occurs when memory is accessed once it has been freed,
    which can cause crashes. It can also allow hackers to execute code via this memory
    address.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用后释放**：当内存被释放后再次访问时发生，这可能导致崩溃。它还可能允许黑客通过此内存地址执行代码。'
- en: '**Dangling pointers**: This occurs when a reference points to a memory address
    that no longer houses the data that the pointer was referencing. Essentially,
    this pointer now points to null or random data.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**悬垂指针**：当引用指向不再包含引用的数据的内存地址时发生。本质上，这个指针现在指向了空或随机数据。'
- en: '**Double frees**: This occurs when allocated memory is freed and then freed
    again. This can cause the program to crash and increases the risk of sensitive
    data being revealed. This also enables a hacker to execute arbitrary code.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双重释放**：当分配的内存被释放然后再次释放时发生。这可能导致程序崩溃，并增加敏感数据泄露的风险。这也使黑客能够执行任意代码。'
- en: '**Segmentation faults**: This occurs when the program tries to access the memory
    it’s not allowed to access.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**段错误**：当程序尝试访问它不允许访问的内存时发生。'
- en: '**Buffer overrun**: An example of this error is reading off the end of an array.
    This can cause the program to crash.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区溢出**：这种错误的例子是读取数组末尾之外的数据。这可能导致程序崩溃。'
- en: 'To protect against these errors and thus achieve memory safety, Rust enforces
    the following rules:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些错误并实现内存安全，Rust强制执行以下规则：
- en: Values are owned by the variables assigned to them
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值由分配给它们的变量拥有
- en: As soon as the variable moves out of the scope of where it was defined, it is
    then deallocated from the memory
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦变量超出其定义的作用域，它就会被从内存中释放
- en: Values can be referenced and altered if we adhere to the rules for copying,
    moving, immutable borrowing, and mutable borrowing
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们遵守复制、移动、不可变借用和可变借用的规则，值可以被引用和修改
- en: Knowing the rules is one thing but, to practically work with the rules in Rust
    code, we need to understand copying, moving, and borrowing in more detail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 了解规则是一回事，但要在Rust代码中实际应用这些规则，我们需要更详细地了解复制、移动和借用。
- en: Copying variables
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制变量
- en: Copying occurs when a value is copied. Once it has been copied, the new variable
    owns the value, while the existing variable also owns its own value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 复制发生在值被复制时。一旦复制完成，新变量拥有该值，而现有变量也拥有自己的值。
- en: '![Figure 1.5 – Variable copy path](img/Figure_1.5_B18722.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 变量复制路径](img/Figure_1.5_B18722.jpg)'
- en: Figure 1.5 – Variable copy path
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 变量复制路径
- en: 'In *Figure 1**.5*, we can see that the path of `copy` trait, then it will automatically
    be copied, as seen in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1**.5*中，我们可以看到`copy`特质的路径，然后它将自动被复制，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Running the preceding code will give us the following printout:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将给出以下打印输出：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding example, we appreciate that the very fact that variables `one`
    and `two` can be printed indicates that `one` has been copied for `two` to utilize.
    To test this, we can test our example with strings using the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们欣赏到变量`one`和`two`可以被打印出来这一事实，表明`one`已经被复制以供`two`使用。为了测试这一点，我们可以使用以下代码测试我们的示例：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Running this code will result in the following error:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将导致以下错误：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Because strings do not implement the `Copy` trait, the code does not work,
    as `one` was moved to `two`. However, the code will run if we get rid of `println!("{}",
    one);`. This brings us to the next concept that we must understand: moving.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串没有实现`Copy`特性，所以代码无法运行，因为`one`被移动到了`two`。然而，如果我们删除`println!("{}", one);`，代码将可以运行。这让我们来到了下一个我们必须理解的概念：移动。
- en: Moving variables
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动变量
- en: Moving refers to when the value is moved from one variable to another. However,
    unlike copying, the original variable no longer owns the value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 移动指的是值从一个变量移动到另一个变量。然而，与复制不同，原始变量不再拥有该值。
- en: '![Figure 1.6 – Variable move path](img/Figure_1.6_B18722.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 变量移动路径](img/Figure_1.6_B18722.png)'
- en: Figure 1.6 – Variable move path
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 变量移动路径
- en: 'From what we can see in *Figure 1**.6*, `one` can no longer be accessed once
    it’s moved to `two`. To really establish what is going on here and how strings
    are affected, we can set up some code designed to fail as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们可以在*图1**.6*中看到的情况来看，一旦`one`被移动到`two`，就无法再访问`one`。为了真正了解这里发生的事情以及字符串是如何受影响的，我们可以设置一些旨在失败的代码，如下所示：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Running the preceding code gives the following error:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将给出以下错误：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we can see, the compiler has been helpful here. It shows us where the string
    was moved to and where the value of that string is borrowed. So, we can make the
    code run instantly by merely removing the `println!("{}", one);` line. However,
    we want to be able to use that `print` function at the bottom of the preceding
    code block. We should not have to constrain the functionality of the code due
    to the rules implemented by Rust. We can solve this by using the `to_owned` function
    with the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，编译器在这里很有帮助。它显示了字符串被移动到何处以及该字符串的值是从哪里借用的。因此，我们只需删除`println!("{}", one);`这一行代码，就可以让代码立即运行。然而，我们希望能够在前面代码块的底部使用那个`print`函数。我们不应该因为Rust实现的规则而限制代码的功能。我们可以通过使用`to_owned`函数和以下代码来解决这个问题：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `to_owned` function is available because strings implement the `ToOwned`
    trait. We will cover traits later in the chapter, so do not halt your reading
    if you do not know what this means yet. We could have used `clone` on the string.
    We must note that `to_owned` is a generalized implementation of `clone`. However,
    it does not really matter which approach we use. It is understandable to wonder
    why strings do not have the `Copy` trait. This is because the string is a pointer
    to a string literal. If we were to copy strings, we would have multiple unconstrained
    pointers to the same string literal data, which would be dangerous. Because of
    this, we can explore the move concept using strings. If we force our string outside
    of the scope with a function, we can see how this affects our move. This can be
    done with the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_owned`函数可用，因为字符串实现了`ToOwned`特质。我们将在本章后面介绍特质，所以如果你现在还不知道这是什么意思，请不要停止阅读。我们本来可以在字符串上使用`clone`。我们必须注意，`to_owned`是`clone`的通用实现。然而，我们使用哪种方法并不重要。人们可能会想知道为什么字符串没有`Copy`特质。这是因为字符串是指向字符串字面量的指针。如果我们复制字符串，我们将有多个不受约束的指向同一字符串字面量数据的指针，这将是非常危险的。正因为如此，我们可以使用字符串来探索移动概念。如果我们用一个函数将字符串移出作用域，我们可以看到这如何影响我们的移动。这可以通过以下代码来完成：'
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If we run the preceding code, we will get an error stating that the `print`
    function moved the `one` value. As a result, the `println!("{}", one);` line borrows
    `one` after it is moved into the `print` function. The key part of this message
    is the word *borrow*. To understand what is going on, we need to explore the concept
    of immutable borrowing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们将得到一个错误，指出`print`函数移动了`one`值。因此，`println!("{}", one);`行在`one`移动到`print`函数中之后借用了`one`。这条消息的关键部分是单词*借用*。为了理解正在发生的事情，我们需要探索不可变借用的概念。
- en: Immutable borrowing of variables
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变借用变量
- en: An immutable borrow occurs when a variable can be referenced by another variable
    without having to clone or copy it. This essentially solves our problem. If the
    borrowed variable falls out of scope, then it is not deallocated from the memory
    and the original reference to the value can still be used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量可以被另一个变量引用而不需要克隆或复制它时，就会发生不可变借用。这本质上解决了我们的问题。如果借用的变量超出作用域，则它不会被从内存中释放，并且仍然可以使用对值的原始引用。
- en: '![Figure 1.7 – Immutable borrow path](img/Figure_1.7_B18722.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 不可变借用路径](img/Figure_1.7_B18722.jpg)'
- en: Figure 1.7 – Immutable borrow path
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 不可变借用路径
- en: 'We can see in *Figure 1**.7* that `two` borrows the value from `one`. It must
    be noted that when `one` is borrowed from, `one` is locked and cannot be accessed
    until the borrow is finished. To perform a borrow operation, we merely apply a
    prefix with `&`. This can be demonstrated with the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**图1.7**中看到`two`从`one`借用了值。必须注意，当从`one`借用时，`one`被锁定，直到借用完成之前不能被访问。要执行借用操作，我们只需在前面加上前缀`&`。这可以通过以下代码来证明：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, we can see that our immutable borrow enables us to pass
    a string into the `print` function and still print it afterward. This can be confirmed
    with the following printout:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们的不可变借用使我们能够将字符串传递给`print`函数，并在之后打印它。这可以通过以下打印结果来确认：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: From what we see in our code, the immutable borrow that we performed can be
    demonstrated in *Figure 1**.8*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的代码中我们看到，我们执行的不可变借用可以在**图1.8**中演示。
- en: '![Figure 1.8 – Immutable borrow in relation to the print function](img/Figure_1.8_B18722.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 与`print`函数相关的不可变借用](img/Figure_1.8_B18722.jpg)'
- en: Figure 1.8 – Immutable borrow in relation to the print function
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 与`print`函数相关的不可变借用
- en: 'In the preceding figure, we can see that `one` is not available when the `print`
    function is running. We can demonstrate this with the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到当`print`函数正在运行时，`one`是不可用的。我们可以用以下代码来证明这一点：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we run the preceding code, we will get the following error:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们将得到以下错误：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can see that we cannot utilize `one` even though it is utilized in the `print`
    function after `&one`. This is because the lifetime of `&one` is throughout the
    entire lifetime of the `print` function. Thus, we can conclude that *Figure 1**.8*
    is correct. However, we can run one more experiment. We can change `value_one`
    to a borrow to see what happens with the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，即使在`print`函数中使用`&one`之后，我们也不能使用`one`。这是因为`&one`的生存期贯穿整个`print`函数的生存期。因此，我们可以得出结论，**图1.8**是正确的。然而，我们可以进行另一个实验。我们可以将`value_one`改为借用，看看会发生什么，以下代码如下：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the preceding code, we can see that we do two immutable borrows of `one`,
    and the code runs. This highlights an important fact: we can make as many immutable
    borrows as we like. However, what happens if the borrow is mutable? To understand,
    we must explore mutable borrows.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们对`one`进行了两次不可变借用，并且代码运行了。这突出了一个重要的事实：我们可以进行尽可能多的不可变借用。但是，如果借用是可变的会发生什么呢？为了理解这一点，我们必须探索可变借用。
- en: Mutable borrowing of variables
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量的可变借用
- en: 'A mutable borrow is essentially the same as an immutable borrow, except that
    the borrow is mutable. Therefore, we can change the borrowed value. To demonstrate
    this, we can create a `print` statement that will alter the borrowed value before
    printing it. We then print it in the `main` function to establish that the value
    has been changed with the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可变借用本质上与不可变借用相同，只是借用是可变的。因此，我们可以更改借用值。为了演示这一点，我们可以创建一个`print`语句，在打印之前改变借用值。然后我们在`main`函数中打印它，以确认值已经被更改，以下代码：
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Running the preceding code will give us the following printout:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将给出以下输出：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding output proves that `one` is `6` even after the lifetime of the
    mutable reference in the `print` function has expired. We can see that in the
    `print` function, we update the value of `one` using a `*` operator. This is called
    a dereference operator. This dereference operator exposes the underlying value
    so it can be operated. This all seems straightforward, but is it exactly like
    our immutable references? If we remember, we could have multiple immutable references.
    We can put this to the test with the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出证明了即使在`print`函数中可变引用的生命周期结束后，`one`仍然是`6`。我们可以看到在`print`函数中，我们使用`*`运算符更新`one`的值。这被称为解引用运算符。这个解引用运算符暴露了底层值以便进行操作。这一切看起来都很直接，但它是否与我们的不可变引用完全一样呢？如果我们记得，我们可能会有多个不可变引用。我们可以用以下代码来测试这一点：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the preceding code, we can see that we make two mutable references and pass
    them through, just like in the previous section, but with immutable references.
    However, running it gives us the following error:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们创建了两个可变引用并将它们传递出去，就像在上一节中一样，但这次使用的是不可变引用。然而，运行它给出了以下错误：
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Through this example, we can confirm that we cannot have more than one mutable
    reference at a time. This prevents data races and has given Rust the *fearless
    concurrency* tag. With what we have covered here, we can now be productive when
    the compiler is combined with the borrow checker. However, we have touched on
    the concepts of scope and lifetimes. The use of them has been intuitive, but like
    the rules around borrowing, we need to dive into scopes and then lifetimes in
    more detail.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们可以确认我们一次不能有多个可变引用。这防止了数据竞争，并赋予了Rust“无畏并发”的标签。在这里我们已经涵盖了，现在当编译器与借用检查器结合使用时，我们可以变得富有生产力。然而，我们已经触及了作用域和生命周期的概念。它们的使用是直观的，但就像借用规则一样，我们需要更详细地深入研究作用域和生命周期。
- en: Scopes
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: 'To understand scopes, let us go back to how we declare variables. You will
    have noticed that when we declare a new variable, we use `let`. When we do, that
    variable is the only one that owns the resource. Therefore, if the value is moved
    or reassigned, then the initial variable no longer owns the value. When a variable
    is moved, it is essentially moved into another scope. Variables declared in an
    outer scope can be referenced in an inner scope, but a variable declared in an
    inner scope cannot be accessed in the inner scope once the inner scope has expired.
    We can break down some code into scopes in the following diagram:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解作用域，让我们回顾一下我们如何声明变量。你会注意到，当我们声明一个新变量时，我们使用`let`。当我们这样做时，那个变量是唯一拥有资源的变量。因此，如果值被移动或重新分配，那么原始变量就不再拥有该值。当一个变量被移动时，它实际上被移动到了另一个作用域。在外部作用域中声明的变量可以在内部作用域中引用，但一旦内部作用域过期，就不能在内部作用域中访问内部作用域中声明的变量。我们可以在以下图中将一些代码拆分为作用域：
- en: '![Figure 1.9 – Basic Rust code broken into scopes](img/Figure_1.9_B18722.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 基本的Rust代码拆分为作用域](img/Figure_1.9_B18722.jpg)'
- en: Figure 1.9 – Basic Rust code broken into scopes
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 将基本的Rust代码拆分为作用域
- en: '*Figure 1**.9* shows us that we can create an inner scope by merely using curly
    brackets. Applying what we just learned about scopes to *Figure 1**.9*, can you
    work out whether it will crash? If it will crash, how will it?'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.9* 显示我们可以通过仅使用花括号来创建一个内部作用域。将我们刚刚学到的关于作用域的知识应用到 *图1.9* 上，你能计算出它是否会崩溃吗？如果它会崩溃，会如何崩溃？'
- en: 'If you guessed that it would result in a compiler error, then you are correct.
    Running the code would result in the following error:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你猜到这会导致编译器错误，那么你是正确的。运行代码会导致以下错误：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Because `one` is defined in the inner scope, we will not be able to reference
    it in the outer scope. We can solve this problem by declaring the variable in
    the outer scope but assigning the value in the inner scope with the following
    code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`one`是在内层作用域中定义的，所以我们无法在外层作用域中引用它。我们可以通过以下代码声明变量在外层作用域，但在内层作用域中赋值来解决这个问题：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the preceding code, we can see that we do not use `let` when assigning the
    value because we have already declared the variable in the outer scope. Running
    the preceding code gives us the following printout:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到在赋值时我们没有使用`let`，因为我们已经在外层作用域中声明了变量。运行前面的代码会得到以下输出：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We also must remember that if we move a variable into a function, then the
    variable gets destroyed once the scope of the function finishes. We cannot access
    the variable after the execution of the function, even though we declared the
    variable before the execution of the function. This is because once the variable
    has been moved into the function, it is no longer in the original scope. It has
    been moved. And because it has been moved to that scope, it is then bound to the
    lifetime of the scope that it was moved into. This brings us to our next section:
    lifetimes.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须记住，如果我们将一个变量移动到函数中，那么当函数的作用域结束时，该变量就会被销毁。在函数执行之后，我们无法访问该变量，即使我们在函数执行之前声明了该变量。这是因为一旦变量被移动到函数中，它就不再处于原始作用域中。它已经被移动了。而且因为它被移动到那个作用域，它就绑定到了它被移动进入的作用域的生命周期。这把我们带到了下一个部分：生命周期。
- en: Running through lifetimes
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历生命周期
- en: 'Understanding lifetimes will wrap up our exploration of borrowing rules and
    scopes. We can explore the effect of lifetimes with the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 理解生命周期将结束我们对借用规则和作用域的探索。我们可以通过以下代码来探索生命周期的效果：
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With the preceding code, we declare `one` before the inner scope starts. However,
    we assign it to have a reference of `two`. `two` only has the lifetime of the
    inner scope, so the lifetime dies before we try and print it out. This is established
    with the following error:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在内层作用域开始之前声明了`one`。然而，我们将其赋值为`two`的引用。`two`只具有内层作用域的生命周期，因此在尝试打印它之前生命周期就已经结束。这一点可以通过以下错误来证明：
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`two` is dropped when the lifetime of `two` has finished. With this, we can
    state that the lifetimes of `one` and `two` are not equal.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当`two`的生命周期结束时，`two`会被丢弃。因此，我们可以断定`one`和`two`的生命周期并不相等。
- en: 'While it is great that this is flagged when compiling, Rust does not stop here.
    This concept also applies to functions. Let’s say that we build a function that
    references two integers, compares them, and returns the highest integer reference.
    The function is an isolated piece of code. In this function, we can denote the
    lifetimes of the two integers. This is done by using the `''` prefix, which is
    a lifetime notation. The names of the notations can be anything you come up with,
    but it is convention to use `a`, `b`, `c`, and so on. We can explore this by creating
    a simple function that takes in two integers and returns the highest one with
    the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在编译时能够标记出来是件好事，但Rust并不会止步于此。这个概念也适用于函数。假设我们构建一个函数，它引用两个整数，比较它们，并返回最大的整数引用。这个函数是一段独立的代码。在这个函数中，我们可以表示两个整数的生命周期。这是通过使用`'`前缀来完成的，这是一个生命周期表示法。表示法的名称可以是任何你想到的，但惯例是使用`a`、`b`、`c`等。我们可以通过创建一个简单的函数来探索这一点，该函数接受两个整数并返回最大的一个，如下所示：
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As we can see, the first and second lifetimes have the same notation of `a`.
    They both must be present for the duration of the function. We also must note
    that the function returns an `i8` integer with the lifetime of `a`. If we were
    to try and use lifetime notation on function parameters without a borrow, we would
    get some very confusing errors. In short, it is not possible to use lifetime notation
    without a borrow. This is because if we do not use a borrow, the value passed
    into the function is moved into the function. Therefore, its lifetime is the lifetime
    of the function. This seems straightforward; however, when we run it, we get the
    following error:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，第一个和第二个生命周期具有相同的符号`a`。它们都必须在函数的整个持续时间内存在。我们还必须注意，该函数返回一个具有`a`生命周期的`i8`整数。如果我们试图在没有任何借用的情况下在函数参数上使用生命周期符号，我们将会遇到一些非常令人困惑的错误。简而言之，没有借用就无法使用生命周期符号。这是因为如果我们不使用借用，传递给函数的值会被移动到函数中。因此，它的生命周期是函数的生命周期。这似乎很简单；然而，当我们运行它时，我们会得到以下错误：
- en: '[PRE66]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The error occurs because all the lifetimes of the parameters passed into the
    function and the returned integer are the same. Therefore, the compiler does not
    know what could be returned. As a result, `two` could be returned. If `two` is
    returned, then the result of the function will not live long enough to be printed.
    However, if `one` is returned, then it will. Therefore, there is a possibility
    of not having a value to print after the inner scope is executed. In a dynamic
    language, we would be able to run code that runs the risk of referencing variables
    that have not been initialized yet. However, with Rust, we can see that if there
    is a possibility of an error like this, it will not compile. In the short term,
    it might seem like Rust takes longer to code, but as the project progresses, this
    strictness will save a lot of time by preventing silent bugs. In conclusion of
    our error, there is no way of solving our problem with the exact function and
    main layout that we have. We would either have to move our printing of the outcome
    into the inner scope or clone the integers and pass them into the function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为传递给函数的所有参数的生命周期以及返回的整数的生命周期都是相同的。因此，编译器不知道可以返回什么。结果，`two`可能会被返回。如果`two`被返回，那么函数的结果将不足以存活到被打印出来。然而，如果`one`被返回，那么它将可以存活。因此，在内部作用域执行完毕后，可能没有值可以打印。然而，在动态语言中，我们能够运行存在引用尚未初始化的变量的风险的代码。然而，在Rust中，我们可以看到，如果存在这种错误的可能性，它将无法编译。短期内，这可能会让人觉得Rust的编码速度较慢，但随着项目的进展，这种严格性将通过防止静默错误来节省大量时间。关于我们的错误，我们无法以我们目前拥有的确切函数和主布局来解决我们的问题。我们或者必须将打印结果移动到内部作用域，或者克隆整数并将它们传递给函数。
- en: 'We can create one more function to explore functions with different lifetime
    parameters. This time we will create a `filter` function. If the first number
    is lower than the second number, we will then return `0`. Otherwise, we will return
    the first number. This can be achieved with the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建另一个函数来探索具有不同生命周期参数的函数。这次我们将创建一个`filter`函数。如果第一个数字小于第二个数字，我们将返回`0`。否则，我们将返回第一个数字。这可以通过以下代码实现：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding code works because we know the lifetimes are different. The first
    parameter has the same lifetime as the returned integer. If we were to implement
    `filter(&two, &one)` instead, we would get an error stating that the outcome does
    not live long enough to be printed. We have now covered all that we need to know
    for now to write productive code in Rust without the borrow checker getting in
    our way. We now need to move on to creating bigger building blocks for our programs
    so we can focus on tackling the complex problems we want to solve with code. We
    will start this with a versatile building block of programs: **structs**.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码之所以有效，是因为我们知道生命周期是不同的。第一个参数具有与返回的整数相同的生命周期。如果我们实现`filter(&two, &one)`，我们会得到一个错误，指出结果的生命周期不足以被打印。我们现在已经涵盖了现在编写Rust代码所需了解的所有内容，而不会受到借用检查器的干扰。我们现在需要继续创建更大的构建块，以便我们可以专注于用代码解决我们想要解决的问题。我们将从这个程序的通用构建块开始：**结构体**。
- en: Building structs
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建结构体
- en: 'In modern high-level dynamic languages, objects have been the bedrock for building
    big applications and solving complex problems, and for good reason. Objects enable
    us to encapsulate data, functionality, and behavior. In Rust, we do not have objects.
    However, we do have structs that can hold data in fields. We can then manage the
    functionality of these structs and group them together with traits. This is a
    powerful approach, and it gives us the benefits of objects without the high coupling,
    as highlighted in the following figure:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代高级动态语言中，对象一直是构建大型应用程序和解决复杂问题的基石，这是有充分理由的。对象使我们能够封装数据、功能和行为。在 Rust 中，我们没有对象。然而，我们确实有可以存储数据的字段的结构体。然后我们可以管理这些结构体的功能并将它们通过特质组合在一起。这是一个强大的方法，它给我们带来了对象的好处，而没有高耦合，如下面的图所示：
- en: '![Figure 1.10 – Difference between Rust structs and objects](img/Figure_1.10_B18722.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – Rust 结构体和对象之间的区别](img/Figure_1.10_B18722.jpg)'
- en: Figure 1.10 – Difference between Rust structs and objects
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – Rust 结构体和对象之间的区别
- en: 'We will start with something basic by creating a `Human` struct with the following
    code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个具有以下代码的 `Human` 结构体开始，做一些基本的工作：
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding code, we can see that our string literal fields have the same
    lifetime as the struct itself. We have also applied the `Debug` trait to the `Human`
    struct, so we can print it out and see everything. We can then create the `Human`
    struct and print the struct out using the following code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们的字符串字面量字段与结构体本身的生存期相同。我们还已经将 `Debug` 特质应用于 `Human` 结构体，因此我们可以打印它并查看一切。然后我们可以创建
    `Human` 结构体并使用以下代码打印结构体：
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Running the preceding code would give us the following printout:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会给出以下输出：
- en: '[PRE70]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can see that our fields are what we expect. However, we can change our string
    slice fields to strings to get rid of lifetime parameters. We may also want to
    add another field where we can reference another `Human` struct under a `friend`
    field. However, we may also have no friends. We can account for this by creating
    an enum that is either a friend or not and assigning this to a `friend` field,
    as seen in the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的字段正如我们所期望的那样。然而，我们可以将我们的字符串切片字段更改为字符串以消除生命周期参数。我们可能还想要添加另一个字段，在这个字段中我们可以通过一个
    `friend` 字段引用另一个 `Human` 结构体。然而，我们可能也没有朋友。我们可以通过创建一个枚举来解决这个问题，这个枚举可以是朋友或不是朋友，并将其分配给
    `friend` 字段，如下面的代码所示：
- en: '[PRE71]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can then define the `Human` struct initially with no friends just to see
    if it works with the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个初始时没有朋友的 `Human` 结构体，只是为了看看它是否工作，以下代码：
- en: '[PRE72]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'However, when we run the compiler, it does not work. I would like to think
    this is because the compiler cannot believe that I have no friends. But alas,
    it’s to do with the compiler not knowing how much memory to allocate for this
    declaration. This is shown through the following error code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们运行编译器时，它并不工作。我想这可能是由于编译器不相信我没有朋友。但遗憾的是，问题在于编译器不知道为这个声明分配多少内存。这可以通过以下错误代码来展示：
- en: '[PRE73]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Because of the enum, theoretically, the memory needed to store this variable
    could be infinite. One `Human` struct could reference another `Human` struct as
    a `friend` field, which could in turn reference another `Human` struct, resulting
    in a potentially infinite number of `Human` structs being linked together through
    the `friend` field. We can solve this problem with pointers. Instead of storing
    all the data of a `Human` struct in the `friend` field, we store a memory address
    that we know has a maximum value because it’s a standard integer. This memory
    address points to where another `Human` struct is stored in the memory. As a result,
    the program knows exactly how much memory to allocate when it crosses a `Human`
    struct, irrespective of whether the `Human` struct has a `friend` field or not.
    This can be achieved by using a `Box` struct, which is essentially a smart pointer
    for our enum, with the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于枚举的存在，理论上，存储这个变量的内存可能无限。一个 `Human` 结构体可以作为 `friend` 字段引用另一个 `Human` 结构体，而这个
    `Human` 结构体又可以引用另一个 `Human` 结构体，从而通过 `friend` 字段链接在一起，形成一个可能无限数量的 `Human` 结构体链。我们可以通过指针解决这个问题。我们不是在
    `friend` 字段中存储 `Human` 结构体的所有数据，而是存储一个内存地址，我们知道它有一个最大值，因为它是一个标准整数。这个内存地址指向内存中存储另一个
    `Human` 结构体的位置。因此，程序在跨越 `Human` 结构体时，无论该 `Human` 结构体是否有 `friend` 字段，都能准确地知道需要分配多少内存。这可以通过使用
    `Box` 结构体来实现，它本质上是我们枚举的智能指针，以下代码：
- en: '[PRE74]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'So, now our enum states whether the friend exists or not, and if so, it has
    a memory address if we need to extract information about this friend. We can achieve
    this with the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的枚举表示朋友是否存在，如果存在，它有一个内存地址，如果我们需要提取有关此朋友的信息。我们可以通过以下代码实现：
- en: '[PRE75]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the preceding code, we can see that we have created one `Human` struct, and
    then another `Human` struct with a reference to the first `Human` struct as a
    `friend` field. We then access the second `Human` struct’s `friend` through the
    `friend` field. Remember, we must handle both possibilities as it could be a nil
    value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们创建了一个`Human`结构体，然后创建了一个带有对第一个`Human`结构体的引用作为`friend`字段的另一个`Human`结构体。然后我们通过`friend`字段访问第二个`Human`结构体的`friend`。记住，我们必须处理两种可能性，因为它可能是一个nil值。
- en: 'While it is exciting that friends can be made, if we take a step back, we can
    see that there is a lot of code written for each human we create. This is not
    helpful if we must create a lot of humans in a program. We can reduce this by
    implementing some functionality for our struct. We will essentially create a constructor
    for the struct with extra functions, so we can add optional values if we want.
    We will also make the `thought` field optional. So, a basic struct with a constructor
    populating only the most essential fields can be achieved with the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够建立朋友关系令人兴奋，但如果退一步思考，我们可以看到为每个创建的人类编写了大量的代码。如果我们必须在程序中创建大量的人类，这并不 helpful。我们可以通过为我们的结构体实现一些功能来减少这一点。我们将基本上为结构体创建一个构造函数，并添加额外的函数，这样我们就可以添加可选值。我们还将使`thought`字段成为可选的。因此，一个基本的结构体，其构造函数只填充最基本字段，可以通过以下代码实现：
- en: '[PRE76]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Therefore, creating a new human now only takes the following line of code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在创建一个新的人类只需要以下一行代码：
- en: '[PRE77]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This will have the following field values:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这将具有以下字段值：
- en: 'Name: `"``Maxwell Flitton"`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`"Maxwell Flitton"`
- en: 'Age: `32`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄：`32`
- en: 'Current Thought: `None`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前想法：`None`
- en: 'Friend: `NIL`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 朋友：`NIL`
- en: 'We can add more functions in the implement block for adding friends and a current
    thought with the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在实现块中添加更多函数，以添加朋友和当前的想法，如下面的代码所示：
- en: '[PRE78]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the preceding code, we can see that we pass in a mutable version of the
    struct that is calling these functions. These functions can be chained because
    they return the struct that called them. If we want to create a developer with
    a thought, we can do this with the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们传递了一个调用这些函数的结构体的可变版本。由于这些函数返回调用它们的结构体，因此它们可以被链式调用。如果我们想创建一个有想法的开发者，我们可以用以下代码实现：
- en: '[PRE79]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We must note that a function that does not require `self` as a parameter can
    be called with `::`, while a function that does require `self` as a parameter
    can be called with a simple dot (`.`). If we want to create a developer with a
    friend, it can be done using the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意，不需要`self`作为参数的函数可以用`::`调用，而需要`self`作为参数的函数可以用简单的点（`.`）调用。如果我们想创建一个有朋友的开发者，可以使用以下代码实现：
- en: '[PRE80]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Running the code will result in the following parameters for `developer`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码将导致`developer`具有以下参数：
- en: '[PRE81]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We can see that structs combined with enums and functions that have been implemented
    with these structs can be powerful building blocks. We can define fields and functionality
    with only a small amount of code if we have defined our structs well. However,
    writing the same functionality for multiple structs can be time-consuming and
    result in a lot of repeated code. If you have worked with objects before, you
    may have utilized inheritance for that. Rust goes one better. It has traits, which
    we will explore in the next section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，结合枚举和已经使用这些结构体实现的函数可以成为强大的构建块。如果我们定义了良好的结构体，我们只需少量代码就可以定义字段和功能。然而，为多个结构体编写相同的功能可能会很耗时，并导致大量重复的代码。如果你之前使用过对象，你可能已经使用了继承。Rust做得更好。它有特性（traits），我们将在下一节中探讨。
- en: Verifying with traits
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特性验证
- en: 'We can see enums can empower structs so that they can handle multiple types.
    This can also be translated for any type of function or data structure. However,
    this can lead to a lot of repetition. Take, for instance, a `User` struct. Users
    have a core set of values, such as a username and password. However, they could
    also have extra functionality based on roles. With users, we must check roles
    before firing certain processes. We can wrap up structs with traits by creating
    a simple toy program that defines users and their roles with the following steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到枚举可以赋予结构体处理多种类型的能力。这也可以翻译为任何类型的函数或数据结构。然而，这可能会导致很多重复。以`User`结构体为例。用户有一组核心值，例如用户名和密码。然而，他们也可以根据角色有额外的功能。在使用用户时，我们必须在执行某些过程之前检查角色。我们可以通过以下步骤创建一个简单的玩具程序来封装结构体，定义用户及其角色：
- en: 'We can define our users with the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码定义我们的用户：
- en: '[PRE82]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We can see in the preceding code that the `User` and `AdminUser` structs have
    the same fields. For this exercise, we merely need two different structs to demonstrate
    the effect traits have on them. Now that our structs are defined, we can move
    on to our next step, which is creating the traits.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到`User`和`AdminUser`结构体具有相同的字段。对于这个练习，我们只需要两个不同的结构体来展示特性能对它们产生的影响。现在我们的结构体已经定义好了，我们可以继续到下一步，也就是创建特型。
- en: 'We will be implementing these traits in our structs. The total traits that
    we will have are, comprise create, edit, and delete. We will be using them to
    assign permissions to our users. We can create these three traits with the following
    code:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在我们的结构体中实现这些特型。我们将拥有的总特型包括创建、编辑和删除。我们将使用它们来分配用户的权限。我们可以使用以下代码创建这三个特型：
- en: '[PRE90]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We can see that the functions for the traits only take in `self`. We cannot
    make any references to the fields in the functions to `self` as we do not know
    what structs will be implemented. However, we can override functions when we implement
    the trait to the struct if needed. If we are to return `self`, we will need to
    wrap it in a `Box` struct, as the compiler will not know the size of the struct
    being returned. We also must note that the signature of the function (input parameters
    and return values) must be the same as the original if we overwrite the function
    for a struct. Now that we have defined the traits, we can move on to the next
    step of implementing the traits to define roles for our user.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，特型的函数只接受`self`作为参数。我们不能在函数中引用`self`的字段，因为我们不知道将要实现哪些结构体。然而，如果我们需要，在将特型实现到结构体时可以重写函数。如果我们需要返回`self`，我们需要将其封装在`Box`结构体中，因为编译器不知道返回的结构体的大小。我们还必须注意，如果我们重写结构体的函数，函数的签名（输入参数和返回值）必须与原始函数相同。现在我们已经定义了特型，我们可以继续到下一步，即实现特型来定义用户的角色。
- en: 'With our roles, we can make our admin have every permission and our user only
    the edit permission. This can be achieved with the following code:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过我们的角色，我们可以让管理员拥有所有权限，而用户只有编辑权限。这可以通过以下代码实现：
- en: '[PRE105]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: From our previous step, we can remember that all the functions already worked
    for the admin by printing out that the admin is doing the action. Therefore, we
    do not have to do anything for the implementation of the traits for the admin.
    We can also see that we can implement multiple traits for a single struct. This
    adds a lot of flexibility. In our user implementation of the `CanEdit` trait,
    we have overwritten the `edit` function so that we can have the correct statement
    printed out. Now that we have implemented the traits, our `user` structs have
    permission in the code to enter scopes that require those traits. We can now build
    the functions for using these traits in the next step.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的步骤中，我们可以记住所有函数已经为管理员工作，通过打印出管理员正在执行的操作。因此，我们不需要为管理员特型的实现做任何事情。我们还可以看到，我们可以为单个结构体实现多个特型。这增加了很大的灵活性。在我们的`CanEdit`特型实现中，我们已经重写了`edit`函数，以便可以打印出正确的语句。现在我们已经实现了特型，我们的`user`结构体在代码中有了进入需要这些特型的作用域的权限。现在我们可以构建在下一步中使用这些特型的函数。
- en: 'We could utilize the functions in the traits by directly running them in the
    `main` function on the structs that have implemented them. However, if we do this,
    we will not see their true power in this exercise. We may also want this standard
    functionality throughout our program in the future when we span multiple files.
    The following code shows how we create functions that utilize the traits:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在实现了它们的结构体上直接在`main`函数中运行它们来利用特质的函数。然而，如果我们这样做，我们在这个练习中看不到它们的真正力量。我们可能还希望在将来的程序中，当我们跨越多个文件时，使用这种标准功能。以下代码展示了我们如何创建利用特质的函数：
- en: '[PRE114]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The preceding notation is fairly like the lifetime annotation. We use angle
    brackets before the input definitions to define the trait we want to accept at
    `T`. We then state that we will accept a borrowed struct that has implemented
    the trait as `&T`. This means that any struct that implements that specific trait
    can pass through the function. Because we know what the trait can do, we can then
    use the trait functions. However, because we do not know what struct is going
    to be passed through, we cannot utilize specific fields. But remember, we can
    overwrite a trait function to utilize struct fields when we implement the trait
    for the struct. This might seem rigid, but the process enforces good, isolated,
    decoupled coding that is safe. For instance, let’s say we remove a function from
    a trait or remove a trait from a struct. The compiler would refuse to compile
    until all the effects of this change were complete. Thus, we can see that, especially
    for big systems, Rust is safe, and can save time by reducing the risk of silent
    bugs. Now that we have defined the functions, we can use them in the `main` function
    in the next step.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的符号相当类似于生命周期注解。我们在输入定义之前使用尖括号来定义我们想要在`T`中接受的特质。然后我们声明我们将接受一个实现了该特质的借用结构体作为`&T`。这意味着任何实现了该特定特质的结构体都可以通过该函数。因为我们知道特质能做什么，所以我们就可以使用特质函数。然而，因为我们不知道将要传递什么结构体，所以我们不能利用特定的字段。但请记住，当我们为结构体实现特质时，我们可以覆盖特质函数来利用结构体字段。这可能会显得有些僵化，但这个过程强制执行了良好、隔离、解耦的编码，这是安全的。例如，假设我们从一个特质中删除一个函数或从一个结构体中删除一个特质。编译器将拒绝编译，直到这个变化的全部影响都完成。因此，我们可以看到，特别是对于大型系统，Rust是安全的，并且可以通过减少静默错误的风险来节省时间。现在我们已经定义了函数，我们可以在下一步的`main`函数中使用它们。
- en: 'We can test to see whether all the traits work with the following code:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码测试所有特质是否工作：
- en: '[PRE123]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We can see that the functions that accept traits are used just like any other
    function.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，接受特质的函数就像任何其他函数一样被使用。
- en: 'Running the entire program will give us the following printout:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 运行整个程序将给出以下输出：
- en: '[PRE137]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: In our output, we can see that the overriding of the `edit` function for the
    `User` struct works.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输出中，我们可以看到`User`结构体的`edit`函数被覆盖是有效的。
- en: We have now learned enough about traits to be productive with web development.
    Traits get even more powerful, and we will be using them for some key parts of
    our web programming. For instance, several web frameworks have traits that execute
    before the request is processed by the view/API endpoint. Implementing structs
    with these traits automatically loads the `view` function with the result of the
    `trait` function. This can be database connections, extraction of tokens from
    headers, or anything else we wish to work with. There is also one last concept
    that we need to tackle before we move on to the next chapter, and that is macros.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学到了足够关于特质的知识，可以用于有效的Web开发。特质变得更加强大，我们将使用它们来处理我们Web编程的一些关键部分。例如，几个Web框架有在请求被视图/API端点处理之前执行的特质。实现具有这些特质的结构体会自动加载`view`函数和特质函数的结果。这可以是数据库连接、从头中提取令牌，或我们希望与之工作的任何其他东西。还有一个最后的概念我们需要在进入下一章之前解决，那就是宏。
- en: Metaprogramming with macros
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用宏进行元编程
- en: '**Metaprogramming** can generally be described as a way in which the program
    can manipulate itself based on certain instructions. Considering the strong typing
    Rust has, one of the simplest ways in which we can meta program is by using generics.
    A classic example of demonstrating generics is through coordinates, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**元编程**可以一般地描述为程序根据某些指令操纵自身的一种方式。考虑到Rust的强类型，我们可以通过泛型来实现元编程的最简单方式之一。一个展示泛型的经典例子是通过坐标，如下所示：'
- en: '[PRE138]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'In the preceding snippet, we can see that the `Coordinate` struct managed to
    take in and handle three different types of numbers. We can add even more variance
    to the `Coordinate` struct so we can have two different types of numbers in one
    struct with the following code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到`Coordinate`结构体成功地处理了三种不同类型的数字。我们可以通过以下代码给`Coordinate`结构体添加更多的变化，以便在一个结构体中拥有两种不同的数字类型：
- en: '[PRE139]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'What is happening in the preceding code with generics is that the compiler
    is looking for all instances where the struct is used, creating structs with the
    types used when the compilation is running. Now that we have covered generics,
    we can move on to the main mechanism of metaprogramming: macros.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用泛型所发生的情况是编译器正在寻找结构体被使用的所有实例，在编译运行时创建具有相应类型的结构体。现在我们已经涵盖了泛型，我们可以继续到元编程的主要机制：宏。
- en: 'Macros enable us to abstract code. We’ve already been using macros in our print
    functions. The `!` notation at the end of the function denotes that this is a
    macro that’s being called. Defining our own macros is a blend of defining a function
    and using a lifetime notation within a `match` statement in the function. To demonstrate
    this, we will define a macro that capitalizes a string with the following code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 宏使我们能够抽象代码。我们已经在我们的打印函数中使用过宏了。函数末尾的`!`符号表示这是一个正在被调用的宏。定义我们自己的宏是定义一个函数和使用函数中的`match`语句内的生命周期符号的结合。为了演示这一点，我们将定义一个宏，以下代码将字符串大写：
- en: '[PRE140]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Instead of using the term `fn`, we use the `macro_rules!` definition. We then
    say that `$a` is the expression passed into the macro. We get the expression,
    convert it into a vector of chars, then make the first `char` uppercase, and then
    convert it back to a string. We must note that we don’t return anything in the
    `capitalize` macro, and when we call the macro, we don’t assign a variable to
    it. However, when we print the `x` variable at the end, we can see that it is
    capitalized. This does not behave like an ordinary function. We also must note
    that we didn’t define a type, instead, we just said it was an expression; the
    macro still does checks via traits. Passing an integer into the macro creates
    the following error:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用`fn`这个词，而是使用`macro_rules!`定义。然后我们说`$a`是传递给宏的表达式。我们获取这个表达式，将其转换为字符向量，然后将第一个字符转换为大写，最后再将其转换回字符串。我们必须注意，在`capitalize`宏中我们不返回任何内容，当我们调用宏时，我们也不给它赋值一个变量。然而，当我们最后打印`x`变量时，我们可以看到它已经被大写了。这并不像普通函数那样表现。我们还必须注意，我们没有定义一个类型，而是只是说它是一个表达式；宏仍然通过特性行为进行检查。将整数传递给宏会创建以下错误：
- en: '[PRE141]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Lifetimes, blocks, literals, paths, metaprogramming, and more, can also be passed
    instead of an expression. While it’s important to have a brief understanding of
    what’s under the hood of a basic macro for debugging and further reading, diving
    more into developing complex macros will not help us in developing web apps. We
    must remember that macros are a last resort and should be used sparingly. Errors
    thrown in macros can be hard to debug. In web development, a lot of the macros
    are already defined in third-party packages. Because of this, we do not need to
    write macros ourselves to get a web app up and running. Instead, we will mainly
    be using derive macros out of the box.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期、块、字面量、路径、元编程等也可以传递而不是表达式。虽然对基本宏的内部机制有一个简要的了解对于调试和进一步阅读很重要，但更深入地开发复杂宏并不会帮助我们开发Web应用。我们必须记住，宏是最后的手段，应该谨慎使用。宏中抛出的错误可能很难调试。在Web开发中，许多宏已经定义在第三方包中。正因为如此，我们不需要自己编写宏来启动Web应用。相反，我们将主要使用现成的`derive`宏。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With Rust, we have seen that there are some traps when coming from a dynamic
    programming language background. However, with a little bit of knowledge of referencing
    and basic memory management, we can avoid common pitfalls and write safe, performant
    code quickly that can handle errors. By utilizing structs and traits, we can build
    objects that are analogous to classes in standard dynamic programming languages.
    On top of this, the traits enabled us to build mixin-like functionality. This
    not only enables us to slot in functionality when it’s useful to us but also perform
    checks on the structs through typing to ensure that the container or function
    is processing structs with certain attributes belonging to the trait that we can
    utilize in the code.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rust，我们发现从动态编程语言背景转换过来时存在一些陷阱。然而，只要稍微了解一些引用和基本内存管理知识，我们就可以避免常见的陷阱，并快速编写安全、高效的代码，以处理错误。通过利用结构体和特质，我们可以构建类似于标准动态编程语言中类的对象。在此基础上，特质还使我们能够构建类似混合功能的特性。这不仅使我们能够在需要时插入功能，而且可以通过类型检查对结构体进行验证，以确保容器或函数正在处理具有属于特质的特定属性的结构体，这些属性可以在代码中利用。
- en: With our fully functioning structs, we bolted on even more functionality with
    macros and looked under the hood of basic macros by building our own `capitalize`
    function, giving us guidance for further reading and debugging. We also got to
    see a brief demonstration of how powerful macros combined with structs can be
    in web development with JSON serialization. With what we have learned in this
    chapter, we can now write basic Rust programs. Because we understand the concepts
    that the borrow checker enforces, we can debug the application that we code. Like
    other languages, there are limited real-world applications that we can do yet.
    However, we do have the essential foundation to build real-world applications
    spanning multiple files running on our own local computers.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完全功能化的结构体上，我们通过宏进一步增加了更多功能，并通过构建自己的 `capitalize` 函数来深入了解基本宏的内部机制，这为我们提供了进一步阅读和调试的指导。我们还看到了一个简短的演示，展示了宏与结构体结合在
    Web 开发中进行 JSON 序列化时的强大功能。通过本章所学，我们现在可以编写基本的 Rust 程序。因为我们理解了借用检查器强制执行的概念，我们可以调试我们编写的应用程序。像其他语言一样，我们目前可以做的实际应用是有限的。然而，我们确实有了构建跨多个文件运行在我们自己的本地计算机上的实际应用的基础。
- en: We can now move on to the next chapter and investigate setting up a Rust environment
    on our own computers to structure files and code to enable us to build programs
    that can solve real-world problems.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到下一章，并调查在我们自己的计算机上设置 Rust 环境，以结构化文件和代码，使我们能够构建可以解决实际问题的程序。
- en: Questions
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between `str` and `String`?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`str` 和 `String` 之间的区别是什么？'
- en: Why can’t string slices be passed into a function (string slice meaning `str`
    as opposed to `&str`)?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么字符串切片不能传递给函数（字符串切片指的是 `str`，而不是 `&str`）？
- en: How do we access the data belonging to a key in a HashMap?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何访问 HashMap 中键所属的数据？
- en: When a function results in an error, can we handle other processes, or will
    the error crash the program instantly?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个函数导致错误时，我们能否处理其他过程，或者错误会立即崩溃程序？
- en: Why does Rust only allow one mutable borrow at a point in time?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 Rust 只允许在某个时间点进行一次可变借用？
- en: When would we need to define two different lifetimes in a function?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在函数中何时需要定义两个不同的生命周期？
- en: How can structs link to the same struct via one of their fields?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构体如何通过其字段之一链接到相同的结构体？
- en: How can we add extra functionality to a struct where the functionality can also
    be implemented by other structs?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何向结构体添加额外的功能，而这些功能也可以由其他结构体实现？
- en: How do we allow a container or function to accept different data structures?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何让容器或函数接受不同的数据结构？
- en: What’s the quickest way to add a trait, such as `Copy`, to a struct?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个特质，如 `Copy`，到结构体的最快方式是什么？
- en: Answers
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '`String` is a fixed-size reference stored in the stack that points to string-type
    data on the heap. `str` is an immutable sequence of bytes stored somewhere in
    memory. Because the size of `str` is unknown, it can only be handled by a `&``str`
    pointer.'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`String` 是一个固定大小的引用，存储在栈上，指向堆上的字符串类型数据。`str` 是存储在内存某处的不可变字节序列。由于 `str` 的大小未知，它只能通过
    `&str` 指针来处理。'
- en: Since we do not know the size of the string slice at compile time, we cannot
    allocate the correct amount of memory for it. Strings, on the other hand, have
    a fixed-size reference stored on the stack that points to the string slice on
    the heap. Because we know this fixed size of the string reference, we can allocate
    the correct amount of memory and pass it through to a function.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在编译时不知道字符串切片的大小，我们无法为其分配正确的内存量。另一方面，字符串有一个固定大小的引用存储在栈上，该引用指向堆上的字符串切片。因为我们知道这个字符串引用的固定大小，我们可以分配正确的内存量并将其传递给函数。
- en: We use the HashMap’s `get` function. However, we must remember that the `get`
    function merely returns an `Option` struct. If we are confident that there is
    something there or we want the program to crash if nothing is found, we can directly
    unwrap it. However, if we don’t want that, we can use a `match` statement and
    handle the `Some` and `None` output as we wish.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用HashMap的`get`函数。然而，我们必须记住，`get`函数仅仅返回一个`Option`结构体。如果我们确信那里有东西，或者我们希望找不到东西时程序崩溃，我们可以直接解包它。然而，如果我们不希望这样，我们可以使用一个`match`语句，并按我们的意愿处理`Some`和`None`输出。
- en: No, results must be unwrapped before exposing the error. A simple `match` statement
    can handle unwrapping the result and managing the error as we see fit.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，在暴露错误之前，结果必须被解包。一个简单的`match`语句可以处理解包结果并按我们的意愿管理错误。
- en: Rust only allows one mutable borrow to prevent memory unsafety. In Goregaokar’s
    blog, the example of an enum is used to illustrate this. If an enum supports two
    different data types (`String` and `i64`), if a mutable reference of the string
    variant of the enum is made, and then another reference is made, the mutable reference
    can change the data, and then the second reference would still be referencing
    the string variant of the enum. The second reference would then try to dereference
    the string variant of the enum, potentially causing a segmentation fault. Elaboration
    on this example and others is provided in the *Further reading* section.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rust只允许一个可变借用，以防止内存不安全。在Goregaokar的博客中，使用枚举的例子来说明这一点。如果一个枚举支持两种不同的数据类型（`String`和`i64`），如果对枚举的字符串变体的可变引用被创建，然后又创建另一个引用，可变引用可以更改数据，然后第二个引用仍然引用枚举的字符串变体。然后，第二个引用将尝试解引用枚举的字符串变体，这可能导致段错误。关于这个例子和其他例子的详细说明，请参阅*进一步阅读*部分。
- en: We would need to define two different lifetimes when the result of a function
    relies on one of the lifetimes and the result of the function is needed outside
    of the scope of where it is called.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当函数的结果依赖于某个生命周期，并且该结果需要在调用它的作用域之外使用时，我们需要定义两个不同的生命周期。
- en: If a struct is referencing itself in one of its fields, the size could be infinite
    as it could continue to reference itself continuously. To prevent this, we can
    wrap the reference to the struct in the field in a `Box` struct.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个结构体在其字段中引用自身，其大小可能是无限的，因为它可以持续不断地引用自身。为了防止这种情况，我们可以在字段中对该结构体的引用用`Box`结构体包装。
- en: We can slot extra functionality and freedom into a struct by using traits. Implementing
    a trait will give the struct the ability to use functions that belong to the trait.
    The trait’s implementation also allows the struct to pass typing checks for that
    trait.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用特质，我们可以将额外的功能和解耦性嵌入到结构体中。实现一个特质将使结构体能够使用属于该特质的函数。特质的实现还允许结构体通过该特质的类型检查。
- en: 'We allow a container or function to accept different data structures by declaring
    enums or traits in the type checking or by utilizing generics (see the *Further
    reading* section: *Mastering Rust* or *Hands-On Functional Programming in Rust
    (first chapter)*).'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们允许容器或函数通过在类型检查中声明枚举或特质，或者通过使用泛型（参见*进一步阅读*部分：*精通Rust*或*Rust函数式编程实践（第一章）*）来接受不同的数据结构。
- en: The quickest way to add a trait to a struct is by annotating the struct with
    a derive macro that has the copy and clone traits.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向结构体添加特质的最快方式是通过使用具有复制和克隆特质的derive宏来注释结构体。
- en: Further reading
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Hands-On Functional Programming in Rust* (2018) by Andrew Johnson, Packt Publishing'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hands-On Functional Programming in Rust*（2018）由Andrew Johnson著，Packt Publishing出版社'
- en: '*Mastering Rust* (2019) by Rahul Sharma and Vesa Kaihlavirta, Packt Publishing'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mastering Rust*（2019）由Rahul Sharma和Vesa Kaihlavirta著，Packt Publishing出版社'
- en: '*The Rust Programming Language* (2018): [https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rust编程语言*（2018）: [https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)'
- en: '*The Problem With Single-threaded Shared Mutability* (2015) by Manish Goregaokar:
    [https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/](https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单线程共享可变性问题*（2015）由Manish Goregaokar撰写：[https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/](https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/)'
