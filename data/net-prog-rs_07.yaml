- en: Asynchronous Network Programming Using Tokio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tokio进行异步网络编程
- en: In a sequential programming model, code is always executed in the order dictated
    by the semantics of the programming language. Thus, if one operation blocks for
    some reason (waiting for a resource, and so forth), the whole execution blocks
    and can only move forward once that operation has completed. This often leads
    to poor utilization of resources, because the main thread will be busy waiting
    on one operation. In GUI apps, this also leads to poor user interactivity, because
    the main thread, which is responsible for managing the GUI, is busy waiting for
    something else. This is a major problem in our specific case of network programming,
    as we often need to wait for data to be available on a socket. In the past, we
    worked around these issues using multiple threads. In that model, we delegated
    a costly operation to a background thread, making the main thread free for user
    interaction, or some other task. In contrast, an asynchronous model of programming
    dictates that no operation should ever block. Instead, there should be a mechanism
    to check whether they have completed from the main thread. But how do we achieve
    this? A simple way would be to run each operation in its own thread, and then
    to join on all of those threads. In practice, this is troublesome owing to the
    large number of potential threads and coordination between them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺序编程模型中，代码总是按照编程语言的语义顺序执行。因此，如果某个操作由于某种原因（等待资源等）而阻塞，整个执行就会阻塞，并且只有在该操作完成后才能继续进行。这通常会导致资源利用率低下，因为主线程会忙于等待某个操作。在GUI应用程序中，这也导致了较差的用户交互性，因为负责管理GUI的主线程正忙于等待其他事情。在我们特定的网络编程案例中，这是一个主要问题，因为我们经常需要等待套接字上的数据可用。在过去，我们通过使用多个线程来解决这个问题。在那个模型中，我们将一个昂贵的操作委托给后台线程，使主线程可以用于用户交互或其他任务。相比之下，异步编程模型规定，任何操作都不应该阻塞。相反，应该有一种机制来检查它们是否已经完成，从主线程中进行检查。但我们如何实现这一点呢？一种简单的方法是让每个操作在自己的线程中运行，然后对所有这些线程进行连接。实际上，由于潜在的线程数量众多以及它们之间的协调，这种方法是麻烦的。
- en: 'Rust provides a few crates that support asynchronous programming using a futures-based,
    event loop-driven model. We will study that in detail in this chapter. Here are
    the topics we will cover here:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Rust提供了一些crate，支持使用基于futures的事件循环驱动模型进行异步编程。我们将在本章中详细研究这一点。以下是本章我们将涉及的主题：
- en: Futures abstraction in Rust
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust中的未来抽象
- en: Asynchronous programming using the tokio stack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tokio堆栈进行异步编程
- en: Looking into the Future
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望未来
- en: The backbone of Rust's asynchronous programming story is the futures crate.
    This crate provides a construct called a *future*. This is essentially a placeholder
    for the result of an operation. As you would expect, the result of an operation
    can be in one of two states—either the operation is still in progress and the
    result is not available yet, or the operation has finished and the result is available.
    Note that in the second case, there might have been an error, making the result
    immaterial.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Rust异步编程故事的核心是futures crate。这个crate提供了一个名为*future*的结构。这本质上是一个操作结果的占位符。正如你所期望的，操作的结果可以是两种状态之一——要么操作仍在进行中，结果尚未可用，要么操作已完成，结果可用。请注意，在第二种情况下，可能发生错误，使得结果变得无关紧要。
- en: 'The library provides a trait called `Future` (among other things),which any
    type can implement to be able to act like a future. This is how the trait looks:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供了一个名为`Future`的特质（以及其他一些东西），任何类型都可以实现这个特质来能够像未来一样行动。这个特质看起来是这样的：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `Item` refers to the type of the returned result on successful completion
    of the operation, and `Error` is the type that is returned if the operation fails.
    An implementation must specify those and also implement the poll method that gets
    the current state of the computation. If it has already finished, the result will
    be returned. If not, the future will register that the current task is interested
    in the outcome of the given operation. This function returns a `Poll`, which looks
    like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Item`指的是操作成功完成时返回的结果类型，而`Error`是操作失败时返回的类型。实现必须指定这些类型，并实现获取计算当前状态的`poll`方法。如果它已经完成，将返回结果。如果没有，未来将注册当前任务对给定操作的结果感兴趣。这个函数返回一个`Poll`，其外观如下：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A `Poll` is typed to a result of another type called `Async` (and the given
    error type), which is defined next.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Poll`被类型化为另一个名为`Async`（以及给定的错误类型）的类型的结果，该类型将在下面定义。'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Async`, in turn, is an enum that can either be in `Ready(T)` or `NotReady`.
    These last two states correspond to the state of the operation. Thus, the poll
    function can return three possible states:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async`是一个枚举，可以是`Ready(T)`或`NotReady`。这两个最后的状态对应于操作的状态。因此，轮询函数可以返回三种可能的状态：'
- en: '`Ok(Async::Ready(result))` when the operation has completed successfully and
    the result is in the inner variable called `result`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作成功完成且结果在内部变量`result`中时，会返回`Ok(Async::Ready(result))`。
- en: '`Ok(Async::NotReady)` when the operation has not completed yet and a result
    is not available. Note that this does not indicate an error condition.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作尚未完成且结果不可用时，会返回`Ok(Async::NotReady)`。请注意，这并不表示错误条件。
- en: '`Err(e)` when the operation ran into an error. No result is available in this
    case.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作遇到错误时，会返回`Err(e)`。在这种情况下，没有结果可用。
- en: It is easy to note that a `Future` is essentially a `Result` that might still
    be running something to actually produce that `Result`. If one removes the case
    that the `Result` might not be ready at any point in time, the only two options
    we are left with are the `Ok` and the `Err` cases, which exactly correspond to
    a `Result`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易注意到，`Future`本质上是一个`Result`，它可能还在运行以实际产生那个`Result`。如果移除`Result`可能在任何时间点未准备好的情况，我们只剩下两个选项：`Ok`和`Err`，它们正好对应于`Result`。
- en: 'Thus, a `Future` can represent anything that takes a non-trivial amount of
    time to complete. This can be a networking event, a disk read, and so on. Now,
    the most common question at this point is: how do we return a future from a given
    function? There are a few ways of doing that. Let us look at an example here.
    The project setup is the same as it always is.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个`Future`可以代表任何需要非平凡时间才能完成的事情。这可以是一个网络事件、磁盘读取等等。现在，在这个阶段最常见的疑问是：我们如何从一个给定的函数中返回一个`Future`？有几种方法可以做到这一点。让我们在这里看一个例子。项目设置和以往一样。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will need to add some libraries in our Cargo config, which will look like
    this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的Cargo配置中添加一些库，它看起来像这样：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our main file, we set up everything as usual. We are interested in finding
    out whether a given integer is a prime or not, and this will represent the part
    of our operation that takes some time to complete. We have two functions, doing
    exactly that. These two use two different styles of returning futures, as we will
    see later. In practice, the naive way of primality testing did not turn out to
    be slow enough to be a good example. Thus, we had to sleep for a random time to
    simulate slowness.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主文件中，我们像往常一样设置一切。我们感兴趣的是找出一个给定的整数是否为素数，这将代表我们操作中需要一些时间才能完成的部分。我们有两个函数，正是为了做到这一点。这两个函数使用两种不同的风格返回`Future`，我们稍后会看到。实际上，原始的素性测试方法并没有慢到足以成为一个好的例子。因此，我们不得不随机休眠一段时间来模拟缓慢。
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are a few major ways of returning futures. The first one is using trait
    objects, as done in `check_prime_boxed`. Now, `Box` is a pointer type pointing
    to an object on the heap. It is a managed pointer in the sense that the object
    will be automatically cleaned up when it goes out of scope. The return type of
    the function is a trait object, which can represent any future that has its `Item`
    set to bool and `Error` set to `io:Error`. Thus, this represents dynamic dispatch.
    The second way of returning a future is using the `impl` trait feature. In the
    case of `check_prime_impl_trait`, that is what we do. We say that the function
    returns a type that implements `Future<Item=bool, Error=io::Error>`, and as any
    type that implements the `Future` trait is a future, our function is returning
    a future. Note that in this case, we do not need to box before returning the result.
    Thus, an advantage of this approach is that no allocation is necessary for returning
    the future. Both of our functions use the `future::ok` function to signal that
    our computation has finished successfully with the given result. Another option
    is to not actually return a future and to use the futures-based thread pool crate
    to do the heavy lifting toward creating a future and managing it. This is the
    case with `check_prime` that just returns a `bool`. In our main function, we set
    up a thread pool using the futures-`cpupool` crate, and we run the last function
    in that pool. We get back a future on which we can call `wait` to get the result.
    A totally different option for achieving the same goal is to return a custom type
    that implements the `Future` trait. This one is the least ergonomic, as it involves
    writing some extra code, but it is the most flexible approach.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 返回未来的主要方法有几种。第一种是使用特质对象，就像在 `check_prime_boxed` 中做的那样。现在，`Box` 是一个指向堆上对象的指针类型。它是一个受管理的指针，意味着当对象超出作用域时，对象将被自动清理。函数的返回类型是一个特质对象，它可以代表任何将
    `Item` 设置为 bool 且将 `Error` 设置为 `io::Error` 的未来。因此，这代表了动态分派。返回未来的第二种方法是使用 `impl`
    特质特性。在 `check_prime_impl_trait` 的情况下，我们就是这样做的。我们说该函数返回一个实现了 `Future<Item=bool,
    Error=io::Error>` 的类型，并且由于任何实现了 `Future` 特质的类型都是未来，我们的函数正在返回一个未来。请注意，在这种情况下，我们不需要在返回结果之前装箱。因此，这种方法的一个优点是返回未来不需要进行分配。我们的两个函数都使用
    `future::ok` 函数来表示我们的计算已经成功完成，并给出了给定的结果。另一种选择是实际上不返回一个未来，而是使用基于未来的线程池 crate 来执行创建未来和管理未来的繁重工作。这就是
    `check_prime` 的情况，它只返回一个 `bool`。在我们的主函数中，我们使用 futures-`cpupool` crate 设置了一个线程池，并在该池中运行最后一个函数。我们得到一个可以调用
    `wait` 来获取结果的未来。为了达到相同的目标，还有一个完全不同的选项，即返回一个实现了 `Future` 特质的自定义类型。这是最不便捷的，因为它需要编写一些额外的代码，但它是最灵活的方法。
- en: The `impl` trait is not a stable feature yet. Thus, `check_prime_impl_trait`
    will only work on nightly Rust.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`impl` 特性目前还不是稳定特性。因此，`check_prime_impl_trait` 只能在 nightly Rust 上工作。'
- en: 'Having constructed a future, the next goal is to execute it. There are three
    ways of doing this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 构建了一个未来之后，下一个目标是执行它。有三种方法可以做到这一点：
- en: 'In the current thread: This will end up blocking the current thread till the
    future has finished executing. In our previous example, `res_one` and `res_two`
    are executed on the main thread, blocking user interaction.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前线程中：这将导致当前线程被阻塞，直到未来完成执行。在我们之前的例子中，`res_one` 和 `res_two` 在主线程上执行，阻止了用户交互。
- en: 'In a thread pool: This is the case with `res_three`, which is executed in a
    thread pool named `thread_pool`. Thus, in this case, the calling thread is free
    to move on with its own processing.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程池中：对于 `res_three` 来说，这是这种情况，它在名为 `thread_pool` 的线程池中执行。因此，在这种情况下，调用线程可以自由地继续自己的处理。
- en: 'In an event loop: In some cases, neither of the above is possible. The only
    option then is to execute futures in an event loop. Conveniently, the tokio-core
    crate provides futures-friendly APIs to use event loops. We will look deeper into
    this model in the next section.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件循环中：在某些情况下，上述两种方法都不可能。那时唯一的选择是在事件循环中执行未来。方便的是，tokio-core crate 提供了面向未来的 API
    来使用事件循环。我们将在下一节更深入地探讨这个模型。
- en: 'In our main function, we call the first two functions in the main thread. Thus,
    they will block execution of the main thread. The last one, however, is run on
    a different thread. In that case, the main thread is immediately free to print
    out that `check_prime` has been called. It blocks again on calling `wait` on the
    future. Note that the futures are lazily evaluated in all cases. When we run this,
    we should see the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们在主线程中调用了前两个函数。因此，它们将阻塞主线程的执行。然而，最后一个函数是在不同的线程上运行的。在这种情况下，主线程可以立即自由地打印出`check_prime`已被调用的信息。当在`future`上调用`wait`时，它再次被阻塞。请注意，在所有情况下，`future`都是惰性评估的。当我们运行这个程序时，我们应该看到以下内容：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What sets futures apart from regular threads is that they can be chained ergonomically.
    This is like saying, *download the web page and then parse the html and then extract
    a given word*. Each of these steps in series is a future, and the next one cannot
    start unless the first one has finished. The whole operation is a `Future` as
    well, being made up of a number of constituent futures. When this larger future
    is being executed, it is called a task. The crate provides a number of APIs for
    interacting with tasks in the `futures::task` namespace. The library provides
    a number of functions to work with futures in this manner. When a given type implements
    the `Future` trait (implements the `poll` method), the compiler can provide implementations
    for all of these combinators. Let us look at an example of implementing a timeout
    functionality using chaining. We will use the tokio-timer crate for the timeout
    future and, in our code, we have two competing functions that sleep for a random
    amount of time and then return a fixed string to the caller. We will dispatch
    all these simultaneously and, if we get back the string corresponding to the first
    function, we declare that it has won. Similarly, this applies for the second one.
    In case we do not get back either, we know that the timeout future has triggered.
    Let''s start with the project setup:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将`future`与常规线程区分开来的是，它们可以以符合人体工程学的方式链式连接。这就像说，*下载网页，然后解析html，然后提取一个特定的单词*。这些串联步骤中的每一个都是一个`future`，下一个步骤不能开始，除非第一个步骤已经完成。整个操作也是一个`Future`，由多个组成部分`future`组成。当这个更大的`future`正在执行时，它被称为任务。该crate在`futures::task`命名空间中提供了一些用于与任务交互的API。该库提供了一些函数来以这种方式处理`future`。当一个给定的类型实现了`Future`特质（实现了`poll`方法）时，编译器可以提供所有这些组合器的实现。让我们看看使用链式连接实现超时功能的示例。我们将使用`tokio-timer`
    crate作为超时`future`，在我们的代码中，我们有两个相互竞争的函数，它们会随机休眠一段时间，然后向调用者返回一个固定的字符串。我们将同时调度所有这些函数，如果我们收到第一个函数对应的字符串，我们就宣布它获胜。同样，这也适用于第二个函数。如果我们都没有收到，我们知道超时`future`已经触发。让我们从项目设置开始：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We then add our dependencies in our `Cargo.toml`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`Cargo.toml`中添加我们的依赖项
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Like last time, we use a thread pool to execute our futures using the futures-`cpupool`
    crate. Lets us look at the code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 和上次一样，我们使用线程池来执行我们的`future`，使用`futures-cpupool` crate。让我们看看代码：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our two players are very similar; both of them generate a random number between
    `1` and `5` and sleep for that amount of seconds. After that, they return a fixed
    string corresponding to their names. We will later use these strings to identify
    them uniquely. In our main function, we initialize the thread pool and the timer.
    We use the combinator on the timer to return a future that errors out after `3`
    seconds. We then spawn the two players in the thread pool and return `Result`s
    from those as futures. Note that those functions are not really running at this
    point, because futures are lazily evaluated. We then put those futures in a list
    and use the `select_ok` combinator to run those in parallel. This function takes
    in a iterable of futures and selects the first successful future; the only restriction
    here is that all the futures passed to this function should be of the same type.
    Thus, we cannot pass the timeout future here. We chain the result of `select_ok`
    to the timeout future using the `select` combinator that takes two futures and
    waits for either to finish executing. The resultant future will have the one that
    has finished and the one that hasn't. We then use the `map` combinator to discard
    the second part. Finally, we block on our futures and signal the end of the chain
    using `ok()`. We can then compare the result with the known strings to determine
    which future has won, and print out messages accordingly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个玩家非常相似；它们都生成一个介于 `1` 和 `5` 之间的随机数，并睡眠相应的时间。之后，它们返回一个与它们名称对应的固定字符串。我们稍后会使用这些字符串来唯一标识它们。在我们的主函数中，我们初始化线程池和计时器。我们使用计时器上的组合器来返回一个在
    `3` 秒后出错的未来。然后我们在线程池中启动两个玩家，并从这些玩家返回 `Result` 作为未来。请注意，这些函数现在实际上并没有真正运行，因为 futures
    是懒加载的。然后我们将这些未来放入一个列表中，并使用 `select_ok` 组合器并行运行这些。这个函数接受一个未来的可迭代集合，并选择第一个成功的未来；这里的唯一限制是传递给此函数的所有未来都应该属于同一类型。因此，我们不能将超时未来传递到这里。我们使用接受两个未来的
    `select` 组合器将 `select_ok` 的结果与超时未来链接起来，该组合器等待任一完成执行。结果未来将包含已经完成和尚未完成的部分。然后我们使用
    `map` 组合器丢弃第二部分。最后，我们阻塞在未来的上，并使用 `ok()` 信号结束链。然后我们可以将结果与已知的字符串进行比较，以确定哪个未来获胜，并相应地打印出消息。
- en: This is how a few runs will look. As our timeout is smaller than the maximum
    sleep period of either of the two functions, we should see a few timeouts. Whenever
    a function chooses a time less than the timeout, it gets a shot at winning.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些运行的结果。由于我们的超时时间小于两个函数中任一的最大睡眠时间，我们应该看到一些超时。每当一个函数选择的时间小于超时时间时，它就有机会获胜。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Working with streams and sinks
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与流和汇一起工作
- en: 'The futures crate provides another useful abstraction for a lazily evaluated
    series of events, called `Stream`. If `Future` corresponds to `Result`, a `Stream`
    corresponds to `Iterator`. Semantically, they are very similar to futures, and
    they look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: futures crate 提供了另一个用于懒加载一系列事件的有用抽象，称为 `Stream`。如果 `Future` 对应于 `Result`，那么
    `Stream` 就对应于 `Iterator`。从语义上看，它们与 futures 非常相似，看起来是这样的：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The only difference here is that the return type is wrapped in an `Option`,
    exactly like the `Iterator` trait. Thus, a `None` here would indicate that the
    stream has terminated. Also, all streams are futures and can be converted using
    `into_future`. Let us look at an example of using this construct. We will partially
    reuse our collatz example from a previous chapter. The first step is to set up
    the project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是返回类型被包裹在一个 `Option` 中，就像 `Iterator` 特性一样。因此，这里的 `None` 会表示流已终止。此外，所有流都是未来，可以使用
    `into_future` 转换。让我们看看使用这个构造的一个例子。我们将部分重用之前章节中的 collatz 示例。第一步是设置项目：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With all the dependencies added, our Cargo config looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了所有依赖项后，我们的 Cargo 配置看起来如下：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Having set everything up, our main file will look as follows. In this case,
    we have a struct called `CollatzStream` that has two fields for the current state
    and the end state (which should always be `1`). We will implement the `Stream`
    trait on this to make this behave as a stream:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好一切之后，我们的主文件将如下所示。在这种情况下，我们有一个名为 `CollatzStream` 的结构体，它有两个字段用于当前状态和结束状态（始终为
    `1`）。我们将在这个结构体上实现 `Stream` 特性，使其表现得像一个流：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We simulate a delay in returning the result by sleeping for a random amount
    of time between `1` and `5` seconds. Our implementation for the poll returns `Ok(Async::Ready(None))`
    to signal that the stream has finished when it reaches `1`. Otherwise, it returns
    the current state as `Ok(Async::Ready(Some(self.current)))`. It''s easy to note
    that, except for the stream semantics, this implementation is the same as that
    for iterators. In our main function, we initialize the struct and use the `for_each`
    combinator to print out each item in the stream. This combinator returns a future
    on which we call `wait` and `ok` to block and get all results. Here is what we
    see on running the last example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `1` 到 `5` 秒之间随机暂停来模拟返回结果的延迟。在我们的轮询实现中，当达到 `1` 时，我们返回 `Ok(Async::Ready(None))`
    来表示流已结束。否则，我们返回当前状态作为 `Ok(Async::Ready(Some(self.current)))`。很容易注意到，除了流语义外，这个实现与迭代器的实现相同。在我们的主函数中，我们初始化结构体并使用
    `for_each` 组合子来打印流中的每个项目。这个组合子返回一个未来，我们在其上调用 `wait` 和 `ok` 来阻塞并获取所有结果。以下是运行最后一个示例时我们看到的内容：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As it is with the `Future` trait, the `Stream` trait also supports a number
    of other combinators useful for different purposes. The dual of a `Stream` is
    a `Sink`, which is a receiver of asynchronous events. This is extremely useful
    in modeling the sending end of Rust channels, network sockets, file descriptors,
    and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `Future` 特性一样，`Stream` 特性也支持许多其他组合子，这些组合子适用于不同的目的。`Stream` 的对偶是 `Sink`，它是异步事件的接收者。这在模拟
    Rust 通道的发送端、网络套接字、文件描述符等时非常有用。
- en: 'A common pattern in any asynchronous system is synchronization. This becomes
    important, as more often than not, components need to communicate with one another
    to pass data or coordinate tasks. We solved this exact problem in the past using
    channels. But those constructions are not applicable here, as the channel implementation
    in the standard library is not asynchronous. Thus, futures has its own channel
    implementation, which provides all the guarantees you would expect from an asynchronous
    system. Let us look at an example; our project setup should look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何异步系统中，一个常见的模式是同步。这变得很重要，因为组件通常需要相互通信以传递数据或协调任务。我们过去使用通道解决了这个确切的问题。但是，这些构造在这里不适用，因为标准库中的通道实现不是异步的。因此，futures
    有自己的通道实现，它提供了您从异步系统期望的所有保证。让我们看看一个例子；我们的项目设置应该如下所示：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Cargo config should look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 配置应该如下所示：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we have two functions. One waits for a random amount of time and then randomly
    returns either `"ping"` or `"pong"`. This function will be our sender. Here is
    what it looks like:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个函数。一个函数会等待随机的时间，然后随机返回 `"ping"` 或 `"pong"`。这个函数将是我们的发送者。以下是它的样子：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The futures crate provides two types of channel: a *oneshot* channel that can
    be used only once to send and receive any messages, and a regular *mpsc* channel
    that can be used multiple times. In our main function, we get hold of both ends
    of the channel and spawn our sender in another thread as a future. The receiver
    is spawned in another thread. In both cases, we record the handles to be able
    to wait for them to finish (using `join`) later. Note that our receiver takes
    in the receiving end of the channel as parameter. Because `Receiver` implements
    `Stream`, we can use the `and_then` combinator on it to print out the value. Finally,
    we call `wait()` and `ok()` on the future before exiting the receiver function.
    In the main function, we join on the two thread handles to drive them to completion.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: futures 库提供了两种类型的通道：一种是一次性使用的 *oneshot* 通道，可以用来发送和接收任何消息，还有一种是可以多次使用的常规 *mpsc*
    通道。在我们的主函数中，我们获取通道的两端，并在另一个线程中将发送者作为未来启动。接收者也在另一个线程中启动。在这两种情况下，我们记录处理程序以便稍后等待它们完成（使用
    `join`）。请注意，我们的接收者将通道的接收端作为参数。因为 `Receiver` 实现了 `Stream`，我们可以使用 `and_then` 组合子在它上面来打印值。最后，我们在退出接收函数之前在未来的
    `wait()` 和 `ok()` 上调用。在主函数中，我们通过两个线程处理程序来连接它们，以驱动它们完成。
- en: Running the last example will randomly print either `"ping"` or `"pong"`, depending
    on what was sent via the channel. Note that the actual printing happens on the
    receiving end.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行最后一个示例将随机打印 `"ping"` 或 `"pong"`，具体取决于通过通道发送的内容。请注意，实际的打印操作发生在接收端。
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The futures crate also provides a locking mechanism in `futures::sync::BiLock`
    that closely mirrors `std::sync::Mutex`. This is a future-aware mutex that arbitrates
    sharing a resource between two owners. Note that a `BiLock` is only for two futures,
    which is an annoying limitation. Here is how it works: we are interested in modifying
    our last example to show a counter when the sender function is called. Now our
    counter needs to be thread-safe so that it can be shared across consumers. Set
    up the project using Cargo:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`futures` crate 还在 `futures::sync::BiLock` 中提供了一个锁定机制，这与 `std::sync::Mutex`
    非常相似。这是一个面向未来的互斥锁，用于在两个所有者之间仲裁资源共享。请注意，`BiLock` 只适用于两个未来，这是一个令人烦恼的限制。以下是它是如何工作的：我们感兴趣的是修改我们的最后一个示例，以在发送函数被调用时显示一个计数器。现在我们的计数器需要是线程安全的，以便可以在消费者之间共享。使用
    Cargo 设置项目：'
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our `Cargo.toml` file should be exactly the same, and here is how the main
    file looks:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Cargo.toml` 文件应该完全相同，以下是主文件的外观：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While this is basically the same as the last example, there are some differences.
    In our main function, we set the counter to zero. We then create a `BiLock` on
    the counter. The constructor returns two handles like a channel, which we can
    then pass around. We then create our channel and spawn the sender. Now, if we
    look at the sender, it has been modified to take in a reference to a `BiLock`.
    In the function, we attempt to acquire a lock using `poll_lock`, and, if that
    works, we increment the counter. Otherwise, we do nothing. We then move on to
    our usual business of returning `"ping"` or `"pong"`. The receiver has been modified
    to take a `BiLock` as well. In that, we try to acquire a lock and, if successful,
    we print out the value of the data being locked. In our main function, we spawn
    these futures using threads and join on them to wait for those to finish.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这基本上与上一个示例相同，但有一些区别。在我们的主函数中，我们将计数器设置为零。然后我们在计数器上创建一个 `BiLock`。构造函数返回两个类似于通道的句柄，然后我们可以将它们传递出去。然后我们创建我们的通道并启动发送者。现在，如果我们查看发送者，它已经被修改为接受一个
    `BiLock` 的引用。在该函数中，我们尝试使用 `poll_lock` 获取锁，如果成功，我们增加计数器。否则，我们不做任何事情。然后我们继续我们通常的业务，返回
    `"ping"` 或 `"pong"`。接收者也被修改为接受一个 `BiLock`。在那里，我们尝试获取锁，如果成功，我们打印出被锁定数据的值。在我们的主函数中，我们使用线程启动这些
    futures，并在它们上等待它们完成。
- en: 'Here is what happens on an unsuccessful run, when both parties fail to acquire
    the lock. In a real example, we would want to handle the error gracefully and
    retry. We left out that part for the sake of brevity:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在尝试获取锁失败时发生的情况，当双方都未能获取锁。在真实示例中，我们希望优雅地处理错误并重试。我们为了简洁起见省略了这部分内容：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is what a good run looks like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个良好的运行示例：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Heading to tokio
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在前往 tokio
- en: 'The tokio ecosystem is an implementation of a network stack in Rust. It has
    all the major functionality of the standard library, the major difference being
    that it is non-blocking (most common calls do not block the current thread). This
    is achieved by using mio to do all the low-level heavy lifting, and using futures
    to abstract away long-running operations. The ecosystem has two basic crates,
    everything else being built around those:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: tokio 生态系统是 Rust 中网络堆栈的一个实现。它具有标准库的所有主要功能，主要区别在于它是非阻塞的（大多数常见调用不会阻塞当前线程）。这是通过使用
    mio 来完成所有底层繁重工作，并使用 futures 来抽象长运行操作来实现的。该生态系统有两个基本 crate，其他所有内容都是围绕这些构建的：
- en: '`tokio-proto` provides primitives for building asynchronous servers and clients.
    This depends heavily on mio for low-level networking and on futures for abstraction.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tokio-proto` 提供了构建异步服务器和客户端的原语。这严重依赖于 mio 进行底层网络和 futures 进行抽象。'
- en: '`tokio-core` provides an event loop to run futures in and a number of related
    APIs. This is useful when an application needs fine-grained control over IO.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tokio-core` 提供了一个事件循环来运行 futures，以及一些相关的 API。当应用程序需要精细控制 IO 时，这很有用。'
- en: 'As we mentioned in the last section, one way to run futures is on an event
    loop. An event loop (called a `reactor` in tokio) is an infinite loop that listens
    for defined events and takes appropriate action once it receives one. Here is
    how this works: we will borrow our previous example of a function that determines
    whether the given input is a prime or not. This returns a future with the result,
    which we then print out. The project setup is the same as it always is:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，运行 futures 的一种方法是在事件循环上。事件循环（在 tokio 中称为 `reactor`）是一个无限循环，它监听定义的事件，并在接收到一个事件时采取适当的行动。以下是它是如何工作的：我们将借用我们之前的示例，该示例确定给定的输入是否为素数。这返回一个包含结果的
    future，然后我们将其打印出来。项目设置与以往相同：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is what `Cargo.toml` should look like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Cargo.toml`应该看起来像什么：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For this example, we will take input in an infinite loop. For each input, we
    trim out newlines and spaces and try to parse it as an `u64`. Here is how it looks:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将在一个无限循环中接收输入。对于每个输入，我们将去除换行符和空格，并尝试将其解析为`u64`。看起来是这样的：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In our main function, we create the core and start our infinite loop. We use
    the `run` method of core to start a task to execute the future asynchronously.
    The result is collected and printed on the standard output. Here is what a session
    should look like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们创建核心并启动我们的无限循环。我们使用核心的`run`方法来启动一个任务以异步执行未来。结果被收集并在标准输出上打印。一个会话应该看起来像这样：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `tokio-proto` crate is an asynchronous server (and client) building toolkit.
    Any server that uses this crate has the following three distinct layers:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokio-proto`是一个异步服务器（和客户端）构建工具包。任何使用此工具包的服务器都有以下三个不同的层：'
- en: A codec that dictates how data should be read from and written to the underlying
    socket forming the transport layer for our protocol. Subsequently, this layer
    is the bottom-most (closest to the physical medium). In practice, writing a codec
    amounts to implementing a few given traits from the library that processes a stream
    of bytes.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编解码器，它决定了如何从底层套接字读取和写入数据，形成我们协议的传输层。随后，这一层是最低的（最接近物理介质）。在实践中，编写编解码器相当于实现库中的一些给定特质，这些特质处理字节流。
- en: 'A protocol sits above a codec and below the actual event loop running the protocol.
    This acts as a glue to bind those together. tokio supports multiple protocol types,
    depending on the application: a simple request-response type protocol, a multiplexed
    protocol, and a streaming protocol. We will delve into each of these shortly.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个协议位于编解码器之上和实际运行协议的事件循环之下。这充当粘合剂，将它们绑定在一起。tokio支持多种协议类型，具体取决于应用程序：一个简单的请求-响应类型协议、一个多路复用协议和一个流协议。我们将很快深入探讨这些。
- en: A service that actually runs all this as a future. As this is just a future,
    an easy way to think of this is as an asynchronous function that transforms an
    input to an eventual response (which could be an error). In practice, most of
    the computation is done in this layer.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实际运行所有这些操作作为未来的服务。由于这只是一个未来，一个简单的方式来思考它是一个将输入转换为最终响应（可能是错误）的异步函数。在实践中，大部分计算都在这一层完成。
- en: 'Because the layers are swappable, an implementation is perfectly free to swap
    the protocol type for another, or the service for another one, or the codec. Let
    us look at an example of a simple service using `tokio-proto`. This one is a traditional
    request-response service that provides a text-based interface. It takes in a number
    and returns its collatz sequence as an array. If the input is not a valid integer,
    it send back a message indicating the same. Our project setup is pretty simple:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于层是可互换的，实现可以完全自由地交换协议类型、服务或编解码器。让我们看看一个使用`tokio-proto`的简单服务的例子。这是一个传统的请求-响应服务，提供基于文本的接口。它接收一个数字并返回其Collatz序列作为数组。如果输入不是一个有效的整数，它将返回一条消息指出这一点。我们的项目设置相当简单：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The Cargo config looks like the following sample:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo配置看起来像以下示例：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As described earlier, we will need to implement the different layers. In our
    current case, each of our layers do not need to hold much state. Thus, they can
    be represented using unit structs. If that was not the case, we would need to
    put some data in those.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要实现不同的层。在我们的当前情况下，我们的每一层都不需要保留太多状态。因此，它们可以用单元结构体来表示。如果不是这种情况，我们就需要在这些层中放入一些数据。
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we saw earlier, the first step is to tell the codec how to read data to and
    from the socket. This is done by implementing `Encoder` and `Decoder` from `tokio_io::codec`.
    Note that we don't have to deal with raw sockets here; we get a stream of bytes
    as input, which we are free to process. According to our protocol defined before,
    a newline indicates an end of input. So, in our decoder, we read till a newline
    and return the data after removing the said newline as a UTF-8 encoded string.
    In case of an error, we return a `None`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，第一步是告诉编解码器如何从套接字读取数据。这是通过从`tokio_io::codec`实现`Encoder`和`Decoder`来完成的。请注意，我们在这里不需要处理原始套接字；我们得到一个字节流作为输入，我们可以自由地处理它。根据我们之前定义的协议，换行符表示输入的结束。因此，在我们的解码器中，我们读取到换行符，然后返回去除该换行符后的数据作为一个UTF-8编码的字符串。在发生错误的情况下，我们返回`None`。
- en: 'The `Encoder` implementation is exactly the reverse: it transforms a string
    into a stream of bytes. The next step is the protocol definition, this one is
    really simple, as it does not do multiplexing or streaming. We implement `bind_transport`
    to bind the codec to our raw socket, which we will get to later. The only catch
    here is that the `Request` and `Response` types here should match that of the
    codec. Having set these up, the next step is to implement the service, by declaring
    an unit struct and implementing the `Service` trait on it. Our helper function
    `get_sequence` returns the collatz sequence given a `u64` as input. The `call`
    method in `Service` implements the logic of computing the response. We parse the
    input as a `u64` (remember that our codec returns input as a String). If that
    did not error out, we call our helper function and return the result as a static
    string, otherwise we return an error. Our main function looks similar to such
    a function as would use standard networking types, but, we use the `TcpServer`
    type from tokio, which takes in our socket (to bind it to the codec) and our protocol
    definition. Finally, we call the `serve` method while passing our service as a
    closure. This method takes care of managing the event loop and cleaning up things
    on exit.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Encoder`实现正好相反：它将字符串转换成字节流。下一步是协议定义，这个协议非常简单，因为它既不做多路复用也不做流处理。我们实现`bind_transport`将编解码器绑定到我们的原始套接字，我们稍后会得到它。这里的唯一问题是这里的`Request`和`Response`类型应该与编解码器匹配。设置好这些之后，下一步是实现服务，通过声明一个单元结构体并在其上实现`Service`特质。我们的辅助函数`get_sequence`根据输入的`u64`返回柯朗序列。`Service`中的`call`方法实现了计算响应的逻辑。我们将输入解析为`u64`（记住，我们的编解码器将输入作为字符串返回）。如果没有出错，我们调用我们的辅助函数并返回一个静态字符串作为结果，否则返回一个错误。我们的主函数看起来与使用标准网络类型的函数类似，但我们使用tokio的`TcpServer`类型，它接受我们的套接字（将其绑定到编解码器）和我们的协议定义。最后，我们调用`serve`方法，并将我们的服务作为闭包传递。这个方法负责管理事件循环并在退出时清理事物。'
- en: 'Let us use `telnet` to interact with it. Here is how a session will look:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`telnet`与之交互。下面是一个会话的示例：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As always, it would be much more useful to write a client for our server. We
    will borrow a lot from the example of running a future in an event loop. We start
    with setting up our project:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，编写一个客户端来与我们的服务器交互将更有用。我们将从在事件循环中运行future的示例中借用很多内容。我们首先设置我们的项目：
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our Cargo setup will look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的货物设置将看起来像这样：
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is our main file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的主文件：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Of course, this one sends a single integer to the server (110 in decimal),
    but it is trivial to put this in a loop to read input and send those. We leave
    that as an exercise for the reader. Here, we create a event loop and get its handle.
    We then use the asynchronous `TcpStream` implementation to connect to the server
    on a given address. This returns a future, which we combine with a closure using
    `and_then` to write to the given socket. The whole construct returns a new future
    called `request`, which is chained with a reader future. The final future is called
    `response` and is run on the event loop. Finally, we read the response and print
    it out. At every step, we have to respect our protocol that a newline denotes
    end-of-input for both the server and the client. Here is what a session looks
    like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个设置会将单个整数发送到服务器（十进制中的110），但将这个操作放入循环以读取输入并发送这些数据是微不足道的。我们将这个任务留给读者去练习。在这里，我们创建了一个事件循环并获取其句柄。然后，我们使用异步的`TcpStream`实现连接到给定地址的服务器。这会返回一个future，我们使用`and_then`将其与闭包结合以写入给定的套接字。整个结构返回一个新的future，称为`request`，它与一个读取future链在一起。最终的future称为`response`，并在事件循环上运行。最后，我们读取响应并将其打印出来。在每一步，我们必须遵守我们的协议，即换行符表示服务器和客户端的输入结束。下面是一个会话的示例：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Socket multiplexing in tokio
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tokio中的套接字多路复用
- en: One model of asynchronous-request processing in a server is through multiplexing
    incoming connections. In this case, each connection is assigned a unique ID of
    some kind and replies are issued whenever one is ready, irrespective of the order
    in which it was received. Thus, this allows a higher throughput, as the shortest
    job gets the highest priority implicitly. This model also makes the server highly
    responsive with a larger number of incoming requests of varying complexity. Traditional
    Unix-like systems support this using the select and poll system calls for socket
    multiplexing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器中异步请求处理的一种模式是通过多路复用传入的连接。在这种情况下，每个连接被分配一个某种类型的唯一ID，并且每当有一个准备好时就会发出回复，而不考虑它接收的顺序。因此，这允许更高的吞吐量，因为最短的任务隐含地获得了最高的优先级。这种模型也使得服务器在面对大量不同复杂度的传入请求时具有高度的响应性。传统的类Unix系统使用select和poll系统调用来支持套接字多路复用。
- en: 'In the tokio ecosystem, this is mirrored by a number of traits that enable
    implementing multiplexed protocols. The basic anatomy of the server is the same
    as a simple server: we have the codec, the protocol using the codec, and a service
    that actually runs the protocol. The only difference here is that we will assign
    a request ID to each incoming request. This will be used later to disambiguate
    while sending back responses. We will also need to implement some traits from
    the `tokio_proto::multiplex` namespace. As an example, we will modify our collatz
    server and add multiplexing to it. Our project setup is a bit different in this
    case, as we are planning to run the binaries using Cargo, and our project will
    be a library. We set it up like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在tokio生态系统中，这通过一系列特性来实现，这些特性使得实现多路复用协议成为可能。服务器的基本结构与简单服务器相同：我们有编解码器、使用编解码器的协议，以及实际运行协议的服务。这里唯一的区别是我们将给每个传入的请求分配一个请求ID。这将用于稍后发送响应时的去歧义。我们还需要实现`tokio_proto::multiplex`命名空间中的一些特性。作为一个例子，我们将修改我们的collatz服务器并为其添加多路复用功能。在这个情况下，我们的项目设置略有不同，因为我们计划使用Cargo运行二进制文件，并且我们的项目将是一个库。我们是这样设置的：
- en: '[PRE36]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The Cargo config is similar:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo配置类似：
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is what the `lib.rs` file looks like:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`lib.rs`文件的样子：
- en: '[PRE38]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Tokio provides a built-in type called `RequestId` to represent unique IDs for
    incoming requests, all states associated with it being managed internally by tokio.
    We define a custom data type called `CollatzFrame` for our frame; this has the
    `RequestId` and a `String` for our data. We move on to implementing `Decoder`
    and `Encoder` for `CollatzCodec` like last time. But, in both of these cases,
    we have to take into account the request ID in the header and the trailing newline.
    Because the `RequestId` type is a `u64` under the hood, it will always be four
    bytes and one extra byte for a newline. Thus, if we have received fewer than 5
    bytes, we know that the whole frame has not been received yet. Note that this
    is not an error case, the frame is still being transmitted, so we return an `Ok(None)`.
    We then check whether the buffer has a newline (in compliance with our protocol).
    If everything looks good, we parse the request ID from the first 4 bytes (note
    that this will be in network-byte order). We then construct an instance of `CollatzFrame`
    and return it. The encoder implementation is the inverse; we just need to put
    the request ID back in, then the actual data, and end with a newline.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Tokio提供了一个内置类型`RequestId`来表示传入请求的唯一ID，所有与其相关的状态都由tokio内部管理。我们定义了一个名为`CollatzFrame`的自定义数据类型来表示我们的帧；它包含`RequestId`和用于我们数据的`String`。我们继续实现`Decoder`和`Encoder`，就像上次一样，为`CollatzCodec`。但是，在这两种情况下，我们必须考虑到头部中的请求ID和尾随的换行符。因为`RequestId`类型在底层是`u64`，它总是占用四个字节，再加上一个换行符的字节。因此，如果我们收到了少于5个字节，我们知道整个帧还没有收到。请注意，这并不是一个错误情况，帧仍在传输中，所以我们返回`Ok(None)`。然后我们检查缓冲区是否有换行符（符合我们的协议）。如果一切看起来都很好，我们从前4个字节解析请求ID（请注意，这将是在网络字节序）。然后我们构造一个`CollatzFrame`实例并返回它。编码器的实现是相反的；我们只需要将请求ID放回，然后是实际的数据，最后以换行符结束。
- en: The next steps are to implement `ServerProto` and `ClientProto` for `CollatzProto`;
    both of these are boilerplates that bind the codec with the transport. Like last
    time, the last step is to implement the service. This step does not change at
    all. Note that we do not need to care about dealing with the request ID after
    implementing the codec because later stages do not see it at all. The codec deals
    with and manages it while passing on the actual data to later layers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现`ServerProto`和`ClientProto`的`CollatzProto`；这两个都是绑定编解码器与传输的样板代码。像上次一样，最后一步是实现服务。这一步没有任何变化。请注意，在实现编解码器后，我们不需要关心处理请求ID，因为后续阶段根本看不到它。编解码器处理并管理它，同时将实际数据传递到后续层。
- en: 'Here is what our frame looks like:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们帧的外观：
- en: '![](img/00016.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00016.jpeg)'
- en: Our request frame with the RequestId as header and a trailing newline
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的请求帧，其中包含作为头部的RequestId和一个尾随换行符
- en: 'This time, our client will be based on tokio too. Our `Client` struct wraps
    an instance of `ClientService`, which takes in the underlying TCP stream and the
    protocol implementation to use. We have a convenience function called `connect`
    for the `Client` type, which connects to a given server and returns a future.
    Lastly, we implement `Service` for `Client` in which the `call` method returns
    a future. We run the server and client as examples by putting them in a directory
    called `examples`. This way, cargo knows that those should be run as associated
    examples with this crate. The server looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的客户端也将基于tokio。我们的`Client`结构体封装了一个`ClientService`实例，它接受底层的TCP流和要使用的协议实现。我们有一个名为`connect`的便利函数，用于`Client`类型，它连接到指定的服务器并返回一个future。最后，我们在`Client`中实现`Service`，其中`call`方法返回一个future。我们将服务器和客户端作为示例放入名为`examples`的目录中。这样，cargo就知道这些应该作为与此crate关联的示例运行。服务器看起来是这样的：
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is pretty much the same as last time, just in a different file. We have
    to declare our parent crate as an external dependency so that Cargo can link everything
    properly. This is how the client looks:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上和上次一样，只是在一个不同的文件中。我们必须将父crate声明为外部依赖，这样Cargo才能正确地链接一切。这是客户端的外观：
- en: '[PRE40]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We run our client in an event loop, using tokio-core. We use the connect method
    defined on the client to get a future wrapping the connection. We use the `and_then`
    combinator and use the call method to send a string to the server. As this method
    returns a future as well, we can use the `and_then` combinator on the inner future
    to extract the response and then resolve it by returning an `Ok(())`. This also
    resolves the outer future.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在事件循环中运行我们的客户端，使用tokio-core。我们使用客户端上定义的`connect`方法获取一个封装连接的future。我们使用`and_then`组合器，并使用`call`方法向服务器发送一个字符串。由于此方法也返回一个future，我们可以在内部future上使用`and_then`组合器来提取响应，然后通过返回`Ok(())`来解析它。这也解析了外部future。
- en: 'Now, if we open two terminals and run the server in one and the client in another,
    here is what we should see in the client. Note that as we do not have sophisticated
    retries and error handling, the server should be run before the client:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开两个终端，在一个终端中运行服务器，在另一个终端中运行客户端，我们应该在客户端看到以下内容。请注意，由于我们没有复杂的重试和错误处理，服务器应该在客户端之前运行：
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And, as expected, this output matches what we got before.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这个输出与之前的结果匹配。
- en: Writing streaming protocols
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写流式协议
- en: 'In a number of cases, a protocol has a data unit with a header attached to
    it. The server typically reads the header first and, based on that, decides how
    to process the data. In some cases, the server may be able to do some processing
    based on the header. One such example is IP, which has a header that has the destination
    address. A server may start running a longest prefix match based on that information,
    before reading the body. In this section, we will look into using tokio to write
    such servers. We will expand our toy collatz protocol to include a header and
    some data body, and work from there. Let us start with an example, and our project
    setup will be exactly the same, setting it up using Cargo:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，一个协议有一个数据单元，其中包含一个附加的头部。服务器通常首先读取头部，然后根据这个头部决定如何处理数据。在某些情况下，服务器可能能够根据头部进行一些处理。一个这样的例子是IP，它有一个包含目标地址的头部。服务器可能开始根据该信息运行最长前缀匹配，然后再读取主体。在本节中，我们将探讨如何使用tokio编写这样的服务器。我们将扩展我们的玩具collatz协议，包括一个头部和一些数据主体，并从这里开始。让我们从一个例子开始，我们的项目设置将与上次完全相同，使用Cargo进行设置：
- en: '[PRE42]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Cargo config does not change much:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo配置没有太大变化：
- en: '[PRE43]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As this example is large, we have broken this down into constituent pieces,
    as follows. The first part shows setting up the client:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个示例较大，我们将其分解为几个组成部分，如下所示。第一部分展示了设置客户端的过程：
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As always, the first step is to set up extern crates and include everything
    required. We define a few types that we will use. A `CollatzMessage` is a message
    that our protocol receives; it has a header and a body both of type `String`.
    A `CollatzInput` is an input stream for the protocol, which is an enum with two
    variants: `Once` represents the case where we have received data in a non-streaming
    way, and `Stream` is for the second case. The protocol implementation is a unit
    struct called `CollatzProto`. We then define a struct for the client, which has
    an inner instance of `ClientProxy`, the actual client implementation. This takes
    in three types, the first two being request and response for the whole server,
    and the last one being for errors. We then implement a connect method for the
    `Client` struct that connects using `CollatzProto`, and this returns a future
    with the connection. The last step is to implement `Service` for `Client`, and
    both the input and output for this is of type `CollatzInput`, thus we have to
    transform the output to that type using map on the future. Let us move on to the
    server; it looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 总是首先设置外部 crate 并包含所有必需的内容。我们定义了一些我们将要使用的类型。`CollatzMessage` 是我们的协议接收到的消息；它有一个头部和一个主体，都是
    `String` 类型。`CollatzInput` 是协议的输入流，它是一个枚举，有两个变体：`Once` 代表我们以非流式方式接收数据的情况，而 `Stream`
    是第二种情况。协议实现是一个名为 `CollatzProto` 的单元结构。然后我们定义了一个客户端结构，它有一个内部的 `ClientProxy` 实例，这是实际客户端的实现。它接受三种类型，前两种是整个服务器的请求和响应，最后一种是错误。然后我们为
    `Client` 结构实现一个连接方法，使用 `CollatzProto` 进行连接，并返回一个包含连接的 future。最后一步是实现 `Client`
    的 `Service`，输入和输出都是 `CollatzInput` 类型，因此我们必须使用 future 上的 map 将输出转换为该类型。让我们继续到服务器；它看起来是这样的：
- en: '[PRE45]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As expected, a `CollatzStream` has a body that is either a string or has resulted
    in an error. Now, for a streaming protocol, we need to provide an implementation
    of a function that returns the sender half of the stream; we do this in the `pair`
    function for `CollatzStream`. Next, we implement the `Stream` trait for our custom
    stream; the `poll` method in this case simply polls the inner `Body` for more
    data. Having set up the stream, we can implement the codec. In here, we will need
    to maintain a way to know what part of the frame we are processing at this moment.
    This is done using a boolean called `decoding_head` that we flip as we need. We
    need to implement `Decoder` for our codec, and this is pretty much the same as
    the last few times; just note that we need to keep track of the streaming and
    non-streaming cases and the boolean defined previously. The `Encoder` implementation
    is the reverse. We also need to bind the protocol implementation to the codec;
    this is done by implementing `ClientProto` and `ServerProto` for `CollatzProto`.
    In both cases, we set the boolean to true, as the first thing to be read after
    receiving the message is the header.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`CollatzStream` 的主体要么是一个字符串，要么是发生了错误。现在，对于流式协议，我们需要提供一个函数的实现，该函数返回流的一半发送者；我们在
    `CollatzStream` 的 `pair` 函数中这样做。接下来，我们为我们的自定义流实现 `Stream` 特性；在这种情况下，`poll` 方法简单地轮询内部
    `Body` 以获取更多数据。在设置好流之后，我们可以实现编解码器。在这里，我们需要维护一种方式来知道我们此刻正在处理帧的哪一部分。这是通过一个名为 `decoding_head`
    的布尔值来完成的，我们需要根据需要翻转它。我们需要为我们的编解码器实现 `Decoder`，这基本上和上次一样；只需注意我们需要跟踪流和非流的情况以及之前定义的布尔值。`Encoder`
    的实现是相反的。我们还需要将协议实现绑定到编解码器；这是通过实现 `ClientProto` 和 `ServerProto` 为 `CollatzProto`
    来完成的。在两种情况下，我们都将布尔值设置为 true，因为接收消息后要读取的第一个东西是头部。
- en: 'The last step in the stack is to implement the services by implementing the
    `Service` trait for `CollatzService`. In that, we read the header and try to parse
    it as a `u64`. If that works fine, we move on to calculating the collatz sequence
    of that `u64` and return the result as a `CollatzInput::Once` in a leaf future.
    In the other case, we iterate over the body and print it on the console. Finally,
    we return a fixed string to the client. Here is what this looks like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈中的最后一步是通过实现 `Service` 特性为 `CollatzService` 实现服务。在那里，我们读取头部并尝试将其解析为 `u64`。如果这做得很好，我们就继续计算该
    `u64` 的 collatz 序列，并以 `CollatzInput::Once` 的形式在 leaf future 中返回结果。在另一种情况下，我们遍历主体并在控制台上打印它。最后，我们向客户端返回一个固定的字符串。这就是它的样子：
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We have also written two conversion helpers from `CollatzMessage` to `CollatzInput`,
    and vice versa, by implementing the `From` trait accordingly. Like everything
    else, we will have to deal with the two cases: when the message has a body and
    when it does not (in other words, the header has arrived but not the rest of the
    message). Here are those:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还编写了两个从`CollatzMessage`到`CollatzInput`以及相反的转换辅助器，通过相应地实现`From`特质。像其他所有内容一样，我们不得不面对两种情况：当消息有主体时，以及当它没有主体时（换句话说，头部已经到达，但消息的其他部分还没有到达）。以下是这些：
- en: '[PRE47]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Having set up the server and the client, we will implement our tests as examples,
    like last time. Here is what they look like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好服务器和客户端之后，我们将像上次一样以示例的形式实现我们的测试。它们看起来是这样的：
- en: '[PRE48]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here is what the client looks like. There is a bit to digest here, compared
    to the server:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端看起来是这样的。与服务器相比，这里有一些内容需要消化：
- en: '[PRE50]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We use the `connect` method defined earlier to set up connection to the server
    on a known address and port. We use the `and_then` combinator to send a fixed
    string to the server, and we print the response. At this point, we have transmitted
    our header and we move on to transmitting the body. This is done by splitting
    the stream in two halves and using the sender to send a number of strings. A final
    combinator prints the response and resolves the future. Everything previously
    is run in an event loop.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用之前定义的`connect`方法在已知地址和端口上设置到服务器的连接。我们使用`and_then`组合器向服务器发送一个固定字符串，并打印响应。此时，我们已经发送了头部，接下来我们将发送主体。这是通过将流分成两半并使用发送者发送多个字符串来完成的。一个最终的组合器打印响应并解决未来。所有之前的内容都在事件循环中运行。
- en: 'This is what a session looks like for the server:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务器会话的样子：
- en: '[PRE51]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And this is how it looks like for the client:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 而客户端看起来是这样的：
- en: '[PRE52]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As expected, the server processed the header before it got the actual body of
    the request (we know that because we sent the body after sending the header).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，服务器在收到请求的实际主体之前处理了头部（我们知道这一点是因为我们在发送头部之后发送了主体）。
- en: Other than what we discussed here, tokio supports a bunch of other features
    as well. For instance, you can implement a protocol handshake by changing the
    `ServerProto` and `ClientProto` implementations to exchange setup messages before
    constructing the `BindTransport` future. This is extremely important, as a lot
    of network protocols need some form of handshaking to set up a shared state to
    work with. Note that it is perfectly possible for a protocol be streaming and
    pipelined, or streaming and multiplexed. For these, an implementation needs to
    substitute traits from the `streaming::pipeline` or `streaming::multiplex` namespace
    respectively.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里讨论的内容之外，tokio还支持许多其他功能。例如，你可以通过更改`ServerProto`和`ClientProto`实现来交换设置消息，在构建`BindTransport`未来之前实现协议握手。这一点非常重要，因为许多网络协议需要某种形式的握手来设置共享状态以协同工作。请注意，一个协议可以是流式和管道化的，或者流式和复用的。对于这些，实现需要分别替换`streaming::pipeline`或`streaming::multiplex`命名空间中的特质。
- en: The larger tokio ecosystem
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更大的tokio生态系统
- en: 'Let us take a look at the current state of the tokio ecosystem. Here are the
    commonly useful crates in the `tokio-rs` GitHub organization, at the time of writing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看tokio生态系统当前的状态。以下是写作时在`tokio-rs` GitHub组织中的常用crate：
- en: '| **Crate** | **Function** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **Crate** | **函数** |'
- en: '| `tokio-minihttp` | Simple HTTP server implementation in tokio; should not
    be used in production. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-minihttp` | 在tokio中的简单HTTP服务器实现；不应在生产中使用。|'
- en: '| `tokio-core` | Future-aware networking implementations; the core event loop.
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-core` | 具有未来感知的网络实现；核心事件循环。|'
- en: '| `tokio-io` | IO primitives for tokio. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-io` | tokio的IO原语。|'
- en: '| `tokio-curl` | A `libcurl`-based HTTP client implementation using tokio.
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-curl` | 使用tokio的基于`libcurl`的HTTP客户端实现。|'
- en: '| `tokio-uds` | Non-blocking unix domain sockets using tokio. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-uds` | 使用tokio的非阻塞Unix域套接字。|'
- en: '| `tokio-tls` | TLS and SSL implementation based on tokio. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-tls` | 基于tokio的TLS和SSL实现。|'
- en: '| `tokio-service` | Provides the `Service` trait that we have used extensively.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-service` | 提供了我们广泛使用的`Service`特质。|'
- en: '| `tokio-proto` | Provides a framework for building network protocols using
    tokio; we have used this one extensively. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-proto` | 提供了一个使用tokio构建网络协议的框架；我们广泛使用了这个。|'
- en: '| `tokio-socks5` | A SOCKS5 server using tokio, not production-ready. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-socks5` | 使用tokio的SOCKS5服务器，尚未准备好用于生产。|'
- en: '| `tokio-middleware` | Collection of middlewares for tokio services; lacks
    essential services at the moment. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-middleware` | 用于 tokio 服务的中间件集合；目前缺少基本服务。|'
- en: '| `tokio-times` | Timer-related functionality based on tokio. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-times` | 基于 tokio 的定时器相关功能。|'
- en: '| `tokio-line` | Sample-line protocol for demonstrating tokio. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-line` | 用于演示 tokio 的样本行协议。|'
- en: '| `tokio-redis` | Proof-of-concept redis client based on tokio; should not
    be used in production. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `tokio-redis` | 基于 tokio 的证明概念 Redis 客户端；不应在生产中使用。|'
- en: '| `service-fn` | Provides a function that implements the Service trait for
    a given closure. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `service-fn` | 为给定的闭包提供实现 Service 特性的函数。|'
- en: Note that a number of these are either not updated in a long time or proof-of-concept
    implementations that should not be used in anything useful. But that is not a
    problem. A large number of independent utilities have adopted tokio since it was
    launched, resulting in a vibrant ecosystem. And, in our opinion, that is the true
    sign of success of any open source project.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其中许多已经很长时间没有更新，或者是一些应该不用于任何有用目的的证明概念实现。但这不是问题。自它推出以来，大量独立的实用工具已经采用了 tokio，从而形成了一个充满活力的生态系统。而且，据我们观察，这是任何开源项目成功的真正标志。
- en: 'Let us look at some commonly used libraries in the preceding list , starting
    with `tokio-curl`. For our example, we will simply download a single file from
    a known location, write it to local disk, and print out the headers we got back
    from the server. Because this is a binary, we will set the project up like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面列表中一些常用的库，首先是 `tokio-curl`。在我们的示例中，我们将简单地从已知位置下载单个文件，将其写入本地磁盘，并打印出我们从服务器获取的头部信息。由于这是一个二进制文件，我们将按照以下方式设置项目：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is what the Cargo setup looks like:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Cargo 设置的示例：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As the `tokio-curl` library is a wrapper around the Rust `curl` library, we
    will need to include that as well. Here is the main file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `tokio-curl` 库是 Rust `curl` 库的包装器，因此我们还需要包含它。以下是主文件：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We will use the `Easy` API from `curl` crate. We start with creating our event
    loop and HTTP session. We then create a handle that `libcurl` will use to process
    our request. We call the `get` method with a bool to indicate that we are interested
    in doing an HTTP GET. We then pass the URL to the handle. Next, we set two callbacks
    passed as closures. The first one is called the `header_function`; this one shows
    each of the client-side headers. The second one is called the `write_function`,
    which writes the data we got to our file. Finally, we create a request by calling
    the `perform` function for our session. Lastly, we run the request in our event
    loop and print out the status code we got back.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自 `curl` crate 的 `Easy` API。我们首先创建我们的事件循环和 HTTP 会话。然后创建一个 `libcurl` 将用于处理我们请求的句柄。我们使用布尔值调用
    `get` 方法来表示我们感兴趣进行 HTTP GET 操作。然后我们将 URL 传递给句柄。接下来，我们设置两个作为闭包传递的回调函数。第一个被称为 `header_function`；这个函数显示客户端的每个头部信息。第二个被称为
    `write_function`，它将我们获取的数据写入我们的文件。最后，我们通过调用会话的 `perform` 函数创建一个请求。最后，我们在事件循环中运行请求并打印出我们得到的状态码。
- en: 'Running this does the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此操作将执行以下操作：
- en: '[PRE56]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will also produce a file called `foo.zip` in the current directory. You
    can use a regular file to download the file and compare the SHA sums of both files,
    to verify that they are indeed the same.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录中生成一个名为 `foo.zip` 的文件。您可以使用常规文件下载该文件，并比较两个文件的 SHA 哈希值，以验证它们确实相同。
- en: Conclusion
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter was an introduction to one of the most exciting components of the
    larger Rust ecosystem. Futures and the Tokio ecosystem provide powerful primitives
    that can be widely used in applications, including networking software. In itself,
    Futures can be used to model any computation that is otherwise slow and/or depends
    on an external resource. Coupled with tokio, it can be used to model complex protocol
    behaviors that are pipelined, or multiplexed, and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是 Rust 更大生态系统中最激动人心的组件之一的一个介绍。Futures 和 Tokio 生态系统提供了强大的原语，这些原语可以广泛应用于应用程序中，包括网络软件。本身，Futures
    可以用来模拟任何其他情况下缓慢的或依赖于外部资源的计算。与 tokio 结合使用，它可以用来模拟复杂的流水线或复用等协议行为。
- en: Some major drawbacks of using these center around lack of proper documentation
    and examples. Also, error messages from these applications are often heavily templated
    and, hence, verbose. Because the Rust compiler itself does not know of the abstractions
    as such, it often complains about type mismatches, and it is up to the user to
    reason through deeply nested types. Somewhere down the line, it may make sense
    to implement a compiler plugin for futures that can translate these errors in
    more intuitive forms.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具的主要缺点集中在缺乏适当的文档和示例。此外，这些应用程序的错误信息通常非常模板化，因此往往冗长。因为Rust编译器本身并不了解这些抽象，它经常会抱怨类型不匹配，用户必须深入推理嵌套的类型。在某个阶段，实现一个能够将这些错误转换为更直观形式的编译器插件可能是有意义的。
- en: In the following chapter, we will look at implementing common security-related
    primitives in Rust.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在Rust中实现常见的与安全相关的原语。
