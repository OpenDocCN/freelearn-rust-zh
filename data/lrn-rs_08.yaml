- en: The Rust Application Lifetime
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust应用程序的寿命
- en: Rust, as we have seen, is a very stable language. It is also what can be described
    as a memory-safe language in that, when the code is compiling, the compiler tests
    the code to ensure that things don't go wrong, such as accessing outside of an
    array or freeing memory twice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Rust是一种非常稳定的语言。它也可以被描述为一种内存安全的语言，因为在代码编译时，编译器会测试代码以确保不会出错，例如访问数组外部或释放内存两次。
- en: This is purely down to Rust obeying three key rules—ownership, references (or
    borrowing, as it's more commonly known), and the application lifetime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全归功于Rust遵守三个关键规则——所有权、引用（或借用，更常见的是借用）和应用寿命。
- en: 'In this chapter, we will discuss and see how the three key facets work to ensure
    that your Rust application always behaves itself. They are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论并看到这三个关键方面是如何协同工作以确保你的Rust应用程序始终表现良好的。它们如下：
- en: Ownership
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有权
- en: Borrowing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借用
- en: Lifetime
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寿命
- en: What are they?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们是什么？
- en: In a nutshell, we can think of the three facets in these terms.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们可以用这些术语来考虑这三个方面。
- en: Ownership
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权
- en: When we think of ownership, we inevitably think of possession. I have a MacBook
    Pro, which I'm writing this text on currently. It is not part of any finance agreement,
    stolen, borrowed, or on a lease, therefore the ownership of it is mine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到所有权时，不可避免地会想到占有。我现在正在用我的MacBook Pro写这篇文本。它不属于任何财务协议，也没有被盗、借用或租赁，因此它的所有权是我的。
- en: Borrowing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用
- en: Should I sell or dispose of my computer, I will release the ownership to the
    next party, or to the recycling facilities. If my son has a DVD that I want to
    use, I will borrow it from him—he has not released ownership to me, just given
    it to me for a finite period. He will keep a record, or a reference, that I have
    it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我出售或丢弃我的电脑，我将把所有权释放给下一方，或者给回收设施。如果我的儿子有一张我想用的DVD，我会从他那里借来——他没有把所有权释放给我，只是把它借给我一段有限的时间。他会保留记录或引用，表明我有它。
- en: Lifetime
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寿命
- en: This is how long something lasts and, unfortunately, virtually nothing lasts
    forever. Once the application or ownership ends, the time from taking ownership
    to removing ownership, which includes the borrowing of something, is considered
    the lifetime of that object or process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指某物持续的时间，不幸的是，几乎没有什么东西能永远持续。一旦应用或所有权结束，从获得所有权到移除所有权的时间，包括借用的东西，都被认为是该物体或过程的寿命。
- en: Let's consider each of these facets in more detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地考虑这些方面。
- en: Ownership in Rust
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust中的所有权
- en: In order to appreciate ownership, we will need to take a small detour into compilation
    abstractions and a very common pitfall.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了欣赏所有权，我们需要稍微偏离一下编译抽象和一个非常常见的陷阱。
- en: Abstractions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: One aspect of any Rust application that holds it above other applications from
    other languages is that they are really fast and memory-safe. This is down to
    an ideal called a **zero-cost abstraction**. An abstraction is a way of hoisting
    a low-level construct higher, making it easier, safer, and more reliable. These
    are commonly seen in cross-platform libraries where a user interface has a common
    abstraction layer, so developers only need to say `var n = new Label {Text = "Hello"};`
    to create a label for the UI without needing to know what is going on under the
    hood.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Rust应用程序优于其他语言应用程序的一个方面是它们真的很快且内存安全。这归功于一个称为**零成本抽象**的理想。抽象是将低级构造提升到更高层次的一种方式，使其更容易、更安全、更可靠。这些在跨平台库中很常见，其中用户界面有一个共同的抽象层，因此开发者只需说`var
    n = new Label {Text = "Hello"};`来创建一个用于UI的标签，而不需要了解底层发生了什么。
- en: It is usual that abstractions cause some sort of penalties, meaning that code
    that uses abstractions would run slower or use more memory than corresponding
    lower-level code. In terms of Rust, these zero-cost abstractions mean that, in
    terms of computer resources, they cause no penalties. This is normally performed
    during compilation; the compiler generates the abstractions and executes them.
    Once done, the compiler will generate the best possible code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，抽象会导致某种形式的惩罚，这意味着使用抽象的代码会比相应的低级代码运行得更慢或使用更多的内存。在Rust的情况下，这些零成本抽象意味着在计算机资源方面，它们不会造成任何惩罚。这通常在编译期间完成；编译器生成抽象并执行它们。一旦完成，编译器将生成最佳可能的代码。
- en: This does have a problem—the compiler will object to code that the developer
    considers completely fine. This is because, as people, we don't think the same
    way as a language does, so what we consider as correct ownership is not how Rust
    considers it. Thankfully, as time goes on, and you use Rust more, this problem
    becomes far less of one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实有一个问题——编译器会反对开发者认为完全没问题的一段代码。这是因为，作为人类，我们的思维方式与语言不同，所以我们认为正确的拥有权并不是Rust所认为的。幸运的是，随着时间的推移，你使用Rust越多，这个问题就会变得越小。
- en: Ownership – from the beginning
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有权的起源
- en: 'Let''s start by considering a very simple piece of code to help you understand
    how this works. We have seen the likes of the following plenty of times up to
    this point:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑一个非常简单的代码片段，以帮助你理解它是如何工作的。我们之前已经多次看到过类似的情况：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When `my_function` is called (it comes into scope), Rust will allocate memory
    on the stack to store this value. When the function ends (it goes out of scope),
    Rust will do an automatic cleanup to deallocate any memory used by `mypi`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当`my_function`被调用（进入作用域）时，Rust会在栈上分配内存来存储这个值。当函数结束时（超出作用域），Rust会自动清理以释放`mypi`使用的任何内存。
- en: 'A vector, or anything else that uses the heap, works in a similar way:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，或者任何使用堆的其他东西，以类似的方式工作：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you recall from [Chapter 5](part0106.html#352RK0-a5175cb437d742a9aed0ea574000ee2d),
    *Remember, Remember*, the vector requires memory both on the heap and on the stack
    and can be thought of like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第五章](part0106.html#352RK0-a5175cb437d742a9aed0ea574000ee2d)中的“记住，记住”，向量需要在堆和栈上都有内存，可以这么理解：
- en: '| Function name | Address | Variable name | Value |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 函数名 | 地址 | 变量名 | 值 |'
- en: '| `heap` | `heap_posn - 1` |  | `base_of_vecs` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `heap` | `heap_posn - 1` |  | `base_of_vecs` |'
- en: '|  | `heap_posn - 2` |  | `Vec[1]` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  | `heap_posn - 2` |  | `Vec[1]` |'
- en: '| `my_second_function` | `0` | `myvec` | `heap_posn - 1` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `my_second_function` | `0` | `myvec` | `heap_posn - 1` |'
- en: This time, when `my_second_function` goes out of scope, not only is the position
    on the stack cleared, but also the contiguous locations pointed to by `myvec`
    on the heap.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当`my_second_function`超出作用域时，不仅栈上的位置被清除，而且由`myvec`指向的堆上的连续位置也会被清除。
- en: I've given two examples of variables here for a good reason—the handling is
    different; a vector takes a generic parameter and these are handled differently
    to a standard variable type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里给出了两个变量的例子，这是有原因的——处理方式不同；向量接受一个泛型参数，这些处理方式与标准变量类型不同。
- en: It's not quite as simple as this though, and to really understand how things
    work with ownership, we will really need to consider things on a basic level.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然事情并不像这样简单，但要真正理解拥有权下事物是如何运作的，我们确实需要从基本层面来考虑问题。
- en: Variable binding
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量绑定
- en: 'Let''s consider the creation of a variable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑变量的创建：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have created a non-mutable variable with the name `myvar`. We will then
    say that this variable has the value `10` as a 32-bit integer. In other words,
    if this was in C, it would be as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`myvar`的非可变变量。然后我们说这个变量有一个值为`10`的32位整数。换句话说，如果这是在C语言中，它将是以下这样：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What we have actually done here is create a binding between the variable name
    and the value. We say that `10i32` is bound to `myvar`. Bindings are very important
    when it comes to ownership. Rust has a rule that you can only have something bound
    to something else once.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实际上创建了一个变量名和值的绑定。我们说`10i32`绑定到`myvar`。绑定在拥有权方面非常重要。Rust有一条规则，即你只能将某个东西绑定到另一个东西一次。
- en: 'Let''s consider the following snippet as it demonstrates why things go wrong
    when at the zero-cost abstraction level:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码片段，因为它展示了在零成本抽象级别时为什么会出现问题：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Normally, as a developer, you'd look at this and say that `myvec` is bound to
    a vector of type `i32`, which contains three elements. You'd then assume that
    `myothervec` is just a copy of the first vector as in the likes of C, C++, and
    C#; that is what it means. The implementation will vary, but the meaning is the
    same.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，作为一个开发者，你会看到`myvec`绑定到一个包含三个元素的`i32`类型的向量，然后你会假设`myothervec`只是第一个向量的一个副本，就像在C、C++和C#中一样；这就是它的意思。实现方式可能不同，但含义是相同的。
- en: The problem is that, in Rust, what it means is that I have first created `myvec`.
    When I then say that `myothervec = myvec`, I am actually telling the compiler
    that the ownership of what `myvec` was bound to has now been given to `myothervec`
    and therefore `myvec` is out of scope and if (as a developer) I try to do anything
    with `myvec`, then the compiler is to fail the build.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，在 Rust 中，这意味着我首先创建了 `myvec`。当我然后说 `myothervec = myvec` 时，我实际上是在告诉编译器，`myvec`
    绑定的所有权现在已经转移给了 `myothervec`，因此 `myvec` 已经超出作用域，如果（作为一个开发者）我尝试对 `myvec` 做任何事情，那么编译器将失败构建。
- en: 'The following screenshot demonstrates this (it can be found in `Chapter 8/outofscope`).
    When you attempt to build it, you will get the following results:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了这一点（可以在 `Chapter 8/outofscope` 中找到）。当你尝试构建它时，你会得到以下结果：
- en: '![](img/00054.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: We will get a similar sort of issue when a function takes ownership.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受所有权时，我们将会遇到类似的问题。
- en: 'The following can be found in `08/function_outofscope`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容可以在 `08/function_outofscope` 中找到：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On the first look through, we don''t see the obvious transfer of ownership
    and, usually, when you pass a variable to a function, you don''t really consider
    that as a transfer. In Rust, passing a variable directly to another function is
    the same as in our first example: the ownership is released from `myvec` and passed
    to the function.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一眼看来，我们没有看到所有权的明显转移，通常，当你将一个变量传递给一个函数时，你并不真正将其视为一个转移。在 Rust 中，直接将变量传递给另一个函数与我们的第一个例子相同：所有权从
    `myvec` 释放并传递给函数。
- en: 'To prove this, try to compile the code and you will end up with the following
    output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，尝试编译代码，你将得到以下输出：
- en: '![](img/00055.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: In other words, it's the same error as earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这与之前相同的错误。
- en: Stack and heap variables
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈和堆变量
- en: To understand why we get this problem, we will need to understand in depth how
    Rust works, and by this I mean at memory level.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们为什么会遇到这个问题，我们需要深入理解 Rust 的工作方式，也就是说，在内存级别。
- en: 'Let''s start with our variable:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的变量开始：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As I've said, in our minds, we will create a `myvar` variable of type `i32`
    and bind it to the value `32`. Rust, on the other hand, does it differently.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，在我们的心中，我们将创建一个 `myvar` 变量，类型为 `i32`，并将其绑定到值 `32`。另一方面，Rust 的做法不同。
- en: Firstly, it identifies that we will need space on the stack for a value that
    is the size of `i32`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它确定我们需要在栈上为大小为 `i32` 的值腾出空间。
- en: Next, it copies the value for `32` into that space allocated on the stack.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将 `32` 的值复制到栈上分配的空间。
- en: Lastly, it binds the binding to the position of the stack allocated block to
    the variable name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将绑定绑定到栈分配块的地址与变量名绑定。
- en: In other words, the complete opposite to how we do it in our minds.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这与我们在心中所做的是完全相反的。
- en: 'Let''s see what happens when we create another binding, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们创建另一个绑定时会发生什么，就像这样：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The compiler moves the binding to where the data sits on the stack for `myvar`
    and then says that that position (and data) belongs to `myvartwo`. The binding
    will be transferred. What happens to `myvar` though? Rust won't allow things to
    *dangle* or allow information to be bound to two different objects. Once the binding
    is transferred, `myvar` is removed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将绑定移动到 `myvar` 在栈上的数据位置，然后说那个位置（和数据）属于 `myvartwo`。绑定将被转移。那么 `myvar` 会发生什么？Rust
    不允许事物 *悬空* 或允许信息绑定到两个不同的对象。一旦绑定被转移，`myvar` 就会被移除。
- en: The same thing happens if the binding points to something in the heap. Therefore,
    when we consider `let myvec = vec![1i32, 2i32, 3i32];`, `let myvec = vec![1i32,
    2i32, 3i32];` we know how this will work. The compiler knows that it requires
    space on the heap, enough to hold three elements of type `i32`. These values are
    copied into the locations and the base address of the contiguous chunk of memory
    is bound to `myvec`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果绑定指向堆中的某个东西，也会发生相同的事情。因此，当我们考虑 `let myvec = vec![1i32, 2i32, 3i32];` 时，我们知道这将如何工作。编译器知道它需要在堆上分配足够的空间，以容纳三个
    `i32` 类型的元素。这些值被复制到位置，连续内存块的基础地址被绑定到 `myvec`。
- en: 'Now, let''s transfer ownership:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转移所有权：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, `vectwo` is the only usable binding to the vector on the heap, and `myvec`
    gets invalidated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`vectwo` 是堆上向量的唯一可用的绑定，而 `myvec` 被无效化。
- en: Why is this important?
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这为什么很重要？
- en: 'A very common error in the likes of C# is when you have the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 等语言中，一个非常常见的错误是当你有以下代码时：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output we will get from this may not be as you would expect, which is as
    follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可能得不到预期的结果，如下所示：
- en: '![](img/00056.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00056.jpeg)'
- en: It may be expected that, as we have removed the duplicate from `dupVar`, the
    `myList` variable should still have all of the numbers it was set to originally.
    In this code, what is happening is that `dupVar` is known as a copy pointer—we
    have two variables bound to the same pointer on the stack. While it may not seem
    that big a deal, we have two variable names that are able to change data. This
    catches a lot of people out and leads to more memory and content bugs than it
    is worth.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会预期，当我们从 `dupVar` 中移除了重复项后，`myList` 变量仍然应该包含它最初设置的所有数字。在这段代码中，发生的情况是 `dupVar`
    被称为复制指针——我们有两个变量绑定到栈上的同一个指针。虽然这看起来可能不是什么大问题，但我们有两个变量名能够改变数据。这会让很多人感到困惑，并导致比它值得的更多内存和内容错误。
- en: As Rust only allows one pointer per block, we cannot have the likes of this.
    Once ownership is transferred, the original bound name can no longer be accessed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Rust 只允许每个块有一个指针，我们不能有类似这种情况。一旦所有权被转移，原始的绑定名称就不再可以访问。
- en: The Copy trait
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Copy 特性
- en: The code for this section can be found in `08/copyint` and `08/copyf32`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码可以在 `08/copyint` 和 `08/copyf32` 文件夹中找到。
- en: 'Rust does have a way to create a copy of the original: the `Copy` trait (traits
    are covered in [Chapter 10](part0238.html#72V5S0-a5175cb437d742a9aed0ea574000ee2d),
    *Creating your own Crate*) and all primitives implement `Copy`. If we have something
    along the lines of `let varone = 1i32;` or `let vartwo = varone;`, then `i32`
    is a primitive type and the `vartwo` variable will contain a copy of `varone`.
    Both will have their own allocations on the stack, rather than `vartwo` pointing
    to `varone`. Ownership will not be changed; the value is duplicated and bound
    to the new variable.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 确实有一种创建原始数据副本的方法：`Copy` 特性（特性将在第 10 章[创建自己的包](part0238.html#72V5S0-a5175cb437d742a9aed0ea574000ee2d)中介绍），所有原始类型都实现了
    `Copy`。如果我们有类似 `let varone = 1i32;` 或 `let vartwo = varone;` 这样的代码，那么 `i32` 是一个原始类型，`vartwo`
    变量将包含 `varone` 的副本。两者都将有自己的栈分配，而不是 `vartwo` 指向 `varone`。所有权不会改变；值被复制并绑定到新变量。
- en: The code for this section can be found in the `08/copyint` and `08/copyf32` folders
    in the supporting code bundle provided for this book.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码可以在本书提供的配套代码包中的 `08/copyint` 和 `08/copyf32` 文件夹中找到。
- en: 'Therefore, we can write the code as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样编写代码：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will give the following output when compiled (`numone` is
    an `i32` value, which is a primitive, so it makes a copy of itself when passed
    to `do_something` with an `i32` being returned into `numtwo`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译上述代码时（`numone` 是一个 `i32` 值，它是一个原始类型，所以在传递给 `do_something` 并返回 `i32` 到 `numtwo`
    时会复制自身）将产生以下输出：
- en: '![](img/00057.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00057.jpeg)'
- en: The `copyf32` example shows the same `Copy` trait in action but for an `f32`
    primitive.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyf32` 示例展示了相同的 `Copy` 特性在 `f32` 原始类型上的应用。'
- en: There must be a way around this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 必须有一种方法可以绕过这个问题。
- en: 'In a way, we''ve seen an answer already in many examples used throughout this
    book—we hand the ownership back; however, as the following code block shows, it
    can get a bit messy:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，我们已经在本书中的许多例子中看到了答案——我们归还了所有权；然而，正如以下代码块所示，这可能会变得有些混乱：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code will give the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将产生以下输出：
- en: '![](img/00058.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00058.jpeg)'
- en: The code for this section can be found in the `Chapter8/handback` folder in
    the supporting code bundle provided for this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码可以在本书提供的配套代码包中的 `Chapter8/handback` 文件夹中找到。
- en: Thankfully, Rust does provide a neater way to pass ownership around. Instead
    of giving ownership, we can borrow ownership.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Rust 提供了一种更整洁的方式来传递所有权。我们不是给予所有权，而是借用所有权。
- en: Borrowing in Rust
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 中的借用
- en: Way back in Chapter 2, *Variables*, we referred to something known as a reference
    and it was said to be a copy of the pointer to some memory location. This is a
    big part of what is meant by borrowing in Rust.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章 *变量* 中，我们提到了一个称为引用的东西，它被描述为对某个内存位置的指针的副本。这是 Rust 中借用的一部分含义。
- en: 'In our preceding example, we can make use of borrowing. Our code for it is
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的例子中，我们可以利用借用。我们为其编写的代码如下：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code for this section can be found in the `08/handback` folder which can
    be found in the supporting code bundle of this book.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码可以在本书配套代码包中的 `08/handback` 文件夹中找到。
- en: 'We will no longer pass ownership, but rather we will pass the reference to
    the vector. When compiled, we will get the following result:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再传递所有权，而是将向量的引用传递过去。当编译时，我们将得到以下结果：
- en: '![](img/00059.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00059.jpeg)'
- en: Borrow immutability
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用不可变性
- en: If we look back to the start of this chapter, I described borrowing as borrowing
    a DVD from my son. When I take possession of the DVD, I cannot change it, as my
    son would expect the same DVD back.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾本章的开头，我描述了借用就像是从我儿子那里借DVD。当我拿到DVD时，我不能改变它，因为我的儿子期望得到同样的DVD。
- en: 'The same applies for Rust: the references cannot be changed as they are immutable
    values. If you think about it, this makes sense. Let me explain.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Rust来说，引用不能改变，因为它们是不可变值。如果你这么想，这很有意义。让我解释一下。
- en: I have created a `Vec<T>` array type, which is, let's say, eight values long
    (it doesn't matter what the values are or the type they are). When the binding
    between the heap and stack is made, it will be of a particular type. If we allow
    the reference to alter the vector, we will have the same problem as the C# example
    and so the guarantees can't be assured and the Rust compiler will fail the build.
    To ensure that the guarantee is kept, Rust simply says that you are unable to
    change the values borrowed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个 `Vec<T>` 数组类型，比如说，有八个值长（值是什么或者它们的类型无关紧要）。当堆和栈之间的绑定建立时，它将具有特定的类型。如果我们允许引用改变向量，我们就会遇到C#示例中的同样问题，因此不能保证保证，Rust编译器将失败构建。为了确保保证得到保持，Rust简单地说你不能改变所借用的值。
- en: Mutable borrows
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变借用
- en: This is more a writable DVD than a prerecorded one if we use the analogy of
    borrowing a DVD.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用借DVD的比喻来说，这更像是一个可写的DVD而不是预先录制的DVD。
- en: Here, we are using a mutable reference, and we have to be careful how we use
    these.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了一个可变引用，我们必须小心如何使用它们。
- en: The code for this section is in the `08/mutableref1` and `08/mutableref2` folders
    in the supporting code bundle provided for this book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码位于本书提供的配套代码包中的 `08/mutableref1` 和 `08/mutableref2` 文件夹中。
- en: 'In our first example `(mutableref1`), we will create a variable, the reference,
    do something, and get a new value out:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子 `(mutableref1)` 中，我们将创建一个变量，引用，做些事情，然后得到一个新的值：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The important line here is `*y += 1`; and, in particular, the `*`, as this means
    we're directly altering the value of the memory position that the reference points
    to. When dealing with anything to do with memory, absolute care has to be observed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的行是 `*y += 1`; 并且特别地，这里的 `*`，因为它意味着我们正在直接改变引用指向的内存位置上的值。在处理与内存相关的事情时，必须非常小心。
- en: 'The second important point to observe is that we have a set of braces around
    the code used in the mutable reference. Remove them and everything fails (`mutableref2`):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的重要点是，我们在可变引用中使用了括号。去掉它们，一切都会失败（`mutableref2`）：
- en: '![](img/00060.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00060.jpeg)'
- en: The important line is the result of the error; it is saying that you cannot
    borrow the same item as both mutable and immutable at the same time. It's like
    saying you can borrow something that can and can't be changed at the same time!
    Utter nonsense. This is down to borrowing having rules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的行是错误的输出；它表示你不能同时以可变和不可变的方式借用相同的项。这就像说你可以同时借用可以改变和不能改变的东西！简直是胡说八道。这是借用有规则的结果。
- en: The Rust borrowing rules
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust的借用规则
- en: 'There are two rules that must be observed with borrowing, which are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在借用时必须遵守两条规则，如下所示：
- en: What you borrow must not outlive the original
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你所借用的东西不能比原始的存活时间更长
- en: 'You can have one of the following types of borrow, but never at the same time:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以有下面以下几种借用类型，但绝不能同时进行：
- en: One (or more) references of type `&T` to a resource
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个（或多个）类型为 `&T` 的引用到资源
- en: Only one mutable reference
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个可变引用
- en: 'The first rule makes sense: you can''t have the reference outlive where it
    came from as once where it comes from goes out of scope, it is destroyed and,
    once destroyed, what are you borrowing exactly?'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则是有意义的：你不能让引用比它来的地方存活时间更长，因为一旦它来的地方出了作用域，它就会被销毁，一旦销毁，你到底借了什么？
- en: The second one requires a bit more thought about why it is as it should be and
    what it is that Rust is trying to achieve.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条需要更多思考为什么它是这样的，以及Rust试图实现什么。
- en: In this case, Rust is ensuring that something known as a **race condition**
    occurs (if you are used to writing multithreaded applications, you'll already
    understand these).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Rust确保发生了一个称为**竞争条件**的情况（如果你习惯于编写多线程应用程序，你将已经理解这些）。
- en: Here, Rust is trying to prevent two references trying to access the same point
    of memory at the same time. In other words, Rust is trying to prevent a synchronization
    error.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Rust试图防止两个引用同时尝试访问同一内存点。换句话说，Rust试图防止同步错误。
- en: With non-mutable references, you can have as many as you'd like, as the references
    can never be written to. With a mutable reference, Rust prevents the problem by
    allowing just a single reference to be valid.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不可变引用，你可以有任意多个，因为引用永远不能被写入。对于可变引用，Rust通过只允许一个引用有效来防止问题。
- en: With this in mind, can we use these rules to fix our code from `mutableref2`
    in order to do away with the `{}` braces around the mutable reference?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以使用这些规则来修复`mutableref2`中的代码，以去掉可变引用周围的`{}`花括号吗？
- en: Fixing the problem
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决问题
- en: 'Let''s examine the code again (I''ve removed anything from the original that
    is not required here):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次检查这段代码（我已经删除了这里不需要的原始内容）：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we try and compile, we get the following output returned from the compiler:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试编译时，编译器会返回以下输出：
- en: '![](img/00061.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: We have broken the second rule—you can only have a single mutable or many immutables,
    never both.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打破了第二个规则——你只能有一个可变引用或多个不可变引用，永远不能两者都有。
- en: 'How can we solve this? Let''s look back to the original `mutableref1`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何解决这个问题？让我们回顾一下原始的`mutableref1`：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This works, but why?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这行得通，但为什么？
- en: Think about the scope
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑作用域
- en: What is actually happening with this code is that we created a new scope for
    the borrowing section of the code, which passes back in to `mutvar` before the
    final `println!` is reached. In other words, the scope changes; therefore, when
    `mutvar` is hit on the `println!`, no borrowing is occurring and we're just displaying
    whatever is bound to the `mutvar` variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上发生了什么，是我们为代码的借用部分创建了一个新的作用域，在到达最终的`println!`之前，将其传递回`mutvar`。换句话说，作用域发生了变化；因此，当在`println!`中遇到`mutvar`时，没有发生借用，我们只是显示绑定到`mutvar`变量的内容。
- en: If we want to remove the braces, we will have to ensure that the borrowing has
    finished before we output through `println!`
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要移除花括号，我们必须确保在通过`println!`输出之前，借用已经完成
- en: It's all for your own good
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这一切都是为了你自己的好处
- en: 'These compiler rules are there to help you as a developer. They prevent the
    sorts of issues commonly found in other languages, the biggest being writing to
    a variable after it is destroyed or doing something stupid, such as trying to
    mutate a vector inside of a loop iterating through that vector:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编译器规则是为了帮助开发者。它们防止了在其他语言中常见的问题，最大的问题是变量被销毁后写入，或者做一些愚蠢的事情，比如尝试在遍历向量的循环中修改向量：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The source for this section is in the `08/invaliditerator` folder in the supporting
    code bundle for this book, with additional discussion in Chapter 5, *Memory Management*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的内容在本书的支持代码包的`08/invaliditerator`文件夹中，第5章，*内存管理*中有进一步的讨论。
- en: 'This is obviously never going to work. If you think about it, we have a loop
    that takes `myvec` as the argument and then, within the loop, we will add to the
    vector, so the loop never knows about one of the guarantees, as that guarantee
    is not there: the iterator count. It won''t build as well because we are breaking
    the second borrowing rule.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然永远不会工作。如果你想想，我们有一个循环，它以`myvec`作为参数，然后在循环中向向量中添加内容，所以循环永远不知道一个保证，因为那个保证不存在：迭代器计数。它不会很好地构建，因为我们打破了第二个借用规则。
- en: The lifetime
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'Let''s consider another piece of code which won''t work:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一段不会工作的代码：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When trying to build this piece of code, the compiler will complain as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试构建这段代码时，编译器会如下抱怨：
- en: '![](img/00062.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.jpeg)'
- en: 'You may recall that we had something similar to the following piece of code
    back in Chapter 4, *Conditions, Recursion, and Loops*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，我们在第4章，*条件、递归和循环*中看到了类似的代码片段：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In Chapter 5, *Memory Management*, we then explained why the preceding code
    would not work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章，*内存管理*中，我们解释了为什么前面的代码不会工作。
- en: We are assigning `y` to the value of a variable that only exists in a small
    scope and then trying to access that value, which is giving rise to undefined
    behavior. As we've seen, the Rust compiler will do everything it can to prevent
    this sort of error. In this case, the compiler keeps track of each and every reference
    and fails to build if a reference lasts longer than the pointer in use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将 `y` 赋值给一个仅在小型作用域中存在的变量的值，然后尝试访问该值，这导致了未定义的行为。正如我们所见，Rust 编译器会尽一切可能防止这种错误。在这种情况下，编译器会跟踪每一个引用，如果引用的持续时间超过了正在使用的指针，则无法构建。
- en: 'We have the same happening here: `varname` is declared before `x`; therefore,
    it lives longer than `x`, which is what gives rise to the error.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到了相同的情况：`varname` 在 `x` 之前声明；因此，它的生命周期比 `x` 更长，这就是导致错误的原因。
- en: The preceding code is a simple demonstration of a lifetime, but it's not as
    simple as that.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个生命周期的简单演示，但它并不像那样简单。
- en: The mythical bank account
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神话般的银行账户
- en: 'To demonstrate a more complex problem with lifetimes, let''s consider a mythical
    bank account:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个更复杂的问题，让我们考虑一个神话般的银行账户：
- en: I am given access to a bank account, legally, of course
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我被合法地赋予了访问银行账户的权限
- en: I decide that I want my friend to have access to it
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我决定让我的朋友能够访问它
- en: After a certain amount of time, I decide I no longer want access to the account
    and have my access removed
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一段时间之后，我决定我不再想访问这个账户，并移除了我的访问权限
- en: My friend then tries to use the account
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我的朋友尝试使用这个账户
- en: When my friend comes to use the account, he is unable to do so, as the reference
    I had, and which was passed to him, no longer exists. He is trying to *use after
    free* (in programming terms) and he is known here as a **dangling reference**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我的朋友来使用这个账户时，他无法这样做，因为我所拥有的，并且传递给他的引用不再存在。他正在尝试 *use after free*（在编程术语中），在这里他被称为
    **悬垂引用**。
- en: It sounds far-fetched, but in development terms, it happens far more frequently
    than you would possibly give credit for.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来有些牵强，但在开发术语中，它发生的频率比你可能给予的信用要高得多。
- en: The lifetime variable - '
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期变量 - '
- en: 'We have two types of lifetime within Rust—implicit and explicit. We have seen
    the implicit functions plenty of times:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中有两种生命周期类型——隐式和显式。我们已经多次看到了隐式函数：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The lifetime of the function is the length of time the code inside of the braces
    exists once it is called.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的生命周期是代码在括号内存在的时间长度，一旦被调用。
- en: 'We also have an explicit lifetime, denoted by `''` before the name:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个显式生命周期，用 `'` 符号在名称之前表示：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, what exactly does the `'a` mean?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`'a` 究竟意味着什么？
- en: It means, for the lifetime of `a`. The `<>` after `expfunction` means that the
    function is taking a generic parameter (these will all become clear in Chapter
    9, *Generics and Traits*), but it means of a type. If you consider `Vec`, it is
    actually `Vec<T>`. When we create a vector of type `f32`, `T` becomes `f32`, so
    it's `Vec<f32>` when it comes to compile time. In the case of `expfunction`, `T`
    is `'a`, and therefore the type inside the `()` has to also be `'a`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，对于 `a` 的生命周期。`expfunction` 后的 `<>` 表示该函数正在接受一个泛型参数（这些将在第 9 章 *泛型和特质* 中变得清晰），但它意味着一个类型。如果你考虑
    `Vec`，它实际上是 `Vec<T>`。当我们创建一个 `f32` 类型的向量时，`T` 变成了 `f32`，因此在编译时它是 `Vec<f32>`。在
    `expfunction` 的情况下，`T` 是 `'a`，因此括号内的类型也必须是 `'a`。
- en: 'If we had another parameter within the `<>`, we would have `<''a, ''b>(f: &''a
    f32, g: &''b i32)`, and so on.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们在 `<>` 中有另一个参数，我们会有 `<''a, ''b>(f: &''a f32, g: &''b i32)`，依此类推。'
- en: Lifetime of other types
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型的生命周期
- en: We will commonly see lifetimes expressed with the likes of `struct` and `impl`
    (`impl` and the `impl` lifetime are dealt with in Chapter 10, *Matching and Structures*).
    You can have multiple lifetimes used as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会看到使用 `struct` 和 `impl` 等方式表达生命周期（`impl` 和 `impl` 生命周期在第 10 章 *匹配和结构体* 中处理）。你还可以使用多个生命周期。
- en: Lifetime within an struct
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体中的生命周期
- en: 'As seen in Chapter 7, *Structs*, within Rust have a special purpose and they
    can also take multiple types within them and can be extended as much as required
    with as many parameters as required. Let''s consider the following piece of code
    as an example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 7 章 *结构体* 所见，Rust 中的结构体有特殊用途，它们也可以包含多个类型，并且可以根据需要扩展，使用所需的参数数量。以下代码片段作为例子：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code creates a `struct` called `MyStruct` with three properties
    called `a`, `b`, and `c`. When an instance of `mystruct` is called into scope,
    the elements within `struct` can be readily accessed. If we want `struct` to be
    able to take a lifetime variable, we will have to both explicitly ask `struct`
    to take that lifetime variable and then allocate it to an element, as shown in
    the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个名为`MyStruct`的`struct`，具有三个属性，分别称为`a`、`b`和`c`。当`mystruct`的实例进入作用域时，`struct`内的元素可以轻松访问。如果我们想让`struct`能够接受一个生命周期变量，我们必须明确要求`struct`接受该生命周期变量，并将其分配给一个元素，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the lifetime variable in there, we can be assured that the structure cannot
    outlive the `f32` reference it was passed to.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中包含生命周期变量，我们可以确保结构体不会超出它传递给`f32`引用的生命周期。
- en: Multiple lifetimes
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个生命周期
- en: 'Both of these are acceptable to define multiple lifetimes within a function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都可以在函数内定义多个生命周期：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have two parameters of the lifetime of `'a` cast as an `i32` value and return
    an `i32` value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个生命周期参数的参数被`i32`值转换，并返回一个`i32`值。
- en: 'We can also have multiple lifetimes passed in, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传入多个生命周期，如下所示：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Always consider the scope
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总是考虑作用域
- en: As with borrowing, we have to consider the scope to ensure that things work
    correctly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与借用一样，我们必须考虑作用域以确保事情能够正确工作。
- en: 'The following piece of code, for example, won''t work:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段将无法工作：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code for this section is in the `08/lifetimescope` folder of the supporting
    code bundle provided along with this book.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码位于随本书提供的支持代码包中的`08/lifetimescope`文件夹中。
- en: It may not seem obvious at first why this should not work. In terms of scope,
    `f` is created after `y`, so is in the scope of `y` and `y` is created within
    the scope of `x`. Or is it?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能不明显为什么这不应该工作。从作用域的角度来看，`f`是在`y`之后创建的，因此位于`y`的作用域内，而`y`是在`x`的作用域内创建的。或者不是吗？
- en: 'When the code is built, we will get the following output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码构建时，我们将得到以下输出：
- en: '![](img/00063.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.jpeg)'
- en: The error will be the `x = &f.lifea`, as we attempted to assign a value of something
    about to go out of scope.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 错误将是`x = &f.lifea`，因为我们试图将即将超出作用域的某个值赋给一个值。
- en: '''struct'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`struct`'
- en: One aspect of many languages that is useful is to have a variable that lives
    for the lifetime of the entire application. While some purists argue that having
    a variable that lasts for the life of an application is not good practice, they
    cannot argue that it has its uses.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言的一个有用方面是拥有一个在整个应用程序生命周期中存在的变量。虽然一些纯粹主义者认为拥有一个持续整个应用程序生命周期的变量不是好的实践，但他们无法否认它有其用途。
- en: 'Within Rust, we can also do this using a special `struct` type, a lifetime
    `struct`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们也可以使用一个特殊的`struct`类型，一个生命周期`struct`来完成这个操作：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Local type inference allows us to omit the type when it is not global, so this
    is equivalent to the above when inside a function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本地类型推断允许我们在不是全局的情况下省略类型，因此这在函数内部等同于上面的代码：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Input and output lifetimes
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出生命周期
- en: 'Although not commonly considered, there are two types of lifetimes: input (going
    into the function) and output (coming out of the function).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常被考虑，但有两种生命周期：输入（进入函数）和输出（离开函数）。
- en: Input only
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅输入
- en: 'The following code snippet is an example of a function with an input lifetime:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是一个具有输入生命周期的函数示例：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Output only
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅输出
- en: 'The following code snippet is an example of a function with an output lifetime:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是一个具有输出生命周期的函数示例：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Input and output
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出
- en: 'The following code snippet is an example of a function with both input and
    output lifetimes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是一个具有输入和输出生命周期的函数示例：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can conclude the following from the preceding code snippet:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的代码片段得出以下结论：
- en: Each lifetime in the function argument becomes a distinct lifetime parameter
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数中的每个生命周期都成为一个独立的生命周期参数
- en: If there is one input lifetime, the lifetime is assigned to all lifetimes in
    the return value
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只有一个输入生命周期，则生命周期被分配给返回值中的所有生命周期
- en: 'There is another concept that we will need to include: if there are multiple
    input lifetimes and one of them points to `&self` (either mutable or immutable),
    the lifetime of self applies to all output lifetimes.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要包含另一个概念：如果有多个输入生命周期，其中一个指向`&self`（可变或不可变），则`self`的生命周期适用于所有输出生命周期。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Understanding how Rust deals with the lifetime of variables is of key importance
    in ensuring that as few mistakes as possible are made when creating your Rust
    applications. We have considered how information is moved around functions and
    seen how the Rust model ensures that we are never left with dangling references
    or code that is addressing a memory location that no longer belongs to the variable.
    We have also seen how Rust removes the ability to have data-race conditions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Rust 如何处理变量的生命周期对于确保在创建 Rust 应用程序时尽可能少犯错误至关重要。我们已经考虑了信息如何在函数间传递，并看到了 Rust
    模型如何确保我们不会留下悬垂引用或指向不再属于变量的内存位置的代码。我们还看到了 Rust 如何消除数据竞争条件的能力。
- en: In the next chapter, we will consider generic types, their importance to your
    Rust application, and how the compiler deals with them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑泛型类型，它们对您的 Rust 应用程序的重要性，以及编译器如何处理它们。
