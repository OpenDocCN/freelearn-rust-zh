- en: Hacking Macros
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏黑客技术
- en: 'In this chapter, we will be covering the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Building macros in Rust
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中构建宏
- en: Implementing matching in macros
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在宏中实现匹配
- en: Playing with common Rust macros
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转常见的 Rust 宏
- en: Implementing designators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现设计者
- en: Overloading macros
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏重载
- en: Implementing repeat
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 repeat
- en: Implementing DRY
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现DRY
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Until now, we have seen many statements in Rust ending with an exclamation mark
    (`!`), such as `println!`, `try!`, and so on. These commands have performed powerful
    operations to execute specific tasks. Rust provides a powerful macro system that
    allows metaprogramming. Macros look like functions but their names end with an
    exclamation mark (`!`). Macros are expanded into source code which, gets compiled
    into the program. In this recipe, we will look into the various aspects of macros,
    ranging from defining your own application-specific macros to testing them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了许多以感叹号 (`!`) 结尾的 Rust 语句，例如 `println!`、`try!` 等。这些命令执行了强大的操作以执行特定任务。Rust
    提供了一个强大的宏系统，允许元编程。宏看起来像函数，但它们的名称以感叹号 (`!`) 结尾。宏被扩展到源代码中，该源代码被编译到程序中。在这个配方中，我们将探讨宏的各个方面，从定义自己的应用程序特定宏到测试它们。
- en: Building macros in Rust
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中构建宏
- en: In this recipe, we will learn about `macro_rules!`--the syntax that will help
    us define our custom application-specific macro, which can have a unique name
    according to the application terminology.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将了解 `macro_rules!`——这个语法将帮助我们定义我们的自定义应用程序特定宏，该宏可以根据应用程序术语有一个独特的名称。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 按照给定的步骤实现此配方：
- en: Create a file named `sample_macro.rs`, and open it in your text editor.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_macro.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写包含相关信息的代码头：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a macro named `Welcome_RustBook`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Welcome_RustBook` 的宏：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the `main` function and call the `Welcome_RustBook` macro:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并调用 `Welcome_RustBook` 宏：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们代码成功执行后，我们将得到以下输出：
- en: '![](img/9056cadb-1379-455d-a5d8-6fe573a8b6d6.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9056cadb-1379-455d-a5d8-6fe573a8b6d6.png)'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We use the `macro_rules!` macro to create a custom-named macro; here, we made
    a macro named `Welcome_RustBook!`. The general syntax of `macro_rules!` is as
    follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `macro_rules!` 宏创建一个自定义命名的宏；在这里，我们创建了一个名为 `Welcome_RustBook!` 的宏。`macro_rules!`
    的一般语法如下：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside the `macro_rules!` macro, we match the arguments. In the case of this
    recipe, we do not accept any arguments from the user, so we match `()` `=>` (a
    certain set of action items). The empty parentheses, `()`, in the code indicate
    that the macro takes no argument. The macro will expand into the contents of the
    block of no arguments at compile time, where we have `println!("Welcome to Rust
    Cookbook!");`, which basically prints a default statement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `macro_rules!` 宏内部，我们匹配参数。在这个配方的情况下，我们不接受用户提供的任何参数，所以我们匹配 `()` `=>` （一组特定的操作项）。代码中的空括号
    `()` 表示该宏不接受任何参数。该宏将在编译时展开为无参数块的内容，其中我们具有 `println!("Welcome to Rust Cookbook!");`，这基本上会打印一个默认语句。
- en: In the main function, we call `Welcome_RustBook!` macro in the function definition,
    just like we would call any other macro. We will see the default statement printed
    in the terminal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们在函数定义中调用 `Welcome_RustBook!` 宏，就像我们调用任何其他宏一样。我们将看到默认语句在终端中打印出来。
- en: Implementing matching in macros
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在宏中实现匹配
- en: Let's go ahead and make our macro a bit more complex by adding more rules in
    our macro, the rules are basically pattern matching cases. In this recipe, the
    key takes-away will be to learn how we can define pattern matching cases in macro
    rules.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，通过在我们的宏中添加更多规则来使我们的宏更加复杂，这些规则基本上是模式匹配案例。在这个配方中，关键的学习成果将是了解我们如何在宏规则中定义模式匹配案例。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the mentioned steps to implement this recipe:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此配方：
- en: Create a file named `sample_match.rs`, and open it in your text editor.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_match.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写包含相关信息的代码头：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a macro named `Check_Val`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Check_Val` 的宏：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define the `main` function and call the `Check_Val` macro:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并调用 `Check_Val` 宏：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码成功执行后得到以下输出：
- en: '![](img/5f198960-7a48-47d9-9fff-32b184e1de29.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f198960-7a48-47d9-9fff-32b184e1de29.png)'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we create a macro named `Check_Val!`, which basically plays
    the role as a `match` expression arm, but the matching happens through the Rust
    syntax trees during compilation time. The common syntax of a pattern is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个名为 `Check_Val!` 的宏，它基本上扮演了 `match` 表达式分支的角色，但匹配是在编译时通过 Rust 语法树进行的。模式的常见语法如下：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the term *pattern* refers to the left-hand side of `=>`, which is known
    as *matcher* in Rust.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，术语 *模式* 指的是 `=>` 的左侧，在 Rust 中被称为 *匹配器*。
- en: The `$x:expr` matcher will match any Rust expression and will bind that to syntax
    tree to the metavariable `$x`, any Rust tokens that appear in a matcher must match
    exactly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`$x:expr` 匹配器将匹配任何 Rust 表达式，并将其绑定到语法树上的元变量 `$x`，匹配器中出现的任何 Rust 令牌都必须完全匹配。'
- en: 'We have two pattern matching cases here: `x => $e:expr` and `y => $e:expr`.
    The metavariable is `$e`, which is used in macro definitions for operations to
    be done following the successful pattern matching of a macro rule. When we call
    `Check_Val!(y => 3);` in the `main` function, the output is `mode Y:3`. Here the
    second case is passed and the value of `$e` is the same as that of the arguments
    passed to the `Check_Val!` macro in the `main` function.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两种模式匹配情况：`x => $e:expr` 和 `y => $e:expr`。元变量是 `$e`，它在宏定义中用于在宏规则成功匹配后执行的操作。当我们调用
    `main` 函数中的 `Check_Val!(y => 3);` 时，输出是 `mode Y:3`。在这里，第二个情况通过，并且 `$e` 的值与传递给
    `main` 函数中 `Check_Val!` 宏的参数相同。
- en: 'If we had called `Check-Val!(z => 3);` we would have got `` error: no rules
    expected the token `z` ``, as we haven''t defined a rule for the token `z` and
    surrounding the matcher with `$(...),*` will match zero or more expressions, separated
    by commas.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `Check-Val!(z => 3);`，我们会得到错误：没有规则期望令牌 `z`，因为我们没有为令牌 `z` 定义规则，并且用 `$(...),*`
    将匹配器包围起来将匹配零个或多个表达式，由逗号分隔。
- en: Playing with common Rust macros
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转常见的 Rust 宏
- en: Throughout this book, we have defined and used common Rust macros that will
    help us perform basic operations, such as printing, and so on. Rust offers these
    macros by default, as these are very complex to be implemented by the user. In
    this recipe, we will learn a few common Rust macros.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们定义并使用了常见的 Rust 宏，这将帮助我们执行基本操作，例如打印等。Rust 默认提供这些宏，因为这些宏对于用户来说非常复杂来实现。在这个菜谱中，我们将学习一些常见的
    Rust 宏。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个菜谱：
- en: Create a file named `sample_common_macros.rs`, and open it in your text editor.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_common_macros.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create the `main` function where we implement a few inbuilt standard Rust macros:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中创建一个实现一些内置标准 Rust 宏的函数：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will get the following output on successful execution of our code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码成功执行后得到以下输出：
- en: '![](img/8790c421-3afa-4ae1-befb-351ef1a3543e.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8790c421-3afa-4ae1-befb-351ef1a3543e.png)'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We declared all the standard macros in the main function. Let,s deep dive into
    each one of them in the following order:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主函数中声明了所有标准宏。让我们以下面的顺序深入了解每一个：
- en: We used the `vec!` macro to create a vector in Rust. It creates `Vec<T>`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `vec!` 宏在 Rust 中创建一个向量。它创建 `Vec<T>`。
- en: 'The next two macros are extensively used in tests: the first one is `assert!`,
    which takes a Boolean value to pass and the second one is `assert_eq!`, which
    takes two values and checks for their equality. The true value passes and the
    false one leads to the `panic!` macro, which causes the thread to panic or break.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两个宏在测试中广泛使用：第一个是 `assert!`，它接受一个布尔值以通过，第二个是 `assert_eq!`，它接受两个值并检查它们的相等性。真值通过，而假值会导致
    `panic!` 宏，这会导致线程崩溃或中断。
- en: In this recipe, we have used the `Vec!` macro to create a vector, `v`. The conditions
    inside the `assert!` and `assert_eq!` macros pass. The failure cases have been
    commented out, as they would cause panic during runtime.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了 `Vec!` 宏来创建一个向量 `v`。`assert!` 和 `assert_eq!` 宏内部的条件通过。已注释掉失败情况，因为它们会在运行时导致崩溃。
- en: Implementing designators
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现设计符
- en: Rust provides a list of designators, which help us create units, such as functions,
    and execute expressions in macros.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 提供了一系列设计符，帮助我们创建单元，如函数，并在宏中执行表达式。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the mentioned steps to implement this recipe:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 按照所述步骤实现此菜谱：
- en: Create a file named `sample_designator.rs`, and open it in your text editor.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_designator.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a macro named `create_function`, which accepts a designator as an argument:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `create_function` 的宏，它接受一个设计符作为参数：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Call the `create_function` macro to create two functions, `foo` and `bar`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `create_function` 宏创建两个函数 `foo` 和 `bar`：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a macro named `print_result`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `print_result` 的宏：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the `main` function, where we play around with the macros we created:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数，在其中我们使用我们创建的宏：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will get the following output on successful execution of our code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们代码成功执行后，我们将得到以下输出：
- en: '![](img/ae8ce396-57b6-4596-8848-4ab739a2c959.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae8ce396-57b6-4596-8848-4ab739a2c959.png)'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In general, the arguments of a macro are prefixed by a dollar sign (`$`) and
    a type annotated with a designator. Here, in this recipe, we have used two commonly
    used designators, which are `expr`, used for expressions, and `ident`, which is
    used for variable/function names.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，宏的参数以美元符号（`$`）为前缀，并使用设计符进行类型注解。在这里，在这个菜谱中，我们使用了两个常用的设计符，即 `expr`，用于表达式，以及
    `ident`，用于变量/函数名。
- en: 'Let''s understand the two main macros that we have created to implement the
    designator in the Rust code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们创建的两个主要宏，用于在 Rust 代码中实现设计符：
- en: '`create_function`: This macro takes an argument of the `ident` designator and
    creates a function named `$func_name`, which is used across the code for creating
    the function. The `ident` designator, as mentioned previously, is used for variable/function
    names. Inside the block of the `($func_name:ident)`, pattern, we define the function
    `fn $func_name`, and we have the `stringify!` macro in its body, which converts
    a `$func_name` into a string.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_function`：这个宏接受 `ident` 设计符的参数，并创建一个名为 `$func_name` 的函数，该函数在代码中用于创建函数。如前所述，`ident`
    设计符用于变量/函数名。在 `($func_name:ident)` 模式的块中，我们定义函数 `fn $func_name`，并在其主体中包含 `stringify!`
    宏，它将 `$func_name` 转换为字符串。'
- en: '`print_result`: This macro takes an expression of the `expr` type and prints
    it as a string along with its result. The `expr` designator is used for expressions.
    In the block for the expression pattern, we use the `stringify!` macro, which
    converts the expression into a string and also executes it.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_result`：这个宏接受 `expr` 类型的表达式并将其作为字符串及其结果打印出来。`expr` 设计符用于表达式。在表达式模式的块中，我们使用
    `stringify!` 宏，它将表达式转换为字符串并执行它。'
- en: We create functions named `foo` and `bar` with the preceding macro by using
    `create_function!(foo);` and `create_function!(bar);`. In the `main` function,
    where we called the two functions, that is, `foo` and `bar`, which return the
    string. We call `function_name`. Next, we call `print_result!`, with a block of
    expression as an argument, where we create a variable, `x`, and assign it a value
    of `1u32`, which is a 32-bit unsigned integer type. We then run `x * x + 2 * x
    - 1`, which gives us the output of `2`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `create_function!(foo);` 和 `create_function!(bar);` 创建名为 `foo` 和 `bar`
    的函数。在 `main` 函数中，我们调用了这两个函数，即 `foo` 和 `bar`，它们返回字符串。我们调用 `function_name`。接下来，我们调用
    `print_result!`，它以一个表达式块作为参数，我们创建一个变量 `x` 并将其赋值为 `1u32`，这是一个 32 位无符号整数类型。然后我们运行
    `x * x + 2 * x - 1`，输出为 `2`。
- en: Overloading macros
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏重载
- en: Overloading macros in Rust is the process of providing multiple combinations
    of similar arguments, where we expect the macro to handle them and provide custom
    results according to the combination passed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，宏的重载是指提供多个类似参数的组合，我们期望宏能够处理这些参数并根据传入的组合提供自定义的结果。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此菜谱：
- en: Create a file named `sample_overloading_macros.rs`, and open it in your text
    editor.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_overloading_macros.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含相关信息：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a macro named `test`, for which we will implement overloading:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `test` 的宏，我们将为其实现重载：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the `main` function in which we''ll implement the features of the macro:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数，在其中我们将实现宏的功能：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码成功执行后得到以下输出：
- en: '![](img/5e2f8a0d-4b1c-4e57-b993-992ed28acd69.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e2f8a0d-4b1c-4e57-b993-992ed28acd69.png)'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we create a macro named `test`, which takes two `expr` designators
    used for taking an expression as arguments and assigning it to two variables,
    `$left` and `$right`, where `$left` is assigned to the first expression and `$right`,
    to the second expression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们创建了一个名为 `test` 的宏，它接受两个 `expr` 设计符作为参数，并将它们分配给两个变量，`$left` 和 `$right`，其中
    `$left` 被分配给第一个表达式，而 `$right` 被分配给第二个表达式。
- en: 'Inside the macros, we have two rules, which are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏内部，我们有两个规则，如下所示：
- en: '`($left:expr; and $right:expr)`: In this rule, we want to return a Boolean
    value. Here, we evaluate both the expressions and pass the values to the `&&`
    operator.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`($left:expr; and $right:expr)`: 在此规则中，我们希望返回一个布尔值。在这里，我们评估两个表达式并将值传递给 `&&`
    操作符。'
- en: '`($left:expr; or $right:expr)`: In this rule, we want to return a Boolean value.
    Here, we evaluate both the expressions and pass the values to the `||` operator.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`($left:expr; or $right:expr)`: 在此规则中，我们希望返回一个布尔值。在这里，我们评估两个表达式并将值传递给 `||`
    操作符。'
- en: Arguments don't need to be separated by a comma and each arm must end with a
    semicolon.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 参数不需要用逗号分隔，并且每个分支必须以分号结束。
- en: In the `main` function, we call the `test!` macro two times with different arguments,
    where we have the combinations. The `test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);`
    combination returns the string form of the expression along with the result, which
    is `true`; `test!(true; or false);` similarly returns `true`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们两次调用 `test!` 宏，使用不同的参数，其中我们有组合。`test!(1i32 + 1 == 2i32; and 2i32
    * 2 == 4i32);` 组合返回表达式的字符串形式以及结果，即 `true`；`test!(true; or false);` 同样返回 `true`。
- en: Implementing repeat
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现重复
- en: Repeat is the ability of a particular macro to accept arguments that repeat
    at least once. In this recipe, you will learn the syntax to implement repeat in
    Rust.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重复是特定宏接受至少重复一次的参数的能力。在本教程中，你将学习如何在 Rust 中实现重复的语法。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现本教程：
- en: Create a file named `sample_repeat.rs`, and open it in your text editor.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_repeat.rs` 的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含相关信息：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a macro named `find_min`, in which we implement `repeat`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `find_min` 的宏，在其中实现 `repeat`：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `main` function in which we pass multiple arguments to `find_min`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个 `main` 函数中创建一个，我们将多个参数传递给 `find_min`：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码成功执行后得到以下输出：
- en: '![](img/8c2a0dbd-a0e4-49b4-9bd8-96f610c451dd.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c2a0dbd-a0e4-49b4-9bd8-96f610c451dd.png)'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Macros can use `+` in the argument list to indicate that an argument may repeat
    at least once or `*` to indicate that the argument may repeat zero or more times.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 宏可以在参数列表中使用 `+` 来表示一个参数至少重复一次，或者使用 `*` 来表示一个参数可以重复零次或多次。
- en: In the recipe, we have a macro named `find_min`, which has two rules in which
    the matcher with `$(...),+` will match one or more expressions, separated by commas.
    In the first case, we have `($x:expr)`, which just executes the expression and
    returns the output; this will be matched if we pass only one expression to the
    `find_min` macro. In the second case, we have `($x:expr, $($y:expr),+)`. Here,
    `$x` is followed by at least one `$y`, and inside the block, we call the `find_min!`
    macro on the tail `$y`; these values are fed to `std::cmp::min`, which returns
    the smallest value from the argument list. On the second call, it would execute
    the first case of the macro and return the expression.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们有一个名为 `find_min` 的宏，它有两个规则，其中 `$(...),+` 匹配器将匹配一个或多个由逗号分隔的表达式。在第一种情况下，我们有
    `($x:expr)`，它仅执行表达式并返回输出；如果我们只向 `find_min` 宏传递一个表达式，它将被匹配。在第二种情况下，我们有 `($x:expr,
    $($y:expr),+)`。在这里，`$x` 后面至少跟有一个 `$y`，在代码块内部，我们调用 `find_min!` 宏对尾部 `$y` 进行操作；这些值被传递给
    `std::cmp::min`，它从参数列表中返回最小值。在第二次调用时，它将执行宏的第一种情况并返回表达式。
- en: 'In the `main` function, we run the following cases and print the results:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们运行以下案例并打印结果：
- en: '`find_min!(1u32)`: This will execute the first case and return `1`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_min!(1u32)`: 这将执行第一种情况并返回 `1`'
- en: '`find_min!(1u32 + 2 , 2u32)`: This will go to the second case, where the macro
    will be called again for the second expression and the `min` result of those two
    expressions will be returned, which is `2`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_min!(1u32 + 2 , 2u32)`: 这将进入第二种情况，其中宏将再次对第二个表达式进行调用，并返回这两个表达式的 `min`
    结果，即 `2`'
- en: '`find_min!(5u32, 2u32 * 3, 4u32)`: This is similar to the second case, but
    here the macro will be called two times and the `min` result of all the expressions
    will be returned, which is `4` in this case'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_min!(5u32, 2u32 * 3, 4u32)`: 这与第二种情况类似，但在这里宏将调用两次，并返回所有表达式的 `min` 结果，在这种情况下是
    `4`'
- en: Implementing DRY
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现DRY
- en: Using Don't Repeat Yourself (DRY), in this recipe, we are going to create a
    test case for some basic standard arithmetic operations in Rust. The catch is,
    however, that we are going to work on automating them using macros and their features
    so that we can reduce redundant code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Don't Repeat Yourself (DRY)，在这个配方中，我们将为 Rust 中的一些基本标准算术操作创建测试用例。然而，我们将通过使用宏及其功能来自动化它们，以减少冗余代码。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此配方：
- en: Create a file named `sample_dry.rs`, and open it in your text editor.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_dry.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Call the standard operation crate:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用标准操作包：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a macro named `assert_equal_len`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `assert_equal_len` 的宏：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a macro named `op`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `op` 的宏：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the `add_assign`, `mul_assign`, and `sub_assign` functions:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下函数：`add_assign`、`mul_assign` 和 `sub_assign`：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a module named `test:mod test {`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `test:mod test {` 的模块：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们代码成功执行后，我们将得到以下输出：
- en: '![](img/45339c3f-4419-4064-a81b-2f4c1fcd2cab.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45339c3f-4419-4064-a81b-2f4c1fcd2cab.png)'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Macros allow developers to write DRY code by factoring out the common parts
    of functions and/or test suites. In this recipe, we implemented tested for the
    `+=`, `*=`, and `-=` operators on `Vec<T>`. We have used a new designator in this
    recipe, `tt`; which stands for token tree and is used for operators and tokens.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 宏允许开发者通过提取函数和/或测试套件的公共部分来编写 DRY 代码。在这个配方中，我们对 `Vec<T>` 上的 `+=`、`*=` 和 `-=` 操作符进行了测试。在这个配方中，我们使用了一个新的设计符
    `tt`；它代表标记树，用于操作符和标记。
- en: 'Let''s first understand all the functional macro units in the code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解代码中的所有功能宏单元：
- en: '`assert_equal_len`: This macro takes in four arguments as inputs, which are
    `$a`, `$b`, and `$func`, of the `ident` type, and `$op` of the `tt` type. If the
    macro receives these arguments, then it will check whether `$a` and `$b` are of
    the same length by using the `len()` method inside the `assert!` macro, which
    will return a Boolean value of `true` in the case of success or else, it prints
    a failure statement saying `dimension mismatch`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert_equal_len`: 这个宏接受四个输入参数，这些参数是 `$a`、`$b` 和 `$func`，它们都是 `ident` 类型，以及
    `$op`，它是 `tt` 类型。如果宏接收到这些参数，那么它将使用 `assert!` 宏内部的 `len()` 方法检查 `$a` 和 `$b` 是否具有相同的长度，这将返回一个成功时的布尔值
    `true` 或否则打印一个失败语句，表示“维度不匹配”。'
- en: '`op`: This macro takes in four arguments as input, which are `$func`, `$bound`,
    and `$method`, of the `ident` type, and `$op` of the `tt` type. We create the
    corresponding operator function with this macro, where `$func` is the name of
    the function and is the first argument in the list, with two arguments of the
    `Vec<T>` type: `xs` and `ys`. Both the variables are shared with the macros, and
    `xs` is provided with a mutable permission while it is shared. Inside the function,
    we perform the operation with `$bound::$method` for all the values of the vectors
    `xs` and `ys`, and the results are stored in `x` as it has mutable access. Here,
    `$bound` is the standard module and its `$method` corresponds to its unit. With
    this macro, we are able to perform a lot of methods on the data passed, which
    reduces the code.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`op`: 这个宏接受四个输入参数，这些参数是 `$func`、`$bound` 和 `$method`，它们都是 `ident` 类型，以及 `$op`，它是
    `tt` 类型。我们使用这个宏创建相应的操作函数，其中 `$func` 是函数的名称，并且是列表中的第一个参数，它有两个 `Vec<T>` 类型的参数：`xs`
    和 `ys`。这两个变量都与宏共享，并且当它们共享时，`xs` 被提供可变权限。在函数内部，我们使用 `$bound::$method` 对向量 `xs`
    和 `ys` 的所有值执行操作，并将结果存储在具有可变访问权限的 `x` 中。在这里，`$bound` 是标准模块，其 `$method` 对应于其单位。通过这个宏，我们能够对传递的数据执行许多方法，从而减少代码量。'
- en: '`test`: This macro takes in four arguments as input, which are `$func`, of
    the `ident` type, and `$x`, `$y`, and `$z`, which are `expr` of the `ident` type,
    and are present inside the `test` module, which is invoked while we run our test
    cases. Inside the `test` macro, we create the function with the name of `$func`.
    By doing so, it will become a function or unit of the parent `test` module. We
    iterate across the values to create vectors in which we perform `super::$func(&mut
    x, &y)`. The `super` here refers to the function that we created by using the
    `op` macro, which updates the value of `x` based on the operation we wanted to
    perform. In the last step, we validate `test` by comparing the updated `x` vector
    with the `z` vector, which is the desired value. The `assert_eq!` macro will return
    `true` if the values match; else it will panic out.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`: 这个宏接受四个输入参数，这些参数是 `$func`，它是 `ident` 类型，以及 `$x`、`$y` 和 `$z`，它们是 `expr`
    类型的 `ident`，存在于我们运行测试用例时调用的 `test` 模块中。在 `test` 宏内部，我们创建一个名为 `$func` 的函数。通过这样做，它将成为父
    `test` 模块中的函数或单元。我们遍历值以创建向量，在其中执行 `super::$func(&mut x, &y)`。这里的 `super` 指的是我们使用
    `op` 宏创建的函数，它根据我们想要执行的操作更新 `x` 的值。在最后一步，我们通过比较更新的 `x` 向量与期望的值 `z` 向量来验证 `test`。如果值匹配，`assert_eq!`
    宏将返回 `true`；否则，它将引发恐慌。'
- en: In this code, we use a certain set of standard libraries, which are `ops` and
    `item`. First, we create the different operations that we want to implement, so
    we call the `op!` and create `add_assign`, `mul_assign`, and `sub_assign`. Later
    in the test module, we call the test case for the different functions that we
    have created. Here, we give all the cases for passing and run the `--test` option
    during compilation to run the test cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用一组特定的标准库，即 `ops` 和 `item`。首先，我们创建我们想要实现的不同操作，因此我们调用 `op!` 并创建 `add_assign`、`mul_assign`
    和 `sub_assign`。在测试模块的后续部分，我们调用我们创建的不同函数的测试用例。在这里，我们给出所有传递的案例，并在编译时运行 `--test`
    选项来运行测试用例。
