- en: Going Further with Advanced Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习高级 Rust
- en: 'There are no doubts as to the difficulties that the Rust language poses to
    the avid learner. However, if you are reading this, you have gone further than
    most and invested the time needed to improve. The language and the way it forces
    you to think about memory is going to introduce new concepts into your programming
    habits. Rust does not necessarily provide new tools to accomplish things, but
    the borrowing and ownership rules help us to concern ourselves more with scopes,
    lifetimes, and freeing memory appropriately, regardless of the language. Hence,
    let''s go deeper into more advanced concepts in Rust in order to complete our
    understanding of the language – when, why, and how to apply concepts such as the
    following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Rust 语言对热衷于学习的用户提出的困难，毫无疑问。然而，如果您正在阅读这篇文章，您已经走在了大多数人的前面，并投入了所需的时间来提高。这种语言及其强制您思考内存的方式将把新的概念引入到您的编程习惯中。Rust
    并不一定提供新的工具来完成事情，但借用和所有权规则帮助我们更多地关注作用域、生命周期以及适当地释放内存，无论语言如何。因此，让我们深入探讨 Rust 中更高级的概念，以完成对语言的全面理解——何时、为什么以及如何应用以下概念：
- en: Creating meaningful numbers with enums
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用枚举创建有意义的数字
- en: There is no null
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有空值
- en: Complex conditions with pattern matching
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的条件与模式匹配
- en: Implementing custom iterators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义迭代器
- en: Filtering and transforming sequences efficiently
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地过滤和转换序列
- en: Reading memory the unsafe way
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不安全的方式读取内存
- en: Shared ownership
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享所有权
- en: Shared mutable ownership
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享可变所有权
- en: References with explicit lifetimes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有显式生命周期的引用
- en: Enforcing behavior with trait bounds
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特质界限强制行为
- en: Working with generic data types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与泛型数据类型一起工作
- en: Creating meaningful numbers with enums
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用枚举创建有意义的数字
- en: Enums, short for enumerations, are well-known programming constructs that many
    languages feature. These special cases of types allow a number to be mapped to
    a name. This can be used to tie constants together under a single name and lets
    us declare values as variants. For example, we could have pi, as well as Euler's
    number, as variants of an enum, `MathConstants`. Rust is no different, but it
    can go a lot further. Instead of simply relying on *naming numbers*, Rust allows
    enums the same flexibility as other Rust types have. Let's see what this means
    in practice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举，简称为枚举，是许多语言中常见的编程结构。这些类型的特殊情况允许将数字映射到名称。这可以用来将常量绑定到单个名称下，并允许我们声明值作为变体。例如，我们可以在枚举
    `MathConstants` 中有 π，以及欧拉数作为变体。Rust 并无不同，但它可以走得更远。Rust 不仅仅依赖于 *命名数字*，它允许枚举具有与其他
    Rust 类型相同的灵活性。让我们看看这在实践中意味着什么。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to explore enums:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来探索枚举：
- en: Create a new project with `cargo new enums --lib` and open this folder in Visual
    Studio Code, or any IDE of your choosing.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new enums --lib` 创建一个新的项目，并在 Visual Studio Code 或您选择的任何 IDE 中打开此文件夹。
- en: 'Open `src/lib.rs` and declare an enum containing some data:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/lib.rs` 并声明一个包含一些数据的枚举：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition to the declaration, we also implement a simple function:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了声明之外，我们还实现了一个简单的函数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we also need to do something with the enum, so let''s implement a dummy
    function called `do_work`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还需要对枚举做一些处理，所以让我们实现一个名为 `do_work` 的虚拟函数：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Nothing is true until it''s tested! Now, add a number of tests that show the
    powerful matching of enums, starting with the `do_work()` function:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未经测试，一切都是假的！现在，添加一些测试来展示枚举强大的匹配功能，从 `do_work()` 函数开始：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the `get_kind()` function, we also require a test:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `get_kind()` 函数，我们还需要一个测试：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a call to `cargo test` in the root directory of the project, we can observe
    the output:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下调用 `cargo test`，我们可以观察到输出：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's see how enums work under the hood.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看枚举在底层是如何工作的。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'Enums in Rust encapsulate choices—just as in any language. However, they behave
    similarly to regular structures in a lot of ways:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的枚举封装了选择——就像在任何语言中一样。然而，它们在许多方面与常规结构的行为相似：
- en: They can have `impl` blocks for traits and functions.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以为特性和函数拥有 `impl` 块。
- en: Unnamed and named properties can carry different values.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无名和命名的属性可以携带不同的值。
- en: 'These aspects make them really great candidates for choices of all kinds, be
    it configuration values, flags, constants, or wrapping errors, as we did in *Step
    2*. Typical enums in other languages map a name to a numerical value of your choice,
    but Rust goes one step further. Instead of just numerical values, Rust''s enum
    can have any value and even named properties. Take a look at the definition in
    *Step 2*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面使它们成为所有选择的真正优秀候选人，无论是配置值、标志、常量还是像*第2步*中那样包装错误。其他语言中的典型枚举将名称映射到你选择的数值，但Rust更进一步。Rust的枚举不仅可以有数值，甚至可以有命名属性。看看*第2步*中的定义：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ApplicationError::Code` features two properties, one called `full` and one
    called `short`—assignable just like any other `struct` instance. The second and
    third variations, `Message` and `IOWrapper`, encapsulate another type instance
    entirely, one a `String`, and the other an `std::io::Error`, similar to tuples.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationError::Code`有两个属性，一个叫做`full`，另一个叫做`short`——就像任何其他`struct`实例一样可赋值。第二个和第三个变体，`Message`和`IOWrapper`，封装了另一个类型实例，一个是`String`，另一个是`std::io::Error`，类似于元组。'
- en: The additional ability to work in match clauses makes these constructs very
    useful, especially for large code bases where readability is important—an example
    of which can be found in *Step 3*, where we implement a function at the enum's
    type. This function maps explicit enum instances to strings for easier printing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在匹配子句中工作的附加能力使这些结构非常有用，尤其是在代码库很大且可读性很重要的情况下——例如在*第3步*中，我们在枚举类型中实现了一个函数。这个函数将显式的枚举实例映射到字符串，以便更容易打印。
- en: '*Step 4* implements a helper function that provides us with different kinds
    of errors and values to work with, something that we require in *Step 5*, where
    we create two extensive tests of these functions. There, we use the `match` clause
    (which will also be discussed in a later recipe in this chapter) to extract values
    from the errors and match on multiple enum variants in a single arm. Additionally,
    we created a test to show that the `print_kind()` function works by using a `Vec`
    as a stream (thanks to it implementing the `Write` trait).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4步*实现了一个辅助函数，为我们提供了不同类型的错误和值来处理，这是我们*第5步*中创建这些函数的两个广泛测试所必需的。在那里，我们使用`match`子句（这个子句将在本章后面的食谱中讨论）从错误中提取值，并在单个分支中匹配多个枚举变体。此外，我们还创建了一个测试来展示`print_kind()`函数通过使用`Vec`作为流（归功于它实现了`Write`特质）是如何工作的。'
- en: We've successfully learned how to create meaningful numbers with enums. Now,
    let's move on to the next recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地学习了如何使用枚举创建有意义的数字。现在，让我们继续下一个食谱。
- en: There is no null
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有null
- en: Functional languages typically don't have a concept of **null** for the simple
    reason that it's always a special case. If you strictly follow functional principles,
    each input must have a workable output—but what is null? Is it an error? Or within
    normal operating parameters, but a negative result?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言通常没有**null**的概念，简单的理由是它总是一个特殊情况。如果你严格遵循函数式原则，每个输入都必须有一个可工作的输出——但是null是什么？它是错误吗？还是正常操作参数内的一个负结果？
- en: As a legacy feature, null has been around since C/C++, when a pointer could
    actually point to the (invalid) address, `0`. However, many new languages try
    to move away from that. Rust does not have null, and no return value as a normal
    case with the `Option` type. The case of error is covered by the `Result` type,
    to which we dedicated an entire chapter, [Chapter 5](898e8c94-b6e0-41d4-a06a-6fd95fb88466.xhtml),
    *Handling Errors and Other Results*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为遗留特性，null自从C/C++时代就有，当时指针实际上可以指向（无效的）地址，`0`。然而，许多新的语言试图摆脱这一点。Rust没有null，也没有使用`Option`类型的正常返回值。错误的情况由`Result`类型覆盖，我们为此专门写了一章，[第5章](898e8c94-b6e0-41d4-a06a-6fd95fb88466.xhtml)，*处理错误和其他结果*。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Since we are exploring a built-in library feature, we''ll create several tests
    that cover everything:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在探索内置库功能，我们将创建几个测试来涵盖所有内容：
- en: Create a new project using `cargo new not-null --lib` and open the project folder
    using Visual Studio code.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new not-null --lib`创建一个新的项目，并使用Visual Studio code打开项目文件夹。
- en: 'To start off, let''s see what `unwrap()` does and replace the default test
    in `src/lib.rs` with the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看`unwrap()`做了什么，并用以下代码替换`src/lib.rs`中的默认测试：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Option` also wraps values well, and it''s sometimes complicated (or simply
    verbose) to get them out. Here are a number of ways of getting the value out:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Option`也很好地封装了值，有时获取它们可能很复杂（或者简单地说，很冗长）。这里有几种获取值的方法：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Due to their functional origins, where it''s often not important whether one
    works on a single value or a collection, `Option` also behaves like a collection
    in some ways:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它们的函数式起源，在单值或集合上工作通常并不重要，`Option`在某些方面也表现得像集合：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, using the `match` clause on `Option` is very popular and often necessary:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Option`上使用`match`子句非常流行且通常是必要的：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To see it all working, we should also run `cargo test`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看到它全部工作，我们也应该运行`cargo test`：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Options` are, to our initial surprise, an enum. While this almost guarantees
    great `match` compatibility, enums behave a lot like structs in the remaining
    aspects. In *Step 2*, we see that it''s not just a regular enum, but also a typed
    enum—which forces us to add a type declaration to `None` as well. *Step 2* also
    shows ways how to get values out of the `Option` type, with and without panicking.
    `unwrap()` is a popular choice, but it comes with some variations that don''t
    halt the thread if `None` is encountered.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Options` 在我们的初步惊讶中，是一个枚举类型。虽然这几乎保证了良好的`match`兼容性，但在其他方面枚举的行为与结构体非常相似。在*步骤
    2*中，我们看到这不仅仅是一个普通的枚举，而是一个类型枚举——这迫使我们为`None`添加类型声明。*步骤 2*还展示了如何从`Option`类型中获取值，包括带和不带恐慌的情况。`unwrap()`是一个流行的选择，但它有一些变体，当遇到`None`时不会使线程停止。'
- en: '`unwrap()` is always a dangerous thing, and should only be used in non-production
    code. It panics, which can bring the entire program to a sudden, unexpected halt,
    and doesn''t even leave you with a proper error message. If stopping the program
    is the desired outcome, `expect()` is a better choice since it lets you add a
    simple message. This is why we added the `#[should_panic]` attribute to the unit
    test, so that we can prove to you that it actually panics (or otherwise the test
    fails).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`unwrap()`始终是一件危险的事情，并且只应在非生产代码中使用。它会引发恐慌，可能导致整个程序突然、意外地停止，甚至不会留下适当的错误消息。如果你希望程序停止，`expect()`是一个更好的选择，因为它允许你添加一个简单的消息。这就是为什么我们在单元测试中添加了`#[should_panic]`属性，这样我们就可以向你证明它实际上会引发恐慌（否则测试会失败）。'
- en: '*Step 3* shows some non-intrusive ways to *unwrap* the value of `Option`. Especially
    since `unwrap()` returns the owned value while destroying `Option` itself, other
    ways can be more useful if `Option` remains part of a data structure and only
    temporarily holds a value. `take()` was designed for these situations that replace
    the value with `None`, similar to `replace()`, which does the same for the replacement
    value. Furthermore, there is `map()`, which lets you work directly with the value
    (if present) and ignore the usual `if`-then or `match` constructs, which add a
    lot of code verbosity (refer to *step 5*).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 3*展示了几种非侵入性的方法来*展开*`Option`的值。特别是由于`unwrap()`返回所有者值同时销毁`Option`本身，如果`Option`仍然是数据结构的一部分并且只是临时持有值，其他方法可能更有用。`take()`是为这些情况设计的，用`None`替换值，类似于`replace()`，它对替换值做同样的处理。此外，还有`map()`，它允许你直接处理值（如果存在），并忽略通常的`if`-then或`match`结构，这些结构会增加大量的代码冗余（参考*步骤
    5*）。'
- en: '*Step 4* features an interesting tidbit in the middle: `Options` can be used
    like Booleans to perform logic operations, similar to Python, where AND/OR operations
    return a particular operand ([https://docs.python.org/3/reference/expressions.html#boolean-operations](https://docs.python.org/3/reference/expressions.html#boolean-operations))
    in either case. Last but not least, `Options` can also be treated like collections
    using an iterator.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 4*中间有一个有趣的细节：`Options`可以像布尔值一样执行逻辑运算，类似于Python，其中AND/OR运算返回特定的操作数([https://docs.python.org/3/reference/expressions.html#boolean-operations](https://docs.python.org/3/reference/expressions.html#boolean-operations))。最后但同样重要的是，`Options`也可以使用迭代器像集合一样处理。'
- en: Rust's options are very versatile and, by looking at the documents ([https://doc.rust-lang.org/std/option/index.html](https://doc.rust-lang.org/std/option/index.html)),
    you can find out many different ways to transform values on the fly without tedious
    guard clauses with `if`, `let`, and `match`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的选项非常灵活，通过查看文档([https://doc.rust-lang.org/std/option/index.html](https://doc.rust-lang.org/std/option/index.html))，你可以找到许多不同的方法来动态转换值，而不需要繁琐的`if`、`let`和`match`保护子句。
- en: Now that we have successfully learned that there is no null in Rust, let's move
    on to the next recipe.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地了解到Rust中没有空值，让我们继续学习下一个菜谱。
- en: Complex conditions with pattern matching
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂的条件与模式匹配
- en: As shown in the previous recipe, pattern matching is very useful with enums.
    However, there is more! Pattern matching is a construct that originates in functional
    languages and curtails much of the choice between conditional branches and the
    assignment of properties in `struct` that commonly follows. These steps are taken
    at once, reducing the amount of code on the screen and creating something akin
    to a higher-order `switch-case` statement.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，模式匹配与枚举一起非常有用。然而，还有更多！模式匹配是一种起源于函数式语言的构造，它减少了在`struct`中分配属性时在条件分支和赋值之间的许多选择。这些步骤同时进行，减少了屏幕上的代码量，并创建了一种类似于高阶`switch-case`语句的东西。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Just a few steps need to be followed in order to learn more about pattern matching:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 只需遵循几个步骤，就可以了解更多关于模式匹配的信息：
- en: Create a new binary project using `cargo new pattern-matching`. This time, we'll
    run an actual executable! Again, open the project using Visual Studio Code or
    another editor.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new pattern-matching`创建一个新的二进制项目。这次，我们将运行一个实际的可执行文件！再次，使用Visual Studio
    Code或其他编辑器打开项目。
- en: 'Let''s check out literal matching. Just like a `switch-case` statement in other
    languages, each matching arm can match to literals as well:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看字面量匹配。就像其他语言中的`switch-case`语句一样，每个匹配臂也可以匹配字面量：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, pattern matching is way more powerful than that. For example, tuple
    elements can be extracted and selectively matched:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，模式匹配比这要强大得多。例如，可以提取元组元素并选择性地匹配：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Destructuring** (moving properties out of a `struct` into their own variables)
    is a powerful feature in conjunction with structs and enums. First, this facilitates
    the assigning of multiple variables in a single matching arm to values that are
    assigned to properties at the incoming struct instance. Now, let''s define a few
    structs and enums:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解构**（将属性从`struct`移动到它们自己的变量中）是与结构和枚举结合使用的一个强大功能。首先，这有助于在单个匹配臂中将多个变量分配给分配给结构实例属性的值。现在，让我们定义一些结构和枚举：'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, the individual properties can be matched in a destructuring match. Enums
    work just as well—however, be sure to cover all possible variations; the compiler
    will notice (or use the special `_` to match all). Matching is also done from
    top to bottom, so whichever rule applies first will be executed. The following
    snippet matches variations of the structs we just defined. It matches and assigns
    variables if a particular user type and theme is detected:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以在解构匹配中匹配单个属性。枚举也工作得很好——然而，务必涵盖所有可能的变体；编译器会注意到（或使用特殊`_`来匹配所有）。匹配也是从上到下进行的，所以首先应用的规则将被执行。以下代码片段匹配了我们刚才定义的结构体的变体。如果检测到特定的用户类型和主题，它将匹配并分配变量：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On top of the powerful regular matching, a guard can also enforce certain conditions.
    Similar to destructuring, we can add more constraints:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在强大的正则匹配之上，守卫也可以强制执行某些条件。类似于解构，我们可以添加更多约束：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So far, borrowing and ownership has not been a significant concern. However,
    the `match` clauses so far have all taken ownership and transferred it to the
    scope of the matching arm (anything after `=>`), which, unless you return it,
    means that the outside scope cannot do any other work with it. To remedy that,
    references can be matched as well:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，借用和所有权并不是一个重要的问题。然而，到目前为止的所有`match`子句都采取了所有权并将其转移到匹配臂的作用域（`=>`之后的内容），除非你返回它，否则外部作用域无法对其进行任何其他操作。为了解决这个问题，也可以匹配引用：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In order to go full circle, we have not yet matched a particular type of literal:
    the string literal. Due to their heap allocation, they are fundamentally different
    from types such as `i32` or `usize`. Syntactically, however, they don''t look
    different from any other form of matching:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了形成一个完整的循环，我们还没有匹配特定的字面量类型：字符串字面量。由于它们的堆分配，它们在本质上与`i32`或`usize`等类型不同。在语法上，它们看起来与其他任何匹配形式没有区别：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s tie it all together and build a `main` function that calls the
    various functions with the right parameters. Let''s begin by printing a few simpler
    matches:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将所有这些结合起来，构建一个`main`函数，该函数使用正确的参数调用各种函数。让我们先打印一些简单的匹配：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we can also print the destructured matches:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还可以打印解构后的匹配：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And lastly, let''s see about guards and literal string matches on UTF symbols:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看关于守卫和UTF符号的文本字面量匹配：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last step again involves running the program. Since this is not a library
    project, the results will be printed on the command line. Feel free to change
    any of the variables in the `main` function to see how it affects the output.
    Here''s what the output *should* be:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步再次涉及到运行程序。由于这不是一个库项目，结果将在命令行上打印。您可以随意更改`main`函数中的任何变量，以查看它如何影响输出。以下是输出*应该*是的样子：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let's take a peek behind the scenes to understand the code better.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后看看，以更好地理解代码。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ever since we came across pattern matching in the Scala programming language,
    we fell in love with its simplicity. As a major pillar of functional programming,
    the technique provides a quick way to transform values in various ways without
    sacrificing Rust's type safety.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在Scala编程语言中遇到模式匹配以来，我们就爱上了它的简单性。作为函数式编程的主要支柱，这项技术提供了一种快速转换值的方法，而不会牺牲Rust的类型安全。
- en: 'The literal matches in *Steps 2* and *7 *are a great way to save on `if-else`
    chains. However, the most common matching is probably done to unpack `Result`
    or `Option` types for extracting the encapsulated values. While multiple matches
    are only possible using the `|` symbol , there are special operators to match
    to particular variations: `...` denotes a range, while `..` means to skip the
    remaining members of a struct. `_` is almost always a wildcard for ignoring a
    particular thing and, as a `match` clause, it is a catch-all and should be placed
    last. In *Step 3*, we did a lot of unpacking of tuples; we skipped some of the
    matches using an `_` in place of a variable name.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**和**步骤 7**中的字面匹配是一种节省`if-else`链的好方法。然而，最常见的情况可能是为了解包`Result`或`Option`类型以提取封装的值。虽然使用`|`符号可以实现多个匹配，但有一些特殊操作符可以匹配特定的变体：`...`表示一个范围，而`..`表示跳过结构体中剩余的成员。`_`几乎总是忽略特定事物的通配符，作为一个`match`子句，它是一个通配符，应该放在最后。在**步骤
    3**中，我们进行了大量的元组解包；我们使用`_`代替变量名来跳过一些匹配。
- en: In a similar fashion, *Step 4* sets up and uses Rust's mechanism to match properties
    inside types when using the `match` clause (also called destructuring). This feature
    supports nesting and lets us pick values and sub-structs out of a complex struct
    instance. Neat!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，**步骤 4**设置了并使用Rust的`match`子句（也称为解构）来匹配类型内的属性。这个特性支持嵌套，并允许我们从复杂的结构体实例中提取值和子结构体。真不错！
- en: However, it is often not done with matching on the type and then working with
    the unpacked values only in the match arm. Instead, having the match conditions
    lined up is a much better way to deal with allowed values within types. Rust's
    `match` clause supports guards for exactly that reason. *Step 5* shows what they
    are capable of.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常不是通过在类型上匹配然后仅在`match`分支中处理解包的值来完成的。相反，将匹配条件排列整齐是处理类型内允许值的更好方法。Rust的`match`子句支持为此目的的守卫。**步骤
    5**展示了它们的能力。
- en: '*Steps 8* and *9* both then show the use of the previously implemented `match`
    functions. We highly recommend going through some experiments yourself and seeing
    what changes. The typed matching allows for complex architectures without verbose
    safeguards or workarounds, which is exactly what we want!'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 8**和**步骤 9**都展示了之前实现的`match`函数的使用。我们强烈建议您亲自进行一些实验，看看会发生什么变化。类型匹配允许在没有冗长的安全措施或解决方案的情况下实现复杂的架构，这正是我们想要的！'
- en: We've successfully learned about complex conditions with pattern matching. Now,
    let's move on to the next recipe.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了使用模式匹配的复杂条件。现在，让我们继续下一个菜谱。
- en: Implementing custom iterators
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义迭代器
- en: 'The true power of a great language is the way in which it lets the programmer
    integrate with types in the standard library and around the general ecosystem.
    One way to do this is the iterator pattern: defined by the Gang of Four in their
    book *Design Patterns* (Addison-Wesley Professional, 1994), an iterator is an
    encapsulation of a pointer moving through a collection. Rust provides a range
    of implementations on top of the `Iterator` trait. Let''s see how we can leverage
    that power with only a few lines of code.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀语言的真正力量在于它让程序员如何与标准库和通用生态系统中的类型进行集成。做到这一点的一种方法是通过迭代器模式：由四人帮在其《设计模式》一书中定义（Addison-Wesley
    Professional，1994年），迭代器是通过一个指针在集合中移动的封装。Rust在`Iterator`特质之上提供了一系列实现。让我们看看我们如何仅用几行代码利用这种力量。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will build an iterator for the linked list we built in an earlier recipe.
    We recommend either using the `Chapter01/testing` project or walking with us through
    construction of the iterator. In case you are too busy for that, the full solution
    can be found in `Chapter02/custom-iterators`. These paths refer to the GitHub
    repository for this book at [https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们在早期菜谱中构建的链表构建一个迭代器。我们建议使用`Chapter01/testing`项目，或者跟随我们构建迭代器的过程。如果你太忙，无法这样做，完整的解决方案可以在`Chapter02/custom-iterators`中找到。这些路径指的是本书的GitHub仓库[https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何去做...
- en: 'Iterators are typically their own structs and, since there can be different
    types (for example, for returning references instead of owned values), they are
    a good choice architecturally as well:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器通常是它们自己的结构体，由于可能有不同类型（例如，用于返回引用而不是拥有值），因此在架构上也是一个很好的选择：
- en: 'Let''s create the struct for the iterator of `List<T>`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`List<T>`的迭代器创建一个结构体：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So far, this is only a regular `struct` that lacks everything an iterator should
    have. Their defining nature is a `next()` function that advances the internal
    pointer and returns the value that it just moved off of. In typical Rust fashion,
    the returned value is wrapped in an `Option` that becomes `None` once the collection
    runs out of items. Let''s implement the `Iterator` trait to get all of these features:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，这只是一个缺少迭代器应有的所有功能的普通`struct`。它们的定义性质是一个`next()`函数，它前进内部指针并返回它刚刚移动过的值。按照典型的Rust风格，返回的值被包裹在一个`Option`中，一旦集合中的项目用完，它就变为`None`。让我们实现`Iterator`特质以获得所有这些功能：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Right now, we could instantiate `ConsumingListIterator` and pass our own `List`
    instance to it and it would work well. However, that is far from a seamless integration!
    The Rust standard library offers an additional trait to implement `IntoIterator`.
    By implementing this trait''s functions, even a `for` loop knows what to do, and
    it looks just like any other collection and is easily interchangeable:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们可以实例化`ConsumingListIterator`并将我们的`List`实例传递给它，这样它就能很好地工作。然而，这还远非无缝集成！Rust标准库提供了一个额外的特质来实现`IntoIterator`。通过实现这个特质的函数，即使是`for`循环也知道该怎么做，它看起来就像任何其他集合，并且可以轻松互换：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lastly, we need to write a test to prove that everything is working. Let''s
    add this to the existing test suite:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要编写一个测试来证明一切正常工作。让我们将其添加到现有的测试套件中：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running the tests will show how well this integration works. The `cargo test` command''s
    output demonstrates this:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试将展示这种集成工作得有多好。`cargo test`命令的输出展示了这一点：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The next section is going to dive deeper into what's happening behind the scenes!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将更深入地探讨幕后发生的事情！
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Iterators are a great way of providing advanced capabilities to custom data
    structures. With their simple, unified interface, collection types can be switched
    out easily as well and programmers don't have to get used to new APIs for every
    data structure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是向自定义数据结构提供高级功能的好方法。凭借它们简单统一的接口，集合类型也可以轻松切换，程序员不必为每个数据结构都适应新的API。
- en: By implementing the `Iterator` trait in *Steps 1* and *2*, it becomes easy to
    provide exactly the desired access level to a collection's elements. In the case
    of this recipe (and similar to `Vec<T>`), it will consume the list entirely and
    remove the items one by one, starting at the front.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在*步骤1*和*步骤2*中实现`Iterator`特质，可以很容易地提供对集合元素的精确访问级别。在这个菜谱的案例中（类似于`Vec<T>`），它将完全消耗列表并逐个移除项目，从前面开始。
- en: 'In *Step 3*, we implement `IntoIterator`, a trait that makes this construct
    available to the `for` loop and other users who call `into_iter()`. Not every
    collection implements this trait to provide multiple different iterators; for
    example, the second iterator of `Vec<T>` is reference-based, and only accessible
    via an `iter()` function on the type. By the way, a reference is a data type,
    just like the actual instance, so it''s all about the type definition in this
    case. These definitions are made inside the trait implementation with the `type
    Item` declaration (so-called **associated types**: [https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html](https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html)).
    These types are called associated types, and can be referenced using `Self::Item`—just
    like generics, but without the added syntax verbosity.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤3* 中，我们实现了 `IntoIterator`，这是一个使这种结构可用于 `for` 循环和其他调用 `into_iter()` 的用户的特例。并非每个集合都实现了这个特例以提供多个不同的迭代器；例如，`Vec<T>`
    的第二个迭代器是基于引用的，并且只能通过类型上的 `iter()` 函数访问。顺便说一句，引用是一种数据类型，就像实际实例一样，所以在这种情况下，一切都关于类型定义。这些定义是在特例实现中通过
    `type Item` 声明（所谓的**关联类型**：[https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html](https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html))完成的。这些类型被称为关联类型，可以使用
    `Self::Item` 来引用——就像泛型一样，但没有额外的语法冗余。
- en: With these interfaces, you can get access to a large library of functions that
    only assume a working iterator to be present! Check out *Steps 4* and *5* to see
    the implementation and outcome of using the iterator on a newly created list type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些接口，你可以访问一个大型函数库，这些函数只假设存在一个正在工作的迭代器！查看 *步骤4* 和 *步骤5* 以查看使用迭代器在新建列表类型上的实现和结果。
- en: We've successfully learned how to implement custom iterators. Now, let's move
    on to the next recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何实现自定义迭代器。现在，让我们继续下一个示例。
- en: Filtering and transforming sequences efficiently
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效地过滤和转换序列
- en: While in the previous recipe we discussed implementing a custom iterator, it's
    now time to make use of the functions they provide. Iterators can transform, filter,
    reduce, or simply convert the underlying elements in a single go, thereby making
    it a very efficient endeavor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们讨论了实现自定义迭代器，现在是时候利用它们提供的函数了。迭代器可以一次性转换、过滤、归约或简单地转换底层元素，从而使其成为一个非常高效的尝试。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, create a new project using `cargo new iteration --lib` and add the following
    to the newly created `Cargo.toml` file in the project''s directory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `cargo new iteration --lib` 创建一个新的项目，并将以下内容添加到项目目录中新建的 `Cargo.toml` 文件：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This adds a dependency to the `rand` ([https://github.com/rust-random/rand](https://github.com/rust-random/rand))
    crate to the project, which will be installed upon running `cargo test` the first
    time. Open the entire project (or the `src/lib.rs` file) in Visual Studio Code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目中添加对 `rand` ([https://github.com/rust-random/rand](https://github.com/rust-random/rand))
    包的依赖，首次运行 `cargo test` 时将安装。在Visual Studio Code中打开整个项目（或 `src/lib.rs` 文件）。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In four easy steps, we''ll be able to filter and transform collections in Rust:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过四个简单的步骤，我们就能在Rust中过滤和转换集合：
- en: 'In order to use an iterator, you have to retrieve it first! Let''s do that
    and implement a test that quickly shows how an iterator works on a regular Rust
    `Vec<T>`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用迭代器，你首先必须检索它！让我们这样做并实现一个测试，快速展示迭代器在常规Rust `Vec<T>` 上的工作方式：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With one test added, let''s explore the notion of iterator functions further.
    They are compose able and let you perform multiple steps in a single iteration
    (think of adding more things to a single `for` loop). Additionally, the outcome''s
    type can be completely different from what you started with! Here is another test
    to add to the project that performs some data transformations:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个测试后，让我们进一步探讨迭代器函数的概念。它们是可组合的，并允许你在单个迭代中执行多个步骤（想想在单个 `for` 循环中添加更多东西）。此外，结果类型可以与开始时完全不同！以下是添加到项目中以执行一些数据转换的另一个测试：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As the final step, let''s also look at some filtering and splitting. These
    have proven to be the most useful in our personal experience—it removes a lot
    of code verbosity. Here is some code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们也看看一些过滤和拆分。在我们的个人经验中，这些证明是最有用的——它们大大减少了代码的冗余。以下是一些代码：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As always, we want to see the examples working! Run `cargo test` to do just
    that:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们希望看到示例工作！运行 `cargo test` 来实现这一点：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Do you want to know more? Let's see how it works.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道更多吗？让我们看看它是如何工作的。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Rust''s iterators are heavily inspired by functional programming languages,
    which makes them very handy to use. As an iterator, every operation is applied
    sequentially one element at a time, but only as far as the iterator is moved forward.
    There are several types of operations shown in this recipe. The most important
    ones are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的迭代器受到了函数式编程语言的强烈启发，这使得它们非常便于使用。作为一个迭代器，每个操作都是逐个元素顺序应用的，但仅当迭代器被向前移动时。本食谱中展示了多种类型的操作。其中最重要的如下：
- en: '`map()` operations execute a value or type transformation, and they are very
    common and easy to use.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`操作执行值或类型的转换，它们非常常见且易于使用。'
- en: '`filter()`, in the same way as many similar operations, executes a predicate
    (a function with a Boolean return value) in order to determine whether an element
    is to be included in the output. Examples are `find()`, `take_while()`, `skip_while()`,
    and `any()`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`与许多类似操作一样，执行一个谓词（一个返回布尔值的函数），以确定一个元素是否应该包含在输出中。例如`find()`、`take_while()`、`skip_while()`和`any()`。'
- en: Aggregation functions such as `fold()`, `sum()`, `min()`, and `max()` are used
    to reduce the entire iterator's contents into a single object. That could be a
    number (`sum()`) or a hash map (for example, by using `fold()`).
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合函数，如`fold()`、`sum()`、`min()`和`max()`，用于将整个迭代器的所有内容缩减为一个单一的对象。这可能是一个数字（例如`sum()`）或者一个哈希表（例如，通过使用`fold()`）。
- en: '`chain()`, `zip()`, `fuse()`, and many more combine iterators so that they
    can be iterated over in a single loop. Typically, we use these if multiple run-throughs
    are otherwise required.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chain()`、`zip()`、`fuse()`以及许多其他操作将迭代器组合起来，以便可以在单个循环中迭代。通常，我们使用这些操作是因为在其他情况下可能需要多次遍历。'
- en: 'This more functional style of programming not only reduces the amount of code
    that has to be written, but also acts as a universal vocabulary: instead of reading
    through the entire `for` loop that pushes items into a previously defined list
    if a condition applies, a function call to `filter()` tells the reader what to
    expect. *Steps 2* and *3* show different function invocations to transform (*Step
    2*) or filter (*Step 3*) collections based on various use cases.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更函数式的编程风格不仅减少了需要编写的代码量，还充当了一个通用词汇表：在条件适用时，不是通过遍历整个将项目推入先前定义列表的`for`循环，而是对`filter()`的函数调用告诉读者可以期待什么。*步骤2*和*步骤3*展示了根据不同用例转换（*步骤2*）或过滤（*步骤3*）集合的不同函数调用。
- en: Additionally, iterators can be chained together, so a call to `iterator.filter().map().fold()` is
    not unusual and typically quicker to reason about than a loop that does the same
    thing. As the last step, most iterators are collected into their target collection
    or variable type. `collect()` evaluates the entire chain, which means that its
    execution is costly. Since the entire topic is very specific to the tasks at hand,
    check out the code we wrote and the outcomes/invocations to get the most out of
    it. *Step 4* only shows running the tests, but the real story is inside the code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，迭代器可以被链式连接起来，因此对`iterator.filter().map().fold()`的调用并不罕见，并且通常比执行相同操作的循环更容易理解。作为最后一步，大多数迭代器都被收集到它们的目标集合或变量类型中。`collect()`评估整个链，这意味着它的执行是昂贵的。由于整个主题非常具体于当前的任务，请查看我们编写的代码和结果/调用，以充分利用它。*步骤4*只展示了运行测试，但真正的故事在代码中。
- en: Done! We've successfully learned how to filter and transform sequences efficiently.
    Move on to the next recipe to learn more!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！我们已经成功学习了如何高效地过滤和转换序列。继续学习下一个食谱，了解更多内容！
- en: Reading memory the unsafe way
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以不安全的方式读取内存。
- en: '`unsafe` is a concept in Rust where some compiler safety mechanisms are turned
    off. These **superpowers** bring Rust closer to C''s abilities to manipulate (almost)
    arbitrary parts of the memory. `unsafe` itself qualifies a scope (or function)
    to be able to use these four superpowers (from [https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)
    ):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe`是Rust中的一个概念，其中一些编译器安全机制被关闭。这些**超能力**使Rust更接近C语言操纵（几乎）任意内存部分的能力。`unsafe`本身使一个作用域（或函数）能够使用这四种超能力（参见[https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)）：'
- en: Dereference a raw pointer.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消原始指针的引用。
- en: Call an `unsafe` function or method.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个`unsafe`函数或方法。
- en: Access or modify a mutable static variable.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问或修改一个可变静态变量。
- en: Implement an unsafe trait.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个不安全的特性。
- en: In most projects, `unsafe` is only required for using the **FFI** (short for
    **Foreign Function Interface**) because it's outside of the borrow checker's reach.
    Regardless, in this recipe, we are going to explore some unsafe ways to read memory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数项目中，`unsafe` 只需要用于使用 **FFI**（即 **Foreign Function Interface**），因为它超出了借用检查器的范围。无论如何，在这个菜谱中，我们将探索一些读取内存的
    `unsafe` 方法。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In just a few steps, we are `unsafe`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个步骤，我们就会进入 `unsafe` 状态：
- en: Create a new library project using `cargo new unsafe-ways --lib`. Open the project
    using Visual Studio Code or another editor.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new unsafe-ways --lib` 创建一个新的库项目。使用 Visual Studio Code 或其他编辑器打开该项目。
- en: 'Open `src/libr.rs` to add the following function before the test module:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/libr.rs` 在测试模块之前添加以下函数：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With that ready, we now have to add some tests inside `mod tests {}`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备就绪后，我们现在必须在 `mod tests {}` 中添加一些测试：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Recalling the `unsafe` superpowers, we could try and change the way we are
    reading memory. Let''s add this test to see how it works:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回忆一下 `unsafe` 的超级能力，我们可以尝试改变读取内存的方式。让我们添加这个测试来看看它是如何工作的：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last step is to see the positive test results after running `cargo test`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在运行 `cargo test` 后查看积极的测试结果：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Safety is an important concept in Rust, so let's find out what we trade off
    by using `unsafe`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是 Rust 中的一个重要概念，让我们来看看使用 `unsafe` 我们会做出哪些权衡。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While `unsafe` is one way to enable easier solutions to sometimes tricky situations,
    this book ([https://rust-unofficial.github.io/too-many-lists/index.html](https://rust-unofficial.github.io/too-many-lists/index.html))
    describes the limitations of safe programming perfectly with something as simple
    as a linked list.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `unsafe` 是一种在某种程度上使解决方案更简单的方法，但这本书 ([https://rust-unofficial.github.io/too-many-lists/index.html](https://rust-unofficial.github.io/too-many-lists/index.html))
    通过像链表这样简单的东西完美地描述了安全编程的限制。
- en: Rust is a safe programming language, which means that the compiler makes sure
    that all the memory is accounted for. Thus, it is impossible for programs to obtain
    multiple mutable references to the same memory address, use memory after it has
    been freed, or incorrect type safety, among other things. This lets Rust avoid
    undefined behavior. For some limited use cases, however, these constraints prohibit
    valid use cases, which is why `unsafe` loosens some of these guarantees to accommodate
    some of the things only C would allow.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种安全的编程语言，这意味着编译器会确保所有内存都被计算在内。因此，程序不可能获得同一内存地址的多个可变引用，使用已释放的内存，或者出现类型安全问题等。这使
    Rust 能够避免未定义的行为。然而，对于一些有限的使用场景，这些约束禁止了有效的使用案例，这就是为什么 `unsafe` 会放宽一些保证，以适应一些只有
    C 语言才允许的操作。
- en: After setting up the project in *Step 1*, we are adding the first function in
    *Step 2*. Its purpose is similar to `chunks()` ([https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut](https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut)),
    but instead of an iterator, we are returning the entire collection right away,
    which is OK as an example, but should be thought about when implementing it for
    production use. Our function splits a provided (mutable) slice into a `parts`
    number of chunks of equal size and returns mutable references to them. Since the
    input is also a mutable reference to the entire part of the memory, we will have
    `parts + 1` number of mutable references to the same memory area; clearly, a violation
    of safe Rust! On top of that, this function allows going beyond the allocated
    memory with the `ptr.offset()` call (which does pointer arithmetic).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中设置好项目后，我们在 *步骤 2* 中添加第一个函数。它的目的是类似于 `chunks()` ([https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut](https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut))，但与迭代器不同，我们立即返回整个集合，这在示例中是可以的，但在实现生产版本时应该考虑。我们的函数将提供的（可变）切片分割成
    `parts` 个大小相等的块，并返回对它们的可变引用。由于输入也是对整个内存部分的可变引用，因此我们将有 `parts + 1` 个对同一内存区域的可变引用；显然，这是违反了安全的
    Rust！此外，这个函数还允许使用 `ptr.offset()` 调用超出分配的内存（这涉及到指针算术）。
- en: 'In the test created in *Step 3*, we show that it compiles and executes without
    any major problems. *Step 4* provides another example for unsafe code: changing
    the data type without casting. The `transmute` ([https://doc.rust-lang.org/std/mem/fn.transmute.html](https://doc.rust-lang.org/std/mem/fn.transmute.html))
    function can easily change the data type of a variable with all the consequences
    that come with that. Had we changed the type to something else, such as `u64`,
    we would end up with a totally different result and read memory that does not
    belong to the program. In *Step 5*, we run the whole test suite.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中创建的测试中，我们展示了它编译和执行没有出现任何重大问题。*步骤 4* 提供了另一个不安全代码的例子：不进行类型转换更改数据类型。`transmute`
    ([https://doc.rust-lang.org/std/mem/fn.transmute.html](https://doc.rust-lang.org/std/mem/fn.transmute.html))
    函数可以轻松地更改变量的数据类型，并带来所有随之而来的后果。如果我们把类型改为其他类型，比如 `u64`，我们最终会得到一个完全不同的结果，并读取不属于程序的内存。在
    *步骤 5* 中，我们运行整个测试套件。
- en: '`unsafe` Rust can be interesting to get that last bit of performance out of
    a data structure, do some magic bin-packing, or to implement `Send` and `Sync` ([https://doc.rust-lang.org/std/mem/fn.transmute.html](https://doc.rust-lang.org/std/mem/fn.transmute.html)).
    Whatever you intend to do with `unsafe`, check out the nomicon ([https://doc.rust-lang.org/nightly/nomicon/](https://doc.rust-lang.org/nightly/nomicon/))
    to delve deeper into the depths.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe` Rust 可以用来从数据结构中获取最后一点性能，进行一些神奇的二进制打包，或者实现 `Send` 和 `Sync` ([https://doc.rust-lang.org/std/mem/fn.transmute.html](https://doc.rust-lang.org/std/mem/fn.transmute.html))。无论你打算用
    `unsafe` 做什么，查看 nomicon ([https://doc.rust-lang.org/nightly/nomicon/](https://doc.rust-lang.org/nightly/nomicon/))
    以深入了解其深度。'
- en: Equipped with that knowledge, let's move on to the next recipe.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有了这些知识，让我们继续下一个菜谱。
- en: Shared ownership
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享所有权
- en: 'Ownership and borrowing are fundamental concepts in Rust; they are the reason
    no runtime garbage collection is required. As a quick primer: how do they work?
    In short: scopes. Rust (and many other languages) use (nested) scopes to determine
    the validity of a variable, so it cannot be used outside of the scope (like a
    function). In Rust, these scopes *own* their variables, so they will be gone after
    the scope finishes. In order for the program to *move* around values, it can transfer
    ownership to a nested scope or return it to the parent scope.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权和借用是 Rust 的基本概念；它们是无需运行时垃圾回收的原因。作为一个快速入门：它们是如何工作的？简而言之：作用域。Rust（以及许多其他语言）使用（嵌套）作用域来确定变量的有效性，因此它不能在作用域之外使用（如函数）。在
    Rust 中，这些作用域 *拥有* 它们的变量，因此当作用域结束时它们将消失。为了使程序能够 *移动* 值，它可以将其所有权转移到嵌套作用域或返回给父作用域。
- en: For temporary transfers (and multiple viewers), Rust has **borrowing**, which
    creates a reference back to the owned value. However, these references are less
    powerful, and sometimes more complex to maintain (for example, can the reference
    outlive the original value?), and they are probably the reason why the compiler
    complains.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于临时转移（和多用户查看），Rust 有 **借用**，它创建了一个指向拥有值的引用。然而，这些引用功能较弱，有时更复杂，难以维护（例如，引用能否比原始值存活得更久？），这可能是编译器抱怨的原因。
- en: In this recipe, we are getting around this problem by sharing ownership using
    a reference counter that only drops the variable after the counter reaches zero.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们通过使用引用计数器来共享所有权，只有当计数器达到零时才会丢弃变量，来解决这个问题。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using `new sharing-ownership --lib`, create a new library project and open the
    directory in your favorite editor. We will also use the `nightly` compiler for
    benchmarks, so running `rustup default nightly` is highly recommended.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `new sharing-ownership --lib` 创建一个新的库项目，并在你最喜欢的编辑器中打开该目录。我们还将使用 `nightly`
    编译器进行基准测试，因此强烈建议运行 `rustup default nightly`。
- en: To enable benchmarks, add `#![feature(test)]` to the top of the `lib.rs` file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用基准测试，请将 `#![feature(test)]` 添加到 `lib.rs` 文件的顶部。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Understanding shared ownership only requires eight steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 理解共享所有权只需要八个步骤：
- en: 'In the fairly young ecosystem that is Rust, APIs and function signatures are
    not always the most efficient, especially when they require somewhat advanced
    knowledge of memory layout. So, consider a simple `length` function (add it to
    the `mod tests` scope):'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相对年轻的 Rust 生态系统里，API 和函数签名并不总是最有效的，尤其是在它们需要一定的内存布局知识时。因此，考虑一个简单的 `length` 函数（将其添加到
    `mod tests` 范围内）：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: While unnecessary, the function requires that you pass your owned variable to
    the scope.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需的，但该函数要求你将你的拥有变量传递到作用域内。
- en: 'Luckily, the `clone()` function is ready for you if you still need ownership
    after the function call. This is similar to a loop, by the way, where ownership
    is moved in the first iteration, which means it is **gone** by the second iteration—leading
    to a compiler error. Let''s add a simple test to illustrate these moves:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，如果你在函数调用后仍然需要所有权，`clone()` 函数已经为你准备好了。顺便说一句，这类似于一个循环，在第一次迭代中所有权被移动，这意味着在第二次迭代时它就**消失了**——导致编译器错误。让我们添加一个简单的测试来展示这些移动：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This works, but creates a lot of clones of a string, only then to drop it shortly
    after. This leads to wasting resources and, with large enough strings, slows down
    the program. To establish a baseline, let''s check this by adding a benchmark:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可行，但会创建大量字符串的副本，然后很快就会丢弃它们。这会导致资源浪费，并且对于足够大的字符串，会减慢程序的速度。为了建立一个基线，让我们通过添加基准测试来检查这一点：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Some APIs require ownership of the input variables without a semantic meaning.
    For example, the `length` function from *Step 1* pretends to require variable
    ownership, but unless mutability is also necessary, Rust''s `std::rc::Rc` (short
    for **Reference Counted**) type is a great choice for avoiding heavyweight cloning
    or taking away ownership from the calling scope. Let''s try it out by creating
    a better `length` function:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些 API 需要输入变量的所有权，但没有语义意义。例如，*步骤 1*中的 `length` 函数假装需要变量所有权，但除非可变性也是必要的，否则 Rust
    的 `std::rc::Rc`（简称**引用计数**）类型是一个很好的选择，可以避免重量级克隆或从调用范围中移除所有权。让我们通过创建一个更好的 `length`
    函数来试试看：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now continue to use the `owned` type after passing it into the function:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在将类型传递到函数之后继续使用 `owned` 类型：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After we have created a baseline benchmark, we certainly want to know how well
    the `Rc` version fares:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建了一个基线基准测试之后，我们当然想知道 `Rc` 版本的表现如何：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'First, we should check whether the implementations are correct by running `cargo
    test`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该通过运行 `cargo test` 来检查实现是否正确：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can check which variation is faster, and what the differences are:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以检查哪种变体更快，以及它们之间的区别：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After we have explored shared ownership with `Rc`, let's go behind the scenes
    to understand them better.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索了 `Rc` 的共享所有权之后，让我们深入了解它们。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The impressive benchmark results are no accident: `Rc` objects are smart pointers
    to locations on the heap, and while we still call clone to do a *deep copy*, `Rc`
    only duplicates a pointer and increments the number of references to it. While
    the actual example function is kept simple so that we don''t have to worry about
    it, it does have all the properties of complex functions we often encounter. We
    define the first version, which only works with owned memory (the input parameter
    is not a reference), in *Step 1*. *Steps 2* and *3* show the consequences of the
    API chosen in *Step 1*: we need to call the clone function if we want to keep
    (a copy of) the data we pass in.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 令人印象深刻的基准测试结果并非偶然：`Rc` 对象是堆上位置的智能指针，尽管我们仍然调用 `clone` 来进行**深拷贝**，但 `Rc` 只会复制一个指针并增加对其的引用计数。而实际示例函数保持简单，这样我们就不必担心它，但它确实具有我们经常遇到的复杂函数的所有特性。我们在*步骤
    1*中定义了第一个版本，它只适用于拥有内存（输入参数不是引用），在*步骤 2*和*步骤 3*中展示了*步骤 1*中选择的 API 的后果：如果我们想保留（传递数据的）数据副本，我们需要调用
    `clone` 函数。
- en: In *Steps 4* to *6,* we do the equivalent with a Rust construct called `Rc`.
    Having ownership of one of those means that you own the pointer location, but
    not the actual value, which makes the entire construct very lightweight. In fact,
    allocating the memory for the original value once and pointing to it from multiple
    locations is a common way to improve performance in applications that require
    a lot of moving around of a string. This is a result that can be observed in *Steps
    7* and *8*, where we execute tests and benchmarks.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*到*步骤 6*中，我们使用 Rust 中的一个称为 `Rc` 的构造函数做等效操作。拥有其中之一意味着你拥有指针位置的所有权，但不是实际值，这使得整个构造非常轻量。实际上，一次为原始值分配内存并从多个位置指向它是提高需要大量移动字符串的应用程序性能的常见方法。这在*步骤
    7*和*步骤 8*中可以观察到，在那里我们执行测试和基准测试。
- en: One caveat remains. `Rc` constructs do not allow for mutable ownership, something
    that we'll solve in the next recipe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一个注意事项。`Rc` 构造函数不允许可变所有权，这个问题我们将在下一个菜谱中解决。
- en: Shared mutable ownership
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享可变所有权
- en: Sharing ownership is great for read-only data. However, mutability is sometimes
    required, and Rust provides a great way to achieve this. If you recall the rules
    of ownership and borrowing, if there is a mutable reference, it has to be the
    only reference to avoid anomalies.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 共享所有权对于只读数据来说很棒。然而，有时需要可变性，Rust提供了一种实现这一点的绝佳方式。如果你还记得所有权和借用规则，如果有一个可变引用，它必须是唯一的引用，以避免异常。
- en: 'This is typically where the borrow checker comes in: at compile time, it makes
    sure that the condition holds true. This is where Rust introduces the pattern
    of interior mutability. By wrapping the data into a `RefCell` or `Cell`-type object,
    immutable and mutable access can be handed out dynamically. Let''s see how this
    works in practice.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是借用检查器介入的地方：在编译时，它确保条件成立。这是Rust引入内部可变性模式的地方。通过将数据包装进`RefCell`或`Cell`类型的对象中，可以动态地分配不可变和可变访问。让我们看看这在实践中是如何工作的。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new library project using `cargo new --lib mut-shared-ownership` and
    open `src/lib.rs` in your favorite editor. To enable benchmarks, please switch
    to `nightly` Rust using `rustup default nightly`, and add `#![feature(test)]` (which
    facilitates the use of the types required for benchmark-type tests) at the top
    of the `lib.rs` file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo new --lib mut-shared-ownership`创建一个新的库项目，并在你喜欢的编辑器中打开`src/lib.rs`。为了启用基准测试，请使用`rustup
    default nightly`切换到`nightly` Rust，并在`lib.rs`文件的顶部添加`#![feature(test)]`（这有助于使用基准测试类型所需的类型）。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create a test to establish the best way to share mutable ownership in
    just a few steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个测试，以在几个步骤中确定共享可变所有权的最佳方式：
- en: 'Let''s create a couple of new functions inside the testing module:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在测试模块内部创建几个新函数：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'These functions dynamically (based on incoming data) mutate a list of integers
    to fit a particular condition (such as the sum needs to be at least *X*) and rely
    on three ways of sharing mutable ownership. Let''s explore how these behave on
    the outside! `Cell` objects (and `RefCell` objects) are simply wrappers that either
    return a reference or ownership of a value:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些函数根据传入的数据动态地（基于特定条件，如总和至少需要是*X*）修改整数列表，并依赖于三种共享可变所有权的方式。让我们探索这些在外部是如何表现的！`Cell`对象（以及`RefCell`对象）只是返回值的引用或所有权的包装器：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Since this seems very familiar to other programming languages, where references
    can be passed around freely, we should also know the caveats. One important aspect
    is that these `Cell` threads panic if the borrow check fails, which brings the
    current thread at least to a sudden halt. In a few lines of code, this is what
    this looks like:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这与其他编程语言非常相似，在这些语言中可以自由传递引用，我们也应该知道其注意事项。一个重要的方面是，如果借用检查失败，这些`Cell`线程会引发恐慌，这至少会使当前线程突然停止。在几行代码中，这看起来是这样的：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Intuitively, these cells should add runtime overhead and thereby be slower
    than a regular – precompiled – borrow check. In order to confirm this, let''s
    add a benchmark:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直观地看，这些单元格应该会增加运行时开销，因此比常规的预编译借用检查要慢。为了确认这一点，让我们添加一个基准测试：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'However, we did not address the dangers of unforeseen panics in `Cell`, which
    might be prohibitive in complex applications. This is where `Cow` comes in. `Cow`
    is a **Copy-on-Write** type that replaces the value it wraps by lazily cloning
    if mutable access is requested. By using this `struct`, we can be certain to avoid
    panics with this code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们没有解决`Cell`中未预见的恐慌的危险，这在复杂的应用中可能是禁止性的。这就是`Cow`出现的地方。`Cow`是一种**写时复制（Copy-on-Write）**类型，如果请求可变访问，它会通过惰性克隆来替换它所包装的值。通过使用这个`struct`，我们可以确保避免使用此代码时的恐慌：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Lastly, let''s verify that the tests and benchmarks are successful by running
    `cargo test`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过运行`cargo test`来验证测试和基准是否成功：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s see the benchmark timings in the output of `cargo bench`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`cargo bench`输出的基准时间：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Sharing memory in various ways is complex, so let's dive deeper into how they
    work.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以各种方式共享内存是复杂的，所以让我们更深入地了解它们是如何工作的。
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe is set up like a large benchmark or testing scheme: in *Step 1*,
    we define the functions to be tested, each with different input parameters, but
    the same behavior; it fills `Vec` up to a minimum sum. These parameters reflect
    different ways of sharing ownership, including `RefCell`, `Cell`, and `Cow`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱就像一个大的基准或测试方案：在*步骤1*中，我们定义要测试的函数，每个函数都有不同的输入参数，但具有相同的行为；它将`Vec`填充到最小总和。这些参数反映了不同的共享所有权方式，包括`RefCell`、`Cell`和`Cow`。
- en: '*Steps 2* and *3* create tests that work exclusively on the different ways
    adopted by `RefCell` and `Cell` of handling and failing these values. *Step 5*
    does something similar to the `Cow` type; all are great opportunities to test
    out your own theories as well!'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*和*步骤3*创建了仅针对`RefCell`和`Cell`采用的不同方式处理和失败这些值的测试。*步骤5*与`Cow`类型类似；这些都是测试您自己理论的绝佳机会！'
- en: In *Steps 4* and *6*, we are creating and running benchmarks and tests on the
    functions we created in this recipe. The results are surprising. In fact, we tried
    different computers and versions and arrived at the same conclusion: `RefCell`
    is almost as fast as the regular way of retrieving a mutable reference (the runtime
    behavior results in a higher variance). The `Cell` parameter's slowdown is also
    expected; they move the entire data in and out at every iteration—and this is
    what we can also expect from `Cow`, so feel free to try it out yourself.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*和*步骤6*中，我们正在创建和运行我们在本菜谱中创建的函数的基准测试和测试。结果是令人惊讶的。事实上，我们尝试了不同的计算机和版本，并得出相同的结论：`RefCell`几乎与常规方式检索可变引用（运行时行为导致更高的方差）一样快。`Cell`参数的减速也是预期的；它们在每次迭代中都将整个数据移入和移出——这也是我们可以从`Cow`期望的，所以请随意尝试它。
- en: Both `Cell` objects and `RefCell` objects move the data onto the heap memory
    and use references (pointers) to get to these values, often requiring an extra
    jump. However, they offer a similar way of moving object references around with
    the comfort of C#, Java, or other such languages.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cell`对象和`RefCell`对象将数据移动到堆内存，并使用引用（指针）来访问这些值，通常需要额外的跳跃。然而，它们提供了与C#、Java或其他类似语言相似的方式来移动对象引用，同时提供了舒适度。'
- en: We hope you have successfully learned about shared mutable ownership. Now, let's
    move on to the next recipe.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您已经成功学习了关于共享可变所有权的知识。现在，让我们继续到下一个菜谱。
- en: Referencing with explicit lifetimes
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式生命周期进行引用
- en: Lifetimes are common in many languages and typically decide whether a variable
    is available outside the scope. In Rust, the situation is a bit more complicated
    thanks to the borrowing and ownership model that extensively uses lifetimes and
    scopes to automatically manage memory. Instead of reserving memory and cloning
    stuff into it, we developers want to avoid the inefficiencies and potential slowdowns
    this causes with references. However, this leads down a tricky path because, as
    the original value goes out of scope, what happens to the reference?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期在许多语言中都很常见，通常决定一个变量是否可以在作用域外使用。在Rust中，由于借用和所有权模型广泛使用生命周期和作用域来自动管理内存，所以情况要复杂一些。我们开发者想要避免保留内存并将内容克隆到其中的低效和潜在的减速，而不是使用引用。然而，这会导致一条棘手的路径，因为当原始值超出作用域时，引用会发生什么？
- en: Since the compiler cannot infer this information from code, you have to help
    it and annotate the code so it can go and check for proper usage. Let's see what
    this looks like.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器无法从代码中推断出这些信息，您必须帮助它并注释代码，以便它可以检查正确的使用。让我们看看这会是什么样子。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Lifetimes can be explored in a few steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期可以通过几个步骤来探索：
- en: Create a new project using `cargo new lifetimes --lib` and open it in your favorite
    editor.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new lifetimes --lib`创建一个新的项目，并在您喜欢的编辑器中打开它。
- en: 'Let''s start with a simple function that takes in a reference that might not
    outlive the function! Let''s make sure that the function and the input parameter
    are on the same lifetime:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的函数开始，该函数接受一个可能不会比函数长寿的引用！让我们确保函数和输入参数具有相同的生命周期：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Where the lifetime declaration is required is in structs. Therefore, we define
    the base `struct` first. It comes with a lifetime annotation for the type it contains:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结构体中需要声明生命周期。因此，我们首先定义基础`struct`。它为包含的类型提供了生命周期注解：
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'What follows is the implementation, which continues the lifetime specifications.
    First, we implement the constructor (`new()`):'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是实现，它继续了生命周期规范。首先，我们实现构造函数（`new()`）：
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we want to implement the variance calculation along with the standard
    deviation and the mean:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们希望实现方差计算以及标准差和平均值：
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As a final operation, we add the median calculation:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的操作，我们添加了中位数计算：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And that''s it! Some tests are required so that we can be certain everything
    works as expected. Let''s start with a few helper functions and a test for calculating
    the mean:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！需要一些测试以确保我们可以确信一切按预期工作。让我们从几个辅助函数和计算平均值的测试开始：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we perform some testing on the new function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对新函数进行一些测试：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, let''s test the actual statistics. In a single function, we are starting
    with some special input data:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试实际的统计数据。在一个函数中，我们开始使用一些特殊的数据输入：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order to check more sophisticated input data (for example, skewed distributions
    or edge cases), let''s expand the test further:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查更复杂的数据输入（例如，偏斜分布或边缘情况），让我们进一步扩展测试：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Use `cargo test` to run the tests and verify that they are successful:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo test`运行测试并验证它们是否成功：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Working with lifetimes is complex, so let's go behind the scenes to understand
    the code better.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与生命周期一起工作很复杂，所以让我们深入了解代码以更好地理解。
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a simple statistics toolbox that allows normal distribution
    samples to be analyzed quickly and accurately. However, this example was only
    chosen to illustrate the ways of how lifetimes are useful and comparatively simple.
    In *Step 2*, we are creating a function to calculate the mean of a given collection.
    Since lifetimes can be inferred from using the functions/variables, explicit specification
    of the lifetime is optional. Nevertheless, the function explicitly ties the input
    parameter's lifetime to the function's lifetime, requiring any reference that
    is passed in to outlive `mean()`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们创建了一个简单的统计工具箱，它允许快速准确地分析正态分布样本。然而，这个例子只是为了说明生命周期的有用性和相对简单的方法。在*步骤2*中，我们创建了一个计算给定集合平均值的函数。由于生命周期可以从使用函数/变量中推断出来，因此显式指定生命周期是可选的。尽管如此，该函数明确地将输入参数的生命周期绑定到函数的生命周期，要求任何传入的引用都要比`mean()`长命。
- en: '*Steps 3* and *4* show how to deal with lifetimes in structs and their implementations.
    Since type instances can easily outlive the references they store (and each could
    even require a different lifetime), the explicit specification of the lifetimes
    becomes necessary. The lifetimes have to be stated every step of the way; in the
    struct declaration, in the `impl` block, and in the functions they are used with.
    The lifetime''s name binds them together. In a way, it creates a virtual scope
    bound to the type instance''s life.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3*和*步骤4*展示了如何在结构体及其实现中处理生命周期。由于类型实例可以很容易地比存储的引用长命（每个甚至可能需要不同的生命周期），因此显式指定生命周期变得必要。生命周期必须在每一步中声明；在结构体声明中，在`impl`块中，以及在使用它们的函数中。生命周期的名称将它们绑定在一起。从某种意义上说，它创建了一个与类型实例的生命周期相关的虚拟作用域。'
- en: Lifetime annotations are useful but verbose, which makes working with references
    sometimes cumbersome. However, once the annotations are in place, the program
    can be much more efficient and the interfaces can be a lot more convenient, removing
    `clone()` method and other things.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期注解很有用但很冗长，这使得处理引用有时很繁琐。然而，一旦注解到位，程序可以更加高效，接口可以更加方便，移除`clone()`方法和其他东西。
- en: The choice for the lifetime name (`'a`) is common, but arbitrary. Other than
    the predefined `'static`, every word works just as fine and a readable choice
    is definitely better.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期名称的选择（`'a'`）是常见的，但也是任意的。除了预定义的`'static'`之外，每个单词都同样适用，而且可读的选择绝对更好。
- en: Working with explicit lifetimes was not too hard, right? We recommend that you
    keep on experimenting until you are ready to move on to the next recipe.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与显式生命周期一起工作并不太难，对吧？我们建议你继续实验，直到你准备好进入下一个食谱。
- en: Enforcing behavior with trait bounds
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特性界限强制行为
- en: When building a complex architecture, prerequisite behavior is very common.
    In Rust, this means that we cannot build either generic or other types without
    requiring them to conform to some prior behavior, or, in other words, we need
    to be able to specify which traits are required. Trait bounds are one way of doing
    that – and you have seen multiple instances of this already, even if you have
    skipped many recipes so far.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建复杂架构时，先决条件行为非常常见。在Rust中，这意味着我们无法构建泛型或其他类型，除非它们符合某些先前的行为，换句话说，我们需要能够指定所需的特性。特性界限是实现这一目标的一种方式——即使你之前跳过了许多食谱，你也已经看到了多个这样的例子。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps to learn more about traits:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习更多关于特性的知识：
- en: Create a new project using `cargo new trait-bounds` and open it in your favorite
    editor.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new trait-bounds`创建一个新的项目，并在你喜欢的编辑器中打开它。
- en: 'Edit `src/main.rs` to add the following code, where we can easily print a variable''s
    debug format since an implementation of that format is required on compilation:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/main.rs`以添加以下代码，其中我们可以轻松地打印变量的调试格式，因为编译时需要实现该格式：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If we were to call this using a custom type such as `struct AnotherType(usize)`,
    the compiler would quickly complain:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用自定义类型，例如 `struct AnotherType(usize)` 来调用它，编译器会很快抱怨：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In order to fix this, we can either implement or derive the `Debug` trait,
    as it says in the error message. Deriving the implementation is very common for
    compositions of standard types. In traits, the trait bounds get a bit more interesting:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以实现或推导 `Debug` 特质，正如错误信息中所述。对于标准类型的组合，推导实现是非常常见的。在特质中，特质的界限变得更有趣：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can then create and implement a suitable type:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以创建并实现一个合适的数据类型：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, let''s tie the code together in the `main` function:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `main` 函数中将代码串联起来：
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Execute `cargo run` and establish whether the output matches your expectations:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `cargo run` 并确定输出是否符合你的预期：
- en: '[PRE67]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: After creating an example program, let's explore the background for trait bounds.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建示例程序后，让我们探索特质界限的背景。
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Trait bounds specify the requirements of the implementation to implementers.
    In this way, we can call functions on generic types without having a more in-depth
    knowledge of their structures.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 特质界限指定了实现者实现时的要求。通过这种方式，我们可以在不了解其结构的情况下对泛型类型调用函数。
- en: In *Step 2*, we require any parameter type to implement the `std::fmt::Debug`
    trait in order to be able to use the debug formatter for printing. However, that
    does not generalize well, and we have to require that implementation for any *other*
    function as well. That's why, in *Step 4*, we require that any type that implements
    the `Loggable` trait also implements `Debug`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 2 步* 中，我们要求任何参数类型都必须实现 `std::fmt::Debug` 特质，以便能够使用调试格式化程序进行打印。然而，这并不很好地推广，我们还需要要求任何
    *其他* 函数也实现该特性。这就是为什么在 *第 4 步* 中，我们要求任何实现 `Loggable` 特质的类型也实现 `Debug`。
- en: As a result, we can expect to use all the required traits in the trait's functions,
    which makes expansion easier and provides the ability for all types to implement
    the trait to be compatible. In *Step 5* , we are implementing the `Loggable` trait
    for the type we created and using it in the remainder of the steps.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在特质的函数中使用所有必需的特质，这使得扩展更加容易，并提供了所有类型实现特质以保持兼容性的能力。在 *第 5 步* 中，我们正在为创建的类型实现
    `Loggable` 特质，并在后续步骤中使用它。
- en: Decisions regarding the required traits are important for public APIs as well
    as for writing well-designed and maintainable code. Being mindful of what types
    are really required and how to provide them will lead to better interfaces and
    types. Notice also the `+` between two type bounds; it requires both (and more
    if more `+` symbols are added) traits to be present when implementing `Loggable`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所需特质的决策对于公共 API 以及编写良好设计和可维护的代码同样重要。注意真正需要哪些类型以及如何提供它们，这将导致更好的接口和类型。注意两个类型界限之间的
    `+` 符号；它要求在实现 `Loggable` 时存在（以及更多，如果添加了更多的 `+` 符号）这两个（以及更多）特质。
- en: We've successfully learned how to enforce behavior with trait bounds. Now, let's
    move on to the next recipe.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何使用特质界限强制行为。现在，让我们继续下一个菜谱。
- en: Working with generic data types
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与泛型数据类型一起工作
- en: Rust's function overloading is a bit more exotic than in other languages. Instead
    of redefining the same function with a different type signature, you can achieve
    the same result by specifying the actual types for a generic implementation. Generics
    are a great way to provide more general interfaces and are not too complex to
    implement thanks to helpful compiler messages.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的函数重载比其他语言更奇特。你不需要用不同的类型签名重新定义相同的函数，通过指定泛型实现的实际类型，你可以达到相同的结果。泛型是提供更通用接口的绝佳方式，由于编译器的有用消息，实现起来并不复杂。
- en: In this recipe, we are going to implement a dynamic array (such as `Vec<T>`)
    in a generic way.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将以泛型方式实现动态数组（例如 `Vec<T>`）。
- en: How to do it...
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Learn how to use generics in just a few steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个步骤就能学会如何使用泛型：
- en: Start off by creating a new library project with `cargo new generics --lib` and
    open the project folder in Visual Studio Code.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `cargo new generics --lib` 创建一个新的库项目，并在 Visual Studio Code 中打开项目文件夹。
- en: 'A dynamic array is a data structure many of you will use every day. In Rust,
    the implementation is called `Vec<T>`, while other languages know it as `ArrayList`
    or `List`. First, let''s establish the basic structure:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态数组是一种你每天都会使用的数据结构。在 Rust 中，它的实现被称为 `Vec<T>`，而其他语言则称之为 `ArrayList` 或 `List`。首先，让我们建立基本结构：
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As the `struct` definition shows, the main element is a box of type `T`, a
    generic type. Let''s see what the implementation looks like:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如`struct`定义所示，主要元素是一个类型为`T`的盒子，这是一个泛型类型。让我们看看实现看起来像什么：
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'So far, very straightforward. Instead of a type name, we''ll simply use `T`.
    What happens if we wanted to implement a specific type for a generic definition?
    Let''s implement the `Index` operation (a trait in Rust) for the `usize` type. Additionally,
    a `clone` operation will become very helpful in the future, so let''s add that
    too:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，非常直接。我们不会使用类型名称，而是简单地使用`T`。如果我们想为泛型定义实现一个特定类型，会发生什么？让我们为`usize`类型实现`Index`操作（Rust中的一个特质）。此外，一个`clone`操作在将来会非常有帮助，所以让我们也添加那个：
- en: '[PRE70]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In order to be certain that all of this works and we did not make any mistakes,
    let''s start with a few tests for each implemented function:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保所有这些都能正常工作，我们没有犯任何错误，让我们为每个实现的功能进行一些测试：
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let''s add some more tests:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加更多的测试：
- en: '[PRE72]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once the tests are implemented, we can run the tests successfully with `cargo
    test`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦实现了测试，我们就可以使用`cargo test`成功运行测试：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, let's look at using generics from behind the scenes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看从幕后使用泛型。
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Generics work very well in Rust and, other than the verbose notation, they are
    very handy. In fact, you will find them all over the place and, as you progress
    in Rust, the need for better, more generic interfaces will increase.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型在Rust中工作得非常好，除了冗长的符号外，它们非常方便。实际上，你会发现它们无处不在，随着你在Rust中的进步，对更好、更通用接口的需求也会增加。
- en: In *Step 2*, we are creating a modified dynamic array (taken from the book *Hand**s-On
    Data Structures and Algorithms with Rust:* [https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-*rust*](https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust))
    that uses a generic type. Using a generic type in code works like any other type,
    writing `T` instead of `i32`. However, as discussed in a previous recipe, the
    compiler expects certain behaviors from the `T` type, such as implementing `Clone`, which
    is specified in the `where` clause of the struct and implementation. In more complex
    use cases, there could be multiple blocks for when `T` implements `Clone` and
    when it doesn't, but that would go beyond the scope of the recipe. *Step 3* shows
    the generic implementation of the dynamic array type and how the `Clone` and `Sized`
    traits come into play.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2步*中，我们正在创建一个修改后的动态数组（来自书籍*《动手学数据结构与算法：Rust语言实现》*：[https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust](https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust)），它使用泛型类型。在代码中使用泛型类型就像使用任何其他类型一样，用`T`代替`i32`。然而，如前所述，编译器期望`T`类型具有某些行为，例如实现`Clone`，这在结构体和实现的`where`子句中指定。在更复杂的使用案例中，可能会有多个块，用于`T`实现`Clone`和未实现`Clone`的情况，但这将超出菜谱的范围。*第3步*显示了动态数组类型的泛型实现以及`Clone`和`Sized`特质如何发挥作用。
- en: When implementing the `Index` trait in *Step 4*, something becomes more obvious.
    First, we specify the `usize` type for the trait implementation header. Therefore,
    this trait is only implemented if someone uses a `usize` variable (or constant/literal)
    for indexing, thereby ruling out any negative values. The second aspect is the
    associated type, which, in itself, has a generic type.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*实现`Index`特质时，某些事情变得更加明显。首先，我们为特质实现头指定`usize`类型。因此，只有当有人使用`usize`变量（或常量/文字）进行索引时，才会实现此特质，从而排除了任何负值。第二个方面是关联类型，它本身具有泛型类型。
- en: Another important aspect of generics is the term `Sized`. Variables in Rust
    are `Sized` when the size is known at compile time, so the compiler knows how
    much memory to allocate. Unsized types have an unknown size at compile time; that
    is, they are dynamically allocated and may grow at runtime. Examples include `str`,
    or slices of type `[T]`. Their actual size can change, which is why they are always
    behind a fixed-size reference, a pointer. If `Sized` is required, only the reference
    to an unsized type can be used (`&str`, `&[T]`), but there is also `?Sized` to
    make this behavior optional.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的一个重要方面是术语`Sized`。当大小在编译时已知时，Rust中的变量是`Sized`的，因此编译器知道要分配多少内存。无尺寸类型在编译时具有未知的大小；也就是说，它们是动态分配的，可能在运行时增长。例如，`str`或类型为`[T]`的切片。它们的实际大小可以改变，这就是为什么它们总是位于一个固定大小的引用之后，即指针。如果需要`Sized`，则只能使用无尺寸类型的引用（`&str`，`&[T]`），但还有`?Sized`来使这种行为可选。
- en: '*Steps 5* and *6* then create some tests and run them. The tests demonstrate
    that the main functions of the dynamic array continue to work, and we encourage
    you to try out any questions you have about the code in there as well.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，*步骤5*和*步骤6*创建一些测试并运行它们。这些测试表明动态数组的主要功能仍然正常工作，我们鼓励你尝试解决其中关于代码的任何疑问。
- en: If you want more details on the dynamic array and why/how it grows (it doubles
    in size, like Java's `ArrayList`), check out *Hands-On Data Structures and Algorithms
    with Rust*, where this dynamic array and other data structures are explained in
    more detail.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于动态数组以及它是如何增长（它的大小会翻倍，就像Java的`ArrayList`一样）的细节，请查看《Rust编程中的动手实践数据结构与算法》，在那里可以更详细地解释这个动态数组以及其他数据结构。
