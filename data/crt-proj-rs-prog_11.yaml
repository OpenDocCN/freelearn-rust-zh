- en: The Future of Rust
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的未来
- en: The buzzword of the 2015 edition of Rust was *stability *because version 1.0
    promised to be compatible with the versions that followed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2015版Rust的热门词汇是*稳定性*，因为1.0版本承诺将与后续版本兼容。
- en: The buzzword of the 2018 edition of Rust was *productivity* because version
    1.31 offered a mature ecosystem of tools that allowed command-line developers
    for desktop operating systems (Linux, Windows, macOS) to be more productive.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 2018版Rust的热门词汇是*生产力*，因为1.31版本提供了一个成熟的工具生态系统，使得桌面操作系统（Linux、Windows、macOS）的命令行开发者可以更加高效。
- en: There is an intent to have a new Rust edition in the coming years, but for this
    edition, neither its release date, nor its features, nor its buzzword is defined
    yet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有意向在未来几年推出一个新的Rust版本，但对于这个版本，其发布日期、功能以及热门词汇都尚未定义。
- en: However, after the release of the 2018 edition, several needs of Rust developers
    are being targeted by Rust ecosystem developers around the world. It is probable
    that the new buzzword will come out of one of these development lines.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在2018版发布后，全球Rust生态系统开发者正在针对Rust开发者的几个需求进行开发。很可能新的热门词汇将出自这些开发路线之一。
- en: 'The most interesting lines of development are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的发展方向如下：
- en: '**Integrated Development Environments** (**IDEs**) and interactive programming'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成开发环境**（**IDEs**）和交互式编程'
- en: Crate maturity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Crate成熟度
- en: Asynchronous programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程
- en: Optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化
- en: Embedded systems
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式系统
- en: 'By the end of this chapter, we will see the most probable developments of the
    Rust ecosystem: the language, the tooling, and the available libraries. You will
    learn what to expect in the next few years.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将看到Rust生态系统最可能的发展方向：语言、工具和可用库。你将了解未来几年可以期待什么。
- en: Two of the most exciting new features of the Rust language are the *asynchronous
    programming* paradigm and the *const generics* language feature. At the end of
    2019, the former was already added to the language, while the latter was still
    under development. This will be explained in this chapter using code examples,
    and so you will get a working knowledge about them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust语言中最激动人心的两个新特性是*异步编程*范式和*const泛型*语言特性。到2019年底，前者已经被添加到语言中，而后者仍在开发中。本章将通过代码示例进行解释，因此你将获得关于它们的实际知识。
- en: IDEs and interactive programming
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDEs和交互式编程
- en: A lot of developers prefer to work inside a graphical application that contains
    or orchestrates all the development tools, instead of using terminal command lines.
    Such graphical applications are usually named **Development Environments**—or
    **DEs** for short.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者更喜欢在包含或协调所有开发工具的图形应用程序中工作，而不是使用终端命令行。这类图形应用程序通常被称为**开发环境**——或简称**DEs**。
- en: 'At present, the most popular IDEs are probably the following ones:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，最受欢迎的IDE可能是以下这些：
- en: '**Eclipse**: This is used mainly for development in the Java language.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse**: 这主要用于Java语言的开发。'
- en: '**Visual Studio**: This is used mainly for development in the C# and Visual
    Basic languages.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio**: 这主要用于C#和Visual Basic语言的开发。'
- en: '**Visual Studio Code**: This is used mainly for development in the JavaScript
    language.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**: 这主要用于JavaScript语言的开发。'
- en: In the 20th century, it was typical to create an IDE from scratch for a single
    programming language. That was a major task, though. Therefore, in the last decades,
    it has become more typical to create customizable IDEs, and then to add extensions
    (or plugins) to support specific programming languages. For most programming languages,
    there is at least one mature extension for a popular IDE. However, in 2018, Rust
    had very limited IDE support, meaning that there were some extensions to use Rust
    in a pair of IDEs but they offered few features, bad performance, and were also
    rather buggy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪，为单一编程语言从头开始创建IDE是典型的做法。但这确实是一项重大任务。因此，在过去的几十年里，创建可定制的IDE变得更加典型，然后添加扩展（或插件）以支持特定的编程语言。对于大多数编程语言，至少有一个成熟的扩展用于流行的IDE。然而，在2018年，Rust的IDE支持非常有限，这意味着有一些扩展可以在一对IDE中使用Rust，但它们提供的功能很少，性能不佳，而且也存在很多错误。
- en: In addition, many programmers prefer an interactive development style. When
    creating a new feature of a software system, they do not like to write a lot of
    software and then compile and test all of it. Instead, they prefer to write a
    single line or a bunch of few lines and test such snippets of code right away.
    After testing that snippet of code successfully, they integrate it into the rest
    of the system. This is typical of developers using interpreted languages such
    as JavaScript or Python.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多程序员更喜欢交互式开发风格。在创建一个软件系统的新功能时，他们不喜欢写很多软件然后编译和测试所有这些。相反，他们更喜欢写一行或几行代码，并立即测试这些代码片段。在成功测试这些代码片段后，他们将它们集成到系统的其余部分。这对于使用JavaScript或Python等解释型语言的开发者来说是典型的。
- en: The tools that are able to run snippets of code are **language interpreters**
    or **fast in-memory compilers**. Such interpreters read a command from the user,
    evaluate it, print the result, and go back to the first step. Therefore, they
    are usually named **read-eval-print loop**, or **REPL** for short. For all interpreted
    programming languages, and for some compiled languages, there are mature REPLs.
    In 2018, the Rust ecosystem was missing a mature REPL.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 能够运行代码片段的工具是**语言解释器**或**快速内存编译器**。这样的解释器从用户那里读取命令，评估它，打印结果，然后回到第一步。因此，它们通常被称为**读取-评估-打印循环**，或简称**REPL**。对于所有解释型编程语言，以及一些编译型语言，都有成熟的REPL。在2018年，Rust生态系统缺少一个成熟的REPL。
- en: 'Here, the IDE issue and the REPL issue are presented together because they
    share the following common problem. The main feature of modern IDEs is to analyze
    source code as it is edited, with the following goals:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，IDE问题和REPL问题一起提出，因为它们存在以下共同问题。现代IDE的主要功能是在编辑源代码时进行分析，以下目标是：
- en: To highlight the code containing invalid syntax, and to display a compilation
    error message in a popup window that appears near the invalid code
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了突出显示包含无效语法的代码，并在靠近无效代码的弹出窗口中显示编译错误消息
- en: To suggest the completion of identifiers, to be chosen among the already declared
    identifiers
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了建议完成标识符，从已声明的标识符中选择
- en: To show the synopsis documentation of an identifier selected in the editor
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示在编辑器中选定的标识符的概要文档
- en: To jump in the editor from the definition of an identifier to its uses, or vice
    versa
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从标识符的定义跳转到其使用，或反之亦然
- en: In a debugging session, to evaluate an expression inside the current context,
    or to change the memory contents owned by a variable
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试会话中，评估当前上下文中的表达式，或更改变量的内存内容
- en: Such operations require very fast parsing of Rust code, and this is also what
    is required by a Rust REPL. An attempt to address such issues is a project named
    the **Rust Language Server** ([https://github.com/rust-lang/rls](https://github.com/rust-lang/rls))
    that is developed by the Rust language team. Another attempt is the project named
    **Rust Analyzer** ([https://github.com/rust-analyzer/rust-analyzer](https://github.com/rust-analyzer/rust-analyzer))
    that is developed by the Ferrous Systems company, supported by several partners.
    Hopefully, before the next Rust edition, there will be a fast and powerful Rust
    language analyzer to support smart programmers' editors, source-level debuggers,
    and REPL tools, just as many other programming languages have.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作需要非常快速地解析Rust代码，这也是Rust REPL所需的功能。解决此类问题的尝试是一个名为**Rust语言服务器**（[https://github.com/rust-lang/rls](https://github.com/rust-lang/rls)）的项目，该项目由Rust语言团队开发。另一个尝试是由Ferrous
    Systems公司开发的名为**Rust Analyzer**（[https://github.com/rust-analyzer/rust-analyzer](https://github.com/rust-analyzer/rust-analyzer)）的项目，由几家合作伙伴支持。希望在下一次Rust版本发布之前，会有一个快速且强大的Rust语言分析器来支持智能程序员的编辑器、源级调试器和REPL工具，就像许多其他编程语言一样。
- en: Crate maturity
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Crate成熟度
- en: A crate becomes mature when it reaches *version 1.0*. That milestone means that
    the following versions 1.x will be compatible with it. Instead, for versions 0.x,
    there is no such guarantee, and any version can have an **application programming
    interface** (**API**) that's quite different from the previous one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个crate达到*版本1.0*时，它就变得成熟。这个里程碑意味着后续的1.x版本将与它兼容。相反，对于0.x版本，没有这样的保证，任何版本都可能有一个与上一个版本相当不同的**应用程序编程接口**（**API**）。
- en: 'Having a mature version is important for several reasons, listed as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个成熟的版本对于几个原因很重要，以下列出：
- en: When you upgrade your dependency to a newer version of a crate (to use new features
    of that library), you are guaranteed that your existing code won't get broken—that
    is, it will continue to behave in a previous way, or in a better way. Without
    such a guarantee, you typically need to review all your code using that crate
    and fix all the incompatibilities.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您将依赖项升级到crate的新版本（以使用该库的新功能）时，您可以保证现有的代码不会损坏——也就是说，它将继续以先前的方式，或者以更好的方式运行。没有这样的保证，您通常需要审查使用该crate的所有代码，并修复所有不兼容性。
- en: Your investment in know-how is preserved. You need to neither retrain yourself
    nor your coworkers and not even update your documentation.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在知识技能上的投资得到了保留。您无需重新培训自己或您的同事，甚至无需更新您的文档。
- en: Typically, software quality is improved. If a version of an API remains unchanged
    for a long time, and many people use it in different corner cases, untested bugs
    and real-world performance issues can emerge and be fixed. Instead, a quickly
    changing version is usually bug-ridden and inefficient in many application cases.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，软件质量会得到提高。如果一个API版本长时间保持不变，并且许多人使用它在不同的边缘情况下，未测试的bug和现实世界的性能问题可能会出现并被修复。相反，快速变化的版本通常在许多应用场景中充满bug且效率低下。
- en: Of course, there is an advantage to iterating through several improvement steps
    of the API, and APIs created in a few weeks are usually badly designed. Although
    there are still many crates that have been in a 0.x version for several years,
    the time is coming to stabilize them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，迭代API的几个改进步骤有优势，几周内创建的API通常设计得很糟糕。尽管仍然有许多crate已经以0.x版本存在了几年，但稳定它们的时间即将到来。
- en: This is a reinterpretation of the buzzword *stability*. In 2015, it meant *the* *stability
    of the language and of the standard library*. Now, the rest of the mature ecosystem
    must stabilize to be accepted in real-world projects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对流行词“稳定性”的重新解释。在2015年，它意味着“语言和标准库的稳定性”。现在，成熟的生态系统其余部分必须稳定下来，才能被实际项目所接受。
- en: Asynchronous programming
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: A major innovation was introduced in stable Rust in November 2019—with release
    1.39—it is the `async-await` syntax, to support asynchronous programming.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 2019年11月，在稳定的Rust中引入了一项重大创新——发布1.39版——它是`async-await`语法，以支持异步编程。
- en: Asynchronous programming is a programming paradigm that is very useful in many
    application areas, mainly in multiuser servers, so that many programming languages—such
    as JavaScript, C#, Go, and Erlang—support it in the language. Other languages,
    such as C++ and Java, support asynchronous programming through the standard library.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是一种在许多应用领域非常有用的编程范式，主要在多用户服务器中，因此许多编程语言——如JavaScript、C#、Go和Erlang——都支持在语言中实现它。其他语言，如C++和Java，则通过标准库支持异步编程。
- en: Around 2016, it was very hard to do asynchronous programming in Rust because
    neither the language nor the available crates supported it in an easy and stable
    way. Then, some crates supporting asynchronous programming were developed, such
    as `futures`, `mio`, and `tokio`, though they were not much easier to use, and
    remained at a version before 1, meaning instability of their API.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2016年，在Rust中进行异步编程非常困难，因为既没有语言也没有可用的crate以简单和稳定的方式支持它。然后，一些支持异步编程的crate被开发出来，例如`futures`、`mio`和`tokio`，尽管它们并不容易使用，并且仍然停留在1.0版本之前，这意味着它们的API不稳定。
- en: After having seen the difficulty of creating convenient support for asynchronous
    programming using only libraries, it appeared clear that a language extension
    was needed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到仅使用库创建方便的异步编程支持有多困难之后，很明显需要一个语言扩展。
- en: The new syntax, similar to that of C#, includes the new `async` and `await` language
    keywords. The stabilization of this syntax means that the previous asynchronous
    crates should now be considered obsolete until they migrate to use the new syntax.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语法，类似于C#的语法，包括新的`async`和`await`语言关键字。这种语法的稳定意味着之前的异步crate现在应该被认为是过时的，直到它们迁移到使用新的语法。
- en: The new syntax—announced on the [https://blog.rust-lang.org/2019/11/07/Async-await-stable.html](https://blog.rust-lang.org/2019/11/07/Async-await-stable.html) web
    page—is described on the [https://rust-lang.github.io/async-book/](https://rust-lang.github.io/async-book/) web
    page.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语法——在[https://blog.rust-lang.org/2019/11/07/Async-await-stable.html](https://blog.rust-lang.org/2019/11/07/Async-await-stable.html)网页上宣布——在[https://rust-lang.github.io/async-book/](https://rust-lang.github.io/async-book/)网页上进行了描述。
- en: 'For those who never felt the need for asynchronous programming, here is a quick
    example of it. Create a new Cargo project, with the following dependencies:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些从未感到异步编程必要的人来说，这里有一个快速示例。创建一个新的Cargo项目，并添加以下依赖项：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Prepare in the root folder of that project a file named `file.txt` that contains
    only five `Hello` characters. Using a Unix-like command-line, you can do this
    using the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在该项目的根目录下准备一个名为`file.txt`的文件，其中只包含五个`Hello`字符。使用类Unix的命令行，你可以使用以下命令来完成：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Put the following content into the `src/main.rs` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容放入`src/main.rs`文件中：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run this project, the output is not quite deterministic. The possible
    output is the following one:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个项目，输出并不完全确定。可能的输出如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first three lines are deterministic. Instead, the last line can be shuffled
    a bit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前三条线是确定的。相反，最后一条线可以稍微打乱一下。
- en: In a first reading, pretend it is synchronous code, ignoring the words `async`, `await`, `block_on`,
    and `join!`. With this simplification, the flow is easy to follow.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次阅读时，假设它是同步代码，忽略`async`、`await`、`block_on`和`join!`等单词。通过这种简化，流程很容易理解。
- en: The `main` function calls the `parallel_read_file` function. The first six lines
    of the `parallel_read_file` function call the `print_file` function three times,
    with the arguments `1`, `2`, and `3`, in different lines, each followed by a call
    to `println!`. The seventh line of the `parallel_read_file` function again calls the `print_file` function three
    times, with the same three arguments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数调用`parallel_read_file`函数。`parallel_read_file`函数的前六行分别三次调用`print_file`函数，参数为`1`、`2`和`3`，每行后面跟着一个`println!`调用。`parallel_read_file`函数的第七行再次三次调用`print_file`函数，使用相同的三个参数。'
- en: The `print_file` function uses the `File::open` function call to open a file,
    and then uses the `file.read` function call to read a byte at a time from that
    file. Any byte read is printed, preceded by the argument of the function (`instance`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_file`函数使用`File::open`函数调用打开一个文件，然后使用`file.read`函数调用从该文件中一次读取一个字节。读取到的任何字节都会打印出来，前面跟着函数的参数（`instance`）。'
- en: So, we obtain the information that the first call to `print_file` prints `1:H
    1:e 1:l 1:l 1:o`. They are the five characters read from the file, preceded by
    the number `1`, received as an argument.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到的信息是第一次调用`print_file`打印了`1:H 1:e 1:l 1:l 1:o`。它们是从文件中读取的五个字符，前面跟着数字`1`，作为函数的参数接收。
- en: 'The fourth line prints the same contents of the first three lines, mixing the
    characters. First, the three `H` characters are printed, then the three `e` characters,
    then the three `l` characters, and then something weird happens: an `o` is printed
    before all the `l` characters have been printed.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第四行打印了前三条线的相同内容，混合了字符。首先打印了三个`H`字符，然后是三个`e`字符，然后是三个`l`字符，然后发生了一些奇怪的事情：在所有`l`字符打印完毕之前，打印了一个`o`。
- en: What is happening is that the first three lines are printed by three sequential
    invocations of the `print_file` function, while the last line is printed by three
    parallel invocations of the same function. In any parallel invocation, all the
    letters printed by one invocation are in the correct order, but the other invocations
    may interleave their output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是前三条线是通过`print_file`函数的三个连续调用打印的，而最后一条线是通过对同一函数的三个并行调用打印的。在任何并行调用中，一个调用打印的所有字母都是正确的顺序，但其他调用可能会交错它们的输出。
- en: If you think that this is similar to multithreading, you are not far from the
    truth. There is an important difference, though. Using threads, the operating
    system may interrupt the threads and pass control to another thread at any time,
    with the effect that the output may be broken at undesirable points.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这类似于多线程，你离真相不远了。尽管如此，有一个重要的区别。使用线程时，操作系统可以在任何时候中断线程并将控制权传递给另一个线程，这可能导致输出在不受欢迎的点中断。
- en: To avoid such interruptions, critical regions or other synchronization mechanisms
    must be used. Instead, with asynchronous programming, functions are never interrupted
    except when a specific asynchronous operation is performed. Typically, such operations
    are an invocation of external services, such as accessing the filesystem, which
    could cause a wait. Instead of waiting, another asynchronous operation is activated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种中断，必须使用关键区域或其他同步机制。相反，在异步编程中，函数永远不会被中断，除非执行特定的异步操作。通常，这样的操作是调用外部服务，例如访问文件系统，这可能导致等待。而不是等待，另一个异步操作被激活。
- en: 'Now, let''s see the code from the beginning, implementing asynchronous operations.
    It uses the `async_std` crate. It is an asynchronous version of the standard library.
    The standard library is still available, but its functions are synchronous. The
    code can be seen in the following snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从代码的开始部分看起，实现异步操作。它使用`async_std`库。它是标准库的异步版本。标准库仍然可用，但其函数是同步的。代码可以在以下片段中看到：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To have an asynchronous behavior, the functions of this crate must be used.
    In particular, we will use the functions of the `File` data type. In addition,
    some features of the not-yet-stabilized `futures` crate are used. The code can
    be seen in the following snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现异步行为，必须使用此crate的函数。特别是，我们将使用`File`数据类型的函数。此外，还使用了尚未稳定的`futures`crate的一些功能。代码可以在以下片段中看到：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, there is the `main` function, whose body contains only the following
    line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是`main`函数，其主体只包含以下一行：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the `parallel_read_file` function is called first.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先调用了`parallel_read_file`函数。
- en: This is an asynchronous function. When you call an asynchronous function using
    the normal function-call syntax, as in the `parallel_read_file()` expression,
    the body of that function is not actually executed, as a normal and synchronous
    function would be. Instead, such a call just returns an object, called a **future**. A
    future is similar to a closure, as it encapsulates a function and the arguments
    used to invoke such a function. The function encapsulated in the returned future
    is the body of the function we were calling.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个异步函数。当你使用正常的函数调用语法调用异步函数时，就像在`parallel_read_file()`表达式中一样，该函数的函数体实际上并没有被执行，就像一个正常和同步的函数那样。相反，这样的调用只是返回一个对象，称为**future**。future类似于闭包，因为它封装了一个函数和用于调用该函数的参数。返回的future中封装的函数是我们调用函数的函数体。
- en: To actually run the function encapsulated in the future, a particular kind of
    function is needed, called an **executor**. The `block_on` function is an executor.
    When an executor is invoked, passing a future to it, the body of the function
    encapsulated in that future is run, and the value returned by such a function
    is then returned by the executor itself.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际运行封装在`future`中的函数，需要一个特定的函数，称为**执行器**。`block_on`函数是一个执行器。当调用执行器并传递一个`future`给它时，该`future`封装的函数体将被执行，然后该函数返回的值由执行器本身返回。
- en: So, when the `block_on` function is called, the body of `parallel_read_file` is
    run, and when it terminates, `block_on` also terminates, returning the same value
    returned by `parallel_read_file`. As this last function has a `Result` value type,
    it should be unwrapped.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当调用`block_on`函数时，`parallel_read_file`的函数体将被执行，当它终止时，`block_on`也会终止，并返回`parallel_read_file`返回的相同值。由于这个最后的函数有一个`Result`值类型，应该将其展开。
- en: 'Then, a function is defined whose signature is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义了一个签名如下所示的功能：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `async` keyword marks that function as asynchronous. It is also fallible,
    and so a `Result` value is returned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`关键字标记该函数为异步的。它也是可能出错的，因此返回一个`Result`值。'
- en: Asynchronous functions can be invoked only by other asynchronous functions or
    by executors, such as `block_on` and `try_join`. The `main` function is not asynchronous,
    and so there, we needed an executor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数只能由其他异步函数或执行器调用，例如`block_on`和`try_join`。`main`函数不是异步的，因此在那里我们需要一个执行器。
- en: 'The first line of the body of the function is added in the following code snippet. It
    is an invocation of the `print_file` function, passing the value `1` to it. As
    the `print_file` function is asynchronous too, to invoke it from inside an asynchronous
    function, the `.await` clause must be used. Such a function is fallible, and so
    a `?` operator is added, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中添加了函数体的第一行。它是调用`print_file`函数的调用，传递值`1`给它。由于`print_file`函数也是异步的，因此要从异步函数内部调用它，必须使用`.await`子句。这样的函数是可能出错的，因此添加了一个`?`运算符，如下所示：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When an asynchronous function is invoked using `.await`, the execution of the
    body of that function starts right away, but as soon as it yields control because
    it executes a blocking function, such as an operating system call, another ready
    asynchronous function may proceed. However, the flow of control does not proceed
    beyond the `.await` clause until the body of the called function is complete.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `.await` 调用一个异步函数时，该函数的主体立即开始执行，但一旦它因为执行一个阻塞函数（如操作系统调用）而交出控制权，另一个就绪的异步函数可能继续执行。然而，控制流不会超出
    `.await` 子句，直到被调用函数的主体执行完毕。
- en: 'The second line of the body of the function is an invocation of a synchronous
    function, and so `.await` is neither needed nor allowed, as can be seen in the
    following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数主体中的第二行是同步函数的调用，因此不需要也不允许 `.await`，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can be sure that it is run after the previous statement because that statement
    ended with a `.await` clause.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确信它是在前一条语句之后运行的，因为那条语句以 `.await` 子句结束。
- en: 'This pattern is repeated three times, and then the seventh line consists of
    a set of three invocations in parallel with the same asynchronous function, as
    illustrated in the following code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式重复三次，然后第七行包含一组与相同异步函数并行调用的三个调用，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Even the `try_join!` macro is an executor. It runs all the three futures generated
    by the three calls to `print_file`. Only one thread is used by asynchronous programming,
    and so, in fact, one of the three futures is run first. If it never has to wait,
    it ends before the other futures have the opportunity to start.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `try_join!` 宏也是一个执行器。它运行由三次 `print_file` 调用生成的所有三个未来。异步编程只使用一个线程，因此实际上首先运行三个未来中的一个。如果它永远不需要等待，它会在其他未来有机会开始之前结束。
- en: Instead, as this function will have to wait, at any wait the context is switched
    to another running future, starting from the statement that had put it on wait.
    So, the executions of the three futures are interleaved.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，由于这个函数将不得不等待，在任何等待时刻上下文都会切换到另一个正在运行的未来，从将其置于等待状态的语句开始。因此，三个未来的执行是交织在一起的。
- en: 'Now, let''s see the definition of such an invoked function. Its signature is
    shown in the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这种被调用函数的定义。其签名如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is an asynchronous function, receiving an integer argument and returning
    an empty `Result` value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个异步函数，接收一个整数参数并返回一个空的 `Result` 值。
- en: 'The first line of its body opens a file using the `File` data type of the asynchronous
    standard library, as illustrated in the following code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其主体中的第一行使用异步标准库中的 `File` 数据类型打开一个文件，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As such, the `open` function is asynchronous too, and it must be followed by
    `.await`, as illustrated in the following code snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`open` 函数也是异步的，它必须跟随 `.await`，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The asynchronous `read` function is used to read bytes to fill the `byte` buffer.
    This buffer has length `1`, and so just one byte at a time is read. The `read`
    function is fallible, and if it is successful, it returns the numbers of bytes
    read. This means that it returns `1` if a byte is read and `0` if the file is
    ended. If the call reads a byte, the loop continues.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 异步的 `read` 函数用于读取字节以填充 `byte` 缓冲区。此缓冲区长度为 `1`，因此每次只读取一个字节。`read` 函数是可能出错的，如果成功，它返回读取的字节数。这意味着如果读取了一个字节，它返回
    `1`，如果文件结束，它返回 `0`。如果调用读取了一个字节，循环继续。
- en: The body of the loop is a synchronous output statement. It prints the identifier
    of the current instance of the file stream, and the byte just read.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的主体是一个同步输出语句。它打印当前文件流实例的标识符和刚刚读取的字节。
- en: So, the sequence of steps is as follows.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，步骤序列如下。
- en: 'First, the `print_file(1)` future is started. When it executes the `File::open` call
    that is blocking, this future is put on hold, and a ready-to-run future is looked
    for. There are two ready futures: `print_file(2)` and `print_file(3)`. The first
    one is chosen, and it is started. Also, it reaches the `File::open` call, and
    so it is put on hold, and the third future is started. When it reaches the `File::open` call,
    it is put on hold and a ready future is looked for. If there is no ready-to-run
    future, the thread itself waits for the first ready future.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动`print_file(1)` future。当它执行阻塞的`File::open`调用时，这个future被挂起，并寻找一个准备就绪的future。有两个准备就绪的future：`print_file(2)`和`print_file(3)`。第一个被选中并启动。它也达到了`File::open`调用，因此被挂起，并启动第三个future。当它达到`File::open`调用时，它被挂起并寻找一个准备就绪的future。如果没有准备就绪的future，线程本身将等待第一个准备就绪的future。
- en: The first future to complete the `File::open` call is the first one, which resumes
    its execution just after that call and starts to read a byte from the file. Even
    this one is a blocking operation, and so this future is put on hold, and control
    is moved to the second future, which starts to read one byte.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首个完成`File::open`调用的future是第一个，它在调用之后立即恢复执行并开始从文件中读取一个字节。即使这个操作也是阻塞的，所以这个future被挂起，控制权转移到第二个future，它开始读取一个字节。
- en: There is always a queue of ready futures. When a future has to wait for an operation,
    it yields control to the executor, which passes control to the first future in
    the queue of ready futures. When the blocking operation is complete, the waiting
    future is appended to the queue of ready futures and can be yielded control if
    no other future is running.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一个准备就绪的future队列。当一个future需要等待一个操作时，它将控制权交给执行器，执行器将控制权传递给准备就绪队列中的第一个future。当阻塞操作完成时，等待的future被追加到准备就绪队列中，如果没有其他future正在运行，它可以获得控制权。
- en: When all the bytes of a file have been read, the `print_file` function ends.
    When all the three calls to `print_file` are ended, the `try_join!` executor ends,
    and the `parallel_read_file` function can proceed. When it reaches its end, the `block_on`
    executor ends and, with it, the whole program.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取完文件的所有字节后，`print_file`函数结束。当所有三个`print_file`调用都结束时，`try_join!`执行器结束，`parallel_read_file`函数可以继续执行。当它到达其末尾时，`block_on`执行器结束，随之整个程序结束。
- en: As blocking operations take a variable amount of time, the sequence of steps
    is non-deterministic. Indeed, the last line of output of the example program seen
    before can be slightly different in different runs, swapping some portions of
    it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于阻塞操作需要可变的时间量，步骤的顺序是非确定性的。确实，之前看到的示例程序的最后一行输出在不同的运行中可能会有所不同，交换其中的一些部分。
- en: As we have seen, asynchronous programming is similar to multithreaded programming
    but it is more efficient, saving both context-switch time and memory usage. It
    is appropriate primarily for **input/output** (**I/O**)-bound tasks as only one
    thread is used, and the flow of control is interrupted only when an I/O operation
    is performed. Instead, multithreading can allocate a different thread on any core,
    and so it is more appropriate for **central processing unit** (**CPU**)-bound
    operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，异步编程类似于多线程编程，但效率更高，可以节省上下文切换时间和内存使用。它主要适用于**输入/输出**（**I/O**）密集型任务，因为只使用一个线程，并且只有当执行I/O操作时才会中断控制流。相反，多线程可以在任何核心上分配不同的线程，因此更适合**中央处理器**（**CPU**）密集型操作。
- en: After the addition of the `async/await` syntax extension, what is still needed
    is the development and stabilization of crates using and supporting such syntax.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了`async/await`语法扩展之后，还需要开发和稳定使用并支持这种语法的crate。
- en: Optimization
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: 'Usually, system programmers are quite interested in efficiency. In this regard,
    Rust shines as one of the most efficient languages, though there are still some
    issues with performance, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，系统程序员对效率非常感兴趣。在这方面，Rust以其高效性而闻名，尽管仍然存在一些性能问题，如下所述：
- en: A full build—in particular, an optimized release build—is quite slow, even more
    so if link-time optimization is enabled. For large projects, this can be quite
    a nuisance. At present, the Rust compiler is just a frontend that generates **Low-Level
    Virtual Machine** (**LLVM**) **intermediate representation** (**IR**) code and
    passes such code to the LLVM machine code generator. However, the Rust compiler
    generates a disproportionate amount of LLVM IR code, and so the LLVM backend must
    take a long time to optimize it. An improved Rust compiler would pass to LLVM
    a much more compact sequence of instructions. A refactoring of the compiler is
    in progress, and this could lead to a faster compiler.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整构建——特别是优化后的发布构建——相当慢，如果启用了链接时间优化，则更是如此。对于大型项目来说，这可能会相当麻烦。目前，Rust 编译器只是一个前端，它生成
    **低级虚拟机** (**LLVM**) **中间表示** (**IR**) 代码，并将此类代码传递给 LLVM 机器码生成器。然而，Rust 编译器生成的
    LLVM IR 代码量不成比例，因此 LLVM 后端必须花费很长时间来优化它。一个改进的 Rust 编译器会将一个更紧凑的指令序列传递给 LLVM。编译器的重构正在进行中，这可能会导致编译器更快。
- en: Since version 1.37, the Rust compiler supports **profile-guided optimization**
    (**PGO**), which can enhance performance for the typical processor workflows.
    However, such a feature is rather cumbersome to use. A graphical frontend or an
    IDE integration would make it easier to use.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自 1.37 版本以来，Rust 编译器支持 **性能分析指导优化** (**PGO**)，这可以提高典型处理器工作流程的性能。然而，此功能使用起来相当繁琐。图形前端或
    IDE 集成将使其更容易使用。
- en: A development underway is an addition to the language of the **const generics**
    feature, described in the next section.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在进行开发的是向语言添加 **const 泛型** 功能，这在下一节中描述。
- en: In LLVM IR, any function argument of a pointer type can be tagged with the `noalias`
    attribute, meaning that the memory reference by this pointer will not be changed
    inside this function, except through this pointer. Using this information, LLVM
    can generate faster machine code. This attribute is similar to the `restrict` keyword
    in the C language. Yet in Rust, for *every* mutable reference (`&mut`), the `noalias`
    property is guaranteed by language ownership rules. Therefore, faster programs
    could be obtained that always generate LLVM IR code with the `noalias` attribute
    for every mutable reference. This has been done in versions 1.0 through 1.7 and
    in versions 1.28 and 1.29, although, because of bugs in the LLVM backend compiler,
    the resulting code was bugged. Therefore, until a correct LLVM implementation
    is released, the `noalias` optimization hint will not be used.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 LLVM IR 中，任何指针类型的函数参数都可以用 `noalias` 属性标记，这意味着此指针引用的内存在此函数内部不会改变，除非通过此指针。利用此信息，LLVM
    可以生成更快的机器码。此属性类似于 C 语言中的 `restrict` 关键字。然而，在 Rust 中，对于 **每个** 可变引用 (`&mut`)，`noalias`
    属性由语言所有权规则保证。因此，可以获得更快的程序，这些程序始终为每个可变引用生成带有 `noalias` 属性的 LLVM IR 代码。这已经在 1.0
    到 1.7 版本以及 1.28 和 1.29 版本中实现，尽管由于 LLVM 后端编译器中的错误，生成的代码存在缺陷。因此，直到发布正确的 LLVM 实现之前，`noalias`
    优化提示将不会使用。
- en: The const generics feature
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: const 泛型功能
- en: 'At present, generic data types are parameterized only by types or lifetimes.
    It is useful to be able to also parameterize a generic data type by a constant
    expression. In a way, this feature is already available, but only for one kind
    of generic type: the arrays. You can have the `[u32; 7]` type that is an array
    parameterized by the `u32` type and by the `7` constant, though you cannot define
    your own generic type parameterized by a constant.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，泛型数据类型只能由类型或生命周期参数化。能够通过常量表达式来参数化泛型数据类型也是有用的。从某种意义上说，此功能已经可用，但仅限于一种泛型类型：数组。你可以有
    `[u32; 7]` 类型，这是一个由 `u32` 类型以及常量 `7` 参数化的数组，尽管你不能定义自己的由常量参数化的泛型类型。
- en: 'This feature, already available in C++ language, is in development in the nightly
    build. It would allow variables to be replaced with constants in generic code,
    and this would surely improve performance. Here is an example program that uses
    as dependencies the `num` crate:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能已在 C++ 语言中可用，正在夜间构建中进行开发。它将允许在泛型代码中将变量替换为常量，这无疑会提高性能。以下是一个使用 `num` 包作为依赖项的示例程序：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This program, to be compiled only using a nightly version of the compiler,
    creates a data type implementing a bidimensional array of floating-point numbers.
    Notice that the parameterization is as follows: `T: Float, const WIDTH: usize,
    const HEIGHT: usize`. The first parameter is the type of array items. The second
    and third parameters are the sizes of the array.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '此程序仅使用编译器的夜间版本进行编译，创建了一个实现二维浮点数数组的类型。请注意，参数化如下：`T: Float, const WIDTH: usize,
    const HEIGHT: usize`。第一个参数是数组元素的类型。第二个和第三个参数是数组的大小。'
- en: Having constant values instead of variables allows important code optimizations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量值而不是变量允许重要的代码优化。
- en: Embedded systems
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式系统
- en: 'Rust has been developed since when Mozilla started to sponsor it in 2009, with
    a specific goal: to create a web browser. Even after 2018, the core team of developers
    works for Mozilla Foundation, whose main business is to build client-side web
    applications. Such software is multiplatform, but oriented exclusively toward
    the following requirements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 自2009年Mozilla开始赞助它以来一直在开发，有一个具体的目标：创建一个网络浏览器。即使到2018年，开发者的核心团队仍然为Mozilla基金会工作，其主营业务是构建客户端网络应用程序。此类软件是跨平台的，但专门针对以下要求：
- en: '**Random-access memory (RAM)**: At least 1 GB'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机存取存储器 (RAM)**: 至少 1 GB'
- en: '**Supported CPUs**: Initially only x86 and x86_64; later, also ARM and ARM64.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的CPU**：最初仅支持x86和x86_64；后来，也支持ARM和ARM64。'
- en: '**Supported operating systems**: Linux, Windows, macOS'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的操作系统**：Linux、Windows、macOS'
- en: These requirements excluded most microcontrollers as the Mozilla Foundation
    was not interested in such platforms, though the features of Rust appear to be
    a good match with the requirements of many embedded systems with more constrained
    requirements. Therefore, thanks to a worldwide group of volunteers, in 2018, the
    Embedded Working Group was created to develop the ecosystem needed to use Rust
    on embedded systems—that is, on bare-metal or on stripped-down operating systems,
    and with severe resource limitations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求排除了大多数微控制器，因为Mozilla基金会对此类平台不感兴趣，尽管Rust的特性似乎与许多具有更多约束要求的嵌入式系统的需求相匹配。因此，多亏了一个全球志愿者团队，2018年成立了嵌入式工作组，以开发在嵌入式系统上使用Rust所需的生态系统——即在裸机或简化版的操作系统上，以及具有严重资源限制的系统。
- en: Progress in this application area has been rather slow and directed mainly at
    a few architectures, but the future is promising, at least for 32-bit or 64-bit
    architectures, because any architecture supported by the LLVM backend is easily
    targetable by the Rust compiler.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用领域的发展相当缓慢，主要针对少数几种架构，但未来前景看好，至少对于32位或64位架构来说如此，因为任何由LLVM后端支持的架构都很容易被Rust编译器定位。
- en: 'Some specific improvements to the language, which ease the use of Rust for
    embedded systems, are listed as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了以下针对语言的一些特定改进，这些改进简化了Rust在嵌入式系统中的使用：
- en: The standard-library `Pin` generic class avoids moving objects in memory. This
    is needed when some external device is accessing a memory location.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库中的 `Pin` 泛型类避免了在内存中移动对象。当某些外部设备访问内存位置时，这是必需的。
- en: The `cfg` and `cfg_attr` attributes, which allow conditional compilation, have
    been extended. This feature is needed because trying to compile code for a wrong
    platform can create unacceptable code bloat, or even cause compilation errors.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许条件编译的 `cfg` 和 `cfg_attr` 属性已被扩展。这个特性是必需的，因为尝试为错误平台编译代码可能会产生不可接受的代码膨胀，甚至导致编译错误。
- en: The `allocator` API has been made more customizable.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allocator` API 已被做得更具可定制性。'
- en: The applicability of `const fn` has been extended. This construct allows a code
    base that is maintainable as normal algorithmic code, but as efficient as a wired
    constant.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const fn` 的适用性已经扩展。这个结构允许代码库在作为正常算法代码维护的同时，效率等同于硬编码的常量。'
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen the most probable development lines of the Rust
    ecosystem in the next few years—support for IDEs and for interactive programming;
    the maturity of the most popular crates; widespread support of the new asynchronous
    programming paradigm and its keywords (`async` and `await`); further optimization
    of both the compiler and the generated machine code; and widespread support of
    embedded systems programming.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Rust生态系统在未来几年中最可能的发展方向——对IDE和交互式编程的支持；最受欢迎的crate的成熟；对新的异步编程范式及其关键字（`async`
    和 `await`）的广泛支持；编译器和生成的机器代码的进一步优化；以及嵌入式系统编程的广泛支持。
- en: We have learned how to write asynchronous code and a possible way to define
    and use const generics (still unstable at the time of writing).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何编写异步代码，以及定义和使用const generics的可能方法（在撰写本文时仍然不稳定）。
- en: We have seen that there are quite a lot of application areas where Rust could
    really shine. Of course, if you are going to use it only for fun, the sky is the
    limit, but for real-world applications, the ecosystem of libraries and tools can
    really decide the viability of a programming system. Now, at last, the critical
    mass of high-quality libraries and tools is about to be reached.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，有很多应用领域是Rust能够真正大放异彩的。当然，如果你只是想用它来娱乐，那么天空才是极限，但对于实际应用来说，库和工具的生态系统确实可以决定一个编程系统的可行性。现在，终于，高质量库和工具的临界质量即将达到。
