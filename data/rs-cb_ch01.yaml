- en: Let us Make System Programming Great Again
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们让系统编程再次伟大
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up Rust in Linux and macOS
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 中设置 Rust
- en: Setting up Rust in Windows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 中设置 Rust
- en: Creating your first Rust program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个 Rust 程序
- en: Defining a variable assignment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义变量赋值
- en: Setting up Boolean and the character types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置布尔类型和字符类型
- en: Controlling decimal points, number formats, and named arguments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制小数点、数字格式和命名参数
- en: Performing arithmetic operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行算术运算
- en: Defining mutable variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可变变量
- en: Declaring and performing string operations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和执行字符串操作
- en: Declaring arrays and using slices in Rust
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中声明数组和使用切片
- en: Declaring vectors in Rust
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中声明向量
- en: Declaring tuples in Rust
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中声明元组
- en: Performing calculations on two numbers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对两个数字进行计算
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is focused on bringing about a behavioral change in you in regard
    to setting up Rust and programming with it. The objective of this chapter is to
    make you realize why one should use Rust when there are so many other programming
    languages out there solving various problems in different verticals--why is there
    a need for yet another programming language?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是改变您对设置 Rust 和使用它进行编程的态度。本章的目标是让您意识到为什么在存在许多其他编程语言解决不同领域问题时，还需要使用 Rust——为什么还需要另一种编程语言？
- en: These are the fundamental questions that would come to one's mind when they
    are learning a new language, well Rust is a systems programming language that
    runs blazingly fast, prevents segfaults, and guarantees thread safety. As the
    definition mentions Rust is focused towards eliminating a various class of system
    programming bugs and errors which at the end of the day helps in making secure,
    faster, and out-of-the-box production grade applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们学习一门新语言时，这些基本问题会浮现在他们的脑海中，Rust 是一种运行速度极快、防止段错误并保证线程安全的系统编程语言。正如定义所述，Rust
    致力于消除各种系统编程错误和漏洞，最终有助于制作安全、快速且即插即用的生产级应用程序。
- en: This chapter dives deeper into various assignment operations and their features,
    data types, and data structures in Rust.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨各种赋值操作及其功能、数据类型和数据结构在 Rust 中的使用。
- en: Setting up Rust in Linux and macOS
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 中设置 Rust
- en: We will explore ways in which we can install Rust components in Linux and macOS
    operating systems and also cover the different problems faced during the installation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨在 Linux 和 macOS 操作系统中安装 Rust 组件的方法，并涵盖安装过程中遇到的不同问题。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to run Rust code in your workstations, we have to install the Rust
    compiler. We require Unix-based operating systems such as Linux distributions
    and macOS.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的工作站上运行 Rust 代码，我们必须安装 Rust 编译器。我们需要基于 Unix 的操作系统，如 Linux 发行版和 macOS。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to set up Rust on your system:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在您的系统上设置 Rust：
- en: Open the Terminal.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: In macOS, you can open the Terminal by pressing the *F4* key, which opens the
    launchpad and searches for the Terminal. Then, you can select the Terminal option
    in the display. This is just one possible way of doing it; there are other ways
    too.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 中，您可以通过按 *F4* 键打开终端，这会打开启动盘并搜索终端。然后，您可以在显示选项中选择终端。这只是其中一种可能的方法；还有其他方法。
- en: In Linux distributions, we can jointly press *Ctrl* + *Alt* + *T* to open the
    Terminal or search for it in the application search window.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 发行版中，我们可以同时按 *Ctrl* + *Alt* + *T* 打开终端或在应用程序搜索窗口中搜索它。
- en: 'Type the following command to install the Rust compiler and Cargo in your system:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以在您的系统上安装 Rust 编译器和 Cargo：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also try using the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以尝试使用以下命令：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding commands will start the installation, and as it proceeds, the
    script will require user input. Enter for the default installation, which is the
    standard way. After this step, different components will be downloaded. If the
    installation happens without any error, you should be able to see the following
    screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将启动安装，在安装过程中，脚本将需要用户输入。输入默认安装，这是标准方式。在此步骤之后，将下载不同的组件。如果安装没有错误发生，您应该能够看到以下截图：
- en: '![](img/7f6b76d2-d283-4c92-882c-af9222ef0862.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f6b76d2-d283-4c92-882c-af9222ef0862.png)'
- en: Rust is installed now. Great!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 已安装。太棒了！
- en: Uninstalling Rust
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卸载 Rust
- en: 'Uninstalling Rust is as easy as installing it. Open the Terminal and type the
    following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载 Rust 与安装一样简单。打开终端并输入以下命令：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/c4fe8d7f-353f-4f0b-a2a4-9215e4a2f479.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/c4fe8d7f-353f-4f0b-a2a4-9215e4a2f479.png)'
- en: Rust's compiler version
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 的编译器版本
- en: 'If you have reached here, you have got Rust installed on your system, and you
    can go ahead and verify it. Open up the Terminal and enter the following command,
    which will give you the version of Rust installed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经到达这里，您已经在系统上安装了 Rust，您可以继续并验证它。打开终端并输入以下命令，这将给出已安装的 Rust 版本：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Take a look at the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图：
- en: '![](img/273d93ef-31be-4635-a686-84dd61634176.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/273d93ef-31be-4635-a686-84dd61634176.png)'
- en: Here, `rustc` stands for the Rust compiler and `--version` displays the Rust
    version we have downloaded. By default, the `rustup.sh` script downloads the latest
    stable build. In this book, we are working with the `1.14.0` version.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`rustc` 代表 Rust 编译器，`--version` 显示我们下载的 Rust 版本。默认情况下，`rustup.sh` 脚本下载最新的稳定构建。在这本书中，我们使用的是
    `1.14.0` 版本。
- en: Congrats, if you have reached this step without any error! Rust has been installed
    successfully.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，如果您没有遇到任何错误就到达了这一步！Rust 已成功安装。
- en: Advanced installation options
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级安装选项
- en: A few other commands with the `rustup.sh` script are as follows. These commands
    are not necessary for common usage. The following commands are advanced commands
    that are not usually used by developers at an early stage of Rust development.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用 `rustup.sh` 脚本的命令。这些命令对于常规使用不是必需的。以下命令是高级命令，通常在 Rust 开发早期阶段不会被开发者使用。
- en: 'Install to a particular location:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装到特定位置：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save the download for faster reinstallation:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存下载以加快重新安装：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install nightly:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装夜间构建：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Install nightly archives:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装夜间构建存档：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Install the explicit versions:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装显式版本：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These commands help with the installation of a particular build, unstable releases,
    and version-controlled component installation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令有助于安装特定构建版本、不稳定发布版本和受版本控制的组件安装。
- en: Troubleshooting
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you try to reinstall Rust after its uninstallation, you''ll often get an
    error saying that `rustup.sh` already exists. Please refer the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在卸载 Rust 后尝试重新安装，您通常会得到一个错误，说 `rustup.sh` 已经存在。请参考以下截图：
- en: '![](img/4bc34fc6-3db4-4c10-8a0b-6ce85772f4f2.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/4bc34fc6-3db4-4c10-8a0b-6ce85772f4f2.png)'
- en: 'To solve the error, just delete the `.rustup` executable file from the user
    space:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决错误，只需从用户空间删除 `.rustup` 可执行文件：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the version command doesn't work for you, then you probably have the PATH
    environment variable wrong and have not included Cargo's binary directory, which
    is `~/.cargo/bin` on Unix and `%USERPROFILE%\.cargo\bin` on Windows.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果版本命令对您不起作用，那么您可能 PATH 环境变量设置错误，并且没有包含 Cargo 的二进制目录，在 Unix 上是 `~/.cargo/bin`，在
    Windows 上是 `%USERPROFILE%\.cargo\bin`。
- en: This is the directory where Rust development tools are present, and most Rust
    developers keep it in their PATH environment variable, which makes it possible
    for them to run `rustc` on the command line.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Rust 开发工具所在的目录，大多数 Rust 开发者都会将其放在他们的 PATH 环境变量中，这使得他们能够在命令行上运行 `rustc`。
- en: Due to the differences between operating systems, command shells, and bugs in
    the installation, you may need to restart your shell, log out of the system, or
    configure PATH manually as appropriate to your operating environment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统、命令外壳和安装中的错误之间的差异，您可能需要重新启动外壳、从系统中注销或根据您的操作环境手动配置 PATH。
- en: Rust does not do its own linking, so you'll need to have a linker installed.
    Doing so will depend on your specific system. For Linux-based systems, Rust will
    attempt to call `cc` for linking. On Rust built on Windows with Microsoft Visual
    Studio, this depends on having Microsoft Visual C++ Build Tools installed. These
    do not need to be in `%PATH%`, as `rustc` will find them automatically. In general,
    if you have your linker in a non-traditional location, you can call `rustc linker=/path/to/cc`,
    where `/path/to/cc` should point to your linker path.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不进行自己的链接，因此您需要安装一个链接器。这样做将取决于您的具体系统。对于基于 Linux 的系统，Rust 将尝试调用 `cc` 进行链接。在用
    Microsoft Visual Studio 构建的 Rust 上，这取决于是否已安装 Microsoft Visual C++ Build Tools。这些工具不需要在
    `%PATH%` 中，因为 `rustc` 会自动找到它们。一般来说，如果您将链接器放在非传统位置，可以调用 `rustc linker=/path/to/cc`，其中
    `/path/to/cc` 应指向您的链接器路径。
- en: If you are still stuck, there are a number of places where you can get help.
    The easiest is the **#rust--beginners** IRC channel for general discussion, and
    the **#rust** IRC channel, which we can access through Mibbit. Other great resources
    include the Rust user's forum and Stack Overflow.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然遇到困难，有多个地方你可以获得帮助。最简单的是**#rust--beginners**的IRC频道，用于一般讨论，以及**#rust**的IRC频道，我们可以通过Mibbit访问。其他优秀的资源包括Rust用户论坛和Stack
    Overflow。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The shell script `rustup.sh` is a great way to install Rust and has been used
    by many developers to not only install Rust, but also Cargo on their machines.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本`rustup.sh`是安装Rust的一个很好的方法，许多开发者已经使用它不仅安装了Rust，还在他们的机器上安装了Cargo。
- en: The working of this script is pretty straightforward, where the code of the
    bash script hosted on the rustup server is downloaded on the host system and run
    automatically by passing the script code to the pipe symbol. The script offers
    you various installation options through which you can choose the version and
    type of Rust compiler you want to install. We have the nightly version, which
    is not the stable one, in Rust's nightly version. This version is used by developers
    and contributors to test and develop features for their existing projects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的运行方式相当直接，其中在rustup服务器上托管的bash脚本代码被下载到主机系统，并通过传递脚本代码到管道符号来自动运行。脚本提供了各种安装选项，你可以通过这些选项选择你想要安装的Rust编译器的版本和类型。我们有Rust的nightly版本，这不是稳定的版本。这个版本被开发者和贡献者用来测试和开发他们现有项目的新功能。
- en: Setting up Rust in Windows
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上设置Rust
- en: This recipe covers how to set up Rust on a Windows system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南涵盖了如何在Windows系统上设置Rust。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require a Windows machine for this purpose.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一台Windows机器来完成这个任务。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'It is very easy to install it on Windows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上安装它非常简单：
- en: Download and run the `.exe` file from [https://win.rustup.rs](https://win.rustup.rs).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://win.rustup.rs](https://win.rustup.rs)下载并运行`.exe`文件。
- en: Click on the downloaded executable; this will start the installation in a Command
    Prompt.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下载的可执行文件；这将启动命令提示符中的安装。
- en: Select option 1 in the Command Prompt for regular installation, which is recommended.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中选择选项1进行常规安装，这是推荐的。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It's similar to Linux and macOS; we have to download the executable and run
    it, which pops up the Command Prompt where the installation starts. Here, instead
    of using the shell script, the Rust team provides an executable file for Windows.
    The executable downloads the Rust compiler and Cargo dependencies on your host
    system.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它与Linux和macOS类似；我们必须下载可执行文件并运行它，这将弹出命令提示符，安装开始。在这里，我们不是使用shell脚本，Rust团队为Windows提供了一个可执行文件。该可执行文件在主机系统上下载Rust编译器和Cargo依赖项。
- en: Creating your first Rust program
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个Rust程序
- en: This recipe is to help you make sure that your compiler is working right and
    also create a workspace where you can try out all these recipes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南旨在帮助你确保编译器正常工作，并创建一个工作区，你可以在这里尝试所有这些食谱。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler setup on the host system for programming;
    I suggest you download a text editor of your choice for this. In this book, we
    are using the Sublime Text editor for the code development process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在主机系统上设置Rust编译器以进行编程；我建议你下载一个你喜欢的文本编辑器。在这本书中，我们使用Sublime Text编辑器进行代码开发过程。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a folder in your user space where you will be storing all the programs
    of the book:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的用户空间中创建一个文件夹，你将在其中存储本书的所有程序：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command will create a directory for you in your user space:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令将在你的用户空间中为你创建一个目录：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding commands will take us to the particular directory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将带我们到特定的目录。
- en: Now, make a file named `sample.rs`; the `.rs` extension indicates that it is
    a Rust script.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`sample.rs`的文件；`.rs`扩展名表示它是一个Rust脚本。
- en: 'Open the script in your text editor and enter the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中打开脚本，并输入以下代码：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save the file and go to your Terminal.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并转到你的终端。
- en: 'Compile the code with the Rust compiler, which will create the executable and
    run in a system without Rust on it:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Rust编译器编译代码，这将创建可执行文件并在没有Rust的系统上运行：
- en: '![](img/69b82b48-8cab-48b3-9fb3-0f6c81f5ca75.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69b82b48-8cab-48b3-9fb3-0f6c81f5ca75.png)'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's go through the code in brief and understand how it is being executed.
    The Rust compiler looks for the `main` function, which is the starting part of
    the code flow. We have a print statement and the dialogue to be displayed. When
    we compile the code, an executable is created which on execution will print the
    dialogue.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地通过代码来了解它是如何执行的。Rust 编译器寻找 `main` 函数，这是代码流的起始部分。我们有一个打印语句和要显示的对话框。当我们编译代码时，将创建一个可执行文件，在执行时将打印对话框。
- en: Rust files always end in a `.rs` extension. If you have to use more than one
    word in your filename to represent your project it is recommended to use an underscore
    to separate them for example, we would use `my_program.rs` rather than `myprogram.rs`,
    this helps in improving readability.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 文件总是以 `.rs` 扩展名结尾。如果你需要使用多个单词来表示你的项目名称，建议使用下划线来分隔它们，例如，我们会使用 `my_program.rs`
    而不是 `myprogram.rs`，这有助于提高可读性。
- en: The keyword `fn` defines a function in Rust. The `main` function is the beginning
    of every Rust program. In this program, we have a `main` function which does not
    take any input arguments and returns any type. In case of any arguments, it would
    go in the parentheses `(` and `)`. The function body is wrapped in curly braces
    `{` and `}`. Rust requires these around all function bodies.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `fn` 在 Rust 中定义一个函数。`main` 函数是每个 Rust 程序的开始。在这个程序中，我们有一个 `main` 函数，它不接受任何输入参数并返回任何类型。如果有任何参数，它们将放在括号
    `(` 和 `)` 中。函数体被大括号 `{` 和 `}` 包围。Rust 要求所有函数体周围都要有这些符号。
- en: It's considered good style to put the opening curly brace on the same line as
    the function declaration, with one space in between.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将开括号放在与函数声明相同的行上，中间有一个空格，被认为是良好的风格。
- en: The `println!` macro in the `std` Rust crate is used for printing to the standard
    output, with a newline. Which is inside the body of the `main` function and prints
    the string `Welcome to Rust Cookbook`. The line ends with a semicolon (`;`). Rust
    is an expression-oriented language, which means that most things are expressions,
    rather than statements. The semicolon(`;`) indicates that this expression is over,
    and the next one is ready to begin.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`std` Rust 框架中的 `println!` 宏用于向标准输出打印，带有换行符。它位于 `main` 函数体内，并打印字符串 `Welcome
    to Rust Cookbook`。该行以分号 (`;`) 结尾。Rust 是一种面向表达式的语言，这意味着大多数事物都是表达式，而不是语句。分号 (`;`)
    表示此表达式已结束，下一个表达式准备开始。'
- en: Before running a Rust program, we have to compile it post which we can use an
    executable file to run the program and print the string in the terminal. The Rust
    compiler by entering the `rustc` command and passing it the name of your source
    file will create the executable, for example, `rustc main.rs` would create an
    executable `./main.` in the same directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 Rust 程序之前，我们必须先编译它，然后我们可以使用可执行文件来运行程序并在终端中打印字符串。通过输入 `rustc` 命令并将源文件名传递给它，Rust
    编译器将创建可执行文件，例如，`rustc main.rs` 将在同一目录中创建一个名为 `./main` 的可执行文件。
- en: Defining a variable assignment
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义变量赋值
- en: We will dive deeply into the various assignment operators and functions in this
    section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨各种赋值运算符和函数。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would require the Rust compiler and any text editor for coding and create
    a file named `assignment.rs` in the project workspace.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来进行编码，并在项目工作区中创建一个名为 `assignment.rs` 的文件。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Start by declaring the different libraries we would be using for this recipe
    in the `assignment.rs` script:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在 `assignment.rs` 脚本中声明我们将要使用的不同库：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `use` statement tells the compiler that the program would use the following
    properties of the library. The `std` is an inbuilt library that comes along with
    the Rust compiler and doesn''t need to be externally downloaded. `i8` and `i16`
    are different data types of the variable that will be used in the program, and
    `stdin` helps us accept user input from the user:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 语句告诉编译器程序将使用库的以下属性。`std` 是 Rust 编译器附带的一个内置库，不需要外部下载。`i8` 和 `i16` 是程序中将使用的变量的不同数据类型，而
    `stdin` 帮助我们接受用户输入：'
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding script is as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面脚本的输出如下：
- en: '![](img/f6fbc1e3-15be-4d69-86ee-92ea8b876bd2.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6fbc1e3-15be-4d69-86ee-92ea8b876bd2.png)'
- en: 'Replace the `main` function of the preceding script in `assignment.rs` file
    with the following code snippet below:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `assignment.rs` 文件中前面的 `main` 函数替换为以下代码片段：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](img/5315a93c-9cbc-494c-90b2-c0ded651b575.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5315a93c-9cbc-494c-90b2-c0ded651b575.png)'
- en: 'In the previous code snippet, we declared a variable named `age` and explicitly
    told the compiler that it''s a 32-bit integer type data and that we are printing
    the maximum and minimum values of the 32-bit int data type. Now, the next piece
    of code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在先前的代码片段中，我们声明了一个名为`age`的变量，并明确告诉编译器它是一个32位整数类型数据，并且我们正在打印32位整型数据的最大值和最小值。现在，接下来的代码：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we have declared two variables in `f_name` and `l_name` using `brackets()`.
    This is a way to declare multiple variables in a single statement in Rust. Similarly,
    while printing them, we can number the position of the variable to determine which
    variable has to be printed first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`brackets()`声明了两个变量`f_name`和`l_name`。这是在Rust中单行声明多个变量的方法。同样，在打印它们时，我们可以编号变量的位置以确定哪个变量需要首先打印。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous section, we declared the `main` function from where the execution
    would start. Here, we are declaring a variable named `num` and assigning it to
    a value of 10\. The `let` statement enables you to declare variables and assigns
    them to a value. We are not explicitly telling what kind of data type the `num`
    variable is, but during compilation time, it will be automatically determined
    and memory will be assigned based on that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们声明了`main`函数，程序将从该函数开始执行。在这里，我们声明了一个名为`num`的变量，并将其赋值为10。`let`语句允许你声明变量并将它们赋值。我们没有明确指出`num`变量是什么类型的数据，但在编译时，它将被自动确定，并根据此分配内存。
- en: The `num` value is immutable, which means that its value cannot be changed during
    the program, and it will be removed from the memory once it goes out of the scope
    of the `main` function. To print the value of the number, we have to use braces;
    we will cover more of this in detail in the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`num`值是不可变的，这意味着它的值在程序运行期间不能改变，一旦它超出`main`函数的作用域，它就会被从内存中移除。要打印数字的值，我们必须使用大括号；我们将在下一节中详细介绍这一点。'
- en: Setting up Boolean and the character types
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置布尔型和字符类型
- en: Boolean operators are of great help to programmers for state identification
    and checking. In this recipe, you will learn about the assignment of character
    type variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符对于程序员的州识别和检查非常有帮助。在本食谱中，你将学习关于字符类型变量的赋值。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would require the Rust compiler and any text editor for coding.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Rust编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a file named `boolean.rs` and compile the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`boolean.rs`的文件，并编译以下代码：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code snippet, we are assigning a Boolean type variable and
    character values in Rust.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在先前的代码片段中，我们在Rust中分配了布尔类型变量和字符值。
- en: 'The output is as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/a701231a-204c-48cc-b6fa-8a9cfd14bf20.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a701231a-204c-48cc-b6fa-8a9cfd14bf20.png)'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding code snippet, we declared the `main` function where we defined
    two variables: `bool_val` and `x_char`. We assigned them with a Boolean and character
    value using the `let` statement. We followed this up by printing them.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码片段中，我们在`main`函数中声明了两个变量：`bool_val`和`x_char`。我们使用`let`语句将布尔值和字符值赋给它们，然后打印它们。
- en: Controlling decimal points, number formats, and named arguments
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制小数点、数字格式和命名参数
- en: This recipe focuses on how to manipulate the print macros to perform various
    control operations in the data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱重点介绍如何操作打印宏以在数据中执行各种控制操作。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would require the Rust compiler and any text editor for coding.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Rust编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Enter the following code in a Rust script named `decimal.rs` and compile them:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`decimal.rs`的Rust脚本中输入以下代码并编译它们：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '2\. The output of the code is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 代码的输出如下：
- en: '![](img/33dd59a5-22e1-4b5d-b05f-fb8a8c7552ce.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33dd59a5-22e1-4b5d-b05f-fb8a8c7552ce.png)'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first print statement, we controlled the number of decimal points to
    be displayed in the Terminal. In the preceding code snippet, we set the value
    to be two after the colon symbol (`:`) in the print statement, which tells the
    compiler to only print the first two decimal points of the variable in the runtime.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个打印语句中，我们控制了在终端中显示的小数位数。在先前的代码片段中，我们在打印语句中的冒号符号（`:`）之后设置了值为二，这告诉编译器在运行时只打印变量的前两位小数。
- en: The next print statement displayed Rust's built-in feature that can convert
    the value to be printed in a different number format. We printed the binary, hex,
    and octal value of the decimal value 10\. To perform this activity, we specifically
    mentioned the parameter after the colon symbol in the print statement. This is
    understood by the Rust compiler. At runtime, Rust would automatically convert
    the decimal type into the mentioned number format, where `b` stands for binary,
    `x` for hex, and `o` for octal. This has to be given after `:` in the print statement.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个打印语句显示了 Rust 内置的可以将要打印的值转换为不同数字格式的功能。我们打印了十进制值 10 的二进制、十六进制和八进制值。为了执行此活动，我们在打印语句中冒号符号后面的参数进行了特别说明。这是
    Rust 编译器可以理解的。在运行时，Rust 会自动将十进制类型转换为所提到的数字格式，其中 `b` 代表二进制，`x` 代表十六进制，`o` 代表八进制。这必须在打印语句中的
    `:` 后面给出。
- en: 'Next, the `print` statement named arguments and we defined the **white space**
    (**ws**) type we wanted to. We have two arguments here: `ten` and `ws`. We had
    control over how we wanted to print the data and what kind of values we wanted
    to fill `ws` with. In the first print statement, we filled it with blank spaces.
    In the second print statement, we explicitly mentioned zero, which is what we
    want to fill the gaps with. We declared the named argument inside the curly braces
    of the print statement and assigned its data value.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用名为 `print` 的语句命名了参数，并定义了我们想要的**空白空间**（**ws**）类型。这里我们有两个参数：`ten` 和 `ws`。我们控制了如何打印数据以及我们想要用哪些值填充
    `ws`。在第一个打印语句中，我们用空格填充了它。在第二个打印语句中，我们明确提到了零，这是我们想要填充空隙的值。我们在打印语句的大括号内声明了命名参数，并为其分配了数据值。
- en: Performing arithmetic operations
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行算术运算
- en: This recipe showcases the different types of arithmetic operations in Rust.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了 Rust 中不同类型的算术运算。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would require the Rust compiler and any text editor for coding.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 Rust 编译器和任何文本编辑器来进行编码。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a file named `arithmetic.rs` in the workspace and compile the following
    code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作区中创建一个名为 `arithmetic.rs` 的文件，并编译以下代码：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '2\. We would get the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 我们将得到以下输出：
- en: '![](img/33943fee-feb3-482d-b11b-d8d95f94af43.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33943fee-feb3-482d-b11b-d8d95f94af43.png)'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the first set of print statements, we have different types of arithmetic
    operations being performed on the data set during runtime. The following symbols
    in the brackets associated with each operation are used to perform the arithmetic
    operation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一组打印语句中，我们在运行时对数据集执行了不同类型的算术运算。与每个操作相关联的括号中的以下符号用于执行算术运算：
- en: addition (*+*)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法（*+*）
- en: subtraction (*-*)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法（*-*）
- en: multiplication (*x*)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法（*x*）
- en: division (*/*)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除法（*/*）
- en: modulus (*%*)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取模（*%*）
- en: In the next set of print statements, we performed various mathematical operations,
    which come built in with the Rust compiler. We declared a variable named `neg_4`
    and assigned it the value `4i32`, which is a negative 32-bit integer with the
    value `4`. We set the absolute value of the variable by calling the `abs()` function
    with the variable name `variable.function`. Similarly, we performed other mathematical
    operations, such as `pow(value)`, which calculates and applies the power value
    to the data. The `round()` function finds the data to the nearest lower value.
    The `ceil()` function returns the smallest integer that is greater than or equal
    to the number. And, the `sin()` functions return the sine value.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一组打印语句中，我们执行了 Rust 编译器内置的各种数学运算。我们声明了一个名为 `neg_4` 的变量，并将其赋值为 `4i32`，这是一个值为
    `4` 的负 32 位整数。我们通过调用 `abs()` 函数并使用变量名 `variable.function` 来设置变量的绝对值。同样，我们执行了其他数学运算，例如
    `pow(value)`，它计算并应用幂值到数据上。`round()` 函数找到最接近的较小值。`ceil()` 函数返回大于或等于数字的最小整数。而且，`sin()`
    函数返回正弦值。
- en: Defining mutable variables
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义可变变量
- en: Rust has the unique feature of ownership and borrowing that enables it to overcome
    segfaults and data races. This is achieved by the mutability property of Rust.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 具有独特的所有权和借用特性，使其能够克服段错误和数据竞争。这是通过 Rust 的可变性属性实现的。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would require the Rust compiler and any text editor for coding.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 Rust 编译器和任何文本编辑器来进行编码。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a file named `mutuable.rs` and compile the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `mutuable.rs` 的文件并编译以下代码：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should get the following output:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![](img/122a56a6-3e03-4fa4-a103-0e43195923f3.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/122a56a6-3e03-4fa4-a103-0e43195923f3.png)'
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Since we have declared the variable type mutable, the Rust compiler allows the
    developer to change the data value assigned any number of times in the scope of
    the functions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已声明变量类型为可变，Rust 编译器允许开发者在函数的作用域内多次更改分配给变量的数据值。
- en: In the preceding program, we created a variable named `sample_var` and explicitly
    marked it as mutable type during its assignment. Due to this action, the Rust
    compiler allows the variables to be assigned different values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们创建了一个名为 `sample_var` 的变量，并在赋值时明确将其标记为可变类型。由于这个操作，Rust 编译器允许变量被赋予不同的值。
- en: Declaring and performing string operations
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和执行字符串操作
- en: This recipe dives deeply into various built-in string operations and functions
    that let the developer split and modify string data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱深入探讨了各种内置的字符串操作和函数，这些函数允许开发者分割和修改字符串数据。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would require the Rust compiler and any text editor for coding.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 Rust 编译器和任何文本编辑器来进行编码。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a script named `string.rs` and compile the following code:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `string.rs` 的脚本，并编译以下代码：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, you are creating an immutable variable called `rand_string` and assigning
    it with a string value. You are also using the `len()` function of the string
    data type to print the length of the sentence, which would also count the white
    space:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个不可变的变量 `rand_string` 并将其赋予一个字符串值。你还使用了字符串数据类型的 `len()` 函数来打印句子的长度，这也会计算空白字符：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `split_at(value)` function divides the sentence into two parts and assigns
    them as two variables: `first` and `second`. We then print them:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`split_at(value)` 函数将句子分成两部分，并将它们分配为两个变量：`first` 和 `second`。然后我们打印它们：'
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We are using two functions here, namely `chars` and `count`, where `chars`
    identifies all the characters and `count` gives the aggregated number of characters:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用了两个函数，即 `chars` 和 `count`，其中 `chars` 识别所有字符，而 `count` 提供字符的总数：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding piece of code, we created a variable named `chars`, which has
    all the characters of the sentence. Then, in the next step, we created another
    variable named `indiv_chars`, which contains the first character of the chars
    variable. We used the `next()` functions to assign the value to `indiv_chars`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个名为 `chars` 的变量，它包含了句子的所有字符。然后，在下一步中，我们创建了一个名为 `indiv_chars`
    的另一个变量，它包含了 `chars` 变量的第一个字符。我们使用 `next()` 函数将值分配给 `indiv_chars`。
- en: 'In the `loop` function, print all the values of the `chars` variable until
    it becomes null:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `loop` 函数中，打印 `chars` 变量的所有值，直到它变为空：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this section of the code, we will iterate over the using the built-in `split_whitespace()`
    function. This section would print the complete words:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将使用内置的 `split_whitespace()` 函数进行迭代。这一部分将打印出完整的单词：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this section of the code, we will iterate over the next line using the built-in
    `lines()` function. This section would print the complete sentence.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将使用内置的 `lines()` 函数迭代下一行。这一部分将打印出完整的句子。
- en: 'You should get the following result:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该得到以下结果：
- en: '![](img/d1d09eb7-36ce-4848-a4bf-15de7b2d7a53.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1d09eb7-36ce-4848-a4bf-15de7b2d7a53.png)'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we assign a variable named `rand_string` with a string value
    of `I love Rust cookbook` in which we perform a certain set of string operations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们给一个变量命名为 `rand_string`，并赋予它字符串值 `I love Rust cookbook`，然后我们在这个字符串上执行一系列字符串操作。
- en: In the first print statement, we display the length of the string by the `len()`
    method of the str type by calling `rand_string.len()` and correspondingly in the
    next print statement we use the `split_at()` method which expects an input argument
    which splits the string at the value of the argument passed and in our case we
    call `rand_string.split_at(7)` to split at index `7` of the string and assign
    it to the two variables named `first` and `second`, here space occupies an index
    value.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个打印语句中，我们通过调用 `rand_string.len()` 使用 `str` 类型的 `len()` 方法来显示字符串的长度，相应地，在下一个打印语句中，我们使用
    `split_at()` 方法，它期望一个输入参数，该参数将字符串分割到传递的参数值处，在我们的例子中，我们调用 `rand_string.split_at(7)`
    来在字符串的索引 `7` 处分割，并将其分配给名为 `first` 和 `second` 的两个变量，这里空格占据了一个索引值。
- en: In the third print statement, we print the numbers of characters present by
    using the `chars()` and `count()` methods, we do it with the following syntax
    `rand_string.chars().count()` where `chars()` iterates through the characters
    and `count()` for counting the number of elements.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个打印语句中，我们使用`chars()`和`count()`方法来打印字符的数量，语法如下`rand_string.chars().count()`，其中`chars()`遍历字符，`count()`用于计数元素的数量。
- en: The `loop` is an iterative statement that keeps on running until the break key
    is called. We used the `match` function, which is similar to switch in other languages.
    We created different conditions for it to check and perform certain actions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`是一个迭代语句，它会一直运行，直到调用`break`键。我们使用了`match`函数，它在其他语言中类似于`switch`。我们为它创建了不同的条件来检查并执行某些操作。'
- en: 'In the `match` statements, we have two conditions which are `Some(x)` and `None`.
    In both the cases, we perform unique operations which are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`match`语句中，我们有两个条件，分别是`Some(x)`和`None`。在这两种情况下，我们执行独特的操作，如下所示：
- en: In the case of `Some(x)`, it basically says that `x` is a value that exists
    and has a type `T` so we can use the `x` variable for further operations and in
    such cases, we print the value
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Some(x)`的情况下，它基本上表示`x`是一个存在且具有类型`T`的值，因此我们可以使用`x`变量进行进一步的操作，在这种情况下，我们打印该值。
- en: In the case of `None`, it refers to cases where a value does not exist which
    ideally is the end of the string and the operation we perform at these cases are
    to break the loop
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`None`的情况下，它指的是不存在值的情况，理想情况下是字符串的末尾，在这些情况下执行的操作是中断循环。
- en: 'We iterate over three types of conditions:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历三种类型的条件：
- en: The first set is individual cases, where we print all the characters of the
    string and is performed by the `chars()` and `next()` functions with the preceding
    match statements
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一组是单个案例，其中打印字符串的所有字符，由`chars()`和`next()`函数以及前面的`match`语句执行。
- en: The second set is where we print all the different words of the string by splitting
    in the places of white spaces and is performed by the `split_whitespace()` and
    `next()` functions with the preceding match statements
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二组是打印字符串中的所有不同单词，通过在空格处分割，由`split_whitespace()`和`next()`函数以及前面的`match`语句执行。
- en: The last ones where we print all the different lines of the string by splitting
    in the places of next line and is performed by the `lines()` and `next()` functions
    with the preceding `match` statements
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个是打印字符串的所有不同行，通过在换行符处分割，由`lines()`和`next()`函数以及前面的`match`语句执行。
- en: Declaring arrays and using slices in Rust
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rust中声明数组和使用切片
- en: 'An array is a collection of objects that are of the same data type and is stored
    in contiguous memory. Arrays are always created using brackets `[]`, and their
    size is known at compile time. It is part of their type: [T; size].'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一系列相同数据类型的对象集合，存储在连续的内存中。数组总是使用方括号`[]`创建，其尺寸在编译时已知。它是它们类型的一部分：[T; size]。
- en: Slices are similar to arrays but their size is not known at compile time. The
    first mark is a pointer value to the data; the second mark is the length of the
    slice that is selected by the user depending on the application. Slices are usually
    used to borrow a section of an array and have the type signature and [T].
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 切片与数组类似，但它们的尺寸在编译时是未知的。第一个标记是数据指针值；第二个标记是用户根据应用程序选择的切片长度。切片通常用于借用数组的某个部分，并且具有类型签名[T]。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would require the Rust compiler and any text editor for coding.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Rust编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a file named `array.rs` and compile the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`array.rs`的文件，并编译以下代码：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '2\. We would get the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 我们将得到以下输出：
- en: '![](img/c4cd3e45-31ac-4ba9-be03-c64f85345fa6.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4cd3e45-31ac-4ba9-be03-c64f85345fa6.png)'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here, we declared a variable named `rand_array` and assigned it to an array
    that has three elements inside square brackets: one, two, and three. In the first
    print statement, we had a question mark (`?`) after the colon (`:`), which indicates
    to the print statement that it would print all the elements of the array.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们声明了一个名为`rand_array`的变量，并将其赋值给一个包含三个元素的数组：一、二、三。在第一个打印语句中，冒号（`:`）后面有一个问号（`?`），这表示打印语句将打印数组的所有元素。
- en: We can address each element of the array by the indices (which refer to the
    position of the array data element). In Rust, the positioning starts from zero.
    So when we print `rand_array[0]`, it will print the first element. In the third
    print statement, we used the `len()` function to get the length or the number
    of elements in the array; we used the length function by calling `rand_var.len()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引（它们指的是数组数据元素的位）来访问数组的每个元素。在Rust中，定位从零开始。因此，当我们打印`rand_array[0]`时，它将打印第一个元素。在第三个打印语句中，我们使用了`len()`函数来获取数组的长度或元素数量；我们通过调用`rand_var.len()`来使用长度函数。
- en: In the fourth print, we had a new concept called slices. Arrays are borrowed
    as slices, where we mention the starting value of the pointer and length in the
    signature. Slices basically reference to a contiguous sequence of the element
    of the array instead of the whole element.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四次打印中，我们有一个新概念，称为切片。数组作为切片借用，我们在签名中提到了指针的起始值和长度。切片基本上是数组的元素连续序列的引用，而不是整个元素。
- en: We printed the complete array by printing `&rand_var`, which would print the
    total array. We also borrowed a section of array using `&rand_var[1..3]`, where
    we mention the size of the slice in square brackets. Here, starting from one,
    we print all the sections of the numbers until the upper limit of three where
    one and three are the index values of the arrays which were dereferenced and printed
    in the Terminal.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过打印`&rand_var`来打印整个数组，这将打印整个数组。我们还使用`&rand_var[1..3]`借用了数组的一部分，其中我们在方括号中提到了切片的大小。在这里，从一开始，我们打印所有数字的部分，直到上限三，其中一和三是数组的索引值，这些索引值被解引用并在终端中打印。
- en: Declaring vectors in Rust
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rust中声明向量
- en: Vector is a very important concept in programming and often people get confused
    between arrays and vectors. Let's demystify the concept. A vector is a dynamic
    array, which implies that its data allocation can be increased or decreased at
    runtime, and we will see how this can be done with a simple built-in function.
    Vectors are implemented in Rust as standard library types, namely `Vec<T>`. Here,
    `T` means that we can have vectors of any data type; vectors always allocate their
    data on the heap and we can create them with the `vec!` macro.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是编程中的一个非常重要的概念，人们经常在数组和向量之间感到困惑。让我们揭开这个概念的秘密。向量是一个动态数组，这意味着它的数据分配可以在运行时增加或减少，我们将看到如何使用一个简单的内置函数来实现这一点。向量在Rust中作为标准库类型实现，即`Vec<T>`。在这里，`T`表示我们可以有任意数据类型的向量；向量始终在堆上分配其数据，我们可以使用`vec!`宏来创建它们。
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We would require the Rust compiler and any text editor for coding.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Rust编译器和任何文本编辑器来进行编码。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a file named `vector.rs` and compile the following code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`vector.rs`的文件并编译以下代码：
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Declare a mutable vector `vec1` with five elements:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个包含五个元素的可变向量`vec1`：
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, to print the third element of the vector, we can refer to the particular
    data of the vector in the heap by its position.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了打印向量的第三个元素，我们可以通过其位置在堆中引用向量的特定数据。
- en: 'The value of the position starts from zero and goes until *n-1* if there are
    n data values:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位置值的起始值为零，直到有n个数据值时的*n-1*：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the previous step, we iterated over the vector by taking reference of the
    vector and printing all its elements:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中，我们通过引用向量并打印其所有元素来遍历向量：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Add and remove the values from the vector.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从向量中添加和移除值。
- en: 'You should get the following output:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![](img/8192ff95-7e22-4e5c-ada2-fbac94856601.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8192ff95-7e22-4e5c-ada2-fbac94856601.png)'
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We cannot use the vector again if we have iterated by taking ownership of the
    vector, and for reiterating the vector many times, we have to take a reference
    to the vector.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经通过获取所有权来迭代了向量，那么我们不能再使用该向量，并且为了多次迭代向量，我们必须引用向量。
- en: Using `pop` and `push`, we can add/remove elements to/from the heap of the memory
    allocation, where the vector data is stored. This feature allows the vector to
    be dynamic. `ush` adds a new element to the top, which is the last element of
    the indices, and `pop` removes the first value and last element with respect to
    the indices.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pop`和`push`，我们可以向/从内存分配的堆中添加/移除元素，其中存储了向量数据。这个特性使得向量是动态的。`push`向顶部添加一个新元素，这是索引的最后一个元素，而`pop`根据索引移除第一个值和最后一个元素。
- en: Declaring tuples in Rust
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rust中声明元组
- en: A tuple is a unique data structure and is widely used by many developers in
    their day-to-day development for processing values of different data types.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一种独特的数据结构，许多开发者在日常开发中广泛使用它来处理不同数据类型的价值。
- en: Generally, tuples are constructed by parentheses `()`, and each tuple has a
    type signature, such as `T1`, `T2`, ..., where `T1` and `T2` are the types of
    its member values.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，元组是通过括号`()`构建的，每个元组都有一个类型签名，例如`T1`, `T2`, ..., 其中`T1`和`T2`是其成员值的类型。
- en: Tuples are very handy in Rust when we want to return multiple data types. We
    can use Rust to package them into a single data structure.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要返回多个数据类型时，元组在Rust中非常方便。我们可以使用Rust将它们打包成一个单一的数据结构。
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would require the Rust compiler and any text editor for coding.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Rust编译器和任何文本编辑器来进行编码。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a file named `tuple.rs` and compile the following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`tuple.rs`的文件，并编译以下代码：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '2\. You should get the following output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 2.你应该得到以下输出：
- en: '![](img/39338298-b9b6-47b8-b8b1-cc23ab9672c1.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39338298-b9b6-47b8-b8b1-cc23ab9672c1.png)'
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous section, we declared two tuples in two different ways. In the
    first method, the Rust compiler automatically located the data types. In the second
    method, we explicitly mentioned the data types and the tuples allowed us to create
    different data types.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们以两种不同的方式声明了两个元组。在第一种方法中，Rust编译器自动确定了数据类型。在第二种方法中，我们明确指出了数据类型，并且元组允许我们创建不同的数据类型。
- en: In the tuple operation section, we extracted values from the tuple using tuple
    indexing, which is performed by printing `tuple_variable.index_value`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在元组操作部分，我们使用元组索引从元组中提取值，这是通过打印`tuple_variable.index_value`来完成的。
- en: Performing calculations on two numbers
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对两个数字进行计算
- en: This recipe covers all the aspects that we have learned from other recipes.
    We perform various operations, such as entering two values from the Terminal to
    be accepted as standard input by the user, converting the string that is acceptable
    to the integer, and performing arithmetic operations.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方涵盖了我们从其他配方中学到的所有方面。我们执行各种操作，例如从终端输入两个值，让用户将其作为标准输入接受，将可接受的字符串转换为整数，并执行算术运算。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We would require the Rust compiler and any text editor for coding.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Rust编译器和任何文本编辑器来进行编码。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a file named `calculator.rs` and compile the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`calculator.rs`的文件，并编译以下代码：
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `io` function helps us accept user input in the Terminal:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`io`函数帮助我们通过终端接受用户输入：'
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should get the following output:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![](img/1a1bdcb8-3808-49b1-b327-9e00b57f13df.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a1bdcb8-3808-49b1-b327-9e00b57f13df.png)'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::io` module contains a number of common things you'll need when. The
    core part of this module is the read and write traits.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::io`模块包含了许多你在编写代码时需要用到的常用功能。该模块的核心部分是读写特性。'
- en: We called the `read_line()` method from the `std::io` module. The `read_line()`
    method doesn't take a String as an argument; it takes a `&mut` String. Rust has
    a feature called *references*, which allows you to have multiple references to
    one piece of data, which can reduce copying. The job of `read_line` is to take
    what the user types as standard input and place it into a string. So it takes
    that string as an argument, and in order to add the input, it needs to be mutable.
    In this case, `io::Result` had an `expect()` method that took a value it was called
    on; if this isn't successful, our program will crash, displaying a message. If
    we do not call `expect()`, our program will compile but we'll get a warning.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`std::io`模块中调用了`read_line()`方法。`read_line()`方法不接收一个String作为参数；它接收一个`&mut`
    String。Rust有一个名为*引用*的功能，它允许你对同一份数据有多个引用，这可以减少复制。`read_line`的职责是将用户输入的标准输入放置到一个字符串中。因此，它需要这个字符串作为参数，并且为了添加输入，它需要是可变的。在这种情况下，`io::Result`有一个`expect()`方法，它接受一个被调用的值；如果这不成功，我们的程序将崩溃，并显示一条消息。如果我们不调用`expect()`，我们的程序将编译，但我们会得到一个警告。
- en: 'For converting the string into an integer, we used `trim` and `parse` methods.
    The `trim()` method on the strings eliminates any `ws` at the beginning and end
    of the data. This means that if we type 5 and hit return, guess it would look
    like this: *5\n*. The `\n` represents a *newline,* the enter key induced newline
    will be got rid by `trim()` method, leaving behind our string with only the number
    5.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将字符串转换为整数，我们使用了 `trim` 和 `parse` 方法。字符串上的 `trim()` 方法消除了数据开头和结尾的任何 `ws`。这意味着如果我们输入
    5 并按回车键，它看起来会是这样：*5\n*。`\n` 代表一个 *换行符*，由 `trim()` 方法消除的回车键将不会保留，只留下包含数字 5 的字符串。
- en: 'The `parse()` method on string data parses a string into some kind of number
    format, since it can parse a variety of numbers, we need to give Rust a hint as
    to the exact type of number format we want it to convert, that is the reason why
    we have the statement `let a_int: i32`. The colon (`:`) after tells Rust we''re
    going to annotate its type, `i32` is an integer containing 32-bit size. We used
    the `expect()` method to capture a crash in the cases of an error. The last section
    of the script was used to conduct regular arithmetic operations.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '字符串数据上的 `parse()` 方法将字符串解析成某种数字格式，因为它可以解析多种数字，所以我们需要给 Rust 提示我们想要的精确数字格式类型，这就是为什么我们有
    `let a_int: i32` 这样的声明。冒号 (`:`) 后面告诉 Rust 我们将要注解其类型，`i32` 是一个包含 32 位大小的整数。我们使用了
    `expect()` 方法来捕获错误情况下的崩溃。脚本的最后一部分用于执行常规的算术运算。'
