- en: Basics of the Rust Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust语言基础
- en: Okay, we're ready to actually begin writing some Rust code. In this chapter,
    we're going to look at how Rust programs are structured, and how an assortment
    of common programming elements are expressed in the language. We'll start with
    functions and modules, then move on to fundamental language features, such as
    branching, looping, and data structures. Almost everything we're covering in this
    chapter has an equivalent in most other programming languages; these are the fundamentals
    of programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在准备开始编写一些Rust代码。在本章中，我们将探讨Rust程序的结构，以及如何在语言中表达各种常见的编程元素。我们将从函数和模块开始，然后转向基本语言特性，如分支、循环和数据结构。本章中涵盖的几乎所有内容在大多数其他编程语言中都有对应；这些都是编程的基础。
- en: 'Specifically, this chapter describes the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章描述了以下内容：
- en: Functions, which are somewhat like miniature programs that are part of the larger
    program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数，它们类似于大型程序中的一部分小程序
- en: Modules, which are used to organize the program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块，用于组织程序
- en: Expressions, which are how we tell the program to actually do specific things
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式，这是我们告诉程序实际执行特定事情的方式
- en: Branching, which is how we tell the program to make a decision
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支，这是我们告诉程序做出决策的方式
- en: Looping, which is how we tell the program to perform extended actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环，这是我们告诉程序执行扩展操作的方式
- en: Structures, which is how we organize information for the program to process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体，这是我们组织信息以便程序处理的方式
- en: Attaching functions to structures or other data types, to make them more useful
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数附加到结构或其他数据类型上，使它们更有用
- en: Functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: We saw a couple of functions, in passing, in the last chapter when we looked
    at the automatically generated boilerplate code created by `cargo new`. What were
    we actually seeing, though?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们查看由`cargo new`自动生成的样板代码时，我们顺便看到了几个函数。我们实际上看到了什么？
- en: A **function** is a sequence of instructions for the computer to follow. It's
    sort of like a recipe. We don't have to tell a person how much flour, sugar, and
    milk to use to bake cookies, if we know that they already have a cookie recipe.
    We can just say: *Bake some cookies, please*. It's similar with a function. We
    don't have to tell the computer exactly how to save some information to a database;
    if there's a `save_to_database` function, we can use it to do the job.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**是一系列计算机需要遵循的指令。它有点像食谱。如果我们知道他们已经有了一个饼干食谱，我们就不必告诉一个人如何使用多少面粉、糖和牛奶来烤饼干。我们只需说：*请烤一些饼干*。函数也是类似的。我们不必告诉计算机如何确切地将一些信息保存到数据库中；如果有`save_to_database`函数，我们可以用它来完成这项工作。'
- en: In Rust, instructions that can tell the computer to take action can *only* be
    written inside of functions. It all starts with a function called `main`, which
    can cause other functions to run, which can in turn cause yet more functions to
    run, and so on. Using our recipe analogy again, it's like a pie recipe saying: *Use
    the recipe on page 57 to make dough for the crust*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，能够告诉计算机采取行动的指令只能写在函数内部。一切始于一个名为`main`的函数，它可以启动其他函数的运行，而这些函数又可以启动更多函数，以此类推。再次使用我们的食谱类比，就像一个馅饼食谱说：*使用第57页的食谱制作饼皮面团*。
- en: Defining a function
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个函数
- en: In Rust, a function starts off with the `fn` keyword. A keyword is a sequence
    of letters or symbols which has a fixed meaning in the language. Nothing we do
    in our program can change the meaning of a keyword, and the libraries we use can't
    change the meaning either. Keywords occasionally have different meaning in clearly
    different contexts, but they always mean the same thing when used in the same
    way. Keywords are the solid foundation that everything else is built on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，函数以`fn`关键字开始。关键字是一系列字母或符号，在语言中有固定的含义。我们在程序中所做的一切都不能改变关键字的含义，我们使用的库也不能改变其含义。关键字在不同的上下文中偶尔有不同的含义，但它们在以相同方式使用时始终具有相同的含义。关键字是构建其他一切的基础。
- en: 'So, the `fn` keyword is used to tell the Rust compiler that we''re about to
    tell it about a new function. After that, separated by a space, comes the function''s
    name. There are rules for what the function name can look like:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`fn`关键字用于告诉Rust编译器我们即将告诉它一个新函数。之后，通过一个空格隔开，接着是函数的名称。函数名称的规则如下：
- en: 'It must be made up of the following:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须由以下内容组成：
- en: English letters (the letters `A` through `Z`, in their lowercase or CAPITAL
    forms)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英语字母（从`A`到`Z`的大写或小写形式）
- en: Arabic numerals (the digits `0` through `9`)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿拉伯数字（数字 `0` 到 `9`）
- en: Underscores(`_`)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线（`_`）
- en: It can't start with a number (so `7samurai` is not a valid name)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能以数字开头（因此 `7samurai` 不是一个有效的名称）
- en: If it starts with an underscore, it must have at least one further character
    (`_` by itself has a special meaning)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它以下划线开头，它必须至少有一个后续字符（`_` 单独具有特殊含义）
- en: Then comes an open parenthesis `(` and a close parenthesis `)`, with a list
    of parameters between them. We're going to gloss over the parameter list for now
    and come back to that later. There doesn't have to be anything between the parenthesis
    if the function does not need parameters, and that's how we'll do it for now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个开括号 `(` 和一个闭括号 `)`，它们之间是参数列表。我们现在暂时跳过参数列表，稍后再回来讨论。如果函数不需要参数，括号之间不需要有任何内容，这就是我们现在要这样做的方式。
- en: After the close parenthesis of the parameter list, we can optionally include
    a `→` symbol followed by a return type, another thing which we'll go into in more
    detail later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数列表的闭括号之后，我们可以选择性地包含一个 `→` 符号，后面跟着返回类型，这是我们稍后会更详细讨论的另一件事。
- en: Next comes a `{` symbol, which tells Rust that we're about to begin a sequence
    of commands, followed by as many commands as we need in order to tell Rust how
    to do what we want the function to do, and then finally a `}` symbol to mark the
    end.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个 `{` 符号，它告诉 Rust 我们即将开始一系列命令，然后是 Rust 需要的命令，以便 Rust 知道我们希望函数做什么，最后是一个
    `}` 符号来标记结束。
- en: 'Going back to the boilerplate code, Let''s take a look at the automatically
    generated `main` function again:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回到样板代码，让我们再次看看自动生成的 `main` 函数：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we can see the `fn` keyword, function name, and empty parameter list.
    The optional return type has been omitted. Then, between the `{` and `}`, we see
    a single instruction, which tells the computer that we want it to print out Hello,
    world! whenever we tell it to run the `main` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `fn` 关键字、函数名和空参数列表。可选的返回类型已被省略。然后，在 `{` 和 `}` 之间，我们看到一条单独的指令，它告诉计算机，每当它被要求运行
    `main` 函数时，我们希望它打印出 Hello, world!。
- en: There's not a lot more to say about functions until we have some understanding
    of what kinds of instructions we can give the computer, between those `{` and
    `}` symbols. The main idea is that we can bundle up many instructions into a function,
    and then use a single instruction elsewhere in the program to tell the computer
    *to do all that stuff*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解了在 `{` 和 `}` 符号之间我们可以给计算机下达哪些指令之前，关于函数就没有太多可以说的了。主要思想是我们可以将许多指令捆绑成一个函数，然后在程序的其他地方使用一条单独的指令来告诉计算机
    *执行所有这些操作*。
- en: Modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Modules give us a way to organize our functions (and other items that have names,
    such as data structures) into categories. This helps us keep things organized,
    and allows us to use the same name more than once, as long as we only use it once
    per module. It also lets us use shorter versions of a thing's name most of the
    time, but gives us a longer version we can use when those short names might be
    confusing or ambiguous.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 模块为我们提供了一种将函数（以及具有名称的其他项目，如数据结构）组织成类别的途径。这有助于我们保持事物有序，并允许我们在模块中多次使用相同的名称，只要我们每次只使用一次。它还让我们大多数时候可以使用该事物的简短版本，但在那些简短名称可能令人困惑或含糊不清的情况下，我们可以使用较长的版本。
- en: Defining a module
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模块
- en: Defining a module is easy. In any `.rs` file which the compiler is going to
    be looking at, we can use the `mod` keyword to start a new module. There are two
    different ways to use that keyword, though, depending on whether we want to define
    the module as a section of the current file or as a separate file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 定义模块很简单。在任何编译器将要查看的 `.rs` 文件中，我们可以使用 `mod` 关键字来开始一个新的模块。尽管如此，使用该关键字有两种不同的方式，这取决于我们是否希望将模块定义为当前文件的一部分或作为单独的文件。
- en: A module as a section of a file
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块作为文件的一部分
- en: To define a module as a section of a file, we use the `mod` keyword followed
    by a name and then a `{` symbol, then the contents of the module, and then a `}`
    symbol to finish it up.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模块定义为文件的一部分，我们使用 `mod` 关键字后跟一个名称，然后是一个 `{` 符号，然后是模块的内容，最后是一个 `}` 符号来完成。
- en: 'So, if we define a new module containing a couple of functions, it would look
    something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们定义一个新的模块，包含几个函数，它看起来可能就像这样：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've created a module named `module_a` and put the `a_thing` and `a_second_thing`
    functions inside of it. We haven't seen it previously, but the line in `a_second_thing`
    that says `a_thing();` is an instruction to the computer to run the `a_thing`
    function. So, when `a_second_thing` runs, the first thing it does is run `a_thing`,
    and then it prints out its own message afterwards.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `module_a` 的模块，并将 `a_thing` 和 `a_second_thing` 函数放入其中。我们之前没有见过它，但
    `a_second_thing` 中的 `a_thing();` 这一行是给计算机运行的 `a_thing` 函数的指令。所以，当 `a_second_thing`
    运行时，它首先运行 `a_thing`，然后打印出它自己的消息。
- en: The `pub` keyword means that `module_a` is part of the public interface of the
    current module, rather than just being internal data. We'll talk more about that
    soon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`pub` 关键字表示 `module_a` 是当前模块的公共接口的一部分，而不仅仅是内部数据。我们很快就会更多地讨论这一点。'
- en: A module as a separate file
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块作为一个独立的文件
- en: 'More often than not, we''re going to want to give our modules their own files.
    It''s just nicer to keep things separated and contained as much as possible, because
    it helps keep the code manageable. Fortunately, this is just as easy. In our `.rs`
    file, we can just write something like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，我们希望给我们的模块它们自己的文件。尽可能地将事物分开并包含起来会更好，因为这有助于保持代码的可管理性。幸运的是，这同样简单。在我们的 `.rs`
    文件中，我们可以简单地写下以下内容：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That looks a lot like the previous example, except that it doesn''t have the
    module contents right there between `{` and `}`. Instead, the Rust compiler goes
    looking for a file called either `module_b.rs` or `module_b/mod.rs`, and uses
    the whole file as the contents of the `module_b` module. So, if the file contains
    a couple of functions similar to the ones we saw previously:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与之前的例子非常相似，只不过它没有在 `{` 和 `}` 之间直接包含模块内容。相反，Rust 编译器会寻找一个名为 `module_b.rs`
    或 `module_b/mod.rs` 的文件，并使用整个文件作为 `module_b` 模块的内容。所以，如果文件包含一些与我们之前看到的类似的功能：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then `module_b` will contain two functions named `a_thing` and `a_second_thing`.
    It's not a problem that those functions have the same names as functions in the
    `module_a` module from before, because they're in a different module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `module_b` 将包含两个名为 `a_thing` 和 `a_second_thing` 的函数。这些函数与之前 `module_a` 模块中的函数同名并不是问题，因为它们在不同的模块中。
- en: Why did the compiler look in two places for the source code of `module_b`? This
    allows us to be more flexible in how we lay out our directory structure for our
    program's source code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么编译器在两个地方寻找 `module_b` 的源代码？这使我们能够更灵活地安排我们程序的源代码目录结构。
- en: Accessing module contents from outside
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部访问模块内容
- en: In the *A module as a section of a file* section, the `a_second_thing` function
    is part of the same module as `a_thing`, so it's automatically allowed to use
    the short version of the other function's name to refer to it. However, code outside
    of the module needs to use the full name to refer to items inside the module.
    There are two ways this can be done. It can either be done directly, which is
    a good choice if we don't expect to be referring to the item often, or we can
    tell Rust that we want to use the short name for an item in a different module,
    which is a good choice if we're going to be using that item often in our code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *模块作为文件的一部分* 部分中，`a_second_thing` 函数是 `a_thing` 函数所在模块的一部分，因此它自动允许使用其他函数的短名称来引用它。然而，模块外的代码需要使用全名来引用模块内的项。这可以通过两种方式完成。可以直接这样做，如果我们不经常引用该项，这是一个不错的选择，或者我们可以告诉
    Rust 我们想要在不同的模块中使用项的短名称，如果我们打算在代码中经常使用该项，这也是一个好的选择。
- en: Using the item's full name directly
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接使用项目的全名
- en: An item's full name consists of the module name, a `::` symbol, and then the
    item's short name. If we have several layers of modules that we need to get through
    before we find the item we want, we list those modules' names in order, with a
    `::` between each name. For example, we might refer to `std::path::Path` to get
    the `Path` item from the `path` module of the `std` module.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的全名由模块名、一个 `::` 符号和项目的短名组成。如果我们需要通过多层模块才能找到我们想要的项，我们按顺序列出这些模块的名称，每个名称之间用 `::`
    隔开。例如，我们可能会引用 `std::path::Path` 来从 `std` 模块的 `path` 模块中获取 `Path` 项。
- en: We can use the full name anywhere and be completely unambiguous as to what item
    we're talking about.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何地方使用全名，并且对所讨论的项目完全明确无误。
- en: Using the item's short name
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用项目的短名
- en: We can also use the `use` keyword to tell Rust that we want to refer to an item
    in a different module by its short name. This is done by just writing `use` followed
    by the full name of the item we want to use. For example, `use std::path::Path;`
    allows us to use just the short name for that item (`Path` in this example) in
    the following instructions, until we come to the `}` that closes the section of
    code where our `use` keyword was written (or we come to the end of the module
    file, which amounts to the same thing).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`use`关键字来告诉Rust我们想要通过短名来引用不同模块中的项。这只需写下`use`后跟我们要使用的项的完整名称即可。例如，`use
    std::path::Path;`允许我们在后续指令中使用该项的短名（在这个例子中是`Path`），直到我们遇到关闭我们`use`关键字所在代码段的大括号`}`（或者我们到达模块文件末尾，这效果相同）。
- en: We can use the same syntax to tell Rust that we want to use the name of a module,
    rather than an item in a module. For example, `std::path` is a valid command.
    That would allow us to use `path::Path` as the name of the `Path` item in subsequent
    code. This is frequently convenient, since it still keeps the external items boxed
    up and separate, while providing reasonably short and informative names to work
    with.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的语法来告诉Rust我们想要使用模块的名称，而不是模块中的项。例如，`std::path`是一个有效的命令。这将允许我们使用`path::Path`作为后续代码中`Path`项的名称。这通常很方便，因为它仍然将外部项封装并分离，同时提供了合理简短且信息丰富的名称来工作。
- en: Public and private module items
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共和私有模块项
- en: In many of the preceding examples, we saw a `pub` keyword. That keyword makes
    the item it's attached to *public*, meaning that it is available to code that
    is not part of the same module. If we omit the `pub` keyword on an item, that
    item is `private`, meaning that it can only be accessed within the module where
    it is defined. Private is the default, so we need to explicitly mark those items
    that we want to have as part of the module's externally accessible interface as
    public by using the `pub` keyword.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多前面的例子中，我们看到了`pub`关键字。该关键字使其附加的项变为`public`，这意味着它对不属于同一模块的代码是可用的。如果我们省略项上的`pub`关键字，则该项是`private`，这意味着它只能在定义它的模块内访问。`private`是默认的，因此我们需要明确标记那些我们希望作为模块外部可访问接口部分的项为`public`，通过使用`pub`关键字。
- en: Making an item private is not a security mechanism. If you're worried that your
    code will be linked with hostile code that might misuse your code or data, making
    the code or data private will not protect against such attacks. Rather, the distinction
    between public and private exists in order to help us make it plain which parts
    of the code are *intended* for use outside of the current module, and which are
    meant to be used only internally. This helps us maintain our software, because
    we are free to make whatever changes we want to to private items, whereas with
    public items, we have to be careful that our changes do not break external things
    we might not even be aware exist.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将项设置为私有并不是一种安全机制。如果你担心你的代码将与恶意代码链接，可能会滥用你的代码或数据，将代码或数据设置为私有将不会防止此类攻击。相反，公共和私有之间的区别存在是为了帮助我们明确哪些代码部分是*打算*在当前模块之外使用的，哪些是打算仅内部使用的。这有助于我们维护软件，因为我们可以在私有项上自由做出任何我们想要的更改，而对于公共项，我们必须小心我们的更改不会破坏我们可能甚至不知道存在的外部事物。
- en: Expressions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: 'The instructions that tell the computer to do something in a Rust program are
    almost all expressions. An expression tells the computer how to compute a particular
    value, and produces that value as its result. In math, *2 + 2* is an expression
    with a resulting value of 4\. Similarly, *(2 + 2) - 1* is an expression with a
    resulting value of 3, which is itself made up of an addition expression and a
    subtraction expression. In Rust, the same basic idea applies: expressions tell
    the computer how to find a value, and they can be combined together, because using
    an expression that produces a value has the same result as using that value directly,
    just as writing (2 + 2) - 1 has the same result as writing 4 - 1.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉计算机在Rust程序中执行某事的指令几乎都是表达式。表达式告诉计算机如何计算特定值，并产生该值作为其结果。在数学中，`2 + 2`是一个结果值为4的表达式。同样，`(2
    + 2) - 1`是一个结果值为3的表达式，它本身由一个加法表达式和一个减法表达式组成。在Rust中，同样的基本思想适用：表达式告诉计算机如何找到一个值，并且它们可以组合在一起，因为使用产生值的表达式与直接使用该值具有相同的结果，就像写作`(2
    + 2) - 1`与写作`4 - 1`具有相同的结果一样。
- en: Not all expressions in Rust look like math, though. Rust is a programming language,
    not just a calculator. It's the idea of expressions, which combine values to produce
    new values, that matters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Rust中的所有表达式看起来并不像数学。Rust是一种编程语言，而不仅仅是一个计算器。重要的是表达式的概念，它们将值组合起来产生新的值。
- en: Literal expressions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量表达式
- en: The simplest of Rust's expressions are the ones where we just write out the
    representation of the value we want. For example, when Rust sees `2` it knows
    we are asking it for the number `2`. Similarly, when Rust sees `"Hello, world!"`
    it knows we're asking it to produce the sequence of letters that spells out *Hello,
    world!*
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Rust最简单的表达式就是我们直接写出我们想要的值的表示。例如，当Rust看到`2`时，它知道我们要求它给出数字`2`。同样，当Rust看到`"Hello,
    world!"`时，它知道我们要求它产生拼写为`Hello, world!`的字母序列。
- en: 'Rust recognizes the following literal expressions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Rust识别以下字面量表达式：
- en: Numbers
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Quoted text
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引号文本
- en: Byte sequences
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节序列
- en: Single Unicode points
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个Unicode点
- en: Single bytes
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个字节
- en: Boolean values
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Numbers can be written as integers or decimal numbers or in engineering notation,
    and there are a few variants for quoted text and byte sequences, too. Boolean
    values are written as either `true` or `false`. In this book, we're not going
    to need any of the variants of quoted text, and we won't need byte sequences at
    all, so we won't go into those in more detail. See [https://doc.rust-lang.org/](https://doc.rust-lang.org/)
    if you're curious.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可以写成整数、十进制数或工程记数法，对于引号文本和字节序列也有几种变体。布尔值写作`true`或`false`。在这本书中，我们不需要任何引号文本的变体，也不需要字节序列，所以不会详细介绍这些。如果你好奇，请参阅[https://doc.rust-lang.org/](https://doc.rust-lang.org/)。
- en: Operator expressions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符表达式
- en: Again, like math, Rust has a number of symbolic **operators** that can be applied
    to values to transform them into some new value. For example, `+` is a Rust operator
    that adds two values together. So, `2 + 2` is a Rust expression adding the number
    2 to itself, producing the number 4\. Rust also uses `-` as the subtraction operator,
    `*` as the multiplication operator, `/` as the division operator, and `%` as the
    remainder operator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，像数学一样，Rust有许多可以应用于值以将它们转换为新值的符号**运算符**。例如，`+`是Rust运算符，用于将两个值相加。所以，`2 + 2`是一个Rust表达式，将数字2加到自身，产生数字4。Rust还使用`-`作为减法运算符，`*`作为乘法运算符，`/`作为除法运算符，`%`作为余数运算符。
- en: Rust is not limited to mathematical operators, though. In Rust, `&` means *and*,
    `|` means *or*, `^` means *exclusive or*, `!` means *not* (`!true` is `false`,
    for example), `<<` means *leftward bit shift*, and `>>` means *rightward bit shift*.
    Sometimes the meanings of those operations depends on the type of value that they're
    acting on. For example, `|` means *bitwise or* when applied to integers, but *logical
    or* when applied to Boolean values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Rust不仅限于数学运算符。在Rust中，`&`表示`and`，`|`表示`or`，`^`表示`exclusive or`，`!`表示`not`（例如，`!true`是`false`），`<<`表示`leftward
    bit shift`，`>>`表示`rightward bit shift`。有时这些运算符的含义取决于它们所作用值的类型。例如，当应用于整数时，`|`表示`bitwise
    or`，但当应用于布尔值时，表示`logical or`。
- en: Then there are the comparison operators. The `==` operator means *check whether
    two values are equal*. An expression built around the `==` operator produces the
    Boolean value `true` if the two values being compared are equal, and `false` if
    they are not. So, for example, `5 == 4` is an expression producing `false` as
    its result. Similarly, `!=` means *not equal*, `>` means *greater than*, `<` means
    *less than*, `>=` means *greater than or equal*, and `<=` means *less than or
    equal*. All of them produce `true` when the relationship is correct, and `false`
    when it is not.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是比较运算符。`==`运算符表示`check whether two values are equal`。围绕`==`运算符构建的表达式，如果被比较的两个值相等，则产生布尔值`true`，如果不相等，则产生`false`。所以，例如，`5
    == 4`是一个产生`false`结果的表达式。同样，`!=`表示`not equal`，`>`表示`greater than`，`<`表示`less than`，`>=`表示`greater
    than or equal`，`<=`表示`less than or equal`。所有这些在关系正确时都产生`true`，在关系不正确时产生`false`。
- en: Finally, Rust recognizes `&&` and `||` operators. These can only be applied
    to Boolean (`true` or `false`) values, and produce the same results as `&` and
    `|` do when applied to the same values. The difference is that `&&` and `||` are
    what is called *lazy* or *short-circuit* operators, which means that they will
    not bother evaluating their right-side operand if the left-side operand provides
    enough information to determine the operator's produced value. For example, for
    the expression `false && some_expensive_calculation()`, Rust will never bother
    to run the `some_expensive_calculation` function, because no matter what the function
    produced as its result, the result of the `&&` operation is going to be `false`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Rust 识别 `&&` 和 `||` 操作符。这些只能应用于布尔值（`true` 或 `false`），并且当应用于相同的值时，它们会产生与 `&`
    和 `|` 相同的结果。区别在于 `&&` 和 `||` 是所谓的 *懒* 或 *短路* 操作符，这意味着如果左侧操作数提供了足够的信息来确定操作符产生的值，它们将不会麻烦去评估其右侧操作数。例如，对于表达式
    `false && some_expensive_calculation()`，Rust 将永远不会麻烦去运行 `some_expensive_calculation`
    函数，因为无论该函数产生什么结果，`&&` 操作的结果都将为 `false`。
- en: In most situations where we'd use `&` or `|` on Boolean values, we should use
    `&&` or `||` instead, since it allows Rust to be a little more efficient, especially
    if we're mindful enough to put the more expensive operations on the right side
    of the operator.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当我们会在布尔值上使用 `&` 或 `|` 时，我们应该使用 `&&` 或 `||`，因为这样可以使得 Rust 更有效率，特别是如果我们足够细心，将更昂贵的操作放在操作符的右侧。
- en: These are not a full list of Rust's operators, and we'll see some of the more
    specialized ones as we move onward through the language. These are the operators
    we need for expressing the majority of calculations, computations, and decisions
    in our programs, though.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是 Rust 操作符的完整列表，随着我们继续学习这门语言，我们将看到一些更专业的操作符。这些是我们表达程序中大多数计算、计算和决策所需的操作符。
- en: Array and tuple expressions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和元组表达式
- en: An **array** is a sequential collection of data values. There are many ways
    to use and manipulate them, but here we're interested in the specialized expressions
    that create them and access their internal data values. To tell Rust that we want
    to create a new array, all we have to do is write a `[` symbol, and then a comma-separated
    list of expressions that produce the values we want to store in the array, and
    then a `]` symbol. There doesn't have to be anything between the beginning and
    ending symbols if we want an empty array. So, we can write `[]` as an expression
    producing an empty array, or `[1, 3, 5]` as an expression producing an array containing
    three numbers. All of the values stored in an array need to have the same data
    type—integers in this case—so trying to set the second element to a text string
    such as `"nope"` would produce a compiler error when we tried to compile the program.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是一系列数据值的顺序集合。有许多使用和操作它们的方法，但在这里我们感兴趣的是创建它们并访问其内部数据值的专用表达式。要告诉 Rust 我们想要创建一个新的数组，我们只需要写一个
    `[` 符号，然后是一个逗号分隔的表达式列表，这些表达式产生我们想要存储在数组中的值，最后是一个 `]` 符号。如果我们想要一个空数组，那么在开始和结束符号之间不需要有任何内容。因此，我们可以将
    `[]` 写作产生空数组的表达式，或者将 `[1, 3, 5]` 写作产生包含三个数字的数组的表达式。数组中存储的所有值都需要具有相同的数据类型——在这个例子中是整数——所以如果我们尝试将第二个元素设置为文本字符串，例如
    `"nope"`，那么在尝试编译程序时会产生编译器错误。'
- en: That's really nice for cases where we need to create a short array, but imagine
    writing out an expression for an array containing a thousand values! We wouldn't
    want to write them out one by one. Fortunately, we can instead do something like
    `[0; 1000]`, which produces an array containing a thousand zero values. Some other
    part of our code can then fill in different values in those slots.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于需要创建短数组的场景来说非常好，但想象一下编写包含一千个值的数组的表达式！我们不想逐个写出它们。幸运的是，我们可以做类似 `[0; 1000]`
    的事情，这将产生一个包含一千个零值的数组。然后，代码的另一个部分可以填充这些槽位中的不同值。
- en: Once we have an array value, we often need access to the values stored inside
    it. That too is achieved using the `[` and `]` symbols. If we have an array named
    `an_array` (we'll see how to give values names in the *Variables, types, and mutability*
    section of this chapter), we can access the first value in the array as `an_array[0]`,
    the second value as `an_array[1]`, and so on. Notice that the first value is numbered
    with `0`, while the second is `1`. Many programming languages count this way,
    because it simplifies some of the math that they frequently need to do with respect
    to arrays and other sequences of values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个数组值，我们通常需要访问存储在其中的值。这也通过使用 `[` 和 `]` 符号来实现。如果我们有一个名为 `an_array` 的数组（我们将在本章的
    *变量、类型和可变性* 部分中看到如何给值命名），我们可以通过 `an_array[0]` 访问数组中的第一个值，通过 `an_array[1]` 访问第二个值，依此类推。请注意，第一个值用
    `0` 编号，而第二个值用 `1` 编号。许多编程语言都是这样计数的，因为这简化了它们经常需要与数组和其他值序列一起进行的某些数学运算。
- en: 'In addition to arrays, Rust allows us to make **tuples**. The expression to
    create a tuple is similar to that for arrays: `(1, "wow", true)` is a tuple containing
    the number value `1`, the text value `wow`, and the Boolean `true`. If we have
    a tuple named `a_tuple`, then `a_tuple.1` produces the second value in the tuple,
    in this case the word `wow`. There''s no simplified way to create a tuple containing
    a thousand duplicates, though, because that''s not what they''re for. Unlike arrays,
    a single tuple can contain values of more than one value type, and they are intended
    to serve as lightweight data structures, rather than as a collection of many similar
    data values.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数组之外，Rust 允许我们创建 **元组**。创建元组的表达式与数组类似：（1，“wow”，true）是一个包含数字值 `1`、文本值 `wow`
    和布尔值 `true` 的元组。如果我们有一个名为 `a_tuple` 的元组，那么 `a_tuple.1` 将产生元组中的第二个值，在这种情况下是单词 `wow`。但是，没有简化的方式来创建包含一千个重复值的元组，因为它们不是为此而设计的。与数组不同，单个元组可以包含多个不同类型的值，它们旨在作为轻量级的数据结构，而不是作为许多相似数据值的集合。
- en: In some languages, the contents of a tuple cannot be changed. That's not how
    it works in Rust, though, where tuples follow the same rules for that sort of
    thing as any other data structure.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，元组的元素内容不能被更改。然而，在 Rust 中并非如此，Rust 中的元组遵循与其他数据结构相同的规则。
- en: 'If we need to make a tuple with only one contained value (which is not common,
    because the whole point of a tuple is to associate multiple values together),
    we need to include a comma after the value. So, a single-element tuple containing
    the number 5 looks like this: `(5,)`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要创建一个只包含一个元素的元组（这并不常见，因为元组的主要目的是将多个值关联在一起），我们需要在值后面包含一个逗号。因此，包含数字 5 的单元素元组看起来是这样的：（5，）
- en: Block expressions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块表达式
- en: Sometimes, the necessary steps to figure out an expression's result value just
    don't fit into a single expression of the sorts we've looked at before. Maybe
    they need to store a data value for a little while in order to execute efficiently,
    or are otherwise too complex to be reasonably written in the *1 + ((2 * 57) /
    13)* style.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，确定表达式结果值的必要步骤根本不适合我们之前看到的单表达式。也许它们需要暂时存储一个数据值以执行效率更高，或者在其他方面过于复杂，无法以 *1
    + ((2 * 57) / 13)* 的风格合理编写。
- en: That's where block expressions come in. Block expressions look a lot like the
    body of a function because the body of a function *is* a block expression. They
    start with `{` and end with `}`. Between those two markers, we can write whatever
    instructions we need, including doing things like defining variables or other
    named items.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是块表达式的作用。块表达式看起来很像函数的主体，因为函数的主体就是一个块表达式。它们以 `{` 开始，以 `}` 结束。在这两个标记之间，我们可以编写所需的任何指令，包括定义变量或其他命名项。
- en: At the very end of the block should come the expression that produces the final
    result value of the block. So, for example, the block expression `{ 2 + 2; 19
    % 3; println!("In a block"); true}` is a (kind of silly) block expression that
    produces the Boolean `true` as its result, but not until after it has calculated
    that 2 plus 2 equals 4, and calculated that the remainder of 19 over 3 is 1, and
    printed out *In a block* to the console.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在块的末尾应该出现产生块最终结果值的表达式。例如，块表达式 `{ 2 + 2; 19 % 3; println!("In a block"); true}`
    是一个（有点愚蠢的）块表达式，其结果为布尔值 `true`，但不是在它计算出 2 加 2 等于 4、计算出 19 除以 3 的余数是 1、并将 *In a
    block* 打印到控制台之后。
- en: By the way, the Rust compiler will warn us about that block expression, because
    it calculates two values and then just discards them. That's wasteful, so Rust
    points it out. If optimizations are enabled, the compiler will actually skip generating
    code to calculate the values at all, but that's an optimization, and the program
    and compiler are still supposed to act as if they did perform the calculations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，Rust 编译器会警告我们关于那个块表达式，因为它计算了两个值，然后又把它们丢弃了。这是浪费的，所以 Rust 会指出这一点。如果启用了优化，编译器实际上会跳过生成计算这些值的代码，但这只是一个优化，程序和编译器仍然应该像它们确实执行了计算一样行事。
- en: Notice the semicolons (`;`) in the block expression. Every top-level instruction
    in the block has a semicolon after it, *except the last one*. That's because the
    semicolon tells Rust that the expression before it should be treated as a **statement**,
    which basically means that it won't produce a value, or if it does, we don't care
    what that value is. In some cases, the semicolon can be left off of expressions
    prior to the last one in a block, but I don't recommend it, because explicitly
    discarding the results of expressions whose results we're not going to use allows
    the compiler more freedom to make inferences and optimizations, and can help avoid
    some fairly obscure compiler errors.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意块表达式中的分号（`;`）。块中的每个顶级指令后面都有一个分号，*除了最后一个之外*。这是因为分号告诉 Rust，它前面的表达式应该被视为一个**语句**，这意味着它不会产生值，或者即使产生了值，我们也不关心那个值是什么。在某些情况下，可以在块中最后一个表达式之前省略分号，但我不建议这样做，因为明确地丢弃我们不会使用的表达式的结果，可以让编译器有更多的自由来做出推断和优化，并且可以帮助避免一些相当隐晦的编译器错误。
- en: 'If we put a `;` after the final expression in a block, we''re saying that the
    block doesn''t have a meaningful resulting value at all. In that case, it ends
    up having `()` as its resulting value. That''s an empty tuple, which is a pretty
    good way of saying: *Nothing to see here, folks*. `()` is used that way throughout
    the Rust language and libraries.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在块中的最后一个表达式后面放一个 `;`，这意味着该块根本没有任何有意义的返回值。在这种情况下，它最终会有一个 `()` 作为其返回值。这是一个空元组，这是一个很好的方式来说明：*这里没有什么可看的*。`()`
    在 Rust 语言和库中就是这样使用的。
- en: Branch expressions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支表达式
- en: 'One of the things that makes programs truly useful is the ability for them
    to make decisions. We can do that in Rust by using an `if` expression. An `if`
    expression looks something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 程序真正有用的一个特点就是它们能够做出决策。在 Rust 中，我们可以通过使用 `if` 表达式来实现这一点。一个 `if` 表达式看起来可能像这样：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you're familiar with other programming languages, you might be wondering
    where the parenthesis are around the condition expression. Rust's syntax doesn't
    call for parenthesis there. In fact, if we place the condition in parenthesis,
    the compiler will warn us that they're not necessary.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他编程语言，你可能会想知道条件表达式周围为什么没有括号。Rust 的语法并不要求在那里使用括号。实际上，如果我们把条件放在括号里，编译器会警告我们这些括号是不必要的。
- en: What we have here is an expression that shows off all the features of an `if`.
    It starts off with the keyword `if`, followed by a *condition expression* that
    produces either `true` or `false`, and then a block expression. If the condition
    expression produces `true`, the block expression is run, but if the condition
    expression produces `false`, the block expression is not run.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个展示 `if` 所有功能的表达式。它从关键字 `if` 开始，后面跟着一个产生 `true` 或 `false` 的*条件表达式*，然后是一个块表达式。如果条件表达式产生
    `true`，则执行块表达式，但如果条件表达式产生 `false`，则不执行块表达式。
- en: Using `3 > 4` as our condition expression is not very useful. We might as well
    just write `false`, or leave that block expression out entirely since it will
    never run. However, in real code, we would use a condition expression whose result
    we would not know at the time we were writing the code. *Is it between the hours
    of 8 A.M. and 5 P.M.*, *Did the user select this value from the menu*, and *Does
    the value match what is stored in the database* are examples of more realistic
    conditions, though of course they would have to be expressed in Rust.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `3 > 4` 作为我们的条件表达式并不是很有用。我们完全可以只写 `false`，或者完全省略那个块表达式，因为它永远不会被执行。然而，在实际代码中，我们会使用一个条件表达式，其结果在我们编写代码时我们并不知道。例如，*是否在上午8点到下午5点之间*、*用户是否从菜单中选择了这个值*，以及*值是否与数据库中存储的值匹配*，这些都是更现实的条件，尽管当然它们必须用
    Rust 表达出来。
- en: After that, we have an `else if` and another condition expression and block.
    That means that, if the first condition expression produced `false`, the computer
    should check whether the second one produces `true`, and if it does, run the associated
    block expression.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有一个 `else if` 和另一个条件表达式和代码块。这意味着，如果第一个条件表达式返回 `false`，计算机应该检查第二个是否返回 `true`，如果是，就运行相关的代码块。
- en: We can chain as many `else if` expressions as we want after an initial `if`,
    so there's no limit to the number of different options we can make available to
    the computer. However, only one of them will run after any given decision. The
    computer will start with the initial `if` and check the values of the conditional
    expressions one at a time until it finds one that produces `true`, then it will
    run the associated block expression, and then it will be done with the if expression
    and move on to the subsequent instructions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在初始 `if` 之后链式连接尽可能多的 `else if` 表达式，因此我们可以提供给计算机的不同选项数量没有限制。然而，在任何给定的决策之后，只有一个会运行。计算机将从初始
    `if` 开始，逐个检查条件表达式的值，直到找到一个返回 `true` 的，然后它会运行相关的代码块，然后它会完成 `if` 表达式并继续后续指令。
- en: After an `if` and any `else if` we might wish to include, we are allowed to
    put an `else` followed by a block expression. This is a branch without a condition,
    and what it means is *if none of the condition expressions produced* `true`, *do
    this*. In other words, it allows us to tell the computer what to do by default,
    if none of the special cases we provided apply.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 和我们可能希望包含的任何 `else if` 之后，我们可以放置一个 `else` 后跟一个代码块。这是一个没有条件的分支，它的意思是 *如果没有任何条件表达式产生*
    `true`，*就执行这个操作*。换句话说，它允许我们告诉计算机在没有提供特殊情况的默认情况下应该做什么。
- en: Loop expressions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环表达式
- en: 'Another of the basic abilities that make programs useful is looping. Rust has
    several different kinds of loops, but we''re going to look at two of them here:
    `while` loops and `for` loops.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 程序变得有用的基本能力之一是循环。Rust 有几种不同的循环类型，但我们将在这里查看两种：`while` 循环和 `for` 循环。
- en: while loops
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: A `while` loop is a lot like an `if` expression. The difference is, instead
    of checking the condition expression once and then either running the block expression
    or not, and then being done, a `while` loop keeps repeating the process until
    the condition expression produces `false`. So, if the condition expression results
    in `false` right away, the block expression never runs. On the other hand, if
    the condition expression produces `true` on the first check, the block expression
    gets run, and then the condition expression is evaluated again. If it produces
    `true` again, the block runs again, and so on, until the condition expression
    finally produces `false`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环与 `if` 表达式非常相似。区别在于，`while` 循环不是只检查一次条件表达式，然后根据结果运行或跳过代码块，之后结束，而是会重复这个过程，直到条件表达式产生
    `false`。所以，如果条件表达式一开始就返回 `false`，代码块就不会运行。另一方面，如果条件表达式第一次检查就返回 `true`，代码块就会运行，然后再次评估条件表达式。如果它再次返回
    `true`，代码块会再次运行，以此类推，直到条件表达式最终返回 `false`。'
- en: That means that it's very important for the block expression to change something
    that affects the condition expression's result. If the condition expression produces
    `true` and the block doesn't have any chance of changing that, the program will
    be stuck looping through that block over and over until the program is forcefully
    terminated. This is the easiest way to cause your program to freeze.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着代码块必须改变影响条件表达式结果的内容非常重要。如果条件表达式返回 `true` 而代码块没有机会改变这一点，程序将会陷入不断循环执行该代码块，直到程序被强制终止。这是导致程序冻结的最简单方法。
- en: 'So, here''s a simple `while` loop:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是一个简单的 `while` 循环：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We're using a variable named `i` here, which we'll talk about more in the *Variables
    and mutability* section of this chapter. For now, just think of `i` as a name
    that we can assign different values to at different times, sort of like how we
    can ask different people to sit in the same chair at different times.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个名为 `i` 的变量，我们将在本章的 *变量和可变性* 部分详细讨论。现在，只需将 `i` 视为一个可以在不同时间赋予不同值的名称，有点像我们可以在不同时间让不同的人坐在同一把椅子上。
- en: 'So, we have the `while` keyword followed by a condition expression. This condition
    expression uses a variable, which we change the value of in the block expression,
    so we''re not in danger of looping forever. If `i` starts with the value `0`,
    we should see the block expression run three times: once when `i` is `0`, once
    when `i` is `1`, and once when `i` is `2`. When `i` gets to `3`, the condition
    expression produces `false` as its result (3 is not less than 3), and the loop
    stops.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有`while`关键字后跟一个条件表达式。这个条件表达式使用一个变量，我们在块表达式中改变其值，所以我们不会陷入无限循环的危险。如果`i`的初始值为`0`，我们应该看到块表达式运行三次：一次当`i`为`0`时，一次当`i`为`1`时，一次当`i`为`2`时。当`i`达到`3`时，条件表达式产生`false`作为其结果（3不小于3），循环停止。
- en: for loops
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for循环
- en: Sometimes, `while` loops are exactly what we need, but the two most common needs
    for looping are to loop a specific number of times or to use a loop to process
    each element contained in an array or similar data structure. In both of these
    cases, `for` loops work better.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`while`循环正是我们所需要的，但循环的两个最常见需求是循环特定次数或使用循环来处理数组或类似数据结构中的每个元素。在这两种情况下，`for`循环表现更好。
- en: A `for` loop runs its block expression once for each value produced by an **iterator**.
    An iterator is a special kind of data value that has the job of returning a sequence
    of values, one at a time. An iterator for an array, for example, produces a different
    member of the array each time we ask it for a value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`for`循环会对其块表达式进行一次迭代，每次迭代都会产生一个由**迭代器**生成的值。迭代器是一种特殊的数据值，其任务是逐个返回一系列值。例如，数组的迭代器每次被请求值时，都会产生数组的一个不同成员。
- en: 'To loop a specific number of times, we can use a `for` loop along with a **range
    expression**, which is an expression that produces an iterator over a sequence
    of numbers. Let''s look at a concrete example of that:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要循环特定次数，我们可以使用`for`循环和**范围表达式**，这是一个产生一系列数字的迭代器的表达式。让我们看看一个具体的例子：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We started off with the `for` keyword and then `num`, which is the name which
    is going to be given to each value that the iterator produces, one at a time,
    as those values are processed by the `for` loop. Then comes another keyword, `in`.
    Finally, the expression that produces our iterator. In this case, we have a range
    expression, which represents the values `3`, `4`, `5`, and `6`. Notice that `7`
    is not included in the range. As with counting from zero, this makes some of the
    math easier for the computer to do, and in this case, it makes things easier for
    us most of the time as well. If we want to loop seven times, we could just write
    `0..7`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`for`关键字开始，然后是`num`，这是将要赋予迭代器逐个产生的每个值的名称，当这些值被`for`循环处理时，一次一个。然后是另一个关键字`in`。最后，产生我们的迭代器的表达式。在这种情况下，我们有一个范围表达式，它表示值`3`、`4`、`5`和`6`。注意，`7`不包括在范围内。与从零开始计数一样，这使计算机的一些数学运算变得更容易，在这种情况下，这也使我们的操作更容易。如果我们想循环七次，我们只需写`0..7`。
- en: 'There is a variant we could use that would include the final number in the
    output, should we need it: `3..=7`. Just remember that if you loop through `0..=7`,
    you''re going to be running the block expression eight times.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个变体来包含输出中的最后一个数字，如果我们需要的话：`3..=7`。只需记住，如果你通过`0..=7`循环，你将运行块表达式八次。
- en: 'The other time when `for` loops shine is when we have a collection of actual
    values that we want to process, as the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环闪耀的另一个时刻是我们有一个想要处理的实际值的集合，如下面的例子所示：'
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This loop prints out each of the words in the array, each on their own line. The
    `word` name is set to the first value produced by the iterator, `"Hello"`, and
    the block expression is run. Then `word` is set to the second value produced by
    the iterator, `"world"`, and the block expression is run again. This continues
    until the iterator runs out of values to produce, and then stops.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会打印出数组中的每个单词，每个单词占一行。`word`名称被设置为迭代器产生的第一个值`"Hello"`，然后运行块表达式。然后`word`被设置为迭代器产生的第二个值`"world"`，再次运行块表达式。这会一直持续到迭代器没有更多的值可以产生，然后停止。
- en: 'Here, our iterator is producing the values stored in an array. The `.iter()`
    part of that expression is saying, basically: *Arrays know how to make iterators
    for themselves, so ask the array to give us an iterator*. We''ll see more about
    how to implement functions that are specific to a data type in a later chapter,
    but for now, we just need to know that that''s what the `.` symbol means: the
    thing on the right of the dot is specific to the thing on the left. We are asking
    the computer to run, not just any `iter` function, but the `iter` function that
    is associated with our array.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的迭代器正在生成数组中存储的值。那个表达式的`.iter()`部分基本上是在说：*数组知道如何为自己创建迭代器，所以请求数组给我们一个迭代器*。我们将在后面的章节中看到更多关于如何实现特定于数据类型的函数的内容，但就现在而言，我们只需要知道`.`符号的含义：点右侧的东西是点左侧东西的特定部分。我们要求计算机运行的不是任何`iter`函数，而是与我们的数组关联的`iter`函数。
- en: Variables, types, and mutability
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量、类型和可变性
- en: A variable is a named box in which a data value can be stored. The variable
    itself isn't the data value, just like a carton of milk is not the same thing
    as milk (it's waxed cardboard and such *containing* milk).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是一个可以存储数据值的命名盒子。变量本身不是数据值，就像一盒牛奶不等于牛奶（它是由蜡纸和类似物质*包含*牛奶）。
- en: On the other hand, if somebody needs milk and you hand them a full milk carton,
    they're not going to complain, and the same goes for Rust. If a Rust expression
    needs an integer, and we provide a variable containing an integer, Rust will be
    perfectly happy with that.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果有人需要牛奶，你递给他们一盒满牛奶，他们不会抱怨，对于Rust也是如此。如果一个Rust表达式需要一个整数，而我们提供了一个包含整数的变量，Rust会对此感到非常满意。
- en: 'Variables are most often created using the `let` keyword:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 变量通常使用`let`关键字创建：
- en: '`let x = 10;`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`let x = 10;`'
- en: This statement creates a variable called `x` containing the `10` value in it.
    Once that's done, we can refer to `x` as part of the expressions. For example,
    `x + 5` is now a valid expression, with a resulting value of `15`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句创建了一个名为`x`的变量，其中包含`10`值。一旦完成，我们就可以将`x`作为表达式的一部分来引用。例如，`x + 5`现在是一个有效的表达式，其结果值为`15`。
- en: The names that `for` loops use are also variables, as are function parameters,
    although they are not created with the `let` keyword.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环使用的名称也是变量，函数参数也是如此，尽管它们不是用`let`关键字创建的。'
- en: 'In addition to having a name, variables are characterized by the type of value
    they can store. Each variable can store one kind of value, and can never store
    any other type of information. Rust can often figure out what type of information
    a given variable can store, but we always have the option of being explicit about
    it. If we tell Rust that `let x: i32 = 99;`then Rust will make sure that the `x`
    variable can store a 32-bit signed integer and report an error if we try to store
    something else there. On the other hand, `let x: f64 = 999.0;`tells Rust that
    we want `x` to store a 64-bit floating-point number and that trying to store anything
    else there is an error.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '除了有名称之外，变量还以其可以存储的值的类型为特征。每个变量可以存储一种类型的值，并且永远不能存储任何其他类型的信息。Rust通常可以确定给定变量可以存储的信息类型，但我们始终有明确指定它的选项。如果我们告诉Rust`let
    x: i32 = 99;`，Rust将确保`x`变量可以存储32位有符号整数，如果我们尝试存储其他东西，它会报告一个错误。另一方面，`let x: f64
    = 999.0;`告诉Rust我们希望`x`存储64位浮点数，并且尝试存储其他任何东西都是错误的。'
- en: 'We don''t have to provide an initial value for a variable. For example, we
    could say `let x: u16;`to tell Rust that the `x` variable needs to be able to
    store 16-bit unsigned integers. That''s fine. However, if it''s even possible
    that some of our code will try to use the contents of the variable without first
    having stored some contents there to be used, the Rust compiler will consider
    that an error. It''s usually easier to just provide a starting value when we create
    a variable.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不必为变量提供一个初始值。例如，我们可以说`let x: u16;`来告诉Rust，`x`变量需要能够存储16位无符号整数。这是可以的。然而，如果有可能我们的某些代码会尝试使用变量的内容，而在此之前没有存储任何内容，Rust编译器会认为这是一个错误。通常在创建变量时直接提供一个起始值会更容易一些。'
- en: Variables are called **variables** because the values they contain can be changed.
    Except in Rust, by default, they can't. Rust allows us to use multiple `let` statements
    to create new variables with the same names as old variables, but we can't just
    assign a new value to an existing variable, unless that variable is **mutable**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 变量被称为 **变量**，因为它们包含的值可以改变。但在 Rust 中，默认情况下，它们不能。Rust 允许我们使用多个 `let` 语句创建与旧变量具有相同名称的新变量，但我们不能只是给现有变量赋新值，除非该变量是
    **可变的**。
- en: Creating a new variable with the same name as an existing variable is called **shadowing** the
    old variable. A shadowed variable still contains the value it did before, but
    cannot be accessed by name any more, because that name now belongs to a different
    variable. If there are any references to the old variable still in play, they
    will still be accessing the old variable, though, not the new one.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与现有变量相同名称创建新变量被称为**遮蔽**旧变量。被遮蔽的变量仍然包含其之前的值，但不能再通过名称访问，因为那个名称现在属于另一个变量。如果还有任何对旧变量的引用仍在使用中，它们仍然会访问旧变量，而不是新变量。
- en: 'Being mutable just means that the variable will accept changes, up to and including
    a whole new value. We use the `mut` keyword to tell Rust that a variable should
    be mutable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可变只是意味着变量将接受更改，包括完全新的值。我们使用 `mut` 关键字告诉 Rust 一个变量应该是可变的：
- en: '`let mut x = 17;`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`let mut x = 17;`'
- en: 'The new `x` variable is mutable. That means we can modify its contents:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `x` 变量是可变的。这意味着我们可以修改其内容：
- en: '`x = 0;`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`x = 0;`'
- en: Instead of containing `17`, `x` now contains `0`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `x` 不再包含 `17`，而是包含 `0`。
- en: 'The equal symbol (`=`) that we''re using for variables is not a statement of
    mathematical equality. It doesn''t mean: *These two things are defined as being
    the same*. Instead it means: *Right here, right now, the value produced by the
    expression on the right side of the* `=` *is to be stored in the variable on the
    left*. This would be nonsense in math, but it makes perfect sense in Rust:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于变量的等号（`=`）不是数学等式的陈述。它并不意味着：“这两个东西被定义为相同”。相反，它意味着：“在这里，现在，右侧表达式的值要存储在左侧的变量中”。这在数学中是荒谬的，但在
    Rust 中却完全合理：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Rust has quite a lot of built-in data types. We've seen `i32`, `f64`, and `u16`,
    which are 32-bit signed integer, 64-bit floating point, and 16-bit unsigned integer,
    respectively. There are also more types following the same pattern, such as `u64`
    for an unsigned 64-bit integer, as well as types such as `bool` for Boolean values;
    `isize` and `usize` for signed and unsigned integers that take up the same number
    of bits as a memory address on the target architecture; and `char` and `str` for
    single Unicode code points and sequences of them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有相当多的内置数据类型。我们已经看到了 `i32`、`f64` 和 `u16`，分别是 32 位有符号整数、64 位浮点数和 16 位无符号整数。还有更多遵循相同模式的数据类型，例如
    `u64` 用于无符号 64 位整数，以及如 `bool` 用于布尔值；`isize` 和 `usize` 用于与目标架构上的内存地址占用相同数量的位的有符号和无符号整数；以及
    `char` 和 `str` 用于单个 Unicode 代码点和它们的序列。
- en: These are known as primitive types, because they're inherent to the language.
    However, Rust also allows us to create new types, and so the Rust standard library
    contains many more data types that are suited to various specific uses, and there
    are even more available in third-party libraries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为原始类型，因为它们是语言固有的。然而，Rust 也允许我们创建新的类型，因此 Rust 标准库包含许多适合各种特定用途的数据类型，第三方库中还有更多。
- en: Type inference
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'As we noticed earlier, we can specify the type of a variable, but we often
    don''t have to. That''s because Rust has a feature called type inference, which
    often lets it figure out what type a variable is by looking at what we do with
    it. For example, if we were using the Tokio networking library, we might use code
    such as this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前注意到的，我们可以指定变量的类型，但通常不必这样做。这是因为 Rust 有一个名为类型推断的功能，它通常可以通过观察我们对变量的操作来推断变量的类型。例如，如果我们使用
    Tokio 网络库，我们可能会使用如下代码：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We didn't specify what type the `addr` variable should have. Even more interesting,
    we didn't tell the text address what kind of information we needed it to parse
    into.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有指定 `addr` 变量应该有什么类型。更有趣的是，我们没有告诉文本地址我们需要它解析成什么类型的信息。
- en: '**Parsing** means *transforming a representation into usable data*, approximately.
    Lots of things can be represented as a string of text, if you know how to parse
    that text into the information you really want.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析**意味着*将表示形式转换为可用的数据*，大约如此。许多东西都可以表示为文本字符串，如果你知道如何将文本解析成你真正想要的信息。'
- en: The question marks in this example are part of Rust's error handling mechanism,
    and the ampersand is an operator that affects how the `addr` variable is shared
    with the function. We'll see more on both of those soon.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中的问号是Rust的错误处理机制的一部分，而&符号是一个影响`addr`变量如何与函数共享的运算符。我们很快就会看到这两个方面的更多内容。
- en: However, Rust can see that we're passing the `addr` variable (or rather, a reference
    to it, but more on that in the next chapter) as a parameter of the `TcpListener::bind`
    function, and it knows that that function needs a reference to a `SocketAddr`,
    so `addr` must be a `SocketAddr`. Then, since it has figured out that `addr` is
    a `SocketAddr`, it takes it a step further and determines that it should use the
    string parsing function that produces a `SocketAddr` as its resulting value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Rust可以看到我们正在将`addr`变量（或者更确切地说，它的引用，但下一章会详细介绍）作为`TcpListener::bind`函数的参数传递，并且它知道该函数需要一个`SocketAddr`的引用，所以`addr`必须是`SocketAddr`。然后，由于它已经确定`addr`是`SocketAddr`，它进一步确定应该使用产生`SocketAddr`的字符串解析函数作为其结果值。
- en: Type inference can save an amazing amount of time in a language as strict as
    Rust. On the other hand, it can be surprising if you see an error message about
    a data type you've never heard of, because Rust decided that it was the one you
    needed. If that happens, try assigning the type you actually expect to your variable
    and see what the Rust compiler has to say afterward.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断可以在像Rust这样严格的编程语言中节省大量的时间。另一方面，如果你看到一条关于你从未听说过的数据类型的错误消息，可能会感到惊讶，因为Rust决定这正是你需要的数据类型。如果发生这种情况，尝试将你实际期望的类型分配给你的变量，并看看Rust编译器之后会说什么。
- en: Data structures
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: Creating a data structure is one of the ways to add a new data type to Rust.
    A data structure is a group of variables that have been attached to each other,
    resulting in a single new data type that means *all of these, together*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据结构是将新数据类型添加到Rust中的方法之一。数据结构是一组相互关联的变量，它们组合成一个新的数据类型，意味着*所有这些一起*。
- en: 'A new structure is defined using the `struct` keyword:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`struct`关键字定义一个新的结构体：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice the commas after each contained variable is defined. It can be tempting
    to use semicolons there, but that would cause a compiler error. The final comma
    is optional, but recommended, because it means that the lines can be rearranged
    without having to pay attention to where a comma might be missing, among other
    reasons.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在定义每个包含变量之后都有逗号。在那里使用分号可能会很有诱惑力，但那会导致编译器错误。最后的逗号是可选的，但建议使用，因为它意味着可以重新排列行，而无需注意逗号可能缺失的位置，以及其他原因。
- en: Here, we've defined a structure called `Constrained`, which is made up of three
    different 32-bit unsigned integer variables. The structure itself is public, meaning
    that it can be used outside of the module where it's defined.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`Constrained`的结构体，它由三个不同的32位无符号整数变量组成。该结构体本身是公共的，这意味着它可以在定义它的模块外部使用。
- en: The `min` and `max` contained variables are also public, but that means something
    slightly different. It means that anywhere we have a `Constrained` value, we can
    access the `min` and `max` contained values directly. The `current` value, on
    the other hand, is private, which means that it can be directly accessed only
    within the module where the structure is defined. We can define functions in that
    module with the express purpose of accessing the data contained in private structure
    members, but the members themselves are not part of the structure's public interface,
    even if the structure itself is public.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`min`和`max`包含的变量也是公共的，但这意味着略有不同。这意味着在任何我们有`Constrained`值的地方，我们都可以直接访问包含的`min`和`max`值。另一方面，`current`值是私有的，这意味着它只能直接在定义结构的模块内访问。我们可以在该模块中定义具有明确访问私有结构成员数据的目的的函数，但成员本身并不是结构公共接口的一部分，即使结构体本身是公共的。'
- en: 'To access `min` and `max`, we can use the same `.` symbol that we''ve seen
    previously in a few places. So, if `cons` is a mutable `Constrained` value, then
    we can do things like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`min`和`max`，我们可以使用之前在几个地方看到的相同的`.`符号。所以，如果`cons`是一个可变的`Constrained`值，那么我们可以做类似这样的事情：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Mutability of data structures
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构的可变性
- en: 'We cannot use the `mut` keyword to make the contained values within a structure
    mutable, and leaving the keyword off does not make them immutable. Instead, the
    entire structure is mutable or immutable on a case-by-case basis. See the following,
    for example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用 `mut` 关键字来使结构体内部包含的值可变，并且省略关键字也不会使它们不可变。相反，整个结构体在特定情况下是可变或不可变的。例如，参见以下内容：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code means that there are two variables, both with `Constrained`
    as their data type, but the value stored in `change_no` is immutable while the
    value stored in `change_yes` is mutable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码意味着有两个变量，它们的数据类型都是 `Constrained`，但存储在 `change_no` 中的值是不可变的，而存储在 `change_yes`
    中的值是可变的。
- en: More about functions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于函数
- en: Now, we're going to fill in the blanks left in the earlier discussion of functions
    by talking about parameters and return types.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过讨论参数和返回类型来填补之前关于函数讨论中留下的空白。
- en: Parameters
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: Parameters allow us to provide information to a function at the time when we
    ask it to run.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 参数允许我们在请求函数运行时提供信息。
- en: Asking a function to run is called *calling* it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请求一个函数运行被称为 *调用* 它。
- en: 'When we define a function, we can tell it the variable names and types we want
    it to use for receiving parameters, as in the following example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个函数时，我们可以告诉它我们希望它使用的变量名和类型，以便接收参数，如下面的例子所示：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll talk about `self` in the *Implementing behavior for types* section of
    this chapter. For now, ignore it and take a look at `value`. Here, we've provided
    a name and data type, just as we would if we were using `let` to create a new
    variable. What we have not done is provide a value for the `value` variable, because
    that happens when the function is called.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的 *实现类型行为* 部分讨论 `self`。现在，忽略它，看看 `value`。在这里，我们提供了一个名称和数据类型，就像我们使用 `let`
    创建新变量时一样。我们没有为 `value` 变量提供值，因为那是在函数调用时发生的。
- en: 'We''ve seen function calls all along, but for the sake of clarity, they look
    like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直看到函数调用，但为了清晰起见，它们看起来是这样的：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In that example, `some_function` is the name of a function, and the values that
    are assigned to its parameters are the results of the expressions `2 + 2` and
    `false`. The parameter expressions are evaluated *before* the function is called,
    so the actual values of the parameters are the number `4` and the Boolean, `false`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个例子中，`some_function` 是一个函数的名称，分配给其参数的值是表达式 `2 + 2` 和 `false` 的结果。参数表达式在函数调用之前被评估，所以参数的实际值是数字
    `4` 和布尔值，`false`。
- en: Return types
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回类型
- en: 'Calling a function is an expression, which means it produces a resulting value.
    We''ve been ignoring that until now. If a function is going to produce a resulting
    value, we have to tell the compiler what data type that result will have. We do
    that like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数是一个表达式，这意味着它会产生一个结果值。我们一直忽略了这一点。如果一个函数将要产生一个结果值，我们必须告诉编译器这个结果值的数据类型。我们这样做：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's a longish example, but for now we're focusing on the first line. After
    the function parameters, we see `->  i32`. That tells Rust that the `get` function
    has `i32` as the data type of its result. Once it knows that, the compiler will
    make sure that it's true. In this example, there's no path through the function
    that doesn't produce an `i32` value, so the compiler is happy with it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个较长的例子，但目前为止我们专注于第一行。在函数参数之后，我们看到 `->  i32`。这告诉 Rust 语言，`get` 函数的结果数据类型是
    `i32`。一旦它知道了这一点，编译器将确保它是正确的。在这个例子中，没有一条路径在函数中不会产生 `i32` 值，所以编译器对此很满意。
- en: We also used the `return` keyword in that example. A `return` statement stops
    the currently running function (meaning that any instructions that would have
    run after the `return` statement do not in fact get run) and provides the resulting
    value for the function call expression. In this example, if the current value
    is less than the minimum value, the minimum value is returned. If the current
    value is greater than the maximum value, the maximum value is returned. Otherwise,
    the current value is returned.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个例子中，我们也使用了 `return` 关键字。`return` 语句停止当前正在运行的函数（这意味着在 `return` 语句之后本应运行的任何指令实际上并没有运行）并为函数调用表达式提供结果值。在这个例子中，如果当前值小于最小值，则返回最小值。如果当前值大于最大值，则返回最大值。否则，返回当前值。
- en: 'You may recall that in Rust, function bodies are block expressions, and `if`
    along with its riders is also an expression, which means they all produce a resulting
    value naturally, even when we don''t use the `return` keyword. That means that
    we could have written the example function this way and gotten the same result:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在Rust中，函数体是块表达式，`if`及其相关内容也是一个表达式，这意味着它们都会自然地产生一个结果值，即使我们没有使用`return`关键字。这意味着我们可以这样编写示例函数并得到相同的结果：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Do you see the difference? Before, we used `return` to specifically terminate
    the function and provide a resulting value. Here, the resulting value of the function's
    block expression is the resulting value of the `if` expression, which is the resulting
    value of the block expression for whichever branch it follows, which is either
    `self.min`, `self.max` or `self.current`. The end result is the same, but it's
    expressed differently.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到区别了吗？之前，我们使用`return`来明确终止函数并提供一个结果值。在这里，函数的块表达式的结果值是`if`表达式的结果值，也就是它所跟随的块表达式的结果值，无论是`self.min`、`self.max`还是`self.current`。最终结果是相同的，但表达方式不同。
- en: Error handling
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Sometimes, we can anticipate the possibility that something could go wrong,
    or we're using a library function that knows it might not succeed. When that happens,
    we'll find ourselves using the special `Result` data type. The result is a **generic
    type**, which we'll talk about in a later chapter, but it's so integral to using
    functions that we're going to see how to use it here in a rote way.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可以预测到可能会出错的可能性，或者我们正在使用一个知道它可能不会成功的库函数。当这种情况发生时，我们会发现自己正在使用特殊的`Result`数据类型。结果是**泛型类型**，我们将在后面的章节中讨论，但它对于使用函数是如此关键，我们将在这里以机械的方式展示如何使用它。
- en: 'A function that can fail will have a return type something like this: `Result<i32, &''static str>`.
    This looks kind of nuts at first glance, I admit. Let''s break it down. The type
    starts off with `Result` followed by a `<`, then `i32`, then a `,`, then `&''static
    str`, and finally a `>`. What that means is that the function will produce an
    `i32` if it succeeds, and an `&''static str` if it fails. `&''static str` happens
    to be the type for a literal text expression, like `oops, it broke`, so what we''re
    really saying here is that the function will return an integer or an error message.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能会失败的功能将有一个类似于这样的返回类型：`Result<i32, &'static str>`。我承认，乍一看这有点疯狂。让我们分解一下。类型从`Result`开始，然后是一个`<`，然后是`i32`，然后是一个`,`，然后是`&'static
    str`，最后是一个`>`。这意味着如果功能成功，它将产生一个`i32`，如果失败，它将产生一个`&'static str`。`&'static str`恰好是字面文本表达式的类型，比如`oops,
    it broke`，所以我们在这里真正说的是，该函数将返回一个整数或错误消息。
- en: It's common to have a data type specifically for representing errors, such as
    an `Error` structure, rather than just using a textual error message.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有一个专门用于表示错误的类型，比如一个`Error`结构体，而不是仅仅使用文本错误消息。
- en: Using Result to signal success or failure
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Result来表示成功或失败
- en: 'Expanding on our example, how do we write a function that can either succeed
    or fail? See the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子基础上扩展，我们如何编写一个既能成功也能失败的功能？请看以下示例：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we set up the return type to use `Result`, then, in the body of the function,
    we use either `Ok()` or `Err()` to signal that we're returning a valid value or
    an error, respectively.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将返回类型设置为使用`Result`，然后在函数体中，我们使用`Ok()`或`Err()`来表示我们正在返回一个有效值或错误。
- en: 'If a function might fail, but doesn''t have any meaningful return value if
    it succeeds, we can use `()` as the successful return type. So, in that case the
    return type might look like this: `Result<(), &''static str>`. The successful
    return value would be `Ok(())`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个功能可能会失败，但在成功时没有任何有意义的返回值，我们可以使用`()`作为成功的返回类型。所以，在这种情况下，返回类型可能看起来像这样：`Result<(),
    &'static str>`。成功的返回值将是`Ok(())`。
- en: Calling functions that return Result
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用返回Result类型的功能
- en: When we call a function that returns `Result`, the return value is—as requested—a `Result`,
    rather than the data type we really need. There are several ways of working with
    that, depending on our specific needs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用返回`Result`类型的功能时，返回值正如请求的那样是一个`Result`，而不是我们真正需要的的数据类型。根据我们的具体需求，有几种处理方式。
- en: 'The simplest way to deal with a `Result` is to use the `?` operator, which
    extracts the stored value from a successful `Result`, or returns a `Result` containing
    the error value if the `Result` it''s looking at indicates an error. Because `?`
    might return from the current function in the same way that a `return` statement
    would, `?` can only be used in functions that themselves return `Result` and use
    the same data type to represent errors. Using `?` looks like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 `Result` 的最简单方法是用 `?` 操作符，它从成功的 `Result` 中提取存储的值，如果查看的 `Result` 指示错误，则返回包含错误值的
    `Result`。因为 `?` 可能以与 `return` 语句相同的方式从当前函数返回，所以 `?` 只能在自身返回 `Result` 并使用相同的数据类型来表示错误的函数中使用。使用
    `?` 的样子如下：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we're calling the `new_constrained` function, which returns either a successful
    result or an error message. However, the variable we're assigning to has `Constrained`
    as its type, not `Result`. That works because of the `?` at the end, which pulls
    out the `Constrained` value if the function call succeeds, and returns if the
    function call fails.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用 `new_constrained` 函数，它返回一个成功的结果或错误信息。然而，我们赋值的变量类型是 `Constrained`，而不是
    `Result`。这之所以可行，是因为末尾的 `?`，它会在函数调用成功时提取 `Constrained` 值，如果函数调用失败则返回。
- en: 'The next easiest way to deal with a returned `Result` is to use the `expect`
    function. This function does something similar to the `?`, pulling out the success
    value if Result indicates success, but it handles failure differently. Instead
    of returning an error from the current function, `expect` terminates the whole
    program and prints out an error message. Functions that use `expect` don''t have
    to return a `Result`, so it can be used in some situations where `?` is unavailable.
    Using `expect` looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 处理返回的 `Result` 的下一个简单方法是使用 `expect` 函数。这个函数与 `?` 类似，如果 `Result` 指示成功，则提取成功值，但处理失败的方式不同。`expect`
    不是从当前函数返回错误，而是终止整个程序并打印出错误信息。使用 `expect` 的函数不需要返回 `Result`，因此它可以在 `?` 不可用的情况下使用。使用
    `expect` 的样子如下：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The parameter passed to `expect` is the error message it should display on failure.
    There are some other functions, similar to `expect`, that handle errors in various
    ways, such as calling an error handler function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `expect` 的参数是它在失败时应该显示的错误信息。还有一些其他与 `expect` 类似的函数，以不同的方式处理错误，例如调用错误处理函数。
- en: Finally, we can actually handle the errors ourselves, by checking whether the
    returned `Result` is an `Ok` or an `Err`. That is done by using the `match` or
    `if let` expressions, which we will learn about in [Chapter 4](700c26ca-e1de-4069-afaf-d9acb22dd6ab.xhtml), the
    *Making Decisions by Pattern Matching*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过检查返回的 `Result` 是 `Ok` 还是 `Err` 来实际处理错误。这是通过使用 `match` 或 `if let` 表达式来完成的，我们将在第
    4 章（700c26ca-e1de-4069-afaf-d9acb22dd6ab.xhtml）中学习，即通过模式匹配做出决策。
- en: Implementing behavior for types
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现类型的行为
- en: 'In previous examples, we''ve seen what appeared to be calls to functions that
    were contained within data values, such as `"127.0.0.1:12345".parse()` or `["Hello",
    "world", "of", "loops"].iter()`. Those are functions that have been **implemented**
    on the type of those values. Implementing functions on a type looks like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了看似调用包含在数据值中的函数的情况，例如 `"127.0.0.1:12345".parse()` 或 `["Hello", "world",
    "of", "loops"].iter()`。这些是在这些值的类型上实现的函数。在类型上实现函数的样子如下：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is an implementation block (which is *not* a block expression) for a data
    type, in this case the `Constrained` type that we created earlier. Implementation
    blocks are introduced with the `impl` keyword, then they have the name of the
    type that we want to place our functions *inside of*, and then the functions we
    want to add to the data type, between the `{` and `}` symbols.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个数据类型（在这个例子中是我们在前面创建的 `Constrained` 类型）的实现块（它不是表达式块）。实现块通过 `impl` 关键字引入，然后是我们要在其中放置函数的类型名称，然后是我们想要添加到数据类型的函数，在
    `{` 和 `}` 符号之间。
- en: While we can access functions that were implemented on a type as if they were
    variables contained in data values of that type, they're not actually stored within
    the memory holding the data value. There's no need for each data value to have
    copies of the functions, since the copies would all be identical anyway.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以像访问包含在数据值中的变量一样访问在类型上实现的函数，但它们实际上并不存储在包含数据值的内存中。没有必要让每个数据值都有函数的副本，因为所有的副本都将完全相同。
- en: Functions implemented on a type can be public or private, depending on whether
    we want them to be used by external users of the data type, or only by other functions
    within the current module.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型上实现的函数可以是公开的或私有的，这取决于我们是否希望外部用户使用数据类型，或者只允许当前模块内的其他函数使用。
- en: When a function is implemented on a type, the first parameter is special. It's
    automatically provided to the function, even though it is not passed as a function
    parameter when we call the function. This automatic parameter is traditionally
    called `self`. It is the job of `self` to give the function access to the data
    value that it is being called through, meaning that if we do something like `"127.0.0.1".parse()`,
    the parse function receives `"127.0.0.1"` as its `self` parameter. The `self`
    parameter can be written as `self`, `&self`, or `&mut self`, a choice that we'll
    discuss in the next chapter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数在某个类型上实现时，第一个参数是特殊的。即使在我们调用函数时没有将其作为函数参数传递，它也会自动提供给函数。这个自动参数传统上被称为`self`。`self`的职责是让函数能够访问通过它被调用的数据值，这意味着如果我们做类似`"127.0.0.1".parse()`的操作，解析函数将`"127.0.0.1"`作为其`self`参数。`self`参数可以写成`self`、`&self`或`&mut
    self`，这个选择将在下一章讨论。
- en: The syntax of an implementation block allows us to specify which data type we're
    implementing functions on. Could we implement functions on types we didn't create,
    such as `i32` or `SocketAddr`? The answer is yes, but only if we create a *trait*.
    We'll see more about traits in [Chapter 5](6c390ac8-f3c8-495d-a97a-29426925531a.xhtml), *One
    data Type Representing Multiple Kinds of Data*. Without using traits, we're only
    able to implement functions on data types we created within the same project,
    although they do not have to be in the same module.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实现块的语法允许我们指定我们要在哪种数据类型上实现函数。我们能否在未创建的类型上实现函数，比如`i32`或`SocketAddr`？答案是肯定的，但前提是我们必须创建一个*特质*。我们将在[第五章](6c390ac8-f3c8-495d-a97a-29426925531a.xhtml)中了解更多关于特质的内容，*一种数据类型表示多种数据类型*。不使用特质，我们只能在我们同一项目中创建的数据类型上实现函数，尽管它们不必在同一个模块中。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we put the things we've learned in this chapter into practice, our grasp
    on them will solidify. We've learned about the basic structure of Rust programs,
    as well as how to write functions, loops, and branches. In addition, we've learned
    about Rust's type system and how to attach behavior to a data type. These things
    give us a foundation to build on, while we learn about the things that make Rust
    truly different from other programming languages.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将本章学到的知识付诸实践时，我们对这些知识的掌握将会更加牢固。我们学习了Rust程序的基本结构，以及如何编写函数、循环和分支。此外，我们还学习了Rust的类型系统以及如何将行为附加到数据类型上。这些为我们提供了一个基础，让我们可以在此基础上学习使Rust真正区别于其他编程语言的特点。
- en: In the next chapter, we're going to look at how the fundamental Rust concepts
    of ownership and borrowing work.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨Rust的基本概念——所有权和借用是如何工作的。
