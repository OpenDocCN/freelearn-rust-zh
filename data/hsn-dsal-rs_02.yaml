- en: Cargo and Crates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargo和Crates
- en: 'Rust is a rather young language that has been designed from scratch to be a
    practical and useful tool for programmers. This is a great situation to be in:
    there are no legacy applications to care about, and many lessons learned from
    other languages have been incorporated in Rust—especially around tooling.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust是一种相当年轻的语言，从头开始设计，旨在成为程序员的一个实用且有用的工具。这是一个非常好的情况：没有遗留应用程序需要关心，并且从其他语言中学到的许多经验教训都融入了Rust——特别是在工具方面。
- en: 'Integrating and managing third-party packages has been an issue in the past
    for a lot of languages, and there are a few different approaches out there:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，集成和管理第三方包一直是许多语言的问题，并且存在几种不同的方法：
- en: '**NPM**: The package manager for Node, which has been very popular with the
    JavaScript community'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NPM**：Node的包管理器，在JavaScript社区中非常受欢迎'
- en: '**Maven**: Enterprise-grade Java package management, based on the XML format'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven**：基于XML格式的企业级Java包管理器'
- en: '**NuGet**: .NET''s package management'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NuGet**：.NET的包管理器'
- en: '**PyPI**: The Python package index'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyPI**：Python包索引'
- en: 'Each of these has different styles of configuration, naming guidelines, publishing
    infrastructure, features, plugins, and so on. The Rust team learned from all of
    these approaches and built their own version: `cargo`. This chapter will be all
    about the power of `cargo` of how and where to integrate with the wealth of packages
    (called crates) out there. Whether you are working on your own small library or
    you are building a large enterprise-grade system, `cargo` will be a central piece
    of the project. By reading this chapter, you can look forward to the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法各有不同的配置风格、命名指南、发布基础设施、功能、插件等。Rust团队从所有这些方法中学习，并构建了自己的版本：`cargo`。本章将全部关于`cargo`的力量，以及如何和在哪里与大量的包（称为crates）集成。无论你是在开发自己的小型库，还是在构建大型企业级系统，`cargo`都将是项目的一个核心部分。通过阅读本章，你可以期待以下内容：
- en: Learning more about `cargo`, its configuration, and plugins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于`cargo`、其配置和插件的信息
- en: Knowing more about the different types of crates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于不同类型的crates
- en: Benchmarking and test integration done in `cargo`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`cargo`中完成的基准测试和测试集成
- en: Cargo
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargo
- en: 'The basic Rust tooling is composed of three programs:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Rust工具由三个程序组成：
- en: '`cargo`: The Rust package manager'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo`：Rust包管理器'
- en: '`rustc`: The Rust compiler'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustc`：Rust编译器'
- en: '`rustup`: The Rust toolchain manager'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustup`：Rust工具链管理器'
- en: Most users will never touch (or even see) `rustc` directly, but will usually
    use `rustup` to install it and then let `cargo` orchestrate the compilation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户永远不会直接接触（甚至看到）`rustc`，而是通常使用`rustup`来安装它，然后让`cargo`来协调编译过程。
- en: 'Running `cargo` without any arguments reveals the subcommands it provides:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不带任何参数运行`cargo`会显示它提供的子命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are a few clues here as to what the package manager can do. Other than
    resolving different types of dependencies for projects, it acts as a test runner
    for benchmarks and unit/integration tests, and provides access to registries such
    as `crates.io` ([https://crates.io/](https://crates.io/)). Many of these properties
    can be configured in a `.cargo/config` file in the TOML ([https://github.com/toml-lang/toml](https://github.com/toml-lang/toml))
    syntax, either in your home directory, the project directory, or the hierarchy
    in between.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于包管理器可以做什么的线索。除了为项目解决不同类型的依赖关系外，它还充当基准测试和单元/集成测试的测试运行器，并提供对`crates.io`（[https://crates.io/](https://crates.io/)）等注册表的访问。许多这些属性都可以在`.cargo/config`文件中进行配置，该文件使用TOML（[https://github.com/toml-lang/toml](https://github.com/toml-lang/toml)）语法，可以在你的主目录、项目目录或两者之间的层次结构中。
- en: The individual properties that can be configured can easily evolve over time,
    so we'll focus on some core parts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置的各个属性可以很容易地随时间演变，因此我们将关注一些核心部分。
- en: '**Local repositories** can be customized with a `paths` property (an array
    of paths) in the root section of the file, whereas any command-line arguments
    for the `cargo new` command can be found in the `[cargo-new]` section of the file.
    If these custom repositories are remote, this can be configured in `[registry]`
    and `[http]` for the `proxy` address and port, custom certificate authority (`cainfo`),
    or high latencies (`timeout`) .'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地仓库**可以通过文件根部分的`paths`属性（一个路径数组）进行自定义，而`cargo new`命令的任何命令行参数都可以在文件的`[cargo-new]`部分找到。如果这些自定义仓库是远程的，可以在`[registry]`和`[http]`中配置`proxy`地址和端口、自定义证书颁发机构（`cainfo`）或高延迟（`timeout`）。'
- en: 'These are handy configurations for enterprise systems with private repositories,
    or CI builds with shared drives acting as caches. However, there are options to
    **customize the toolchain**, by letting the user provide some configuration in
    a `[target.$triple]` section (for example, `[target.wasm32-unknown-unknown]` to
    customize a Wasm target). Each of those sections contains the following properties:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是针对具有私有仓库的企业系统或使用共享驱动作为缓存的 CI 构建的有用配置。然而，可以通过让用户在 `[target.$triple]` 部分提供一些配置来**自定义工具链**（例如，`[target.wasm32-unknown-unknown]`
    用于自定义 Wasm 目标）。每个这些部分都包含以下属性：
- en: A `linker` specific to the selected triple
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对所选三重组合的特定 `linker`
- en: Another archiver by customizing `ar`
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自定义 `ar` 的另一个归档器
- en: A `runner` for running the program and associated tests
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于运行程序及其相关测试的 `runner`
- en: Flags for the compiler in `rustflags`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器的标志位于 `rustflags`
- en: Lastly, the **build configuration** is set within the `[build]` section, where
    the number of `jobs`, binaries, such as `rustc` or `rustdoc`, the `target` triple,
    `rustflags`, or `incremental` compilation can be set. To learn more about configuring
    `cargo` and to obtain a sample of this configuration, go to [https://doc.rust-lang.org/cargo/reference/config.html](https://doc.rust-lang.org/cargo/reference/config.html).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**构建配置**是在 `[build]` 部分设置的，其中可以设置 `jobs` 的数量、二进制文件，如 `rustc` 或 `rustdoc`、`target`
    三重组合、`rustflags` 或增量编译。要了解更多关于配置 `cargo` 和获取此配置的示例，请访问 [https://doc.rust-lang.org/cargo/reference/config.html](https://doc.rust-lang.org/cargo/reference/config.html)。
- en: 'In the next sections, we are going to explore the core of `cargo`: the project.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨 `cargo` 的核心：项目。
- en: Project configuration
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目配置
- en: 'In order to recognize a Rust project, `cargo` requires its manifest to be present,
    where most of the other aspects (metadata, source code location, and so on) can
    be configured. Once this has been done, building the project will create another
    file: `Cargo.lock`. This file contains the dependency tree of a project with library
    versions and locations in order to speed up future builds. Both of these files
    are essential to a Rust project.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别 Rust 项目，`cargo` 需要其清单存在，其中大多数其他方面（元数据、源代码位置等）可以配置。一旦完成这些配置，构建项目将创建另一个文件：`Cargo.lock`。此文件包含项目的依赖项树，包括库版本和位置，以便加快未来的构建。这两个文件对于
    Rust 项目都是必不可少的。
- en: The manifest – Cargo.toml
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清单文件 – Cargo.toml
- en: 'The `Cargo.toml` file follows—as the name suggests—the TOML structure. It''s
    handwritten and contains metadata about the project as well as dependencies, links
    to other resources, build profiles, examples, and much more. Most of them are
    optional and have reasonable defaults. In fact, the `cargo new` command generates
    the minimal version of a manifest:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo.toml` 文件遵循——正如其名所示——TOML 结构。它是手写的，包含有关项目以及依赖项、指向其他资源的链接、构建配置文件、示例等元数据。其中大部分是可选的，并有合理的默认值。实际上，`cargo
    new` 命令生成清单的最小版本：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are many more sections and properties, and we will present a few important
    ones here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多章节和属性，我们将在下面介绍一些重要的内容。
- en: Package
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件包
- en: This manifest section is all about metadata for the package, such as name, version,
    and authors, but also a link to the documentation that defaults to the corresponding
    page ([https://docs.rs/](https://docs.rs/)). While many of these fields are there
    to support `crates.io` and display various indicators (categories, badges, repository,
    homepage, and so on), some fields should be filled regardless of whether they
    are published there, such as license (especially with open source projects).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单部分主要关于软件包的元数据，例如名称、版本和作者，但也包含指向默认为相应页面的文档的链接 ([https://docs.rs/](https://docs.rs/)).
    虽然许多这些字段是为了支持 `crates.io` 并显示各种指标（类别、徽章、仓库、主页等），但某些字段无论是否发布在那里都应该填写，例如许可证（特别是开源项目）。
- en: Another interesting section is the metadata table in `package.metadata`, because
    it's ignored by `cargo`. This means that projects can store their own data in
    the manifest for project- or publishing-related properties—for example, for publishing
    on Android's Google Play Store, or information to generate Linux packages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的章节是 `package.metadata` 中的元数据表，因为它被 `cargo` 忽略。这意味着项目可以在清单中存储自己的数据，用于项目或发布相关的属性——例如，用于在
    Android 的 Google Play 商店发布，或生成 Linux 软件包的信息。
- en: Profiles
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: 'When you run `cargo build`, `cargo build --release`, or `cargo test`, `cargo`
    uses profiles to determine individual settings for each stage. While these have
    reasonable defaults, you might want to customize some settings. The manifest provides
    these switches with the `[profile.dev]`, `[profile.release]`, `[profile.test]`,
    and `[profile.bench]` sections:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`cargo build`、`cargo build --release`或`cargo test`时，`cargo`使用配置文件来确定每个阶段的单独设置。虽然这些有合理的默认值，但你可能想要自定义一些设置。清单提供了这些开关，包括`[profile.dev]`、`[profile.release]`、`[profile.test]`和`[profile.bench]`部分：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These values are the defaults (as of writing this book) and are already useful
    for most users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是默认值（截至撰写本书时），对大多数用户来说已经很有用了。
- en: Dependencies
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: This is probably the most important section for most developers. The dependencies
    section contains a list of values that represent crate names on `crates.io` (or
    your configured private registry) as keys along with the version as values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是对大多数开发者来说最重要的部分。依赖项部分包含一个值列表，代表`crates.io`（或你配置的私有注册表）上的crate名称，作为键，版本作为值。
- en: 'Instead of the version string, it''s equally possible to provide an inline
    table as a value that specifies optionality or other fields:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与版本字符串一样，也可以提供内联表作为值，指定可选性或其他字段：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Interestingly, since this is an object, TOML allows us to use it like a section:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，由于这是一个对象，TOML允许我们像使用部分一样使用它：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since, in the 2018 edition, the `extern` crate declarations inside the `.rs`
    files are optional, renaming a dependency can be done inside the `Cargo.toml`
    specification by using the `package` property. Then, the specified key can become
    an alias for this `package`, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在2018版中，`.rs`文件内的`extern` crate声明是可选的，因此可以通过使用`package`属性在`Cargo.toml`规范内部重命名依赖项。然后，指定的键可以成为此`package`的别名，如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Features are crate-specific strings that include or exclude certain features.
    In the case of rand (and some others), `stdweb` is a feature that allows us to
    use the crate in Wasm scenarios by leaving out things that would not compile otherwise.
    Note that these features might be automatically applied when they depend on toolchains.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 功能是特定于crate的字符串，包括或排除某些功能。在rand（以及一些其他情况）中，`stdweb`是一个功能，允许我们在Wasm场景中使用crate，通过排除那些否则无法编译的内容。请注意，这些功能可能在它们依赖于工具链时自动应用。
- en: 'Something that needs to be specified via those objects is the dependence on
    a remote Git repository or local path. This is useful for testing a patched version
    of a library locally without publishing it to `crates.io` ([https://crates.io/](https://crates.io/))
    and having it built by `cargo` during the parent''s build phase:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 需要通过这些对象指定的是对远程Git仓库或本地路径的依赖。这对于在本地测试库的补丁版本非常有用，而无需将其发布到`crates.io` ([https://crates.io/](https://crates.io/))，并在父构建阶段由`cargo`构建：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Specifying versions with `cargo` follows a pattern too. Since any crate is
    encouraged to follow a semantic versioning scheme (`<major>.<minor>.<patch>`),
    there are operators that include or exclude certain versions (and thereby APIs).
    For `cargo`, those operators are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo`指定版本也遵循一个模式。由于任何crate都鼓励遵循语义版本控制方案（`<major>.<minor>.<patch>`），因此存在包括或排除某些版本（以及因此API）的运算符。对于`cargo`，这些运算符如下：
- en: '**Tilde** (`~`): Only patch increases are allowed.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**波浪号** (`~`): 只允许补丁增加。'
- en: '**Caret** (`^`): No major update will be done (2.0.1 to 2.1.0 is OK, to 3.0.1
    is not!) .'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入符** (`^`): 不会进行主要更新（从2.0.1到2.1.0是可以的，到3.0.1则不行！）。'
- en: '**Wildcard** (`*`): Allows any version, but it can be used to replace a position.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通配符** (`*`): 允许任何版本，但也可以用来替换一个位置。'
- en: These operators avoid future dependency headaches and introduce a stable API
    without missing the required updates and fixes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符避免了未来的依赖问题，并引入了一个稳定的API，同时不会错过所需的更新和修复。
- en: It isn't possible to publish a crate with wildcard dependencies. After all,
    which version is the target computer supposed to use? This is why `cargo` enforces
    explicit version numbers when running `cargo publish`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无法发布带有通配符依赖的crate。毕竟，目标计算机应该使用哪个版本？这就是为什么`cargo`在运行`cargo publish`时强制执行显式版本号。
- en: 'There are several ways to work with purpose-specific dependencies. They can
    either be declared by platform (`[target.wasm32-unknown-unknown]`) or by their
    intention: there is a dependency type, `[dev-dependencies]`, for compiling tests,
    examples, and benchmarks, but there is also a build-only dependency specification,
    `[build-dependencies]`, that will be separated from others.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以处理特定目的的依赖。它们可以通过平台（`[target.wasm32-unknown-unknown]`）声明，或者通过它们的意图：存在一个依赖类型，`[dev-dependencies]`，用于编译测试、示例和基准测试，但还有一个仅用于构建的依赖规范，`[build-dependencies]`，它将与其他依赖分开。
- en: Once the dependencies are specified, they are resolved and looked up to generate
    a dependency tree within the project. This is where the `Cargo.lock` file comes
    in.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指定了依赖，它们就会被解析并查找，以在项目内部生成依赖树。这就是`Cargo.lock`文件发挥作用的地方。
- en: Dependencies – Cargo.lock
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖 – Cargo.lock
- en: 'Here is a great quote from the `cargo` FAQ ([https://doc.rust-lang.org/cargo/faq.html](https://doc.rust-lang.org/cargo/faq.html))
    about what the purpose of this file is and what it does:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一句来自`cargo`常见问题解答（[https://doc.rust-lang.org/cargo/faq.html](https://doc.rust-lang.org/cargo/faq.html)）的精彩引言，关于此文件的目的以及它所做的工作：
- en: The purpose of a Cargo.lock is to describe the state of the world at the time
    of a successful build. It is then used to provide deterministic builds across
    whatever machine is building the project by ensuring that the exact same dependencies
    are being compiled.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo.lock的目的在于描述成功构建时的世界状态。然后，通过确保正在编译的依赖完全相同，它被用来确保在构建项目的任何机器上都能提供确定性的构建。
- en: This serialized state can easily be transferred across teams or computers. Therefore,
    should a dependency introduce a bug with a patch update, your build should be
    largely unaffected unless you run `cargo update`. In fact, it's recommended for
    libraries to commit the `Cargo.lock` file to version control to retain a stable,
    working build. For debugging purposes, it's also quite handy to streamline the
    dependency tree.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种序列化状态可以轻松地在团队或计算机之间传输。因此，如果依赖引入了补丁更新中的错误，除非运行`cargo update`，否则你的构建应该不会受到太大影响。实际上，建议将`Cargo.lock`文件提交到版本控制中，以保留一个稳定且可工作的构建。出于调试目的，简化依赖树也非常方便。
- en: Commands
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: '`cargo` supports a wealth of commands that can be extended easily. It deeply
    integrates with the project and allows for additional build scripts, benchmarking,
    testing, and so on.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo`支持大量易于扩展的命令。它与项目深度集成，允许添加额外的构建脚本、基准测试、测试等。'
- en: The compile and run commands
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行命令
- en: As the main build tool, `cargo` does compile and run by way of creating and
    then executing the output binary (usually found in `target/<profile>/<target-triple>/`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为主要的构建工具，`cargo`通过创建并执行输出二进制文件（通常位于`target/<profile>/<target-triple>/`）来进行编译和运行。
- en: What if a library written in a different language is required to precede the
    Rust build? This is where build scripts come in. As mentioned in the *Project
    configuration* section, the manifest provides a field called `build` which takes
    a path or name to a `build` script.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用不同语言编写的库来先于Rust构建，那该怎么办？这正是构建脚本发挥作用的地方。如*项目配置*部分所述，清单提供了一个名为`build`的字段，它接受一个指向`build`脚本的路径或名称。
- en: 'The script itself can be a regular Rust binary that generates output in a designated
    folder, and can even have dependencies specified in `Cargo.toml` (`[build-dependencies]`,
    but nothing else). Any required information (target architecture, output, and
    so on) is passed into the program using environment variables, and any output
    for `cargo` is required to have the `cargo:key=value` format. Those are picked
    up by `cargo` to configure further steps. While the most popular is building native
    dependencies, it''s entirely possible to generate code (such as bindings, data
    access classes, and so on) as well. Read more in the `cargo` reference: [https://doc.rust-lang.org/cargo/reference/build-scripts.html](https://doc.rust-lang.org/cargo/reference/build-scripts.html).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本本身可以是一个普通的Rust二进制文件，在指定的文件夹中生成输出，甚至可以在`Cargo.toml`中指定依赖（`[build-dependencies]`，但不能是其他任何内容）。任何所需的信息（目标架构、输出等）都通过环境变量传递给程序，并且任何针对`cargo`的输出都需要遵循`cargo:key=value`格式。这些信息会被`cargo`捕获以配置后续步骤。虽然构建本地依赖是最受欢迎的，但也可以生成代码（如绑定、数据访问类等）。更多详情请参阅`cargo`参考文档：[https://doc.rust-lang.org/cargo/reference/build-scripts.html](https://doc.rust-lang.org/cargo/reference/build-scripts.html)。
- en: 'Larger projects will require a more complex structure than a simple `src/`
    folder to contain all the source code, which is why `cargo` provides the option
    to split projects into subprojects, called a workspace. This comes in handy for
    architectural patterns such as microservices (each service could be a project),
    or loosely coupling components (clean architecture). To set this up, place each
    subproject in a subdirectory and create a `Cargo.toml` in the workspace that declares
    its members:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的项目需要比简单的`src/`文件夹更复杂的结构来包含所有源代码，这就是为什么`cargo`提供了将项目拆分为子项目（称为工作空间）的选项。这对于像微服务（每个服务可以是项目）或松耦合组件（清洁架构）这样的架构模式很有用。要设置此环境，将每个子项目放置在子目录中，并在工作空间中创建一个`Cargo.toml`文件来声明其成员：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This applies any commands run at the top level to every crate in the workspace.
    Invoking `cargo test` will run all types of tests and that can take a long time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将应用在顶层运行的任何命令到工作空间中的每个crate。调用`cargo test`将运行所有类型的测试，这可能会花费很长时间。
- en: Testing
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'As far as commands go, `cargo` supports test and bench to run a crate''s tests.
    These tests are specified in the code by creating a "module" inside a module and
    annotating it with `#[cfg(test)]`. Furthermore, each test also has to be annotated
    with either `#[test]` or `#[bench]`, whereas the latter takes an argument to the
    `Bencher`, a benchmark runner class that allows us to collect stats on each run:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令方面，`cargo`支持`test`和`bench`来运行crate的测试。这些测试通过在模块内部创建一个“模块”并用`#[cfg(test)]`进行注释来指定。此外，每个测试还必须用`#[test]`或`#[bench]`进行注释，而后者需要传递一个参数给`Bencher`，这是一个基准运行器类，允许我们收集每次运行的统计数据：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After running `cargo test`, the output is as expected:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo test`后，输出符合预期：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the tests are importing and calling a function from its parent
    module, called `my_add`. One of the tests even expects a `panic!` (caused by an
    overflow) to be thrown, which is why the `#[should_panic]` annotation has been
    added.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，测试正在导入并调用其父模块中的一个函数，称为`my_add`。其中一个测试甚至期望抛出一个`panic!`（由溢出引起），这就是为什么添加了`#[should_panic]`注释的原因。
- en: On top of this, `cargo` supports doctests, which is a special form of testing.
    One of the most tedious things when refactoring is updating the examples in the
    documentation which is why they are frequently not working. Coming from Python,
    the doctest is a solution to this dilemma. By running the actual code in a denoted
    example, doctests makes sure that everything that's printed in the documentation
    can be executed—creating a black box test at the same time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，`cargo`支持doctests，这是一种特殊的测试形式。重构时最繁琐的事情之一是更新文档中的示例，这就是为什么它们经常不起作用。从Python迁移过来，doctest是解决这个困境的方案。通过在指定的示例中运行实际代码，doctests确保文档中打印出的所有内容都可以执行——同时创建一个黑盒测试。 '
- en: Every function in Rust can be annotated using a special docstring—which is used
    to generate the documentation at DOCS.RS ([https://docs.rs/](https://docs.rs/)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Rust函数都可以使用特殊的文档字符串进行注释——该字符串用于在DOCS.RS（[https://docs.rs/](https://docs.rs/)）生成文档。
- en: doctests are only available for crates of the library type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: doctests仅适用于库类型的crate。
- en: 'This documentation has sections (indicated by a markdown header: `#`), and
    if a particular section is called `Examples`, any contained code will be compiled
    and run:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这份文档有章节（由Markdown标题`#`指示），如果某个特定章节被命名为`Examples`，则其中包含的任何代码都将被编译并运行：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now add another test to the preceding sample by creating a few lines
    of documentation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过创建几行文档来向先前的示例添加另一个测试：
- en: '[PRE11]rust'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]rust'
- en: /// assert_eq!(ch2::my_add(1, 1), 2);
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: /// assert_eq!(ch2::my_add(1, 1), 2);
- en: /// [PRE12]
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE12]
- en: 'The `cargo test` command will now run the code in examples as well:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo test`命令现在将运行示例中的代码：'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For larger tests or black-box tests, it's also possible (and recommended) to
    put the tests into a subfolder of the project, called `tests`. `cargo` will pick
    this up automatically and run the tests accordingly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的测试或黑盒测试，也可以（并且推荐）将测试放入项目的子文件夹中，称为`tests`。`cargo`会自动检测并相应地运行测试。
- en: On top of tests, other commands are often required (code metrics, linting, and
    so on) and recommended. For that, `cargo` provides a third-party command interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试之外，通常还需要其他命令（如代码度量、linting等）和推荐。为此，`cargo`提供了一个第三方命令接口。
- en: Third-party subcommands
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方子命令
- en: '`cargo` allows the extension of its command-line interface with subcommands.
    These subcommands are binaries that are called when invoking `cargo <command>`
    (for example, `cargo clippy` for the popular linter).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo` 允许通过子命令扩展其命令行界面。这些子命令是当调用 `cargo <command>`（例如，`cargo clippy` 用于流行的代码检查器）时被调用的二进制文件。'
- en: In order to install a new command (for a particular toolchain), run `cargo +nightly
    install clippy`, which will download, compile, and install a crate called `cargo-clippy`
    and then put it into the `.cargo` directory in your home folder. In fact, this
    will work with any binary that is called `cargo-<something>` and is executable
    from any command line. The `cargo` project keeps an updated list of some useful
    subcommands in the repository at [https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands](https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装一个新的命令（针对特定的工具链），运行 `cargo +nightly install clippy`，这将下载、编译并安装一个名为 `cargo-clippy`
    的 crate，并将其放入您家目录中的 `.cargo` 目录。实际上，这适用于任何被称作 `cargo-<something>` 且可以从任何命令行执行的二进制文件。`cargo`
    项目在 [https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands](https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands)
    的仓库中维护了一个有用的子命令更新列表。
- en: Crates
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Crates
- en: Rust's modules (crates) can easily be packaged and distributed once all the
    compilation and testing is done, regardless of whether they are libraries or executables.
    First, let's take a look at Rust binaries in general.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成所有编译和测试，Rust 的模块（crates）可以轻松打包和分发，无论它们是库还是可执行文件。首先，让我们看看 Rust 二进制文件的一般情况。
- en: Rust libraries and binaries
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 库和二进制文件
- en: 'There are executable binaries and libraries in Rust. When these Rust programs
    use dependencies, they rely on the linker to integrate those so it will work on—at
    least—the current platform. There are two major types of linking: static and dynamic—both
    of which are somewhat dependent on the operating system.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中有可执行二进制文件和库。当这些 Rust 程序使用依赖项时，它们依赖于链接器来集成这些依赖项，以便在至少当前平台上运行。链接主要有两种类型：静态链接和动态链接——这两种类型都多少依赖于操作系统。
- en: Static and dynamic libraries
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态和动态库
- en: 'Generally, Rust dependencies have two types of linking:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Rust 依赖项有两种类型的链接：
- en: '**Static**: Via the `rlib` format.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态链接**：通过 `rlib` 格式。'
- en: '**Dynamic**: Via shared libraries (`.so` or `.dll`).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态链接**：通过共享库（`.so` 或 `.dll`）。'
- en: The preference—if a corresponding `rlib` can be found—is to link statically
    and therefore include all dependencies into the output binary, making the file
    a lot larger (to the dismay of embedded programmers). Therefore, if multiple Rust
    programs use the same dependency, each comes with its own built-in version. It's
    all about the context though, since, as Go's success has shown, static linking
    can simplify complex deployments since only a single file has to be rolled out.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以找到相应的 `rlib`，首选是静态链接，因此将所有依赖项包含到输出二进制文件中，使得文件变得很大（这让嵌入式程序员感到沮丧）。因此，如果多个
    Rust 程序使用相同的依赖项，每个程序都会带有其内置的版本。尽管如此，这完全取决于上下文，因为，正如 Go 的成功所展示的，静态链接可以简化复杂的部署，因为只需要分发单个文件。
- en: 'There are drawbacks to the static linking approach beyond size: for static
    libraries, all dependencies have to be of the `rlib` type, which is Rust''s native
    package format, and cannot contain a dynamic library since the formats (for example,
    `.so` (dynamic) and `.a` (static) on ELF systems) aren''t convertible.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了大小之外，静态链接方法还有其他缺点：对于静态库，所有依赖项都必须是 `rlib` 类型，这是 Rust 的原生包格式，并且不能包含动态库，因为格式（例如，ELF
    系统上的 `.so`（动态）和 `.a`（静态））是不可转换的。
- en: For Rust, dynamic linking is commonly used for native dependencies, since they
    are usually available in the operating system and don't need to be included in
    the package. The Rust compiler can favor this with a `-C prefer-dynamic` flag,
    which will get the compiler to look for the corresponding dynamic libraries first.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Rust，动态链接通常用于本地依赖项，因为它们通常在操作系统中可用，不需要包含在包中。Rust 编译器可以通过 `-C prefer-dynamic`
    标志优先使用动态链接，这将使编译器首先查找相应的动态库。
- en: 'Therein lies the current strategy of the compiler: depending on the output
    format (`--crate-format= rlib`, `dylib`, `staticlib`, `library`, or `bin`), it
    decides on the best linking type with your influence via flags. However, there
    is a rule that the output cannot statically link the same library twice, so it
    won''t link two libraries with the same static dependency.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编译器的当前策略：根据输出格式（`--crate-format= rlib`、`dylib`、`staticlib`、`library` 或 `bin`），它决定最佳的链接类型，并通过标志影响你的选择。然而，有一条规则是输出不能静态链接相同的库两次，因此它不会链接具有相同静态依赖的两个库。
- en: For more information on the topic, we recommend checking out [https://doc.rust-lang.org/reference/linkage.html](https://doc.rust-lang.org/reference/linkage.html).
    That said, the compiler is usually trustworthy and, unless there is an interoperability
    goal, `rustc` will decide optimally.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的更多信息，我们建议查看[https://doc.rust-lang.org/reference/linkage.html](https://doc.rust-lang.org/reference/linkage.html)。话虽如此，编译器通常是可信的，除非有互操作性目标，否则
    `rustc` 将决定最优方案。
- en: Linking and interoperability
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接和互操作性
- en: Rust compiles to native code like many other languages, which is great because
    it expands the available libraries and lets you choose the best technology to
    solve a problem. "Playing nice with others" has always been a major design goal
    of Rust.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译成原生代码，就像许多其他语言一样，这很好，因为它扩展了可用的库，并允许你选择最佳技术来解决一个问题。“与其他人友好相处”一直是 Rust
    的主要设计目标。
- en: 'Interoperability on that level is as simple as declaring the function that
    you want to import and dynamically linking a library that exports this function.
    This process is largely automated: the only thing required is to create and declare
    a build script that compiles the dependency and then tells the linker where the
    output is located. Depending on what type of library you built, the linker does
    what is necessary to include it into the Rust program: static or dynamic linking
    (the default).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个层面上，互操作性就像声明你想要导入的函数，并动态链接导出此函数的库一样简单。这个过程在很大程度上是自动化的：唯一需要的是创建和声明一个构建脚本，该脚本编译依赖项，然后告诉链接器输出所在的位置。根据你构建的库类型，链接器执行必要的操作将其包含到
    Rust 程序中：静态链接或动态链接（默认）。
- en: If there is only one native library that is to be linked dynamically, the manifest
    file offers a `links` property to specify that. Programmatically, it's very easy
    to interact with these included libraries by using the Foreign Function Interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个要动态链接的原生库，清单文件提供了一个 `links` 属性来指定这一点。通过使用外部函数接口，程序化地与这些包含的库交互非常简单。
- en: FFI
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FFI
- en: 'The **Foreign Function Interface** (**FFI**) is Rust''s way of calling into
    other native libraries (and vice versa) using a simple keyword: `extern`. By declaring
    an `extern` function, the compiler knows that, either an outside interface needs
    to be bound via the linker (import) or, that the declared function is to be exported
    so other languages can make use of it (export).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部函数接口**（**FFI**）是 Rust 通过简单的关键字 `extern` 调用其他原生库（反之亦然）的方式。通过声明一个 `extern`
    函数，编译器知道，要么需要通过链接器（导入）绑定外部接口，要么声明的函数将被导出，以便其他语言可以使用它（导出）。'
- en: 'In addition to the keyword, the compiler and linker have to get a hint of what
    type of binary layout is expected. That''s why the usual `extern` declaration
    looks as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关键字之外，编译器和链接器还需要了解预期的二进制布局类型。这就是为什么通常的 `extern` 声明看起来如下：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This allows a `C` library function to be called from within Rust. However,
    there''s one caveat: the calling part has to be wrapped in an `unsafe` section.
    The Rust compiler cannot guarantee the safety of an external library so it makes
    sense to be pessimistic about its memory management. The exported function is
    safe, and by adding the `#[no_mangle]` attribute, there is no name mangling, so
    it can be found using its name.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许从 Rust 中调用 `C` 库函数。然而，有一个注意事项：调用部分必须包裹在 `unsafe` 部分。Rust 编译器无法保证外部库的安全性，因此对它的内存管理持悲观态度是有道理的。导出的函数是安全的，通过添加
    `#[no_mangle]` 属性，没有名称混淆，因此可以通过其名称找到它。
- en: In order to use libraries for specialized algorithms available in a C/C++ library,
    there is a tool that generates suitable structures, `extern "C"` declarations,
    and data types, called `rust-bindgen`. Find out more at [https://github.com/rust-lang-nursery/rust-bindgen](https://github.com/rust-lang-nursery/rust-bindgen).
    These interoperability capabilities make Rust code available to legacy software
    or for use in a vastly different context, such as web frontends.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用C/C++库中可用的专用算法库，有一个名为`rust-bindgen`的工具，它可以生成合适的结构、`extern "C"`声明和数据类型。更多详情请访问[https://github.com/rust-lang-nursery/rust-bindgen](https://github.com/rust-lang-nursery/rust-bindgen)。这些互操作性能力使得Rust代码可用于遗留软件或用于非常不同的环境中，例如网页前端。
- en: Wasm
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wasm
- en: '**Wasm**, which **WebAssembly** is now commonly called, is a binary format
    meant to complement JavaScript that Rust can be compiled to. The format is designed
    to run as a stack machine inside several sandboxed execution environments (such
    as web browsers, or the Node.js runtime) for performance-critical applications
    ([https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/)).
    While this is—as of this writing—in its early stages, Rust and the Wasm target
    have been used in real-time frontend settings (such as browser games), and in
    2018 there was a dedicated working group seeking to improve this integration.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wasm**，现在通常称为**WebAssembly**，是一种二进制格式，旨在补充JavaScript，Rust可以编译成这种格式。该格式旨在在多个沙盒执行环境中（如网页浏览器或Node.js运行时）作为堆栈机器运行，用于性能关键的应用程序([https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/))。尽管目前仍处于早期阶段，但Rust和Wasm目标已被用于实时前端设置（如浏览器游戏），并且在2018年有一个专门的工作组寻求改进这种集成。'
- en: 'Similar to other targets, such as ARM, the Wasm target is an LLVM (the compiler
    technology Rust is built on) backend so it has to be installed using `rustup target
    add wasm32-unknown-unknown`. Furthermore, it isn''t necessary to declare the binary
    layout (the `"C"` in `extern "C"`) and a different bindgen tool does the rest:
    `wasm-bindgen`, available at [https://github.com/rustwasm/wasm-bindgen](https://github.com/rustwasm/wasm-bindgen).
    We highly recommend reading the documentation for more information.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他目标，例如ARM类似，Wasm目标是一个LLVM（Rust构建所依赖的编译器技术）后端，因此必须使用`rustup target add wasm32-unknown-unknown`进行安装。此外，没有必要声明二进制布局（`extern
    "C"`中的`"C"`）和不同的bindgen工具来完成剩余工作：`wasm-bindgen`，可在[https://github.com/rustwasm/wasm-bindgen](https://github.com/rustwasm/wasm-bindgen)找到。我们强烈建议阅读文档以获取更多信息。
- en: The main repository – crates.io
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要仓库 - crates.io
- en: The `crates.io` website ([https://crates.io/](https://crates.io/)) provides
    a huge repository of crates to be used with Rust. Along with discoverability functions,
    such as `tags` and `search`, it allows Rust programmers to offer their work to
    others.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`crates.io`网站([https://crates.io/](https://crates.io/))提供了一个巨大的crates仓库，可用于Rust。除了可发现性功能，如`tags`和`search`，它还允许Rust程序员将他们的工作提供给他人。'
- en: 'The repository itself provides APIs to interact with and a wealth of documentation
    pointers for `cargo`, crates in general, and so on. The source code is available
    on GitHub—we recommend checking out the repository for more information: [https://github.com/rust-lang/crates.io](https://github.com/rust-lang/crates.io).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库本身提供了与仓库交互的API以及大量关于`cargo`、crates等文档的指针。源代码可在GitHub上找到——我们建议查看仓库以获取更多信息：[https://github.com/rust-lang/crates.io](https://github.com/rust-lang/crates.io)。
- en: Publishing
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布
- en: 'For developers to get their crate into this repository, `cargo` harbors a command:
    `cargo publish`. The command is actually doing more things behind the scenes:
    first it runs the `cargo` package to create a `*.crate` file that contains everything
    that is uploaded. Then it verifies the contents of the package by essentially
    running `cargo test` and checks whether there are any uncommitted files in the
    local repository. Only if these checks pass does `cargo` upload the contents of
    the `*.crate` file to the repository. This requires a valid account on `crates.io`
    (available with your GitHub login) to acquire your personal secret API token,
    and the crate has to follow certain rules.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让开发者的crate进入这个仓库，`cargo`提供了一个命令：`cargo publish`。实际上，这个命令在幕后做了更多的事情：首先运行`cargo`包来创建一个包含上传内容的`*.crate`文件。然后通过基本上运行`cargo
    test`来验证包的内容，并检查本地仓库中是否有未提交的文件。只有当这些检查通过时，`cargo`才会将`*.crate`文件的内容上传到仓库。这需要一个有效的`crates.io`账户（可以通过GitHub登录获得）来获取个人秘密API令牌，并且crate必须遵循某些规则。
- en: 'With the previously-mentioned Wasm target, it''s even possible to publish Rust
    packages to the famous JavaScript package repository: `npm` Keep in mind that
    Wasm support is still very new, but once a crate compiles to Wasm it can be packed
    into an `npm` package using Wasm-pack: [https://github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的 Wasm 目标下，甚至可以将 Rust 包发布到著名的 JavaScript 包仓库：`npm`。请注意，Wasm 的支持仍然非常新，但一旦库编译成
    Wasm，就可以使用 Wasm-pack 打包成一个 `npm` 包：[https://github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)。
- en: '`crates.io` aspires to be a permanent storage for Rust crates, so there is
    no "unpublish" button. Versions can be yanked with `cargo yank`, but this won''t
    delete any code; it will just prohibit updates to this particular version. Additionally
    there can be team structures, colorful READMEs, badges, and so on, on your repository''s
    site and we highly recommend you check out the docs on that as well: [https://doc.rust-lang.org/cargo/reference/publishing.html](https://doc.rust-lang.org/cargo/reference/publishing.html).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`crates.io` 致力于成为 Rust 库的永久存储库，因此没有“取消发布”按钮。版本可以通过 `cargo yank` 被撤回，但这不会删除任何代码；它只会禁止更新这个特定版本。此外，你还可以在仓库网站上设置团队结构、多彩的
    README、徽章等等，我们强烈建议你也查看相关的文档：[https://doc.rust-lang.org/cargo/reference/publishing.html](https://doc.rust-lang.org/cargo/reference/publishing.html)。'
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: '`cargo` is Rust''s package manager and build tool that is configurable with
    a manifest called `Cargo.toml`. The file is used by `cargo` to build the desired
    binary with the specified dependencies, profiles, workspaces, and package metadata.
    During this process, the package state is saved in a file called `Cargo.lock`.
    Thanks to its LLVM frontend, Rust compiles to native code on various platforms
    including the web (using Wasm)—thus keeping a high degree of interoperabilty.
    Successfully-built packages can be published on a repository called `crates.io`,
    a website that is a central hub for available Rust libraries and binaries.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo` 是 Rust 的包管理器和构建工具，可以通过名为 `Cargo.toml` 的清单进行配置。该文件由 `cargo` 使用，以构建具有指定依赖项、配置文件、工作空间和包元数据的所需二进制文件。在这个过程中，包状态被保存在一个名为
    `Cargo.lock` 的文件中。得益于其 LLVM 前端，Rust 能够在各种平台上编译成原生代码，包括网络（使用 Wasm），从而保持高度的互操作性。成功构建的包可以发布到一个名为
    `crates.io` 的仓库，这是一个 Rust 库和二进制文件的中央枢纽。'
- en: Before we dive into data structures (starting with lists), the next chapter
    will introduce the ways Rust stores variables and data in memory, whether to copy
    or to clone, and what sized and unsized types are.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入数据结构（从列表开始）之前，下一章将介绍 Rust 在内存中存储变量和数据的方式，是复制还是克隆，以及什么是有大小和无大小的类型。
- en: Questions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does `cargo` do?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo` 都做了些什么？'
- en: Does `cargo` provide linting support?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo` 提供了代码风格检查支持吗？'
- en: In which cases is the `Cargo.lock` file important to publish?
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪些情况下，`Cargo.lock` 文件对于发布很重要？
- en: What are the requirements to publish to `crates.io`?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到 `crates.io` 需要满足哪些要求？
- en: What is Wasm and why should you care?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wasm 是什么，为什么你应该关心？
- en: How are tests organized in a Rust project?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 项目中的测试是如何组织的？
- en: Further reading
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下链接，了解更多关于本章涵盖主题的信息：
- en: '[https://crates.io](https://crates.io)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://crates.io](https://crates.io)'
- en: '[https://doc.rust-lang.org/cargo/](https://doc.rust-lang.org/cargo/)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://doc.rust-lang.org/cargo/](https://doc.rust-lang.org/cargo/)'
- en: '[https://github.com/rustwasm/team](https://github.com/rustwasm/team)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/rustwasm/team](https://github.com/rustwasm/team)'
- en: '[https://webassembly.org](https://webassembly.org)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webassembly.org](https://webassembly.org)'
- en: '[https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/)'
