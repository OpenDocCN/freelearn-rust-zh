- en: '*Chapter 1*: Tools of the Trade – Rust Toolchains and Project Structures'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：行业工具 – Rust 工具链和项目结构'
- en: Rust, as a modern systems programming language, has many inherent characteristics
    that make it easier to write safe, reliable, and performant code. Rust also has
    a compiler that enables a relatively fearless code refactoring experience as a
    project grows in size and complexity. But any programming language in itself is
    incomplete without the toolchains that support the software development life cycle.
    After all, where would software engineers be without their tools?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 作为一种现代的系统编程语言，具有许多固有的特性，使得编写安全、可靠和高效的代码变得更加容易。Rust 还有一个编译器，它使得随着项目规模和复杂性的增长，代码重构体验相对无忧。但任何编程语言本身如果没有支持软件开发生命周期的工具链都是不完整的。毕竟，如果没有工具，软件工程师将何去何从？
- en: This chapter specifically discusses the Rust toolchain and its ecosystem, and
    techniques to structure code within Rust projects to write safe, testable, performant,
    documented, and maintainable code that is also optimized to run in the intended
    target environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章特别讨论了 Rust 工具链及其生态系统，以及如何在 Rust 项目中组织代码，以编写安全、可测试、高效、有文档和维护性好的代码，同时优化以在目标环境中运行。
- en: 'The following are the key learning outcomes for this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的关键学习成果如下：
- en: Choosing the right configuration of Rust for your project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的项目选择正确的 Rust 配置
- en: Cargo introduction and project structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cargo 介绍和项目结构
- en: Cargo build management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cargo 构建管理
- en: Cargo dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cargo 依赖项
- en: Writing test scripts and doing automated unit and integration testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试脚本和进行自动单元和集成测试
- en: Automating the generation of technical documentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成技术文档
- en: By the end of this chapter, you will have learned how to select the right project
    type and toolchain; organize project code efficiently; add external and internal
    libraries as dependencies; build the project for development, test, and production
    environments; automate testing; and generate documentation for your Rust code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何选择正确的项目类型和工具链；高效组织项目代码；添加外部和内部库作为依赖项；为开发、测试和生产环境构建项目；自动化测试；并为你的
    Rust 代码生成文档。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Rustup must be installed in the local development environment. Use this link
    for installation: [https://github.com/rust-lang/rustup](https://github.com/rust-lang/rustup).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rustup 必须安装在本地的开发环境中。请使用此链接进行安装：[https://github.com/rust-lang/rustup](https://github.com/rust-lang/rustup)。
- en: 'Refer to the following link for official installation instructions: [https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接获取官方安装说明：[https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install)。
- en: 'After installation, check `rustc`, and `cargo` have been installed correctly
    with the following commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，使用以下命令检查 `rustc` 和 `cargo` 是否已正确安装：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You must have access to any code editor of your choice.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须能够访问你选择的任何代码编辑器。
- en: Some of the code and commands in this chapter, especially those related to shared
    libraries and setting paths, require a Linux system environment. It is recommended
    to install a local virtual machine such as VirtualBox or equivalent with a Linux
    installation for working with the code in this chapter. Instructions to install
    VirtualBox can be found at [https://www.virtualbox.org](https://www.virtualbox.org).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些代码和命令，特别是与共享库和设置路径相关的代码，需要在 Linux 系统环境中运行。建议安装一个本地虚拟机，如 VirtualBox 或等效产品，并安装
    Linux 以便处理本章中的代码。安装 VirtualBox 的说明可以在以下链接找到：[https://www.virtualbox.org](https://www.virtualbox.org)。
- en: The Git repo for the examples in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例的 Git 仓库可以在以下链接找到：[https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01)。
- en: Choosing the right Rust configuration for your project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的项目选择正确的 Rust 配置
- en: When you start with Rust programming, you have to first select a Rust release
    channel and a Rust project type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始学习 Rust 编程时，你首先需要选择一个 Rust 发布渠道和一个 Rust 项目类型。
- en: This section discusses details of the Rust *release channels* and gives guidance
    on how to choose among them for your project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了 Rust 的 *发布渠道* 的细节，并提供了关于如何为你的项目选择它们的指导。
- en: Rust also allows you to build different types of binaries – standalone executables,
    static libraries, and dynamic libraries. If you know upfront what you will be
    building, you can create the right project type with the scaffolding code generated
    for you.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Rust还允许你构建不同类型的二进制文件——独立可执行文件、静态库和动态库。如果你事先知道你将构建什么，你可以使用为你生成的脚手架代码创建正确的项目类型。
- en: We will cover these in this section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中介绍这些内容。
- en: Choosing a Rust release channel
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择Rust发布通道
- en: The Rust programming language is developed continually and there are three releases
    being developed simultaneously at any point in time, each called a **release channel**.
    Each channel has a purpose and has varying features and stability characteristics.
    The three release channels are *stable*, *beta*, and *nightly*. Unstable language
    features and libraries are developed in the **nightly** and **beta** channels,
    while stability guarantees are provided on the **stable** channel.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Rust编程语言是持续开发的，在任何时候都有三个版本在同时开发，每个版本称为**发布通道**。每个通道都有其目的，具有不同的功能和稳定性特征。三个发布通道是*稳定*、*beta*和*夜间*。不稳定语言功能和库在**夜间**和**beta**通道中开发，而**稳定**通道提供稳定性保证。
- en: '**Rustup** is the tool that installs the Rust compiler, the Rust Standard Library,
    the Cargo package manager, and other core tools for activities such as code formatting,
    testing, benchmarking, and documentation. All these tools are available in multiple
    flavors called *toolchains*. A *toolchain* is a combination of a *release channel*
    and a *host*, and optionally also has an associated archive date.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rustup**是安装Rust编译器、Rust标准库、Cargo包管理器和用于代码格式化、测试、基准测试和文档等活动的其他核心工具的工具。所有这些工具都可用作多种称为*工具链*的版本。*工具链*是*发布通道*和*宿主*的组合，并且可选地还有一个相关的存档日期。'
- en: '*Rustup* can install a toolchain from a *release channel*, or from other sources
    such as official archives and local builds. *Rustup* also determines the toolchain
    depending on the host platform. Rust is officially available on Linux, Windows,
    and macOS. Rustup thus is called a *tool multiplexer* as it installs and manages
    multiple toolchains, and in this sense is similar to *rbenv*, *pyenv*, or *nvm*
    in *Ruby*, *Python*, and *Node.js* respectively.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rustup*可以从*发布通道*或其他来源（如官方存档和本地构建）安装工具链。*Rustup*还根据宿主平台确定工具链。Rust官方支持Linux、Windows和macOS。因此，*Rustup*被称为*工具多路复用器*，因为它安装和管理多个工具链，从这个意义上讲，它与*Ruby*中的*rbenv*、*Python*中的*pyenv*或*Node.js*中的*nvm*类似。'
- en: Rustup manages the complexity associated with toolchains but makes the installation
    process fairly straightforward as it provides sensible defaults. These can later
    be modified by the developer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Rustup管理与工具链相关的复杂性，但由于它提供了合理的默认设置，安装过程相对简单。这些设置可以由开发者稍后修改。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Rust's stable version is released every 6 weeks; for example, Rust 1.42.0 was
    released on March 12, 2020, and 6 weeks later to the day, Rust 1.43 was released
    on April 23, 2020.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的稳定版本每6周发布一次；例如，Rust 1.42.0于2020年3月12日发布，6周后的同一天，Rust 1.43于2020年4月23日发布。
- en: A new nightly version of Rust is released every day. Once every 6 weeks, the
    latest master branch of nightly becomes the beta version.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每天都会发布一个新的Rust夜间版本。每6周，最新的夜间版本的主分支将成为beta版本。
- en: Most Rust developers primarily use the *stable* channel. Beta channel releases
    are not used actively, but only to test for any regressions in the Rust language
    releases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Rust开发者主要使用*稳定*通道。beta通道的发布并不活跃，但仅用于测试Rust语言发布中的任何回归。
- en: The *nightly* channel is for active language development and is published every
    night. The *nightly* channel lets Rust develop new and experimental features and
    allows early adopters to test them before they are stabilized. The price to be
    paid for early access is that there may be breaking changes to these features
    before they get into stable releases. Rust uses feature flags to determine what
    features are enabled in a given nightly release. A user who wants to use a cutting-edge
    feature in nightly version has to annotate the code with the appropriate *feature
    flag*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*夜间*通道用于活跃的语言开发，并且每晚发布。*夜间*通道允许Rust开发新的和实验性功能，并允许早期采用者在它们稳定之前测试它们。早期访问的代价是，在它们进入稳定发布之前，这些功能可能会有破坏性的变化。Rust使用功能标志来确定给定夜间版本中启用了哪些功能。想要在夜间版本中使用前沿功能的使用者必须使用适当的*功能标志*对代码进行注释。'
- en: 'An example of a feature flag is shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了功能标志的一个例子：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that beta and stable releases cannot use feature flags.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，beta和稳定版本不能使用功能标志。
- en: 'Rustup is configured to use the stable channel by default. To work with other
    channels, here are a few commands. For a complete list, refer to the official
    link: [https://github.com/rust-lang/rustup](https://github.com/rust-lang/rustup).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustup`默认配置为使用稳定通道。要使用其他通道，这里有一些命令。对于完整的列表，请参阅官方链接：[https://github.com/rust-lang/rustup](https://github.com/rust-lang/rustup)。'
- en: 'To install nightly Rust, use this command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装夜间Rust，请使用以下命令：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To activate nightly Rust globally, use this command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局激活夜间Rust，请使用以下命令：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To activate nightly at a directory level, use this command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在目录级别激活夜间Rust，请使用以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get the version of the compiler in nightly Rust, use this command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取夜间Rust中编译器的版本，请使用以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To reset `rustup` to use the stable channel, use this command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`rustup`重置为使用稳定通道，请使用以下命令：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To show the installed toolchains and which is currently active, use this command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示已安装的工具链以及当前活动的是哪一个，请使用以下命令：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To update the installed toolchains to the latest versions, use this command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新已安装的工具链到最新版本，请使用以下命令：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that once `rustup default <channel-name>` is set, other related tools,
    such as Cargo and Rustc, use the default channel set.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦设置了`rustup default <channel-name>`，其他相关工具，如Cargo和Rustc，将使用默认通道设置。
- en: Which Rust channel should you use for your project? For any **production-bound**
    projects, it is advisable to use only the **stable** release channel. For any
    **experimental** projects, the **nightly** or **beta** channels may be used, with
    caution as there may be breaking changes needed for the code in future releases.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的项目，应该使用哪个Rust通道？对于任何**面向生产的**项目，建议只使用**稳定**发布通道。对于任何**实验性**项目，可以使用**夜间**或**beta**通道，但需谨慎，因为未来版本中可能会有破坏性更改。
- en: Selecting a Rust project type
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择Rust项目类型
- en: 'There are two basic types of projects in Rust: **libraries** and **binaries**
    (or executables).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中有两种基本的项目类型：**库**和**二进制文件**（或可执行文件）。
- en: A *library* is a self-contained piece of code that is intended for use by other
    programs. The purpose of a library is to enable code reuse and speed up the development
    cycle by leveraging the hard work of other open source developers. Libraries,
    also called a `crates.io`) that can be discovered and downloaded by other developers
    for use in their own programs. Program execution for a library crate begins in
    the `src/lib.rs` file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *库* 是一个自包含的代码片段，旨在供其他程序使用。库的目的是通过利用其他开源开发者的辛勤工作来促进代码重用并加快开发周期。库也称为`crates.io`，可以被其他开发者发现和下载，用于他们自己的程序。库crate的程序执行从`src/lib.rs`文件开始。
- en: A *binary* is a standalone executable that may download and link other libraries
    into a single binary. A binary project type is also called a `main()` function
    that is present in the `src/main.rs` file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *二进制文件* 是一个独立的可执行文件，它可以下载并链接其他库到一个单独的二进制文件中。二进制项目类型也称为`main()`函数，该函数位于`src/main.rs`文件中。
- en: It is important to determine whether you want to build a binary or a library
    program in Rust while initializing the project. We will see examples of these
    two types of projects later in this chapter. It's time to introduce the star tool
    and Swiss-Army knife in the Rust ecosystem, *Cargo*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化项目时确定你想要在Rust中构建二进制或库程序是很重要的。我们将在本章后面看到这两种类型项目的示例。现在是时候介绍Rust生态系统中的明星工具和瑞士军刀——*Cargo*。
- en: Introducing Cargo and project structures
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Cargo和项目结构
- en: Cargo is the official build and dependency management tool for Rust. It has
    many of the features of the other popular tools in this segment, such as Ant,
    Maven, Gradle, npm, CocoaPods, pip, and yarn, but provides a far more seamless
    and integrated developer experience for compiling code, downloading and compiling
    dependent libraries (called **crates** in Rust), linking libraries, and building
    development and release binaries. It also performs the incremental build of the
    code to reduce the compilation time as the programs evolve. In addition, it creates
    an idiomatic project structure while creating new Rust projects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo是Rust的官方构建和依赖管理工具。它具有许多其他流行工具的许多功能，如Ant、Maven、Gradle、npm、CocoaPods、pip和yarn，但为编译代码、下载和编译依赖库（在Rust中称为**crate**）、链接库、构建开发和发布二进制文件提供了更加无缝和集成的开发者体验。它还执行代码的增量构建，以减少程序演变过程中的编译时间。此外，在创建新的Rust项目时，它还创建了一个惯用的项目结构。
- en: In short, Cargo as an integrated toolchain gives a seamless experience in the
    day-to-day tasks of creating a new project, building it, managing external dependencies,
    debugging, testing, generating documentation, and release management.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Cargo作为一个集成工具链，在创建新项目、构建项目、管理外部依赖、调试、测试、生成文档和发布管理等日常任务中提供了无缝体验。
- en: 'Cargo is the tool that can be used to set up the basic project scaffolding
    structure for a new Rust project. Before we create a new Rust project with Cargo,
    let''s first understand the options for organizing code within Rust projects:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo是可以用来为新Rust项目设置基本项目脚手架结构的工具。在我们使用Cargo创建新的Rust项目之前，让我们首先了解在Rust项目中组织代码的选项：
- en: '![Figure 1.1 – Cargo project structure and hierarchy](img/Figure_1.1_B16405.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – Cargo项目结构和层次](img/Figure_1.1_B16405.jpg)'
- en: Figure 1.1 – Cargo project structure and hierarchy
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Cargo项目结构和层次
- en: '*Figure 1.1* shows how code can be organized within a Cargo-generated Rust
    project.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.1*展示了如何在Cargo生成的Rust项目中组织代码。'
- en: The smallest standalone unit of organization of code in a Rust project is a
    `main.rs` is a source file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust项目中，代码组织的最小独立单元是`main.rs`源文件。
- en: The next highest level of code organization is a **module**. Code within modules
    has its own unique namespace. A module can contain user-defined data types (such
    as structs, traits, and enums), constants, type aliases, other module imports,
    and function declarations. Modules can be nested within one another. Multiple
    module definitions can be defined within a single source file for smaller projects,
    or a module can contain code spread across multiple source files for larger projects.
    This type of organization is also referred to as a module system.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码组织的下一个高级别是**模块**。模块内的代码有其自己的唯一命名空间。一个模块可以包含用户定义的数据类型（如结构体、特性和枚举）、常量、类型别名、其他模块导入和函数声明。模块可以嵌套在彼此内部。在较小的项目中，可以在单个源文件中定义多个模块定义，或者一个模块可以包含跨越多个源文件的代码，这在较大的项目中也很常见。这种组织方式也被称为模块系统。
- en: Multiple modules can be organized into `main.rs` and for library crates it is
    `lib.rs`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 多个模块可以组织到`main.rs`中，对于库crate则是`lib.rs`。
- en: One or more crates can be combined into a `Cargo.toml` file, which contains
    information on how to build the package, including downloading and linking the
    dependent crates. When Cargo is used to create a new Rust project, it creates
    a *package*. A *package* must contain at least one crate – either a library or
    a binary crate. A package may contain any number of binary crates, but it can
    contain either zero or only one library crate.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个或多个crate可以组合成一个`Cargo.toml`文件，其中包含有关如何构建包的信息，包括下载和链接依赖的crate。当使用Cargo创建新的Rust项目时，它创建一个*package*。一个*package*必须至少包含一个crate
    – 要么是库crate，要么是二进制crate。一个package可以包含任意数量的二进制crate，但它可以包含零个或仅有一个库crate。
- en: As Rust projects grow in size, there may be a need to split up a package into
    multiple units and manage them independently. A set of related packages can be
    organized as a `Cargo.lock` file (containing details of specific versions of dependencies
    that are shared across all packages in the workspace) and output directory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Rust项目规模的扩大，可能需要将一个包拆分成多个单元并独立管理。一组相关的包可以组织成一个`Cargo.lock`文件（包含工作区中所有包共享的依赖项特定版本的详细信息）和输出目录。
- en: Let's see a few examples to understand various types of project structures in
    Rust.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个例子来了解Rust中各种项目结构的类型。
- en: Automating build management with Cargo
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cargo自动化构建管理
- en: When Rust code is compiled and built, the generated binary can either be a standalone
    executable binary or a library that can be used by other projects. In this section,
    we will look at how Cargo can be used to create Rust binaries and libraries, and
    how to configure metadata in `Cargo.toml` to provide build instructions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当Rust代码编译和构建时，生成的二进制文件可以是独立的可执行二进制文件，也可以是其他项目可以使用的库。在本节中，我们将探讨如何使用Cargo创建Rust的二进制文件和库，以及如何配置`Cargo.toml`中的元数据以提供构建指令。
- en: Building a basic binary crate
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基本的二进制crate
- en: In this section, we will build a basic binary crate. A binary crate when built,
    produces an executable binary file. This is the default crate type for the cargo
    tool. Let's now look at the command to create a binary crate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个基本的二进制crate。当构建二进制crate时，会产生一个可执行的二进制文件。这是cargo工具的默认crate类型。现在让我们看看创建二进制crate的命令。
- en: The first step is to generate a Rust source package using the `cargo new` command.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是使用`cargo new`命令生成Rust源代码包。
- en: 'Run the following command in a terminal session inside your working directory
    to create a new package:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的工作目录内的终端会话中运行以下命令以创建一个新的包：
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the command executes, you will see the following directory structure:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦命令执行，你将看到以下目录结构：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And the `src` directory contains one file called `main.rs`:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且 `src` 目录中包含一个名为 `main.rs` 的文件：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To generate a binary crate (or executable) from this package, run the following
    command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从这个包生成二进制crate（或可执行文件），请运行以下命令：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Execute the following from the command line:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行执行以下操作：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will see the following printed to your console:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将在控制台看到以下输出：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the following in the command line:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中运行以下命令：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A cargo package can contain the source for multiple binaries. Let''s learn
    how to add another binary to our project. In `Cargo.toml`, add a new `[[bin]]`
    target below the first one:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个cargo包可以包含多个二进制的源代码。让我们学习如何向我们的项目中添加另一个二进制。在 `Cargo.toml` 中，在第一个 `[[bin]]`
    目标下方添加一个新的 `[[bin]]` 目标：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, create a new file, `src/second.rs`, and add the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的文件，`src/second.rs`，并添加以下代码：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will see the statement `target/debug` directory with the name `new-second-program`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到名为 `new-second-program` 的 `target/debug` 目录中的声明。
- en: 'Congratulations! You have learned how to do the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经学会了以下内容：
- en: Create your first Rust source package and compile it into an executable binary
    crate
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个Rust源包并将其编译成一个可执行二进制crate
- en: Give a new name to the binary, different from the package name
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给二进制取一个新名字，不同于包名
- en: Add a second binary to the same cargo package
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向同一个cargo包添加第二个二进制
- en: Note that a `cargo` package can contain one or more binary crates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个 `cargo` 包可以包含一个或多个二进制crate。
- en: Configuring Cargo
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Cargo
- en: A cargo package has an associated `Cargo.toml` file, which is also called the
    **manifest**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个cargo包有一个关联的 `Cargo.toml` 文件，也称为 **清单**。
- en: 'The manifest, at a minimum, contains the `[package]` section but can contain
    many other sections. A subset of the sections are listed here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 清单至少包含 `[package]` 部分，但可以包含许多其他部分。这里列出了部分部分：
- en: '**Specifying output targets for the package**: Cargo packages can have five
    types of targets:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**指定包的输出目标**：Cargo包可以有五种类型的目标：'
- en: '`[[bin]]`: A binary target is an executable program that can be run after it
    is built.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[bin]]`: 二进制目标是构建后可以运行的可执行程序。'
- en: '`[lib]`: A library target produces a library that can be used by other libraries
    and executables.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[lib]`: 库目标生成一个库，可以被其他库和可执行程序使用。'
- en: '`[[example]]`: This target is useful for libraries to demonstrate the use of
    external APIs to users through example code. The example source code located in
    the `example` directory can be built into executable binaries using this target.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[example]]`: 这个目标对于库来说很有用，可以通过示例代码向用户展示外部API的使用。位于 `example` 目录中的示例源代码可以使用此目标构建成可执行二进制。'
- en: '`[[test]]`: Files located in the `tests` directory represent integration tests
    and each of these can be compiled into a separate executable binary.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[test]]`: 位于 `tests` 目录中的文件代表集成测试，并且这些文件中的每一个都可以编译成一个单独的可执行二进制。'
- en: '`[[bench]]`: Benchmark functions defined in libraries and binaries are compiled
    into separate executables.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[bench]]`: 定义在库和二进制中的基准函数被编译成单独的可执行程序。'
- en: For each of these targets, the configuration can be specified, including parameters
    such as the name of the target, the source file of the target, and whether you
    want cargo to automatically run test scripts and generate documentation for the
    target. You may recall that in the previous section, we changed the name and set
    the source file for the generated binary executable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些目标中的每一个，都可以指定配置，包括目标名称、目标源文件以及是否让cargo自动运行测试脚本并为目标生成文档。你可能还记得，在前一节中，我们更改了名称并设置了生成的二进制可执行文件的源文件。
- en: '**Specifying dependencies for the package**: The source files in a package
    may depend on other internal or external libraries, which are also called *dependencies*.
    Each of these in turn may depend on other libraries and so on. Cargo downloads
    the list of dependencies specified under this section and links them to the final
    output targets. The various types of dependencies include the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**指定包的依赖项**：包中的源文件可能依赖于其他内部或外部库，这些库也被称为 *依赖项*。每个依赖项反过来可能依赖于其他库，依此类推。Cargo下载本节中指定的依赖项列表，并将它们链接到最终输出目标。依赖项的多种类型包括以下：'
- en: '`[dependencies]`: Package library or binary dependencies'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[dependencies]`: 包库或二进制依赖'
- en: '`[dev-dependencies]`: Dependencies for examples, tests, and benchmarks'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[dev-dependencies]`：用于示例、测试和基准测试的依赖项'
- en: '`[build-dependencies]`: Dependencies for build scripts (if any are specified)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[build-dependencies]`：构建脚本（如果有指定）的依赖项'
- en: '`[target]`: This is for the cross-compilation of code for various target architectures.
    Note that this is not to be confused with the output targets of the package, which
    can be lib, bin, and so on.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[target]`：这是用于为各种目标架构交叉编译代码的。注意，这不要与包的输出目标混淆，包的输出可以是lib、bin等等。'
- en: '**Specifying build profiles**: There are four types of profiles that can be
    specified while building a cargo package:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**指定构建配置文件**：在构建cargo包时可以指定四种类型的配置文件：'
- en: '`dev`: The `cargo build` command uses the `dev` profile by default. Packages
    built with this option are optimized for compile-time speed.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`：`cargo build`命令默认使用`dev`配置文件。使用此选项构建的包针对编译时速度进行了优化。'
- en: '`release`: The `cargo build –-release` command enables the release profile,
    which is suitable for production release, and is optimized for runtime speed.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release`：使用`cargo build –-release`命令启用发布配置文件，这适合用于生产发布，并且针对运行时速度进行了优化。'
- en: '`test`: The `cargo test` command uses this profile. This is used to build test
    executables.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：`cargo test`命令使用此配置文件。这用于构建测试可执行文件。'
- en: '`bench`: The `cargo bench` command creates the benchmark executable, which
    automatically runs all functions annotated with the `#[bench]` attribute.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bench`：`cargo bench`命令创建基准测试的可执行文件，它会自动运行所有带有`#[bench]`属性的函数。'
- en: '`[workspace]` section can be used to define the list of packages that are part
    of the workspace.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`[workspace]`部分可以用来定义工作空间中包含的包列表。'
- en: Building a static library crate
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建静态库crate
- en: 'We have seen how to create binary crates. Let''s now learn how to create a
    library crate:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建二进制crate。现在让我们学习如何创建库crate：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The default directory structure of a new cargo project is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 新建cargo项目的默认目录结构如下：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following code in `src/lib.rs`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/lib.rs`中添加以下代码：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will see the library built under `target/debug` and it will have the name
    `libmy_first_lib.rlib`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到在`target/debug`下构建的库，它将具有`libmy_first_lib.rlib`的名称。
- en: To invoke the function in this library, let's build a small binary crate. Create
    a `bin` directory under `src`, and a new file, `src/bin/mymain.rs`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这个库中的函数，让我们构建一个小的二进制crate。在`src`下创建一个`bin`目录，并创建一个新文件，`src/bin/mymain.rs`。
- en: 'Add the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `use my_first_lib::hello_from_lib` statement tells the compiler to bring
    the library function into the scope of this program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`use my_first_lib::hello_from_lib`语句告诉编译器将库函数引入到本程序的范围内。'
- en: 'Run the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You will see the `print` statement in your console. Also, the binary `mymain`
    will be placed in the `target/debug` folder along with the library we wrote earlier.
    The binary crate looks for the library in the same folder, which it finds in this
    case. Hence it is able to invoke the function within the library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在你的控制台中看到`print`语句。同时，二进制文件`mymain`将被放置在`target/debug`文件夹中，与我们之前编写的库文件一起。二进制crate会在同一文件夹中寻找库文件，在这种情况下它找到了。因此，它能够调用库中的函数。
- en: 'If you want to place the `mymain.rs` file in another location (instead of within
    `src/bin`), then add a target in `Cargo.toml` and mention the name and path of
    the binary as shown in the following example, and move the `mymain.rs` file to
    the specified location:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将`mymain.rs`文件放置在另一个位置（而不是在`src/bin`内），那么在`Cargo.toml`中添加一个目标，并像以下示例中那样指定二进制文件的名字和路径，然后将`mymain.rs`文件移动到指定位置：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run `cargo run --bin mymain` and you will see the `println` output in your console.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`cargo run --bin mymain`，你将在你的控制台中看到`println`输出。
- en: Automating dependency management
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化依赖项管理
- en: You learned in the previous section how Cargo can be used to set up the base
    project directory structure and scaffolding for a new project, and how to build
    various types of binary and library crates. We will look at the dependency management
    features of Cargo in this section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何使用Cargo设置新项目的基目录结构和脚手架，以及如何构建各种类型的二进制和库crate。在本节中，我们将探讨Cargo的依赖项管理功能。
- en: Rust comes with a built-in standard library consisting of language primitives
    and commonly used functions, but it is small by design (compared to other languages).
    Most real-world programs in Rust depend on additional external libraries to improve
    functionality and developer productivity. Any such external code that is used
    is a *dependency* for the program. Cargo makes it easy to specify and manage dependencies.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Rust附带一个内置的标准库，由语言原语和常用函数组成，但按设计来说很小（与其他语言相比）。大多数现实世界的Rust程序都依赖于额外的外部库来提高功能性和开发者生产力。任何此类外部代码都是程序的*依赖项*。Cargo使得指定和管理依赖项变得容易。
- en: In the Rust ecosystem, *crates.io* is the central public package registry for
    discovering and downloading libraries (called `crates.io` as the default package
    registry.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust生态系统中，*crates.io*是发现和下载库（称为`crates.io`作为默认包注册表）的中心公共包注册表。
- en: Dependencies are specified in the `[dependencies]` section of `Cargo.toml`.
    Let's see an example.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项在`Cargo.toml`的`[dependencies]`部分中指定。让我们看看一个例子。
- en: 'Start a new project with this command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令开始一个新项目：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `Cargo.toml`, make the following entry to include an external library:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`中，进行以下条目以包含外部库：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Chrono` is a datetime library. This is called a dependency because our `deps-example`
    crate depends on this external library for its functionality.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chrono`是一个日期时间库。这被称为依赖项，因为我们的`deps-example`crate依赖于这个外部库来实现其功能。'
- en: When you run `cargo build`, cargo looks for a crate on `crates.io` with this
    name and version. If found, it downloads this crate along with all of its dependencies,
    compiles them all, and updates a file called `Cargo.lock` with the exact versions
    of packages downloaded. The `Cargo.lock` file is a generated file and not meant
    for editing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`cargo build`时，cargo会查找`crates.io`上具有此名称和版本的crate。如果找到，它将下载此crate及其所有依赖项，编译它们，并将下载的包的确切版本更新到名为`Cargo.lock`的文件中。`Cargo.lock`文件是一个生成文件，不应进行编辑。
- en: Each dependency in `Cargo.toml` is specified in a new line and takes the format
    `<crate-name> = "<semantic-version-number>"`. **Semantic versioning or Semver**
    has the form X.Y.Z, where X is the major version number, Y is the minor version,
    and Z is the patch version.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo.toml`中的每个依赖项都在新的一行中指定，并采用格式`<crate-name> = "<semantic-version-number>"`。**语义版本或Semver**的格式为X.Y.Z，其中X是主版本号，Y是次版本号，Z是补丁版本号。'
- en: Specifying the location of a dependency
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定依赖项的位置
- en: 'There are many ways to specify the location and version of dependencies in
    `Cargo.toml`, some of which are summarized here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`中指定依赖项的位置和版本有许多方法，其中一些在此处总结：
- en: '**Crates.io registry**: This is the default option and all that is needed is
    to specify the package name and version string as we did earlier in this section.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Crates.io注册表**：这是默认选项，我们只需指定包名和版本字符串，就像在本节中之前所做的那样。'
- en: '`crates.io` is the default registry, Cargo provides the option to use an alternate
    registry. The registry name has to be configured in the `.cargo/config` file,
    and in `Cargo.toml`, an entry is to be made with the registry name, as shown in
    the example here:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crates.io`是默认注册表，Cargo提供了使用备用注册表选项。注册表名称必须在`.cargo/config`文件中进行配置，并在`Cargo.toml`中创建一个条目，如下例所示：'
- en: '[PRE28]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Cargo.toml` file in order to fetch its dependencies.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cargo.toml`文件以获取其依赖项。'
- en: '**Specify a local path**: Cargo supports path dependencies, which means the
    library can be a sub-crate within the main cargo package. While building the main
    cargo package, the sub-crates that have also been specified as dependencies will
    be built. But dependencies with only a path dependency cannot be uploaded to the
    *crates.io* public registry.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定本地路径**：Cargo支持路径依赖项，这意味着库可以是主cargo包内的子crate。在构建主cargo包时，也被指定为依赖项的子crate将被构建。但只有路径依赖项的依赖项不能上传到*crates.io*公共注册表。'
- en: '**Multiple locations**: Cargo supports the option to specify both a registry
    version *and* either a Git or path location. For local builds, the Git or path
    version is used, and the registry version will be used when the package is published
    to *crates.io*.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个位置**：Cargo支持指定注册表版本和Git或路径位置。对于本地构建，使用Git或路径版本，当包发布到*crates.io*时将使用注册表版本。'
- en: Using dependent packages in source code
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在源代码中使用依赖包
- en: 'Once the dependencies are specified in the `Cargo.toml` file in any of the
    preceding formats, we can use the external library in the package code as shown
    in the following example. Add the following code to `src/main.rs`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 `Cargo.toml` 文件中指定了依赖项，无论以何种格式，我们都可以在包代码中使用外部库，如下例所示。将以下代码添加到 `src/main.rs`：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `use` statement tells the compiler to bring the `chrono` package `Utc`
    module into the scope of this program. We can then access the function `now()`
    from the `Utc` module to print out the current date and time. The `use` statement
    is not mandatory. An alternative way to print datetime would be as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 语句告诉编译器将 `chrono` 包的 `Utc` 模块引入到本程序的范围内。然后我们可以从 `Utc` 模块访问 `now()` 函数来打印当前的日期和时间。`use`
    语句不是强制的。打印日期时间的另一种方法如下：'
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This would give the same result. But if you have to use functions from the `chrono`
    package multiple times in code, it is more convenient to bring `chrono` and required
    modules into scope once using the `use` statement, and it becomes easier to type.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出相同的结果。但是，如果你需要在代码中多次使用 `chrono` 包中的函数，使用 `use` 语句一次性将 `chrono` 和所需模块引入范围会更方便，这会使输入变得更简单。
- en: 'It is also possible to rename the imported package with the `as` keyword:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 `as` 关键字重命名导入的包：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For more details on managing dependencies, refer to the Cargo docs: [https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有关管理依赖项的更多详细信息，请参阅 Cargo 文档：[https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html)。
- en: In this section, we have seen how to add dependencies to a package. Any number
    of dependencies can be added to `Cargo.toml` and used within the program. Cargo
    makes the dependency management process quite a pleasant experience.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何向包中添加依赖项。可以在 `Cargo.toml` 中添加任意数量的依赖项并在程序中使用。Cargo 使依赖项管理过程变得相当愉快。
- en: Let's now look at another useful feature of Cargo – running automated tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看 Cargo 的另一个有用功能——运行自动化测试。
- en: Writing and running automated tests
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和运行自动化测试
- en: The Rust programming language has built-in support for writing automated tests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编程语言内置了对编写自动化测试的支持。
- en: Rust tests are basically Rust functions that verify whether the other non-test
    functions written in the package work as intended. They basically invoke the other
    functions with the specified data and assert that the return values are as expected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 测试基本上是 Rust 函数，用于验证包中编写的其他非测试函数是否按预期工作。它们基本上使用指定数据调用其他函数，并断言返回值符合预期。
- en: Rust has two types of tests – unit tests and integration tests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有两种测试类型——单元测试和集成测试。
- en: Writing unit tests in Rust
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Rust 中编写单元测试
- en: 'Create a new Rust package with the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个新的 Rust 包：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Write a new function that returns the process ID of the currently running process.
    We will look at the details of process handling in a later chapter, so you may
    just type in the following code, as the focus here is on writing unit tests:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个返回当前运行进程的进程 ID 的新函数。我们将在后面的章节中查看进程处理细节，所以你只需输入以下代码即可，因为这里的重点是编写单元测试：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have written a simple (silly) function to use the standard library process
    module and retrieve the process ID of the currently running process.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个简单的（愚蠢的）函数，使用标准库进程模块并检索当前运行进程的进程 ID。
- en: Run the code using `cargo check` to confirm there are no syntax errors.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cargo check` 运行代码以确认没有语法错误。
- en: 'Let''s now write a unit test. Note that we cannot know upfront what the process
    ID is going to be, so all we can test is whether a number is being returned:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写一个单元测试。请注意，我们事先不知道进程 ID 会是多少，所以我们只能测试是否返回了一个数字：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run `cargo test`. You will see that the test has passed successfully, as the
    function returns a non-zero positive integer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `cargo test`。你会看到测试已经成功通过，因为函数返回了一个非零正整数。
- en: Note that we have written the unit tests in the same source file as the rest
    of the code. In order to tell the compiler that this is a test function, we use
    the `#[test]` annotation. The `assert!` macro (available in standard Rust library)
    is used to check whether a condition evaluates to true. There are two other macros
    available, `assert_eq!` and `assert_ne!`, which are used to test whether the two
    arguments passed to these macros are equal or not.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将单元测试写在了与代码相同的源文件中。为了告诉编译器这是一个测试函数，我们使用了 `#[test]` 注解。`assert!` 宏（在标准
    Rust 库中可用）用于检查条件是否评估为真。还有两个其他宏可用，`assert_eq!` 和 `assert_ne!`，它们用于测试传递给这些宏的两个参数是否相等或不等。
- en: 'A custom error message can also be specified:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以指定自定义错误消息：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To compile but not run the tests, use the `--no-run` option with the `cargo
    test` command.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译但不运行测试，请使用 `cargo test` 命令的 `--no-run` 选项。
- en: 'The preceding example has only one simple `test` function, but as the number
    of tests increases, the following problems arise:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子只有一个简单的 `test` 函数，但随着测试数量的增加，以下问题会出现：
- en: How do we write any helper functions needed for test code and differentiate
    it from the rest of the package code?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何编写测试代码所需的任何辅助函数，并将其与其他包代码区分开来？
- en: How can we prevent the compiler from compiling tests as part of each build (to
    save time) and not include test code as part of the normal build (saving disk/memory
    space)?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何防止编译器将测试作为每个构建的一部分进行编译（以节省时间），并且不将测试代码作为正常构建的一部分（节省磁盘/内存空间）？
- en: 'In order to provide more modularity and to address the preceding questions,
    it is idiomatic in Rust to group test functions in a `test` module:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更多模块化和解决前面的问题，在 Rust 中将测试函数分组在 `test` 模块中是一种惯例：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here are the changes made to the code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码所做的更改：
- en: We have moved the `test` function under the `tests` module.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经将 `test` 函数移动到 `tests` 模块下。
- en: We have added the `cfg` attribute, which tells the compiler to compile test
    code only if we are trying to run tests (that is, only for `cargo test`, not for
    `cargo build`).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `cfg` 属性，它告诉编译器只有在尝试运行测试时才编译测试代码（即，仅对 `cargo test`，而不是对 `cargo build`）。
- en: 'There is a `use` statement, which brings the `get_process_id` function into
    the scope of the `tests` module. Note that `tests` is an inner module and so we
    use `super:: prefix` to bring the function that is being tested into the scope
    of the `tests` module.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 `use` 语句，它将 `get_process_id` 函数引入 `tests` 模块的范围内。请注意，`tests` 是一个内部模块，因此我们使用
    `super::` 前缀将正在测试的函数引入 `tests` 模块的范围内。
- en: '`cargo test` will now give the same results. But what we have achieved is greater
    modularity, and we''ve also allowed for the conditional compilation of test code.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo test` 现在将给出相同的结果。但我们实现的是更大的模块化，我们还允许条件编译测试代码。'
- en: Writing integration tests in Rust
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Rust 中编写集成测试
- en: In the *Writing unit tests in Rust* section, we saw how to define a `tests`
    module to hold the unit tests. This is used to test fine-grained pieces of code
    such as an individual function call. Unit tests are small and have a narrow focus.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Rust 中编写单元测试* 部分，我们看到了如何定义 `tests` 模块来保存单元测试。这是用来测试细粒度代码片段的，如单个函数调用。单元测试很小，关注面很窄。
- en: For testing broader test scenarios involving a larger scope of code such as
    a workflow, integration tests are needed. It is important to write both types
    of tests to fully ensure that the library works as expected.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及更大范围代码的更广泛的测试场景，例如工作流程，需要集成测试。编写这两种类型的测试对于完全确保库按预期工作非常重要。
- en: To write integration tests, the convention in Rust is to create a `tests` directory
    in the package root and create one or more files under this folder, each containing
    one integration test. Each file under the `tests` directory is treated as an individual
    crate.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写集成测试，Rust 中的惯例是在包根目录下创建一个 `tests` 目录，并在该目录下创建一个或多个文件，每个文件包含一个集成测试。`tests`
    目录下的每个文件都被视为一个单独的crate。
- en: 'But there is a catch. Integration tests in Rust are not available for binary
    crates, only library crates. So, let''s create a new library crate:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个问题。Rust 中的集成测试不适用于二进制crate，仅适用于库crate。因此，让我们创建一个新的库crate：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `src/lib.rs`, replace the existing code with the following. This is the
    same code we wrote earlier, but this time it is in `lib.rs`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/lib.rs` 中，用以下代码替换现有代码。这是我们之前写的相同代码，但这次它在 `lib.rs` 中：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s create a `tests` folder and create a file, `tests/integration_test1.rs`.
    Add the following code in this file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `tests` 文件夹并创建一个文件，`tests/integration_test1.rs`。在这个文件中添加以下代码：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note the following changes to the test code compared to unit tests:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与单元测试相比，以下是对测试代码的以下更改：
- en: 'Integration tests are external to the library, so we have to bring the library
    into the scope of the integration test. This is simulating how an external user
    of our library would call a function from the public interface of our library.
    This is in place of `super:: prefix` used in unit tests to bring the tested function
    into scope.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试位于库外部，因此我们必须将库引入集成测试的作用域。这是模拟外部用户如何从我们的库的公共接口调用函数。这是在单元测试中用`super::`前缀将测试函数引入作用域的替代方案。
- en: We did not have to specify the `#[cfg(test)]` annotation with integration tests,
    because these are stored in a separate folder and cargo compiles files in this
    directory only when we run `cargo test`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要在集成测试中指定`#[cfg(test)]`注解，因为这些测试存储在单独的文件夹中，并且cargo只有在运行`cargo test`时才会编译此目录下的文件。
- en: We still have to specify the `#[test]` attribute for each `test` function to
    tell the compiler these are the test functions (and not helper/utility code) to
    be executed.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们仍然必须为每个`test`函数指定`#[test]`属性，以告诉编译器这些是测试函数（而不是辅助/实用代码）要执行的。
- en: Run `cargo test`. You will see that this integration test has been run successfully.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo test`。你会看到这个集成测试已经成功运行。
- en: Controlling test execution
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制测试执行
- en: The `cargo test` command compiles the source code in test mode and runs the
    resultant binary. `cargo test` can be run in various modes by specifying command-line
    options. The following is a summary of the key options.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo test`命令以测试模式编译源代码并运行生成的二进制文件。`cargo test`可以通过指定命令行选项以各种模式运行。以下是关键选项的摘要。'
- en: Running a subset of tests by name
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过名称运行测试子集
- en: 'If there are a large number of tests in a package, `cargo test` runs all tests
    by default each time. To run any particular test cases by name, the following
    option can be used:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个包中有大量测试，`cargo test`默认每次都会运行所有测试。要按名称运行特定的测试用例，可以使用以下选项：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To verify this, let''s replace the code in the `integration_test1.rs` file
    with the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，让我们将`integration_test1.rs`文件中的代码替换为以下内容：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This last dummy `test` function is for purposes of the demonstration of running
    selective cases.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的虚拟`test`函数是为了演示如何运行选择性的案例。
- en: Run `cargo test` and you can see both tests executed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo test`，你可以看到两个测试都执行了。
- en: Run `cargo test files_test1` and you can see `files_test1` executed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo test files_test1`，你可以看到`files_test1`被执行。
- en: Run `cargo test files_test2` and you can see `files_test2` executed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo test files_test2`，你可以看到`files_test2`被执行。
- en: Run `cargo test files` and you will see both `files_test1` and `files_test2`
    tests executed, but `process_test1` is not executed. This is because cargo looks
    for all test cases containing the term `'files'` and executes them.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo test files`，你会看到`files_test1`和`files_test2`测试被执行，但`process_test1`没有被执行。这是因为cargo寻找所有包含术语`'files'`的测试用例并执行它们。
- en: Ignoring some tests
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略一些测试
- en: In some cases, you want to execute most of the tests every time but exclude
    a few. This can be achieved by annotating the `test` function with the `#[ignore]`
    attribute.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你希望每次执行大多数测试，但排除几个。这可以通过在`test`函数上标注`#[ignore]`属性来实现。
- en: 'In the previous example, let''s say we want to exclude `process_test1` from
    regular execution because it is computationally intensive and takes a lot of time
    to execute. The following snippet shows how it''s done:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，假设我们想要排除`process_test1`的常规执行，因为它计算密集，执行时间很长。以下代码片段展示了如何操作：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Run `cargo test`, and you will see that `process_test1` is marked as ignored,
    and hence not executed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo test`，你会看到`process_test1`被标记为忽略，因此没有执行。
- en: 'To run only the ignored tests in a separate iteration, use the following option:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在单独的迭代中运行被忽略的测试，请使用以下选项：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first `--` is a separator between the command-line options for the `cargo`
    command and those for the `test` binary. In this case, we are passing the `--ignored`
    flag for the test binary, hence the need for this seemingly confusing syntax.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`--`是`cargo`命令和`test`二进制命令行选项之间的分隔符。在这种情况下，我们正在为测试二进制传递`--ignored`标志，因此需要这种看似令人困惑的语法。
- en: Running tests sequentially or in parallel
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序或并行运行测试
- en: 'By default, `cargo test` runs the various tests in parallel in separate threads.
    To support this mode of execution, the `test` functions must be written in a way
    that there is no common data sharing across test cases. However if there is indeed
    such a need (for example, one test case writes some data to a location and another
    test case reads it), then we can run the tests in sequence as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`cargo test` 在单独的线程中并行运行各种测试。为了支持这种执行模式，测试函数必须以没有测试案例之间共享公共数据的方式编写。然而，如果确实有这样的需求（例如，一个测试案例将一些数据写入某个位置，另一个测试案例读取它），那么我们可以按以下方式按顺序运行测试：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command tells cargo to use only one thread for executing tests, which indirectly
    means that tests have to be executed in sequence.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令告诉 cargo 只使用一个线程来执行测试，这间接意味着测试必须按顺序执行。
- en: In summary, Rust's strong built-in type system and strict ownership rules enforced
    by the compiler, coupled with the ability to script and execute unit and integration
    test cases as an integral part of the language and tooling, makes it very appealing
    to write robust, reliable systems.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Rust强大的内置类型系统和编译器强制执行的严格所有权规则，加上能够将单元和集成测试案例作为语言和工具的一部分进行脚本化和执行的能力，使得编写健壮、可靠的系统非常吸引人。
- en: Documenting your project
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录你的项目。
- en: Rust ships with a tool called `Rustdoc`, which can generate documentation for
    Rust projects. Cargo has integration with `Rustdoc`, so you can use either tool
    to generate documentation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Rust附带了一个名为`Rustdoc`的工具，它可以生成Rust项目的文档。Cargo与`Rustdoc`集成，因此你可以使用任何工具来生成文档。
- en: To get an idea of what it means to have documentation generated for Rust projects,
    go to [http://docs.rs](http://docs.rs).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为Rust项目生成文档的含义，请访问[http://docs.rs](http://docs.rs)。
- en: This is a documentation repository for all the crates in *crates.io*. To see
    a sample of the generated documentation, select a crate and view the docs. For
    example, you can go to `docs.rs/serde` to see docs for the popular serialization/deserialization
    library in Rust.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个为*crates.io*中所有crate提供的文档仓库。要查看生成的文档样本，选择一个crate并查看文档。例如，你可以访问`docs.rs/serde`来查看Rust中流行的序列化/反序列化库的文档。
- en: To generate similar documentation for your Rust projects, it is important to
    think through what to document, and how to document it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的Rust项目生成类似的文档，重要的是要考虑要记录什么，以及如何记录。
- en: 'But what can you document? The following are some of the aspects of a crate
    that it would be useful to document:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以记录什么？以下是一些有用的crate记录方面：
- en: An overall short description of what your Rust library does
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的Rust库所做事情的整体简短描述。
- en: A list of modules and public functions in the library
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库中模块和公共函数的列表。
- en: A list of other items, such as `traits`, `macros`, `structs`, `enums`, and `typedefs`,
    that a public user of the library needs to be familiar with to use various features
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份其他项目的列表，例如`traits`、`macros`、`structs`、`enums`和`typedefs`，公共用户需要熟悉这些内容才能使用各种功能。
- en: For binary crates, installation instructions and command-line parameters.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于二进制crate，安装说明和命令行参数。
- en: Examples that demonstrate to users how to use the crate
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 举例说明用户如何使用crate。
- en: Optionally, design details for the crate
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，crate的设计细节。
- en: 'Now that we know **what** to document, we have to learn **how** to document
    it. There are two ways to document your crate:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了**要记录什么**，我们必须学习**如何记录**。记录你的crate有两种方法：
- en: Inline documentation comments within the crate
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在crate中编写内联文档注释。
- en: Separate markdown files
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离的Markdown文件。
- en: You can use either approach, and the `rustdoc` tool will convert them into `HTML`,
    `CSS`, and `JavaScript` code that can be viewed from a browser.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何一种方法，`rustdoc` 工具会将它们转换为浏览器可以查看的 `HTML`、`CSS` 和 `JavaScript` 代码。
- en: Writing inline documentation comments within crate
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在crate中编写内联文档注释。
- en: 'Rust has two types of comments: **code comments** (aimed at developers) and
    **documentation comments** (aimed at users of the library/crate).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有两种类型的注释：**代码注释**（面向开发者）和**文档注释**（面向库/crate的用户）。
- en: 'Code comments are written using:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注释使用以下方式编写：
- en: '`//` for single-line comments and writing inline documentation comments within
    crate'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `//` 进行单行注释和在crate中编写内联文档注释。
- en: '`/* */` for multi-line comments'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `/* */` 进行多行注释。
- en: 'Documentation comments are written using two styles:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释使用两种风格编写：
- en: The first style is to use three slashes `///` for commenting on individual items
    that follow the comments. Markdown notation can be used to style the comments
    (for example, bold or italic). *This is typically used for item-level documentation.*
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种风格是使用三个斜杠`///`来注释随后的单个项目。Markdown标记可以用于注释的样式（例如，粗体或斜体）。*这通常用于项目级文档*。
- en: The second style is to use `//!`. This is used to add documentation for the
    item that contains these comments (as opposed to the first style, which is used
    to comment items that follow the comments). *This is typically used for crate-level
    documentation.*
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种风格是使用`//!`。这用于为包含这些注释的项目添加文档（与第一种风格相反，第一种风格用于注释随后的项目）。*这通常用于crate级文档*。
- en: In both cases, `rustdoc` extracts documentation from the crate's documentation
    comments.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`rustdoc`都会从crate的文档注释中提取文档。
- en: 'Add the following comments to the `integ-test-example` project, in `src/lib.rs`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在`integ-test-example`项目中的`src/lib.rs`文件中添加以下注释：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run `cargo doc –open` to see the generated HTML documentation corresponding
    to the documentation comments.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cargo doc –open`以查看与文档注释对应的生成的HTML文档。
- en: Writing documentation in markdown files
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Markdown文件中编写文档
- en: 'Create a new folder, `doc`, under the crate root, and add a new file, `itest.md`,
    with the following markdown content:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在crate根目录下创建一个新的文件夹`doc`，并添加一个名为`itest.md`的新文件，包含以下Markdown内容：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This function returns the process ID of the currently running executable:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回当前运行的可执行文件的过程ID：
- en: '[PRE47]rust'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE47]rust'
- en: use integ_test_example;
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: use integ_test_example;
- en: fn get_id() -> i32 {
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: fn get_id() -> i32 {
- en: let my_pid = get_process_id();
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: let my_pid = get_process_id();
- en: 'println!("Process id for current process is: {}", my_pid);'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'println!("当前进程的进程ID为: {}", my_pid);'
- en: '}'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the preceding code example is only representational.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码示例仅用于说明。
- en: 'Unfortunately, cargo does not directly support generating HTML from standalone
    markdown files (at the time of this writing), so we have to use `rustdoc` as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Cargo在编写时并不直接支持从独立的Markdown文件生成HTML（在此写作时），因此我们必须使用`rustdoc`如下：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You will find the generated HTML document `itest.html` in the same folder. View
    it in your browser.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在同一文件夹中找到生成的HTML文档`itest.html`。在浏览器中查看它。
- en: Running documentation tests
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行文档测试
- en: If there are any code examples written as part of the documentation, `rustdoc`
    can execute the code examples as tests.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档中包含任何代码示例，`rustdoc`可以将代码示例作为测试执行。
- en: 'Let''s write a code example for our library. Open `src/lib.rs` and add the
    following code example to existing code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的库编写一个代码示例。打开`src/lib.rs`，并将以下代码示例添加到现有代码中：
- en: '[PRE50]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: /// fn get_id() {
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: /// fn get_id() {
- en: /// let x = integ_test_example::get_process_id();
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: /// let x = integ_test_example::get_process_id();
- en: /// println!("{}",x);
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: /// println!("{}",x);
- en: /// }
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: /// }
- en: /// [PRE51]
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE51]
- en: If you run `cargo test --doc`, it will run this example code and provide the
    status of the execution.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`cargo test --doc`，它将运行此示例代码并提供执行状态。
- en: Alternatively, running `cargo test` will run all the test cases from the `tests`
    directory (except those that are marked as ignored), and then run the documentation
    tests (that is, code samples provided as part of the documentation).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，运行`cargo test`将运行`tests`目录中的所有测试用例（除了标记为忽略的），然后运行文档测试（即作为文档一部分提供的代码示例）。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Understanding the Cargo ecosystem of toolchains is very important to be effective
    as a Rust programmer, and this chapter has provided the foundational knowledge
    that will be used in future chapters.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Cargo生态系统中的工具链对于作为Rust程序员有效非常重要，本章已经提供了将在未来章节中使用的知识基础。
- en: We learned that there are three release channels in Rust – stable, beta, and
    nightly. Stable is recommended for production use, nightly is for experimental
    features, and beta is an interim stage to verify that there isn't any regression
    in Rust language releases before they are marked `stable`. We also learned how
    to use rustup to configure the toolchain to use for the project.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到Rust有三个发布渠道——稳定版、beta版和nightly版。稳定版推荐用于生产使用，nightly版用于实验性功能，beta版是一个中间阶段，用于在它们被标记为`稳定版`之前验证Rust语言发布中是否存在任何回归。我们还学习了如何使用rustup配置项目使用的工具链。
- en: We saw different ways to organize code in Rust projects. We also learned how
    to build executable binaries and shared libraries. We also looked at how to use
    Cargo to specify and manage dependencies.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了在Rust项目中组织代码的不同方式。我们还学习了如何构建可执行二进制文件和共享库。我们还探讨了如何使用Cargo指定和管理依赖项。
- en: We covered how to write unit tests and integration tests for a Rust package
    using Rust's built-in test framework, how to invoke automated tests using cargo,
    and how to control test execution. We learned how to document packages both through
    inline documentation comments and using standalone markdown files.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了如何使用 Rust 的内置测试框架为 Rust 包编写单元测试和集成测试，如何使用 cargo 调用自动化测试，以及如何控制测试执行。我们学习了如何通过内联文档注释和使用独立的
    Markdown 文件来记录包。
- en: In the next chapter, we will take a quick tour of the Rust programming language,
    through a hands-on project.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过一个动手项目快速浏览 Rust 编程语言。
- en: Further reading
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Cargo Book ([https://doc.rust-lang.org/cargo](https://doc.rust-lang.org/cargo))
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cargo 书籍 ([https://doc.rust-lang.org/cargo](https://doc.rust-lang.org/cargo))
- en: The Rust Book ([https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/))
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 书籍 ([https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/))
- en: Rust Forge ([https://forge.rust-lang.org/](https://forge.rust-lang.org/))
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust Forge ([https://forge.rust-lang.org/](https://forge.rust-lang.org/))
- en: The Rustup book ([https://rust-lang.github.io/rustup/index.html](https://rust-lang.github.io/rustup/index.html))
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rustup 书籍 ([https://rust-lang.github.io/rustup/index.html](https://rust-lang.github.io/rustup/index.html))
- en: 'The Rust style guide – the Rust style guide contains conventions, guidelines,
    and best practices to write idiomatic Rust code, and can be found at the following
    link: [https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md](https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 风格指南 – Rust 风格指南包含了编写惯用 Rust 代码的约定、指南和最佳实践，可以在以下链接找到：[https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md](https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md)
