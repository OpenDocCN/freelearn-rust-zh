- en: Working with Futures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与未来一起工作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Providing futures with a CPU pool and waiting for them
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供带有 CPU 池的未来并等待它们
- en: Implementing error handling for futures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为未来实现错误处理
- en: Combining futures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合未来
- en: Using Streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流
- en: Using Sinks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用汇（Sinks）
- en: Using the oneshot channel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单次通道
- en: Returning futures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回未来
- en: Locking resources with BiLocks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 BiLocks 锁定资源
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Futures provide the building blocks for asynchronous computations with zero-cost
    abstraction. Asynchronous communication is useful for handling timeouts, computing
    across thread pools, network responses, and any function that does not immediately
    return a value.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 未来提供了异步计算的零成本抽象构建块。异步通信对于处理超时、跨线程池计算、网络响应以及任何不立即返回值的函数非常有用。
- en: In a synchronous block, the computer would execute each command sequentially
    after waiting for each command to return a value. If you were to apply the synchronous
    model when sending an email, you would send the message, stare at your inbox,
    and wait until you have received a response from your recipient.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步块中，计算机会在等待每个命令返回一个值后，依次执行每个命令。如果您在发送电子邮件时应用同步模型，您将发送消息，盯着您的收件箱，直到收到收件人的回复。
- en: Fortunately, life does not work synchronously. After we send an email, we could
    switch to another application or get off our chair. We can start performing other
    tasks such as getting the groceries, cooking dinner, or reading a book. Our attention
    can focus on, and perform, other tasks simultaneously. Periodically, we will check
    our inbox for a response from our recipient. The process of periodically checking
    for the new message illustrates the asynchronous model. Unlike humans, computers
    can check for a new message in our inbox and perform other tasks at the same time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，生活并不总是同步的。在我们发送电子邮件后，我们可以切换到另一个应用程序或离开椅子。我们可以开始执行其他任务，如购买杂货、做晚饭或读书。我们的注意力可以同时集中在执行其他任务上。定期地，我们会检查收件箱以查看收件人的回复。定期检查新消息的过程说明了异步模型。与人类不同，计算机可以在我们的收件箱中检查新消息，并同时执行其他任务。
- en: Rust’s futures work by implementing the polling model, which utilizes a central
    component (for example, a piece of software, hardware devices, and network hosts)
    to handle status reports from other components. The central, or master, component
    sends signals to other components repetitively until the master component receives
    an update, an interruption signal, or the polling event has timed out.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的未来通过实现轮询模型来工作，该模型利用一个中心组件（例如，软件、硬件设备和网络主机）来处理来自其他组件的状态报告。中心或主组件会重复地向其他组件发送信号，直到主组件收到更新、中断信号或轮询事件超时。
- en: To get a better understanding on how concurrency works within Rust's model,
    you can view Alex Crichton's concurrency presentations at [https://github.com/alexcrichton/talks](https://github.com/alexcrichton/talks). Throughout
    our recipes, we will be using the `futures::executor::block_on` function within
    our main thread to return values. This is intentionally done for demonstrative
    purposes only. In a real application, you would use `block_on` within another
    a separate thread and your functions would return some sort of `futures::Future`
    implementation such as `futures::future::FutureResult`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解 Rust 模型中并发的工作原理，您可以查看 Alex Crichton 的并发演示文稿，链接为 [https://github.com/alexcrichton/talks](https://github.com/alexcrichton/talks)。在我们的食谱中，我们将在主线程中使用
    `futures::executor::block_on` 函数来返回值。这是为了演示目的而故意这样做的。在实际应用中，您将在另一个单独的线程中使用 `block_on`，并且您的函数将返回某种
    `futures::Future` 实现例如 `futures::future::FutureResult`。
- en: At the time of writing, futures is performing a lot of developmental changes
    throughout its code base. You can view futures' RFCs (Request For Comments) on
    their official repository at [https://github.com/rust-lang-nursery/futures-rfcs](https://github.com/rust-lang-nursery/futures-rfcs)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，未来在其代码库中进行了大量的开发性更改。您可以在他们的官方仓库 [https://github.com/rust-lang-nursery/futures-rfcs](https://github.com/rust-lang-nursery/futures-rfcs)
    上查看未来的 RFC（请求评论）。
- en: Providing futures with a CPU pool and waiting for them
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供带有 CPU 池的未来并等待它们
- en: 'Futures are usually assigned to a `Task`, which gets assigned to an `Executor`.
    When a task is *awake,* the executor will place the task into a queue, and will call
    `poll()` on the task until the process has been completed. Futures offer us a
    few convenient ways to execute tasks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 未来通常被分配给一个`Task`，然后被分配给一个`Executor`。当一个任务*唤醒*时，执行器将任务放入队列，并将在任务上调用`poll()`直到进程完成。未来为我们提供了执行任务的一些方便的方法：
- en: Spawn a future task manually with `futures::executor::block_on()`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`futures::executor::block_on()`手动生成未来任务。
- en: Using `futures::executor::LocalPool`, which is useful for performing many small
    tasks on a single thread. In our future returns, we would not be required to implement
    `Send` since we are only involving the task on a single thread. However, you are
    required to use `futures::executor::spawn_local()` on the `Executor` if you omit
    the `Send` trait.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`futures::executor::LocalPool`，这对于在单个线程上执行许多小任务非常有用。在我们的未来返回中，我们不需要实现`Send`，因为我们只在一个线程上涉及任务。然而，如果你省略了`Send`特性，你需要在`Executor`上使用`futures::executor::spawn_local()`。
- en: Using `futures::executor::ThreadPool`, which allows us to offload tasks to other
    threads.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`futures::executor::ThreadPool`，它允许我们将任务卸载到其他线程。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a Rust project to work on during this chapter with `cargo new futures`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new futures`创建一个Rust项目，在本章中工作。
- en: Navigate into the newly-created `futures` folder. For the rest of this chapter,
    we will assume that your command line is within this directory.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`futures`文件夹。在本章的其余部分，我们将假设你的命令行在这个目录内。
- en: Inside the `src` folder, create a new folder called `bin`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹内，创建一个名为`bin`的新文件夹。
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的`lib.rs`文件，因为我们没有创建库。
- en: Open the `Cargo.toml` file that has been generated.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, add the following lines:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`下添加以下行：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `src/bin` folder, create a file called `pool.rs`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`pool.rs`的文件。
- en: 'Add the following code and run it with `cargo run —bin pool`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run —bin pool`运行它：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s add our constants, enums, structures, and trait implementations:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的常量、枚举、结构和特性实现：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s add our first local threaded function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的第一个本地线程函数：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now for our locally-spawned threading examples:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们的本地生成的线程示例：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now for our thread pool example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们的线程池示例：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And lastly, our `main` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`main`函数：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by introducing the `Future` trait:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先介绍一下`Future`特性：
- en: 'Implementing the `Future` trait requires only three constraints: an `Item` 
    type, an `Error` type, and a `poll()` function. The actual trait looks as follows:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Future`特性只需要三个约束：一个`Item`类型，一个`Error`类型，以及一个`poll()`函数。实际的特性看起来如下：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Poll<Self::Item, Self::Error>` is a type that translates into `Result<Async<T>,
    E>` , where `T = Item` and `E = Error`. This is what our example is using on line
    50.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Poll<Self::Item, Self::Error>`是一个类型，它转换为`Result<Async<T>, E>`，其中`T = Item`和`E
    = Error`。这就是我们在第50行使用的示例。'
- en: '`poll()` is called upon whenever a `futures::task::Waker` (can also be known
    as a *Task*) is executed with one of our executors located at `futures::executor`,
    or manually woken up by building a `futures::task::Context` and running with a
    future wrapper such as `futures::future::poll_fn`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用位于`futures::executor`的执行器执行`futures::task::Waker`（也可以称为*Task*）时，或者通过构建`futures::task::Context`并使用未来包装器（如`futures::future::poll_fn`）手动唤醒时，会调用`poll()`。
- en: 'Now, onto our `local_until()` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到我们的`local_until()`函数：
- en: '`LocalPool` offers us the ability to run tasks concurrently using a single
    thread. This is useful for functions with minimal complexity, such as traditional
    I/O bound functions. `LocalPools` can have multiple `LocalExecutors` (as we have
    created one on line 65), which can spawn our task. Since our task is single-threaded,
    we do not need to `Box` or add the `Send` trait to our future.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalPool`为我们提供了使用单个线程并发运行任务的能力。这对于具有最小复杂性的函数非常有用，例如传统的I/O绑定函数。`LocalPools`可以有多个`LocalExecutors`（正如我们在第65行创建的那样），它们可以生成我们的任务。由于我们的任务是单线程的，我们不需要`Box`或添加`Send`特性到我们的未来。'
- en: The `futures::future::lazy` function will create a new future, from a `FnOnce`
    closure, which becomes the same future as the one that the closure returns (any
    `futures::future::IntoFuture` trait), which in our case that future is `FutureResult<Container,
    Never>`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`futures::future::lazy`函数将创建一个新的未来，从一个`FnOnce`闭包，这个闭包返回的将是与闭包返回的相同的未来（任何`futures::future::IntoFuture`特性），在我们的情况下，这个未来是`FutureResult<Container,
    Never>`。'
- en: 'Executing the `run_until(F: Future)` function from the `LocalPool` will perform
    all of the future tasks until the `Future` (indicated as `F`) has been marked
    as completed. This function will return `Result<<F as Future>::Item, <F as Future>::Error>`
    upon completion. In the example, we are returning `futures::future::ok(Container)`,
    on line 75, so our `F::Item` will be our `Container`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '从`LocalPool`执行`run_until(F: Future)`函数将执行所有future任务，直到`Future`（表示为`F`）被标记为完成。该函数在完成时会返回`Result<<F
    as Future>::Item, <F as Future>::Error>`。在示例中，我们在第75行返回`futures::future::ok(Container)`，所以我们的`F::Item`将是我们的`Container`。'
- en: 'For our `local_spawns_completed()` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`local_spawns_completed()`函数：
- en: First, we set up our `futures::channel::oneshot` channel (which is explained
    later, in the *Using the oneshot channel* section).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们设置了我们的`futures::channel::oneshot`通道（稍后将在*使用oneshot通道*部分进行解释）。
- en: We will use the `oneshot` channel's `futures::channel::oneshot::Receiver` as
    the future to run until completion within the `run_until()` function. This allows
    us to demonstrate how polling would work until a signal has been received from
    another thread or task (in our example, this happens on line 102 with the `tx.send(...)`
    command).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用`oneshot`通道的`futures::channel::oneshot::Receiver`作为在`run_until()`函数中运行直到完成的future。这允许我们演示在从另一个线程或任务接收到信号之前（在我们的示例中，这发生在第102行的`tx.send(...)`命令）轮询将如何工作。
- en: The `LocalExecutor`'s `spawn_local()` is a special `spawn` function that gives
    us the capability of executing future functions without implementing the `Send`
    trait.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalExecutor`的`spawn_local()`是一个特殊的`spawn`函数，它赋予我们执行future函数而不需要实现`Send`特质的权限。'
- en: 'Next, our `local_nested()` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的`local_nested()`函数：
- en: We set up our usual `Container` and then declare a reference counter that will
    allow us to keep a value (this would be our `Container`) across multiple executors
    or threads. We do not need to use an atomic reference counter, since we are using
    `spawn_local()`, which performs the future on a green thread (a thread that is
    scheduled by a virtual machine or a runtime library).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设置了我们的常规`Container`，然后声明了一个引用计数器，这将允许我们在多个executors或线程之间保持一个值（这将是我们`Container`）。由于我们使用`spawn_local()`，它在一个绿色线程（由虚拟机或运行时库调度的线程）上执行future，所以我们不需要使用原子引用计数器。
- en: 'The `LocalPool`''s `run(exec: &mut Executor)` function will run any futures
    spawned within the pool until all of the futures have been completed. This also
    includes any executors that may `spawn` additional tasks within other tasks, as
    our example shows.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalPool`的`run(exec: &mut Executor)`函数将运行池中生成的任何future，直到所有future都完成。这也包括可能在其他任务中`spawn`额外任务的任何executors，如我们的示例所示。'
- en: 'Onto our `thread_pool()` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的`thread_pool()`函数：
- en: An `std::sync::mspc::sync_channel` is created with the intention of blocking
    the thread for demonstration purposes.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个`std::sync::mspc::sync_channel`，目的是为了演示阻塞线程。
- en: 'Next, we created a `ThreadPool` with default settings and called its `spawn(F:
    Box<Future<Item = (), Error = Never> + ''static + Send>)` function, which will
    poll the task until completion whenever we decide to execute the pool.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '接下来，我们使用默认设置创建了一个`ThreadPool`，并调用了它的`spawn(F: Box<Future<Item = (), Error =
    Never> + ''static + Send>)`函数，无论何时我们决定执行池，它都会轮询任务直到完成。'
- en: 'After setting up our tasks, we execute the `ThreadPool`''s `run(F: Future)`
    function, which will block the thread in which is invoking `run()` until the `F:
    Future` has been completed. The function will return a value upon the future''s
    completion even if there are other tasks spawned, and running, within the pool. 
    Using the `mspc::sync_channel` earlier helps mitigate this issue, but will block
    the thread upon being invoked.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在设置好我们的任务后，我们执行`ThreadPool`的`run(F: Future)`函数，这将阻塞调用`run()`的线程，直到`F: Future`完成。即使池中还有其他任务被生成和运行，该函数在future完成时也会返回一个值。使用`mspc::sync_channel`之前有助于减轻这个问题，但会在被调用时阻塞线程。'
- en: 'With the `ThreadPoolBuilder` , you can:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ThreadPoolBuilder`，你可以：
- en: Set the number of worker threads
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置工作线程的数量
- en: Adjust the stack size
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整栈大小
- en: Set a prefixed name for the pools
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为池设置一个前缀名称
- en: Run a function (with the signature as `Fn(usize) + Send + Sync + 'static`) after
    each worker thread has started, right before the worker thread runs any tasks
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个工作线程启动后，在运行任何任务之前运行一个函数（函数签名为`Fn(usize) + Send + Sync + 'static`）
- en: Execute a function (with the signature as `Fn(usize) + Send + Sync + 'static`)
    before each worker thread shuts down
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个工作线程关闭之前执行一个函数（函数签名为`Fn(usize) + Send + Sync + 'static`）
- en: Handling errors in futures
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理future中的错误
- en: In a real application, we would not be returning a value instantly from an asynchronous
    function that directly returns `Async::Ready<T>` or `FutureResult<T, E>`. Network
    requests time out, buffers become full, services become unavailable due to bugs
    or outages, and many more issues pop up on a daily basis. As much as we like to
    build order from chaos, usually chaos wins due to naturally-occurring entropy
    (programmers may know this as *scope creep*) and decay (software updates, new
    computer science paradigms, and so on). Luckily for us, the futures library offers
    us a simple way to implement error handling.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们不会从直接返回 `Async::Ready<T>` 或 `FutureResult<T, E>` 的异步函数中立即返回一个值。网络请求超时，缓冲区满，由于错误或中断服务变得不可用，以及许多其他问题每天都在出现。尽管我们喜欢从混乱中建立秩序，但由于自然发生的熵（程序员可能称之为
    *范围蔓延*）和衰减（软件更新、新的计算机科学范式等），通常混乱获胜。幸运的是，futures 库为我们提供了一个简单的方法来实现错误处理。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Inside the `bin` folder, create a new file called `errors.rs`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹内，创建一个名为 `errors.rs` 的新文件。
- en: 'Add the following code and run it with `cargo run --bin errors`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并使用 `cargo run --bin errors` 运行它：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After that, let''s add our structures and implementations:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们添加我们的结构和实现：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After that, let''s add our generic error handling functions/examples:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们添加我们的泛型错误处理函数/示例：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And now for our `panic` functions:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是我们的 `panic` 函数：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And finally, our `main` function:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的 `main` 函数：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start with the `using_recover()` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `using_recover()` 函数开始：
- en: Any errors that have occurred within the future will be transformed into `<Self
    as Future>::Item`. Any `<Self as Future>::Error` type can be passed through, since
    we never produce an actual error.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 future 中发生的任何错误都将被转换成 `<Self as Future>::Item`。任何 `<Self as Future>::Error`
    类型都可以传递，因为我们永远不会产生实际的错误。
- en: 'The `futures::executor::block_on(F: Future)` function will run a future until
    completion within the invoking thread. Any tasks within futures'' `default executor`
    will also run on the invoking thread, but completion on the tasks may never occur
    since `F` may finish before the tasks have been completed. If this is the case,
    then the spawned tasks are dropped. `LocalPool` is often recommended for mitigating
    this issue, but for our examples `block_on()` will be sufficient.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`futures::executor::block_on(F: Future)` 函数将在调用线程中运行一个 future，直到完成。任何在 futures
    的 `default executor` 中的任务也将在这个调用线程上运行，但由于 `F` 可能会在任务完成之前完成，所以任务可能永远不会完成。如果这种情况发生，那么产生的任务将被丢弃。`LocalPool`
    常常被推荐用于缓解这个问题，但对我们来说 `block_on()` 将足够。'
- en: All of these error handling functions can be found within the `futures::FutureExt` trait.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些错误处理函数都可以在 `futures::FutureExt` 特性中找到。
- en: 'Now, onto our `map_error()` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的 `map_error()` 函数：
- en: 'The `<Self as Future>::map_err<E, F>(F: FnOnce(Self::Error) -> E)` function
    will map a future''s (`Self`) error into another error while returning a new future.
    This function is often used in conjunction with combinators, such as select or
    join, since we can guarantee that the futures will have the same error type to
    complete the composition.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Self as Future>::map_err<E, F>(F: FnOnce(Self::Error) -> E)` 函数将 future 的
    (`Self`) 错误映射到另一个错误，同时返回一个新的 future。这个函数通常与组合器（如 select 或 join）一起使用，因为我们可以保证 futures
    将具有相同的错误类型以完成组合。'
- en: 'Next, the `err_into()` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是 `err_into()` 函数：
- en: Transforms the `Self::Error` into another `Error` type using the `std::convert::Into`
    trait
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::convert::Into` 特性将 `Self::Error` 转换为另一种 `Error` 类型
- en: Like `futures::FutureExt::map_err`, this function is useful for aggregating
    combinators together
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `futures::FutureExt::map_err` 类似，这个函数对于组合组合器很有用
- en: 'The `or_else()` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`or_else()` 函数：'
- en: If `<Self as Future>` returns an error, `futures::FutureExt::or_else` will execute
    a closure with the following signature:  `FnOnce(Self::Error) -> futures::future::IntoFuture<Item
    = Self::Item>`
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `<Self as Future>` 返回一个错误，`futures::FutureExt::or_else` 将执行一个具有以下签名的闭包：`FnOnce(Self::Error)
    -> futures::future::IntoFuture<Item = Self::Item>`
- en: Useful for chaining failing combinators together
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于将失败的组合器链接在一起很有用
- en: The closure will not execute if the future has completed successfully, panics,
    or its future is dropped
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 future 成功完成、panic 或其 future 被丢弃，闭包将不会执行
- en: 'Then the `catch_unwind()` function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 `catch_unwind()` 函数：
- en: This function is generally not recommended as a way to handle errors, and is
    only enabled with Rust's `std` option (which is enabled by default)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数通常不推荐作为处理错误的方式，并且仅通过 Rust 的 `std` 选项启用（默认启用）
- en: 'Future traits implement the `AssertUnwindSafe` trait as `AssertUnwindSafe<F:
    Future>` trait'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Future 特性实现了 `AssertUnwindSafe` 特性作为 `AssertUnwindSafe<F: Future>` 特性'
- en: 'And lastly, the `stream_panics()` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`stream_panics()` 函数：
- en: On line 95, this `futures::StreamExt::catch_unwind` function is similar to `futures::FutureExt::catch_unwind`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 95 行，此 `futures::StreamExt::catch_unwind` 函数类似于 `futures::FutureExt::catch_unwind`
- en: If a panic occurs, it will be the last element of the stream for the stream
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生 panic，它将是流中的最后一个元素
- en: This feature is only enabled with Rust's `std` option as well
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此功能仅在 Rust 的 `std` 选项启用时才可用
- en: 'The `AssertUnwindSafe` trait is also implemented for streams as `AssertUnwindSafe<S:
    Stream>`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssertUnwindSafe` 特性也实现了流作为 `AssertUnwindSafe<S: Stream>`'
- en: The combinators for streams are located in the `futures::StreamExt` trait, which
    has the same functions as `futures::FutureExt` with some additional stream-specific
    combinators such as `split()` and `skip_while()` that may prove to be useful for
    your projects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 流的组合器位于 `futures::StreamExt` 特性中，它具有与 `futures::FutureExt` 相同的函数，还有一些额外的流特定组合器，如
    `split()` 和 `skip_while()`，这些可能对您的项目很有用。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml), *Handling Errors*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 6 章](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml)，*处理错误*'
- en: Combining futures
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合 futures
- en: Combining, and chaining, our futures allows us to perform multiple operations
    in sequential order and helps organize our code a bit more. They can be used to
    transform, splice, filter, and so on `<Self as Future>::Item`s.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结合和链式调用我们的 futures 允许我们按顺序执行多个操作，并有助于更好地组织我们的代码。它们可以用来转换、拼接、过滤等 `<Self as Future>::Item`s。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Inside the `bin` folder, create a new file called `combinators.rs`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `combinators.rs` 的新文件。
- en: 'Add the following code and run it with `cargo run --bin combinators`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin combinators` 运行它：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s add our `join_all` example function:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加我们的 `join_all` 示例函数：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we will write out our `shared` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写我们的 `shared` 函数：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And now for our `select_all` example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下我们的 `select_all` 示例：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can add our `flatten`, `fuse`, and `inspect` functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加我们的 `flatten`、`fuse` 和 `inspect` 函数：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we can add our `chaining` example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以添加我们的 `chaining` 示例：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And now for our `main` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下 `main` 函数：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `join_all()` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`join_all()` 函数：'
- en: 'Collects results from several futures and returns a new future with the `futures::future::JoinAll<F:
    Future>` trait'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '从几个 futures 收集结果并返回一个新的具有 `futures::future::JoinAll<F: Future>` 特性的 future'
- en: 'The new future will perform commands for all of the aggregated futures within
    the `futures::future::join_all` call, returning a vector of `Vec<T: Future::Item>`
    in FIFO ordering'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '新的 future 将在 `futures::future::join_all` 调用中执行所有聚合 future 的命令，以 FIFO 顺序返回一个
    `Vec<T: Future::Item>` 向量'
- en: An error will return itself immediately and cancel the other related futures
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个错误将立即返回并取消其他相关 future
- en: 'And the `shared()` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 `shared()` 函数：
- en: '`futures::FutureExt::shared` will create a handle that can be cloned, which
    resolves to the returning value of `<T as futures::future::SharedItem>` which
    can be deferred into `T`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`futures::FutureExt::shared` 将创建一个可以克隆的句柄，它解析为 `<T as futures::future::SharedItem>`
    的返回值，它可以延迟到 `T`。'
- en: Useful for polling a future on more than one thread
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于在多个线程上轮询 future
- en: This method is enabled only when Rust's `std` option is enabled (which it is
    by default)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法仅在 Rust 的 `std` 选项启用时才可用（默认情况下是启用的）
- en: The underlying result is `futures::future::Shared<Future::Item>`, which implements
    `Send` and `Sync` traits
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础结果是 `futures::future::Shared<Future::Item>`，它实现了 `Send` 和 `Sync` 特性
- en: Using `futures::future::Shared::peek(&self)` will return a value without blocking
    if any single shared handle has been completed
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `futures::future::Shared::peek(&self)` 如果任何单个共享句柄已经完成，将返回一个值而不阻塞
- en: 'Next, the `select_all_example()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`select_all_example()` 函数：
- en: '`futures::FutureExt::select_all` returns a new future that selects from a list
    of vectors'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`futures::FutureExt::select_all` 返回一个新的 future，它从一系列向量中选择'
- en: The return value is `futures::future::SelectAll`, which allows us to iterate
    through the results
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值是 `futures::future::SelectAll`，它允许我们遍历结果
- en: The future's item, index of execution, and a list of futures that still need
    to be processed will be returned by this function as soon as one of the futures
    completes its execution
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦某个 future 完成其执行，此函数将返回 future 的项目、执行索引以及还需要处理的 future 列表
- en: 'Then the `flatten()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 `flatten()` 函数：
- en: '`futures::FutureExt::flatten` will combine futures together with a returning
    result of their items being flattened'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`futures::FutureExt::flatten` 将将未来组合在一起，其返回的结果是它们的项被展平'
- en: The resultant item must implement the `futures::future::IntoFuture` trait
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果项必须实现 `futures::future::IntoFuture` 特性
- en: 'Onto the `fuse()` function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `fuse()` 函数：
- en: There is a small chance of `undefined behavior`, such as panicking or blocking
    forever, when polling a future that has already returned a `futures::Async::Ready`
    or `Err` value. The `futures::FutureExt::fuse` function allows us to `poll` the
    future again without worrying about `undefined behavior`, and will always return
    `futures::Async::Pending`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当轮询已经返回 `futures::Async::Ready` 或 `Err` 值的未来时，存在 `undefined behavior` 的小概率，例如恐慌或永远阻塞。`futures::FutureExt::fuse`
    函数允许我们再次 `poll` 未来，而不用担心 `undefined behavior`，并且总是返回 `futures::Async::Pending`。
- en: The future that's being fused will be dropped upon completion in order to reclaim
    resources.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被融合的未来在完成时将被丢弃，以回收资源。
- en: 'The `inspect()` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect()` 函数：'
- en: '`futures::FutureExt::inspect` allows us to peek at an item of a future which
    is useful for when we are chaining combinators.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`futures::FutureExt::inspect` 允许我们窥视未来的一个项，这在我们在链式组合器时非常有用。'
- en: 'And then the `chaining()` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 `chaining()` 函数：
- en: We first create a channel with three values, and `spawn` a thread to send those
    three values to the channel's receiver using the `futures::FutureExt::and_then`
    combinator.  We collect the results on line 130 from the channel.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含三个值的通道，并使用 `futures::FutureExt::and_then` 组合器 `spawn` 一个线程将这三个值发送到通道的接收者。我们在第130行从通道中收集结果。
- en: Then we chain two streams together on line 134 and 135 with the collection occurring
    on line 140\. The result of both streams should be chained together on lines 137
    and 138.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们在第134行和第135行将两个流链在一起，在第140行发生收集。两个流的结果应该在第137行和第138行链在一起。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using a vector* and *Access collections as iterators* recipes in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), **Working with Collections**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用向量* 和 *将集合作为迭代器访问* 的配方在 [第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，**处理集合**'
- en: Using Streams
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流
- en: A stream is a pipeline for events that returns a value asynchronously to the
    invoker. `Streams` are more useful for items that require the `Iterator` trait,
    while `Futures` are more apt for `Result` values. When an error occurs throughout
    a stream, the error will not halt the stream, and polling on the stream will still
    return other results until the `None` value has been returned.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 流是一个事件管道，它异步地向调用者返回一个值。`Streams` 对于需要 `Iterator` 特性的项更有用，而 `Futures` 对于 `Result`
    值更合适。当流中发生错误时，错误不会停止流，并且对流的轮询仍然会返回其他结果，直到返回 `None` 值。
- en: '`Streams` and `Channels` can be a bit confusing for some.  `Streams` are used
    for continuous, buffered data, and `Channels` are more suited for completed messages
    between endpoints.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Streams` 和 `Channels` 对于一些人来说可能有点令人困惑。`Streams` 用于连续、缓冲的数据，而 `Channels` 更适合端点之间的完成消息。'
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Inside the `bin` folder, create a new file called `streams.rs`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `streams.rs` 的新文件。
- en: 'Add the following code and run it with `cargo run --bin streams`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin streams` 运行它：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s add our constants, implementations, and so on:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加我们的常量、实现等：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our `quick_streams` example would be:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `quick_streams` 示例将是：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are several ways to iterate through streams; let''s add them to our code
    base:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几种方法可以遍历流；让我们将它们添加到我们的代码库中：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now for our channeling example:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来看我们的通道示例：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Dealing with errors and channels can be done as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理错误和通道可以这样做：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can even work with buffers and channels together. Let''s add our `channel_buffer`
    function:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以一起处理缓冲区和通道。让我们添加我们的 `channel_buffer` 函数：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just because we''re using the futures crate doesn''t mean everything has to
    be concurrent. Add the following example to demonstrate how to block with channels:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们正在使用 futures crate，但这并不意味着一切都必须是并发的。添加以下示例以演示如何使用通道进行阻塞：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Sometimes we''ll need concepts such as unbounded channels; let''s add our `channel_unbounded`
    function:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候我们需要像无界通道这样的概念；让我们添加我们的 `channel_unbounded` 函数：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And now we can add our `main` function:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加我们的 `main` 函数：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, let''s talk about the `QuickStream` structure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈 `QuickStream` 结构：
- en: The `poll_next()` function will continuously be invoked, and with each iteration,
    `i`'s ticks attribute will be decremented by `1`
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll_next()`函数将不断被调用，并且随着每次迭代的进行，`i`的ticks属性将递减`1`。'
- en: Polling will stop when the ticks attribute reaches `0` and returns `futures::Async::Ready<None>`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当ticks属性达到`0`时，轮询将停止，并返回`futures::Async::Ready<None>`。
- en: 'Within the `quick_streams()` function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quick_streams()`函数内部：
- en: 'We build a `futures::task::Context` by using `futures::future::poll_on(f: FnMut(|cx:
    Context|))`, so that we can explicitly invoke `QuickStream`''s `poll_next()` function
    on lines 42 and 50'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们通过使用`futures::future::poll_on(f: FnMut(|cx: Context|))`构建一个`futures::task::Context`，这样我们就可以在42和50行显式调用`QuickStream`的`poll_next()`函数。'
- en: Since we have declared `10` ticks on line 38, our first two `block_on`'s `poll_next()`
    calls should yield `9` and `8`
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们在38行声明了`10`个ticks，我们的前两个`block_on`的`poll_next()`调用应该产生`9`和`8`。
- en: The next `block_on` call, on line 57, will keep polling `QuickStream` until
    `futures::Async::Ready<None>` is returned from the ticks attribute equaling zero
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个`block_on`调用，在57行，将不断轮询`QuickStream`，直到ticks属性等于零时返回`futures::Async::Ready<None>`。
- en: 'Within `iterate_streams()`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`iterate_streams()`内部：
- en: '`futures::stream::iter_ok` will convert an `Iterator` into a `Stream`, which
    will always be ready to return the next value'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`futures::stream::iter_ok`将一个`Iterator`转换为一个`Stream`，它将始终准备好返回下一个值。'
- en: '`futures::stream::iter_result` does the same thing as `iter_ok`, except we
    use `Result` values instead of `Ok` values'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`futures::stream::iter_result`与`iter_ok`做同样的事情，只是我们使用`Result`值而不是`Ok`值。'
- en: On lines 78 through 89, we iterate through the stream's results and print out
    some information depending on whether the value was `Ok` or an `Error` type. If
    the `None` type has been returned from our stream, then we will break the loop
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在78到89行，我们遍历流的输出并打印出一些信息，这取决于值是`Ok`还是`Error`类型。如果我们的流返回了`None`类型，那么我们将退出循环。
- en: Lines 92 through 95 show an alternative way of iterating through a stream's
    `Ok` results by using the `into_iter()` calls
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 92到95行显示了使用`into_iter()`调用迭代流`Ok`结果的另一种方法。
- en: Lines 97 through 99 show an alternative way of iterating through a stream's
    `Result` return types
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 97到99行显示了迭代流`Result`返回类型的另一种方法。
- en: Loops, iterated results, and `collect()` calls are synchronous. We used this
    functions for demonstrative/educational purposes only. Combinators such as `map()`,
    `filter()`, `and_then()`, etc. would be used in a real application for streams
    and channels.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 循环、迭代结果和`collect()`调用是同步的。我们只使用这些函数进行演示/教育目的。在实际应用中，将使用如`map()`、`filter()`、`and_then()`等组合子。
- en: 'The `channel_threads()` function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`channel_threads()`函数：'
- en: On line 107, we define the maximum number of sends we want to attempt.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在107行，我们定义了我们想要尝试的最大发送次数。
- en: On line 108, we declare a channel to send messages to. Channel capacity is the
    `buffer size (the argument of futures::channel::mpsc::channel) + the number of
    senders` (each sender is guaranteed a slot within the channel). Channels will
    return a `futures::channel::mpsc::Receiver<T>`, which implements the `Stream`
    trait, and a `futures::channel::mpsc::Sender<T>`, which implements the `Sink`
    trait.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在108行，我们声明了一个通道以发送消息。通道容量是`buffer size（futures::channel::mpsc::channel的参数）+
    发送者数量`（每个发送者都保证在通道中有一个槽位）。通道将返回一个`futures::channel::mpsc::Receiver<T>`，它实现了`Stream`特质，以及一个`futures::channel::mpsc::Sender<T>`，它实现了`Sink`特质。
- en: Lines 110 through 120 is where we `spawn` a thread and attempt to send 10 signals,
    looping until each send is sent successfully.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 110到120行是我们`spawn`一个线程并尝试发送10个信号的地方，循环直到每个发送都成功发送。
- en: We collect, and display, our results on line 122 through 125, and join our threads
    on line 127.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在122到125行收集并显示我们的结果，并在127行合并我们的线程。
- en: 'The `channel_error()` section:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`channel_error()`部分：'
- en: On line 131, we declare our channel with a `0 usize` buffer as the argument,
    which gives us one slot for the initial sender
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在131行，我们使用`0 usize`缓冲区作为参数声明我们的通道，这给我们提供了一个初始发送者的槽位。
- en: We send the first message successfully on line 133
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在133行成功发送了第一条消息。
- en: Lines 136 through 139 should fail, since we are trying to send a message to
    a channel that is considered full (since we did not receive the value, drop the
    initial sender, flush the stream, and so on)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 136到139行应该失败，因为我们正在尝试向一个被认为是满的通道发送消息（因为我们没有收到值，删除初始发送者，刷新流等）。
- en: 'On line 146, we use the sender''s `futures::channel::mpsc::Sender::try_send(&mut
    self, msg: T)` functions, which won''t block our thread unless we don''t drop/invoke
    the sender''s destroyer method using `drop(T)` on line 147'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在第146行，我们使用发送者的`futures::channel::mpsc::Sender::try_send(&mut self, msg: T)`函数，除非我们不使用第147行的`drop(T)`调用发送者的销毁方法，否则它不会阻塞我们的线程。'
- en: Polling the stream any additional times after receiving the last value will
    always return `None`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接收到最后一个值之后，对流的任何额外轮询都将始终返回`None`。
- en: 'Next, the `channel_buffer()` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`channel_buffer()`函数：
- en: We set up a future closure with `poll_fn()` on line 162.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在第162行使用`poll_fn()`设置了一个future闭包。
- en: 'We check to see if our sender is ready to be polled with its `futures::sink::poll_ready(&mut
    self, cx: &mut futures::task::Context)` method on lines 163 through 165.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们在第163行到第165行使用其`futures::sink::poll_ready(&mut self, cx: &mut futures::task::Context)`方法检查我们的发送者是否准备好被轮询。'
- en: 'Sinks have a method called `futures::sink::start_send(&mut self, item: <Self
    as Sink>::SinkItem) -> Result<(), <Self as Sink>::SinkError>`, which prepares
    the message to be delivered, but won''t until we flush or close the sink. `poll_flush()`
    is often used to guarantee that every message has been sent from the sink.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '接收器有一个名为`futures::sink::start_send(&mut self, item: <Self as Sink>::SinkItem)
    -> Result<(), <Self as Sink>::SinkError>`的方法，它准备要发送的消息，但不会发送，直到我们刷新或关闭接收器。`poll_flush()`通常用于确保从接收器发送了每条消息。'
- en: 'Polling the stream for the next value will also alleviate space within the
    sink/sender using the `futures::stream::poll_next(&mut self, cx: &mut futures::task::Context)`
    method, as we have done on line 179.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用`futures::stream::poll_next(&mut self, cx: &mut futures::task::Context)`方法轮询流以获取下一个值，也将减轻接收器/发送者中的空间，就像我们在第179行所做的那样。'
- en: We can check if our sender is ready, as we have done on line 182 using the `futures::Async::is_ready(&self)
    -> bool` method.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以检查我们的发送者是否准备好，就像我们在第182行使用`futures::Async::is_ready(&self) -> bool`方法所做的那样。
- en: Our final value should be `22` and displayed to the console from line 192.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终的值应该是`22`，并从第192行显示到控制台。
- en: 'Then the `channel_threads_blocking()` function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`channel_threads_blocking()`函数：
- en: First, we set up our channels on lines 201 and 202.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们在第201行和第202行设置了我们的通道。
- en: Then we `spawn` a thread that will map all of `tx_2`'s errors into a `panic!`
    (line 205), and then we send the value of `10` to our first channel while joining
    a second sender with the `()` value (line 206). On line 208, we send the value
    of `30` and another empty value `()` to our second channel.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们`spawn`了一个线程，该线程将`tx_2`的所有错误映射到`panic!`（第205行），然后我们向第一个通道发送`10`的值，同时将第二个发送者与`()`值连接起来（第206行）。在第208行，我们向第二个通道发送`30`的值和另一个空值`()`。
- en: On line 211 we poll the second channel, which would hold a value of `()`.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第211行我们轮询第二个通道，它将包含一个值为`()`的值。
- en: On line 212 we poll the first channel, which would hold a value of `10`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第212行我们轮询第一个通道，它将包含一个值为`10`的值。
- en: We drop the second channel's receiver (line 215), since we need to close or
    flush for the second `tx_2.send()` call on line 208 (`tx_2` is known as variable
    `b` on this line).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在第215行丢弃了第二个通道的接收者，因为我们需要在第208行的`tx_2.send()`调用上关闭或刷新（`tx_2`在这一行被称为变量`b`）。
- en: After performing the drop, we can finally return our second value from the first
    channel's sender, which should be `30`.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行丢弃操作后，我们最终可以从第一个通道的发送者返回第二个值，这应该是`30`。
- en: 'And the `channel_unbounded()` function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`channel_unbounded()`函数：
- en: On line 225 we declare an `unbounded channel`, which means that sending messages
    to this channel will always succeed as long as the receiver is not closed. Messages
    will be buffered on an as-needed basis, and since this channel is unbounded, our
    application can exhaust our available memory.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第225行我们声明了一个`unbounded channel`，这意味着只要接收者没有关闭，向这个通道发送消息总是会成功。消息将根据需要缓冲，由于这个通道是无界的，因此我们的应用程序可能会耗尽我们的可用内存。
- en: Lines 227 through 232 `spawn` a thread that collects all of the receiver's messages
    (line 228), and we iterate through them on line 229\. The item on line 230 is
    a tuple of the index in which the message was received and the message's value
    (in our case, this is always 1).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从第227行到第232行，`spawn`了一个线程来收集接收者的所有消息（第228行），我们在第229行遍历它们。第230行的项目是一个元组，包含接收消息的索引和消息的值（在我们的例子中，这始终是1）。
- en: Lines 237 through 241 is what will `spawn` the number of threads (using the
    `MAX_THREADS` constant) as well as the number of times that we want to send per
    thread using the `MAX_THREADS` constant.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从第237行到第241行将`spawn`出线程的数量（使用`MAX_THREADS`常量）以及我们想要每个线程发送的次数（使用`MAX_THREADS`常量）。
- en: Lines 244 we will drop (which closes) the channel's sender so that we may collect
    all of the messages from line 228.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 244 行我们将丢弃（关闭）通道的发送者，以便我们可以收集第 228 行的所有消息。
- en: We join the spawned thread with our current thread on line 246, which will execute
    the collection and iterations commands (lines 228 through 231).
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 246 行，我们将生成的线程与当前线程连接，这将执行收集和迭代命令（第 228 行至第 231 行）。
- en: Using Sinks
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sinks
- en: Sinks are the *sending-side* of channels, sockets, pipes, and so on, in which
    messages can be sent from the sink asynchronously. Sinks communicate by initiating
    a send signal, and then the rest is polled. One thing to watch out for when using
    sinks is that they can run out of sending space, which will prevent more messages
    from being sent.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 输出端是通道、套接字、管道等 *发送端*，其中可以异步发送消息。输出端通过启动发送信号进行通信，然后进行轮询。在使用输出端时需要注意的一点是，它们可能会耗尽发送空间，这将阻止发送更多消息。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Inside the `bin` folder, create a new file called `sinks.rs`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `sinks.rs` 的新文件。
- en: 'Add the following code and run it with `cargo run --bin sinks`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并使用 `cargo run --bin sinks` 运行它：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s add our examples with using vectors as `sinks`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加使用向量作为 `sinks` 的示例：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can map/transform our `sinks` values. Let''s add our `mapping_sinks` example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以映射/转换我们的 `sinks` 值。让我们添加我们的 `mapping_sinks` 示例：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can even send messages to multiple `sinks`. Let''s add our `fanout` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以向多个 `sinks` 发送消息。让我们添加我们的 `fanout` 函数：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we''ll want to implement a structure for a customized sink. Sometimes
    our application will require us to manually flush our `sinks` instead of doing
    it automatically. Let''s add our `ManualSink` structure:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将想要实现一个自定义输出端的结构。有时我们的应用程序将需要我们手动刷新 `sinks` 而不是自动执行。让我们添加我们的 `ManualSink`
    结构：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And now for our `manual flush` function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们的 `manual flush` 函数：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And lastly, we can add our `main` function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加我们的 `main` 函数：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, let''s take a look at the `futures::Sink` trait itself:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `futures::Sink` 特性本身：
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We are already familiar with the `Item` and `Error` concepts from futures and
    streams, so we will move on to the required functions:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了来自 futures 和 streams 的 `Item` 和 `Error` 概念，因此我们将继续到所需的函数：
- en: '`poll_ready` must be invoked with the returning value of `Ok(futures::Async::Ready(()))`
    before each attempt at using `start_send`. If the sink receives an error, the
    sink will no longer be able to receive items.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次尝试使用 `start_send` 之前，必须使用返回值 `Ok(futures::Async::Ready(()))` 调用 `poll_ready`。如果输出端收到错误，输出端将无法再接收项。
- en: '`start_send`, as stated previously, prepares the message to be delivered, but
    won''t until we flush or close the sink. If the sink uses buffers, the `Sink::SinkItem`
    won''t be processed until the buffer has been fully completed.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，`start_send` 准备要发送的消息，但只有在刷新或关闭输出端之前，它才会发送。如果输出端使用缓冲区，则 `Sink::SinkItem`
    不会在缓冲区完全完成后被处理。
- en: '`poll_flush` will flush the sink, which will allow us to collect items that
    are currently being processed. `futures::Async::Ready` will return if the sink
    does not have any more items within the buffer, otherwise, the sink will return
    `futures::Async::Pending`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll_flush` 将刷新输出端，这将允许我们收集正在处理的项。如果输出端在缓冲区中没有更多项，则将返回 `futures::Async::Ready`，否则输出端将返回
    `futures::Async::Pending`。'
- en: '`poll_close` will flush and close the sink, following the same return rules
    as `poll_flush`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll_close` 将刷新并关闭输出端，遵循与 `poll_flush` 相同的返回规则。'
- en: 'Now, onto our `vector_sinks()` function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的 `vector_sinks()` 函数：
- en: Sinks are implemented for `Vec<T>` types, so we can declare a mutable vector
    and use the `start_send()` function, which will immediately poll our values into
    the vector on lines 13 through 15.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出端是为 `Vec<T>` 类型实现的，因此我们可以声明一个可变向量并使用 `start_send()` 函数，该函数将立即将我们的值轮询到第 13
    行至第 15 行的向量中。
- en: 'On line 28 we use the `futures::SinkExt::send(self, item: Self::SinkItem)`,
    which will complete after the item has been processed and flushed through the
    sink. `futures::SinkExt::send_all` is recommended for batching multiple items
    to send through, versus having to manually flush between each send call (as demonstrated
    on line 43).'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在第 28 行，我们使用 `futures::SinkExt::send(self, item: Self::SinkItem)`，这将完成在项被处理并通过输出端刷新后。建议使用
    `futures::SinkExt::send_all` 来批量发送多个项，而不是在每次发送调用之间手动刷新（如第 43 行所示）。'
- en: 'Our `mapping_sinks()` function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `mapping_sinks()` 函数：
- en: Line 51 demonstrates how you can map/manipulate elements within a sink using
    the `futures::SinkExt::with` function. This function produces a new sink that
    iterates through each item and sends the final value *as a future* to the *parent* sink.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 51 行展示了如何使用 `futures::SinkExt::with` 函数在接收器内映射/操作元素。这个函数产生一个新的接收器，它遍历每个项目，并将最终值
    *作为一个 future* 发送到 *父* 接收器。
- en: Line 60 illustrates the `futures::SinkExt::flat_with_map` function that has
    mostly the same functionality as the `futures::SinkExt::with` function except
    each iterated item is sent as a stream value to the *parent* sink and will return
    an `Iterator::flat_map` value instead of a `Iterator::map`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 60 行说明了 `futures::SinkExt::flat_with_map` 函数，它基本上与 `futures::SinkExt::with`
    函数具有相同的功能，除了每个迭代的项被作为流值发送到 *父* 接收器，并且将返回一个 `Iterator::flat_map` 值而不是 `Iterator::map`。
- en: 'Next, the `fanout()` function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `fanout()` 函数：
- en: The `futures::SinkExt::fanout` function allows us to send messages to multiple
    sinks at one time, as we have done on line 72.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`futures::SinkExt::fanout` 函数允许我们一次向多个接收器发送消息，就像我们在第 72 行所做的那样。'
- en: 'And then `manual_flush()`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行 `manual_flush()`：
- en: We first implement our own `Sink` trait with the `ManualSink<T>` construct (lines
    81 through 135). Our `ManualSink`'s `poll_flush` method will only return `Async::Ready()`
    if our data vector is empty, otherwise, we are going to push the task (`futures::task::Waker`)
    into a queue line through the `waiting_tasks` attribute. We use the `waiting_tasks`
    attribute within our `force_flush()` function (line 128) in order to manually
    *wake up* our tasks (line 130).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先使用 `ManualSink<T>` 构造函数实现我们自己的 `Sink` 特性（第 81 到 135 行）。我们的 `ManualSink`
    的 `poll_flush` 方法只有在我们的数据向量为空时才会返回 `Async::Ready()`，否则，我们将任务（`futures::task::Waker`）推入通过
    `waiting_tasks` 属性的队列中。我们在 `force_flush()` 函数（第 128 行）中使用 `waiting_tasks` 属性来手动
    *唤醒* 我们的任务（第 130 行）。
- en: On lines 138 through 140, we build our `ManualSink<Option<i32>>` and start sending
    some values.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 138 到 140 行，我们构建了我们的 `ManualSink<Option<i32>>` 并开始发送一些值。
- en: We use `poll_fn` on line 142 in order to quickly build a `futures::task::Context`
    so that we may pass this value down to our underlying poll calls.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在第 142 行使用 `poll_fn` 来快速构建一个 `futures::task::Context`，以便我们可以将此值传递给底层的轮询调用。
- en: On line 144 we manually call our `poll_flush()` function, which will not execute
    our actual tasks since they are placed within the `waiting_tasks` attribute.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 144 行，我们手动调用我们的 `poll_flush()` 函数，由于任务被放置在 `waiting_tasks` 属性中，所以它不会执行实际的任务。
- en: Until we invoke `force_flush()`, our sink will not return any values (as indicated
    on lines 150-151). Once this function has been called upon and the underlying
    `Waker` tasks have finished executing, then we can see the messages (line 152)
    that we sent earlier (lines 139 and 140).
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直到我们调用 `force_flush()`，我们的接收器将不会返回任何值（如第 150-151 行所示）。一旦这个函数被调用，并且底层的 `Waker`
    任务执行完毕，我们就可以看到我们之前发送的消息（第 152 行，第 139 和 140 行）。
- en: Using the oneshot channel
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单次发送通道
- en: Oneshot channels are useful for when you need to send only one message to a
    channel. The oneshot channel is applicable for tasks that really only need to
    be updated/notified once, such as whether or not a recipient has read your message,
    or as a final destination within a task pipeline to notify the end user that the
    task has been completed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 单次发送通道在你只需要向通道发送一条消息时很有用。单次发送通道适用于那些实际上只需要更新/通知一次的任务，例如，接收者是否阅读了你的消息，或者作为任务管道中的最终目的地，通知最终用户任务已完成。
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Inside the `bin` folder, create a new file called `oneshot.rs`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹内，创建一个名为 `oneshot.rs` 的新文件。
- en: 'Add the following code and run it with `cargo run --bin oneshot`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并使用 `cargo run --bin oneshot` 运行它：
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Within our `send_example()` function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `send_example()` 函数中：
- en: On lines 13 through 15, we set up three `oneshot` channels.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 13 到 15 行，我们设置了三个 `oneshot` 通道。
- en: On lines 20 through 23 we use `futures::stream::futures_ordered`, which will
    convert a list (any `IntoIterator` value) of futures into a `Stream` yielding
    results on a first in, first out (FIFO) basis. If any underlying futures do not
    complete before the next future is invoked, this function will wait until the
    long-running future has been completed and will then internally re-sort that future
    into its proper order.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 20 到 23 行，我们使用 `futures::stream::futures_ordered`，它将 future 的列表（任何 `IntoIterator`
    值）转换为在先进先出（FIFO）基础上产生结果的 `Stream`。如果任何底层 future 在下一个 future 被调用之前没有完成，这个函数将等待直到长时间运行的
    future 完成，然后将其内部重新排序到正确的顺序。
- en: Line 25 shows us that we can push additional futures into the `futures_ordered`
    iterator separately.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 25 行显示我们可以将额外的 futures 推入 `futures_ordered` 迭代器中。
- en: Line 28 demonstrates another function that doesn't rely on sorting on a FIFO
    basis, called `futures::stream::futures_unordered`. This function will have better
    performance than its counterpart `futures_ordered`, but for our example, we are
    not sending enough values to make a difference.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 28 行演示了另一个不依赖于基于 FIFO 排序的排序函数，称为 `futures::stream::futures_unordered`。这个函数的性能将优于其对应物
    `futures_ordered`，但对我们这个示例来说，我们发送的值不足以产生差异。
- en: On lines 31 through 33 we send values to our channels, mimicking the process
    of returning values from an API, a database, and so on. If the send is successful
    then `Ok(())` will be returned, otherwise, an `Err` type will be returned.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 31 到 33 行，我们向我们的通道发送值，模拟从 API、数据库等返回值的过程。如果发送成功，则返回 `Ok(())`，否则返回 `Err` 类型。
- en: And on our last two lines (35 and 36), we collect our `futures_ordered` values
    and display them to the console.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们最后两行（35 和 36）中，我们收集 `futures_ordered` 的值并将它们显示到控制台。
- en: 'Next, the `check_if_closed()` function:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是 `check_if_closed()` 函数：
- en: Our channel should remain open until we explicitly drop/destroy the receiver
    (or send a value to the channel). We can check the status of our receiver by invoking
    the `futures::channel::oneshot::Sender::is_canceled(&self) -> bool` function,
    which we have done on lines 42 and 45.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的通道应该保持打开状态，直到我们显式地丢弃/销毁接收器（或向通道发送一个值）。我们可以通过调用 `futures::channel::oneshot::Sender::is_canceled(&self)
    -> bool` 函数来检查我们接收器的状态，我们在第 42 和 45 行已经这样做过了。
- en: 'Then the `check_if_ready()` function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 `check_if_ready()` 函数：
- en: On line 50 we explicitly assign a value to the oneshot's receiver, which would
    put our receiver in a state of pending (since it already has a value).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 50 行，我们显式地为一个 oneshot 的接收器分配一个值，这将使我们的接收器处于挂起状态（因为它已经有一个值了）。
- en: We drop our receiver on line 55 and we can check if our receiver is ready by
    using our sender's `futures::channel::oneshot::Sender::poll_cancel` function,
    which we use on lines 57 and 58\. `poll_cancel` will return `Ok(Async::Ready)`
    if the receiver has been dropped or `Ok(Async::Pending)` if the receiver has not
    been dropped.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在第 55 行丢弃了我们的接收器，我们可以通过使用我们的发送器的 `futures::channel::oneshot::Sender::poll_cancel`
    函数来检查我们的接收器是否就绪，我们在第 57 和 58 行使用它。`poll_cancel` 将在接收器被丢弃时返回 `Ok(Async::Ready)`，如果接收器没有被丢弃，则返回
    `Ok(Async::Pending)`。
- en: Returning futures
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回 futures
- en: 'The `Future` trait relies on three main ingredients: a type, an error, and
    a `poll()` function that returns a `Result<Async<T>, E>` structure. The `poll()`
    method will never block the main thread, and `Async<T>` is an enumerator with
    two variants: `Ready(T)` and `Pending`. Periodically, the `poll()` method will
    be invoked by a task’s context''s `waker()` trait, located in `futures::task::context::waker`,
    until a value is ready to be returned.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 特性依赖于三个主要成分：一个类型、一个错误和一个返回 `Result<Async<T>, E>` 结构的 `poll()` 函数。`poll()`
    方法永远不会阻塞主线程，而 `Async<T>` 是一个具有两个变体的枚举器：`Ready(T)` 和 `Pending`。定期地，`poll()` 方法将由任务上下文的
    `waker()` 特性调用，位于 `futures::task::context::waker` 中，直到有值可以返回。'
- en: How to do it...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the `src/bin` folder, create a file called `returning.rs`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中，创建一个名为 `returning.rs` 的文件。
- en: 'Add the following code and run it with `cargo run —bin returning`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并使用 `cargo run —bin returning` 运行它：
- en: '[PRE39]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now comes the implementations for the structs:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是结构体的实现：
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we''ll want to add our `helper` functions and our `Async` function for
    adding points to our players:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加我们的 `helper` 函数和用于给玩家添加分数的 `Async` 函数：
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And finally, the actual usage:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实际的用法：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by introducing the structures that participate in this example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先介绍参与这个示例的结构：
- en: '`PlayerStatus` is an enumerator for maintaining a *global* state on the player''s
    instance. The variants are:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerStatus` 是一个枚举器，用于在玩家的实例上维护一个 *全局* 状态。变体有：'
- en: '`Loading`, which is the initial state'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “加载”，这是初始状态
- en: '`Default`, which is applied after we are done loading the player''s stats'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “默认”，在我们完成加载玩家的统计数据后应用
- en: '`Jumping` is a special state that won''t allow us to add points to the player''s
    scoreboard due to the rules of the game'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “跳跃”是一种特殊状态，由于游戏规则，它不会允许我们向玩家的计分板上添加分数
- en: '`Player` holds our player''s main attributes, along with a special attribute
    called ticks that stores the amount of cycles that we want to run through with
    `poll()` before assigning the player''s status from `Loading` to `Default`.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player` 包含玩家主要属性，以及一个名为 `ticks` 的特殊属性，它存储了我们想要在将玩家的状态从 `Loading` 转换为 `Default`
    之前通过 `poll()` 运行的周期数。'
- en: 'Now, onto our implementations:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们的实现：
- en: 'Jumping down to the `fn set_status(&mut self, status: PlayerStatus) -> FutureResult<&mut
    Self, Never>` function on our `Player` structure, we will notice a return value
    of `FutureResult`, which tells futures that this function will immediately return
    a computed value from the `result()`, `ok()`, or `err()` functions from `futures::futures`. 
    This is useful for quickly prototyping our application while being able to utilize
    our `executors` and futures combinators.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '跳转到 `Player` 结构中的 `fn set_status(&mut self, status: PlayerStatus) -> FutureResult<&mut
    Self, Never>` 函数，我们会注意到返回值是 `FutureResult`，这告诉 futures 这个函数将立即从 `futures::futures`
    的 `result()`、`ok()` 或 `err()` 函数返回一个计算值。这对于快速原型设计我们的应用程序非常有用，同时能够利用我们的 `executors`
    和未来组合器。'
- en: 'At the `fn add_points(&mut self, points: u32) -> Async<&mut Self>` function
    we return our `Async` value immediately, since we currently do not have a server
    to use, but we would implement the `Async<T>` value over `FutureResult` for functions
    that require computations asynchronously.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 `fn add_points(&mut self, points: u32) -> Async<&mut Self>` 函数中，我们立即返回我们的
    `Async` 值，因为我们目前没有服务器可以使用，但我们会为需要异步计算的函数实现 `Async<T>` 值，基于 `FutureResult`。'
- en: We mimic the time it takes for a network request using our player's `ticks`
    attribute. `Poll<I, E>` will keep executing as long as we are returning `Async::Pending`
    (line [x]).  The executor needs to know whether or not a task needs to be polled
    again. The task's `Waker` trait is what handles these notifications, and we can
    manually invoke it using `cx.waker().wake()` on line 83 . Once our player's `ticks`
    attribute reaches zero we send an `Async::Ready(self)` signal, which tells the
    executor to no longer poll this function.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用玩家的 `ticks` 属性来模拟网络请求所需的时间。`Poll<I, E>` 将会一直执行，只要我们返回 `Async::Pending`（行
    [x]）。执行器需要知道是否需要再次轮询任务。任务的 `Waker` 特性负责处理这些通知，我们可以在第 83 行手动调用它，使用 `cx.waker().wake()`。一旦玩家的
    `ticks` 属性达到零，我们发送一个 `Async::Ready(self)` 信号，这告诉执行器不再轮询此函数。
- en: 'For our `async_add_points()` helper method:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `async_add_points()` 辅助方法：
- en: We return `Box<Future<Item = Player, Error = Never> + Send`, which tells futures
    that this function will eventually return a value of `Player` (since we `Never`
    return an error).
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们返回 `Box<Future<Item = Player, Error = Never> + Send>`，这告诉 futures 这个函数最终将返回一个
    `Player` 类型的值（因为我们 `Never` 返回错误）。
- en: The `+ Send` part of the return is not necessary for our current code base,
    but in the future, we may want to offload some of these tasks onto other threads
    which executors require. Spawning across threads requires us to return the `futures::prelude::Never`
    type as an error and a `'static` variable as well.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值中的 `+ Send` 部分对于我们的当前代码库不是必需的，但将来，我们可能希望将这些任务卸载到其他线程上，因为执行器需要这样做。跨线程生成需要我们返回
    `futures::prelude::Never` 类型作为错误，以及一个 `'static` 变量。
- en: When calling future functions with combinators (such as `then` and `and_then`),
    we will need to return a `Never` error type or the same error type as every other
    future function that is being called within the same combinator flow.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用组合器（如 `then` 和 `and_then`）调用未来函数时，我们需要返回 `Never` 错误类型或与同一组合器流中调用的其他每个未来函数相同的错误类型。
- en: 'Finally, onto our main block:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下我们的主块：
- en: We use the `futures::future::join_all` function, which accepts any `IntoIterator`
    that contains all `InfoFuture` trait elements (which should be all future functions).
    This either collects and returns `Vec<T>` sorted FIFO, or cancels executing as
    soon as the first error returns from any of the future functions within the collection,
    which becomes the returning value for the `join_all()` call.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `futures::future::join_all` 函数，它接受任何包含所有 `InfoFuture` 特性元素的 `IntoIterator`（这应该是所有未来函数）。这要么收集并返回排序为
    FIFO 的 `Vec<T>`，要么在集合中的任何未来函数返回第一个错误时取消执行，这成为 `join_all()` 调用的返回值。
- en: '`then()` and `and_then()` are combinators that internally use `future::Chain`
    and return a `Future` trait value, which allows us to add more combinators if
    we wanted. See the *Using combinators and utilities* section for more information
    on combinators.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then()` 和 `and_then()` 是内部使用 `future::Chain` 并返回 `Future` 特性值的组合器，这允许我们添加更多组合器。有关组合器的更多信息，请参阅
    *使用组合器和工具* 部分。'
- en: '`block_on()` is an executor method that handles any future function or value
    as its input and returns a `Result<Future::Item, Future::Error>`. When running
    this method, the function containing the method will block until the future(s)
    have been completed. Spawned tasks will execute on the default executor, but they
    may not be completed before `block_on` finishes its task(s). If `block_on()` finishes
    before the spawned tasks, then those spawned tasks will be dropped.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block_on()`是一个执行器方法，它处理任何未来函数或值作为其输入，并返回`Result<Future::Item, Future::Error>`。当运行此方法时，包含该方法的函数将阻塞，直到未来（s）完成。派生的任务将在默认执行器上执行，但它们可能不会在`block_on`完成其任务（s）之前完成。如果`block_on()`在派生任务之前完成，则那些派生的任务将被丢弃。'
- en: We can also use `block_on()` as a quick way to run our cycles/ticks and execute
    task(s), which invokes our `poll()` functions. We used this method on line 124
    for *initially loading players* onto the game.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用`block_on()`作为快速运行我们的周期/滴答和执行任务（s）的方法，这会调用我们的`poll()`函数。我们在第124行使用此方法来*最初加载玩家*进入游戏。
- en: There's more...
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `box()` method for returning futures does cause an additional allocation
    to the heap. Another method of returning futures relies on using a `nightly` version
    of Rust or for this issue  [https://github.com/rust-lang/rust/issues/34511](https://github.com/rust-lang/rust/issues/34511)
    to be resolved. The new `async_add_points()` method would return an implied `Future`
    trait and would look as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 返回未来的`box()`方法会导致堆上的额外分配。另一种返回未来的方法是使用Rust的`nightly`版本，或者等待此问题[https://github.com/rust-lang/rust/issues/34511](https://github.com/rust-lang/rust/issues/34511)得到解决。新的`async_add_points()`方法将返回一个隐含的`Future`特质，其外观如下：
- en: '[PRE43]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Rust may cause `undefined behavior` if we were to call `poll()` more than once
    for a future. This problem can be mitigated by converting the future into a stream
    by using the `into_stream()` method or using the `fuse()` adapter, which adds
    a tiny bit of runtime overhead.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对一个未来调用`poll()`超过一次，Rust可能会引起`undefined behavior`。这个问题可以通过使用`into_stream()`方法将未来转换为流或使用添加了微小运行时开销的`fuse()`适配器来缓解。
- en: Tasks are usually executed/polled from using an `executor` such as the `block_on()`
    helper function. You can manually execute tasks by creating a `task::Context`
    and calling `poll()` directly from the task. As a general rule, it is recommended
    to not invoke `poll()` manually and to have an executor manage polling automatically.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 任务通常是通过使用`executor`（例如`block_on()`辅助函数）来执行/轮询的。你可以通过创建`task::Context`并直接从任务中调用`poll()`来手动执行任务。作为一般规则，建议不要手动调用`poll()`，而应该由执行器自动管理轮询。
- en: See also
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Boxing data* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)中的*数据结构高级*章节中的*数据装箱*配方'
- en: '[Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism and Rayon*'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)，*并行性与Rayon*'
- en: Locking resources with BiLocks
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BiLocks锁定资源
- en: BiLocks are used when we need to store a value across multiple threads with
    up to two owners associated with that value. Applicable uses for a BiLock type
    would be splitting TCP/UDP data for reading and writing, or adding a layer between
    a sink and a stream (for logging, monitoring, and so on), or it can be a sink
    and a stream at the same time.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在多个线程之间存储一个值，并且该值最多有两个所有者时，会使用BiLocks。BiLock类型的适用用途包括分割TCP/UDP数据用于读写，或者在接收器和流之间添加一层（用于日志记录、监控等），或者它可以是同时作为接收器和流。
- en: When using futures with an additional crate (such as tokio or hyper), knowing
    BiLocks can help us wrap data around the other crate's common methods. This would
    allow us to build futures and concurrency on top of existing crates without having
    to wait until the crate's maintainers support concurrency explicitly. BiLocks
    are a very low-level utility, but understanding how they work can help us further
    down the road with our (web) applications.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用带有额外crate（例如tokio或hyper）的未来时，了解BiLocks可以帮助我们将数据包装在其他crate的常用方法周围。这将使我们能够在不等待crate的维护者明确支持并发的情况下，在现有crate之上构建未来和并发。BiLocks是一个非常底层的实用工具，但了解它们的工作原理可以帮助我们在未来的（Web）应用中走得更远。
- en: In the next chapter, we will mostly focus on networking with Rust, but we will
    also get to practice integrating futures with other crates. BiLocks can be used
    throughout these next examples, if you wanted to split a TCP/UDP stream in a mutex
    state, although it is not necessary to do so with the crates that we will be using.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将主要关注Rust的网络编程，但我们也会练习将futures与其他crate集成。如果需要将TCP/UDP流分割成互斥状态，可以使用BiLocks，尽管使用我们将要使用的crate时这样做不是必需的。
- en: How to do it...
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In the `src/bin` folder, create a file called `bilocks.rs`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`bilocks.rs`的文件。
- en: 'Add the following code and run it with `cargo run —bin bilocks`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并使用`cargo run —bin bilocks`运行它：
- en: '[PRE44]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we need to implement a fake `futures::task::Waker` for when we create
    a new context (this is what our `FakeWaker` structure is for on lines 11 through
    14)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要实现一个假的`futures::task::Waker`，以便在我们创建一个新的上下文时使用（这就是第11行至第14行的`FakeWaker`结构的作用）。
- en: Since BiLocks require two owners, we will divide the ownership into two different
    structures, called `Reader<T>` (on lines 16 through 18) and `Writer<T>` (on lines
    20 through 22)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于BiLocks需要两个所有者，我们将所有权分为两个不同的结构，称为`Reader<T>`（第16行至第18行）和`Writer<T>`（第20行至第22行）。
- en: 'Our `split() -> (Reader<u32>, Writer<u32>)` function is just to structure/organize
    our code a bit better, and when calling `BiLock::new(t: T)` the return type is
    a tuple of two `futures_util::lock::BiLock` elements'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们的`split() -> (Reader<u32>, Writer<u32>)`函数只是为了更好地结构化/组织我们的代码，并且在调用`BiLock::new(t:
    T)`时，返回类型是两个`futures_util::lock::BiLock`元素的元组。'
- en: 'Now that the preliminary code has been explained, let''s dive into our `main()`
    function:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初步代码已经解释完毕，让我们深入到我们的`main()`函数：
- en: On lines 30 through 34 we set up a new `LocalPool`, `LocalExecutor`, `Waker`
    (`FakeWaker`), and a `LocalMap` (map storage of local data within tasks) for creating
    a new `Context`, since we will be polling our locks manually for demonstration
    purposes.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第30行至第34行，我们设置了一个新的`LocalPool`、`LocalExecutor`、`Waker`（`FakeWaker`）和一个`LocalMap`（任务内的本地数据映射存储），用于创建一个新的`Context`，因为我们将会手动轮询锁以进行演示。
- en: Lines 38 and 40 use the `futures_util::lock::BiLock::poll_lock` function, which
    returns an `Async<futures_util::lock::BiLockGuard<T>>` value if the lock is available.
    If the lock is not available then the function will return `Async::Pending`. The
    lock (the `BiLockGuard<T>`) will unlock when the reference is dropped.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第38行和第40行使用了`futures_util::lock::BiLock::poll_lock`函数，如果锁可用，则返回一个`Async<futures_util::lock::BiLockGuard<T>>`值。如果锁不可用，则函数将返回`Async::Pending`。当引用被丢弃时，锁（`BiLockGuard<T>`）将解锁。
- en: On line 42 we execute `writer.lock.lock()`, which will block the lock and a
    `BiLockAcquire<T>` will be returned, which is a future that can be polled. When
    `BiLockAcquire` is polled, a `Poll<BiLockAcquired<T>, ()>` value is returned and
    that value can be dereferenced mutably.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第42行，我们执行`writer.lock.lock()`，这将阻塞锁并返回一个`BiLockAcquire<T>`，这是一个可以被轮询的未来。当轮询`BiLockAcquire`时，返回一个`Poll<BiLockAcquired<T>,
    ()>`值，并且这个值可以被可变地解引用。
- en: On line 48, we can now see that the lock is currently in an `Async::Pending`
    state, which would not allow us to lock the BiLock again, as shown on lines 51
    through 57.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第48行，我们现在可以看到锁目前处于`Async::Pending`状态，这不会允许我们再次锁定BiLock，正如第51行至第57行所示。
- en: After modifying our lock's value (line 49), we should now unlock it (line 59)
    so that the other owner can reference it (lines 61 through 64).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在修改我们的锁的值（第49行）之后，我们现在应该解锁它（第59行），以便其他所有者可以引用它（第61行至第64行）。
- en: When we call `BiLockAcquired::unlock()` (line 68), the original `BiLock<T>`
    is returned and the lock is officially unlocked.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用`BiLockAcquired::unlock()`（第68行）时，返回原始的`BiLock<T>`，并且锁正式解锁。
- en: 'On line 69 we perform `futures_util::lock::BiLock::reunite(other: T)`, which
    recovers the value of the lock and destroys the *two halves* of the BiLock references
    (presuming that `T` is the other half of the BiLock from the `BiLock::new()` call).'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在第69行，我们执行`futures_util::lock::BiLock::reunite(other: T)`，这恢复了锁的值并销毁了BiLock引用的*两个部分*（假设`T`是`BiLock::new()`调用中BiLock的另一部分）。'
