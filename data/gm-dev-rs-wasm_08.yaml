- en: '*Chapter 6*: Creating an Endless Runner'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：创建无限跑酷游戏'
- en: '**Red Hat Boy** (**RHB**) can run, jump on a platform, and even crash into
    a rock and fall over. But once he starts running to his right, he just goes off
    the screen and is never seen again. There isn''t much to it, and if you wait long
    enough, the game even crashes with a buffer overflow error. In this chapter, we''ll
    make our game truly endless by generating new scenes as RHB runs that contain
    new obstacles and challenges. They will even contain randomness, and it all starts
    with RHB staying in one place! It''s a real trick.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**红帽男孩**（**RHB**）可以跑步，跳上平台，甚至撞到岩石并摔倒。但一旦他开始向右跑，他就从屏幕上消失，再也没有出现过。这并不复杂，如果你等待足够长的时间，游戏甚至会因为缓冲区溢出错误而崩溃。在本章中，我们将通过在RHB跑步时生成新的场景来使我们的游戏真正实现无限，这些场景包含新的障碍和挑战。它们甚至包含随机性，一切始于RHB保持在原地！这是一个真正的技巧。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Scrolling the background
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动背景
- en: Refactoring for endless running
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化以实现无限跑酷
- en: Creating a dynamic level
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态关卡
- en: By the end of this chapter, you'll have a functioning endless runner and be
    able to create obstacles for RHB to hop over and slide under.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个功能齐全的无限跑酷游戏，并且能够为RHB创建可以跳过和滑过的障碍物。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need all the assets at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
    Just like in the previous chapters, you can find the source code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_6](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_6).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要所有在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)的资源。就像在前几章中一样，你可以在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_6](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_6)找到源代码。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/35pES1T](https://bit.ly/35pES1T)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/35pES1T](https://bit.ly/35pES1T)
- en: Scrolling the background
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动背景
- en: 'To run RHB left to right with an infinite background, we have two choices,
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要用无限背景让RHB从左到右跑，我们有两种选择，如下：
- en: Procedurally generate a background, based on a pattern or mathematical formula.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据图案或数学公式程序化生成背景。
- en: Use the Hanna-Barbera technique.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hanna-Barbera技术。
- en: While the first option may appear more interesting or dynamic, the Hanna-Barbera
    technique is much simpler, and it's what we'll be using for Walk the Dog. What
    is the Hanna-Barbera technique? Well, for starters, it may not even go by that
    name, but that's what I'm calling it. Hanna-Barbera was an animation studio that
    ran a series of very popular cartoons from the '50s through to the '90s, including
    Tom and Jerry, The Flintstones, Scooby-Doo, Yogi Bear, and many more. If you were
    a child in any of those decades, you would wake up to "Saturday morning cartoons,"
    which were dominated by Hanna-Barbera properties. While the studio was known for
    their beloved characters, they were also known for cutting costs. They produced
    a lot of cartoons and needed to maximize the ways they could create them quickly
    and cheaply.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一种选择可能看起来更有趣或更动态，但Hanna-Barbera技术要简单得多，这就是我们将用于Walk the Dog的技术。Hanna-Barbera技术是什么？首先，它可能根本不叫这个名字，但这就是我给它取的名字。Hanna-Barbera是一家动画工作室，从20世纪50年代到90年代制作了一系列非常受欢迎的卡通，包括汤姆和杰瑞、弗林斯通一家、神秘岛、约吉熊等等。如果你是那个年代的孩子，你会醒来看到“周六早晨卡通”，这些卡通由Hanna-Barbera的作品主导。虽然该工作室因其深受喜爱的角色而闻名，但他们也因削减成本而闻名。他们制作了大量的卡通，并需要最大化他们快速且低成本地制作卡通的方式。
- en: 'One of the most common traits of Hanna-Barbera cartoons was a repeating background.
    At the end of an episode of Yogi Bear, for example, Ranger Smith would start chasing
    Yogi Bear across Jellystone park. However, if you looked closely, Jellystone park
    appeared to have the same series of trees repeating (see [https://bit.ly/3BNuNXZ](https://bit.ly/3BNuNXZ)
    for an example). This money-saving technique is going to work great for our endless
    runner. We''ll use the same background element we''re using now and move it to
    the left as RHB runs to the right. Immediately after, it will become a copy of
    the same background, making two `Image` elements with the same source image. Once
    the first image moves completely off screen, we''ll move it so that it''s to the
    right of the second image. These two backgrounds will loop, creating the illusion
    of the background moving forever:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Hanna-Barbera卡通最常见的特点之一是重复的背景。例如，在《YOgI熊》的一集结束时，Ranger Smith会开始追逐YOgI熊穿越Jellystone公园。然而，如果你仔细观察，Jellystone公园似乎有一系列相同的树木在重复（见[https://bit.ly/3BNuNXZ](https://bit.ly/3BNuNXZ)以获取示例）。这种节省金钱的技术将非常适合我们的无尽跑酷游戏。我们将使用我们现在使用的相同背景元素，并在RHB向右跑时将其向左移动。紧接着，它将变成相同背景的副本，从而创建两个具有相同源图像的`Image`元素。一旦第一张图像完全移出屏幕，我们将将其移动到第二张图像的右侧。这两个背景将循环，创造出背景永远在移动的错觉：
- en: '![Figure 6.1 – Sliding the canvas over the background'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.1 – Sliding the canvas over the background'
- en: '](img/Figure_6.01_B17151.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.01_B17151.jpg](img/Figure_6.01_B17151.jpg)'
- en: Figure 6.1 – Sliding the canvas over the background
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 在背景上滑动画布
- en: This technique relies on three things. The first is that the background has
    to be seamless so that there is no visible seam between the two images. Fortunately,
    our background was built for this and it will work fine. The second is that the
    canvas window needs to be smaller than the background so that the entire background
    is never shown on screen. If we do this, then the first background can go entirely
    off screen to the left and then be moved to the right of the second background,
    all without any noticeable gaps or tearing. This is because this all happens outside
    the window's boundaries. I like to think of it as being offstage in a play, then
    scrambling over to the right-hand side behind the curtain.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术依赖于三个因素。第一个是背景必须是无缝的，这样两个图像之间就没有可见的缝隙。幸运的是，我们的背景就是为了这个目的而构建的，并且它将工作得很好。第二个是画布窗口需要比背景小，这样整个背景就永远不会显示在屏幕上。如果我们这样做，那么第一个背景就可以完全移出屏幕到左边，然后被移动到第二个背景的右边，而这一切都不会有任何明显的缝隙或撕裂。这是因为这一切都发生在窗口边界之外。我倾向于将其想象成戏剧中的幕后，然后迅速跳到幕布的右侧。
- en: Finally, we must use another illusion and freeze the main character in place.
    Instead of moving the character from left to right on the screen, the objects
    will move right to left, almost as if on a treadmill. Visually, this will look
    the same as if the character were running, and it has the advantage of fixing
    a bug where if the player keeps running right, their *x* position eventually overflows
    (becomes bigger than the i16 we are using to hold it) and the game crashes. We'll
    have to adjust our brains by changing the *x* velocity from what we expect, but
    once you get used to it, you'll find that it works quite easily. Let's get started
    with our scrolling background.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须使用另一个错觉并冻结主要角色。不是将角色从屏幕左边移动到右边，而是将物体从右向左移动，几乎就像在跑步机上一样。从视觉上看，这看起来就像角色在跑步一样，并且它有一个优点，即修复了一个错误，如果玩家持续向右跑，他们的*x*位置最终会溢出（变得比我们用来保存它的i16更大），从而导致游戏崩溃。我们将不得不通过改变*x*速度来调整我们的思维，但一旦你习惯了它，你会发现它工作得相当容易。让我们开始制作我们的滚动背景。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For another example of this technique, go to [https://bit.ly/3BPNBGc](https://bit.ly/3BPNBGc),
    which explains how this works in a game that continuously moves up, such as Doodle
    Jump.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种技术的另一个示例，请访问[https://bit.ly/3BPNBGc](https://bit.ly/3BPNBGc)，它解释了这种技术在持续向上移动的游戏中的应用，例如Doodle
    Jump。
- en: Fixing RHB in x
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复RHB的x坐标
- en: We can scroll the background as much as we want, but if we continue to simultaneously
    move RHB to the right at the same time, the effect will be having him run at double
    speed. Instead, we want RHB to run in place while the rocks and platforms move
    toward him as if they were on a conveyor belt. At the end of this section, we
    will see RHB run to the right into an empty white void as everything passes past
    him as if he were running past the end of the world.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随意滚动背景，但如果我们继续同时将RHB向右移动，效果将是让他以双倍速度奔跑。相反，我们希望RHB原地奔跑，而岩石和平台则向他移动，就像它们在传送带上一样。在本节结束时，我们将看到RHB向右跑进一个空白的白色空间，而一切都在他身边经过，就像他正在跑过世界的尽头。
- en: 'Let''s start in the `game::red_hat_boy_states` module and not update `x` in
    the `update` method of `RedHatBoyContext`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`game::red_hat_boy_states`模块开始，并在`RedHatBoyContext`的`update`方法中不更新`x`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this change, RHB will run in place, with nothing moving around him. We
    are keeping `velocity` as is because that value is going to be used by the rest
    of the code base. For ease of use, we''ll add a few methods. First, let''s add
    an accessor to the `RedHatBoy` implementation, as shown here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，RHB将原地运行，周围没有任何东西移动。我们保持`velocity`不变，因为这个值将被代码库的其余部分使用。为了方便使用，我们将添加一些方法。首先，让我们向`RedHatBoy`实现添加一个访问器，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function works similar to several of our other accessors for `RedHatBoy`,
    making it easier to get at the `context` values. Next, let''s add a new implementation
    – `Walk` for the `Walk` struct:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的工作方式与我们的其他几个`RedHatBoy`访问器类似，这使得获取`context`值更容易。接下来，让我们添加一个新的实现——`Walk`结构体的`Walk`：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Walk` implementation is only available when the `WalkTheDog` enum is in
    the `Loaded` state and it flips `walking_speed` of `boy`. While `boy` is moving
    to the right, this means everything else is moving to the left. Now, in the `update`
    function of `WalkTheDog`, we can use that value to move everything else to the
    left. Right after updating `walk.boy`, we can update the `stone` and `platform`
    positions so that they match the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Walk`实现仅在`WalkTheDog`枚举处于`Loaded`状态时可用，并且它翻转`boy`的`walking_speed`。当`boy`向右移动时，这意味着其他所有东西都在向左移动。现在，在`WalkTheDog`的`update`函数中，我们可以使用该值将其他所有东西向左移动。在更新`walk.boy`之后，我们可以更新`stone`和`platform`的位置，使它们与以下代码匹配：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get a compiler error because `stone` doesn''t have a `move_horizontally`
    function. `Stone` is of the `Image` type and can be found in the `engine` module,
    while `position` on `Image` is private. We''ll keep things that way, and instead
    add `move_horizontally` to the `Image` implementation, as shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个编译器错误，因为`stone`没有`move_horizontally`函数。`Stone`是`Image`类型，可以在`engine`模块中找到，而`Image`上的`position`是私有的。我们将保持这种方式，并在此处将`move_horizontally`添加到`Image`实现中，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Two things may bother you about this code. The first is that we are directly
    manipulating `position` on `Platform` but used a method on `Image`. This inconsistency
    is a *smell* that tells us that something isn't right with our code – in this
    case, `stone` and `platform` have two different interfaces to modify their positions,
    even though the code has been duplicated. For now, we'll leave this as is, but
    it's a hint regarding changes we may want to make later. The other is that we're
    updating the `bounding_box` and `position` values with the same thing. That's
    a refactoring we'll leave for the next section (putting a `position` on `Rect
    Point`), although you can do it now if you're feeling ambitious.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能有两件事会让你感到烦恼。第一点是我们在`Platform`上直接操作`position`，但使用了`Image`上的方法。这种不一致性是一个*异味*，告诉我们我们的代码中可能有问题——在这种情况下，`stone`和`platform`有两个不同的接口来修改它们的位置，尽管代码已经被复制。现在，我们将保持原样，但这是一个关于我们可能想要稍后做出的更改的提示。另一点是我们在更新`bounding_box`和`position`值时使用了相同的内容。这是一个我们将留到下一节（在`Rect
    Point`上放置`position`）的重构，尽管如果你有雄心壮志，你现在就可以做。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Code smell is a programming term that was coined by Kent Beck and popularized
    by Martin Fowler in his book *Refactoring*. If you're getting paid money to program,
    gaming or not, you should check this book out.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味是一个编程术语，由Kent Beck提出，并由Martin Fowler在其书籍《重构》中普及。如果你因为编程而获得报酬，无论是游戏还是其他，你应该看看这本书。
- en: 'Now, you should see RHB running in place as the rock and platform move beneath
    him:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该看到RHB原地奔跑，岩石和平台在他下面移动：
- en: '![Figure 6.2 – Where did the rock go?'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 岩石去哪了？'
- en: '](img/Figure_6.02_B17151.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B17151.jpg)'
- en: Figure 6.2 – Where did the rock go?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 岩石去哪了？
- en: Tip
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget to restart the server if changes don't seem to be showing up. I
    had to when deleting code, for some reason.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改似乎没有显示出来，不要忘记重新启动服务器。我删除代码时就是这样做的，出于某种原因。
- en: 'We can start moving the background by matching the `stone` and `platform` movement
    in the `update` function of `WalkTheDogupdate`. This change will look as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过匹配`WalkTheDogupdate`函数中的`stone`和`platform`移动来开始移动背景。这个更改看起来如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This small change will mean that RHB can now walk off the edge of the world:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小小的更改意味着RHB现在可以走出世界的边缘：
- en: '![Figure 6.3 – Look, the empty void!](img/Figure_6.03_B17151.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 看看，这空旷的虚无！](img/Figure_6.03_B17151.jpg)'
- en: Figure 6.3 – Look, the empty void!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 看看，这空旷的虚无！
- en: However, we don't want this, so let's learn how to use two tiling backgrounds
    to simulate an infinite one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不想这样，所以让我们学习如何使用两个平铺背景来模拟一个无限的背景。
- en: An infinite background
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限背景
- en: 'To get an infinite background, we''ll need two background images instead of
    one. We''ll start by storing `background` as an array instead of just one `Image`
    in `Walk`, as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到无限背景，我们需要两个背景图像而不是一个。我们将首先将`background`存储为数组，而不是在`Walk`中只存储一个`Image`，如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will cause several compiler errors because `backgrounds` doesn''t exist;
    even if it did, the code expects it to be an `Imagearray`. Fortunately, the errors
    largely make sense and we can figure out what needs to be done. Moving once again
    to `initialize` in the `Game` implementation, let''s set up an array of `backgrounds`
    instead of just one when initializing `Walk`, as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致几个编译器错误，因为`backgrounds`不存在；即使它存在，代码也期望它是一个`Imagearray`。幸运的是，错误在很大程度上是有意义的，我们可以找出需要做什么。再次移动到`Game`实现的`initialize`中，让我们在初始化`Walk`时设置一个`backgrounds`数组，而不是只有一个，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's a little more going on here compared to our previous changes, so let's
    go through this code in more detail. The first thing we do is get the `width`
    property of `background`. This is the temporary variable that we created when
    we loaded `HtmlImageElement`, not the `background` property that's attached to
    `Walk` that we have been using. We have done this to prevent a borrow-after-move
    error during the initialization of `Walk`. Then. we made `Walk` take an array
    of `Image` objects, making sure to clone the `background` property the first time
    we create it. Finally, we made sure to position the second `Image` at `background_width`
    so that it will be lined up to the right of the first background, off screen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的变化相比，这里发生了一些额外的事情，所以让我们更详细地看看这段代码。我们首先获取`background`的`width`属性。这是我们加载`HtmlImageElement`时创建的临时变量，而不是我们一直在使用的附加到`Walk`的`background`属性。我们这样做是为了防止在`Walk`初始化期间出现借用后移动错误。然后，我们让`Walk`接受一个`Image`对象的数组，确保在第一次创建时克隆`background`属性。最后，我们确保将第二个`Image`定位在`background_width`处，以便它与第一个背景对齐，位于屏幕之外。
- en: 'However, we still aren''t done with compiler errors. This is because the background
    is being updated and drawn. We''ll make the simplest changes we can so that we
    can start compiling and running again. First, replace the `move_horizontally`
    code we just wrote in the `update` function with the following code, which loops
    through all the backgrounds and moves them:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完成编译器错误的问题。这是因为背景正在更新和绘制。我们将做出最简单的更改，以便我们可以重新开始编译和运行。首先，将我们在`update`函数中刚刚编写的`move_horizontally`代码替换为以下代码，该代码遍历所有背景并将它们移动：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Make sure you use `iter_mut` so that `background` is mutable. Note that you''ll
    need to bind `walk.velocity()` to a temporary variable; otherwise, you''ll get
    a compiler error saying `cannot borrow ''*walk'' as immutable because it is also
    borrowed as mutable`. Now, you can update the `draw` function to draw all the
    backgrounds:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用`iter_mut`，以便`background`是可变的。注意，您需要将`walk.velocity()`绑定到一个临时变量上；否则，您将得到一个编译器错误，提示`cannot
    borrow '*walk' as immutable because it is also borrowed as mutable`。现在，您可以更新`draw`函数来绘制所有背景：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we are looping through `backgrounds` again and drawing them, relying
    on the canvas to only show the backgrounds that are on screen. If you play the
    game while running this code, you''ll see that RHB runs farther but doesn''t run
    infinitely. This is because we aren''t cycling the backgrounds. If you run the
    game for long enough, you''ll see that the game also crashes with a buffer overflow
    error, but we''ll fix that in the next section. First, we need to get the backgrounds
    cycling. We can do that by replacing the loop in the `update` function with code
    that explicitly destructures the array, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次遍历`backgrounds`并绘制它们，依赖于画布只显示屏幕上的背景。如果你在运行此代码时玩游戏，你会看到RHB跑得更远，但不会无限跑。这是因为我们没有循环背景。如果你运行游戏足够长时间，你会看到游戏也会因为缓冲区溢出错误而崩溃，但我们在下一节中会修复这个问题。首先，我们需要让背景循环。我们可以通过将`update`函数中的循环替换为显式解构数组的代码来实现这一点，如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we start by replacing the `for` loop with `let [first_background, second_background]
    = &mut walk.backgrounds;` to get access to both backgrounds. Then, we move them
    both to the left, the same as we did in the loop, and we check whether the right-hand
    side of the image is negative. This means that the image is off screen, so we
    can go ahead and move it to the right-hand side of the other background. If you
    type this in, it won''t compile because `set_x` and `right` don''t exist on the
    `Image` struct. Open the `engine` module again so that we can add those to `Image`,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先用`let [first_background, second_background] = &mut walk.backgrounds;`替换`for`循环，以便访问两个背景。然后，我们将它们都向左移动，就像我们在循环中做的那样，并检查图像的右侧是否为负。这意味着图像已经离屏幕，因此我们可以继续将其移动到另一个背景的右侧。如果你输入这段代码，它将无法编译，因为`set_x`和`right`在`Image`结构体上不存在。再次打开`engine`模块，这样我们就可以将它们添加到`Image`中，如下所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we added a `set_x` function that updates `position` and `bounding_box`,
    just like we did previously, and we had `move_horizontally` call it to avoid duplication.
    We also added a `right` function that calculates the right-hand side of `bounding_box`
    based on the current position. With that, RHB now runs to the right, forever!
    Well, until the buffer overflows and it crashes. Fortunately, we'll take care
    of that in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`set_x`函数，它更新`position`和`bounding_box`，就像我们之前做的那样，并且我们让`move_horizontally`调用它以避免重复。我们还添加了一个`right`函数，它根据当前位置计算`bounding_box`的右侧。有了这个，RHB现在可以永远向右跑！嗯，直到缓冲区溢出并崩溃。幸运的是，我们将在下一节中处理这个问题。
- en: Refactoring for endless running
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构以实现无限运行
- en: By now, you've properly noticed a pattern. Every time we add a new feature,
    we start by refactoring the old code to make it easier to add it. This is generally
    a good practice in most forms of software development, and we'll be following
    that same pattern now. We identified a couple of code smells while creating the
    infinite background, so let's clean those up now, starting with dealing with all
    those casts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经正确地注意到了一个模式。每次我们添加一个新功能，我们首先重构旧代码，使其更容易添加。这在大多数形式的软件开发中通常是一个好的实践，我们现在也将遵循相同的模式。在创建无限背景时，我们识别出了一些代码异味，所以现在让我们清理这些，从处理所有这些类型转换开始。
- en: f32 versus i16
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: f32与i16
- en: 'We had to cast values several times to go from `i16` to `f32` and back again.
    This isn''t a safe operation; the maximum of `f32` is orders of magnitude larger
    than the maximum of `i16`, so there''s the potential for our program to crash
    on a big `f32`. `HtmlImageElement` uses `u32` types, so all the casting to make
    the compiler shut up isn''t even correct. We have two choices here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不多次将值从`i16`转换为`f32`然后再转换回来。这不是一个安全的操作；`f32`的最大值比`i16`的最大值大几个数量级，因此我们的程序有可能在大的`f32`上崩溃。`HtmlImageElement`使用`u32`类型，所以所有为了让编译器闭嘴的类型转换都是不正确的。我们在这里有两个选择：
- en: Take our data types (such as `Rect` and `Point`) and make them match `HtmlImageElement`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的数据类型（如`Rect`和`Point`）与`HtmlImageElement`匹配。
- en: Set `Rect` and any other domain object to be our preferred, smaller, type and
    cast to the larger type on demand.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Rect`和任何其他域对象设置为我们的首选、较小的类型，并在需要时转换为较大的类型。
- en: I suppose we've been using the second choice so far – that is, cast at random
    to get the compiler to compile – but that's hardly ideal. While the first option
    is tempting as we won't have any casts, I prefer `Rect` and `Point` to be as small
    as possible, so we'll set those up to use `i16` as their values. This is more
    than large enough for any of our game objects, and the smaller size is potentially
    beneficial for performance.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们到目前为止一直在使用第二个选择——即随机抛掷以使编译器编译——但这并不是理想的选择。虽然第一个选择很有吸引力，因为我们不会有任何类型转换，但我更喜欢`Rect`和`Point`尽可能小，因此我们将它们设置为使用`i16`作为它们的值。这对于我们所有的游戏对象来说已经足够大了，而且较小的尺寸可能对性能有益。
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The WebAssembly specification does not have an `i32` type, so an `i32` would
    be just as effective here. It also doesn't have an unsigned type, so it may be
    worth profiling to see which type is fastest. For our purposes, we'll go with
    the smallest reasonable size – `i16`. As a professor I once had would say, "We
    got to the moon on 16 bits!"
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly规范没有`i32`类型，所以在这里`i32`同样有效。它也没有无符号类型，所以可能值得分析哪种类型最快。就我们的目的而言，我们将选择最小的合理大小——`i16`。正如我的一位教授曾经说过，“我们用16位到达了月球！”
- en: To get started with this approach, change all the fields in `engine::Rect` to
    be `i16` instead of `f32`. Then, follow the compiler errors. Start by getting
    it to compile, casting `i16` to `f32` as necessary. After getting it to compile
    and run again, look for anywhere we can cast from `i16` to `f32`, and remove it
    if possible. This will include looking at the `Land` event in the `Event` enum,
    which holds an `f32`, and switching it to an `i16`. Finally, look for anywhere
    you cast to `i16`, and see whetherit's still necessary. It will end up being in
    a lot of places but it shouldn't be too painful; in the end, there should only
    be a few necessary casts left. Do this slowly and carefully so that you don't
    get stuck as you work through the errors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这种方法，将`engine::Rect`中的所有字段从`f32`更改为`i16`。然后，跟随编译器错误。首先让它编译，根据需要将`i16`转换为`f32`。在编译并再次运行之后，寻找我们可以从`i16`转换为`f32`的地方，并在可能的情况下将其删除。这将包括查看`Event`枚举中的`Land`事件，它包含一个`f32`，并将其更改为`i16`。最后，寻找所有将值转换为`i16`的地方，并看看它是否仍然必要。这最终会在很多地方，但应该不会太痛苦；最终，应该只剩下几个必要的转换。这样做时要慢而仔细，以免在处理错误时陷入困境。
- en: A more useful Rect
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更有用的矩形
- en: 'The `Rect` implementation only contains the `intersects` method, but there
    are two very useful methods it could use: `right` and `bottom`. If you look at
    the method we just wrote on `Image`, you will see that it''s a natural fit for
    a `right` function. Let''s go ahead and add it to `Rect`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect`实现只包含`intersects`方法，但它可以使用两个非常有用的方法：`right`和`bottom`。如果你看看我们刚刚在`Image`上写的那个方法，你会看到它非常适合`right`函数。让我们继续添加到`Rect`中：'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Adding the `right` and `bottom` methods will prevent that addition logic from
    getting smeared across the game logic. We''ve also refactored `intersects` to
    use these new methods. Now, let''s go back to the `Image` code we just wrote and
    update it to use the new `right` method, as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`right`和`bottom`方法将防止这种添加逻辑散布到游戏逻辑中。我们还重构了`intersects`以使用这些新方法。现在，让我们回到我们刚刚编写的`Image`代码，并更新它以使用新的`right`方法，如下所示：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While we're in `Image`, let's deal with the duplication of `position` and `bounding_box`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`Image`中时，让我们处理`position`和`bounding_box`的重复。
- en: Setting Rect's position
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置矩形的坐标
- en: An image containing a bounding_box `Rect` and a position `Point` is an accident
    that occurred due to our code evolving. So, the question is, which one do we want
    to keep? We could always keep `bounding_box` for the image, which would mean constructing
    a `Point` every time we draw because we need that for the `draw_entire_element`
    call. We could also create a `Dimens` structure that just has `width` and `height`,
    and construct a `Rect` every time we need it on the update. While I doubt that
    the cost of creating those objects is going to be noticeable, the fact that it's
    on every frame is bothersome.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 包含边界框`Rect`和位置`Point`的图像是由于我们的代码演变而发生的意外。所以，问题是，我们想要保留哪一个？我们可以始终保留图像的`bounding_box`，这意味着每次我们绘制时都需要构造一个`Point`，因为我们需要它来调用`draw_entire_element`。我们还可以创建一个只包含`width`和`height`的`Dimens`结构，并在需要时在更新中构造一个`Rect`。虽然我怀疑创建这些对象的成本将不会引起注意，但它在每一帧上都令人烦恼。
- en: 'What we''ll do instead is give `Rect` a `position` field – after all, that''s
    what the `x` and `y` coordinates of `Rect` are. This is a seemingly minor change
    but with far-reaching implications because we constantly initialize `Rect` with
    `x` and `y`. Fortunately, we can use the compiler to make this simpler for us.
    We''ll start by changing `Rect` to hold a `position` field, instead of `x` and
    `y`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的是给 `Rect` 一个 `position` 字段——毕竟，这就是 `Rect` 的 `x` 和 `y` 坐标。这是一个看似微小的变化，但具有深远的影响，因为我们不断地用
    `x` 和 `y` 初始化 `Rect`。幸运的是，我们可以使用编译器来简化这个过程。我们首先将 `Rect` 改为持有 `position` 字段，而不是
    `x` 和 `y`：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Adding `position` is going to cause compiler errors all over the place, as
    expected. We know that we frequently want to both access the `x` and `y` values
    and create a `Rect` using `x` and `y`, so to make it easier to work with, we''ll
    add two `factory` methods for `Rect`, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `position` 将会在各个地方引起编译错误，这是预料之中的。我们知道我们经常需要同时访问 `x` 和 `y` 值并使用 `x` 和 `y`
    创建一个 `Rect`，因此为了便于操作，我们将为 `Rect` 添加两个 `factory` 方法，如下所示：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, when we fix `Rect` everywhere, we will stop creating a `Rect` directly
    and instead use the new constructor methods. We''ll also add getters for `x` and
    `y` because we access those frequently, as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们修复 `Rect` 的所有地方时，我们将停止直接创建 `Rect`，而是使用新的构造方法。我们还将添加 `x` 和 `y` 的获取器，因为我们经常访问它们，如下所示：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This gives you most of the tools you will need to fix the compiler errors. I
    won't reproduce all of them, because there are quite a few and it's repetitive.
    There are two examples you can use to make take care of all but one error. The
    first is replacing every reference to `.x` or `.y` with references to the methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了修复编译错误所需的大部分工具。我不会全部重新展示，因为错误有很多，而且重复性很高。有两个例子你可以使用，以处理除一个错误之外的所有错误。第一个是将所有对
    `.x` 或 `.y` 的引用替换为对方法的引用。
- en: 'This is how you do that in the `intersects` method of `Rect`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在 `Rect` 的 `intersects` 方法中这样做的方式：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, it''s the same but with `x` and `y` replaced with `x()` and
    `y()`. In addition to seeing errors while accessing `x` or `y`, you''ll see errors
    around creating `Rect` because the `position` field isn''t specified. You''ll
    want to replace creating `Rect` directly with using one of the constructor methods,
    as shown here in the implementation of `Image`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它与之前相同，只是将 `x` 和 `y` 替换为 `x()` 和 `y()`。除了在访问 `x` 或 `y` 时看到错误外，你还会在创建 `Rect`
    时看到错误，因为 `position` 字段未指定。你将想要直接使用构造方法之一来创建 `Rect`，如下所示在 `Image` 的实现中：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Taking care of those compiler errors, which will show up in both the `engine`
    and `game` modules, will leave you with only one remaining failure. This can be
    found in the `set_x` method of `Image`. This is because we need to set the `bounding_box.x`
    value. Rather than using `position.x`, which will compile but expose us to errors
    if the internals of `Rect` change again, we''ll add a setter to the `Rect` implementation,
    as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 解决那些将在 `engine` 和 `game` 模块中出现的编译错误，将只留下一个剩余的失败。这可以在 `Image` 的 `set_x` 方法中找到。这是因为我们需要设置
    `bounding_box.x` 的值。而不是使用 `position.x`，这会编译但如果我们再次更改 `Rect` 的内部结构，则会暴露我们于错误之中，我们将向
    `Rect` 实现中添加一个设置器，如下所示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, in `Image`, we can fix the last compiler error by using `set_x`, as shown
    here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `Image` 中，我们可以通过使用 `set_x` 来修复最后的编译错误，如下所示：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that the code is inconsistent when it uses setters versus
    when it uses public variables directly. In general, my rule of thumb is that dumb
    structures such as `Rect` don't need setters and getters, especially if we keep
    them immutable. However, if the internal structure changes, which it did here,
    then it's time to add an abstraction to hide the internals. This change, from
    `x` and `y` to a position, demonstrated the necessity of the setter after all.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当代码使用设置器而不是直接使用公共变量时，代码是不一致的。一般来说，我的经验法则是像 `Rect` 这样的简单结构不需要设置器和获取器，特别是如果我们保持它们不可变的话。然而，如果内部结构发生变化，就像这里发生的那样，那么是时候添加一个抽象来隐藏内部结构了。从
    `x` 和 `y` 到位置的这一变化，最终证明了设置器的必要性。
- en: At this point, you should see RHB running to the right and jumping on and off
    the platform again. Make sure you check out this behavior each time you get to
    a successful compile since it is easy to make a mistake as you make a large number
    of small changes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该看到 RHB 向右跑并再次跳上跳下平台。确保每次成功编译时都检查这种行为，因为当你进行大量的小改动时，很容易出错。
- en: 'Now that we''ve prepared `Rect` to hold a `position`, we can remove the duplication
    of that data in `Image`. We''ll start by removing `position` from the `Image`
    struct, as shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为`Rect`准备了存储`position`，我们可以从`Image`中移除该数据的重复。我们将从从`Image`结构体中移除`position`开始，如下所示：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s follow the compiler and remove all references to `position` in
    the `Image` implementation. Fortunately, there are no longer any references to
    `position` outside of the `Image` implementation, so we can do this by making
    a few quick changes. These changes are shown here. Note how wherever we previously
    used `position`, we are now using `bounding_box.position` or `bounding_box.x()`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跟随编译器，从`Image`实现中移除所有对`position`的引用。幸运的是，现在没有对`position`的引用存在于`Image`实现之外，所以我们可以通过进行一些快速更改来完成这项工作。这些更改如下所示。注意，我们之前在哪里使用`position`，现在我们使用`bounding_box.position`或`bounding_box.x()`：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we've removed the duplication on `Image`, we're ready to get all of
    the obstacles in a level into one shared `trait` so that we can use them all in
    one list. Doing that will allow us to fix a bug that occurs when the buffer overflows
    due to running infinitely and prepare the code for dynamically adding many shared
    segments. Let's get to it!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从`Image`中移除了重复，我们准备好将一个关卡中的所有障碍物放入一个共享的`trait`中，这样我们就可以在一个列表中使用它们。这样做将允许我们修复当缓冲区因无限运行而溢出时发生的错误，并为动态添加许多共享段准备代码。让我们开始吧！
- en: Obstacle traits
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 障碍物特质
- en: 'Currently, the stone and the platform are separate objects on the `Walk` struct.
    If we want to add more obstacles to the game, we must add more fields to this
    struct. This is an issue if we want to have an endlessly generated list of things
    to jump over and slide under. What we''d like to do instead is keep a list of
    `Obstacles`, go through each one, and check what to do when `RedHatBoy` intersects
    them. Why do we want to do that? Let''s have a look:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在`Walk`结构体中，石头和平台是独立的对象。如果我们想给游戏添加更多障碍物，我们必须向这个结构体添加更多字段。如果我们想要有一个无限生成的跳过和滑过的物品列表，这就会成为一个问题。我们真正想要做的是保持一个`Obstacles`列表，遍历每一个，并检查当`RedHatBoy`与之相交时应该做什么。我们为什么要这样做呢？让我们看看：
- en: It will eliminate the duplication for knocking out RHB, and eliminate *future*
    duplication that we'd have to create to continue with our current pattern.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将消除消除RHB时的重复，并消除我们为了继续当前模式而必须创建的*未来*重复。
- en: We want to treat each `Obstacle` as the same so that we can create obstacles
    on the fly.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望将每个`Obstacle`视为相同，这样我们就可以在飞行中创建障碍物。
- en: We'll be able to remove any obstacles that have gone off screen.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将能够移除任何已经离开屏幕的障碍物。
- en: 'We''ll start by creating an `Obstacle` trait in the `game` module, with one
    new method named `check_intersection` and two that exist already on `Platform`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`game`模块中创建一个名为`check_intersection`的新`Obstacle`特质，以及两个已经在`Platform`上存在的特质：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Why these three methods? `stone` and `platform` are both going to implement
    `Obstacle`, and we''ll need to loop through them, `draw` them, and move them.
    So, that''s why the trait contains `move_horizontally` and `draw`. The new method,
    `check_intersection`, exists because a `platform` lets you land on it, whereas
    a `stone` doesn''t. So, we''ll need an abstraction that can handle intersections
    differently depending on the type of `Obstacle`. Now that we''ve created our `trait`,
    we can implement it on the `Platform` structure. We can start by pulling `draw`
    out of the `Platform` implementation and creating a `move_horizontally` method,
    as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有三个方法？`stone`和`platform`都将实现`Obstacle`，我们需要遍历它们，绘制它们，并移动它们。所以，这就是为什么特质包含`move_horizontally`和`draw`。新的方法`check_intersection`存在，因为`platform`允许你着陆在上面，而`stone`则不行。所以，我们需要一个可以处理不同类型`Obstacle`交叉的不同抽象。现在我们已经创建了我们的`trait`，我们可以在`Platform`结构体上实现它。我们可以从将`draw`从`Platform`实现中提取出来并创建一个`move_horizontally`方法开始，如下所示：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I've elided the implementation of `draw` here because this method does not change.
    Meanwhile, `move_horizontally` mimics the code that is currently in `update`,
    which we identified as a code smell earlier.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里省略了`draw`的实现，因为这个方法没有变化。同时，`move_horizontally`模仿了之前在`update`中识别出的代码。
- en: 'Finally, let''s add the `check_intersection` function, which currently exists
    in the `update` method of `WalkTheDog`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加`check_intersection`函数，该函数目前存在于`WalkTheDog`的`update`方法中：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The version that''s been implemented for `Platform` should be very similar,
    without the references to `walk`, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为`Platform`实现的版本应该非常相似，没有对`walk`的引用，如下所示：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code is largely the same but with one fairly significant optimization:
    instead of looping through every bounding box in `Platform`, this code uses `find`
    to get the first bounding box that''s intersected. If there is one (`if let Some(box_to_land_on)`),
    then we handle the collision. This prevents redundant checks after a collision
    is found. The rest of the code is a little bit shorter without the references
    to `walk`, which is nice. Now, we need to replace `Platform` in `Walk` with a
    reference to it on the heap, like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码大体相同，但有一个相当重要的优化：而不是遍历`Platform`中的每个边界框，这段代码使用`find`来获取第一个相交的边界框。如果有（`if
    let Some(box_to_land_on)`），那么我们处理碰撞。这防止了在找到碰撞后的重复检查。其余的代码稍微短一些，没有对`walk`的引用，这是很棒的。现在，我们需要将`Walk`中的`Platform`替换为对堆上的它的引用，如下所示：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: We do have an alternative to using a trait object here, which would be using
    an enum containing every type of obstacle, just like we did with our state machine.
    The tradeoff to using dynamic dispatch, via the `dyn` keyword, is that a lookup
    table is stored in memory. The benefit of this is that we write less boilerplate
    code, and the code doesn't need to be updated every time we add an obstacle. In
    this case, I think `trait` works better in the same way that an enum works better
    for a state machine, but it's worth keeping that in mind.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里确实有一个替代方案，那就是使用一个包含每种障碍物类型的枚举，就像我们在状态机中做的那样。使用`dyn`关键字进行动态分发的权衡是，一个查找表被存储在内存中。这个好处是我们写更少的样板代码，而且代码不需要每次添加障碍物时都更新。在这种情况下，我认为`trait`和枚举对状态机一样好，但这是值得记住的。
- en: 'This will cause two compiler errors that we can fix by making small changes.
    In the `initialize` method of `WalkTheDog`, we are not setting `platform` correctly
    when we create `Walk`, so let''s make a small change, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致两个编译错误，我们可以通过进行小的修改来修复它们。在`WalkTheDog`的`initialize`方法中，我们在创建`Walk`时没有正确设置`platform`，所以让我们进行一个小改动，如下所示：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is only a one-line change that involves replacing `platform` with `platform:
    Box::new(platform)`. The other fix is something you''ll remember being a smell
    – setting the position on `x` directly when `stone` uses a method called `move_horizontally`.
    This is why we created that method on the `Obstacle` trait on the `Platform` struct.
    This change can be found in the `update` function for `WalkTheDog`, as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '这只是一个单行的改动，涉及将`platform`替换为`platform: Box::new(platform)`。另一个修复是你会记得的一个问题——当`stone`使用名为`move_horizontally`的方法时，直接在`x`上设置位置。这就是为什么我们在`Platform`结构体上的`Obstacle`特质中创建了那个方法。这个改动可以在`WalkTheDog`的`update`函数中找到，如下所示：'
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Having both `platform` and `stone` have a `move_horizontally` function is a
    sign that those interfaces can be brought together, which we''ll do in a moment.
    Finally, we must replace the code that we moved into `check_intersection` with
    a call to that function. Just a little further down the `update` function, you''ll
    want to update the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`platform`和`stone`都有`move_horizontally`函数，这是一个迹象表明这些接口可以被合并，我们将在稍后做到这一点。最后，我们必须用对这个函数的调用替换我们移动到`check_intersection`中的代码。在`update`函数的稍低处，你将想要更新以下代码：'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The call to `check_intersection` goes before the check to see whether you've
    crashed into a stone and after the background updates. You may notice that the
    code for checking for collisions with a stone is different, in the sense that
    `boy` is always knocked out when you collide with it, but is it also conceptually
    the same because you are, once again, checking for a collision with an obstacle
    and then doing something. This is why we need to turn `stone`, which is currently
    an `Image type`, into an `Obstacle` type. But what type should it be?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_intersection`的调用在检查你是否撞到石头之前，在背景更新之后。你可能注意到检查与石头碰撞的代码有所不同，从某种意义上说，当与`boy`碰撞时，它总是被击倒，但它在概念上也是相同的，因为你再次检查与障碍物的碰撞，然后做些什么。这就是为什么我们需要将当前是`Image`类型的`stone`转换为`Obstacle`类型。但应该是什么类型呢？'
- en: Barriers versus platforms
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 障碍物与平台
- en: We need another type of `Obstacle` that cannot be landed on, and right now a
    `stone` is an `Image`. Adding features to `Image` isn't appropriate because an
    `Obstacle trait` is a `game` concept and `Image` is part of `engine`. Instead,
    we'll create a type of `Obstacle` that always causes the user to crash into it,
    called `Barrier`, and turn `stone` into that. It's a very dangerous stone.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一种类型的`Obstacle`，它不能着陆，而目前`stone`是一个`Image`。向`Image`添加功能并不合适，因为`Obstacle
    trait`是一个`game`概念，而`Image`是`engine`的一部分。相反，我们将创建一种总是导致用户与之碰撞的`Obstacle`类型，称为`Barrier`，并将`stone`转换为那种类型。这是一块非常危险的石头。
- en: 'We''ll start by creating a `Barrier` struct and implementing the `Obstacle`
    trait with placeholders, as shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个`Barrier`结构体，并使用占位符实现`Obstacle`特质，如下所示：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: I generated this skeleton with `rust-analyzer` while using the `add-missing-members`
    action. In my editor (emacs), this is as simple as typing `c v`. In Visual Studio
    Code, simply click the lightbulb and choose `todo!` macro throws a runtime exception
    if this code is called without any implementation, and it is meant to signal temporary
    code that is there to please the compiler.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我在使用`add-missing-members`操作时，用`rust-analyzer`生成了这个骨架。在我的编辑器（emacs）中，这只需要输入`c
    v`。在Visual Studio Code中，只需点击灯泡并选择`todo!`宏，如果没有实现就调用此代码，将抛出一个运行时异常，这是为了向编译器传达临时代码的存在。
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Right now, all `Barrier` objects have to be an `Image`, whereas a `Platform`
    uses a sprite sheet. You may want to use sprite sheets for everything, or even
    one sprite sheet for everything, and that's fine – better, even. We'll leave things
    as is here because we've redesigned this application enough already.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有的`Barrier`对象都必须是`Image`，而`Platform`使用精灵表。你可能想为所有东西使用精灵表，甚至为所有东西使用一个精灵表，这也是可以的——甚至更好。我们将保持现状，因为我们已经对这个应用程序进行了足够的重新设计。
- en: 'Before we fill in all those `todo!` blocks, let''s add a typical `new` method
    to create the `Barrier` object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们填充所有那些`todo!`块之前，让我们添加一个典型的`new`方法来创建`Barrier`对象：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can fill in the functions. The `draw` and `move_horizontally` functions
    can delegate to `Image`, as shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以填充函数。`draw`和`move_horizontally`函数可以委托给`Image`，如下所示：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The final function, `check_intersection`, will be a little different. Unlike
    a `Platform`, which `boy` can land on, a `Barrier` is always crashed into. The
    code for this already exists in the `update` method of `WalkTheDog` because it''s
    what we used for `stone`. Let''s mimic that implementation here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的函数`check_intersection`将略有不同。与`Platform`不同，`Platform`是男孩可以着陆的地方，而`Barrier`总是导致碰撞。这个代码已经在`WalkTheDog`的`update`方法中存在，因为我们就是用它来处理`stone`的。让我们在这里模仿那个实现：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Barrier` isn''t being used anywhere yet. So, we could start by changing `stone`
    from an `Image` into a `Barrier`. However, we''re going to go a little further
    than that. We''re going to create a list in `Walk` that contains *all* the `Obstacle`
    types. This will let us reduce the amount of specific code in `Walk`, and it will
    make it far simpler to generate new obstacles on the fly. Remember that''s what
    we''re refactoring for. Let''s make our list and add it to the `Walk` struct,
    as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Barrier`目前还没有被使用。因此，我们可以从将`stone`从`Image`改为`Barrier`开始。然而，我们将做得更多。我们将在`Walk`中创建一个包含所有`Obstacle`类型的列表。这将使我们能够减少`Walk`中的特定代码量，并且可以更简单地动态生成新的障碍物。记住，这是我们重构的原因。让我们创建我们的列表并将其添加到`Walk`结构体中，如下所示：'
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that we''ve removed `platform` and `stone` from `Walk`, we''ll need to
    update the rest of its implementation and replace direct references to `stone`
    and `platform` with references to the `Obstacle` vector. This doesn''t mean we
    won''t ever mention `platform` and `stone` again; we still have to load the image
    and sprite sheet, but we''ll only mention it once. Once again, we''ll look at
    the compiler error messages, which are complaining a lot about the `initialize`,
    `update`, and `draw` methods in `WalkTheDog`. Let''s start by making changes to
    the `initialize` function, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经从`Walk`中移除了`platform`和`stone`，我们需要更新其余的实现，并将对`stone`和`platform`的直接引用替换为对`Obstacle`向量的引用。这并不意味着我们永远不会再次提到`platform`和`stone`；我们仍然需要加载图像和精灵表，但我们只会提到一次。再次提醒，我们将查看编译器错误信息，这些信息大量抱怨`WalkTheDog`中的`initialize`、`update`和`draw`方法。让我们首先从修改`initialize`函数开始，如下所示：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We''re only changing the construction of the `Walk` construct, replacing the
    references to `stone` and `platform` by initializing the `obstacles` vector. The
    first item in the vector is now a `Barrier` but that''s just the `stone` object
    that we created earlier wrapped in the new `Barrier` struct. The second is the
    `platform` object that we created previously. Everything has to be in a `Box`
    so that we can use the `Obstacle` trait. The next few changes we''ll make must
    be done in the `update` method. We''ll rearrange the code a little bit to update
    `boy` first, then our backgrounds, and finally our `obstacles`, as shown here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只更改了`Walk`结构的构建，将`stone`和`platform`的引用替换为初始化`obstacles`向量。向量中的第一个项目现在是一个`Barrier`，但这只是我们之前创建的`stone`对象被新的`Barrier`结构包装起来。第二个是之前创建的`platform`对象。所有内容都必须在`Box`中，这样我们才能使用`Obstacle`特质。接下来我们将做的几个更改必须在`update`方法中完成。我们将稍微调整一下代码，首先更新`boy`，然后是我们的背景，最后是我们的`obstacles`，如下所示：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There should be no direct references to `stone` or `platform` in `update`.
    Now, the code for checking for the movement of obstacles and whether they intersect
    should only be four lines long and be at the bottom of the `update` method – and
    that''s generously counting the closing brace. Make sure you use the `iter_mut`
    method since we are mutating `obstacle` in the loop. One of the ways we can tell
    that we are moving in the right direction in our design is that we''re writing
    *less* code that works with *more* things. Finally, we will need to draw all our
    `obstacles`, which can be handled by updating the `draw` method, as shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`中不应有直接引用`stone`或`platform`。现在，检查障碍物移动以及它们是否相交的代码应该只有四行长，并且位于`update`方法的底部——这还是慷慨地计算了闭合花括号。确保你使用`iter_mut`方法，因为我们正在循环中修改`obstacle`。我们可以判断我们的设计方向是否正确的一种方式是，我们正在编写的代码更少，但与更多事物协同工作。最后，我们需要绘制所有的`obstacles`，这可以通过更新`draw`方法来实现，如下所示：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, we can use `for_each` and a plain `iter()`. As you may have guessed,
    when we want to add more obstacles to the screen, we will just add them to the
    `obstacles` list. At this point, the code should be working again; RHB should
    hop his way over a platform and a stone and then crash into it. Now, all we need
    to take care of is the crash that occurs if we let RHB keep running. We'll handle
    that next.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用`for_each`和普通的`iter()`。正如你可能猜到的，当我们想要在屏幕上添加更多障碍物时，我们只需将它们添加到`obstacles`列表中。到目前为止，代码应该再次工作；RHB应该跳过平台和石头，然后撞到它们。现在，我们只需要处理如果让RHB继续运行时发生的崩溃。我们将在下一部分处理这个问题。
- en: Removing obstacles as they go off screen
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随着障碍物从屏幕上消失时移除它们
- en: 'If you let RHB run to the right for long enough, you''ll see a crash message
    that looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你让RHB向右跑足够长的时间，你会看到一个类似这样的崩溃信息：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code is from the log in the browser. Here, the images move farther
    and farther to the left until they eventually reach the maximum length of the
    signed 16-bit integer. This is happening because we''re never removing an obstacle
    from the obstacles Vec when they go off screen, and we should. Let''s add a line
    of code to the `update` function that goes right before we move and collide with
    the obstacles, as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码来自浏览器的日志。在这里，图像向左移动越来越远，直到最终达到有符号16位整数的最大长度。这是因为在障碍物从屏幕上消失时，我们从未从障碍物Vec中移除障碍物，我们应该这样做。让我们在`update`函数中添加一行代码，就在我们移动和与障碍物碰撞之前，如下所示：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `retain` function will keep any `obstacles` that match the predicate that''s
    been passed in. In this case, this will happen if the rightmost point of the obstacle
    is to the right of the left edge of the screen. This means we''re looping through
    the list of obstacles twice. If we were using the nightly build of Rust, we could
    use the `drain_filter` function to avoid that, but our `obstacles` list should
    never be long enough for that to be an issue. For this code to compile, you''ll
    need to add one more method to the `Obstacle` trait – the `right` method for the
    rightmost point of `Obstacle`. This can be seen in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`retain`函数将保留任何与传入的谓词匹配的`obstacles`。在这种情况下，如果障碍物的最右端点在屏幕的左侧边缘的右侧，这将发生。这意味着我们正在两次遍历障碍物列表。如果我们使用Rust的nightly构建，我们可以使用`drain_filter`函数来避免这种情况，但我们的`obstacles`列表永远不会长到成为问题。为了使这段代码编译，你需要在`Obstacle`特质中添加一个额外的方法——`right`方法，用于`Obstacle`的最右端点。这可以在以下代码中看到：'
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This method will need to be added to both the `Platform` and `Barrier` implementations
    of `Obstacle`. `Barrier` can just delegate to the image it''s holding, `Platform`
    is a little trickier because it has more than one box. We want to use the right
    edge of the last bounding box, as shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法需要添加到`Obstacle`的`Platform`和`Barrier`实现中。`Barrier`可以直接委托到它持有的图像，而`Platform`稍微复杂一些，因为它有多个盒子。我们希望使用最后一个边界框的右边，如下所示：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code gets the last bounding box with `last` and unwraps it since `last`
    returns an `Option`. We don't want to return a `Result` and then force everybody
    to use a `Result`, so we are using `unwrap_or(&Rect::default())` to return an
    empty `Rect` when `Platform` has no bounding boxes. One empty bounding box is
    effectively the same as no bounding boxes. Then, we get the rightmost value of
    the last `Rect` with `right`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用`last`获取最后一个边界框并解包它，因为`last`返回一个`Option`。我们不希望返回一个`Result`然后强迫每个人使用`Result`，所以我们使用`unwrap_or(&Rect::default())`在`Platform`没有边界框时返回一个空的`Rect`。一个空的边界框实际上等同于没有边界框。然后，我们使用`right`获取最后一个`Rect`的最右侧值。
- en: '`Rect` doesn''t have a default implementation yet, so we''ll need to add a
    `#[derive(Default)]` annotation to the `Rect` and `Point` structures in `engine`.
    The annotation automatically implements the `Default` trait for a `struct` by
    using the default value of every field in that `struct`. `Point` will need the
    annotation because it is in the `Rectstructure`, so for the macro to work for
    `Rect`, it must also work for `Point`. Fortunately, there''s no real harm in adding
    this to them.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect`还没有默认实现，所以我们需要在`engine`中的`Rect`和`Point`结构上添加`#[derive(Default)]`注解。该注解通过使用该`struct`中每个字段的默认值来自动实现`Default`特质。`Point`需要这个注解，因为它位于`Rect`结构中，所以为了让宏对`Rect`起作用，它也必须对`Point`起作用。幸运的是，添加这个注解并没有真正的害处。'
- en: With that, you can let RHB run for as long as he wants, with no buffer overflow.
    Now, we need to give RHB many platforms to jump on. We will start by sharing the
    sprite sheet. Let's dig into this last piece of refactoring.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以让RHB运行尽可能长时间，而不会发生缓冲区溢出。现在，我们需要给RHB提供许多可以跳上的平台。我们将从共享精灵图集开始。让我们深入研究这个重构的最后部分。
- en: Sharing a sprite sheet
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分享精灵图集
- en: Each `Platform` has a reference to an `Image` and a `Sheet` that we've casually
    been referring to as "the sprite sheet." When we start generating more `Platform`
    objects, we'll want to share a reference to the sheet. So, the time has come to
    add a `SpriteSheetstruct` to our engine to enable that. Let's open the `engine`
    module and add that new concept.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Platform`都有一个对`Image`和`Sheet`的引用，我们随意称之为“精灵图集”。当我们开始生成更多的`Platform`对象时，我们希望共享图集的引用。因此，现在是时候在我们的`engine`中添加一个`SpriteSheetstruct`以实现这一点。让我们打开`engine`模块并添加这个新概念。
- en: Creating a sprite sheet
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建精灵图集
- en: 'We will start by creating a `struct` that holds both `HtmlImageElement` and
    `Sheet` in the `engine` module:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`engine`模块中创建一个`struct`，它同时包含`HtmlImageElement`和`Sheet`：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s create an implementation that will wrap the common behaviors of
    the sheet that we''re using in `Platform`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个实现，它将封装我们在`Platform`中使用的图集的常见行为：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'I initially considered having `draw` take the name of the `cell` property we
    were drawing, but right now, our `Platform` draws more than one `cell` at a time,
    and we want to keep that functionality. Let''s replace `HtmlImageElement` and
    `Sheet` in `Platform` with the `SpriteSheet` field, as shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初考虑让`draw`函数接受我们正在绘制的`cell`属性的名称，但现在，我们的`Platform`一次绘制多个`cell`，我们希望保持这种功能。让我们将`Platform`中的`HtmlImageElement`和`Sheet`替换为`SpriteSheet`字段，如下所示：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Don''t forget to import `SpriteSheet` from the `engine` module. Now, you can
    follow the compiler to simplify `Platform` by removing references to `Sheet` and
    `HtmlImageElement` and just using `SpriteSheet`. In particular, you''ll need to
    change the `new` function so that it takes one `SpriteSheet` instead of the two
    parameters. The following code shows how this can be initialized in the `initialize`
    method of `WalkTheDog`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记从`engine`模块导入`SpriteSheet`。现在，你可以跟随编译器简化`Platform`，通过移除对`Sheet`和`HtmlImageElement`的引用，只使用`SpriteSheet`。特别是，你需要更改`new`函数，使其接受一个`SpriteSheet`而不是两个参数。以下代码显示了如何在`WalkTheDog`的`initialize`方法中初始化这一点：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The rest of `Platform` can be modified to fit the new interface. Note how you
    no longer need to say `frames` and can just call `sheet.cell`. The `draw` method
    will now delegate to `self.sheet.draw` and pass it the `renderer` instead of an
    `Image`. This structure is small and wouldn't be worth the effort if we didn't
    want to share the same `SpriteSheet` across multiple `Platform` objects. But we
    do want to share one `SpriteSheet`, instead of duplicating that memory everywhere.
    Due to this, we need to make it possible to share it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Platform` 的其余部分可以修改以适应新的接口。注意，你不再需要说 `frames`，可以直接调用 `sheet.cell`。`draw` 方法现在将委托给
    `self.sheet.draw` 并传递 `renderer` 而不是 `Image`。这个结构很小，如果我们不想要在多个 `Platform` 对象之间共享相同的
    `SpriteSheet`，那么这就不值得努力。但我们确实想要共享一个 `SpriteSheet`，而不是在各个地方复制内存。因此，我们需要使其能够共享。'
- en: Sharing a sprite sheet
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享精灵表
- en: To share `SpriteSheet` across more than one `Platform`, we'll need to store
    it somewhere that all of the platforms can point to, and designate something to
    be the owner of `SpriteSheet`. We could give `SpriteSheet` a `static` lifetime,
    and make it global, but that would mean making it an `Option` since it's not available
    until `initialize` is used. Instead, we'll store a reference-counted version of
    `SpriteSheet` in the `Walk` structure. This is a tradeoff since we'll be using
    reference counting instead of ownership to track when we should delete `SpriteSheet`,
    but in exchange, we'll only be duplicating the pointer in memory instead of an
    entire `SpriteSheet`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多个 `Platform` 之间共享 `SpriteSheet`，我们需要将其存储在一个所有平台都可以指向的地方，并指定一个作为 `SpriteSheet`
    的所有者。我们可以给 `SpriteSheet` 一个 `static` 生命周期，并使其全局，但这意味着它必须是一个 `Option`，因为它在 `initialize`
    被使用之前不可用。相反，我们将 `SpriteSheet` 的引用计数版本存储在 `Walk` 结构体中。这是一个权衡，因为我们将使用引用计数而不是所有权来跟踪何时应该删除
    `SpriteSheet`，但作为交换，我们只会在内存中复制指针而不是整个 `SpriteSheet`。
- en: 'Let''s add `obstacle_sheet` to the `Walk` struct, as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `obstacle_sheet` 添加到 `Walk` 结构体中，如下所示：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You''ll need to make sure you add `use std::rc::Rc` to the top of the `game`
    module. We''ll also need to make sure that `Platform` can take a reference-counted
    `SpriteSheet` instead of taking ownership of `SpriteSheet`, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保将 `use std::rc::Rc` 添加到 `game` 模块的顶部。我们还需要确保 `Platform` 可以接受一个引用计数的 `SpriteSheet`
    而不是接受 `SpriteSheet` 的所有权，如下所示：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we''re replacing `SpriteSheet` with `Rc<SpriteSheet>`. This leaves us
    with one last modification we need to make – we must initialize the `Walk` struct
    and set up `obstacle_sheet` and the platform, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `SpriteSheet` 替换为 `Rc<SpriteSheet>`。这让我们只剩下最后一个需要做的修改——我们必须初始化 `Walk`
    结构体，并设置 `obstacle_sheet` 和平台，如下所示：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Two sections change in `initialize`. First, after we call `fetch_json` to get
    `tiles.json`, we use that to create a reference-counted `SpriteSheet` named `sprite_sheet`
    with `Rc::new`. Note that we've replaced `let platform_sheet` with `let tiles`
    because that's a better name – it's loading `tiles.json` after all. Then, when
    we create `platform` with `Platform::new`, we pass it a clone of the created sprite
    `_sheet`. Previously, this was done inline, but we're going to need `sprite_sheet`
    again in a minute.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initialize` 中有两个部分发生了变化。首先，在调用 `fetch_json` 获取 `tiles.json` 之后，我们使用它通过 `Rc::new`
    创建一个名为 `sprite_sheet` 的引用计数 `SpriteSheet`。请注意，我们将 `let platform_sheet` 替换为 `let
    tiles`，因为这个名字更好——它毕竟是在加载 `tiles.json`。然后，当我们使用 `Platform::new` 创建 `platform` 时，我们传递给它创建的精灵
    `_sheet` 的副本。之前，这是直接完成的，但我们在一分钟后还需要 `sprite_sheet`。
- en: Then, when we're creating the `Walk` struct, we need to pass that created sheet
    to the `obstacle_sheet` field. This doesn't need to be cloned because `Walk` is
    the ultimate owner of `sprite_sheet`, so `sprite_sheet` can be moved into it.
    This will increment the reference counter and will not clone the entire `SpriteSheet`.
    We will need to clone `obstacle_sheet` every time we create a `Platform` to ensure
    the references are counted correctly, but don't worry about this – the compiler
    will force us to do this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们创建 `Walk` 结构体时，我们需要将创建的表格传递给 `obstacle_sheet` 字段。这不需要克隆，因为 `Walk` 是 `sprite_sheet`
    的最终所有者，所以 `sprite_sheet` 可以移动到其中。这将增加引用计数，并且不会克隆整个 `SpriteSheet`。我们将需要在创建每个 `Platform`
    时克隆 `obstacle_sheet`，以确保正确计数引用，但不用担心这个问题——编译器会强制我们这样做。
- en: With that, we're now ready to reevaluate how our `Platform` object works. Currently,
    it can only create one `Platform`, but there's no reason it can't create many
    things the player can stand on. We'll want that as we generate levels. We'll do
    that next.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在准备重新评估我们的`Platform`对象是如何工作的。目前，它只能创建一个`Platform`，但没有任何理由它不能创建许多玩家可以站立的物体。当我们生成关卡时，我们会需要这个功能。我们将在下一步实现它。
- en: Many different platforms
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多不同的平台
- en: 'The current `Platform` struct assumes it''s using the same three cells in the
    sprite sheet, including calculating the bounding boxes. So, to allow many kinds
    of platforms to be used, we''ll need to pass in the cells we want to be rendered
    from the sheet, and we''ll need to pass in custom bounding boxes for each potential
    `Platform`. For example, imagine that you wanted to take the provided tileset
    (`tiles.json`) and arrange them into a little cliff:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的`Platform`结构体假设它使用的是精灵图中相同的三个单元格，包括计算边界框。因此，为了允许使用多种类型的平台，我们需要传递从图中要渲染的单元格，并且我们需要为每个潜在的`Platform`传递自定义的边界框。例如，假设你想要将提供的瓷砖集（`tiles.json`）排列成一个小悬崖：
- en: '![Figure 6.4 – Look out below!'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 下面小心！'
- en: '](img/Figure_6.04_B17151.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.04_B17151.jpg)'
- en: Figure 6.4 – Look out below!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 下面小心！
- en: This would require passing the `11`, `2`, and `3` platform tiles. Those tiles
    aren't arranged horizontally or neatly, and the bounding boxes don't match our
    other platform. When we create this platform, we'll need to look up the tile dimensions
    in `tiles.json` and work out the bounding boxes from the provided dimensions manually.
    This means changing the way `Platform` works so that it's less specific.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要传递`11`、`2`和`3`个平台瓷砖。这些瓷砖不是水平排列或整齐排列的，并且边界框与我们的其他平台不匹配。当我们创建这个平台时，我们需要在`tiles.json`中查找瓷砖尺寸，并手动从提供的尺寸中计算出边界框。这意味着我们需要改变`Platform`的工作方式，使其不那么具体。
- en: 'Let''s start by changing the `Platform` struct so that it can hold the bounding
    boxes and a list of the sprites, as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更改`Platform`结构体开始，使其能够持有边界框和精灵列表，如下所示：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While we''re changing `Platform` to make it less specific, we''re also going
    to introduce an optimization: `Platform` will hold the sprite cells instead of
    looking them up every time they are drawn. There are two optimizations here because
    we are also storing the bounding boxes for `Platform` instead of calculating them
    every time they''re created.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在改变`Platform`以使其不那么具体的同时，我们还将引入一个优化：`Platform`将持有精灵单元格而不是每次绘制时都查找它们。这里有两个优化，因为我们还在存储`Platform`的边界框而不是每次创建时都计算它们。
- en: 'This change will break pretty much everything in the implementation of `Platform`,
    most notably the `new` constructor, which will need to take a list of sprite names
    and bounding boxes and then convert the sprite names into cells, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变将几乎破坏`Platform`实现的每一部分，最显著的是`new`构造函数，它需要接受一个精灵名称列表和边界框列表，然后将精灵名称转换为单元格，如下所示：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This isn't the entire `new` method, just the beginning. We started by changing
    the signature so that it takes four parameters. `sheet` and `position` were already
    there but the `new` method now takes a list of sprite names as a reference to
    an array of string slices. You can take a `Vec` of `String` objects, but it's
    a lot nicer to use the reference to string slices because it's much easier to
    call it. Clippy will also object to the code taking a `Vec<String>`, which we
    will cover in [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing,
    Debugging, and Performance*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是`new`方法的全部内容，只是开始。我们首先更改了签名，使其接受四个参数。`sheet`和`position`已经存在，但`new`方法现在接受一个精灵名称列表作为字符串切片数组的引用。你可以取一个`Vec`的`String`对象，但使用字符串切片的引用要方便得多，因为它更容易调用。Clippy也会反对代码接受一个`Vec<String>`，我们将在[*第9章*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203)中介绍，*测试、调试和性能*。
- en: 'The first thing we do in the constructor is to use an iterator to look up every
    `Cell` in the sprite sheet via the `filter_map` call. We use `filter_map` instead
    of `map` because `sheet.cell` can return `None`, so we''ll need to skip any invalid
    sprite names. `filter_map` combines `filter` and `map` to automatically reject
    any options that have a value of `None` but `map` the inner value if it is present.
    The `cloned` method on `Option` will return an `Option<T>` for any `Option<&T>`
    by cloning the inner value. We use this to take ownership of the inner `Cell`.
    Let''s continue with our constructor:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们首先使用迭代器通过`filter_map`调用查找精灵表中的每个`Cell`。我们使用`filter_map`而不是`map`，因为`sheet.cell`可以返回`None`，所以我们需要跳过任何无效的精灵名称。`filter_map`结合了`filter`和`map`，可以自动拒绝任何值为`None`的选项，但如果存在，则映射内部值。`Option`上的`cloned`方法将返回一个`Option<T>`，对于任何`Option<&T>`，它都会克隆内部值。我们使用这个方法来获取内部`Cell`的所有权。让我们继续我们的构造函数：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We continue by taking the passed-in bounding boxes, which are of the `&[Rect]`
    type, and converting them into a `Vec<Rect>` to be owned by the `Platform` struct.
    However, instead of just calling `collect` or `to_owned`, we take each `Rect`
    and adjust its `position` by the actual `position` of `Platform`. So, `bounding_boxes`
    will need to be passed in relative to its image, where the image starts at `(0,0)`.
    Imagine that the image you're drawing is positioned in the top-left corner. The
    bounding boxes are then "drawn" around them, skipping any transparency that's
    relative to the top-left corner. Then, everything is moved to the right spot in
    the game. That's the mental model I use to prevent confusion when I'm specifying
    the bounding boxes later.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续进行，通过接收传入的边界框，这些边界框是`&[Rect]`类型，并将它们转换为`Vec<Rect>`，以便由`Platform`结构体拥有。然而，我们不是简单地调用`collect`或`to_owned`，而是对每个`Rect`进行调整，使其`position`与`Platform`的实际`position`相匹配。因此，`bounding_boxes`需要相对于其图像传入，其中图像从`(0,0)`开始。想象一下你正在绘制的图像位于左上角。然后，在这些图像周围“绘制”边界框，跳过任何相对于左上角的不透明区域。然后，将所有内容移动到游戏中的正确位置。这就是我在指定边界框时防止混淆所使用的心理模型。
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Rust has some pretty good tools for functional-style programming, such as `filter`
    and `map`. It's worth getting to know them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有一些相当不错的工具用于函数式编程风格，如`filter`和`map`。了解它们是值得的。
- en: Tip
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Having four parameters is a lot for a constructor, so you should probably consider
    replacing this code with the `Builder` pattern. We did not do this here because
    it would distract from the topic at hand, but it is a worthwhile code improvement.
    For an example of this, take a look at the unofficial *Rust Design Patterns* book
    here: `https://bit.ly/3GKxMld`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构造函数来说，有四个参数已经很多了，所以你可能需要考虑用`Builder`模式替换这段代码。我们没有在这里这样做，因为这会分散我们对当前主题的关注，但它是一个值得改进的代码。例如，你可以查看这里的非官方*Rust设计模式*书籍：`https://bit.ly/3GKxMld`。
- en: 'You''ll also need to change the function for retrieving `bounding_boxes`, which
    gets a lot smaller:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要更改获取`bounding_boxes`的函数，这将变得很小：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Well, that was a lot easier! Make sure you return a reference to `Vec` and
    not a `Vec`.instance We don''t need to make any more calculations here; `Platform`
    is being passed its bounding boxes. The rest of the implementation for `Platform`
    won''t be so easy, as we''ll need to modify `move_horizontally` and `draw` to
    account for these changes. The change that needs to be made to `move_horizontally`
    is shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这要容易得多！确保你返回`Vec`的引用而不是`Vec`实例。我们在这里不需要进行任何更多的计算；`Platform`正在接收其边界框。对于`Platform`的其余实现来说，不会那么简单，因为我们需要修改`move_horizontally`和`draw`以考虑这些更改。需要修改`move_horizontally`的更改如下所示：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The original code only moved position because `bounding_boxes` was calculated
    on demand. Now that `bounding_boxes` is stored on `Platform`, this needs to be
    adjusted every time we move `Platform`. Otherwise, you'll have images for `Platform`
    in one place, the bounding boxes in another, and very strange bugs. Ask me how
    I know.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 原始代码只移动位置，因为`bounding_boxes`是在需要时计算的。现在`bounding_boxes`存储在`Platform`上，每次我们移动`Platform`时都需要进行调整。否则，你会在一个地方看到`Platform`的图像，在另一个地方看到边界框，并且会出现非常奇怪的错误。问我怎么知道。
- en: 'Finally, let''s update the `draw` function for the new structure. Whereas the
    original implementation assumed that it was three cells wide and looked up each
    cell on each draw, the new implementation will loop through every cell and draw
    it individually. It will also need to account for the width of each cell. So,
    if the cells are `50` pixels wide, then the first cell will be positioned at `0`,
    the second at `50`, and so on:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新 `draw` 函数以适应新的结构。原始实现假设它是三个单元格宽，并且每次绘制时都会查找每个单元格，而新的实现将遍历每个单元格并单独绘制它。它还需要考虑每个单元格的宽度。所以，如果单元格宽度为
    `50` 像素，那么第一个单元格将位于 `0`，第二个位于 `50`，以此类推：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This isn't my favorite code in the world, but it gets the job done. It starts
    by creating a local, temporary `x` that will calculate the offset from `position`
    for each `Cell`. Then, it loops through the sprites, drawing each one but adjusting
    them for both `position` and `x`. Note how, in the destination `Rect`, we advance
    the `x` position with `self.position.x + x`. This ensures each `cell` is drawn
    to the right of the previous one. Finally, we calculate the next `x` position
    based on the width of `cell`. This implementation of `draw` does not use the `destination_box`
    method, which means nobody uses it, and you can safely delete it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是世界上我最喜欢的代码，但它能完成任务。它首先创建一个局部、临时的 `x`，用于计算每个 `Cell` 相对于 `position` 的偏移量。然后，它遍历精灵，绘制每一个，同时调整它们的
    `position` 和 `x`。注意，在目标 `Rect` 中，我们通过 `self.position.x + x` 来推进 `x` 位置。这确保每个 `cell`
    都被绘制在之前的一个右边。最后，我们根据 `cell` 的宽度计算下一个 `x` 位置。这个 `draw` 的实现没有使用 `destination_box`
    方法，这意味着没有人使用它，你可以安全地删除它。
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This code assumes that `width` is variable but `height` is constant and that
    the sprites move from left to right. Here, a two-level platform would need to
    be constructed with two platforms.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码假设 `width` 是可变的，而 `height` 是固定的，并且精灵从左向右移动。在这里，一个两层平台需要用两个平台来构建。
- en: '`Platform` should now work with any list of sprites that we can construct it
    with. Now, all we need to do is initialize `Platform` properly in `WalkTheDog::initialize`,
    as shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Platform` 现在应该可以使用我们可以构造的任何精灵列表来工作。现在，我们只需要在 `WalkTheDog::initialize` 中正确初始化
    `Platform`，如下所示：'
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With that, `Platform` has been created with two more parameters – the list of
    tiles and the list of bounding boxes – making up the platform we've had all along.
    Notice that we can now pass in a simple array of strings for the names of the
    sprites. This is because we accept the `&[&str]` type as a parameter instead of
    a `Vec<String>`. You may be wondering where I got the three bounding box rectangles
    from. After all, previously, we were calculating them in the `bounding_boxes`
    method, using offsets. I simply looked in `tiles.json` and did the math, factoring
    in the offsets we used earlier. These are the same measurements as the bounding
    boxes were when we calculated them. You may also be wondering why these don't
    use constants, especially after I extolled the virtues of using constants in [*Chapter
    5*](B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114), *Collision Detection*. That's
    because we're going to create those in the next section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，`Platform` 已经通过两个额外的参数创建——瓷砖列表和边界框列表——构成了我们一直以来的平台。注意，我们现在可以传递一个简单的字符串数组作为精灵的名称。这是因为我们接受
    `&[&str]` 类型作为参数，而不是 `Vec<String>`。你可能想知道我从哪里得到了三个边界框矩形。毕竟，之前我们在 `bounding_boxes`
    方法中使用偏移量来计算它们。我只是查看了 `tiles.json` 并做了数学计算，考虑到了我们之前使用的偏移量。这些测量值与我们在计算边界框时使用的相同。你可能还想知道为什么这些不使用常量，尤其是在我赞扬了在
    [*第五章*](B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114) *碰撞检测* 中使用常量的优点之后。那是因为我们将在下一节创建它们。
- en: At this point, you should be back to where you started – with RHB waiting to
    jump over a rock. Now, we are ready to create a stream of dynamic segments. At
    the end of the next section, you'll have the constructs you will need for an endless
    runner.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你应该回到了起点——RHB 正在等待跳过一块石头。现在，我们准备创建一系列动态段。在下一个部分的结尾，你将拥有制作无尽跑酷游戏所需的结构。
- en: Creating a dynamic level
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态关卡
- en: 'The initial screen we''ve been looking at for so long, with RHB jumping from
    a stone onto a platform, is what we''re going to call a "segment." It''s not a
    technical term, just a concept we''ve made up for the sake of generating them.
    As RHB moves to the right (that is, when all the obstacles move to the left),
    we''ll generate new segments to the right, which is just off screen. We''ll create
    these as segments so that we can control what is generated and how they fit together.
    Think of it like this: if we generated obstacles at random, then our platforms
    would look messy and would arrange themselves in an unbeatable fashion, like so:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们长时间观察的初始屏幕，其中RHB从一个石头跳到一个平台上，我们将称之为“段”。这不是一个技术术语，而是一个为了生成它们而创造的观念。当RHB向右移动（即，当所有障碍物向左移动时），我们将生成新的段到屏幕右侧，我们将创建这些段，以便我们可以控制生成的内容以及它们如何组合。可以这样想：如果我们随机生成障碍物，那么我们的平台看起来会杂乱无章，并且会以无法击败的方式排列，如下所示：
- en: '![Figure 6.5 – A truly random level](img/Figure_6.05_B17151.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 一个真正的随机关卡](img/Figure_6.05_B17151.jpg)'
- en: Figure 6.5 – A truly random level
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 一个真正的随机关卡
- en: Instead, what we'll do is create a segment where the first one looks exactly
    like our one platform and one rock, and have them string together via a "timeline"
    value that's stored in `Walk`. This timeline will represent the right-hand side
    of the last segment in `x`. As that value gets closer to the edge of the screen,
    we'll generate another new segment and move the timeline back out. With this approach,
    RHB will be able to run for as long as we like, and we will have the freedom of
    a level designer. We will be able to create segments that are both easy and hard
    to navigate, though we'll need to make sure they all interlock and can be beaten.
    This is the fun part!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将创建一个段，第一个段看起来就像我们的一个平台和一个岩石，并通过存储在`Walk`中的“时间线”值将它们连接起来。这个时间线将代表`x`轴上最后一个段的右侧。当这个值接近屏幕边缘时，我们将生成另一个新的段并将时间线移回。采用这种方法，RHB可以运行我们喜欢的时间，我们将拥有关卡设计师的自由。我们将能够创建既容易又难以导航的段，尽管我们需要确保它们都能相互锁合并能被击败。这是最有意思的部分！
- en: Creating one segment
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个段
- en: We'll start by taking the introductory screen and creating it as a segment.
    Let's do this by creating a new file called `segments.rs`, making sure to add
    `mod segments` to the `lib.rs` file. This module isn't created for the typical
    software design reasons; usually, it's because `game.rs` is getting pretty long
    and these segments are closer to being levels than they are true code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个介绍屏幕并将其作为一个段来创建。让我们通过创建一个名为`segments.rs`的新文件来实现这一点，并确保将`mod segments`添加到`lib.rs`文件中。这个模块不是出于典型的软件设计原因而创建的；通常，是因为`game.rs`变得相当长，这些段更接近于关卡而不是真正的代码。
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that `game.rs` can be broken down into a module with separate files
    using a directory with a `mod.rs` file. We're not doing this here because I find
    it gets harder to explain where new code goes – at least in book form – when we
    have a large number of files. If you are comfortable with doing this, then feel
    free to break this down into smaller chunks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`game.rs`可以通过使用包含`mod.rs`文件的目录分解成一个模块，使用单独的文件。我们在这里不这样做，因为我觉得当文件数量较多时，解释新代码的去向变得更加困难——至少在书籍形式中是这样。如果你对此感到舒适，那么请随意将其分解成更小的块。
- en: 'Each segment will be a function that returns a list of obstacles. Let''s create
    a public function in `segments.rs` that returns the same list that the game is
    initialized with:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每个段将是一个返回障碍物列表的函数。让我们在`segments.rs`中创建一个公共函数，它返回游戏初始化时相同的列表：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Look, constants! We want the segments module to look as data-driven as possible,
    so we'll be using constants throughout this file. This section of code doesn't
    compile because the `create_floating_platform` function doesn't exist yet, but
    it does the same things that the corresponding code in the `initialize` method
    of `WalkTheDog` does. The only differences are that it uses the `create_floating_platform`
    function, which doesn't exist, and some constants that also do not exist.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 看，这是常数！我们希望段模块尽可能看起来是数据驱动的，所以我们将在这个文件中使用常数。这段代码无法编译，因为`create_floating_platform`函数还不存在，但它执行的功能与`WalkTheDog`的`initialize`方法中的对应代码相同。唯一的区别是它使用了不存在的`create_floating_platform`函数，以及一些也不存在的常数。
- en: The function itself takes `HtmlImageElement` from `stone` and `Rc<SpriteSheet>`
    to create `Barrier` and `Platform`, respectively, but it also takes an `offset_x
    value`. That's because while the first `Barrier` and `Platform` may be at `150`
    and `200`, respectively, in the future, we'll want those to be that many pixels
    away from the timeline. It returns a vector of obstacles, which we can use in
    the `initialize` method of `WalkTheDog` and anywhere else that we generate segments.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数本身从`stone`中获取`HtmlImageElement`，从`Rc<SpriteSheet>`创建`Barrier`和`Platform`，同时还需要一个`offset_x`值。这是因为虽然第一个`Barrier`和`Platform`可能分别位于`150`和`200`，但在未来，我们希望它们与时间轴的距离是这么多像素。它返回一个障碍物向量，我们可以在`WalkTheDog`的`initialize`方法以及任何其他生成段的地方使用。
- en: Information
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You may have noticed that we used an `Rc` for `SpriteSheet` but just take ownership
    of `HtmlImageElement`, which may need to be cloned when it's called. Nice catch!
    You may wish to consider making `HtmlImageElement` an `Rc` as well. `HtmlImageElement`
    is small enough that it's probably fine if we clone it, but it may be worth investigating
    in [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing, Debugging,
    and Performance*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们为`SpriteSheet`使用了`Rc`，但只是接管了`HtmlImageElement`的所有权，当它被调用时可能需要克隆。这是一个很好的发现！你可能希望考虑将`HtmlImageElement`也改为`Rc`。`HtmlImageElement`足够小，如果我们克隆它，可能就足够了，但在[*第9章*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203)，*测试、调试和性能*中可能值得调查。
- en: 'Let''s continue by creating the function that''s missing – that is, `create_floating_platform`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建缺少的函数——即`create_floating_platform`：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is a pretty small function in that it just delegates to the `Platform`
    constructor and passes along important information. As you can see, there are
    two new constants to go along with the others in `stone_and_platform`. I told
    you that the constants would come back!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当小的函数，因为它只是委托给`Platform`构造函数并传递重要信息。正如你所见，有两个新的常量与`stone_and_platform`中的其他常量一起使用。我告诉你常量会回来的！
- en: Tip
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to use `Rect::new_from_x_y` when you're declaring `FLOATING_PLATFORM_BOUNDING_BOXES`,
    you'll need to declare it and `Rect::new` as `pub const fn`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在声明`FLOATING_PLATFORM_BOUNDING_BOXES`时使用`Rect::new_from_x_y`，你需要将其和`Rect::new`声明为`pub
    const fn`。
- en: The rest of the segments module consists of constants and `use` statements.
    You can infer the values for all the constants from the code we used earlier,
    or just check out [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/blob/chapter_6/src/segments.rs](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/blob/chapter_6/src/segments.rs).
    Reproducing that code here would amount to padding. By putting all the values
    in constants, the code looks increasingly data-driven, with functions just returning
    the data we want for every segment.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`segments`模块的其余部分由常量和`use`语句组成。你可以从我们之前使用的代码中推断出所有常量的值，或者直接查看[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/blob/chapter_6/src/segments.rs](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/blob/chapter_6/src/segments.rs)。在这里重现那段代码将相当于填充。通过将所有值放入常量中，代码看起来越来越数据驱动，函数只是返回我们为每个段想要的数据。'
- en: Tip
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's possible to serialize these segments into JSON using `serde` and then read
    them in from JSON files instead of having the levels be written in Rust code.
    This is an experiment that you can undertake; I prefer the Rust code version.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`serde`可以将这些段序列化为JSON，然后从JSON文件中读取它们，而不是将级别写入Rust代码。这是一个你可以尝试的实验；我更喜欢Rust代码版本。
- en: 'Once you''ve filled in the constants and the `use` statements, you can use
    the new `stone_and_platform` function in the `initialize` method of `WalkTheDog`.
    Yeah, that one again. Let''s replace the hardcoded list of obstacles with a call
    to this new function:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦填写了常量和`use`语句，你就可以在`WalkTheDog`的`initialize`方法中使用新的`stone_and_platform`函数。是的，又是那个。让我们用这个新函数替换硬编码的障碍物列表：
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Make sure you import `stone_and_platform` from `segments`! Now that we've got
    a function to create the initial scene, we can add a timeline and start generating
    scenes again and again. Let's get started.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你从`segments`中导入`stone_and_platform`！现在我们已经有一个创建初始场景的函数，我们可以添加时间轴并反复生成场景。让我们开始吧。
- en: Tip
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may have noticed that this puts a circular dependency between `segments`
    and `game`. You're right. To fix this, take anything that `segments` depends on
    that is in `game` and put it in another module that both `game` and `segments`
    depend on. This has been left as an exercise for you.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这会在`segments`和`game`之间产生一个循环依赖。你说得对。为了解决这个问题，将`segments`所依赖的任何在`game`中的东西放入另一个模块，这个模块同时被`game`和`segments`依赖。这已经被留给你作为一个练习。
- en: Adding a timeline
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加时间线
- en: 'We need to initialize the timeline at the width of a segment. We can calculate
    this by finding the right-most point in the list of obstacles, and we''ll use
    those cool functional constructs we used earlier. This will be a standalone function
    that we can keep in the `game` module, which looks like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在段落的宽度上初始化时间线。我们可以通过找到障碍物列表中的最右端点来计算这个值，我们将使用之前用过的那些酷炫的功能结构。这将是一个独立的函数，我们可以将其保留在`game`模块中，如下所示：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This function goes through a `vec` of `Obstacle` and gets its `right` value.
    Then, it uses the `max_by` function to figure out the maximum value on the right.
    Finally, it uses `unwrap_or` because while `max_by` can technically return `None`,
    if it does that here, then we have completely screwed up and may as well shove
    all the graphics onto the leftmost part of the screen. Now that we have this function,
    we can add a `timeline` value to the `Walk` struct, as shown here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数遍历一个`vec`的`Obstacle`，获取它的`right`值。然后，它使用`max_by`函数来确定右边的最大值。最后，它使用`unwrap_or`，因为虽然`max_by`在技术上可以返回`None`，但如果它在这里这样做，那么我们就完全搞砸了，我们最好把所有图形都推到屏幕的最左边。现在我们有了这个函数，我们可以在`Walk`结构体中添加一个`timeline`值，如下所示：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We also added a reference to `HtmlImageElement` because we''ll need that later.
    We will now initialize `Walk` – yes, we''re back in that function again – with
    `stone` and `timeline`. We''ll have to tweak the code slightly to deal with the
    borrow checker:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了对`HtmlImageElement`的引用，因为我们稍后会需要它。现在，我们将使用`stone`和`timeline`初始化`Walk`——是的，我们又回到了那个函数中——我们将不得不稍微调整代码以处理借用检查器：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we bind `starting_obstacles` and `timeline` before we initialize `Walk`
    since we wouldn't be able to get `timeline` as we've moved `obstacles` already.
    Note how we now clone `stone` when we pass it into `stone_and_platform`. We'll
    need to do this from now on because each `Barrier` obstacle owns an `Image` and,
    ultimately, its `HtmlImageElement`. Finally, we pass `stone` and `timeline` into
    the `Walk` struct. Now that we have a `timeline field` we can update it, by moving
    the rightmost edge of the generated obstacles to the left on each update, and
    respond to it by generating more obstacles as necessary. Our `Canvas` is still
    `600` pixels wide, so let's say that if there are no obstacles at the rightmost
    point past `1000`, we need to generate more.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在初始化`Walk`之前将`starting_obstacles`和`timeline`绑定，因为我们已经移动了`obstacles`，所以无法再获取`timeline`。注意，当我们把`stone`传递给`stone_and_platform`时，我们现在克隆了`stone`。从现在开始，我们需要这样做，因为每个`Barrier`障碍物都拥有一个`Image`，最终是它的`HtmlImageElement`。最后，我们将`stone`和`timeline`传递给`Walk`结构体。现在我们有了`timeline
    field`，我们可以通过将生成的障碍物的最右边向左移动来更新它，并在必要时生成更多的障碍物。我们的`Canvas`仍然是`600`像素宽，所以如果我们发现在`1000`点之后的最右边没有障碍物，我们就需要生成更多的障碍物。
- en: 'These changes belong in the `update` method of `WalkTheDog`, at the end of
    the update logic:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改属于`WalkTheDog`的`update`方法，在更新逻辑的末尾：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: After moving the obstacles, we check whether `walk.timeline` is `< TIMELINE_MINIMUM`,
    which is set to `1000` at the top of the module. If it is, we create another `stone_and_platform`
    segment at `walk.timeline + OBSTACLE_BUFFER`, which is another constant that's
    set to `20`. Why `20`? We needed a little buffer to make sure the segments weren't
    right on top of each other, and `20` seemed fine. You could use a larger number
    or none at all. Then, we update `walk.timeline` to the `rightmost` point of the
    new obstacles, and we append those obstacles to the list, ready to be drawn.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动障碍物之后，我们检查`walk.timeline`是否小于`TIMELINE_MINIMUM`，它在模块顶部被设置为`1000`。如果是，我们在`walk.timeline
    + OBSTACLE_BUFFER`处创建另一个`stone_and_platform`段，`OBSTACLE_BUFFER`是一个常量，被设置为`20`。为什么是`20`？我们需要一点缓冲区来确保段之间不会完全重叠，`20`看起来是合适的。你可以使用更大的数字或者根本不用。然后，我们将`walk.timeline`更新为新障碍物的最右边，并将这些障碍物添加到列表中，准备绘制。
- en: 'If `walk.timeline` is beyond `TIMELINE_MINIMUM`, we simply decrease it by RHB''s
    walking speed until the next update. Upon adding this code, you should see something
    similar to the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`walk.timeline`超过了`TIMELINE_MINIMUM`，我们只需将其减少到RHB的行走速度，直到下一次更新。添加此代码后，你应该会看到以下类似的内容：
- en: '![Figure 6.6 – As one platform ends, another beckons](img/Figure_6.06_B17151.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 当一个平台结束时，另一个平台在召唤](img/Figure_6.06_B17151.jpg)'
- en: Figure 6.6 – As one platform ends, another beckons
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 当一个平台结束时，另一个平台在召唤
- en: That's right – you have an endless runner! So, how come we're only halfway through
    this book? Well, our runner is a little dull, seeing as it only has the same two
    objects over and over again. How about we add some randomness and creativity with
    multiple segments?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 没错 – 你有一个无尽跑酷游戏！那么，我们怎么只读到这本书的一半呢？嗯，我们的跑酷者有点无聊，因为它只是反复出现同样的两个物体。我们不妨用多个段落增加一些随机性和创意，怎么样？
- en: Creating segments
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建段落
- en: 'Creating random segments means using the random library to choose a different
    segment each time one is needed. Let''s start by extracting the code we wrote
    previously into a function, as shown here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建随机段落意味着使用随机库在每次需要时选择不同的段落。让我们首先将之前编写的代码提取到一个函数中，如下所示：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Information
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: '`WalkTheDog` has a bad case of `WalkTheDog` and into `Walk`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`WalkTheDog`有一个严重的`WalkTheDog`病例，并且进入了`Walk`。'
- en: 'Now that `Walk` can generate the next segment, we''ll use the `random` crate
    from [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015), *Hello WebAssembly*,
    to choose the next segment. Of course, we only have one segment, so that won''t
    mean much. It looks like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Walk`可以生成下一个段落，我们将使用来自[*第1章*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015)，“Hello
    WebAssembly”，的`random` crate来选择下一个段落。当然，我们只有一个段落，所以这不会意味着太多。它看起来是这样的：
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Don''t forget to add `use rand::prelude::*;` at the top of the file. This generates
    a random number between `0` and, well, `0`. Then, it matches that value and generates
    the selected segment, which in this case will always be `stone_and_platform`.
    There''s a default case here, but that''s just to quiet the compiler – it can''t
    happen. I''ll create a second segment called `platform_and_stone` that is the
    same as the first one except it flips the position of `stone` and `platform`,
    and then puts the platform higher by using the `HIGH_PLATFORM` constant we created
    earlier. Now, the `generate_next_segment` function looks like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在文件顶部添加`use rand::prelude::*;`。这将在`0`和，嗯，`0`之间生成一个随机数。然后，它匹配那个值并生成所选段落，在这种情况下，将始终是`stone_and_platform`。这里有一个默认情况，但这只是为了让编译器安静下来
    – 它不会发生。我将创建第二个名为`platform_and_stone`的段落，它与第一个相同，除了它翻转了`stone`和`platform`的位置，然后使用我们之前创建的`HIGH_PLATFORM`常量将平台提高。现在，`generate_next_segment`函数看起来是这样的：
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here, you can see that I get two segments, both of which are called in the
    same way. Make sure `gen_range` now generates a number from `0` to `2`. Upon running
    this code, I get to see a new segment:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我得到了两个段落，它们都以相同的方式被调用。确保`gen_range`现在生成一个从`0`到`2`的数字。运行此代码后，我可以看到一个新的段落：
- en: '![Figure 6.7 – Who moved that rock?](img/Figure_6.07_B17151.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 谁动了那块石头？](img/Figure_6.07_B17151.jpg)'
- en: Figure 6.7 – Who moved that rock?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 谁动了那块石头？
- en: 'If you try to copy/paste the preceding code, it won''t work since you don''t
    have `platform_and_stone`. This hasn''t been included here because you have all
    the knowledge you need to create your *own* segments. You can start by copying/pasting
    `stone_and_platform` and tweaking its values. Then, you can try creating platforms
    with the sprite sheet. Remember that you''re not limited to just the three images
    in our sprite sheet. The entire sheet looks like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试复制/粘贴前面的代码，它将不会工作，因为你没有`platform_and_stone`。这没有包括在这里，因为你已经拥有了创建你自己的*段落*所需的所有知识。你可以从复制/粘贴`stone_and_platform`并调整其值开始。然后，你可以尝试使用精灵图集创建平台。记住，你不仅限于我们精灵图集中的三个图像。整个图集看起来是这样的：
- en: '![Figure 6.8 – The sprite sheet](img/Figure_6.08_B17151.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 精灵图集](img/Figure_6.08_B17151.jpg)'
- en: Figure 6.8 – The sprite sheet
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 精灵图集
- en: You can use this to make larger platforms, steps, and even cliffs. Try making
    a few different shapes. Try making smaller platforms by skipping the middle tile
    in the platform we've been using. RHB can slide; can you make something for him
    to slide under?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这个来制作更大的平台、阶梯，甚至是悬崖。试着制作几种不同的形状。试着通过跳过我们一直在使用的平台中的中间瓷砖来制作更小的平台。RHB可以滑动；你能为他制作一个可以滑下的东西吗？
- en: For a real challenge, take a look at the water sprites. Currently, RHB can't
    fall through the ground since we're using a `FLOOR` variable, but what if we didn't?
    Could RHB drown? Fall off a cliff, perhaps? It's time to become a game designer!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个真正的挑战，看看水精灵。目前，RHB不能穿过地面，因为我们使用了`FLOOR`变量，但如果我们不使用它呢？RHB会淹死吗？从悬崖上掉下来吗？是时候成为一个游戏设计师了！
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It's time for a confession. If you're like me, a programmer, that means you're
    probably sitting in a room with a bunch of books like this one behind you. Of
    those books, you've probably only opened half of them, and you've probably only
    read one or two of them cover-to-cover. Harry Potter notwithstanding.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候坦白了。如果你像我一样，是一个程序员，这意味着你可能坐在一个房间里，背后堆满了像这样的一堆书。在那堆书中，你可能只打开了一半，而且你可能只从头到尾读了一本或两本。不包括《哈利·波特》在内。
- en: Great news! At this point, you've made an endless runner. It's got no sound,
    the collision boxes are pretty big (have you tried to go under a platform yet?),
    and there's no menu system, but at this point, you have a game. You have the skeleton
    to make it more fun as you play around, and you're welcome to use this to make
    even larger or completely different endless runners. I wouldn't hold it against
    you if you stopped following along at this point, because you've learned a ton.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！到目前为止，你已经制作了一个无尽跑酷游戏。它没有声音，碰撞框相当大（你尝试过从平台下穿过吗？），而且没有菜单系统，但到目前为止，你已经有一个游戏了。你可以通过在游戏中探索来让它更有趣，你也可以使用这个基础来制作更大或完全不同的无尽跑酷游戏。如果你在这个时候停止跟随，我不会怪你，因为你已经学到了很多。
- en: But if you do decide to stick around for the next chapter, we'll be adding a
    requirement for immersion that's required for any game – *sound*. Don't you want
    to hear what RHB sounds like?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你决定留下来阅读下一章，我们将增加一个对任何游戏都必需的沉浸式体验要求——*声音*。难道你不想听听RHB的声音吗？
