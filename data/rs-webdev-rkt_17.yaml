- en: '*Chapter 14*: Building a Full Stack Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：构建全栈应用程序'
- en: In this chapter, we are going to learn how to build a simple WebAssembly application
    and use Rocket to serve the WebAssembly application. We are going to make WebAssembly
    load the user information from one of the endpoints that we created earlier. After
    learning the information in this chapter, you will be able to write and build
    a WebAssembly application using Rust. You will learn how to serve WebAssembly
    using the Rocket web framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何构建一个简单的WebAssembly应用程序，并使用Rocket来提供WebAssembly应用程序。我们将使WebAssembly从我们之前创建的一个端点中加载用户信息。学习本章中的信息后，您将能够使用Rust编写和构建WebAssembly应用程序。您将学习如何使用Rocket网络框架提供WebAssembly。
- en: 'In this chapter, we are going to cover these main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing WebAssembly
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍WebAssembly
- en: Setting up a Cargo workspace
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Cargo工作区
- en: Setting a WebAssembly build target
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置WebAssembly构建目标
- en: Writing a WebAssembly application using Yew
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Yew编写WebAssembly应用程序
- en: Serving a WebAssembly application using Rocket
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rocket提供WebAssembly应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are very simple: the Rust compiler,
    the Cargo command line, and a web browser.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求非常简单：Rust编译器、Cargo命令行和一个网页浏览器。
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14)找到本章的代码。
- en: Introducing WebAssembly
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WebAssembly
- en: In the past, almost all applications in the web browser were made using the
    JavaScript language. There were also attempts to use different languages in the
    web browser, such as Java Applet, Adobe Flash, and Silverlight. But, all those
    different attempts were not web standards, and, therefore, the adoption of those
    attempts was not as universal as JavaScript.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，几乎所有的网页浏览器应用程序都是使用JavaScript语言制作的。也有尝试在网页浏览器中使用不同语言的情况，例如Java Applet、Adobe
    Flash和Silverlight。但是，所有这些不同的尝试都不是网络标准，因此这些尝试的采用并没有像JavaScript那样普遍。
- en: 'However, there is a way to use other programming languages in the web browser:
    by using **WebAssembly**. WebAssembly is both a binary executable format and its
    corresponding text format for a stack-based virtual machine. Web browsers that
    support WebAssembly can execute the binary executable format. Any programming
    language that can be compiled into WebAssembly can be executed by web browsers.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种方法可以在网页浏览器中使用其他编程语言：通过使用**WebAssembly**。WebAssembly既是一种二进制可执行格式，也是对应于基于栈的虚拟机的文本格式。支持WebAssembly的网页浏览器可以执行二进制可执行格式。任何可以编译成WebAssembly的编程语言都可以由网页浏览器执行。
- en: In 2015, WebAssembly was announced and was first released in March 2017\. All
    major web browser vendors finished the release of browsers with minimum support
    for WebAssembly in September 2017, and then World Wide Web Consortium recommended
    WebAssembly on December 5th, 2019\.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，WebAssembly被宣布，并于2017年3月首次发布。所有主要的网页浏览器供应商都在2017年9月完成了对至少支持WebAssembly的浏览器的发布，然后万维网联盟于2019年12月5日推荐了WebAssembly。
- en: Compiled languages such as C++ or Rust can be compiled into a `.wasm` file,
    and a virtual machine in the browser can then run the WebAssembly file. To run
    interpreted languages, first, the language runtime can be compiled into a `.wasm`
    file, and then, the runtime can run the runtime scripts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于C++或Rust这样的编译型语言可以被编译成`.wasm`文件，然后浏览器中的虚拟机可以运行WebAssembly文件。要运行解释型语言，首先，语言运行时可以被编译成`.wasm`文件，然后运行时可以运行运行时脚本。
- en: '![Figure 14.1 ‒ Interpreted languages and compiled languages in WebAssembly'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1 - WebAssembly中的解释型语言和编译型语言'
- en: '](img/Figure_14.1_B16825.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.1_B16825.jpg)'
- en: Figure 14.1 ‒ Interpreted languages and compiled languages in WebAssembly
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 - WebAssembly中的解释型语言和编译型语言
- en: The Rust programming language supports WebAssembly, and as we have already learned
    about Rust and created a backend application using Rust and Rocket, we can take
    this opportunity to learn a little about frontend application development using
    Rust. The old web standards and web technologies, such as HTML, CSS, and JavaScript,
    are technologies that changed the course of human history. Learning about new
    web standards, such as WebAssembly, is a good opportunity to be a part of future
    development.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编程语言支持 WebAssembly，而且我们已经学习了 Rust 并使用 Rust 和 Rocket 创建了一个后端应用程序，我们可以利用这个机会学习一点使用
    Rust 开发前端应用程序。旧的网络标准和网络技术，如 HTML、CSS 和 JavaScript，是改变了人类历史进程的技术。了解新的网络标准，如 WebAssembly，是成为未来开发一部分的好机会。
- en: Let's implement a page in our application where we will render an empty template.
    The template will load WebAssembly binary from the server. WebAssembly will call
    the user API endpoint that we created earlier. It will then render users using
    a custom component.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中实现一个页面，我们将渲染一个空模板。模板将从服务器加载 WebAssembly 二进制文件。WebAssembly 将调用我们之前创建的用户
    API 端点。然后，它将使用自定义组件渲染用户。
- en: For the implementation, we are going to use Yew ([https://yew.rs](https://yew.rs)),
    which is a frontend Rust framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现，我们将使用 Yew ([https://yew.rs](https://yew.rs))，这是一个前端 Rust 框架。
- en: Setting up a Cargo workspace
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Cargo 工作区
- en: Since we are going to create a new application, it would be nice if we could
    make the code for the `our_application` Rocket application work alongside this
    new application. Cargo has a feature called **Cargo workspaces**. A Cargo workspace
    is a set of different Cargo packages in a single directory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们即将创建一个新的应用程序，如果我们能让 `our_application` Rocket 应用程序的代码与这个新应用程序一起工作那就很好了。Cargo
    有一个名为 **Cargo 工作区** 的功能。Cargo 工作区是在单个目录中包含多个 Cargo 包的集合。
- en: 'Let''s set up a Cargo workspace to have multiple applications in a single directory
    using the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤设置一个 Cargo 工作区，以便在单个目录中拥有多个应用程序：
- en: Create a directory, for example, `01Wasm`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录，例如，`01Wasm`。
- en: Move the `our_application` directory inside the `01Wasm` directory and create
    a new `Cargo.toml` file inside the `01Wasm` directory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `our_application` 目录移动到 `01Wasm` 目录内，并在 `01Wasm` 目录内创建一个新的 `Cargo.toml` 文件。
- en: 'Edit the `Cargo.toml` file as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式编辑 `Cargo.toml` 文件：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new Rust application inside `01Wasm` using this command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `01Wasm` 内使用以下命令创建一个新的 Rust 应用程序：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, add the new application as a member of the workspace in `01Wasm/Cargo.toml`,
    as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将新应用程序添加到 `01Wasm/Cargo.toml` 中的工作区成员，如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Try building both applications using this command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令尝试构建这两个应用程序：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To build or run one of the applications, append `--bin` with the binary package
    name, or `--lib` with the library package name. To run the application, consider
    the location of the directories required for running the Rocket application. For
    example, if there's no logs directory, the application might fail to run. Also,
    if there's no static directory, the application might not be able to find the
    assets file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建或运行其中一个应用程序，请使用二进制包名称添加 `--bin`，或使用库包名称添加 `--lib`。要运行应用程序，请考虑运行 Rocket 应用程序所需的目录位置。例如，如果没有日志目录，应用程序可能无法运行。此外，如果没有静态目录，应用程序可能无法找到资产文件。
- en: 'Try building one of the applications by running this command in the terminal:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行此命令尝试构建其中一个应用程序：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have set up the Cargo workspace, we can learn how to build the application
    for a different target specifically for WebAssembly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 Cargo 工作区，我们可以学习如何为不同的目标构建应用程序，特别是针对 WebAssembly 的应用程序。
- en: Setting a WebAssembly build target
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 WebAssembly 构建目标
- en: The Rust compiler can be set to compile to a different architecture. The architectures
    are also called `x86_64-unknown-linux_gnu` and `x86_64-apple-darwin`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器可以设置为编译到不同的架构。这些架构也称为 `x86_64-unknown-linux_gnu` 和 `x86_64-apple-darwin`。
- en: 'Targets can be categorized into three tiers, tier 1, tier 2, and tier 3:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目标可以分为三个级别，一级、二级和三级：
- en: '**Tier 1** means that the target is guaranteed to work properly.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一级**意味着目标保证能够正常工作。'
- en: '**Tier 2** means that the target is guaranteed to build but, sometimes, the
    automated test to build the binary for the targets may not pass. The host tools
    and full standard library for this tier are also supported.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二级**意味着目标保证能够构建，但有时为这些目标构建的二进制文件的自动化测试可能不会通过。此级别的宿主工具和完整标准库也得到支持。'
- en: '**Tier 3** means that the Rust code base supports some features of the targets.
    The build for those targets may or may not exist, and the tooling might not be
    complete.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tier 3**表示Rust代码库支持目标的一些功能。为这些目标构建可能存在也可能不存在，并且工具可能不完整。'
- en: Remember that WebAssembly is a binary format for a virtual machine. The Rust
    compiler has targets for the virtual machine specifications, such as `asmjs-unknown-emscripten`,
    `wasm32-unknown-emscripten`, or `wasm32-unknown-unknown`. The community mostly
    supports the tooling around `wasm32-unknown-unknown`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，WebAssembly是一个虚拟机的二进制格式。Rust编译器有针对虚拟机规范的target，例如`asmjs-unknown-emscripten`、`wasm32-unknown-emscripten`或`wasm32-unknown-unknown`。社区主要支持围绕`wasm32-unknown-unknown`的工具。
- en: 'To see the available target list for the Rust compiler, run the following command
    in the terminal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Rust编译器的可用目标列表，请在终端中运行以下命令：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To add WebAssembly target support for the Rust compiler, run the following
    command in the terminal:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Rust编译器添加WebAssembly目标支持，请在终端中运行以下命令：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After adding the target, try building `our_application_wasm` by running this
    command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 添加目标后，通过运行此命令尝试构建`our_application_wasm`：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will use `wasm32-unknown-unknown` to build the WebAssembly application in
    the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用`wasm32-unknown-unknown`来构建WebAssembly应用程序。
- en: Writing a WebAssembly application using Yew
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Yew编写WebAssembly应用程序
- en: In the application, we are going to use Yew (https://yew.rs). On the website,
    it says that Yew is a modern Rust framework for creating multithreaded frontend
    web apps.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，我们将使用Yew（https://yew.rs）。在网站上，它说Yew是一个用于创建多线程前端Web应用程序的现代Rust框架。
- en: 'Cargo can compile the WebAssembly binary, but the WebAssembly binary itself
    is not usable without other steps. We have to load the WebAssembly binary in the
    web browser''s virtual machine engine. There are proposals such as using a `<script
    type="module"></script>` tag, but unfortunately, those proposals are not standard
    yet. We have to tell JavaScript to load the module using the WebAssembly Web API.
    To make the development easier, we can use `wasm-pack` from the Rust WebAssembly
    working group at https://rustwasm.github.io/. Yew uses an application named `trunk`
    (https://trunkrs.dev) that wraps `wasm-pack` and provides other conveniences.
    Install `trunk` by using this command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo可以编译WebAssembly二进制文件，但如果没有其他步骤，WebAssembly二进制文件本身是不可用的。我们必须在Web浏览器的虚拟机引擎中加载WebAssembly二进制文件。有一些提议，例如使用`<script
    type="module"></script>`标签，但不幸的是，这些提议还没有成为标准。我们必须告诉JavaScript使用WebAssembly Web
    API来加载模块。为了使开发更容易，我们可以使用来自Rust WebAssembly工作组（https://rustwasm.github.io/）的`wasm-pack`。Yew使用一个名为`trunk`（https://trunkrs.dev）的应用程序，它封装了`wasm-pack`并提供其他便利。使用以下命令安装`trunk`：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that the preparation for compiling WebAssembly has been completed, we can
    write the code for the WebAssembly application. Follow these steps to create the
    application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译WebAssembly的准备已经完成，我们可以为WebAssembly应用程序编写代码。按照以下步骤创建应用程序：
- en: 'Create an HTML file named `index.html` inside the `our_application_wasm` directory.
    We will use this HTML file to mimic the template on `our_application`, with small
    differences. We want to add an ID for an HTML tag to be the main tag for the WebAssembly
    application. Let''s name this ID `main_container`. Append the following lines
    to `our_application_wasm/index.html`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`our_application_wasm`目录内创建一个名为`index.html`的HTML文件。我们将使用此HTML文件来模拟`our_application`上的模板，但有细微差别。我们希望为HTML标签添加一个ID，使其成为WebAssembly应用程序的主要标签。让我们称这个ID为`main_container`。将以下行追加到`our_application_wasm/index.html`：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add `yew` as a dependency to `our_application_wasm`. We also want to access
    the browser DOM, so we need another dependency. Gloo ([https://gloo-rs.web.app/](https://gloo-rs.web.app/))
    provides bindings to the Web API, and we want to use `gloo_utils` as a dependency
    for our WebAssembly application to access the DOM. Add the following dependencies
    to `our_application_wasm/Cargo.toml`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`yew`作为依赖项添加到`our_application_wasm`中。我们还想访问浏览器DOM，因此需要另一个依赖项。Gloo ([https://gloo-rs.web.app/](https://gloo-rs.web.app/))提供了对Web
    API的绑定，我们希望将`gloo_utils`作为我们的WebAssembly应用程序的依赖项来访问DOM。将以下依赖项添加到`our_application_wasm/Cargo.toml`中：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the required `use` declarations in `our_application_wasm/src/main.rs`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`our_application_wasm/src/main.rs`中添加所需的`use`声明：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a minimal component that creates an empty HTML inside `our_application_wasm/src/main.rs`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`our_application_wasm/src/main.rs`中创建一个最小的组件，创建一个空的HTML：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use `gloo_utils` in the `main()` function in `our_application_wasm/src/main.rs`
    to select the `div` tag with the `main_container` ID. Append the following lines
    in the `main()` function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`our_application_wasm/src/main.rs`的`main()`函数中使用`gloo_utils`选择具有`main_container`
    ID的`div`标签。在`main()`函数中追加以下行：
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Initialize a Yew application by appending this line to the `main()` function:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将此行添加到`main()`函数来初始化Yew应用程序：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can use `trunk` to create a small web server and build everything needed
    to build the WebAssembly and related JavaScript to load the WebAssembly and serve
    the HTML. Run this command in the terminal inside the `our_application_wasm` directory:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`trunk`创建一个小的Web服务器，构建构建WebAssembly和相关JavaScript所需的一切，以加载WebAssembly并服务HTML。在`our_application_wasm`目录内的终端中运行以下命令：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There should be an output like the following in the terminal:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 终端中应该有如下输出：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Try opening a web browser to `http://127.0.0.1:8080`; you''ll see that it loads
    and runs the Yew WebAssembly application:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试打开一个网络浏览器到`http://127.0.0.1:8080`；你会看到它加载并运行Yew WebAssembly应用程序：
- en: '![Figure 14.2 ‒ Hello WebAssembly!'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2 - Hello WebAssembly！'
- en: '](img/Figure_14.2_B16825.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.2_B16825.jpg)'
- en: Figure 14.2 ‒ Hello WebAssembly!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 - Hello WebAssembly！
- en: 'We are going to get users'' information using an API endpoint that returns
    the JSON that we created earlier in `our_application` from `http://127.0.0.1:8000/api/users`.
    To convert the JSON into Rust types, let''s define similar types to those in `our_application`.
    The types should derive SerDes'' `deserialize`. In `our_application_wasm/Cargo.toml`,
    add the dependencies for the WebAssembly code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个API端点来获取用户信息，该端点返回我们在`our_application`中之前创建的JSON，从`http://127.0.0.1:8000/api/users`。要将JSON转换为Rust类型，让我们定义与`our_application`中相似的类型。这些类型应该派生自SerDes的`deserialize`。在`our_application_wasm/Cargo.toml`中，添加WebAssembly代码的依赖项：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in `our_application_wasm/src/main.rs`, add the required `use` declarations:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`our_application_wasm/src/main.rs`中添加所需的`use`声明：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, add the types to deserialize the JSON:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加用于反序列化JSON的类型：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: One thing that we can do to improve redefining the types is to create a library
    that defines types that can be used by both applications.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了改进重新定义类型，我们可以创建一个库，该库定义的类型可以由两个应用程序使用。
- en: 'If we look at the `User` struct, we can see that the description field is an
    `Option`. Create a convenience function to return an empty `String` if the value
    is `None`, and return the `String` content of `Some` if the value is `Some`. Add
    the following function to `our_application_wasm/src/main.rs`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看`User`结构体，我们可以看到描述字段是一个`Option`。创建一个便利函数，如果值是`None`，则返回一个空`String`，如果值是`Some`，则返回`String`的内容。将以下函数添加到`our_application_wasm/src/main.rs`：
- en: '[PRE20]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It''s now time to implement a component that will render `User`. We will name
    the component `UsersList`. Add the following function to `our_application_wasm/src/main.rs`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候实现一个将渲染`User`的组件了。我们将该组件命名为`UsersList`。将以下函数添加到`our_application_wasm/src/main.rs`：
- en: '[PRE21]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that the `html!` macro content looks like the content of `our_application/src/views/users/_user.html.tera`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`html!`宏的内容看起来像`our_application/src/views/users/_user.html.tera`的内容。
- en: 'We want to load the `User` data from the API endpoint. We can do this by using
    two libraries, `reqwasm` (which provides HTTP request functionality), and `wasm-bindgen-futures`
    (which converts Rust `futures` into JavaScript `promise` and vice versa). Add
    the following dependencies to `our_application_wasm/Cargo.toml`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望从API端点加载`User`数据。我们可以通过使用两个库来实现这一点，`reqwasm`（它提供HTTP请求功能），以及`wasm-bindgen-futures`（它将Rust
    `futures`转换为JavaScript `promise`和反之亦然）。将以下依赖项添加到`our_application_wasm/Cargo.toml`：
- en: '[PRE22]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `our_application_wasm/src/main.rs`, add a `const` for our API endpoint.
    Add the following line:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`our_application_wasm/src/main.rs`中，为我们的API端点添加一个`const`。添加以下行：
- en: '[PRE23]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Implement the routine to fetch the `User` data. Add the required `use` declaration:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现获取`User`数据的例程。添加所需的`use`声明：
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, append the following lines inside the `app()` function in `our_application_wasm/src/main.rs`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`our_application_wasm/src/main.rs`中的`app()`函数内追加以下行：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Below the `{}` block under the `users_wrapper` fetching, set the value for
    `next` and `limit`. Append the following lines:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`users_wrapper`获取下的`{}`块中，设置`next`和`limit`的值。追加以下行：
- en: '[PRE26]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Change the HTML from `Hello WebAssembly!` to show the proper `User` information.
    We want to use the `UsersList` component that we created earlier. Change the `html!`
    macro content into the following:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HTML从`Hello WebAssembly!`更改为显示正确的`User`信息。我们希望使用我们之前创建的`UsersList`组件。将`html!`宏内容更改为以下内容：
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build the `our_application_wasm` WebAssembly and JavaScript by running this
    command in the terminal:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端运行此命令来构建 `our_application_wasm` WebAssembly 和 JavaScript：
- en: '[PRE28]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The command should generate three files in the `dist` directory: `index.html`,
    a WebAssembly file with random name, and a JavaScript file with random name. The
    example of random WebAssembly and JavaScript file are `index-9eb0724334955a2a_bg.wasm`
    and `index-9eb0724334955a2a.js` in the `dist` directory.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应在 `dist` 目录中生成三个文件：`index.html`、一个具有随机名称的 WebAssembly 文件和一个具有随机名称的 JavaScript
    文件。`dist` 目录中随机 WebAssembly 和 JavaScript 文件的示例是 `index-9eb0724334955a2a_bg.wasm`
    和 `index-9eb0724334955a2a.js`。
- en: At this point, we have successfully written and built a WebAssembly application.
    In the next section, we are going to learn how to serve a WebAssembly application
    using Rocket.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功编写并构建了一个 WebAssembly 应用程序。在下一节中，我们将学习如何使用 Rocket 服务 WebAssembly
    应用程序。
- en: Serving a WebAssembly application using Rocket
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rocket 服务 WebAssembly 应用程序
- en: 'In this section, we are going to serve the WebAssembly web application using
    the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将按照以下步骤使用以下步骤来服务 WebAssembly 网络应用程序：
- en: To run the WebAssembly file in `our_application`, we have to modify `our_application`
    a little bit. First, copy the WebAssembly and the JavaScript from `our_application_wasm/dist`
    to the `our_application/static` directory.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 `our_application` 中运行 WebAssembly 文件，我们需要对 `our_application` 进行一点修改。首先，将
    WebAssembly 和 JavaScript 从 `our_application_wasm/dist` 复制到 `our_application/static`
    目录。
- en: 'Edit the template to be able to selectively use WebAssembly in `our_application/src/views/template.html.tera`
    as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑模板以能够选择性地在 `our_application/src/views/template.html.tera` 中使用 WebAssembly，如下所示：
- en: '[PRE29]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add a new template file named `our_application/src/views/users/wasm.html.tera`.
    Edit the file in order to make sure the HTML file loads the necessary WebAssembly
    and JavaScript file, and run the WebAssembly on the right DOM. Add the following
    lines:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `our_application/src/views/users/wasm.html.tera` 的新模板文件。编辑文件以确保 HTML
    文件加载必要的 WebAssembly 和 JavaScript 文件，并在正确的 DOM 上运行 WebAssembly。添加以下行：
- en: '[PRE30]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a new route handling function to load just the generated HTML. Add the
    following function in `our_application/src/routes/user.rs`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的路由处理函数来加载生成的 HTML。在 `our_application/src/routes/user.rs` 中添加以下函数：
- en: '[PRE31]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, don''t forget to load the route. Add the new route in `our_application/src/lib.rs`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，别忘了加载路由。在 `our_application/src/lib.rs` 中添加新路由：
- en: '[PRE32]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the `our_application` web server by running `cargo run` in the `our_application`
    directory, and then open `http://127.0.0.1:8000/users/wasm` in the web browser.
    If we inspect the web browser developer tools, we can see that the web browser
    runs the JavaScript and WebAssembly, as shown in the following screenshot:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `our_application` 目录中运行 `cargo run` 来运行 `our_application` 网络服务器，然后在网页浏览器中打开
    `http://127.0.0.1:8000/users/wasm`。如果我们检查网页浏览器开发者工具，我们可以看到网页浏览器运行了 JavaScript
    和 WebAssembly，如下面的截图所示：
- en: '![Figure 14.3 ‒ Web browser loading and running our_application_wasm'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.3 - 网页浏览器加载和运行 our_application_wasm'
- en: '](img/Figure_14.3_B16825.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.3_B16825.jpg)'
- en: Figure 14.3 ‒ Web browser loading and running our_application_wasm
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 - 网页浏览器加载和运行 our_application_wasm
- en: WebAssembly should run properly by modifying the tag with the `main_container`
    tag, then loading the JSON from `http://127.0.0.1:8000/api/users` and rendering
    the HTML in the web browser properly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改带有 `main_container` 标签的标签，然后从 `http://127.0.0.1:8000/api/users` 加载 JSON
    并在网页浏览器中正确渲染 HTML，WebAssembly 应该可以正常运行。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Web technology has evolved to allow web browsers to run a universal binary format
    for a virtual machine. Web browsers can now run a binary generated by the Rust
    compiler.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网技术已经发展到允许网络浏览器运行虚拟机的通用二进制格式。现在，网络浏览器可以运行由 Rust 编译器生成的二进制文件。
- en: In this chapter, we have looked at an overview of WebAssembly, and how to prepare
    the Rust compiler to compile to WebAssembly. We also learned how to set up a Cargo
    workspace to have more than one application in a single directory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了 WebAssembly，以及如何准备 Rust 编译器以编译到 WebAssembly。我们还学习了如何设置 Cargo 工作区，以便在单个目录中拥有多个应用程序。
- en: We then learned how to write a simple frontend application that loads the `User`
    data from the `our_application` API endpoint that we created earlier using Yew
    and other Rust libraries.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何编写一个简单的前端应用程序，该应用程序使用 Yew 和其他 Rust 库从我们之前创建的 `our_application` API
    端点加载 `User` 数据。
- en: Finally, we finished with how to serve the generated WebAssembly and JavaScript
    in the `our_application` web server.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了如何在 `our_application` 网络服务器中服务生成的 WebAssembly 和 JavaScript。
- en: The next chapter is the final chapter, and we're going to see how we can expand
    the Rocket application and find alternatives to it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是最后一章，我们将探讨如何扩展Rocket应用并寻找其替代方案。
