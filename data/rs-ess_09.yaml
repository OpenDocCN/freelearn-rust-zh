- en: Chapter 9. Programming at the Boundaries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。边界编程
- en: In this chapter, we look at how we can start up a Rust program with command-line
    parameters. Then, we go on to look at situations where we have to leave the safety
    boundaries, such as when interfacing with C programs, and how Rust minimizes potential
    dangers when doing so.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用命令行参数启动 Rust 程序。然后，我们将探讨我们必须离开安全边界的情况，例如与 C 程序接口，以及 Rust 在这样做时如何最小化潜在的危险。
- en: 'We will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下主题：
- en: Program arguments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序参数
- en: Unsafe code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全代码
- en: Raw pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始指针
- en: Interfacing with C
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 C 接口
- en: Inlining assembly code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联汇编代码
- en: Calling Rust from other languages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他语言调用 Rust
- en: Program arguments
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序参数
- en: 'Reading program parameters from the command line at startup is easy in Rust;
    just use the `std::env::args()` method. We can collect these parameters into a
    vector of `String` like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，从启动时读取命令行参数很容易；只需使用 `std::env::args()` 方法。我们可以将这些参数收集到一个 `String` 向量中，如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Call the program in the following format:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下格式调用程序：
- en: '`arguments arg1 arg2` on Windows'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments arg1 arg2` 在 Windows 上'
- en: '`./arguments arg1 arg2` on Linux and Mac OS X'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./arguments arg1 arg2` 在 Linux 和 Mac OS X 上'
- en: 'The following is the output from a real call:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从实际调用中得到的输出：
- en: '![Program arguments](img/image00185.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![程序参数](img/image00185.jpeg)'
- en: The program's name is `args[0]`; the next arguments are the command-line parameters.
    We can iterate through the arguments or access them by index. The number of parameters
    is given by `args.len() – 1`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序名称是 `args[0]`；下一个参数是命令行参数。我们可以遍历这些参数或通过索引访问它们。参数的数量由 `args.len() – 1` 给出。
- en: For more complex parsing with options and flags, use the `getopts` or `docopt`
    crate. To get started, there is an example at [http://rustbyexample.com](http://rustbyexample.com).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的带有选项和标志的解析，请使用 `getopts` 或 `docopt` crate。要开始，请参阅 [http://rustbyexample.com](http://rustbyexample.com)
    上的示例。
- en: 'Now, `env::vars()` returns the operating system''s environment variables:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`env::vars()` 返回操作系统的环境变量：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This starts with printing out the following on Windows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，首先会打印出以下内容：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unsafe code
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全代码
- en: 'There are situations in which even the Rust compiler cannot guarantee us that
    our code will behave in a safe manner. This can occur in the following scenarios:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况，即使是 Rust 编译器也无法保证我们的代码以安全的方式运行。这可能在以下场景中发生：
- en: When we have to program against the "metal", close to the operating system,
    processors, and hardware
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们必须针对“金属”编程，接近操作系统、处理器和硬件时
- en: When we want to work with the same amount of control that is possible in C
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要与 C 中可能实现的控制量相同
- en: When we delegate a part of program execution to an unsafe language such as C
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们将程序执行的一部分委托给不安全语言，如 C 时
- en: When we want to inline assembly language
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要内联汇编语言时
- en: 'Rust allows us to code for these scenarios, but we have to envelop this possibly
    dangerous code in an `unsafe` block:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许我们为这些场景编写代码，但我们必须将这些可能危险的代码包裹在一个 `unsafe` 块中：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, the programmer takes full responsibility. The `unsafe` block is a promise
    to the compiler that the unsafety will not leak out of the block. The compiler
    will check the code areas that are marked as `unsafe` more loosely and allow otherwise
    forbidden manipulations, but a number of rules from the ownership system (refer
    to [Chapter 6](part0056.xhtml#aid-1LCVG2 "Chapter 6. Pointers and Memory Safety"),
    *Pointers and Memory Safety*, for more information) will still remain in place.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，程序员承担全部责任。`unsafe` 块是对编译器的一个承诺，即不安全性不会从块中泄漏出来。编译器将更宽松地检查标记为 `unsafe` 的代码区域，并允许其他禁止的操作，但所有权系统（有关更多信息，请参阅第
    6 章，*指针和内存安全*）的一些规则仍然有效。
- en: The clear advantage is that problem areas will now appear very well isolated;
    if a problem occurs, we will know that it can only occur in these marked code
    areas. Having a code base where 99 percent of the code is safe and 1 percent is
    unsafe is much easier to maintain than a code base with 100 percent unsafe code,
    as in C!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 明显的优势是，问题区域现在将非常清晰地隔离；如果出现问题，我们将知道它只能在这些标记的代码区域中发生。拥有 99% 的代码是安全的、1% 是不安全的代码库比拥有
    100% 不安全代码的代码库更容易维护，就像在 C 中那样！
- en: 'Here is what we can do in an `unsafe` block:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `unsafe` 块中我们可以做以下事情：
- en: Work with raw pointers, especially by dereferencing them. For more information,
    refer to the *Raw pointers* section of this chapter.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与原始指针一起工作，特别是通过解引用它们。有关更多信息，请参阅本章的 *原始指针* 部分。
- en: Call a function in another language through a **Foreign Function Interface**
    (**FFI**). For more information, see the *Interfacing with C* section of this
    chapter.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 **Foreign Function Interface**（**FFI**）调用另一种语言中的函数。有关更多信息，请参阅本章的 *与 C 接口*
    部分。
- en: Inline assembly code
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联汇编代码
- en: 'Use `std::mem::transmute` to convert simple types bitwise; here is an example
    of its use in which a string is transformed into a slice of bytes:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::mem::transmute` 来进行简单的类型位操作；以下是一个使用示例，其中字符串被转换为一个字节数组切片：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This prints the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下输出：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An `unsafe` block can also call the `unsafe` functions that perform these dangerous
    operations and are marked as `unsafe fn dangerous() { }`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe` 块也可以调用执行这些危险操作并标记为 `unsafe fn dangerous() { }` 的 `unsafe` 函数。'
- en: In `unsafe` code, the use of the `std::mem` module (which contains functions
    to work with memory at a low level) and the `std::ptr` module (which contains
    functions to work with raw pointers) is common.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `unsafe` 代码中，使用 `std::mem` 模块（其中包含用于在低级别处理内存的函数）和 `std::ptr` 模块（其中包含用于处理原始指针的函数）很常见。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We recommend that you use `assert!` statements abundantly inside unsafe code
    to check at runtime whether it is doing what you expect it to. For instance, before
    dereferencing a raw `ptr` pointer of unknown origin, always call `assert!(!ptr.is_null());`
    to ensure that the pointer points to a valid memory location.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你在 `unsafe` 代码中大量使用 `assert!` 语句来检查运行时是否做了你期望的事情。例如，在解引用未知来源的原始 `ptr` 指针之前，始终调用
    `assert!(!ptr.is_null());` 以确保指针指向有效的内存位置。
- en: Raw pointers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始指针
- en: 'In unsafe code blocks, Rust allows the use of a new kind of pointers called
    *raw pointers*. For these pointers, there is no built-in security, and you can
    work with them with the same freedom as C pointers. They are written as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `unsafe` 代码块中，Rust 允许使用一种称为 *原始指针* 的新类型指针。对于这些指针，没有内置的安全机制，你可以像 C 指针一样自由地使用它们。它们被写成如下形式：
- en: '`*const T`: This is used for a pointer of an immutable value or the `T` type'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*const T`：这用于不可变值或 `T` 类型的指针'
- en: '`*mut T`: This is used as a mutable pointer'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*mut T`：这用作可变指针'
- en: They can point to invalid memory, and the memory resource needs to be manually
    freed. This means that a raw pointer could inadvertently be used after freeing
    the memory that it points to. In addition, multiple concurrent threads have nonexclusive
    access to mutable raw pointers. Since we're not sure of the contents (at least
    we have no compiler guarantee of valid content), dereferencing a raw pointer can
    also lead to program failure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以指向无效的内存，内存资源需要手动释放。这意味着原始指针可能在释放它所指向的内存之后意外地被使用。此外，多个并发线程对可变原始指针有非独占访问权。由于我们不确定其内容（至少我们没有编译器保证有效内容），解引用原始指针也可能导致程序失败。
- en: 'That''s why dereferencing a raw pointer can only be done inside an `unsafe`
    block, as illustrated in the following code fragment:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，解引用原始指针只能在 `unsafe` 块内部进行，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you try to do this in normal code, you will get the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在普通代码中这样做，你将得到以下输出：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can make raw pointers safely out of references, implicitly or explicitly,
    with `&` as `*const`, as shown in the following snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `&` 作为 `*const`，隐式或显式地从引用安全地创建原始指针，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, converting a raw pointer into a reference, which should be done through
    a `&*` (address of a dereference) operation, must be done within an `unsafe` block:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将原始指针转换为引用，应该通过 `&*`（解引用的地址）操作完成，必须在 `unsafe` 块内部进行：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Raw pointers could also be useful when defining other more intelligent pointers;
    for example, they are used to implement the `Rc` and `Arc` pointer types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义其他更智能的指针时，原始指针也可能很有用；例如，它们用于实现 `Rc` 和 `Arc` 指针类型。
- en: Interfacing with C
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 C 接口
- en: Due to the vast functionality that exists in C's code, it can sometimes be useful
    to delegate processing to a C routine, instead of writing everything in Rust.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C 代码中存在大量的功能，有时将处理委托给 C 例程可能很有用，而不是在 Rust 中编写一切。
- en: 'You can call all functions from the C standard library by using the `libc`
    crate, which must be obtained through Cargo. To do this, simply add the following
    to your Rust code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `libc` crate 来调用 C 标准库中的所有函数，这必须通过 Cargo 获取。为此，只需将以下内容添加到你的 Rust 代码中：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To import C functions and types, you can sum them up like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入 C 函数和类型，你可以这样总结：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Alternatively, you can use a `*` wildcard, such as `use libc::*;`, to make them
    all available.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `*` 通配符，例如 `use libc::*;`，使它们全部可用。
- en: To work with C (or another language) from Rust, you will have to use the FFI,
    which has its utilities in the `std::ffi` module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Rust（或另一种语言）中与 C（或另一种语言）一起工作，您将不得不使用 FFI，它在其 `std::ffi` 模块中有其工具。
- en: 'Here is a simple example to call C for printing out a Rust string with the
    `puts` function in C:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的示例，使用 C 的 `puts` 函数打印 Rust 字符串：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This prints out the following sentence:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出以下句子：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `new()` method of `CString` will produce a string (ending with a 0 byte)
    that is compatible with C from the Rust string. The `as_ptr()` method returns
    a pointer to this C string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`CString` 的 `new()` 方法将从 Rust 字符串生成一个与 C 兼容的字符串（以一个 0 字节结尾）。`as_ptr()` 方法返回指向这个
    C 字符串的指针。'
- en: The `#![feature(libc)]` attribute (a so called feature gate) is (temporarily)
    necessary to enable the use of `libc`. It does not work with Rust from the beta
    channel, you need to take the Rust compiler from the nightly channel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`#![feature(libc)]` 属性（一个所谓的功能门）是（暂时）必要的，以启用 `libc` 的使用。它不与 beta 通道的 Rust 一起工作，您需要从
    nightly 通道获取 Rust 编译器。'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Feature gates are common in Rust to enable the use of a certain functionality,
    but they are not available in stable Rust; they are only available in the current
    development branch (the nightly release).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 功能门在 Rust 中很常见，用于启用某些功能的使用，但在稳定 Rust 中不可用；它们仅在当前开发分支（nightly 发布）中可用。
- en: Using a C library
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 C 库
- en: Suppose we want to calculate the tangents of a complex number. The `num` crate
    offers basic operations on complex numbers, but at this time, the `tangents` function
    is not yet included, so we will call the `ctanf` function from the C library `libm`,
    which is a collection of mathematical functions that are implemented in C.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算复数的正切值。`num` 包提供了复数的基本操作，但在这个时候，`tangents` 函数尚未包含，因此我们将调用 C 库 `libm`
    中的 `ctanf` 函数，这是一个用 C 实现的数学函数集合。
- en: 'The following code does just that and defines a complex number as a simple
    `struct`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码正是如此，并定义了一个复数作为一个简单的 `struct`：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This program prints the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将打印以下输出：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `#[derive(Debug)]` attribute is necessary because we want to show the number
    in a `{:?}` format string. The `#[derive(Copy, Clone)]` attribute is needed because
    we want to use `z` in the `println!` statement, after we have moved it by calling
    `ctanf(z)`. The function of `#[repr(C)]` is to reassure the compiler that the
    type we are passing to C is foreign function-safe, and it tells `rustc` to create
    `struct` with the same layout as C.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[derive(Debug)]` 属性是必要的，因为我们想在 `{:?}` 格式字符串中显示数字。`#[derive(Copy, Clone)]`
    属性是必要的，因为我们想在调用 `ctanf(z)` 将 `z` 移动后使用 `z` 在 `println!` 语句中。`#[repr(C)]` 的功能是让编译器确信我们传递给
    C 的类型是外国函数安全的，并且它告诉 `rustc` 创建与 C 相同布局的 `struct`。'
- en: 'The signatures of the C functions that we want to use must be listed in an
    `extern {}` block. The compiler cannot check these signatures, so it is important
    to specify them accurately to make the correct bindings at runtime. This block
    can also declare global variables that are exported by C to use in Rust. They
    must be marked as `static` or `static mut`, for example, `static mut version:
    libc::c_int`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '我们想要使用的 C 函数的签名必须列在一个 `extern {}` 块中。编译器无法检查这些签名，因此准确指定它们对于在运行时正确绑定非常重要。此块还可以声明
    C 导出的全局变量，以便在 Rust 中使用。它们必须标记为 `static` 或 `static mut`，例如，`static mut version:
    libc::c_int`。'
- en: The `extern` block must be preceded by a `#[link(name = "m")]` attribute to
    link the `libm` library. This instructs `rustc` to link to that native library
    so that symbols from that library are resolved.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern` 块之前必须有一个 `#[link(name = "m")]` 属性，以链接 `libm` 库。这指示 `rustc` 链接到该本地库，以便解析该库的符号。'
- en: The C call itself must evidently be done inside an `unsafe {}` block. This block
    is enveloped inside a `tan(z)` wrapper function, which only uses Rust types. This
    way this wrapper can be exposed as a safe interface, by hiding the unsafe calls
    and type conversions between Rust and C types, especially C pointers. When the
    C code returns a resource, the Rust code must contain destructors for these values
    to assure their memory release.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: C 调用本身显然必须在 `unsafe {}` 块内完成。这个块被一个 `tan(z)` 包装函数包围，该函数只使用 Rust 类型。这样这个包装函数就可以作为一个安全的接口暴露出来，通过隐藏
    Rust 和 C 类型之间的不安全调用和类型转换，特别是 C 指针。当 C 代码返回资源时，Rust 代码必须包含这些值的析构函数，以确保它们的内存释放。
- en: Inlining assembly code
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联汇编代码
- en: In Rust, we can embed assembly code. This should be extremely rare, but we can
    think of situations where this might be useful, for example, when you have to
    get the utmost performance or very low-level control. However, the portability
    of your code and perhaps its stability are decreased when you do this. The Rust
    compiler will probably generate better assembly code than you could write, so
    it isn't worth the effort most of the time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，我们可以嵌入汇编代码。这应该非常罕见，但我们可以想到一些可能有用的情况，例如，当你必须获得极致的性能或非常低级别的控制时。然而，当你这样做时，你的代码的可移植性和可能的不稳定性都会降低。Rust
    编译器可能会生成比你自己编写的更好的汇编代码，所以大多数时候这并不值得。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This feature is not yet enabled in Rust 1.0 on the stable release channel. To
    use this mechanism (or other unstable features) in the meantime, you have to use
    Rust from the master branch (which is the nightly release).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能在 Rust 1.0 的稳定发布渠道中尚未启用。在此期间，要使用此机制（或其他不稳定功能），您必须使用来自 master 分支的 Rust（这是夜间发布）。
- en: 'The mechanism works by using the `asm!` macro, like this example where we calculate
    `b` in the subtract function by calling assembly code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制通过使用 `asm!` 宏来实现，例如以下示例中，我们通过调用汇编代码来计算减法函数中的 `b`：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This prints out the result as `35`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将结果打印为 `35`。
- en: We can only use `asm!` with a so-called feature gate, which is `#![feature(asm)]`
    here.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能使用具有所谓功能门的功能 `asm!`，在这里是 `#![feature(asm)]`。
- en: The `asm!` macro has a number of parameters separated by `:`. The first is the
    assembly template, containing the assembly code as a string, then the output and
    input operands follow.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`asm!` 宏有多个参数，由 `:` 分隔。第一个是汇编模板，包含作为字符串的汇编代码，然后是输出和输入操作数。'
- en: 'You can indicate the kind of processor your assembly code is meant to execute
    on with the `cfg` attribute and its `target_arch` value, for example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `cfg` 属性及其 `target_arch` 值来指示您的汇编代码打算在哪种处理器上执行，例如：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The compiler will then check whether you have specified valid assembly code
    for that processor.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将检查您是否为该处理器指定了有效的汇编代码。
- en: For more detailed information about the use of `asm!`, refer to the *Inline
    Assembly* section of this chapter at [http://doc.rust-lang.org/book/unsafe.html](http://doc.rust-lang.org/book/unsafe.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `asm!` 的更多详细信息，请参阅本章的 *内联汇编* 部分，链接为 [http://doc.rust-lang.org/book/unsafe.html](http://doc.rust-lang.org/book/unsafe.html)。
- en: Calling Rust from other languages
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从其他语言调用 Rust
- en: 'A Rust code can be called from any language that can call C. However, the Rust
    library should have the `dylib` crate type value. When `rustfn1` is the Rust function
    to be called, this must be declared as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从任何可以调用 C 的语言中调用 Rust 代码。然而，Rust 库应该具有 `dylib` 包类型值。当 `rustfn1` 是要调用的 Rust
    函数时，必须如下声明：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `#[no_mangle]` serves to keep the function names plain and simple so that
    they are easier to link to. C exports the function to the outside world with the
    C calling convention.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`#[no_mangle]` 用于保持函数名称简单明了，以便更容易链接。C 使用 C 调用约定将函数导出至外部世界。
- en: Examples of calling Rust from C, Python, Haskell, and Node.js can be found in
    the article at [https://siciarz.net/24-days-of-rust-calling-rust-from-other-languages/](https://siciarz.net/24-days-of-rust-calling-rust-from-other-languages/).
    Calling Rust from Perl and Julia is shown at [http://paul.woolcock.us/posts/rust-perl-julia-ffi.html](http://paul.woolcock.us/posts/rust-perl-julia-ffi.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在文章 [https://siciarz.net/24-days-of-rust-calling-rust-from-other-languages/](https://siciarz.net/24-days-of-rust-calling-rust-from-other-languages/)
    中可以找到从 C、Python、Haskell 和 Node.js 调用 Rust 的示例。从 Perl 和 Julia 调用 Rust 的示例可以在 [http://paul.woolcock.us/posts/rust-perl-julia-ffi.html](http://paul.woolcock.us/posts/rust-perl-julia-ffi.html)
    找到。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we showed you how to process parameters for your program that
    are read from the command line at startup. Then, we proceeded to unsafe territory
    where raw pointers point the way. We covered how to use assembly code, how to
    call C functions from Rust, and how to call Rust functions from other languages.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了如何处理在启动时从命令行读取的程序参数。然后，我们进入了不安全的地带，原始指针指引了方向。我们介绍了如何使用汇编代码，如何从 Rust
    调用 C 函数，以及如何从其他语言调用 Rust 函数。
- en: This chapter concludes our essential tour of Rust. In the [Appendix](part0075.xhtml#aid-27GQ61
    "Appendix A. Exploring Further"), *Exploring Further*, that follows this chapter,
    we provide you with pointers (no pun intended!) to pursue your Rust journey.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了我们对 Rust 的基本巡游。在随后的 [附录](part0075.xhtml#aid-27GQ61 "附录 A. 探索更多")，*探索更多*
    中，我们为您提供了一些线索（无意中！）来继续您的 Rust 之旅。
