- en: Benchmarking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: 'We have learned how to profile our application and how to find and fix the
    main bottlenecks, but there is another step in this process: checking whether
    our changes have improved the performance.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何分析我们的应用程序，以及如何找到和修复主要瓶颈，但在这个过程中还有另一个步骤：检查我们的更改是否提高了性能。
- en: 'In this chapter, you will learn how to benchmark your application so that you
    can measure your improvements. This can meet two objectives: firstly, to check
    whether a new version of your application runs faster than an older version, and
    secondly, if you are creating a new application to solve a problem an existing
    application already solves, to compare the efficiency of your creation to the
    existing application.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何基准测试你的应用程序，以便你可以衡量你的改进。这可以满足两个目标：首先，检查你的应用程序的新版本是否比旧版本运行得更快，其次，如果你正在创建一个新应用程序来解决现有应用程序已经解决的问题，比较你的新应用程序与现有应用程序的效率。
- en: 'In this context, you will learn about the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，你将在本章中了解以下主题：
- en: Selecting what to benchmark
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择要基准测试的内容
- en: Benchmarking in nightly Rust
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 夜间Rust的基准测试
- en: Benchmarking in stable Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定Rust中的基准测试
- en: Continuous integration for benchmarks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试的持续集成
- en: Selecting what to benchmark
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择要基准测试的内容
- en: Knowing whether your program improves efficiency for each change is a great
    idea, but you might be wondering how to measure that improvement or regression
    properly. This is actually one of the bigger deals of benchmarking since, if done
    properly, it will clearly show your improvements or regressions but, if done poorly,
    you might think your code is improving while it's even regressing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你的程序在每次更改后是否提高了效率是一个好主意，但你可能会想知道如何正确地衡量这种改进或退化。这实际上是基准测试中的一个重要问题，因为如果做得好，它将清楚地显示你的改进或退化，但如果做得不好，你可能会认为你的代码正在改进，而实际上它正在退化。
- en: Depending on the program you want to benchmark, there are different parts of
    its execution you should be interested in benchmarking. For example, a program
    that processes some information and then ends (an analyzer, a CSV converter, a
    configuration parser...), would benefit from a whole-program benchmark. This means
    it might be interesting to have some test input data and see how much time it
    takes to process it. It should be more than one set, so that you can see how the
    performance changes with the input data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想要基准测试的程序，你应该对其执行的不同部分感兴趣。例如，一个处理一些信息然后结束的程序（分析器、CSV转换器、配置解析器...），将受益于全程序基准测试。这意味着你可能需要一些测试输入数据，看看处理它们需要多少时间。应该有多个集合，这样你就可以看到性能如何随着输入数据的变化而变化。
- en: A program that has an interface and requires some user interaction, though,
    is difficult to benchmark this way. The best thing is to take the most relevant
    pieces of code and benchmark them. In the previous chapter, we learned how to
    find the most relevant pieces of code in our software. With profiling techniques,
    we can understand which functions and code pieces impact the execution of our
    application the most, so we can decide to benchmark those.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有界面并需要一些用户交互的程序，用这种方式进行基准测试是困难的。最好的办法是选取最相关的代码片段进行基准测试。在前一章中，我们学习了如何在我们的软件中找到最相关的代码片段。通过分析技术，我们可以了解哪些函数和代码片段对我们的应用程序的执行影响最大，因此我们可以决定对这些进行基准测试。
- en: Usually, you will want to mostly have fine-grained benchmarks. This way, you
    will be able to detect a change in one of the small pieces of code that affect
    the overall performance of the application. If you have broader benchmarks, you
    might know that the overall performance of one part of the application has regressed,
    but it will be difficult to tell what in the code has made that happen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你将希望主要拥有细粒度的基准测试。这样，你将能够检测到影响应用程序整体性能的某个小代码片段的变化。如果你有更广泛的基准测试，你可能会知道应用程序某个部分的整体性能有所下降，但很难确定代码中的哪个部分导致了这种情况。
- en: In any case, as we will see later, having continuous integration for benchmarks
    is a good idea, creating alerts if a particular commit regresses the performance.
    It's also important for all benchmarks to run in as similar as possible environments.
    This means that the computer they are running on should not change from one run
    to the next, and it should be running only the benchmarks, so that the results
    are as real as possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，正如我们稍后将看到的，为基准测试设置持续集成是一个好主意，如果某个特定的提交降低了性能，则会创建警报。对于所有基准测试都在尽可能相似的环境中运行也很重要。这意味着运行它们的计算机不应从一个运行到下一个运行时发生变化，并且它应该只运行基准测试，以便结果尽可能真实。
- en: Another issue is that, as we saw in the previous chapter, the first time we
    run something in a computer, things go slower. Caches have to be populated, branch
    prediction needs to be activated, and so on. This is why you should run benchmarks
    multiple times, and we will see how Rust will do this for us. There is also the
    option to warm caches up for some seconds and then start benchmarking, and there
    are libraries that do this for us.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们将在上一章中看到的那样，我们在计算机上第一次运行某些东西时，速度会变慢。缓存需要填充，分支预测需要激活，等等。这就是为什么你应该多次运行基准测试的原因，我们将看到Rust将如何为我们做这件事。还有选项可以在某些秒数内预热缓存，然后开始基准测试，还有一些库为我们做这件事。
- en: So, for the rest of the chapter, you should take all this into account. Create
    small micro-benchmarks, select the most relevant sections of your code to benchmark,
    and run them in a known non-changing environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的章节中，您应该考虑所有这些因素。创建小型微基准测试，选择您代码中最相关的部分进行基准测试，并在已知的不变环境中运行它们。
- en: Also, note that creating benchmarks does not mean that you should not write
    unit tests, as I have seen more than once. Benchmarks will only tell you how fast
    your code runs, but you will not know whether it does it properly. Unit testing
    is out of the scope of this book, but you should test your software thoroughly
    before even thinking about benchmarking it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，创建基准测试并不意味着您不应该编写单元测试，因为我不止一次看到过这种情况。基准测试只会告诉您代码运行得多快，但您不知道它是否正确执行。单元测试不在此书的范围之内，但在您考虑基准测试之前，您应该彻底测试您的软件。
- en: Benchmarking in nightly Rust
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在夜间Rust中进行基准测试
- en: If you search online for information on how to benchmark in Rust, you will probably
    see a bunch of guides on how to do it in nightly Rust, but not many on how to
    do it in stable Rust. This is because the built-in Rust benchmarks are only available
    on the nightly channel. Let's start by explaining how the built-in benchmarks
    work, so that we can then find out how to do it in stable Rust.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在网上搜索有关如何在Rust中进行基准测试的信息，您可能会看到一堆关于如何在夜间Rust中进行的指南，但关于如何在稳定Rust中进行的却不多。这是因为内置的Rust基准测试仅在夜间通道中可用。让我们首先解释内置基准测试是如何工作的，这样我们就可以了解如何在稳定Rust中实现它。
- en: 'First of all, let''s see how to create benchmarks for a library. Imagine the
    following small library (code in `lib.rs`):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何为库创建基准测试。想象以下小型库（代码在`lib.rs`中）：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, I added some unit tests so that we can be sure that any modifications
    we make to the code will still be tested, and checked that the results were correct.
    That way, if our benchmarks find out that something improves the code, the resulting
    code will be (more or less) guaranteed to work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我添加了一些单元测试，这样我们就可以确保我们对代码所做的任何修改都将得到测试，并检查结果是否正确。这样，如果我们的基准测试发现某些改进了代码，那么生成的代码将（或多或少）保证能够工作。
- en: The `fibonacci()` function that I created is the simplest recursive function.
    It is really easy to read and to understand what is going on. The Fibonacci sequence,
    as you can see in the code, is a sequence that starts with `0` and `1`, and then
    each number is the sum of the previous two.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建的`fibonacci()`函数是最简单的递归函数。它非常容易阅读和理解正在发生的事情。如您在代码中所见，斐波那契序列是一个以`0`和`1`开始的序列，然后每个数字都是前两个数字的和。
- en: As we will see later, recursive functions are easier to develop, but their performance
    is worse than iterative functions. In this case, for each calculation, it will
    need to calculate the two previous numbers, and for them, the two before, and
    so on. It will not store any intermediate state. This means that, from one calculation
    to the next, the last numbers are lost.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将看到的，递归函数更容易开发，但它们的性能不如迭代函数。在这种情况下，对于每次计算，它都需要计算前两个数字，而对于它们，又需要计算前两个，依此类推。它不会存储任何中间状态。这意味着，从一个计算到下一个计算，最后的数字会丢失。
- en: Also, this will push the stack to the limits. For each computation, two functions
    have to be executed and their stack filled, and, in each of them, they have to
    recursively create new stacks when they call themselves again, so the stack usage
    grows exponentially. Furthermore, this computation could be done in parallel since,
    as we discard previous calculations, we do not need to do them sequentially.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这会将栈推到极限。对于每次计算，必须执行两个函数并将它们的栈填满，并且在每个函数中，当它们再次调用自己时，它们必须递归地创建新的栈，因此栈的使用呈指数增长。此外，这个计算可以并行进行，因为我们丢弃了之前的计算，所以我们不需要按顺序执行它们。
- en: 'In any case, let''s check how this performs. For this, we''ll add the following
    code to the `lib.rs` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，让我们检查一下这个性能如何。为此，我们将以下代码添加到`lib.rs`文件中：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will need to add `#![feature(test)]` to the top of the `lib.rs` file (after
    the first comment).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在`lib.rs`文件的顶部添加`#![feature(test)]`（在第一个注释之后）。
- en: Let's first understand why we created these benchmarks. We are testing how long
    it takes for the program to generate the numbers with index `0`, `1`, `2`, `10`,
    and `20` of the Fibonacci sequence. But, the issue is that if we directly provide
    those numbers to the function, the compiler will actually run the recursive function
    itself, and directly only compile the resulting number (yes, **Low Level Virtual
    Machine** (**LLVM**) does this). So, all benchmarks will tell us that it took
    0 nanoseconds to calculate, which is not particularly great.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先理解为什么我们创建了这些基准测试。我们正在测试程序生成斐波那契序列中索引为`0`、`1`、`2`、`10`和`20`的数字需要多长时间。但是，问题是如果我们直接将这些数字提供给函数，编译器实际上会运行递归函数本身，并且只编译生成的数字（是的，**低级虚拟机**（**LLVM**）会这样做）。所以，所有基准测试都会告诉我们计算需要0纳秒，这并不是特别好。
- en: So, for each number we add an iterator that will yield all numbers from `0`
    to the given number (remember that ranges are non-inclusive from the right), calculate
    all results, and generate a vector with them. This will make LLVM unable to precalculate
    all the results.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个数字，我们添加一个迭代器，它会生成从`0`到给定数字的所有数字（记住，范围是从右边非包含的），计算所有结果，并生成一个包含它们的向量。这将使LLVM无法预先计算所有结果。
- en: Then, as we discussed earlier, each benchmark should run multiple times so that
    we can calculate a median value. Rust makes this easy by giving us the `test`
    crate and the `Bencher` type. The `Bencher` is an iterator that will run the closure
    we pass to it multiple times.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，正如我们之前讨论的，每个基准测试都应该运行多次，这样我们就可以计算一个中值。Rust通过给我们`test`包和`Bencher`类型来简化这一点。`Bencher`是一个迭代器，它将多次运行我们传递给它的闭包。
- en: 'As you can see, the map function receives a pointer to the `fibonacci()` function
    that will transform the given `u32` to its Fibonacci sequence number. To run this,
    it''s as simple as running `cargo bench`. And, the result is:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，map函数接收一个指向`fibonacci()`函数的指针，该函数将给定的`u32`转换为它的斐波那契序列数字。要运行它，只需运行`cargo
    bench`即可。结果是：
- en: '![](img/e3c13942-6d78-4be7-8d9b-c34bab3d54ea.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3c13942-6d78-4be7-8d9b-c34bab3d54ea.png)'
- en: So, this is interesting. I selected those numbers (`0`, `1`, `2`, `10` and `20`)
    to show something. For the `0` and the `1` numbers the result is straightforward,
    it will just return the given number. From the second number onward, it needs
    to perform some calculations. For example, for the number `2`, it's just adding
    the previous two, so there is almost no overhead. For the number `10` though,
    it has to add the ninth and the eighth, and for each of them, the eighth and the
    seventh, and the seventh and the sixth respectively. You can see how this soon gets out
    of hand. Also, remember that we discard the previous results for each call.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣。我选择了这些数字（`0`、`1`、`2`、`10`和`20`）来展示一些内容。对于`0`和`1`这两个数字，结果是直接的，它只会返回给定的数字。从第二个数字开始，它需要进行一些计算。例如，对于数字`2`，它只是将前两个数字相加，所以几乎没有开销。但是对于数字`10`来说，它必须将第9个和第8个数字相加，而对于每一个，第8个和第7个，第7个和第6个分别相加。你可以看到这很快就会变得难以控制。另外，记住我们为每次调用丢弃之前的结果。
- en: So, as you can see in the results, it gets really exponential for each new number.
    Take into account that these results are on my laptop computer, and yours will
    certainly be different, but the proportions between one another should stay similar.
    Can we do better? Of course we can. This is usually one of the best learning experiences
    to see the differences between recursive and iterative approaches.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你在结果中看到的那样，对于每个新的数字，它都会变得非常指数级。考虑到这些结果是在我的笔记本电脑上进行的，你的结果肯定会有所不同，但彼此之间的比例应该保持相似。我们能做得更好吗？当然可以。这通常是最好的学习体验之一，可以看到递归和迭代方法之间的差异。
- en: 'So, let''s develop an iterative `fibonacci()` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开发一个迭代的 `fibonacci()` 函数：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, for the first two numbers, we simply return the proper one, as
    before. For the rest, we start with the sequence status for the number 2 (0, 1,
    1), and then iterate up to number `n` (remember that the range is not inclusive
    on the right). This means that for the number `2`, we already have the result,
    and for the rest, it will simply add the two numbers again and again until it
    gets the result.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，对于前两个数字，我们简单地返回之前正确的数字。对于其余的，我们从数字 2 的序列状态（0, 1, 1）开始，然后迭代到数字 `n`（记住右边的范围是不包含的）。这意味着对于数字
    `2`，我们已经有结果了，对于其余的，它将简单地重复将两个数字相加，直到得到结果。
- en: In this algorithm, we always remember the previous two numbers, so we do not
    lose information from one call to the next. We also do not use too much stack
    (we only need three variables for the number 2 onward and we do not call any function).
    So it will require less allocation (if any), and it should be much faster.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，我们总是记住前两个数字，这样我们不会从一次调用中丢失信息。我们也没有使用太多的栈（从数字 2 开始，我们只需要三个变量，并且我们不调用任何函数）。所以它需要的分配（如果有的话）会更少，而且应该会快得多。
- en: Also, if we give it a much bigger number, it should scale linearly, since it
    will calculate each previous number only once, instead of many times. So, how
    much faster is it?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们给它一个更大的数字，它应该线性扩展，因为它只会计算每个前面的数字一次，而不是多次。那么，它会快多少呢？
- en: '![](img/ac3ca992-b4a6-406d-8db7-2fee4df1b72a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac3ca992-b4a6-406d-8db7-2fee4df1b72a.png)'
- en: Wow! The results have really changed! We now see that, at least until the 10th
    number, the processing time is constant and, after that, it will only go up a
    little bit (it will multiply by less than 10 for calculating 10 more numbers).
    If you run `cargo test`, you will still see that the test passes successfully.
    Also, note that the results are much more predictable, and the deviation from
    test to test is much lower.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！结果真的改变了！我们现在看到，至少直到第 10 个数字，处理时间是恒定的，之后它只会略微上升（在计算 10 个更多数字时，乘数将小于 10）。如果你运行
    `cargo test`，你仍然会看到测试成功通过。此外，请注意，结果更加可预测，测试之间的偏差也较低。
- en: But, there is something odd in this case. As before, 0 and 1 run without doing
    any calculation, and that's why it takes so much less time. We could maybe understand
    that for the number 2, it will not do any calculations either (even though it
    will need to compare it to see if it has to run the loop). But, what happens with
    number 10?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这个案例中有些奇怪。就像之前一样，0 和 1 不进行任何计算就运行了，这就是为什么它花费的时间如此之少。我们可能可以理解对于数字 2，它也不会进行任何计算（即使它需要比较以确定是否需要运行循环）。但是，数字
    10 会发生什么呢？
- en: In this case, it should have run the iteration seven times to calculate the
    final value, so it should definitely take more time than not running the iteration
    even once. Well, an interesting thing about the LLVM compiler (the compiler Rust
    uses behind the scenes) is that it is pretty good at optimizing iterative loops.
    This means that, even if it could not do the precalculation for the recursive
    loop, it can do it for the iterative loop. At least seven times.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它应该运行了七次迭代来计算最终值，所以它肯定比不运行迭代一次要花更多的时间。嗯，关于 LLVM 编译器（Rust 在幕后使用的编译器）的一个有趣的事情是，它非常擅长优化迭代循环。这意味着，即使它不能为递归循环进行预计算，它可以为迭代循环进行预计算。至少七次。
- en: How many iterations can LLVM calculate at compile time? Well, it depends on
    the loop, but I've seen it do more than 10\. And, sometimes, it will unroll those
    loops so that if it knows it will be called 10 times, it will write the same code
    10 times, one after the other, so that the compiler does not need to branch.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 在编译时能计算多少次迭代？嗯，这取决于循环，但我看到它做过超过 10 次。有时，它会展开这些循环，这样如果它知道它将被调用 10 次，它就会连续写
    10 次相同的代码，这样编译器就不需要分支了。
- en: 'Does this defeat the purpose of the benchmark? Well, partly, since we no longer
    know how much difference it makes for the number 10, but for that, we have the
    number 20\. Nevertheless, it tells us a great story: if you can create an iterative
    loop to avoid a recursive function, do it. You will not only create a faster algorithm,
    but the compiler will even know how to optimize it.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否违背了基准测试的目的？嗯，部分是，因为我们不再知道数字 10 的差异有多大，但对于这一点，我们有数字 20。尽管如此，它告诉我们一个很好的故事：如果你可以创建一个迭代循环来避免递归函数，就做吧。你不仅会创建一个更快的算法，编译器甚至知道如何优化它。
- en: Benchmarking in stable Rust
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳定 Rust 中的基准测试
- en: Until now, we have seen how to benchmark our code using the nightly release
    channel. This is because Rust requires the `test` nightly feature for benchmarks
    to run. It's where the `test` crate and the `Bencher` types can be found. If you
    still want to be able to use the stable compiler for everything except benchmarks,
    you can put all your benchmarks in the `benches` directory. The stable compiler
    will ignore them for normal builds, but the nightly compiler will be able to run
    them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用夜间发布通道来基准测试我们的代码。这是因为 Rust 需要基准测试的 `test` 夜间功能才能运行。这是 `test`
    crate 和 `Bencher` 类型所在的地方。如果你仍然想使用稳定编译器进行基准测试之外的所有操作，你可以将所有基准测试放在 `benches` 目录中。稳定编译器将忽略它们进行正常构建，但夜间编译器将能够运行它们。
- en: But, if you really want to use the stable compiler to run benchmarks, you can
    use the `bencher` crate. You can find it in `crates.io`, and using it is really
    similar to using the built-in nightly benchmarks, since this crate is just a stable
    port of the benchmarking library.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你真的想使用稳定编译器来运行基准测试，你可以使用 `bencher` crate。你可以在 `crates.io` 中找到它，使用它非常类似于使用内置的夜间基准测试，因为这个
    crate 只是基准测试库的稳定版本。
- en: 'To use it, you will need to first change the `Cargo.toml` file to make sure
    it looks like the following after the package metadata and dependencies:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，你首先需要更改 `Cargo.toml` 文件，确保在包元数据和依赖项之后看起来像以下内容：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we create a benchmark with an example name, and specify not to create
    a harness around it. Then, create the `benches/example.rs` file with the following
    content:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个示例名称创建一个基准测试，并指定不要围绕它创建一个 harness。然后，创建一个名为 `benches/example.rs` 的文件，并包含以下内容：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And, finally, remove the benchmark module. This will create a benchmark for
    each of the previous functions. The main difference is that you need to import
    the crate you are benchmarking, you do not add the `#[bench]` attribute to each
    function, and you use two macros to make the benchmark run. The `benchmark_group!`
    macro will create a group of benchmarks with the first argument for the macro
    as its name and with the given functions. The `benchmark_main!` macro will create
    a `main()` function that will run all the benchmarks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，移除基准测试模块。这将为之前每个函数创建一个基准测试。主要区别在于你需要导入你正在基准测试的 crate，你不需要为每个函数添加 `#[bench]`
    属性，并且你使用两个宏来使基准测试运行。`benchmark_group!` 宏将创建一个以宏的第一个参数为名称的基准测试组，并包含给定的函数。`benchmark_main!`
    宏将创建一个 `main()` 函数，该函数将运行所有基准测试。
- en: 'Let''s look at the results:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果：
- en: '![](img/1057263e-2aec-4539-91a4-4884bcc7b0c5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1057263e-2aec-4539-91a4-4884bcc7b0c5.png)'
- en: As you can see, this approach does not give us beautiful colors and it adds
    some extra overhead to the native method, but the results are still equivalent.
    In this case, we can see that the 10th number will actually not be calculated
    at compile time. This is because, on stable Rust, using an external crate, the
    compiler is not able to compute everything at compile time. Still, it gives us
    really good information about how different each option's performance is.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这种方法并没有给我们带来美丽的颜色，并且给原生方法添加了一些额外的开销，但结果仍然是等效的。在这种情况下，我们可以看到第 10 个数字实际上不会在编译时计算。这是因为，在稳定
    Rust 中，使用外部 crate，编译器无法在编译时计算一切。尽管如此，它还是给我们提供了关于不同选项性能差异的非常好的信息。
- en: Continuous integration for benchmarks
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试的持续集成
- en: Once we know how to benchmark (and I will use the nightly way from now on),
    we can set up our continuous integration environment so that we can get alerts
    when a performance regression occurs. There are multiple ways of achieving something
    like this, but I will be using the Travis-CI infrastructure, some Bash, and a
    Rust library to do it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何进行基准测试（从现在起我将使用夜间版本），我们就可以设置我们的持续集成环境，以便在性能回归发生时收到警报。实现类似功能有多种方式，但我会使用
    Travis-CI 基础设施、一些 Bash 和一个 Rust 库来完成。
- en: Travis-CI integration
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Travis-CI 集成
- en: Let's first start by thanking the great work of Lloyd Chan and Sunjay Varma,
    who were the first to suggest this approach. You can find the code we will be
    using in Sunjay's blog ([http://sunjay.ca/2017/04/27/rust-benchmark-comparison-travis](http://sunjay.ca/2017/04/27/rust-benchmark-comparison-travis)).
    Nevertheless, it makes sense to check it, understand it, and see how it works.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们感谢Lloyd Chan和Sunjay Varma的杰出工作，他们是第一个提出这种方法的。您可以在Sunjay的博客中找到我们将要使用的代码（[http://sunjay.ca/2017/04/27/rust-benchmark-comparison-travis](http://sunjay.ca/2017/04/27/rust-benchmark-comparison-travis)）。尽管如此，检查它、理解它并看看它是如何工作的还是有意义的。
- en: 'The idea is simple: on Travis-CI builds, you can build against multiple Rust
    channels. When a pull request is received when building against the nightly channel,
    let''s run all the benchmarks and then compare them to benchmarks we will run
    on the pull request target branch. Finally, output the comparison results in Travis-CI''s
    build logs.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单：在Travis-CI构建中，您可以针对多个Rust渠道进行构建。当收到针对nightly渠道的构建请求时，让我们运行所有基准测试，然后将它们与我们将在pull
    request目标分支上运行的基准测试进行比较。最后，在Travis-CI的构建日志中输出比较结果。
- en: 'Let''s start by configuring our Travis-CI build script. For that, we will need
    a `.travis.yml` file similar to the following one in our repository:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先配置我们的Travis-CI构建脚本。为此，我们需要在我们的仓库中创建一个类似于以下内容的`.travis.yml`文件：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's see what this code does. First of all, if you never used Travis-CI for
    your continuous integration, you should know that the `.travis.yml` YAML file
    contains the build configuration. In this case, we tell Travis-CI that we want
    to build a Rust project (so that it sets up the compiler by itself) and we tell
    it that we want to build against nightly, beta, and stable release channels. I
    usually like to add the minimum supported Rust version, mostly to know when it
    breaks, so that we can advertise the minimum Rust compiler version in our documentation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码做了什么。首先，如果您从未使用过Travis-CI进行持续集成，您应该知道`.travis.yml` YAML文件包含了构建配置。在这种情况下，我们告诉Travis-CI我们想要构建一个Rust项目（这样它就会自己设置编译器），并且我们告诉它我们想要针对nightly、beta和稳定发布渠道进行构建。我通常喜欢添加最小支持的Rust版本，主要是为了知道何时会出错，这样我们就可以在我们的文档中宣传最小Rust编译器版本。
- en: We then export the `cargo` binary path so that we can add `cargo` binaries by
    installing them in the build. This will be needed for the benchmark comparison
    script. Then, we tell Travis-CI to build the library/binary crate, we tell it
    to package it to check that a valid package will be generated, and we finally
    run all the unit tests. So far, nothing too different from a normal Travis-CI
    Rust build.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们导出`cargo`二进制路径，这样我们就可以通过在构建中安装它们来添加`cargo`二进制文件。这将是基准比较脚本所需要的。然后，我们告诉Travis-CI构建库/二进制crate，我们告诉它打包以检查是否生成了有效的包，最后运行所有单元测试。到目前为止，与正常的Travis-CI
    Rust构建没有太大不同。
- en: Things change once we get to the `after-success` section. We call a shell script
    that we haven't defined yet. This script will contain the logic of the benchmark
    comparison.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达`after-success`部分，我们会调用一个尚未定义的shell脚本。这个脚本将包含基准比较的逻辑。
- en: Before writing all the code, let's first learn about a library that will make
    things much easier for us. I'm talking about the `cargo-benchcmp`, `cargo` binary.
    This executable can read outputs from Rust benchmarks and compare them. To install
    it, you only need to run `cargo install cargo-benchcmp`. It also has some great
    command-line arguments that can help us get the output we want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写所有代码之前，让我们先了解一个将使事情变得容易得多的库。我指的是`cargo-benchcmp`，一个`cargo`二进制文件。这个可执行文件可以读取Rust基准测试的输出并进行比较。要安装它，您只需运行`cargo
    install cargo-benchcmp`。它还有一些很好的命令行参数，可以帮助我们获得想要的输出。
- en: To get the results of a benchmark in a file, it's as simple as doing `cargo
    bench > file`. In this case, we will have two benchmarks, the *control* benchmark,
    a benchmark that we decide will be the reference; and a *variable* benchmark,
    the one we want to compare. Usually, a pull request will have the target branch
    as a control benchmark and the pull request branch as a variable benchmark.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要将基准测试的结果输出到文件中，只需执行`cargo bench > file`即可。在这种情况下，我们将有两个基准测试，一个是*控制*基准测试，这是我们决定作为参考的基准测试；另一个是*变量*基准测试，这是我们想要比较的基准测试。通常，pull
    request的目标分支将作为控制基准测试，而pull request分支将作为变量基准测试。
- en: Using the executable is as easy as running `cargo benchcmp control variable`.
    This will show a great output with a side-by-side comparison. You can ask the
    tool to filter the output a bit, since you probably don't want to see tens of
    benchmarks with really similar values, and you are probably interested in big
    improvements or regressions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可执行文件就像运行 `cargo benchcmp control variable` 一样简单。这将显示一个带有并列比较的出色输出。你可以要求工具稍微过滤一下输出，因为你可能不想看到有数十个具有非常相似值的基准测试，你可能更感兴趣的是大的改进或回归。
- en: To see the improvements, add the `--improvements` flag to the command line and,
    to see the regressions, add the `--regressions` flag. You can also set up a threshold
    as a percentage, and benchmarks that change below that threshold won't show, to
    avoid non-changing benchmarks. For that, use the `--threshold {th}` syntax, where
    `{th}` is a number higher than 0 representing the percentage change that should
    be taken into account.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看改进，请在命令行中添加 `--improvements` 标志，要查看回归，请添加 `--regressions` 标志。你还可以设置一个作为百分比的阈值，低于该阈值的基准测试将不会显示，以避免显示没有变化的基准测试。为此，请使用
    `--threshold {th}` 语法，其中 `{th}` 是一个大于 0 的数字，表示应考虑的百分比变化。
- en: 'Now we understand this, let''s see the code that will be in the `travis-after-success.sh`
    file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们明白了这个，让我们看看 `travis-after-success.sh` 文件中的代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's see what this script is doing. The `set -e` and `set -x` commands will
    simply improve how the commands are shown in Travis-CI build logs. Then, only
    for nightly, it will clone the repository in a new location. If it's a pull request,
    it will clone the base branch; if not, it will clone the master branch. Then,
    it will run benchmarks in both places and compare them using `cargo-benchcmp`.
    This will show the results in the build logs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个脚本在做什么。`set -e` 和 `set -x` 命令将简单地改善命令在 Travis-CI 构建日志中的显示方式。然后，仅对 nightly
    版本，它将在新位置克隆仓库。如果是拉取请求，它将克隆基础分支；如果不是，它将克隆 master 分支。然后，它将在两个地方运行基准测试，并使用 `cargo-benchcmp`
    进行比较。这将结果显示在构建日志中。
- en: This script can, of course, be modified to suit any needs and, for example,
    use a different branch to the master branch as a default branch, or filter the
    output of the comparison, as we saw earlier.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个脚本可以被修改以适应任何需求，例如，使用默认分支之外的分支，或者过滤比较的输出，就像我们之前看到的。
- en: Benchmark statistics with Criterion
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Criterion 的基准测试统计信息
- en: If we want to know more about benchmark comparison, there is no better library
    than **Criterion**. It will generate statistics that you can use to compare benchmarks
    from multiple commits, and not only that, it will also enable you to show plots
    if you have `gnuplot` installed. It requires Rust nightly to run.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想了解更多关于基准测试比较的信息，没有比 **Criterion** 更好的库了。它将生成你可以用来比较多个提交的基准测试的统计数据，不仅如此，它还允许你显示图表，如果你已经安装了
    `gnuplot`。它需要 Rust nightly 版本才能运行。
- en: 'Let''s see how to use it. First, you will need to add Criterion as a dependency
    in your `Cargo.toml` file and create a benchmarks file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用它。首先，你需要在你的 `Cargo.toml` 文件中添加 Criterion 作为依赖项并创建一个基准测试文件：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, you will need to create a benchmark. I will be using the Fibonacci function
    that we saw earlier to demonstrate the behavior. The way to declare the benchmarks
    is almost exactly the same as the Rust stable `bencher` crate. Let''s write the
    following code in the `benches/example.rs` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要创建一个基准测试。我将使用我们之前看到的斐波那契函数来演示行为。声明基准测试的方式几乎与 Rust 稳定版 `bencher` crate
    完全相同。让我们在 `benches/example.rs` 文件中写下以下代码：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we now run `cargo bench`, we will see a similar output to this one (with
    the recursive version):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行 `cargo bench`，我们将看到与此类似的输出（与递归版本相同）：
- en: '![](img/d3507a8c-049d-4d23-8f9c-1dc4b7338e87.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3507a8c-049d-4d23-8f9c-1dc4b7338e87.png)'
- en: As you can see, we get tons of information here. First, we see that Criterion
    warms the processor for three seconds so that it can load the caches and set up
    branch prediction. Then, it gets 100 measurements of the function, and it shows
    us valuable information about the sample.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在这里得到了大量的信息。首先，我们看到 Criterion 为处理器预热了三秒钟，以便它可以加载缓存并设置分支预测。然后，它对函数进行 100
    次测量，并显示有关样本的有价值信息。
- en: We can see how much time it takes to run an iteration (about 42 microseconds),
    the mean and the median of the sample, the number of outliers (significantly different
    samples), and a slope with its `R²` function. Until now, it only gives some extra
    information regarding the benchmark. If you check the current directory, you will
    see that it created a `.criterion` folder, which stores previous benchmarks. You
    can even check the JSON data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到运行一个迭代的耗时（大约42微秒），样本的平均值和中位数，异常值（显著不同的样本）的数量，以及一个带有其`R²`函数的斜率。到目前为止，它只提供了关于基准的一些额外信息。如果你检查当前目录，你会看到它创建了一个`.criterion`文件夹，其中存储了之前的基准测试。你甚至可以检查JSON数据。
- en: 'Let''s run the benchmark again, by replacing the recursive function with the
    iterative function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行基准测试，通过将递归函数替换为迭代函数：
- en: '![](img/a2cc5c46-37d8-44f8-8e76-44cbd749be84.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2cc5c46-37d8-44f8-8e76-44cbd749be84.png)'
- en: Wow! Lots more data! Criterion compared this new benchmark with the previous
    one and saw that there is strong evidence to reject that this improvement is just
    a statistical anomaly. The benchmarks have improved by 99.96%!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！数据更多了！标准比较工具将这个新基准与之前的基准进行了比较，并发现有力证据表明这种改进并非仅仅是统计上的异常。基准提高了99.96%！
- en: As you can see, Criterion gives us a better informative approach than the built-in
    benchmarks for statistical analysis. Running this tool once in a while will show
    us how the performance of our application changes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，标准比较工具在统计分析方面比内置的基准测试提供了更好的信息方法。偶尔运行这个工具将向我们展示应用程序性能的变化。
- en: The library allows for function comparison, graph creation, and more. It can
    be configured for each benchmark, so you will be able to fine-tune your results
    according to your needs. I recommend you check the official documentation of the
    project for further insights ([https://crates.io/crates/criterion](https://crates.io/crates/criterion)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该库允许进行函数比较、图形创建等。它可以针对每个基准进行配置，因此你将能够根据你的需求微调你的结果。我建议你查看项目的官方文档以获取更多信息([https://crates.io/crates/criterion](https://crates.io/crates/criterion))。
- en: To include this in your Travis-CI builds, it's as simple as modifying the previous
    shell script. Just call `cargo bench` instead of `cargo benchcmp` and make sure
    that you move the `.criterion` folder to where you run the benchmarks (since it
    downloads two repositories).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此包含在你的Travis-CI构建中，只需修改之前的shell脚本即可。只需调用`cargo bench`而不是`cargo benchcmp`，并确保将`.criterion`文件夹移动到运行基准测试的位置（因为它下载了两个仓库）。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to benchmark your Rust application. You saw
    the different options and found out what was best for your particular needs. You
    also learned about some libraries that will help you compare the results of the
    benchmarks and even how to use them in your continuous integration environment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何基准测试你的Rust应用程序。你看到了不同的选项，并找到了最适合你特定需求的方案。你还了解了一些可以帮助你比较基准测试结果的库，甚至如何在持续集成环境中使用它们。
- en: For the next chapter, you will enter the world of metaprogramming by learning
    about Rust's macro system and the macros built in to the standard library.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将通过学习Rust的宏系统和标准库中内置的宏来进入元编程的世界。
