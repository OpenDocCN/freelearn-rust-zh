- en: Implementing an Asynchronous FTP Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现异步FTP服务器
- en: 'In the previous chapter, we wrote a synchronous FTP server. Now, we''ll write
    an asynchronous version with `tokio`, the asynchronous IO (Input/Output) library
    for Rust. We''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写了一个同步FTP服务器。现在，我们将使用`tokio`，Rust的异步IO（输入/输出）库，编写一个异步版本。我们将涵盖以下主题：
- en: Asynchronous servers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步服务器
- en: Futures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来
- en: Streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流
- en: Tokio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tokio
- en: Async/await
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Async/await
- en: Error handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Advantages of asynchronous IO
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步IO的优点
- en: Asynchronous IO allows us to send a request without waiting for its result,
    we'll get notified somehow later when we receive the response. This enables our
    programs to be more concurrent and scale better.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 异步IO允许我们在不等待其结果的情况下发送请求，我们将在稍后以某种方式收到响应时得到通知。这使得我们的程序更加并发，并且可以更好地扩展。
- en: In the previous chapter, we used threads in order to avoid blocking other clients
    while we wait for a response. Using threads has a cost, though, besides the fact
    that threads require more memory, they also impose a performance cost because
    they require a context switch when the code goes from one thread to the other.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了线程来避免在等待响应时阻塞其他客户端。虽然使用线程有成本，除了线程需要更多内存的事实之外，它们还因为代码从一条线程切换到另一条线程时需要上下文切换而带来性能成本。
- en: Disadvantages of asynchronous IO
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步IO的缺点
- en: However, using asynchronous IO does not come without drawbacks. Using asynchronous
    IO is harder than using synchronous IO. With asynchronous IO, we also need a way
    to know when an event has terminated. So, we need to learn a new way to manage
    the IO events and it'll take more time to implement the same software that we
    wrote in the previous chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用异步IO并非没有缺点。使用异步IO比使用同步IO更难。在使用异步IO的情况下，我们还需要一种方式来知道何时一个事件已经终止。因此，我们需要学习一种新的方式来管理IO事件，这将需要更多的时间来实现我们在上一章中编写的相同软件。
- en: Creating the new project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新项目
- en: 'Let''s start by creating a new binary project, as usual:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像往常一样先创建一个新的二进制项目：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll add the following dependencies in the `Cargo.toml` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Cargo.toml`文件中添加以下依赖项：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see here, we specify a dependency via a Git URL. This dependency
    is using nightly-only features, so make sure you''re using the nightly compiler
    by running this command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过Git URL指定了一个依赖项。这个依赖项使用仅限nightly的功能，所以请确保您正在使用nightly编译器，通过运行此命令来确保：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s start our `main` module by adding the required `extern crate` statements:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加所需的`extern crate`语句开始我们的`main`模块：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we're using some nightly features. These are needed by the `futures-await`
    crate. We also decided to import this crate under another name, `futures`, because
    it exports the same types and functions as the `futures` crate itself.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了一些nightly功能。这些功能是`futures-await`crate所需要的。我们还决定以另一个名称导入这个crate，即`futures`，因为它导出了与`futures`crate本身相同的类型和函数。
- en: 'We''ll copy some code from the previous chapter and put them in the new module,
    for better organization. Here are the new modules:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一章复制一些代码并将它们放入新的模块中，以获得更好的组织。以下是新模块：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a new file, called `src/cmd.rs`, put the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`src/cmd.rs`的新文件中，放置以下代码：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We first have an enumeration representing the different commands and their
    parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先有一个表示不同命令及其参数的枚举：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we create a method to get the string representation of a command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个获取命令字符串表示的方法：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This constructor parses a byte string as a `Command`. This requires a function
    to convert a byte string to uppercase:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数将字节字符串解析为`Command`。这需要一个将字节字符串转换为uppercase的函数：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We simply decrement all lowercase letters by 32 to convert them to uppercase:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将所有小写字母减去32来将它们转换为 uppercase：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we have an enumeration for the transfer type and a function to parse
    a byte character to this type. And in another file, `src/ftp.rs`, let''s write
    the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个表示传输类型的枚举和一个将字节字符解析为该类型的函数。在另一个文件`src/ftp.rs`中，让我们写下以下内容：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We're now ready to start working on the FTP server itself.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始着手处理FTP服务器本身了。
- en: Using Tokio
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tokio
- en: Tokio is based on the lower-level crate mio, which is itself directly based
    on system calls such as `epoll` (Linux), `kqueue` (FreeBSD), and IOCP (Windows).
    This crate is also based on the `futures` crate, which provides abstractions to
    reason about a value (or multiple values) that will be available later. As I told
    you when using asynchronous I/O, the calls do not block so we need a way to know
    when the result of a read is available. This is where `Future` and `Stream`, two
    abstractions from the `futures` crate, come into play.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Tokio基于较低级别的crate mio，而mio本身直接基于系统调用，如`epoll`（Linux）、`kqueue`（FreeBSD）和IOCP（Windows）。这个crate还基于`futures`
    crate，它提供了关于稍后可用的值（或多个值）进行推理的抽象。正如我告诉你的，在使用异步I/O时，调用不会阻塞，因此我们需要一种方式来知道读取的结果何时可用。这就是`Future`和`Stream`两个来自`futures`
    crate的抽象发挥作用的地方。
- en: Tokio event loop
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tokio事件循环
- en: Tokio also provides an event loop, on which we will be able to execute some
    code (with `futures`) that will be executed when some I/O events happen, such
    as when the result of a socket read is ready. To do so, the event loop will register
    events on specific file descriptors that represent sockets. It registers these
    events using the aforementioned system calls and then waits for any of the registered
    events to happen. The file descriptors and the system calls are low-level stuff
    that we do not need to know to use `tokio`, but it is important to understand
    how it works at the lower level. For instance, `epoll` does not support regular
    files, so if you try to wait for an event to happen on a regular file, it could
    block even though we're using asynchronous I/O which should not block.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Tokio还提供了一个事件循环，我们可以在其上执行一些代码（使用`futures`），当某些I/O事件发生时，例如当套接字读取的结果准备好时，这些代码将被执行。为此，事件循环将在表示套接字的具体文件描述符上注册事件。它使用上述系统调用注册这些事件，然后等待任何已注册的事件发生。文件描述符和系统调用是低级内容，我们不需要了解它们来使用`tokio`，但了解它在低级别上是如何工作的是很重要的。例如，`epoll`不支持常规文件，所以如果你尝试在常规文件上等待事件发生，即使我们使用异步I/O，它也可能阻塞。
- en: Using futures
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用future
- en: A `future` represents a value that will be available later, or an error, similar
    to the `Result` type. A `stream` represents multiple values (or errors) that will
    be available at different times in the `future`, similar to an `Iterator<Result<T>>`.
    This crate provides many combinators such as `and_then()`, `map()`, and others
    similar to the one available on the `Result` type. But, we won't use them, preferring
    the `async`/`await` syntax that we'll see later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`future`代表一个稍后可用的值，或者一个错误，类似于`Result`类型。一个`stream`代表多个值（或错误），这些值将在`future`中的不同时间可用，类似于`Iterator<Result<T>>`。这个crate提供了许多组合器，例如`and_then()`、`map()`等，类似于在`Result`类型上可用的组合器。但是，我们不会使用它们，更喜欢稍后我们将看到的`async`/`await`语法。
- en: Handling errors
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: Before we start coding the FTP server, let's talk about how we'll be handling
    the errors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写FTP服务器代码之前，让我们谈谈我们将如何处理错误。
- en: Unwrapping
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解包
- en: In the previous projects, we used the `unwrap()` or `expect()` methods a lot.
    These methods are handy for fast prototyping, but when we want to write high-quality
    software, we should avoid them in most cases. Since we're writing an FTP server,
    a software that must keep running for a long time, we don't want it to crash because
    we called `unwrap()` and a client sent a bad command. So, we'll do proper error
    handling.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的项目中，我们大量使用了`unwrap()`或`expect()`方法。这些方法对于快速原型设计很有用，但当我们想要编写高质量的软件时，我们应该在大多数情况下避免使用它们。由于我们正在编写一个FTP服务器，这是一个必须长时间运行的软件，我们不希望它因为调用`unwrap()`而崩溃，并且客户端发送了一个错误的命令。因此，我们将进行适当的错误处理。
- en: Custom error type
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义错误类型
- en: 'Since we can get different types of errors and we want to keep track of all
    of them, we''ll create a custom error type. Let''s create a new module in which
    we''ll put this new type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以得到不同类型的错误，并且我们希望跟踪所有这些错误，我们将创建一个自定义错误类型。让我们创建一个新的模块，我们将在这个模块中放置这个新类型：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add it to the `src/error.rs` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到`src/error.rs`文件中：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have an enum representing the different errors that can happen in our
    FTP server to be implemented. There are UTF-8 errors since FTP is a string-based
    protocol and I/O errors because we communicate over the network and communication
    issues can happen. We created variants for error types coming from the standard
    library, which will be helpful later when we want to compose different types of
    errors. We also created a variant `Msg` for our own errors and we represent them
    as a `String` since we only want to show them in the terminal (we could also log
    them to `syslog`, for instance).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个枚举，表示我们 FTP 服务器可能发生的不同错误，需要实现。由于 FTP 是基于字符串的协议，所以存在 UTF-8 错误；由于我们通过网络进行通信，所以存在
    I/O 错误，因为通信问题可能会发生。我们为来自标准库的错误类型创建了变体，这将在我们想要组合不同类型的错误时很有帮助。我们还创建了一个 `Msg` 变体来表示我们自己的错误，我们用
    `String` 来表示它们，因为我们只想在终端中显示它们（例如，我们也可以将它们记录到 `syslog` 中）。
- en: This is the standard way in Rust to represent an error type. It's a good practice
    to create this type, especially if your crate is a library, so that the users
    of your crate can know exactly why an error happened.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Rust 中表示错误类型的标准方式。如果你的 crate 是一个库，创建此类类型是一种良好的实践，这样 crate 的用户可以确切地知道错误发生的原因。
- en: Displaying the error
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示错误
- en: 'Since we want to print the error to the terminal, we''ll implement the `Display` trait
    for our `Error` type:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要将错误打印到终端，我们将为我们的 `Error` 类型实现 `Display` 特性：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the three cases where we wrap an error from another type, we just call the
    corresponding `fmt()` method of these errors. In the case that it is a `Msg`,
    we write the string using the `write!` macro. This macro is a bit similar to `print!`,
    but needs a parameter to specify where to write the formatted data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们包装来自其他类型的错误的三种情况，我们只需调用这些错误的相应 `fmt()` 方法。如果是 `Msg`，我们使用 `write!` 宏来写入字符串。这个宏与
    `print!` 类似，但需要一个参数来指定格式化数据写入的位置。
- en: 'It is not very helpful in our case, but it is recommended to also implement
    the `Error` trait for custom error types:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这并不很有帮助，但建议也实现自定义错误类型的 `Error` 特性：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The only required method of this trait is `description()`, which returns a short
    description of the error. Again, in the three cases, we just call the `description()`
    method from the wrapped type itself. And, for our `Msg` variant, we return the
    wrapped message.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特质的唯一必需方法是 `description()`，它返回错误的简短描述。同样，在三种情况下，我们只是从包装类型本身调用 `description()`
    方法。对于我们的 `Msg` 变体，我们返回包装的消息。
- en: 'It is possible that we don''t have a string to return from this method. If
    it is the case, we can just return `&''static str`, like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可能我们从这个方法中返回的字符串不存在。如果是这种情况，我们只需返回 `&'static str`，如下所示：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `cause()` method is optional and is used to return the cause of the error.
    Here, we return the inner error when there's one in the variant and return `None`
    for our `Msg` variant.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`cause()` 方法是可选的，用于返回错误的起因。在这里，当变体中有内部错误时，我们返回内部错误；对于我们的 `Msg` 变体，则返回 `None`。'
- en: 'The trait `Error` requires the `Self` type to implement both `Display` and
    `Debug`. We implemented `Display` earlier, but we don''t implement `Debug` yet.
    Let''s fix that by adding an attribute in front of the type declaration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error` 特性要求 `Self` 类型实现 `Display` 和 `Debug`。我们之前实现了 `Display`，但还没有实现 `Debug`。让我们通过在类型声明前添加一个属性来修复这个问题：'
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It is good practice to provide a type alias named `Result` that is specialized
    for our error type. Let''s write one:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个名为 `Result` 的类型别名，该别名专门针对我们的错误类型，这是一种良好的实践。让我们来写一个：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By doing so, we hide the original `Result` type from the standard library. That's
    why we're specifying a qualified version of this type. Otherwise, the compiler
    will assume that it is a recursive type, which is not the case here. We'll have
    to be careful when we import this type in other modules, because it hides the
    `Result` type. In case we want to use the original `Result` type, we'll have to
    use the same trick; qualifying it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们隐藏了标准库中的原始 `Result` 类型。这就是为什么我们要指定这个类型的限定版本。否则，编译器会假设它是一个递归类型，但在这里并不是这样。当我们需要在其他模块中导入此类型时，我们必须小心，因为它隐藏了
    `Result` 类型。如果我们想使用原始的 `Result` 类型，我们必须使用同样的技巧；限定它。
- en: Composing error types
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合错误类型
- en: 'The last thing we need to do in order to use all the good practices for error
    types in Rust is to make them easy to compose, because, for now, if we have another
    error type, such as `io::Error`, we would need to use the following code every
    time we have another type:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Rust 中使用所有关于错误类型的良好实践，我们需要做的是使它们易于组合，因为，目前，如果我们有另一个错误类型，例如 `io::Error`，每次我们遇到另一个类型时，我们都需要使用以下代码：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This can quickly become cumbersome. To improve that, we''ll implement the `From` trait
    for different error types:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这很快就会变得繁琐。为了改进这一点，我们将为不同的错误类型实现 `From` 特性：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These implementations are easy to understand: if we have an `io::Error`, we
    just wrap them in the corresponding variant. We also added a convenient conversion
    from the `&str` type.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现很容易理解：如果我们有一个 `io::Error`，我们只需将其包装在相应的变体中。我们还添加了从 `&str` 类型到方便的转换。
- en: 'This will allow us to use the following, which is not really better, but the
    good old `?` operator will help us to reduce the boilerplate:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们使用以下内容，这并不真正更好，但古老的 `?` 操作符将帮助我们减少样板代码：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The ? operator, revisited
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视 ? 操作符
- en: 'This operator will not only return the error if there is one, but will also
    convert it to the required type. It converts it with a call to `Into::into()`,
    `Into` being a trait. But why did we implement the `From` trait, instead of `Into`?
    Because there''s a generic implementation of `Into` which is based on `From`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作符不仅会在有错误时返回错误，还会将其转换为所需类型。它通过调用 `Into::into()` 来转换，其中 `Into` 是一个特性。但为什么我们实现了
    `From` 特性，而不是 `Into`？因为有一个基于 `From` 的 `Into` 的泛型实现：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Thanks to this implementation, we rarely need to implement the `Into` trait
    ourselves. We only need to implement the `From` trait.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个实现，我们很少需要自己实现 `Into` 特性。我们只需要实现 `From` 特性。
- en: 'This means that we can rewrite the previous code as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将之前的代码重写如下：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And it will behave exactly the same as before.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它的行为将完全与之前相同。
- en: Starting the Tokio event loop
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 Tokio 事件循环
- en: 'In `tokio`, the object we need to use to manage an event loop is `Core`. Here''s
    how we start an event loop using `tokio` (in the `main` module):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tokio` 中，我们需要用来管理事件循环的对象是 `Core`。以下是使用 `tokio`（在 `main` 模块中）启动事件循环的方法：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We first create a new `Core` object, and then call the `run()` method to start
    the event loop. The latter method will return when the provided future ends. Here,
    we call `server()` to get the future, so let''s write this function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的 `Core` 对象，然后调用 `run()` 方法来启动事件循环。后者方法将在提供的 future 结束时返回。在这里，我们调用
    `server()` 来获取 future，所以让我们编写这个函数：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, we use the `#[async]` attribute. Since attributes are currently
    instable in Rust, we had to specify that we are using the `proc_macro` feature.
    We also import the `async` attribute from the `futures_await` crate (which was
    imported under the name `futures`). So don't forget the `#![feature]` attribute
    and the `extern crate` statements at the top.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了 `#[async]` 属性。由于属性在 Rust 中目前是不稳定的，我们必须指定我们正在使用 `proc_macro` 功能。我们还从
    `futures_await` 包（在名称 `futures` 下导入）中导入 `async` 属性。所以不要忘记在顶部添加 `#![feature]` 属性和
    `extern crate` 语句。
- en: This attribute allows us to write a normal function, returning a `Result`, and
    will convert this function to actually return a `Future`. This function does nothing
    and returns `Ok(())`, so when you run the program, it will end immediately.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性允许我们编写一个返回 `Result` 的普通函数，并将此函数转换为实际上返回 `Future` 的函数。此函数不做任何事情并返回 `Ok(())`，因此当你运行程序时，它将立即结束。
- en: 'There''s another syntax we could have used that is provided by the `futures-await`
    crate:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用由 `futures-await` 包提供的另一种语法：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We won't use this syntax in our FTP server, but it is worth knowing about. By
    using an `async_block`, we are not required to create a new function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 FTP 服务器中，我们不会使用这种语法，但了解它是有价值的。通过使用 `async_block`，我们不需要创建一个新的函数。
- en: Starting the server
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'The program we just wrote does absolutely nothing, so let''s update it so that
    it at least starts a server, using `tokio`. Let''s write an actual body to our
    `server()` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才编写的程序实际上什么也没做，所以让我们更新它，至少让它启动一个服务器，使用 `tokio`。让我们为我们的 `server()` 函数编写一个实际的主体：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The function now takes a `Handle`, which will be useful to specify on which
    event loop the server must run. We start this function by specifying on which
    port we want to start the server by creating a `SocketAddr`. Then, we create a
    `TcpListener` in a similar way to how we would create a synchronous `TcpListener`
    from the standard library. The difference here is that we also send the `handle`
    as an argument to specify on which event loop we want the server to run. After
    that, we use the `#[async]` attribute again, but on a `for` loop this time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数现在接受一个`Handle`，这将有助于指定服务器必须在哪个事件循环上运行。我们通过创建`SocketAddr`来指定我们想要在哪个端口上启动服务器。然后，我们以类似于从标准库创建同步`TcpListener`的方式创建一个`TcpListener`。这里的区别是，我们还发送`handle`作为参数来指定我们想要服务器在哪个事件循环上运行。之后，我们再次使用`#[async]`属性，但这次是在一个`for`循环上。
- en: Async `for` loops are used to iterate over a `Stream`, returning an error if
    there is one. These async loops can only be used in an `#[async]` function. In
    the loop, we spawn the future returned by `handle_client()`. Spawning a future
    means that it will be executed and handled by the event loop. The difference with
    `Core::run()` is that the future must return `()` and the error should also be
    `()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 异步`for`循环用于遍历`Stream`，如果存在错误则返回错误。这些异步循环只能在`#[async]`函数中使用。在循环中，我们生成`handle_client()`返回的未来。生成一个未来意味着它将被事件循环执行和处理。与`Core::run()`的区别是，未来必须返回`()`，错误也应该也是`()`。
- en: 'Now that this function takes an argument, we''ll need to update the `main`
    function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个函数接受一个参数，我们需要更新`main`函数：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Handling clients
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理客户端
- en: 'Let''s now see the `handle_client()` function we''ve just mentioned:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们刚才提到的`handle_client()`函数：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is a simple wrapper over the `client` future. Here, we used a new macro,
    `await!`, which allows us to write asynchronous code in an asynchronous way. When
    the result of the future inside `await!()` is not ready, the event loop will execute
    other stuff, and when it's ready it will continue executing the code after the
    `await!()`. In this case, we print the error returned by the `client` future.
    This is why we needed a wrapper.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的`client`未来的包装器。在这里，我们使用了一个新的宏`await!`，它允许我们以异步的方式编写异步代码。当`await!()`内部的未来结果未准备好时，事件循环将执行其他操作，当它准备好时，它将继续执行`await!()`之后的代码。在这种情况下，我们打印出`client`未来返回的错误。这就是为什么我们需要一个包装器的原因。
- en: 'Now, let''s write this `client` future:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写这个`client`未来：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we specify that the `stream` will be handled by a `FtpCodec`, which means
    that we''ll be able to encode and decode structured data instead of dealing with
    bytes directly. We''ll write this `FtpCodec` soon. Then, we split the stream between
    a `reader` and a `writer`. This `split()` method is very useful in Rust, because
    of ownership: we cannot have two owners, one that will write to the socket and
    another that will read to it. To fix this issue, we split the stream and we can
    now have an owner for the `reader` and another owner for the `writer`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定`stream`将由`FtpCodec`处理，这意味着我们将能够对结构化数据进行编码和解码，而不是直接处理字节。我们将很快编写这个`FtpCodec`。然后，我们将流分割成`reader`和`writer`。在Rust中，这个`split()`方法非常有用，因为它是关于所有权的：我们不能有两个所有者，一个将写入套接字，另一个将读取它。为了解决这个问题，我们分割了流，现在我们可以有一个`reader`的所有者，另一个`writer`的所有者。
- en: Then, we use the `writer` to send a welcome message. Again, we use the `await!`
    macro to specify that the code after will be executed when the message is sent
    (but without blocking the whole program, thanks to asynchronous I/O). Next, we
    create a `Client` which will be the object that will manage a client, by executing
    the appropriate actions when it receives commands and sending the right responses.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`writer`发送欢迎消息。同样，我们使用`await!`宏来指定在消息发送后，代码将会被执行（但不会阻塞整个程序，多亏了异步I/O）。接下来，我们创建一个`Client`对象，它将负责管理客户端，通过在接收到命令时执行适当的操作并发送正确的响应。
- en: After that, we use again an `#[async] for` loop to iterate over a stream; here,
    we iterate over the stream of the data received by this specific client. In the
    `for` loop, we call the `handle_cmd()` method that we will soon write. This method,
    as its name indicates, will handle the command received from this FTP client,
    act accordingly, and send a response back. Here, we use `await!()?` with a question
    mark at the end. The `futures-await` crate allows us to do so; this means that
    if the future returned an error, this error will propagate to the `client` future,
    which is the same semantic for the normal `?` operator used in a function returning
    a `Result`. We'll see why we reassign the result to `client` when we write the
    `handle_cmd()` method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们再次使用`#[async] for`循环来遍历一个流；在这里，我们遍历由该特定客户端接收到的数据流。在`for`循环中，我们调用即将编写的`handle_cmd()`方法。这个方法，正如其名称所示，将处理从该
    FTP 客户端接收到的命令，相应地执行操作，并发送响应。在这里，我们使用`await!()?`并在末尾加上问号。`futures-await` crate
    允许我们这样做；这意味着如果未来返回了错误，这个错误将传播到`client`未来，这与在返回`Result`的函数中使用的正常`?`运算符的语义相同。我们将在编写`handle_cmd()`方法时看到为什么我们将结果重新分配给`client`。
- en: Handling commands
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理命令
- en: 'To handle the commands received by the FTP server, we''ll have a `Client` struct:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理 FTP 服务器接收到的命令，我们将有一个`Client`结构体：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The client contains a `Writer` object that will be useful to send messages
    to the client. The `Writer` type represents a `Sink` that has been split, and
    uses the `FtpCodec` on a `TcpStream`. A `Sink` is the opposite of a `Stream`:
    instead of representing a sequence of values that are received, it represents
    a sequence of values that are sent.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端包含一个`Writer`对象，该对象将用于向客户端发送消息。`Writer`类型代表一个已分割的`Sink`，并在`TcpStream`上使用`FtpCodec`。`Sink`是`Stream`的相反面：它不表示接收到的值的序列，而是表示发送的值的序列。
- en: 'We used two methods on `Client`, so let''s write them:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Client`上使用了两个方法，所以让我们编写它们：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The constructor is very simple and creates the `struct` with the provided argument.
    The `handle_cmd()` receives the command sent to the FTP server by this specific
    client and will handle them; we''ll write the code to handle them progressively
    in this chapter and the next. For now, it only returns `self`. Also, take note
    that this method receives `self` by move, instead of by `reference`. This is due
    to a current limitation of the `futures-await` crate: for now, async functions
    cannot take a reference. This issue will probably be fixed later, which will make
    the code even better. This is why we reassigned to the `client` variable in the
    `client` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数非常简单，它使用提供的参数创建`struct`。`handle_cmd()`接收由该特定客户端发送到 FTP 服务器的命令，并将处理它们；我们将在本章和下一章中逐步编写处理它们的代码。目前，它只返回`self`。请注意，此方法通过移动而不是通过引用接收`self`。这是由于`futures-await`
    crate 当前的一个限制：目前，异步函数不能接收引用。这个问题可能会在以后得到解决，这将使代码更加完善。这就是为什么我们在`client`函数中将它重新分配给`client`变量的原因：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: FTP codec
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 编解码器
- en: 'The only remaining thing to code before we can try our FTP server is the `codec`.
    So, let''s create a new module for the `codec`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以尝试我们的 FTP 服务器之前，唯一剩下要编写的代码是`codec`。因此，让我们为`codec`创建一个新的模块：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `src/codec.rs` file, we''ll create our FTP `codec`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/codec.rs`文件中，我们将创建我们的 FTP `codec`：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To create a `codec`, we must implement the traits `Decoder` and `Encoder`.
    These traits come from the `tokio-io` crate:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`codec`，我们必须实现`Decoder`和`Encoder`这两个特质。这些特质来自`tokio-io` crate：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Decoding FTP commands
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码 FTP 命令
- en: 'Let''s first write the decoder:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先编写解码器：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `Decoder` trait has two associated types, `Item` and `Error`. The former
    is the type produced when we're able to decode a sequence of bytes. The latter
    is the type of the error. We first check if there the bytes `CR` and `LF`. If
    we don't find them, we return `Ok(None)` to indicate that we need more bytes to
    parse the command. If we find them, we get the line of the command, excluding
    these bytes. Then, we skip these bytes so that the next parsing does not see them.
    Finally, we parse the line with `Command::new()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decoder`特质有两个关联类型，`Item`和`Error`。前者是在我们能够解码一系列字节时产生的类型。后者是错误类型。我们首先检查是否存在字节`CR`和`LF`。如果我们找不到它们，我们返回`Ok(None)`以指示我们需要更多的字节来解析命令。如果我们找到了它们，我们就获取命令的行，排除这些字节。然后，我们跳过这些字节，这样下一次解析就不会看到它们。最后，我们使用`Command::new()`解析这一行。'
- en: 'We used two new functions here that we must implement. The first one is the
    `Error::to_io_error()` method that we''ll add to the `error` module:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了两个必须实现的新函数。第一个是添加到`error`模块的`Error::to_io_error()`方法：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we have an `Io` error, we return it. Otherwise, we return the `Other` kind
    of I/O error.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到 `Io` 错误，我们返回它。否则，我们返回 `Other` 类型的 I/O 错误。
- en: 'The `decode()` methods also uses the following function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`decode()` 方法也使用了以下函数：'
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This returns the position of the byte string `"\r\n"` if it is present. Remember
    that this string is the delimiter in the FTP protocol.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在字节字符串 `"\r\n"`，则返回其位置。请记住，这个字符串是 FTP 协议中的分隔符。
- en: Encoding FTP commands
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码 FTP 命令
- en: 'We still need to write an `Encoder` in order to have a `codec` that can send
    commands to FTP clients:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要编写一个 `Encoder`，以便有一个可以发送命令到 FTP 客户端的 `codec`：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, if we have a non-empty message, we push it to the buffer, preceded by
    the FTP code number. Otherwise, we only push this code number to the buffer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们有一个非空的消息，我们将其推送到缓冲区，前面是 FTP 代码号。如果没有消息，我们只推送这个代码号到缓冲区。
- en: 'We can now try the FTP server in FileZilla to see the following result:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试在 FileZilla 中运行 FTP 服务器以查看以下结果：
- en: '![](img/00043.jpeg)*Figure 9.1*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1](img/00043.jpeg)*图9.1*'
- en: Handling commands
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理命令
- en: 'Our `handle_cmd()` method does nothing, for now, so let''s update it. First
    of all, we''ll need a method to send a response to a client:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `handle_cmd()` 方法目前什么也不做，所以让我们更新它。首先，我们需要一个方法向客户端发送响应：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This simply calls the `send()` method of the `writer`. Since it consumes it,
    we reassign the result to the attribute.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是调用了 `writer` 的 `send()` 方法。由于它消耗了它，我们将结果重新分配给属性。
- en: 'Now, we''ll handle the `USER` FTP command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理 `USER` FTP 命令：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we pattern match to know which command was sent by the client. If it is
    not `User`, we send a response to say that the command is not implemented. If
    it is `User`, we check the content and if it is good, we send the welcome message.
    This is very similar to what we did in the previous chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过模式匹配来了解客户端发送了哪个命令。如果不是 `User`，我们发送一个响应来说明该命令尚未实现。如果是 `User`，我们检查内容，如果内容良好，我们发送欢迎信息。这与我们在上一章中做的非常相似。
- en: 'If we run the server again, we''ll see the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行服务器，我们会看到以下内容：
- en: '>![](img/00044.jpeg)*Figure 9.2*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>>![图9.2](img/00044.jpeg)*图9.2*'
- en: Managing the current working directory
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理当前工作目录
- en: There are still a few commands missing before we can see the files in the FTP
    client. Let's now add the command to print the current directory and to change
    it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够在 FTP 客户端中看到文件之前，还有一些命令缺失。现在让我们添加打印当前目录和更改目录的命令。
- en: Printing the current directory
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印当前目录
- en: 'First of all, we''ll need a new attribute for our `Client` structure to specify
    what the current directory is:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的 `Client` 结构添加一个新的属性来指定当前目录：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `cwd` attribute stands for current working directory. We also need to update
    the `Client` constructor accordingly:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`cwd` 属性代表当前工作目录。我们还需要相应地更新 `Client` 构造函数：'
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can add the handler for the `PWD` command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加 `PWD` 命令的处理程序：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, again, we have a code similar to the previous chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次强调，我们有一个与上一章类似的代码。
- en: Changing the current directory
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改当前目录
- en: 'Let''s add another case in our `match` expression in the `handle_cmd()` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `handle_cmd()` 方法中的 `match` 表达式中添加另一个情况：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It simply calls the following method:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是调用了以下方法：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code uses the following two methods, which are similar to those in the
    previous chapter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用了以下两个方法，它们与上一章中的类似：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Since it uses a new attribute, let''s add it to the `Client` structure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它使用了一个新的属性，让我们将其添加到 `Client` 结构中：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We also add its constructor:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了其构造函数：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also need to pass this value in a few places, first, in the `client` function
    and its wrapper:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在几个地方传递这个值，首先是在 `client` 函数及其包装器中：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we need to update the `server` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新 `server` 函数：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To send the server root to the `handle_client` function call.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务器根目录发送到 `handle_client` 函数调用。
- en: 'And finally, we''ll update the main function to send it to the `server` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新主函数以将其发送到 `server` 函数：
- en: '[PRE52]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we send the current directory as the server root.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将当前目录作为服务器根目录发送。
- en: Setting the transfer type
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置传输类型
- en: 'Let''s add a new command before we test our server again:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们再次测试服务器之前，让我们添加一个新的命令：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This requires a new attribute for our `Client` structure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要为我们的 `Client` 结构添加一个新的属性：
- en: '[PRE54]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And we need to update the constructor:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新构造函数：
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we run this new server and connect to it through FileZilla, we''ll see the
    following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个新的服务器并通过 FileZilla 连接到它，我们会看到以下内容：
- en: '![](img/00045.jpeg) *Figure 9.3*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3](img/00045.jpeg) *图9.3*'
- en: Entering passive mode
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入被动模式
- en: 'Let''s now write the code to handle the `PASV` command. Add the following case
    in `handle_cmd()`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写处理 `PASV` 命令的代码。在 `handle_cmd()` 中添加以下情况：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For the following, we''ll need four new fields in the `Client` structure:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下内容，我们需要在 `Client` 结构中添加四个新字段：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And all of them are initialized to `None`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都被初始化为 `None`：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This requires changing a few other functions to send the `Handle` to the `Client`
    constructor. First, the `client` function now requires a new `handle` parameter:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要更改几个其他函数以将 `Handle` 发送到 `Client` 构造函数。首先，`client` 函数现在需要一个新的 `handle` 参数：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `handle_client()` method also needs to take a new parameter:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_client()` 方法也需要一个新的参数：'
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And in the `server()` function, you need to send the `handler` to the `handle_client()`
    function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server()` 函数中，你需要将 `handler` 发送到 `handle_client()` 函数：
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And here is the start of the method that does the real stuff for the `PASV`
    command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行 `PASV` 命令实际功能的方法的开始：
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If a port was set by an earlier command, we use it, otherwise, we use zero
    to ask the system to choose one. As you know from the previous chapter, there
    are two channels in FTP—the command channel and the data channel. So, here, we
    check whether the data channel is already open. If that is the case, we send the
    appropriate response and end the function by returning. Here''s the rest of the
    method:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前有命令设置了端口，我们使用它，否则我们使用零以请求系统选择一个。如您从上一章所知，FTP 有两个通道——命令通道和数据通道。因此，这里我们检查数据通道是否已经打开。如果是这种情况，我们发送适当的响应并通过返回结束函数。以下是方法的其余部分：
- en: '[PRE63]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We start by starting the listener for the data channel. See the following line:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先启动数据通道的监听器。看以下行：
- en: '[PRE64]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is used to get the port that was chosen by the system, if we specified
    port `0` to let the operating system choose a port. Then, we use an `async for`
    loop that breaks immediately after the first iteration because we only have one
    client that will connect to this new channel. In the loop, we're using the same
    split trick again; after saying that our stream uses the `BytesCodec`, we split
    the stream between the `writer` and the `reader`. We'll describe this new `codec`
    shortly. We then same both the data `writer` and `reader`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于获取系统选择的端口，如果我们指定了端口 `0` 以让操作系统选择一个端口。然后，我们使用一个 `async for` 循环，在第一次迭代后立即中断，因为我们只有一个客户端将连接到这个新通道。在循环中，我们再次使用相同的拆分技巧；在说我们的流使用
    `BytesCodec` 之后，我们在 `writer` 和 `reader` 之间拆分流。我们很快就会描述这个新的 `codec`。然后我们保存数据 `writer`
    和 `reader`。
- en: Bytes codec
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节编解码器
- en: 'We start by creating an empty structure for the `codec`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为 `codec` 创建一个空的结构：
- en: '[PRE65]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Decoding data bytes
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码数据字节
- en: 'Then, we implement the `Decoder` trait like we did for the `FtpCodec`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们像为 `FtpCodec` 实现的那样实现 `Decoder` 特性：
- en: '[PRE66]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Since the data of a transmitted file can be binary, we cannot use an `Item`
    of type `String`. We instead use `Vec<u8>`, which we can contain every possible
    byte. If the buffer is empty, we return `Ok(None)` to indicate to `tokio` that
    we need more data. Otherwise, we convert it to a vector, clear the buffer and
    return the vector.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传输的文件数据可以是二进制，我们不能使用类型为 `String` 的 `Item`。我们改用 `Vec<u8>`，它可以包含每一个可能的字节。如果缓冲区为空，我们返回
    `Ok(None)` 以指示 `tokio` 我们需要更多数据。否则，我们将它转换为向量，清空缓冲区并返回该向量。
- en: Encoding data bytes
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码数据字节
- en: 'Let''s now see how to encode data; it''s even simpler:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何编码数据；这甚至更简单：
- en: '[PRE67]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We just extend the buffer with the data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将数据扩展到缓冲区。
- en: Quitting
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出
- en: 'Let''s now implement the `QUIT` command. As always, we need to add a case in
    the `handle_cmd()` method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现 `QUIT` 命令。像往常一样，我们需要在 `handle_cmd()` 方法中添加一个情况：
- en: '[PRE68]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And here is the code of the `quit()` method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `quit()` 方法的代码：
- en: '[PRE69]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: So, we send a response back to the client and `close()` the `writer`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们向客户端发送响应并 `close()` `writer`。
- en: To finish this chapter, let's implement the command to create and delete directories.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一章，让我们实现创建和删除目录的命令。
- en: Creating directories
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目录
- en: 'We''ll start by handling the command to create a new directory. So, we add
    a case in `handle_cmd()`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始处理创建新目录的命令。因此，我们在 `handle_cmd()` 中添加一个情况：
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And the function handling this command is:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此命令的函数是：
- en: '[PRE71]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We first check that the `parent` directory is valid and under the server root:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查父目录是否有效并且位于服务器根目录下：
- en: '[PRE72]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If it is, we create the directory. Otherwise, we send an error.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是，我们创建目录。否则，我们发送错误。
- en: 'This requires two new functions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要两个新函数：
- en: '[PRE73]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: These are simple wrappers over the methods from the standard library, doing
    type conversion.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是标准库方法的简单包装，执行类型转换。
- en: Removing directories
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除目录
- en: 'Finally, let''s see the code to remove directories:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看删除目录的代码：
- en: '[PRE74]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Like for the previous commands, we add a new case that calls the method that
    will handle it:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的命令类似，我们添加了一个新的情况，调用处理它的方法：
- en: '[PRE75]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here again, we check that the directory is valid and under the server root,
    and delete it if that is the case. Otherwise, we send an error message.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次检查目录是否有效且位于服务器根目录下，如果是这种情况，则删除它。否则，我们发送一个错误消息。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented a lot of commands for our asynchronous FTP server
    and learned about using `tokio`. We also saw in more detail what asynchronous
    I/O is, and its advantages and disadvantages. We used the new `async`/`await`
    syntax to simplify the code using `tokio`. We learned what futures and streams are, and
    how they interact with `tokio`. We also saw how to do proper error handling and
    how to do it concisely. In the next chapter, we'll complete the implementation
    of the FTP server and see how to test it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为我们的异步FTP服务器实现了很多命令，并学习了使用`tokio`。我们还更详细地了解了异步I/O是什么，以及它的优缺点。我们使用新的`async`/`await`语法简化了使用`tokio`的代码。我们学习了什么是futures和streams，以及它们如何与`tokio`交互。我们还看到了如何进行适当的错误处理，以及如何简洁地处理。在下一章，我们将完成FTP服务器的实现，并了解如何对其进行测试。
