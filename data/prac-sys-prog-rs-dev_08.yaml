- en: '*Chapter 6*: Working with Files and Directories in Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：在 Rust 中处理文件和目录'
- en: In the previous chapter, we looked at the details of how Rust uses memory, a
    key system resource.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Rust 使用内存的细节，内存是关键的系统资源。
- en: In this chapter, we will look at how Rust interacts with another important class
    of system resources – **files** and **directories**. The Rust Standard Library
    offers a rich set of abstractions that enable platform-independent file and directory
    operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Rust 如何与另一类重要的系统资源——**文件**和**目录**——交互。Rust 标准库提供了一套丰富的抽象，使得平台无关的文件和目录操作成为可能。
- en: For this chapter, we will review the basics of how files are managed by Unix/Linux,
    and master the key APIs that the Rust Standard Library provides to deal with *files*,
    *paths*, *links*, and *directories*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将回顾 Unix/Linux 管理文件的基本知识，并掌握 Rust 标准库提供的用于处理**文件**、**路径**、**链接**和**目录**的关键
    API。
- en: Using the Rust Standard Library, we will implement a shell command, `rstat`,
    that counts the total number of lines of Rust code in a directory (and its subfolders),
    and provides a few additional source code metrics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rust 标准库，我们将实现一个 shell 命令 `rstat`，该命令计算目录（及其子目录）中 Rust 代码的总行数，并提供一些额外的源代码度量指标。
- en: 'We will cover the topics in the following order:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下顺序介绍主题：
- en: Understanding Linux system calls for file operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux 文件操作的系统调用
- en: Doing file I/O in Rust
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中进行文件 I/O 操作
- en: Learning directory and path operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习目录和路径操作
- en: Setting hard links, symbolic links, and performing queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置硬链接、符号链接和执行查询
- en: Writing a shell command in Rust (project)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中编写 shell 命令（项目）
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Verify that `rustc`, and `cargo` have been installed correctly with the following
    command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证 `rustc` 和 `cargo` 是否已正确安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的 Git 仓库可以在 [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06)
    找到。
- en: Understanding Linux system calls for file operations
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Linux 文件操作的系统调用
- en: In this section, we will look at the terminology and basic mechanisms associated
    with managing file system resources at the operating system level. We will use
    Linux/Unix as an example, but similar concepts apply to other operating systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨与操作系统级别管理文件系统资源相关的术语和基本机制。我们将以 Linux/Unix 为例，但类似的概念也适用于其他操作系统。
- en: So, what do you think a file is?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你认为文件是什么？
- en: A **file** is just a set of bytes. A **byte** represents a unit of information—it
    can be a number, text, video, audio, image, or any other such digital content.
    The bytes are organized in a *linear array* called a **byte stream**. There is
    no other expectation in terms of the structure or contents of a file, as far as
    the operating system is concerned. It is the *user application* that does the
    interpretation of the file and its contents.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**只是一组字节。**字节**代表信息的一个单位——它可以是一个数字、文本、视频、音频、图像或其他类似的数字内容。字节组织在一个称为**字节流**的**线性数组**中。从操作系统的角度来看，文件的结构或内容没有其他期望。对文件的解释及其内容是由**用户应用程序**来完成的。'
- en: A **user application** is a program that is not a part of the operating system
    kernel. An example of a user application is an image viewer that interprets the
    bytes of data as an image. Since files are resources that are managed by the operating
    system, any user programs that we write must know how to interact with the operating
    system through system calls. A file can be read from, written to, or executed.
    An example of a file that can be executed is the binary executable (object) file,
    generated by software build systems such as **Make** or **Cargo**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户应用程序**是一个不属于操作系统内核的程序。一个用户应用程序的例子是图像查看器，它将数据字节解释为图像。由于文件是由操作系统管理的资源，因此我们编写的任何用户程序都必须知道如何通过系统调用来与操作系统交互。文件可以被读取、写入或执行。一个可以执行的文件示例是由
    **Make** 或 **Cargo** 等软件构建系统生成的二进制可执行（对象）文件。'
- en: 'Another aspect that is unique to Linux/Unix is the philosophy that *everything
    is a file*. Here, *everything* refers to system resources. There can be many types
    of files on Linux/Unix:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Linux/Unix独有的另一个方面是“一切皆文件”的哲学。在这里，“一切”指的是系统资源。Linux/Unix上可以存在许多类型的文件：
- en: '**Regular files**, which we use to store text or binary data'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常规文件**，我们用它来存储文本或二进制数据'
- en: '**Directories**, which contain listings of names and references to other files'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**，包含名称列表和其他文件的引用'
- en: '**Block device files**, for example, a hard disk, a tape drive, USB cameras'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块设备文件**，例如硬盘、磁带驱动器、USB摄像头'
- en: '**Character device files**, for example, a terminal, a keyboard, a printer,
    a sound card'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符设备文件**，例如终端、键盘、打印机、声卡'
- en: '**Named pipes**, an in-memory inter-process communication mechanism'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名管道**，一种内存中的进程间通信机制'
- en: '**Unix domain sockets**, also a form of inter-process communication'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix域套接字**，也是一种进程间通信的形式'
- en: '**Links**, such as hard links and symbolic links'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**，如硬链接和符号链接'
- en: In this chapter, we will focus on files, directories, and links. However, the
    universality of the Unix I/O model means that the same set of system calls used
    to open, read, write, and close regular files can also be used on any other types
    of files such as **device files**. This is achieved in Linux/Unix by standardizing
    the system calls, which are then implemented by various filesystems and device
    drivers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注文件、目录和链接。然而，Unix I/O模型的通用性意味着用于打开、读取、写入和关闭常规文件的同一系列系统调用也可以用于任何其他类型的文件，如**设备文件**。在Linux/Unix中，这是通过标准化系统调用实现的，然后由各种文件系统和设备驱动程序实现。
- en: Linux/Unix also provides a unified `/mnt/cdrom`, which becomes the location
    to access the root of the filesystem. The root directory of a "filesystem" can
    be accessed at the mount point.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Linux/Unix还提供了一个统一的`/mnt/cdrom`，它成为访问文件系统根目录的位置。文件系统的根目录可以在挂载点访问。
- en: The **mount namespace** of a process is the set of all mounted filesystems it
    sees. A process that makes system calls for file operations operates on the set
    of files and directories that it sees as a part of its mount namespace.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的**挂载命名空间**是它看到的所有挂载文件系统的集合。执行文件操作的系统调用进程在它视为其挂载命名空间一部分的文件和目录集合上操作。
- en: 'The Unix/Linux system calls (**Application Programming Interface - API**) model
    for file operations hinges on four operations: **open**, **read**, **write**,
    and **close**, all of which work with the concept of **file descriptors**. What
    is a file descriptor?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Unix/Linux系统调用（**应用程序编程接口 - API**）模型中的文件操作依赖于四个操作：**打开**、**读取**、**写入**和**关闭**，所有这些操作都与**文件描述符**的概念相关。什么是文件描述符？
- en: A file descriptor is a handle to a file. Opening a file returns a file descriptor,
    and other operations such as reading, writing, and closing use the file descriptor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是文件的句柄。打开一个文件会返回一个文件描述符，而读取、写入和关闭等操作则使用文件描述符。
- en: More about file descriptors
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于文件描述符的信息
- en: File operations such as read and write are performed by processes. A process
    performs these operations by invoking system calls on the kernel. As soon as a
    file is opened by a process, the kernel records it in a *file table*, where each
    entry contains details of the open file including the **file descriptor** (**fd**)
    and **file position**. Each Linux process has a limit on the number of files it
    can open.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 读写等文件操作由进程执行。进程通过在内核上调用系统调用来执行这些操作。一旦进程打开一个文件，内核就会在**文件表**中记录它，其中每个条目都包含打开文件的详细信息，包括**文件描述符**（**fd**）和**文件位置**。每个Linux进程对其可以打开的文件数量都有一个限制。
- en: 'To the kernel, all open files are referred to by file descriptors. When a process
    opens an existing file or creates a new file, the kernel returns a file descriptor
    to the process. By default, when a process is started from a shell, three file
    descriptors are automatically created: `open: 0 – standard input (stdin)`, `1-
    standard output(stdout)`, and `2-standard error(stderr)`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '对于内核来说，所有打开的文件都通过文件描述符来引用。当进程打开一个现有文件或创建一个新文件时，内核会返回一个文件描述符给进程。默认情况下，当进程从shell启动时，会自动创建三个文件描述符：`open:
    0 – 标准输入(stdin)`、`1- 标准输出(stdout)`和`2- 标准错误(stderr)`。'
- en: The kernel maintains a table of all open file descriptors. If the process opens
    or creates a file, the kernel allocates the next free file descriptor from the
    pool of free file descriptors. When a file is closed, the file descriptor is released
    back to the pool and is available for re-allotment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 内核维护一个所有打开文件描述符的表。如果进程打开或创建一个文件，内核从空闲文件描述符池中分配下一个空闲的文件描述符。当文件关闭时，文件描述符被释放回池中，并可用于重新分配。
- en: 'Let''s now look at the common *system calls* associated with file operations,
    which the operating system exposes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下与文件操作相关的常见 *系统调用*，操作系统将这些调用暴露出来：
- en: '`open()`: This system call opens an existing file. It can also create a new
    file if the file does not exist. It accepts a pathname, the mode in which the
    file is to be opened, and flags. It returns a file descriptor that can be used
    in subsequent system calls to access the file:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open()`: 这个系统调用打开一个现有文件。如果文件不存在，它还可以创建一个新文件。它接受一个路径名、文件打开的模式和标志。它返回一个文件描述符，可以在后续的系统调用中使用该文件描述符来访问文件：'
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`read()`: This system call accepts three arguments: a *file descriptor*, the
    *number of bytes* to be read, and the *memory address of the buffer* into which
    the data read is to be placed. It returns the number of bytes read. `-1` is returned
    in the event of an error when reading the file.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read()`: 这个系统调用接受三个参数：一个 *文件描述符*、要读取的 *字节数* 以及数据读取后要放置的 *缓冲区内存地址*。它返回读取的字节数。在读取文件时发生错误时返回
    `-1`。'
- en: '`write()`: This system call is similar to `read()`, in that it also takes three
    parameters – a *file descriptor*, a *buffer pointer* from which to read the data,
    and the *number of bytes* to read from the buffer. Note that successful completion
    of the `write()` system call does not guarantee that the bytes have been written
    to disk immediately, as the kernel performs buffering of I/O to disk for performance
    and efficiency reasons.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write()`: 这个系统调用与 `read()` 类似，因为它也接受三个参数——一个 *文件描述符*、一个从其中读取数据的 *缓冲区指针* 以及从缓冲区中读取的
    *字节数*。请注意，`write()` 系统调用的成功完成并不保证字节立即写入磁盘，因为内核为了性能和效率原因对磁盘的 I/O 进行了缓冲。'
- en: '`close()`: This system call accepts a *file descriptor* and releases it. If
    a `close()` call is not explicitly invoked for a file, all open files are closed
    when the process terminates. But it is good practice to release file descriptors
    (when no longer needed) for reuse by the kernel.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close()`: 这个系统调用接受一个 *文件描述符* 并释放它。如果对一个文件没有显式调用 `close()`，那么当进程结束时，所有打开的文件都会被关闭。但是，为了重用内核，在不再需要时释放文件描述符（文件描述符）是一个好的做法。'
- en: '`lseek()`: For each open file, the kernel keeps track of a file offset, which
    represents the location in the file at which the next read or write operation
    will happen. The system call `lseek()` allows you to reposition the file offset
    to any location in the file. The `lseek()` system call accepts three arguments
    – the file descriptor, an offset, and a reference position. The reference position
    can take three values – *start of file*, *current cursor position*, or *end of
    file*. The offset specifies the number of bytes relative to the reference position
    that the file offset should be pointed to, for the next `read()` or `write()`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lseek()`: 对于每个打开的文件，内核跟踪一个文件偏移量，它表示下一次读取或写入操作将在文件中的位置。`lseek()` 系统调用允许你将文件偏移量重新定位到文件中的任何位置。`lseek()`
    系统调用接受三个参数——文件描述符、偏移量和参考位置。参考位置可以取三个值——*文件开头*、*当前光标位置*或*文件结尾*。偏移量指定相对于参考位置的字节数，文件偏移量应指向该位置，以便进行下一次
    `read()` 或 `write()` 操作。'
- en: This concludes the overview of terminologies and key concepts of how operating
    systems manage files as system resources. We have seen the main system calls (`syscalls`)
    in Linux for working with files. We will not be directly using these `syscalls`
    in this book. But we will work with these `syscalls` indirectly, through the Rust
    Standard Library modules. The Rust Standard Library provides higher-level *wrappers*
    to make it easier to work with these `syscalls`. These *wrappers* also allow Rust
    programs to work without necessarily understanding all the differences in `syscalls`
    across different operating systems. However, gaining basic knowledge of how operating
    systems manage files gives us a glimpse into what goes on under the hood when
    we use the Rust Standard Library for file and directory operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对操作系统如何管理文件作为系统资源术语和关键概念的概述。我们已经看到了 Linux 中用于处理文件的 主要系统调用（`syscalls`）。在这本书中，我们不会直接使用这些
    `syscalls`。但我们将通过 Rust 标准库模块间接地使用这些 `syscalls`。Rust 标准库提供了更高层次的 *包装器*，以便更容易地使用这些
    `syscalls`。这些 *包装器* 还允许 Rust 程序在没有必要了解不同操作系统之间 `syscalls` 的所有差异的情况下工作。然而，了解操作系统如何管理文件，可以让我们窥见当我们使用
    Rust 标准库进行文件和目录操作时，底层发生了什么。
- en: In the next section, we will cover how to do file I/O in Rust.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何在 Rust 中进行文件输入/输出操作。
- en: Doing file I/O in Rust
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中进行文件 I/O 操作
- en: In this section, we will look at the Rust method calls that let us work with
    files in Rust programs. The Rust Standard Library spares the programmer from having
    to work with system calls directly and provides a set of wrapper methods exposing
    APIs for common file operations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Rust 方法调用，这些调用使我们能够在 Rust 程序中处理文件。Rust 标准库让程序员免于直接处理系统调用，并提供了一组包装方法，这些方法公开了常见文件操作的
    API。
- en: 'The primary module in the Rust Standard Library for working with files is `std::fs`.
    The official documentation for `std::fs` can be found here: [https://doc.rust-lang.org/std/fs/index.html](https://doc.rust-lang.org/std/fs/index.html).
    This documentation provides the set of methods, structs, enums, and traits that
    collectively provide features for working with files. It helps to study the structure
    of the `std::fs` module to gain a deeper understanding. However, for those starting
    out with exploring system programming in Rust, it is more useful to begin with
    a mental model of what kinds of things a programmer would like to do with files,
    and map it back to the Rust Standard Library. This is what we will do in this
    section. The common lifecycle operations for a file are shown in *Figure 6.1*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 标准库中用于处理文件的主要模块是 `std::fs`。`std::fs` 的官方文档可以在这里找到：[https://doc.rust-lang.org/std/fs/index.html](https://doc.rust-lang.org/std/fs/index.html)。该文档提供了一组方法、结构体、枚举和特质，这些方法共同提供了处理文件的功能。研究
    `std::fs` 模块的结构有助于加深理解。然而，对于刚开始探索 Rust 系统编程的人来说，从程序员希望对文件执行的操作的心理模型开始，并将其映射回 Rust
    标准库，可能更有用。这就是本节我们将要做的事情。文件的常见生命周期操作在 *图 6.1* 中展示。
- en: '![Figure 6.1 – Common file life cycle operations](img/Figure_6.1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 常见的文件生命周期操作](img/Figure_6.1.jpg)'
- en: Figure 6.1 – Common file life cycle operations
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 常见的文件生命周期操作
- en: 'The common things programmers like to do with files include creating a file,
    opening and closing files, reading and writing files, accessing metadata about
    files, and setting file permissions. These are shown in *Figure 6.1*. Descriptions
    of how to perform each of these file operations using the Rust Standard Library
    are provided here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员喜欢对文件执行的一些常见操作包括创建文件、打开和关闭文件、读取和写入文件、访问文件的元数据以及设置文件权限。这些操作在 *图 6.1* 中展示。这里提供了如何使用
    Rust 标准库执行每个文件操作的描述：  '
- en: '`std::fs` module is `File::create()`, which allows you to create a new file
    and write to it. Custom permissions for the file to be created can be specified
    using the `std::fs::OpenOptions` struct. An example of a *create* operation using
    the `std::fs` module is shown in the code snippet here:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs` 模块中的 `File::create()` 允许你创建一个新文件并向其写入。可以使用 `std::fs::OpenOptions`
    结构指定要创建的文件的自定义权限。下面是一个使用 `std::fs` 模块进行 *创建* 操作的代码片段示例：'
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`std::fs::File::open()`. This opens a file in *read-only* mode by default.
    The `std::fs::OpenOptions` struct can be used to set *custom permissions* to create
    the file. Two methods to open a file are shown below. The first function returns
    a `Result` type, which we are just handling using `.expect()`, which panics with
    a message if the file is not found. The second function uses `OpenOptions` to
    set additional permissions on the file to be opened. In the example shown, we
    are opening a file for the *write* operation, and also are asking for the file
    to be created if not present already:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs::File::open()`。默认情况下，它以*只读*模式打开文件。可以使用`std::fs::OpenOptions`结构来设置创建文件的*自定义权限*。以下展示了两种打开文件的方法。第一个函数返回一个`Result`类型，我们只是使用`.expect()`来处理它，如果文件未找到，则抛出带有消息的异常。第二个函数使用`OpenOptions`为要打开的文件设置额外的权限。在示例中，我们正在打开一个文件进行*写*操作，并且要求如果文件尚未存在则创建该文件：'
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`std::fs::copy()` function can be used to copy the contents of one file to
    another, overwriting the latter. An example is shown here:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs::copy()`函数可用于将一个文件的内容复制到另一个文件，并覆盖后者。以下是一个示例：'
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`std::fs::rename()` function can be used for this purpose. If the *to* file
    exists, it is replaced. One thing to note is that there can be more than one filesystem
    mounted (at various points) within the *mount namespace* of a process, as seen
    in the previous section. The `rename` method in Rust will work only if both the
    *from* and *to* file paths are in the same filesystem. An example of usage of
    the `rename()` function is shown here:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs::rename()`函数可用于此目的。如果*目标*文件已存在，则将其替换。需要注意的是，在进程的*挂载命名空间*中可以挂载多个文件系统（在各个位置），如前节所示。Rust中的`rename`方法只有在*源*和*目标*文件路径位于同一文件系统中时才会工作。以下是一个`rename()`函数用法的示例：'
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`std::fs` module, there are two functions available: `fs::read()` and `fs::read_to_string()`.
    The former reads the contents of a file into a `bytes vector`. It pre-allocates
    a buffer based on file size (when available). The latter reads the contents of
    a file directly into a string. Examples are shown here:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs`模块中提供了两个函数：`fs::read()`和`fs::read_to_string()`。前者将文件内容读取到一个`bytes`向量中。它根据文件大小（如果可用）预分配一个缓冲区。后者直接将文件内容读取到字符串中。以下是一些示例：'
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`std::fs`, the `fs::write()` function accepts a *filename* and a *byte slice*,
    and writes the *byte slice* as the contents of the file. An example is shown here:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs`模块中的`fs::write()`函数接受一个*文件名*和一个*字节切片*，并将*字节切片*作为文件的内容写入。以下是一个示例：'
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`std::fs` module. The functions `is_dir()`, `is_file()`, and `is_symlink()`
    respectively check whether a file is a *regular file*, *directory*, or a *symlink*.
    The `modified()`, `created()`, `accessed()` , `len()`, and `metadata()` functions
    are used to retrieve file metadata information. The `permissions()` function is
    used to retrieve a list of permissions on the file.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs`模块。函数`is_dir()`、`is_file()`和`is_symlink()`分别检查一个文件是否是*常规文件*、*目录*或*符号链接*。`modified()`、`created()`、`accessed()`、`len()`和`metadata()`函数用于检索文件元数据信息。`permissions()`函数用于检索文件上的权限列表。'
- en: 'A few examples of the usage of query operations are shown here:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面展示了查询操作的几个示例：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`set_permissions()`. An example is shown here, where, after setting the file
    permission to read-only, the write operation to the file fails:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_permissions()`。以下是一个示例，其中在将文件权限设置为只读后，对文件的写操作失败：'
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`close()` method in the Rust Standard Library to close files.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust标准库中的`close()`方法用于关闭文件。
- en: In this section, we saw the key function calls from the Rust Standard Library
    that can be used to perform *file manipulation* and *query* operations. In the
    next section, we will take a look at how the Rust Standard Library can be used
    for *directory* and *path* operations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了Rust标准库中用于执行*文件操作*和*查询*操作的关键函数调用。在下一节中，我们将探讨如何使用Rust标准库进行*目录*和*路径*操作。
- en: Learning directory and path operations
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习目录和路径操作
- en: The kernel in Linux (and other Unix variants) maintains a single directory tree
    structure visible to a process, which is hierarchical and contains all files in
    that namespace. This hierarchical organization contains both individual files,
    directories, and links (for example, a symbolic link).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Linux（以及其他Unix变体）的内核维护一个对进程可见的单个目录树结构，它是分层的，包含该命名空间中的所有文件。这种分层组织包含单个文件、目录和链接（例如，符号链接）。
- en: In the previous section, we looked at *files* and file operations in Rust. In
    this section, we will take a closer look at *directory* and *path* operations.
    In the next section, we will cover *links*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个部分，我们探讨了Rust中的*文件*和文件操作。在本节中，我们将更详细地探讨*目录*和*路径*操作。在下一节中，我们将介绍*链接*。
- en: 'A *directory* is a special file that contains a list of filenames with references
    (`/` represents the root directory, and `/home` and `/etc` will link to `/` as
    the *parent* directory. (Note that in some operating systems, such as Microsoft
    Windows variants, each disk device has its own hierarchy of files, and there is
    not a single unified namespace.) Each directory contains at least two entries
    – a *dot entry* pointing to itself and a *dot-dot* directory, which is a link
    to its parent directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*目录*是一个特殊的文件，其中包含一个文件名列表及其引用（`/`代表根目录，而`/home`和`/etc`将链接到`/`作为*父目录*。（注意，在某些操作系统，如Microsoft
    Windows变体中，每个磁盘设备都有自己的文件层次结构，并且没有单一的统一命名空间。）每个目录至少包含两个条目——一个指向自身的*点条目*和一个*点点*目录，它指向其父目录：'
- en: '![Figure 6.2 – Common directory and path operations](img/Figure_6.2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 常见的目录和路径操作](img/Figure_6.2.jpg)'
- en: Figure 6.2 – Common directory and path operations
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 常见的目录和路径操作
- en: In the Rust Standard Library, the `std::fs` module contains methods to work
    with directories, and the `std::path` module contains methods to work with *paths*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust标准库中，`std::fs`模块包含用于处理目录的方法，而`std::path`模块包含用于处理*路径*的方法。
- en: 'Just as in the previous section, we will look at the common programming tasks
    involving *directory* and *path* manipulations. These are shown in *Figure 6.2*
    and detailed here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个部分一样，我们将探讨涉及*目录*和*路径*操作的常见编程任务。这些在*图6.2*中展示，并在此处详细说明：
- en: '`std::fs` module. The `std::fs::read_dir()` function can be used to iterate
    through and retrieve the entries in a directory. From the directory entry thus
    retrieved, the metadata details of the directory entry can be obtained with the
    functions `path()`, `metadata()`, `file_name()`, and `file_type()`. Examples of
    how to do this are shown here:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::fs`模块中的`std::fs::read_dir()`函数可以用来遍历和检索目录中的条目。从检索到的目录条目中，可以使用`path()`、`metadata()`、`file_name()`和`file_type()`函数获取目录条目的元数据详情。这里展示了如何操作的示例：'
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we'll look at how to construct directory trees programmatically.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何程序化构建目录树。
- en: '`std::fs` module. The Rust `std::fs:DirBuilder` struct provides methods to
    recursively construct a directory structure. An example of creating a directory
    structure recursively is shown here:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::fs`模块。Rust的`std::fs::DirBuilder`结构体提供了递归构建目录结构的方法。这里展示了递归创建目录结构的示例：'
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that there are two other functions also available to create directories.
    `create_dir()` and `create_dir_all()` in `std::fs` can be used for this purpose.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，还有另外两个函数也可以用来创建目录。`std::fs`中的`create_dir()`和`create_dir_all()`可以用于此目的。
- en: Likewise, the functions `remove_dir()` and `remove_dir_all()` in the `std::fs`
    module can be used to delete directories.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，`std::fs`模块中的`remove_dir()`和`remove_dir_all()`函数可以用来删除目录。
- en: Next, we'll look at how to construct path strings dynamically.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何动态构建路径字符串。
- en: '`/usr/bob/a.txt`, `usr` and `bob` represent directories, while `a.txt` represents
    a file. The Rust Standard Library provides facilities to construct a path string
    (representing the full path to a file or a directory) programmatically. This is
    available in `std::path::PathBuf`. An example of how to construct a path dynamically
    is shown here:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/usr/bob/a.txt`，`usr`和`bob`代表目录，而`a.txt`代表文件。Rust标准库提供了程序化构建路径字符串（表示文件或目录的完整路径）的功能。这在`std::path::PathBuf`中可用。这里展示了如何动态构建路径的示例：'
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the code shown, a new variable of type `PathBuf` is constructed, and the
    various path components are dynamically added to create a fully qualified path.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示的代码中，创建了一个新的`PathBuf`类型变量，并将各种路径组件动态添加以创建一个完全限定的路径。
- en: This concludes this subsection on directory and path operations with the Rust
    Standard Library.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了关于Rust标准库中目录和路径操作的子节。
- en: In this section, we looked at how to use the Rust Standard Library to read through
    directory entries, get their metadata, construct a directory structure programmatically,
    get path components, and build a path string dynamically.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用Rust标准库读取目录条目，获取它们的元数据，程序化构建目录结构，获取路径组件，并动态构建路径字符串。
- en: In the next section, we will look at how to work with *links* and *queries*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 *链接* 和 *查询*。
- en: Setting hard links, symbolic links, and performing queries
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置硬链接、符号链接和执行查询
- en: 'We saw earlier that a directory is treated in a file system similarly to a
    regular file. But it has a different file type, and it contains a list of filenames
    with their inodes. `ls –li` command shows the inode number corresponding to a
    file, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，在文件系统中，目录被处理得类似于常规文件。但它有不同的文件类型，并且包含一个包含文件名及其 Inode 的列表。`ls –li` 命令显示了与文件对应的
    Inode 号码，如下所示：
- en: '![](img/Figure_6.3.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3](img/Figure_6.3.jpg)'
- en: Figure 6.3 – Inode numbers visible in the file listing
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 文件列表中可见的 Inode 号码
- en: Since a directory contains a listing that maps *filenames* with *inode numbers*,
    there can be multiple filenames that map to the same inode number. Such multiple
    names are called `ln` shell command. Not all non-UNIX filesystems support such
    hard links.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目录包含一个将 *文件名* 与 *inode 号码* 映射的列表，因此可以有多个文件名映射到同一个 Inode 号码。这样的多个名称称为 `ln`
    shell 命令。并非所有非 UNIX 文件系统都支持这样的硬链接。
- en: Within a file system, there can be many *links* to the same file. All of them
    are essentially the same, as they point to the same file. Most files have a *link
    count* of 1 (meaning there is a single directory entry for that file), but a file
    can have a *link count* > 1 ( for example, if there are two links pointing to
    the same *inode* entry, there will be two directory entries for that file, and
    the *link count* will be 2). The kernel maintains this *link count*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中，可以有指向同一文件的多个 *链接*。它们本质上都是相同的，因为它们都指向同一个文件。大多数文件都有一个 *链接计数* 为 1（意味着该文件只有一个目录条目），但文件可以有
    *链接计数* > 1（例如，如果有两个链接指向同一个 *inode* 条目，那么该文件将有两个目录条目，并且 *链接计数* 将为 2）。内核维护这个 *链接计数*。
- en: A *hard link* has a limitation in that they can refer only to files within the
    same file system because inode numbers are unique only within a file system. There
    is another type of link called a `ln –s` command. Since a symbolic link refers
    to a filename instead of an inode number, it can refer to a file in another filesystem.
    Also, unlike hard links, symbolic links can be created in directories.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 硬链接有一个限制，即它们只能引用同一文件系统内的文件，因为 Inode 号码只在文件系统内是唯一的。还有一种称为 `ln –s` 命令的另一种链接类型。由于符号链接引用的是文件名而不是
    Inode 号码，因此它可以引用另一个文件系统中的文件。此外，与硬链接不同，符号链接可以在目录中创建。
- en: 'In the following points, we will see the methods in the Rust Standard Library
    that can be used to create and query hard links and symbolic links (symlinks):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下要点中，我们将看到 Rust 标准库中可用于创建和查询硬链接和符号链接（symlinks）的方法：
- en: '`std::fs` module has a function, `fs::hard_link`, that can be used to create
    a new hard link on the file system. An example is shown here:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs` 模块有一个名为 `fs::hard_link` 的函数，可以用于在文件系统中创建一个新的硬链接。以下是一个示例：'
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`symlink` using the Rust Standard Library vary by platform. On Unix/Linux,
    the `std::os::unix::fs::symlink` method can be used. On windows, there are two
    APIs – `os::windows::fs::symlink_file` to create a *symbolic link* to a file,
    or `os::windows::fs::symlink_dir` to create a `symlink` to a directory. An example
    of creating a `symlink` on Unix-like platforms is shown here:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rust 标准库中的 `symlink` 方法在不同平台上会有所不同。在 Unix/Linux 上，可以使用 `std::os::unix::fs::symlink`
    方法。在 Windows 上，有两个 API – `os::windows::fs::symlink_file` 用于创建指向文件的 *符号链接*，或者 `os::windows::fs::symlink_dir`
    用于创建指向目录的 `symlink`。以下是在类 Unix 平台上创建 `symlink` 的示例：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `fs::read_link` function can be used to read a symbolic link as shown in
    the code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `fs::read_link` 函数来读取符号链接，如下面的代码所示。
- en: With this, we conclude the subsection on working with links in the Rust Standard
    Library. We have so far seen how to work with files, directories, paths, and links
    in Rust. In the next section, we will build a small shell command that demonstrates
    the practical use of the Rust Standard Library for file and directory operations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们完成了关于在 Rust 标准库中处理链接的子节。到目前为止，我们已经看到了如何在 Rust 中处理文件、目录、路径和链接。在下一节中，我们将构建一个小型的
    shell 命令，以展示 Rust 标准库在文件和目录操作中的实际应用。
- en: Writing a shell command in Rust (project)
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中编写 shell 命令（项目）
- en: In this section, we will use our knowledge of the Rust Standard Library on file
    and directory operations that we learned in previous sections to implement a shell
    command.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用我们在前几节中学到的 Rust 标准库中关于文件和目录操作的知识来实现一个 shell 命令。
- en: What will the shell command do?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 shell 命令会做什么？
- en: The shell command will be called **rstat**, short for **Rust source statistics**.
    Given a directory as an argument, it will generate a *file count* of Rust source
    files, and source code metrics such as the *number of blanks*, *comments*, and
    *actual lines of code* within the directory structure.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该shell命令将被命名为**rstat**，即**Rust源统计**。给定一个目录作为参数，它将生成Rust源文件的*文件计数*，以及目录结构内的源代码度量，如*空白数*、*注释*和*实际代码行数*。
- en: 'Here is what you will type:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你将输入的内容：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is an example of the result you will see from this shell command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从这个shell命令中看到的结果示例：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This section is structured as four sub-sections. In the first sub-section, we
    will see an overview of the code structure and a summary of steps to build this
    shell command. Then, in three different subsections, we will review the code for
    the three source files corresponding to error handling, source metric computation,
    and the main program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节分为四个子节。在第一个子节中，我们将概述代码结构并总结构建此shell命令的步骤。然后，在三个不同的子节中，我们将回顾与错误处理、源度量计算和主程序对应的三个源文件的代码。
- en: Code overview
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码概述
- en: In this subsection, we will look at how the code is structured for the shell
    command. We will also review a summary of the steps to build the shell command.
    Let's get started.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本子节中，我们将探讨shell命令的代码结构。我们还将回顾构建shell命令的步骤摘要。让我们开始吧。
- en: 'The code structure is shown in *Figure 6.4*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码结构如图*6.4*所示：
- en: '![Figure 6.4 – Shell command code structure](img/Figure_6.4.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – Shell命令代码结构](img/Figure_6.4.jpg)'
- en: Figure 6.4 – Shell command code structure
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – Shell命令代码结构
- en: 'Here is a summary of the steps to build the shell command. The source code
    snippets are shown later in this section:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是构建shell命令的步骤摘要。源代码片段将在本节后面展示：
- en: 'Create project: Create a new project with the following command and change
    directory into the `rstat` directory:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目：使用以下命令创建一个新项目，并将目录更改为`rstat`目录：
- en: '[PRE17]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create source files: Create three files under the `src` folder – `main.rs`,
    `srcstats.rs`, and `errors.rs`.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建源文件：在`src`文件夹下创建三个文件 – `main.rs`、`srcstats.rs`和`errors.rs`。
- en: 'Define custom error handling: In `errors.rs`, create a struct, `StatsError`,
    to represent our custom error type. This will be used to unify error handling
    in our project and to send messages back to the user. Implement the following
    four traits on `struct StatsError` : `fmt::Display, From<&str>`, `From<io::Error>`,
    and `From<std::num::TryFromIntError>`.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义自定义错误处理：在`errors.rs`中，创建一个结构体`StatsError`来表示我们的自定义错误类型。这将用于统一我们项目中的错误处理并向用户发送消息。在`struct
    StatsError`上实现以下四个特质：`fmt::Display`、`From<&str>`、`From<io::Error>`和`From<std::num::TryFromIntError>`。
- en: 'Define logic for computing source stats: In `srcstats.rs`, create a struct,
    `SrcStats`, to define the source metrics to be computed. Define two functions:
    `get_src_stats_for_file()` (which accepts a filename as an argument and computes
    the source metrics for that file) and `get_summary_src_stats()` (which takes a
    directory name as an argument and computes source metrics for all files in that
    directory root).'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义计算源统计的逻辑：在`srcstats.rs`中，创建一个结构体`SrcStats`来定义要计算的源度量。定义两个函数：`get_src_stats_for_file()`（接受一个文件名作为参数并计算该文件的源度量）和`get_summary_src_stats()`（接受一个目录名称作为参数并计算该目录根下所有文件的源度量）。
- en: 'Write the main() function to accept command-line parameters:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`main()`函数以接受命令行参数：
- en: In `main.rs`, define a `Opt` struct to define command-line parameters and flags
    for the shell command. Write the `main()` function, which accepts a source directory
    name from the command line and invokes the `get_summary_src_stats()` method in
    the `srcstats` module. Ensure to include `Cargo.toml` under dependencies.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`main.rs`中，定义一个`Opt`结构来定义shell命令的命令行参数和标志。编写`main()`函数，该函数从命令行接受源目录名称并调用`srcstats`模块中的`get_summary_src_stats()`方法。确保在依赖项中包含`Cargo.toml`。
- en: 'Build the tool with the following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建工具：
- en: '[PRE18]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the shell command with the following command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行shell命令：
- en: '[PRE19]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'LD_LIBRARY_PATH can be set as shown here (equivalent commands can be used for
    Windows):'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以像下面这样设置LD_LIBRARY_PATH（对于Windows可以使用等效命令）：
- en: '[PRE20]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: View the consolidated source stats printed to the terminal and confirm the metrics
    generated.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看打印到终端的汇总源统计并确认生成的度量。
- en: Let's now look at the code snippets for the steps listed previously. We will
    start by defining custom error handling.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看之前列出的步骤的代码片段。我们将首先定义自定义错误处理。
- en: Error handling
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'While executing our shell command, several things can go wrong. The source
    folder specified may be invalid. The permissions may be insufficient to view the
    directory entries. There can be other types of I/O errors such as those listed
    here: [https://doc.rust-lang.org/std/io/enum.ErrorKind.html](https://doc.rust-lang.org/std/io/enum.ErrorKind.html).
    In order for us to give a meaningful message back to the user, we will create
    a custom error type. We will also write conversion methods that will automatically
    convert different types of I/O errors into our custom error type by implementing
    various `From` traits. All this code is stored in the `errors.rs` file. Let''s
    review the code snippets from this file in two parts:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行我们的shell命令时，可能会出现几个问题。指定的源文件夹可能无效。查看目录条目的权限可能不足。还可能有其他类型的I/O错误，如以下所列：[https://doc.rust-lang.org/std/io/enum.ErrorKind.html](https://doc.rust-lang.org/std/io/enum.ErrorKind.html)。为了向我们用户返回有意义的消息，我们将创建一个自定义错误类型。我们还将编写转换方法，通过实现各种
    `From` 特性，将不同类型的I/O错误自动转换为我们的自定义错误类型。所有这些代码都存储在 `errors.rs` 文件中。让我们分两部分回顾这个文件中的代码片段：
- en: Part 1 covers the definition of the custom error type and `Display` trait implementation.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分涵盖了自定义错误类型和 `Display` 特性的实现。
- en: Part 2 covers the various `From` trait implementations for our custom error
    type.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分涵盖了自定义错误类型的各种 `From` 特性实现。
- en: 'Part 1 of the `errors.rs` code is shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`errors.rs` 代码的第一部分如下所示：'
- en: src/errors.rs (part-1)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: src/errors.rs (第一部分)
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here the `StatsError` struct is defined with a field `message` that will be
    used to store the error message, which will get propagated to the user in case
    of errors. We have also implemented the `Display` trait to enable the error message
    to get printed to the console.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定义了 `StatsError` 结构体，其中包含一个 `message` 字段，用于存储错误消息，在出现错误的情况下将传递给用户。我们还实现了
    `Display` 特性，以便错误消息可以打印到控制台。
- en: 'Let''s now see part 2 of the `errors.rs` file. Here, we implement the various
    `From` trait implementations, as shown here. Code annotations are numbered, and
    are described after the code listing:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `errors.rs` 文件的第二部分。在这里，我们实现了各种 `From` 特性的实现，如下所示。代码注释编号，并在代码列表之后进行描述：
- en: src/errors.rs (part-2)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: src/errors.rs (第二部分)
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The source code annotations (shown with numbers) are detailed here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码注释（用数字表示）的详细说明如下：
- en: Helps to construct a `StatsError` from a string
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帮助从字符串构建 `StatsError`
- en: Converts `IO:Error` to `StatsError`
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `IO:Error` 转换为 `StatsError`
- en: Used to check for errors while converting `usize` into `u32`
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于在将 `usize` 转换为 `u32` 时检查错误
- en: In this section, we reviewed the code for the `errors.js` file. In the next
    section, we will see the code for the computation of source code metrics.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了 `errors.js` 文件的代码。在下一节中，我们将看到源代码度量的计算代码。
- en: Source metric computation
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码度量计算
- en: 'In this section, we will look at the code for the `srcstats.rs` file. The code
    snippets for this file are shown in the following order in separate parts:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 `srcstats.rs` 文件的代码。该文件的代码片段按以下顺序分别展示：
- en: '*Part 1*: Module imports'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一部分:* 模块导入'
- en: '*Part 2:* Definition of the `SrcStats` struct'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第二部分:* `SrcStats` 结构体的定义'
- en: '*Part 3*: Definition of the `get_summary_src_stats()` function'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三部分:* `get_summary_src_stats()` 函数的定义'
- en: '*Part 4:* Definition of the `get_src_stats_for_file()` function'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第四部分:* `get_src_stats_for_file()` 函数的定义'
- en: 'Let''s look at *part 1*. The module imports are shown here. The descriptions
    corresponding to code annotation numbers are shown after the code listing:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 *第一部分*。模块导入如下所示。与代码注释编号对应的描述在代码列表之后：
- en: src/srcstats.rs (part-1)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: src/srcstats.rs (第一部分)
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The descriptions for the numbered code annotations are listed here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列出编号代码注释的描述如下：
- en: '`TryFrom` is used to capture any errors in converting `usize` to `u32`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TryFrom` 来捕获将 `usize` 转换为 `u32` 时可能出现的任何错误。
- en: '`OsStr` is used to check for files with the `.rs` extension.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OsStr` 用于检查具有 `.rs` 扩展名的文件。'
- en: '`std::fs` is the main module in the Rust Standard Library for file and directory
    operations.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs` 是 Rust 标准库中用于文件和目录操作的主要模块。'
- en: '`DirEntry` is a struct used by Rust Standard Library to denote individual directory
    entries.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DirEntry` 是 Rust 标准库中用于表示单个目录条目的结构体。'
- en: '`Path` and `PathBuf` are used to store path names. `&Path` is similar to `&str`
    and `PathBuf` is similar to `String`. One is a reference and another is an owned
    object.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path` 和 `PathBuf` 用于存储路径名。`&Path` 类似于 `&str`，而 `PathBuf` 类似于 `String`。一个是引用，另一个是拥有对象。'
- en: Any errors in reading files or computations are converted to the custom error
    type `StatsError`. This is imported in this line.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件或计算中出现的任何错误都被转换为自定义错误类型 `StatsError`。这一行中导入了它。
- en: We will now look at *part 2*. The definition of the struct to store computed
    metrics is covered here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看 *第 2 部分*。存储计算出的指标的结构的定义在这里介绍。
- en: 'The struct `SrcStats` contains the following source metrics, which will be
    generated by our shell command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体 `SrcStats` 包含以下源代码指标，这些指标将由我们的 shell 命令生成：
- en: The number of Rust source files
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 源代码文件的数量
- en: A count of lines of code (excluding comments and blanks)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码行数（不包括注释和空白行）
- en: The number of blank lines
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白行的数量
- en: The number of comment lines (single-line comments that begin with `//`; note
    that we are not considering multi-line comments in the scope of this tool)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释行的数量（以 `//` 开头的单行注释；请注意，在这个工具的范围内我们不考虑多行注释）
- en: 'The Rust data structure to hold the computed source file metrics is shown next:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储计算出的源代码指标的 Rust 数据结构如下所示：
- en: src/srcstats.rs (part-2)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: src/srcstats.rs (第-2 部分)
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s look at *part 3*, which is the main function that computes summary statistics.
    As this code is a bit long, we will look at this in three parts:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 *第 3 部分*，这是计算汇总统计信息的主要函数。由于这段代码有点长，我们将分三部分来查看：
- en: Part 3a of the code snippet shows variable initialization.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码片段的第 3a 部分显示了变量初始化。
- en: Part 3b of the code snippet shows the main code that recursively retrieves the
    Rust source files within a directory.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码片段的第 3b 部分显示了递归检索目录内 Rust 源代码文件的主要代码。
- en: In part 3c, we iterate through the list of Rust files and invoke the `get_src_stats_for_file()`
    method to compute source metrics for each file. The results are consolidated.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 3c 部分，我们遍历 Rust 文件列表，并对每个文件调用 `get_src_stats_for_file()` 方法来计算源代码指标。结果被汇总。
- en: 'Part 3a of the `get_summary_src_stats()` method is shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_summary_src_stats()` 方法的第 3a 部分如下所示：'
- en: src/srcstats.rs (part 3a)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: src/srcstats.rs (第 3a 部分)
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Part 3a shows the initialization of variables representing the various metrics
    that will be computed by the shell command – `total_loc`, `total_comments`, and
    `total_blanks`. Two more variables, `dir_entries` and `file_entries`, are initialized
    as `vector` data types, which will be used for intermediate computations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段的第 3a 部分显示了变量的初始化。
- en: 'Part 3b of the `get_summary_src_stats()` method is shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_summary_src_stats()` 方法的第 3b 部分如下所示：'
- en: src/srcstats.rs (part-3b)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: src/srcstats.rs (第-3b 部分)
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In part 3b of the code, we are iterating through the entries within the specified
    folder and segregating the entries of the type *directory* from the entries of
    the type *file*, and storing them in separate `vector` variables.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第 3b 部分，我们正在遍历指定文件夹内的条目，并将 *目录* 类型的条目与 *文件* 类型的条目分开，分别存储在单独的 `vector` 变量中。
- en: 'Part 3c of the `get_summary_src_stats()` method is shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_summary_src_stats()` 方法的第 3c 部分如下所示：'
- en: src/srcstats.rs (part 3c)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: src/srcstats.rs (第 3c 部分)
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will now look at *part 4*, which is the code to compute source metrics for
    an individual Rust source file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看 *第 4 部分*，这是计算单个 Rust 源代码文件的源代码指标的代码：
- en: src/srcstats.rs (part-4)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: src/srcstats.rs (第-4 部分)
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In part 4, the code for the `get_src_stats_for_file()` function is shown. This
    function reads the source file line by line and determines whether the line corresponds
    to a regular line of code, or blanks, or comments. Based on this classification,
    the respective counters are incremented. The final result is returned as the `SrcStats`
    struct from the function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 部分，展示了 `get_src_stats_for_file()` 函数的代码。此函数逐行读取源文件，并确定该行是否对应于常规代码行、空白行或注释。根据这种分类，相应的计数器会增加。最终结果作为
    `SrcStats` 结构体从函数返回。
- en: This concludes the code listing for the `srcstats` module. In this subsection,
    we reviewed the code for computing source code metrics. In the next section, we
    will review the code for the last part of the code listing, which is the `main()`
    function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `srcstats` 模块的代码列表。在本小节中，我们回顾了计算源代码指标的代码。在下一节中，我们将回顾代码列表的最后部分，即 `main()`
    函数。
- en: The main() function
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`main()` 函数'
- en: 'In this subsection, we will now look at the final part of the code, which is
    the `main()` function that represents the entry point into the binary. It performs
    four tasks:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们现在将查看代码的最后一部分，即代表二进制程序入口点的 `main()` 函数。它执行四个任务：
- en: Accepts user inputs from the command line.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行接受用户输入。
- en: Invokes the appropriate method to compute the source code metrics.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用适当的方法来计算源代码指标。
- en: Displays the result to the user.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果显示给用户。
- en: In the event of errors, a suitable error message is displayed to the user.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现错误的情况下，会向用户显示一个合适的错误信息。
- en: 'The code listing for the `main()` function is shown in two parts:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数的代码分为两部分：'
- en: Part 1 shows the structure of the command-line interface for the shell command.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1部分展示了shell命令的命令行界面结构。
- en: Part 2 shows the code to invoke calls for the computation of source metrics
    and to display the results to the user.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2部分展示了调用计算源指标并显示结果给用户的代码。
- en: '*Part 1* of `main.rs` is shown here. We will use the `structopt` crate to define
    the structure of the command line inputs to be accepted from the user.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.rs` 的 *第1部分* 如下所示。我们将使用 `structopt` crate 来定义从用户那里接受的命令行输入的结构。'
- en: 'Add the following to the `Cargo.toml` file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `Cargo.toml` 文件中：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code listing for *part 1* is shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*第1部分* 的代码列表如下所示：'
- en: src/main.rs (part-1)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: src/main.rs (第1部分)
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In part 1 of the code shown, a data structure, `Opt`, is defined, which contains
    two fields – `in_dir`, representing the path to the input folder (for which source
    metrics are to be computed), and a field, `mode`. The value for `mode` in our
    example is `src`, which indicates that we want to compute source code metrics.
    In the future, additional modes can be added (such as the `object` mode to compute
    object file metrics such as the size of the executable and library object files).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的代码第1部分中，定义了一个数据结构 `Opt`，它包含两个字段 – `in_dir`，表示输入文件夹的路径（要计算源指标），以及一个字段 `mode`。在我们的示例中，`mode`
    的值是 `src`，表示我们想要计算源代码指标。在未来，可以添加额外的模式（例如，`object` 模式，用于计算可执行文件和库对象文件的大小等指标）。
- en: 'In *part 2* of this code, we read the source folder from user''s command-line
    argument, and invoke the `get_summary_src_stats()` method from the `srcstats`
    module, which we reviewed in the previous subsection. The metrics returned by
    this method are then shown to user in the terminal. *Part 2* of the code listing
    is shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码的 *第2部分* 中，我们从用户的命令行参数中读取源文件夹，并从 `srcstats` 模块调用 `get_summary_src_stats()`
    方法，我们在前面的子节中已讨论过。然后，该方法返回的指标将在终端中显示给用户。代码列表的 *第2部分* 如下所示：
- en: src/main.rs
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: src/main.rs
- en: 'The `main` function code is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数的代码如下：'
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Part 2 shows the `main()` function, which is the entry point into our shell
    command. The function accepts and parses command-line parameters, and invokes
    the `get_summary_src_stats()` function, passing the *source folder* specified
    by the user as a function parameter. The results, containing consolidated source
    code metrics, are printed to the console.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第2部分展示了 `main()` 函数，它是我们shell命令的入口点。该函数接受并解析命令行参数，并调用 `get_summary_src_stats()`
    函数，将用户指定的 *源文件夹* 作为函数参数传递。包含综合源代码指标的成果将打印到控制台。
- en: 'Build and run the tool with the following commands:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建和运行工具：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`<source-folder>` is the location of the Rust project or source files and `-m`
    is the command-line flag to be specified. It will be `src`, to indicate that we
    want source code metrics.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`<source-folder>` 是Rust项目或源文件的位置，`-m` 是需要指定的命令行标志。它将是 `src`，表示我们想要源代码指标。'
- en: 'If you want to run the stats for the current project, you can do so with the
    following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想运行当前项目的统计信息，可以使用以下命令：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note the dot (`.`) in the command, which indicates we want to run the command
    for the current project folder.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令中的点（`.`），它表示我们想要在当前项目文件夹中运行该命令。
- en: You will see the source code metrics displayed on the terminal.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在终端上看到源代码指标。
- en: As an exercise, you can extend this shell command to generate metrics on the
    binary files generated for a Rust project. To invoke this option, allow the user
    to specify the `–m` flag as `bin`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以扩展这个shell命令以生成Rust项目生成的二进制文件的指标。要调用此选项，允许用户指定 `–m` 标志为 `bin`。
- en: This concludes the section on developing a shell command, which demonstrated
    file and directory operations in Rust.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了关于开发shell命令的章节，它展示了在Rust中进行的文件和目录操作。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the basics of file management at the operating
    system level, and the main system calls to work with files. We then learned how
    to use the Rust Standard Library to open and close a file, read and write to a
    file, query file metadata, and work with links. After file operations, we learned
    how to do directory and path operations in Rust. In the third section, we saw
    how to create hard links and soft (symbolic) links using Rust, and how to query
    `symlinks`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了操作系统级别的文件管理基础知识，以及与文件操作相关的主要系统调用。然后我们学习了如何使用 Rust 标准库打开和关闭文件，向文件读写数据，查询文件元数据，以及处理链接。在文件操作之后，我们学习了如何在
    Rust 中进行目录和路径操作。在第三部分，我们看到了如何使用 Rust 创建硬链接和软（符号）链接，以及如何查询 `symlinks`。
- en: We then developed a shell command that computed source code metrics for Rust
    source files within a directory tree. This project illustrated how to perform
    various file and directory operations in Rust using a practical example, and reinforced
    the concepts of the Rust Standard Library for file I/O operations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开发了一个 shell 命令，用于计算目录树中 Rust 源文件的源代码度量。这个项目展示了如何通过实际示例在 Rust 中执行各种文件和目录操作，并加强了
    Rust 标准库在文件 I/O 操作中的概念。
- en: Continuing with the topic of I/O, in the next chapter, we will learn the basics
    of terminal I/O and the features Rust provides to work with pseudo terminals.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 继续探讨 I/O 主题，在下一章中，我们将学习终端 I/O 的基础知识以及 Rust 提供的用于处理伪终端的功能。
