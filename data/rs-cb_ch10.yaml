- en: Advanced Web Development in Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 的高级 Web 开发
- en: 'We will be covering the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Setting up the API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 API
- en: Saving user data in MongoDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MongoDB 中保存用户数据
- en: Fetching user data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户数据
- en: Deleting user data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除用户数据
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will create a RESTful API web service using open source
    crates in the Rust language. The simple RESTful API in Rust will connect to a
    MongoDB service, which provides an end-to-end API solution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Rust 语言中的开源软件包创建 RESTful API 网络服务。Rust 中的简单 RESTful API 将连接到 MongoDB
    服务，提供端到端的 API 解决方案。
- en: We will look at how to perform `GET`, `POST`, and `DELETE` requests on user
    data from an endpoint. The crates, `nickel.rs` and the MongoDB Rust driver, make
    it possible to create these actions in the Rust language.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何从端点执行对用户数据的 `GET`、`POST` 和 `DELETE` 请求。`nickel.rs` 软件包和 MongoDB Rust
    驱动程序使得在 Rust 语言中创建这些操作成为可能。
- en: Setting up the API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 API
- en: In this recipe, you will learn the steps through which we can install all the
    dependencies, such as nickel crate, to set up, and create the API, in our Rust
    project. You will also learn the commands required to set up the basic REST API
    service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，您将学习到安装所有依赖项的步骤，例如 nickel 软件包，以设置并创建我们的 Rust 项目的 API，您还将学习到设置基本 REST API
    服务的所需命令。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will have to install the following nickel and MongoDB crates before we can
    go ahead and create the REST API. Follow the steps given to download and set up
    nickel and the other crate for your project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建 REST API 之前，我们必须安装以下 nickel 和 MongoDB 软件包。按照给定的步骤下载和设置 nickel 以及其他软件包到您的项目中：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: 'Create a Rust project using the `cargo` command-line tool, and enter the newly
    created project:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo` 命令行工具创建 Rust 项目，并进入新创建的项目：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Take a look at the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下截图：
- en: '![](img/512cf565-9e68-4877-aa0a-64698c75276e.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/512cf565-9e68-4877-aa0a-64698c75276e.png)'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modifications
    shown in the following screenshot. Here, we are using the nickel crate, which
    is entered in the dependencies field:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的首选文本编辑器中打开 `Cargo.toml` 文件，并按照以下截图进行修改。在此处，我们使用 nickel 软件包，它在依赖项字段中输入：
- en: '![](img/07c90ba1-3f49-47fe-a0df-be9e652b8cad.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07c90ba1-3f49-47fe-a0df-be9e652b8cad.png)'
- en: 'Install the crate in your project with the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在项目中安装该软件包：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will get the following screenshot as output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下截图作为输出：
- en: '![](img/0215c6f6-5481-463f-8310-889598705abf.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0215c6f6-5481-463f-8310-889598705abf.png)'
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps to implement this recipe:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此配方：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的首选文本编辑器中打开 `src` 目录下的 `main.rs` 文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Import the installed nickel crate by using the `extern` keyword:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `extern` 关键字导入已安装的 nickel 软件包：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the `main` function in which we declare the `server` instance:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中声明 `server` 实例的 `main` 函数中定义：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the `GET` endpoint:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `GET` 端点：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define the `POST` endpoint:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `POST` 端点：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define the `DELETE` endpoint:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `DELETE` 端点：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Declare the port at which the services will be started:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明服务启动的端口：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save the file and start the server with the following command from the root
    directory of the project:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并从项目的根目录使用以下命令启动服务器：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will get the following output on the successful execution of our code in
    the terminal:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端成功执行我们的代码后，我们将得到以下输出：
- en: '![](img/7ea86c97-3340-497f-b701-95a8a6726b5a.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ea86c97-3340-497f-b701-95a8a6726b5a.png)'
- en: 'We make a `GET` request to `http://127.0.0.1:9000/users`, which returns `Hello
    from GET /users` from the web service created using the nickel web application
    framework, as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `http://127.0.0.1:9000/users` 发送 `GET` 请求，该请求从使用 nickel 网络应用程序框架创建的 Web
    服务返回 `Hello from GET /users`，如下截图所示：
- en: '![](img/35e4d971-4dd5-42a5-a1d9-f78b8d5135f2.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35e4d971-4dd5-42a5-a1d9-f78b8d5135f2.png)'
- en: 'We make a `POST` request to `http://127.0.0.1:9000/users/new`, which returns
    `Hello from POST /users/new` from the web service created using the nickel web
    application framework:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `http://127.0.0.1:9000/users/new` 发送 `POST` 请求，该请求从使用 nickel 网络应用程序框架创建的
    Web 服务返回 `Hello from POST /users/new`：
- en: '![](img/c7fdfd28-1166-41c7-938b-4656f766c718.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7fdfd28-1166-41c7-938b-4656f766c718.png)'
- en: 'We make a `DELETE` request to `http://127.0.0.1:9000/users/:id`, which returns
    `Hello from DELETE /users/:id` from the web service created using the nickel web
    application framework:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`http://127.0.0.1:9000/users/:id`发送一个`DELETE`请求，它从使用镍Web应用程序框架创建的Web服务中返回`Hello
    from DELETE /users/:id`：
- en: '![](img/69efb63b-b7dd-4289-9065-1bf0008e2397.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69efb63b-b7dd-4289-9065-1bf0008e2397.png)'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created the basic skeleton of our REST API service, where
    we have all our endpoints set.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了我们的REST API服务的骨架，其中我们设置了所有的端点。
- en: 'Our API will have three endpoints, which are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API将有三个端点，如下所示：
- en: '`/users`: Here, we will hit out the `GET` request, which retrieves the `firstname`
    field of all the users'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users`：在这里，我们将执行`GET`请求，以检索所有用户的`firstname`字段'
- en: '`/users/new`: The `POST` request to this endpoint creates and saves a new user'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users/new`：对该端点的`POST`请求将创建并保存一个新的用户'
- en: '`/users/:id`: The `DELETE` method will delete a user based on the record''s
    `ObjectId`, which is the unique ID obtained from the MongoDB database'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users/:id`：`DELETE`方法将根据记录的`ObjectId`删除一个用户，这是从MongoDB数据库中获得的唯一ID'
- en: We will activate all these endpoints in the following recipes with their exact
    behavior, but currently, these will only display a sample message when the user
    hits the endpoint with the corresponding requests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的菜谱中激活所有这些端点，并展示它们的确切行为，但当前，当用户使用相应的请求点击端点时，这些端点将只显示一条示例消息。
- en: Starting at the top, we're referencing the external nickel crate using the `extern`
    keyword and loading all of its macros with `#[macro_use]`. The nickel is the application
    object and the surface that holds all the public APIs; it's a struct, which implements
    all the fundamental methods for performing all the web application tasks. The
    other crates, such as bson, rustc-serialize, and MongoDB, which we downloaded
    initially using the `cargo` tool, will be used in the following recipes to activate
    the functionalities in the endpoints.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们使用`extern`关键字引用外部镍crate，并使用`#[macro_use]`加载其所有宏。镍是应用程序对象和包含所有公共API的表面；它是一个结构体，实现了执行所有Web应用程序任务的基本方法。我们最初使用`cargo`工具下载的其他crate，如bson、rustc-serialize和MongoDB，将在以下菜谱中用于激活端点的功能。
- en: In the `main` function, we first assign the `server` instances to a mutable
    variable and create a new nickel application object using `Nickel::new()`, which
    creates an instance of the nickel with default error handling. Similarly, we create
    a mutable router instance and assign it to `Nickel::router()`, which will take
    care of handling the different endpoints.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们首先将`server`实例分配给一个可变变量，并使用`Nickel::new()`创建一个新的镍应用程序对象，这会创建一个具有默认错误处理的镍实例。同样，我们创建一个可变路由实例并将其分配给`Nickel::router()`，它将负责处理不同的端点。
- en: 'We set up our endpoint routing using different methods, such as `get()`, `post()`,
    and `delete()`, of the `router` instance and provide a simple message in the `format!`
    macro to be displayed when these endpoints are accessed. The messages are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`router`实例的不同方法（如`get()`、`post()`和`delete()`）设置我们的端点路由，并在`format!`宏中提供一个简单的消息，当访问这些端点时显示。消息如下：
- en: '`/users`: The `GET` request will get `Hello from GET /users`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users`：对该端点的`GET`请求将返回`Hello from GET /users`'
- en: '`/users/new`: The `POST` request will get `Hello from POST /users/new`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users/new`：对该端点的`POST`请求将返回`Hello from POST /users/new`'
- en: '`/users/:id`: The `DELETE` request will get `Hello from DELETE /users/:id`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users/:id`：对该端点的`DELETE`请求将返回`Hello from DELETE /users/:id`'
- en: The `middleware!` macro is provided by `nickel.rs` and reduces the amount of
    boilerplate code needed for each route. Double-pipe characters represent the closure
    in Rust, and this is where our `request` and `response` parameters are placed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`middleware!`宏由`nickel.rs`提供，它减少了每个路由所需的样板代码量。双竖线字符代表Rust中的闭包，这是我们放置`request`和`response`参数的地方。'
- en: Using the `server.utilize` method, we add the endpoints to the `server` instance
    and register the handler that will be invoked among other handlers before each
    request, by passing the `router` instance. The `server.listen` method listens
    to the API requests on `127.0.0.1:9000`, where it binds and listens for connections
    on the given host and port.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`server.utilize`方法，我们将端点添加到`server`实例中，并通过传递`router`实例注册将在其他处理程序之前调用的处理程序。`server.listen`方法监听在`127.0.0.1:9000`上的API请求，它绑定并监听给定主机和端口上的连接。
- en: Saving user data in MongoDB
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MongoDB中保存用户数据
- en: In this recipe, we will go a step ahead and rewrite the logic for the `POST`
    request, which will take the user data and save it in the MongoDB database, for
    which we will use the MongoDB Rust driver for interacting with the DB.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将进一步重写`POST`请求的逻辑，该请求将获取用户数据并将其保存到MongoDB数据库中，我们将使用MongoDB Rust驱动程序与数据库交互。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following nickel and MongoDB crates before we can
    go ahead and create the REST API. Follow these steps to download and set up nickel
    and the MongoDB service in the project:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建REST API之前，必须安装以下nickel和MongoDB crates。按照以下步骤在项目中下载和设置nickel和MongoDB服务：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: 'Create a Rust project using the `cargo` command-line tool and enter the newly
    created project:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo`命令行工具创建Rust项目，并进入新创建的项目：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Take a look at the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/01b6b8eb-786b-48dc-9e44-7a905ee6bdbe.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/01b6b8eb-786b-48dc-9e44-7a905ee6bdbe.png)'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    as shown in the following screenshot. Here, we are using the nickel crate, which
    is entered in the dependencies field:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中打开`Cargo.toml`文件，并根据以下截图进行修改。在这里，我们使用的是nickel crate，它在依赖项字段中输入：
- en: '![](img/06847d30-c762-41a9-bc0a-5e07beda174c.png)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![截图](img/06847d30-c762-41a9-bc0a-5e07beda174c.png)'
- en: 'Install the crate in your project with the following command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在项目中安装crate：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set up the MongoDB service in your Linux system by following these steps:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤在您的Linux系统中设置MongoDB服务：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the mentioned steps to implement this recipe:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照提到的步骤实现此配方：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的文本编辑器中打开`src`目录下的`main.rs`文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Import all the required installed nickel and other supporting crates by using
    the `extern` keyword:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extern`关键字导入所有必需的已安装的nickel和其他支持crate：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We create a `struct` named `User`, which is encodable and decodable and which
    models our user data:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个名为`User`的`struct`，它是可编码和可解码的，并模拟我们的用户数据：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define the `main` function, where we''ll declare the `server` instance:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数，其中我们将声明`server`实例：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the `GET` endpoint:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`GET`端点：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define the `POST` endpoint:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`POST`端点：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define the `DELETE` endpoint:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`DELETE`端点：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Declare the port at which the services will be started:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明服务启动的端口：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Save the file and start the server with the following command from the root
    directory of the project:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并从项目的根目录使用以下命令启动服务器：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will get the following screenshot as output on the successful execution
    of our code in the terminal:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端成功执行我们的代码后，将得到以下截图作为输出：
- en: '![](img/cf635a8e-3e72-44a2-9218-d2626d197c96.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/cf635a8e-3e72-44a2-9218-d2626d197c96.png)'
- en: 'We submit a `POST` request to `http://127.0.0.1:9000/users/new` with a body,
    as shown in the following screenshot containing the user data:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`http://127.0.0.1:9000/users/new`提交一个包含用户数据的`POST`请求，如下面的截图所示：
- en: '![](img/4cf43a29-ef65-46e0-aeeb-81425af34c00.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/4cf43a29-ef65-46e0-aeeb-81425af34c00.png)'
- en: 'On a successful API call, the web service built using the nickel web application
    framework returns a message `Item saved!`, which is an indication of the data
    being saved in the MongoDB configuration mentioned in the code. Take a look at
    the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的API调用中，使用nickel网络应用程序框架构建的Web服务返回消息`Item saved!`，这是数据已按代码中提到的MongoDB配置保存的指示。看看下面的截图：
- en: '![](img/ca61d191-4f47-4164-a379-4da0c297ce8f.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ca61d191-4f47-4164-a379-4da0c297ce8f.png)'
- en: 'In order to validate whether the `POST` request was successful, we can verify
    the record from the MongoDB database, where we can select the `rust-cookbook`
    database and the `users` collection:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证`POST`请求是否成功，我们可以从MongoDB数据库中验证记录，其中我们可以选择`rust-cookbook`数据库和`users`集合：
- en: '![](img/e5bbc9da-a7e7-463c-bef6-2a88eb31573c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e5bbc9da-a7e7-463c-bef6-2a88eb31573c.png)'
- en: In this recipe, we focused on getting the user data and saving it to the database.
    We activated `POST` requests to the `/users/new` endpoint for creating and saving
    a new user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们专注于获取用户数据并将其保存到数据库中。我们激活了对`/users/new`端点的`POST`请求，以创建和保存新用户。
- en: Starting at the top, we referenced the external nickel crate using the `extern`
    keyword and loaded all of its macros with `#[macro_use]`. The nickel is the application
    object and surface that holds all the public APIs; it's a struct, which implements
    all the fundamental methods for performing all the web application tasks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们使用 `extern` 关键字引用外部 nickel crate，并使用 `#[macro_use]` 加载了其所有宏。Nickel 是应用程序对象和表面，它包含所有公共
    API；它是一个结构体，实现了执行所有网络应用程序任务的基本方法。
- en: In the `main` function, we first assign `server` mutable instances to a mutable
    variable and create a new nickel application object with `Nickel::new()`, which
    creates an instance of nickel with default error handling. Similarly, we create
    a mutable router instance and assign it to `Nickel::router()`, which will take
    care of handling the different endpoints.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们首先将 `server` 可变实例分配给一个可变变量，并使用 `Nickel::new()` 创建一个新的 nickel
    应用程序对象，这会创建一个具有默认错误处理的 nickel 实例。同样，我们创建一个可变路由实例并将其分配给 `Nickel::router()`，它将负责处理不同的端点。
- en: The MongoDB Rust driver provides a nice interface for interacting with databases,
    collections, and cursors, with which we can establish a database connection for
    creating, reading, updating, and deleting user data in our application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB Rust 驱动程序提供了一个优雅的接口，用于与数据库、集合和游标进行交互，通过它我们可以在应用程序中建立数据库连接，用于创建、读取、更新和删除用户数据。
- en: We will be getting the `POST /users/new` route working, for which we will be
    using the different crates that we downloaded initially, which are the units of
    `rustc_serialize`, `bson`, and `MongoDB`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使 `POST /users/new` 路由工作，我们将使用最初下载的不同crate，它们是 `rustc_serialize`、`bson` 和
    `MongoDB` 的单元。
- en: Next up, we create a complex data structure, which is a `User` struct that is
    encodable and decodable and that represents our user data fields.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个复杂的数据结构，这是一个可编码和解码的 `User` 结构体，它代表我们的用户数据字段。
- en: We will need to send a JSON string input from the user end and convert the input
    data to the `User` struct by creating some variables that can hold the data. The
    `unwrap` method is one of the several ways that Rust provides for assigning a
    value. The unwrapped data from the user input is saved to variables `firstname`,
    `lastname`, and `email`. The next step is to establish a connection with the MongoDB
    service so that we can store the data that we just parsed from the input string.
    We achieve this with `Client::connect("localhost", 27017)`, where `27017` is the
    port in which the MongoDB service is running. The `coll` variable connected the
    particular collection in the database with `client.db("rust-cookbook").collection("users")`,
    where `rust-cookbook` is the database and `users` is the collection.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从用户端发送一个 JSON 字符串输入，并通过创建一些可以保存数据的变量将输入数据转换为 `User` 结构体。`unwrap` 方法是 Rust
    提供的几种分配值的方法之一。从用户输入中解包的数据被保存到变量 `firstname`、`lastname` 和 `email` 中。下一步是建立与 MongoDB
    服务的连接，以便我们可以存储从输入字符串中解析出的数据。我们通过 `Client::connect("localhost", 27017)` 实现这一点，其中
    `27017` 是 MongoDB 服务运行的端口。`coll` 变量通过 `client.db("rust-cookbook").collection("users")`
    将数据库中的特定集合与 `client` 连接，其中 `rust-cookbook` 是数据库，`users` 是集合。
- en: We can see the `match` statement at work when we use `coll.insert_doc` to insert
    the user data. In the `Ok` condition, we respond with a success message, which
    is `Item saved`, and in the `Err` condition, we respond with an error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `coll.insert_doc` 插入用户数据时，我们可以看到 `match` 语句在起作用。在 `Ok` 条件下，我们返回一个成功消息，即
    `Item saved`，在 `Err` 条件下，我们返回一个错误。
- en: Using the `server.utilize` method, we add the endpoints to the server instance
    and register the handler, which will be invoked among other handlers before each
    request by passing the `router` instance. The `server.listen` method listens to
    the API requests on `127.0.0.1:9000`, where it binds and listens for connections
    on the given host and port.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `server.utilize` 方法，我们将端点添加到服务器实例并注册处理程序，该处理程序将在传递 `router` 实例之前由其他处理程序调用，以处理每个请求。`server.listen`
    方法监听 `127.0.0.1:9000` 上的 API 请求，其中它绑定并监听给定主机和端口上的连接。
- en: Fetching user data
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户数据
- en: In this recipe, you will learn the steps with which we can install all the dependencies,
    such as the nickel crate, to set up and create the API, and the MongoDB Rust driver
    to interact with the database in our Rust project. You will also learn the commands
    with which you can get all the specific data required from the database. The `GET`
    request will fetch the `firstname` field's data, which was previously saved in
    the database, using the `POST` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何安装所有依赖项的步骤，例如镍crate，以设置和创建API，以及MongoDB Rust驱动程序以在我们的Rust项目中与数据库交互。你还将学习使用哪些命令可以从数据库中获取所有所需的具体数据。`GET`请求将使用`POST`方法检索之前保存在数据库中的`firstname`字段的数据。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following nickel and MongoDB crates before we can
    go ahead and create the REST API. Follow these steps to download and set up nickel
    and the MongoDB service in the project:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建REST API之前，我们必须安装以下镍和MongoDB crates。按照以下步骤下载和设置项目中的nickel和MongoDB服务：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: 'Create a Rust project using the `cargo` command-line tool and enter the newly
    created project:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo`命令行工具创建Rust项目，并进入新创建的项目：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/d1503520-ddaa-491c-a637-27e8aaeb213e.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1503520-ddaa-491c-a637-27e8aaeb213e.png)'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    as shown in the following screenshot. Here, we are using the nickel crate, which
    is entered in the dependencies field:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的文本编辑器中打开`Cargo.toml`文件，并按照以下截图进行修改。在这里，我们使用nickel crate，它在依赖项字段中输入：
- en: '![](img/99e1c63b-fde4-4890-a2ef-09d179b9b594.png)'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/99e1c63b-fde4-4890-a2ef-09d179b9b594.png)'
- en: 'Install the crate in your project with the following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在你的项目中安装crate：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Set up the MongoDB service in your system by following these steps:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤在你的系统中设置MongoDB服务：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the mentioned steps to implement this recipe:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个菜谱：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的文本编辑器中打开`src`目录下的`main.rs`文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Import all the required installed nickel and other supporting crates by using
    the `extern` keyword:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extern`关键字导入所有已安装的nickel和其他支持crate：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We create a `struct` named `User`, which is encodable and decodable and which
    models our user data:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`User`的`struct`，它是可编码和可解码的，并模拟我们的用户数据：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define the `main` function in which we declare the `server` instance:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中声明`server`实例的`main`函数中：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define the `GET` endpoint:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`GET`端点：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define the `POST` endpoint:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`POST`端点：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define the `DELETE` endpoint:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`DELETE`端点：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Declare the port at which the services will be started:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明服务将启动的端口：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Save the file and start the server with the following command from the root
    directory of the project:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并从项目的根目录使用以下命令启动服务器：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will get the following output on the successful execution of our code in
    the terminal:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码在终端成功执行后，我们将得到以下输出：
- en: '![](img/435cb018-6bac-4547-816d-7c604fcd9ee5.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/435cb018-6bac-4547-816d-7c604fcd9ee5.png)'
- en: 'We submit a `GET` request to `http://127.0.0.1:9000/users`, as shown in the
    following screenshot, which fetches the user data on a successful API call, which
    returns `{"data":[VIKI,]}` from the web service created using the nickel web application
    framework. The data is fetched from the MongoDB records from the previous recipe
    where we store this data in the `rust-cookbook` database, as shown in the following
    screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`http://127.0.0.1:9000/users`提交`GET`请求，如以下截图所示，它从使用nickel Web应用程序框架创建的Web服务中检索用户数据，在成功的API调用中返回`{"data":[VIKI,]}`。数据是从之前菜谱中的MongoDB记录中检索的，我们将其存储在`rust-cookbook`数据库中，如以下截图所示：
- en: '![](img/93f02bc5-2d39-489f-b11e-f67253cc5b83.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93f02bc5-2d39-489f-b11e-f67253cc5b83.png)'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we focused on getting previously-saved user data from the database.
    We activated `GET` requests to the `/users` endpoint for getting the data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们专注于从数据库中获取之前保存的用户数据。我们激活了对`/users`端点的`GET`请求以获取数据。
- en: Starting at the top, we referenced the external nickel crate using the `extern`
    keyword and loaded all of its macros with `#[macro_use]`. The nickel is the application
    object and surface that holds all the public APIs. It's a struct that implements
    all the fundamental methods for performing all the web application tasks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们使用`extern`关键字引用了外部镍制箱，并通过`#[macro_use]`加载了其所有宏。镍是应用程序对象和表面，它包含所有公共API。它是一个实现了执行所有Web应用程序任务的基本方法的`struct`。
- en: In the `main` function, we first assign `server` mutable instances to a mutable
    variable and create a new nickel application object with `Nickel::new()`, which
    creates an instance of nickel with default error handling. Similarly, we create
    a mutable router instance and assign it to `Nickel::router()`, which will take
    care of handling the different endpoints.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们首先将可变`server`实例分配给一个可变变量，并使用`Nickel::new()`创建一个新的镍应用程序对象，这会创建一个具有默认错误处理的镍实例。同样，我们创建一个可变路由实例并将其分配给`Nickel::router()`，这将负责处理不同的端点。
- en: We will be getting the `GET/users` route working, for which we will be using
    the different crates that we downloaded initially, which are the units of `rustc_serialize`,
    `bson`, and `MongoDB`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使`GET/users`路由工作，我们将使用最初下载的不同crate，它们是`rustc_serialize`、`bson`和`MongoDB`的单元。
- en: Next up, we create a complex data structure, which is a `User` struct that is
    encodable and decodable and that represents our user data fields.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个复杂的数据结构，这是一个可编码和可解码的`User`结构体，它代表我们的用户数据字段。
- en: We first establish a connection with the MongoDB service so that we can store
    our data, which we just parsed from the input string. We achieve this with `Client::connect("localhost",
    27017)`, where `27017` is the port in which the MongoDB service is running, and
    the `coll` variable connected the particular collection in the database with `client.db("rust-cookbook").collection("users")`,
    where `rust-cookbook` is the database and `users` is the collection. Then, we
    have to read through all the values in the collection, for which we create `cursor`,
    a mutable instance that uses the `find` method to get all the documents in the
    `users` collection. We create a `data_result` instance, which is a JSON string
    that will be returned to the user after getting all the data from the collections.
    We then iterate over `result` with a `for` loop, where we collect the `i` index
    and the `Bson` form document with the cursor's `enumerate` method. We convert
    the value returned, which is of the `Option<Result<Document>` type. We stringify
    the `firstname` field of the `item` instance using `Bson`, and push the results
    to the `data_result` string. In the end, we close it off the post, which we send
    back to the user in the `format!` macro.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先与MongoDB服务建立连接，以便我们可以存储从输入字符串中解析出的数据。我们通过`Client::connect("localhost", 27017)`实现这一点，其中`27017`是MongoDB服务运行的端口，`coll`变量通过`client.db("rust-cookbook").collection("users")`将特定的集合与数据库中的`users`集合连接起来，其中`rust-cookbook`是数据库，`users`是集合。然后，我们必须遍历集合中的所有值，为此我们创建了一个名为`cursor`的可变实例，它使用`find`方法获取`users`集合中的所有文档。我们创建了一个`data_result`实例，它是一个JSON字符串，在从集合中获取所有数据后将被返回给用户。然后我们使用`for`循环遍历`result`，其中我们使用cursor的`enumerate`方法收集`i`索引和文档的`Bson`形式。我们将`item`实例的`firstname`字段转换为字符串，使用`Bson`，并将结果推送到`data_result`字符串。最后，我们关闭帖子，将其发送回用户，在`format!`宏中完成。
- en: Using the `server.utilize` method, we add the endpoints to the server instance
    and register the handler that will be invoked among other handlers before each
    request by passing the `router` instance. The `server.listen` method listens to
    the API requests on `127.0.0.1:9000`, where it binds and listens for connections
    on the given host and port.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`server.utilize`方法，我们将端点添加到服务器实例，并通过传递`router`实例来注册将在其他处理程序之前被调用的处理程序。`server.listen`方法监听`127.0.0.1:9000`上的API请求，在那里它绑定并监听给定主机和端口上的连接。
- en: Deleting user data
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除用户数据
- en: In this recipe, you will learn the steps with which you can install all the
    dependencies, such as nickel crate, to set up and create the API, and the MongoDB
    Rust driver to interact with the database in our Rust project. You will also learn
    the commands with which you can get all the specific data required from the database.
    The `GET` request will fetch the `firstname` field's data, which was previously
    saved in the database by the `POST` method, and then, we will delete the fetched
    object, which makes this process an end-to-end REST API service.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何安装所有依赖项的步骤，例如镍 crate，以设置和创建 API，以及 MongoDB Rust 驱动程序以与 Rust 项目中的数据库交互。您还将学习使用哪些命令可以从数据库中获取所有所需的具体数据。`GET`
    请求将检索之前通过 `POST` 方法保存到数据库中的 `firstname` 字段的数据，然后我们将删除检索到的对象，这使得这个过程成为一个端到端的 REST
    API 服务。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following nickel and MongoDB crates before we can
    go ahead and create the REST API. Follow these steps to download and set up nickel
    and the MongoDB service in the project:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建 REST API 之前，我们必须安装以下镍和 MongoDB crate。按照以下步骤下载和设置项目中的镍和 MongoDB 服务：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: 'Create a Rust project using the `cargo` command-line tool, and enter the newly
    created project:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo` 命令行工具创建一个 Rust 项目，并进入新创建的项目：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![](img/723686d2-1ecf-45c9-978f-0409eda3e6bd.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/723686d2-1ecf-45c9-978f-0409eda3e6bd.png)'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    as shown in the following screenshot. Here, we are using the nickel crate, which
    is entered in the dependencies field:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中打开 `Cargo.toml` 文件，并按照以下截图所示进行修改。在此，我们使用镍 crate，它在依赖项字段中输入：
- en: '![](img/31b734ce-ea56-4c61-878e-4425763a5893.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/31b734ce-ea56-4c61-878e-4425763a5893.png)'
- en: 'Install the crate in your project with the following command:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在您的项目中安装 crate：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Set up the MongoDB service in your system by following these steps:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下步骤在您的系统中设置 MongoDB 服务：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to implement this recipe:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此配方：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的文本编辑器中打开 `src` 目录下的 `main.rs` 文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Import all the required installed nickel and other supporting crates by using
    the `extern` keyword:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `extern` 关键字导入所有必需的已安装的镍和其他支持 crate：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We create a `struct` named `User`, which is encodable and decodable and which
    models our user data:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `User` 的 `struct`，它是可编码和可解码的，并模拟我们的用户数据：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define the `main` function in which we declare the `server` instance:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义包含我们声明 `server` 实例的 `main` 函数：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define the `GET` endpoint:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `GET` 端点：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the `POST` endpoint:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `POST` 端点：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the `DELETE` endpoint:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `DELETE` 端点：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Declare the port at which the services will be started:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明服务将启动的端口：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save the file and start the server with the following command from the root
    directory of the project:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并从项目的根目录使用以下命令启动服务器：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will get the following screenshot as output on the successful execution
    of our code in the terminal:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端成功执行我们的代码后，我们将获得以下截图作为输出：
- en: '![](img/c5e52e3c-98e7-45c8-9297-f02833c4b741.png)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![截图](img/c5e52e3c-98e7-45c8-9297-f02833c4b741.png)'
- en: 'We find the `ObjectID` of the user data saved, as shown in the following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到用户数据的 `ObjectID`，如下截图所示：
- en: '![](img/eb54cf04-3237-4e29-a361-7f265f221be6.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/eb54cf04-3237-4e29-a361-7f265f221be6.png)'
- en: 'We submit a `DELETE` request to `http://127.0.0.1:9000/objectID`, as shown
    in the following screenshot, which deletes the user data on successful API calls,
    which returns `Item deleted!` from the web service created using the nickel web
    application framework, which deleted the data in MongoDB:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `http://127.0.0.1:9000/objectID` 提交一个 `DELETE` 请求，如以下截图所示，在成功的 API 调用中删除用户数据，该调用从使用镍
    Web 应用程序框架创建的 Web 服务中返回 `Item deleted!`，该服务删除了 MongoDB 中的数据：
- en: '![](img/9e1511b0-0a04-4a3e-9b24-144983103d11.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/9e1511b0-0a04-4a3e-9b24-144983103d11.png)'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we focused on deleting the user data that was saved in the database.
    We activated `DELETE` requests to the `/users/:id` endpoint for deleting the previous
    records by the object ID.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们专注于删除保存在数据库中的用户数据。我们激活了对 `/users/:id` 端点的 `DELETE` 请求，通过对象 ID 删除以前的记录。
- en: Starting at the top, we referenced the external nickel crate using the `extern`
    keyword and loaded all of its macros with `#[macro_use]`. The nickel is the application
    object and surface that holds all public APIs. It's a struct, which implements
    all the fundamental methods for performing all the web application tasks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们使用`extern`关键字引用外部nickel crate，并通过`#[macro_use]`加载了它所有的宏。nickel是应用程序对象和表面，它持有所有公共API。它是一个结构体，实现了执行所有Web应用程序任务的基本方法。
- en: In the `main` function, we first assign `server` mutable instances to a mutable
    variable and create a new nickel application object with `Nickel::new()`, which
    creates an instance of nickel with default error handling. Similarly, we create
    a mutable router instance and assign it to `Nickel::router()`, which will take
    care of handling the different endpoints.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们首先将`server`可变实例分配给一个可变变量，并使用`Nickel::new()`创建一个新的nickel应用程序对象，它创建了一个具有默认错误处理的nickel实例。同样，我们创建一个可变路由实例并将其分配给`Nickel::router()`，它将负责处理不同的端点。
- en: We will be getting the `DELETE /users/:id` route working, for which we will
    be using the different crates that we downloaded initially, which are the units
    of `rustc_serialize`, `bson`, and `MongoDB`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使`DELETE /users/:id`路由工作，我们将使用最初下载的不同crate，这些crate是`rustc_serialize`、`bson`和`MongoDB`的单元。
- en: Next up, we create a complex data structure, which is a `User` struct that is
    encodable and decodable and that represents our user data fields.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个复杂的数据结构，这是一个可编码和解码的`User`结构体，它代表我们的用户数据字段。
- en: This is the final step for this end-to-end API, where we allow the `users` collection
    elements to be deleted by their `objectId`. We can do this with the MongoDB Rust
    driver's `delete_one` method.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是端到端API的最终步骤，我们允许通过`objectId`删除`users`集合的元素。我们可以使用MongoDB Rust驱动程序的`delete_one`方法来完成此操作。
- en: We first establish a connection with the MongoDB service so that we can store
    our data, which we just parsed from the input string. We achieve this with `Client::connect("localhost",
    27017)`, where `27017` is the port in which the MongoDB service is running, and
    the `coll` variable connected the particular collection in the database with `client.db("rust-cookbook").collection("users")`,
    where `rust-cookbook` is the database and `users` is the collection.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先与MongoDB服务建立连接，以便我们可以存储从输入字符串中解析出来的数据。我们通过`Client::connect("localhost",
    27017)`实现这一点，其中`27017`是MongoDB服务运行的端口，`coll`变量通过`client.db("rust-cookbook").collection("users")`连接到数据库中的特定集合，其中`rust-cookbook`是数据库，`users`是集合。
- en: We get the `objectId` from the request parameters and assign it to `object_id`
    with `request.param("id").unwrap()`. Then, we use the `ObjectId::with_string`
    helper to decode the string representation of the `objectId`, after which it can
    be used in the `delete_one` method to remove the document for that user. With
    the `DELETE /users/:id` route in place, we should be able to remove `users` from
    the database when we make a request to it and include `objectId` as a parameter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从请求参数中获取`objectId`并将其分配给`object_id`，使用`request.param("id").unwrap()`。然后，我们使用`ObjectId::with_string`辅助函数解码`objectId`的字符串表示形式，之后它可以在`delete_one`方法中使用，以删除该用户的文档。在设置`DELETE
    /users/:id`路由后，我们应该能够在向其发出请求时从数据库中删除`users`，并将`objectId`作为参数包含在内。
- en: Using the `server.utilize` method, we add the endpoints to the server instance
    and register the handler that will be invoked among other handlers before each
    request, by passing the `router` instance. The `server.listen` method listens
    to the API requests on `127.0.0.1:9000`, where it binds and listens for connections
    on the given host and port.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`server.utilize`方法，我们将端点添加到服务器实例中，并通过传递`router`实例注册一个处理程序，该处理程序将在其他处理程序之前被调用。`server.listen`方法监听在`127.0.0.1:9000`上的API请求，它在该主机和端口上绑定并监听连接。
- en: Consider posting multiple data entries using the `POST` web service to store
    data values in the MongoDB with different `ObjectID`, and delete them using the
    service developed in this recipe to better understand the delete web service working.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用`POST`网络服务发布多个数据条目，将不同`ObjectID`的数据值存储在MongoDB中，并使用本食谱中开发的服务删除它们，以更好地理解删除网络服务的工作原理。
