- en: Remember, Remember
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住，记住
- en: One of the main advantages of using Rust over the likes of C is its memory management.
    For example, C programs will run into buffer overruns and associated undefined
    behavior if you attempt to write past the end of an array or past an area reserved
    using `malloc`. Rust protects against most of these problems without compromising
    on efficiency.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Rust而不是C等语言的主要优势之一是其内存管理。例如，如果你尝试在数组的末尾或使用`malloc`预留的区域之后写入，C程序将遇到缓冲区溢出和相关的不确定行为。Rust在保持效率的同时，保护了大多数这些问题。
- en: 'In this chapter, we will delve into how Rust handles memory and will cover
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Rust如何处理内存，并将涵盖以下主题：
- en: Understanding the memory system used within Rust
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Rust中使用的内存系统
- en: How it can go wrong if you're not careful
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不小心，可能会出错
- en: Looking at pointers, references, stack overflows, and preventing crashes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看指针、引用、栈溢出和防止崩溃
- en: Allocating and freeing up memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配和释放内存
- en: Let's start at the beginning
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们从一开始说起
- en: In [Chapter 2](part0039.html#1565U0-a5175cb437d742a9aed0ea574000ee2d)*, Variables*,
    I briefly mentioned how data is stored within memory, and I said that non-compound
    types, such as `i32`, are stored on the stack, whereas, the likes of `String`,
    `Vector<T>`, types, and such are stored on the heap.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0039.html#1565U0-a5175cb437d742a9aed0ea574000ee2d)*，变量*中，我简要介绍了数据在内存中的存储方式，我说非复合类型，如`i32`，存储在栈上，而`String`、`Vector<T>`等类型则存储在堆上。
- en: By default, Rust stores data on the stack, as it's incredibly fast. There are
    drawbacks though. The stack is limited in size and the allocation only lasts for
    the lifetime of the function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Rust将数据存储在栈上，因为它非常快。但是，也存在一些缺点。栈的大小有限，分配仅持续到函数的生存期。
- en: The question is, how much memory does a function take?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，一个函数需要多少内存？
- en: The stack frame
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈帧
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once `main` has exited, the stack frame allocated on entry will be released.
    The beauty of both the allocation and deallocation is that they are carried out
    without the user needing to do anything. The amount of memory can also be computed
    ahead of time, as the compiler knows which local variables are in use. This, again,
    gives a speed increase.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`main`退出，在进入时分配的栈帧将被释放。分配和释放的美丽之处在于，它们在没有用户需要做任何事情的情况下完成。内存量也可以提前计算，因为编译器知道哪些局部变量正在使用。这再次提高了速度。
- en: 'For every positive, there is a downside: the values stored only exist for the
    lifetime of the method.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个优点，都有一个缺点：存储的值仅存在于方法的生存期内。
- en: What is meant by the stack?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是栈？
- en: 'The simplest way to think about the stack is to consider memory as a series
    of boxes. For these examples, think of the boxes in groups of four: the function
    name, the address, the variable name, and the value. Here''s a `main` function
    with a single local variable:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑栈的最简单方式是将内存视为一系列盒子。对于这些示例，请将盒子分为四组：函数名、地址、变量名和值。以下是一个包含单个局部变量的`main`函数示例：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The stack boxes will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 栈盒子将看起来像这样：
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **函数名** | **地址** | **变量名** | **值** |'
- en: '| `main` | `0` | `i` | `32` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `main` | `0` | `i` | `32` |'
- en: 'A slightly different example is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个略有不同的示例：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we will have two unconnected stack boxes. Since the `second` function
    is never called, we never actually allocate memory on the stack for it. The memory
    allocations are therefore exactly same as in the first example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将有两个未连接的栈盒子。由于`second`函数从未被调用，我们实际上从未为它分配栈内存。因此，内存分配与第一个示例完全相同。
- en: 'Our third example is where we have the `main` function call to the `second`
    function; in this case, we actually reserve memory for the `second` function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个示例是`main`函数调用`second`函数的情况；在这种情况下，我们实际上为`second`函数预留了内存：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In terms of our stack boxes, we have the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们的栈盒子而言，我们有以下内容：
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **函数名** | **地址** | **变量名** | **值** |'
- en: '| `second` | `2` | `a` | `32` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `second` | `2` | `a` | `32` |'
- en: '|  | `1` | `b` | `12` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  | `1` | `b` | `12` |'
- en: '| `main` | `0` | `d` | `100` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `main` | `0` | `d` | `100` |'
- en: The variable from the `main` function has the address of 0 as it is from the
    top frame-the frame that calls the other function. The value for the address is
    purely for this example; it can be anywhere and, typically, different types require
    a different amount of the stack to hold them. For instance, if the `number` type
    is 4 bytes in length, the address will be the base address of the stack to store
    `d`, then the address + 4 for `b`, and finally the address + 8 for `a`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数中的变量地址为0，因为它来自最顶层帧——调用其他函数的帧。地址的值纯粹是为了这个例子；它可以在任何地方，并且通常，不同类型需要不同数量的栈空间来存储它们。例如，如果`number`类型长度为4字节，则地址将是存储`d`的栈的基地址，然后是地址+4的`b`，最后是地址+8的`a`。'
- en: 'Once `foo` has returned, the stack reverts to this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`foo`函数返回，栈将恢复到以下状态：
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **函数名** | **地址** | **变量名** | **值** |'
- en: '| `main` | `0` | `d` | `100` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `main` | `0` | `d` | `100` |'
- en: As soon as the `main` function has finished, the stack is empty.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`main`函数执行完毕，栈就为空。
- en: This stacking continues for as many different functions as the application has,
    and they always work in the same way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种堆叠会持续到应用程序中有多少不同的函数，并且它们总是以相同的方式工作。
- en: Let's consider the heap
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们考虑堆
- en: As already discussed, the heap is typically used for complex types. The stack
    frame model can still be used, but it will need modifying, as the stack will need
    to point to the base address of the complex type on the heap.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，堆通常用于复杂类型。栈帧模型仍然可以使用，但需要修改，因为栈需要指向堆上复杂类型的基地址。
- en: 'Let''s construct a stack frame for the following piece of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为以下代码片段构建一个栈帧：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **函数名** | **地址** | **变量名** | **值** |'
- en: '| `main` | `1` | `f` | `42` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `main` | `1` | `f` | `42` |'
- en: '|  | `0` | `my_ids` | `(an instance of Vector)` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  | `0` | `my_ids` | `(一个Vector实例)` |'
- en: Space is allocated correctly for `f`, but `my_ids` is different; it is a `Vector<i64>`
    with pre-allocated space for five `i64s` values. While the vector itself is stored
    in the stack, its contents are allocated in the heap.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 空间已正确分配给`f`，但`my_ids`不同；它是一个预分配了五个`i64`值空间的`Vector<i64>`。虽然向量本身存储在栈上，但其内容是在堆上分配的。
- en: Values in the heap are considered to be more persistent than those in the stack.
    That means, unlike values in the stack, their lifetime does not have to be as
    short as the block's they were defined in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 堆中的值被认为比栈中的值更持久。这意味着，与栈中的值不同，它们的生命周期不必像它们定义的块那样短。
- en: Deallocation
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放
- en: Unlike when memory is freed up on the stack, when you deallocate memory from
    the heap, you end up with holes in the heap. These are empty and can be reallocated
    to other variables. As with anything to do with memory, the reallocation is handled
    by the OS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与在栈上释放内存不同，当你从堆上释放内存时，你会在堆中留下空洞。这些是空的，可以被重新分配给其他变量。与内存相关的任何事物一样，重新分配由操作系统处理。
- en: Deallocation is handled automatically by Rust with a style typically called
    **Resource acquisition is initialization**. This confusingly named concept means
    that resources (such as heap memory, but also other things such as file pointers)
    are allocated during object creation and released during object destruction. Object
    destruction in Rust happens when the binding goes out of scope. If you need to
    define custom destructors for your own objects, you can implement the `std::ops::Drop()`
    trait. It contains a single method, `drop`, which gets called when your object
    loses its last binding.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 释放由Rust以通常称为**资源获取即初始化**的风格自动处理。这个名称令人困惑的概念意味着资源（如堆内存，但也包括文件指针等其他事物）在对象创建时分配，在对象销毁时释放。Rust中的对象销毁发生在绑定超出作用域时。如果您需要为您的对象定义自定义析构函数，您可以实现`std::ops::Drop()`特质。它包含一个方法，`drop`，当您的对象失去最后一个绑定时会被调用。
- en: What about functions with arguments?
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数怎么办？
- en: 'Consider the following piece of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have created two variable bindings, with the second one (`b`) pointing at
    the address for `a`. The `b` variable doesn't contain the value of the `a` variable,
    but it points to the position `a` is held at, from which it can obtain a value
    (in other words, the value of `b` is borrowed from `a`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个变量绑定，第二个绑定（`b`）指向`a`的地址。`b`变量不包含`a`变量的值，而是指向`a`值所在的位置，从中它可以获取值（换句话说，`b`的值是从`a`借用的）。
- en: 'In terms of our stack diagram, we have this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的栈图中，我们有以下内容：
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **函数名** | **地址** | **变量名** | **值** |'
- en: '| `main` | `1` | `b` | `→ address 0` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `main` | `1` | `b` | `→ 地址 0` |'
- en: '|  | `0` | `a` | `32` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|  | `0` | `a` | `32` |'
- en: 'If we have a function call another function, but with a parameter, our stack
    will look slightly different:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个函数调用另一个函数，但带有参数，我们的栈将略有不同：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **函数名** | **地址** | **变量名** | **值** |'
- en: '|  | `3` | `c` | `42` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  | `3` | `c` | `42` |'
- en: '| second | `2` | `i` | `→ address 0` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| second | `2` | `i` | `→ 地址 0` |'
- en: '|  | `1` | `b` | `→ address 0` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  | `1` | `b` | `→ 地址 0` |'
- en: '| main | `0` | `a` | `32` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| main | `0` | `a` | `32` |'
- en: The `i` binding points to `address 0` and the `b` variable points to `address
    0`, and this is the parameter being passed to `second`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`i` 绑定指向 `地址 0`，而 `b` 变量也指向 `地址 0`，这就是传递给 `second` 的参数。'
- en: We can use this stack method to think about memory for a complex situation if
    you like.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢，可以使用这种方法来考虑复杂情况中的内存。
- en: Static memory allocation
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态内存分配
- en: While we have the stack and heap, Rust also has another type of memory allocation,
    that is, statically allocated memory. This is not allocated at runtime, but moves
    into memory with the program's code before the program is run.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有栈和堆时，Rust还有另一种类型的内存分配，那就是静态分配的内存。这不是在运行时分配的，而是在程序运行之前，随着程序的代码移动到内存中。
- en: The likes of `static` and `const` variables are good examples of static allocations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 和 `const` 变量是静态分配的好例子。'
- en: Static memory allocation has the same lifetime as that of the application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内存分配的生存期与应用程序相同。
- en: Garbage collecting time and ownership
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收时间与所有权
- en: If you're used to any of the .NET languages, you'll be more than accustomed
    to the **garbage collector** (**GC**). Essentially, when all references to an
    object have gone out of scope, the object's heap allocation is freed up by the
    garbage collector. The garbage collector comes around every once in a while, basically
    checks through the whole space of allocated memory to see if something isn't used
    anymore, and removes such content from memory; in other words, the garbage left
    behind by a deallocated pointer is collected and removed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了任何.NET语言，你将非常习惯于**垃圾回收器**（**GC**）。本质上，当一个对象的引用全部超出作用域时，垃圾回收器会释放该对象的堆分配。垃圾回收器时不时地出现，基本上会检查整个已分配内存空间，看看是否有不再使用的内容，并将此类内容从内存中移除；换句话说，回收并移除未分配指针留下的垃圾。
- en: Rust has a primitive garbage collector in the form of a reference counted container,
    `Rc<T>`. For most cases, it's not required though, as Rust uses a system known
    as **ownership for allocation**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有一个原始的垃圾回收器，以引用计数容器`Rc<T>`的形式存在。尽管如此，在大多数情况下并不需要，因为Rust使用一种称为**分配所有权**的系统。
- en: Up to this point, when we created a variable, we created variables that mostly
    live on the stack. These have a very short life span. When we create an object
    that lives on the heap, we create a single variable that points to it, but then
    we can have any number of objects point to it, or even through a copy of the pointer,
    have the copy become the base and free up the original. It gets messy and deallocation
    of the heap memory can lead to a variety of memory issues.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们创建变量时，我们创建的变量大多在栈上。它们的生存期非常短。当我们创建一个在堆上生存的对象时，我们创建一个指向它的单个变量，但然后我们可以有任意数量的对象指向它，或者甚至通过指针的副本，使副本成为基础并释放原始指针。这会变得混乱，堆内存的释放可能导致各种内存问题。
- en: We can wrap any type in a generic container, `Box<T>`. This creates an owned
    pointer in Rust, which can only have a single owner, and when that pointer goes
    out of scope, the memory is automatically freed. In this way, Rust prevents a
    large number of the problems that we see in other languages. The point of this
    owned box is that we can hand out the box to other functions, thus being able
    to return heap allocated variables.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何类型包裹在泛型容器`Box<T>`中。这会在Rust中创建一个所有者指针，它只能有一个所有者，当这个指针超出作用域时，内存会自动释放。这样，Rust可以防止我们在其他语言中看到的大量问题。这个所有者盒子的目的是我们可以将盒子分发给其他函数，从而能够返回堆分配的变量。
- en: An owned pointer example
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权指针示例
- en: 'Consider the following piece of code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `x` variable is the single owner of the `my_rectangle` object on the heap.
    As soon as `allocate_rect()` is complete, the memory on the heap allocated to
    `x` is freed, since the last owner is gone.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 变量是堆上 `my_rectangle` 对象的唯一所有者。一旦 `allocate_rect()` 完成，分配给 `x` 的堆内存就会被释放，因为最后一个所有者已经不存在了。'
- en: 'The single owner is enforced by the compiler. The following example demonstrates
    transferring ownership. Once the transfer is complete, the original cannot be
    used again:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器强制执行单一所有者。以下示例演示了所有权转移。一旦转移完成，原始对象就不能再使用了：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Comparison to C
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 C 的比较
- en: 'Consider the following C code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 C 代码：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s what the preceding code does:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码做了什么：
- en: The `int` line allocates a block of memory large enough to store an integer
    value. The `memblock` variable will be in the stack, and the block of memory it
    points to will be in the heap.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int` 行分配了一个足够存储整数值的内存块。`memblock` 变量将在栈上，它指向的内存块将在堆上。'
- en: A value `256` is placed at the location pointed to by `x`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `x` 指向的位置放置了一个值 `256`。
- en: The value of the memory location pointed to by `x` is printed out.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出由 `x` 指向的内存位置的值。
- en: The memory allocated to `memblock` is deallocated.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配给 `memblock` 的内存被释放。
- en: 'This works well, but has the following three major drawbacks:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，但有以下三个主要缺点：
- en: Once the memory is deallocated, it is still entirely possible to use `memblock`.
    Should you try to do this, the application will exhibit undefined behavior; most
    likely, the application will just quit, but there is also a chance that it will
    corrupt memory, which will cause a system crash. The compiler will make no attempt
    to warn you that you've done this, as it assumes you know what you're doing.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦内存被释放，仍然完全有可能使用 `memblock`。如果你尝试这样做，应用程序将表现出未定义的行为；最可能的情况是应用程序会直接退出，但也有可能它会导致内存损坏，从而引起系统崩溃。编译器不会尝试警告你做了这件事，因为它假设你知道你在做什么。
- en: If you allocate a type larger than what was placed into the `sizeof`, this will
    also give rise to undefined behavior. You are essentially trying to put a quart
    into a pint pot.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你分配了一个比 `sizeof` 中放置的类型更大的类型，这也会引发未定义的行为。你本质上是在试图把一夸脱的液体放进一品的罐子里。
- en: If `free` is not called, the memory remains reserved, even though nothing points
    to it anymore, which leads to memory leaks.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有调用 `free`，即使没有任何指针指向它，内存仍然被保留，这会导致内存泄漏。
- en: 'You can perform something similar in Rust but, as we''ll see, Rust prevents
    this undefined behavior automatically:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Rust 中执行类似操作，但正如我们将看到的，Rust 会自动防止这种未定义的行为：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are a number of differences between the C and Rust code versions. They
    are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 Rust 代码版本之间存在许多差异。具体如下：
- en: In C, you allocate heap memory with the `malloc` function. In Rust, we use an
    owned pointer via the `Box<T>` generic.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C 中，你使用 `malloc` 函数分配堆内存。在 Rust 中，我们使用 `Box<T>` 泛型来通过所有者指针。
- en: The call to `malloc` in C returns an `int` pointer (`int *`). In Rust, a smart
    pointer (`Box<T>`) is returned, in this case to an `i64`. A smart pointer is called
    smart as it controls when the object is freed. This can be when the pointer goes
    out of scope without the pointer being given away. Rust keeps track of objects
    and how to clean the memory up.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 中的 `malloc` 调用返回一个 `int` 指针（`int *`）。在 Rust 中，返回一个智能指针（`Box<T>`），在这种情况下指向
    `i64`。智能指针之所以被称为智能，是因为它控制着对象何时被释放。这可能是当指针超出作用域而没有将指针传递出去时。Rust 会跟踪对象以及如何清理内存。
- en: Another useful smart pointer type is the reference counted pointer, `Rc<T>`.
    This generic type allows the sharing of the data inside it over multiple locations.
    It works so that whenever the `Rc` binding gets cloned, a reference count is incremented.
    Whenever such a binding gets deallocated, the reference count is decremented.
    Only when the reference count reaches zero is the underlying value deallocated.
    Note that `Rc<T>` works only in single-threaded scenarios.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的智能指针类型是引用计数的指针，`Rc<T>`。这个泛型类型允许在多个位置共享其内部的数据。它的工作原理是，每当 `Rc` 绑定被克隆时，引用计数就会增加。每当这样的绑定被释放时，引用计数就会减少。只有当引用计数达到零时，底层值才会被释放。请注意，`Rc<T>`
    只在单线程场景中工作。
- en: 'It is used like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式如下：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code, we make several clones of the reference counted pointer. At the
    peak (on the second line of the `secondMethod` function), we have a total of three
    pointers to the underlying heap. When we leave `secondMethod`, the pointer allocated
    via the `secMemBlock` variable gets destructed. Then the `memBlock` clone gets
    deallocated. Finally, when we exit the main function, the last pointer goes away
    and the heap memory is deallocated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了几个引用计数的指针副本。在峰值（`secondMethod` 函数的第二行），我们总共有三个指向底层堆的指针。当我们离开 `secondMethod`
    时，通过 `secMemBlock` 变量分配的指针被销毁。然后 `memBlock` 副本被释放。最后，当我们退出主函数时，最后一个指针消失，堆内存被释放。
- en: Let's revisit some old code
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们回顾一下旧代码
- en: 'Back in [Chapter 4](part0094.html#2PKKS0-a5175cb437d742a9aed0ea574000ee2d)*,
    Conditions, Recursion, and Loops*, we had some code that looked like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第4章](part0094.html#2PKKS0-a5175cb437d742a9aed0ea574000ee2d)*，条件、递归和循环*，我们有一些看起来像这样的代码：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It was explained that what it did was assign the result of `x_cube + x_squared
    + x to y`. If, outside of that, we attempted to access either `x_squared` or `x_cubed`,
    then we wouldn't be able to, as they only existed within the scope of that calculation
    for `y`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 解释说，它所做的操作是将 `x_cube + x_squared + x` 的结果赋值给 `y`。如果在这个范围之外，我们尝试访问 `x_squared`
    或 `x_cubed`，那么我们就无法访问，因为它们只存在于计算 `y` 的那个计算范围内。
- en: 'Consider, then, what would happen if we made `y` a reference and tried to point
    it to a temporary value:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑，如果我们将 `y` 设置为引用并尝试将其指向一个临时值会发生什么：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are assigning `y` to the value of a variable that only exists in a small
    scope (the temporary unnamed value of the computation), then we're trying to access
    that value giving rise to undefined behavior. As we've seen, the Rust compiler
    will do everything it can to prevent this sort of error. In this case, the compiler
    keeps track of each and every reference and fails to build if a reference lasts
    longer than the pointer in use.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `y` 赋值给一个仅在小型作用域中存在的变量的值（计算中的临时未命名值），然后我们尝试访问这个值，从而产生未定义的行为。正如我们所看到的，Rust
    编译器会尽一切努力防止这种错误。在这种情况下，编译器会跟踪每一个引用，如果引用的持续时间超过正在使用的指针，则无法构建。
- en: Let's not race ahead!
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们不要急于前进！
- en: As with anything to do with memory, we do have times where memory is shared
    between pointers. Typically, when we write an application, we don't consider that,
    at any given time, there may be multiple threads running at the same time, and
    while we can fairly accurately predict what will happen by following the flow,
    we can sometimes face an issue known as a race condition. Quite simply, we don't
    know which condition will *hit* first.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与内存相关的任何事物一样，我们确实有内存在指针之间共享的时候。通常，当我们编写应用程序时，我们不会考虑在任何给定时间可能有多个线程同时运行，虽然我们可以通过遵循流程相当准确地预测会发生什么，但我们有时会遇到一个称为竞争条件的问题。简单地说，我们不知道哪个条件会首先*击中*。
- en: 'Let''s look at the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This won't compile because the compiler doesn't know which thread will be `0`
    or `1`, as they both attempt to access `counter` at the same time. In Rust terms,
    `counter` gets moved to the inner thread, which means that it cannot be accessed
    anywhere else. Reference counting via the `Rc` type does not help here, because
    it's not thread-safe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法编译，因为编译器不知道哪个线程将是 `0` 或 `1`，因为它们都试图同时访问 `counter`。在 Rust 术语中，`counter` 被移动到内部线程，这意味着它不能在其他任何地方被访问。通过
    `Rc` 类型的引用计数在这里没有帮助，因为它不是线程安全的。
- en: Stop the race...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止竞争...
- en: How can this error be avoided?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如何避免这种错误？
- en: 'There''s another reference counted type with an incredibly cool name: Atomic
    RC. Atomicity, in this case, refers to non-divisible actions and/or containers,
    which means that they are thread-safe. Also, we''ll need to pair the `Arc` type
    with a `Mutex` to allow us to lock the data for access. Here''s the full code
    for a threaded implementation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个具有非常酷名字的引用计数类型：Atomic RC。在这种情况下，原子性指的是不可分割的操作和/或容器，这意味着它们是线程安全的。此外，我们还需要将
    `Arc` 类型与 `Mutex` 配对，以便我们可以锁定数据以进行访问。以下是线程实现的全代码：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Usually, this code will print `0` because the print method tends to be reached
    before the mutation in the thread takes place.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这段代码将打印 `0`，因为打印方法往往在线程中的突变发生之前被调用。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As far as memory handling is concerned, Rust does a lot for the developer and
    virtually ensures that it is impossible to run into the same form of issues as
    found in C. Freeing up memory from the heap is automatic, and there is even protection
    when using pointers by having unique and multiple protected pointers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存处理方面，Rust 为开发者做了很多工作，几乎确保了不可能遇到像在 C 中发现的那种问题。从堆中释放内存是自动的，而且在使用指针时还有独特的保护机制，即拥有唯一和多个受保护的指针。
- en: In the next chapter, we will have some respite from learning and see how you
    can put what we have covered into your own applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从学习中暂时休息一下，看看你如何将我们所学的内容应用到自己的应用程序中。
