- en: Implementing Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现并发
- en: Concurrency is the act of doing two things at the same time. On a single-core
    processor, this means **multitasking**. When multitasking, an operating system
    will switch between running processes to give each of them a share of time to
    use the processor. On a multi-core processor, concurrent processes can run simultaneously.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是指同时做两件事的行为。在单核处理器上，这意味着 **多任务处理**。在多任务处理时，操作系统将在运行进程之间切换，以便每个进程都能获得处理器使用的时间份额。在多核处理器上，并发进程可以同时运行。
- en: In this chapter, we will look at different models of concurrency. Some of these
    tools are relevant, others are used more for educational purposes. Here, we recommend
    and explain the thread model of concurrency. Further, we will explain how functional
    design patterns can make it easier to develop programs that use concurrency effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的并发模型。其中一些工具与实际应用相关，而其他工具则更多用于教育目的。在这里，我们推荐并解释了并发中的线程模型。此外，我们还将解释如何使用函数式设计模式使开发有效使用并发的程序变得更加容易。
- en: 'Learning outcomes will include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习成果将包括以下内容：
- en: Recognizing and applying subprocess concurrency appropriately
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当地识别并应用子进程并发
- en: Understanding the nix fork concurrency model and its benefits
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 nix 分叉并发模型及其优势
- en: Recognizing and applying thread concurrency appropriately
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当地识别并应用线程并发
- en: Understanding Rust primitive `Send` and `Sync` traits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Rust 原始 `Send` 和 `Sync` 特性
- en: Recognizing and applying the actor design pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别并应用演员设计模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A recent version of Rust is necessary to run the examples provided:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 运行提供的示例需要 Rust 的最新版本：
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
- en: 'This chapter''s code is also available on GitHub:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码也可在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个章节的 `README.md` 文件中也包含了具体的安装和构建说明。
- en: Using subprocess concurrency
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子进程并发
- en: 'A subprocess is a command that is started from within another process. As a
    simple example of this, let''s create a parent process with three children. `process_a`
    will be the parent. Consider the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程是从另一个进程中启动的命令。作为一个简单的例子，让我们创建一个有三个子进程的父进程。`process_a` 将是父进程。考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The child process, `process_b`, runs a loop and prints its own process ID.
    This is shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程 `process_b` 运行一个循环并打印其自己的进程 ID。如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you run `process_a`, then you will see output from the three `process_b`
    processes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `process_a`，那么你将看到来自三个 `process_b` 进程的输出：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you inspect the process tree starting at `process_a`, then you will find
    that three `process_b` processes are attached as children, as shown in the following
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从 `process_a` 开始检查进程树，那么你将发现三个 `process_b` 进程作为子进程附加，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding commands to inspect the process tree require a Unix-like Command
    Prompt. The subprocess module itself, though, is more or less platform-independent.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 检查进程树的先前命令需要 Unix-like 命令提示符。然而，子进程模块本身基本上是平台无关的。
- en: Subprocess concurrency is useful if you want to run and manage other projects
    or utilities. A good example of subprocess concurrency done right is the `cron`
    utility. `cron` accepts a configuration file that specifies different commands
    to be run, and a schedule of when to run them. `cron` continues to run in the
    background and at the appropriate time starts each configured process according
    to schedule.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程并发对于想要运行和管理其他项目或实用程序非常有用。子进程并发做得很好的一个例子是 `cron` 实用程序。`cron` 接受一个配置文件，该文件指定了要运行的不同命令以及运行它们的时间表。`cron`
    会持续在后台运行，并在适当的时间根据时间表启动每个配置的进程。
- en: Subprocess concurrency is not well suited for parallel computation in general.
    No resources will be shared between parent and child processes when using the
    `subprocess::Command` interface. Also, information cannot be shared easily between
    these processes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程并发通常不适合并行计算。使用 `subprocess::Command` 接口时，父进程和子进程之间不会共享任何资源。此外，这些进程之间难以轻松共享信息。
- en: Understanding nix fork concurrency
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 nix 分叉并发
- en: Before threads were introduced as a standard for POSIX operating systems in
    1995, the best option available for concurrency was `fork`. On these operating
    systems, `fork` was a fairly primitive command that allowed programs to create
    copies of themselves as child processes. The name `fork` comes from the idea of
    taking one process and splitting it into two.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在1995年将线程作为POSIX操作系统的标准之前，可用的最佳并发选项是`fork`。在这些操作系统中，`fork`是一个相当原始的命令，允许程序作为子进程创建自己的副本。`fork`这个名字来源于将一个进程分成两个的想法。
- en: '`fork` is not platform-independent, specifically it is not available on Windows,
    and we recommend using threads instead. However, for educational purposes, it
    is helpful to introduce some of the concepts from `fork` because they are also
    relevant to threaded programming.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork`不是平台无关的，具体来说，它在Windows上不可用，我们建议使用线程。然而，出于教育目的，介绍一些`fork`的概念是有帮助的，因为这些概念也与线程编程相关。'
- en: 'The following code is a translation of the preceding `process_a`, `process_b`
    example to use `fork`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是将先前的`process_a`、`process_b`示例翻译成使用`fork`的代码：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the parent-child relationship is very similar to our first
    example. We have three children running and one parent managing them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，父-子关系与我们的第一个例子非常相似。我们有三个子进程在运行，一个父进程在管理它们。
- en: It should be noted that forked processes share memory initially. Only when either
    process modifies its memory, will the operating system then perform an operation
    called **copy-on-write**, duplicating the memory. This behavior is a first step
    into shared memory between running processes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，初始时，被`fork`的进程共享内存。只有当任一进程修改其内存时，操作系统才会执行一个称为**写时复制**的操作，复制内存。这种行为是运行进程之间共享内存的第一步。
- en: 'To demonstrate copy-on-write, let''s allocate 200 MB of memory and fork 500
    processes. Without copy-on-write, this would be 100 GB and would crash most personal
    computers. Consider the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示写时复制，让我们分配200 MB的内存并`fork` 500个进程。如果没有写时复制，这将需要100 GB的内存，并且会崩溃大多数个人电脑。考虑以下代码：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Many resources from the parent process also remain available and safe to use
    from the child process. This is very useful for server applications that listen
    on a socket in the parent process and poll for incoming connections in the child
    process. This simple trick permits server applications to distribute work across
    worker processes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程的许多资源也仍然可用，并且可以从子进程中安全地使用。这对于在父进程中监听套接字并在子进程中轮询传入连接的服务器应用程序非常有用。这个简单的技巧允许服务器应用程序在工作进程之间分配工作：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, we start listening for connections on port `8888`. Then, after
    forking three times, we start serving responses with our worker process. Sending
    requests to the server, we can confirm that separate processes are indeed competing
    to serve requests. Consider the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们开始监听端口号`8888`的连接。然后，在三次`fork`之后，我们开始用我们的工作进程提供响应。向服务器发送请求，我们可以确认确实有多个进程在竞争提供服务。考虑以下代码：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All three workers served at least one response. Combining the first strategy
    of memory sharing with this new concept of built-in load balancing, forked processes
    effectively solve several common problems where concurrency is desired.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个工作进程至少提供了一次响应。结合内存共享的第一种策略和这种新的内置负载均衡概念，`fork`进程有效地解决了许多需要并发性的常见问题。
- en: However, the fork concurrency model is very rigid. Both of these tricks require
    planning the application to strategically fork after resources are allocated.
    Fork does not help at all after the processes have been split. In POSIX, there
    have been additional standards created to address this problem. Sending information
    over channels or sharing memory are a common pattern, much like in Rust. However,
    none of these solutions have proved as practical as threads.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`fork`并发模型非常僵化。这两个技巧都需要在分配资源后战略性地`fork`应用程序。一旦进程被分割，`fork`就完全无助于解决问题。在POSIX中，已经创建了额外的标准来解决这一问题。通过通道发送信息或共享内存是一种常见的模式，就像在Rust中一样。然而，这些解决方案没有一个像线程那样实用。
- en: Threads implicitly permit inter-process messaging and memory sharing. The risk
    of threads is that sharing messages or memory may not be thread-safe and may lead
    to memory corruption. Rust is built from the ground up to make threaded programming
    safer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 线程隐式地允许进程间消息传递和内存共享。线程的风险是，共享消息或内存可能不是线程安全的，可能会导致内存损坏。Rust从头开始构建，以使线程编程更安全。
- en: Using thread concurrency
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程并发
- en: 'Rust threads have the following features:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Rust线程具有以下特性：
- en: Share memory
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存
- en: Share resources, such as files or sockets
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享资源，例如文件或套接字
- en: Tend to be thread-safe
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常具有线程安全性
- en: Support inter-thread messaging
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持线程间消息传递
- en: Are platform-independent
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有平台无关性
- en: For the preceding reasons, we suggest that Rust threads are better suited to
    most concurrency use cases than subprocesses. If you want to distribute computation,
    circumvent a blocking operation, or otherwise utilize concurrency for your application—use
    threads.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述原因，我们建议Rust线程比子进程更适合大多数并发用例。如果您想分发计算、绕过阻塞操作或以其他方式利用并发来为您的应用程序提供服务——请使用线程。
- en: 'To show the thread pattern, we can re-implement the preceding examples. Here
    are three children threads:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示线程模式，我们可以重新实现前面的示例。以下是三个子线程：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we spawn three threads and let them run. We print the process ID, but
    we must also print the thread ID because threads share the same process ID. Here
    is the output demonstrating this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们启动了三个线程，并让它们运行。我们打印进程ID，但我们必须也打印线程ID，因为线程共享相同的进程ID。以下是演示这一点的输出：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next example to port is the 500 processes and shared memory. In a threaded
    program, sharing might look something like the following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要移植的例子是500个进程和共享内存。在一个线程程序中，共享可能看起来像以下代码片段：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The process starts 500 threads, all sharing the same memory. Also, thanks to
    the lock, we could modify this memory safely if we wanted.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 进程启动了500个线程，它们共享相同的内存。此外，多亏了锁，如果我们想修改这个内存，我们可以安全地这样做。
- en: 'Let''s try the server example, as shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下代码所示的服务器示例：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, three worker processes scrape a queue of requests that get served down
    from the parent process. All three children and the parent need to read and mutate
    the request queue. To mutate the request queue, each thread must lock the data.
    There is a dance here that the children and parent do to avoid holding the lock
    for too long. If one thread monopolizes the locked resource, then all other processes
    wanting to use the data must wait.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，三个工作进程从父进程那里抓取请求队列，这些请求由父进程提供服务。所有三个子进程和父进程都需要读取和修改请求队列。为了修改请求队列，每个线程都必须锁定数据。这里有一个子进程和父进程之间的舞蹈，以避免长时间持有锁。如果一个线程垄断了锁定的资源，那么所有其他想要使用数据的进程都必须等待。
- en: The trade-off of locking and waiting is called **contention**. In the worst
    case scenario, two threads can each hold a lock while waiting for the other thread
    to release the lock it holds. This is called **deadlock**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定和等待的权衡被称为**竞争**。在最坏的情况下，两个线程可以各自持有锁，同时等待另一个线程释放它持有的锁。这被称为**死锁**。
- en: Contention is a difficult problem associated with mutable shared state. For
    the preceding server case, it would have been better to send messages to children
    threads. Message passing does not create locks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争是与可变共享状态相关的一个难题。对于前面的服务器案例，向子线程发送消息会更好。消息传递不会创建锁。
- en: 'Here is a lock-free server:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个无锁服务器的示例：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Channels work much better in this situation. This multi-threaded server has
    load balancing controlled from the parent process and does not suffer from lock
    contention.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通道工作得更好。这个多线程服务器由父进程控制负载均衡，并且不受锁竞争的影响。
- en: 'Channels are not strictly better than shared state. For example, legitimately
    contentious resources are good to handle with locks. Consider the following code
    snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通道并不严格优于共享状态。例如，合法的竞争性资源用锁来处理是很好的。考虑以下代码片段：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have a large mutable data structure (a neural network) that is broken
    into rows and columns. Each column has a thread-safe lock. Row data is all associated
    with the same lock. This pattern is useful for data and computation-heavy programs.
    Neural network training is a good example of where this technique may be relevant.
    Unfortunately, the code does not implement an actual neural network, but it does
    demonstrate how lock concurrency could be used to do so.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个大的可变数据结构（一个神经网络），它被分解成行和列。每一列都有一个线程安全的锁。行数据都与同一个锁相关联。这种模式对于数据密集型和计算密集型程序非常有用。神经网络训练是这种技术可能相关的良好例子。不幸的是，代码并没有实现一个实际的神经网络，但它确实展示了如何使用锁并发来实现这一点。
- en: Understanding Send and Sync traits
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Send和Sync特性
- en: In the previous neural network example, we used a static data structure that
    was shared between threads without being wrapped in a counter or lock. It contained
    locks, but why was the outer data structure permitted to be shared?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的神经网络示例中，我们使用了一个静态数据结构，它在没有包裹在计数器或锁中时在多个线程间共享。它包含锁，但为什么外部的数据结构被允许共享？
- en: 'To answer this question, let''s first review the rules of ownership:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，让我们首先回顾一下所有权规则：
- en: Each value in Rust has a variable that's called its **owner**
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 中的每个值都有一个称为其 **所有者** 的变量
- en: There can only be one owner at a time
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次只能有一个所有者
- en: When the owner goes out of scope, the value will be dropped
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有者超出作用域时，其值将被丢弃
- en: 'With these rules in mind, let''s try to share a variable across threads, as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些规则的基础上，让我们尝试在多个线程间共享一个变量，如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we try to compile this, then we will get an error complaining of the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译这个，那么我们会得到一个错误，抱怨以下内容：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This error indicates the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误指示以下内容：
- en: Referencing variable `a` from inside the closure is okay
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在闭包内部引用变量 `a` 是可以的
- en: The closure lives longer than variable `a`
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `a` 的生命周期比闭包长
- en: Closures sent to threads must have a static lifetime. Variable `a` is a local
    variable, and thus will go out of scope before the static closure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到线程的闭包必须具有静态生命周期。变量 `a` 是局部变量，因此它将在静态闭包之前超出作用域。
- en: 'To fix this error, it is common to move the variable `a` into the closure.
    Thus, `a` will inherit the same lifetime as the closure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个错误，通常会将变量 `a` 移动到闭包中。因此，`a` 将继承闭包相同的生命周期：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This program will compile and run. Ownership of the variable `a` is transferred
    to the closure and therefore lifetime issues are avoided. It should be noted that
    transferring ownership of a variable implies that the original variable is no
    longer valid. This is caused by ownership rule number `2`—there can only by one
    owner at a time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序可以编译并运行。变量 `a` 的所有权被转移到闭包中，因此避免了生命周期问题。需要注意的是，转移变量的所有权意味着原始变量不再有效。这是由所有权规则编号
    `2`——一次只能有一个所有者所导致的。
- en: 'If we try to share the variable again, we get an error:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次尝试共享变量，我们会得到一个错误：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compiling this gives us this error message:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编译这个会给我们这个错误信息：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This compiler error is a bit complicated. It says the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译器错误有点复杂。它说以下内容：
- en: '**Capture of moved value**: `a`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动值的捕获**：`a`'
- en: Value moved (into closure) here
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里移动的值（进入闭包）
- en: Value captured here after move
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里捕获的移动后的值
- en: Note—move occurs because `a` does not implement the `Copy` trait
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意——移动发生是因为 `a` 没有实现 `Copy` 特性
- en: Part four of the error tells us that if `a` implements the `Copy` trait, then
    we would not have this error. However, that would be implicitly copying the variable
    for us, meaning we would not be sharing data. So, that suggestion is not useful
    for us.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息中的第四部分告诉我们，如果 `a` 实现了 `Copy` 特性，那么我们就不会有这个错误。然而，那将隐式地为我们复制变量，这意味着我们不会共享数据。所以，这个建议对我们来说没有用。
- en: 'The main problem is part one—capture of moved value `a`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是第一部分——移动值的捕获 `a`：
- en: First we move the variable `a` into the first closure. We needed to do this
    to avoid the lifetime problem and to use the variable. Using a variable in a closure
    is called a **capture**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将变量 `a` 移动到第一个闭包中。我们需要这样做以避免生命周期问题并使用该变量。在闭包中使用变量称为 **捕获**。
- en: Next we use variable `a` in the second closure. This is the `value captured
    after move`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们在第二个闭包中使用变量 `a`。这是 `移动后的值捕获`。
- en: 'So our problem is that moving variable `a` invalidates it for further use.
    A much simpler example of this problem would be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的问题是移动变量 `a` 使其对于进一步使用无效。这个问题的一个更简单的例子如下：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By moving ownership of the value in `a` into `b`, we invalidate the original
    variable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `a` 中的值的所有权移动到 `b`，我们使原始变量无效。
- en: So what do we do? Are we stuck?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们该怎么办？我们卡住了吗？
- en: In the neural network example, we used a shared data structure, so clearly there
    must be a way. If there is a way, hopefully there is also a rule to make sense
    of the problem. To fully understand thread-safety rules in Rust, you must understand
    three concepts—scope, `Send`, and `Sync`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在神经网络示例中，我们使用了一个共享的数据结构，所以显然必须有一种方法。如果有方法，希望也有规则来解释这个问题。要完全理解 Rust 中的线程安全规则，你必须理解三个概念——作用域、`Send`
    和 `Sync`。
- en: First, let's address scope. Scope for threads means that variables used must
    be allowed to capture the variables that they used. Variables can be captured
    by value, by reference, or by mutable reference.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解决作用域问题。线程的作用域意味着使用的变量必须允许捕获它们所使用的变量。变量可以通过值、引用或可变引用来捕获。
- en: 'Our first example, not using `move`, almost worked. The only problem was that
    the lifetime of the variable we used went out of scope too soon. All thread closures
    must have static lifetimes, and therefore variables that they capture must also
    have static lifetimes. Adjusting for this, we can create a simple two-thread program
    that captures our variable, `A`, by reference and therefore does not move the
    variable:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子，没有使用 `move`，几乎成功了。唯一的问题是，我们使用的变量的生命周期过早地超出了作用域。所有线程闭包都必须具有静态生命周期，因此它们捕获的变量也必须具有静态生命周期。对此进行调整，我们可以创建一个简单的双线程程序，通过引用捕获我们的变量
    `A`，因此不需要移动变量：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Reading from static variables is safe. Mutating static variables is unsafe.
    Static variables are also disallowed from allocating heap memory directly, so
    they can be difficult to work with.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从静态变量中读取是安全的。修改静态变量是不安全的。静态变量也不允许直接分配堆内存，因此它们可能难以处理。
- en: 'Using the `lazy_static` crate is a good way to create static variables with
    types that have memory allocation and need initialization:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lazy_static` 包是一个创建具有内存分配和初始化需求的静态变量的好方法：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A second way to fix scope problems is to use a reference counter, such as `Arc`.
    Here, we use `Arc` instead of `Rc` because `Arc` is thread-safe and `Rc` is not.
    Consider the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 解决作用域问题的第二种方法是使用引用计数器，例如 `Arc`。在这里，我们使用 `Arc` 而不是 `Rc`，因为 `Arc` 是线程安全的，而 `Rc`
    不是。考虑以下代码：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The reference counter moves the reference into the closure. However, the internal
    data is shared, so it is then possible to reference common data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数器将引用移动到闭包中。然而，内部数据是共享的，因此可以引用公共数据。
- en: 'If shared data should be mutated, then a `Mutex` lock can allow thread-safe
    locking. Another useful lock is the `std::sync::RwLock`. This is shown as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果共享数据应该被修改，那么一个 `Mutex` 锁可以允许线程安全的锁定。另一个有用的锁是 `std::sync::RwLock`。如下所示：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So why is mutation allowed after the lock, but not before? The answer is `Send`
    and `Sync`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么在锁定之后允许修改，而在锁定之前不允许呢？答案是 `Send` 和 `Sync`。
- en: '`Send` and `Sync` are marker traits. A marker trait does not implement any
    functionality; however, it indicates that a type has some property. These two
    properties tell the compiler what behavior should be allowed with regards to sharing
    data between threads.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send` 和 `Sync` 是标记特性。标记特性不实现任何功能；然而，它表明一个类型具有某些属性。这两个属性告诉编译器在数据线程间共享时应允许哪些行为。'
- en: 'These are the rules regarding thread data sharing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是关于线程数据共享的规则：
- en: A type is `Send` if it is safe to send it to another thread
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将一个类型安全地发送到另一个线程，则该类型是 `Send`。
- en: A type is `Sync` if it is safe to share between multiple threads
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类型可以在多个线程间安全地共享，则该类型是 `Sync`。
- en: To make mutable data that can be shared across threads, whatever data type,
    you use must implement `Sync`. The standard Rust library has some thread-safe
    concurrency primitives, such as `Mutex`, for this purpose. If you don't like the
    options available, then you can search for another crate or make something yourself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建可以在多个线程间共享的可变数据，无论数据类型如何，你必须实现 `Sync`。标准 Rust 库有一些线程安全的并发原语，如 `Mutex`，用于此目的。如果你不喜欢可用的选项，那么你可以搜索另一个包或自己创建一个。
- en: 'To implement `Sync` for a type, just implement the trait with no body:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要为类型实现 `Sync`，只需实现没有主体的特性：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Be warned—incorrectly implementing `Send` or `Sync` can cause undefined behavior.
    The traits are always unsafe to implement. Thankfully, both of these marker traits
    are generally derived by the compiler, so you will very rarely need to manually
    derive them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 警告——错误地实现 `Send` 或 `Sync` 可能会导致未定义的行为。这些特性总是不安全的实现。幸运的是，这两个标记特性通常由编译器自动推导，所以你很少需要手动推导它们。
- en: With these various rules in mind, we can see how Rust prevents many common threading
    bugs. Foremost, the ownership system prevents a lot of problems. Then, to allow
    some inter-thread communication, we find that channels and locks can help to safely
    implement most concurrency models.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记这些各种规则，我们可以看到 Rust 如何防止许多常见的线程错误。首先，所有权系统防止了许多问题。然后，为了允许一些线程间的通信，我们发现通道和锁可以帮助安全地实现大多数并发模型。
- en: This was a lot of trial and error but, in summary, we learned that `thread`,
    `move`, `channel`,  `Arc`, and `Mutex` will get us through most problems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要进行大量的试错，但总的来说，我们了解到`thread`、`move`、`channel`、`Arc`和`Mutex`将帮助我们解决大多数问题。
- en: Using functional design for concurrency
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数式设计进行并发
- en: Concurrency forces the programmer to be more careful about information sharing.
    This difficulty coincidentally encourages good functional programming practices,
    such as immutable data and pure functions; when computation is not context-sensitive,
    it tends to also be thread-safe.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 并发迫使程序员更加注意信息共享。这种困难偶然地鼓励了良好的函数式编程实践，如不可变数据和纯函数；当计算不是上下文相关时，它往往也是线程安全的。
- en: Functional programming sounds great for concurrency, but are there downsides?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程听起来非常适合并发，但有没有缺点？
- en: In one example of good intentions with bad effects, during development of a
    functional language called **Haskell**, the development team ([https://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell](https://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell))
    wanted to make programs run faster using concurrency. Due to a unique trait of
    the Haskell language, it was possible to run all expressions and sub-expressions
    in new threads. The development team thought this sounded great and tested it
    out.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个意图良好但效果不佳的例子中，在开发名为**Haskell**的函数式语言期间，开发团队（[https://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell](https://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell)）希望通过并发来使程序运行得更快。由于Haskell语言的独特特性，可以在新线程中运行所有表达式和子表达式。开发团队认为这听起来很棒，并进行了测试。
- en: The result was that more time was spent spawning new threads than doing any
    computation. The idea still had merit, but it turned out that implementing concurrency
    automatically would be difficult. There are many trade-offs in concurrent programming.
    Letting the programmer make decisions regarding these trade-offs is the current
    state-of-the-art.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，花费在创建新线程上的时间比进行任何计算的时间还要多。这个想法本身还是有价值的，但最终证明实现自动并发是困难的。并发编程中有许多权衡。让程序员就这些权衡做出决策是当前最先进的状态。
- en: So, from functional programming, what patterns have proven useful?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从函数式编程来看，哪些模式被证明是有用的？
- en: 'There are many patterns for concurrent programming, but here we will introduce
    a few primitives:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程有许多模式，但在这里我们将介绍一些基本模式：
- en: '**Actors**: Threads and patterns of behavior'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**actor**：线程和行为模式'
- en: '**Supervisors**: Monitor and manage actors'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监督者**：监控和管理actor'
- en: '**Routers**: Send messages between actors'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器**：在actor之间发送消息'
- en: '**Monads**: Composable units of behavior'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**monad**：可组合的行为单元'
- en: 'First, let''s look at actors in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看以下代码中的actor：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we have two threads sending messages back and forth. Is this really much
    different than any of the previous examples?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有两个线程在相互发送消息。这真的和之前的任何例子有很大不同吗？
- en: There is a fairly common saying in functional programming that "*a closure is
    a poor man's object, and an object is a* *poor man's closure*".
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中有一个相当常见的说法：“*闭包是穷人的对象，而对象是穷人的闭包*”。
- en: According to object-oriented programming, objects have a type, fields, and methods.
    The closures we define hold their own mutable state, like fields of on an object.
    The ping and pong closures have slightly different types. The behavior inside
    the closure could be thought of as a single nameless method on the closure object.
    There are similarities here between object and closure.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据面向对象编程，对象有类型、字段和方法。我们定义的闭包持有它们自己的可变状态，就像对象上的字段一样。ping和pong闭包有略微不同的类型。闭包内的行为可以被视为闭包对象上的一个无名称方法。在这里，对象和闭包之间有相似之处。
- en: However, it would be much nicer to use a normal object. The problem with attempting
    this is that the thread boundary gets in the way. Threads do not expose methods,
    only message passing. As a compromise, we could wrap the message passing into
    the form of methods. This would hide all of the channel management and would make
    programming with concurrent objects much nicer. We call this pattern the actor
    model.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用普通对象会更好一些。尝试这样做的问题在于线程边界会阻碍操作。线程不暴露方法，只进行消息传递。作为一个折衷方案，我们可以将消息传递封装成方法的形式。这将隐藏所有的通道管理，使得使用并发对象进行编程更加方便。我们将这种模式称为actor模型。
- en: An actor is very similar to an OOP object with the additional property that
    it lives in its own thread. Messages are sent to the actor, the actor processes
    the messages, and maybe sends out messages of its own. The actor model is like
    a busy city of people living and working doing different jobs but interacting
    and exchanging with one another according to their own schedules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 演员与 OOP 对象非常相似，额外的一个属性是它生活在自己的线程中。消息被发送到演员，演员处理消息，并可能发送出自己的一些消息。演员模型就像一个繁忙的城市，人们生活在其中，从事不同的工作，但根据他们自己的时间表相互交流和交换。
- en: There are crates that attempt to provide elegant concurrent actor behavior,
    but we won't endorse any specifically. For the time being, please just squint
    your eyes and continue to pretend that closures are similar to objects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些箱子试图提供优雅的并发演员行为，但我们不会特别推荐任何一种。目前，请只是眯起眼睛，继续假装闭包与对象相似。
- en: 'In the next example, let''s wrap these actors into functions so that they can
    be created more easily:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，让我们将这些演员包装成函数，以便更容易地创建它们：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To run the example, we will create three of each type of actor and store the
    channels in a vector, as shown in the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，我们将创建每种类型的三个演员，并将通道存储在一个向量中，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we have actors and a really basic supervisor for each actor group. The
    supervisor here is just a vector to keep track of communication channels for each
    actor. A good supervisor should periodically check the health of each actor, kill
    bad actors, and resupply the stock of good actors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为每个演员组有了演员和一个非常基本的监督者。这里的监督者只是一个向量，用于跟踪每个演员的通信通道。一个好的监督者应该定期检查每个演员的健康状况，杀死不良演员，并补充良好演员的库存。
- en: The last actor-based primitive that we will mention is routing. Routing is the
    method equivalent of object-oriented programming. OOP method calls were originally
    called **message passing**. The actor model is very object-oriented and accordingly
    we still call methods by actually passing messages around. We are still using
    the poor man's objects (closures), so our routing will probably look like a glorified
    `if` statement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要提到的最后一个基于角色的原始方法是路由。路由是面向对象编程的方法等价物。OOP 方法调用最初被称为 **消息传递**。演员模型非常面向对象，因此我们仍然通过实际传递消息来调用方法。我们仍在使用穷人的对象（闭包），所以我们的路由可能看起来像是一个美化过的
    `if` 语句。
- en: 'To start our actor router, we will define two data types—addresses and messages.
    Addresses should define all possible destinations and routing behaviors for messages.
    Messages should correspond to all possible method calls from all actors. Here
    is our extended ping pong application:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的演员路由器，我们将定义两种数据类型——地址和消息。地址应该定义消息的所有可能目的地和路由行为。消息应该对应于所有演员的所有可能方法调用。以下是我们的扩展乒乓应用：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then we define our actors. They now need to match against the new `Message`
    type, and outgoing messages should have an `Address` in addition to a `Message`.
    Despite the changes, the code remains very similar to before:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的演员。现在，它们需要与新的 `Message` 类型匹配，并且发出的消息应该有一个 `Address`，除了 `Message`。尽管有所变化，代码仍然非常相似：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each ping pong process loops to consume one message and send two more across.
    The last component for the program is initialization and routing:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个乒乓进程循环消费一条消息，并发送两条消息。程序的最后一个组件是初始化和路由：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After initializing the different actors, the main thread starts acting as the
    router. The router is a single thread with the sole responsibility of finding
    destinations, then moving, copying, cloning, and otherwise distributing messages
    to the recipient threads. This is not a complex solution, but it is effective,
    and uses only the typesafe, thread-safe, platform-independent primitives that
    we have introduced so far.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化了不同的演员之后，主线程开始充当路由器。路由器是一个单线程，唯一的责任是找到目的地，然后移动、复制、克隆以及其他方式将消息分发给接收线程。这不是一个复杂的解决方案，但它是有效的，并且只使用了我们迄今为止引入的类型安全、线程安全、平台无关的原始类型。
- en: 'In a more complex example, the routing `Address` will typically have the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更复杂的例子中，路由 `Address` 通常具有以下特点：
- en: An actor role
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员角色
- en: A method name
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称
- en: Argument type signatures
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型签名
- en: The message would then be the arguments according to the preceding type signature.
    Sending a message from an actor is as simple as sending your `(Address,Message)`
    to the router. The router at this time should be regularly checking each channel
    for new routing requests. When it sees the new message, it will pick an actor
    that satisfies the `Address` condition and send the message to that actor's inbox.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么消息将是根据前面的类型签名提供的参数。从演员发送消息就像发送你的`(Address,Message)`到路由器一样简单。此时，路由器应该定期检查每个通道是否有新的路由请求。当它看到新消息时，它将选择满足`Address`条件的演员，并将消息发送到该演员的收件箱。
- en: Watching the output, each ping pong action doubles the number of messages received.
    If each thread didn't do so much sleeping, then the program could get out of hand
    quickly. Messaging noise is one risk of overusing the actor model.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 观察输出，每次乒乓动作都会将接收到的消息数量翻倍。如果每个线程不做那么多睡眠，那么程序可能会迅速失控。消息噪声是过度使用演员模型的一个风险。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the primitives of concurrent computation. Subprocesses,
    forked processes, and threads are the basic building blocks of all concurrent
    applications. In Rust threads, there are additional concerns that are introduced
    by the language to encourage type and thread safety.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了并发计算的基本原理。子进程、分叉进程和线程是所有并发应用程序的基本构建块。在Rust的线程中，语言引入了额外的关注点，以鼓励类型和线程安全。
- en: In several examples, we built a concurrent web server using fork or threads.
    Later, while exploring thread behavior, we looked closely at what data can be
    shared between threads and how information can be sent between threads safely.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个示例中，我们使用分叉或线程构建了并发网络服务器。后来，在探索线程行为时，我们仔细观察了线程之间可以共享哪些数据以及如何安全地在线程之间发送信息。
- en: In the design pattern section, we introduced the actor design pattern. This
    popular technique combines some elements of object-oriented programming with other
    concepts from functional programming. The result is a programming tool designed
    specifically for complex resilient concurrency.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模式部分，我们介绍了演员设计模式。这种流行的技术结合了面向对象编程的一些元素和函数式编程的其他概念。结果是专为复杂健壮的并发设计的一种编程工具。
- en: In the next chapter, we will explore performance, debugging, and metaprogramming.
    Performance can be hard to measure or compare, but we will try to introduce habits
    that are strictly good for performance. To help debugging, we will look at proactive
    and reactive techniques to solve issues. Proactive debugging is a set of techniques,
    such as proper error handling, that either prevents bugs or makes them easier
    to document and resolve. Reactive techniques are useful for difficult bugs that
    don't have an obvious cause. Finally, metaprogramming can do lots of complicated
    work behind the scenes to make ugly code look nicer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨性能、调试和元编程。性能可能难以衡量或比较，但我们将尝试介绍对性能严格有益的习惯。为了帮助调试，我们将探讨主动和被动技术来解决这些问题。主动调试是一套技术，如适当的错误处理，它要么防止错误，要么使错误更容易记录和解决。被动技术对于没有明显原因的困难错误很有用。最后，元编程可以在幕后完成大量复杂的工作，使丑陋的代码看起来更美观。
- en: Questions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a subprocess?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是子进程？
- en: Why is fork called fork?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么分叉被称为分叉？
- en: Is fork still useful?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分叉（fork）是否仍然有用？
- en: When were threads standardized?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程何时被标准化？
- en: Why is `move` sometimes needed for thread closures?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么有时需要`move`来处理线程闭包？
- en: What is the difference between `Send` and `Sync` traits?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Send`和`Sync`特质的区别是什么？'
- en: Why are we allowed to lock and then mutate `Mutex` without an unsafe block?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们可以不对`Mutex`加锁就进行修改，而不需要使用不安全的代码块？
