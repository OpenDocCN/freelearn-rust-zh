- en: Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: Modern day software is rarely written to perform tasks sequentially. It is more
    important today to be able to write programs that do more than one thing at a
    time and do it correctly. As transistors keep getting smaller, computer architects
    are unable to scale CPU clocks frequency due to quantum effects in the transistors.
    This has shifted focus more towards building concurrent CPU architectures that
    employ multiple cores. With this shift, developers need to write highly concurrent
    applications to maintain performance gains that they had for free when Moore's
    law was in effect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的软件很少被编写为顺序执行任务。今天，能够编写能够同时做很多事情并且正确执行这些事情的程序更为重要。随着晶体管变得越来越小，由于晶体管中的量子效应，计算机架构师无法通过提高CPU时钟频率来扩展CPU的性能。这导致更多的关注点转向构建采用多个核心的并发CPU架构。随着这种转变，开发者需要编写高度并发的应用程序来维持当摩尔定律生效时所获得的免费性能提升。
- en: But writing concurrent code is hard and languages that don't provide better
    abstractions make the situation worse. Rust attempts to make things better and
    safer in this space. In this chapter, we will go through the concepts and primitives
    that enable Rust to provide fearless concurrency to developers, allowing them
    to easily express their programs in a way that can safely do more than one thing
    at a time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但编写并发代码是困难的，那些不提供更好抽象的语言使得情况变得更糟。Rust试图在这个领域使事情变得更好、更安全。在本章中，我们将探讨使Rust能够为开发者提供无畏并发、允许他们以安全的方式轻松表达程序的概念和原语。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Program execution models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序执行模型
- en: Concurrency and associated pitfalls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发及其相关陷阱
- en: Threads as unit of concurrency
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程作为并发单元
- en: How Rust provides thread-safety
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust如何提供线程安全性
- en: Concurrency primitives in Rust
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust中的并发原语
- en: Other libraries for concurrency
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他并发库
- en: Program execution models
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序执行模型
- en: '"An evolving system increases its complexity unless work is done to reduce
    it."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '"一个不断发展的系统，除非进行工作来减少它，否则会增加其复杂性。"'
- en: '- *Meir Lehman*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '- *梅尔·莱曼*'
- en: In the early 1960s, before multitasking was even a thing, programs written for
    computers were limited to a sequential execution model, where they were able to
    run instructions one after the other in chronological order. This was mainly due
    to limitations in how many instructions the hardware could process during that
    time. As we shifted from vacuum tubes to transistors, then to integrated chips,
    the modern day computer opened up possibilities to support multiple points of
    execution in programs. Gone are the days of sequential programming model where
    computers had to wait for an instruction to finish before executing the next one.
    Today, it's more common for computers to be able to do more than one thing at
    a time and do it correctly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代初，在多任务处理甚至还是一个概念之前，为计算机编写的程序局限于顺序执行模型，它们能够按照时间顺序依次执行指令。这主要是因为当时硬件在处理指令方面的限制。当我们从真空管转向晶体管，再到集成电路时，现代计算机为支持程序中的多个执行点打开了可能性。那些需要等待一个指令执行完毕才能执行下一个指令的顺序编程模型已经过去了。今天，计算机能够同时做很多事情并且正确地完成这些事情的情况更为常见。
- en: 'The modern day computer models a concurrent execution model, where a bunch
    of instructions can execute independently of each other with overlapping time
    periods. In this model, instructions need not wait for each other and run nearly
    at the same time, except when they need to share or coordinate with some data.
    If you look at the modern day software, it does many things that appear to happen
    at the same time, as in the following examples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机模型了一个并发执行模型，其中一组指令可以在不同的时间间隔内独立执行。在这个模型中，指令不需要相互等待，几乎同时运行，除非它们需要共享或协调某些数据。如果你观察现代软件，它做很多事情看起来似乎是同时发生的，如下面的例子所示：
- en: The user interface of a desktop application continues to work normally even
    though the application connects to the network in the background
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使桌面应用程序在后台连接到网络，其用户界面仍然可以正常工作
- en: A game updates the state of thousands of entities at the same time, while playing
    a soundtrack in the background and keeping a consistent frame rate
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个游戏同时更新成千上万的实体状态，同时在后台播放音轨并保持一致的帧率
- en: A scientific, compute-heavy program splits computation in order to take full
    advantage of all of the cores in the machine
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个科学计算密集型程序会将计算分割开来，以便充分利用机器上的所有核心
- en: A web server handles more than one request at a time in order to maximize throughput
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Web服务器一次处理多个请求以最大化吞吐量
- en: These are some really compelling examples that propel the need to model our
    program as concurrent processes. But what does concurrency really mean? In the
    next section, let's define that.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些非常有说服力的例子，推动了将我们的程序建模为并发进程的需求。但并发究竟意味着什么呢？在下一节中，我们将对其进行定义。
- en: Concurrency
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: 'The ability of a program to manage more than one thing at a time while giving
    an illusion of them happening at the same time is called concurrency, and such
    programs are called concurrent programs. Concurrency allows you to structure your
    program in a way that it performs faster if you have a problem that can be split
    into multiple sub-problems. When talking about concurrency, another term called
    parallelism is often thrown in the discussion, and it is important we know the
    differences as the usage of these terms often overlap. Parallelism is when each
    task runs simultaneously on separate CPU cores  with non-overlapping time periods.
    The following diagram illustrates the difference between concurrency and parallelism:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 程序能够同时管理多件事情并给人一种它们同时发生的错觉，这种能力被称为并发，这样的程序被称为并发程序。并发允许你以某种方式结构化你的程序，使其在可以将问题分解为多个子问题时运行得更快。当谈论并发时，另一个术语并行性经常被提及，了解这两个术语之间的区别很重要，因为这两个术语的使用往往重叠。并行性是指每个任务在非重叠的时间段内同时在不同的CPU核心上运行。以下图表说明了并发和并行之间的区别：
- en: '![](img/03050029-7f64-46ff-a375-a1e6de196796.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03050029-7f64-46ff-a375-a1e6de196796.png)'
- en: To put it another way, concurrency is about structuring your program to manage
    more than one thing at a time, while parallelism is about putting your program
    on multiple cores to increase the amount of work it does in a period of time.
    With this definition, it follows that concurrency when done right, does a better
    utilization of the CPU while parallelism might not in all cases. If your program
    runs in parallel but is only dealing with a single dedicated task, you aren't
    gaining much throughput. This is to say that we gain the best of both worlds when
    a concurrent program is made to run on multiple cores.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用另一种方式来说，并发是关于结构化你的程序以一次管理多件事情，而并行是关于将你的程序放在多个核心上以增加它在一定时间内完成的工作量。根据这个定义，可以得出结论，当并发做得正确时，可以更好地利用CPU，而并行可能在所有情况下都不一定如此。如果你的程序并行运行但只处理一个专用任务，你并不会获得很多吞吐量。这就是说，当一个并发程序被设计在多个核心上运行时，我们可以获得两者的最佳效果。
- en: Usually, the support for concurrency is already provided at the lower levels
    by the operating system, and developers mostly program against the higher level
    abstractions provided by programming languages. On top of the low level support,
    there are different approaches to concurrency.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，操作系统在较低级别已经提供了对并发的支持，开发者主要针对编程语言提供的较高层抽象进行编程。在底层支持之上，有不同并发的途径。
- en: Approaches to concurrency
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发方法
- en: We use concurrency to offload parts of our program to run independently. At
    times, these parts may depend on each other and are progressing towards a common
    goal or they may be embarrassingly parallel, which is a term used to refer to
    problems that can be split into independent stateless tasks, for instance, transforming
    each pixel of an image in parallel. As such, the approaches used to make a program
    concurrent depend on what level we are leveraging concurrency and the nature of
    the problem we are trying to solve. In the next section, let's discuss the available
    approaches to concurrency.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用并发来卸载程序的一部分以独立运行。有时，这些部分可能相互依赖，并朝着共同的目标前进，或者它们可能是令人尴尬的并行，这是一个用来指代可以分解为独立无状态任务的问题的术语，例如，并行转换图像中的每个像素。因此，使程序并发的途径取决于我们利用并发的层次以及我们试图解决的问题的性质。在下一节中，我们将讨论可用的并发方法。
- en: Kernel-based
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内核
- en: 'With multitasking being the norm these days, modern operating systems need
    to deal with more than one processes. As such, your operating system kernel already
    provides primitives for writing concurrent programs in one of the following forms:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着多任务处理成为常态，现代操作系统需要处理多个进程。因此，你的操作系统内核已经提供了编写并发程序的原始方法，以下是一种形式：
- en: '**Processes**: In this approach, we can run different parts of a program by
    spawning separate replicas of themselves. On Linux, this can be achieved using
    the `fork` system call. To communicate any data with the spawned processes, one
    can use various **Inter Process Communication** (**IPC**) facilities such as pipes
    and FIFOs. Process based concurrency provides you with features such as fault
    isolation, but also has the overhead of starting a whole new process. There''s
    a limited number of processes you can spawn before the OS runs out of memory and
    kills them. Process-based concurrency is seen in Python''s multiprocessing module.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程**: 在这种方法中，我们可以通过生成它们自己的独立副本来运行程序的不同部分。在Linux上，这可以通过使用`fork`系统调用实现。为了与生成的进程通信任何数据，可以使用各种**进程间通信（IPC**）设施，如管道和FIFOs。基于进程的并发提供了诸如故障隔离等特性，但也存在启动整个新进程的开销。在操作系统耗尽内存并杀死它们之前，可以生成的进程数量是有限的。基于进程的并发在Python的multiprocessing模块中可以看到。'
- en: '**Threads**: Processes under the hood are just threads, specifically called
    the main thread. A process can launch or spawn one or more threads. A thread is
    the smallest schedulable unit of execution. Every process starts with a main thread.
    In addition to that, it can spawn additional threads using the APIs provided by
    the OS. To allow a programmer to use threads, most languages come with threading
    APIs in their standard library. They are lightweight compared to processes. Threads
    share the same address space with the parent process. They don''t need to have
    a separate entry in the **Process Control Block (PCB)** in the kernel, which is
    updated every time we spawn a new process. But taming multiple threads within
    a process is a challenge because, unlike processes, they share the address space
    with their parent process and other child threads and, because scheduling of threads
    is decided by the OS, we cannot rely on the order the threads will execute and
    what memory they will read from or write to. These operations suddenly become
    hard to reason about when we go from a single-threaded program to a multi-threaded
    one.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程**: 内部运行的进程只是线程，具体称为主线程。一个进程可以启动或生成一个或多个线程。线程是可调度执行的最小单元。每个进程都以主线程开始。除此之外，它还可以使用操作系统提供的API生成额外的线程。为了允许程序员使用线程，大多数语言在其标准库中都提供了线程API。与进程相比，它们更轻量级。线程与父进程共享相同的地址空间。它们不需要在内核的**进程控制块（PCB**）中有一个单独的条目，每次我们生成一个新进程时，该条目都会更新。但是，在进程内部驯服多个线程是一个挑战，因为与进程不同，它们与父进程和其他子线程共享地址空间，并且由于线程的调度由操作系统决定，我们无法依赖线程执行的顺序或它们将读取或写入的内存。当我们从单线程程序过渡到多线程程序时，这些操作突然变得难以推理。'
- en: '**Note**: The implementation of threads and processes differ between operating
    systems. Under Linux, they are treated the same by the kernel, except that threads
    don''t have their own process control block entry in the kernel and they share
    the address space with their parent process and any other child threads.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**: 线程和进程的实现因操作系统而异。在Linux下，内核将它们视为相同，除了线程在内核中没有自己的进程控制块条目，并且它们与父进程和任何其他子线程共享地址空间。'
- en: User-level
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户级
- en: Process- and thread-based concurrency are limited by how many of them we can
    spawn. A lighter and more efficient alternative is to use user space threads,
    popularly known as green threads. They first appeared in Java with the code name
    *green* and the name has stuck since then. Other languages such as Go (goroutines),
    and Erlang also have green threads. The primary motivation in using green threads
    is to reduce the overhead that comes with using process- and thread-based concurrency.
    Green threads are very lightweight to spawn and use less space than a thread.
    For instance, in Go, a goroutine takes only 4 KiB of space compared to the usual
    8MB by a thread.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基于进程和线程的并发受我们能够生成多少个的限制。一个更轻量级且更高效的替代方案是使用用户空间线程，通常被称为绿色线程。它们首次出现在Java中，代号为*green*，这个名字一直沿用至今。其他语言如Go（goroutines）和Erlang也有绿色线程。使用绿色线程的主要动机是减少使用基于进程和线程的并发带来的开销。绿色线程生成和使用的开销非常小，比线程占用更少的空间。例如，在Go中，goroutine仅占用4
    KiB的空间，而线程通常占用8MB。
- en: User space threads are managed and scheduled as part of the language runtime.
    A runtime is any extra bookeeping or managing code that's executed with every
    program you run. This would be your garbage collector or the thread scheduler. Internally,
    user space threads are implemented on top of native OS threads. Rust had green
    threads before the 1.0 version, but they were later removed before the language
    hit stable release. Having green threads would have steered away Rust's guarantee
    and its principle of having no runtime costs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间线程作为语言运行时的一部分进行管理和调度。运行时是任何额外的记录或管理代码，它随着你运行的每个程序执行。这可能是你的垃圾收集器或线程调度器。内部上，用户空间线程是在原生操作系统线程之上实现的。Rust在1.0版本之前有绿色线程，但后来在语言稳定发布之前被移除。拥有绿色线程可能会偏离Rust的保证及其无运行时成本的原则。
- en: User space concurrency is more efficient, but hard to get right in its implementation.
    Thread-based concurrency, however, is a tried and tested approach and has been
    popular since multi-process operating systems came into existence and it's the
    go- to approach for concurrency. Most mainstream languages provide threading APIs
    that allows users to create threads and easily offload a portion of their code
    for independent execution.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间并发更高效，但在其实施过程中却难以做到正确。然而，基于线程的并发是一种经过验证和测试的方法，自从多进程操作系统出现以来就非常流行，并且是并发的首选方法。大多数主流语言都提供了线程API，允许用户创建线程并轻松地将代码的一部分卸载以进行独立执行。
- en: Leveraging concurrency in a program follows a multi-step process. First, we
    need to identify parts of our problem that can be run independently. Then, we
    need to look for ways to co-ordinate threads that are split into multiple sub-tasks
    to accomplish a shared goal. In the process, threads might also need to share
    data and they need synchronization for accessing or writing to shared data. With
    all of the benefits that concurrency brings with it, there are a new set of challenges
    and paradigms that developers need to care and plan for. In the next section,
    let's discuss the pitfalls of concurrency.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中利用并发遵循一个多步骤的过程。首先，我们需要确定问题中可以独立运行的部分。然后，我们需要寻找协调多个子任务的方法，这些子任务被分割以实现共同的目标。在这个过程中，线程可能还需要共享数据，并且需要同步来访问或写入共享数据。尽管并发带来了许多好处，但开发者还需要关注和计划一系列新的挑战和范式。在下一节中，我们将讨论并发的陷阱。
- en: Pitfalls
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 陷阱
- en: 'The advantages of concurrency abound, but it brings a whole lot of complexity
    and pitfalls that we have to deal with. Some issues when writing concurrent programs
    code are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 并发的优势很多，但它也带来了一大堆复杂性和陷阱，我们必须应对。编写并发程序时可能会遇到以下问题：
- en: '**Race conditions**: As threads are scheduled by the operating system, we don''t
    have a say in what order and how threads will access a shared data. A common use
    case in multi-threaded code is about updating a global state from multiple threads.
    This follows a three step process—read, modify, and write. If these three operations
    aren''t performed atomically by threads, we may end up with a race condition.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞态条件**：由于线程是由操作系统调度的，我们无法决定线程访问共享数据的顺序和方式。在多线程代码中，一个常见的用例是从多个线程更新全局状态。这遵循三个步骤——读取、修改和写入。如果这三个操作不是由线程原子性地执行，我们可能会遇到竞态条件。'
- en: A set of operations is atomic if they execute together in an indivisble manner.
    For a set of operations to be atomic, it must not be pre-empted in the middle
    of its execution. It must execute completely or not at all.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一组操作以不可分割的方式一起执行，则该组操作是原子的。为了使一组操作成为原子操作，它必须在执行过程中不被抢占。它必须完全执行或不执行。
- en: If two threads try to update a value at a memory location at the same time,
    they might end up overwriting each other's values and only one of the updates
    will ever be written to memory or the value might not get updated at all. This
    is a classic example of a race condition. Both threads are racing to update the
    value without any co-ordination with each other. This leads to other issues such
    as data races.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个线程同时尝试更新同一内存位置上的值，它们可能会覆盖彼此的值，只有其中一个更新会被写入内存，或者值可能根本不会更新。这是一个经典的竞态条件示例。这两个线程都在没有彼此协调的情况下竞争更新值。这导致其他问题，如数据竞争。
- en: '**Data race**: When multiple threads try to write data to a certain location
    in memory and when both of them write at the same time, it''s hard to predict
    what values will get written. The end result in the memory could also be garbage
    value. Data race is a consequence of a race condition, as read-modify-update operation
    must happen atomically by any thread to ensure that consistent data gets read
    or written by any thread.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据竞争**：当多个线程试图同时写入内存中某个特定位置的数据时，很难预测将写入哪些值。内存中的最终结果也可能是垃圾值。数据竞争是竞争条件的结果，因为任何线程都必须以原子方式执行读取-修改-更新操作，以确保任何线程都能读取或写入一致的数据。'
- en: '**Memory unsafety and undefined behavior**: Race conditions can also lead to
    undefined behavior. Consider the following pseudocode:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存不安全和未定义行为**：竞争条件也可能导致未定义的行为。考虑以下伪代码：'
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have two threads, A and B, that act on a linked list. `Thread A` tries to
    retrieve the head of the list. For doing this safely, it first checks the head
    of the list is not `NULL` and then returns it. `Thread B` sets the head of the
    list to a `NULL` value. Both of these run at nearly the same time and might get
    scheduled by the OS in different order. For instance, in one of the execution
    instances, the point where `Thread A` runs first and asserts that `list.head`,
    is not `NULL`. Right after that, `Thread A` is preempted by the OS and `Thread
    B` is scheduled to run. Now, `Thread B` sets `list.head` to `NULL`. Following
    that, when `Thread A` gets the chance to run, it will try to return `list.head`
    which is a `NULL` value. This would result in a segmentation fault when `list.head`
    is read from. In this case, memory unsafety happens because ordering is not maintained
    for these operations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个线程，A 和 B，它们对链表进行操作。`Thread A` 尝试检索链表的头部。为了安全地执行此操作，它首先检查链表的头部不是 `NULL`，然后返回它。`Thread
    B` 将链表的头部设置为 `NULL` 值。这两个线程几乎同时运行，并且可能被操作系统以不同的顺序调度。例如，在一个执行实例中，`Thread A` 首先运行并断言
    `list.head` 不是 `NULL`。紧接着，`Thread A` 被操作系统抢占，`Thread B` 被调度运行。现在，`Thread B` 将
    `list.head` 设置为 `NULL`。随后，当 `Thread A` 再次获得运行机会时，它将尝试返回 `list.head`，这是一个 `NULL`
    值。这将导致在读取 `list.head` 时发生段错误。在这种情况下，由于这些操作的顺序没有得到维护，发生了内存不安全。
- en: There is a common solution to the previously mentioned problems—synchronizing
    or serializing access to shared data or code or ensuring that the threads run
    critical sections atomically. This is done using synchronization primitives such
    as a mutex, semaphores, or conditional variables. But even using these primitives
    can lead to other issues such as deadlocks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前提到的问题有一个常见的解决方案——同步或序列化对共享数据或代码的访问，或者确保线程原子地运行关键部分。这是通过使用同步原语，如互斥锁、信号量或条件变量来实现的。但即使使用这些原语也可能导致其他问题，如死锁。
- en: '**Deadlocks**: Apart from race conditions, another issue that threads face
    is getting starved of resources while holding a lock on a resource. Deadlock is
    a condition where a Thread A holding a resource a and waiting for resource b.
    Another Thread B is holding a resource `b` and is waiting for resource a. The
    following diagram depicts the situation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁**：除了竞争条件之外，线程面临的另一个问题是，在持有资源锁的同时，资源被耗尽。死锁是一种情况，其中线程 A 持有资源 a 并等待资源 b。另一个线程
    B 持有资源 `b` 并等待资源 a。以下图表描述了这种情况：'
- en: '![](img/7470c731-80cc-4842-9826-0dad5073d09d.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7470c731-80cc-4842-9826-0dad5073d09d.png)'
- en: Deadlocks are hard to detect but they can be solved by taking locks in the correct
    order. In the preceding case, if both Thread A and Thread B try to take the lock
    first, we can ensure that the locks are released properly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁很难检测，但可以通过正确地获取锁来解决。在前面的例子中，如果线程 A 和线程 B 都试图首先获取锁，我们可以确保锁被正确释放。
- en: With the advantages and pitfalls explored, let's go through the APIs that Rust
    provides to write concurrent programs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了优势和陷阱之后，让我们来看看 Rust 提供的 API，用于编写并发程序。
- en: Concurrency in Rust
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 中的并发
- en: Rust's concurrency primitives rely on native OS threads. It provides threading
    APIs in the `std::thread` module in the standard library. In this section, we'll
    start with the basics on how to create threads to perform tasks concurrently.
    In subsequent sections,  we'll explore how threads can share data with each other.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的并发原语依赖于原生操作系统线程。它通过标准库中的 `std::thread` 模块提供线程 API。在本节中，我们将从如何创建线程以并发执行任务的基本知识开始。在随后的章节中，我们将探讨线程如何相互共享数据。
- en: Thread basics
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程基础
- en: 'As we said, every program starts with a main thread. To create an independent
    execution point from anywhere in the program, the main thread can spawn a new
    thread, which becomes its child thread. Child threads can further spawn their
    own threads. Let''s look at a concurrent program in Rust that uses threads in
    the simplest way possible:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，每个程序都以主线程开始。要从程序的任何地方创建一个独立的执行点，主线程可以创建一个新的线程，该线程成为其子线程。子线程可以进一步创建自己的线程。让我们看看一个使用线程的最简单方式的
    Rust 并发程序：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `main`, we call the `spawn` function from the `thread` module which takes
    a no parameter closure as an argument. Within this closure, we can write any code
    that we want to execute concurrently as a separate thread. In our closure, we
    simply print some text and return `String`. Compiling and running this program
    gives us the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，我们调用 `thread` 模块中的 `spawn` 函数，该函数接受一个无参数闭包作为参数。在这个闭包中，我们可以编写任何我们想要以单独线程执行并发代码。在我们的闭包中，我们只是打印一些文本并返回
    `String`。编译并运行这个程序，我们得到以下输出：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Strange! We only get to see `"Hello"` being printed. What happened to `println!("Thread");`
    from the child thread ? A call to `spawn` creates the thread and returns immediately
    and the thread starts executing concurrently without blocking the instructions
    after it. The child thread is created in the detached state. Before the child
    thread has any chance to run its code, the program reaches the `print!("Hello");`
    statement and exits the program when it returns from `main`. As a result, code
    within the child thread doesn''t execute at all. To allow the child thread to
    execute its code, we need to wait on the child thread. To do that, we need to
    first assign the value returned by `spawn` to a variable:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪！我们只看到了 `"Hello"` 被打印出来。子线程中的 `println!("Thread");` 发生了什么？对 `spawn` 的调用创建了线程并立即返回，线程开始并发执行，而不阻塞其后的指令。子线程处于分离状态。在子线程有机会运行其代码之前，程序到达了
    `print!("Hello");` 语句，并在从 `main` 返回时退出程序。因此，子线程中的代码根本不会执行。要允许子线程执行其代码，我们需要在子线程上等待。为此，我们需要首先将
    `spawn` 返回的值赋给一个变量：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `spawn` function returns a `JoinHandle` type, which we store in the `child` variable.
    This type is a handle to the child thread, which can be used to join a thread—in
    other words, wait for its termination. If we ignore the `JoinHandle` type of a
    thread, there is no way to wait for the thread. Continuing with our code, we call
    the `join` method on the child before exiting from `main` as in the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn` 函数返回一个 `JoinHandle` 类型，我们将其存储在 `child` 变量中。这种类型是子线程的句柄，可以用来连接线程——换句话说，等待其终止。如果我们忽略线程的
    `JoinHandle` 类型，就没有办法等待线程。继续我们的代码，我们在退出 `main` 之前在子线程上调用 `join` 方法，如下所示：'
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Calling `join` blocks the current thread and waits for the child thread to
    finish before executing any line of code following the `join` call. It returns
    a `Result` value. Since we know that this thread does not panic, we call `expect`
    to unwrap the `Result` type giving us the string. Joining the thread can fail
    if a thread is joining itself or gets deadlocked, and, in that case, it returns
    an `Err` variant with the value that was passed to the `panic!` call though, in
    this case, the returned value is of the `Any` type which must be downcasted to
    a proper type. Our updated code is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `join` 会阻塞当前线程，并在执行 `join` 调用之后的任何代码行之前等待子线程完成。它返回一个 `Result` 值。由于我们知道这个线程不会崩溃，我们调用
    `expect` 来解包 `Result` 类型，从而得到字符串。如果线程正在将自己连接或发生死锁，连接线程可能会失败，在这种情况下，它返回一个包含传递给
    `panic!` 调用的值的 `Err` 变体。然而，在这种情况下，返回的值是 `Any` 类型，必须将其向下转换为适当的类型。我们的更新代码如下：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s the output of the program:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Great ! We wrote our first concurrent *hello world* program. Let's explore other
    APIs from the `thread` module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们编写了第一个并发的 *hello world* 程序。让我们探索 `thread` 模块中的其他 API。
- en: Customizing threads
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义线程
- en: 'We also have APIs that can be used to configure threads by setting their properties
    such as the name or their stack size. For this, we have the `Builder` type from
    the `thread` module. Here''s a simple program that creates a thread and spawns
    it using the `Builder` type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有可以用来通过设置线程属性（如名称或堆栈大小）来配置线程的 API。为此，我们有 `thread` 模块中的 `Builder` 类型。以下是一个创建线程并使用
    `Builder` 类型启动它的简单程序：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we use the `Builder::new`, method followed by calling
    the `name` and `stack_size` methods to add a name to our thread and its stack
    size respectively. We then call `spawn` on `my_thread`, which consumes the builder
    instance and spawns the thread. This time, within our closure, we `panic!` with
    an `"Oops"` message. Following is the output of this program:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`Builder::new`方法，然后调用`name`和`stack_size`方法分别为我们的线程添加名称和堆栈大小。然后我们在`my_thread`上调用`spawn`，这会消耗构建器实例并创建线程。这次，在我们的闭包中，我们使用`panic!`并传递一个`"Oops"`消息。以下是程序的输出：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We get to see that the thread has the same name we gave it - `"Worker Thread"`.
    Also, notice the `"Child status"` message that's returned as an `Any` type. Values
    returned from panic call in a thread are returned as an `Any` type and must be
    downcasted to a specific type. That's all on the basics of spawning threads.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到线程具有我们给它起的相同名称——“Worker Thread”。注意返回的`"Child status"`消息是一个`Any`类型。线程中panic调用返回的值是`Any`类型，必须向下转换为特定类型。这就是关于创建线程的基础。
- en: But the threads we spawned in the preceding code examples aren't doing much.
    We use concurrency to solve problems that can be split into multiple sub-tasks.
    In simple cases, these sub-tasks are independent of each other such as applying
    a filter to each pixel of an image in parallel. In other situations, the sub-tasks
    running in threads might want want to co-ordinate on some shared data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但前面代码示例中创建的线程并没有做什么。我们使用并发来解决可以分解为多个子任务的问题。在简单的情况下，这些子任务彼此独立，例如并行地对图像的每个像素应用过滤器。在其他情况下，线程中运行的子任务可能需要协调一些共享数据。
- en: They might also be contributing to a computation whose end result depends on
    the individual results from the threads, for instance, downloading a file from
    multiple threads in blocks and communicating it to a parent manager thread. Other
    problems might be dependent on a shared state such as an HTTP client sending a
    `POST` request to a server that has to update the database. Here, the database
    is the shared state common to all threads. These are some of the most common use
    cases of concurrency and it's important that threads are able to share or communicate
    data back and forth between each other and with their parent thread.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可能在计算中做出贡献，其最终结果取决于线程的个别结果，例如，从多个线程中分块下载文件并将其传递给父管理线程。其他问题可能依赖于共享状态，例如HTTP客户端向需要更新数据库的服务器发送`POST`请求。在这里，数据库是所有线程共有的共享状态。这些都是并发的一些最常见用例，并且线程能够相互之间以及与父线程之间共享或传递数据是非常重要的。
- en: Let's step up the game a bit and look at how we can access existing data from
    parent threads within child threads.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提高一下难度，看看我们如何在子线程中访问父线程中的现有数据。
- en: Accessing data from threads
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从线程中访问数据
- en: 'A thread that doesn''t communicate or access data from the parent thread is
    not much. Let''s take a very common pattern of using multiple threads to concurrently
    access items in a list to perform some computation. Consider the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不与父线程通信或访问父线程数据的线程并没有什么作用。让我们以一个非常常见的模式为例，使用多个线程并发访问列表中的项目以执行一些计算。考虑以下代码：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we have `5` numbers in `values` and we spawn `5` threads
    where each one of them accesses the data in `values`. Let''s compile this program:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`values`中有`5`个数字，并创建了`5`个线程，其中每个线程都访问`values`中的数据。让我们编译这个程序：
- en: '![](img/ac1bd9b6-7a3d-4362-b894-7349fc9ea2fb.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac1bd9b6-7a3d-4362-b894-7349fc9ea2fb.png)'
- en: Interesting ! The error makes sense if you think about it from a borrowing perspective.
    `nums` comes from the main thread. When we spawn a thread, it is not guaranteed
    to exit before the parent thread and may outlive it. When the parent thread returns,
    the `nums` variable is gone and `Vec` it's pointing to is freed. If the preceding
    code was allowed by Rust, the child thread could have accessed `nums` which might
    have some garbage value after `main` returns and it would have undergone a segmentation
    fault.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣！如果你从借用角度考虑，这个错误是有意义的。`nums`来自主线程。当我们创建一个线程时，它不一定在父线程之前退出，甚至可能比它存活得更久。当父线程返回时，`nums`变量消失了，它指向的`Vec`也被释放了。如果Rust允许前面的代码，子线程可以访问`nums`，它可能在`main`返回后具有一些垃圾值，并且它将经历段错误。
- en: If you look at the help message from from the compiler, it suggests us to move
    or capture `nums` inside the closure. This way the referenced a `nums` variable
    from `main` is moved inside `closure` and it won't be available in the `main`
    thread.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看编译器的帮助信息，它会建议我们在闭包内部移动或捕获`nums`。这样，从`main`中引用的`nums`变量就被移动到`closure`内部，它将不会在`main`线程中可用。
- en: 'Here''s the code that uses the `move` keyword to move the value from the parent
    thread in its child thread:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`move`关键字将值从父线程移动到其子线程的代码：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we are trying to accessed `my_str` again. This fails
    with the following error:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们试图再次访问`my_str`。这会失败，并出现以下错误：
- en: '![](img/247021c7-5046-4d3c-87b5-c143f34aa150.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/247021c7-5046-4d3c-87b5-c143f34aa150.png)'
- en: As you can see from the preceding error message, with `move`, you don't get
    to use the data again, even if we are only reading `my_str` from our child thread.
    Here too, we are saved by the compiler. If the child thread frees the data and
    we access `my_str` from `main`, we'll access a freed value which is a use after
    free issue.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述错误信息所示，使用`move`后，你无法再次使用数据，即使我们只是在子线程中读取`my_str`。在这里，我们同样被编译器所拯救。如果子线程释放了数据，而我们从`main`中访问`my_str`，我们将访问一个已释放的值，这是一个使用后释放的问题。
- en: As you saw, the same rules of ownership and borrowing work in multi-threaded
    contexts too. This is one of the novel aspects of its design that doesn't require
    additional constructs to enforce correct concurrent code. But, how do we achieve
    the preceding use case of accessing data from threads? Because threads are more
    likely to outlive their parent, we can't have references in threads. Instead,
    Rust provides us with synchronization primitives that allow us to safely share
    and communicate data between threads. Let's explore these primitives. These types
    are usually composed in layers depending on the needs and you only pay for what
    you use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在多线程环境中，所有权和借用规则同样适用。这是其设计中一个新颖的方面，它不需要额外的结构来强制执行正确的并发代码。但是，我们如何实现从线程访问数据的先前的用例呢？因为线程更有可能比它们的父线程存活时间更长，所以我们不能在线程中有引用。相反，Rust为我们提供了同步原语，允许我们在线程之间安全地共享和通信数据。让我们来探索这些原语。这些类型通常根据需求分层组合，你只需为所使用的部分付费。
- en: Concurrency models with threads
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于线程的并发模型
- en: We mainly use threads to perform a task that can be split into sub-problems,
    where the threads might need to communicate or share data with each other. Now,
    using the threading model as the baseline, there are different ways to structure
    our program and control access to shared data. A concurrency model specifies how
    multiple threads interact with instructions and data shared between them and how
    they make progress over time and space (here, memory).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要使用线程来执行可以分解为子问题的任务，其中线程可能需要相互通信或共享数据。现在，以线程模型为基础，有不同方式来构建我们的程序和控制对共享数据的访问。并发模型指定了多个线程如何相互作用以及它们如何随时间和空间（在这里是内存）的推移进行进展。
- en: Rust does not prefer any opinionated concurrency model and frees the developer
    in using their own models depending on the problem they are trying to solve through
    third party crates. So, other models of concurrency exist that includes the actor
    model implemented as a library in the `actix` crate. There are other models too,
    such as the work stealing concurrency model implemented by the `rayon` crate.
    Then, there is the `crossbeam` crate, which allows concurrent threads to share
    data from their parent stack frame and are guaranteed to return before the parent
    stack is deallocated.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Rust不偏好任何有偏见的并发模型，并让开发者根据他们试图通过第三方crate解决的问题使用自己的模型。因此，存在其他并发模型，包括在`actix`crate中实现的actor模型。还有其他模型，例如由`rayon`crate实现的work
    stealing并发模型。然后，还有`crossbeam`crate，它允许并发线程从它们的父堆栈帧共享数据，并保证在父堆栈释放之前返回。
- en: 'There are two popular built-in concurrency models with which Rust provides
    us: sharing data with synchronization and sharing data by message passing.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Rust提供了两种流行的内置并发模型：通过同步共享数据和通过消息传递共享数据。
- en: Shared state model
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享状态模型
- en: Using shared state to communicate values to a thread is the most widely used
    approach, and the synchronization primitives to achieve this exist in most mainstream
    languages. Synchronization primitives are types or language constructs that allow
    multiple threads to access or manipulate a value in a thread-safe way. Rust also
    has many synchronization primitives that we can wrap around types to make them
    thread-safe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用共享状态将值传递给线程是最常用的方法，而实现这一点的同步原语存在于大多数主流语言中。同步原语是允许多个线程以线程安全的方式访问或操作一个值的类型或语言构造。Rust也有许多同步原语，我们可以将它们包装在类型周围以使它们线程安全。
- en: 'As we saw in the previous section, we cannot have shared access to any value
    from multiple threads. We need shared ownership here. Back in [Chapter 5](db2c2723-8ca0-43be-b135-afd847342146.xhtml),
    *Memory Management and Safety*, we introduced the `Rc` type. that can provide
    shared ownership of values. Let''s try using this type with our previous example
    of reading data from multiple threads:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，我们不能从多个线程共享访问任何值。这里我们需要共享所有权。在[第五章](db2c2723-8ca0-43be-b135-afd847342146.xhtml)中，我们在*内存管理和安全性*部分介绍了`Rc`类型，它可以提供值的共享所有权。让我们尝试使用这个类型与我们的从多个线程读取数据的先前示例一起使用：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This fails with the following error:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下错误：
- en: '![](img/c89bb9a2-3bb7-4903-8e87-f93e0db940b2.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c89bb9a2-3bb7-4903-8e87-f93e0db940b2.png)'
- en: Rust saves us here too. This is because an `Rc` type is not thread-safe as mentioned
    previously, as the reference count update operation is not atomic. We can only
    use `Rc` in single-threaded code. If we want to have the same kind of shared ownership
    across multi-threaded contexts, we can use the `Arc` type, which is just like
    `Rc`, but has atomic reference counting capability.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Rust在这里也帮了我们。这是因为，正如之前提到的，`Rc`类型不是线程安全的，因为引用计数更新操作不是原子的。我们只能在单线程代码中使用`Rc`。如果我们想在多线程环境中拥有相同类型的共享所有权，我们可以使用`Arc`类型，它就像`Rc`一样，但具有原子引用计数能力。
- en: Shared ownership with Arc
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Arc的共享所有权
- en: 'The preceding code can be made to work with the multi-threaded `Arc` type as
    follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以通过以下方式与多线程的`Arc`类型一起工作：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we simply replaced the wrapper of the vector from `Rc`
    to the `Arc` type. Another change is that, before we reference `nums` from a child
    thread, we need to clone it with `Arc::clone()`, which gives us an owned `Arc<Vec<i32>>`
    value that refers to the same `Vec`. With that change, our program compiles and
    provides safe access to the shared `Vec`, with the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们只是将向量的包装器从`Rc`替换为`Arc`类型。另一个变化是，在我们从子线程引用`nums`之前，我们需要使用`Arc::clone()`对其进行克隆，这给我们一个拥有`Arc<Vec<i32>>`值的所有权，它指向相同的`Vec`。有了这个变化，我们的程序可以编译并提供对共享`Vec`的安全访问，以下为输出结果：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, another use case in multi-threaded code is to mutate a shared value from
    multiple threads. Let's see how to do that next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在多线程代码中，另一个用例是从多个线程中修改共享值。让我们看看如何做到这一点。
- en: Mutating shared data from threads
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从线程中修改共享数据
- en: 'We''ll take a look at a sample program where five threads push data to a shared
    `Vec`. The following program tries to do the same:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个示例程序，其中五个线程将数据推送到共享的`Vec`。以下程序尝试做同样的事情：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have the same `nums` wrapped with `Arc`. But we cannot mutate it, as the
    compiler gives the following error:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有相同的`nums`被`Arc`包装。但我们不能修改它，因为编译器给出了以下错误：
- en: '![](img/c617b0b5-c313-45fd-849a-e5d38347357b.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c617b0b5-c313-45fd-849a-e5d38347357b.png)'
- en: This doesn't work as cloning `Arc` hands out immutable reference to the inner
    value. To mutate data from multiple threads, we need to use a type that provides
    shared mutability just like `RefCell`. But similar to `Rc`, `RefCell` cannot be
    used across multiple threads. Instead, we need to use their thread-safe variants
    such as the `Mutex` or `RwLock` wrapper types. Let's explore them next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这不起作用，因为克隆`Arc`会提供对内部值的不可变引用。要从多个线程中修改数据，我们需要使用提供共享可变性的类型，就像`RefCell`一样。但与`Rc`类似，`RefCell`不能在多个线程中使用。相反，我们需要使用它们的线程安全变体，如`Mutex`或`RwLock`包装类型。让我们接下来探索它们。
- en: Mutex
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mutex
- en: When safe mutable access to a shared resource is required, the access can be
    provided by the use of mutex. Mutex is a portmanteau for mutual exclusion, a widely
    used synchronization primitive for ensuring that a piece of code is executed by
    only one thread at a time. A `mutex` in general is a guard object which a thread
    acquires to protect data that is meant to be shared or modified by multiple threads. It
    works by prohibiting access to a value from more than one thread at a time by
    locking the value. If one of the  threads has a lock on the `mutex` type, no other
    thread can run the same code until the thread that holds the lock is done with
    it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要安全地访问共享资源时，可以使用互斥锁（mutex）来提供访问。互斥锁（Mutex）是“互斥”的缩写，是一种广泛使用的同步原语，用于确保代码一次只由一个线程执行。一般来说，`mutex`
    是一个保护对象，线程通过获取它来保护那些打算由多个线程共享或修改的数据。它通过锁定值来禁止一次从多个线程访问一个值。如果一个线程已经对 `mutex` 类型有了锁，那么其他线程将无法运行相同的代码，直到持有锁的线程完成操作。
- en: The `std::sync` module from the standard library contains the `Mutex` type allowing
    one to mutate data from threads in thread-safe manner.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的 `std::sync` 模块包含 `Mutex` 类型，允许以线程安全的方式从线程中修改数据。
- en: 'The following code example shows how to use the `Mutex` type from a single
    child thread:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何从单个子线程中使用 `Mutex` 类型：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Running this works as expected. But, this won't work when multiple threads try
    to access the value as `Mutex` doesn't provide shared mutability. To allow a value
    inside a `Mutex` to be mutated from multiple threads, we need to compose it it
    the `Arc` type. Let's see how to do that next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码按预期工作。但是，当多个线程尝试以 `Mutex` 访问值时，这不会工作，因为 `Mutex` 不提供共享可变。要允许从多个线程中修改 `Mutex`
    内部的值，我们需要将其组合到 `Arc` 类型中。让我们看看如何做到这一点。
- en: Shared mutability with Arc and Mutex
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Arc 和 Mutex 共享可变
- en: 'Having explored the basics of Mutex in single threaded contexts, we''ll revisit
    the example from the previous section. The following code modifies a value using
    a `Mutex` wrapped in an `Arc` from the multiple threads:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了单线程上下文中 `Mutex` 的基础知识后，我们将重新审视上一节中的示例。以下代码使用 `Arc` 包装的 `Mutex` 从多个线程修改一个值：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we created a `Mutex` value in `m`. We then spawn a thread.
    The output on your machine may vary.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在 `m` 中创建了一个 `Mutex` 值。然后我们启动一个线程。你的机器上的输出可能会有所不同。
- en: 'Calling `lock` on a mutex will block other threads from calling `lock` until
    the lock is gone. As such, it is important that we structure our code in such
    a way that the is granular. Compiling and running this gives the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在互斥锁上调用 `lock` 将阻塞其他线程调用 `lock`，直到锁释放。因此，我们很重要的一点是要以细粒度的方式组织我们的代码。编译和运行此代码将给出以下输出：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is another similar alternative to `Mutex`, which is the `RwLock` type
    that is more aware on the kind of lock you have on your type, and can be more
    performant when reads are more often than writes. Let's explore it next.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutex` 还有一个类似的替代品，即 `RwLock` 类型，它对锁的类型有更多的了解，并且在读取比写入更频繁时可以提供更好的性能。让我们接下来探索它。'
- en: RwLock
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RwLock
- en: While Mutex is fine for most use cases, for some multi-threaded scenarios, reads
    happen more often than writes from multiple threads. In that case, we can use
    the RwLock type, which also provides shared mutability but can do so at a more
    granular level. RwLock stands for Reader-Writer lock. With `RwLock`, we can have
    many readers at the same but only one writer in a given scope. This is much better
    than a Mutex which agnostic of the kind of access a thread wants. Using RwLock
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Mutex` 对于大多数用例来说都很好，但对于一些多线程场景，读取操作比写入操作更频繁。在这种情况下，我们可以使用 `RwLock` 类型，它也提供了共享可变，但可以在更细粒度的层面上做到这一点。`RwLock`
    代表读者-写入者锁。使用 `RwLock`，我们可以同时有多个读者，但在给定的作用域内只有一个写入者。这比 `Mutex` 更好，因为 `Mutex` 对线程想要访问的类型一无所知。使用
    RwLock
- en: 'RwLock exposes two methods:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: RwLock公开了两种方法：
- en: '`read`: Gives read access to the thread. There can be many read invocations.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`：为线程提供读取访问。可以有多个读取调用。'
- en: '`write`: Gives exclusive access to thread for writing data to the wrapped type.
    There can be one write access from an `RwLock` instance to a thread.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`：为线程提供对包装类型的写入数据的独占访问。`RwLock` 实例可以有一个写入访问。'
- en: 'Here''s a sample program that demonstrates using the `RwLock` instead of `Mutex`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例程序，演示了使用 `RwLock` 而不是 `Mutex`：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But `RwLock` on some systems such as Linux, suffers from the writer starvation
    problem. It's a situation when readers continually access the shared resource,
    and writer threads never get the chance to access the shared resource.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些系统（如Linux）上的`RwLock`存在写者饥饿问题。这是一种当读者持续访问共享资源时，写线程从未有机会访问共享资源的情况。
- en: Communicating through message passing
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过消息传递进行通信
- en: Threads can also communicate with each other through a more high level abstraction
    called message passing. This model of thread communication removes the need to
    use explicit locks by the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 线程还可以通过一个更高级的抽象，称为消息传递，相互通信。这种线程通信模型消除了用户使用显式锁的需求。
- en: 'The standard library''s `std::sync::mpsc` module provides a lock-free multi-producer,
    single-subscriber queue, which serves as a shared message queue for threads wanting
    to communicate with one another. The `mpsc` module standard library has two kinds
    of channels:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的`std::sync::mpsc`模块提供了一个无锁的多生产者、单订阅者队列，它作为想要相互通信的线程的共享消息队列。`mpsc`模块标准库有两种类型的通道：
- en: '`channel`: This is an asynchronous, infinite buffer channel.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：这是一个异步、无限缓冲区通道。'
- en: '`sync_channel`: This is a synchronous, bounded buffer channel.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync_channel`：这是一个同步、有界缓冲区通道。'
- en: Channels can be used to send data from one thread to another. Let's look at
    asynchronous channels first.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以用来将数据从一个线程发送到另一个线程。让我们首先看看异步通道。
- en: Asynchronous channels
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步通道
- en: 'Here is an example of a simple producer-consumer system, where the main thread
    produces the values `0, 1, ..., 9` and the spawned thread prints them:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的生产者-消费者系统的例子，其中主线程产生值`0, 1, ..., 9`，而派生的线程打印它们：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We first call the `channel` method. This returns two values, `tx` and `rx`.
    `tx` is the transmitter end, having type `Sender<T>` and `rx` is the receiver
    end having type `Receiver<T>`. Their names are just a convention and you can name
    them anything. Most often, you will see code bases use these names as they are
    concise to write.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用`channel`方法。这个方法返回两个值，`tx`和`rx`。`tx`是发送端，类型为`Sender<T>`，而`rx`是接收端，类型为`Receiver<T>`。它们的名称只是一个约定，你可以将它们命名为任何东西。通常，你会在代码库中看到这些名称，因为它们简洁易写。
- en: 'Next, we spawn a thread that will receive values from the `rx` side:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们派生一个线程，它将从`rx`端接收值：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use a `while let` loop. This loop will receive `Err` when `tx` is dropped.
    The drop happens when `main` returns.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`while let`循环。当`tx`被丢弃时，这个循环将接收到`Err`。丢弃发生在`main`返回时。
- en: In the preceding code, first, to create the `mpsc` queue, we call the `channel`
    function, which returns to us `Sender<T>` and `Receiver<T>`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，为了创建`mpsc`队列，我们调用`channel`函数，它返回给我们`Sender<T>`和`Receiver<T>`。
- en: '`Sender<T>` is a `Clone` type, which means it can be handed off to many threads,
    allowing them to send messages into the shared queue.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sender<T>`是一个`Clone`类型，这意味着它可以被传递给多个线程，允许它们将消息发送到共享队列。'
- en: 'The **multi producer, single consumer** (**mpsc**) approach provides multiple
    writers but only a single reader. Both of these functions return a pair of generic
    types: a sender and a receiver. The sender can be used to push new things into
    the channel, while receivers can be used to get things from the channel. The sender
    implements the `Clone` trait while the receiver does not.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**多生产者，单消费者**（**mpsc**）方法提供了多个写者但只有一个读者。这两个功能都返回一对通用类型：发送者和接收者。发送者可以用来将新事物推入通道，而接收者可以用来从通道中获取事物。发送者实现了`Clone`特质，而接收者则没有。'
- en: 'With the default asynchronous channels, the `send` method never blocks. This
    is because the channel buffer is infinite, so there''s always space for more.
    Of course, it''s not really infinite, just conceptually so: your system may run
    out of memory if you send gigabytes to the channel without receiving anything.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的异步通道中，`send`方法永远不会阻塞。这是因为通道缓冲区是无限的，所以总有空间。当然，它并不是真正无限的，只是概念上如此：如果你向通道发送了几十亿字节而没有接收任何东西，你的系统可能会耗尽内存。
- en: Synchronous channels
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步通道
- en: 'Synchronous channels have a bounded buffer and, when it''s full, the `send`
    method blocks until there''s more space in the channel. The usage is otherwise
    quite similar to asynchronous channels:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同步通道有一个有界缓冲区，当它满时，`send`方法会阻塞，直到通道中有更多空间。其用法与异步通道非常相似：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The synchronous channel size is `1`, which means that we can't have more than
    one item in the channel. Any send call after the first send will block in such
    a case. However, in the preceding code, we don't get blocks (at least, the long
    ones) as the two sending threads work in the background and the main thread gets
    to receive it without being blocked on the `send` call. For both these channel
    types, the `recv` call returns an `Err` value if the channel is empty.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同步通道的大小是 `1`，这意味着通道中不能有超过一个的项目。在这种情况下，任何在第一个发送之后的发送调用都会阻塞。然而，在前面的代码中，我们没有遇到阻塞（至少，是长阻塞），因为两个发送线程在后台工作，主线程可以接收它而不会在
    `send` 调用上阻塞。对于这两种通道类型，如果通道为空，`recv` 调用将返回一个 `Err` 值。
- en: thread-safety in Rust
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 中的线程安全
- en: In the previous section, we saw how the compiler stops us from sharing the data.
    If a child thread accesses data mutably, it is moved because Rust won't allow
    it to be used in the parent thread as the child thread might deallocate it, leading
    to a dangling pointer dereference in the main thread. Let's explore the idea of
    thread-safety and how Rust's type systems achieves that.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了编译器如何阻止我们共享数据。如果一个子线程以可变方式访问数据，它会被移动，因为 Rust 不允许它在父线程中使用，因为子线程可能会释放它，导致主线程中出现悬垂指针解引用。让我们来探讨线程安全的理念以及
    Rust 的类型系统是如何实现这一点的。
- en: What is thread-safety?
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是线程安全？
- en: thread-safety is the property of a type or a piece of code that, when executed
    or accessed by multiple threads, does not lead to unexpected behavior. It refers
    to the idea that data is consistent for reads while being safe from corruption
    when multiple threads write to it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全是类型或代码片段的一个属性，当由多个线程执行或访问时，不会导致意外行为。它指的是数据在读取时保持一致性，而在多个线程写入时保持安全。
- en: Rust only protects you from data races. It doesn't aim to protect against deadlocks
    as they are difficult to detect. It instead offloads this to third-party crates
    such as the `parking_lot` crate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 只能保护你免受数据竞争的影响。它不旨在防止死锁，因为死锁很难检测。相反，它将这项工作委托给第三方 crate，如 `parking_lot`
    crate。
- en: 'Rust has a novel approach to protecting against data races. Most of the thread-safety
    bits are already embedded in the `spawn` method''s type signature. Let''s look
    at its type signature:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有一种新颖的方法来防止数据竞争。大多数线程安全的部分已经嵌入到 `spawn` 方法的类型签名中。让我们看看它的类型签名：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's a scary-looking type signature. Let's make it less scary by explaining
    what each of the parts mean.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个看起来很吓人的类型签名。让我们通过解释每个部分的意义来让它不那么吓人。
- en: '`spawn` is a generic function over `F` and `T` and takes a parameter, `f`,
    and returns a generic type called `JoinHandle<T>`. Following that, the `where`
    clause specifies multiple trait bounds:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn` 是一个泛型函数，它对 `F` 和 `T` 进行泛型化，并接受一个参数 `f`，返回一个名为 `JoinHandle<T>` 的泛型类型。随后，`where`
    子句指定了多个特性约束：'
- en: '`F: FnOnce() -> T`: This says that `F` implements a closure that can be called
    only once. In other words, `f` is a closure that takes everything by value and
    moves items referenced from the environment.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F: FnOnce() -> T`：这意味着 `F` 实现了一个只能调用一次的闭包。换句话说，`f` 是一个闭包，它以值的方式接受所有内容，并将环境中的引用项移动。'
- en: '`F: Send + ''static`: This means that the closure must be `Send` and must have
    the `''static` lifetime, implying that any type referenced from within the closure
    in its environment must also be Send and must live for the entire duration of
    the program.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F: Send + ''static`：这意味着闭包必须是 `Send`，并且必须具有 `''static` 生命周期，这意味着闭包环境中引用的任何类型也必须是
    `Send`，并且必须在整个程序运行期间存在。'
- en: '`T: Send + ''static`: The return type, `T`, from the closure must also implement
    the `Send + ''static` trait.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T: Send + ''static`：闭包的返回类型 `T` 也必须实现 `Send + ''static` 特性。'
- en: As we know, `Send` is a marker trait. It is just used as a type-level marker
    that implies that the value is safe to be sent across threads; most types are
    Send. Types that don't implement `Send` are pointers, references, and so on. In
    addition, `Send` is an auto trait or an automatically derived trait whenever applicable.
    Compound data types such as a struct implement `Send` if all of the fields in
    a struct are `Send`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，`Send` 是一个标记特性。它仅仅用作类型级别的标记，表示该值可以安全地在线程间传递；大多数类型都是 `Send`。没有实现 `Send`
    的类型包括指针、引用等。此外，`Send` 是一个自动特性或自动推导的特性，只要适用。复合数据类型，如结构体，如果其所有字段都是 `Send`，则实现 `Send`。
- en: Traits for thread-safety
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程安全特性
- en: Thread-safety is the idea that, if you have data that you want to data from
    multiple threads, any read or write operation on that value does not lead to inconsistent
    results. The problem with updating a value, even with a simple increment operation
    such as `a += 1` is that it roughly translates in to a three-step process—`load`
    `increment` `store`. Data that can be safely updated is meant to be wrapped in
    thread-safe types such as `Arc` and `Mutex` to ensure that we have data consistency
    in a program.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全是这样一个想法，即如果你有想要从多个线程中读取的数据，对该值的任何读取或写入操作都不会导致不一致的结果。更新一个值的问题，即使是像 `a +=
    1` 这样的简单增加操作，它大致上可以转化为三个步骤——`load` `increment` `store`。可以安全更新的数据意味着应该被封装在线程安全类型，如
    `Arc` 和 `Mutex` 中，以确保程序中的数据一致性。
- en: In Rust, you get compile-time guarantees on types that can be safely used and
    referenced within a thread. These guarantees are implemented as traits, which
    are the `Send` and `Sync` trait.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，你可以通过类型签名在编译时确保可以安全地在线程中使用和引用的类型。这些保证是通过特性实现的，即 `Send` 和 `Sync` 特性。
- en: Send
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Send
- en: A Send type is safe to send to multiple threads. This implies that the type
    is a `move` type. Types that aren't Send are pointer types such as `&T`, unless
    `T` is `Sync`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send` 类型可以安全地发送到多个线程。这暗示了该类型是一个 `move` 类型。不是 `Send` 的类型是指针类型，例如 `&T`，除非 `T`
    是 `Sync`。'
- en: 'The `Send` trait has the following type signature in the standard library''s
    `std::marker` module:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send` 特性在标准库的 `std::marker` 模块中有以下类型签名：'
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are three important things to notice in its definition: first, it''s
    a marker trait without any body or item. Second, it''s prefixed with the `auto`
    keyword as it is implemented implicitly for most types when appropriate. Thirdly,
    it''s an unsafe trait because Rust wants to make the developer sure that they
    opt in explicitly and ensure that their type has thread-safe synchronization built
    in.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在其定义中有三个重要的事项需要注意：首先，它是一个标记特性，没有主体或项目。其次，它以 `auto` 关键字为前缀，因为它在大多数适当的情况下是隐式实现的。第三，它是一个不安全的特性，因为
    Rust 想确保开发者明确选择并确保他们的类型内置了线程安全的同步。
- en: Sync
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sync
- en: 'The `Sync` trait has a similar type signature:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sync` 特性具有类似的方法签名：'
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This trait signifies that types that implement this trait are safe to be shared
    between threads. If something is `Sync` then a reference to it in other words,
    `&T` is `Send`. This means that we can pass references to it to many threads.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性表示实现了这个特性的类型可以在线程之间安全共享。如果某物是 `Sync`，那么它的引用，换句话说，`&T` 是 `Send`。这意味着我们可以将它传递给多个线程。
- en: Concurrency using the actor model
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用演员模型进行并发
- en: Another model of concurrency that is quite similar to the message passing model
    is the actor model. The actor model became popular with Erlang, a functional programming
    language popular in the telecom industry, known for its robustness and distributed
    by default nature.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与消息传递模型相当相似的并发模型是演员模型。演员模型随着电信行业流行的函数式编程语言 Erlang 的流行而变得流行，Erlang 以其健壮性和默认的分布式特性而闻名。
- en: 'The actor model is a conceptual model that implements concurrency at the type
    level using entities called actors. It was first introduced by Carl Eddie Hewitt
    in 1973\. It removes the need for locks and synchronization and provides a cleaner
    way to introduce concurrency in a system. The actor model consists of three things:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 演员模型是一个概念模型，它使用称为演员的实体在类型级别实现并发。它最初由卡尔·爱迪·休伊特在 1973 年提出。它消除了对锁和同步的需求，并为系统中的并发引入提供了一种更干净的方式。演员模型由三件事组成：
- en: '**Actor:** This is a core primitive in the actor model. Each actor consists
    of its address, using which we can send messages to an actor''s and mailbox, which
    is just a queue to store the messages it has received. The queue is generally
    a **First In, First Out** (**FIFO**) queue. The address of an actor is needed
    so that other actors can send messages to it. The supervisor actor can create
    child actors that can create other child actors.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演员**：这是演员模型中的一个核心原语。每个演员由其地址组成，我们可以通过这个地址向演员的邮箱发送消息，邮箱只是一个存储已接收消息的队列。队列通常是
    **先进先出**（**FIFO**）队列。演员的地址是必要的，这样其他演员才能向它发送消息。监督演员可以创建子演员，这些子演员可以创建其他子演员。'
- en: '**Messages:** Actors communicate only via messages. They are processed asynchronously
    by actors. The `actix-web` framework provides a nice wrapper for synchronous operations
    in an asynchronous wrapper.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：演员只通过消息进行通信。它们由演员异步处理。`actix-web` 框架提供了一个用于异步包装中同步操作的优雅包装器。'
- en: In Rust, we have the `actix` crate that implements the actor model. The `actix`
    crate, uses the tokio and futures crate which we'll cover in [Chapter 12](33562886-4278-4ab1-aa0d-de533af4bb99.xhtml),
    *Network Programming in Rust*. The core objects to that crate is the Arbiter type
    which is simply a thread which spawns an event loop underneath and provides a
    handle to the event loop as an `Addr` type. Once created, we can use this handle
    to send messages to the actor.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们有实现actor模型的`actix`crate。`actix`crate使用了tokio和futures crate，我们将在[第12章](33562886-4278-4ab1-aa0d-de533af4bb99.xhtml)中介绍，即《Rust网络编程》。该crate的核心对象是Arbiter类型，它简单地说是一个在下面spawn一个事件循环的线程，并提供一个作为`Addr`类型的事件循环句柄。一旦创建，我们可以使用这个句柄向actor发送消息。
- en: In `actix`, creation of actor follows a simple step of creating a type, defining
    a message and implementing the handler for the message for the actor type. Once
    that is done, we can create the actor and spawn them into one of the created arbiters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`actix`中，创建actor遵循一个简单的步骤：创建一个类型，定义一个消息，并为actor类型实现消息的处理程序。一旦完成这些，我们就可以创建actor并将它们spawn到创建的仲裁者之一中。
- en: Each actor runs within an arbiter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个actor都在一个仲裁者中运行。
- en: When we create an actor, they don't execute right away. It's when we put these
    actors into arbiter threads, they then start executing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建actor时，它们不会立即执行。只有当我们将这些actor放入仲裁者线程中时，它们才开始执行。
- en: 'To keep the code example simple and to show how to setup actors and run them
    in actix, we''ll create a actor that can add two numbers. Let''s create a new
    project by running `cargo new actor_demo` with the following dependencies in `Cargo.toml`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码示例简单，并展示如何在actix中设置actor并运行它们，我们将创建一个可以相加两个数字的actor。让我们通过运行`cargo new actor_demo`来创建一个新的项目，并在`Cargo.toml`中包含以下依赖项：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our `main.rs` contains the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main.rs`包含以下代码：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we have created an actor named `Adder`. This actor can
    send and receive messages of type `Add`. This is a tuple struct that encapsulates
    two numbers to be added. To allow `Adder` to receive and process `Add` messages,
    we implement the `Handler` trait for `Adder` parameterized over the `Add` message
    type. In the `Handler` implementation, we print the computation being performed
    and return the sum of the given numbers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为`Adder`的actor。这个actor可以发送和接收类型为`Add`的消息。这是一个封装了要相加的两个数字的元组结构体。为了允许`Adder`接收和处理`Add`消息，我们为`Adder`参数化`Add`消息类型实现了`Handler`特质。在`Handler`实现中，我们打印出正在执行的计算，并返回给定数字的和。
- en: Following that, in `main`, we first create a `System` actor by calling its `run`
    method which takes in a closure. Within the closure, we start a `SyncArbiter`
    with `3` threads by calling its `start` method. This create 3 actors ready to
    receive messages. It returns a `Addr` type which is a handle to the event loop
    to which we can send messages to the `Adder` actor instance. We then send 5 messages
    to our arbiter address `addr`. As the System::run is an parent event loop that
    runs forever, we spawn a future to stop the System actor after a delay of 1 second.
    We can ignore the details of this part of the code as it is simply to shutdown
    the System actor in an asynchronous way.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，在`main`中，我们首先通过调用其`run`方法创建一个`System`actor，该方法接受一个闭包。在闭包内部，我们通过调用其`start`方法启动一个带有`3`个线程的`SyncArbiter`。这创建了3个准备接收消息的actor。它返回一个`Addr`类型，这是一个事件循环的句柄，我们可以向`Adder`actor实例发送消息。然后我们向我们的仲裁者地址`addr`发送5条消息。由于System::run是一个无限运行的父事件循环，我们在1秒的延迟后spawn一个future来停止System
    actor。我们可以忽略这部分代码的细节，因为它只是以异步方式关闭System actor。
- en: 'With that said, let''s take this program for a spin:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们运行这个程序：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similar to the `actix` crate, there are other crates in the Rust ecosystem that
    implements various concurrency models suitable for different use cases.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与`actix`crate类似，Rust生态系统中有其他crate实现了适用于不同用例的各种并发模型。
- en: Other crates
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他crate
- en: Apart from `actix`, we have a crate named `rayon` which is a work stealing based
    data parallelism library that makes it dead simple to write concurrent code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`actix`之外，我们还有一个名为`rayon`的crate，它是一个基于工作窃取的数据并行库，使得编写并发代码变得非常简单。
- en: Another notable crate to mention is the `crossbeam` crate which allows one to
    write multi-threaded code that can access data from its parent stack frame and
    are guaranteed to terminate before the parent stack frame goes away.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的crate是`crossbeam`，它允许编写可以访问其父堆栈帧数据的并发代码，并保证在父堆栈帧消失之前终止。
- en: '`parking_lot` is another crate that provides a faster alternative to concurrency
    primitives present in the standard library. If you have a use case where the standard
    library `Mutex` or `RwLock` is not performant enough, then you can use this crate
    to gain significant speedups.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`parking_lot` 是另一个提供比标准库中现有的并发原语更快替代方案的 crate。如果你有一个标准库中的 `Mutex` 或 `RwLock`
    性能不足的使用场景，那么你可以使用这个 crate 来获得显著的加速。'
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It is quite astonishing that the same ownership principle that prevents memory
    safety violations in single-threaded contexts also works for multithreaded contexts
    in composition with marker traits. Rust has easy and safe ergonomics for integrating
    concurrrency in your application with minimal runtime cost. In this chapter, we
    learned how to use the `threads` API provided by Rust's standard library and got
    to know how copy and move types work in the context of concurrency. We covered
    channels, the atomic reference counting type, `Arc`, and how to use `Arc` with
    `Mutex` and also explored the actor model of concurrency.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上非常令人惊讶的是，同样的所有权原则，它防止了单线程上下文中的内存安全违规，在与标记特质组合时也适用于多线程上下文。Rust 提供了简单且安全的 ergonomics，以最小的运行时成本将并发集成到你的应用程序中。在本章中，我们学习了如何使用
    Rust 标准库提供的 `threads` API，并了解了在并发上下文中复制和移动类型是如何工作的。我们涵盖了通道、原子引用计数类型 `Arc`，以及如何使用
    `Arc` 与 `Mutex` 一起，还探讨了并发的actor模型。
- en: In the next chapter, we'll dive into metaprogramming which is all about generating
    code from code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨元编程，它完全是关于从代码生成代码的。
