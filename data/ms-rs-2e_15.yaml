- en: Rust on the Web with WebAssembly
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WebAssembly 在 Web 上构建 Rust
- en: Rust extends far beyond its system programming domain and can be made to run
    on the web as well. In this chapter, we'll explore one such technology for doing
    this, called WebAssembly. We'll go into the details of what exactly WebAssembly
    is, and how Rust can be made to run alongside JavaScript using this technology.Being
    able to run on web browsers unlocks a domain that enables Rust to be used by a
    much larger audience, that is, the community of web developers, and enables them
    to leverage the performance of a systems language in their applications. Later
    in this chapter, we'll explore the tools and libraries that offer WebAssembly
    support, and build a live markdown editor that invokes an API implemented in Rust
    for rendering markdown documents to an HTML page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 超出了其系统编程领域，也可以在 Web 上运行。在本章中，我们将探讨一种实现这一目标的技术，称为 WebAssembly。我们将详细介绍 WebAssembly
    究竟是什么，以及如何使用这项技术使 Rust 能够与 JavaScript 一起运行。能够在 Web 浏览器上运行解锁了一个领域，使得 Rust 能够被更广泛的受众使用，即
    Web 开发者社区，并使他们能够在应用程序中利用系统语言的功能。在本章的后面部分，我们将探讨提供 WebAssembly 支持的工具和库，并构建一个实时 Markdown
    编辑器，该编辑器调用在 Rust 中实现的 API，将 Markdown 文档渲染到 HTML 页面上。
- en: In this chapter, we will cover the following topics
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题
- en: What is WebAssembly?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 WebAssembly？
- en: The goals of WebAssembly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly 的目标
- en: How can WebAssembly be used?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 WebAssembly？
- en: The tale of Rust and WebAssembly and available crates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 和 WebAssembly 的故事以及可用的 crate
- en: Building a WebAssembly-based web application in Rust
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中构建基于 WebAssembly 的 Web 应用程序
- en: What is WebAssembly?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 WebAssembly？
- en: '"Be curious. Read widely. Try new things. I think a lot of what people call
    intelligence boils down to curiosity."                                       
                                                                               – Aaron
    Swartz'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “保持好奇心。广泛阅读。尝试新事物。我认为人们所说的许多所谓的智力都归结为好奇心。”                                 
                                                                             – 阿伦·斯沃茨
- en: WebAssembly is a suite of technologies and specifications that allows native
    code to run on the web by compiling down to a low-level programming language called
    **wasm**. From a usability perspective, it's a set of technologies that allows
    programs written in other non-web programming languages to run on web browsers.
    From a technical standpoint, WebAssembly is a virtual machine specification with
    a binary, load-time-efficient **Instruction Set Architecture (ISA)**. Okay, that's
    jargon overload. Let's simplify this definition a bit. As we know, a compiler
    is a complex program that turns code written in a human-readable programming language
    into machine code consisting of zeroes and ones. However, this translation happens
    in a multi-step process. It does this in several phases of compilation where,
    in the end, it gets compiled to the assembly language that's specific to the machine.
    Following that, the machine-specific assembler encodes it to the machine code
    by following the rules specified in the ISA for the target machine. Here, the
    compiler is targeting a real machine. However, it doesn't always have to be a
    real machine. It can also be a virtual machine (VM) executing its own virtual
    instruction set on top of a real machine. One example of virtual machines are
    video game emulators such as the Gameboy emulator that runs on normal computers
    and emulates the Gameboy hardware. A WebAssembly virtual machine is similar to
    that! Here, the browser engine implements the WebAssembly virtual machine, which
    enables us to run wasm code alongside JavaScript.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 是一套技术和规范，它允许通过编译成名为 **wasm** 的低级编程语言来在 Web 上运行原生代码。从可用性的角度来看，它是一套技术，允许用其他非
    Web 编程语言编写的程序在 Web 浏览器上运行。从技术角度来看，WebAssembly 是一个具有二进制、加载时高效的 **指令集架构 (ISA)**
    的虚拟机规范。好吧，这是术语过载。让我们稍微简化一下这个定义。正如我们所知，编译器是一个复杂的程序，它将人类可读的编程语言编写的代码转换为由零和一组成的机器代码。然而，这种转换发生在多步过程中。它通过编译的几个阶段来完成，最终编译成特定于机器的汇编语言。随后，特定于机器的汇编器根据目标机器的
    ISA 规则将其编码为机器代码。在这里，编译器针对的是真实机器。然而，它不总是必须是真实机器。它也可以是一个虚拟机 (VM)，在真实机器上执行自己的虚拟指令集。虚拟机的一个例子是视频游戏模拟器，如运行在普通计算机上的
    Gameboy 模拟器，它模拟 Gameboy 硬件。WebAssembly 虚拟机与此类似！在这里，浏览器引擎实现了 WebAssembly 虚拟机，使我们能够在
    JavaScript 旁边运行 wasm 代码。
- en: An instruction set architecture or ISA defines how a computer executes instructions
    and what sort of operations it supports at the lowest level. This ISA doesn't
    have to always be for a real physical machine; it can also be defined for a virtual
    machine. Wasm is the ISA for WebAssembly virtual machines.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集架构或ISA定义了计算机如何执行指令以及它在最低级别支持的操作类型。这个ISA不一定要总是为真实的物理机器定义；它也可以为虚拟机定义。Wasm是WebAssembly虚拟机的ISA。
- en: The past 5 years of increasing dependence on the web and its diverse range of
    applications has resulted in developers trying hard to transpile their code to
    JavaScript. This is because JavaScript is the most popular and is the only cross-platform
    technology on the web. One project, called `asm.js`, from Mozilla (a faster-typed
    subset of JavaScript) was the first effort to make the web more efficient and
    fast enough to meet growing demands. From `asm.js` and its founding principles
    and learned lessons, WebAssembly was born.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 过去5年中，对网络及其各种应用的日益依赖导致了开发者们努力将他们的代码转换为JavaScript。这是因为JavaScript是最受欢迎的，也是网络上的唯一跨平台技术。一个名为`asm.js`的项目，由Mozilla（JavaScript的一个更快的子集）发起，是第一个努力使网络更高效、足够快以满足不断增长需求的项目。从`asm.js`及其创立原则和所学经验中，WebAssembly应运而生。
- en: WebAssembly is a joint effort from the browser committee bodies of various major
    companies, namely Mozilla, Google, Apple, and Microsoft. Since early 2018, it
    has seen a tremendous rise in popularity as a compilation target for a wide variety
    of languages, ranging from *C++* using the Emscripten toolchain, Rust using LLVM/Emscripten,
    TypeScript using AssemblyScript, and many others. As of 2019, all major browsers
    implement a WebAssembly virtual machine in their web browser engine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly是来自各大公司浏览器委员会的共同努力，包括Mozilla、Google、Apple和Microsoft。自2018年初以来，它作为各种语言的编译目标而受到极大的欢迎，这些语言从使用Emscripten工具链的*C++*，到使用LLVM/Emscripten的Rust，使用AssemblyScript的TypeScript，以及其他许多语言。截至2019年，所有主要浏览器都在其网络浏览器引擎中实现了WebAssembly虚拟机。
- en: 'WebAssembly has the name assembly in it, as it''s a low-level programming language
    similar to assembly instructions. It has a limited set of primitive types, which
    makes the language simple to parse and run. It supports the following types natively:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的名字中有assembly，因为它是一种类似于汇编指令的低级编程语言。它有一组有限的原始类型，这使得语言易于解析和运行。它支持以下类型：
- en: '**i32**: 32-bit integer'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i32**: 32位整数'
- en: '**i64**: 64-bit integer'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i64**: 64位整数'
- en: '**f32**: 32-bit floating point'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f32**: 32位浮点数'
- en: '**f64**: 64-bit floating point'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f64**: 64位浮点数'
- en: It's less of a programming language that you will write daily, like JavaScript,
    but more of a compilation target for compilers. The WebAssembly platform and the
    ecosystem is currently focused on running this technology on the web, but it's
    not limited to the web in any way. If a platform implements the WebAssembly virtual
    machine specification as a program, a wasm program will be able to run on that
    virtual machine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它不像JavaScript那样是你每天都会编写的编程语言，而更像是一个编译目标，供编译器使用。WebAssembly平台和生态系统目前专注于在网络上运行这项技术，但它并不局限于网络。如果一个平台将WebAssembly虚拟机规范实现为一个程序，那么wasm程序就能在该虚拟机上运行。
- en: To support WebAssembly on any platform, a virtual machine needs to be implemented
    in the language that is supported by the platform. This is just like JVM's platform-agnostic
    code—write once, run faster, safe anywhere! But it's primary target, as of now,
    is the browser. Most web browsers come with a JavaScript parser that can parse
    `.js` files in their browser engines to enable all sorts of interactivity for
    the user. To allow the web to interpret wasm files too, these engines implement
    the WebAssembly VM within them, allowing browsers to interpret and run wasm code
    alongside JavaScript code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在任何平台上支持WebAssembly，需要用该平台支持的语言实现一个虚拟机。这就像JVM的平台无关代码——一次编写，运行更快，安全在任何地方！但它的主要目标，到目前为止，是浏览器。大多数网络浏览器都带有JavaScript解析器，可以在其浏览器引擎中解析`.js`文件，以使用户能够进行各种交互。为了允许网络也能解释wasm文件，这些引擎在其内部实现了WebAssembly
    VM，允许浏览器在JavaScript代码旁边解释和运行wasm代码。
- en: A stark difference between parsing JavaScript and parsing WebAssembly code is
    that wasm code is an order of magnitude faster to parse because of its compact
    representation. Most of the initial page-load time on dynamic websites is spent
    on parsing JavaScript code, and using WebAssembly can provide a huge boost in
    performance for these websites. The goal of WebAssembly, however, is not to replace
    JavaScript, but to be a helping hand for JavaScript when performance matters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 JavaScript 和解析 WebAssembly 代码之间的一个显著差异是，由于其紧凑的表示，wasm 代码的解析速度要快一个数量级。在动态网站上，大多数初始页面加载时间都花在解析
    JavaScript 代码上，而使用 WebAssembly 可以为这些网站提供巨大的性能提升。然而，WebAssembly 的目标并不是取代 JavaScript，而是在性能重要时成为
    JavaScript 的助手。
- en: 'WebAssembly''s language comes in two formats, as per the specification, which
    is defined at [https://webassembly.org/](https://webassembly.org/): the human-readable
    text format, `.wat`, which is suitable for viewing and debugging WebAssembly code
    before its final deployment, and the compact, low-level machine format called
    **wasm**. The `.wasm` format is the one that''s interpreted and executed by the
    WebAssembly VM.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[https://webassembly.org/](https://webassembly.org/)上的规范，WebAssembly 的语言有两种格式：人类可读的文本格式，`.wat`，适合在最终部署前查看和调试
    WebAssembly 代码，以及称为 **wasm** 的紧凑、低级机器格式。`.wasm` 格式是 WebAssembly VM 解释和执行的一种格式。
- en: 'A WebAssembly program starts with a module. Within a module, you can define
    variables, functions, constants, and so on. Wasm programs are written as s-expressions.
    S-expressions are a concise way to represent programs via a nested sequence of
    parenthesis-delimited blocks. For instance, a single `(1)` is an s-expression
    that returns the value `1`. Every s-expression in WebAssembly returns a value.
    Let''s take a look at a very minimal WebAssembly program in the readable `.wat`
    format:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 WebAssembly 程序从模块开始。在模块内部，你可以定义变量、函数、常量等。Wasm 程序以 s-表达式编写。S-表达式是通过嵌套括号分隔的块序列来表示程序的简洁方式。例如，单个
    `(1)` 是一个返回值 `1` 的 s-表达式。WebAssembly 中的每个 s-表达式都返回一个值。让我们看看一个非常简单的 WebAssembly
    程序，以可读的 `.wat` 格式：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding `wat` code, we have a parent s-expression block `(module)`
    that contains other nested s-expressions. Inside `module`, we have sections called
    `table`, `memory`, and `export`, and a `func` definition called `$one`, which
    returns an `i32`. We won't be going into the details of them, as that would digress
    us too far.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `wat` 代码中，我们有一个包含其他嵌套 s-表达式的父 s-表达式块 `(module)`。在 `module` 内部，我们有名为 `table`、`memory`
    和 `export` 的部分，以及一个返回 `i32` 的 `func` 定义 `$one`。我们不会深入探讨它们的细节，因为这会让我们偏离主题太远。
- en: The important point to mention about wasm programs is that they are very efficient
    in their representation and can be sent and parsed much faster in browsers than
    JavaScript. Having said that, WebAssembly was designed with a focused set of goals
    and not to be a general-purpose programming language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 wasm 程序的一个重要点是，它们在表示上非常高效，可以在浏览器中比 JavaScript 快得多地发送和解析。话虽如此，WebAssembly
    是为了实现一系列目标而设计的，而不是作为一个通用编程语言。
- en: Design goals of WebAssembly
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly 的设计目标
- en: 'WebAssembly''s design is the result of a joint collaboration between major
    browser vendors. Together, they aim to shape its design with the following goals
    in mind:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 的设计是主要浏览器供应商之间联合协作的结果。他们共同的目标是以下目标来塑造其设计：
- en: '**Be as safe and universal as JavaScript**: The web platform is an unsafe environment
    and having untrusted code run is detrimental to the safety of users on the web.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像 JavaScript 一样安全和通用**：网络平台是一个不安全的环境，运行不受信任的代码对网络用户的安全是有害的。'
- en: '**Run as quickly as native code**: Because the language is quite compact, WebAssembly
    can be loaded faster than JavaScript code and can be interpreted five times faster
    than JavaScript.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以原生代码的速度运行**：由于语言相当紧凑，WebAssembly 可以比 JavaScript 代码加载得更快，并且可以比 JavaScript
    快五倍的速度进行解释。'
- en: '**Provide consistent, predictable performance**: Being statically typed, and
    with very minimal analysis happening at runtime, WebAssembly is able to provide
    consistent performance on the web, whereas JavaScript falls short because of its
    dynamic nature.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供一致、可预测的性能**：作为静态类型，并且在运行时进行非常少的分析，WebAssembly 能够在网络上提供一致的性能，而 JavaScript
    由于其动态性质而在这方面表现不足。'
- en: '**Allow code reuse between web and native**: A lot of existing code bases in
    C/C++, Rust, and other languages can now be reused and run on the web after compilation
    to WebAssembly.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许在 Web 和本地之间重用代码**：许多现有的 C/C++、Rust 和其他语言的代码库现在可以在编译成 WebAssembly 后重用并在网络上运行。'
- en: Getting started with WebAssembly
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 WebAssembly
- en: Though WebAssembly modules can be written by hand, it is not advisable to do
    so, as the code is hard to maintain and is not human-friendly. It is a pretty
    low-level language and, as a result, creating complex applications using raw wasm
    code can be challenging and time-consuming. Instead, it is often compiled to,
    or generated from, a variety of languages. Let's look at the available tools that
    we can use to explore the details of how WebAssembly programs are written and
    run.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以手动编写 WebAssembly 模块，但这样做并不建议，因为代码难以维护且不便于人类使用。它是一种相当低级的语言，因此，使用原始 wasm 代码创建复杂的应用程序可能会具有挑战性且耗时。相反，它通常被编译成或从各种语言生成。让我们看看我们可以使用的可用工具，以探索
    WebAssembly 程序的编写和运行细节。
- en: Trying it out online
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线尝试
- en: 'Before we discuss how WebAssembly is used as a compilation target across different
    language ecosystems, we can explore it online without requiring any kind of setup
    on our machine. Some tools that can be used to do this are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论 WebAssembly 如何作为不同语言生态系统的编译目标之前，我们可以在网上探索它，而无需在我们的机器上做任何设置。以下是一些可以用来做这件事的工具：
- en: '**WebAssembly Studio**: The folks at Mozilla have created a really handy tool
    to try out WebAssembly in a quick way, and it''s hosted at [https://webassembly.studio](https://webassembly.studio).
    Using this tool, we can experiment and prototype ideas in WebAssembly really quickly.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebAssembly Studio**：Mozilla 的人们创建了一个非常实用的工具，可以快速尝试 WebAssembly，它托管在 [https://webassembly.studio](https://webassembly.studio)。使用这个工具，我们可以快速实验和原型设计
    WebAssembly 的想法。'
- en: '**Wasm Fiddle**: This is another handy tool for trying out wasm code online,
    and can be found at [https://wasdk.github.io/WasmFiddle/](https://wasdk.github.io/WasmFiddle/).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wasm Fiddle**：这是另一个方便的工具，可以在线尝试 wasm 代码，可以在 [https://wasdk.github.io/WasmFiddle/](https://wasdk.github.io/WasmFiddle/)
    找到。'
- en: There are other tools online and community resources for you to explore, all
    of which you can find at [https://github.com/mbasso/awesome-wasm](https://github.com/mbasso/awesome-wasm).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在线还有其他工具和社区资源供您探索，您都可以在 [https://github.com/mbasso/awesome-wasm](https://github.com/mbasso/awesome-wasm)
    找到。
- en: Ways to generate WebAssembly
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 WebAssembly 的方法
- en: 'There are several compiler toolchain projects that can help developers compile
    their code from any language to wasm. Compiling native code has huge implications
    for the web. It means that most major performance-intensive code can now be run
    on the web. For instance, C++ code can be compiled to wasm using the emscripten
    LLVM backend. The emscripten project takes in the LLVM IR generated by the C++
    compiler and converts it into WebAssembly modules in wasm format. There are also
    projects such as AssemblyScript, which convert TypeScript code into WebAssembly
    using another emscripten-like tool, called binaryen. Rust also supports emitting
    WebAssembly code by default using LLVM''s native WebAssembly backend. Compiling
    to wasm with Rust is very simple. First, we need to add the wasm by running the
    following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个编译器工具链项目可以帮助开发者将任何语言的代码编译为 wasm。编译本地代码对网络有巨大的影响。这意味着大多数主要性能密集型代码现在都可以在网络上运行。例如，可以使用
    emscripten LLVM 后端将 C++ 代码编译为 wasm。emscripten 项目接收由 C++ 编译器生成的 LLVM IR，并将其转换为
    wasm 格式的 WebAssembly 模块。还有像 AssemblyScript 这样的项目，使用类似 emscripten 的工具 binaryen
    将 TypeScript 代码转换为 WebAssembly。Rust 还默认支持通过 LLVM 的本地 WebAssembly 后端生成 WebAssembly
    代码。使用 Rust 编译到 wasm 非常简单。首先，我们需要运行以下代码来添加 wasm：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once that is done, we can compile any Rust program to wasm by running the following
    code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以通过运行以下代码将任何 Rust 程序编译为 wasm：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the bare minimum that's needed to create a wasm file from a Rust crate,
    but it's a lot of hand holding from there. Fortunately, there are amazing projects
    being developed around the wasm and Rust ecosystem that allow for more higher-level,
    intuitive interaction with JavaScript and Rust, and vice versa. We'll explore
    one such project, called wasm-bindgen, and build a real-world web application
    soon.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 Rust crate 创建 wasm 文件所需的最基本内容，但从那里开始有很多手动操作。幸运的是，围绕 wasm 和 Rust 生态系统正在开发一些惊人的项目，允许进行更高级、更直观的
    JavaScript 和 Rust 之间的交互，反之亦然。我们将探索这样一个项目，称为 wasm-bindgen，并很快构建一个真实世界的 Web 应用程序。
- en: Rust and WebAssembly
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 和 WebAssembly
- en: The ecosystem around Rust and WebAssembly is hurtling at quite a fast pace and
    it'll take time before the community agrees on a set of tools for building practical
    applications. Fortunately, some tools and libraries are emerging that give us
    a picture of what to expect as developers when building applications for the web
    in Rust using WebAssembly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 和 WebAssembly 围绕的生态系统正在以相当快的速度发展，社区在就构建实用应用程序的工具集达成一致之前还需要一段时间。幸运的是，一些工具和库正在出现，为我们描绘了当使用
    WebAssembly 在 Rust 中构建 Web 应用程序时，作为开发者我们可以期待什么。
- en: In this section, we'll explore a crate from the community called `wasm-bindgen`*.*
    This crate is pretty much a work in progress, as the WebAssembly specification
    itself is a work in progress, but nonetheless, it is quite feature-rich to explore
    what is possible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索一个来自社区的库，称为 `wasm-bindgen`*.* 这个库基本上是一个正在进行中的项目，因为 WebAssembly 规范本身也是一个正在进行中的项目，但尽管如此，它仍然功能丰富，可以探索可能实现的内容。
- en: Wasm-bindgen
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wasm-bindgen
- en: '`wasm-bindgen` is a crate that was developed by the rust-wasm team on GitHub.
    It allows Rust code to call JavaScript code and vice versa. Based on this library,
    other higher-level libraries have been built, such as the `web-sys` crate and
    the `js-sys` crate.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen` 是由 GitHub 上的 rust-wasm 团队开发的一个库。它允许 Rust 代码调用 JavaScript 代码，反之亦然。基于这个库，已经构建了其他高级库，如
    `web-sys` 库和 `js-sys` 库。'
- en: JavaScript by itself is what is defined by the ECMA standard, but the standard
    does not specify how it works on the web. JavaScript can support many hosts and
    the web happens to be one of them. The `web-sys` crate gives access to all of
    the JavaScript APIs on the web, that is, DOM APIs such as `Window`, `Navigator`,
    `EventListener`, and so on. The `js-sys` crate provides all of the base JavaScript
    objects that are specified in the ECMA standard specification, that is, functions,
    objects, numbers, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 本身是由 ECMA 标准定义的，但该标准并未指定其在网页上的工作方式。JavaScript 可以支持许多宿主环境，而网页恰好是其中之一。`web-sys`
    库提供了对网页上所有 JavaScript API 的访问，即 DOM API，如 `Window`、`Navigator`、`EventListener`
    等。`js-sys` 库提供了 ECMA 标准规范中指定的所有基本 JavaScript 对象，即函数、对象、数字等。
- en: Since WebAssembly only supports numeric types, the `wasm-bindgen` crate generates
    shims to allow you to use native Rust types in JavaScript. For example, a struct
    in Rust is represented as an object on the JavaScript side, while a `Promise`
    object can be accessed as a `Future` on the Rust side. It does all of this by
    using the `#[wasm-bindgen]` attribute macro over function definitions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WebAssembly 只支持数值类型，`wasm-bindgen` 库生成垫片，允许你在 JavaScript 中使用原生 Rust 类型。例如，Rust
    中的结构体在 JavaScript 端表示为对象，而 `Promise` 对象在 Rust 端可以像 `Future` 一样访问。它通过在函数定义上使用 `#[wasm-bindgen]`
    属性宏来实现所有这些。
- en: 'To explore `wasm-bindgen` and how it interacts with JavaScript, we''ll build
    something practical. We''ll build a live markdown editor app that will allow you
    to write markdown and view the rendered HTML page. Before we start, though, we
    need to install the wasm-bindgen-cli tool that will generate shims for us, allowing
    us to conveniently use the exposed Rust functions from our library. We can install
    it by running:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索 `wasm-bindgen` 以及它与 JavaScript 的交互方式，我们将构建一些实用的东西。我们将构建一个实时 Markdown 编辑器应用程序，允许你编写
    Markdown 并查看渲染的 HTML 页面。不过，在我们开始之前，我们需要安装 wasm-bindgen-cli 工具，该工具将为我们生成垫片，使我们能够方便地使用库中暴露的
    Rust 函数。我们可以通过运行以下命令来安装它：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let''s create a new project by running `cargo new livemd` with the following
    contents in `Cargo.toml`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过运行 `cargo new livemd` 并在 `Cargo.toml` 中包含以下内容来创建一个新的项目：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have named our library `livemd`. Our library is of the `cdylib` type and
    is exposing a C interface because WebAssembly accepts a widely targetable dynamic
    C library interface, which most languages can compile to. Next, we''ll also create
    a `run.sh` script at our directory root that will let us build and run our project
    and rerun it every time we change any of our code using `cargo-watch`. Here''s
    the content of the `run.sh` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的库命名为 `livemd`。我们的库是 `cdylib` 类型，并暴露了一个 C 接口，因为 WebAssembly 接受广泛可移植的动态
    C 库接口，大多数语言都可以编译成这种接口。接下来，我们还将在我们目录的根目录下创建一个 `run.sh` 脚本，它将允许我们构建和运行我们的项目，并在我们更改任何代码时使用
    `cargo-watch` 重新运行它。以下是 `run.sh` 文件的内容：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next is the implementation of the the markdown conversion code in `lib.rs`,
    in its entirety:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `lib.rs` 中 markdown 转换代码的实现，完整如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our `livemd` crate exposes a single function named `pars`, which takes in the
    markdown text from the `textarea` tag on the web page (yet to be created) and
    returns the compiled HTML string by invoking the `markdown_to_html` function from
    the `comrak` crate. As you may have noticed, the `parse` method is annotated with
    the `#[wasm_bindgen]` attribute. This macro generates code for all kinds of lower-level
    conversions, and is required to expose this function to JavaScript. Using this
    attribute, we don't have to care about what kind of strings our parse method will
    take. Strings from JavaScript are different than strings in Rust. The `#[wasm_bindgen]`
    attribute handles this difference and the low-level details of converting the
    string from the JavaScript side before accepting it as a `&amp;str` type for us.
    At the time of writing this book, there are some types that `wasm-bindgen` cannot
    convert, such as references and type definitions with lifetime annotation on them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `livemd` 包公开一个名为 `pars` 的单个函数，它接受来自网页上（尚未创建）的 `textarea` 标签的Markdown文本，并通过调用
    `comrak` 包中的 `markdown_to_html` 函数返回编译后的HTML字符串。如您所注意到的，`parse` 方法被注释为 `#[wasm_bindgen]`
    属性。此宏生成所有类型的底层转换代码，并且是暴露此函数到JavaScript所必需的。使用此属性，我们不必关心我们的解析方法将接受什么类型的字符串。JavaScript中的字符串与Rust中的字符串不同。`#[wasm_bindgen]`
    属性处理这种差异以及将字符串从JavaScript端转换为低级细节，在我们接受它作为 `&str` 类型之前。在撰写本书时，有一些类型 `wasm-bindgen`
    无法转换，例如带有生命周期注释的引用和类型定义。
- en: 'We then need to generate the wasm file for this crate. But before we do that,
    let''s set up our app. In the same directory, we''ll create a directory named
    `app/` and initialize our project by running `yarn init`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要为这个包生成wasm文件。但在我们这样做之前，让我们设置我们的应用。在相同的目录下，我们将创建一个名为 `app/` 的目录，并通过运行
    `yarn init` 来初始化我们的项目：
- en: '![](img/3c8e0591-081b-467a-bc5f-dd78dfcb232e.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c8e0591-081b-467a-bc5f-dd78dfcb232e.png)'
- en: '`yarn init` creates our `package.json` file. Apart from the usual fields, we''ll
    specify `scripts` and `dev-dependencies`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarn init` 创建我们的 `package.json` 文件。除了常规字段外，我们还将指定 `scripts` 和 `dev-dependencies`：'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll be using webpack to spin up our development web server. Webpack is a
    module bundler. A module bundler takes multiple JavaScript source files and bundles
    them into a single file, possibly minifying it for consumption on the web. To
    configure webpack so that we can bundle our JavaScript and wasm-generated code,
    we''ll create a webpack config file in a file named `webpack.config.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用webpack来启动我们的开发web服务器。Webpack是一个模块打包器。模块打包器将多个JavaScript源文件打包成一个文件，可能还会对其进行压缩以便在网络上使用。为了配置webpack以便我们可以打包我们的JavaScript和wasm生成的代码，我们将在名为
    `webpack.config.js` 的文件中创建一个webpack配置文件：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, in the same `app/` directory, we''ll create three files:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在相同的 `app/` 目录下，我们将创建三个文件：
- en: '`index.html`: This contains the UI of the app:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`: 这包含应用的UI：'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have declared a `<textarea>` HTML element with an ID of `editor`. This will
    be shown on the left, and is where you can write your markdown. Next, we have
    a `<div>` element with an ID of `preview`, which will show the live rendered HTML
    content.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已声明一个具有ID为 `editor` 的 `<textarea>` HTML元素。这将在左侧显示，并且是您可以在此处编写Markdown的地方。接下来，我们有一个具有ID为
    `preview` 的 `<div>` 元素，它将显示实时渲染的HTML内容。
- en: '`style.css`: To make our app look nice, this file provides the basic styling
    for rendering the live editor and preview panes in the app:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style.css`: 为了使我们的应用看起来更美观，此文件为应用中的实时编辑器和预览面板提供基本的样式：'
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`index.js`: This file provides the glue code between our UI and our `livemd`
    crate:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.js`: 此文件提供我们UI和 `livemd` 包之间的粘合代码：'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code imports the `livemd` module, which returns a `Promise` instance.
    We then chain on the value that's produced by this promise by calling the `then`
    method, which takes an anonymous function, `(livemd) => {}`. This function receives
    the wasm module (we named it `livemd`). Within this method, we get the `editor`
    and `preview` HTML elements by their IDs. We then create a function called `markdownToHtml`,
    which takes the text from the `editor` element from its property `value` and passes
    it to the `parse` method from the livemd wasm module. This returns rendered HTML
    text as a string. We then set the `innerHTML` property of the `preview` element
    to this text. Next, to provide live feedback for any updates made by the user
    on any text changes in the `editor` element, we need to invoke this function.
    We can use the `onInput` event handler for this. To the editor element, we call
    the `addEventListener` method with the `"input"` event and pass this function
    as the handler. Finally, we invoke `markdownToHtml` to kick off the parsing and
    rendering of the text.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码导入了 `livemd` 模块，该模块返回一个 `Promise` 实例。然后，我们通过调用 `then` 方法来链式调用由这个承诺产生的值，该方法接受一个匿名函数
    `(livemd) => {}`。这个函数接收 wasm 模块（我们命名为 `livemd`）。在这个方法内部，我们通过 ID 获取 `editor` 和
    `preview` HTML 元素。然后，我们创建一个名为 `markdownToHtml` 的函数，该函数从 `editor` 元素的 `value` 属性中获取文本并将其传递给
    livemd wasm 模块的 `parse` 方法。这返回一个作为字符串的渲染 HTML 文本。然后，我们将 `preview` 元素的 `innerHTML`
    属性设置为这个文本。接下来，为了提供用户在 `editor` 元素中任何文本更改的实时反馈，我们需要调用这个函数。我们可以使用 `onInput` 事件处理器来实现。我们对编辑器元素调用
    `addEventListener` 方法，使用 `"input"` 事件，并将此函数作为处理器传递。最后，我们调用 `markdownToHtml` 来启动文本的解析和渲染。
- en: That's it—we have created our first web application that uses Rust under the
    hood and runs WebAssembly alongside JavaScript.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——我们已经创建了我们第一个使用 Rust 作为底层并运行 WebAssembly 的 Web 应用程序。
- en: '**Note**: This isn''t an efficient implementation and there are lot of improvements
    that can be made. However, since we are learning about the tools here, it''s okay
    for demonstration purposes.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：这不是一个高效的实现，有很多改进可以做出。然而，由于我们在这里学习工具，为了演示目的，这是可以接受的。'
- en: 'Now, we need to compile our crate into WebAsssembly code, that is, as a `wasm`
    file, and generate a bundled JavaScript file. We have a script set up already,
    called `run.sh`. Here''s the output on running our `run.sh` script:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的 crate 编译成 WebAssembly 代码，即一个 `wasm` 文件，并生成一个捆绑的 JavaScript 文件。我们已经设置了一个名为
    `run.sh` 的脚本。以下是运行我们的 `run.sh` 脚本时的输出：
- en: '![](img/a4213403-fe51-4b07-be87-6b012e27b065.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4213403-fe51-4b07-be87-6b012e27b065.png)'
- en: The `run.sh` script first builds the `livemd` crate by running `cargo build
    --target wasm32-unknown-unknown`. Next, it invokes the `wasm-bindgen` tool, which
    optimizes our `wasm` file and outputs it in the `app/` directory. Then, we run
    `yarn install` in our app directory, followed by `yarn run serve`, which starts
    our development server using the `webpack-dev-server` plugin.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`run.sh` 脚本首先通过运行 `cargo build --target wasm32-unknown-unknown` 构建 `livemd`
    crate。然后，它调用 `wasm-bindgen` 工具，该工具优化我们的 `wasm` 文件并将其输出到 `app/` 目录。接着，我们在应用目录中运行
    `yarn install`，然后是 `yarn run serve`，这会使用 `webpack-dev-server` 插件启动我们的开发服务器。'
- en: 'If you face errors while running wasm-bindgen cli command, try updating the
    wasm-bindgen dependency in livemd/Cargo.toml by running:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行 wasm-bindgen 命令行时遇到错误，尝试通过运行以下命令更新 livemd/Cargo.toml 中的 wasm-bindgen
    依赖项：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also need to install the yarn package manager for hosting the web page on
    localhost. This can be done by running:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装 yarn 包管理器来在本地主机上托管网页。这可以通过运行以下命令来完成：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From webpack''s output, our development server is running at `http://localhost:8080`.
    Let''s head over to our web browser and go to this address. Here''s the output
    on my browser:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从 webpack 的输出来看，我们的开发服务器正在 `http://localhost:8080` 运行。让我们转到我们的网页浏览器并访问这个地址。以下是我在浏览器中的输出：
- en: '![](img/79393ad6-760c-4b95-b8ea-06a23fbeb810.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79393ad6-760c-4b95-b8ea-06a23fbeb810.png)'
- en: As you can see, we have our text in markdown format on the left-hand pane and
    it gets rendered on the right in real time as HTML. Under the hood, every bit
    of text we type on the left-hand side of this page gets converted into HTML text,
    which is generated by the `livemd` wasm module that we created.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在左侧面板中有 markdown 格式的文本，并且它实时地渲染在右侧的 HTML 中。在底层，我们在这个页面的左侧键入的每一比特文本都被转换成了由我们创建的
    `livemd` wasm 模块生成的 HTML 文本。
- en: We can also publish our `livemd` crate as an npm package. The wasm-pack project
    at [https://github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)
    provides all kinds of orchestration that's needed to build and ship npm modules
    written in Rust that have been compiled to WebAssembly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将我们的`livemd`包发布为npm包。位于[https://github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)的wasm-pack项目提供了构建和分发用Rust编写并编译成WebAssembly的npm模块所需的所有编排。
- en: Other WebAssembly projects
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他WebAssembly项目
- en: Apart from the `wasm-bindgen` crate and friends, there are other emerging frameworks
    and projects in the Rust community that are worth exploring.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`wasm-bindgen`包及其相关项目外，Rust社区中还有其他新兴的框架和项目值得探索。
- en: Rust
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust
- en: 'Wasm-bindgen is not the only project that aims to create amazing development
    experiences. Some other projects in the Rust ecosystem are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm-bindgen并不是唯一旨在创建出色开发体验的项目。Rust生态系统中的其他一些项目如下：
- en: '**Stdweb**: This crate aims to provide a high-level, Rust-based API for accessing
    DOM APIs over the web.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stdweb**：这个包旨在提供一个基于Rust的高层API，用于通过Web访问DOM API。'
- en: '**Yew**: This is a complete frontend web application building framework that
    allows you to write web applications in Rust that can access Web APIs and compile
    them into wasm so that they can be run on the web. It is inspired by the Elm and
    ReactJS projects. It also encapsulates actor-based message passing concurrency
    via web workers on the web. Yew uses the `stdweb` crate internally to access DOM
    APIs.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Yew**：这是一个完整的前端Web应用程序构建框架，允许你使用Rust编写可以访问Web API并将它们编译成wasm以便在Web上运行的Web应用程序。它受到了Elm和ReactJS项目的启发。它还通过Web
    Workers封装了基于actor的消息传递并发。Yew内部使用`stdweb`包来访问DOM API。'
- en: '**Nebutlet**: This is a micro-kernel that can execute WebAssembly programs
    without any kind of system call interface, which is usually the norm in most operating
    system implementations.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nebutlet**：这是一个可以执行WebAssembly程序而不需要任何系统调用接口的微内核，这在大多数操作系统实现中通常是标准做法。'
- en: '**Wasmi**: This is a wasm virtual machine that''s implemented in Rust, but
    it isn''t related to the wasm VM in browser engines. The project was initiated
    by Parity, an Ethereum-based start-up, which is more suited to running WebAssembly
    applications on many platforms. The project is hosted at [https://github.com/paritytech/wasmi](https://github.com/paritytech/wasmi).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wasmi**：这是一个用Rust实现的wasm虚拟机，但它与浏览器引擎中的wasm虚拟机无关。该项目由以太坊初创公司Parity发起，更适合在多个平台上运行WebAssembly应用程序。该项目托管在[https://github.com/paritytech/wasmi](https://github.com/paritytech/wasmi)。'
- en: Other languages
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他语言
- en: 'Other languages also have technologies that target WebAssembly, such as the
    following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言也有针对WebAssembly的技术，例如以下内容：
- en: '**Life**: Life is a WebAssembly VM that''s implemented in Golang for running
    high performance, decentralized applications securely. The project resides at
    [https://github.com/perlin-network/life](https://github.com/perlin-network/life).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Life**：Life是一个用Golang实现的WebAssembly虚拟机，用于安全地运行高性能、去中心化的应用程序。该项目位于[https://github.com/perlin-network/life](https://github.com/perlin-network/life)。'
- en: '**AssemblyScript**: This is a TypeScript-to-WebAssembly compiler.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AssemblyScript**：这是一个TypeScript到WebAssembly的编译器。'
- en: '**Wagon**: Wagon is a WebAssembly interpreter in Golang.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wagon**：Wagon是一个用Golang编写的WebAssembly解释器。'
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: WebAssembly will have a huge impact on how web developers build their applications,
    allowing them to gain a lot of performance gains with little effort. It will allow
    for diversity in terms of application developers, thus allowing them to write
    web applications in their native language without worrying about learning other
    frameworks. WebAssembly is not meant to replace Javascript, but to serve as a
    high-performance language for running complex web applications on the web. The
    WebAssembly standard is constantly evolving and has a lot of exciting possibilities.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly将对Web开发者构建应用程序的方式产生巨大影响，使他们能够以最小的努力获得大量的性能提升。它将允许应用开发者多样化，从而使得他们能够用他们的本地语言编写Web应用程序，而无需担心学习其他框架。WebAssembly不是用来取代JavaScript的，而是作为一个高性能语言，用于在Web上运行复杂的Web应用程序。WebAssembly标准正在不断演变，并有许多令人兴奋的可能性。
- en: 'In this chapter, we learned about how Rust can compile down to wasm code and
    the available tooling that helps ship Rust code on the web. If you want to learn
    more about WebAssembly, head over to the excellent documentation at: [https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Rust 如何编译成 wasm 代码以及帮助在网络上部署 Rust 代码的可用工具。如果你想要了解更多关于 WebAssembly
    的信息，请访问优秀的文档：[https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)。
- en: In the next chapter, we will learn a bit about GUI development and how to build
    desktop applications with Rust.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些关于 GUI 开发以及如何使用 Rust 构建桌面应用程序的内容。
