- en: Systems Programming Made Easy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统编程变得简单
- en: Rust was originally envisioned as a systems programming language in the same
    way as C (and maybe C++). Although its appeal led to significant growth outside
    this field (somewhat like C/C++), there are still many features that significantly
    facilitate working on low-level projects. We suspect that the novelty aspect (as
    well as the powerful compiler, error messages, and community) led to very interesting
    projects in that space—such as operating systems. One of them is intermezzOS ([https://intermezzos.github.io/](https://intermezzos.github.io/)),
    an operating system for learning programming (in Rust); another is Redox OS ([https://www.redox-os.org/](https://www.redox-os.org/)),
    a microkernel effort in pure Rust. However, it doesn't stop there—the Rust embedded
    working group has compiled a list of resources and highlight projects on their
    GitHub ([https://github.com/rust-embedded/awesome-embedded-rust](https://github.com/rust-embedded/awesome-embedded-rust)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust最初被设想为与C（以及可能C++）一样的系统编程语言。尽管其吸引力导致了该领域之外的重大增长（有点像C/C++），但仍有许多特性显著地简化了低级项目的工作。我们怀疑新颖性方面（以及强大的编译器、错误信息和社区）导致了该领域非常有趣的项目——例如操作系统。其中之一是intermezzOS（[https://intermezzos.github.io/](https://intermezzos.github.io/)），一个用于学习编程（使用Rust）的操作系统；另一个是Redox
    OS（[https://www.redox-os.org/](https://www.redox-os.org/)），一个纯Rust的微内核项目。然而，这并没有结束——Rust嵌入式工作组已经编译了一份资源列表，并在他们的GitHub上突出显示了一些项目（[https://github.com/rust-embedded/awesome-embedded-rust](https://github.com/rust-embedded/awesome-embedded-rust)）。
- en: Linux is the most widely adopted operating system for embedded devices, but
    we tried to show the principles without requiring you to run Linux. In order to
    fully implement, for example, an I2C device driver, macOS and Windows users can
    use virtual machines with Hyper-V ([https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/)), VirtualBox
    ([https://www.virtualbox.org/](https://www.virtualbox.org/)), or Parallels ([https://www.parallels.com/](https://www.parallels.com/)),
    or rent a machine on the cloud ([https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)).
    With the exception of the first recipe, the recipes in this chapter work across
    OSes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是嵌入式设备最广泛采用的操作系统，但我们试图展示这些原则，而无需您运行Linux。为了完全实现，例如，I2C设备驱动程序，macOS和Windows用户可以使用带有Hyper-V（[https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/)）、VirtualBox（[https://www.virtualbox.org/](https://www.virtualbox.org/））或Parallels（[https://www.parallels.com/](https://www.parallels.com/））的虚拟机，或者租用云上的机器（[https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/））。除了第一个菜谱外，本章中的菜谱可以在各种操作系统上运行。
- en: 'This list is truly awesome, and we are aiming to get you to a place where you
    can start building embedded drivers and cross-compile them to various CPU architectures.
    With that in mind, this chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表真正令人惊叹，我们的目标是让您能够开始构建嵌入式驱动程序并将它们跨编译到各种CPU架构。考虑到这一点，本章涵盖了以下主题：
- en: Cross-compiling Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台编译Rust
- en: Implementing device drivers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现设备驱动程序
- en: Reading from these drivers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这些驱动程序中读取
- en: Cross-compiling Rust
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台编译Rust
- en: Surprisingly, one of the more challenging aspects of implementing low-level
    projects is cross-compilation. Thanks to its LLVM underpinnings, `rustc` comes
    with a lot of toolchains for different CPU architectures. However, cross-compiling
    an application means that its (native) dependencies have to be available for this
    CPU architecture as well. This is challenging for small projects since it requires
    lots of management for versions across architectures and grows more and more complex
    with every added requirement. This is why there have been several tools that relate
    to this issue. In this recipe, we will explore at a few tools and learn how to
    use them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 意想不到的是，实现低级项目更具挑战性的方面之一是跨编译。多亏了其LLVM基础，`rustc`为不同的CPU架构提供了大量的工具链。然而，跨编译一个应用程序意味着它的（本地）依赖也必须适用于这个CPU架构。这对于小型项目来说是一个挑战，因为它需要在架构之间进行大量的版本管理，并且随着每个新要求的增加而变得越来越复杂。这就是为什么已经出现了几个与这个问题相关的工具。在本菜谱中，我们将探索一些工具并学习如何使用它们。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is highly platform-specific; at the time of writing, cross-compiling
    Rust on platforms other than Linux is tricky. On macOS and Windows, you can use
    virtual machines with Hyper-V ([https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/)), VirtualBox
    ([https://www.virtualbox.org/](https://www.virtualbox.org/)), or Parallels ([https://www.parallels.com/](https://www.parallels.com/)),
    or rent a machine from your favorite cloud provider ([https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱非常特定于平台；在撰写本文时，在 Linux 之外的平台交叉编译 Rust 是一项棘手的工作。在 macOS 和 Windows 上，你可以使用带有
    Hyper-V ([https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/))、VirtualBox
    ([https://www.virtualbox.org/](https://www.virtualbox.org/)) 或 Parallels ([https://www.parallels.com/](https://www.parallels.com/))
    的虚拟机，或者从你最喜欢的云服务提供商那里租用一台机器（[https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/))。
- en: The **Windows Subsystem for Linux** (**WSL**) on Windows 10 doesn't support
    Docker at the time of writing. There might be ways around this limitation, but
    we will leave the required tinkering to our readers. If you find a solution, be
    sure to share it on our GitHub repository ([https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 10 上的 **Windows 子系统 for Linux**（**WSL**）在撰写本文时不支持 Docker。可能存在绕过此限制的方法，但我们将把所需的调整留给读者。如果你找到一个解决方案，请确保在我们的
    GitHub 仓库（[https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)）上分享它。
- en: Then, install Docker ([https://docs.docker.com/install/](https://docs.docker.com/install/)) and
    make sure you can run Docker without **`sudo`** ([https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/))
    to proceed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，安装 Docker ([https://docs.docker.com/install/](https://docs.docker.com/install/))
    并确保你可以不使用 **`sudo`** ([https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/))
    来继续。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'With Docker available, take these steps to cross-compile to many targets:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 可用的情况下，按照以下步骤进行交叉编译到多个目标：
- en: Create a project using `cargo new cross-compile` for a binary executable and
    open the folder using VS Code.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new cross-compile` 创建一个用于二进制可执行文件的项目，并使用 VS Code 打开文件夹。
- en: 'Open `src/main.rs` and replace the default with the following:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/main.rs` 并将默认内容替换为以下内容：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use `cargo run` to see if it works and what architecture you are on:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo run` 来查看它是否工作以及你所在的架构：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s do some cross-compilation. First, install a tool called cross using
    `cargo install cross`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进行一些交叉编译。首先，使用 `cargo install cross` 安装一个名为 cross 的工具：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As mentioned in the `rust-cross` ([https://github.com/rust-embedded/cross](https://github.com/rust-embedded/cross))
    repository, start the Docker daemon to run a cross-build for `ARMv7`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如 `rust-cross` ([https://github.com/rust-embedded/cross](https://github.com/rust-embedded/cross))
    仓库中所述，启动 Docker 守护进程以运行 `ARMv7` 的交叉构建：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you have a Raspberry Pi 2 (or later), you can then run the binary there:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一台 Raspberry Pi 2（或更高版本），你可以在那里运行二进制文件：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, how does `rust-cross` compile the code? Why use Docker? Let's look at how
    it works.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`rust-cross` 是如何编译代码的？为什么使用 Docker？让我们看看它是如何工作的。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we are creating a simple binary (*step 1* and *step 2*) with
    a conditional compilation that matches the target architecture in order to see
    if it worked. *Step 3* should show your architecture (typically `x64` or `x86_64`);
    we install the cross-compilation toolkit in *step 4* to try and get it to run
    on a Raspberry Pi 2 and above (*step 5*). After compiling the binary, we transfer
    it to the device (ARM binaries won't work on `x86_64` instruction sets) for execution
    (*step 6*).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们正在创建一个简单的二进制文件（*步骤 1* 和 *步骤 2*），它具有条件编译以匹配目标架构，以便查看它是否工作。*步骤 3* 应该显示你的架构（通常是
    `x64` 或 `x86_64`）；我们在 *步骤 4* 中安装交叉编译工具包，尝试在 Raspberry Pi 2 及以上版本上运行（*步骤 5*）。编译二进制文件后，我们将它传输到设备（ARM
    二进制文件在 `x86_64` 指令集上无法运行）以执行（*步骤 6*）。
- en: QEMU, a popular virtualization framework, also supports emulating ARM instructions,
    so a device is not strictly required. Check out their wiki ([https://wiki.qemu.org/Documentation/Platforms/ARM](https://wiki.qemu.org/Documentation/Platforms/ARM))
    to learn more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU，一个流行的虚拟化框架，也支持模拟 ARM 指令，因此不需要严格的要求。查看他们的维基百科（[https://wiki.qemu.org/Documentation/Platforms/ARM](https://wiki.qemu.org/Documentation/Platforms/ARM)）以了解更多信息。
- en: Keep reading if you are interested in more details about cross-compiling an
    application. If not, feel free to move on to the next recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣了解更多关于交叉编译应用程序的细节，请继续阅读。如果不感兴趣，请随意跳到下一个菜谱。
- en: There's more...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Cross-compilation is a very specific process where all of the following have
    to fit together:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译是一个非常具体的过程，其中以下所有内容都必须匹配：
- en: CPU instruction set, that is, assembler instructions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU指令集，即汇编指令
- en: Compatible libraries for linking (for example, the standard library)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于链接的兼容库（例如，标准库）
- en: Binary layout
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制布局
- en: Compatible toolchains (compiler, linker)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容的工具链（编译器、链接器）
- en: Thanks to LLVM's architecture and the GNU compiler collection, we do not need
    to worry much about the CPU instruction set since it is largely provided by default,
    which is also the reason why it's tricky to run on Windows. As we have seen in
    many recipes in [Chapter 7](ccc55197-effc-4a8a-833f-c8a5607d06d5.xhtml), *Integrating
    Rust with Other Languages*, Windows and macOS use different toolchains, which
    makes compiling for other CPU instruction sets trickier. Our feeling is that it's
    easier to work smoothly in a virtualized environment these days instead of setting
    everything up locally.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了LLVM的架构和GNU编译器集合，我们不必过多担心CPU指令集，因为它大部分默认提供，这也是为什么它在Windows上运行有些棘手的原因。正如我们在第7章中看到的许多配方中，*将Rust与其他语言集成*，Windows和macOS使用不同的工具链，这使得为其他CPU指令集编译变得更加困难。我们的感觉是，如今在虚拟化环境中工作比在本地设置一切要容易得多。
- en: If you are using Fedora or any other SELinux-enabled distribution, the cross-build
    may fail with a permission error. Right now, the solution is to disable SELinux
    (`sudo setenforce 0`), but a fix is underway ([https://github.com/rust-embedded/cross/issues/112](https://github.com/rust-embedded/cross/issues/112)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Fedora或任何其他启用了SELinux的分发版，交叉构建可能会因为权限错误而失败。目前，解决方案是禁用SELinux（`sudo setenforce
    0`），但修复正在进行中 ([https://github.com/rust-embedded/cross/issues/112](https://github.com/rust-embedded/cross/issues/112))）。
- en: Considering the target toolchain, `rustup` allows us to quickly install other
    targets (`rustup target add armv7-unknown-linux-gnueabihf`), yet some other aspects
    (for example, the C standard library ([https://www.gnu.org/software/libc/](https://www.gnu.org/software/libc/)))
    still need to be natively installed. Along with the number of targets available,
    managing the number of native libraries is going to be a full-time job (we are
    disregarding the various library versions entirely here).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到目标工具链，`rustup` 允许我们快速安装其他目标（例如，`rustup target add armv7-unknown-linux-gnueabihf`），然而一些其他方面（例如，C标准库
    ([https://www.gnu.org/software/libc/](https://www.gnu.org/software/libc/)))）仍然需要本地安装。随着可用目标数量的增加，管理本地库的数量将变成一项全职工作（在这里我们完全不考虑各种库版本）。
- en: In an effort to contain these dependencies, versions, and more, `rust-cross`
    ([https://github.com/rust-embedded/cross#usage](https://github.com/rust-embedded/cross#usage)) (and others
    ([https://github.com/dlecan/rust-crosscompiler-arm](https://github.com/dlecan/rust-crosscompiler-arm))),
    use Docker containers that come prepared with a basic set of libraries. Typically,
    these containers can be customized ([https://github.com/rust-embedded/cross#custom-docker-images](https://github.com/rust-embedded/cross#custom-docker-images)) to
    add any certificates, configurations, libraries, and more you need for your use
    case.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制这些依赖项、版本以及更多内容，`rust-cross` ([https://github.com/rust-embedded/cross#usage](https://github.com/rust-embedded/cross#usage))（以及其他
    ([https://github.com/dlecan/rust-crosscompiler-arm](https://github.com/dlecan/rust-crosscompiler-arm)))），使用预先准备了一套基本库的Docker容器。通常，这些容器可以定制
    ([https://github.com/rust-embedded/cross#custom-docker-images](https://github.com/rust-embedded/cross#custom-docker-images))，以添加任何你为你的用例所需的证书、配置、库等。
- en: Equipped with this knowledge, we can move on to the next recipe.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，我们可以继续下一个配方。
- en: Creating I2C device drivers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建I2C设备驱动程序
- en: Communicating with devices in Linux happens at different levels. The most basic
    layer of drivers is the kernel module. Among other things, these modules have
    unrestricted access to the operating system and, if necessary, provide access
    to users via interfaces such as block devices. This is where the I2C ([https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all)) driver
    offers the as `/dev/i2c-1` bus (for example) that you can write to and read from.
    Using Rust, we can use this interface to create a driver for a sensor device that
    is connected to that bus. Let's see how that works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中与设备通信发生在不同的层级。驱动程序最基本的一层是内核模块。这些模块除了其他功能外，对操作系统拥有无限制的访问权限，并在必要时通过如块设备等接口为用户提供访问权限。这就是
    I2C ([https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all))
    驱动程序提供 `as /dev/i2c-1` 总线（例如）的地方，您可以向其写入和从中读取。使用 Rust，我们可以使用这个接口为连接到该总线的传感器设备创建一个驱动程序。让我们看看它是如何工作的。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Device drivers can be implemented in a few steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序可以通过几个步骤实现：
- en: Create a binary project: `cargo new i2cdevice-drivers`
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个二进制项目：`cargo new i2cdevice-drivers`
- en: 'Open the folder in VS Code and add some code to the `src/main.rs` file to:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开文件夹，并将一些代码添加到 `src/main.rs` 文件中：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we are going to implement the actual sensor driver. Create a file named `src/sensor.rs` to
    implement all aspects of the sensor driver. Let''s start by setting up a few basics:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现实际的传感器驱动程序。创建一个名为 `src/sensor.rs` 的文件来实现传感器驱动程序的各个方面。让我们先设置一些基本内容：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we add a mock device that represents the bus system:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加一个模拟设备来表示总线系统：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we implement the actual sensor code that the user sees:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现用户实际看到的传感器代码：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to encapsulate the behavior of the sensor into a proper function,
    let''s implement the `Thermometer` trait we created at the top of `sensor.rs`.
    The way raw data is transformed into a usable temperature is typically stated
    in a manual or tech specification:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将传感器的行为封装到适当的函数中，让我们实现我们在 `sensor.rs` 顶部创建的 `Thermometer` 特性。将原始数据转换为可用的温度通常在手册或技术规范中说明：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also need to adapt the `Cargo.toml` configuration to add the random number
    generator crate:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要调整 `Cargo.toml` 配置以添加随机数生成器包：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As usual, we want to see the program in action. Use `cargo run` to see it printing
    what we pretend to be the temperature (stop it by pressing *Ctrl + C*):'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，我们想看到程序的实际运行情况。使用 `cargo run` 来查看它打印出我们假装的温度（通过按 *Ctrl + C* 停止）：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After implementing this, you are probably curious about why and how this works.
    Let's see.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实现之后，你可能想知道为什么以及它是如何工作的。让我们看看。
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we showed how to implement a very simple device driver that
    is available on a bus such as the I2C ([https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all)).
    Since the I2C is a comparatively sophisticated bus (which makes implementing drivers
    simpler), a driver implements a protocol for reading and write operations to assumed
    registers and encapsulates them in a nice API. In this recipe, we did not actually
    use an I2C bus crate to provide the `struct` device, since it would impact OS
    compatibility.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们展示了如何实现一个在总线（如 I2C ([https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all)））上可用的非常简单的设备驱动程序。由于
    I2C 是一个相对复杂的总线（这使得实现驱动程序变得简单），驱动程序实现了一个用于读取和写入操作的协议，并将它们封装在一个良好的 API 中。在这个菜谱中，我们没有实际使用
    I2C 总线包来提供 `struct` 设备，因为这会影响操作系统兼容性。
- en: In *step 2*, we create the main loop to read from the sensor in a very simplistic
    way (check the *Efficiently reading hardware sensors *recipe), using sleep to
    control reading speed. In a typical fashion, we instantiate the driver by creating
    the block device abstraction using the *nix path (`/dev/i2c-1`) and the device's
    hardware address (defined by the manufacturer).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们创建主循环以非常简单的方式从传感器读取（检查 *高效读取硬件传感器* 菜谱），使用睡眠来控制读取速度。按照典型方式，我们通过创建使用
    *nix 路径（`/dev/i2c-1`）和设备的硬件地址（由制造商定义）的块设备抽象来实例化驱动程序。
- en: 'In *step 3*, we add some constructs to make our lives easier and better structured:
    the `Thermometer` trait is good practice for bundling capabilities together if
    there are more devices or features on that sensor. Abstracting `Result` is a common
    strategy for reducing code verbosity.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们添加了一些构造来使我们的生活更轻松和更有结构：如果传感器上有更多设备或功能，`Thermometer` 特性是打包能力的良好实践。抽象
    `Result` 是减少代码冗余的常见策略。
- en: Only in *step 4* do we create a mock for the bus, providing a read and write
    function for single bytes. Since we are not actually reading from or writing to
    a bus, these functions read random numbers and write to nowhere. For an idea of
    how this is done in real life (for example, reading several bytes at once), check
    out the real `i2cdev` crate ([https://github.com/rust-embedded/rust-i2cdev](https://github.com/rust-embedded/rust-i2cdev)).
    So far, we have only gotten it to work on Linux, however.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在*第4步*中，我们为总线创建了一个模拟，提供了对单个字节的读写功能。由于我们实际上并没有从总线读取或写入，这些函数读取随机数并将它们写入无处。为了了解这在现实生活中是如何完成的（例如，一次读取多个字节），请查看真实的`i2cdev`
    crate ([https://github.com/rust-embedded/rust-i2cdev](https://github.com/rust-embedded/rust-i2cdev))）。到目前为止，我们只让它在工作在Linux上，然而。
- en: '*Step 5* creates the abstraction API. Whenever we implement a driver from scratch,
    we are communicating with the device by writing specific binary commands into
    predefined registers. This could be to change the power state of the device, to
    change the sampling rate, or to ask for a particular measurement (if the device
    has multiple sensors and triggers hardware processes on the actual device). After
    this write operation, we can then read a specified data registry (all of the addresses
    and values can be found in the device''s specification) to transform the value
    into something usable (such as °C). This involves things such as shifting bits
    around, reading several calibration registries, and multiplying with overflows.
    Any such process varies from sensor to sensor. For a real-life example, check
    out the `bmp085` device driver ([https://github.com/celaus/rust-bmp085](https://github.com/celaus/rust-bmp085)),
    which shows a real-world driver implementation in Rust, and watch a talk on the
    driver at the following URL: [https://www.youtube.com/watch?v=VMaKQ8_y_6s](https://www.youtube.com/watch?v=VMaKQ8_y_6s).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*第5步*创建抽象API。每次我们从零开始实现驱动程序时，我们都是通过将特定的二进制命令写入预定义的寄存器来与设备通信。这可能是为了改变设备的状态，改变采样率，或者请求特定的测量（如果设备有多个传感器，并在实际设备上触发硬件过程）。在这项写入操作之后，我们可以读取指定的数据寄存器（所有地址和值都可以在设备的规范中找到），将值转换为可用的东西（如°C）。这涉及到像移位位、读取几个校准寄存器以及乘以溢出等事情。这样的过程因传感器而异。对于现实生活中的例子，请查看`bmp085`设备驱动程序([https://github.com/celaus/rust-bmp085](https://github.com/celaus/rust-bmp085))，它展示了在Rust中的实际驱动程序实现，并观看以下URL上的驱动程序演讲：[https://www.youtube.com/watch?v=VMaKQ8_y_6s](https://www.youtube.com/watch?v=VMaKQ8_y_6s)。'
- en: The following step then shows implementing and getting the actual temperature
    from the device and creating a usable number from the random number the raw device
    mock provides. This should be a simplification of what is typically done with
    raw values to get them into a usable form.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤展示了如何实现并从设备获取实际温度，并从原始设备模拟提供的随机数创建一个可用的数字。这应该是对通常如何使用原始值以将其转换为可用形式的简化。
- en: In the last step, we then see how it works and verify that the temperatures
    is generally spread nicely in realistic values, although with a frightening rate
    of change.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们看到它是如何工作的，并验证温度在现实值中通常分布得很好，尽管变化率令人恐惧。
- en: Let's move on and find out how we can read these sensor values more efficiently
    than with a pure loop.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看我们如何能比使用纯循环更有效地读取这些传感器值。
- en: Efficiently reading hardware sensors
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效读取硬件传感器
- en: Creating efficient I/O-based applications is tricky—they have to provide exclusive
    access to a resource as quickly as possible and as often as required. It's a resource
    scheduling problem. The basis of solving this type of problem is to handle and
    queue requests, as with reading a sensor value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于I/O的应用程序很棘手——它们必须尽可能快地、尽可能频繁地提供对资源的独占访问。这是一个资源调度问题。解决这类问题的基本方法是处理和排队请求，就像读取传感器值一样。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can use I/O loops to read things efficiently in a few steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用I/O循环在几个步骤中高效地读取事物：
- en: 'Create a binary project: `cargo new reading-hardware`.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个二进制项目：`cargo new reading-hardware`。
- en: 'Open the folder in VS Code and create a `src/sensor.rs` file to add the code
    from the *Creating I2C device drivers* recipe:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开文件夹，创建一个`src/sensor.rs`文件来添加来自*创建I2C设备驱动程序*菜谱的代码：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Typically, a raw device abstraction is provided by the hardware protocol drivers
    used. In our case, we mock up such a type:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，原始设备抽象由硬件协议驱动程序提供。在我们的例子中，我们模拟了这样一个类型：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For proper encapsulation, it''s a good idea to create a `struct` that wraps
    the raw device:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了适当的封装，创建一个`struct`来包装原始设备是个好主意：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the implementation of the `Thermometer` trait:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是对 `Thermometer` 特性的实现：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now open `src/main.rs` and replace the default with something more interesting.
    Let''s start with imports and helper functions:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `src/main.rs` 并将默认内容替换为更有趣的内容。让我们从导入和辅助函数开始：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we''ll add the actual event loop and the `main` function:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加实际的事件循环和 `main` 函数：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For this to work, we should add some dependencies to `Cargo.toml`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这成为可能，我们应该在 `Cargo.toml` 中添加一些依赖项：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to finish up the recipe, we also want to see it run and print out
    some mock readings:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成菜谱，我们还希望看到它运行并打印出一些模拟的读数：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Great! Let's see how this works.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！让我们看看这是如何工作的。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Instead of the naive busy waiting loop we created in the *Creating I2C device
    drivers* recipe, we now use a `tokio-rs` stream (effectively an asynchronous iterator)
    of events on which we can register a handler. Let's see how this more efficient
    structure is implemented.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在 *创建 I2C 设备驱动程序* 菜谱中创建的简单忙等待循环不同，我们现在使用一个 `tokio-rs` 事件流（实际上是一个异步迭代器），我们可以在其上注册一个处理程序。让我们看看这个更有效的结构是如何实现的。
- en: First, in *step 2*, we recreate the sensor code from the *Creating I2C device
    drivers* recipe in order to have a sensor to use. In short, the code simulates
    an I2C-connected temperature sensor with a random number generator to show how
    a bus-connected device driver operates.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 *步骤 2* 中，我们重新创建了 *创建 I2C 设备驱动程序* 菜谱中的传感器代码，以便有一个可用的传感器。简而言之，该代码通过随机数生成器模拟了一个连接到
    I2C 的温度传感器，以展示总线连接的设备驱动程序是如何工作的。
- en: In *step 3*, we are preparing to use the driver to read a value and send it
    to a worker thread using a channel. Therefore, we create a `Reading` struct that
    saves a sensor reading at a certain timestamp. Only in *step 4* do we create the
    `tokio-rs` task runner and a stream. This stream is a construct that represents
    an iterator over asynchronous events that need to be handled. Each event corresponds
    to a timed interval every second, starting now (`Instant::now()`), and since we
    don't want to run forever in this recipe, we limit the number of events to five
    (`.take(5)`)—just as we would with any other iterator. `tokio::run()` takes this
    stream and starts executing the events on its event loop and thread pool, and
    blocks while there is something to execute.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们正在准备使用驱动程序读取一个值并将其通过通道发送到工作线程。因此，我们创建了一个 `Reading` 结构体，它保存了在某个时间戳的传感器读数。只有在
    *步骤 4* 中，我们才创建 `tokio-rs` 任务运行器和流。这个流是一个表示需要处理的异步事件的迭代器的构造。每个事件对应于每秒一个定时间隔，从现在开始（`Instant::now()`），由于我们不想在这个菜谱中无限期运行，所以我们限制事件的数量为五个（`.take(5)`）——就像我们处理任何其他迭代器一样。`tokio::run()`
    接收这个流，并在其事件循环和线程池上开始执行事件，并在有事件要执行时阻塞。
- en: In concurrent applications, the usage of something like `std::thread::sleep`
    is considered an anti-pattern. Why? Because it prevents the entire thread from
    doing *anything* while it is sleeping. In fact, the thread pauses and the OS's
    CPU scheduler context-switches to do some other stuff. Only after *at least* the
    specified time does the scheduler rotate the thread back into active mode to continue
    working. Drivers sometimes require some waiting time (several milliseconds to
    do the measuring), and `sleep` is typically used. Since devices can only be accessed
    from a single thread, `sleep()` is appropriate here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发应用程序中，使用类似 `std::thread::sleep` 的做法被认为是一种反模式。为什么？因为它阻止了整个线程在睡眠期间做任何事。实际上，线程暂停，操作系统的CPU调度器会进行上下文切换以执行其他任务。只有在指定时间至少过去之后，调度器才会将线程转回活动模式以继续工作。驱动程序有时需要一些等待时间（几毫秒进行测量），这时通常会使用
    `sleep`。由于设备只能从单个线程访问，因此在这里使用 `sleep()` 是合适的。
- en: 'The `for_each` closure implements the handler for each event and receives an
    `Instant` instance as a parameter. Inside the closure, we read from the sensor
    and send it through a channel ([https://doc.rust-lang.org/std/sync/mpsc/](https://doc.rust-lang.org/std/sync/mpsc/)) to
    a receiving thread that we created earlier—a pattern that we saw in [Chapter 4](eb7f566a-00ca-4e6c-bc05-4e9d00bf8c56.xhtml), *Fearless
    Concurrency*. While we could process the data right away in the handler, pushing
    it into a queue for processing enables us to create batches and minimize the stream
    delay. This is especially important when the potential required time to finish
    processing is unknown, very large (that is, it comprises web requests or other
    moving parts), or requires extensive error handling (such as exponential backoff
    ([https://docs.microsoft.com/en-us/azure/architecture/patterns/retry](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry))).
    This will not only separate concerns and make maintenance easier, it also allows
    us to execute the reading operation more precisely. To visualize this, let''s
    look at the big picture for *step 4*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`for_each`闭包实现了每个事件的处理器，并接收一个`Instant`实例作为参数。在闭包内部，我们从传感器读取数据并通过通道([https://doc.rust-lang.org/std/sync/mpsc/](https://doc.rust-lang.org/std/sync/mpsc/))发送到我们之前创建的接收线程——这是我们在[第4章](eb7f566a-00ca-4e6c-bc05-4e9d00bf8c56.xhtml)中看到的模式，“无畏并发”。虽然我们可以在处理器中立即处理数据，但将其推入队列进行处理使我们能够创建批次并最小化流延迟。这在需要完成处理所需时间未知、非常大（即包括Web请求或其他移动部件）或需要大量错误处理（如指数退避([https://docs.microsoft.com/en-us/azure/architecture/patterns/retry](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry)))的情况下尤为重要。这不仅可以将关注点分离并简化维护，还允许我们更精确地执行读取操作。为了可视化这一点，让我们看看*步骤4*的整体图景：'
- en: '![](img/60ed9da9-0221-48e2-bcbe-1a2896c84324.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60ed9da9-0221-48e2-bcbe-1a2896c84324.png)'
- en: In *step 5*, we add the required dependencies, and *step 6* shows the output—take
    note of the timestamp to see it really does fire every second and the stream is
    processed in the order they appear.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们添加所需的依赖项，而*步骤6*显示了输出——注意时间戳以确认它确实每秒触发一次，并且流按出现的顺序进行处理。
- en: This concludes our in-depth journey into device drivers; if this was your first
    foray into the field, you have now learned about de-coupling reading sensor data
    from processing it; how device drivers are built in the first place; and, once
    ready, how to get them onto the desired device. In the next chapter, we return
    to a higher level of abstraction and work on more practical recipes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对设备驱动程序的深入探索的结束；如果这是你第一次涉足这个领域，你现在已经了解了如何解耦读取传感器数据与处理它；设备驱动程序最初是如何构建的；一旦准备就绪，如何将它们部署到目标设备上。在下一章中，我们将回到更高的抽象层次，并专注于更实用的食谱。
