- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章
- en: '**What are traits and how are they different from interfaces?**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是特性，它们与接口有何不同？**'
- en: Traits are pieces of functionality shared across components. They can contain
    code as well as associated types, and can be implemented for any type and generics
    independently. Interfaces, on the other hand, describe the public methods a class
    provides, without an implementation and typically with inheritance. Rust only
    has traits.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 特性是跨组件共享的功能块。它们可以包含代码以及关联类型，并且可以为任何类型和泛型独立实现。另一方面，接口描述了一个类提供的公共方法，没有实现，通常带有继承。Rust
    只有特性。
- en: '**Why doesn''t Rust have a garbage collector?**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么 Rust 没有垃圾回收器？**'
- en: Garbage collection is required to free up unused heap memory that is generated
    from a running the program. Rust avoids this by providing a static code analysis
    at compile-time that forces the user to think of variable lifetimes. These lifetimes
    are very strictly defined and require a lifetime scope to own or borrow memory
    so that the compiler knows when it's not being used without an explicit statement.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是释放由程序运行生成的未使用堆内存所必需的。Rust 通过在编译时提供静态代码分析来避免这一点，这迫使用户思考变量的生命周期。这些生命周期定义得非常严格，并且需要生命周期作用域来拥有或借用内存，以便编译器知道何时没有使用到它们，而不需要显式声明。
- en: '**Name three examples of how lifetimes are created in Rust (explicitly and**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**请列举 Rust 中创建生命周期（显式和隐式）的三个例子**'
- en: '**implicitly)!**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式地！**'
- en: 'Any three that you can come up with are great, but here are mine: Functions,
    scopes (simply create one using `{}`), and closures (lambda functions).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到的任何三个都是很好的，但这里是我的：函数、作用域（只需使用 `{}` 创建一个），以及闭包（lambda 函数）。
- en: '**Why is immutability for variables important?**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么变量的不可变性很重要？**'
- en: It guarantees that only read operations take place, thereby avoiding any side
    effects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它保证只进行读取操作，从而避免任何副作用。
- en: '**What does the Sync marker trait do?**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步标记特性有什么作用？**'
- en: It marks a structure as safe to access from multiple threads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它将一个结构标记为可以从多个线程安全访问。
- en: '**Where can you go to participate in the Rust community?**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**你可以在哪里参与 Rust 社区？**'
- en: Go to [https://github.com/rust-lang](https://github.com/rust-lang) (opening
    issues, submitting code, discussions, and so on) or [www.rust-lang.org/community](https://www.rust-lang.org/community),
    where all the current community resources (such as the forum and chats) are kept.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://github.com/rust-lang](https://github.com/rust-lang)（打开问题、提交代码、讨论等）或
    [www.rust-lang.org/community](https://www.rust-lang.org/community)，那里保存了所有当前社区资源（如论坛和聊天）。
- en: '**Why are RFCs preferred over PRs?**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么 RFC 比 PR 更受欢迎？**'
- en: To contribute changes to the Rust programming language, `cargo`, or `crates.io`,
    the traditional fork-then-change-and-PR (pull request) won't work (especially
    if there are major changes). RFCs are the formal process required for substantial
    changes to either of the three projects and allow the wider community to discuss
    and evaluate the proposed changes, as well as contribute to them. This is the
    Rust community's effort to effectively govern something as fundamental as a programming
    language.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 Rust 编程语言、`cargo` 或 `crates.io` 贡献更改，传统的“分叉-更改-PR（pull request）”方法不会工作（特别是如果存在重大更改）。RFC
    是对这三个项目中的任何一个进行重大更改所需的正式流程，并允许更广泛的社区讨论和评估所提出的更改，以及为它们做出贡献。这是 Rust 社区为有效地管理像编程语言这样基本的东西所做的努力。
- en: Chapter 2
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章
- en: '**What does cargo do?**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**cargo 做什么？**'
- en: Read and write access to repositories, run tests, dependency management (download,
    update, and managing the dependency tree), executing the build process, and providing
    a central interface for additional tooling.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对仓库的读写访问、运行测试、依赖管理（下载、更新和管理依赖树）、执行构建过程，以及提供用于额外工具的中心接口。
- en: '**Does cargo provide linting support?**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**cargo 提供了 linting 支持吗？**'
- en: '`cargo` itself doesn''t, but there are additional tools, such as `clippy` ([https://github.com/rust-lang/rust-clippy](https://github.com/rust-lang/rust-clippy)),
    that work seamlessly with `cargo`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo` 本身不做，但有额外的工具，如 `clippy` ([https://github.com/rust-lang/rust-clippy](https://github.com/rust-lang/rust-clippy))，它们可以无缝地与
    `cargo` 一起工作。'
- en: '**In which cases is the Cargo.lock file important to publish?**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**在哪些情况下，Cargo.lock 文件对发布很重要？**'
- en: For libraries. The file is used by cargo to determine the exact versions of
    the dependency tree. As a consequence, there should not be any version issues
    caused by unintentionally updated dependencies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于库。该文件由 cargo 用于确定依赖树的精确版本。因此，不应由于意外更新依赖项而产生任何版本问题。
- en: '**What are the requirements to publish to crates.io?**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布到crates.io需要满足哪些要求？**'
- en: Passing tests, no uncommitted files in the repository, a valid account, and
    an available spot on `crates.io`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试，仓库中没有未提交的文件，拥有有效的账户，以及`crates.io`上的可用位置。
- en: '**What is Wasm and why should you care?**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wasm是什么？为什么你应该关心它？**'
- en: Wasm is a compilation target that can be executed in traditional JavaScript
    environments, such as browsers or the Node runtime. This skips the compilation
    steps required for JavaScript as well as its garbage collection, so Wasm binaries
    are better suited for (near-) real-time applications with a browser UI component.
    They can be simply run in the JavaScript world.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm是一个编译目标，可以在传统的JavaScript环境中执行，例如浏览器或Node运行时。这跳过了JavaScript及其垃圾回收所需的编译步骤，因此Wasm二进制文件更适合具有浏览器UI组件的（近）实时应用程序。它们可以在JavaScript世界中简单地运行。
- en: '**How are tests organized in a Rust project?**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rust项目中测试是如何组织的？**'
- en: Tests can either be added to each file in a module, annotated by `#[tests]`
    and `#[test]`, as well as `#[bench]`. These can also be placed into their own
    file structure under `test/` in the component's directory. Additionally, Rust
    supports doctests, which are executed when the docstring (`///`) has an example
    section that contains code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以添加到模块中的每个文件，通过`#[tests]`和`#[test]`以及`#[bench]`进行注释。这些也可以放置在组件目录下的`test/`中的自己的文件结构中。此外，Rust支持doctests，当docstring（`///`）包含包含代码的示例部分时，它们会被执行。
- en: Chapter 3
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章
- en: '**How are Sized types different from other types?**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sized类型与其他类型有何不同？**'
- en: Sized means that the size of a type instance is known at runtime, so it doesn't
    contain a growing data type. For example, `str` is typically not a sized type – `String`
    is.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大小意味着类型实例的大小在运行时已知，因此它不包含增长的数据类型。例如，`str`通常不是一个大小类型——`String`是。
- en: '**How does Clone differ from Copy?**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clone与Copy有何区别？**'
- en: Clone is an explicit call to the `clone()` function; copy happens implicitly,
    for example, at assignments. Since Clone is explicitly called, it usually does
    a deep copy on the underlying data structure.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Clone是对`clone()`函数的显式调用；复制是隐式的，例如在赋值时发生。由于Clone是显式调用的，它通常在底层数据结构上执行深拷贝。
- en: '**What are the main drawbacks of immutable data structures?**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变数据结构的主要缺点是什么？**'
- en: Immutable data structures can have worse absolute performances since they can't
    use the optimizations that regular data structures provide. Additionally, updates
    on the data that's contained is impossible, making it a very inefficient choice
    for constantly changing data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构可能具有较差的绝对性能，因为它们不能使用常规数据结构提供的优化。此外，对包含的数据的更新是不可能的，这使得它对于不断变化的数据是一个非常低效的选择。
- en: '**How can applications benefit from immutable data structures?**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序如何从不可变数据结构中受益？**'
- en: They implicitly keep track of changes and work well across threads without side
    effects or the need for locking.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它们隐式地跟踪更改，并且在没有副作用或锁定需求的情况下跨线程工作得很好。
- en: '**Think about an immutable list that you want to work on—how would you ****distribute
    it across multiple threads?**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑一个你想要工作的不可变列表——你将如何将其** ****分配到多个线程中？**'
- en: Depending on the task, it can be split into *n* chunks, where *n* is the number
    of threads. However, this requires you to create *n* copies of the list—or at
    least a move per each. Alternatively, the list can be made accessible across threads,
    providing only the indices to represent the chunks to work on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据任务，它可以分成*n*个块，其中*n*是线程的数量。然而，这需要你创建列表的*n*个副本——或者至少每个副本至少移动一次。或者，列表可以跨线程访问，只提供索引来表示要工作的块。
- en: Chapter 4
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: '**Why is a linked list tricky to implement in Rust?**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么在Rust中实现链表很棘手？**'
- en: Rust's ownership principle makes it hard to implement non-hierarchical structures,
    such as the doubly-linked list. There, it's unclear which node owns which area
    of the memory, since both neighbors hold a reference that can't be invalid.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的所有权原则使得实现非层次结构，如双链表变得困难。在那里，不清楚哪个节点拥有内存的哪个区域，因为邻居都持有无法无效的引用。
- en: '**How does Rust''s standard library, LinkedList<T>, work?**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rust的标准库LinkedList<T>是如何工作的？**'
- en: 'It''s a doubly-linked list: individual nodes are interlinked, just like the
    implementation in this chapter.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个双链表：单个节点相互连接，就像本章中的实现一样。
- en: '**What is the difference between a doubly-linked list and a skip list?**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**双链表与跳表有什么区别？**'
- en: A skip list has multiple levels where nodes are linked together to achieve a
    tree-like search performance. Therefore, the skip list has to be ordered and stores
    multiple pointers to successors and predecessors. The doubly-linked list has only
    two links (forward and backward), doesn't need to be sorted, and achieves linear
    search performance at best.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表有多个层级，节点通过链接在一起以实现类似树状搜索的性能。因此，跳表必须是有序的，并存储多个指向后继和前驱的指针。双链表只有两个链接（前向和后向），不需要排序，并且在最佳情况下实现线性搜索性能。
- en: '**Does a dynamic array outperform a skip list for element access?**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态数组在元素访问方面是否优于跳表？**'
- en: Yes, if the skip list doesn't use a dynamic array as a base!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，如果跳表不使用动态数组作为基础的话！
- en: '**Why is a dynamic array a great choice for CPU caching?**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么动态数组是CPU缓存的绝佳选择？**'
- en: The data is stored in a large continuous portion of the memory, with the elements
    stored one after the other. Caching always builds on blocks of memory, which is
    why caching several elements that are likely processed after each other makes
    the dynamic array well-suited for that.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储在内存的一个大连续部分中，元素一个接一个地存储。缓存始终建立在内存块上，这就是为什么缓存几个可能依次处理的元素使动态数组非常适合这一点。
- en: '**What is another growth strategy for dynamic arrays?**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态数组还有另一种增长策略吗？**'
- en: Memory can be doubled, increased by a certain amount each time, or logarithmically
    so that it grows fast in the beginning and slows down later on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 内存可以加倍，每次增加一定量，或者以对数方式增长，这样在开始时增长快，后来变慢。
- en: '**Rust takes arrays seriously, so what does the dynamic array use internally?**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rust认真对待数组，那么动态数组内部使用什么？**'
- en: It uses a boxed slice.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一个带框的切片。
- en: Chapter 5
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: '**How does a binary search tree skip several nodes when searching?**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉搜索树在搜索时如何跳过多个节点？**'
- en: By following one branch, it skips one subtree every time the decision for one
    branch is made. A subtree can be anything from a single node to all nodes except
    one.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过跟随一个分支，每次做出一个分支的决定时，它就会跳过一个子树。子树可以是单个节点，也可以是除了一个节点之外的所有节点。
- en: '**What are self-balancing trees?**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是自平衡树？**'
- en: Trees that use some kind of logic to (roughly) equalize the number of nodes
    in each subtree. This ensures that all tree algorithms work at the best possible
    efficiency.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用某种逻辑来（大致）平衡每个子树中节点数量的树。这确保了所有树算法都以最佳可能的效率工作。
- en: '**Why is balance in a tree important?**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么树中的平衡很重要？**'
- en: If a tree is skewed, any algorithm operating on it will encounter an uneven
    amount of work depending on the subtree it works on. The mismatch is the assumption
    that every branch of the tree leads to the same amount of work (for example, the
    same number of comparisons to make), which is what makes the tree data structure
    efficient.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树是倾斜的，任何在其上操作的算法都会遇到根据它操作的子树而不同量的工作。这种不匹配是假设树的每个分支都会导致相同量的工作（例如，进行相同数量的比较），这就是为什么树数据结构是高效的。
- en: '**Is a heap a binary tree?**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆是不是二叉树？**'
- en: Yes. Each node has two children.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。每个节点有两个子节点。
- en: '**What are good use cases for tries?**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**tries有哪些好的应用场景？**'
- en: 'Here are mine: A trie set is a very efficient data structure for guaranteeing
    uniqueness, there are sequence prediction methods based on tries, and they can
    do a lossless data compression.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的：一个trie集合是保证唯一性的非常高效的数据结构，有基于tries的序列预测方法，它们可以进行无损数据压缩。
- en: '**What is a B-Tree?**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是B-树？**'
- en: 'A B-Tree is a tree with a defined level that relates to the number of children
    in each node. Thus, it is a self-balancing generalization of all trees: a level
    2 B-Tree is akin to a binary tree, but more children will make the data structure
    more efficient and avoid unnecessary heights.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: B-树是一种具有定义级别的树，该级别与每个节点中的子节点数量相关。因此，它是所有树的自我平衡泛化：一个级别2的B-树类似于二叉树，但更多的子节点会使数据结构更高效，并避免不必要的层数。
- en: '**What are the fundamental components of a graph?**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**图的基本组成部分是什么？**'
- en: Graphs are nodes that are connected with edges. These nodes typically have a
    value; the value on the edges is referred to as weights. In a general graph, there
    are no directions on the edges, but further constraints can make it directed,
    acyclic, or otherwise limited. Graphs are the superstructure of all lists and
    trees.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图是通过边连接的节点。这些节点通常具有值；边上的值被称为权重。在一般图中，边没有方向，但进一步的约束可以使它有向、无环或有限制。图是所有列表和树的超结构。
- en: Chapter 6
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: '**What makes a good hash function?**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么使一个好的哈希函数？**'
- en: It depends on the use case. Cryptography should minimize collisions, message
    digests should maximize hash differences on minor input differences, and bloom
    filters should do the reverse.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于用例。密码学应最小化冲突，消息摘要应最大化在微小输入差异上的哈希差异，而布隆过滤器应做相反的事情。
- en: '**How can you estimate the suitability of a hash function for a particular
    task?**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何估计哈希函数对特定任务的适用性？**'
- en: By using plots and tests to get a sense of how the output hashes are distributed
    and whether that's what you're looking for. Histograms and scatter plots work
    well to see the distribution of values. Also, search the internet for potential
    breaches or weaknesses and the original paper.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用图表和测试来了解输出哈希的分布情况以及是否是你所寻找的。直方图和散点图可以很好地显示值的分布。此外，在网上搜索潜在的漏洞或弱点以及原始论文。
- en: '**Is a checksum hash useful in other ways?**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**校验和哈希在其他方面有用吗？**'
- en: They can also be useful to determine whether two texts or files are equal, which
    can be used for finding matches quickly or to check whether the content is the
    content that was transferred or whether the content has been tampered with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还可以用来确定两个文本或文件是否相等，这可以用于快速查找匹配项或检查内容是否是传输的内容，或者内容是否已被篡改。
- en: '**What are two ways to implement a map?**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现映射有两种方式吗？**'
- en: Using trees or using hashing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用树或使用哈希。
- en: '**What are buckets?**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是桶？**'
- en: Buckets are the hash values that are mapped onto the underlying data structure.
    Hashes might output `u64`, but `Vec<T>` only has a length of 100\. Therefore,
    multiple hashes share an index in `Vec<T>`, which is called a bucket.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 桶是映射到底层数据结构的哈希值。哈希可能输出`u64`，但`Vec<T>`的长度只有100。因此，多个哈希共享`Vec<T>`中的一个索引，这被称为桶。
- en: '**Can a set replace a list? **'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合能否替代列表？**'
- en: Only if uniqueness is a required constraint for the contents.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当唯一性是内容所需约束时。
- en: '**What makes a set useful?**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么使集合有用？**'
- en: Quick and specialized set operations, such as union, intersect, difference,
    and fast "contains" lookups, as well as the ability to guarantee uniqueness with
    better efficiency.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 快速且专业的集合操作，例如并集、交集、差集和快速的“包含”查找，以及以更好的效率保证唯一性的能力。
- en: Chapter 7
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: '**Which std::collections data structure is not discussed here?**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**这里没有讨论哪个std::collections数据结构？**'
- en: '`BinaryHeap` ([https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html](https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html)).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryHeap` ([https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html](https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html)).'
- en: '**How does Vec<T> or VecDeque<T> grow, as of 2018?**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**截至2018年，Vec<T>或VecDeque<T>是如何增长的？**'
- en: They double (or more) their size when more space is required.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要更多空间时，它们会加倍（或更多）其大小。
- en: '**Is LinkedList<T> a good default data structure?**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**LinkedList<T>是一个好的默认数据结构吗？**'
- en: No. It doesn't provide index access and is generally slower than `Vec<T>`, thanks
    to the internal memory structure, but provides the same basic features.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不。它不提供索引访问，并且由于内部内存结构，通常比`Vec<T>`慢，但提供相同的基本功能。
- en: '**What hashing implementation does the 2018 HashMap<T> use by default?**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**2018年的HashMap<T>默认使用哪种哈希实现？**'
- en: SipHashing. There are others that are on their way into the standard library,
    such as the `hashbrown` crate ([https://github.com/Amanieu/hashbrown](https://github.com/Amanieu/hashbrown)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: SipHashing。还有其他一些正在进入标准库，例如`hashbrown` crate ([https://github.com/Amanieu/hashbrown](https://github.com/Amanieu/hashbrown))。
- en: '**What are three benefits of BTreeMap<T> over HashMap<T>?**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**BTreeMap<T>相对于HashMap<T>有哪些三个优点？**'
- en: 'Use any three, but here are some suggestions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任意三个，但这里有一些建议：
- en: Ordered keys
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序键
- en: Lower computational intensity (no hashing required)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较低的计算强度（不需要哈希）
- en: No hash function required—good performance regardless
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要哈希函数——无论何种情况都有良好的性能
- en: '**I****s the internal tree of BTreeMap<T> wider or higher?**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**BTreeMap<T>的内部树是更宽还是更高？**'
- en: Wider, thanks to a larger number of children (up to *2 * level - 1*) for efficient
    CPU caching.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更宽，因为有更多的子节点（最多*2*级 - 1），这有助于高效的CPU缓存。
- en: Chapter 8
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: '**Why estimate runtime complexity over something such as the number of statements?**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么估计运行时复杂度要超过诸如语句数量之类的因素？**'
- en: Runtime complexity is more about the projected growth alongside the main input
    parameter. In a way, it *is* counting the number of statements and you would likely
    arrive at the same conclusion. The statements that are being counted are the subset
    that matters most.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间复杂度更多地关注与主要输入参数并行的预期增长。从某种意义上说，它确实是在计算语句的数量，你很可能会得出相同的结论。被计算出的语句是其中最重要的子集。
- en: '**How does runtime complexity relate to math functions?**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时间复杂度如何与数学函数相关？**'
- en: 'In two ways: mathematical functions can be described the same way as functions
    in programming, since they rest on the same fundamental construct; and math functions
    are used to express the runtime complexity itself, in particular the logarithmic
    and exponential functions.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式：数学函数可以像编程中的函数一样描述，因为它们建立在相同的基本构造上；并且数学函数用于表达运行时间复杂度本身，特别是对数和指数函数。
- en: '**Is the complexity class that is typically provided the best or worst case?**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**通常提供的复杂度类是最好或最坏的情况吗？**'
- en: The worst case, since this will be the slowest/most inefficient case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况，因为这将是速度最慢/效率最低的情况。
- en: '**Why are loops important in estimating complexity?**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么循环在估计复杂度时很重要？**'
- en: Loops are great constructs that repeatedly execute statements and, depending
    on the growth parameter, will drive the function's runtime complexity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是重复执行语句的强大构造，根据增长参数，将推动函数的运行时间复杂度。
- en: '**Is O(n log(n)) a better or worse runtime complexity than O(log(n))?**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**O(n log(n))的运行时间复杂度比O(log(n))好还是差？**'
- en: '*O(log(n))* is clearly a better runtime complexity. Try replacing the *n* with
    three numbers of your choice and calculate *log(n)* versus *n * log(n)*.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*O(log(n))*显然是更好的运行时间复杂度。试着用你选择的三个数字替换*n*，并计算*log(n)*与*n * log(n)*。'
- en: '**What are some common known complexity classes?**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些常见的已知复杂度类有哪些？**'
- en: '*O(n)*, *O(log(n)*, *O(n²)*, and *O(2^n)*.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*O(n)*, *O(log(n)*, *O(n²)*, 和 *O(2^n)*。'
- en: Chapter 9
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: '**What is information retrieval?**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是信息检索？**'
- en: All disciplines surrounding storage, search, ranking, tokenization, analysis,
    and a general understanding of an information structure. It's everything that
    a good search engine does well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有围绕存储、搜索、排名、标记化、分析和对信息结构的一般理解的相关学科。这是一切好的搜索引擎都能做得很好的事情。
- en: '**Do modern search engines and databases use simple search algorithms?**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**现代搜索引擎和数据库是否使用简单的搜索算法？**'
- en: Yes. Regardless of the abstraction on top of the search index, the storing of
    tokens is often done in a linear, append-only fashion that allows for efficient
    search (binary search) on these segments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。无论在搜索索引之上采用何种抽象，标记的存储通常是以线性、追加的方式进行的，这允许在这些段上进行高效的搜索（二分搜索）。
- en: '**Why does the linear search have O(n) runtime complexity?**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么线性搜索有O(n)的运行时间复杂度？**'
- en: In case an element doesn't exist in the sequence, it has to walk over all *n*
    items to be sure.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果序列中不存在元素，它必须遍历所有*n*个元素以确保。
- en: '**What does jump search do better than linear search?**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳跃查找比线性查找做得更好是什么？**'
- en: It skips parts of the list since, in an ordered list, certain locations can
    be ruled out based on the sorting. Therefore, it significantly reduces the number
    of elements that are searched for linearly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它跳过了列表的一部分，因为在有序列表中，可以根据排序规则排除某些位置。因此，它显著减少了线性搜索中要搜索的元素数量。
- en: '**What is binary search and why is it comparable to a tree?**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是二分查找以及为什么它和树形结构相似？**'
- en: Binary search splits the input sequence in half and only continues on the part
    that has to contain the element. Drawing these parts visually (including those
    that have been skipped) looks just like a binary tree, which is why the two parts
    are effectively branches.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索将输入序列分成两半，并且只继续包含该元素的半个部分。将这些部分可视化（包括那些被跳过的部分）看起来就像一棵二叉树，这就是为什么这两个部分实际上是分支一样。
- en: Chapter 10
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: '**Why is sorting an important aspect of programming?**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么排序是编程中的重要方面？**'
- en: Establishing a predictable order so that algorithms can make assumptions based
    on the content (for example, for search) will enable it to perform much better.
    Another important aspect is user experience in user interfaces, or to establish
    a semantic link between data points (for example, a time series can now have trends).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 建立可预测的顺序，以便算法可以根据内容（例如，搜索）做出假设，这将使其性能大大提高。另一个重要方面是用户界面中的用户体验，或者建立数据点之间的语义链接（例如，时间序列现在可以具有趋势）。
- en: '**What makes values bubble up in bubble sort?**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**冒泡排序中是什么使得值向上冒泡？**'
- en: By repeatedly swapping a pair of elements when going through the sequence, elements
    that belong on the opposite end (or close to it) will have to swap places with
    every other element on the way. Therefore, the large number "bubbles up."
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在遍历序列时反复交换一对元素，属于对立端（或接近它）的元素将不得不与其他每个元素交换位置。因此，较大的数字“冒泡”到上面。
- en: '**Why is shell sort useful?**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么希尔排序是有用的？**'
- en: It achieves solid sorting performances, yet it's not as complex as merge sort
    and uses less computational resources. This makes it great in scenarios where
    hardware can be bottlenecked (embedded devices) or other sorting approaches aren't
    available (for example, if the standard library is not supported).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它实现了稳定的排序性能，但不如归并排序复杂，使用的计算资源也更少。这使得它在硬件可能成为瓶颈（嵌入式设备）或没有其他排序方法可用（例如，如果标准库不受支持）的情况下非常出色。
- en: '**Can heap sort outperform bubble sort in its best case?**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆排序在其最佳情况下能否优于冒泡排序？**'
- en: No. Bubble sort's best case is simply iterating the list – *O(n)*. Heap sort,
    on the other hand, always has to build a heap, regardless of the sequence being
    already sorted or not – *O(n log n)*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不。冒泡排序的最佳情况仅仅是遍历列表 – *O(n)*。另一方面，堆排序始终需要构建一个堆，无论序列是否已经排序 – *O(n log n)*。
- en: '**What do merge sort and quicksort have in common?**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**归并排序和快速排序有什么共同点？**'
- en: 'The divide-and-conquer approach: both split the sequence into smaller pieces
    so that they can work on those separately.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 分而治之的方法：两者都将序列分割成更小的部分，以便它们可以分别处理。
- en: '**What are hybrid sorting algorithms?**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是混合排序算法？**'
- en: Hybrid sorting algorithms use the strengths of at least two different approaches.
    Timsort, for example, uses insertion sort for smaller sequences (for example,
    under 20 items) but merge sort for larger ones.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 混合排序算法使用至少两种不同方法的优势。例如，Timsort使用插入排序处理较小的序列（例如，小于20个项），但对于较大的序列则使用归并排序。
- en: Chapter 11
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: '**What is the difference between PRNGs and RNGs?**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRNGs 和 RNGs 之间的区别是什么？**'
- en: Pseudo-random number generators (PRNGs) use a process to generate a close-to-random
    sequence of numbers that are as statistically independent as possible. Random
    number generators (RNGs) try to use true randomness (for example, phenomena from
    the physical world that cannot be predicted) to generate random numbers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机数生成器（PRNGs）使用一个过程来生成尽可能统计独立的接近随机的数字序列。随机数生成器（RNGs）试图使用真正的随机性（例如，物理世界中无法预测的现象）来生成随机数。
- en: '**What crate provides random number generators in Rust?**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**哪个crate在Rust中提供随机数生成器？**'
- en: '`rand` is the most important one.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand` 是最重要的一个。'
- en: '**How can backtracking solve combinatorial problems?**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**回溯如何解决组合问题？**'
- en: Backtracking recursively tries out possible combinations and evaluates their
    validity as soon as possible. This allows you to backtrack the bad solutions and
    save good solutions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯递归地尝试可能的组合，并尽快评估它们的有效性。这允许你回溯不良的解决方案并保存好的解决方案。
- en: '**What is dynamic programming?**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是动态规划？**'
- en: A programming technique that saves and uses common intermediate solutions to
    improve the algorithm's runtime complexity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一种编程技术，通过保存和使用常见的中间解决方案来提高算法的运行时间复杂度。
- en: '**How are metaheuristics a problem-agnostic approach to solving hard problems?**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**元启发式是如何成为解决难题的无问题方法的？**'
- en: Metaheuristics use generally applicable strategies to find the best solution.
    These strategies can be inspired by nature (natural selection, animal behavior,
    physical processes) and repeatedly generate and evaluate parameters to improve
    the next solution. If the generation and validation of a problem is supplied by
    the user, the approach can be problem-agnostic and since the strategies take care
    of converging toward the best solution, they can provide a best guess in predictable
    time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 元启发式使用普遍适用的策略来找到最佳解决方案。这些策略可以受到自然的启发（自然选择、动物行为、物理过程），并反复生成和评估参数以改进下一个解决方案。如果问题的生成和验证由用户提供，则该方法可以是无问题的，并且由于策略负责收敛到最佳解决方案，它们可以在可预测的时间内提供最佳猜测。
- en: Chapter 12
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: '**Where is Rust''s implementation of generic algorithms on collections?**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rust在集合上的泛型算法实现在哪里？**'
- en: The slice primitive type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 切片原始类型。
- en: '**When is linear search better than binary search?**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时线性搜索比二分搜索更好？**'
- en: If the sequence is short and not sorted—the time it takes to sort it would be
    longer than a simple linear search.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果序列短且未排序——排序它所需的时间将长于简单的线性搜索。
- en: '***Potential job interview question:* What are stable and unstable sorting
    algorithms?**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '***潜在面试问题：*什么是稳定排序算法和不稳定排序算法？**'
- en: Stable sorting algorithms maintain a relative order between equal elements,
    while unstable sorting algorithms don't. This means that if there are sequences
    of the same number, the entire block will show up in the sorted collection exactly
    in the same order.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定排序算法在相等元素之间保持相对顺序，而不稳定排序算法则不这样做。这意味着如果有相同数字的序列，整个块在排序集合中会按照完全相同的顺序出现。
- en: '**What is a bad behavior of Quicksort that pattern-defeating Quicksort mitigates?**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速排序的哪种不良行为是模式破坏快速排序缓解的？**'
- en: The choice of bad pivots is the most important problem that is mitigated. This
    is done by employing strategies to improve the selection or, if all else fails, use
    heap sort to achieve at least a *O(n log n)* runtime complexity (instead of quicksort's
    *O(n²)*).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 选择不良的枢轴是缓解的最重要问题。这是通过采用策略来改进选择，或者在所有其他方法都失败的情况下，使用堆排序以实现至少*O(n log n)*的运行时间复杂度（而不是快速排序的*O(n²)*）。
