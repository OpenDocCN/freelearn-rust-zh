- en: '*Chapter 10*: Working with Device I/O'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：使用设备 I/O'
- en: In [*Chapter 6*](B16405_06_Final_NM_ePUB.xhtml#_idTextAnchor101), *Working with
    Files and Directories in Rust*, we covered the details of how to perform file
    I/O operations (such as reading and writing to files) using the Rust Standard
    Library. In Unix-like operating systems, a file is an abstraction that is used
    to work not only with regular disk files (which are used to store data) but also
    with several types of devices that are connected to a machine. In this chapter,
    we will look at the features of the Rust Standard Library that enable us to perform
    reads and writes to any type of device (also called device I/O) in Rust. Device
    I/O is an essential aspect of system programming to monitor and control various
    types of devices attached to a computer, such as keyboards, USB cameras, printers,
    and sound cards. You may be curious to know what support Rust provides to a system
    programmer to handle all these different types of devices. We'll answer this question
    as we go through the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B16405_06_Final_NM_ePUB.xhtml#_idTextAnchor101) 中，我们介绍了如何使用 Rust
    标准库执行文件 I/O 操作（如读取和写入文件）的详细情况。在类 Unix 操作系统中，文件是一个抽象概念，它不仅用于处理常规磁盘文件（用于存储数据），还用于与连接到机器的多种类型的设备进行交互。在本章中，我们将探讨
    Rust 标准库的功能，使我们能够在 Rust 中对任何类型的设备进行读取和写入（也称为设备 I/O）。设备 I/O 是系统编程的一个基本方面，用于监控和控制连接到计算机的各种类型的设备，如键盘、USB
    摄像头、打印机和外设。你可能想知道 Rust 为系统程序员提供了哪些支持来处理所有这些不同类型的设备。我们将随着章节的进行回答这个问题。
- en: In this chapter, we will review the basics of I/O management in Unix/Linux using
    the Rust Standard Library, including handling errors, and then write a program
    to detect and print details of connected USB devices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Rust 标准库回顾 Unix/Linux 中 I/O 管理的基础知识，包括错误处理，然后编写一个程序来检测并打印连接的 USB
    设备的详细信息。
- en: 'We will cover these topics in the following order:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下顺序介绍这些主题：
- en: Understanding device I/O fundamentals in Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux 中的设备 I/O 基础知识
- en: Doing buffered reads and writes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行缓冲读取和写入
- en: Working with standard input and output
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准输入和输出
- en: Chaining and iterators over I/O
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O 的链式操作和迭代器
- en: Handling errors and returning values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误和返回值
- en: Getting details of connected USB devices (project)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取连接的 USB 设备的详细信息（项目）
- en: By the end of this chapter, you will have learned how to work with standard
    readers and writers, which constitute the foundation of any I/O operation. You'll
    also learn how to optimize system calls through the use of buffered reads and
    writes. We'll cover reading and writing to standard I/O streams of a process and
    handling errors from I/O operations, as well as learning ways to iterate over
    I/O. These concepts will be reinforced through an example project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何使用标准读取器和写入器，这是任何 I/O 操作的基础。你还将学会如何通过使用缓冲读取和写入来优化系统调用。我们将涵盖对进程的标准
    I/O 流的读取和写入以及处理 I/O 操作的错误，以及学习遍历 I/O 的方法。这些概念将通过一个示例项目得到加强。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Verify that `rustup`, `rustc`, and `cargo` have been installed correctly with
    the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证 `rustup`、`rustc` 和 `cargo` 是否已正确安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter10/usb](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter10/usb).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的 Git 仓库可以在 [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter10/usb](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter10/usb)
    找到。
- en: For running and testing the project in this book, you must have the native libusb
    library installed where it can be found by `pkg-config`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行和测试本书中的项目，你必须安装本机 libusb 库，使其可以通过 `pkg-config` 找到。
- en: The project in this book has been tested on macOS Catalina 10.15.6.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的项目已在 macOS Catalina 10.15.6 上进行测试。
- en: 'For instructions on building and testing on Windows, refer: [https://github.com/dcuddeback/libusb-rs/issues/20](https://github.com/dcuddeback/libusb-rs/issues/20)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在 Windows 上构建和测试的说明，请参阅：[https://github.com/dcuddeback/libusb-rs/issues/20](https://github.com/dcuddeback/libusb-rs/issues/20)
- en: 'For general instructions on environmental setup of `libusb` crate, refer to:
    [https://github.com/dcuddeback/libusb-rs](https://github.com/dcuddeback/libusb-rs)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `libusb` crate 环境设置的通用说明，请参阅：[https://github.com/dcuddeback/libusb-rs](https://github.com/dcuddeback/libusb-rs)
- en: Understanding device I/O fundamentals in Linux
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Linux 中的设备 I/O 基础知识
- en: In previous chapters, we saw how to schedule work on CPUs using **processes
    and threads**, and how to manage **memory** by controlling the memory layout of
    a program. In addition to the CPU and memory, the operating system also manages
    the system's hardware devices. Examples of hardware devices include keyboards,
    mice, hard disks, video adapters, audio cards, network adapters, scanners, cameras,
    and other USB devices. But the peculiarities of these physical hardware devices
    are hidden from the user programs by the operating system, using software modules
    called **device drivers**. Device drivers are indispensable software components
    for doing device I/O. Let's take a closer look at them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用**进程和线程**来在CPU上调度工作，以及如何通过控制程序的内存布局来管理**内存**。除了CPU和内存，操作系统还管理系统的硬件设备。硬件设备的例子包括键盘、鼠标、硬盘、视频适配器、音频卡、网络适配器、扫描仪、摄像头以及其他USB设备。但是，这些物理硬件设备的特殊性被操作系统通过称为**设备驱动程序**的软件模块隐藏起来。设备驱动程序是进行设备I/O不可或缺的软件组件。让我们更深入地了解一下它们。
- en: What are device drivers?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是设备驱动程序？
- en: '**Device drivers** are shared libraries loaded into the kernel that contain
    functions to perform low-level hardware control. They communicate with the devices
    through the computer bus or communication subsystem to which the device is connected.
    They are specific to each device type (for example, a mouse or network adaptor)
    or class of devices (for example, IDE or SCSI disk controllers). They are also
    specific to an operating system (for example, a device driver for Windows doesn''t
    work on Linux even for the same device type).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备驱动程序**是加载到内核中的共享库，其中包含执行低级硬件控制的功能。它们通过连接到设备的计算机总线或通信子系统与设备进行通信。它们针对每种设备类型（例如，鼠标或网络适配器）或设备类（例如，IDE或SCSI磁盘控制器）特定。它们也针对特定的操作系统（例如，Windows的设备驱动程序在Linux上即使对于相同的设备类型也无法工作）。'
- en: Device drivers handle the peculiarities of the devices (or device classes) for
    which they are written. For example, a device driver to control a hard disk receives
    requests to read or write some file data identified by a **block number**. The
    device driver translates the block number into track, sector, and cylinder numbers
    on the disk. It also initializes the device, checks whether the device is in use,
    validates input parameters to its function calls, determines the commands to be
    issued, and issues them to the device. It handles the interrupts from the device
    and communicates them back to the calling program. The device driver further implements
    the specific hardware protocols that the device supports, such as **SCSI/ATA/SATA**
    for disk access or **UART** for serial port communications. Device drivers thus
    abstract away a lot of the hardware-specific details of controlling devices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序处理它们所编写的设备（或设备类）的特殊性。例如，用于控制硬盘的设备驱动程序接收读取或写入由**块号**标识的某些文件数据的请求。设备驱动程序将块号转换为磁盘上的磁道、扇区和柱面号。它还初始化设备，检查设备是否在使用中，验证其函数调用输入参数的有效性，确定要发出的命令，并将它们发送到设备。它处理来自设备的中断，并将它们传达给调用程序。设备驱动程序还实现了设备支持的特定硬件协议，例如用于磁盘访问的**SCSI/ATA/SATA**或用于串行端口通信的**UART**。因此，设备驱动程序抽象出了控制设备的大量硬件特定细节。
- en: 'The operating system (specifically the kernel) accepts system calls from the
    user programs for device access and control, and then uses the respective device
    driver to physically access and control the device. *Figure 10.1* illustrates
    how user space programs (for example, Rust programs that use the standard library
    to talk to the operating system kernel) use system calls to manage and control
    various types of devices:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（特别是内核）接受用户程序对设备访问和控制的系统调用，然后使用相应的设备驱动程序物理访问和控制设备。*图10.1*说明了用户空间程序（例如，使用标准库与操作系统内核通信的Rust程序）如何使用系统调用来管理和控制各种类型的设备：
- en: '![Figure 10.1 – Device I/O in Linux](img/Figure_10.1_B16405.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – Linux中的设备I/O](img/Figure_10.1_B16405.jpg)'
- en: Figure 10.1 – Device I/O in Linux
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – Linux中的设备I/O
- en: In [*Chapter 6*](B16405_06_Final_NM_ePUB.xhtml#_idTextAnchor101), *Working with
    Files and Directories in Rust*, we saw that Linux/Unix has the philosophy that
    *everything is a file*, characterized by the universality of I/O. The same system
    calls, such as `open()`, `close()`, `read()`, and `write()`, can be applied to
    all types of I/O whether it's a regular file (used to store text or binary data),
    a directory, device files, or network connections. What this means is that programmers
    of user space programs can write code to communicate with and control devices
    without worrying about the protocol and hardware specifics of the devices, thanks
    to the abstraction layers provided by the kernel (system calls) and device drivers.
    Furthermore, the Rust Standard Library adds another layer of abstraction to provide
    a device-independent software layer, which Rust programs can use for device I/O.
    This is the primary focus of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B16405_06_Final_NM_ePUB.xhtml#_idTextAnchor101)“在Rust中处理文件和目录”，我们了解到Linux/Unix有“一切皆文件”的哲学，这体现在I/O的通用性上。相同的系统调用，如`open()`、`close()`、`read()`和`write()`，可以应用于所有类型的I/O，无论是常规文件（用于存储文本或二进制数据）、目录、设备文件还是网络连接。这意味着用户空间程序的程序员可以编写代码与设备通信和控制设备，而无需担心设备的协议和硬件细节，这得益于内核（系统调用）和设备驱动程序提供的抽象层。此外，Rust标准库添加了另一层抽象，以提供设备无关的软件层，Rust程序可以使用它进行设备I/O。这是本章的主要关注点。
- en: Types of devices
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备类型
- en: 'In Unix/Linux, devices are broadly classified into three types:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix/Linux中，设备被广泛分为三种类型：
- en: '**Character devices** send or receive data as a serial stream of bytes. Examples
    are terminals, keyboards, mice, printers, and sound cards. Unlike regular files,
    data cannot be accessed at random but only sequentially.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符设备**以字节序列的形式发送或接收数据。例如，终端、键盘、鼠标、打印机和声卡。与常规文件不同，数据不能随机访问，只能按顺序访问。'
- en: '**Block devices** store information in fixed-size blocks and allow random access
    to these blocks. Filesystems, hard disks, tape drives, and USB cameras are examples
    of block devices. A filesystem is mounted on a block device.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块设备**以固定大小的块存储信息，并允许随机访问这些块。文件系统、硬盘、磁带驱动器和USB摄像头是块设备的例子。文件系统安装在块设备上。'
- en: '**Network devices** are similar to character devices as data is read serially,
    but there are some differences. Data is sent in variable-length packets using
    a network protocol, which the operating system and the user program have to deal
    with. A network adaptor is usually a hardware device (with some exceptions, such
    as the loopback interface, which is a software interface) that interfaces to a
    network (such as **Ethernet** or **Wi-Fi**).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络设备**与字符设备类似，因为数据是按顺序读取的，但也有一些区别。数据使用网络协议以可变长度的数据包发送，操作系统和用户程序必须处理这些协议。网络适配器通常是一个硬件设备（有些例外，如环回接口，它是一个软件接口），它连接到网络（如**以太网**或**Wi-Fi**）。'
- en: A hardware device is identified by its *type* (block or character) and a *device
    number*. The device number in turn is split into a major and minor device number.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件设备通过其*类型*（块或字符）和*设备号*来识别。设备号反过来又分为主设备号和次设备号。
- en: When a new hardware is connected, the kernel needs a device driver that is compatible
    with the device and can operate the device controller hardware. A device driver,
    as discussed earlier, is essentially a shared library of low-level, hardware-handling
    functions that can operate in a privileged manner as part of the kernel. Without
    device drivers, the kernel does not know how to operate the device. When a program
    attempts to connect to a device, the kernel looks up associated information in
    its tables and transfers control to the device driver. There are separate tables
    for *block* and *character* devices. The device driver performs the required task
    on the device and returns control back to the operating system kernel.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接新的硬件时，内核需要与设备兼容的设备驱动程序，并且可以操作设备控制器硬件。正如之前讨论的，设备驱动程序本质上是一个低级、硬件处理函数的共享库，可以作为内核的一部分以特权方式运行。没有设备驱动程序，内核不知道如何操作设备。当程序尝试连接到设备时，内核在其表中查找相关信息的条目，并将控制权转交给设备驱动程序。对于**块**和**字符**设备，有单独的表。设备驱动程序在设备上执行所需的任务，并将控制权返回给操作系统内核。
- en: As an example, let's look at a web server sending a page to a web browser. The
    data is structured as an **HTTP response message** with the **web page (HTML)**
    sent as part of its **data payload**. The data itself is stored in the kernel
    in a buffer (data structure), which is then passed to the **TCP layer**, then
    to the **IP layer**, on to the **Ethernet device driver**, then to the **Ethernet
    adaptor**, and onward to the **network**. The Ethernet device driver does not
    know anything about connections and only handles data packets. Similarly, when
    data needs to be stored to a file on the disk, the data is stored in a buffer,
    which is passed on to the **filesystem device driver** and then onward to the
    **disk controller**, which then saves it to the disk (for example, hard disk,
    SSD, and so on). Essentially, the *kernel* relies on a *device driver* to interface
    with the device.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看一个网页服务器向网页浏览器发送页面。数据结构为一个**HTTP响应消息**，其中作为其**数据负载**一部分发送的**网页（HTML）**。数据本身存储在内核中的缓冲区（数据结构）中，然后传递给**TCP层**，接着是**IP层**，然后是**以太网设备驱动程序**，然后是**以太网适配器**，最后到达**网络**。以太网设备驱动程序不了解任何连接，只处理数据包。同样，当需要将数据存储到磁盘上的文件时，数据会存储在缓冲区中，然后传递给**文件系统设备驱动程序**，然后传递给**磁盘控制器**，然后将其保存到磁盘（例如，硬盘、SSD等）。本质上，*内核*依赖于*设备驱动程序*与设备进行接口。
- en: Device drivers are usually part of the kernel (**kernel device driver**), but
    there are also **user space device drivers**, which abstract out the details of
    kernel access. Later in this chapter, we will be using one such user space device
    driver to detect USB devices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序通常是内核的一部分（**内核设备驱动程序**），但也有一些**用户空间设备驱动程序**，它们抽象化了内核访问的细节。在本章的后面部分，我们将使用这样一个用户空间设备驱动程序来检测USB设备。
- en: We've discussed the basics of device I/O, including device drivers and types
    of devices in Unix-like systems, in this section. Starting from the next section,
    we'll focus on how to do device-independent I/O using features from the Rust Standard
    Library.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了设备I/O的基本知识，包括Unix-like系统中的设备驱动程序和设备类型。从下一节开始，我们将关注如何使用Rust标准库中的功能进行设备无关的I/O。
- en: Doing buffered reads and writes
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行缓冲读取和写入
- en: Reads and writes are the fundamental operations performed on I/O types such
    as files and streams and are very crucial for working with many types of system
    resources. In this section, we'll discuss different ways to do *reads* and *writes*
    to I/O in Rust. We'll first cover the core traits – `Read` and `Write` – which
    allow Rust programs to perform read and write operations on objects that implement
    these traits (which are also called **readers** and **writers**). Then, we'll
    see how to do *buffered reads* and *buffered writes*, which are more efficient
    for certain types of read and write operations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入是执行在文件和流等I/O类型上的基本操作，对于与许多类型的系统资源一起工作非常重要。在本节中，我们将讨论在Rust中进行不同方式的*读取*和*写入*。我们将首先介绍核心特质——`Read`和`Write`——这些特质允许Rust程序在实现这些特质的对象上执行读取和写入操作（这些也被称为**读取器**和**写入器**）。然后，我们将看到如何进行*缓冲读取*和*缓冲写入*，这对于某些类型的读取和写入操作更有效。
- en: Let's start with the basic `Read` and `Write` traits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的`Read`和`Write`特质开始。
- en: In line with the *everything-is-a-file* philosophy, the Rust Standard Library
    provides two traits – `Read` and `Write` – which provide a general interface for
    reading and writing inputs and outputs. This trait is implemented for different
    types of I/O, such as files, `TcpStream`, standard input, and standard output
    streams of processes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据哲学“一切皆文件”，Rust标准库提供了两个特质——`Read`和`Write`——它们提供了读取和写入输入和输出的通用接口。这个特质为不同类型的I/O实现了，例如文件、`TcpStream`、标准输入和标准输出流。
- en: 'An example of using the `Read` trait is shown in the following code. Here,
    we are opening a `records.txt` file with the `open()` function in the `std::fs::File`
    module (which we learned earlier). We''re then bringing the `Read` trait from
    the `std::io` module into scope, and using the `read()` method of this trait to
    read bytes from a file. The same `read()` method can also be used to read from
    any other entity implementing the `Read` trait, such as a **network socket** or
    a **standard input** stream:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用`Read`特质的示例。在这里，我们使用`std::fs::File`模块中的`open()`函数（我们之前学过）打开一个`records.txt`文件。然后，我们将`std::io`模块中的`Read`特质引入作用域，并使用这个特质的`read()`方法从文件中读取字节。相同的`read()`方法也可以用于从实现`Read`特质的任何其他实体中读取，例如**网络套接字**或**标准输入**流：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create a file called `records.txt` in the project root and run the program with
    `cargo run`. You can optionally print out the value of the buffer, which will
    display the raw bytes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个名为 `records.txt` 的文件，并使用 `cargo run` 运行程序。你可以选择打印缓冲区的值，这将显示原始字节。
- en: '`Read` and `Write` are byte-based interfaces, which can get inefficient as
    they involve continual system calls to the operating system. To overcome this,
    Rust also provides two structs to enable doing buffered reads and writes – `BufReader`
    and `BufWriter`, which have a built-in buffer and reduce the number of calls to
    the operating system.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read` 和 `Write` 是基于字节的接口，当它们涉及对操作系统的持续系统调用时可能会变得低效。为了克服这一点，Rust 还提供了两个结构体，以实现缓冲读取和写入
    – `BufReader` 和 `BufWriter`，它们具有内置的缓冲区并减少了调用操作系统的次数。'
- en: 'The previous example can be rewritten as shown here, to use `BufReader`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例可以重写如下，以使用 `BufReader`：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code changes (from the previous version) have been highlighted. `BufReader`
    uses the `BufRead` trait, which is brought into scope. Instead of reading directly
    from the file handle, we create a `BufReader` instance and read a line into this
    struct. The `BufReader` methods internally optimize calls to the operating system.
    Run the program and verify that the value from the file is printed correctly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更改（与前一个版本相比）已被突出显示。`BufReader` 使用 `BufRead` 特性，该特性已被引入作用域。我们不是直接从文件句柄读取，而是创建一个
    `BufReader` 实例并将一行读取到这个结构中。`BufReader` 方法内部优化了对操作系统的调用。运行程序并验证文件中的值是否正确打印。
- en: '`BufWriter` similarly buffers writes to the disk, thus minimizing system calls.
    It can be used in a similar manner as shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufWriter` 类似地缓冲对磁盘的写入，从而最小化系统调用。它可以像以下代码所示那样使用：'
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the code shown, we're creating a new file to write into, and are also creating
    a new `BufWriter` instance. We then write a value from the buffer into the `BufWriter`
    instance. Run the program and verify that the specified string value has been
    written to a file with the name `file.txt` in the project root directory. Note
    that here, in addition to `BufWriter`, we also have to bring the `Write` trait
    into scope as this contains the `write()` method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的代码中，我们正在创建一个新文件以写入，同时也创建了一个新的 `BufWriter` 实例。然后我们将缓冲区中的值写入 `BufWriter` 实例。运行程序并验证指定的字符串值是否已写入项目根目录下的
    `file.txt` 文件。注意，在这里，除了 `BufWriter` 之外，我们还需要将 `Write` 特性引入作用域，因为其中包含 `write()`
    方法。
- en: 'Note when to use and when not to use `BufReader` and `BufWriter`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意何时使用和何时不使用 `BufReader` 和 `BufWriter`：
- en: '`BufReader` and `BufWriter` speed up programs that make small and frequent
    reads or writes to a disk. If the reads or writes only occasionally involve large-sized
    data, they do not offer any benefit.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BufReader` 和 `BufWriter` 可以加速那些对磁盘进行小而频繁的读取或写入的程序。如果读取或写入仅偶尔涉及大量数据，它们不会提供任何好处。'
- en: '`BufReader` and `BufWriter` do not help while reading from or writing to in-memory
    data structures.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BufReader` 和 `BufWriter` 在从内存数据结构中读取或写入时并不提供帮助。'
- en: In this section, we saw how to do both unbuffered and buffered reads and writes.
    In the next section, we'll learn how to work with standard inputs and outputs
    of a process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何进行无缓冲和缓冲的读取和写入。在下一节中，我们将学习如何处理进程的标准输入和输出。
- en: Working with standard input and output
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理标准输入和输出
- en: 'In Linux/Unix, **streams** are communication channels between a process and
    its environment. By default, three standard streams are created for every running
    process: **standard input**, **standard output**, and **standard error**. A stream
    is a communication channel that has two ends. One end is connected to the process
    and the other end to another system resource. For example, a standard input can
    be used by a process to read characters or text from a keyboard or another process.
    Similarly, a standard output stream can be used by a process to send some characters
    to the terminal or to a file. In many modern programs, the standard error of a
    process is connected to a log file, which makes analyzing and debugging errors
    easier.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux/Unix 中，**流** 是进程与其环境之间的通信通道。默认情况下，为每个运行进程创建三个标准流：**标准输入**、**标准输出**和**标准错误**。流是一个具有两端点的通信通道。一端连接到进程，另一端连接到另一个系统资源。例如，标准输入可以被进程用来从键盘或另一个进程读取字符或文本。同样，标准输出流可以被进程用来将一些字符发送到终端或文件。在许多现代程序中，进程的标准错误连接到一个日志文件，这使得分析和调试错误变得更容易。
- en: The Rust Standard Library provides methods to interact with standard input and
    output streams. The `Stdin` struct in the `std::io` module represents the handle
    to the input stream of a process. This handle implements the `Read` trait, which
    we covered in the previous section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库提供了与标准输入和输出流交互的方法。`std::io`模块中的`Stdin`结构体表示进程输入流的句柄。此句柄实现了我们在上一节中提到的`Read`特质。
- en: 'The code example here shows how to interact with the standard input and standard
    output streams of a process. In the code shown, we are reading a line from the
    standard input into a buffer. We''re then writing back the contents of the buffer
    to the standard output of the process. Note that here, the word *process* refers
    to the running program that you have written. You are essentially *reading from*
    and *writing to* the *standard input* and *standard output*, respectively, of
    the running program:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何与进程的标准输入和标准输出流进行交互。在显示的代码中，我们从标准输入读取一行到缓冲区。然后，我们将缓冲区的内容写回进程的标准输出。请注意，在这里，单词*process*指的是您所编写的正在运行的程序。您本质上是从*标准输入*和*标准输出*分别*读取*和*写入*的：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the program with `cargo run`, enter some text, and hit the *Enter* key.
    You'll see the text echoed back on the terminal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo run`运行程序，输入一些文本，然后按*Enter*键。您将在终端上看到文本被回显。
- en: '`Stdin`, which is a handle to the input stream of a process, is a shared reference
    to a global buffer of input data. Likewise, `Stdout`, which is the output stream
    of a process, is a shared reference to a global data buffer. Since `Stdin` and
    `Stdout` are references to shared data, to ensure exclusive use of these data
    buffers, the handles can be locked. For example, the `StdinLock` struct in the
    `std::io` module represents a locked reference to the `Stdin` handle. Likewise,
    the `StdoutLock` struct in the `std::io` module represents a locked reference
    to the `Stdout` handle. Examples of how to use the locked reference are shown
    in the code example here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stdin`，它是进程输入流的句柄，是对全局输入数据缓冲区的共享引用。同样，`Stdout`，它是进程的输出流，是对全局数据缓冲区的共享引用。由于`Stdin`和`Stdout`是共享数据的引用，为了确保这些数据缓冲区的独占使用，句柄可以被锁定。例如，`std::io`模块中的`StdinLock`结构体代表对`Stdin`句柄的锁定引用。同样，`std::io`模块中的`StdoutLock`结构体代表对`Stdout`句柄的锁定引用。以下代码示例展示了如何使用锁定引用的示例：'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the code shown, the standard input and output stream handles are locked before
    reading and writing to them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的代码中，在读取和写入之前，将标准输入和输出流句柄锁定。
- en: 'We can similarly write to the *standard error* stream. A code example is shown
    here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地向*标准错误*流写入。以下是一个代码示例：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the code shown, we're constructing a handle to the standard error stream
    using the `stderr()` function. Then, we're locking this handle and then writing
    some text to it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的代码中，我们使用`stderr()`函数构建标准错误流的句柄。然后，我们锁定此句柄并向其写入一些文本。
- en: In this section, we've seen how to interact with the standard input, standard
    output, and standard error streams of a process using the Rust Standard Library.
    Recall that in the previous chapter on managing concurrency, we saw how, from
    a parent process, we can read from and write to the standard input and output
    streams of the child process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用Rust标准库与进程的标准输入、标准输出和标准错误流进行交互。回想一下，在前一章关于管理并发的内容中，我们看到了如何从父进程读取和写入子进程的标准输入和输出流。
- en: In the next section, let's look at a couple of functional programming constructs
    that can be used for I/O in Rust.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看一些可以在Rust中进行I/O的功能编程结构。
- en: Chaining and iterators over I/O
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O的链式操作和迭代器
- en: In this section, we'll look at how to use iterators and chaining with the `std::io`
    module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用迭代器和链式操作与`std::io`模块一起使用。
- en: 'Many of the data structures provided by the `std::io` module have built-in
    `while` and `for` loops. Here is an example of using the `lines()` iterator with
    the `BufReader` struct, which is a part of the `std::io` module. This program
    reads lines from the *standard input* stream in a loop:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::io`模块提供的许多数据结构都具有内置的`while`和`for`循环。以下是一个使用`BufReader`结构体和`lines()`迭代器的示例，`BufReader`是`std::io`模块的一部分。这个程序在循环中从*标准输入*流中读取行：'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the code shown, we have created a handle to the standard input stream and
    passed it to a `BufReader` struct. This struct implements the `BufRead` trait,
    which has a `lines()` method that returns an *iterator* over the lines of the
    reader. This helps us to type inputs on the terminal *line by line* and have it
    read by our running program. The text entered on the terminal is echoed back to
    the terminal. Execute `cargo run`, and type some text, and then hit the *Enter*
    key. Repeat this step as many times as you'd like. Exit from the program with
    *Ctrl* + *C*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们创建了一个指向标准输入流的句柄，并将其传递给一个`BufReader`结构体。这个结构体实现了`BufRead`特质，它有一个`lines()`方法，该方法返回一个遍历读取器行数的迭代器。这有助于我们在终端逐行输入文本，并让我们的运行程序读取它。在终端输入的文本会被回显到终端。执行`cargo
    run`，输入一些文本，然后按*Enter*键。根据需要重复此步骤。使用*Ctrl* + *C*退出程序。
- en: 'Likewise, the iterator can be used to read line by line from a *file* (instead
    of from standard input, which we saw in the previous example). A code snippet
    is shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，迭代器也可以用来逐行从*文件*中读取（而不是从我们在上一个示例中看到的标准输入中读取）。这里有一个代码片段的示例：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a file called `file.txt` in the project root directory. Enter a few lines
    of text in this file. Then, run the program using `cargo run`. You'll see the
    file contents printed out to the terminal.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个名为`file.txt`的文件。在这个文件中输入几行文本。然后，使用`cargo run`运行程序。你会看到文件内容被打印到终端。
- en: 'We''ve so far seen how to use iterators from the `std::io` module. Let''s now
    look at another concept: **chaining**.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`std::io`模块中的迭代器。现在让我们看看另一个概念：**链式操作**。
- en: 'The `Read` trait in the `std::io` module has a `chain()` method, which allows
    us to chain multiple `BufReader` together into one handle. Here is an example
    of how to create a single **chained handle** combining two files, and how to read
    from this handle:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::io`模块中的`Read`特质有一个`chain()`方法，它允许我们将多个`BufReader`链接在一起形成一个句柄。以下是一个如何创建一个将两个文件组合在一起的单一**链式句柄**的示例，以及如何从这个句柄中读取的示例：'
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The statement using the `chain()` method has been highlighted in the code. The
    rest of the code is fairly self-explanatory, as it is similar to what we've seen
    in previous examples. Ensure to create two files, `file1.txt` and `file2.txt`,
    under the project root folder and enter a few lines of text in each. Run the program
    with `cargo run`. You'll see the data from both files printed out line by line.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中使用`chain()`方法的语句已被突出显示。其余的代码相当直观，因为它与我们之前看到的示例类似。确保在项目根目录下创建两个文件，`file1.txt`和`file2.txt`，并在每个文件中输入几行文本。使用`cargo
    run`运行程序。你会看到两个文件的数据逐行打印出来。
- en: In this section, we've seen how to use iterators and how to chain readers together.
    In the next section, let's take a look at error handling for I/O operations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用迭代器以及如何将读取器链接在一起。在下一节中，让我们看看I/O操作的错误处理。
- en: Handling errors and returning values
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误和返回值
- en: In this section, we'll learn about the built-in error handling support in the
    `std::io` module. Handling recoverable errors in an appropriate manner makes Rust
    programs more robust.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解`std::io`模块中内置的错误处理支持。以适当的方式处理可恢复的错误可以使Rust程序更加健壮。
- en: In the code examples we've seen so far, we've used the `unwrap()` function to
    extract the return value from the `std::io` module methods and associated functions,
    such as `Read`, `Write`, `BufReader`, and `BufWriter`. However, this is not the
    correct way to handle errors. The `std::io` module has a specialized `Result`
    type that is returned from any function or method in this module that may produce
    an error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前看到的代码示例中，我们使用了`unwrap()`函数从`std::io`模块的方法和相关函数（如`Read`、`Write`、`BufReader`和`BufWriter`）中提取返回值。然而，这并不是处理错误的方法。`std::io`模块有一个专门的`Result`类型，它由该模块中可能产生错误的任何函数或方法返回。
- en: 'Let''s rewrite the previous example (of chaining readers) using the `io::Result`
    type as the return value from the function. This allows us to use the `?` operator
    to directly pass errors back from the `main()` function, instead of using the
    `unwrap()` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写之前的示例（链式读取器），使用`io::Result`类型作为函数的返回值。这允许我们使用`?`运算符直接从`main()`函数传递错误，而不是使用`unwrap()`函数：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Code related to error handling has been highlighted. Run the program with `cargo
    run`, this time making sure that neither `file1.txt` nor `file3.txt` exists in
    the project root folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与错误处理相关的代码已被突出显示。使用`cargo run`运行程序，这次确保项目根目录下既不存在`file1.txt`也不存在`file3.txt`。
- en: You'll see the error message printed to the terminal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到错误信息打印到终端。
- en: 'In the code we''ve just seen, we''re just propagating the error received from
    the operating system while making the calls. Let''s now try to handle the errors
    in a more active manner. The code example here shows custom error handling for
    the same code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚才看到的代码中，我们只是在调用操作系统时传播接收到的错误。现在让我们尝试以更积极的方式处理错误。下面的代码示例显示了相同代码的自定义错误处理：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You'll notice that we've created a new function that returns `std::io::Result`
    to the `main()` function. We're handling errors in various operations, such as
    reading from a file and reading from the chained readers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们创建了一个新的函数，该函数将`std::io::Result`返回给`main()`函数。我们在各种操作中处理错误，例如从文件读取和从链式读取器读取。
- en: First, run the program with `cargo run`, ensuring that both `file1.txt` and
    `file2.txt` exist. You'll see the contents from both files printed to the terminal.
    Rerun the program by removing one of these files. You should see the custom error
    message from our code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`cargo run`运行程序，确保`file1.txt`和`file2.txt`都存在。你将看到两个文件的内容都打印到终端。通过移除其中一个文件来重新运行程序。你应该看到我们代码中的自定义错误消息。
- en: With this, we conclude the section on handling errors. Let's now move on to
    the last section of the chapter, where we will go through a project to detect
    and display details of USB devices connected to a computer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了关于错误处理的章节。现在让我们继续到本章的最后一节，我们将通过一个项目来检测和显示连接到计算机的USB设备的详细信息。
- en: Getting details of connected USB devices (project)
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取连接的USB设备的详细信息（项目）
- en: In this section, we will demonstrate an example of working with devices in Rust.
    The example chosen is to display details of all connected USB devices of a computer.
    We'll be using `libusb`, a C library that helps to interact with USB devices.
    The `libusb` crate in Rust is a safe wrapper around the C `libusb` library. Let's
    first look at the design.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示在Rust中与设备一起工作的示例。所选的示例是显示计算机上所有连接的USB设备的详细信息。我们将使用`libusb`，这是一个C库，有助于与USB设备交互。Rust中的`libusb`包是C
    `libusb`库的安全包装。让我们首先看看设计。
- en: Designing the project
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计项目
- en: 'Here is how this would work:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是如何工作的：
- en: When a USB device is plugged into a computer, the electrical signals on the
    computer bus trigger the **USB controller** (hardware device) on the computer.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当USB设备插入到计算机中时，计算机总线上的电信号会触发计算机上的**USB控制器**（硬件设备）。
- en: The USB controller raises an interrupt on the CPU, which then executes the interrupt
    handler registered for that interrupt in the kernel.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB控制器在CPU上引发中断，然后执行内核中注册的该中断的处理程序。
- en: When a call is made from the Rust program through the Rust `libusb` wrapper
    crate, the call is routed to the `libusb` C library, which in turn makes a system
    call on the kernel to read the device file corresponding to the USB device. We've
    seen earlier in this chapter how Unix/Linux enables standard `read()` and `write()`,
    for I/O.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从Rust程序通过Rust `libusb`包装器包发起调用时，该调用被路由到`libusb` C库，然后该库反过来在内核上执行系统调用来读取对应USB设备的设备文件。我们在本章前面已经看到Unix/Linux如何启用标准的`read()`和`write()`来进行I/O。
- en: When the system call returns from the kernel, the `libusb` library returns the
    value from the syscall to our Rust program.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当系统调用从内核返回时，`libusb`库将syscall的值返回给我们的Rust程序。
- en: 'We''re using the `libusb` library because writing a USB device driver from
    scratch requires implementing the USB protocol specifications, and writing device
    drivers is the subject of a separate book in itself. Let''s look at the design
    of our program:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`libusb`库，因为从头开始编写USB设备驱动程序需要实现USB协议规范，而编写设备驱动程序本身就是另一本书的主题。让我们看看我们程序的设计：
- en: '![Figure 10.2 – Design of the USB detector project](img/Figure_10.2_B16405.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – USB检测器项目设计](img/Figure_10.2_B16405.jpg)'
- en: Figure 10.2 – Design of the USB detector project
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – USB检测器项目设计
- en: '*Figure 10.2* shows the structs and functions in the program. Here is a description
    of the data structures:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.2* 展示了程序中的结构和函数。以下是数据结构的描述：'
- en: '`USBList`: List of USB devices detected.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USBList`：检测到的USB设备列表。'
- en: '`USBDetails`: This contains the list of USB details that we want to retrieve
    through this program for each USB device.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USBDetails`：这包含我们希望通过此程序检索的USB设备详细信息列表。'
- en: '`USBError`: Custom error handling.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USBError`：自定义错误处理。'
- en: 'These are the functions that we will write:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将要编写的函数：
- en: '`get_device_information()`: Function to retrieve the required device details
    given a device reference and device handle.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_device_information()`: 用于根据设备引用和设备句柄检索所需设备详情的函数。'
- en: '`write_to_file()`: Function to write device details to an output file.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_to_file()`: 将设备详情写入输出文件的函数。'
- en: '`main()`: This is the entry point to the program. It instantiates a new `libusb::Context`,
    retrieves a list of attached devices, and iterates through the list to call `get_device_information()`
    for each device. The retrieved details are printed to the terminal and also written
    to the file using the `write_to_file()` function.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`: 这是程序的入口点。它实例化一个新的`libusb::Context`，检索连接设备的列表，然后遍历列表以对每个设备调用`get_device_information()`。检索到的详情将被打印到终端，并使用我们之前看到的`write_to_file()`函数写入文件。'
- en: We can now begin to write the code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写代码了。
- en: Writing data structures and utility functions
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写数据结构和实用函数
- en: 'In this section, we''ll write the data structures for storing the USB device
    list and USB details and for custom error handling. We''ll also write a few utility
    functions:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写用于存储USB设备列表和USB详情以及用于自定义错误处理的数据结构，我们还将编写一些实用函数：
- en: 'Let''s begin by creating a new project:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的项目开始：
- en: '[PRE12]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s add the `libusb` crate to `Cargo.toml`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`libusb`包添加到`Cargo.toml`中：
- en: '[PRE13]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll now look at the code in parts. Add all the code for this project in `usb/src/main.rs`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将分部分查看代码。将此项目的所有代码添加到`usb/src/main.rs`中。
- en: 'Here are the module imports:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是模块导入：
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We're importing the `libusb` modules and a few modules from the Rust Standard
    Library. `fs::File` and `io::Write` are for writing to an output file, `result::Result`
    is the return value from the functions, and `time::Duration` is for working with
    the `libusb` library.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在导入`libusb`模块和Rust标准库中的几个模块。`fs::File`和`io::Write`用于写入输出文件，`result::Result`是函数的返回值，而`time::Duration`用于与`libusb`库一起工作。
- en: 'Let''s look at the data structures now:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在看看数据结构：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`USBError` is for custom error handling, `USBList` is to store a list of the
    USB devices detected, and `USBDetails` is to capture the list of details for each
    USB device.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`USBError`用于自定义错误处理，`USBList`用于存储检测到的USB设备列表，而`USBDetails`用于捕获每个USB设备的详情列表。'
- en: 'Let''s implement the `Display` trait for the `USBList` struct so that custom
    formatting can be done to print the contents of the struct:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`USBList`结构体实现`Display`特质，以便可以对结构体的内容进行自定义格式化以打印：
- en: '[PRE16]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we''ll implement `From` traits for the `USBError` struct so that errors
    from the `libusb` crate and from the Rust Standard Library are automatically converted
    into the `USBError` type when we use the `?` operator:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为`USBError`结构体实现`From`特质，以便在调用`?`操作符时，将来自`libusb`包和Rust标准库的错误自动转换为`USBError`类型：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s next look at the function to write the details retrieved for all the
    attached devices to an output file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们接下来看看将所有连接设备的详情写入输出文件的函数：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now move on to the `main()` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续编写`main()`函数。
- en: Writing the main() function
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写main()函数
- en: 'In this section, we''ll write the `main()` function, which sets up the device
    context, gets a list of connected USB devices, and then iterates through the list
    of devices to retrieve the details of each device. We''ll also write a function
    to print out the device details:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写`main()`函数，该函数设置设备上下文，获取连接的USB设备列表，然后遍历设备列表以检索每个设备的详情。我们还将编写一个函数来打印设备详情：
- en: 'We''ll start with the `main()` function:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`main()`函数开始：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `main()` function, we're first creating a new `libusb Context` that can
    return the list of connected devices. We are then iterating through the device
    list obtained from the `Context` struct, and calling the `get_device_information()`
    function for each USB device. The details are finally also printed out to an output
    file by calling the `write_to_file()` function that we saw earlier.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们首先创建一个新的`libusb Context`，它可以返回连接设备的列表。然后，我们遍历从`Context`结构体获得的设备列表，并对每个USB设备调用`get_device_information()`函数。最后，通过调用我们之前看到的`write_to_file()`函数，将详情打印到输出文件。
- en: 'To wrap up the code, let''s write the function to get the device details:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了结束代码，让我们编写一个获取设备详情的函数：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This concludes the code. Make sure to plug in a USB device (such as a thumb
    drive) to the computer. Run the code with `cargo run`. You should see the list
    of attached USB devices printed to the terminal, and also written to the output
    `usb_details.txt` file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了代码部分。请确保将USB设备（如U盘）连接到计算机上。使用`cargo run`运行代码。你应该会在终端看到连接的USB设备列表，并且这些信息也会写入到输出文件`usb_details.txt`中。
- en: Note that in this example, we have demonstrated how to do file I/O using both
    an external crate (for retrieving USB device details) and the standard library
    (for writing to an output file). We've unified error handling using a common error
    handling struct, and automated conversions of error types to this custom error
    type.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，我们展示了如何使用外部crate（用于检索USB设备详情）和标准库（用于写入输出文件）进行文件I/O。我们使用一个通用的错误处理结构体统一了错误处理，并自动将错误类型转换为这种自定义错误类型。
- en: The Rust crates ecosystem (`crates.io`) has similar crates to interact with
    other types of devices and filesystems. You can experiment with them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的crate生态系统（`crates.io`）有类似crate可以用来与其它类型的设备和文件系统交互。你可以尝试使用它们。
- en: This concludes the section on writing a program to retrieve USB details.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于编写程序获取USB详细信息的章节。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the foundational concepts of device management
    in Unix/Linux. We looked at how to do buffered reads and writes using the `std::io`
    module. We then learned how to interact with the standard input, standard output,
    and standard error streams of a process. We also saw how to chain readers together
    and use iterators for reading from devices. We then looked at the error handling
    features with the `std::io` module. We concluded with a project to detect the
    list of connected USB devices and printed out the details of each USB device both
    to the terminal and to an output file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了Unix/Linux设备管理的基石概念。我们探讨了如何使用`std::io`模块进行缓冲读取和写入。然后我们学习了如何与进程的标准输入、标准输出和标准错误流进行交互。我们还看到了如何将读取器链在一起，并使用迭代器从设备中读取。接着我们研究了`std::io`模块的错误处理功能。最后，我们通过一个项目来检测连接的USB设备列表，并将每个USB设备的详细信息打印到终端和输出文件中。
- en: The Rust Standard Library provides a clean layer of abstraction for doing I/O
    operations on any type of device. This encourages the Rust ecosystem to implement
    these standard interfaces for any type of device, enabling Rust system programmers
    to interact with different devices in a uniform manner. Continuing on the topic
    of I/O, in the next chapter, we will learn how to do network I/O operations using
    the Rust Standard Library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库为在任意类型的设备上进行I/O操作提供了一个干净的抽象层。这鼓励Rust生态系统为任何类型的设备实现这些标准接口，使得Rust系统程序员能够以统一的方式与不同的设备进行交互。继续I/O主题，在下一章中，我们将学习如何使用Rust标准库进行网络I/O操作。
