- en: Logging and Configuring Microservice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志和配置微服务
- en: Microservices work in the real world, which is dynamic. To be useful, they have
    to be configurable, so that you can change an address or port to bind the server's
    socket. Often, you will need to set tokens, secrets, and the addresses of other
    microservices. Even if you have configured them correctly, your microservices
    may fail. In this case, you need to be able to use the server's logs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务在现实世界中工作，这是一个动态的环境。为了有用，它们必须可配置，以便你可以更改地址或端口以绑定服务器的套接字。通常，你需要设置令牌、密钥和其他微服务的地址。即使你已经正确配置了它们，你的微服务也可能失败。在这种情况下，你需要能够使用服务器的日志。
- en: 'In this chapter, we''ll learn the following skills:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下技能：
- en: How to use logging with the `log` crate
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`log` crate进行日志记录
- en: How to read command-line parameters with the `clap` crate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`clap` crate读取命令行参数
- en: How to read environment variables with the `dotenv` crate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`dotenv` crate读取环境变量
- en: How to declare and use configuration files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何声明和使用配置文件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter explains how to add logging to a service and parse command-line
    parameters or the environment variables required to configure a microservice.
    You don't need any special software except the Rust compiler, version 1.31 or
    above. Install it using the rustup tool.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何将日志添加到服务中，并解析配置微服务所需的命令行参数或环境变量。除了Rust编译器（版本1.31或更高版本）之外，你不需要任何特殊的软件。使用rustup工具进行安装。
- en: 'You can find the code for the examples of this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter3).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章示例的代码：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter3)。
- en: Adding logging to a microservice
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将日志添加到微服务中
- en: We can't use or debug a microservice if it doesn't record the actions that it
    carries out. In this section, we will start to use logging with our microservices
    to understand what is going on inside them. We will create a microservice that
    generates random values and attach a logger to a microservice to record the actions
    it carries out. Afterward, we will configure logging using environment variables.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果微服务没有记录它执行的操作，我们就无法使用或调试微服务。在本节中，我们将开始使用我们的微服务进行日志记录，以了解它们内部发生了什么。我们将创建一个生成随机值的微服务，并将其附加到微服务上以记录其执行的操作。之后，我们将使用环境变量配置日志。
- en: Random-value-generating microservices
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机值生成微服务
- en: To discuss these more advanced topics, we need a microservices architecture
    that has a more useful purpose than generating *hello* messages. We will create
    a microservice application for generating random values. This is simple enough
    to implement and will provide us with sufficient opportunities to use logging
    and configuration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论这些更高级的话题，我们需要一个比生成*hello*消息更有用目的的微服务架构。我们将创建一个用于生成随机值的微服务应用程序。这足够简单，足以为我们提供足够的机会来使用日志和配置。
- en: 'However, we won''t start completely from scratch; let''s take the example from
    the previous chapter and add a dependency to it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会完全从头开始；让我们以前一章的例子为基础，并添加一个依赖项：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A `rand` crate provides the utilities necessary to generate random values in
    Rust. Import the necessary types in the `main.rs` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand` crate提供了在Rust中生成随机值所需的实用工具。在`main.rs`文件中导入必要的类型：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add two lines to the `service_fn_ok` function to handle incoming requests:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service_fn_ok`函数中添加两行以处理传入的请求：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To learn more about the preceding code, please refer to the previous chapter,
    where we explored the `hyper` crate.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于前面代码的信息，请参阅前一章，其中我们探讨了`hyper` crate。
- en: As you can see, we have added two lines in the closure provided to the `service_fn_ok`
    function. The first line generates a random byte with the `random` function of
    the `rand` crate. We set the generated type in the type parameter of the `rand::random::<u8>()`
    call. Now, `u8`  is an unsigned byte integer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在提供给`service_fn_ok`函数的闭包中添加了两行。第一行使用`rand` crate的`random`函数生成随机字节。我们在`rand::random::<u8>()`调用中将生成的类型设置为类型参数。现在，`u8`是一个无符号字节整数。
- en: 'In the second line, we simply convert the generated byte to a string and return
    it as a `Body` of the `Response`. Try to run the code to test it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们简单地将生成的字节转换为字符串，并将其作为`Response`的`Body`返回。尝试运行代码以测试它：
- en: '![](img/164b62dc-2c6e-43d5-a135-4a257ddff4d1.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/164b62dc-2c6e-43d5-a135-4a257ddff4d1.png)'
- en: From the preceding screenshot, you can see that the service returned the generated
    random value successfully.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图可以看出，该服务成功返回了生成的随机值。
- en: The log crate
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志crate
- en: Logging is the process of recording the activities of a program. Logs can be
    a textual flow in a specified format, which prints to a console or writes to a
    file. Rust has a great logging ecosystem based on the `log` crate. It is worth
    noting that the `log` crate contains macros without a real logger implementation.
    This gives you an opportunity to use different loggers depending on what you need
    them for. In this section, we will start to use the log crate in our microservices
    to learn how logging levels work and how to set the desired level of logs you
    want to see.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是记录程序活动的过程。日志可以是特定格式的文本流，它打印到控制台或写入文件。Rust有一个基于`log` crate的优秀的日志生态系统。值得注意的是，`log`
    crate包含宏但没有实际的日志实现。这给了你根据需要使用不同日志记录器的机会。在本节中，我们将开始在微服务中使用log crate，以了解日志级别的工作原理以及如何设置您想要看到的日志级别。
- en: Loggers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录器
- en: 'The actual logger implementations that are contained in some crates are as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上包含在某些crate中的日志实现如下：
- en: '`env_logger`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env_logger`'
- en: '`simple_logger`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simple_logger`'
- en: '`simplelog`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simplelog`'
- en: '`pretty_env_logger`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pretty_env_logger`'
- en: '`stderrlog`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stderrlog`'
- en: '`flexi_logger`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flexi_logger`'
- en: '`log4rs`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4rs`'
- en: '`fern`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fern`'
- en: It can be difficult to choose between these logger implementations. I recommend
    that you explore them on [crates.io](http://crates.io) to learn how they differ.
    The most popular one is `env_logger`, which is the one that we are going to use.
    `env_logger` reads the `RUST_LOG` environment variable to configure logging and
    prints logs to `stderr`. There is also the `pretty_env_logger` crate, which is
    built on top of `env_logger` and prints logs with a compact and colorful format.
    Both use the same environment variable for configuration.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些日志实现之间进行选择可能很困难。我建议您在[crates.io](http://crates.io)上探索它们，以了解它们之间的差异。最受欢迎的是`env_logger`，这是我们将要使用的一个。`env_logger`读取`RUST_LOG`环境变量来配置日志并将日志打印到`stderr`。还有一个基于`env_logger`的`pretty_env_logger`
    crate，它以紧凑和彩色格式打印日志。两者都使用相同的环境变量进行配置。
- en: '`stderr` is one of three standard streams—`stdin`*,* where your program reads
    the input data with the console; `stdout`*,* where the program sends the output
    data; and `stderr`*, *which has the special purpose of showing errors or other
    information about working with the application. Loggers often use `stderr` to
    avoid affecting the output data. For example, let''s say that you have a tool
    that decodes an input stream. You want the tool to send the decoded data only
    to the output stream. How will the program inform you about any issues it is experiencing?
    In this case, we can use the `stderr` stream, which works as an output stream,
    but doesn''t pollute `stdout`? There is `stderr` stream that works as output stream,
    but doesn''t pollute `stdout`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`stderr`是三个标准流之一——`stdin`*，*其中您的程序通过控制台读取输入数据； `stdout`*，*程序发送输出数据；和 `stderr`*，*具有显示错误或其他与应用程序相关信息的特殊用途。日志记录器通常使用`stderr`以避免影响输出数据。例如，假设您有一个解码输入流的工具。您希望工具只将解码后的数据发送到输出流。程序将如何通知您它遇到的问题？在这种情况下，我们可以使用`stderr`流，它作为一个输出流工作，但不会污染`stdout`？有一个`stderr`流，它作为一个输出流工作，但不会污染`stdout`。'
- en: 'Add the logger to the dependencies list of your `Cargo.toml`  file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志记录器添加到您的`Cargo.toml`文件的依赖项列表中：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then add these types to your `main.rs` file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这些类型添加到您的`main.rs`文件中：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Log levels
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志级别
- en: 'As we discussed earlier, with the `log` crate, we need to import the following
    logging macros. We can use the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，使用`log` crate，我们需要导入以下日志宏。我们可以使用以下：
- en: '`trace!`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace!`'
- en: '`debug!`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug!`'
- en: '`info!`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info!`'
- en: '`warn!`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warn!`'
- en: '`error!`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error!`'
- en: 'These are ordered by the importance of the information they print, with `trace!`
    being the least important and `error!` being the most important:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按它们打印的信息的重要性排序，其中`trace!`是最不重要的，而`error!`是最重要的：
- en: '`trace!`: Used to print verbose information about any pivotal activity. It
    allows web servers to trace any incoming chunk of data.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace!`: 用于打印关于任何关键活动的详细信息。它允许Web服务器跟踪任何传入的数据块。'
- en: '`debug!`: Used for less verbose messages, such as the incoming server requests.
    It is useful for debugging.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug!`: 用于较少冗余的消息，例如传入的服务器请求。它对调试很有用。'
- en: '`info!`: Used for important information such as the runtime or server configuration.
    It is rarely used in library crates.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info!`: 用于重要信息，如运行时或服务器配置。在库crate中很少使用。'
- en: '`warn!`: Informs the user about non-critical errors, such as if the client
    has used broken cookies or if the necessary microservice is temporarily unavailable
    and cached data is used for responses instead.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warn!`：通知用户关于非关键错误，例如如果客户端使用了损坏的cookie，或者必要的微服务暂时不可用，并且使用缓存数据作为响应。'
- en: '`error!`: Provides an alert about critical errors. This is used when the database
    connection is broken.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error!`：提供关于关键错误的警报。这用于数据库连接中断的情况。'
- en: We imported the necessary macro directly from the `log` crate.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接从`log`crate中导入了必要的宏。
- en: Logging messages
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录日志
- en: 'Logging is not useful without the contextual data of the code. Every logging
    macro expects a text message that can contain positional parameters. For example,
    take a look at the `println!` macro:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 没有代码的上下文数据，日志记录是没有用的。每个日志宏都期望一个可以包含位置参数的文本消息。例如，看看`println!`宏：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code will work for types that implement the `Display` trait. As
    in the `println!` macro, you can add types that implement the `Debug` trait with
    the `{:?}` formatter. It's useful to derive the `Debug` trait for all types in
    your code with `#[derive(Debug)]` and set the  `#![deny(missing_debug_implementations)]`
    attribute for the whole crate.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将适用于实现了`Display`特质的类型。就像在`println!`宏中一样，你可以添加实现了`Debug`特质的类型，并使用`{:?}`格式化器。对于你的代码中的所有类型使用`#[derive(Debug)]`并设置整个crate的`#![deny(missing_debug_implementations)]`属性是有用的。
- en: Custom level of messages
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息的自定义级别
- en: Levels have an important role in the logging process. They are used for filtering
    the records by their priority. If you set the `info` level for the `logger`, it
    will skip all the `debug` and `trace` records. Obviously, you need more verbose
    logging for debugging purposes and less verbose logging to use the server in production.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 级别在日志记录过程中起着重要的作用。它们用于根据优先级过滤记录。如果你为`logger`设置了`info`级别，它将跳过所有`debug`和`trace`记录。显然，在调试目的时需要更详细的日志记录，而在生产中使用服务器时则需要更简略的日志记录。
- en: 'Internally, every macro of the `log` crate uses the `log!` macro, which has
    an argument to set the level:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`log`crate的每个宏都使用`log!`宏，该宏有一个参数用于设置级别：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It takes an instance of the `Level` enumeration that has the following variants—`Trace`,
    `Debug`, `Info`, `Warn`, and `Error`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要一个`Level`枚举的实例，该枚举有以下变体——`Trace`、`Debug`、`Info`、`Warn`和`Error`。
- en: Checking logging is enabled
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查日志是否启用
- en: 'Sometimes, logging may require a lot of resources. In this case, you can use
    the `log_enabled!` macro to check that a certain logging level has been enabled:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，日志记录可能需要很多资源。在这种情况下，你可以使用`log_enabled!`宏来检查是否已启用某个日志级别：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Own target
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义目标
- en: 'Every log record has a target. A typical logging record looks as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志记录都有一个目标。一个典型的日志记录看起来如下：
- en: '![](img/c33631fa-2d5f-4e41-a7d4-24b88db2bd90.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c33631fa-2d5f-4e41-a7d4-24b88db2bd90.png)'
- en: The log record consists of the logging level, the time (not shown in this output),
    the target, and the message. You can think about the target as a namespace. If
    no target is specified, the `log` crate uses the `module_path!` macro to set one.
    We can use the target to detect the module where an error or warning has happened
    or use it for filtering records by name. We will see how to set filtering by environment
    variable in the following section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录包含日志级别、时间（在此输出中未显示）、目标和消息。你可以将目标视为一个命名空间。如果没有指定目标，`log`crate将使用`module_path!`宏来设置一个。我们可以使用目标来检测错误或警告发生的位置，或者用它来按名称过滤记录。我们将在下一节中看到如何通过环境变量设置过滤。
- en: Using logging
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日志记录
- en: 'We can now add logging to our microservice. In the following example, we will
    print information about the socket address, the incoming request, and a generated
    random value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为我们的微服务添加日志记录。在以下示例中，我们将打印关于套接字地址、传入请求和生成的随机值的信息：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using logging is quite simple. We can use macros to print the address of the
    socket and information about the request and response.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志记录相当简单。我们可以使用宏来打印套接字的地址以及请求和响应的信息。
- en: Configuring a logger with variables
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量配置记录器
- en: There are some environment variables that you can use to configure a logger.
    Let's take a look at each variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些环境变量可以用来配置记录器。让我们看看每个变量。
- en: RUST_LOG
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RUST_LOG
- en: Compile this example. To run it with an activated logger, you have to set the `RUST_LOG`
    environment variable. The `env_logger` crate reads it and configures the logger
    using filters from this variable. A `logger` instance must be configured with
    a corresponding logging level.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此示例。要使用激活的日志记录器运行它，您必须设置`RUST_LOG`环境变量。`env_logger`包读取它，并使用此变量的过滤器配置日志记录器。必须使用相应的日志级别配置`logger`实例。
- en: You can set the `RUST_LOG` variable globally. If you use the Bash shell, you
    can set it in your `.bashrc` file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以全局设置`RUST_LOG`变量。如果您使用Bash shell，您可以在`.bashrc`文件中设置它。
- en: 'You can set `RUST_LOG` temporarily before the `cargo run` command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`cargo run`命令之前临时设置`RUST_LOG`：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, this will also print a lot of `cargo` tool and compiler records, because
    the Rust compiler also uses the `log` crate for logging. You can exclude all records
    except for those of your program using filtering by name. You only need to use
    part of the target name, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也会打印大量的`cargo`工具和编译器记录，因为Rust编译器也使用`log`包进行日志记录。您可以通过名称过滤排除所有记录，除了您程序中的记录。您只需要使用目标名称的一部分，如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This value of the `RUST_LOG` variable filters all records by the *warn* level
    and uses the *trace* level for targets starting with the `random_service` prefix.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此`RUST_LOG`变量的值通过`warn`级别过滤所有记录，并为以`random_service`前缀开始的目标使用`trace`级别。
- en: RUST_LOG_STYLE
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RUST_LOG_STYLE
- en: 'The `RUST_LOG_STYLE` variable sets the style of printed records. It has three
    variants:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUST_LOG_STYLE`变量设置打印记录的样式。它有三个变体：'
- en: '**auto**: Tries to use the style characters'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**auto**：尝试使用样式字符'
- en: '**always**: Always uses the style characters'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**always**：始终使用样式字符'
- en: '**never**: Turns off the style characters'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**never**：关闭样式字符'
- en: 'See the following example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I recommend that you use the `never` value if you redirect the `stderr` output
    a file or if you want to use `grep` or `awk` to extract values with special patterns.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您使用`never`值，如果您将`stderr`输出重定向到文件，或者您想使用`grep`或`awk`提取具有特殊模式的值。
- en: Changing the RUST_LOG variable to your own
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`RUST_LOG`变量更改为您自己的
- en: 'If you release your own product, you may need to change the name of the `RUST_LOG`
    and the `RUST_LOG_STYLE` variable to your own. New releases of the `env_logger`
    contain the `init_from_env` special function to fix this. This expects one argument—an
    instance of the `Env` object. Take a look at the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发布自己的产品，您可能需要更改`RUST_LOG`和`RUST_LOG_STYLE`变量的名称。`env_logger`的新版本包含一个用于修复此问题的`init_from_env`特殊函数。它期望一个参数——一个`Env`对象的实例。请看以下代码：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It creates an `Env` instance and sets the `OWN_LOG_VAR` variable to configure
    logging and the `OWN_LOG_STYLE_VAR` variable to control the style of the logs.
    When the `env` object is created, we will use it as an argument for the `init_from_env`
    function call of the `env_logger` crate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个`Env`实例，并将`OWN_LOG_VAR`变量设置为配置日志，将`OWN_LOG_STYLE_VAR`变量设置为控制日志的样式。当创建`env`对象时，我们将将其用作`env_logger`包的`init_from_env`函数调用的参数。
- en: Reading environment variables
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取环境变量
- en: In the previous example, we used a value of the `RUST_LOG` environment variable
    to set filtering parameters for logging. We can use other environment variables
    to set parameters for our server as well. In the following example, we will use
    the `ADDRESS` environment variable to set the address of the socket we want to
    bind.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用`RUST_LOG`环境变量的值来设置日志记录的过滤参数。我们还可以使用其他环境变量来设置服务器的参数。在以下示例中，我们将使用`ADDRESS`环境变量来设置我们想要绑定的套接字地址。
- en: Standard library
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库
- en: 'There are enough functions in the `std::env` standard module to work with environment
    variables. It contains the `var` function to read external values. This function
    returns a `Result` with a `String` value of the variable if it exists, or a `VarError`
    error if it doesn''t exist. Add the import of the `env` module to your `main.rs`
    file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::env`标准模块中提供了足够多的函数来处理环境变量。它包含`var`函数来读取外部值。如果变量存在，此函数返回一个包含变量`String`值的`Result`，如果不存在，则返回一个`VarError`错误。将`env`模块的导入添加到您的`main.rs`文件中：'
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need to replace the following line:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要替换以下行：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Replace it with the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为以下内容：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This new code reads the `ADDRESS` value. If this value doesn't exist, we won't
    let the code throw a panic. Instead, we will replace it with the default value, `"127.0.0.1:8080"`,
    using the `unwrap_or_else` method call. As the `var` function returns a `String`,
    we also have to convert `&'static str` into a `String` instance with the `into`
    method call.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码读取`ADDRESS`值。如果此值不存在，我们不会让代码抛出panic。相反，我们将使用`unwrap_or_else`方法调用将其替换为默认值`"127.0.0.1:8080"`。由于`var`函数返回一个`String`，我们还需要使用`into`方法调用将`&'static
    str`转换为`String`实例。
- en: If we can't parse an address, we will throw a panic in the `except` method call.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法解析地址，我们将在`except`方法调用中抛出panic。
- en: Your server will now use the `addr` variable, which takes a value from the `ADDRESS`
    environment variable or from the default value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您的服务器现在将使用`addr`变量，该变量从`ADDRESS`环境变量或默认值中获取值。
- en: Environment variables are a simple way of configuring your application. They
    are also widely supported with hosting or cloud platforms and Docker containers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是配置应用程序的一种简单方式。它们也广泛得到托管或云平台和Docker容器的支持。
- en: Remember that all sensitive data is visible to the system administrator of the
    host. In Linux, the system administrator can read this data simply by using the ``cat
    /proc/`pidof random-service-with-env`/environ` | tr '\0' '\n'`` command. This
    means that it's not a good idea to set the secret key of your bitcoin wallet to
    the environment variable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有敏感数据都对主机系统管理员可见。在Linux中，系统管理员可以通过使用`cat /proc/`pidof random-service-with-env`/environ`
    | tr '\0' '\n''`命令来读取这些数据。这意味着将比特币钱包的密钥设置为环境变量不是一个好主意。
- en: Using the .env file
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`.env`文件
- en: Setting many environment variables is time-consuming. We can simplify this using
    configuration files, which we will explore further at the end of this chapter.
    However, configuration files can't be used in cases where the crates or dependencies
    use environment variables.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设置许多环境变量很耗时。我们可以通过使用配置文件来简化这一点，我们将在本章末尾进一步探讨。然而，在包或依赖项使用环境变量的情况下，不能使用配置文件。
- en: To make this process simple, we can use the `dotenv` crate. This is used to
    set environment variables from a file. This practice appeared as part of *The
    Twelve-Factor App* methodology *([https://12factor.net/](https://12factor.net/))*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过程简单，我们可以使用`dotenv`包。这个包用于从文件中设置环境变量。这种做法作为*十二要素应用*方法的一部分出现（[https://12factor.net/](https://12factor.net/)*）。
- en: '*The Twelve-Factor App* approach is a methodology for building **Software as
    a Service** (**SaaS**) applications to fulfill the following three objectives:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*十二要素应用*方法是一种构建**软件即服务**（**SaaS**）应用程序的方法，旨在实现以下三个目标：'
- en: Configurations in declarative formats
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式格式配置
- en: Maximum portability with operating systems and clouds
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与操作系统和云的最大可移植性
- en: Continuous deployment and scaling
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署和扩展
- en: This methodology encourages you to use environment variables to configure the
    application. The *Twelve-Factor App* approach doesn't require disk space for configuration
    and it is extremely portable, meaning that all operating systems support the environment
    variables.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法鼓励你使用环境变量来配置应用程序。*十二要素应用*方法不需要配置磁盘空间，并且具有极高的可移植性，这意味着所有操作系统都支持环境变量。
- en: Using the dotenv crate
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`dotenv`包
- en: The `dotenv` crate allows you to set environment variables in a file called
    `.env` and join them with variables set in the traditional way. You don't need
    to read this file manually. All you need to do is add the dependency and call
    the initialization method of the crate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotenv`包允许你在名为`.env`的文件中设置环境变量，并将它们与以传统方式设置的环境变量连接起来。你不需要手动读取此文件。你只需要添加依赖项并调用包的初始化方法。'
- en: 'Add this crate to the list of `dependencies` :'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将此包添加到`dependencies`列表中：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following imports to the `main.rs` file of the previous example to
    use the `dotenv` crate:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下导入添加到上一个示例的`main.rs`文件中，以使用`dotenv`包：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Initialize it with the `dotenv` function, which will try to find the `.env`
    file. It will return a `Result` with a path to this file. Call the `ok` method
    of the `Result` to ignore it if the file hasn't been found.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dotenv`函数初始化它，该函数将尝试找到`.env`文件。它将返回一个包含此文件路径的`Result`。如果文件未找到，调用`Result`的`ok`方法来忽略它。
- en: Adding variables to the .env file
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向`.env`文件添加变量
- en: 'The `.env` file contains pairs of names and values of environment variables.
    For our service, we will set the `RUST_LOG`, `RUST_BACKTRACE`, and `ADDRESS` variables:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`.env`文件包含环境变量的名称和值对。对于我们的服务，我们将设置`RUST_LOG`、`RUST_BACKTRACE`和`ADDRESS`变量：'
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we set all the targets of the `logger` to the `debug` level,
    because `cargo` doesn't use `dotenv` and therefore skips these settings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将`logger`的所有目标都设置为`debug`级别，因为`cargo`不使用`dotenv`，因此跳过了这些设置。
- en: The `RUST_BACKTRACE` variable sets the flag to print a backtrace of the application
    in the case of panic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUST_BACKTRACE`变量设置标志，在应用程序发生panic时打印应用程序的回溯。'
- en: Store this file in the working directory from which you will run the application.
    You can have multiple files and use them for different configurations. This file
    format is also compatible with Docker and can be used to set variables to the
    container.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件存储在运行应用程序的工作目录中。你可以有多个文件，并使用它们进行不同的配置。此文件格式也与Docker兼容，可以用于设置容器的变量。
- en: I recommend that you add the `.env` file to your `.gitignore` to prevent leaking
    of sensitive or local data. This means that every user or developer who works
    with your project has their own environment and needs their own version of the `.env`
    file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你将`.env`文件添加到`.gitignore`中，以防止敏感或本地数据的泄露。这意味着每个与你的项目一起工作的用户或开发者都有自己的环境和需要他们自己的`.env`文件版本。
- en: Parsing command-line arguments
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析命令行参数
- en: Environment variables are useful for using with containers. If you use your
    application from a console or you want to avoid a conflict of names with other
    variables, you can use command-line parameters. This is a more conventional way
    for developers to set parameters to the program.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量对于与容器一起使用很有用。如果你从控制台使用应用程序或想避免与其他变量名称冲突，你可以使用命令行参数。这是开发者设置程序参数的更传统方式。
- en: 'You can also get command-line arguments with the `env` module. This contains
    the `args` function, which returns an `Args` object. This object is not an array
    or vector, but it''s iterable and you can use the `for` loop processes all command-line
    arguments:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`env`模块获取命令行参数。它包含`args`函数，该函数返回一个`Args`对象。此对象不是一个数组或向量，但它可迭代，你可以使用`for`循环处理所有命令行参数：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This variant may come in handy in simple cases. For parsing arguments with complex
    rules, however, you have to use a command-line argument parser. A good implementation
    of this is contained in the `clap` crate.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单情况下，这个变体可能很有用。然而，对于具有复杂规则的参数解析，你必须使用命令行参数解析器。`clap`crate中包含了一个很好的实现。
- en: Using the clap crate
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`clap`crate
- en: To use the `clap` crate for parsing arguments, you have to build a parser and
    use it for arguments. To build a parser, you start by creating an instance of
    the `App` type. To use it, add all the necessary imports.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`clap`crate解析参数，你必须构建一个解析器并使用它来处理参数。要构建解析器，你首先创建一个`App`类型的实例。要使用它，添加所有必要的导入。
- en: Adding dependencies
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'Add a dependency to `Cargo.toml`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`中添加依赖项：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This crate provides useful macros for adding meta information about the program.
    These are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此crate提供了一些有用的宏，用于添加关于程序元信息。具体如下：
- en: '`crate_name!`: Returns the name of the crate'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crate_name!`：返回crate的名称'
- en: '`crate_version!`: Returns the version of the crate'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crate_version!`：返回crate的版本'
- en: '`crate_authors!`: Returns the list of authors'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crate_authors!`：返回作者列表'
- en: '`crate_description!`: Provides the description of the crate'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crate_description!`：提供crate的描述'
- en: All information for these macros is taken from the `Cargo.toml` file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏的所有信息都来自`Cargo.toml`文件。
- en: 'Import the necessary types. We need two types, which are `App` and `Arg`, and
    the macros mentioned previously:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 导入必要的类型。我们需要两个类型，即`App`和`Arg`，以及之前提到的宏：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Building a parser
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建解析器
- en: 'The process of building a parser is quite simple. You will create an `App`
    instance and feed this type with the `Arg` instances. The `App` also has methods
    that can be used to set information about the application. Add the following code
    to the `main` function of our server:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构建解析器的过程相当简单。你将创建一个`App`实例，并用`Arg`实例填充此类型。`App`还有可以用来设置应用程序信息的方法。将以下代码添加到我们服务器的`main`函数中：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we create an `App` instance with a `new` method that expects the name
    of the crate. We provide this using the `crate_name!` macro. After that, we use
    the `version`, `author`, and `about` methods to set this data using the corresponding
    macros. We can chain these method calls, because every method consumes and returns
    the updated `App` object. When we set meta-information about the application,
    we have to declare the supported arguments with the `arg` method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`new`方法创建一个`App`实例，该方法期望接收crate的名称。我们使用`crate_name!`宏提供这个名称。之后，我们使用`version`、`author`和`about`方法通过相应的宏设置这些数据。我们可以链式调用这些方法，因为每个方法都会消耗并返回更新后的`App`对象。当我们设置应用程序的元信息时，我们必须使用`arg`方法声明支持的参数。
- en: To add an argument, we have to create an `Arg` instance with the `with_name`
    method, provide the name, and set extra parameters using chaining-of-methods calls.
    We can set a short form of the argument with the `short` method and the long form
    with the `long` method. You can set the name of the value for the generated documentation
    using the `value_name` method. You can provide a description of an argument using
    the  `help` method. The `takes_value` method is used to indicate that this argument
    requires a value. There is also a `required` method to indicate that an option
    is required, but we didn't use that here. All options are optional in our server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个参数，我们必须使用`with_name`方法创建一个`Arg`实例，提供名称，并使用链式方法调用设置额外的参数。我们可以使用`short`方法设置参数的简写形式，使用`long`方法设置长写形式。你可以使用`value_name`方法为生成的文档设置值的名称。你可以使用`help`方法提供参数的描述。`takes_value`方法用于指示此参数需要值。还有一个`required`方法用于指示选项是必需的，但在这里我们没有使用它。在我们的服务器中，所有选项都是可选的。
- en: We added the `--address` argument using these methods to set the address of
    the socket that we will use to bind the server. It also supports the short form
    `a` of the argument. We will read this value later.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些方法添加了`--address`参数，用于设置我们将用于绑定服务器的套接字地址。它还支持参数的简写形式`a`。我们将在稍后读取这个值。
- en: The server will support the `--config` argument to set a configuration file.
    We have added this argument to the builder, but we will use it in the next section
    of this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将支持`--config`参数来设置配置文件。我们已经将此参数添加到构建器中，但我们将在本章的下一节中使用它。
- en: After we create the builder, we call the `get_matches` method. This reads arguments
    with `std::env::args_os` and returns an `ArgMatches` instance, which we can use
    to get the values of the command-line parameters. We assign it to the `matches`
    local variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建构建器之后，我们调用`get_matches`方法。这个方法读取`std::env::args_os`中的参数，并返回一个`ArgMatches`实例，我们可以使用它来获取命令行参数的值。我们将它分配给`matches`局部变量。
- en: We should add the `get_matches` method before any logging call because it also
    prints help messages. We should avoid printing logs with the help description.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在任何日志调用之前添加`get_matches`方法，因为它也会打印帮助信息。我们应该避免打印带有帮助描述的日志。
- en: Reading arguments
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读参数
- en: 'To read arguments, `ArgMatches` contains a `value_of` method, where you add
    the name of a parameter. In this case, it is convenient to use constants to avoid
    typos. Extract the  `--address` argument, and if this does not exist, then check
    the `ADDRESS` environment variable. This means that the command-line argument
    is a higher priority than the environment variable and you can override the parameters
    from the `.env` file with command-line parameters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取参数，`ArgMatches`包含一个`value_of`方法，其中你可以添加一个参数的名称。在这种情况下，使用常量很方便，可以避免输入错误。提取`--address`参数，如果它不存在，则检查`ADDRESS`环境变量。这意味着命令行参数的优先级高于环境变量，并且你可以使用命令行参数覆盖`.env`文件中的参数：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this code, we have converted all of the provided string references with the
    `&str` type to solid `String` objects. This is useful if you want to use the object
    later in the code or if you need to move it elsewhere.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将所有提供的字符串引用转换为`&str`类型的实体`String`对象。如果你想在代码的后续部分使用这个对象，或者需要将其移动到其他地方，这很有用。
- en: Usage
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法
- en: 'When you use the `clap` crate in your application, you can use command-line
    parameters to tweak it. The `clap` crate adds a `--help` argument, which the user
    can use to print information about all the arguments. This description was generated
    automatically by the crate, as can be seen in the following example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在你的应用程序中使用`clap`crate时，你可以使用命令行参数来调整它。`clap`crate添加了一个`--help`参数，用户可以使用它来打印有关所有参数的信息。这个描述是由crate自动生成的，如下面的示例所示：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our application successfully printed the usage info: it provided us with all
    flags, options, and usage variants. If you need to add your own help description,
    you can use the `help` method of the `App` instance to set any string as a help
    message.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序成功打印了用法信息：它提供了所有标志、选项和用法变体。如果你需要添加自己的帮助描述，可以使用 `App` 实例的 `help` 方法设置任何字符串作为帮助信息。
- en: 'If you use the `cargo run` command, you can also set command-line parameters
    after the `--` parameter. This means that it stops reading the `run` command and
    passes all remaining arguments to the running application:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `cargo run` 命令，你还可以在 `--` 参数之后设置命令行参数。这意味着它停止读取 `run` 命令，并将所有剩余的参数传递给正在运行的应用程序：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can now start the server and set an address using the `--address` parameter
    with value:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `--address` 参数并设置值为来启动服务器：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The server has started and prints to the console:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已启动并向控制台打印：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How to add subcommands
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何添加子命令
- en: 'Some popular applications, such as `cargo` and `docker`, use subcommands to
    provide multiple commands inside a single binary. We can also support subcommands
    with the `clap` crate. A microservice might have two commands: one to run the
    server and one to generate a secret for the HTTP cookies. Take a look at the following
    code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的应用程序，例如 `cargo` 和 `docker`，使用子命令在单个二进制文件内提供多个命令。我们也可以使用 `clap` 包来支持子命令。一个微服务可能有两个命令：一个用于运行服务器，另一个用于生成
    HTTP 甜点的密钥。看看下面的代码：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we have used two methods. The `setting` method tweaks the builder and
    you can set it with variants of the `AppSettings` enumeration. The `SubcommandRequiredElseHelp` method
    requires us to use subcommands or prints help message if no subcommands are provided.
    To add a subcommand, we use the `subcommand` method with the `SubCommand` instance
    that we created with the `with_name` method. A subcommand instance also has methods
    to set meta information about a subcommand, like we did with the `App` instance.
    Subcommands can also take arguments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了两种方法。`setting` 方法调整构建器，你可以使用 `AppSettings` 枚举的变体来设置它。`SubcommandRequiredElseHelp`
    方法要求我们使用子命令，如果没有提供子命令，则打印帮助信息。要添加子命令，我们使用 `subcommand` 方法，并使用通过 `with_name` 方法创建的
    `SubCommand` 实例。子命令实例也有设置子命令元信息的方法，就像我们对 `App` 实例所做的那样。子命令也可以接受参数。
- en: 'In the preceding example above, we added two subcommands—`run`, to run the
    server, and `key`, to generate secrets. You can use these when you start the application:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们添加了两个子命令——`run` 用于运行服务器，`key` 用于生成密钥。当你启动应用程序时，你可以使用这些命令：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have two `run` arguments because the cargo has a command with the same name.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个 `run` 参数，因为 cargo 有一个同名的命令。
- en: Reading the configuration from file
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取配置
- en: Environment variables and command-line arguments are useful to add temporary
    change parameters for a single run. They are a more convenient way to configure
    servers to use configuration files. This approach doesn't conform to The *Twelve-Factor
    App* methodology, but it's useful in cases when you need to set long parameters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量和命令行参数对于添加单次运行的临时更改参数很有用。它们是配置服务器使用配置文件的更方便的方式。这种方法不符合 *十二要素应用* 方法论，但在需要设置长参数的情况下很有用。
- en: There are many formats that can be used for configuration files. The popular
    ones include TOML, YAML, and JSON. We will use TOML, because it is widely used
    with the Rust programming language.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于配置文件的格式有很多。其中一些流行的包括 TOML、YAML 和 JSON。我们将使用 TOML，因为它在 Rust 编程语言中得到了广泛的应用。
- en: Adding the TOML config
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 TOML 配置
- en: The TOML file format is implemented in the `toml` crate. It previously used
    the now-obsolete `rustc-serialize` crate, but the last few versions have used
    the `serde` crate for serialization and deserialization. We will use both the `toml`
    and the `serde` crates.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 文件格式在 `toml` 包中实现。它之前使用的是现在已废弃的 `rustc-serialize` 包，但最近几个版本已经使用 `serde`
    包进行序列化和反序列化。我们将使用 `toml` 和 `serde` 包。
- en: Adding dependencies
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'We actually need not only the `serde` crate but also the `serde_derive` crate.
    Both crates help with the serialization struct in various serialization formats.
    Add all three crates to the dependencies list in `Cargo.toml`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不仅需要 `serde` 包，还需要 `serde_derive` 包。这两个包都帮助在多种序列化格式中处理序列化结构体。将所有三个包添加到
    `Cargo.toml` 文件的依赖列表中：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The full list of imports in the `main.rs` file contains the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.rs` 文件中的完整导入列表包含以下内容：'
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, we haven't imported the `serde` crate here. We won't use it
    directly in the code because it's necessary to use the `serde_derive` crate instead.
    We have imported all macros from the `serde_derive` crate, because the `serde`
    crate contains the `Serialize` and `Deserialize` traits and `serde_derive` helps
    us to derive these for our structs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这里没有导入`serde`包。我们不会直接在代码中使用它，因为它需要使用`serde_derive`包。我们已经导入了`serde_derive`包中的所有宏，因为`serde`包包含`Serialize`和`Deserialize`特性，而`serde_derive`帮助我们为我们的结构体推导这些特性。
- en: Microservices often need to serialize and deserialize data when interacting
    with the client. We will cover this topic in the next chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务在与客户端交互时通常需要序列化和反序列化数据。我们将在下一章中介绍这个主题。
- en: Declaring a struct for configuration
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明配置结构体
- en: 'We have now imported all the necessary dependencies and can declare our configuration
    file structure. Add the `Config` struct to your code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经导入了所有必要的依赖项，可以声明我们的配置文件结构。将`Config`结构体添加到您的代码中：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This struct contains only one field with the address. You can add more, but
    remember that all fields have to implement the `Deserialize` trait. The `serde`
    crate already has implementations for standard library types. For our types, we
    have to derive the implementation of `Deserialize` with the macro of the `serde_derive`
    crate.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构体仅包含一个带有地址的字段。您可以添加更多字段，但请记住，所有字段都必须实现`Deserialize`特性。`serde`包已经为标准库类型提供了实现。对于我们的类型，我们必须使用`serde_derive`包的宏推导`Deserialize`的实现。
- en: Everything is ready for us to read the configuration from the file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪，我们可以从文件中读取配置。
- en: Reading the configuration file
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取配置文件
- en: 'Our server will expect to find a configuration file in the current working
    folder with the name `microservice.toml`. To read a configuration and convert
    it to the `Config` struct, we need to find and read this file if it exists. Add
    the following code to the `main` function of the server:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器期望在当前工作目录中找到一个名为`microservice.toml`的配置文件。为了读取配置并将其转换为`Config`结构体，我们需要找到并读取此文件（如果存在）。将以下代码添加到服务器的`main`函数中：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code is a chain of method calls that start with the `File` instance.
    We use the `open` method to open the file and provide the name `microservice.toml`.
    The call returns a `Result`, which we will process in the chain. At the end of
    the processing, we will convert it to an option using the `ok` method and ignore
    any errors that occur during the parsing of the config file. This is because our
    service also supports environment variables and command-line parameters and has
    defaults for unset parameters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一系列以`File`实例开始的调用链。我们使用`open`方法打开文件并提供名称`microservice.toml`。调用返回一个`Result`，我们将在调用链中处理它。在处理结束时，我们将使用`ok`方法将其转换为选项，并忽略在解析配置文件过程中发生的任何错误。这是因为我们的服务也支持环境变量和命令行参数，并为未设置的参数提供了默认值。
- en: When the file is ready, we will try to convert it into a `String`. We created
    an empty string, called a buffer, and used the `read_to_string` method of the `File`
    instance to move all of the data into the buffer. This is a synchronous operation.
    It's suitable for reading a configuration but you shouldn't use it for reading
    files to send to the client, because it will lock the runtime of the server until
    the file is read.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件准备就绪时，我们将尝试将其转换为`String`。我们创建了一个空字符串，称为缓冲区，并使用`File`实例的`read_to_string`方法将所有数据移动到缓冲区中。这是一个同步操作。它适合读取配置，但您不应该用它来读取发送给客户端的文件，因为它将锁定服务器的运行时直到文件读取完成。
- en: After we have read the `buffer` variable, we will try to parse it as a TOML
    file into the `Config` struct. The `toml` crate has a `from_str` method in the
    root namespace of the crate. It expects a type parameter to deserialize and an
    input string. We use the `Config` struct for the output type and our `buffer`
    for the input. But there is a problem: the `File` uses `io::Error` for errors,
    but `from_str` uses `toml::de:Error` for the error type. We can convert the second
    type to `io::Error` to make it compatible with the chain of calls.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们读取`buffer`变量之后，我们将尝试将其解析为TOML文件并将其转换为`Config`结构体。`toml`包在包的根命名空间中有一个`from_str`方法。它期望一个类型参数用于反序列化和一个输入字符串。我们使用`Config`结构体作为输出类型，使用`buffer`作为输入。但是有一个问题：`File`使用`io::Error`作为错误类型，但`from_str`使用`toml::de:Error`作为错误类型。我们可以将第二种类型转换为`io::Error`以使其与调用链兼容。
- en: The penultimate part of the chain is the `map_err` method call. We use this
    to write any errors with the configuration file to logs. As you can see, we used
    the `Warn` level. Issues with the configuration file are not critical, but it
    is important to be aware of them because they can affect the configuration. This
    makes the `microservices.toml` file optional.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 链表的倒数第二个部分是`map_err`方法调用。我们使用它将任何配置文件错误写入日志。正如你所见，我们使用了`Warn`级别。配置文件的问题不是关键的，但了解它们很重要，因为它们可能会影响配置。这使得`microservices.toml`文件成为可选的。
- en: Joining all values by a priority
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按优先级连接所有值
- en: 'Our server has four sources of address settings:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器有四个地址设置的来源：
- en: The configuration file
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件
- en: The environment variable
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: The command-line parameter
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: The default value
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认值
- en: 'We have to join these in this order. It''s simple to implement this using a
    set of options and using the `or` method to set a value if the option doesn''t
    contain anything. Use the following code to get address values from all of the
    sources:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须按此顺序连接它们。使用一组选项和`or`方法设置值，如果选项不包含任何内容，则实现这一点很简单。使用以下代码从所有来源获取地址值：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At first, this code takes a value from the `--address` command-line parameter.
    If it doesn't contain any value, the code tries to get a value from the `ADDRESS`
    environment variable. After that, we try to parse a textual value to the socket
    address. If all these steps fail, we can try to get a value from the `Config`
    instance that we read from `microservice.toml`.  We will use the default address
    value if the value wasn't set by a user. In the previous address-parsing code,
    we also parsed the default value from a string. In this code, we use a tuple to
    construct the `SocketAddr` instance. Since we are guaranteed to get a value, we
    `unwrap` the option to extract it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，此代码从`--address`命令行参数获取一个值。如果它不包含任何值，代码将尝试从`ADDRESS`环境变量中获取一个值。之后，我们尝试将文本值解析为套接字地址。如果所有这些步骤都失败，我们可以尝试从我们从`microservice.toml`读取的`Config`实例中获取一个值。如果没有用户设置值，我们将使用默认地址值。在之前的地址解析代码中，我们也从字符串中解析了默认值。在此代码中，我们使用一个元组来构建`SocketAddr`实例。由于我们保证会得到一个值，所以我们使用`unwrap`来提取它。
- en: Creating and using the configuration file
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用配置文件
- en: 'We can now create a configuration file and run the server. Create the `microservice.toml`
    file in the root folder of the project and add the following line to it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个配置文件并运行服务器。在项目的根目录中创建`microservice.toml`文件，并添加以下行到其中：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Compile and start the service and you will see it has bound to that address:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并启动服务，你会看到它已经绑定到了该地址：
- en: '![](img/99563a72-b365-490a-a091-846628f66c5e.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99563a72-b365-490a-a091-846628f66c5e.png)'
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we added logging to the server and learned how to activate
    the `logger` and set filters to it. After that, we transformed our unflexible
    server to a configurable microservice that can read settings from different sources—the
    configuration file, the environment variable, and the command-line parameters.
    We became familiar with *The Twelve-Factor App* methodology and used the `dotenv`
    crate, which helped us to read environment variables from a file. We also used
    the `clap` crate to add a command-line parser. Finally, we touched on the `serde`
    crate, which introduced us to the world of serialization.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向服务器添加了日志记录，并学习了如何激活`logger`并设置其过滤器。之后，我们将我们的不灵活服务器转换为一个可配置的微服务，可以从不同的来源读取设置——配置文件、环境变量和命令行参数。我们熟悉了*十二要素应用*方法，并使用了`dotenv`
    crate，它帮助我们从文件中读取环境变量。我们还使用了`clap` crate来添加命令行解析器。最后，我们简要介绍了`serde` crate，它带我们进入了序列化的世界。
- en: 'In the next chapter we will learn how to use `serde` crate for needs of a microservices:
    to deserialize request and serialize responses to a certain format like JSON,
    CBOR, BSON, MessagePack, etc.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用`serde` crate来满足微服务的需求：将请求反序列化并将响应序列化到特定的格式，如JSON、CBOR、BSON、MessagePack等。
