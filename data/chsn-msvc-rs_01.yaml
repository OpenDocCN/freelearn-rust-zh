- en: Introduction to Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: This chapter will introduce you to the basics of microservices, including what
    a microservice is and how to break a monolithic server down into microservices.
    It will be useful if you are not familiar with the concept of microservices or
    if you have never implemented them using the Rust programming language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍微服务的基础知识，包括微服务是什么以及如何将单体服务器拆分为微服务。如果您不熟悉微服务的概念，或者从未使用Rust编程语言实现过它们，这将很有用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What are microservices?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: How to transform a traditional server architecture into microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将传统服务器架构转换为微服务
- en: The importance of Rust in microservices development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust在微服务开发中的重要性
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter hasn't got any special technical requirements, but now is a good
    time to install or update your Rust compiler. You can get this from Rust's official
    website: [https://www.rust-lang.org/](https://www.rust-lang.org/) . I recommend
    that you use the `rustup` tool, which you can download from [https://rustup.rs/](https://rustup.rs/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有特殊的技术要求，但现在安装或更新您的Rust编译器是个好时机。您可以从Rust的官方网站获取：[https://www.rust-lang.org/](https://www.rust-lang.org/)。我建议您使用`rustup`工具，您可以从[https://rustup.rs/](https://rustup.rs/)下载。
- en: 'If you have previously installed the compiler, you need to update it to the
    latest version using the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前已安装编译器，您需要使用以下命令将其更新到最新版本：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can get the examples for this book from the GitHub page: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub页面获取本书的示例：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/)。
- en: What are microservices?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: Modern users interact with microservices every day; not directly, but by using
    web applications. Microservices are a flexible software development technique
    that help to implement applications as a collection of independent services with
    weak relations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现代用户每天都在与微服务互动；虽然不是直接互动，但通过使用Web应用程序。微服务是一种灵活的软件开发技术，有助于将应用程序作为一系列独立服务集合起来，这些服务之间关系较弱。
- en: In this section, we'll learn about why microservices are a good thing and why
    we need them. Microservices follow the REST architecture, which provides rules
    about using consistent HTTP methods. We will also look at how microservices can
    be deployed to the user, which is one of their main advantages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解为什么微服务是个好东西，以及为什么我们需要它们。微服务遵循REST架构，该架构提供了关于使用一致HTTP方法的规则。我们还将探讨如何将微服务部署给用户，这是它们的主要优势之一。
- en: Why we need microservices
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要微服务
- en: Microservices are a modern software development approach that refers to the
    splitting of software into a suite of small services that are easier to develop,
    debug, deploy, and maintain. Microservices are tiny, independent servers that
    act as single business functions. For example, if you have an e-commerce suite
    that works as a monolith, you could split it into small servers that have limited
    responsibility and carry out the same tasks. One microservice could handle user
    authorization, the other could handle the users' shopping carts, and the remaining
    services could handle features such as search functionality, social-media integration,
    or recommendations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种现代软件开发方法，指的是将软件拆分为一系列小型服务，这些服务更容易开发、调试、部署和维护。微服务是微型的、独立的服务器，充当单一业务功能。例如，如果您有一个作为单体工作的电子商务套件，您可以将其拆分为具有有限责任的小型服务器，执行相同的任务。一个微服务可以处理用户授权，另一个可以处理用户的购物车，其余的服务可以处理诸如搜索功能、社交媒体集成或推荐等功能。
- en: Microservices can either interact with a database or be connected to other microservices.
    To interact with a database, microservices can use different protocols. These
    might include HTTP or REST, Thrift, ZMQ, AMQP for the messaging communication
    style, WebSockets for streaming data, and even the old-fashioned **Simple Object
    Access Protocol** (**SOAP**) to integrate them with the existing infrastructure.
    We will use HTTP and REST in this book, because this is the most flexible way
    to provide and interact with the web API. We'll explain this choice later.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以与数据库交互或连接到其他微服务。为了与数据库交互，微服务可以使用不同的协议。这可能包括HTTP或REST、Thrift、ZMQ、AMQP用于消息通信风格、WebSockets用于流数据，甚至古老的**简单对象访问协议**（**SOAP**）来与现有基础设施集成。本书我们将使用HTTP和REST，因为这是提供和交互Web
    API最灵活的方式。我们将在后面解释这个选择。
- en: 'Microservices have the following advantages over monolithic servers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与单体服务器相比，微服务有以下优势：
- en: You can use different programming languages
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用不同的编程语言
- en: The code base of a single server is smaller
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个服务器的代码库更小
- en: They have an independent DevOps process to build and deploy activities
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有独立的DevOps流程来构建和部署活动
- en: They can be scaled depending on their implementation
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以根据其实现进行扩展
- en: If one microservice fails, the rest will continue to work
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个微服务失败，其余的将继续工作
- en: They work well within containers
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在容器内运行良好
- en: Increased isolation between elements leads to better security
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素之间的隔离性提高导致安全性更好
- en: They are suitable for projects involving the Internet of Things
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们适合涉及物联网的项目
- en: They are in line with the DevOps philosophy
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们与DevOps哲学一致
- en: They can be outsourced
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被外包
- en: They can be orchestrated after development
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发完成后可以进行编排
- en: They are reusable
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是可重用的
- en: 'There are, however, a few drawbacks of microservices. These include the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，微服务也有一些缺点。以下是一些：
- en: Too many microservices overload the development process
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过多的微服务会超负荷开发过程
- en: You have to design interaction protocols
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须设计交互协议
- en: They can be expensive for small teams
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于小型团队来说，它们可能很昂贵
- en: A microservices architecture is a modern approach that can help you achieve
    the goal of having loosely coupling elements. This is where the servers are independent
    from one another, helping you to release and scale your application faster than
    a monolithic approach, in which you put all your eggs in one basket.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一种现代方法，可以帮助你实现拥有松耦合元素的目标。这就是服务器相互独立，帮助你比单体方法更快地发布和扩展应用程序，在单体方法中，你把所有的鸡蛋都放在一个篮子里。
- en: How to deploy a microservice
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何部署微服务
- en: Since a microservice is a small but complete web server, you have to deploy
    it as a complete server. But since it has a narrow scope of features, it's also
    simpler to configure. Containers can help you pack your binaries into an image
    of the operating system with the necessary dependencies to simplify deployment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务是一个小型但完整的Web服务器，你必须将其作为完整的服务器进行部署。但由于其功能范围较窄，配置起来也更简单。容器可以帮助你将二进制文件打包到包含必要依赖项的操作系统镜像中，从而简化部署过程。
- en: This differs from the case with monoliths, in which you have a system administrator
    who installs and configures the server. Microservices need a new role to carry
    out this function—DevOps. DevOps is not just a job role, but a whole software
    engineering culture in which developers become system administrators and vice
    versa. DevOps engineers are responsible for packing and delivering the software
    to the end user or market. Unlike system administrators, DevOps engineers work
    with clouds and clusters and often don't touch any hardware except their own laptop.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这与单体架构的情况不同，在单体架构中，你有一个系统管理员负责安装和配置服务器。微服务需要一个新角色来执行此功能——DevOps。DevOps不仅仅是一个工作角色，而是一种整个软件工程文化，其中开发人员成为系统管理员，反之亦然。DevOps工程师负责打包和交付软件给最终用户或市场。与系统管理员不同，DevOps工程师与云和集群一起工作，通常除了自己的笔记本电脑外不接触任何硬件。
- en: 'DevOps uses a lot of automation and carries the application through various
    stages of the delivery process: building, testing, packaging, releasing, or deployment,
    and the monitoring of the working system. This helps to reduce the time it takes
    both to market a particular software and to release new versions of it. It''s
    impossible to use a lot of automation for monolithic servers, because they are
    too complex and fragile. Even if you want to pack a monolith to a container, you
    have to deliver it as a large bundle and run the risk that any part of the application
    could fail. In this section, we''ll have a brief look at containers and continuous
    integration. We will go into detail about these topics in [Chapter 15](80b8c3ec-d291-40df-a7a7-b9e9f0a64a99.xhtml), *Packing
    Servers to Containers*, and [Chapter 16](02047e73-9d47-4f12-ae3c-99d5c77daf51.xhtml),
    *DevOps of Rust Microservices – Continuous Integration and Delivery*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 使用大量自动化，并将应用程序通过交付流程的各个阶段：构建、测试、打包、发布或部署，以及工作系统的监控。这有助于减少将特定软件推向市场以及发布其新版本所需的时间。对于单体服务器，很难使用大量自动化，因为它们过于复杂且脆弱。即使你想将单体打包到容器中，你也必须以大型捆绑包的形式交付它，并承担应用程序任何部分可能失败的风险。在本节中，我们将简要介绍容器和持续集成。我们将在第15章“将服务器打包到容器中”和第16章“Rust微服务的DevOps
    – 持续集成和交付”中详细介绍这些主题。
- en: Docker
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: When we refer to containers, we almost always mean Docker containers ([https://www.docker.com/](https://www.docker.com/)).
    Docker is the most popular software tool for running programs in containers, which
    are isolated environments.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到容器时，我们几乎总是指Docker容器（[https://www.docker.com/](https://www.docker.com/)）。Docker是运行容器（隔离环境）中程序的最受欢迎的软件工具。
- en: Containerization is a kind of virtualization where the scope of the application's
    resources is limited. This means the application works at its maximum performance
    level. This is different from full virtualization, where you have to run the full
    operating system with the corresponding overhead and run your application inside
    that isolated operating system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化是一种虚拟化形式，其中应用程序资源的作用域受到限制。这意味着应用程序在其最大性能水平上运行。这与全虚拟化不同，全虚拟化需要运行完整的操作系统及其相应的开销，并在该隔离操作系统中运行你的应用程序。
- en: Docker has become popular for a variety of reasons. One of these reasons is
    that it has a registry—the place where you can upload and download images of containers
    with applications. The public registry is Docker Hub ([https://hub.docker.com/explore/](https://hub.docker.com/explore/)),
    but you can have a private registry for a private or permissioned software.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker因其多种原因而变得流行。其中一个原因是它有一个注册表——你可以在这里上传和下载带有应用程序的容器镜像。公共注册表是Docker Hub（[https://hub.docker.com/explore/](https://hub.docker.com/explore/)），但你可以为私有软件拥有一个私有或受权限的注册表。
- en: Continuous Integration
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: '**Continuous Integration** (**CI**) is the practice of keeping a master copy
    of the software and using tests and merging processes to expand the features of
    the application. The process of CI is integrated with the **Source Code Management**
    (**SCM**) process. When the source code is updated (for example, in Git), the
    CI tool checks it and starts the tests. If all tests pass, developers can merge
    the changes to the master branch.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是指保持软件的主副本，并使用测试和合并过程来扩展应用程序的功能。CI的过程与**源代码管理**（**SCM**）过程集成。当源代码更新时（例如，在Git中），CI工具会检查它并开始测试。如果所有测试都通过，开发者可以将更改合并到主分支。'
- en: CI doesn't guarantee that the application will work, because tests can be wrong,
    but it removes the need to run tests from developers on an automated system. This
    gives you the great benefit of being able to test all your upcoming changes together
    to detect conflicts between changes. Another advantage is that the CI system can
    pack your solution in a container, so the only thing that you have to do is deliver
    the container to a production cloud. The deployment of containers is also simple
    to automate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: CI不能保证应用程序将正常工作，因为测试可能会出错，但它消除了在自动系统中由开发者运行测试的需求。这让你能够测试所有即将到来的更改，以检测更改之间的冲突。另一个优点是CI系统可以将你的解决方案打包到容器中，因此你唯一需要做的事情是将容器交付到生产云。容器的部署也易于自动化。
- en: How to split a traditional server into multiple microservices
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将传统服务器拆分为多个微服务
- en: 'Around 10 years ago, developers used to use the Apache web server with a scripting
    programming language to create web applications, rendering the views on the server-side.
    This meant that there was no need to split applications into pieces and it was
    simpler to keep the code together. With the emergence of **Single-Page Applications**
    (**SPAs**), we only needed server-side rendering for special cases and applications
    were divided into two parts: frontend and backend. Another tendency was that servers
    changed processing method from synchronous (where every client interaction lives
    in a separate thread) to asynchronous (where one thread processes many clients
    simultaneously using non-blocking, input-output operations). This trend promotes
    the better performance of single server units, meaning they can serve thousands
    of clients. This means that we don''t need special hardware, proprietary software,
    or a special toolchain or compiler to write a tiny server with great performance.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大约10年前，开发者们通常使用Apache网络服务器和脚本编程语言来创建Web应用程序，在服务器端渲染视图。这意味着没有必要将应用程序拆分成多个部分，并且将代码保持在一起更为简单。随着**单页应用程序**（**SPA**）的出现，我们只需要在特殊情况下进行服务器端渲染，应用程序被分为两部分：前端和后端。另一个趋势是服务器改变了处理方法，从同步（每个客户端交互都存在于一个单独的线程中）变为异步（一个线程使用非阻塞的输入输出操作同时处理多个客户端）。这一趋势促进了单服务器单元性能的提升，意味着它们可以服务数千个客户端。这意味着我们不需要特殊的硬件、专有软件或特殊的工具链或编译器来编写具有出色性能的小型服务器。
- en: The invasion of microservices happened when scripting programming languages
    become popular. By this, we are not only referring to languages for server-side
    scripting, but general-purpose high-level programming languages such as Python
    or Ruby. The adoption of JavaScript for backend needs, which had previously always
    been asynchronous, was particularly influential.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本编程语言变得流行时，微服务的入侵发生了。通过这一点，我们不仅指的是服务器端脚本的编程语言，还包括像Python或Ruby这样的通用高级编程语言。JavaScript在后台需求中的采用，尤其是它以前一直是异步的，具有特别的影响力。
- en: If writing your own server wasn't hard enough, you could create a separate server
    for special cases and use them directly from the frontend application. This would
    not require rendering procedures on the server. This section has provided a short
    description of the evolution from monolithic servers to microservices. We are
    now going to examine how to break a monolithic server into small pieces.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写自己的服务器已经足够困难，你可以为特殊情况创建一个单独的服务器，并直接从前端应用程序中使用它们。这不需要在服务器上进行渲染过程。本节简要描述了从单体服务器到微服务的演变。我们现在将探讨如何将单体服务器分解成小块。
- en: Reasons to avoid monoliths
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免单体服务的理由
- en: If you already have a single server that includes all backend features, you
    have a monolithic service, even if you start two or more instances of this service.
    A monolithic service has a few disadvantages—it is impossible to scale vertically,
    it is impossible to update and deploy one feature without interrupting all the running
    instances, and if the server fails, it affects all features. Let's discuss these
    disadvantages a little further. This might help you to convince your manager to
    break your service down into microservices.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个包含所有后端功能的单个服务器，即使你启动了两个或更多个此服务的实例，你仍然有一个单体服务。单体服务有几个缺点——它无法垂直扩展，无法在不中断所有运行实例的情况下更新和部署一个功能，如果服务器故障，它会影响所有功能。让我们进一步讨论这些缺点。这可能会帮助你说服你的经理将你的服务分解成微服务。
- en: Impossible to scale vertically
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无法垂直扩展
- en: 'There are two common approaches to scaling an application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序扩展的两种常见方法：
- en: '**Horizontally**: Where you start a new instance of application'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平扩展**：指的是启动应用程序的新实例'
- en: '**Vertically**: Where you improve an independent application layer that has
    a bottleneck'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直扩展**：指的是改进一个具有瓶颈的独立应用层'
- en: The simplest way to scale a backend is to start another instance of the server.
    This will solve the issue, but in many cases it is a waste of hardware resources.
    For example, imagine you have a bottleneck in an application that collects or
    logs statistics. This might only use 15% of your CPU, because logging might include
    multiple IO operations but no intensive CPU operations. However, to scale this
    auxiliary function, you will have to pay for the whole instance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展后端最简单的方式是启动服务器的另一个实例。这将解决问题，但在许多情况下，这会浪费硬件资源。例如，假设你在收集或记录统计数据的应用程序中遇到瓶颈。这可能会只使用你CPU的15%，因为记录可能包括多个I/O操作，但没有密集的CPU操作。然而，为了扩展这个辅助功能，你将不得不为整个实例付费。
- en: Impossible to update and deploy only one feature
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无法仅更新和部署一个功能
- en: If your backend works as a monolith, you can't update only a small part of it.
    Every time you add or change a feature, you have to stop, update, and start the
    service again, which causes interruptions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的后端作为单体运行，你无法仅更新其一小部分。每次你添加或更改一个功能，你都必须停止、更新并重新启动服务，这会导致中断。
- en: When you have a microservice and you have find a bug, you can stop and update
    only this microservice without affecting the others. As I mentioned before, it
    can also be useful to split a product into separate development teams.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个微服务并且发现一个错误时，你可以停止并仅更新这个微服务，而不会影响其他服务。正如我之前提到的，将产品拆分成单独的开发团队也是有用的。
- en: The failure of one server affects all features
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个服务器的故障会影响所有功能
- en: Another reason to avoid monoliths is that every server crash also crashes all
    of the features, which causes the application to stop working completely, even
    though not every feature is needed for it to work. If your application can't load
    new user interface themes, the error is not critical, as long as you don't work
    in the fashion or design industry, and your application should still be able to
    provide the vital functions to users. If you split your monolith into independent
    microservices, you will reduce the impact of crashes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 避免单体应用程序的另一个原因是，每次服务器崩溃也会导致所有功能崩溃，即使不是每个功能都需要它工作，应用程序也会完全停止工作。如果你的应用程序无法加载新的用户界面主题，错误不是关键的，只要你不从事时尚或设计行业，你的应用程序仍然能够向用户提供关键功能。如果你将单体应用程序分解成独立的微服务，你将减少崩溃的影响。
- en: Breaking a monolithic service into pieces
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将单体服务分解成各个部分
- en: 'Let''s look an example of an e-commerce monolith server that provides the following
    features:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个提供以下功能的电子商务单体服务器的例子：
- en: '**User registration**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户注册**'
- en: '**Product catalog**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品目录**'
- en: '**Shopping cart**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购物车**'
- en: '**Payment integration**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付集成**'
- en: '**E-mail notifications**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子邮件通知**'
- en: '**Statistics collecting**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统计收集**'
- en: 'Old-fashioned servers developed years ago would include all of these features
    together. Even if you split it into separate application modules, they would still
    work on the same server. You can see an example structure of a monolithic service
    here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前开发的旧式服务器将包括所有这些功能。即使你将其拆分为单独的应用程序模块，它们仍然会在同一服务器上运行。你可以在以下位置看到单体服务的示例结构：
- en: '![](img/89a92a8e-cb97-474c-afbd-4b055ef7c647.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89a92a8e-cb97-474c-afbd-4b055ef7c647.png)'
- en: 'In reality, the real server contains more modules than this, but we have separated
    them into logical groups based on the tasks they perform. This is a good starting
    point to breaking your monolith into multiple, loosely coupled microservices.
    In this example, we can break it further into the pieces represented in the following
    diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，实际服务器包含的模块比这更多，但我们已经根据它们执行的任务将它们分成了逻辑组。这是一个将单体应用程序分解成多个松散耦合的微服务的好起点。在这个例子中，我们可以进一步将其分解成以下图中表示的各个部分：
- en: '![](img/3ba5553e-806f-4099-b53a-2e5f0a37791b.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ba5553e-806f-4099-b53a-2e5f0a37791b.png)'
- en: As you can see, we use a **balancer** to route requests to microservices. You
    can actually connect to microservices directly from the frontend application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用**均衡器**将请求路由到微服务。你实际上可以直接从前端应用程序连接到微服务。
- en: Shown in the preceding diagram is the potential communication that occurs between
    services. For simple cases, you can use direct connections. If the interaction
    is more complex, you can use message queues. However, you should avoid using a
    shared state such as a central database and interacting through records, because
    this can cause a bottleneck for the whole application. We will discuss how to
    scale microservices in [Chapter 12](98204850-538d-4a2b-9a77-23f85e716400.xhtml), *Scalable
    Microservices Architecture.* For now, we will explore REST API, which will be
    partially implemented in a few examples throughout this book. We will also discuss
    why Rust is a great choice for implementing microservices.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中显示了服务之间可能发生的潜在通信。对于简单情况，您可以使用直接连接。如果交互更复杂，您可以使用消息队列。但是，您应该避免使用共享状态，如中央数据库，并通过记录进行交互，因为这可能会成为整个应用程序的瓶颈。我们将在第
    12 章 [可扩展微服务架构](98204850-538d-4a2b-9a77-23f85e716400.xhtml)中讨论如何扩展微服务。现在，我们将探索
    REST API，它将在本书的一些示例中部分实现。我们还将讨论为什么 Rust 是实现微服务的绝佳选择。
- en: Definition of a REST API
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API 的定义
- en: Let's define the APIs that we will use in our microservice infrastructure using
    the REST methodology. In this example, our microservices will have minimal APIs
    for demonstration purposes; real microservices might not be quite so "micro".
    Let's explore the REST specifications of the microservices of our application.
    We will start by looking at a microservice for user registration and go through
    every part of the application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 REST 方法定义我们将在微服务基础设施中使用的 API。在这个例子中，为了演示目的，我们的微服务将具有最小的 API；实际的微服务可能不会如此“微小”。让我们探索我们应用程序微服务的
    REST 规范。我们将从查看用户注册微服务开始，并查看应用程序的每个部分。
- en: User registration microservice
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户注册微服务
- en: 'The first service is responsible for the registration of users. It has to contain
    methods to add, update, or delete users. We can cover all needs with the standard
    REST approach. We will use a combination of methods and paths to provide this
    user registration functionality:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个服务负责用户的注册。它必须包含添加、更新或删除用户的方法。我们可以使用标准的 REST 方法来满足所有需求。我们将使用方法和路径的组合来提供此用户注册功能：
- en: '`POST` request to `/user/` creates a new user and returns its `id`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/user/` 的 `POST` 请求创建一个新用户并返回其 `id`
- en: '`GET` request to `/user/id`  returns information related to a user with `id`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/user/id` 的 `GET` 请求返回与具有 `id` 的用户相关的信息
- en: '`PUT` request to `/user/id`  applies changes to a user with `id`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/user/id` 的 `PUT` 请求将更改应用于具有 `id` 的用户
- en: '`DELETE` request to `/user/id`  removes a user with `id`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/user/id` 的 `DELETE` 请求移除具有 `id` 的用户
- en: This service can use the **E-mail notifications** microservice and call its
    methods to notify the user about registration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务可以使用 **电子邮件通知** 微服务并调用其方法来通知用户注册。
- en: E-mail notifications microservice
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件通知微服务
- en: 'The **E-mail notifications** microservice can be extremely simple and contains
    only a single method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子邮件通知** 微服务可以非常简单，并且只包含一个方法：'
- en: The `POST` request to `/send_email/`  sends an email to any address
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/send_email/` 的 `POST` 请求向任何地址发送电子邮件
- en: This server can also count the sent emails to prevent spam or check that the
    email exists in the user's database by requesting it from the **User registration**
    microservice. This is done to prevent malicious use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器还可以通过请求 **用户注册** 微服务来计算发送的电子邮件数量，以防止垃圾邮件或检查电子邮件是否存在于用户的数据库中。这是为了防止恶意使用。
- en: Product catalog  microservice
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品目录微服务
- en: 'The **Product catalog** microservice tracks the available products and needs
    only weak relations with other microservices, except for the **Shopping cart**.
    This microservice can contain the following methods:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**产品目录** 微服务跟踪可用的产品，并且只需要与其他微服务建立弱关系，除了 **购物车**。此微服务可以包含以下方法：'
- en: '`POST` request to `/product/` creates a new product and returns its `id`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/product/` 的 `POST` 请求创建一个新产品并返回其 `id`
- en: '`GET` request to `/product/id`  returns information about the product with
    `id`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/product/id` 的 `GET` 请求返回具有 `id` 的产品信息
- en: '`PUT` request to `/product/id`  updates information about the product with
    `id`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/product/id` 的 `PUT` 请求更新具有 `id` 的产品信息
- en: '`DELETE` request to `/product/id`  marks the product with `id` as deleted'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/product/id` 的 `DELETE` 请求将 `id` 标识的产品标记为已删除
- en: '`GET` request to `/products/` returns a list of all products (can be paginated
    by extra parameters)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到 `/products/` 的 `GET` 请求返回所有产品的列表（可以通过额外参数进行分页）
- en: Shopping cart microservice
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车微服务
- en: 'The **Shopping cart** microservice is closely integrated with the **User registration**
    and **Product catalog** microservices. It holds pending purchases and prepares
    invoices. It contains the following methods:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**购物车**微服务与**用户注册**和**产品目录**微服务紧密集成。它持有待购商品并准备发票。它包含以下方法：'
- en: '`POST` request to `/user/uid/cart/`, which puts a product in the cart and returns
    the `id` of item in the user''s cart with the `uid`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `/user/uid/cart/` 发送的 `POST` 请求，将产品放入购物车，并返回具有 `uid` 的用户购物车中项目的 `id`
- en: '`GET` request to `/user/uid/cart/id`, which returns information about the item
    with `id`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `/user/uid/cart/id` 发送的 `GET` 请求，返回有关 `id` 的项目信息
- en: '`PUT` request to `/user/uid/cart/id`, which updates information about the item
    with `id` (alters the quantity of items)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `/user/uid/cart/id` 发送的 `PUT` 请求，用于更新具有 `id` 的项目信息（更改项目数量）
- en: '`GET` request to `/user/uid/cart/`, which returns a list of all the items in
    the cart'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `/user/uid/cart/` 发送的 `GET` 请求，返回购物车中所有项目的列表
- en: 'As you can see, we don''t add an extra "s" to the `/cart/` URL and we use the
    same path for creating items and to get a list, because the first handler reacts
    to the `POST` method, the second processes requests with the `GET` method, and
    so on. We also use the user''s ID in the path. We can implement the nested REST
    functions in two ways:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们没有在 `/cart/` URL 中添加额外的 "s"，并且我们使用相同的路径来创建项目和获取列表，因为第一个处理器对 `POST` 方法做出响应，第二个处理器处理使用
    `GET` 方法的请求，依此类推。我们还在路径中使用用户的 ID。我们可以以两种方式实现嵌套的 REST 函数：
- en: Use session information to get the user's `id`. In this case, the paths contain
    a single object, such as `/cart/id` . We can keep the user's `id` in session cookies,
    but this is not reliable.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话信息获取用户的 `id`。在这种情况下，路径包含单个对象，例如 `/cart/id`。我们可以将用户的 `id` 保存在会话 cookie 中，但这并不可靠。
- en: We can add the `id` of a user to a path explicitly.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以明确地将用户的 `id` 添加到路径中。
- en: Payment Integration microservice
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支付集成微服务
- en: 'In our example, this microservice will be a third-party service, which contains
    the following methods:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，此微服务将是一个第三方服务，它包含以下方法：
- en: '`POST` request to `/invoices`  creates a new invoice and returns its `id`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `/invoices` 发送的 `POST` 请求创建一个新的发票并返回其 `id`
- en: '`POST` request to `/invoices/id/pay`  pays for the invoice'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `/invoices/id/pay` 发送的 `POST` 请求支付发票
- en: Statistics collecting microservice
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计收集微服务
- en: 'This service collects usage statistics and logs a user''s actions to later improve
    the application. This service exports API calls to collect the data and contains
    some internal APIs to read the data:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务收集使用统计信息并将用户的操作记录下来以供以后改进应用程序。此服务导出 API 调用来收集数据，并包含一些内部 API 来读取数据：
- en: '`POST` request to `/log`  logs a user''s actions (the `id` of a user is set
    in the body of the request)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `/log` 发送的 `POST` 请求记录用户的操作（用户的 `id` 设置在请求体中）
- en: '`GET` request to `/log?from=?&to=?`  works only from the internal network and
    returns the collected data for the period specified'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅从内部网络向 `/log?from=?&to=?` 发送的 `GET` 请求返回指定期间收集的数据
- en: This microservice doesn't conform clearly to the REST principles. It's useful
    for microservices that provide a full set of methods to add, modify, and remove
    the data, but for other services, it is excessively restrictive. You don't have
    follow a clear REST structure for all of your services, but it may be useful for
    some tools that expect it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此微服务并不明显符合 REST 原则。它对提供完整方法集以添加、修改和删除数据的微服务很有用，但对于其他服务来说，它过于限制性。您不必为所有服务遵循清晰的
    REST 结构，但对于一些期望它的工具来说可能很有用。
- en: Transformation to microservices
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为微服务
- en: If you already have a working application, you might transform it into a set
    of microservices, but you have to keep the application running at the highest
    rate and prevent any interruptions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经有一个运行中的应用程序，您可能将其转换为一组微服务，但您必须保持应用程序以最高的速率运行并防止任何中断。
- en: To do this, you can create microservices step by step, starting from the least
    important task. In our example, it's better to start from email activities and
    logging. This practice helps you to create a DevOps process from scratch and join
    it with the maintenance process of your app.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您可以逐步创建微服务，从最不重要的任务开始。在我们的示例中，从电子邮件活动和日志开始会更好。这种做法有助于您从头开始创建 DevOps 流程并将其与您的应用程序维护流程结合起来。
- en: Reusing existing microservices
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新使用现有的微服务
- en: If your application is a monolith server, you don't need to turn all modules
    into microservices, because you can use existing third-party services and shrink
    the bulk of the code that needs rewriting. These services can help with many things,
    including storage, payments, logging, and transactional notifications that tell
    you whether an event has been delivered or not.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序是一个单体服务器，你不需要将所有模块都转换为微服务，因为你可以使用现有的第三方服务并缩减需要重写的代码量。这些服务可以帮助处理许多事情，包括存储、支付、日志记录以及交易通知，告诉你事件是否已送达。
- en: I recommend that you create and maintain services that determine your competitive
    advantage yourself and then use third-party services for other tasks. This can
    significantly shrink your expenses and the time to market.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你自己创建和维护确定你竞争优势的服务，然后使用第三方服务处理其他任务。这可以显著减少你的开支和上市时间。
- en: In any case, remember the product that you are delivering and don't waste time
    on unnecessary units of your application. The microservices approach helps you
    to achieve this simply, unlike the tiresome coding of monoliths, which requires
    you to deal with numerous secondary tasks. Hopefully, you are now fully aware
    of the reasons why microservices can be useful. In the next section, we will look
    at why Rust is a promising tool for creating microservices.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，记住你正在交付的产品，不要在应用程序的不必要单元上浪费时间。微服务方法帮助你简单地实现这一点，与单体服务的繁琐编码不同，单体服务需要你处理许多次要任务。希望你现在已经完全了解微服务可能有用的原因。在下一节中，我们将探讨为什么Rust是创建微服务的有希望的工具。
- en: Why Rust is a great tool for creating microservices
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么Rust是创建微服务的优秀工具
- en: 'If you have chosen to read this book, you probably already know that Rust is
    an up-to-date, powerful, and reliable language. However, choosing it to implement
    microservices is not an obvious decision, because Rust is a system programming
    language that is often assigned to low-level software such as drivers or OS kernels.
    This is because you tend to have to write a lot of glue code or get into detailed
    algorithms with low-level concepts, such as pointers in system programming languages.
    This is not the case with Rust. As a Rust programmer, you''ve surely already seen
    how it can be used to create high-level abstractions with flexible language capabilities.
    In this section, we''ll discuss the strengths of Rust: its strict and explicit
    nature, its high performance, and its great package system.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了阅读这本书，你可能已经知道Rust是一种最新、强大且可靠的编程语言。然而，选择它来实现微服务并不是一个明显的决定，因为Rust是一种系统编程语言，通常用于低级软件，如驱动程序或操作系统内核。这是因为你往往需要编写大量的粘合代码或深入研究涉及低级概念（如系统编程语言中的指针）的详细算法。但这并不是Rust的情况。作为一个Rust程序员，你肯定已经看到了它如何利用灵活的语言能力创建高级抽象。在本节中，我们将讨论Rust的优势：其严格和显式的本质、其高性能以及其出色的包管理系统。
- en: Explicit versus implicit
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式与隐式
- en: 'Up until recently, there hasn''t been a well-established approach to using
    Rust for writing asynchronous network applications. Previously, developers tended
    to use two styles: either explicit control structures to handle asynchronous operations
    or implicit context switching. The explicit nature of Rust meant that the first
    approach outgrew the second. Implicit context switching is used in concurrent
    programming languages such as Go, but this model does not suit Rust for a variety
    of reasons. First of all, it has design limitations and it''s hard or even impossible
    to share implicit contexts between threads. This is because the standard Rust library
    uses thread-local data for some functions and the program can''t change the thread
    environment safely. Another reason is that an approach with context switching
    has overheads and therefore doesn''t follow the zero-cost abstractions philosophy
    because you would have a background runtime. Some modern libraries such as `actix`
    provide a high-level approach similar to automatic context switching, but actually
    use explicit control structures for handling asynchronous operations.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，还没有一个使用 Rust 编写异步网络应用程序的成熟方法。以前，开发者倾向于使用两种风格：要么使用显式控制结构来处理异步操作，要么使用隐式上下文切换。Rust
    的显式性意味着第一种方法超越了第二种。隐式上下文切换在像 Go 这样的并发编程语言中使用，但这种模型不适合 Rust，有各种原因。首先，它有设计限制，并且很难或甚至不可能在线程之间共享隐式上下文。这是因为标准
    Rust 库为某些函数使用线程局部数据，程序无法安全地更改线程环境。另一个原因是上下文切换的方法有开销，因此不符合零成本抽象哲学，因为你会有一个后台运行时。一些现代库，如
    `actix`，提供了一个类似于自动上下文切换的高级方法，但实际上使用显式控制结构来处理异步操作。
- en: Network programming in Rust has evolved over time. When Rust was released, developers
    could only use the standard library. This method was particularly verbose and
    not suitable for writing high-performance servers. This was because the standard
    library didn't contain any good asynchronous abstractions. Also, event `hyper`, a
    good crate for creating HTTP servers and clients, processed requests in separate
    threads and could therefore only have a certain number of simultaneous connections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的网络编程随着时间的推移而发展。当 Rust 发布时，开发者只能使用标准库。这种方法特别冗长，不适合编写高性能服务器。这是因为标准库没有包含任何好的异步抽象。此外，`hyper`
    事件，一个用于创建 HTTP 服务器和客户端的好包，在单独的线程中处理请求，因此只能有有限数量的并发连接。
- en: The `mio` crate was introduced to provide a clear asynchronous approach to make
    high-performance servers. It contained functions to interact with asynchronous
    features of the operating system, such as epoll or kqueue***,*** but it was still
    verbose, which made it hard to write modular applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`mio` 包的引入是为了提供一个清晰的异步方法来构建高性能服务器。它包含了与操作系统异步特性交互的函数，例如 epoll 或 kqueue***，***，但它仍然很冗长，这使得编写模块化应用程序变得困难。'
- en: The next abstraction layer over `mio` was a `futures` and `tokio` pair of crates.
    The `futures` crate contained abstractions for implementing delayed operations
    (like the defers concept in Twisted, if you're familiar with Python). It also
    contained types for assembling stream processors, which are reactive and work
    like a finite state machine.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mio` 之上的下一个抽象层是由 `futures` 和 `tokio` 这对包组成的。`futures` 包包含了实现延迟操作的抽象（如果你熟悉
    Python 中的 Twisted 的 defer 概念），它还包含了用于组装流处理器的类型，这些处理器是反应式的，并且像有限状态机一样工作。
- en: Using the `futures` crate was a powerful way to implement high-performance and
    high-accuracy network software. However, it was a middleware crate, which made
    it hard to solve everyday tasks. It was a good base for rewriting crates such
    as `hyper`, because these can use explicit asynchronous abstractions with full
    control.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `futures` 包是实现高性能和高精度网络软件的有效方式。然而，它是一个中间件包，这使得解决日常任务变得困难。它是重写 `hyper` 等包的好基础，因为这些包可以使用具有完全控制的显式异步抽象。
- en: The highest level of abstraction today are crates that use `futures`, `tokio`,
    and `hyper` crates, such as `rocket` or `actix-web`. Now, `rocket` includes high-level
    elements to construct a web server with the minimal amount of lines. `actix-web`
    works as a set of actors when your software is broken down into small entities
    that interact with one another. There are many other useful crates, but we will
    start with hyper as a basis for developing web servers from scratch. Using this
    crate, we will be between low-level crates, such as futures, and high-level crates,
    such as `rocket`. This will allow us to understand both in detail.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的最高抽象级别是使用 `futures`、`tokio` 和 `hyper` crate 的 crate，例如 `rocket` 或 `actix-web`。现在，`rocket`
    包含了构建具有最少行数的 Web 服务器的元素。`actix-web` 在你的软件被分解成相互交互的小实体时，充当一组演员。还有很多其他有用的 crate，但我们将从
    hyper 开始，作为从头开始开发 Web 服务器的基石。使用这个 crate，我们将在低级 crate（如 futures）和高级 crate（如 `rocket`）之间。这将使我们能够详细了解两者。
- en: Minimal amount of runtime errors
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化运行时错误
- en: There are many languages suitable for creating microservices, but not every
    language has a reliable design to keep you from making mistakes. Most interpreted
    dynamic languages let you write flexible code that decides on the fly which field
    of the object to get and which function to call. You can often even override the
    rules of function calling by adding meta-information to objects. This is vital
    in meta-programming or in cases where your data drives the behavior of the runtime.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多语言适合创建微服务，但并非每种语言都有可靠的设计来防止你犯错误。大多数解释型动态语言允许你编写灵活的代码，该代码可以即时决定获取对象的哪个字段以及调用哪个函数。你甚至可以通过向对象添加元信息来覆盖函数调用的规则。这在元编程或数据驱动运行时行为的情况下至关重要。
- en: The dynamic approach, however, has significant drawbacks for the software, which
    requires reliability rather than flexibility. This is because any inaccuracy in
    the code causes the application to crash. The first time you try to use Rust,
    you may feel that it lacks flexibility. This is not true, however; the difference
    is in the approach you use to achieve flexibility. With Rust, all your rules must
    be strict. If you create enough abstractions to cover all of the cases your application
    might face, you will get the flexibility you want.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，动态方法对于需要可靠性而不是灵活性的软件来说具有显著的缺点。这是因为代码中的任何不准确都会导致应用程序崩溃。当你第一次尝试使用 Rust 时，你可能会觉得它缺乏灵活性。但这并不是真的；区别在于你用来实现灵活性的方法。在
    Rust 中，你必须遵守所有规则。如果你创建了足够的抽象来覆盖应用程序可能遇到的所有情况，你将获得你想要的灵活性。
- en: Rust rookies who come from the JavaScript or the Python world might notice that
    they have to declare every case of serialization/deserialization of data, whereas
    with dynamic languages, you can simply unpack any input data to the free-form
    object and explore the content later. You actually have to check all cases of
    inconsistency during runtime and try and work out what consequences could be caused
    if you change one field and remove another. With Rust, the compiler checks everything,
    including the type, the existence, and the corresponding format. The most important
    thing here is the type, because you can't compile a program that uses incompatible
    types. With other languages, this sometimes leads to strange compilation errors
    such as a case where you have two types for the same crate but the types are incompatible
    because they were declared in different versions of the same crate. Only Rust
    protects you from shooting yourself in the foot in this way. In fact, different
    versions can have different rules of serialization/deserialization for a type,
    even if both declarations have the same data layout.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 JavaScript 或 Python 世界的 Rust 新手可能会注意到，他们必须声明数据序列化/反序列化的每一个案例，而在动态语言中，你可以简单地解包任何输入数据到自由形式的对象，并在之后探索其内容。实际上，你必须检查运行时期间的所有不一致性案例，并尝试确定如果你更改一个字段并删除另一个字段可能会产生什么后果。在
    Rust 中，编译器会检查一切，包括类型、存在性和相应的格式。这里最重要的是类型，因为你不能编译使用不兼容类型的程序。在其他语言中，这有时会导致奇怪的编译错误，例如，你有两个相同crate的类型，但由于它们是在不同版本的同一crate中声明的，因此这些类型是不兼容的。只有
    Rust 可以保护你免受这种自伤的方式。事实上，不同版本可以有不同的序列化/反序列化规则，即使两个声明具有相同的数据布局。
- en: Great performance
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优秀的性能
- en: Rust is a system programming language. This means your code is compiled into
    native binary instructions for the processor and runs without unwanted overhead,
    unlike interpreters such as JavaScript or Python.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Rust是一种系统编程语言。这意味着你的代码会被编译成处理器的原生二进制指令，并且运行时没有不必要的开销，这与JavaScript或Python等解释器不同。
- en: Rust also doesn't use a garbage collector and you can control all allocations
    of memory and the size of buffers to prevent overflow.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Rust也不使用垃圾回收器，你可以控制所有内存分配和缓冲区大小，以防止溢出。
- en: Another reason why Rust is so fast for microservices is that it has zero-cost
    abstractions, which means that most abstractions in the language weigh nothing.
    They turn into effective code during compilation without any runtime overhead.
    For network programming, this means that your code will be effective after compilation,
    that is, once you have added meaningful constructions in the source code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Rust之所以在微服务中如此快速，另一个原因是它具有零成本抽象，这意味着语言中的大多数抽象在编译时没有任何开销。它们在编译期间转化为有效代码，没有任何运行时开销。对于网络编程来说，这意味着你的代码在编译后将是有效的，也就是说，一旦你在源代码中添加了有意义的构造。
- en: Minimal dependencies burden
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化依赖项负担
- en: Rust programs are compiled into a single binary without unwanted dependencies.
    It needs libc or another dynamic library if you want to use OpenSSL or similar
    irreplaceable dependencies, but all Rust crates are compiled statically into your
    code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Rust程序编译成一个单一的二进制文件，不包含任何不想要的依赖。如果你想要使用OpenSSL或类似的不可替代的依赖项，则需要libc或另一个动态库，但所有Rust包都是静态编译到你的代码中的。
- en: You may think that the compiled binaries are quite large to be used as microservices.
    The word microservice, however, refers to the narrow logic scope, rather than
    the size. Even so, statically linked programs remain tiny for modern computers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为编译的二进制文件太大，不适合用作微服务。然而，微服务这个词指的是狭义的逻辑范围，而不是大小。即便如此，静态链接的程序对于现代计算机来说仍然非常小巧。
- en: What benefits does this give you? You will avoid having to worry about dependencies.
    Each Rust microservice uses its own set of dependencies compiled into a single
    binary. You can even keep microservices with obsolete features and dependencies
    besides new microservices. In addition, Rust, in contrast with the Go programming
    language, has strict rules for dependencies. This means that the project resists
    breaking, even if someone forces an update of the repository with the dependency
    you need.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这能给你带来什么好处？你将无需担心依赖项。每个Rust微服务都使用自己的一套依赖项，这些依赖项被编译成一个单一的二进制文件。你甚至可以保留具有过时功能和依赖项的微服务，同时使用新的微服务。此外，与Go编程语言相比，Rust对依赖项有严格的规则。这意味着即使有人强制更新包含所需依赖项的存储库，项目也能抵抗崩溃。
- en: How does Rust compare to Java? Java has microframeworks for building microservices,
    but you have to carry all dependencies with them. You can put these in a fat **Java
    ARchive** (**JAR**), which is a kind of compiled code distribution in Java, but
    you still need **Java Virtual Machine** (**JVM**). Don't forget, too, that Java
    will load every dependency with a class loader. Also, Java bytecode is interpreted
    and it takes quite a while for the **Just-In-Time** (**JIT**) compilation to finish to
    accelerate the code. With Rust, bootstrapping dependencies don't take a long time
    because they are attached to the code during compilation and your code will work
    with the highest speed from the start since it was already compiled into native
    code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Rust与Java相比如何？Java有用于构建微服务的微框架，但你必须携带所有依赖项。你可以将这些依赖项放入一个胖**Java ARchive**（**JAR**）中，这是Java中的一种编译代码分发方式，但你仍然需要**Java虚拟机**（**JVM**）。别忘了，Java还会用类加载器加载每个依赖项。此外，Java字节码是解释执行的，**即时编译**（**JIT**）完成需要相当长的时间来加速代码。在Rust中，依赖项的自举过程不需要很长时间，因为它们在编译期间就附加到了代码上，你的代码将从一开始就以最高速度运行，因为它已经被编译成原生代码。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have mastered the basics of microservices. Simply put, a
    microservice is a compact web server that handles specific tasks. For example, microservices
    can be responsible for user authentication or for email notifications. They make
    running units reusable. This means you don't need to recompile or restart units
    if they don't require any updates. This approach is simpler and more reliable
    in deployment and maintenance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们掌握了微服务的基础知识。简单来说，微服务是一个处理特定任务的紧凑型Web服务器。例如，微服务可以负责用户认证或电子邮件通知。它们使运行单元可重用。这意味着如果它们不需要任何更新，你不需要重新编译或重启单元。这种方法在部署和维护中更简单、更可靠。
- en: We have also discussed how to split a monolithic web server that contains all
    of its business logic in a single unit into smaller pieces and join them together
    through communication, in line with the ideology of loose coupling. To split a
    monolithic server, you should separate it into domains that are classified by
    what tasks the servers carry out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何将包含所有业务逻辑的单个单元的垄断式Web服务器拆分成更小的部分，并通过通信将它们连接起来，这与松耦合的理念相符。为了拆分垄断式服务器，你应该将其分离成执行特定任务的域。
- en: In the last section of this chapter, we've looked at why Rust is a good choice
    for developing microservices. We touched on dependencies management, the performance
    of Rust, its explicit nature, and its toolchain. It's now time to dive deep into
    coding and write a minimal microservice with Rust.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们探讨了为什么Rust是开发微服务的良好选择。我们提到了依赖管理、Rust的性能、其显式性和其工具链。现在是时候深入编码，用Rust编写一个最小的微服务了。
- en: In the next chapter we will start to writing microservices with Rust using `hyper`
    crate that provides all necessary features to write compact asynchronous HTTP
    server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始使用`hyper` crate用Rust编写微服务，该crate提供了编写紧凑型异步HTTP服务器所需的所有功能。
- en: Further reading
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You have learned about the basics of microservices in this chapter, which will
    serve as a point for you to start writing microservices on Rust throughout this
    book. If you want to learn more about topics discussed in this chapter, please
    consult the following list:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中学到了微服务的基础知识，这将作为你在本书中开始用Rust编写微服务的起点。如果你想了解更多关于本章讨论的主题，请参考以下列表：
- en: '*Microservices - a definition of this new architectural term*, 2014, Martin
    Fowler, available at [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html).
    This article introduces the concept of microservices.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*微服务 - 新架构术语的定义*，2014年，马丁·福勒，可在[https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)找到。这篇文章介绍了微服务的概念。'
- en: '`mio`, available at [https://github.com/carllerche/mio](https://github.com/carllerche/mio).
    This is a crate that is widely used by other crates for asynchronous operations
    in Rust. We won''t use it directly, but it is useful to know how it works.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mio`，可在[https://github.com/carllerche/mio](https://github.com/carllerche/mio)找到。这是一个被其他crate广泛用于Rust中异步操作的crate。我们不会直接使用它，但了解它是如何工作的是有用的。'
- en: '*Network Programming with Rust*, *2018*, Abhishek Chanda, available at [https://www.packtpub.com/application-development/network-programming-rust](https://www.packtpub.com/application-development/network-programming-rust).
    This book explains more about network addresses, protocols and sockets, and how
    to use them all with Rust.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Rust进行网络编程*，2018年，阿比谢克·钱达，可在[https://www.packtpub.com/application-development/network-programming-rust](https://www.packtpub.com/application-development/network-programming-rust)找到。这本书解释了更多关于网络地址、协议和套接字的内容，以及如何使用Rust来使用它们。'
