- en: Events and Basic Game Mechanisms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件和基本游戏机制
- en: In the last chapter, we saw how to add dependencies into a project thanks to
    `Cargo` and the basics of the `SDL2` library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何通过 `Cargo` 和 `SDL2` 库的基础知识将依赖项添加到项目中。
- en: We now have all the Rust basics in order to write the Tetris game. Time to look
    at how we will actually write Tetris.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了编写俄罗斯方块游戏所需的 Rust 基础知识。现在是时候看看我们如何实际编写俄罗斯方块了。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Tetrimino
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tetrimino
- en: Creating tetriminos
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 tetriminos
- en: Generating a tetrimino
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 tetrimino
- en: Tetris struct
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tetris 结构体
- en: Interacting with the game map
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与游戏地图交互
- en: SDL events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDL 事件
- en: Score, level, lines sent
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分、等级、送出的行数
- en: Writing Tetris
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写俄罗斯方块
- en: 'First, let''s review the Tetris rules (just in case):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下俄罗斯方块的规则（以防万一）：
- en: There is a grid with a height of 16 blocks and a width of 10 blocks.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个高度为 16 块、宽度为 10 块的网格。
- en: You have seven different `tetrimino` (a tetris piece) that are all composed
    of four blocks.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有七种不同的 `tetrimino`（俄罗斯方块部件），它们都是由四个块组成的。
- en: A new `tetrimino` appears at the top of the game's grid every time the previous
    one cannot descend any more (because the block below is already occupied or because
    you've reached the game's floor).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当上一个 `tetrimino` 无法再下降时（因为下面的块已经被占据，或者因为你已经到达了游戏的地板），游戏中的网格顶部就会出现一个新的 `tetrimino`。
- en: The game is over when a new `tetrimino` cannot appear anymore (because there
    is already a tetrimino at the top of the grid).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个新的 `tetrimino` 无法再出现时（因为网格顶部已经有了一个 `tetrimino`），游戏结束。
- en: Every time a line is *full* (all blocks are occupied by a `tetrimino` part),
    it disappears and all lines above descend by one line.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当一行 *满*（所有块都被 `tetrimino` 部分占据）时，它就会消失，并且上面的所有行都会下降一行。
- en: Now that we all agree on the game rules, let's see how to actually write those
    mechanisms.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们都同意了游戏规则，让我们看看如何实际编写这些机制。
- en: First, we need to actually create those `tetrimino`s.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要实际创建那些 `tetrimino`s。
- en: Tetrimino
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tetrimino
- en: 'As said previously, every `tetrimino` has four blocks. Another thing to note
    is that they can rotate. So for example you have this `tetrimino`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个 `tetrimino` 有四个块。另一个需要注意的事情是它们可以旋转。所以例如，你有一个这样的 `tetrimino`：
- en: '![](img/00012.jpeg)*Figure 3.1*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00012.jpeg)*图 3.1*'
- en: 'It can also rotate in the three following positions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以在以下三个位置旋转：
- en: '![](img/00013.jpeg)*Figure 3.2*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00013.jpeg)*图 3.2*'
- en: 'Theoretically, every `tetrimino` should have four states, but in reality, not
    all of them do. For example, this one has no transformation so to speak:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，每个 `tetrimino` 都应该有四个状态，但现实中并非所有 `tetrimino` 都是这样。例如，这个 `tetrimino` 没有任何变换：
- en: '![](img/00014.jpeg)*Figure 3.3*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00014.jpeg)*图 3.3*'
- en: 'And these three only have two states:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个只有两种状态：
- en: '![](img/00015.jpeg)*Figure 3.4*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00015.jpeg)*图 3.4*'
- en: 'We have two ways of handling these rotations: using matrix rotation or storing
    the different states. To have a code that''s easy to read and update, I picked
    the second option, but don''t hesitate to try using matrix on your own, it could
    help you learn a lot of new things!'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种处理这些旋转的方法：使用矩阵旋转或存储不同的状态。为了使代码易于阅读和更新，我选择了第二种方法，但请不要犹豫，尝试自己使用矩阵，这可能会帮助你学到很多新东西！
- en: 'So first, let''s write down a `struct` for `tetrimino`s:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们为 `tetrimino`s 编写一个 `struct`：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Everything seems fine except this line:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这一行之外，一切看起来都很正常：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pretty ugly, right? Let's make it look a bit better by using type aliasing!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很丑，对吧？让我们通过使用类型别名来让它看起来更好一些！
- en: 'So what is our `states` field representing? Simply a list of states. Each state
    represents a piece''s transformation. I suppose it''s a bit hard to understand
    all of this. Let''s write an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的 `states` 字段代表什么呢？简单来说，是一个状态列表。每个状态代表一个部件的变换。我想这有点难以理解。让我们写一个例子：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In here, `0` means the block is empty, otherwise, it''s a `tetrimino` block.
    So from reading this code, I suppose you could guess that we were representing
    the square:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`0` 表示该块为空，否则，它是一个 `tetrimino` 块。所以从阅读这段代码来看，我猜你可以猜出我们正在表示正方形：
- en: '![](img/00014.jpeg)*Figure 3.5*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00014.jpeg)*图 3.5*'
- en: 'In case you wondered, we have four lines with four blocks because the *biggest *`tetrimino`
    has a height (or a width, depending the transformation) of four:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有所疑问，我们这里有四行，每行有四个块，因为 *最大* 的 `tetrimino` 的高度（或宽度，取决于变换）为四：
- en: '![](img/00016.jpeg)*Figure 3.6*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00016.jpeg)*图 3.6*'
- en: This isn't mandatory (we could make it fit the form of each `tetrimino`), but
    it makes our lives easier, so why not?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是强制性的（我们可以让它适合每个 `tetrimino` 的形状），但它使我们的工作更简单，所以为什么不这样做呢？
- en: 'Coming back to our type aliasing: a piece is basically a vector or vector of
    numbers. It''s long to write it down every time, so let''s alias it as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的类型别名：一个方块基本上是一个数字向量或数字向量。每次写下来都很长，所以让我们给它取一个别名如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can rewrite the `states` field declaration as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将 `states` 字段声明重写如下：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Way better and more explicit, right? But since we'll be using those states as
    well, why not alias them too?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更好且更明确，对吧？但是既然我们也会使用这些状态，为什么不也给它们取别名呢？
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And now our `states` field declaration becomes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 `states` 字段声明变成了：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s explain the other fields (just in case):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下其他字段（以防万一）：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A little explanation of this struct:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个结构体的一点点解释：
- en: '`states` (if you didn''t already understand it) is the list of possible states
    of the `tetrimino`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`states`（如果你还没有理解）是 `tetrimino` 可能的状态列表'
- en: '`x` is the *x* position of the `tetrimino`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` 是 `tetrimino` 的 *x* 位置'
- en: '`y` is the *y* position of the `tetrimino`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y` 是 `tetrimino` 的 *y* 位置'
- en: '`current_state` is the state in which the `tetrimino` is currently'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_state` 是 `tetrimino` 当前所在的状态'
- en: Ok, so far so good. Now how should we handle the creation of this type generically?
    We don't want to rewrite this for every `tetrimino`. This is where `traits` kick
    in!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止一切顺利。现在我们如何泛型地处理这个类型的创建呢？我们不想为每个 `tetrimino` 重新编写这个。这就是 `traits` 发挥作用的地方！
- en: Creating tetriminos
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `tetrimino`
- en: We wrote the type that will be used in our game, but we didn't write its initialization/creation
    yet. This is where Rust `trait`s will be useful.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了将在我们的游戏中使用的类型，但我们还没有编写它的初始化/创建。这就是Rust `trait` 将会派上用场的地方。
- en: 'Let''s start by writing a generator trait that will be implemented on all `tetrimino`s:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先写一个生成器 `trait`，它将在所有的 `tetrimino` 上实现：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And that's it. This `trait` just provides a function that creates a new `Tetrimino`
    instance. It maybe doesn't like this very much, but thanks to this `trait`, we'll
    be able to easily create all our `tetrimino`s.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这个 `trait` 只提供了一个创建新的 `Tetrimino` 实例的函数。它可能不太喜欢这样，但多亏了这个 `trait`，我们将能够轻松地创建所有的
    `tetrimino`。
- en: 'Time to write our first `tetrimino`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候写我们的第一个 `tetrimino` 了：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'No need to look for more code, this is what a `tetrimino` really looks like.
    It''s an empty structure. The interesting part comes just after:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要寻找更多的代码，这就是 `tetrimino` 真正的样子。它是一个空的结构体。有趣的部分就在后面：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Which is:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是：
- en: '![](img/00017.jpeg)*Figure 3.7*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00017.jpeg)*图3.7*'
- en: In here, a number represents a color and `0` means no color (because there is
    no block).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个数字代表一种颜色，`0` 表示没有颜色（因为没有方块）。
- en: 'And that''s it. Now you can create this `tetrimino` just by calling:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在你只需调用以下命令就可以创建这个 `tetrimino`：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It'll return an instance of the `Tetrimino` structure and that's the one you'll
    be using in the game. The other `tetrimino` structures (such as `TetriminoI` in
    here) are just used to generically create the `Tetrimino` structure with the related
    information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回 `Tetrimino` 结构体的一个实例，这就是你将在游戏中使用的实例。其他 `tetrimino` 结构体（如这里的 `TetriminoI`）只是用来泛型地创建带有相关信息的
    `Tetrimino` 结构体。
- en: 'We now need to create all the other `tetrimino` as well, so let''s do it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建所有其他的 `tetrimino`，让我们来做这件事：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In case you're wondering why the blocks have `2` as values, it's simply so that
    we can differentiate them when displaying them (having all `tetrimino` with the
    same color wouldn't be very pretty...). It has no other meaning.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么方块有 `2` 这个值，那只是为了在显示时能够区分它们（如果所有的 `tetrimino` 都有相同的颜色，看起来会很丑...）。它没有其他含义。
- en: 'This `tetrimino` looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `tetrimino` 看起来是这样的：
- en: '![](img/00018.jpeg)*Figure 3.8*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00018.jpeg)*图3.8*'
- en: 'Let''s go for the next one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `tetrimino` looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `tetrimino` 看起来是这样的：
- en: '![](img/00019.jpeg)*Figure 3.9*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00019.jpeg)*图3.9*'
- en: 'Another `tetrimino`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `tetrimino`：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `tetrimino` looks like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `tetrimino` 看起来是这样的：
- en: '![](img/00020.jpeg)*Figure 3.10*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00020.jpeg)*图3.10*'
- en: 'Another `tetrimino` (will it ever end?!):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `tetrimino`（难道它永远不会结束吗？！）：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This `tetrimino` looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `tetrimino` 看起来是这样的：
- en: '![](img/00021.jpeg)*Figure 3.11*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00021.jpeg)*图3.11*'
- en: 'Guess what? Another `tetrimino`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？另一个 `tetrimino`：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This `tetrimino` looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `tetrimino` 看起来是这样的：
- en: '![](img/00022.jpeg)*Figure 3.12*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00022.jpeg)*图3.12*'
- en: 'And the last one (finally!):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个（终于！）：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, this `tetrimino` looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个 `tetrimino` 看起来是这样的：
- en: '![](img/00023.jpeg)*Figure 3.13*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00023.jpeg)*图3.13*'
- en: Phew... That was quite a lot of code! Easy code, but still a lot!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 呼...这相当多的代码！虽然简单，但仍然很多！
- en: It's now time to see how we can generate a new `tetrimino` randomly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们如何随机生成一个新的 `tetrimino` 了。
- en: Generating a tetrimino
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 `tetrimino`
- en: In order to do so, we'll need to import another `crate`—`rand`. This `crate`
    is used to generate random numbers and that is exactly what we need here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要导入另一个`crate`——`rand`。这个`crate`用于生成随机数，这正是我们在这里需要的。
- en: 'First, add the following line to your `Cargo.toml` file (in the `[dependencies]`
    section):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下行添加到你的`Cargo.toml`文件中（在`[dependencies]`部分）：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add the following line to your `main.rs` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下行添加到你的`main.rs`文件中：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And we''re done! Now we can write the generation function of the `tetrimino`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了！现在我们可以编写`tetrimino`的生成函数：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Pretty easy, right? Though, please note that this is a bit too random. It''d
    be problematic if we had the same `tetrimino` generated more than twice in a row
    (which is already a lot!), so let''s improve this function a bit by adding a `static`
    variable:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 确实很简单，对吧？尽管如此，请注意，这有点太随机了。如果我们连续生成两次以上的相同`tetrimino`（这已经很多了），那就会有问题，所以让我们通过添加一个`static`变量来稍微改进这个函数：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A bit of explanation might be helpful here. First, what is a `static` variable?
    It''s a variable that will keep its value and won''t be destroyed when the scope
    it has been created inside has been left. An example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些解释可能是有帮助的。首先，什么是`static`变量？它是一个在创建它的作用域离开后仍然保持其值的变量。一个例子：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you execute this code, it''ll print out:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行这段代码，它会打印出：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here are the other properties of the `static` variable:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`static`变量的其他属性：
- en: It cannot have a destructor (it's possible to avoid this limitation by using
    the `lazy_static` crate though, but we won't talk about it here) so only *simple*
    types that don't implement the `Drop` trait can be used as `static`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能有析构函数（虽然可以通过使用`lazy_static` crate来避免这种限制，但在这里我们不会讨论它），所以只能使用不实现`Drop` trait
    的`simple`类型作为`static`。
- en: Changing the value of a `static` variable is unsafe (that's why there are `unsafe`
    blocks) for the simple reason that the `static` is shared between all threads
    in the program and can be modified and read at the same time
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变`static`变量的值是不安全的（这就是为什么有`unsafe`块），因为`static`在程序的所有线程之间是共享的，并且可以同时被修改和读取
- en: Reading the value of a mutable `static` is unsafe (for the reason mentioned
    previously)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取可变`static`的值是不安全的（原因如前所述）
- en: 'We now have a function that can generate a `tetrimino`. We now need to add
    the following functionalities:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以生成`tetrimino`的函数。我们现在需要添加以下功能：
- en: Rotating
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转
- en: Changing position
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变位置
- en: Let's start with the rotation part!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从旋转部分开始！
- en: Rotating a tetrimino
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转tetrimino
- en: 'Thanks to how we created the `Tetrimino` type, it''s quite easy to do:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建的`Tetrimino`类型，这样做相当简单：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And we''re done. However, we don''t check anything: what happens if there is
    a block already used by another `tetrimino`? We''ll just overwrite it. Such a
    thing cannot be accepted!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了。然而，我们没有进行检查：如果已经有其他`tetrimino`使用了某个块会发生什么？我们只是简单地覆盖它。这种事情是不能接受的！
- en: 'In order to perform this check, we''ll need the game *map* as well. It''s simply
    a vector line and a line is a vector of `u8`. Or, more simply:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个检查，我们需要游戏地图。它只是一个向量行，一行是一个`u8`的向量。或者，更简单地说：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Considering that it isn''t too hard to read, we''ll just keep it this way.
    Now let''s write the method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到它并不难读，我们就保持这种方式。现在让我们编写这个方法：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Before explaining this function, it seems important to explain why the game
    map became a `&[Vec<u8>]`. When you send a non-mutable reference over a vector
    (`Vec<T>`), it is then dereferenced into a `&[T]` slice, which is a constant *view* over
    the vector's content.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释这个函数之前，似乎有必要解释一下为什么游戏地图变成了`&[Vec<u8>]`。当你将一个非可变引用传递给一个向量（`Vec<T>`）时，它就会被解引用为一个`&[T]`切片，这是一个对向量内容的常量视图。
- en: 'And we''re done (for this method)! Now time for explanations: we loop over
    every block of our `tetrimino` and check whether the block is free in the game
    map (by checking whether it is equal to `0`) and if it isn''t going out of the
    game map.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了（这个方法）！现在轮到解释了：我们遍历我们的`tetrimino`的每一个块，检查这个块在游戏地图中是否空闲（通过检查它是否等于`0`），并且如果没有超出游戏地图的范围。
- en: 'Now that we have our `test_position` method, we can update the `rotate` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`test_position`方法，我们可以更新`rotate`方法：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A bit longer, indeed. Since we can''t be sure that the piece will be put where
    we want it to go, we need to make temporary variables and then check the possibilities.
    Let''s go through the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 确实更长一些。由于我们无法确定这个部件会被放置在我们想要的位置，我们需要创建临时变量并检查可能性。让我们来看看代码：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is *exactly* what our `rotate` method did before, except that now, we
    use temporary variables before going further:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们的`rotate`方法之前所做的事情，但现在，我们在进一步之前使用临时变量：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This line on its own doesn''t make much sense but it''ll be very useful next:
    in case the piece cannot be placed where we want, we try to move it on the `x`
    axis to see if it''d work in some other place. It allows you to have a Tetris
    that is much more flexible and comfortable to play:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行单独来看并没有什么意义，但它将非常有用：如果我们不能把碎片放在我们想要的地方，我们尝试在`x`轴上移动它，看看它是否在其他地方可以工作。这使你能够拥有一个更加灵活、更易于游玩的Tetris：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the explanations given previously, this loop should be really easy to understand.
    For each `x` shift, we check whether the piece can be placed there. If it works,
    we change the values of our `tetrimino`, otherwise we just continue.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前给出的解释，这个循环应该很容易理解。对于每个`x`位移，我们检查碎片是否可以放置在那里。如果它起作用，我们就改变`tetrimino`的值，否则我们继续。
- en: If no `x` shift worked, we just leave the function without doing anything.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`x`位移起作用，我们只是让函数什么也不做。
- en: Now that we can rotate and test the position of a `tetrimino`, it'd be nice
    to actually move it as well (when the timer goes to 0 and the `tetrimino` needs
    to go down, for example). The main difference with the `rotate` method will be
    that, if the `tetrimino` cannot move, we'll return a Boolean value to allow the
    caller to be aware of it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够旋转和测试`tetrimino`的位置，实际上移动`tetrimino`也会很好（例如，当计时器归零且`tetrimino`需要下降时）。与`rotate`方法的主要区别将是，如果`tetrimino`不能移动，我们将返回一个布尔值，以便调用者知道这一点。
- en: 'So the method looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个方法看起来是这样的：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Another difference that you have certainly already spotted is that we don't
    check multiple possible positions, just the one received. The reason is simple; contrary
    to a rotation, we can't move the `tetrimino` around when it receives a move instruction.
    Imagine asking the `tetrimino` to move to the right and it doesn't move, or worse,
    it moves to the left! We can't allow it and so we're not doing it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定已经注意到的另一个区别是我们不检查多个可能的位置，只检查接收到的那个。原因是简单的；与旋转不同，当`tetrimino`收到移动指令时，我们不能移动`tetrimino`。想象一下要求`tetrimino`向右移动，但它没有移动，或者更糟，它向左移动！我们不能允许这样的事情发生，所以我们不做这件事。
- en: 'Now about the method''s code: it''s very simple. If we can put the `tetrimino` in
    a place, we update the position of the `tetrimino` and return true, otherwise,
    we do nothing other than return false.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于方法的代码：它非常简单。如果我们能把`tetrimino`放在某个位置，我们就更新`tetrimino`的位置并返回true，否则，我们除了返回false之外什么都不做。
- en: Most of the work is performed in the `test_position` method, allowing our method
    to be really small.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作都在`test_position`方法中完成，这使得我们的方法真正小巧。
- en: 'With these three methods, we have almost everything we need. But for even more
    simplicity in the future, let''s add one more:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这三个方法，我们几乎拥有了所有需要的东西。但为了将来的更多简洁性，让我们再添加一个：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ll use it when we generate a new `tetrimino`: if it cannot be placed where
    it appeared because another `tetrimino` is already there, it means the game is
    over.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们生成一个新的`tetrimino`时，我们会使用它：如果`tetrimino`不能放在它出现的位置，因为另一个`tetrimino`已经在那里，这意味着游戏结束了。
- en: We can now say that our `Tetrimino` type is fully implemented. Congratulations!
    Time to start the game type!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以说，我们的`Tetrimino`类型已经完全实现。恭喜！现在是时候开始游戏类型了！
- en: Tetris struct
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tetris结构
- en: 'This type will be the one holding all the game''s information:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型将包含所有游戏信息：
- en: Game map
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏地图
- en: Current level
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前等级
- en: Score
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数
- en: Number of lines
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行数
- en: The current `tetrimino`
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的`tetrimino`
- en: Some potential other information (such as a ghost, or the preview of the next
    `tetrimino`!)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些潜在的其他信息（例如幽灵或下一个`tetrimino`的预览！）
- en: 'Let''s write down this type:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写下这个类型：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once again, pretty simple. I don't think any additional information is required
    so let's continue!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，很简单。我认为不需要任何额外的信息，所以我们继续！
- en: 'Let''s start by writing the `new` method for this new type:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为这个新类型编写`new`方法开始：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Nothing really complicated except maybe the loop. Let''s look at how it works:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可能是一个循环之外，没有真正复杂的东西。让我们看看它是如何工作的：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We know that a `tetris` map has a width of 10 blocks and a height of 16 blocks.
    This loop creates our game map by looping over the number of lines and generating
    an empty vector of 10 blocks, which will be a line.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`tetris`地图的宽度是10个方块，高度是16个方块。这个循环通过遍历行数来创建我们的游戏地图，生成一个10个方块的空向量，这将是一行。
- en: 'Apart from this, everything else is very straightforward:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，其他一切都是非常直接的：
- en: You start at level 1
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你从等级1开始
- en: With your score at 0
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的得分为 0
- en: With 0 lines sent
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有发送任何行
- en: No current `tetrimino`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前没有 `tetrimino`
- en: 'Let''s start by generating a new `tetrimino` randomly. For this, you''ll require
    the `rand` crate. Add the following to your `Cargo.toml` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先随机生成一个新的 `tetrimino`。为此，你需要 `rand` crate。将以下内容添加到你的 `Cargo.toml` 文件中：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then add this at the top of your `main` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在你的 `main` 文件顶部添加以下内容：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we can write the method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以编写这个方法：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Explanations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `static` keyword is the same in `Rust` as it is in `C` and `C++` for variables:
    the value set to the variable will be kept between the function calls. So for
    example, if you write the following function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 关键字在 `Rust` 中与在 `C` 和 `C++` 中的变量相同：变量的值将在函数调用之间保持。所以例如，如果你编写以下函数：'
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And you then call it, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你按照以下方式调用它：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You''ll get the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So now, why do we have these `unsafe` blocks? The reason is quite simple: in
    case the static variable is accessed and modified from different threads, you
    can''t be *sure* that you won''t have data race, concurrency errors, or even memory
    errors.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，为什么我们有这些 `unsafe` 块？原因很简单：如果在不同的线程中访问和修改静态变量，你无法确保不会出现数据竞争、并发错误，甚至内存错误。
- en: In this case, since we don't have threads, it's fine. However, keep in mind
    that you should ALWAYS try to avoid unsafe at all costs and use it ONLY when nothing
    else can be done.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为我们没有线程，所以没问题。然而，请记住，你应该始终尽量避免使用 `unsafe`，并且只有在没有其他选择的情况下才使用它。
- en: 'However, if our static variable wasn''t mutable, then we could access its value
    without needing the `unsafe` blocks. The reason once again is simple: even if
    multiple threads try to access its value at the same time, since this value cannot
    change, you can''t have data race and therefore it is safe.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们的静态变量不是可变的，那么我们就不需要 `unsafe` 块就能访问它的值。原因再次很简单：即使多个线程同时尝试访问它的值，由于这个值不能改变，所以不可能有数据竞争，因此它是安全的。
- en: 'Let''s continue with our function''s code explanations:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续解释我们函数的代码：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This line generates a random `u8` and then limits its value between 0 (included)
    and 6 (included) because we have seven different `tetrimino`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码生成一个随机的 `u8` 并将其值限制在 0（包含）和 6（包含）之间，因为我们有七个不同的 `tetrimino`：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the generated `tetrimino` is the same as the previous one, we generate another
    one. It enables you to prevent having the same `tetrimino` too many times at once.
    It isn''t the best way to do it, having a specific balancing for each `tetrimino`
    would be better, but this solution is acceptable enough (and a lot easier to write!):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成的 `tetrimino` 与上一个相同，我们将生成另一个。这可以防止你一次性出现太多的相同 `tetrimino`。这并不是最好的方法，为每个
    `tetrimino` 进行特定的平衡会更好，但这个解决方案足够可行（而且更容易编写！）：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We now set the generated `tetrimino` *ID* to our `static` variable:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将生成的 `tetrimino` *ID* 设置到我们的 `static` 变量中：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Nothing much to say about this pattern matching. Every *ID* matches a `tetrimino`
    and then we call the corresponding constructor. The only really interesting thing
    about this construction is the following line:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种模式匹配没有太多可说的。每个 *ID* 都匹配一个 `tetrimino`，然后我们调用相应的构造函数。这个构造过程中唯一真正有趣的地方是以下这一行：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This macro is really useful. It allows us to add a security over the matched
    value. If the code ever enters this pattern matching, it'll panic right away (because,
    as the macro's name suggests, it's not supposed to happen).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏非常有用。它允许我们在匹配的值上添加一层安全性。如果代码进入这个模式匹配，它将立即崩溃（因为，正如宏的名字所暗示的，这种情况不应该发生）。
- en: Interacting with the game map
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与游戏地图交互
- en: 'Ok, we can now move all the `tetrimino` and generate them. Two mechanisms are
    still missing: checking lines to see whether one can be sent (that is, removed
    since complete) and making a `tetrimino` *permanent *(that is, not movable anymore).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在可以移动所有的 `tetrimino` 并生成它们。还有两个机制尚未实现：检查行以查看是否可以发送（即，移除因为完成）以及使 `tetrimino`
    *永久*（即，不能再移动）。
- en: 'Let''s start with the line check:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查这一行开始：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For now, I didn't add the score, lines sent counting, nor level handling but
    this is here that'll do it later.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我没有添加得分、发送行数的计数以及等级处理，但这里将是以后完成这些的地方。
- en: Now time to explain this method a bit. Its purpose is to remove lines when they're
    full (meaning when every block is occupied by a `tetrimino` block). So we just
    go through the game map line by line and run the check on each.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是解释这个方法的时候了。它的目的是在行填满时（即，当每个方块都被 `tetrimino` 方块占据时）删除行。所以我们只是逐行遍历游戏地图并对每一行进行检查。
- en: 'The code itself doesn''t use much of the Rust-specific syntax, but you might
    wonder why we did it like this. I''m talking about this loop:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身并没有使用很多 Rust 特定的语法，但你可能会想知道为什么我们这样做。我指的是这个循环：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we could have just used:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们本可以使用：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is actually a good question and the answer is simple, but maybe hard to
    understand, if you're used to how Rust ownership works.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个好问题，答案很简单，但如果你习惯了 Rust 的所有权工作方式，可能难以理解。
- en: 'All the problems actually come from this line:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的问题实际上都来自这一行：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In here, we mutably borrow `self.game_map` in order to remove a line. However,
    `self.game_map` would already be non-mutably borrowed by the `for` loop! A quick
    reminder on how the borrowing rules work:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为了删除一行而可变地借用了 `self.game_map`。然而，`self.game_map` 已经被 `for` 循环非可变地借用了！快速回顾一下借用规则是如何工作的：
- en: You can non-mutably borrow a variable as many times as you want
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以无数次非可变地借用一个变量
- en: You can mutably borrow a variable only if there are no other borrows (either
    mutable or non-mutable)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能在没有其他借用（无论是可变还是不可变）的情况下可变地借用一个变量
- en: So in our case, the `for` loop would break the second rule since we'd have a
    non-mutable borrow when trying to get mutable access to `self.game_map`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的例子中，`for` 循环会违反第二条规则，因为我们试图获取对 `self.game_map` 的可变访问时会有一个非可变的借用。
- en: 'In this case, we have two solutions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两个解决方案：
- en: Iterate over the game map "by hand" (with an index variable)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动遍历游戏地图（使用索引变量）
- en: Store lines to remove into a second vector and then remove them after we get
    out of the loop
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要删除的行存储到第二个向量中，然后在我们退出循环后删除它们
- en: Both solutions are more or less equivalent in this case so I just picked the
    first one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，这两种解决方案在某种程度上是等价的，所以我只是选择了第一个。
- en: 'Once the first loop is finished, we have filled the game map with empty lines
    to replace the one(s) we deleted:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第一轮循环完成后，我们已经用空行填充了游戏地图，以替换我们删除的行：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: And we're done with this method! Let's write the other one.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这个方法！让我们写另一个。
- en: So now it's time to write the `make_permanent` method. Just like the previous
    one, it won't be a complete version, but in the future, this is where we'll update
    the score (we update it when a `tetrimino` is made permanent).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在是我们编写 `make_permanent` 方法的时候了。就像之前的那个一样，它不会是一个完整的版本，但将来，这就是我们更新分数的地方（我们在
    `tetrimino` 被永久化时更新分数）。
- en: 'So let''s write it:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们来写它：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This code doesn''t seem very encouraging... Brace yourselves, explanations
    are coming:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来并不鼓舞人心... 准备好，解释即将到来：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It''s simple pattern matching. If `self.current_piece` is `Some`, then we enter
    the condition and the value contained by `Some` that is bound into the `piece`
    variable:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的模式匹配。如果 `self.current_piece` 是 `Some`，那么我们就进入条件，并将 `Some` 中包含的值绑定到 `piece`
    变量：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This loop and its condition allow us to avoid a buffer overflow error by checking
    whether we're not outside of the game map limit for the current rotation (that
    is, `self.current_state`).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环及其条件允许我们通过检查当前旋转（即 `self.current_state`）是否超出游戏地图限制来避免缓冲区溢出错误。
- en: 'The same goes for the inner loop (which iterates over the blocks of a line):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 内部循环（遍历行的块）也是一样：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It is in this loop that we write the blocks of the current `tetrimino` into
    the game map:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这个循环，我们将当前 `tetrimino` 的块写入游戏地图：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If the current block of the current `tetrimino` isn't empty, then we put it
    into the game map (it's as simple as that).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前 `tetrimino` 的当前块不为空，我们就将其放入游戏地图（就这么简单）。
- en: 'Once done, this is where we call the `check_lines` method. But now you''ll
    certainly wonder why we don''t call it directly inside the `if let` condition.
    Well, it''s for the exact same reason that we didn''t use the `for` loop inside
    the `check_lines` method, `self` is already mutably borrowed by the following
    line:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，这就是我们调用 `check_lines` 方法的位置。但现在你肯定会想知道为什么我们不在 `if let` 条件中直接调用它。嗯，原因和我们在
    `check_lines` 方法中不使用 `for` 循环的原因一样，`self` 已经被下一行可变地借用了：
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'That''s right: if an element of a type is borrowed, then its parent is mutably
    borrowed as well!'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对的：如果一个类型的元素被借用，那么它的父元素也会被可变借用！
- en: With these two methods, our `Tetris` type is now fully implemented (minus the
    small required modifications that will come later). Time to add the `SDL` events
    handling!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种方法，我们的 `Tetris` 类型现在已经完全实现（除了稍后需要的小修改）。现在是时候添加 `SDL` 事件处理了！
- en: SDL events
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDL 事件
- en: 'There aren''t many different events to handle:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 没有多少不同的事件需要处理：
- en: '*Left* and *right arrow* keys to move the `tetrimino` to the right or the left'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*左* 和 *右* 方向键用来将 `tetrimino` 移动到左边或右边'
- en: '*Up arrow* key to make the `tetrimino` rotate'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向上箭头* 键使 `tetrimino` 旋转'
- en: '*Down arrow* key to make the `tetrimino` descend one block'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向下箭头* 键使 `tetrimino` 下降一个方块'
- en: '*Spacebar* to make the `tetrimino` descend to the bottom instantly'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*空格键* 使 `tetrimino` 瞬间下降到最底部'
- en: '*Escape* to quit the game'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Escape* 键退出游戏'
- en: 'It''s still possible to add some later on (such as pausing the game with the
    *return* key, for example) but for now, let''s focus on these ones. For this,
    go back inside the main loop of the game (inside the `main` function) and replace
    the current event handling with the following function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以在稍后添加一些（例如，使用 *回车* 键暂停游戏等），但现在，让我们专注于这些。为此，回到游戏的 `main` 函数中的主循环内部，并用以下函数替换当前的事件处理：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Quite a big one:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当大的函数：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This variable will tell us whether the current `tetrimino` is still falling.
    If not, then it becomes `true`, the `tetrimino` is then put into the game map
    and we generate a new one. Luckily for us, we already wrote all the needed functions
    to perform these operations:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将告诉我们当前的 `tetrimino` 是否仍在下落。如果不是，那么它变为 `true`，`tetrimino` 被放入游戏地图，并生成一个新的
    `tetrimino`。幸运的是，我们已经编写了所有执行这些操作所需的功能：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This is simple pattern binding. If our game doesn''t have a current piece (for
    some reason), then we don''t do anything and just leave:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的模式绑定。如果我们的游戏没有当前碎片（由于某种原因），那么我们不做任何事情，直接离开：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If there is a move on the `x` or on the `y` axis, we''ll write it into these
    variables and then we''ll test whether the `tetrimino` can actually go there:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `x` 或 `y` 轴上有移动，我们将将其写入这些变量，然后测试 `tetrimino` 是否可以真正移动到那里：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As there can be multiple events that happened since the last time we came into
    this function, we need to loop over all of them.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自上次我们进入这个函数以来可能发生了多个事件，我们需要遍历它们所有。
- en: 'Now we''re arriving at the interesting part:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正到达有趣的部分：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can almost consider this small code as the core of our application, without
    it, no interaction with the program is possible. If you want more interactions,
    this is where you''ll add them:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以将这段小代码视为我们应用程序的核心，没有它，无法与程序进行交互。如果你想添加更多交互，这就是你应该添加它们的地方：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If we receive a *quit* event from `sdl` or if we receive an `Escape`, `KeyDown`
    event, we set the `quit` variable to `true`. It''ll be used outside of this function
    to then leave the main loop--and therefore leave the program itself. Then we *break;* no
    need to go further since we know that we''re leaving the game:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 `sdl` 接收到一个 *退出* 事件，或者我们接收到一个 `Escape`、`KeyDown` 事件，我们将 `quit` 变量设置为 `true`。它将在函数外部使用，以便退出主循环——从而退出程序本身。然后我们
    *break;* 没有必要再继续，因为我们知道我们要离开游戏：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the *down arrow* is pressed, we need to make our `tetrimino` descend by one
    block and also put the `timer` value to now. `timer` is used to know at what speed
    the `tetrimino` blocks are falling. The shorter the time, the faster they'll descend.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下 *向下箭头*，我们需要使 `tetrimino` 下降一个方块，并将 `timer` 值设置为当前时间。`timer` 用于知道 `tetrimino`
    块下落的速度。时间越短，下落速度越快。
- en: 'For now, it isn''t used in this function, so we''ll see how to handle it outside
    of it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个函数中没有使用它，所以我们将看看如何在函数外部处理它：
- en: '[PRE67]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In here, we handle the *right* and *left arrow* keys. It''s just like the *down
    arrow* key, except we don''t need to change the `timer` variable:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处理 *右箭头* 和 *左箭头* 键。这就像 *向下箭头* 键一样，只是我们不需要更改 `timer` 变量：
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If we receive an *up arrow* key pressed event, we rotate the `tetrimino`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们接收到一个 *向上箭头* 键按下的事件，我们将旋转 `tetrimino`：
- en: '[PRE69]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And finally the last of our events: the *spacebar* key pressed event. Here,
    we move the `tetrimino` down as much as we can and then set the `make_permanent`
    variable to `true`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是我们的最后一个事件：按下 *空格键* 的事件。在这里，我们将 `tetrimino` 向下移动尽可能远，并将 `make_permanent` 变量设置为
    `true`。
- en: With this, that's it for our events. However, like we said before if you want
    to add more events, this is where you should put them.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们的事件就到这里了。然而，正如我们之前所说的，如果你想添加更多的事件，这就是你应该放置它们的地方。
- en: 'Time to put all this into our main loop:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将这些放入我们的主循环中：
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Doesn't seem that long, right? Just a few comments where we're supposed to draw
    our `Tetris`, but otherwise everything is in there, which means that our `Tetris`
    is now fully functional (even though it isn't displayed).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来并不长，对吧？只是几个应该绘制我们的 `Tetris` 的注释，但除此之外，一切都在其中，这意味着我们的 `Tetris` 现在已经完全可用（即使它还没有显示）。
- en: 'Let''s explain what''s happening in there:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下那里发生了什么：
- en: '[PRE71]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In here, we initialize both our `Tetris` object and the `timer`. The timer
    will be used to let us know when the `tetrimino` is supposed to descend by one
    block:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了我们的`Tetris`对象和`timer`。计时器将用来告诉我们`tetrimino`应该下降一个方块的时间：
- en: '[PRE72]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This code checks whether it''s been one second or more since the last time
    the `tetrimino` descended by one block. If we want to handle levels, we''ll need
    to replace the following line:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查自上次`tetrimino`下降一个方块以来是否已过去一秒或更长时间。如果我们想处理级别，我们需要替换以下行：
- en: '[PRE73]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Its replacement will need to be something more generic and we'll add an array
    to store the different levels' speed of descent.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 其替代品需要更通用的东西，我们将添加一个数组来存储不同级别的下降速度。
- en: So coming back to the code, if it's been one second or more then we try to make
    the `tetrimino` descend by one block. If it cannot, then we put it into the game
    map and re-initialize the `timer` variable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 所以回到代码，如果已经过去了一秒或更长时间，我们就尝试让`tetrimino`下降一个方块。如果它不能下降，那么我们就将其放入游戏地图并重新初始化`timer`变量。
- en: 'Once again, you might wonder why we had to create the `make_permanent` variable
    instead of directly checking the output of:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可能想知道为什么我们不得不创建`make_permanent`变量而不是直接检查以下内容的输出：
- en: '[PRE74]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'It has an `if` condition, right? Well, just like the previous times, it''s
    because of the borrow checker. We borrow `tetris` here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个`if`条件，对吗？好吧，就像之前几次一样，这是因为借用检查器。我们在这里借用`tetris`：
- en: '[PRE75]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'So as long as we''re in this condition, we can''t use `tetris` mutably, which
    is why we store the result of the condition in `make_permanent` so we can use
    the `make_permanent` method after:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 所以只要我们处于这种状态，我们就不能可变地使用`tetris`，这就是为什么我们将条件的结果存储在`make_permanent`中，这样我们就可以在之后使用`make_permanent`方法：
- en: '[PRE76]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If there is no current `tetrimino`, we need to generate a new one, which we
    do by calling the `create_new_tetrimino` method. Then we check whether it can
    be put into the game on the top line by calling the `test_current_position` method.
    If not, then it means the game is over and we quit. Otherwise, we store the newly-generated
    `tetrimino` in `tetris.current_piece` and we move on.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有当前的`tetrimino`，我们需要生成一个新的，我们通过调用`create_new_tetrimino`方法来实现。然后我们通过调用`test_current_position`方法检查它是否可以放在顶部行上。如果不能，那么这意味着游戏结束了，我们退出。否则，我们将新生成的`tetrimino`存储在`tetris.current_piece`中，然后继续。
- en: 'Two things are missing here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里缺少两件事：
- en: Since we don't handle the increase of lines sent, nor the score, nor the level,
    there's no need to print them
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们不处理发送的行数、得分或级别的增加，因此不需要打印它们
- en: We didn't add yet the highscores loading/overwrite
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还没有添加高分加载/覆盖
- en: 'Of course, we''ll add all this later on:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们稍后会添加所有这些：
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This code calls the `handle_events` function and acts according to its output.
    It returns whether the current `tetrimino` has been put into the game map or not.
    If it is the case, then there is no need to draw it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码调用`handle_events`函数并根据其输出执行操作。它返回当前`tetrimino`是否已放入游戏地图。如果是这样，则不需要绘制它。
- en: 'We now need to do the following remaining things:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要完成以下剩余的事情：
- en: Add the score, levels, and number of lines sent
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加得分、级别和发送的行数
- en: Load/overwrite the highscores if needed
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，加载/覆盖高分
- en: Actually draw the `Tetris`
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上绘制`Tetris`
- en: Seems like we're getting very close to the end! Let's start by adding the score,
    number of lines sent, and levels!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们离结束已经很近了！让我们先添加得分、发送的行数和级别！
- en: Score, level, lines sent
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 得分、级别、发送的行数
- en: The biggest required change will be the level handling. You need to create an
    array with different times to increase the `tetrimino`'s speed of descent and
    to check whether the level needs to be changed or not (based on the number of
    lines).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的需求更改将是级别处理。你需要创建一个数组，包含不同的时间来增加`tetrimino`的下降速度，并检查级别是否需要更改（基于行数）。
- en: 'The score will be updated in the following cases:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下将更新得分：
- en: When the `tetrimino` is made permanent
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`tetrimino`被永久固定时
- en: When a line is sent
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发送一行时
- en: When the player makes a `Tetris` (no more blocks in the game map)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家完成`Tetris`（游戏地图中不再有方块）
- en: Let's start with the easiest change—the score.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的更改开始——得分。
- en: 'First, let''s add the following method into our `Tetris` type:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将以下方法添加到我们的`Tetris`类型中：
- en: '[PRE78]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can suppose that no additional explanations are required here.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设这里不需要额外的解释。
- en: 'Next, let''s update a few methods:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新几个方法：
- en: '[PRE79]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As usual, we create a temporary variable (here, `score_add`) and once the borrow
    of `self` is over, we call the `update_score` method. There is also the usage
    of the `increase_line` method. We haven't defined it yet; it'll come just after.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们创建一个临时变量（这里，`score_add`），一旦`self`的借用结束，我们就调用`update_score`方法。还有`increase_line`方法的用法。我们还没有定义它；它将在之后出现。
- en: 'The second method is `make_permanent`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法是`make_permanent`：
- en: '[PRE80]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Include this just above the `self.check_lines` call.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在`self.check_lines`调用之前包含这个。
- en: With these two methods updated, we now have the score handling fully implemented.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新这两个方法，我们现在已经完全实现了得分处理。
- en: Levels and lines sent
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送等级和行数
- en: The next two being strongly bound (the level depends directly on the number
    of lines sent), we'll implement them at the same time.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个是紧密相连的（等级直接取决于发送的行数），我们将同时实现它们。
- en: 'Before doing anything else, let''s define the two following `const`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何其他事情之前，让我们定义以下两个`const`：
- en: '[PRE81]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The first one corresponds to the times before the current `tetrimino` descends
    by one block. Each case being a different level.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对应于当前`tetrimino`下降一个方块之前的时间。每个情况对应不同的等级。
- en: The second one corresponds to how many lines the player needs before getting
    to the next level.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个对应于玩家达到下一等级之前需要消除的行数。
- en: 'Next, let''s add the following method in our `Tetris` type:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的`Tetris`类型中添加以下方法：
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Nothing complicated. Just be careful when reading the `LEVEL_LINES` const because
    our `current_level` variable starts at `1` and not 0.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么复杂的。只是在读取`LEVEL_LINES`常量时要小心，因为我们的`current_level`变量从`1`开始，而不是`0`。
- en: 'Next, we''ll need to update how we determine whether the time is up or not.
    To do so, let''s write another function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们确定时间是否到的方法。为了做到这一点，让我们再写一个函数：
- en: '[PRE83]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: A small but tricky one. The problem is that the type returned by `timer.elapsed`
    (which is `Duration`) doesn't provide a method to get the number of milliseconds,
    so we need to get it ourselves.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小但棘手的问题。问题是`timer.elapsed`返回的类型（`Duration`）不提供获取毫秒数的方法，所以我们需要自己获取它。
- en: First, we get the number of seconds elapsed and then multiply it by 1,000 (because
    1 second = 1,000 milliseconds). Finally, we get the number of nanoseconds (in
    the current second) and divide it by 1,000,000 (because 1 millisecond = 1 million
    nanoseconds).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取经过的秒数，然后乘以1,000（因为1秒=1,000毫秒）。最后，我们获取当前秒内的纳秒数，然后除以1,000,000（因为1毫秒=1百万纳秒）。
- en: 'We can now compare the results to see whether the `tetrimino` should descend
    or not and return the result:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以比较结果，看看`tetrimino`是否应该下降，并返回结果：
- en: '[PRE84]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And with this, we''ve finished this part. Let''s make the last one now: the
    highscore loading/overwriting!'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们已经完成了这一部分。现在让我们来做最后一个：高分加载/覆盖！
- en: Highscores loading/overwriting
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高分加载/覆盖
- en: 'We already saw how to perform the I/O operations in the previous chapter, so
    it''ll be very quick to do:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中看到了如何执行I/O操作，所以这将非常快：
- en: '[PRE85]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Not much to explain with this code. For the moment, we limited the number of
    each highscore to `5`. Just update it as you want.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有太多要解释的。目前，我们限制了每个高分记录的数量为`5`。只需按需更新即可。
- en: And with this code, all the mechanisms are implemented. All that's left is to
    actually draw the game!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，所有机制都已实现。剩下的只是实际绘制游戏！
- en: 'Here is the full code for this chapter:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的完整代码：
- en: '[PRE86]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Phew! That was quite the chapter! But now, all the game's mechanisms are here
    so adding the last remaining parts (such as the drawing) will be a piece of cake.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这一章真的很长！但现在，所有的游戏机制都已经到位，所以添加最后剩下的部分（比如绘图）将变得轻而易举。
- en: Once again, be sure to understand this chapter before starting to read the next
    one.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，在开始阅读下一章之前，一定要理解这一章。
