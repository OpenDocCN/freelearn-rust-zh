- en: '*Chapter 2*: Drawing Sprites'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：绘制精灵'
- en: Now that we've got a working app and we're drawing to the screen, we can start
    making something that actually looks like a game. That means **rendering sprites**,
    which is just a fancy way of saying drawing pictures. So, in this chapter, we'll
    start by defining what those pictures are by doing a little bit of game design,
    and then we'll render a static sprite to the screen. Since a static picture is
    a pretty boring game, we'll even get the sprite animating too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个运行中的应用，并且开始在屏幕上绘制，我们可以开始制作真正看起来像游戏的东西。这意味着**渲染精灵**，这只是一个说法，意思是绘制图片。所以，在本章中，我们将通过进行一点游戏设计来定义这些图片是什么，然后我们将渲染一个静态精灵到屏幕上。由于静态图片是一个非常无聊的游戏，我们甚至会让精灵动起来。
- en: 'In this chapter, we''ll do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Design our game, Walk the Dog.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计我们的游戏，遛狗。
- en: Render a sprite to the Canvas.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵渲染到画布上。
- en: Use a sprite sheet to load many sprites at once.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用精灵表单一次性加载多个精灵。
- en: Animate a character via the sprite sheet.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过精灵表单动画化一个角色。
- en: By the end of this chapter, you'll be drawing characters instead of static triangles,
    and you'll even have them running on the screen.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将绘制角色而不是静态三角形，甚至它们会在屏幕上奔跑。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In addition to the technical requirements of [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015),
    *Hello WebAssembly*, you'll need to download the assets found at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
    We'll build on top of the results of that chapter as well, so don't throw away
    the code. If you're reading this book out of order because you can't be tamed
    by society's rules, then you can get the previous chapter's source code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1)
    and start there. If you get stumped, you can find the complete source code for
    this chapter at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[*第一章*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015)的技术要求*Hello WebAssembly*之外，你还需要下载位于[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)的资产。我们还会基于该章节的结果进行构建，所以不要丢弃代码。如果你因为无法被社会规则驯服而按顺序阅读这本书，那么你可以在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1)找到上一章的源代码并从这里开始。如果你遇到难题，你可以在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2)找到本章的完整源代码。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3wOpCqy](https://bit.ly/3wOpCqy)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：[https://bit.ly/3wOpCqy](https://bit.ly/3wOpCqy)
- en: A quick game design session
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速游戏设计会议
- en: In the previous chapter, I had you create a project called "Walk the Dog", and
    you were so engrossed by the process of creating a Rust project and my thrilling
    prose that you didn't even ask why that was the name of the project. Now we'll
    dig into the game we're making for this book – **Walk the Dog**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我让你创建了一个名为“遛狗”的项目，你如此沉浸于创建Rust项目和我令人兴奋的散文中，以至于你甚至没有问为什么项目会叫这个名字。现在我们将深入研究这本书中我们要制作的这款游戏——**遛狗**。
- en: '*Walk the Dog* is an endless runner with a simple concept. You play as a boy
    walking his dog through the forest when your dog is surprised by a cat that runs
    by and starts chasing it. You, in turn, begin chasing your dog through the forest,
    dodging obstacles along the way, until you crash into one and fall down. At which
    point, of course, the dog turns around and checks on you.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*遛狗*是一个概念简单的无尽跑酷游戏。你扮演一个男孩，带着他的狗穿过森林，当你的狗被跑过的猫吓到并开始追逐它时，你开始追逐你的狗穿过森林，途中躲避障碍，直到你撞到其中一个并跌倒。这时，当然，狗会转身来看看你。'
- en: 'In case you hadn''t guessed, the idea for this game came to me while walking
    the dog on ice. I''ve used *Miro* ([https://miro.com](https://miro.com)) to make
    a prototype, just to get a feel for what the game will look like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 未经你猜测，这个游戏的灵感是在我遛狗时在冰上走时产生的。我使用了*Miro*([https://miro.com](https://miro.com))来制作原型，只是为了感受游戏将看起来是什么样子：
- en: '![Figure 2.1 – A Walk the Dog screen, hypothetically](img/Figure_2.01_B17151.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 假设的遛狗屏幕](img/Figure_2.01_B17151.jpg)'
- en: Figure 2.1 – A Walk the Dog screen, hypothetically
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 假设的遛狗屏幕
- en: Before you get the idea that I'm a great artist, all of the assets I'm using
    are freely available online via creative commons licenses. You might notice that
    the background is a little fuzzy relative to the characters, and that's because
    I made almost no effort to scale the characters to fit beyond copying and pasting
    them into Miro and dragging the corners around. When we place the actual objects
    in our game, we'll need to make a better effort than that.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在你得到我是个伟大艺术家的想法之前，我使用的所有资源都是通过创意共享许可在网络上免费提供的。你可能注意到背景相对于角色来说有点模糊，这是因为我在将角色复制粘贴到Miro并拖动角落时几乎没有做任何努力来调整角色的比例。当我们将实际对象放入我们的游戏中时，我们需要做出比这更好的努力。
- en: The temptation at this point is to say, "we're done" and start coding. Given
    the small size of our game, I don't think we need a full treatment to start coding,
    but I do want to make sure that we clarify a few things about the game.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，诱惑就是可以说“我们完成了”然后开始编码。鉴于我们的游戏规模较小，我认为我们不需要完整的处理就可以开始编码，但我确实想确保我们澄清关于游戏的一些事情。
- en: Scoring is done by measuring how far our little **Red Hat Boy** (**RHB** for
    short) runs – the same as most endless runners such as *Canabalt* ([http://canabalt.com/](http://canabalt.com/))
    or the *Dinosaur T-Rex* game that shows up when you start Google Chrome without
    an internet connection. The dog and cat navigate all obstacles effortlessly and
    are just there to give the player ideas on how to catch the dog, and perhaps mislead
    the player by taking a path they cannot follow. Obstacles will include rocks and
    boxes that you can crash into and water that you can fall into. RHB has a slide
    animation, so sometimes he'll need to slide under little cliffs too, which the
    dog runs under effortlessly. It's not enough for a fully fledged game, but it's
    enough to give us a checklist of features for future chapters. Let's say goodbye
    to our lovely triangles and begin rendering our adorable Red Hat Boy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 得分是通过测量我们的小红帽男孩（简称RHB）跑了多远来计算的——和大多数无尽跑者游戏一样，如*Canabalt*（[http://canabalt.com/](http://canabalt.com/)）或在没有互联网连接时启动Google
    Chrome时出现的*恐龙霸王龙*游戏。狗和猫可以轻松地导航所有障碍，只是给玩家提供如何捕捉狗的想法，也许通过走玩家无法跟随的路线来误导玩家。障碍将包括你可以撞到的岩石和箱子，以及你可以掉进去的水。RHB有一个滑动动画，所以有时他需要从小悬崖下滑行，狗可以轻松地从下面跑过。这不足以成为一个完整的游戏，但足以给我们一个未来章节的功能清单。让我们告别我们可爱的小三角形，开始渲染我们可爱的小红帽男孩。
- en: Rendering a sprite
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染sprite
- en: Sprite is a term so commonplace that it's possible to use it in conversation
    without actually knowing its meaning, yet properly defining it means properly
    defining bitmap, which in turn means properly defining pixmap. Did you know the
    term sprite was coined in the 1970s by Danny Hillis ([http://bit.ly/3aZlJ72](http://bit.ly/3aZlJ72))?
    It's exhausting.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite是一个如此常见的术语，以至于在谈话中可以使用它而不必真正知道它的含义，但正确地定义它意味着正确地定义位图，而这又意味着正确地定义像素图。你知道术语sprite是在20世纪70年代由Danny
    Hillis（[http://bit.ly/3aZlJ72](http://bit.ly/3aZlJ72)）提出的吗？这太令人疲惫了。
- en: While I find all of this fascinating, you didn't get this book for that, so
    for our purposes, a sprite is a 2D image loaded from a file. Red Hat Boy, his
    dog and cat, and the background will all be sprites. Let's not waste any more
    time on definitions and start drawing one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我觉得所有这些都很有趣，但你不是为此而买这本书的，所以为了我们的目的，sprite是从文件中加载的2D图像。红帽男孩、他的狗和猫以及背景都将被定义为sprite。让我们不要在定义上浪费时间，开始绘制一个。
- en: Loading images
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载图像
- en: 'We''ll start by unzipping the assets and copying the `Idle (1).png` file from
    `resized/rhb` into the `static` directory in your project. This will make it reachable
    from your program. As we build the program out, we''ll need further organization,
    but for one file, this is fine. Next, we''ll need to modify our code. You can
    leave the Sierpiński triangle in there for now as it looks cute next to the sprite,
    but the first thing to do is use the `HTMLImage` element to load an image. For
    now, it''s important that you load and draw the image **before** calling into
    the Sierpiński triangle. It looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将资源解压缩，并将`Idle (1).png`文件从`resized/rhb`复制到项目中`static`目录下。这样就可以从程序中访问它。随着我们构建程序，我们需要进一步的整理，但对于一个文件来说，这样是可以的。接下来，我们需要修改我们的代码。你可以暂时保留Sierpiński三角形，因为它和精灵放在一起看起来很可爱，但首先要做的是使用`HTMLImage`元素来加载一张图片。目前，重要的是在调用Sierpiński三角形之前加载并绘制图片。它看起来是这样的：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will once again get the `` ^^^^^^^^^^^^^^^^ could not find `HtmlImageElement`
    in `web_sys` `` error. Remember that the `web-sys` crate makes heavy use of feature
    flags, so you'll need to add `HtmlImageElement` to the feature flag list in `Cargo.toml`.
    After you add that, rebuilding will take a little longer, but the application
    will build again. Now you have loaded the image, and we can draw it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你将再次遇到`^^^^^^^^^^^^^^^ could not find `HtmlImageElement` in `web_sys``错误。记住，`web-sys`包大量使用了功能标志，所以你需要将`HtmlImageElement`添加到`Cargo.toml`中的功能标志列表中。在你添加之后，重建将需要更长的时间，但应用程序将再次构建。现在你已经加载了图像，我们可以绘制它。
- en: Canvas coordinates
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布坐标
- en: 'Before we draw it, we need to cover one thing about the `line_to` and `move_to`
    commands that may not have made sense at the time, which is why we need to discuss
    the coordinate system:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制之前，我们需要讨论一下`line_to`和`move_to`命令，这些命令可能当时没有意义，这就是为什么我们需要讨论坐标系的原因：
- en: '![Figure 2.2 – Source: Mozilla (http://mzl.la/30NLhxX)](img/Figure_2.02_B17151.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 来源：Mozilla (http://mzl.la/30NLhxX)](img/Figure_2.02_B17151.jpg)'
- en: 'Figure 2.2 – Source: Mozilla (http://mzl.la/30NLhxX)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 来源：Mozilla (http://mzl.la/30NLhxX)
- en: Our canvas is divided into a 2D grid with dimensions of 600 by 600\. Why 600
    x 600? Because that's the height and width of our canvas element on the HTML page
    that we created in [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015),
    *Hello WebAssembly*. The size itself was completely arbitrary, and we'll probably
    change it as our game grows. The units of the grid are pixels, so when we moved
    the top of our original triangle to `(300.0, 0.0)`, we moved it 300 pixels to
    the right (because `(0.0, 0.0)` is in the top-left corner of the canvas.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的画布被划分为一个600 x 600的2D网格。为什么是600 x 600？因为这是我们创建在HTML页面上的画布元素的宽度和高度，我们在[*第1章*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015)，*Hello
    WebAssembly*中创建了它。这个大小完全是任意的，随着我们的游戏发展，我们可能会改变它。网格的单位是像素，所以当我们将原始三角形的顶部移动到`(300.0,
    0.0)`时，我们将其向右移动了300像素（因为`(0.0, 0.0)`位于画布的左上角。
- en: Drawing images
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制图像
- en: Drawing one image at this point seems uncomplicated – we'll use the `drawImage`
    command from JavaScript; only we'll use the `web-sys` version for `HtmlElement`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段绘制一个图像看起来并不复杂 – 我们将使用JavaScript中的`drawImage`命令；只是我们会使用针对`HtmlElement`的`web-sys`版本。
- en: Tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that JavaScript functions frequently use function overloading, which
    Rust doesn't support, so one JavaScript function may have many corresponding variations
    in Rust.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，JavaScript函数经常使用函数重载，而Rust不支持，所以一个JavaScript函数在Rust中可能有多个相应的变体。
- en: 'So, let''s add the draw command right after the code to load the image, and
    we''ll be done:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在加载图像的代码之后立即添加绘制命令，然后我们就完成了：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've ignored `Result` from the `draw_image_with_html_image_element` command,
    but that should draw the image, except, it…doesn't. It turns out you can't draw
    the image immediately after setting the source of an image element because the
    image hasn't been loaded yet. In order to wait for the image to be loaded, we'll
    use the `onload` callback of `HtmlImageElement`, which you can set up using `set_onload`
    in Rust. To do that, you'll need to learn a little about using JavaScript callbacks
    from Rust in the WebAssembly environment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了`draw_image_with_html_image_element`命令中的`Result`，但应该会绘制图像，但是，它…没有。结果是，你不能在设置图像元素的源之后立即绘制图像，因为图像还没有被加载。为了等待图像加载，我们将使用`HtmlImageElement`的`onload`回调，你可以在Rust中使用`set_onload`来设置它。为了做到这一点，你需要了解一些在WebAssembly环境中使用JavaScript回调的知识。
- en: JavaScript callbacks
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript回调
- en: 'When you set the `onload` callback via the `set_onload` function in Rust, you''re
    calling into JavaScript from WebAssembly, via a function that `web-sys` has generated
    for you. Unfortunately, translating the following JavaScript to Rust is complicated
    by the fact that JavaScript is garbage collected whereas Rust uses manual memory
    management, with its famous borrow checker. Take this code for example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过Rust中的`set_onload`函数设置`onload`回调时，你是在通过WebAssembly调用JavaScript，通过`web-sys`为你生成的函数。不幸的是，将以下JavaScript代码翻译成Rust变得复杂，因为JavaScript是垃圾回收的，而Rust使用手动内存管理，拥有著名的借用检查器。以下是一个例子：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What this means is to actually pass a function to JavaScript, as we want to
    do here, you have to use a complicated signature as well as think carefully about
    the borrowing rules of Rust. It's the kind of code that finally makes sense after
    you get it right but can be hard to write. Let's work through what we need to
    do here.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着要实际传递一个函数到JavaScript，就像我们在这里想要做的那样，你必须使用一个复杂的签名，并且仔细考虑Rust的借用规则。这是一种在你正确理解之后才变得有意义的代码，但可能很难编写。让我们来分析一下我们需要做什么。
- en: 'Back in our source code, right after creating `HtmlImageElement`, we can try
    to add an `onload` callback in a way that seems intuitive:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的源代码中，在创建`HtmlImageElement`之后，我们可以尝试以直观的方式添加一个`onload`回调：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Intuitive might be an exaggeration, but that fits with the code we know how
    to write so far. Unfortunately, that doesn''t work, as you''ll get compiler errors
    about mismatched types, as shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 直观可能是一种夸张，但这与我们迄今为止知道如何编写的代码相符。不幸的是，这不起作用，因为你会在编译器错误中看到类型不匹配的问题，如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As the error says, `set_onload` doesn''t take a Rust closure but instead takes
    `Option<&js_sys::Function>`. Unfortunately, the error doesn''t tell you how to
    fix it, and it''s not clear how to create the `js_sys::Function` object. What
    you can do is start by creating a `Closure` object, with a capital "C," and try
    passing that into `set_onload`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如错误信息所说，`set_onload`不接收Rust闭包，而是接收`Option<&js_sys::Function>`。不幸的是，错误信息没有告诉你如何修复它，而且不清楚如何创建`js_sys::Function`对象。你可以做的是首先创建一个`Closure`对象，首字母大写"C"，然后尝试将其传递给`set_onload`：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Closure` is a `wasm-bindgen` struct that is used to transfer a Rust closure
    to JavaScript. Here, we are using the `once` function on `Closure` because we
    know the `onload` handler is only called once. However, we still can''t just send
    that to JavaScript as is; trying to via `image.set_onload(callback)` results in
    the following error:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Closure`是`wasm-bindgen`结构体，用于将Rust闭包传递到JavaScript。在这里，我们使用`Closure`上的`once`函数，因为我们知道`onload`处理程序只被调用一次。然而，我们仍然不能直接将其发送到JavaScript；通过`image.set_onload(callback)`尝试这样做会导致以下错误：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Remember that `set_onload` wants `Option<&js_sys::Function>`, and so far, we''ve
    only created `Closure`. Fortunately, the `Closure` struct provides a way to make
    that conversion, which looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`set_onload`需要`Option<&js_sys::Function>`，而到目前为止，我们只创建了`Closure`。幸运的是，`Closure`结构体提供了一种进行转换的方法，如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we call `as_ref` on the callback, which returns a raw `JsValue`, and
    then we call `unchecked_ref`, which converts it to a `&Function` object. We pass
    that into `Some` because `onload` can be `null` in JavaScript. Hooray! It compiles!
    The draw code now looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在回调函数上调用`as_ref`，它返回一个原始的`JsValue`，然后我们调用`unchecked_ref`，将其转换为`&Function`对象。我们将它传递给`Some`，因为在JavaScript中`onload`可以是`null`。太棒了！它编译成功了！现在的绘制代码如下：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And if you run the app, it **still** doesn''t show our image, but it does log
    an error in the browser''s console:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，它**仍然**没有显示我们的图片，但在浏览器控制台中记录了一个错误：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When was the closure destroyed? This is all in the `main` function, and so
    the closure is destroyed a couple of lines later when the function completes and
    the `callback` variable is no longer in scope. In order to see our log message,
    we can add one more call to the code after setting the `on_load` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包何时被销毁？这一切都在`main`函数中，因此闭包在函数完成几行后销毁，此时`callback`变量不再在作用域内。为了看到我们的日志消息，我们可以在设置`on_load`函数之后在代码中添加一个额外的调用：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Calling `forget()` on the callback hands over memory management from Rust to
    JavaScript, effectively creating a deliberate memory leak. This is not something
    we want to do often, and it's here strictly to get us past our latest error, by
    preventing the closure from being destroyed. If you compile that and check your
    browser console, you'll see the message "loaded" now. This is great and all, but
    it still doesn't draw our picture because we're not actually waiting for the image
    to be loaded yet. For that, we'll need an asynchronous function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数上调用`forget()`将内存管理从Rust转移到JavaScript，从而有效地创建了一个故意的内存泄漏。这不是我们经常想要做的事情，而且它在这里严格是为了帮助我们克服最新的错误，通过防止闭包被销毁。如果你编译这段代码并检查浏览器控制台，你会看到现在有“loaded”的消息。这很好，但是它仍然没有绘制我们的图片，因为我们实际上还没有等待图片加载完成。为此，我们需要一个异步函数。
- en: Tip
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Translating Rust closures to JavaScript closures is one of those cases where
    the abstractions between JavaScript and Rust are leaking all over the place, and
    it can be "accidentally-swear-in-front-of-your-kids" frustrating. So, don't feel
    bad when you get this wrong or get confused; it just means you're human.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Rust 闭包转换为 JavaScript 闭包是那些 JavaScript 和 Rust 之间的抽象到处泄漏的案例之一，这可能会让人感到“不小心在孩子面前发誓”般的沮丧。所以，当你做错或感到困惑时，不要感到难过；这仅仅意味着你是一个凡人。
- en: Important Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We'll have more examples of sending closures to JavaScript throughout this book,
    but you may find yourself wanting to cross-reference the official documents at
    [http://bit.ly/3kSyOSI](http://bit.ly/3kSyOSI) and [http://bit.ly/3sXt1OW](http://bit.ly/3sXt1OW).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将有更多发送闭包到 JavaScript 的示例，但你可能会发现自己想要交叉引用官方文档[http://bit.ly/3kSyOSI](http://bit.ly/3kSyOSI)和[http://bit.ly/3sXt1OW](http://bit.ly/3sXt1OW)。
- en: Async Rust
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步 Rust
- en: Rust added `async`, letting the runtime know that a function can be made to
    run asynchronously. Inside that function, you can then use an `await` call to
    pause execution of the current thread/process and allow the rest of the application
    to continue until the function that's being waited for can resume. The key thing
    is that while `await` pauses execution of the current execution context, it allows
    the rest of the code to continue. This makes it ideal for a game that cannot ever
    stop executing its game loop. It's also significantly cleaner to work with than
    callback-based code, so we'll be using it here (in combination with channels)
    to make sure that we don't try to draw our image before it's loaded.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 添加了 `async`，让运行时知道可以将函数设置为异步执行。在该函数内部，你可以使用 `await` 调用来暂停当前线程/进程的执行，并允许应用程序的其他部分继续运行，直到等待的函数可以恢复。关键点是，虽然
    `await` 暂停了当前执行上下文的执行，但它允许其他代码继续执行。这使得它非常适合那些永远不会停止执行游戏循环的游戏。与基于回调的代码相比，它的工作方式也更为简洁，因此我们将在这里（结合通道）使用它，以确保我们不会在图像加载完成之前尝试绘制图像。
- en: 'If you''re familiar with using `async`/`.await` in traditional Rust, then you
    know these functions need to execute in a runtime, usually using crates such as
    `tokio` or `async-std`. That runtime is responsible for handing off control and
    restoring it. Take this simple example from the `async-std` library''s repository:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉在传统 Rust 中使用 `async`/`.await`，那么你知道这些函数需要在运行时中执行，通常使用 `tokio` 或 `async-std`
    等crate。该运行时负责传递控制权并恢复它。以下是从 `async-std` 库仓库中的简单示例：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the `async` block is wrapped in a function called `task::block_on`, which
    handles stopping the execution of this block on each `await` call and then resuming
    execution when the `await` "wakes up" for future processing. All of this requires
    spawning threads or checking event loops, code that you don't have to write because
    you're getting it from `async-std`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`async` 块被包裹在一个名为 `task::block_on` 的函数中，该函数在每个 `await` 调用中处理停止该块的执行，然后在
    `await` “醒来”进行未来处理时恢复执行。所有这些都需要生成线程或检查事件循环，这些代码你不需要编写，因为你从 `async-std` 中获取它们。
- en: If you're familiar with other languages that natively support async/.await syntax,
    such as JavaScript, you might wonder why this additional step is necessary. The
    answer is that, unlike JavaScript, Rust doesn't `async` and `await` keywords exist
    in the language but don't work without additional crates, but that's a price we
    pay for additional power.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他原生支持 async/.await 语法的高级语言，例如 JavaScript，你可能会想知道为什么这个额外步骤是必要的。答案是，与 JavaScript
    不同，Rust 语言中不存在 `async` 和 `await` 关键字，但如果没有额外的 crate，它们将无法工作，但这是我们为了获得额外功能所付出的代价。
- en: That's the bad news, but now for the good news – in WebAssembly, we don't need
    any additional runtime! Our code runs in the browser and can, therefore, use the
    browser's runtime; we just need to use a crate to spawn futures on the local event
    loop, and that crate is already present – `wasm_bindgen_futures`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是坏消息，但好消息是——在 WebAssembly 中，我们不需要任何额外的运行时！我们的代码在浏览器中运行，因此可以使用浏览器的运行时；我们只需要使用一个
    crate 在本地事件循环中生成 futures，而这个 crate 已经存在——`wasm_bindgen_futures`。
- en: Spawning a future
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成 future
- en: A `Future`, naturally, but as a user of futures, you don't generally create
    the `Future` type directly. You declare a function or closure as `async`, and
    when an `async` function is called, its return value will be wrapped in `Future`.
    Then, the caller can wait for that `Future` instance to finish by calling `await`.
    The benefit of this approach is that while the program doesn't actually stop when
    you call `await`, it looks like it does from the perspective of the code author.
    This makes the code look a lot more linear. In reality, execution of your program
    continues; otherwise, it would become unresponsive, but the runtime handles picking
    up the program where it left off when `Future` completes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们谈论的是“未来”，但作为一个期货的使用者，你通常不会直接创建`Future`类型。你声明一个函数或闭包为`async`，当调用一个`async`函数时，其返回值将被包裹在`Future`中。然后，调用者可以通过调用`await`来等待那个`Future`实例完成。这种方法的优点是，尽管在调用`await`时程序实际上并没有停止，但从代码作者的视角来看，它看起来像是停止了。这使得代码看起来更加线性。实际上，程序的执行会继续；否则，它将变得无响应，但运行时会处理在`Future`完成时从上次停止的地方恢复程序。
- en: In case you forgot, we're trying to draw a sprite to the canvas, and to do so,
    we have to wait for the image to be loaded first. For that, we'll eventually use
    futures, but there's some infrastructure we need to build first. We'll start by
    adding an `onload` callback to `HtmlImageElement`, which will call a `oneshot`
    channel when the image is loaded. A `oneshot` channel is a channel where the receiver
    implements the `Future` trait, so we can call `await` on it to wait for it to
    receive a message. If we set up the `onload` callback to send a message to that
    channel, we can then call `await` on the receiver so execution will block until
    that image is loaded. Then, we can actually draw the image, knowing it's loaded.
    For all that to work, we need to wrap everything in an `async` block and spawn
    the returned future. That's a limitation of the `await` syntax; it can only work
    inside an `async` function of a block. Naturally, we'll start the implementation
    in the…`Cargo.toml` file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了，我们正在尝试将精灵绘制到画布上，为此，我们必须首先等待图像加载。为此，我们最终将使用期货，但我们需要先构建一些基础设施。我们将首先向`HtmlImageElement`添加一个`onload`回调，当图像加载时，它会调用一个`oneshot`通道。一个`oneshot`通道是一个接收者实现了`Future`特质的通道，因此我们可以调用`await`来等待它接收消息。如果我们设置`onload`回调向那个通道发送消息，然后我们可以在接收者上调用`await`，这样执行就会阻塞，直到图像加载完成。然后，我们实际上可以绘制图像，因为我们知道它已经加载了。为了使所有这些工作，我们需要将所有内容包裹在一个`async`块中并启动返回的期货。这是`await`语法的限制；它只能在`async`函数或块内部工作。自然地，我们将从…`Cargo.toml`文件开始实现。
- en: 'I guess it''s not natural to start with the .`TOML` file, but we need to pull
    the future dependencies into our WebAssembly project. They''re already present
    in testing, so we''ll move `futures` and `wasm-bindgen-futures` out of `dev-dependencies`
    and into the standard `dependencies` block. You can put them right under `getrandom`,
    as shown in the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我想从`.TOML`文件开始并不自然，但我们需要将期货依赖项拉入我们的WebAssembly项目中。它们已经在测试中存在，所以我们将`futures`和`wasm-bindgen-futures`从`dev-dependencies`移动到标准的`dependencies`块中。你可以将它们放在`getrandom`下面，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have access to Rust futures, we can use `wasm_bindgen_futures::spawn_local`
    to spawn a local future and put all our code for drawing the image into it. Returning
    to the code we wrote earlier to load `HtmlImageElement`, we will want to wrap
    all of it in a call to `spawn_local`, as shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了对Rust期货的访问权限，我们可以使用`wasm_bindgen_futures::spawn_local`来启动一个本地期货并将所有用于绘制图像的代码放入其中。回到我们之前编写的用于加载`HtmlImageElement`的代码，我们希望将所有这些代码包裹在一个对`spawn_local`的调用中，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you call `spawn_local`, you need to pass it as a block marked with `async,`
    because `spawn_local` requires `Future`. We've marked this block as `move` to
    give the block ownership of any bindings we reference in it. Later, we'll also
    need to make sure we deal properly with the lifetime of this closure, which must
    be `'static`, but right now, we don't have to worry about that because everything
    is in the closure. This image is still not going to draw because while `Future`
    gets spawned when it runs to completion, our program exits. We need to wait for
    the image to be loaded, and for that, we'll use the `oneshot` channel.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`spawn_local`时，你需要将其作为一个标记为`async,`的块传递，因为`spawn_local`需要`Future`。我们已经将这个块标记为`move`，以便给块赋予我们在此块中引用的任何绑定所有权。稍后，我们还需要确保我们正确处理这个闭包的生命周期，它必须是`'static`，但就目前而言，我们不必担心这一点，因为一切都在闭包中。这张图片仍然不会绘制，因为当`Future`运行到完成时，它会生成，但我们的程序会退出。我们需要等待图像加载，为此，我们将使用`oneshot`通道。
- en: A `oneshot` channel works like its name; you can call once, at which point it
    is consumed and cannot be called again. This means that when you move a `oneshot`
    channel into a Rust closure, the closure immediately becomes `FnOnce`. In fact,
    if you try to move `oneshot` into `FnMut` or `Fn`, you'll get compiler errors,
    with a side effect of your hair falling out as you try to figure out what's wrong.
    So, don't do that – it hurts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`oneshot`通道的工作方式就像它的名字一样；你可以调用一次，此时它被消耗，不能再调用。这意味着当你将`oneshot`通道移动到Rust闭包中时，闭包立即变为`FnOnce`。实际上，如果你尝试将`oneshot`移动到`FnMut`或`Fn`，你会得到编译器错误，副作用是当你试图找出问题所在时，你的头发会掉落。所以，不要这样做——这很痛苦。'
- en: 'Instead, let''s create the channel inside the `spawn_local` block, and then
    replace the `web_sys::console::log_1` call in the callback by sending a message
    to the channel. The changes are shown as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们在`spawn_local`块内部创建通道，然后通过向通道发送消息来替换回调中的`web_sys::console::log_1`调用。更改如下所示：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the first line, we created the `oneshot` channel of `unit` type and then
    moved its transmitter into the callback. We got rid of the log message and replaced
    it with a call to `send` on the transmitter. Now, we need to wait for that message
    to be sent before we try to draw the image. Let''s modify the code underneath
    the closure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了`unit`类型的`oneshot`通道，并将其发射器移动到回调中。我们移除了日志消息，并用对发射器上的`send`的调用替换了它。现在，在我们尝试绘制图像之前，我们需要等待该消息被发送。让我们修改闭包下面的代码：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we remove the `forget` call, as it's no longer necessary since we'll
    wait for the `onload` function to be called before we try to draw the image. That
    makes it okay for the closure to be deleted when the scope completes. Then, we
    call `success_rx.await` to block while the load completes. Finally, we'll draw
    the image as we were doing before, and it shows up!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们移除了`forget`调用，因为它不再必要，因为我们将在尝试绘制图像之前等待`onload`函数被调用。这使得当作用域完成时删除闭包变得可以接受。然后，我们调用`success_rx.await`以阻塞，直到加载完成。最后，我们将像之前一样绘制图像，它就会出现！
- en: '![Figure 2.3 – It is I, Red Hat Boy, king of the triangle](img/Figure_2.03_B17151.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 我是红帽男孩，三角形的国王](img/Figure_2.03_B17151.jpg)'
- en: Figure 2.3 – It is I, Red Hat Boy, king of the triangle
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 我是红帽男孩，三角形的国王
- en: Important Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We're ignoring a lot of results here, which is a bad practice. In the next chapter,
    we'll start structuring our game to better separate concerns, and when doing so,
    we'll remove that in favor of explicit error handling or calls to `expect` if
    we truly want to halt execution.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们忽略了大量的结果，这是一个坏习惯。在下一章中，我们将开始构建我们的游戏，以便更好地分离关注点，并且在这个过程中，我们将移除它，转而使用显式的错误处理或调用`expect`，如果我们真正想要停止执行。
- en: You might wonder why we're using `spawn_local` at all here, instead of just
    using a standard Rust channel and calling `recv` on it, and the reason is that
    a `recv` call blocks the main thread's execution, which is a big no-no in the
    browser. Browser-based code must allow the web browser to continue its event loop,
    and pausing it will cause the browser itself to become unresponsive. You could
    use a `try_rcv` call because that doesn't block, but you'd have to check it in
    a loop to make sure to wait until the image loads. That would also pause the browser
    and would probably cause one of those irritating `The browser is not responding`
    errors. Since both the browser and video games coincidentally can't cause the
    app to become unresponsive, we will use a `spawn_local` block and the `async`/`await`
    syntax. Remember that while the `await` context pauses local execution, the program
    itself actually keeps running, if only to constantly poll and see whether `Future`
    is complete.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们在这里使用`spawn_local`，而不是简单地使用标准的Rust通道并在其上调用`recv`，原因在于`recv`调用会阻塞主线程的执行，这在浏览器中是绝对不允许的。基于浏览器的代码必须允许浏览器继续其事件循环，而暂停它会导致浏览器本身变得无响应。你可以使用`try_rcv`调用，因为它不会阻塞，但你必须在一个循环中检查它，以确保等待图像加载完成。这也会暂停浏览器，并可能引起那些令人烦恼的“浏览器无响应”错误。由于浏览器和视频游戏意外地都不能使应用程序变得无响应，我们将使用`spawn_local`块和`async`/`await`语法。记住，虽然`await`上下文会暂停本地执行，但程序本身实际上仍在运行，只是为了不断地轮询并查看`Future`是否完成。
- en: 'Congratulations! You''ve drawn an image on the screen a mere thousand words
    after I promised you would, but there''s one more thing we have to concern ourselves
    with. Let''s make a small change to the code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在我承诺你会在一千个单词之后在屏幕上绘制图像之后，你做到了，但还有一件事我们必须关注。让我们对代码做一些小的修改：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, if you run the app, the screen doesn't draw anything, including the triangle!
    This is because we await a successful load, which will never come. We need to
    handle the error case as well so that we can continue in the event of a failed
    load rather than hanging, even if we just want to halt the error. What we want
    to do is send one message (a unit) on success and another message (the error)
    to the receiver when the image is finished loading, either one way or the other.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行应用程序，屏幕上什么也没有绘制，包括三角形！这是因为我们等待一个成功的加载，而这个加载永远不会到来。我们需要处理错误情况，以便在加载失败的情况下继续，而不是挂起，即使我们只想停止错误。我们想要做的是在图像加载完成时发送一条消息（一个`unit`）或向接收者发送另一条消息（错误），无论哪种方式。
- en: You might think you can change `success_tx` to take either `unit` or an error
    code when the load fails. We can use `JsValue` for the error since that's the
    type any error code from the browser will be.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为当加载失败时，你可以将`success_tx`改为接受`unit`或错误代码。我们可以使用`JsValue`作为错误，因为浏览器中的任何错误代码都将是这个类型。
- en: Important Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`JsValue` is a type that represents any value that comes directly from JavaScript.
    In Rust code, we''ll frequently convert these types into more specific Rust types.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsValue`是一种表示直接来自JavaScript的任何值的类型。在Rust代码中，我们将经常将这些类型转换为更具体的Rust类型。'
- en: 'That code will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码看起来是这样的：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is immediately going to be a compiler error:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将立即变成一个编译器错误：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`success_tx` cannot be moved into both closures at the same time. We''re going
    to need to use one of the Rust constructs to share the channel across threads
    so that we can use it in both callbacks.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`success_tx`不能同时移动到两个闭包中。我们需要使用Rust构造来在线程之间共享通道，以便我们可以在两个回调中使用它。'
- en: Important Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We could use two `oneshot` channels and a `select` statement here as well, but
    at the time of writing, that did not work well in WebAssembly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里使用两个`oneshot`通道和一个`select`语句，但在编写本文时，这并没有在WebAssembly中很好地工作。
- en: 'What we''ll do is create the channel and then set up a reference counted version
    of the success and error transmitters. This means that both transmitters will
    send to the same receiver. Both of these will need to wrapped inside `Mutex`,
    as shown here, replacing the original creation of the `oneshot` channel:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建通道，然后设置成功和错误发送者的引用计数版本。这意味着这两个发送者将发送到同一个接收者。这两个都需要被包裹在`Mutex`中，就像这里所示，替换原始的`oneshot`通道创建：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we will start sending the channel the `Result`, so we can differentiate
    between success and failure later. You''ll need to make sure that you import `std::rc::Rc`
    and `std::sync::Mutex`. Now that `success_tx` has been changed into `Rc<Mutex<Sender>`,
    you''ll need to update the `success` callback to reflect it. You''ll want to lock
    access to `Mutex` and then send the `success` message. Your first try is likely
    to look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将开始向通道发送 `Result`，这样我们就可以在以后区分成功和失败。你需要确保导入 `std::rc::Rc` 和 `std::sync::Mutex`。现在
    `success_tx` 已经被更改为 `Rc<Mutex<Sender>>`，你需要更新 `success` 回调以反映这一点。你将想要锁定对 `Mutex`
    的访问并然后发送 `success` 消息。你的第一次尝试可能看起来像这样：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This locks `Mutex` and then sends its `oneshot` an `Ok(())`. This is *almost*
    right, but there''s a problem leading to a compiler error, as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这会锁定 `Mutex` 并向其 `oneshot` 发送 `Ok(())`。这几乎是对的，但有一个问题导致编译器错误，如下所示：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The compiler error is a mouthful, so it''s worth breaking it down. As the error
    says, the`.and_then(|oneshot| Ok(oneshot.send(Ok(()))));` line requires the `oneshot`
    value to be moved into the closure. This is because `oneshot` doesn''t implement
    copy. This makes sense; if you could copy `oneshot`, then you could use it more
    than once. Okay, so `oneshot` has to be moved into the closure – so what? Moves
    aren''t bad, but the error says, ``error[E0507]: cannot move out of dereference
    of `std::sync::MutexGuard``. `Mutex` takes ownership of the value you move into
    it, and you can''t just move out its value leaving it with "nothing." So, the
    compiler prevents this action.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器错误信息很长，所以值得分解。正如错误所说，`.and_then(|oneshot| Ok(oneshot.send(Ok(()))));` 这一行需要将
    `oneshot` 值移动到闭包中。这是因为 `oneshot` 没有实现拷贝。这很有道理；如果你可以拷贝 `oneshot`，那么你可以多次使用它。好吧，所以
    `oneshot` 必须移动到闭包中——那么问题是什么？移动并不坏，但错误信息说，“错误[E0507]：不能从 `std::sync::MutexGuard`
    的解引用中移动”。`Mutex` 会获取你移动到其中的值的所有权，你不能只是移动它的值而留下“什么也没有”。因此，编译器阻止了这个操作。
- en: These are the kinds of errors that are both a great feature of Rust and the
    bane of a Rustacean's existence. Here, the compiler is preventing us from making
    a threading mistake, the kind that would be easy to do in almost any other language,
    but the side effect is an error that's hard to read. The Rust team continues to
    work hard on clearer compiler messages, but some things are just hard. When the
    compiler has you confused, read the errors slowly and carefully, and you'll usually
    figure out what it's trying to tell you.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误既是 Rust 的一个伟大特性，也是 Rustacean 存在的痛苦之源。在这里，编译器正在阻止我们犯线程错误，这种错误在几乎所有其他语言中都很容易犯，但副作用是难以阅读的错误。Rust
    团队一直在努力改进编译器信息的清晰度，但有些事情确实很难。当编译器让你感到困惑时，请慢慢仔细地阅读错误，你通常会弄清楚它试图告诉你什么。
- en: So, how do you get around this problem? What you need to do is make sure to
    never move out of the `Mutex` reference while still getting access to the underlying
    `Sender`. The way we can do that is to use the `Option<T>` type, which implements
    a copy and the `take` function. That will allow us to replace, inside the locked
    `Mutex`, `Sender` with `None`. Then, any other user of that `Mutex` reference
    will have `None` and be able to use it appropriately.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何解决这个问题呢？你需要确保在仍然可以访问底层 `Sender` 的同时，永远不要从 `Mutex` 引用中移出。我们可以通过使用 `Option<T>`
    类型来实现这一点，它实现了拷贝和 `take` 函数。这将允许我们在锁定 `Mutex` 内部用 `None` 替换 `Sender`。然后，任何其他使用该
    `Mutex` 引用的用户都将拥有 `None` 并能适当地使用它。
- en: 'Start by modifying the creation of `success_tx` to take `Option`, as shown
    in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改 `success_tx` 的创建，使其接受 `Option`，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, in the `success` callback, we need to modify the code to account for the
    transmitter being optional. We''ll use `take` here to immediately replace `Some(transmitter)`
    with `None` when its used. This is the `success` callback:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `success` 回调中，我们需要修改代码以考虑传输器是可选的。这里我们将使用 `take` 来立即将 `Some(transmitter)`
    替换为 `None`，当它被使用时。这是 `success` 回调：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we've used the `if let` construct to get the transmitter out of `Mutex`
    and `Option`. If you follow the code from `success_tx.lock()`, you'll see we call
    `ok` to convert the `lock()` result to an `Option`, use the `and_then` function
    to operate on the `Some` version of `Option`, and then finally use `take` to get
    the value of `Option`. In the `if` condition, we call the transmitter's `send`
    function with an `Ok` result, and we no longer need the strange `Ok` wrapper around
    the `send` call. The key is that `Option` never moves out of `Mutex`; it's replaced
    by `None`. Since nobody else can access the `oneshot` struct while in the lock,
    the code is thread-safe, and because we use `Option`, the `Mutex` always contains
    something – even if it's `None`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`if let`构造来从`Mutex`和`Option`中获取发送器。如果你从`success_tx.lock()`的代码跟下来，你会看到我们调用`ok`将`lock()`的结果转换为`Option`，使用`and_then`函数对`Option`的`Some`版本进行操作，然后最终使用`take`来获取`Option`的值。在`if`条件中，我们用`Ok`结果调用发送器的`send`函数，并且我们不再需要围绕`send`调用的奇怪`Ok`包装器。关键是`Option`永远不会从`Mutex`中移出；它被`None`替换。由于在锁定期间没有人可以访问`oneshot`结构，代码是线程安全的，而且因为我们使用了`Option`，`Mutex`总是包含某些东西——即使它是`None`。
- en: 'We can finally write the `error` callback that started all this, and it''s
    very similar:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于可以编写开始所有这些的`error`回调了，它非常相似：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That `error` callback needs to be set using the `set_onerror` call. We had
    that previously, but just in case you didn''t add that earlier, it looks like
    the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`error`回调需要使用`set_onerror`调用设置。我们之前有那个，但以防你之前没有添加，它看起来如下：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I placed the `set_onerror` call right under the existing `set_onload` call for
    symmetry. We do not need to add a second `await` call for the errors. Both `oneshot`
    transmitters send to the same receiver, because `error_tx` is a clone of `success_tx`,
    and we are protected from receiving an error and success because `oneshot` can
    only fire one time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`set_onerror`调用放在现有的`set_onload`调用下面，以保持对称。我们不需要为错误添加第二个`await`调用。因为`error_tx`是`success_tx`的克隆，并且我们受到保护，不会同时收到错误和成功，因为`oneshot`只能触发一次。
- en: Now, we're handling the error and success cases correctly, and we aren't getting
    compiler errors. If you look at your browser right now, you should see just the
    triangle, as we aren't stuck at the `await` call anymore. Go ahead and restore
    the call to `image.set_src("Idle (1).png")` so that it uses the right file again
    and the RHB shows back up.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正确地处理了错误和成功的情况，并且没有收到编译器错误。如果你现在看看你的浏览器，你应该只看到三角形，因为我们不再卡在`await`调用了。继续恢复`image.set_src("Idle
    (1).png")`的调用，使其再次使用正确的文件，RHB就会重新出现。
- en: So, there it is – our game now displays an image again *and* handles errors.
    But what if your game displays...more than one image?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，就是这样——我们的游戏现在再次显示图像并处理错误。但是，如果你的游戏显示的图像是...多于一个呢？
- en: Sprite sheets
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵表
- en: 'Creating a game where every sprite is its own individual file is certainly
    possible, but it would mean making the player wait for every file to load individually
    when the game started. One common way to organize sprites for a game is a **sprite
    sheet**, which is made up of two parts. The first is an image file with many sprites
    in it, like this one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个每个精灵都是其自身独立文件的游戏当然可能，但这意味着当游戏开始时，玩家需要等待每个文件单独加载。组织游戏精灵的一种常见方式是**精灵表**，它由两部分组成。第一部分是包含许多精灵的图像文件，就像这样：
- en: '![Figure 2.4 – The top of the sprite sheet](img/Figure_2.04_B17151.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 精灵表顶部](img/Figure_2.04_B17151.jpg)'
- en: Figure 2.4 – The top of the sprite sheet
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 精灵表顶部
- en: 'The second part is a map of coordinates and metadata that lets us "cut out"
    each image we need, like a cookie cutter. For instance, if we want to show the
    first sprite in the preceding figure (which happens to be named `Dead (7).png`),
    we''ll need to know its location and dimensions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是坐标和元数据的映射，它允许我们“裁剪”我们需要的每个图像，就像饼干切割器一样。例如，如果我们想要显示前面图中的第一个精灵（碰巧命名为`Dead
    (7).png`），我们需要知道其位置和尺寸：
- en: '![Figure 2.5 – One sprite in the sheet](img/Figure_2.05_B17151.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 图表中一个精灵](img/Figure_2.05_B17151.jpg)'
- en: Figure 2.5 – One sprite in the sheet
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 图表中一个精灵
- en: I've drawn a box marking the frame you'd want to "cut out" of the image when
    you want to draw `Dead (7).png`. When you want to draw a different file, say `Slide
    (1).png`, you can use the same image but a different frame when drawing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我画了一个框，标记了你想要从图像中“裁剪”的帧，当你想要绘制`Dead (7).png`时。当你想要绘制不同的文件，比如`Slide (1).png`时，你可以在绘制时使用相同的图像但不同的帧。
- en: 'In order to know the frame and names of every sprite sheet, we need to load
    a separate file that stores all that information alongside the image itself. In
    our case, we will use files I''ve already generated for you with a tool called
    *TexturePacker* ([https://www.codeandweb.com/texturepacker](https://www.codeandweb.com/texturepacker)),
    which lets you export a JSON file that looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道每个精灵表格的帧和名称，我们需要加载一个单独的文件，该文件存储所有这些信息以及图像本身。在我们的情况下，我们将使用一个名为 *TexturePacker*
    的工具（[https://www.codeandweb.com/texturepacker](https://www.codeandweb.com/texturepacker)）为我生成的文件，该工具允许你导出一个看起来像这样的
    JSON 文件：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*TexturePacker* generated a JSON file with a lookup table by sprite name. In
    this case, the "`Dead` `(7).png`" sprite is found at (`0,0`) with a width of 109
    pixels and a height of 67 pixels, so in the upper left-hand corner of the larger
    image. To draw the image, you''ll eventually use a version of the `drawImage`
    function that takes source coordinates, which are the dimensions you saw in the
    preceding code, and destination coordinates where you want to position the drawing
    on the canvas.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*TexturePacker* 通过精灵名称生成了一个包含查找表的 JSON 文件。在这种情况下，名为 "`Dead` `(7).png`" 的精灵位于
    (`0,0`)，宽度为 109 像素，高度为 67 像素，因此位于较大图像的左上角。要绘制图像，你最终将使用一个 `drawImage` 函数版本，它接受源坐标，即你在前面的代码中看到的尺寸，以及你想要在画布上定位绘制的目标坐标。'
- en: 'So, to render the same `Idle` `(1).png` that we rendered earlier from the sprite
    sheet, we need to do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了渲染之前从精灵表格中渲染的相同的 `Idle` `(1).png`，我们需要做以下事情：
- en: Load the JSON file.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 JSON 文件。
- en: Parse the JSON file into a Rust structure.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 JSON 文件解析为 Rust 结构体。
- en: Load the image into `HtmlImageElement`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像加载到 `HtmlImageElement`。
- en: Use the version of `drawImage` that lets us draw only a part of an image element.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用允许我们只绘制图像元素一部分的 `drawImage` 版本。
- en: There isn't anything else to do, so let's get started.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他事情要做，让我们开始吧。
- en: Loading JSON
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载 JSON
- en: Inside the assets that you downloaded earlier, there's a directory called `sprite_sheets`
    that has two files, `rhb.json` and `rhb.png`. Go ahead and copy both of those
    to the `static` directory so that they can be loaded by our project. Now, let's
    go back and start editing `lib.rs` to load our sheet.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在你之前下载的资产中，有一个名为 `sprite_sheets` 的目录，其中包含两个文件，`rhb.json` 和 `rhb.png`。请将这两个文件都复制到
    `static` 目录中，以便它们可以被我们的项目加载。现在，让我们回到 `lib.rs` 并开始编辑以加载我们的表格。
- en: 'In this case, we''ll start by writing an entirely new function to call `fetch_json`.
    It will use the `window.fetch` call to retrieve the JSON file and then pull the
    JSON off of the response body. This requires two asynchronous calls, so we''re
    going to write the entire thing as an `async` function. Go ahead and put all of
    this after `main`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将首先编写一个全新的函数来调用 `fetch_json`。它将使用 `window.fetch` 调用来检索 JSON 文件，然后从响应体中提取
    JSON。这需要两个异步调用，因此我们将整个内容编写为一个 `async` 函数。请将所有这些内容放在 `main` 之后：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are a few things that won't even compile yet, and we'll fix them as I
    walk through this line by line.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还有一些事情甚至无法编译，我们将在逐行分析时修复它们。
- en: 'First, we retrieve `window`. Once again, we''re using `unwrap` because `window()`
    is an `Option`; in the next chapter, we''ll do a better job of dealing with our
    errors. That second line is a doozy; we''ll go through it in parts:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索 `window`。再一次，我们使用 `unwrap` 因为 `window()` 是一个 `Option`；在下一章，我们将更好地处理我们的错误。第二条线是一个难题；我们将分部分来处理它：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first part is the call to `wasm_bindgen_futures::JsFuture::from`, which
    is a little misleading. `JsFuture` is not a JavaScript future but a Rust future
    backed by a JavaScript promise. We want a Rust future so that we can eventually
    call `await` on it. We call `from` with the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是调用 `wasm_bindgen_futures::JsFuture::from`，这有点误导。`JsFuture` 不是一个 JavaScript
    future，而是一个由 JavaScript promise 支持的 Rust future。我们想要一个 Rust future，这样我们最终可以在它上面调用
    `await`。我们使用以下内容调用 `from`：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This corresponds to the `window.fetch` function in JavaScript, but as with many
    other JavaScript functions, `fetch` is overloaded, so we need to explicitly call
    it `with_str`. That function returns `Promise`, which we immediately convert to
    a future via the `from` call we discussed earlier. Finally, we call `await?` ,
    which will block until `fetch` returns. This is allowed because the `fetch_json`
    function is `async`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于 JavaScript 中的 `window.fetch` 函数，但就像许多其他 JavaScript 函数一样，`fetch` 是重载的，因此我们需要显式调用它为
    `with_str`。该函数返回 `Promise`，我们立即通过之前讨论的 `from` 调用将其转换为 future。最后，我们调用 `await?`，这将阻塞直到
    `fetch` 返回。这是允许的，因为 `fetch_json` 函数是 `async`。
- en: Still with me? If you understood that, you've figured out the hardest part.
    Next, we cast the returned `resp_value` into `Response` because the `fetch` call
    resolves to `JsValue`. Once again, we must convert from the dynamic typing of
    JavaScript to the static typing of Rust, and the `dyn_into()` function does that.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你还在吗？如果你理解了这一点，你就已经解决了最困难的部分。接下来，我们将返回的`resp_value`转换为`Response`，因为`fetch`调用解析为`JsValue`。再一次，我们必须从JavaScript的动态类型转换为Rust的静态类型，而`dyn_into()`函数就是做这件事的。
- en: Now that we've got a response (corresponding to the `Response` object in the
    browser), we can call its `json()` function, corresponding to the `json()` function
    on the web's `Response` object. That function also returns a promise, so we wrap
    it in `JsFuture` as well and block on it with an `await` call.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了一个响应（对应于浏览器中的`Response`对象），我们可以调用它的`json()`函数，对应于网络`Response`对象的`json()`函数。该函数也返回一个promise，所以我们用`JsFuture`包装它，并用`await`调用阻塞它。
- en: Finally, this function returns `Result<JsValue, JsValue>`, which means it's
    `Result` with a dynamic JavaScript object as both its `Ok` or `Err` cases. That's
    why we can use `?` everywhere.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个函数返回`Result<JsValue, JsValue>`，这意味着它是一个`Result`，其`Ok`或`Err`情况都是动态JavaScript对象。这就是为什么我们可以在任何地方使用`?`。
- en: But of course, this still doesn't compile because, once again, we're missing
    a feature flag. Make sure you add `Response` to the list of `web-sys` dependencies,
    and you should be green again. Well, except for the warning that says `fetch_json`
    isn't called.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，这仍然无法编译，因为我们再次缺少一个功能标志。确保你将`Response`添加到`web-sys`依赖项列表中，你应该再次变为绿色。嗯，除了那个说`fetch_json`没有被调用的警告。
- en: Parsing JSON
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析JSON
- en: 'Back in `main`, we''ll make the draw order as Red Hat Boy, the Sierpiński triangle,
    and then another Red Hat Boy. So, after the call to `sierpinski`, let''s fetch
    the "`rhb.json`" file corresponding to the Red Hat Boy''s data file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`main`函数中，我们将绘制顺序设置为红帽男孩、Sierpiński三角形，然后是另一个红帽男孩。所以，在调用`sierpinski`之后，让我们获取对应红帽男孩数据文件的"`rhb.json`"文件：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This fetches the JSON but doesn't parse it into a structure we can use. We have
    a few options for JSON parsing, including using the browser's built-in facilities,
    but this is a Rust book, so let's use a Rust library, **Serde**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这会获取JSON，但不会将其解析成我们可以使用的结构。我们有几种JSON解析的选项，包括使用浏览器内置的功能，但这是本Rust书籍，所以让我们使用Rust库，**Serde**。
- en: 'Serde is one of the more popular serialization libraries for Rust and is excellent
    at taking JSON (as well as many other formats) and converting it to Rust structures.
    Add the necessary dependency to `Cargo.toml`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Serde是Rust中更受欢迎的序列化库之一，它擅长将JSON（以及许多其他格式）转换为Rust结构。在`Cargo.toml`中添加必要的依赖项：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The crate we need is `serde`, which generically handles serialization and deserialization
    (`rhb.json` file that you copied to the `static` directory earlier in your editor.
    At the top, you should see something like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的crate是`serde`，它可以泛型处理序列化和反序列化（你之前在编辑器中将`rhb.json`文件复制到`static`目录中的文件。在顶部，你应该看到类似这样的内容：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This JSON document describes a hash of frames, where the key to each frame is
    the name of the image `("Dead (1).png`") and the structure below it is the properties
    of that image. The property we care about is `frame`. The image for "`Dead (1).png`"
    is located at (`210, 493`) with a width of 71 pixels and a height of 115 pixels.
    Go back to the code, and we can parse that JSON that we fetched earlier.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这份JSON文档描述了一个帧的哈希，其中每个帧的键是图像的名称`("Dead (1).png")`，下面的结构是该图像的属性。我们关心的属性是`frame`。"`Dead
    (1).png`"的图像位于（`210, 493`），宽度为71像素，高度为115像素。回到代码中，我们可以解析我们之前获取的JSON。
- en: 'First, we need to set up data structures that `serde` can use. At the top of
    `lib.rs`, we can add the `Deserialize` procedural macro to the scope:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置`serde`可以使用的数据结构。在`lib.rs`的顶部，我们可以添加`Deserialize`过程宏到作用域中：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You''ll also want to add `HashMap` from `std::collections`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你还想要添加`HashMap`从`std::collections`：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we''ll work backward. You''ll have a `Sheet` class that contains the lookup
    table from the preceding JSON. You can put this struct anywhere in the `lib.rs`
    file, just not inside a function. I put it at the top:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逆向工作。你将有一个包含前面JSON中查找表的`Sheet`类。你可以在`lib.rs`文件中的任何地方放置这个结构体，只是不要在函数内部。我把它放在了顶部：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `[derive(Deserialize)]` macro means we can use `Sheet` as a target for
    deserializing the JSON, and `HashMap` and `String` work automatically, but we
    haven''t defined `Cell`. This will represent the portion of the JSON containing
    `frame`, which is what we care about because it''s where the target sprite is
    located. We''ll add all the structs we need above `Sheet`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`[derive(Deserialize)]`宏意味着我们可以将`Sheet`用作反序列化JSON的目标，`HashMap`和`String`会自动工作，但我们还没有定义`Cell`。这将代表包含`frame`的部分JSON，这是我们关心的，因为它是目标精灵所在的位置。我们将在`Sheet`之上添加所有需要的结构体：'
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Great – we have a bunch of structures that can hold the map of data we need
    to draw our images, but we haven''t filled them, but fortunately, `wasm-bindgen`
    makes this very easy with the `serde-serialize` feature. To enable that feature,
    you''ll need to once again update `Cargo.toml`, replacing the basic `wasm-bindgen`
    dependency with the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们有一系列结构可以保存我们需要绘制图像的数据映射，但我们还没有填充它们，但幸运的是，`wasm-bindgen`通过`serde-serialize`功能使这变得非常简单。要启用该功能，你需要再次更新`Cargo.toml`，将基本的`wasm-bindgen`依赖项替换为以下内容：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Where before you only had `wasm-bindgen = "0.2.78"`, now you''ll need to add
    the `serde-serialize` feature flag, so you have to use the slightly more complex
    syntax. After that builds, you can import the JSON data with only one line of
    code, `into_serde`, after you fetch the JSON:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 之前你只有`wasm-bindgen = "0.2.78"`，现在你需要添加`serde-serialize`功能标志，所以你必须使用稍微复杂一点的语法。构建之后，你只需用一行代码`into_serde`导入JSON数据，在你获取JSON之后：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: I removed the `unwrap` calls and replaced them with `expect` because I wanted
    a specific message in these cases.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我移除了`unwrap`调用，并用`expect`替换了它们，因为我希望在这些情况下有一个特定的消息。
- en: Tip
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Almost all of the dependencies that we are using are very young, and it's unlikely
    that this book will be able to keep up with every quirk. To follow along, stick
    to versions the book is using, but for your own future projects, remember to check
    documents for feature flags, version numbers, or both whenever a dependency seemingly
    doesn't work.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的几乎所有依赖都非常年轻，这本书不太可能跟上每一个怪癖。为了跟上，请坚持使用书中使用的版本，但为了你自己的未来项目，记住，当依赖似乎不起作用时，要检查文档中的功能标志、版本号或两者。
- en: Now that we have the sheet, we are ready to load the image and draw a sprite
    in it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了sheet，我们就可以加载图片并在其中绘制精灵了。
- en: Drawing with our "cookie cutter"
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用我们的“饼干切割器”绘制
- en: 'Recall that we had four steps to draw from a sprite sheet. We''ve completed
    the first two:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们已经有四个步骤来从精灵图中绘制。我们已经完成了前两个：
- en: Load the JSON file.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载JSON文件。
- en: Parse the JSON file into a Rust structure.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JSON文件解析为Rust结构。
- en: Load the image into `HtmlImageElement`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像加载到`HtmlImageElement`。
- en: Use the version of `drawImage` that lets us draw only a part of an image element.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用允许我们只绘制图像元素一部分的`drawImage`版本。
- en: Step 3 is something you've already done before, and like all good programmers,
    we go immediately to one tool when we need to write the same code twice…
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步是你之前已经做过的，就像所有优秀的程序员一样，当我们需要两次编写相同的代码时，我们会立即使用一个工具…
- en: Copy and paste, of course! What, you thought that I was gonna say a function?
    We'll save that for later.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然是复制粘贴！你以为我会说一个函数吗？我们会留到以后再说。
- en: Tip
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: More seriously, copying and pasting to get something working a second time is
    perfectly acceptable; just avoid checking that in as the final version.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，为了使某物第二次工作而复制粘贴是完全可接受的；只是避免将其作为最终版本提交。
- en: 'Copy everything from `let (success_tx, success_rx)` to `success_rx.await` and
    paste it right below, where we converted `rhb.json` into `Sheet`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将从`let (success_tx, success_rx)`到`success_rx.await`的所有内容复制并粘贴到下面，在那里我们将`rhb.json`转换为`Sheet`：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Thanks to the way Rust works, you won''t need to rename any variables, as every
    time you use `let`, you shadow the previous version of that variable and create
    a new binding. In the pasted code, we only need to make one change – to load the
    image sheet instead of "`Idle (1().png`":'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Rust的工作方式，你不需要重命名任何变量，因为每次你使用`let`，你都会覆盖之前的变量版本并创建一个新的绑定。在粘贴的代码中，我们只需要做一个小改动——加载图像sheet而不是"`Idle
    (1().png`"：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Step 3 is now complete; we''ve loaded the large image with many sprites in
    it. Finally, we''ll draw the sprite that we want. Let''s go ahead and draw the
    "`Run (1).png`" sprite, which will admittedly look similar but will allow us to
    add some animation to go along with it. We''ll use the version of the `drawImage`
    call that takes a source location, which is the frame we discussed earlier, and
    a destination location where we will put the image on the canvas. To make sure
    that we see the new image, let''s stick this image somewhere near the middle.
    Add this right after the last `await` call:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步现在已经完成；我们已加载包含许多精灵的大图像。最后，我们将绘制我们想要的精灵。让我们绘制"`Run (1).png`"精灵，它虽然看起来相似，但将允许我们添加一些与之配合的动画。我们将使用带有源位置的`drawImage`调用版本，这是我们之前讨论过的帧，以及目标位置，我们将在这里放置图像在画布上。为了确保我们看到新图像，让我们将其放置在中间附近。在最后一个`await`调用之后添加此图像：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first line, `sheet.frames.get`, retrieves the sprite by name, with an `expect`
    thrown in for when we get the name wrong. The next line is a monster because `drawImage`
    has nine argument versions in JavaScript, and it''s represented in Rust by the
    call to `draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh`.
    That''s a mouthful, but what it means is drawing the image using the source rectangle
    (our frame) to a destination rectangle, where the source rectangle is represented
    by four position and size coordinates, and the destination rectangle is also represented
    by four coordinates. The source rectangle is our frame, drawn from the JSON file
    we loaded earlier. The destination rectangle starts at (`300,300`) to put RHB
    in about the center of the canvas and uses the same width and height because we
    don''t want to change the size of the image. The end result is this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，`sheet.frames.get`通过名称检索精灵，如果名称错误，会抛出`expect`异常。下一行是一个怪物，因为`drawImage`在JavaScript中有九种参数版本，在Rust中通过调用`draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh`来表示。这听起来很复杂，但它的意思是用源矩形（我们的帧）绘制图像到目标矩形，其中源矩形由四个位置和大小坐标表示，目标矩形也由四个坐标表示。源矩形是我们的帧，从我们之前加载的JSON文件中绘制。目标矩形从（`300,300`）开始，将RHB放置在画布的大约中心，并使用相同的宽度和高度，因为我们不想改变图像的大小。最终结果是这个：
- en: '![Figure 2.6 – Multiple Red Hat Boys](img/Figure_2.06_B17151.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 多个红帽男孩](img/Figure_2.06_B17151.jpg)'
- en: Figure 2.6 – Multiple Red Hat Boys
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 多个红帽男孩
- en: The original RHB is up in the left, using its own image file, and the second
    RHB from the sprite sheet is approximately in the center of the triangle. You'll
    notice his right hand is slightly tucked in because it's at the start of his run
    animation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 原始RHB在左上角，使用自己的图像文件，而精灵图集中的第二个RHB大约在三角形的中心。你会注意到他的右手稍微缩回，因为这是他跑步动画的开始。
- en: Speaking of the run animation, how about we see it in action?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 说到跑步动画，我们不妨看看它是如何运作的？
- en: Important Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Loading the sprite sheet and images the way we did here is just one of many
    ways to implement this technique. For example, another option would have been
    to embed the JSON and the images in the Rust executable, perhaps by Base64-encoding
    them, thereby doing all data loading at once. They could also have been bundled
    into destination applications via webpack and exposed to our Rust app. All these
    different ways come with their own trade-offs, and in our case, we have traded
    some complexity and upfront load times for the requirement to make calls to a
    server. Find the solution that works best for your game.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们在这里的方式加载精灵图集和图像只是实现这种技术的方式之一。例如，另一种选择可能是将JSON和图像嵌入Rust可执行文件中，可能通过Base64编码它们，从而一次性完成所有数据加载。它们也可以通过webpack打包到目标应用程序中，并暴露给我们的Rust应用程序。所有这些不同的方式都伴随着它们自己的权衡，在我们的情况下，我们为了满足调用服务器的需求，牺牲了一些复杂性和初始加载时间。为你的游戏找到最佳解决方案。
- en: Adding animation
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动画
- en: 'Sprite animation works just like a flip-book or a movie. Show a sequence of
    images fast enough, where each image is drawn to be only slightly different than
    the previous one, and it causes the illusion of motion. Animation on the canvas
    works in much the same way, where each frame in the sprite sheet has the same
    effect as a drawing in a flip-book:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 小精灵动画的工作原理就像翻页书或电影。快速展示一系列图像，其中每个图像都绘制得与前一个图像略有不同，从而产生运动的错觉。画布上的动画以类似的方式工作，其中精灵图集中的每一帧都像翻页书中的一幅画：
- en: '![Figure 2.7 – The run animation for Red Hat Boy](img/Figure_2.07_B17151.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 红帽男孩的跑步动画](img/Figure_2.07_B17151.jpg)'
- en: Figure 2.7 – The run animation for Red Hat Boy
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 红帽男孩的跑步动画
- en: To draw Red Hat Boy running, we have to simply draw the images in order, one
    at a time, and loop after drawing the last one. Simple for a loop, right?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制正在跑步的红帽男孩，我们只需按顺序绘制图像，一次一个，并在绘制最后一个图像后循环。对于循环来说很简单，对吧？
- en: Of course, it's not quite that simple. First, we can't just use an infinite
    loop, as that would block the browser from any processing, resulting in a frozen
    browser tab. Second, we have to make sure to clear the canvas between each frame.
    Otherwise, we'll see all the images merged together as one draws on top of the
    other. So, each time we draw the canvas, we'll need to clear it first, and then
    draw the desired frame.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，事情并不那么简单。首先，我们不能简单地使用无限循环，因为这将会阻止浏览器进行任何处理，导致浏览器标签页冻结。其次，我们必须确保在每一帧之间清除画布。否则，我们会看到所有图像合并在一起，因为一个图像会在另一个图像之上绘制。所以，每次我们绘制画布时，我们都需要先清除它，然后绘制所需的帧。
- en: Important Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you're familiar with double buffering in traditional game development and
    are worried about seeing flicker when we clear the canvas and then redraw, don't.
    The canvas element already handles this for you.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉传统游戏开发中的双缓冲，并且担心我们在清除画布然后重新绘制时看到闪烁，不用担心。画布元素已经为你处理了这个。
- en: 'Fortunately, you already know almost all you need to in order to draw the animated
    RHB. You''ll need to pass a Rust closure to a function and draw a sprite from
    a sprite sheet. The only thing you don''t know is how to clear the canvas, and
    we''ll cover that in a moment, but we must start by saying goodbye:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你已经几乎知道了绘制动画RHB所需的所有知识。你需要将Rust闭包传递给一个函数，并从精灵表中绘制精灵。唯一你不了解的是如何清除画布，我们稍后会介绍，但我们必须首先说再见：
- en: '`sierpinski` and all the code it uses, including the `midpoint` and `draw_triangle`
    functions. They served us well and will be missed.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sierpinski` 以及它所使用的所有代码，包括 `midpoint` 和 `draw_triangle` 函数。它们为我们服务得很好，将会被怀念。'
- en: '**Delete the idle RHB**: We could probably go to the effort of keeping the
    idle RHB sprite around, but it would require dealing with the duplicated code
    we wrote to create the sprite sheet. It''s best to delete all that copy and paste
    code before the boss finds out.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除闲置的RHB**: 我们可能需要费力地保留闲置的RHB精灵，但这将需要处理我们为创建精灵表而编写的重复代码。最好在BOSS发现之前删除所有这些复制粘贴的代码。'
- en: 'No, go ahead and delete everything inside the `spawn_local` closure up until
    we loaded the `rhb.json` file. After those deletions, your code should look like
    this around `spawn_local`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不，继续删除 `spawn_local` 闭包中直到我们加载 `rhb.json` 文件之前的所有内容。删除这些内容后，你的代码在 `spawn_local`
    附近应该看起来像这样：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, before spawning the local future, the last thing you do is get the `2d`
    context, and the first thing you do after spawning the future is load the JSON.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在生成本地未来之前，你最后要做的事情是获取 `2d` 上下文，而在生成未来之后的第一件事是加载JSON。
- en: Now, it's time to change the draw into a callback function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将绘制改为回调函数了。
- en: '`setInterval` function, which is called `set_interval_with_callback`. First,
    we need to set up the callback itself, using the `Closure` `struct` that we used
    earlier. Right after the `success_rx.await` call, add this:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setInterval` 函数，被称为 `set_interval_with_callback`。首先，我们需要设置回调本身，使用我们之前使用的 `Closure`
    `结构体`。在 `success_rx.await` 调用之后，添加以下内容：'
- en: '[PRE43]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This sets up an empty `Closure`, but unlike the previous time we created `Closure`,
    we're using `Closure::wrap` instead of `Closure::once`. Why? Well, because this
    closure will be called multiple times. This also means we need to use `Box` with
    an explicit cast, `as Box<dyn FnMut()>`, because the `wrap` function requires
    `Box`, and there isn't enough information for the compiler to infer the type.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了一个空的 `Closure`，但与之前我们创建 `Closure` 的时候不同，我们这次使用 `Closure::wrap` 而不是 `Closure::once`。为什么？因为这个闭包将会被多次调用。这也意味着我们需要使用
    `Box` 并进行显式转换，`as Box<dyn FnMut()>`，因为 `wrap` 函数需要 `Box`，并且编译器没有足够的信息来推断类型。
- en: 'Now that we have an empty interval callback, we can schedule it to be called.
    On the next line, add the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个空的间隔回调，我们可以安排它被调用。在下一行，添加以下内容：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Adding that will start the process of calling our `interval_callback` every
    50 milliseconds; however, doing so will cause an error. If you look into the browser''s
    error log via the console, you''ll see this repeated:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个将会启动每50毫秒调用我们的 `interval_callback` 的过程；然而，这样做将会导致错误。如果你通过控制台查看浏览器的错误日志，你会看到这个重复的：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That should sound familiar, as we''ve already fixed it once this chapter. The
    fix will be to once again forget the closure that we passed into `setInterval`
    so that Rust doesn''t destroy it when we leave the scope of this future. Add this
    right *after* the `set_interval` call:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来应该很熟悉，因为我们已经在本章中修复过一次了。修复方法是将我们传递给 `setInterval` 的闭包再次忘记，这样 Rust 就不会在我们离开这个
    future 的作用域时销毁它。在 `set_interval` 调用后添加此行：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Then, go back and check the console to verify that the error has gone away.
    You may need to refresh the browser to ensure that you don't get stale error messages
    showing up to confuse you.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，返回并检查控制台以验证错误是否已消失。你可能需要刷新浏览器以确保不会出现陈旧的错误消息来混淆你。
- en: 'Now that you''ve scheduled a regular callback, let''s add one line to that
    callback to clear the screen:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安排了一个定期的回调，让我们在回调中添加一行来清除屏幕：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will not compile because outside of this callback, we''re still calling
    `draw_image`. Since we''ve moved the `context` into this `Closure`, we''ve run
    afoul of the borrow checker. To address this, we''re going to need to move the
    drawing code into the closure, like so:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法编译，因为在这个回调之外，我们仍在调用 `draw_image`。由于我们将 `context` 移入这个 `Closure`，我们触犯了借用检查器。为了解决这个问题，我们需要将绘图代码移入闭包，如下所示：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Congratulations! You are now clearing the screen and redrawing it every 50 milliseconds.
    Unfortunately, it doesn't look like anything because you're always drawing the
    same image. Let's change the code to loop from "`Run (1).png`" to "`Run (8).png`"
    over and over again.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在每 50 毫秒清除屏幕并重新绘制它。不幸的是，看起来什么都没有，因为你总是在绘制相同的图像。让我们改变代码，让它从 "`Run (1).png`"
    到 "`Run (8).png`" 无限循环。
- en: 'Initialize a frame counter outside of the closure:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包外部初始化一个帧计数器：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, on the inside of the closure, we''ll cycle the frame count between 0 and
    7:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在闭包内部，我们将帧计数器在 0 和 7 之间循环：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Why 0 to 7 when it goes to frame 8? Because we''ll adjust it on the next line
    when we construct `framename`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是 0 到 7，而不是到帧 8？因为我们将在下一行调整它，当我们构造 `framename` 时：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, instead of getting "`Run (1).png`" every time, we''ll get the constructed
    sprite name from the sprite sheet. Just change the `sheet.get` call to use `&frame_name`,
    and we''ll move the call to `get` above the `clear_rect` call as well:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不再每次都获取 "`Run (1).png`"，而是从精灵图集中获取构造的精灵名称。只需将 `sheet.get` 调用改为使用 `&frame_name`，并将
    `get` 调用移至 `clear_rect` 调用之上：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Take a look now and, sure enough, Red Hat Boy is running!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看，红帽男孩正在跑！
- en: '![Figure 2.8 – You can''t see running in a book, trust me](img/Figure_2.08_B17151.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 你在书中看不到跑步，相信我](img/Figure_2.08_B17151.jpg)'
- en: Figure 2.8 – You can't see running in a book, trust me
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 你在书中看不到跑步，相信我
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered rendering sprites to the screen, including
    sprite sheets, but we actually covered so much more than that. We covered how
    to use futures and `async` code in a WebAssembly app, how to parse JSON, and perhaps
    most confusingly how to send Rust closures to JavaScript via the `Closure` struct.
    We also reviewed some of the quirks of using Rust in the WebAssembly environment
    from [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015), *Hello WebAssembly*.
    This chapter was fun, but we made some messy code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了将精灵渲染到屏幕上的内容，包括精灵图集，但实际上我们涵盖的内容远不止于此。我们介绍了如何在 WebAssembly 应用中使用 futures
    和 `async` 代码，如何解析 JSON，以及可能最令人困惑的是，如何通过 `Closure` 结构体将 Rust 闭包发送到 JavaScript。我们还回顾了在
    WebAssembly 环境中使用 Rust 的一些怪癖，这些怪癖在 [*第 1 章*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015)
    *Hello WebAssembly* 中有所提及。本章很有趣，但我们编写了一些混乱的代码。
- en: In the next chapter, we'll deal with that by setting up a simple architecture
    for our game and writing a proper game loop. Lest you think [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)*,
    Creating a Game Loop*, is all refactoring, we'll also move our friend Red Hat
    Boy around the screen. It'll start to look like a real game!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过为我们的游戏设置一个简单的架构并编写一个合适的游戏循环来处理这个问题。以免你认为 [*第 3 章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)*，创建游戏循环*
    只是对代码进行重构，我们还将让我们的朋友红帽男孩在屏幕上移动。它将开始看起来像一款真正的游戏！
