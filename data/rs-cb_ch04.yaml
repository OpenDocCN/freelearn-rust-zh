- en: Creating Crates and Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Crates和Modules
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Defining a module in Rust
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rust中定义模块
- en: Building a nested module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建嵌套模块
- en: Creating a module with struct
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构体创建模块
- en: Controlling modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制模块
- en: Accessing modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问模块
- en: Creating a file hierarchy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件层次结构
- en: Building libraries in Rust
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rust中构建库
- en: Calling external crates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用外部crate
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter focuses on introducing modules and crates in Rust. It will help
    you develop a highly modular and production-grade Rust application. With this,
    you will have a great file hierarchy, which will compliment the development of
    features in a modular fashion. The recipes in the chapter will also help you build
    libraries in Rust and define, control, and access features through external programs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍Rust中的模块和crate。这将帮助你开发高度模块化和生产级别的Rust应用程序。有了这个，你将有一个很好的文件层次结构，这将有助于以模块化的方式开发功能。本章中的食谱还将帮助你构建Rust库，并通过外部程序定义、控制和访问功能。
- en: Defining a module in Rust
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rust中定义模块
- en: All the applications must be modularized so that they become easy to maintain
    and develop. In Rust, we can have a powerful module system for our application
    that could hierarchically split the application source code into logical units,
    which we call modules, and manage their visibility (public/private) across the
    application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序都必须模块化，以便它们易于维护和开发。在Rust中，我们可以为我们的应用程序提供一个强大的模块系统，可以将应用程序源代码分层拆分为逻辑单元，我们称之为模块，并管理它们在应用程序中的可见性（公共/私有）。
- en: The dictionary description of a module is that it's a collection of items, such
    as functions, structs, traits, impl blocks, and even other modules.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的字典描述是它是一组项目，例如函数、结构体、特质、impl块，甚至是其他模块。
- en: You will learn how to create a sample module and understand the concept of visibility
    in this recipe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本食谱中学习如何创建一个示例模块，并理解可见性的概念。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a file named `sample_mod.rs` and open it in your text editor.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_mod.rs`的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息编写代码标题：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a module named `sample_mod` using the `mod` keyword and define a function
    named `private_function` in it:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mod`关键字创建一个名为`sample_mod`的模块，并在其中定义一个名为`private_function`的函数：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define a function named `sample_function` by marking its visibility as public,
    using the `pub` keyword in the module:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在模块中使用`pub`关键字标记其可见性，定义一个名为`sample_function`的函数：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Declare a public function `indirect_private_fn`, which would call `private_function`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个公共函数`indirect_private_fn`，它将调用`private_function`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define `sample_function` outside the scope of the `sample_mod` module:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sample_mod`模块的作用域之外定义`sample_function`：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare the `main` function, in which we will call each item of the `sample_mod`
    module to understand how they work and print the output:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`main`函数，在其中我们将调用`sample_mod`模块的每个项目，以了解它们的工作原理并打印输出：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Upon the correct setup of the preceding code, you should get the following
    screenshot output when you compile and run the program:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置前面的代码后，当你编译并运行程序时，你应该得到以下截图输出：
- en: '![](img/9b6ad408-6aed-42c1-80af-fa537251a934.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b6ad408-6aed-42c1-80af-fa537251a934.png)'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you learned how to create a sample module in Rust and how you
    are allowed to call the items of the module.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你学习了如何创建一个Rust示例模块以及你被允许调用模块的项目。
- en: From this chapter onward we will follow the header style, which is our first
    step. It basically describes what the code or part of the application unit does.
    This is a very good code practice to follow, as it helps when another person starts
    off from where you develop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将遵循标题样式，这是我们第一步。它基本上描述了代码或应用程序单元的部分功能。遵循这种非常好的代码实践，有助于当另一个人从你开发的地方开始时。
- en: We created a module named `sample_mod` using the `mod` keyword, followed by
    the braces `{}`. The content of the module is its items. Each item is designed
    to perform a specific task. By default, all the items in the module have private
    visibility, which means that they cannot be accessed directly outside the scope.
    In the `sample_mod` module, we explicitly created two functions with public visibility
    using the `pub` keyword. We added the keyword before creating or declaring the
    function using the `fn` keyword. This makes the item publicly visible outside
    the scope of the module. The private function or items can be accessed inside
    the scope of the module, where all the items can call each other, so we can indirectly
    call a public item to access a private item from it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `mod` 关键字创建了一个名为 `sample_mod` 的模块，后跟大括号 `{}`。模块的内容是其项。每个项都设计用于执行特定任务。默认情况下，模块中的所有项都具有私有可见性，这意味着它们不能直接在作用域外访问。在
    `sample_mod` 模块中，我们使用 `pub` 关键字显式创建了两个具有公共可见性的函数。我们在使用 `fn` 关键字创建或声明函数之前添加了该关键字。这使得项在模块的作用域外可见。私有函数或项可以在模块的作用域内访问，其中所有项都可以相互调用，因此我们可以间接调用公共项以从它访问私有项。
- en: We create four functions in this code, where three are inside the module and
    one is accessible globally. The first function we created inside `sample_mod`
    was `private_function`, which, by default, has private visibility. Then we created
    two public functions, namely `sample_function` and `indirect_private_fn`, where
    `indirect_private_fn` calls `private_function` in its body.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了四个函数，其中三个在模块内部，一个可以全局访问。我们在 `sample_mod` 内部创建的第一个函数是 `private_function`，它默认具有私有可见性。然后我们创建了两个公共函数，即
    `sample_function` 和 `indirect_private_fn`，其中 `indirect_private_fn` 在其主体中调用 `private_function`。
- en: 'To call an item of the module outside its scope, we have to follow a particular
    syntax--`module_name::publically_visible_function name`. In the `main` function,
    we call `sample_fucntion`, which is a regular function, and the two publicly visible
    items of the `sample_mode` module: `function sample_mod::sample_function()` and
    `sample_mod::indirect_private_fn()`. These items will execute the content inside
    their respective scope.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模块的作用域之外调用模块中的项，我们必须遵循特定的语法--`module_name::publically_visible_function name`。在
    `main` 函数中，我们调用 `sample_fucntion`，这是一个普通函数，以及 `sample_mode` 模块的两个公开可见项：`function
    sample_mod::sample_function()` 和 `sample_mod::indirect_private_fn()`。这些项将执行它们各自作用域内的内容。
- en: On calling the private item of the module, it will throw an error saying that
    the particular item is private. For example, in the preceding recipe, we got an
    error when we directly called `sample_mod::private_function();` from the `main`
    function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用模块的私有项时，它将抛出一个错误，表明特定的项是私有的。例如，在前面的菜谱中，当我们直接从 `main` 函数中调用 `sample_mod::private_function();`
    时，我们得到了一个错误。
- en: Building a nested module
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建嵌套模块
- en: A nested module is where we want to have modules inside modules, performing
    different tasks. You will learn how to declare and access the items of a nested
    module.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套模块是我们希望在模块中拥有模块的地方，执行不同的任务。您将学习如何声明和访问嵌套模块的项。
- en: Nested modules are a great way of having similar items or functional units in
    an application together, which helps in maintaining features and debugging crashes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套模块是将类似项或功能单元在应用程序中一起使用的好方法，这有助于维护特性和调试崩溃。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a file named `sample_nested.rs` in the project workspace
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目工作区中创建一个名为 `sample_nested.rs` 的文件
- en: 'Write the code header information, which will provide an overview of the code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头部信息，这将提供代码的概述：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a module named `sample_mod` using the `mod` keyword:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mod` 关键字创建一个名为 `sample_mod` 的模块：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create another module named `nested_mod` with `function` and public visibility
    under the `sample_mod` module, which makes `sample_mod` a nested module:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sample_mod` 模块下创建另一个名为 `nested_mod` 的模块，其中包含 `function` 和公共可见性，这使得 `sample_mod`
    成为嵌套模块：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a function named `private_function` under the `nested_mod` module:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `nested_mod` 模块下创建一个名为 `private_function` 的函数：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define another module named `private_nested_mod` with a public function named
    `function` inside `sample_mod`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sample_mod` 内部定义另一个名为 `private_nested_mod` 的模块，其中包含一个名为 `function` 的公共函数：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the `main` function and call the nested modules with different items
    declared in them:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并调用嵌套模块，其中包含不同声明的项：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Upon the correct setup of the preceding code, you should get the following
    output when you compile and run the program:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置前面的代码后，当你编译并运行程序时，你应该得到以下输出：
- en: '![](img/12cab925-0611-405f-8ea7-fa5949698ca2.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12cab925-0611-405f-8ea7-fa5949698ca2.png)'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The nested module is a concept where you have a module inside another module.
    This feature is helpful in having a collection of units of application placed
    inside a common header.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套模块是一个概念，其中你有一个模块嵌套在另一个模块内部。这个特性有助于将应用单元集合放置在公共头文件中。
- en: 'In this recipe, we created a module named `sample_mod` using the `mod` keyword;
    in this module, we created two more modules, namely `nested_mod` and `private_nested_mod`,
    with different visibility. The rules of modules'' visibility follow the same rules
    as those of the items of the modules: we have to explicitly mention the `pub`
    keyword to mention the visibility of the module. If we do not mention anything,
    it will be considered private by the Rust compiler.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们使用`mod`关键字创建了一个名为`sample_mod`的模块；在这个模块中，我们创建了另外两个模块，即`nested_mod`和`private_nested_mod`，具有不同的可见性。模块的可见性规则遵循模块项的相同规则：我们必须显式提及`pub`关键字来提及模块的可见性。如果我们不提及任何内容，Rust编译器将认为它是私有的。
- en: 'We then create the items inside the nested modules, which are under the `sample_mod`
    module. In `nested_mod`, which is a public nested module, we created two items:
    a public method named `function` and a private method named `private_function`.
    In the other private nested module `private_nested_mod`, we created a public method
    named `function`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在嵌套模块内部创建项目，这些项目位于`sample_mod`模块下。在公共嵌套模块`nested_mod`中，我们创建了两个项目：一个名为`function`的公共方法和一个名为`private_function`的私有方法。在另一个私有嵌套模块`private_nested_mod`中，我们创建了一个名为`function`的公共方法。
- en: We can have the same name for items/units residing inside different modules.
    In the preceding recipe, we had an item named `function`, which was present in
    both the nested modules.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为位于不同模块中的项/单元使用相同的名称。在先前的菜谱中，我们有一个名为`function`的项，它存在于嵌套模块中。
- en: In the `main` function, we call the respective items that follow the standard
    syntax for accessing items. The only difference here is that the items reside
    inside different nested modules. In this case, we follow the `module_name::nested_module_name:item_name`
    syntax. Here, we first call the module name, followed by the nested module name
    and its items.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们调用遵循标准访问项语法的相应项。这里唯一的区别是项位于不同的嵌套模块中。在这种情况下，我们遵循`module_name::nested_module_name:item_name`语法。在这里，我们首先调用模块名称，然后是嵌套模块名称及其项。
- en: We call a public nested module a public item, which is `sample_mod::nested_mod::function()`.
    It will run fine and execute the contents of the item. On calling a private nested
    module, which in our recipe is `sample_mod::nested_mod::private_function()`, and
    similar private items of the public nested module, which in our recipe is `sample_mod::private_nested_mod::function()`,
    we will get an error mentioning that these items are private, as privately visible
    units cannot be directly accessed outside the scope.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将公共嵌套模块称为公共项，即`sample_mod::nested_mod::function()`。它将正常运行并执行项的内容。在调用私有嵌套模块时，在我们的菜谱中是`sample_mod::nested_mod::private_function()`，以及公共嵌套模块的类似私有项，在我们的菜谱中是`sample_mod::private_nested_mod::function()`，我们将得到一个错误，指出这些项是私有的，因为私有可见单元不能直接在作用域外访问。
- en: We have the `#[allow(dead_code)]` attribute for the item `function` in the `private_nested_mod`
    module. The idea is to disable the `dead_code` lint of the compiler, which will
    warn about the unused function. In simple terms, lint is software which flags
    bugs in the code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`private_nested_mod`模块中的`function`项上使用了`#[allow(dead_code)]`属性。其想法是禁用编译器的`dead_code`
    lint，这将警告关于未使用的函数。简单来说，lint是标记代码中错误的软件。
- en: Creating a module with struct
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构体创建模块
- en: This recipe covers the structs that have an extra level of visibility with their
    fields. The visibility defaults to private and can be overridden with the pub
    modifier. This visibility only matters when a `struct` is accessed from outside
    the module, where it is defined and has the goal of hiding information (encapsulation).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱涵盖了具有额外可见性级别的结构体字段。默认情况下，可见性为私有，可以使用`pub`修饰符来覆盖。这种可见性仅在从定义该结构体的模块外部访问`struct`时才有意义，其目的是隐藏信息（封装）。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a file named `sample_struct.rs` in the project workspace
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目工作区中创建一个名为 `sample_struct.rs` 的文件
- en: 'Write the code header with the details of the code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含代码的详细信息：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a sample module named `sample_struct`, in which you can declare a public
    `struct` named `WhiteBox`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_struct` 的示例模块，在其中你可以声明一个名为 `WhiteBox` 的公共 `struct`：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Declare a public `struct` named `BlackBox` with a private generic type `T`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `BlackBox` 的公共 `struct`，它有一个私有的泛型类型 `T`：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a public constructor named `const_new` using the `impl` keyword, which
    takes the generic `T` type as input:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `impl` 关键字创建一个名为 `const_new` 的公共构造函数，它接受泛型 `T` 类型作为输入：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Declare the `main` function by calling the `struct` items of the`sample_struct`
    module, which is the `whitebox` `struct` item:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `sample_struct` 模块的 `struct` 项来声明 `main` 函数，这是 `whitebox` `struct` 项：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Upon the correct setup of the preceding code, you should get the following
    output when you compile and run the program:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置前面的代码后，当你编译并运行程序时，你应该得到以下输出：
- en: '![](img/72c586e8-b773-412f-86f0-dc9e5fc4820c.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72c586e8-b773-412f-86f0-dc9e5fc4820c.png)'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Until now, in the preceding recipes, we were only looking into modules that
    had functions that acted as their items. In this recipe, we will create `struct`
    items that have an extra level of visibility with their fields.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在前面的菜谱中，我们只关注了具有作为其项的函数的模块。在这个菜谱中，我们将创建具有额外可见性级别的 `struct` 项，其字段。
- en: The visibility, by default, is private and can be changed using the `pub` keyword.
    The visibility allows us to hide information when we try to access a modules',
    items out of the scope of the module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可见性是私有的，可以使用 `pub` 关键字进行更改。可见性允许我们在尝试访问模块外部的作用域中的模块项时隐藏信息。
- en: We created a module named `sample_struct` using the `mod` keyword. We created
    two structs with public visibility, named `WhiteBox` and `BlackBox`, using the
    `pub` and `struct` keywords. In both the `struct` items, we had a generic type
    `T`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `mod` 关键字创建了一个名为 `sample_struct` 的模块。我们使用 `pub` 和 `struct` 关键字创建了两个具有公共可见性的
    `struct`，分别命名为 `WhiteBox` 和 `BlackBox`。在这两个 `struct` 项中，我们都有一个泛型类型 `T`。
- en: In Rust, generic means that the particular unit can accept one or more generic
    type parameters, `<T>`. For example, consider `fn foo<T>(T) { ... }`. Here, `T`
    is the argument that is specified as a generic type parameter using `<T>`, and
    it allows it to take any argument of any type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，泛型意味着特定的单元可以接受一个或多个泛型类型参数，`<T>`。例如，考虑 `fn foo<T>(T) { ... }`。在这里，`T`
    是使用 `<T>` 指定的泛型类型参数的参数，它允许它接受任何类型的任何参数。
- en: In both structs, we had a field named `information`, which was tied up with
    `T`, which is the argument we received. The only difference is that we mentioned
    `information` in `WhiteBox` as public inside the `struct` and `information` inside
    `BlackBox` as private by default.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个 `struct` 中，我们都有一个名为 `information` 的字段，它与 `T` 相关联，即我们接收到的参数。唯一的区别是我们将 `WhiteBox`
    中的 `information` 作为 `struct` 内部的公共提及，而将 `BlackBox` 中的 `information` 默认设置为私有。
- en: Next up, we created an implementation block for `BlackBox` where we explicitly
    specified the generic type `T` in the `impl` block. Inside it, we created a method
    named `const_new`, which we made publically visible, that accepted the generic
    type `T` as an argument and returned a `BlackBox` `struct`. The `const_new` acts
    as a public constructor for `BlackBox`, where we wanted to create the data type.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为 `BlackBox` 创建了一个实现块，在其中我们明确指定了 `impl` 块中的泛型类型 `T`。在其中，我们创建了一个名为 `const_new`
    的方法，我们将其公开可见，它接受泛型类型 `T` 作为参数并返回一个 `BlackBox` `struct`。`const_new` 作为 `BlackBox`
    的公共构造函数，我们希望创建数据类型。
- en: 'In the `main` block, we created the `WhiteBox` structure first and assigned
    it to a variable named `white_box` by `sample_struct::WhiteBox { information:
    "public information \n" }`. Here, we were calling the module, creating a complex
    data structure and printing the `white_box`, information field, which was delivered
    in the preceding step. Next, we tried to create a variable with the data structure
    of `BlackBox` in a similar manner. This led to an error saying the field name
    is private. This is the reason why we created a public method `const_new`, which
    is a constructor for the `BlackBox` data type. We performed this step by `sample_struct::BlackBox::const_new("classified
    information \n")` and assigned it to `_black_box`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '在`main`块中，我们首先创建了`WhiteBox`结构并将其通过`sample_struct::WhiteBox { information: "public
    information \n" }`赋值给名为`white_box`的变量。在这里，我们正在调用模块，创建一个复杂的数据结构并打印`white_box`的信息字段，这是在前面步骤中传递的。接下来，我们尝试以类似的方式创建一个具有`BlackBox`数据结构变量的变量。这导致了一个错误，说字段名是私有的。这就是我们创建一个公共方法`const_new`的原因，它是`BlackBox`数据类型的构造函数。我们通过`sample_struct::BlackBox::const_new("classified
    information \n")`执行此步骤，并将其赋值给`_black_box`。'
- en: This passed the argument from `main` to the `impl` block and created the structure.
    In this way, we were able to define a public `struct` with private fields, but
    we were still not able to publically access the information field by `_black_box.information`,
    as it was a private field originally.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将参数从`main`传递到`impl`块并创建结构。这样，我们能够定义一个具有私有字段的公共`struct`，但我们仍然不能通过`_black_box.information`公开访问信息字段，因为它最初是一个私有字段。
- en: 'The private members can be accessed by indirect methods in the module. Consider
    the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的私有成员可以通过间接方法访问。考虑以下代码片段：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We expose a public constructor `create_foo` in the `foo` module, but the module
    `foo` still remains private and we only expose `create_foo` in `root` by the `use`
    keyword, which means that `bar` can now create a `Foo` `struct` but `create_foo`
    is still private outside of `root`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`foo`模块中公开了一个构造函数`create_foo`，但`foo`模块仍然保持私有，我们只通过`use`关键字在`root`中公开`create_foo`，这意味着`bar`现在可以创建一个`Foo`结构体，但`create_foo`在`root`外部仍然是私有的。
- en: Controlling modules
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制模块
- en: This recipe focuses on the usage of the `use` keyword in the Rust module, which
    will help in binding long and tiresome module call paths to a simple single entity.
    This will improve code readability and provide more control to the developer to
    call module units. We will also go through the scope of `use` and the concept
    of shadowing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方侧重于Rust模块中`use`关键字的用法，这将帮助将长而繁琐的模块调用路径绑定到简单的单个实体。这将提高代码的可读性，并为开发者提供更多调用模块单元的控制。我们还将讨论`use`的作用域和阴影的概念。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器进行编码。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a file named `sample_control.rs` in the project workspace.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目工作区中创建一个名为`sample_control.rs`的文件。
- en: 'Write the code header with the details of the code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含代码的详细信息：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create `other_function` using the `use` keyword, in order to create the binding
    for the `deeply` module''s items:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`use`关键字创建`other_function`，以便为`deeply`模块的项目创建绑定：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Declare the nested module `deeply` with the nested module named `nested` containing
    the public function `sample_function`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明嵌套模块`deeply`，其中包含名为`nested`的嵌套模块，该模块包含公共函数`sample_function`：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a function named `sample_function`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_function`的函数：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Declare the `main` function by calling `other_function`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`other_function`来声明`main`函数：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a block. In this block, use the `use` keyword and declare `deeply ::
    nested :: sample_function`, which is equivalent to binding it to `sample_function`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个块。在这个块中，使用`use`关键字并声明`deeply :: nested :: sample_function`，这相当于将其绑定到`sample_function`：'
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Call `sample_function` outside the block that is created:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建的块外部调用`sample_function`：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Upon the correct setup of the preceding code, you should get the following
    output when you compile and run the program:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置前面的代码后，当你编译并运行程序时，你应该得到以下输出：
- en: '![](img/56deda1c-814d-4cbf-ae51-2eadc68a3039.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56deda1c-814d-4cbf-ae51-2eadc68a3039.png)'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We focused on the `use` keyword in this recipe, which is really handy when your
    modules get deeper (which means there are a lot of nested modules and units).
    In short, `use` helps bind a long module call to a single name. In the preceding
    recipe, we had a nested module named `deeply`, where `nested` is the module inside
    `deeply` that has a public function named `sample_function`. Conventionally, we
    can call this function by `deeply::nested::sample_function`; however, using the
    `use` keyword, we can bind this to a single entity and call it in the `main` function,
    which provides much easier access. Here, we bound this path to `other_function()`
    and we also created a normal function named `sample_function` to understand the
    concept of shadowing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们关注了 `use` 关键字，当你的模块更深时（这意味着有很多嵌套模块和单元），它真的非常方便。简而言之，`use` 帮助将一个长的模块调用绑定到一个单一的名字。在前面的菜谱中，我们有一个名为
    `deeply` 的嵌套模块，其中 `nested` 是 `deeply` 内部的模块，它有一个名为 `sample_function` 的公共函数。传统上，我们可以通过
    `deeply::nested::sample_function` 来调用这个函数；然而，使用 `use` 关键字，我们可以将其绑定到一个单一实体，并在 `main`
    函数中调用它，这提供了更简单的访问。在这里，我们将这个路径绑定到 `other_function()`，我们还创建了一个名为 `sample_function`
    的普通函数来理解阴影的概念。
- en: We created a block inside the `main` function and explicitly mentioned `use
    deeply::nested::sample_function` . We also called `sample_function` after that.
    This calls the `deeply` module's `sample_function` item rather than the globally
    available function and the `use` mentioned in the block ends once it goes outside
    the scope. Calling `sample_function` outside the block will lead to calling the
    global function, as `use` is not active anymore.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `main` 函数内部创建了一个块，并明确提到了 `use deeply::nested::sample_function`。之后我们也调用了
    `sample_function`。这调用的是 `deeply` 模块的 `sample_function` 项目，而不是全局可用的函数，并且当它超出作用域时，块中提到的
    `use` 将结束。在块外部调用 `sample_function` 将导致调用全局函数，因为 `use` 已经不再活跃。
- en: Accessing modules
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问模块
- en: In this recipe, we will use the `self` and `super` keywords in Rust to provide
    better access to the module's units and learn about the scope of Rust units. In
    this recipe, we will create various module units across the code with similar
    names, to create ambiguity in the unit name. We will check out how the `self`
    and `super` keywords help the developer overcome these problems.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Rust 中的 `self` 和 `super` 关键字来提供对模块单元的更好访问，并了解 Rust 单元的范围。在这个菜谱中，我们将在代码中创建具有相似名称的各种模块单元，以创建单元名称的歧义。我们将检查
    `self` 和 `super` 关键字如何帮助开发者克服这些问题。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for coding. Also, create
    a file named `sample_module.rs` in the project workspace.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器进行编码。此外，在项目工作区中创建一个名为 `sample_module.rs` 的文件。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a file named `sample_access.rs` in the project workspace.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目工作区中创建一个名为 `sample_access.rs` 的文件。
- en: 'Write the code header with the details of the code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代码头详细描述代码：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a function named `sample_function` and print ``"called `sample_function()`"``
    in its scope:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_function` 的函数，并在其作用域内打印 ``"called `sample_function()`"``：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare a module named `cool` using the `mod` keyword and create a function
    named `sample_function` with public visibility. Then, print ``called `cool::sample_function()`
    n`` in its scope:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mod` 关键字声明一个名为 `cool` 的模块，并创建一个名为 `sample_function` 的函数，其可见性为公共。然后，在其作用域内打印
    ``"called `cool::sample_function()` n"``：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create another module using the `mod` keyword named `sample_mod` and create
    a function item named `sample_function` by printing ``"called `sample_mod::sample_function()`
    n"``:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mod` 关键字创建另一个模块，命名为 `sample_mod`，并创建一个名为 `sample_function` 的函数项，打印 ``"called
    `sample_mod::sample_function()` n"``：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a module named `cool` with the function item `sample_function` by marking
    its visibility as public using the `pub` keyword, and printing ``"called `sample_mod::cool::sample_function()`
    n"``:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `pub` 关键字标记其可见性为公共，创建一个名为 `cool` 的模块，并包含一个名为 `sample_function` 的函数项，然后打印
    ``"called `sample_mod::cool::sample_function()` n"``：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create another function inside the `cool` module named `indirect_call` by marking
    its visibility as public using the `pub` keyword, and printing ``"called `sample_mod::indirect_call()`,
    thatn> "``:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cool` 模块内部创建另一个函数，命名为 `indirect_call`，并使用 `pub` 关键字标记其可见性为公共，然后打印 ``"called
    `sample_mod::indirect_call()`，thatn> "``：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Call `sample_function` using the `self` and `super` keywords:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `self` 和 `super` 关键字调用 `sample_function`：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a block and call `root_sample_function`, which is bound to `cool::sample_function`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个块并调用 `root_sample_function`，它绑定到 `cool::sample_function`：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the `main` function and call the sample module''s `indirect_call` function:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并调用样本模块的 `indirect_call` 函数：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Upon the correct setup of the preceding code, you should get the following
    screenshot as output when you compile and run the program:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置前面的代码后，当你编译并运行程序时，你应该得到以下截图作为输出：
- en: '![](img/0a32d7ae-7916-4997-a740-7e2ef7ab8b59.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a32d7ae-7916-4997-a740-7e2ef7ab8b59.png)'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the `super` and `self` keywords, we can remove ambiguity when accessing
    items across modules. This can help us eliminate a lot of hardcoding of paths.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `super` 和 `self` 关键字，我们可以消除跨模块访问项时的歧义。这可以帮助我们消除大量的路径硬编码。
- en: We started off by creating a function named `sample_function`. In all the functions,
    we print how the function should be called. Then, we created a module named `cool`
    with a public function named `sample_function`, which had the same name as that
    of the declared outside the scope of `cool`. Lastly, we created a module named
    `sample_mod` consisting of a private function named `sample_function` and a public
    nested module `cool`, and a public function named `sample_function` and publicly
    visible function `indirect_call`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个名为 `sample_function` 的函数。在所有函数中，我们打印出函数应该如何被调用。然后，我们创建了一个名为 `cool`
    的模块，其中包含一个名为 `sample_function` 的公共函数，其名称与在 `cool` 的作用域外声明的名称相同。最后，我们创建了一个名为 `sample_mod`
    的模块，它包含一个名为 `sample_function` 的私有函数和一个公共嵌套模块 `cool`，以及一个名为 `sample_function` 的公共函数和公开可见的函数
    `indirect_call`。
- en: All of the action in this recipe happens in the `indirect_call` function, which
    we call from the `main` function by `sample_mod::indirect_call()`. When we start
    to execute the `indirect_call` function, it first has a print statement that prints
    how the function was called, and then proceeds ahead with calling `self::sample_function()`.
    The `self` keyword refers to the current module scope. In this case, it was `sample_mod`,
    and calling `sample_function()` or `self::sample_function()` would have given
    the same result as they referred to the same `sample_function`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的所有操作都在 `indirect_call` 函数中发生，我们通过 `main` 函数调用 `sample_mod::indirect_call()`
    来调用它。当我们开始执行 `indirect_call` 函数时，它首先有一个打印语句，打印出函数是如何被调用的，然后继续调用 `self::sample_function()`。`self`
    关键字指的是当前模块作用域。在这种情况下，它是 `sample_mod`，调用 `sample_function()` 或 `self::sample_function()`
    会得到相同的结果，因为它们都指向同一个 `sample_function`。
- en: To access `sample_function` of other modules (which in this case is `cool`)
    inside the scope of `sample_mod`, we have to mention the call using the `self`
    keyword, which is `self::cool::sample_function()`. To call the items/units outside
    the scope of the `sample_mod` module, we use `super`, which basically helps in
    calling the items outside the scope of the current module. Here, we called `sample_function`
    using the `super` keyword, which fetched the function that could be accessed by
    any units of the code. We achieved this by calling `super::sample_function()`.
    Next, we created a block in which we had the code chunk `use` `cool::sample_function`
    as `root_sample_function`, which used the `use` keyword to call `sample_function`
    of the `cool` module outside the scope and bind the path to `root_sample_function`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `sample_mod` 作用域内其他模块（在这种情况下是 `cool`）的 `sample_function`，我们必须使用 `self` 关键字来指定调用，即
    `self::cool::sample_function()`。要调用 `sample_mod` 模块作用域外的项/单元，我们使用 `super`，它基本上有助于调用当前模块作用域外的项。在这里，我们使用
    `super` 关键字调用了 `sample_function`，这获取了任何代码单元都可以访问的函数。我们通过调用 `super::sample_function()`
    实现了这一点。接下来，我们创建了一个代码块，其中包含 `use` `cool::sample_function` 作为 `root_sample_function`
    的代码片段，它使用 `use` 关键字在作用域外调用 `cool` 模块的 `sample_function` 并将路径绑定到 `root_sample_function`。
- en: Creating a file hierarchy
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件层次结构
- en: This recipe discusses how to create a file structure for complex and bigger
    code bases so that it would be easier for the developer to manage application
    feature development. We will learn about the rules enforced by the Rust compiler
    to create a file hierarchy successfully so that the developer can utilize and
    get the same flexibility while using modules' units.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱讨论了如何为复杂和更大的代码库创建文件结构，以便开发者更容易管理应用程序功能开发。我们将了解 Rust 编译器强制执行的规则，以成功创建文件层次结构，这样开发者在使用模块单元时可以利用并获得相同的灵活性。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to code. Also, create
    a file named `sample_module.rs` in the project workspace.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来编写代码。此外，在项目工作区中创建一个名为 `sample_module.rs` 的文件。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a file named `sample_split.rs` and a folder named `sample_module` in
    the project workspace:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目工作区中创建一个名为 `sample_split.rs` 的文件和一个名为 `sample_module` 的文件夹：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the `mod.rs`, `nested_mod.rs`, and `sample_private.rs` files inside
    the `sample_module` folder:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sample_module` 文件夹内创建 `mod.rs`、`nested_mod.rs` 和 `sample_private.rs` 文件：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We should get a folder structure, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到以下截图所示的文件夹结构：
- en: '![](img/aaf93d7d-a35b-423a-a127-199ea0e6ad76.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaf93d7d-a35b-423a-a127-199ea0e6ad76.png)'
- en: 'Write the code header with the details of the code in `sample_split.rs`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sample_split.rs` 中编写代码头，包含代码的详细信息：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a folder named `sample_module` containing the content of the `sample_mod`
    module in `sample_split.rs`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_module` 的文件夹，包含 `sample_split.rs` 中 `sample_mod` 模块的内容：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Declare a local function named `sample_function` that will print ``"called
    `sample_function()`"``, which will help in understanding the scope:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `sample_function` 的局部函数，该函数将打印 ``"called `sample_function()`"`，这有助于理解作用域：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define the `main` function, where we can call various items that will help
    in understanding the code workflow in the modules:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数，我们可以调用各种项目，这有助于理解模块中的代码工作流程：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Write the code header with the details of the code in `sample_module/mod.rs`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sample_module/mod.rs` 中编写代码头，包含代码的详细信息：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Declare the different modules that are `sample_private` and the publicly visible
    module `nested_mod` from the files inside the `sample_module` folder.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `sample_module` 文件夹内的文件中声明不同的模块，包括 `sample_private` 模块和公开可见的模块 `nested_mod`：
- en: '`mod.rs` is an essential Rust script file inside the module folder that helps
    the compiler understand the different contents of the module:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod.rs` 是模块文件夹中的一个重要 Rust 脚本文件，它帮助编译器理解模块的不同内容：'
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Declare a public function named `sample_function` and print the called `` `sample_module::sample_function()`
    ``:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `sample_function` 的公开函数，并打印调用 `` `sample_module::sample_function()` ``：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define a function named `private_function` and print the ``"called `sample_module::private_function()`"``:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `private_function` 的函数并打印 ``"called `sample_module::private_function()`"``：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Declare a function named `indirect_access`, which calls `private_function`
    inside its scope:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `indirect_access` 的函数，在其作用域内调用 `private_function`：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Write the code header with the details of the code in `sample_module/nested_mod.rs`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sample_module/nested_mod.rs` 中编写代码头，包含代码的详细信息：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Declare the items of the `nested_mod` module in this script. We start with
    defining the publicly visible `sample_function` and print ``"called `sample_module::nested::sample_function()`"``:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此脚本中声明 `nested_mod` 模块的项。我们首先定义公开可见的 `sample_function` 并打印 ``"called `sample_module::nested::sample_function()`"``：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Define a private function named `private_function` and print ``"called `sample_module::nested::private_function()`"``:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `private_function` 的私有函数并打印 ``"called `sample_module::nested::private_function()`"``：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Write the code header with the details of the code in `sample_module/sample_private.rs`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sample_module/sample_private.rs` 中编写代码头，包含代码的详细信息：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Define a publicly visible function named `public_function` inside the script
    and print ``"called `sample_module::sample_private::public_function()`"``:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本内部定义一个名为 `public_function` 的公开函数并打印 ``"called `sample_module::sample_private::public_function()`"``：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Upon the correct setup of the preceding code, you should get the following
    screenshot as output when you compile and run the program:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置前面的代码后，当你编译并运行程序时，应该得到以下截图作为输出：
- en: '![](img/a7c3afe0-1f3d-4032-b807-9aa2fe172d1d.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7c3afe0-1f3d-4032-b807-9aa2fe172d1d.png)'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It is not possible to have all the modules inside the same script for a large
    application, so we definitely need to follow a file hierarchy to maintain different
    units. We also need to learn the mapping to create a **file hierarchy**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型应用程序，不可能将所有模块放在同一个脚本中，因此我们绝对需要遵循文件层次结构来维护不同的单元。我们还需要学习如何创建 **文件层次结构**。
- en: In the preceding recipe, we created the following files, which are `rs`, and
    a folder named `sample_module`, which has `mod.rs`, `nested_mod.rs`, and `sample_private.rs`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们创建了以下文件，它们是 `rs` 文件，以及一个名为 `sample_module` 的文件夹，其中包含 `mod.rs`、`nested_mod.rs`
    和 `sample_private.rs`：
- en: The `mod.rs` is a mandatory file inside the directory where we mention other
    modules that the `sample_split.rs` function would use in the file. The `sample_module`
    uses the private module `sample_private` and public module `nested_mod`, which
    are declared at the top of the file. We also created two public functions `sample_function`
    and `indirect_access`, which call the private function named `private_function`.
    These items are part of `sample_module` and can be directly called by `sample_module`
    in the `sample_split.rs` file.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod.rs` 是目录中的一个强制文件，我们在其中提到其他模块，这些模块是 `sample_split.rs` 函数在文件中将要使用的。`sample_module`
    使用私有模块 `sample_private` 和公共模块 `nested_mod`，这些模块在文件顶部声明。我们还创建了两个公共函数 `sample_function`
    和 `indirect_access`，它们调用名为 `private_function` 的私有函数。这些项目是 `sample_module` 的部分，可以直接在
    `sample_split.rs` 文件中由 `sample_module` 调用。'
- en: In the `nested_mod.rs` file, we created a public function named `sample_function`,
    which can be called, and a private function named `private_function`, which cannot
    be called. Because `sample_module` is a private element of `nested_mod` and, similarly,
    the `sample_private.rs` file, we have a public function named `public_function`
    that cannot be accessed, as the `sample_private` module is private.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `nested_mod.rs` 文件中，我们创建了一个名为 `sample_function` 的公共函数，它可以被调用，以及一个名为 `private_function`
    的私有函数，它不能被调用。因为 `sample_module` 是 `nested_mod` 的私有元素，同样地，`sample_private.rs` 文件也是，我们有一个名为
    `public_function` 的公共函数，它不能被访问，因为 `sample_private` 模块是私有的。
- en: In `sample_split.rs`, which is outside the `sample_module` directory, we used
    this script as the gateway to call the modules that were inside the `sample_module`
    folder. We started off by calling `mod` `sample_module`, which is the module name
    to call the contents of the directory. We also created a function named `sample_function`,
    local to `sample_split.rs`, for understanding the purpose. Then, in the `main`
    function, we called all the units.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sample_split.rs` 文件中，它位于 `sample_module` 目录之外，我们使用这个脚本作为调用 `sample_module`
    文件夹内模块的网关。我们首先调用 `mod` `sample_module`，这是要调用的模块名称，用于调用目录的内容。我们还创建了一个名为 `sample_function`
    的函数，它是 `sample_split.rs` 的局部函数，用于理解其目的。然后，在 `main` 函数中，我们调用了所有单元。
- en: First, we called `sample_module::sample_function()`, which is the element of
    the `sample_function` module itself. The working of `sample_module::indirect_access()`,
    which would call the private item of `sample_module`, would be similar. To call
    the `nested_mod` public element, we called `sample_module::nested_mod::sample_function()`,
    which has the same syntax as that of the nested module.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用了 `sample_module::sample_function()`，这是 `sample_function` 模块本身的元素。`sample_module::indirect_access()`
    的工作方式，它将调用 `sample_module` 的私有项，将是类似的。要调用 `nested_mod` 的公共元素，我们调用了 `sample_module::nested_mod::sample_function()`，其语法与嵌套模块相同。
- en: Building libraries in Rust
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中构建库
- en: In this recipe, you will learn how to build libraries that will contain the
    functional units of the Rust application, and the way we can compile the application
    in a library format so that we can access it externally from other programs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何构建包含 Rust 应用程序功能单元的库，以及我们可以如何以库格式编译应用程序，以便我们可以从其他程序外部访问它。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to code. Also, create
    a file named `sample_module.rs` in the project workspace.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来编写代码。同时，在项目工作区中创建一个名为 `sample_module.rs` 的文件。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a file named `sample_lib.rs` in the project workspace
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目工作区中创建一个名为 `sample_lib.rs` 的文件
- en: 'Write the code header with the details of the code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码头编写代码的详细信息：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define a public visible function named `public_function` and print ``"called
    sample_lib `public_function()`"``:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `public_function` 的公共可见函数并打印 ``"called sample_lib `public_function()`"``：
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Define a private function named `private_function` and print ``"called sample_lib
    `private_function()`"``:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `private_function` 的私有函数并打印 ``"called sample_lib `private_function()`"``：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Define another public function named `indirect_access` that will call `private_function`,
    declared in the preceding step, in its scope:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个名为 `indirect_access` 的公共函数，它将在其作用域内调用前面步骤中声明的 `private_function`：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once the preceding code is set up, compile and run the project by the following
    command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好前面的代码，可以通过以下命令编译并运行项目：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We should get the following screenshot as output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到以下截图作为输出：
- en: '![](img/150c8c6a-0f15-4fda-adf5-cb382d564ba9.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/150c8c6a-0f15-4fda-adf5-cb382d564ba9.png)'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...'
- en: In this recipe, we created a sample library and made a `.rlib` extension package
    of the code. This will help us call the units of the library in other crates or
    Rust programs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们创建了一个示例库，并使代码具有`.rlib`扩展包。这将帮助我们调用库在其他crate或Rust程序中的单位。
- en: We created two public functions named `public_function` and `indirect_access`
    and a private function named `private_function`. We called `private_function`
    from `indirect_access`, which is a way through which we can call it outside the
    scope. Then, we created the library using the Rust compiler and passed a few command-line
    arguments to it, which tells the compiler to create the library format of the
    script.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个名为`public_function`和`indirect_access`的公共函数和一个名为`private_function`的私有函数。我们从`indirect_access`中调用了`private_function`，这是我们可以从外部作用域调用它的方式。然后，我们使用Rust编译器创建了库，并传递了一些命令行参数给它，这些参数告诉编译器创建脚本的库格式。
- en: While compiling the program, we ran `rustc --crate-type=lib sample_lib.rs`,
    which created a package named `libsample_lib.rlib` in the same directory. This
    file can be externally used at other crates. Alternatively, we can use Cargo to
    ship libraries by adding the `[lib]` tag in the `Cargo.toml` file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译程序时，我们运行了`rustc --crate-type=lib sample_lib.rs`，这在同一目录中创建了一个名为`libsample_lib.rlib`的包。此文件可以在其他crate中外部使用。或者，我们可以在`Cargo.toml`文件中添加`[lib]`标签来使用Cargo打包库。
- en: Usually, libraries get prefixed with `lib`, and by default, they get the name
    of their crate file. But this default name can be overridden using the `crate_name`
    attribute while creating the library using rustc.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，库会以`lib`为前缀，并且默认情况下，它们会获得crate文件的名称。但是，在创建库时可以使用`crate_name`属性来覆盖此默认名称。
- en: Calling external crates
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用外部crate
- en: In this recipe, you will learn how to use the external module units, libraries,
    or crates created from another Rust project. During the process, you will understand
    some basic syntax that allows external crate resources to be utilized as modules
    in the code, as well as the `extern crate` keyword, which provides a smooth way
    to call external crate resources.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何使用从另一个Rust项目创建的外部模块单位、库或crate。在这个过程中，你将了解一些基本语法，这些语法允许外部crate资源作为模块在代码中使用，以及`extern
    crate`关键字，它提供了一种平滑地调用外部crate资源的方式。
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor to code. Also, create
    a file named `sample_module.rs` in the project workspace.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来编写代码。此外，在项目工作区中创建一个名为`sample_module.rs`的文件。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a file named `sample_exec.rs` in the project workspace
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目工作区中创建一个名为`sample_exec.rs`的文件
- en: 'Write the code header with the details of the code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含代码的详细信息：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The previous script creates `libsample_lib.rlib`, which uses the `extern` `crate`
    keyword we are calling in this particular script:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的脚本创建了`libsample_lib.rlib`，它使用了我们在特定脚本中调用的`extern crate`关键字：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Declare the `main` function that calls all the public items of `sample_lib`,
    which are `public_function` and `indirect_access`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`main`函数，该函数调用`sample_lib`的所有公共项目，即`public_function`和`indirect_access`：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once the preceding code is setup, compile and run the project by the following
    command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好前面的代码，可以通过以下命令编译和运行项目：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We should get the following screenshot as output:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到以下截图作为输出：
- en: '![](img/fac5f416-2018-457e-b04d-b18f82c83098.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fac5f416-2018-457e-b04d-b18f82c83098.png)'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The aim of this recipe is to reuse the units created in the `libsample_lib.rlib`
    library in the code to link a crate to a new Rust script. We have to use the `extern
    crate` declaration to call the units. This will not only link the library, but
    also import all its items/units under the same module name as the library name,
    which in our case is `sample_lib`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的目的是在代码中重用`libsample_lib.rlib`库中创建的单位，以将一个crate链接到一个新的Rust脚本。我们必须使用`extern
    crate`声明来调用这些单位。这不仅会链接库，还会将库的所有项目/单位导入到与库名相同的模块名下，在我们的例子中是`sample_lib`。
- en: The visibility rules that apply to modules also apply to libraries.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于模块的可见性规则也适用于库。
- en: Our first statement is `extern crate sample_lib`, which imports all the units.
    Now, we can call the units of the external library the way we call module items.
    In the `main` function, we call the units by `sample_lib::public_function()`;
    this would call `public_function` of `sample_lib` and `sample_lib::indirect_access()`
    would call `private_function` of `sample_lib`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一条语句是 `extern crate sample_lib`，这会导入所有单元。现在，我们可以像调用模块项一样调用外部库的单元。在 `main`
    函数中，我们通过 `sample_lib::public_function()` 调用单元；这将调用 `sample_lib` 的 `public_function`，而
    `sample_lib::indirect_access()` 将调用 `sample_lib` 的 `private_function`。
