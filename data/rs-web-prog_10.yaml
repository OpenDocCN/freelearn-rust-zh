- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Deploying Our Application on AWS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 上部署我们的应用程序
- en: In a lot of tutorials and educational materials, deployment is rarely covered.
    This is because there are a lot of moving parts, and the process can be fairly
    brittle. It may be more convenient to refer to other resources when mentioning
    deployment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多教程和教育材料中，部署很少被涉及。这是因为有很多可变的部分，过程可能相当脆弱。在提及部署时，参考其他资源可能更为方便。
- en: In this chapter, we will cover enough to automate deployment on a server on
    **Amazon Web Services** (**AWS**) and then build and connect to a database from
    there. It must be stressed that deployment and cloud computing are big topics—there
    are whole books written on them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何在 **Amazon Web Services** (**AWS**) 上的服务器上自动化部署，并从那里构建和连接数据库。必须强调的是，部署和云计算是很大的主题——关于它们有整本书的论述。
- en: In this chapter, we will get to a point where we can deploy and run our application
    for others to use. Learning how to deploy applications on a server is the final
    step. This is where you will turn the application that you have been developing
    into a practical reality that can be used by others all over the world.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将达到可以部署和运行我们的应用程序以供他人使用的地方。学习如何在服务器上部署应用程序是最后一步。这就是您将您一直在开发的应用程序转变为一个实用现实的过程，可以供全世界的人们使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up our build environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的构建环境
- en: Managing our software with Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 管理我们的软件
- en: Deploying our application on AWS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AWS 上部署我们的应用程序
- en: By the end of this chapter, you will be able to wrap your code up in Docker
    images and deploy it on a server instance on AWS so that it can be accessed by
    other users. You will also be able to configure infrastructure using **Terraform**,
    which is a tool used to define cloud computing infrastructure such as servers
    and databases as code. Once you have finished this chapter, you will have a few
    build scripts that create a build and deployment server using Terraform, pass
    the data from that Terraform build into config files, **SSH** into these servers,
    and run a series of commands resulting in database migrations and spinning up
    the Docker containers on our server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够将您的代码打包成 Docker 镜像，并在 AWS 上的服务器实例上部署，以便其他用户可以访问。您还将能够使用 **Terraform**
    配置基础设施，这是一个用于将服务器和数据库等云计算基础设施定义为代码的工具。完成本章后，您将拥有几个构建脚本，这些脚本使用 Terraform 创建构建和部署服务器，将
    Terraform 构建中的数据传递到配置文件中，**SSH** 到这些服务器，并运行一系列命令，导致数据库迁移并在我们的服务器上启动 Docker 容器。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’ll build on the code built in [*Chapter 9*](B18722_09.xhtml#_idTextAnchor182),
    *Testing Our Application Endpoints and Components*. This can be found at the following
    URL: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09/building_test_pipeline](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09/building_test_pipeline).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于第 [*第9章*](B18722_09.xhtml#_idTextAnchor182) 中构建的代码，*测试我们的应用程序端点和组件*
    进行扩展。您可以在以下网址找到它：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09/building_test_pipeline](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09/building_test_pipeline)。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter10](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下网址找到：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter10](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter10)。
- en: 'This chapter also has the following requirements:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还有以下要求：
- en: 'We will be using Terraform to automate the building of our servers. Because
    of this, we will need to install Terraform using the following URL: [https://learn.hashicorp.com/tutorials/terraform/install-cli](https://learn.hashicorp.com/tutorials/terraform/install-cli).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 Terraform 自动化服务器的构建。因此，我们需要使用以下网址安装 Terraform：[https://learn.hashicorp.com/tutorials/terraform/install-cli](https://learn.hashicorp.com/tutorials/terraform/install-cli)。
- en: 'When we are using Terraform, it will be making calls to the AWS infrastructure.
    We will need AWS authentication, which will be done using the AWS client. We will
    be using the AWS client in this chapter, which can be installed using the following
    URL: [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用 Terraform 时，它将对 AWS 基础设施进行调用。我们需要 AWS 认证，这将通过 AWS 客户端来完成。在本章中，我们将使用 AWS
    客户端，可以使用以下网址安装：[https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)。
- en: You will also need a Docker Hub account so that we can package and deploy our
    application. This can be found at [https://hub.docker.com/](https://hub.docker.com/).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还需要一个 Docker Hub 账户，这样我们就可以打包和部署我们的应用程序。这可以在以下网址找到：[https://hub.docker.com/](https://hub.docker.com/)。
- en: 'Since you will be deploying the application on a server, you will need to sign
    up for an AWS account. This can be done at the following URL: [https://aws.amazon.com/](https://aws.amazon.com/).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于你将在服务器上部署应用程序，你需要注册一个 AWS 账户。这可以在以下网址完成：[https://aws.amazon.com/](https://aws.amazon.com/)。
- en: Setting up our build environment
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的构建环境
- en: So far, we have been running our application with the `cargo run` command. This
    has been working well, but you might have noticed that our application is not
    very fast. In fact, it is relatively slow when we try to log in to the application.
    This seems to be counterintuitive as we are learning Rust to develop faster applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用 `cargo run` 命令运行我们的应用程序。这一直运行得很好，但你可能已经注意到我们的应用程序速度并不快。事实上，当我们尝试登录到应用程序时，它相对较慢。这似乎与我们学习
    Rust 来开发更快应用程序的目标相悖。
- en: 'So far, it does not look very fast. This is because we are not running an optimized
    version of our application. We can do this by adding the `--release` tag. As a
    result, we run our optimized application using the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它看起来并不快。这是因为我们没有运行应用程序的优化版本。我们可以通过添加 `--release` 标签来实现这一点。结果，我们使用以下命令运行我们的优化应用程序：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we notice that the compilation takes a lot longer. Running this every
    time we alter the code, and during a development process, is not ideal; hence,
    we have been building and running in debug mode using the `cargo run` command.
    However, now that our optimized application is running, we can see that the login
    process is a lot faster. While we can run the server locally, our aim is to deploy
    our application on a server. To run our application on a server, we are going
    to have to build our application in a Docker image. To ensure that our Docker
    image build runs smoothly, we are going to use an online computing unit on AWS.
    Before we run our build process, we need to carry out the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注意到编译需要更长的时间。每次我们更改代码，以及在开发过程中运行这个命令，都不是理想的；因此，我们一直使用 `cargo run` 命令在调试模式下构建和运行。然而，现在我们的优化应用程序正在运行，我们可以看到登录过程要快得多。虽然我们可以在本地运行服务器，但我们的目标是部署我们的应用程序到服务器上。为了在我们的应用程序上运行，我们必须在
    Docker 镜像中构建我们的应用程序。为了确保我们的 Docker 镜像构建过程顺利，我们将在 AWS 上使用在线计算单元。在我们运行构建过程之前，我们需要执行以下步骤：
- en: Set up an AWS **Secure Shell** (**SSH**) key for **Elastic Compute** **Cloud**
    (**EC2**)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 AWS **安全外壳**（**SSH**）设置 AWS **弹性计算** **云**（**EC2**）密钥
- en: Set up the AWS client for our local computer
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的本地计算机设置 AWS 客户端
- en: Write a Terraform script that builds our build server
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 Terraform 脚本来构建我们的构建服务器
- en: Write a Python script that manages the build
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 Python 脚本来管理构建
- en: Write a Bash script that orchestrates the build on the server
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 Bash 脚本来在服务器上编排构建过程
- en: Once we have done the aforementioned steps, we will be able to run an automated
    pipeline that creates a build EC2 server on AWS and then build our Rust application.
    First, let us get started by creating an SSH key for our server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了上述步骤，我们就能运行一个自动化的流水线，该流水线会在 AWS 上创建一个构建 EC2 服务器，然后构建我们的 Rust 应用程序。首先，让我们开始创建服务器的
    SSH 密钥。
- en: Setting up an AWS SSH key for an AWS EC2 instance
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 AWS EC2 实例设置 AWS SSH 密钥
- en: 'If we want to run commands on a server, we are going to have to connect to
    the server using the SSH protocol over the **Hypertext Transfer Protocol** (**HTTP**).
    However, we cannot have anyone accessing our server as it will not be secure.
    To stop anyone from connecting to our server and running any commands they want,
    we will only allow users to connect to our server if they have an SSH key. To
    create our key, we need to log in to the AWS console and navigate to our EC2 dashboard,
    which can be accessed via the search box, as seen in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在服务器上运行命令，我们将不得不通过**超文本传输协议**（**HTTP**）使用SSH协议连接到服务器。然而，我们不能让任何人访问我们的服务器，因为它将不安全。为了阻止任何人连接到我们的服务器并运行他们想要的任何命令，我们只允许拥有SSH密钥的用户连接到我们的服务器。为了创建我们的密钥，我们需要登录到AWS控制台并导航到我们的EC2仪表板，这可以通过搜索框访问，如下面的屏幕截图所示：
- en: '![Figure 10.1 – Navigating to the EC2 dashboard with the search box](img/Figure_10.1_B18722.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 使用搜索框导航到EC2仪表板](img/Figure_10.1_B18722.jpg)'
- en: Figure 10.1 – Navigating to the EC2 dashboard with the search box
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 使用搜索框导航到EC2仪表板
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It must be noted that AWS might not look like the screenshots in this chapter
    as AWS keeps changing the UI. However, the fundamental concepts will be the same.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，AWS可能看起来与本章中的截图不同，因为AWS不断更改UI。然而，基本概念将是相同的。
- en: 'Once we have navigated to the EC2 dashboard, we can navigate to **Key Pairs**
    in the **Network & Security** section of the panel on the left side of the view,
    as seen in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导航到EC2仪表板，我们可以在视图左侧面板的**网络与安全**部分导航到**密钥对**，如下面的屏幕截图所示：
- en: '![Figure 10.2 – Navigating to Key Pairs](img/Figure_10.2_B18722.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 导航到密钥对](img/Figure_10.2_B18722.jpg)'
- en: Figure 10.2 – Navigating to Key Pairs
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 导航到密钥对
- en: 'Once we have navigated to the **Key Pairs** section, there will be a list of
    key pairs that you already own. If you have built EC2 instances before, you might
    already see some listed. If you have never built an EC2 instance before, then
    you will not have anything listed. On the top right of the screen, you can create
    a key by clicking on the **Create key pair** button shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导航到**密钥对**部分，将有一个您已拥有的密钥对列表。如果您之前构建过EC2实例，您可能已经看到一些列出了。如果您之前从未构建过EC2实例，那么列表将为空。在屏幕右上角，您可以通过点击以下屏幕截图所示的**创建密钥对**按钮来创建一个密钥：
- en: '![Figure 10.3 – Button to allow the creation of a key pair](img/Figure_10.3_B18722.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 允许创建密钥对的按钮](img/Figure_10.3_B18722.jpg)'
- en: Figure 10.3 – Button to allow the creation of a key pair
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 允许创建密钥对的按钮
- en: 'Once we have clicked on this button, we will see the following form:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击了这个按钮，我们将看到以下表单：
- en: '![Figure 10.4 – Create key pair form](img/Figure_10.4_B18722.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 创建密钥对表单](img/Figure_10.4_B18722.jpg)'
- en: Figure 10.4 – Create key pair form
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 创建密钥对表单
- en: 'In the preceding screenshot, we can see that we have named our `remotebuild`
    key; we also state that our key has the `.pem` format and is of the `.ssh` directory.
    Inside the `.ssh` directory, we can create a `keys` directory with the following
    command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到我们已将我们的`remotebuild`密钥命名；我们还声明我们的密钥具有`.pem`格式，并且位于`.ssh`目录下。在`.ssh`目录内，我们可以使用以下命令创建一个`keys`目录：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `"$HOME"` environment variable is always available in the Bash shell, and
    it denotes the home directory for the user. This means that other users who log
    in to the computer under a different username cannot access the SSH keys we downloaded
    if we store them in the directory that we have just created. We can now navigate
    to where our key has been downloaded and copy it to our `keys` directory with
    the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$HOME"`环境变量始终在Bash shell中可用，它表示用户的家目录。这意味着如果我们将这些SSH密钥存储在我们刚刚创建的目录中，其他用户在计算机上以不同的用户名登录时无法访问这些密钥。我们现在可以导航到我们的密钥已下载的位置，并使用以下命令将其复制到`keys`目录：'
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then must change the permissions for the key so that only the owner of the
    file can read the file with the 600 code for us to use the key for SSH purposes
    with the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须更改密钥的权限，以便只有文件的所有者才能使用600代码读取文件，这样我们才能使用密钥进行SSH操作，以下命令即可实现：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We now have an SSH key stored in our `.ssh/keys` directory where we can access
    this key with the correct permissions in order to access the servers that we create.
    Now that we have this, we need programmatic access to our AWS services by setting
    up our AWS client.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 SSH 密钥存储在我们的 `.ssh/keys` 目录中，我们可以使用正确的权限访问这个密钥来访问我们创建的服务器。现在我们有了这个，我们需要通过设置我们的
    AWS 客户端来获取对 AWS 服务的程序访问。
- en: Setting up our AWS client
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的 AWS 客户端
- en: 'We will be using Terraform to automate our server build. In order to do this,
    Terraform will make calls to the AWS infrastructure. This means that we must have
    the AWS client installed on our local machine. Before we configure our client,
    we need to get some programmatic user keys. If we do not obtain programmatic access,
    our code will not be authorized to build infrastructure on our AWS account. The
    first step of obtaining the user keys is navigating to the **IAM** section via
    the search box, as seen in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Terraform 自动化我们的服务器构建。为了做到这一点，Terraform 将调用 AWS 基础设施。这意味着我们必须在我们的本地机器上安装
    AWS 客户端。在我们配置客户端之前，我们需要获取一些程序用户密钥。如果我们没有获取程序访问权限，我们的代码将不会被授权在我们的 AWS 账户上构建基础设施。获取用户密钥的第一步是通过搜索框导航到**IAM**部分，如下面的截图所示：
- en: '![Figure 10.5 – Navigating to the IAM section](img/Figure_10.5_B18722.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 导航到 IAM 部分](img/Figure_10.5_B18722.jpg)'
- en: Figure 10.5 – Navigating to the IAM section
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 导航到 IAM 部分
- en: 'Once we have navigated to the **IAM** section, we will get the following layout:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导航到**IAM**部分，我们将看到以下布局：
- en: '![Figure 10.6 – View of the IAM section](img/Figure_10.6_B18722.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – IAM 部分视图](img/Figure_10.6_B18722.jpg)'
- en: Figure 10.6 – View of the IAM section
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – IAM 部分视图
- en: 'We can see in the preceding screenshot that my user has **multi-factor authentication**
    (**MFA**), and I keep my access key rotated. If you are new to AWS, this checklist
    might not be satisfactory, and it is suggested that you follow the security recommendations
    that AWS gives you. We now must access the **Users** option on the left-hand side
    of the view and create a new user by clicking the **Add users** button in the
    top-right corner of the screen, as seen in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到我的用户启用了**多因素认证**（**MFA**），并且我定期更换访问密钥。如果你是 AWS 的新手，这个清单可能不会令人满意，建议你遵循
    AWS 提供的安全建议。我们现在必须访问视图左侧的**用户**选项，并通过点击屏幕右上角的**添加用户**按钮来创建新用户，如下面的截图所示：
- en: '![Figure 10.7 – Creating users](img/Figure_10.7_B18722.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 创建用户](img/Figure_10.7_B18722.jpg)'
- en: Figure 10.7 – Creating users
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 创建用户
- en: 'We can then create a user. It does not matter what name you call the user,
    but you must ensure that they have programmatic access by checking the **Access
    key - Programmatic access** option, as seen in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个用户。用户的名字不重要，但你必须确保他们有程序访问权限，通过检查**访问密钥 - 程序访问**选项，如下面的截图所示：
- en: '![Figure 10.8 – First stage of creating a user](img/Figure_10.8_B18722.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 创建用户的第一个阶段](img/Figure_10.8_B18722.jpg)'
- en: Figure 10.8 – First stage of creating a user
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 创建用户的第一个阶段
- en: 'Once we have highlighted the programmatic access and defined the username,
    we can move on to the permissions, as seen in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们突出显示了程序访问并定义了用户名，我们就可以继续到权限部分，如下面的截图所示：
- en: '![Figure 10.9 – Defining permissions](img/Figure_10.9_B18722.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 定义权限](img/Figure_10.9_B18722.jpg)'
- en: Figure 10.9 – Defining permissions
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 定义权限
- en: 'We can see that we have given the user `AdministratorAccess` permissions, which
    will enable us to create and destroy servers and databases. The rest of the steps
    in the user creation process are trivial, and you can get through these by just
    clicking **Next**. Once the user is created, you will be exposed to an access
    key and a secret access key. It is important to note these down in a secure location
    such as a password manager because you will never be able to see your secret access
    key again on the AWS site, and we will need them when configuring our AWS client
    on our local computer. Now that we have the user keys handy, we can configure
    our AWS client with the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经赋予了用户 `AdministratorAccess` 权限，这将使我们能够创建和销毁服务器和数据库。用户创建过程中的其余步骤都很简单，您只需点击
    **下一步** 即可完成。一旦用户创建成功，您将获得一个访问密钥和一个秘密访问密钥。请注意，将这些密钥记录在安全的位置，例如密码管理器中，因为您将无法再次在
    AWS 网站上看到您的秘密访问密钥，并且在我们配置本地计算机上的 AWS 客户端时需要它们。现在我们已经有了用户密钥，我们可以使用以下命令配置我们的 AWS
    客户端：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The AWS client will then prompt you to enter the user keys as and when they
    are required. Once this is done, your AWS client is configured, and we can use
    AWS features programmatically on our local computer. Now, we are ready to start
    creating servers using Terraform in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 AWS 客户端将提示您在需要时输入用户密钥。完成此操作后，您的 AWS 客户端配置完成，我们就可以在本地计算机上以编程方式使用 AWS 功能。现在，我们已经准备好在下一节开始使用
    Terraform 创建服务器。
- en: Setting up our Terraform build
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Terraform 构建
- en: When it comes to building infrastructure on AWS, we can simply point and click
    in the EC2 dashboard. However, this is not desirable. If you are anything like
    me, when I point and click a series of configuration settings, I forget what I
    have done unless I document it, and let’s be honest, documenting what you’ve clicked
    is not something you are going to look forward to. Even if you are a better person
    than me and you document it, when you change the configuration, there is a chance
    that you will not go back to update the documentation of that change. Pointing
    and clicking is also time-consuming. If we wanted to create some infrastructure
    and then destroy it a week later, and then recreate it a month after that, we
    would be reluctant to touch it if we had to point and click, and our server bills
    would be higher. This is where **infrastructure as code** (**IaC**) comes in.
    We will have to do some pointing and clicking, as we did in the previous sections.
    We cannot do any programmatic access without pointing and clicking to set up programmatic
    access.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在 AWS 上构建基础设施时，我们可以在 EC2 控制台中简单地点击和选择。然而，这并不是我们所希望的。如果您像我一样，当我点击一系列配置设置时，除非我记录下来，否则我会忘记我做了什么，而且说实话，记录您点击的内容并不是您期待的事情。即使您比我更好，您会记录下来，但当您更改配置时，您可能会忘记返回更新该更改的文档。点击和选择也很耗时。如果我们想创建一些基础设施，然后在一周后销毁它，然后在一个月后再重新创建它，如果我们必须点击和选择，我们可能会不愿意去操作它，而且我们的服务器账单会更高。这就是
    **基础设施即代码**（**IaC**）发挥作用的地方。我们仍然需要像前几节那样进行一些点击和选择。如果我们不点击和选择来设置程序访问权限，我们就无法进行任何程序访问。
- en: 'Now that we have programmatic access, we can build out our `build` directory,
    which should be next to our `web_app` and `front_end` directories. In the `build`
    directory, we can define our infrastructure for the build server in the `build/main.tf`
    file. It must be noted that the `.tf` extension is the standard extension for
    Terraform files. First, we define which version of Terraform is being used with
    the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了程序访问权限，我们可以构建 `build` 目录，该目录应位于我们的 `web_app` 和 `front_end` 目录旁边。在 `build`
    目录中，我们可以在 `build/main.tf` 文件中定义构建服务器的基础设施。必须注意的是，`.tf` 扩展名是 Terraform 文件的标准扩展名。首先，我们使用以下代码定义正在使用哪个版本的
    Terraform：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have defined the Terraform version, we can declare that we are
    using the AWS module. The Terraform registry has modules for a range of platforms,
    including Google Cloud and Microsoft Azure. Anyone can build modules and abstract
    infrastructure to be downloaded on the Terraform registry. Our AWS module usage
    declaration takes the following form:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 Terraform 版本，我们可以声明正在使用 AWS 模块。Terraform 注册表中包含各种平台的模块，包括 Google Cloud
    和 Microsoft Azure。任何人都可以构建模块并抽象基础设施，以便在 Terraform 注册表中下载。我们的 AWS 模块使用声明采用以下形式：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You might want to pick a different region if another region suits you. A list
    of the available regions on AWS for EC2 can be found via the following link: [https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个区域更适合您，您可能想要选择不同的区域。您可以通过以下链接找到 AWS 上可用于 EC2 的所有区域：[https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html)。
- en: 'I’m merely using `"eu-west-2"` for demonstration purposes. We can now build
    our EC2 instance with the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是用 `"eu-west-2"` 来进行演示。现在我们可以用以下代码构建我们的 EC2 实例：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`resource` declares that we are defining a resource to be built, and `aws_instance`
    states that we are using the EC2 instance template in the AWS module. A list of
    the available AWS Terraform modules and their documentation can be found via the
    following link: [https://registry.terraform.io/providers/hashicorp/aws/latest/docs](https://registry.terraform.io/providers/hashicorp/aws/latest/docs).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`resource` 声明我们正在定义一个要构建的资源，而 `aws_instance` 表明我们正在使用 AWS 模块中的 EC2 实例模板。可以通过以下链接找到可用的
    AWS Terraform 模块及其文档：[https://registry.terraform.io/providers/hashicorp/aws/latest/docs](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)。'
- en: '`build_server` is what we are calling it. We can refer to `build_server` anywhere
    else in the Terraform script, and Terraform will work out the order in which resources
    need to be built to make sure all references are accounted for. We can see that
    we have referenced the `"remotebuild"` key that we defined in the previous section.
    We can create multiple EC2 instances that can be accessed by one key if we want.
    We also declare the name so that when we look at our EC2 instances, we know what
    the server is for. We must also note that `user_data` is the Bash script that
    will be run on the new EC2 server once it has been built. The `ami` section is
    a reference to the type of operating system and version being used. Do not directly
    copy my **Amazon Machine Image** (**AMI**) ID in the example unless you are using
    the same region, as AMI IDs can vary depending on the region. If you want to find
    out the AMI ID, go to your EC2 dashboard and click on **Launch an instance**,
    which will result in the following window:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_server` 是我们给它起的名字。我们可以在 Terraform 脚本的任何地方引用 `build_server`，Terraform
    将确定资源构建的顺序，以确保所有引用都被考虑在内。我们可以看到我们引用了上一节中定义的 `"remotebuild"` 键。如果我们想的话，我们可以创建多个可以通过一个密钥访问的
    EC2 实例。我们还声明了名称，这样当我们查看我们的 EC2 实例时，我们就知道服务器是用来做什么的。我们还必须注意，`user_data` 是在新的 EC2
    服务器构建完成后将运行的 Bash 脚本。`ami` 部分是对正在使用的操作系统类型和版本的引用。除非您使用的是相同的区域，否则请不要直接复制示例中的我的
    **Amazon Machine Image** (**AMI**) ID，因为 AMI ID 可能会根据区域而变化。如果您想找到 AMI ID，请转到您的
    EC2 仪表板并点击 **启动实例**，这将导致以下窗口：'
- en: '![Figure 10.10 – Launching an instance](img/Figure_10.10_B18722.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 启动实例](img/Figure_10.10_B18722.jpg)'
- en: Figure 10.10 – Launching an instance
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 启动实例
- en: 'Here, we can see that we are picking **Amazon Linux**. You must select this;
    otherwise, your build scripts will not work. If we zoom in, we can see that the
    AMI ID is visible, as seen here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们选择了 **Amazon Linux**。您必须选择这个选项；否则，您的构建脚本将无法工作。如果我们放大查看，我们可以看到 AMI
    ID 是可见的，如下所示：
- en: '![Figure 10.11 – Accessing AMI ID for the server](img/Figure_10.11_B18722.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 获取服务器的 AMI ID](img/Figure_10.11_B18722.jpg)'
- en: Figure 10.11 – Accessing AMI ID for the server
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 获取服务器的 AMI ID
- en: 'This will be the AMI ID for the Amazon Linux operating system in the region
    that you want to launch. You can also see nothing is stopping you from using other
    operating systems in other Terraform projects. If you have built EC2 instances
    in the past, you will know that the IP address is random unless we attach an elastic
    IP to the EC2 instance. We will have to produce an output of the IP of our EC2
    instance so that we can connect to it. Our output is defined with the following
    code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是您想要启动的区域的 Amazon Linux 操作系统的 AMI ID。您也可以看到没有任何阻止您在其他 Terraform 项目中使用其他操作系统的。如果您以前构建过
    EC2 实例，您将知道除非我们将弹性 IP 绑定到 EC2 实例，否则 IP 地址是随机的。我们将不得不生成我们 EC2 实例的 IP 地址输出，这样我们就可以连接到它。我们的输出是用以下代码定义的：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we can see that we reference our build server using `aws_instance.build_server`.
    Further reading on Terraform outputs is provided in the *Further reading* section.
    At this point, our Terraform build is nearly done. We must remember that we need
    to build the `server_build.sh` script that is going to be run on the EC2 instance
    once the EC2 instance has been built. In our `/build/server_build.sh` file, we
    can install the basic requirements needed for our server with the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们使用`aws_instance.build_server`引用我们的构建服务器。关于Terraform输出的进一步阅读可以在*进一步阅读*部分找到。到目前为止，我们的Terraform构建几乎完成了。我们必须记住，我们需要构建一个`server_build.sh`脚本，这个脚本将在EC2实例构建完成后在EC2实例上运行。在我们的`/build/server_build.sh`文件中，我们可以使用以下代码安装服务器所需的基本要求：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the preceding packages, we will be able to navigate around the server
    looking at file trees with `tree`; we will also be able to perform `git` operations,
    open files, and edit them using `vim`, and have multiple panels open through one
    terminal if we need to with `tmux`. The other packages enable us to compile our
    Rust code. We must also note that we have appended each install with a `-y` tag.
    This is to tell the computer to bypass input prompts and put in default answers.
    This means that we can run this script in the background without any problems.
    We now must install the PostgreSQL drivers with the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的包，我们将能够使用`tree`在服务器上导航并查看文件树；我们还将能够执行`git`操作，打开文件并使用`vim`编辑它们，如果需要的话，通过一个终端打开多个面板。其他包使我们能够编译我们的Rust代码。我们还必须注意，我们在每个安装中都附加了一个`-y`标签。这是告诉计算机跳过输入提示并输入默认答案。这意味着我们可以没有问题地在后台运行此脚本。现在我们必须使用以下代码安装PostgreSQL驱动程序：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We nearly have everything that we need. In the next section, we will be using
    Docker to build and package our applications. This can be done with the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎拥有了我们所需要的一切。在下一节中，我们将使用Docker构建和打包我们的应用程序。这可以通过以下代码完成：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we can see that we install Docker, start the Docker service, and then
    register our user with the Docker service so that we do not have to use `sudo`
    with every Docker command. Seeing as we have installed Docker, we might as well
    install `docker-compose` for completeness. This can be done at the end of our
    script with the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们安装了Docker，启动了Docker服务，然后使用Docker服务注册我们的用户，这样我们就不必在每一个Docker命令中使用`sudo`了。既然我们已经安装了Docker，我们不妨为了完整性安装`docker-compose`。这可以在我们脚本的末尾通过以下代码完成：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `curl` command downloads `docker-compose`. We then make the `docker-compose`
    executable with the `chmod` command. The build script is almost finished. However,
    running all the commands that we have defined in the build script will take a
    while. There is a chance that we can SSH into our server before the build script
    has finished. Therefore, we should write a `FINISHED` string to a file to inform
    other processes that the server has all the packages that have been installed.
    We can write our flag with the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`命令下载`docker-compose`。然后我们使用`chmod`命令使`docker-compose`可执行。构建脚本几乎完成了。然而，运行构建脚本中定义的所有命令将需要一段时间。有可能在构建脚本完成之前我们能够通过SSH连接到我们的服务器。因此，我们应该将一个`FINISHED`字符串写入一个文件，以通知其他进程服务器已经安装了所有已安装的包。我们可以用以下代码写入我们的标志：'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have now built out the infrastructure that is going to build our applications
    for deployment. In the next section, we are going to build scripts that orchestrate
    the building of our application using the build server that we have configured.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了将要为我们构建应用程序以进行部署的基础设施。在下一节中，我们将构建脚本，这些脚本将使用我们配置的构建服务器来编排我们的应用程序构建。
- en: Writing our Python application build script
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的Python应用程序构建脚本
- en: 'We could technically try to fit our application-building script in the same
    scripts that we wrote in the previous section. However, it is desired to keep
    our scripts separate. For instance, if we were going to use a `build/run_build.py`
    script, we start by importing everything that we need with the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们可以尝试将我们的应用程序构建脚本放入我们在上一节中编写的相同脚本中。然而，我们希望保持我们的脚本独立。例如，如果我们打算使用一个`build/run_build.py`脚本，我们首先通过以下代码导入我们需要的所有内容：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We now have the absolute path for the `build` directory, we can run Bash commands
    through the `Popen` class, and we can load JSON. Now that we have everything imported,
    we can run our Terraform commands with the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`build`目录的绝对路径，我们可以通过`Popen`类运行Bash命令，并且我们可以加载JSON。现在我们已经导入了所有内容，我们可以使用以下代码运行我们的Terraform命令：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In each of the commands, we go to the directory path and then perform the Terraform
    command. We then wait for the command to finish before moving on to the next command.
    While Python is a slow, easy, and not strongly typed language, here it adds a
    lot of power. We can run multiple Bash commands at the same time and then wait
    for them later if needed. We can also pull data out of processes and manipulate
    this data and feed it into another command easily. The two Terraform commands
    that we carry out in the preceding snippet are `init` and `apply`. `init` sets
    up the Terraform state to record what is going on and downloads the modules that
    we need, which in this case is AWS. The `apply` command runs the Terraform build,
    which will build our EC2 server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个命令中，我们进入目录路径然后执行 Terraform 命令。然后我们等待命令完成再继续执行下一个命令。虽然 Python 是一个慢速、简单且非强类型的语言，但在这里它增加了很多功能。我们可以同时运行多个
    Bash 命令，并在需要时稍后等待它们。我们还可以轻松地从进程提取数据，操作这些数据并将其输入到另一个命令中。前一个片段中执行的两个 Terraform 命令是
    `init` 和 `apply`。`init` 命令设置 Terraform 状态以记录正在发生的事情并下载我们需要的模块，在这个例子中是 AWS。`apply`
    命令运行 Terraform 构建，这将构建我们的 EC2 服务器。
- en: 'Once our EC2 instance is built, we can get the output of Terraform and write
    it to a JSON file, and then load the data from that JSON file with the following
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的 EC2 实例构建完成，我们可以获取 Terraform 的输出并将其写入 JSON 文件，然后使用以下代码从该 JSON 文件加载数据：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have the server IP, we can SSH into this server and get it to do
    our builds. However, there could be some concurrency issues. There is a small-time
    window where the Terraform build finishes, but the server is not ready yet to
    accept connections. Therefore, we just need the script to wait for a small period
    before continuing with the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了服务器 IP，我们可以 SSH 连接到这台服务器并让它执行我们的构建。然而，可能会存在一些并发问题。在 Terraform 构建完成但服务器尚未准备好接受连接的短暂时间内，因此，我们只需要脚本等待一小段时间后再继续执行以下代码：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once this is done, we need to pass our server IP into another Bash script that
    manages the build and then destroy the server afterward with the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们需要将我们的服务器 IP 传递给另一个管理构建的 Bash 脚本，然后在之后使用以下代码销毁服务器：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have now built the orchestration of a build and the Terraform script that
    defines the infrastructure for the build. We now must build the final build script
    that will run the build commands on the server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了构建的编排和定义构建基础设施的 Terraform 脚本。现在我们必须构建最终的构建脚本，该脚本将在服务器上运行构建命令。
- en: Writing our Bash deployment script
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的 Bash 部署脚本
- en: 'Our Bash deployment script must take in the IP address of the build server,
    SSH into the server, and run a series of commands on the server. It will also
    have to copy our code onto the server to be built. We can see from the preceding
    code that we can build our build Bash script in the `/build/run_build.sh` file.
    First, we start with the standard boilerplate code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Bash 部署脚本必须接受构建服务器的 IP 地址，SSH 连接到服务器，并在服务器上运行一系列命令。它还必须将我们的代码复制到服务器上进行构建。我们可以从前面的代码中看到，我们可以在
    `/build/run_build.sh` 文件中构建我们的构建 Bash 脚本。首先，我们从标准的样板代码开始：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this boilerplate code, we have stated that this is a Bash script and that
    the rest of the Bash code will run in the `build` directory. We then upload the
    code from the Rust application with the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个样板代码，我们声明这是一个 Bash 脚本，并且其余的 Bash 代码将在 `build` 目录中运行。然后我们使用以下代码上传 Rust 应用程序的代码：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we can see that we remove the `target` directory. As we remember, the
    `target` directory is built when we build our Rust application; we do not need
    to upload build files from the local build. We then copy our Rust code using the
    `scp` command. We access the first argument passed into the script, which is `$1`.
    Remember that we pass in the IP address, so `$1` is the IP address. We then SSH
    into our server and run commands on this server with the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们移除了 `target` 目录。正如我们所记得的，`target` 目录是在我们构建 Rust 应用程序时创建的；我们不需要从本地构建上传构建文件。然后我们使用
    `scp` 命令复制我们的 Rust 代码。我们访问脚本传入的第一个参数，即 `$1`。记住，我们传入的是 IP 地址，所以 `$1` 是 IP 地址。然后我们通过以下代码
    SSH 连接到我们的服务器并在该服务器上运行命令：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we see that we loop sleeping for 2 seconds on each iteration until the
    `output.txt` file is present. Once the `output.txt` file is present, we know that
    the build script from the Terraform is complete and we can start our build. We
    signal this by echoing `"File found"` to the console. We then install Rust, load
    our `cargo` commands into our shell with the `source` command, move into the `web_app`
    directory, and build our Rust application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们在每次迭代中循环休眠2秒钟，直到`output.txt`文件出现。一旦`output.txt`文件出现，我们就知道Terraform的构建脚本已经完成，我们可以开始我们的构建。我们通过在控制台回显`"File
    found"`来发出这个信号。然后我们安装Rust，使用`source`命令将我们的`cargo`命令加载到我们的shell中，移动到`web_app`目录，并构建我们的Rust应用程序。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We can get rid of the Python dependency if needed by using the `jq` command
    in our `run_build.sh` script with the following code insertion:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以通过在`run_build.sh`脚本中使用`jq`命令并插入以下代码来去除Python依赖：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It must be noted that the references to the `$1` variable are replaced with
    `$IP_ADDRESS`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，对`$1`变量的引用会被替换为`$IP_ADDRESS`。
- en: 'To run our pipeline without the Python dependency, we merely need to run the
    following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要在没有Python依赖的情况下运行我们的管道，我们只需要运行以下命令：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, we will be relying on our Python script later on in the chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在接下来的章节中，我们将依赖于我们的Python脚本。
- en: 'Now that our build pipeline is built, we can run it with the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了构建管道，我们可以使用以下命令来运行它：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: WARNING
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Terraform can sometimes be temperamental; if it fails, you may need to run it
    again. Sometimes, I’ve had to perform a Terraform run up to three times before
    it fully works. Every action is stored by Terraform, so do not worry—running the
    Python script again will not result in duplicate servers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform有时可能会表现得有些情绪化；如果它失败了，你可能需要再次运行它。有时，我不得不运行Terraform三次以上才能完全正常工作。Terraform会存储每一个动作，所以请不要担心——再次运行Python脚本不会导致服务器重复创建。
- en: 'When running this command, you will be prompted to write `yes` at three different
    points of the process. The first time is to approve the building of the server
    with Terraform, the second time is to add the IP address of the server to the
    list of known hosts to approve the SSH connection, and the last time is to approve
    the destruction of the server. It usually makes sense to show the printouts in
    this book; however, the printout here is long and would probably take up multiple
    pages. Also, the printouts are obvious. Terraform openly states what is being
    built, the copying and building are also verbose, and the destruction of the server
    with Terraform is also printed out. It will be very clear what is going on when
    you run this build pipeline. You might also notice that there is a range of Terraform
    files that have been created. These files keep track of the state of our resources
    that have been built on the AWS platform. If you delete these state files, you
    have no way of knowing what is built, and duplicates will be spun up. It will
    also prevent Terraform from cleaning up. At the place where I work, at the time
    of writing this, we use Terraform to build massive data models for calculating
    the risk of financial loss over geographical locations. The data being processed
    can go over terabytes per chunk. We use Terraform to spin up a range of powerful
    computers, run data through it (which can take days), and then shut it down when
    it is finished. Multiple people need to monitor this process, so our Terraform
    state is housed in a `state.tf` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此命令时，你将在过程中的三个不同点被提示输入`yes`。第一次是为了批准使用Terraform构建服务器，第二次是为了将服务器的IP地址添加到已知主机列表以批准SSH连接，最后一次是为了批准服务器的销毁。通常来说，在这个书中展示打印输出是有意义的；然而，这里的打印输出很长，可能需要占用多页。此外，打印输出是显而易见的。Terraform明确说明了正在构建的内容，复制和构建过程也是详尽的，使用Terraform销毁服务器的过程也会打印出来。当你运行这个构建管道时，会发生什么将非常清楚。你也可能注意到创建了一系列Terraform文件。这些文件跟踪我们在AWS平台上构建的资源的状态。如果你删除这些状态文件，你就无法知道构建了什么，并且会创建重复的服务器。它还会阻止Terraform进行清理。在我工作的地方，在撰写本文时，我们使用Terraform构建用于计算地理区域财务损失风险的大规模数据模型。正在处理的数据可以超过每块数太字节。我们使用Terraform启动一系列强大的计算机，将数据通过它们运行（这可能需要几天时间），然后在完成时关闭它们。需要多个人监控这个过程，因此我们的Terraform状态存储在一个`state.tf`文件中：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It must be noted that your account needs to have access to the bucket defined.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你的账户需要有权访问定义的存储桶。
- en: 'Now, it is time to build our frontend application. Looking and what we have
    just done, all we need to do is add to the `/build/run_build.sh` file the steps
    to upload our frontend code to the build server and build the frontend application.
    At this point, you should be able to code this yourself. Right now, it would be
    a good use of your time to stop reading and attempt to build it. If you have attempted
    it yourself, it should look like the code shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候构建我们的前端应用程序了。看看我们刚刚所做的工作，我们所需做的只是将上传我们的前端代码到构建服务器并构建前端应用程序的步骤添加到 `/build/run_build.sh`
    文件中。在这个阶段，你应该能够自己编写这段代码。现在，停止阅读并尝试构建它将是一个很好的时间利用方式。如果你已经尝试过，它应该看起来像这里显示的代码：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we remove the node modules, copy the code to the server, install node,
    and then run the `install` command for our application. Now that our build pipeline
    is fully working, we can move on to wrapping our software in Docker so that we
    can package the software in Docker and deploy it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们移除了 node 模块，将代码复制到服务器上，安装 node，然后运行我们应用程序的 `install` 命令。现在，我们的构建管道完全工作后，我们可以继续将我们的软件包装在
    Docker 中，以便我们可以将软件打包并部署。
- en: Managing our software with Docker
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 管理我们的软件
- en: So far, we have been using Docker to manage our PostgreSQL and Redis databases.
    When it comes to running our frontend and Rust server, we have merely been running
    it directly on our local computer. However, when it comes to running our applications
    on remote servers, it is simpler and easier to distribute. Before we get on to
    deploying our Docker images on servers, we need to build and run them locally,
    which starts with writing our Docker image file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 Docker 来管理我们的 PostgreSQL 和 Redis 数据库。当涉及到运行我们的前端和 Rust 服务器时，我们只是在我们的本地计算机上直接运行它们。然而，当涉及到在远程服务器上运行我们的应用程序时，它更简单、更容易分发。在我们开始在服务器上部署我们的
    Docker 镜像之前，我们需要在本地构建和运行它们，这从编写我们的 Docker 镜像文件开始。
- en: Writing Docker image files
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Docker 镜像文件
- en: 'Before we proceed, it must be noted that the approach carried out here is the
    simplest, least optimized way to build a Rust server Docker image, because we
    are juggling a lot of new concepts. We cover an optimized way of building Rust
    server Docker images in [*Chapter 13*](B18722_13.xhtml#_idTextAnchor264), *Best
    Practices for a Clean Web App Repository*. When it comes to building a Docker
    image, we need a Dockerfile. This is where we define the steps needed to build
    our image. In our `web_app/Dockerfile` file, we basically borrow a base image
    and then run our commands on top of this image for our application to work. We
    can define the base image and the requirements to run our database interactions
    with the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，必须注意的是，这里执行的方法是构建 Rust 服务器 Docker 镜像的最简单、最不优化的方式，因为我们正在处理许多新概念。我们在 [*第
    13 章*](B18722_13.xhtml#_idTextAnchor264) 中介绍了构建 Rust 服务器 Docker 镜像的优化方法，*最佳实践：干净的
    Web 应用程序仓库*。当涉及到构建 Docker 镜像时，我们需要一个 Dockerfile。这是我们定义构建我们的镜像所需的步骤的地方。在我们的 `web_app/Dockerfile`
    文件中，我们基本上借用了一个基础镜像，然后在上面运行我们的命令，以便我们的应用程序能够工作。我们可以使用以下代码定义基础镜像和运行我们的数据库交互的要求：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here in our Docker build, we are starting with the official `rust` image. We
    then update `apt` so that we can download all the available packages. We then
    install `g++` and the `diesel` client so that our database operations will work.
    We then copy the code and config files from our Rust application and define our
    work directory with the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Docker 构建中，我们以官方的 `rust` 镜像开始。然后我们更新 `apt` 以便我们可以下载所有可用的包。然后我们安装 `g++`
    和 `diesel` 客户端，以便我们的数据库操作能够工作。然后我们将 Rust 应用程序的代码和配置文件复制过来，并使用以下代码定义我们的工作目录：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we have everything to build our Rust application with the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有以下代码来构建我们的 Rust 应用程序：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now our build is done, we move the static binary from the `target` directory
    into our home directory, remove excessive code such as the `target` and `src`
    directories, and allow the static binary file to be executable with the following
    code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了构建，我们将 `target` 目录中的静态二进制文件移动到我们的主目录，删除过量的代码，如 `target` 和 `src` 目录，并使用以下代码允许静态二进制文件可执行：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now everything is done, we can expose the port at which the web server will
    be running to make the server exposed by the container and execute the command
    that gets run when the Docker image is spun up with the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经完成，我们可以暴露运行 Web 服务器的端口，以便通过容器暴露服务器并执行以下代码启动 Docker 镜像时运行的命令：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that our Docker image file is written, we can move on to building Docker
    images.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了 Docker 镜像文件，我们可以继续构建 Docker 镜像。
- en: Building Docker images
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: 'Before we can run this, however, we need to remove our build script. There
    is only one thing left our Docker image build needs. When copying over the code
    into the Docker image, we know that the `target` directory has a lot of code and
    files that we do not need in our image. We can avoid copying over the `target`
    directory by having the following code in the `.``dockerignore` file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以运行这个之前，我们需要删除我们的构建脚本。我们的 Docker 镜像构建只剩下一件事。当我们把代码复制到 Docker 镜像中时，我们知道 `target`
    目录中有许多我们不需要在镜像中的代码和文件。我们可以通过在 `.dockerignore` 文件中添加以下代码来避免复制 `target` 目录：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we try to compile our application with the build script, Docker will just
    throw itself into an infinite file loop and then time out. This means that our
    `ALLOWED_VERSION` variable in our `main.rs` file takes the following form:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用构建脚本编译我们的应用程序，Docker 将将自己陷入无限文件循环，然后超时。这意味着我们的 `main.rs` 文件中的 `ALLOWED_VERSION`
    变量采用以下形式：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And we then must comment out our `build` dependency in our `Cargo.toml` file
    with the following code and remove the `build.rs` file entirely:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在 `Cargo.toml` 文件中取消注释我们的 `build` 依赖项，并使用以下代码，并完全删除 `build.rs` 文件：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are now ready to build our image; we navigate to where the Dockerfile is
    and run the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好构建我们的镜像；我们导航到 Dockerfile 所在的位置，并运行以下命令：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This command executes the build defined by the Dockerfile in the current directory.
    The image is tagged `rust_app`. We can list our images with the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令执行当前目录中 Dockerfile 定义的构建。镜像被标记为 `rust_app`。我们可以使用以下命令列出我们的镜像：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will give us the following printout:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can then test to see if our application is properly built; we just run the
    following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以测试我们的应用程序是否正确构建；我们只需运行以下命令：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This directly runs our Rust app. Our application should crash instantly with
    the following error:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接运行我们的 Rust 应用程序。我们的应用程序应该立即崩溃，并显示以下错误：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can see that the error is not down to our build, but a connection issue with
    Redis from our counter file. This is reassuring, and it will work when we run
    our Rust application with our two databases.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，错误不是来自我们的构建，而是来自计数器文件与 Redis 的连接问题。这令人放心，并且当我们在两个数据库上运行我们的 Rust 应用程序时，它将工作。
- en: There is an approach in Docker where you can do multi-layered builds. This is
    where we start off with the `rust` base image, build our application, and then
    move our build into another Docker image with no dependencies. The result is that
    our server image is usually merely 100 MB as opposed to multiple GB. However,
    our application has a lot of dependencies, and this multi-layered build approach
    will result in multiple driver errors. We explore building tiny images in [*Chapter
    13*](B18722_13.xhtml#_idTextAnchor264), *Best Practices for a Clean Web* *App
    Repository*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 中有一个多层级构建的方法。这就是我们从 `rust` 基础镜像开始，构建我们的应用程序，然后将构建移动到另一个没有依赖项的 Docker
    镜像中。结果是我们的服务器镜像通常只有 100 MB，而不是多个 GB。然而，我们的应用程序有很多依赖项，这种多层级构建方法会导致多个驱动错误。我们在 [*第
    13 章*](B18722_13.xhtml#_idTextAnchor264) 中探讨了构建小型镜像的最佳实践，*清洁 Web 应用程序仓库*。
- en: Building an EC2 build server using Terraform
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Terraform 构建 EC2 构建服务器
- en: 'We have now built our Rust Docker image locally. We can now build it on our
    build server. Before we do this, we are going to have to increase the size of
    the hard drive on our builder server; otherwise, the image will refuse to build
    due to lack of space. This can be done in our `/build/main.tf` file by adding
    a root block device, as seen in the following code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在本地构建了我们的 Rust Docker 镜像。我们可以在构建服务器上构建它。在我们这样做之前，我们必须增加构建服务器硬盘的大小；否则，镜像将因为空间不足而拒绝构建。这可以通过在我们的
    `/build/main.tf` 文件中添加一个根块设备来完成，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`gp2` is the version of SSD that AWS supports we are using. `150` is the number
    of GB that we are connecting to the server. This will be enough memory to build
    our Docker images, leaving us only to build the pipeline that constructs our Docker
    images.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`gp2` 是 AWS 支持的 SSD 版本，我们正在使用。`150` 是我们连接到服务器的 GB 数。这将足够构建我们的 Docker 镜像，剩下的只是构建构建我们的
    Docker 镜像的管道。'
- en: Orchestrating builds with Bash
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Bash 进行构建编排
- en: 'At this point, we are also going to optimize our build Bash script in our `/build/run_build.sh`
    file. First, we do not remove the `target` directory; instead, we are selective
    with what we upload onto our server with the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们还将优化我们的 `/build/run_build.sh` 文件中的构建 Bash 脚本。首先，我们不删除 `target` 目录；相反，我们使用以下代码有选择性地上传到我们的服务器：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we can see that we make the `web_app` directory, and then upload the
    files and directories that we need to build our Rust Docker image. We then need
    to connect to the server to install Rust with the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们创建了 `web_app` 目录，然后上传了构建 Rust Docker 镜像所需的文件和目录。然后我们需要使用以下代码连接到服务器来安装
    Rust：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, we can see that we install Rust before we block the script until the
    server is ready with everything installed. This means that we are running the
    installation of Rust at the same time the rest of the server is being built, saving
    time. We then exit the connection to our build server. Finally, we connect to
    the server again and build our Docker image with the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们在安装 Rust 之前阻止脚本直到服务器准备好所有安装。这意味着我们在构建服务器其余部分的同时运行 Rust 的安装，从而节省时间。然后我们退出与构建服务器的连接。最后，我们再次连接到服务器，并使用以下代码构建
    Docker 镜像：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have then built the pipeline that builds our Rust Docker image on our build
    server. This seems like a lot of steps, and you would be right. We can build our
    image locally with a different target operating system and chip architecture.
    Exploring it here would disjoint the flow of what we are trying to achieve, but
    further information on compiling with different targets will be provided in the
    *Further* *reading* section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的构建服务器上构建了构建 Rust Docker 镜像的管道。这看起来像有很多步骤，你是对的。我们可以使用不同的目标操作系统和芯片架构在本地构建我们的镜像。在这里探索它将打断我们试图实现的目标的流程，但有关使用不同目标编译的更多信息将在
    *进一步阅读* 部分提供。
- en: Writing a Docker image file for the React frontend
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 React 前端编写 Docker 镜像文件
- en: 'For now, we are going to package our frontend application in Docker. In our
    `front_end/Dockerfile` file, we inherit the node base image, copy the code, and
    define the working directory with the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将使用 Docker 打包我们的前端应用程序。在我们的 `front_end/Dockerfile` 文件中，我们继承 node 基础镜像，复制代码，并使用以下代码定义工作目录：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We then install a `serve` package to serve the web app build files, the modules
    needed to build the application, and build the React application with the following
    code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们安装一个 `serve` 包来提供 web 应用构建文件、构建应用程序所需的模块，并使用以下代码构建 React 应用程序：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then expose the port and server to our application with the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码公开端口和服务器到我们的应用程序：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can then build our Docker image with the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令构建我们的 Docker 镜像：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can then run the recently built image with the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令运行最近构建的镜像：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This routes the container’s external port (`80`) to the locally exposed port
    `4000`. When our image is running, we get the following printout:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将容器的外部端口 (`80`) 路由到本地暴露的端口 `4000`。当我们的镜像运行时，我们得到以下输出：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This shows that our image is running in a container. We will be able to access
    our frontend container by merely accessing our localhost, which is port `80`,
    as seen in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的镜像正在容器中运行。我们可以通过访问本地主机来访问我们的前端容器，本地主机端口为 `80`，如下截图所示：
- en: '![Figure 10.12 – Accessing our frontend container using localhost](img/Figure_10.12_B18722.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 使用本地主机访问我们的前端容器](img/Figure_10.12_B18722.jpg)'
- en: Figure 10.12 – Accessing our frontend container using localhost
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 使用本地主机访问我们的前端容器
- en: We will not be able to do anything with it, however, because our Rust server
    is not running. We can now lift the steps that we have carried out to build our
    frontend into our `/build/run_build.sh` script to have our build pipeline construct
    our frontend image as well. This is a good opportunity for you to try to add the
    step yourself. We will have to install node and then carry out the frontend build
    steps on the build server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法对其进行任何操作，因为我们的 Rust 服务器尚未运行。现在，我们可以将构建前端所执行的步骤提升到我们的 `/build/run_build.sh`
    脚本中，以便我们的构建管道构建前端镜像。这是一个尝试自己添加步骤的好机会。我们将在构建服务器上安装 node，然后执行前端构建步骤。
- en: 'If you have had an attempt at incorporating our React build in our pipeline,
    it should look like the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在我们的管道中集成我们的 React 构建，它应该看起来像以下代码：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can be more optimal in our implementation; however, the preceding code is
    the simplest application. First, we copy over the code we need to the build server.
    We then connect to our build server to install node. After installing node, we
    connect to the server again to move into the React application directory and build
    our Docker image.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的实现中更加优化；然而，前面的代码是最简单的应用。首先，我们将需要的代码复制到构建服务器上。然后我们连接到构建服务器来安装node。安装node后，我们再次连接到服务器，进入React应用程序目录并构建我们的Docker镜像。
- en: Our build pipeline is now working. Just think of what we have achieved here—we
    have built a pipeline that constructs a build server; we then copied our code
    onto the build server, constructed Docker images, and then destroyed the server
    after the build was done. Even though this pipeline is not perfect, we have explored
    some powerful tools that will enable you to automate tasks and lift a lot of the
    code that we have covered in this subsection in other CI pipeline tools. However,
    right now, we are just building the Docker images and then destroying them with
    the server. In the next section, we will deploy our images on **Docker Hub**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建设管道现在正在工作。想想我们在这里取得的成就——我们构建了一个管道，它构建了一个构建服务器；然后我们将我们的代码复制到构建服务器上，构建了Docker镜像，然后在构建完成后销毁了服务器。尽管这个流水线并不完美，但我们已经探索了一些强大的工具，这些工具将使您能够自动化任务，并减轻我们在本节中涵盖的其他CI流水线工具中的许多代码。然而，现在我们只是在构建Docker镜像，然后与服务器一起销毁它们。在下一节中，我们将部署我们的镜像到**Docker
    Hub**。
- en: Deploying images onto Docker Hub
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将镜像部署到Docker Hub
- en: 'Before we can pull our images from Docker Hub, we will have to push our images
    to Docker Hub. Before we can push our images to Docker Hub, we will have to create
    a Docker Hub repo. Registering our image on Docker Hub is straightforward. After
    logging in, we click on the **Create Repository** button in the top-right corner,
    as shown in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够从Docker Hub拉取我们的镜像之前，我们必须先将我们的镜像推送到Docker Hub。在我们能够将我们的镜像推送到Docker Hub之前，我们必须创建一个Docker
    Hub仓库。在Docker Hub上注册我们的镜像非常简单。登录后，我们点击右上角的**创建仓库**按钮，如图所示：
- en: '![Figure 10.13 – Creating a new repository on Docker Hub](img/Figure_10.13_B18722.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 在Docker Hub上创建新的仓库](img/Figure_10.13_B18722.jpg)'
- en: Figure 10.13 – Creating a new repository on Docker Hub
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 在Docker Hub上创建新的仓库
- en: 'Once we have clicked on this, we define the repository with the following configuration:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击了它，我们使用以下配置定义仓库：
- en: '![Figure 10.14 – Defining a new Docker repository](img/Figure_10.14_B18722.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 定义新的Docker仓库](img/Figure_10.14_B18722.jpg)'
- en: Figure 10.14 – Defining a new Docker repository
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 定义新的Docker仓库
- en: We can see that there is an option for connecting our repository with GitHub
    by clicking on the *GitHub* button seen in the preceding screenshot. The **Connected**
    GitHub status in the preceding screenshot simply means that my GitHub is connected
    to my Docker Hub account. This means that every time a successful pull request
    gets completed, the image is rebuilt with the code, and then it is sent to the
    repository. This can be helpful if you are building a fully automated pipeline.
    However, for this book, we will not connect our GitHub repository. We will push
    it onto our build server. You will also need to create a Docker Hub repository
    for our frontend if you are deploying the React application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，有一个选项可以通过点击前面截图中的*GitHub*按钮将我们的仓库与GitHub连接起来。前面截图中的**已连接**GitHub状态简单意味着我的GitHub已经连接到我的Docker
    Hub账户。这意味着每次成功的拉取请求完成后，镜像都会用代码重新构建，然后发送到仓库。如果你正在构建一个完全自动化的流水线，这可能会很有帮助。然而，对于这本书，我们不会连接我们的GitHub仓库。我们将将其推送到我们的构建服务器。如果你正在部署React应用程序，你还需要为我们的前端创建一个Docker
    Hub仓库。
- en: 'Now that we have defined our Docker Hub repositories, we need to add a Docker
    login in our build pipeline. This means that we must pass our Docker Hub password
    and username into our Python build script. Our Python script can then pass the
    Docker Hub credentials into the build Bash script. This build Bash script will
    then log in to Docker on the build server so that we can push our images to our
    Docker Hub. In our `/build/run_build.py` file, we define the arguments passed
    into the Python script with the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的Docker Hub仓库，我们需要在我们的构建管道中添加一个Docker登录。这意味着我们必须将我们的Docker Hub密码和用户名传递到我们的Python构建脚本中。然后我们的Python脚本可以将Docker
    Hub凭证传递到构建Bash脚本中。这个构建Bash脚本将登录到构建服务器上的Docker，以便我们可以将我们的镜像推送到我们的Docker Hub。在我们的`/build/run_build.py`文件中，我们使用以下代码定义传递给Python脚本的参数：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can see that we have set `required` to `True`, which means that the Python
    script will not run unless both parameters are supplied. If we supply a `-h` parameter
    in the Python script, the parameters that we have defined in the preceding code
    will be printed out with help information. Now that we have ingested the Docker
    credentials, we can then pass them into our build Bash script in the `/build/run_build.py`
    file with the following adaptation to our code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经将`required`设置为`True`，这意味着除非提供这两个参数，否则Python脚本不会运行。如果我们向Python脚本提供一个`-h`参数，那么在前面代码中定义的参数将带有帮助信息打印出来。现在我们已经摄入了Docker凭证，我们可以在`/build/run_build.py`文件中将它们传递到我们的构建Bash脚本中，以下是对我们代码的以下修改：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, we can see that the Docker username is accessed using the `args.u` attribute
    and the Docker password is accessed using the `args.p` attribute. Now that we
    are passing Docker credentials into our build Bash script, we need to use these
    credentials to push our images. In our `/build/run_build.sh` file, we should log
    in after Docker is installed on our build server with the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Docker用户名是通过`args.u`属性访问的，而Docker密码是通过`args.p`属性访问的。既然我们已经将Docker凭证传递到我们的构建Bash脚本中，我们需要使用这些凭证来推送我们的镜像。在我们的`/build/run_build.sh`文件中，我们应该在Docker安装在我们的构建服务器上后，使用以下代码进行登录：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code, we use `–password-stdin` to pipe our password into the
    Docker login. `stdin` ensures that the password is not stored in the logs, making
    it a little bit more secure. We can then build, tag, and then push our Rust application
    with the update in the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`–password-stdin`将密码管道输入到Docker登录中。`stdin`确保密码不会存储在日志中，这使得它稍微安全一些。然后我们可以使用以下代码构建、标记并推送我们的Rust应用程序的更新：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we build the Rust image as we always do. We then tag the Rust app image
    as the latest release and then push it to the Docker repository. We also must
    push our frontend application to Docker Hub. At this point, this is a good chance
    for you to write the code that pushes the frontend image. If you did attempt to
    push the frontend image, it should look like the following code snippet:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们像往常一样构建Rust镜像。然后我们将Rust应用程序镜像标记为最新发布版本，并将其推送到Docker仓库。我们还必须将我们的前端应用程序推送到Docker
    Hub。在这个时候，这是一个写代码推送前端镜像的好机会。如果你尝试推送前端镜像，它应该看起来像以下代码片段：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We have now coded all that we need to build both of our images and push them
    to our Docker repositories. We can run our Python build script with the following
    command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经编写了所有必要的代码来构建两个镜像并将它们推送到我们的Docker仓库。我们可以使用以下命令运行我们的Python构建脚本：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Again, the printout is lengthy, but we can check our Docker Hub repository
    to see if our image was pushed. As we can see in the following screenshot, the
    Docker Hub repository states when the image has been pushed:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，打印输出很长，但我们可以检查我们的Docker Hub仓库以查看我们的镜像是否已推送。正如以下屏幕截图所示，Docker Hub仓库会显示镜像何时被推送：
- en: '![Figure 10.15 – View of pushed Docker repository](img/Figure_10.15_B18722.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 推送Docker仓库的视图](img/Figure_10.15_B18722.jpg)'
- en: Figure 10.15 – View of pushed Docker repository
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 推送Docker仓库的视图
- en: We now have our images pushed onto our Docker Hub repositories! This means that
    we can pull them onto any computer that we need, just as we did when pulling the
    PostgreSQL image in the `docker-compose` file. We should now pull our images onto
    a server so that other people can access and use our application. In the next
    section, we will deploy our application for external use.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将镜像推送到我们的Docker Hub仓库！这意味着我们可以将它们拉到任何我们需要使用的计算机上，就像我们在`docker-compose`文件中拉取PostgreSQL镜像时做的那样。我们现在应该将我们的镜像拉到服务器上，以便其他人可以访问和使用我们的应用程序。在下一节中，我们将部署我们的应用程序以供外部使用。
- en: Deploying our application on AWS
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS上部署我们的应用程序
- en: Even though we have packaged our Rust application in Docker, we have not run
    our Rust application in a Docker container. Before we run our Rust application
    on a server on AWS, we should run our Rust application locally. This will help
    us understand how a simple deployment works without having to build servers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经将Rust应用程序打包到Docker中，但我们还没有在Docker容器中运行我们的Rust应用程序。在我们将Rust应用程序运行在AWS服务器上之前，我们应该在本地运行我们的Rust应用程序。这将帮助我们了解简单的部署是如何工作的，而无需构建服务器。
- en: Running our application locally
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地运行我们的应用程序
- en: 'When it comes to running our application locally, we will be using `docker-compose`
    with the following layout:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在本地运行我们的应用程序时，我们将使用以下布局的`docker-compose`：
- en: '![Figure 10.16 – Structure for local deployment](img/Figure_10.16_B18722.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 本地部署结构](img/Figure_10.16_B18722.jpg)'
- en: Figure 10.16 – Structure for local deployment
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 本地部署结构
- en: 'Here, we can see that the NGINX container takes in traffic from outside of
    the `docker-compose` network and directs the traffic to the appropriate container.
    Now that we understand our structure, we can define our `docker-compose` file.
    First, we need to make a directory called `deployment` next to our `build`, `front_end`,
    and `web_app` directories. Our general layout for our `docker-compose.yml` file
    in our `deployment` directory takes the following form:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到NGINX容器从`docker-compose`网络外部接收流量，并将流量导向适当的容器。现在我们理解了我们的结构，我们可以定义我们的`docker-compose`文件。首先，我们需要在`build`、`front_end`和`web_app`目录旁边创建一个名为`deployment`的目录。在我们的`deployment`目录中，我们的`docker-compose.yml`文件的一般布局如下所示：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can start with our NGINX service. Now that we know the outside port is `80`,
    it makes sense that our NGINX container listens to the outside port of `80` with
    the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从NGINX服务开始。既然我们知道外部端口是`80`，那么我们的NGINX容器监听外部端口`80`是有意义的，以下代码实现了这一点：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can see that we get the latest NGINX image. We also have links to the `front_end`
    and `rust_app` containers because we will be passing HTTP requests to these containers.
    It also must be noted that we have a volume. This is where we share a volume outside
    of the container with a directory inside the container. So, this volume definition
    means that our `deploy/nginx_config.conf` file can be accessed in the NGINX container
    in the `etc/nginx/nginx.conf` directory. With this volume, we can configure NGINX
    routing rules in our `deploy/nginx_config.conf` file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们获取了最新的NGINX镜像。我们还链接到`front_end`和`rust_app`容器，因为我们将会将这些HTTP请求转发到这些容器。还必须注意的是，我们有一个卷。这是在容器外部与容器内部的目录共享卷的地方。所以，这个卷定义意味着我们的`deploy/nginx_config.conf`文件可以在NGINX容器的`etc/nginx/nginx.conf`目录中访问。有了这个卷，我们可以在`deploy/nginx_config.conf`文件中配置NGINX路由规则。
- en: 'First, we set the number of worker processes to `auto`. We can manually define
    the number of worker processes if needed. `auto` detects the number of CPU cores
    available and sets the number to that with the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将工作进程的数量设置为`auto`。如果需要，我们可以手动定义工作进程的数量。`auto`会检测可用的CPU核心数量，并将数量设置为该值，以下代码实现了这一点：
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `error_log` directive defines the logging to a particular file. We not
    only define the file, but we also state the minimum level needed to write to the
    log file, which is `warning`. By default, the logging level needed to write to
    the file is `error`. We can now move on to defining contexts in our `deploy/nginx_config.conf`
    file. In the `events` context, we define the maximum number of connections that
    a worker can entertain at a time. This is achieved with the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`error_log`指令定义了日志记录到特定的文件。我们不仅定义了文件，还声明了写入日志文件所需的最小级别，即`warning`。默认情况下，写入文件所需的日志级别是`error`。现在我们可以继续在`deploy/nginx_config.conf`文件中定义上下文。在`events`上下文中，我们定义了工作进程一次可以处理的连接的最大数量。这是通过以下代码实现的：'
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The number of workers that we have defined is the default number that NGINX
    sets. Now that this is done, we can move on to our `http` context. Here, we define
    the `server` context. Inside this, we instruct the server to listen to port `80`,
    which is the port that listens to outside traffic, with the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的工作进程数量是NGINX设置的默认数量。现在这已经完成，我们可以继续到我们的`http`上下文。在这里，我们定义了`server`上下文。在这个上下文中，我们指示服务器监听端口`80`，这是监听外部流量的端口，以下代码实现了这一点：
- en: '[PRE61]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we can see that if the URL has `/v1/` at the start of the endpoint, we
    then pass it through the Rust server. It must be noted that we pass `v1` forward
    to the Rust server. If we did not pass `v1` forward to the Rust server, `v1` will
    be missing from the URL when it hits the Rust server. If the URL does not contain
    `v1` in the URL, then we forward it to our `front_end` container. Our NGINX container
    is now ready to manage traffic in our `docker-compose` system. Before we move
    on to our frontend and backend services, we need to define the Redis and PostgreSQL
    databases. There is nothing new here, so at this point, you can try to define
    them yourself. If you have, then your code should look like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，如果端点的URL以`/v1/`开头，我们就将其通过Rust服务器转发。必须注意的是，我们将`v1`传递给Rust服务器。如果我们没有将`v1`传递给Rust服务器，当它到达Rust服务器时，URL中会缺少`v1`。如果URL中不包含`v1`，那么我们就将其转发到我们的`front_end`容器。我们的NGINX容器现在已准备好管理我们的`docker-compose`系统中的流量。在我们继续到前端和后端服务之前，我们需要定义Redis和PostgreSQL数据库。这里没有什么新的，所以在这个时候，你可以尝试自己定义它们。如果你已经定义了，那么你的代码应该看起来像这样：
- en: '[PRE62]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding database definitions are the same as what we have used before
    in local development. With these databases, we can define our Rust application
    with the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 之前在本地开发中使用的数据库定义与此相同。有了这些数据库，我们可以使用以下代码定义我们的 Rust 应用程序：
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we can see that we are not defining an image. Instead of declaring the
    image, we point to a build. The `build` tag is where we point to a `deploy/rust_config.yml`
    file takes the following form:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们没有定义一个镜像。而不是声明镜像，我们指向一个构建。`build` 标签是我们指向 `deploy/rust_config.yml`
    文件的地方，其形式如下：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, we can see that we reference the name of the service defined in the `docker-compose`
    system instead of the URL. We also must change the address for our Rust application
    in our `web_app/src/main.rs` file to zeros, as seen here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们引用的是 `docker-compose` 系统中定义的服务名称，而不是 URL。我们还必须在 `web_app/src/main.rs`
    文件中将我们的 Rust 应用程序的地址更改为零，如下所示：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We then must remove our config file in our Docker build in our `web_app/Dockerfile`
    file with the following line of code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在我们的 `web_app/Dockerfile` 文件中删除 Docker 构建中的配置文件，如下所示：
- en: '[PRE66]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we do not do this, then our Rust application will not connect with the NGINX
    container. Now everything is defined for our Rust server, we can move on to defining
    the frontend application in our `docker-compose.yml` file with the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不这样做，那么我们的 Rust 应用程序将无法与 NGINX 容器连接。现在，我们的 Rust 服务器已经定义完毕，我们可以继续在 `docker-compose.yml`
    文件中定义前端应用程序，如下所示：
- en: '[PRE67]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here, we see that we reference our image in Docker Hub and expose the ports.
    Now that our local system is defined, we can run our system and interact with
    it by running the following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们引用了 Docker Hub 中的镜像并公开了端口。现在，我们的本地系统已经定义，我们可以通过运行以下命令来运行我们的系统并与之交互：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Everything will build and run automatically. Before we can interact with our
    system, we need to run our `diesel` migrations in our Rust application build with
    the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的构建和运行都将自动完成。在我们能够与我们的系统交互之前，我们需要在我们的 Rust 应用程序构建中运行以下命令的 `diesel` 迁移：
- en: '[PRE69]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We then need to create a user with the following `curl` command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用以下 `curl` 命令创建一个用户：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We now have everything in place to interact with our application. We can see
    that localhost with no reference to ports works with the following screenshot:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好与我们的应用程序进行交互。我们可以看到，没有端口引用的 localhost 在以下屏幕截图中的工作情况：
- en: '![Figure 10.17 – Accessing our docker-compose system through the browser](img/Figure_10.17_B18722.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – 通过浏览器访问我们的 docker-compose 系统](img/Figure_10.17_B18722.jpg)'
- en: Figure 10.17 – Accessing our docker-compose system through the browser
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – 通过浏览器访问我们的 docker-compose 系统
- en: If your NGINX is working, you should be able to log in and interact with the
    to-do application as before. We are now able to deploy our system on AWS so that
    other people can access and use our to-do application in the next section.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 NGINX 正在运行，你应该能够登录并像以前一样与待办事项应用程序进行交互。我们现在能够将我们的系统部署到 AWS，以便在下一节中其他人可以访问和使用我们的待办事项应用程序。
- en: Running our application on AWS
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 AWS 上运行我们的应用程序
- en: 'We can deploy our application on AWS by carrying out the following steps:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下步骤在 AWS 上部署我们的应用程序：
- en: Building a server
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建服务器
- en: Running our `docker-compose` system on that server
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个服务器上运行我们的 `docker-compose` 系统
- en: Running database migrations on that server
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个服务器上运行数据库迁移
- en: Creating a user
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户
- en: 'Once we have carried out those steps, we will be able to access the application
    on the remote server. However, before we do this, we are going to have to alter
    the React application. Right now, our React application makes API calls to the
    localhost via `127.0.0.1`. When we are using a remote server, this will not work
    as we will have to make calls to the server to which we have deployed our application.
    To do this, we can extract where our API calls are made in the React application
    and update the root of the URL for the API call with the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这些步骤，我们就能访问远程服务器上的应用程序。然而，在我们这样做之前，我们必须修改 React 应用程序。目前，我们的 React 应用程序通过
    `127.0.0.1` 向 localhost 发起 API 调用。当我们使用远程服务器时，这将不起作用，因为我们必须调用我们部署应用程序的服务器。为此，我们可以在
    React 应用程序中提取 API 调用的位置，并使用以下代码更新 API 调用的 URL 根：
- en: '[PRE71]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'What is happening here is that `window.location.href` returns the current location,
    which will be the IP of the server our application is deployed on, or localhost
    if we are developing it locally on our computer. The following files have API
    calls that need to be updated:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是 `window.location.href` 返回当前位置，这将是我们应用程序部署在的服务器 IP 地址，或者如果我们是在本地计算机上开发，则是
    localhost。以下文件有需要更新的 API 调用：
- en: '`src/components/LoginForm.js`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/components/LoginForm.js`'
- en: '`src/components/CreateToDoitem.js`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/components/CreateToDoitem.js`'
- en: '`src/components/ToDoitem.js`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/components/ToDoitem.js`'
- en: '`src/App.js`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/App.js`'
- en: 'Once we have updated these files, we will be able to run another build in the
    `build` directory by running the following command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 更新这些文件后，我们可以在 `build` 目录下通过运行以下命令来运行另一个构建：
- en: '[PRE72]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once our build has been done, both our images will be updated. We can now move
    to our `deployment` directory and flesh it out with the following files:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的构建完成，我们的两个镜像都将更新。现在我们可以移动到我们的 `deployment` 目录，并使用以下文件来完善它：
- en: '`main.tf`: This should be the same as the `main.tf` file in the `build` directory,
    except for the server having a different tag'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.tf`：这应该与 `build` 目录中的 `main.tf` 文件相同，除了服务器有一个不同的标签'
- en: '`run_build.py`: This should be the same as the `run_build.py` file in the `build`
    directory, except for the *destroy server* process at the end of the `run_build.py`
    script'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_build.py`：这应该与 `build` 目录中的 `run_build.py` 文件相同，除了 `run_build.py` 脚本末尾的
    *销毁服务器* 过程'
- en: '`server_build.sh`: This should be the same as the `server_build.sh` script
    in the `build` directory as we want our server to have the same environment as
    when our images were built'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server_build.sh`：这应该与 `build` 目录中的 `server_build.sh` 脚本相同，因为我们希望我们的服务器拥有与构建镜像时相同的环境'
- en: '`deployment-compose.yml`: This should be the same as the `docker-compose.yml`
    file in the `deployment` directory, except that `rust_app` service has an image
    tag instead of a build tag and the image tag should have the image of `maxwellflitton/to_do_actix:latest`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deployment-compose.yml`：这应该与 `deployment` 目录中的 `docker-compose.yml` 文件相同，除了
    `rust_app` 服务有一个镜像标签而不是构建标签，并且镜像标签应该是 `maxwellflitton/to_do_actix:latest`'
- en: '`.env`: This should be the same as the `.env` file in the `web_app` directory,
    and we will need it to perform database migrations'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.env`：这应该与 `web_app` 目录中的 `.env` 文件相同，我们需要它来执行数据库迁移'
- en: 'We are now ready to code our `run_build.sh` file that will enable us to deploy
    our application, run migrations, and create a user. First, we start off with some
    standard boilerplate code to ensure that we are in the right directory, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写 `run_build.sh` 文件，这将使我们能够部署我们的应用程序，运行迁移，并创建一个用户。首先，我们从一些标准的样板代码开始，以确保我们处于正确的目录，如下所示：
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We then copy the files needed to spin up our `docker-compose` system and perform
    database migrations with the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们复制启动我们的 `docker-compose` 系统所需的文件，并使用以下代码执行数据库迁移：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'None of this should be a surprise as we needed all the preceding files to run
    our `docker-compose` system. We then install Rust and wait for the server build
    to be done with the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不应该令人惊讶，因为我们需要所有前面的文件来运行我们的 `docker-compose` 系统。然后我们安装 Rust 并等待服务器构建完成，使用以下代码：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Again, this is nothing new that we have not seen. We then install the `diesel`
    client with the following code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这并不是我们没有见过的新的东西。然后我们使用以下代码安装 `diesel` 客户端：
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We then log in to Docker, spin up our `docker-compose` system, run our migrations,
    and then make a user with the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们登录到 Docker，启动我们的 `docker-compose` 系统，运行我们的迁移，然后使用以下代码创建一个用户：
- en: '[PRE77]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'With this, our system is deployed! We will be able to access our application
    on our server by putting the IP of the server that is in the `output.json` file
    into the browser. We will be able to log in and use our to-do application just
    like when we were running our system on our local computer, as seen on in the
    following screenshot:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的系统就部署完成了！我们可以通过将 `output.json` 文件中的服务器 IP 地址放入浏览器来访问我们的应用程序。我们可以登录并使用我们的待办事项应用程序，就像我们在本地计算机上运行系统时一样，如下面的截图所示：
- en: '![Figure 10.18 – Our application on our deployment server](img/Figure_10.18_B18722.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – 我们在部署服务器上的应用程序](img/Figure_10.18_B18722.jpg)'
- en: Figure 10.18 – Our application on our deployment server
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – 我们在部署服务器上的应用程序
- en: As we can see, the connection is not secure and our browser is giving us a warning
    because we are not implementing the HTTPS protocol. This is because our connection
    is not encrypted. We will cover how to encrypt our connection in the next chapter.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，连接不安全，我们的浏览器正在给我们发出警告，因为我们没有实现HTTPS协议。这是因为我们的连接未加密。我们将在下一章中介绍如何加密我们的连接。
- en: Writing our application build script
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的应用程序构建脚本
- en: Right now, our application is running a database locally on the EC2 instance.
    This has a few problems. Firstly, it means that the EC2 is stateful. If we tear
    down the instance, we will lose all our data.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序在EC2实例上本地运行数据库。这有几个问题。首先，这意味着EC2是状态化的。如果我们拆毁实例，我们将丢失所有数据。
- en: 'Secondly, if we wipe the containers on the instance, we could also lose all
    our data. Data vulnerability is not the only issue here. Let’s say that our traffic
    drastically increases, and we need more computing instances to manage it. This
    can be done by using NGINX as a load balancer between two instances, as shown
    in the following diagram:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果我们擦除实例上的容器，我们可能会丢失所有数据。数据脆弱性并不是这里唯一的问题。假设我们的流量急剧增加，我们需要更多的计算实例来管理它。这可以通过使用NGINX作为两个实例之间的负载均衡器来实现，如下面的图所示：
- en: '![Figure 10.19 – Doubling our EC2 instances for our system](img/Figure_10.19_B18722.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图10.19 – 为我们的系统加倍EC2实例](img/Figure_10.19_B18722.jpg)'
- en: Figure 10.19 – Doubling our EC2 instances for our system
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 – 为我们的系统加倍EC2实例
- en: As you can see, the problem here is accessing random data. If user one creates
    an item, and this request hits the instance on the left, it is stored in the database
    on the left. However, user one can then make a `GET` request, which hits the instance
    on the right side. The second request will not be able to access the item that
    was created in the first request. The user would be accessing random states depending
    on which instance the request hit.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里的问题是访问随机数据。如果用户一创建了一个项目，并且这个请求击中了左侧的实例，它将存储在左侧的数据库中。然而，用户一可以随后发起一个`GET`请求，这个请求击中了右侧的实例。第二个请求将无法访问第一个请求中创建的项目。用户将根据请求击中的实例访问随机状态。
- en: 'This can be solved by deleting the database from our `docker-compose` file
    and creating a database outside it, as shown in this diagram:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过从我们的`docker-compose`文件中删除数据库并在其外部创建数据库来解决，如下面的图所示：
- en: '![Figure 10.20 – Our new improved system](img/Figure_10.20_B18722.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图10.20 – 我们的新改进系统](img/Figure_10.20_B18722.jpg)'
- en: Figure 10.20 – Our new improved system
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 – 我们的新改进系统
- en: Now, we have a single point of truth for our data, and our EC2 instances are
    stateless, meaning we have the freedom to create and delete instances as and when
    we need to.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个单一的数据真相，我们的EC2实例是无状态的，这意味着我们有自由根据需要创建和删除实例。
- en: 'When it comes to adding an AWS database to our deployment, we are going to
    have to build our database in Terraform, and then pass the information about the
    constructed database to our `deployment/.env` file for database migrations and
    our `deployment/rust_config.yml` file for our Rust server to access. First, we
    must add the database definition to our `deployment/main.tf` file with the following
    code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将AWS数据库添加到我们的部署中时，我们必须在Terraform中构建我们的数据库，然后将有关构建的数据库的信息传递到我们的`deployment/.env`文件以进行数据库迁移，以及传递到我们的`deployment/rust_config.yml`文件以供我们的Rust服务器访问。首先，我们必须将数据库定义添加到我们的`deployment/main.tf`文件中，如下面的代码所示：
- en: '[PRE78]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The fields defined in the preceding code are straightforward apart from the
    `allocated_storage` field, which is the number of GB allocated to the database.
    We can also see that we use variables with the `var` variable. This means that
    we must pass a password and username into our Terraform build when running. We
    need to define our input variables in the `deployment/variables.tf` file with
    the following code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中定义的字段很简单，除了`allocated_storage`字段，这是分配给数据库的GB数。我们还可以看到我们使用了带有`var`变量的变量。这意味着我们必须在运行Terraform构建时传递密码和用户名。我们需要在`deployment/variables.tf`文件中定义我们的输入变量，如下面的代码所示：
- en: '[PRE79]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'These variables have defaults, so we do not need to pass in a variable. However,
    if we want to pass in a variable, we can do this with the following layout:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量有默认值，因此我们不需要传递变量。但是，如果我们想传递变量，我们可以使用以下布局：
- en: '[PRE80]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We now must pass these parameters into the needed files and the Terraform build.
    This is where Python starts to shine. We will be reading and writing YAML files,
    so we will have to install the YAML Python package with the following command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将这些参数传递到所需的文件和Terraform构建中。这正是Python开始发光的地方。我们将读取和写入YAML文件，因此我们必须使用以下命令安装YAML
    Python包：
- en: '[PRE81]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We then import this package in our `deployment/run_build.py` file at the top
    of the script with the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在脚本的顶部导入这个包到我们的`deployment/run_build.py`文件中，使用以下代码：
- en: '[PRE82]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We then load database parameters from a JSON file called `database.json` and
    create our `vars` command string with the following code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从名为`database.json`的JSON文件中加载数据库参数，并使用以下代码创建我们的`vars`命令字符串：
- en: '[PRE83]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You can come up with any parameters you want for your `deployment/database.json`
    file; I have recently been playing with GitHub Copilot, which is an AI pair programmer
    that auto-fills code, and this gave me the following parameters:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为您的`deployment/database.json`文件制定任何所需的参数；我最近一直在尝试GitHub Copilot，这是一个自动填充代码的AI配对程序员，这给了我以下参数：
- en: '[PRE84]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'I do not know who `Santiago` is, but the Copilot AI clearly thinks that `Santiago`
    is the right user, so I am going to use it. Going back to our `deployment/run_build.py`
    file, we must pass our parameters to the Terraform `apply` command by updating
    the following code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道谁是`Santiago`，但Copilot AI显然认为`Santiago`是正确的用户，所以我将使用它。回到我们的`deployment/run_build.py`文件，我们必须通过更新以下代码将我们的参数传递给Terraform的`apply`命令：
- en: '[PRE85]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'After the processes that run the Terraform build have finished, we then store
    the output of that build in a JSON file. We then create our own database URL and
    write this URL to a text file with the following code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Terraform构建的进程完成后，我们将该构建的输出存储在一个JSON文件中。然后我们创建自己的数据库URL，并使用以下代码将此URL写入一个文本文件：
- en: '[PRE86]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The only thing we need to do now is update our Rust application config data
    with the following code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在唯一需要做的事情是使用以下代码更新我们的Rust应用程序配置数据：
- en: '[PRE87]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'There is only one change left in our pipeline, and this is in our `deployment/run_build.sh`
    file. Instead of copying our local `.env` file to our deployment server, we copy
    our `deployment/database.txt` file with the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的管道中，只剩下一个更改，这是在我们的`deployment/run_build.sh`文件中。我们不是将我们的本地`.env`文件复制到部署服务器，而是使用以下代码复制我们的`deployment/database.txt`文件：
- en: '[PRE88]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Running our deployment again will deploy our server and connect it to the AWS
    database that we have created. Again, these build scripts can be brittle. Sometimes,
    a connection can be refused when copying one of the files to the deployment server,
    which can result in the breaking of the entire pipeline. Because we have coded
    all the steps ourselves and understand each step, if there is a break, it will
    not take us much to manually sort out the break or try to run the Python build
    script again.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的部署将部署我们的服务器并将其连接到我们创建的AWS数据库。同样，这些构建脚本可能很脆弱。有时，在将其中一个文件复制到部署服务器时可能会被拒绝连接，这可能导致整个管道中断。因为我们自己编写了所有步骤并理解每个步骤，如果发生中断，手动解决问题或再次尝试运行Python构建脚本不会花费我们太多时间。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have finally come to the end of our journey. We have created our own Docker
    image, packaging our Rust application. We then ran this on our local computer
    with the protection of an NGINX container. We then deployed it onto a Docker Hub
    account, enabling us to use it to deploy onto an AWS server that we set up.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到达了旅程的终点。我们已经创建了自己的Docker镜像，打包了我们的Rust应用程序。然后我们在本地计算机上运行了这个镜像，并受到NGINX容器的保护。然后我们将其部署到Docker
    Hub账户，使我们能够将其部署到我们设置的AWS服务器上。
- en: It must be noted that we have gone through the lengthy steps of configuring
    containers and accessing our server via SSH. This has enabled us to apply this
    process to other platforms as our general approach was not AWS-centric. We merely
    used AWS to set up the server. However, if we set up a server on another provider,
    we would still be able to install Docker on the server, deploy our image onto
    it, and run it with NGINX and a connection to a database.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，我们已经完成了配置容器和通过SSH访问服务器的漫长步骤。这使得我们能够将此过程应用于其他平台，因为我们的通用方法并非仅针对AWS。我们只是使用AWS来设置服务器。然而，如果我们使用其他提供商设置服务器，我们仍然能够在服务器上安装Docker，将我们的镜像部署到上面，并使用NGINX和数据库连接来运行它。
- en: There are a few more things we can do as a developer’s work is never done. However,
    we have covered and achieved the core basics of building a Rust web application
    from scratch and deploying it in an automated fashion.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为开发者，我们的工作永远不会结束，我们还能做更多的事情。不过，我们已经涵盖了构建 Rust 网络应用程序的核心基础知识，并实现了从零开始构建和自动化部署。
- en: Considering this, there is little holding back developers from building web
    applications in Rust. Frontend frameworks can be added to improve the frontend
    functionality, and extra modules can be added to our application to increase its
    functionality and API endpoints. We now have a solid base to build a range of
    applications and read further on topics to enable us to develop our skills and
    knowledge of web development in Rust.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，几乎没有阻碍开发者使用 Rust 构建 Web 应用程序。可以添加前端框架来提高前端功能，还可以添加额外的模块来增加我们的应用程序的功能和
    API 端点。我们现在有一个坚实的基础来构建各种应用程序，并进一步阅读相关主题，以使我们能够开发 Rust Web 开发的技能和知识。
- en: We are at an exciting time with Rust and web development, and hopefully, after
    getting to this point, you feel empowered to push Rust forward in the field of
    web development. In the next chapter, we will be encrypting our web traffic to
    our application using HTTPS.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正处于 Rust 和 Web 开发的一个激动人心的时期，希望到达这个阶段后，你会有信心推动 Rust 在 Web 开发领域的进步。在下一章中，我们将使用
    HTTPS 加密我们的 Web 流量到应用程序。
- en: Further reading
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Rust compiling to different targets documentation: [https://doc.rust-lang.org/rustc/targets/index.html](https://doc.rust-lang.org/rustc/targets/index.html)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 编译到不同目标文档：[https://doc.rust-lang.org/rustc/targets/index.html](https://doc.rust-lang.org/rustc/targets/index.html)
- en: 'GitHub Actions documentation: [https://github.com/features/actions](https://github.com/features/actions)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions 文档：[https://github.com/features/actions](https://github.com/features/actions)
- en: 'Travis CI documentation: [https://docs.travis-ci.com/user/for-beginners/](https://docs.travis-ci.com/user/for-beginners/)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis CI 文档：[https://docs.travis-ci.com/user/for-beginners/](https://docs.travis-ci.com/user/for-beginners/)
- en: 'CircleCI documentation: [https://circleci.com/docs/](https://circleci.com/docs/)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CircleCI 文档：[https://circleci.com/docs/](https://circleci.com/docs/)
- en: 'Jenkins documentation: [https://www.jenkins.io/doc/](https://www.jenkins.io/doc/)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins 文档：[https://www.jenkins.io/doc/](https://www.jenkins.io/doc/)
- en: 'Terraform output documentation: [https://developer.hashicorp.com/terraform/language/values/outputs](https://developer.hashicorp.com/terraform/language/values/outputs)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 输出文档：[https://developer.hashicorp.com/terraform/language/values/outputs](https://developer.hashicorp.com/terraform/language/values/outputs)
- en: '*AWS Certified Developer - Associate Guide*, *Second Edition*, *V. Tankariya*
    and *B. Parmar* (2019), *Packt Publishing*, [*Chapter 5*](B18722_05.xhtml#_idTextAnchor091),
    *Getting Started with Elastic Compute Cloud (EC2)*, page 165'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS 认证开发者 - 副总裁指南*，第二版，*V. Tankariya* 和 *B. Parmar* (2019)，*Packt Publishing*，[*第五章*](B18722_05.xhtml#_idTextAnchor091)，*开始使用弹性计算云
    (EC2)*，第 165 页'
- en: '*AWS Certified Developer - Associate Guide*, *Second Edition*, *V. Tankariya*
    and *B. Parmar* (2019), *Packt Publishing*, [*Chapter 10*](B18722_10.xhtml#_idTextAnchor200),
    *AWS Relational Database Service (RDS)*, page 333'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS 认证开发者 - 副总裁指南*，第二版，*V. Tankariya* 和 *B. Parmar* (2019)，*Packt Publishing*，[*第十章*](B18722_10.xhtml#_idTextAnchor200)，*AWS
    关系型数据库服务 (RDS)*，第 333 页'
- en: '*AWS Certified Developer - Associate Guide*, *Second Edition*, *V. Tankariya*
    and *B. Parmar* (2019), *Packt Publishing*, *Chapter 21*, *Getting Started with
    AWS CodeDeploy*, page 657'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS 认证开发者 - 副总裁指南*，第二版，*V. Tankariya* 和 *B. Parmar* (2019)，*Packt Publishing*，*第二十一章*，*开始使用
    AWS CodeDeploy*，第 657 页'
- en: '*Mastering Kubernetes*, *G. Sayfan* (2020), *Packt Publishing*'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通 Kubernetes*，*G. Sayfan* (2020)，*Packt Publishing*'
- en: '*Getting Started with Terraform*, *K. Shirinkin* (2017), *Packt Publishing*'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始使用 Terraform*，*K. Shirinkin* (2017)，*Packt Publishing*'
- en: '*Nginx HTTP Server*, *Fourth Edition*, *M. Fjordvald* and *C. Nedelcu* (2018),
    *Packt Publishing*'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Nginx HTTP 服务器*，第四版，*M. Fjordvald* 和 *C. Nedelcu* (2018)，*Packt Publishing*'
