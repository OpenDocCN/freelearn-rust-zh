- en: '*Chapter 11*: Best Practices for Integrating Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：Rust集成的最佳实践'
- en: In [*Chapter 10*](B17720_10__Final_SK_ePub.xhtml#_idTextAnchor182), *Injecting
    Rust into a Python Flask App*, we managed to fuse our Rust code with a Python
    web application. In this final chapter, we will wrap up what we have covered in
    the book with best practices. These practices are not essential to fuse Rust with
    Python; however, they will help us in avoiding pitfalls when building bigger packages
    in Rust. When it comes to best practices, we can Google search the topic *SOLID
    principles*, which will give us loads of free information on how to keep code
    generally clean. But instead of regurgitating these principles, we will cover
    concepts that are specific to using Rust and Python together. We will learn how
    to keep the Rust/Python implementation as simple as possible if the requirements
    are not too demanding. We will also understand what Python and Rust excel in when
    it comes to computational tasks and Python interfaces. We then investigate traits
    in Rust and how they can help us organize and structure our structs. Finally,
    we look into keeping it simple when we want data parallelism with the Rayon crate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B17720_10__Final_SK_ePub.xhtml#_idTextAnchor182)，“将Rust注入Python Flask应用”，我们成功地将我们的Rust代码与Python网络应用程序融合在一起。在本章的最后一章中，我们将总结本书中涵盖的最佳实践。这些实践对于将Rust与Python融合不是必需的；然而，它们将帮助我们避免在构建Rust的大包时遇到陷阱。当谈到最佳实践时，我们可以通过Google搜索主题“SOLID原则”，这将给我们提供大量关于如何保持代码通常干净的免费信息。但不是重复这些原则，我们将涵盖特定于使用Rust和Python一起的概念。如果要求不是过于苛刻，我们将学习如何尽可能简化Rust/Python实现。我们还将了解Python和Rust在计算任务和Python接口方面的优势。然后，我们研究Rust中的特性和它们如何帮助我们组织和结构我们的结构体。最后，当我们想要使用Rayon
    crate实现数据并行时，我们将探讨如何保持简单。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Keeping our Rust implementation simple by piping data to and from Rust
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将数据从Rust中导入和导出，保持我们的Rust实现简单
- en: Giving the interface a native feel with objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使界面具有原生对象感
- en: Using traits as opposed to objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特性和对象相对
- en: Keeping data-parallelism simple with Rayon
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rayon保持数据并行简单
- en: Covering these topics will enable us to avoid pitfalls when building bigger
    packages that are more complex. We will also be able to build Rust solutions for
    smaller projects faster as we will learn that we do not have to rely on Python
    setup tools and installation with `pip`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖这些主题将使我们能够在构建更复杂的大包时避免陷阱。我们还将能够更快地为小型项目构建Rust解决方案，因为我们将会了解到我们不必依赖于Python设置工具和`pip`安装。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code and data for this chapter can be found at the following link:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码和数据可以在以下链接找到：
- en: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_eleven](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_eleven)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_eleven](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_eleven)'
- en: Keeping our Rust implementation simple by piping data to and from Rust
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过将数据从Rust中导入和导出，保持我们的Rust实现简单
- en: 'We have covered everything we need to integrate Rust into our Python system.
    We can build Rust packages that can be installed using `pip` and use them in Docker
    when integrating with a web application. However, reaching for a setup tool can
    be too much effort if the problem being solved is small and simple. For instance,
    if in a situation we were merely opening a **comma-separated values** (**CSV**)
    file full of numbers in Python, calculating the Fibonacci numbers, and then writing
    them in another file, then it would make sense to just write the program in Rust.
    However, we do not start building a Rust package with Python setup tools if we
    have a more complicated Python standalone script that just needs a simple speedup
    with Rust—it is still just a standalone script. Instead, we pipe data. This means
    we pass data from a Python script to a Rust standalone binary and back to a Python
    script for computing Fibonacci numbers, as shown here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了将Rust集成到我们的Python系统中所需的所有内容。我们可以构建可以使用`pip`安装的Rust包，并在与Web应用程序集成时在Docker中使用它们。然而，如果我们要解决的问题既小又简单，那么伸手去拿设置工具可能太过费力。例如，如果我们只是在Python中打开一个包含数字的**逗号分隔值**（**CSV**）文件，计算斐波那契数，然后将它们写入另一个文件，那么直接用Rust编写程序是有意义的。然而，如果我们有一个更复杂的Python独立脚本，只需要用Rust简单地加速——它仍然只是一个独立脚本——我们不会用Python设置工具开始构建Rust包。相反，我们通过管道传输数据。这意味着我们将数据从Python脚本传递到Rust独立二进制文件，然后再将其传递回Python脚本以计算斐波那契数，如图所示：
- en: '![](img/Figure_11.01_B17720.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_11.01_B17720.jpg)'
- en: Figure 11.1 – Process of a basic pipeline
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 基本管道的过程
- en: 'To achieve the same speed as the Rust Fibonacci calculation package without
    having to use any setup tools, we must carry out the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不使用任何设置工具的情况下达到与Rust斐波那契计算包相同的速度，我们必须执行以下步骤：
- en: Build a Python script that formulates the numbers for calculation.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个Python脚本，用于为计算制定数字。
- en: Build a Rust file that accepts the numbers, calculates the Fibonacci numbers,
    and returns the calculated numbers.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个Rust文件，该文件接受数字，计算斐波那契数，并返回计算结果。
- en: Build another Python script that accepts the calculated numbers and prints them
    out.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建另一个Python脚本，该脚本接受计算出的数字并将它们打印出来。
- en: With this, we will be able to have a simple pipeline. While each file is isolated
    and we can build in any order, it makes sense to start with *Step 1*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将能够拥有一个简单的管道。虽然每个文件都是隔离的，并且我们可以按任何顺序构建，但开始于*步骤1*是有意义的。
- en: Building a Python script that formulates the numbers for calculation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个Python脚本，用于为计算制定数字。
- en: 'For this example, we will just hardcode the input numbers that we are passing
    into our pipeline, but nothing is stopping you from reading your data from files
    or taking in numbers from command-line arguments. In our `input.py` file, we can
    write to `stdout` with the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们只是将输入数字硬编码到我们的管道中，但没有任何阻止你从文件中读取数据或从命令行参数中获取数字。在我们的`input.py`文件中，我们可以使用以下代码写入`stdout`：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this, if we run this script with the Python interpreter, we get the following
    output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，如果我们使用Python解释器运行此脚本，我们将得到以下输出：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this, we can now move on to the next step.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续进行下一步。
- en: Building a Rust file that accepts the numbers, calculates the Fibonacci numbers,
    and returns the calculated numbers
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建另一个Rust文件，该文件接受数字，计算斐波那契数，并返回计算结果。
- en: 'For our Rust file, we must have everything contained in the file to keep it
    as simple as possible. We can span it over multiple files if needed, but for a
    simple calculation, keeping it all in one file is good enough. In our `fib.rs`
    file, we initially import what we need and define our Fibonacci function with
    the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Rust文件，我们必须确保文件中包含所有内容，以尽可能保持其简单性。如果需要，我们可以将其分散到多个文件中，但对于简单的计算，将所有内容放在一个文件中就足够了。在我们的`fib.rs`文件中，我们最初导入所需的库并使用以下代码定义我们的斐波那契函数：
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we can see that there is nothing new; we are merely going to use `std::io`
    to get the numbers piped into the file, and then calculate the Fibonacci number,
    sending it to the next file in the pipeline with the following `main` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到没有什么新东西；我们只是将要使用`std::io`从文件中获取数字，然后计算斐波那契数，通过以下`main`函数将其发送到管道中的下一个文件：
- en: '[PRE23]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we can see that we define `stdin` to receive the numbers sent to the
    Rust program, and `stdout` to send out the calculated Fibonacci numbers. We then
    loop through the lines sent into the Rust program and then parse each line at
    an integer. We then calculate the Fibonacci number and then send it using the
    macro that we imported with the `io` prelude. With this, we can now compile our
    Rust file with the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们定义了`stdin`来接收发送给Rust程序的数量，以及`stdout`来发送计算出的斐波那契数。然后我们遍历发送到Rust程序中的每一行，并将每一行解析为整数。然后我们计算斐波那契数，然后使用我们通过`io`预处理器导入的宏将其发送出去。有了这个，我们现在可以使用以下命令编译我们的Rust文件：
- en: '[PRE34]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will compile our Rust file. We can now run both files, piping the data
    from the Python file to the compiled Rust code with the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译我们的Rust文件。我们现在可以运行这两个文件，使用以下命令将Python文件中的数据管道传输到编译后的Rust代码：
- en: '[PRE35]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we can see that the numbers from the `python input.py` command get piped
    into the Rust code returning the calculated Fibonacci numbers. With this, we can
    now move on to the final step, where we get the calculated Fibonacci numbers from
    the Rust code and print them out.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到来自`python input.py`命令的数字被管道传输到返回计算出的斐波那契数的Rust代码。有了这个，我们现在可以继续到最后一步，从Rust代码中获取计算出的斐波那契数并将它们打印出来。
- en: Building another Python script that accepts the calculated numbers and prints
    them out
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建另一个Python脚本，该脚本接受计算出的数字并将它们打印出来
- en: 'Our `output.py` file is very straightforward. It takes the following form:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`output.py`文件非常简单。它具有以下形式：
- en: '[PRE42]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We have a `try` block because the start and the end of the data passed into
    the last Python script will have empty lines, and they will fail when we try to
    convert them into integers. We then print out the data with `"receiving: {processed_number}"`
    added to the last script to make it clear that it is the `output.py` file printing
    out the numbers. This gives us the printout, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '我们有一个`try`块，因为传递给最后一个Python脚本的数据的开始和结束将有空行，并且当我们尝试将它们转换为整数时会失败。然后我们在最后一个脚本中添加`"receiving:
    {processed_number}"`来打印数据，以便使其清晰，这是`output.py`文件正在打印数字。这给我们以下打印输出：'
- en: '[PRE49]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can time how long it takes for the pipeline to run using the `time` command.
    If we compare this to pure Python with the example numbers that we have used,
    pure Python will be faster. However, we know that Rust is much faster than pure
    Python code. Because the `pure_python.py` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`time`命令来测量管道运行所需的时间。如果我们将这个与使用我们使用的示例数字的纯Python进行比较，纯Python将更快。然而，我们知道Rust比纯Python代码要快得多。因为`pure_python.py`文件：
- en: '[PRE56]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This gives us the following printout:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下打印输出：
- en: '[PRE64]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Adding the same numbers to the pipeline gives us the following printout:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的数字添加到管道中，我们得到以下打印输出：
- en: '[PRE78]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here, we can see that our pipeline is much faster. The gap between Rust and
    pure Python will just get larger as the numbers increase and become more numerous.
    We can see here that this is a lot easier with fewer moving parts. If our program
    is simple, then we keep the construction and use of Rust simple.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的管道运行得更快。随着数字的增加和数量的增多，Rust和纯Python之间的差距将越来越大。我们可以看到这里，这要容易得多，因为涉及的组件更少。如果我们的程序很简单，那么我们保持Rust的构建和使用简单。
- en: Giving the interface a native feel with objects
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过对象为界面提供原生感觉
- en: 'Python is an object-oriented language. When we are building our Rust packages,
    we need to keep the friction of adoption low. The adoption of Rust packages would
    be better if we keep our interfaces as objects. Most Python packages have object
    interfaces. Calculations are done with inputs, and the Python object has a range
    of functions and attributes that give us the results of those calculations. While
    we did cover creating classes in Rust with `pyo3` macros in [*Chapter 6*](B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100),
    *Working with Python Objects in Rust*, in the *Constructing our custom Python
    objects in Rust* section, it is advised that we understand the pros and cons of
    doing this. We remember that classes written in Rust are faster. However, the
    freedom of inheritance and metaclassing with pure Python is useful. As a result,
    it is best to leave the construction and organization of the object interface
    in pure Python. Any calculations that need to be done can be done in Rust. To
    demonstrate this, we can use the simple physics example of a particle''s **two-dimensional**
    (**2D**) trajectory, as seen in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种面向对象的语言。当我们构建Rust包时，我们需要保持较低的采用摩擦。如果我们保持接口为对象，Rust包的采用会更好。大多数Python包都有对象接口。计算使用输入完成，Python对象有一系列函数和属性，可以给我们计算的结果。虽然我们在[*第6章*](B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100)中介绍了如何使用`pyo3`宏在Rust中创建类，即*在Rust中处理Python对象*部分，但在*在Rust中构建我们的自定义Python对象*部分，建议我们了解这样做的好处和坏处。我们记得用Rust编写的类运行得更快。然而，使用纯Python进行继承和元类化的自由是有用的。因此，最好将对象接口的构建和组织留给纯Python。任何需要完成的计算都可以在Rust中完成。为了演示这一点，我们可以使用以下截图中的简单物理示例，即粒子的**二维**(**2D**)轨迹：
- en: '![Figure 11.2 – Simple 2D physics trajectory'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – 简单的二维物理轨迹'
- en: '](img/Figure_11.02_B17720.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 Figure_11.02_B17720.jpg](img/Figure_11.02_B17720.jpg)'
- en: Figure 11.2 – Simple 2D physics trajectory
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 简单的二维物理轨迹
- en: 'Here, we can see that the initial velocity is denoted as *V0*. The projection
    on the *x* axis is denoted by *Vx*, and the projection on the *y* axis is denoted
    by *Vy*. The dashed line is the particle at every point in time. Time here is
    another dimension. Our equations for each position in time and the endpoint in
    time (when it hits the ground) are defined as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到初始速度被表示为*V0*。在*x*轴上的投影被表示为*Vx*，而在*y*轴上的投影被表示为*Vy*。虚线表示粒子在每一时刻的位置。这里的“时间”是另一个维度。我们为时间中的每一个位置以及时间终点（当它触地时）的方程定义如下：
- en: '![](img/B17720_11_001.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B17720_11_001.png](img/B17720_11_001.png)'
- en: '![](img/B17720_11_002.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B17720_11_002.png](img/B17720_11_002.png)'
- en: '![](img/B17720_11_003.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B17720_11_003.png](img/B17720_11_003.png)'
- en: 'Here, *g* is the constant for gravity. We also want to know the position of
    the particle at a certain point in time. We do this by calculating the last point
    in time, then looping through all the time points between zero and the last point
    in time, calculating the `x` and `y` coordinates. All we would need is the initial
    velocity in `x` and `y`. The loop through with the position calculations would
    all be done in Rust. The dictionary where all the keys are all the times and all
    the values are tuples of `x` and `y` is housed in the Python object. We could
    write one function that processes all the times and returns a dictionary in Rust
    called `calculate_coordinates`. Using it in our Python class would look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*g*是重力常数。我们还想知道粒子在某个特定时间点的位置。我们通过计算最后一个时间点，然后遍历从零到最后一个时间点之间的所有时间点，计算`x`和`y`坐标来实现。我们需要的只是`x`和`y`的初始速度。位置计算的循环都会在Rust中完成。所有键都是时间，所有值都是`x`和`y`元组的字典被包含在Python对象中。我们可以编写一个函数来处理所有时间，并返回一个名为`calculate_coordinates`的Rust字典。在Python类中使用它看起来像这样：
- en: '[PRE92]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The user would just have to import the `Particle` object, initialize it with
    the initial velocity in the `x` and `y` coordinates, and then input times to get
    the coordinates. To plot all the positions for a particle, we would use our class
    with the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用户只需导入`Particle`对象，用`x`和`y`坐标的初始速度初始化它，然后输入时间以获取坐标。为了绘制粒子的所有位置，我们会使用以下代码的类：
- en: '[PRE101]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This is intuitive to Python. We have kept all our number crunching in Rust to
    get that speed, but we have managed to keep all of our interfaces, including accessing
    times and positions in Python. As a result, a developer using this package would
    not know that it is written in Rust—they would just appreciate that it is fast.
    We can drive home the benefits of keeping the formation and access to data 100%
    in Python while doing all the calculations in Rust with metaclassing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这对Python来说是很直观的。我们一直在Rust中保留所有的数值计算以获得速度，但我们已经设法保留了所有的接口，包括访问时间和位置，都在Python中。因此，使用这个包的开发者不会知道它是用Rust编写的——他们只会欣赏它的速度。我们可以通过元类将数据结构和访问保持100%在Python中，而所有计算都在Rust中完成，来强调这样做的好处。
- en: 'In our particle system, we could load a lot of data for the initial velocities
    of particles. As a result, our system would calculate the trajectories for a range
    of particles that we load. However, if we load two particles with the same initial
    velocities, they will both have the same trajectories. Considering this, it would
    not make sense for us to calculate the trajectory for both particles. To avoid
    this, we do not need to store anything in a file or database for reference; we
    just need to implement a flyweight design pattern. This is where we check the
    parameters passed into the object. If they are the same as the previous instance,
    we just return the previous instance. The flyweight pattern is defined with the
    following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的粒子系统中，我们可以为粒子的初始速度加载大量数据。结果，我们的系统将计算我们加载的粒子的轨迹。然而，如果我们加载两个具有相同初始速度的粒子，它们都将具有相同的轨迹。考虑到这一点，对我们来说计算两个粒子的轨迹是没有意义的。为了避免这种情况，我们不需要在文件或数据库中存储任何东西作为参考；我们只需要实现一个轻量级设计模式。这就是我们检查传递给对象的参数的地方。如果它们与之前的实例相同，我们就只返回之前的实例。轻量级模式用以下代码定义：
- en: '[PRE109]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Here, we can see that we combine the initial velocities to define a key, and
    then check to see if there is already an instance with these velocities. If there
    is, we return the instance from our `_instances` dictionary. If not, we create
    a new instance and insert it into our `_instances` dictionary. Our particles will
    then take the form of the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们通过组合初始速度来定义一个键，然后检查是否已经存在具有这些速度的实例。如果存在，我们就从我们的`_instances`字典中返回该实例。如果不存在，我们就创建一个新的实例并将其插入到我们的`_instances`字典中。我们的粒子将采取以下代码的形式：
- en: '[PRE117]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Here, our particles will now adhere to the flyweight pattern. We can test this
    with the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的粒子现在将遵循轻量级模式。我们可以用以下代码来测试这一点：
- en: '[PRE125]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Running this will give us the following printout:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将给出以下输出：
- en: '[PRE131]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Here, we can see that the two particles that have the same initial velocities
    have the same memory address, so it works.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到具有相同初始速度的两个粒子具有相同的内存地址，所以它工作得很好。
- en: We can initialize these particles anywhere and this design pattern will apply,
    ensuring that we do not perform duplicate calculations. Considering that we are
    writing Python extensions in Rust, the flyweight pattern really shows us how much
    control we get with how the interface is called, used, and displayed. Even though
    we have built our interfaces in Python, this does not mean that we do not have
    to structure our Rust code. This brings us on to the next section, in which we
    discuss how to lean into traits as opposed to objects when it comes to structuring
    our Rust code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何地方初始化这些粒子，并且这个设计模式将适用，确保我们不进行重复的计算。考虑到我们正在用Rust编写Python扩展，轻量级模式真正展示了我们如何通过接口的调用、使用和显示来获得多少控制。尽管我们在Python中构建了接口，但这并不意味着我们不需要结构化我们的Rust代码。这把我们带到了下一个部分，我们将讨论在结构化我们的Rust代码时如何倾向于特质而不是对象。
- en: Using traits as opposed to objects
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特质而不是对象
- en: 'As a Python developer, it is tempting to build structs that inherit via the
    composition of other structs. **Object-oriented programming** (**OOP**) is well
    supported in Python; however, there are many reasons why Rust is favored, and
    one of them is traits. As seen in the following screenshot, traits enable us to
    separate data from behavior:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名Python开发者，构建通过其他结构体组合继承的结构体是有诱惑力的。**面向对象编程**（**OOP**）在Python中得到了很好的支持；然而，有许多原因使得Rust更受欢迎，其中之一就是特质。正如以下截图所示，特质使我们能够将数据与行为分离：
- en: '![Figure 11.3 – Difference between traits and objects'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 – 特质与对象的区别'
- en: '](img/Figure_11.03_B17720.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.03_B17720.jpg)'
- en: Figure 11.3 – Difference between traits and objects
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 特质与对象的区别
- en: 'This gives us a lot of flexibility as the data and behavior are decoupled,
    enabling us to slot behavior in and out of structs as we need. Structs can have
    a portfolio of traits without giving us disadvantages arising from multiple inheritance.
    To demonstrate this, we are going to create a basic doctor, patient, nurse program
    so that we can see how different structs can have different traits, allowing them
    to move through functions. We are going to see how traits affect the way we lay
    out code over multiple files. Our program will have the following layout:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了很大的灵活性，因为数据和行为是解耦的，使我们能够根据需要将行为插入和从结构体中移除。结构体可以拥有一系列特性，而不会给我们带来多重继承的缺点。为了演示这一点，我们将创建一个基本的医生、病人、护士程序，以便我们可以看到不同的结构体可以有不同的特性，使它们能够通过函数移动。我们将看到特性如何影响我们在多个文件中布局代码的方式。我们的程序将具有以下布局：
- en: '[PRE134]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'With this structure, the flow of our code will take the following form:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，我们的代码流程将呈现以下形式：
- en: '![](img/Figure_11.04_B17720.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_11.04_B17720.jpg)'
- en: Figure 11.4 – Code flow of a simple trait-based program
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 简单基于特性的程序代码流程
- en: 'With this, we can see that our code is decoupled. Our traits go into all the
    other files to define the behavior of those files. To build this program, we must
    carry out the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以看到我们的代码是解耦的。我们的特性被放入所有其他文件中，以定义这些文件的行为。为了构建这个程序，我们必须执行以下步骤：
- en: Defining traits—building traits for our structs
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义特性——为我们的结构体构建特性
- en: Defining struct behavior with traits
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特性定义结构体行为
- en: Passing traits through functions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数传递特性
- en: Storing structs with common traits
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储具有共同特性的结构体
- en: Running our program in the `main.rs` file.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main.rs`文件中运行我们的程序。
- en: With this, we can start by defining our traits in the first subsection.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以从第一小节开始定义我们的特性。
- en: Defining traits
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义特性
- en: 'Before we start defining traits, we must conceptualize the types of people
    in our program that we are defining behavior for. They are laid out as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始定义特性之前，我们必须概念化我们程序中定义行为的人的类型。它们如下列出：
- en: '**Patient**: This person does not have any clinical skills, but actions are
    performed on them.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**病人**：这个人没有任何临床技能，但对他们执行操作。'
- en: '**Nurse**: This person has clinical skills but cannot prescribe or diagnose.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**护士**：这个人拥有临床技能，但不能开具处方或诊断。'
- en: '**Nurse practitioner**: This person has clinical skills and can prescribe but
    cannot diagnose.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**护士执业医师**：这个人拥有临床技能，可以开具处方但不能诊断。'
- en: '**Advanced nurse practitioner**: This person has clinical skills and can prescribe
    and diagnose.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级护士执业医师**：这个人拥有临床技能，可以开具处方和诊断。'
- en: '**Doctor**: This person has clinical skills and can prescribe and diagnose.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**医生**：这个人拥有临床技能，可以开具处方和诊断。'
- en: 'What we can see here is that they are all humans. Therefore, they are all able
    to speak and introduce themselves. So, in our `traits.rs` file, we can create
    a `Speak` trait with the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到，他们都是人类。因此，他们都能说话并介绍自己。所以，在我们的`traits.rs`文件中，我们可以创建一个`Speak`特性，以下代码：
- en: '[PRE141]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'If a struct implements this trait, it will have to create its own `introduce`
    function with the same return and input parameters. We can also see that everyone
    apart from the patient has clinical skills. To accommodate this, we can implement
    a clinical skills trait with the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个结构体实现了这个特性，它必须创建自己的`introduce`函数，具有相同的返回和输入参数。我们还可以看到，除了病人之外的所有人都有临床技能。为了适应这一点，我们可以实现一个临床技能特性，以下代码：
- en: '[PRE144]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Here, we can see that we have defined the most common attributes for each clinician.
    Only two people—the doctor and the advanced nurse practitioner—can diagnose and
    prescribe. However, all of them can administer medication. We can implement this
    trait for all clinicians and then overwrite specifics. We must note that because
    the doctor and advanced nurse practitioner have the same possibilities in terms
    of diagnosing and prescribing, we can create another trait for this to prevent
    repeating ourselves, and a trait for the patient with the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们为每个临床医生定义了最常用的属性。只有两个人——医生和高级护士执业医师——可以诊断和开具处方。然而，他们所有人都可以给药。我们可以为所有临床医生实现这个特性，然后覆盖具体细节。我们必须注意，由于医生和高级护士执业医师在诊断和开具处方方面具有相同的可能性，我们可以为这一点创建另一个特性，以防止重复，并使用以下代码为病人创建一个特性：
- en: '[PRE155]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: We have now defined all the traits that we need. We can start using them to
    define our people in the next subsection.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了我们需要的所有特性。我们可以开始使用它们来定义下一小节中的人。
- en: Defining struct behavior with traits
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特性定义结构体行为
- en: 'Before we define any structs, we must import our traits into our `people.rs`
    file with the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义任何结构体之前，我们必须使用以下代码将我们的特征导入到`people.rs`文件中：
- en: '[PRE159]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'We now have all our traits, so we can define our people in the program with
    the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了所有特征，因此我们可以使用以下代码在程序中定义我们的人：
- en: '[PRE162]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Sadly, there is some repetition here. This is also going to happen with our
    `Speak` trait; however, it is important to keep these structs separate as we will
    slot traits into them later, so we need them to be decoupled. We can implement
    our `Speak` trait for each person with the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这里有一些重复。这也会发生在我们的`Speak`特征上；然而，保持这些结构体分开是很重要的，因为我们稍后会将特征插入到它们中，所以我们需要它们是解耦的。我们可以使用以下代码为每个人实现`Speak`特征：
- en: '[PRE177]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'We can continue this pattern and implement `Speak` traits for all the people
    structs. Now this is done, we can implement our clinical skills and patient role
    traits for our people with the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这种模式，并为所有人结构体实现`Speak`特征。现在这已经完成，我们可以使用以下代码为我们的人实现临床技能和病人角色特征：
- en: '[PRE196]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Here, we can see that our people structs have the following traits:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到我们的人结构体具有以下特征：
- en: The `Patient` struct has the standard `PatientRole` trait.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Patient`结构体具有标准的`PatientRole`特征。'
- en: The `Nurse` struct has the standard `ClinicalSkills` trait.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nurse`结构体具有标准的`ClinicalSkills`特征。'
- en: The `NursePractitioner` struct has the standard `ClinicialSkills` trait with
    the `can_prescribe` function overwritten to return `true`.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NursePractitioner`结构体具有标准的`ClinicialSkills`特征，并且将`can_prescribe`函数重写为返回`true`。'
- en: 'Now that we have our clinical skills applied to our standard clinicians, we
    can now apply our advanced traits with the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将临床技能应用到标准临床医生上，我们现在可以使用以下代码应用我们的高级特征：
- en: '[PRE207]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Here, we apply the `AdvancedMedical` trait to our `Doctor` and `AdvancedNursePractitioner`
    structs. However, we know that these structs are also clinicians. We need them
    to have clinical skills. Therefore, we implement `ClinicalSkills` for the `AdvancedMedical`
    trait. We then overwrite the `can_prescribe` and `can_diagnose` functions to `true`.
    Therefore, doctors and advanced nurse practitioners have both `ClinicalSkills`
    and `AdvancedMedical` traits and can diagnose and prescribe. With this, our people
    structs are ready to be passed into functions. We will do this in the next subsection.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将`AdvancedMedical`特征应用到`Doctor`和`AdvancedNursePractitioner`结构体上。然而，我们知道这些结构体也是临床医生。我们需要它们具有临床技能。因此，我们为`AdvancedMedical`特征实现`ClinicalSkills`。然后，我们将`can_prescribe`和`can_diagnose`函数重写为`true`。因此，医生和高级护士执业医师都具有`ClinicalSkills`和`AdvancedMedical`特征，可以进行诊断和开处方。有了这个，我们的人结构体就准备好传递到函数中了。我们将在下一小节中这样做。
- en: Passing traits through functions
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过函数传递特征
- en: 'To perform actions such as updating a database or sending data to a server,
    we are going to pass our people structs through functions where clinicians can
    act on patients. To do this, we must import our traits in our `actions.rs` file
    with the following code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行更新数据库或向服务器发送数据等动作，我们将通过函数传递我们的人结构体，让临床医生可以对病人采取行动。为此，我们必须使用以下代码在我们的`actions.rs`文件中导入我们的特征：
- en: '[PRE217]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Our first action is to admit a patient. This can be done by anyone with clinical
    skills. Considering this, we can define this action with the following code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项动作是接收病人。这可以由任何具有临床技能的人完成。考虑到这一点，我们可以用以下代码定义这个动作：
- en: '[PRE219]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Here, we can see that our clinician being passed in is anything with a `ClinicalSkills`
    trait, which means all our clinician structs. However, it must be noted that we
    are also passing in `&Box<dyn PatientRole>` for the patient. This is because we
    will be using a patient list when passing in patients. We can have multiple patients
    assigned to a clinician. We will explore why we are using `&Box<dyn PatientRole>`
    in the next subsection when we define our patient list struct. The next action
    is to diagnose a patient, which is defined with the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到传入我们的临床医生可以是任何具有`ClinicalSkills`特征的实体，这意味着所有我们的临床医生结构体。然而，必须注意的是，我们还在传入`&Box<dyn
    PatientRole>`作为病人。这是因为当传入病人时，我们将使用病人列表。我们可以将多个病人分配给一个临床医生。我们将在定义病人列表结构体的下一小节中探讨为什么我们使用`&Box<dyn
    PatientRole>`。接下来的动作是对病人进行诊断，这通过以下代码定义：
- en: '[PRE223]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Here, it makes sense to have the `AdvancedMedical` trait to diagnose. If we
    try to pass in a `Nurse` or `NursePractitioner` struct, the program will fail
    to compile due to mismatching traits. We can then have a prescribe medication
    action, which takes the form of the following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，拥有用于诊断的`AdvancedMedical`特质是有意义的。如果我们尝试传递一个`Nurse`或`NursePractitioner`结构体，由于特质不匹配，程序将无法编译。然后我们可以有一个开药动作，其形式如下代码：
- en: '[PRE227]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Here, we can see that the `ClinicalSkills` trait is accepted but the code will
    throw an error if the clinician cannot prescribe. This is because our `NursePractitioner`
    struct can prescribe. We could also make a third intermediate trait and apply
    it to doctor, advanced, and normal nurse practitioners. However, this is just
    one check as opposed to implementing a new trait for all three clinician structs.
    Our last action is that of administering medication and discharging the patient,
    which can be done by all our clinician structs; therefore, it takes the following
    form:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`ClinicalSkills`特质被接受，但如果临床医生不能开药，代码将会抛出错误。这是因为我们的`NursePractitioner`结构体可以开药。我们也可以创建一个第三级中间特质，并将其应用于医生、高级和普通护士。然而，这只是一个检查，而不是为所有三个临床医生结构体实现一个新特质。我们的最后一个动作是给药和出院，这可以通过我们所有的临床医生结构体来完成；因此，它具有以下形式：
- en: '[PRE236]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: We can now pass our people structs through a range of actions, with our compiler
    refusing to compile if we pass through the wrong person struct into the function.
    In the next subsection, we will be storing structs with traits in a patient list.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过一系列动作传递我们的`people`结构体，如果我们将错误的人结构体传递到函数中，编译器将拒绝编译。在下一小节中，我们将存储具有特质的结构体在患者列表中。
- en: Storing structs with common traits
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储具有共同特质的结构体
- en: 'When it comes to a patient list, it is tempting to just store patient structs
    in a vector. However, this does not give us much flexibility. For instance, let''s
    say that our system is deployed, and one of the nurses in the hospital is sick
    and must be admitted. We could allow this by implementing the `PatientRole` trait
    to the `Nurse` struct without having to rewrite anything else. We might also need
    to expand the different types of patients, adding more structs such as `ShortStayPatient`,
    or `CriticallySickPatient`. Because of this, we store our patients with the `PatientRole`
    trait in our `objects.rs` file with the following code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到患者列表时，直接在向量中存储患者结构体似乎很诱人。然而，这并不提供很多灵活性。例如，假设我们的系统已经部署，医院里的一名护士生病了，必须住院。我们可以通过将`PatientRole`特质应用于`Nurse`结构体来实现这一点，而无需重写其他任何内容。我们可能还需要扩展不同类型的患者，添加更多结构体，如`ShortStayPatient`或`CriticallySickPatient`。因此，我们在`objects.rs`文件中使用以下代码存储具有`PatientRole`特质的我们的患者：
- en: '[PRE245]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: We must wrap our structs in a box because we do not know the size at compile
    time. Different structs of different sizes can implement the same trait. A `Box`
    is a pointer on the heap memory. Because we know the size of pointers, we know
    the size of memory being added to the vector at compile time. The `dyn` keyword
    is used to define that it is a trait that we are referring to. Managing to access
    the struct directly in the `patients` vector is not going to happen, as again,
    we do not know the size of the struct. Therefore, we access the data of the struct
    via the `get_name` function in the `PatientRole` trait in our action functions.
    Traits are also pointers. We can still build functions such as constructors for
    our struct. However, when it comes to our `Patient` struct being passed through
    an action function that we created, our `PatientRole` trait acts as an interface
    between our `Patient` struct and our `admit_function` function. We now have everything
    we need, so we can move on to our next subsection to put it all together and run
    it in our `main.rs` file.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将我们的结构体包装在`Box`中，因为我们不知道编译时的确切大小。不同大小不同结构体的结构体可以实现相同的特质。`Box`是堆内存中的指针。因为我们知道指针的大小，所以我们知道在编译时添加到向量中的内存大小。`dyn`关键字用于定义我们正在引用的特质。在`patients`向量中直接访问结构体是不可能的，因为我们再次不知道结构体的大小。因此，我们通过`PatientRole`特质中的`get_name`函数在我们的动作函数中访问结构体的数据。特质也是指针。我们仍然可以构建如结构体构造函数之类的函数。然而，当我们的`Patient`结构体通过我们创建的动作函数传递时，我们的`PatientRole`特质充当了`Patient`结构体和我们的`admit_function`函数之间的接口。我们现在拥有了所有需要的东西，因此我们可以继续到下一个小节，将它们全部组合在一起，并在我们的`main.rs`文件中运行。
- en: Running our traits in the main file
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主文件中运行我们的特质
- en: 'Running all our code together is straightforward and safe. Here''s what we
    need to do:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有代码一起运行既简单又安全。以下是我们需要做的：
- en: 'First, we import all we need in our `main.rs` file with the following code:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在 `main.rs` 文件中使用以下代码导入所有需要的模块：
- en: '[PRE250]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'In our `main` function, we can now define the two nurses and doctors for our
    clinic for the day with the following code:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `main` 函数中，我们现在可以使用以下代码定义我们诊所当天所需的两位护士和医生：
- en: '[PRE251]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'We then get our patient list, and it turns out that the four horsemen have
    turned up for their treatment, as seen in the following code snippet:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取病人名单，结果发现四骑士已经到来接受治疗，如下面的代码片段所示：
- en: '[PRE252]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'We then loop through our patients, getting our doctors and nurses to care for
    them with the following code:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历我们的病人，使用以下代码让医生和护士照顾他们：
- en: '[PRE253]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'This is the end of our `main` function. Running it would give us the following
    printout:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 `main` 函数的结束。运行它将给出以下输出：
- en: '[PRE254]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'With this, we have finished our exercise in using traits in Rust. Hopefully,
    with this, you see the flexibility and decoupling we get when we use traits. However,
    we must remember that this approach cannot be supported if we were to build an
    interface with our Python system. If we were to build an interface, this could
    be done with the following pseudocode:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经完成了在 Rust 中使用特质的练习。希望如此，你能看到使用特质时我们获得的灵活性和解耦。然而，我们必须记住，如果我们构建一个与我们的
    Python 系统的接口，这种方法将无法得到支持。如果我们构建一个接口，可以使用以下伪代码来完成：
- en: '[PRE265]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: Here, we can see that we swapped the functions in the `ClinicalSkills` trait
    for attributes. We would be able to pass our `NurseClass` struct with traits into
    a function which calls the `ClinicalSkills` functions. The results from the `ClinicalSkills`
    functions can then be passed into the constructor for our `NurseClass` struct.
    Our `NurseClass` struct can then be passed out to our Python system.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们用属性替换了 `ClinicalSkills` 特质中的函数。我们将能够将带有特质的 `NurseClass` 结构体传递给调用
    `ClinicalSkills` 函数的函数。然后，`ClinicalSkills` 函数的结果可以传递给 `NurseClass` 结构体的构造函数。然后，我们的
    `NurseClass` 结构体可以被传递到我们的 Python 系统中。
- en: OOP has its merits and should be used when coding in Python. However, Rust has
    given us a new approach that is flexible and decoupled. It may take a while to
    get your head around traits, however, they are worth it. It's advised that you
    keep working with traits in your Rust code to get the advantages of using traits.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程有其优点，应该在用 Python 编码时使用。然而，Rust 给我们带来了一个新的灵活且解耦的方法。虽然理解特质可能需要一段时间，但它们是值得的。建议你在
    Rust 代码中继续使用特质以获得使用特质的优点。
- en: Keeping data-parallelism simple with Rayon
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rayon 保持数据并行简单
- en: 'In [*Chapter 3*](B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046), *Understanding
    Concurrency* we processed our Fibonacci numbers in parallel. While it was interesting
    to look into concurrency, when we are building our own applications, we should
    lean on other crates to reduce the complexity of our application. This is where
    the `rayon` crate comes in. This will enable us to loop through numbers to be
    calculated and process them in parallel. In order to do this, we initially have
    to define the crate in the `Cargo.toml` file as seen here:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046) *理解并发* 中，我们并行处理了斐波那契数。虽然研究并发很有趣，但当我们构建自己的应用程序时，我们应该依赖其他
    crate 来减少应用程序的复杂性。这就是 `rayon` crate 发挥作用的地方。这将使我们能够遍历要计算的数字并将它们并行处理。为了做到这一点，我们最初必须在
    `Cargo.toml` 文件中定义 crate，如下所示：
- en: '[PRE288]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'Then, if we do not import the macros with `use rayon::prelude::*;` our compiler
    will refuse to compile when we try and turn a standard vector into a parallel
    iterator. With these macros, we can execute parallel Fibonacci calculations with
    the following code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们没有使用 `use rayon::prelude::*;` 导入宏，当我们尝试将标准向量转换为并行迭代器时，编译器将拒绝编译。有了这些宏，我们可以使用以下代码执行并行斐波那契计算：
- en: '[PRE294]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'With this code, we can see that we define a standard Fibonacci number function.
    We then get a vector of input numbers and convert it into a parallel iterator
    with the `into_par_iter` function. We then map our Fibonacci function to this
    parallel iterator. After this, we collect the results. Therefore, printing `numbers`
    will give us `[8, 13, 21, 34, 55]`. And that''s it! We have coded parallel code,
    and we have kept it simple with the `rayon` crate. However, we must remember that
    there is a cost to set up this parallelization. If we were only going to use the
    numbers in the example, a normal loop would be faster. However, if the numbers
    and size of the array increase, the benefits of `rayon` start to show. For instance,
    if we were to have a vector of numbers to be calculated ranging from 6 to 33,
    we will get the time difference as seen in the following figure:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们可以看到我们定义了一个标准的斐波那契数函数。然后我们获取一个输入数字的向量，并使用 `into_par_iter` 函数将其转换为并行迭代器。然后我们将斐波那契函数映射到这个并行迭代器上。之后，我们收集结果。因此，打印
    `numbers` 将会给出 `[8, 13, 21, 34, 55]`。就这样！我们已经编写了并行代码，并且我们用 `rayon` 包保持了它的简单性。然而，我们必须记住，设置这种并行化是有成本的。如果我们只是使用示例中的数字，普通的循环会更快。然而，如果数字和数组的大小增加，`rayon`
    的好处开始显现。例如，如果我们有一个从 6 到 33 的数字向量要计算，我们将在以下图中看到时间差异：
- en: '![Figure 11.5 – Time taken for a loop 6 -> 33 Fib numbers to be taken in microseconds'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.5 – 循环 6 -> 33 斐波那契数所需时间（微秒）'
- en: '](img/Figure_11.05_B17720.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.05_B17720.jpg]'
- en: Figure 11.5 – Time taken for a loop 6 -> 33 Fib numbers to be taken in microseconds
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 循环 6 -> 33 斐波那契数所需时间（微秒）
- en: '[left = Rayon right = normal loop]'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[左 = Rayon 右 = 普通循环]'
- en: With this, we have a simple approach to parallelizing our calculations which
    will keep our complexity and mistakes down.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们有一个简单的并行化计算方法，这将保持我们的复杂性和错误率较低。
- en: Summary
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went over best practices for implementing Rust in our Python
    systems. We initially started by keeping it simple. We saw that we could leverage
    the speed of Rust without any setup tools or installing a package thanks to piping
    data to and from our Rust binary with Python. This is a useful technique to have
    and is not just limited to Python and Rust. In fact, you can pipe data between
    any language.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在 Python 系统中实现 Rust 的最佳实践。我们最初从保持简单开始。我们看到了，我们可以利用 Rust 的速度，而无需设置工具或安装包，这得益于通过管道将数据从
    Python 传输到 Rust 二进制文件以及从 Rust 二进制文件传输到 Python。这是一个有用的技术，不仅限于 Python 和 Rust。实际上，你可以在任何语言之间传输数据。
- en: If you are writing a basic program, then data piping should be the first thing
    you should do. This way, you reduce the number of moving parts and speed up development.
    A simple Bash script could compile the Rust file and run the process. However,
    as the program complexity increases, you can go for setup tools and import your
    Rust code directly into your Python code, utilizing what you covered in this book.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个基础程序，那么数据管道应该是你首先应该做的事情。这样，你可以减少移动部件的数量并加快开发速度。一个简单的 Bash 脚本可以编译 Rust
    文件并运行该过程。然而，随着程序复杂性的增加，你可以选择设置工具并将你的 Rust 代码直接导入到 Python 代码中，利用本书中介绍的内容。
- en: We then moved on to the importance of leveraging Python's object support with
    a metaclass to lean on Python for our interfaces without Rust packages. Python
    is a mature language that is very expressive. It makes sense to use the best of
    Python and the best of Rust when building our packages by using Python for the
    interfaces and Rust for the calculations. We finally covered how to utilize traits
    as opposed to forcing Rust to have an object-orientated approach with inheritance
    via composition. The result is more decoupling and flexibility. Finally, we kept
    our parallel processing code simple with third-party crates which will increase
    our productivity and reduce the complexity of our code, and in turn, reduce mistakes.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了利用 Python 的对象支持以及元类的重要性，以便在不使用 Rust 包的情况下依赖 Python 来构建我们的接口。Python 是一种成熟且非常表达性的语言。在构建我们的包时，使用
    Python 作为接口和 Rust 作为计算，使用 Python 的最佳和 Rust 的最佳是有意义的。我们最终讨论了如何利用特质而不是通过组合强制 Rust
    采用面向对象的方法。结果是解耦和灵活性更高。最后，我们通过第三方包保持了并行处理代码的简单性，这将提高我们的生产力并减少代码的复杂性，从而减少错误。
- en: We have now come to the end of the book. There is always more to learn; however,
    you now have a full tool belt. You not only have a handle on the fastest memory-safe
    language that is cutting-edge, but you can also fuse it with the widely used Python
    language in an efficient way, installing it with `pip`. Not only can you do this
    for Python scripts, but you can also wrap up Rust extensions in Docker, enabling
    you to use Rust in Python web applications. Therefore, you do not have to wait
    for your company and projects to rewrite and adopt Rust. Instead, you can plug
    Rust into an already established project tomorrow. I am nothing short of excited
    about what you will do with this in the future.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经来到了这本书的结尾。总有更多东西要学习；然而，你现在已经拥有了一个完整的工具箱。你不仅掌握了最先进的、内存安全的快速语言，而且还能以高效的方式将其与广泛使用的Python语言融合，通过`pip`进行安装。这不仅适用于Python脚本，你还可以将Rust扩展封装在Docker中，使你能够在Python网络应用程序中使用Rust。因此，你不必等待你的公司和项目重写和采用Rust。相反，你可以在明天就将Rust插入到一个已经建立的项目中。我对你在未来将如何使用这一点感到无比兴奋。
- en: Further reading
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering Object-Oriented Python* by *Steven Lott* (2019) (*Packt Publishing*)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[《精通面向对象Python》](https://packtpub.com/product/mastering-object-oriented-python/2019)
    由 [Steven Lott](https://packtpub.com/authors/steven-lott) 著（2019）[Packt Publishing](https://packtpub.com/packt-publishing)'
- en: '*Mastering Rust* by *Rahul Sharma*, *Vesa Kaihlavirta* (2018) (*Packt Publishing*)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[《精通Rust》](https://packtpub.com/product/mastering-rust/2018) 由 [Rahul Sharma](https://packtpub.com/authors/rahul-sharma)
    和 [Vesa Kaihlavirta](https://packtpub.com/authors/vesa-kaihlavirta) 著（2018）[Packt
    Publishing](https://packtpub.com/packt-publishing)'
