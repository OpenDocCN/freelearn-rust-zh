- en: The Rust Memory Model – Ownership, References and Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust内存模型 - 所有权、引用和操作
- en: In the previous chapter, [Chapter 2](8c61da2f-08c8-40be-89d4-d8afa8510850.xhtml),
    *Sequential Rust Performance and Testing*, we discussed factors that contribute
    or detract from the serial performance of a Rust program. We did not explicitly
    address concurrent performance for want of sufficient information about the way
    Rust's abstract memory model interacts with the real memory hierarchy of a machine.
    In this chapter, we'll discuss Rust's memory model, how to control the layout
    of types in memory, how types are aliased, and how Rust's memory safety works.
    We'll dig into the standard library to understand how this plays out in practice.
    This chapter will also examine common crates in the ecosystem that will be of
    interest to us later in this book. Please be aware that by the time you read this
    chapter, the `rustc` implementation will have changed, potentially making our
    code listings here no longer square with the naming patterns in `rustc` itself.
    If you wish to follow along, please check out Rust at SHA `da569fa9ddf8369a9809184d43c600dc06bd4b4d`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，[第2章](8c61da2f-08c8-40be-89d4-d8afa8510850.xhtml)，*Rust的顺序性能和测试*，我们讨论了影响Rust程序顺序性能的因素。我们没有明确地讨论并发性能，因为缺乏关于Rust的抽象内存模型如何与机器的真实内存层次结构交互的足够信息。在本章中，我们将讨论Rust的内存模型，如何控制类型在内存中的布局，类型是如何被别名的，以及Rust的内存安全性是如何工作的。我们将深入研究标准库，以了解这些在实际中是如何体现的。本章还将检查生态系统中的一些常见crate，这些crate将在本书后面的部分对我们感兴趣。请注意，当你阅读这一章时，`rustc`
    的实现可能已经改变，这可能会使这里的代码列表与 `rustc` 本身的命名模式不再一致。如果你希望跟随，请查看SHA `da569fa9ddf8369a9809184d43c600dc06bd4b4d`
    的Rust。
- en: 'By the close of this chapter, we will have:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将：
- en: Investigated how Rust lays objects out in memory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究了Rust如何在内存中布局对象
- en: Discussed the various ways Rust points to memory and their guarantees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了Rust指向内存的各种方式及其保证
- en: Discussed how Rust allocates and deallocates memory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了 Rust 如何分配和释放内存
- en: Discussed how Rust denotes stack and heap allocations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Rust如何表示栈和堆分配
- en: Investigated the internal implementation of `Option`, `Cell`, `CellRef` , `Rc` and
    `Vec`.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究了 `Option`、`Cell`、`CellRef`、`Rc` 和 `Vec` 的内部实现
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires a working Rust installation. The details of verifying
    your installation are covered in [Chapter 1](5f3aec9d-fd53-48ff-9ba8-43ce13e91cff.xhtml),
    *Preliminaries – Machine Architecture and Getting Started with Rust*. No additional
    software tools are required.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要有一个工作的Rust安装。验证安装的细节在[第1章](5f3aec9d-fd53-48ff-9ba8-43ce13e91cff.xhtml)，*预备知识
    - 机器架构和Rust入门*中有介绍。不需要额外的软件工具。
- en: 'You can find the source code for this book''s projects on GitHub: [https://github.com/PacktPublishing/Hands-On-Concurrency-with-Rust](https://github.com/PacktPublishing/Hands-On-Concurrency-with-Rust).
    This chapter has its source code under `Chapter03`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本书项目的源代码：[https://github.com/PacktPublishing/Hands-On-Concurrency-with-Rust](https://github.com/PacktPublishing/Hands-On-Concurrency-with-Rust)。本章的源代码位于
    `Chapter03`。
- en: Memory layout
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存布局
- en: 'Rust has a handful of mechanisms to lay out compound types in memory. They
    are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有一系列机制来在内存中布局复合类型。它们如下：
- en: Arrays
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Enums
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Structs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Tuples
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: 'Exactly how these are laid out in memory depends on the representation chosen.
    By default, everything in Rust is `repr(Rust)`. All `repr(Rust)` types are aligned
    on byte boundaries to the power of two. Every type is at least one byte in memory,
    then two, then four, and so forth. Primitives—`u8`, `usize`, `bool`, and `&T`—are
    aligned to their size. In Rust, representation structures have alignment according
    to the largest field. Consider the following struct:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在内存中的具体布局取决于选择的表现形式。默认情况下，Rust中的所有内容都是 `repr(Rust)`。所有 `repr(Rust)` 类型都按照2的幂次对字节边界对齐。每个类型在内存中至少占用一个字节，然后是两个，然后是四个，以此类推。原始类型——`u8`、`usize`、`bool`
    和 `&T`——都与其大小对齐。在Rust中，表示结构体的对齐方式取决于最大的字段。考虑以下结构体：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`AGC` is aligned to `u32` with padding inserted as appropriate to match that
    32-bit alignment. Rust will re-order fields to achieve maximal packing. Enums
    are different, being subject to a host of optimizations, most notably null pointer
    optimization. See the following enumeration:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`AGC` 与 `u32` 对齐，并插入适当的填充以匹配32位对齐。Rust将重新排序字段以实现最大打包。枚举不同，受到大量优化的影响，最值得注意的是空指针优化。请参见以下枚举：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will be laid out as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按照以下方式布局：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `data` field is wide enough to accommodate the largest inner value and the
    `tag` allows discrimination between variants. Where this gets complicated is in
    the case of an enum that holds a non-nullable pointer, and other variants cannot
    refer to the same. `Option<&T>` means if a null pointer is discovered when dereferencing
    the option Rust can assume that the `None` variant was discovered. Rust will optimize
    away the tag for `Option<&T>`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`字段足够宽，可以容纳最大的内部值，而`tag`允许区分不同的情况。当涉及到一个包含非空指针的枚举时，情况会变得复杂，其他情况不能引用相同的指针。`Option<&T>`表示如果在取消引用选项时发现空指针，Rust可以假设发现了`None`情况。Rust会优化掉`Option<&T>`的标签。'
- en: Rust supports other representations. `repr(C) ` lays out types in memory in
    a manner that C would do and is often used in FFI projects, as we'll see later
    in this book. `repr(packed)` lays types out in memory like `repr(Rust)` except
    that no padding is added, and alignment occurs only to the byte. This representation
    is likely to cause unaligned loads and a severe effect on performance of common
    CPUs, certainly the two CPU architectures we concern ourselves with in this book.
    The remaining representations have to do with forcing the size of fieldless enumerations—that
    is, enumerations that have no data in their variants—and these are useful for
    forcing the size of such an enum with an eye towards ABI compatability.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Rust支持其他表示形式。`repr(C)`以C语言的方式在内存中布局类型，常用于FFI项目，我们将在本书后面的内容中看到。`repr(packed)`以`repr(Rust)`类似的方式布局类型，但不会添加填充，对齐仅发生在字节级别。这种表示形式可能会引起未对齐的加载，并对常见CPU的性能产生严重影响，特别是本书中我们关注的两种CPU架构。其余的表示形式与强制无字段枚举的大小有关——即没有数据在其变体中的枚举——这些表示形式对于确保与ABI兼容性有关的大小非常有用。
- en: 'Rust allocations happen by default on the hardware stack, as is common for
    other low-level languages. Heap allocations must be performed explicitly by the
    programmer or be done implicitly when creating a new type that holds some sort
    of internal storage. There are complications here. By default, Rust types obey
    move semantics: the bits of the type are moved as appropriate between contexts.
    For example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的分配默认发生在硬件栈上，这与其他底层语言的做法相同。堆分配必须由程序员显式执行，或者当创建一个包含某种内部存储的新类型时隐式执行。这里有一些复杂性。默认情况下，Rust类型遵循移动语义：类型位在上下文之间适当地移动。例如：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `project_flights` function allocates a new `Vec<(u16, u8)>` on the heap,
    populates it, and then returns ownership of the heap-allocated vector to the caller.
    This does not mean that the bits of `t` are copied from the stack frame of `project_flights`
    but, instead, that the pointer  `t` is returned from the `project_flights` stack
    to `main`. It is possible to achieve copy semantics in Rust through the use of
    the `Copy` trait. `Copy` types will have their bits copied in memory from one
    place to the other. Rust primitive types are `Copy`—copying them is as fast as
    moving them, especially when the type is smaller than the native pointer. It''s
    possible to implement `Copy` for your own type unless your type implements `Drop`,
    the trait that defines how a type deallocates itself. This restriction eliminates—in
    Rust code not using `unsafe` —the possibility of double frees. The following code
    block derives `Copy` for two user-defined types and is an example of a poor random
    generator:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`project_flights`函数在堆上分配一个新的`Vec<(u16, u8)>`，填充它，然后将堆分配的向量所有权返回给调用者。这并不意味着`t`的位从`project_flights`的栈帧中复制过来，而是指针`t`从`project_flights`的栈返回到`main`。在Rust中，可以通过使用`Copy`特质来实现复制语义。`Copy`类型将在内存中从一个地方复制到另一个地方。Rust的原始类型是`Copy`——复制它们与移动它们一样快，特别是当类型小于本地指针时。除非你的类型实现了`Drop`特质（定义了类型如何释放自身），否则可以实现你自己的类型的`Copy`。这个限制在Rust代码（不使用`unsafe`）中消除了双重释放的可能性。以下代码块为两个用户定义的类型推导了`Copy`，是一个糟糕的随机生成器的示例：'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pointers to memory
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存指针
- en: 'Rust defines several kinds of pointers, each with a specific purpose. `&T`
    is a shared reference and there may be many duplicates of that shared reference.
    The owner of `&T` does not necessarily, own `T` and may not modify it. Shared
    references are immutable. Mutable references—written `&mut T`—also do not imply
    that the other  `&mut T` owns `T` necessarily but the reference may be used to
    mutate `T`. There may be only one reference for any `T` with a `&mut T`. This
    complicates some code but means that Rust is able to prove that two variables
    do not overlap in memory, unlocking a variety of optimization opportunities absent
    from C/C++. Rust references are designed so that the compiler is able to prove
    the liveness of the referred to type: references cannot dangle. This is not true
    of Rust''s raw pointer types—`*const T` and `*mut T`—which work analogously to
    C pointers: they are, strictly, an address in memory and no guarantees about the
    data at that address are made. As such, many operations on raw pointers require
    the `unsafe` keyword and they are almost always seen solely in the context of
    performance-sensitive code or FFI interfaces. Put another way, a raw pointer may
    be null; a reference may never be null.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 定义了几种指针类型，每种都有特定的用途。`&T` 是一个共享引用，可能会有许多该共享引用的副本。`&T` 的拥有者不一定拥有 `T`，并且可能无法修改它。共享引用是不可变的。可变引用——写成
    `&mut T`——也不一定意味着其他 `&mut T` 必然拥有 `T`，但引用可以用来修改 `T`。对于任何 `T`，可能只有一个 `&mut T` 引用。这使某些代码变得复杂，但意味着
    Rust 能够证明两个变量在内存中不重叠，从而解锁了 C/C++ 中不存在的各种优化机会。Rust 引用被设计成编译器能够证明所引用类型的活性：引用不能悬空。这不是
    Rust 的原始指针类型——`*const T` 和 `*mut T`——的工作方式，它们与 C 指针类似：它们严格上是内存中的一个地址，对该地址的数据不提供任何保证。因此，许多原始指针的操作都需要
    `unsafe` 关键字，并且它们几乎总是仅在性能敏感的代码或 FFI 接口上下文中出现。换句话说，原始指针可能为空；引用永远不会为空。
- en: 'The rules around references often cause difficulty in situations where an immutable
    borrow is accidentally made of a mutable reference. The Rust documentation uses
    the following small program to illustrate the difficulty:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于引用的规则通常会在意外地对可变引用进行不可变借用的情况下引起困难。Rust 文档使用以下小型程序来展示这种困难：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `println!` macro takes its arguments by reference, implicitly here, creating
    a `&x`. The compiler rejects this program as `y: &mut u8` is invalid. Were this
    program to compile, we would be subject to a race between the update of `y` and
    the read of `x`, depending on the CPU and memory ordering. The exclusive nature
    of references could be potentially limiting when working with structures. Rust
    allows programs to split borrows for a structure, providing that the disjoint
    fields cannot be aliased.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`println!` 宏通过引用接收其参数，在这里隐式地创建了一个 `&x`。编译器拒绝了这个程序，因为 `y: &mut u8` 是无效的。如果这个程序能够编译，我们就会面临
    `y` 的更新和 `x` 的读取之间的竞争条件，这取决于 CPU 和内存排序。当与结构一起工作时，引用的排他性可能会限制潜在的应用。Rust 允许程序分割结构的借用，只要不重叠的字段不能被别名。'
- en: 'We demonstrate this in the following brief program:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下简短的程序中展示了这一点：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This same trick is difficult to impossible for general container types. Consider
    a map where two keys map to the same referenced `T`. Or, for now, a slice:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技巧对于通用容器类型来说很难甚至不可能实现。考虑一个映射，其中两个键映射到相同的引用 `T`。或者，现在考虑一个切片：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This program fails to compile with the following error:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序编译失败，错误如下：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We, the programmers*,* know that this was safe—`gemini_2` and `gemini_12` don''t
    overlap in memory—but it''s not possible for the compiler to prove this. What
    if we had done the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们，程序员，知道这是安全的——`gemini_2` 和 `gemini_12` 在内存中不重叠——但是编译器无法证明这一点。如果我们做了以下操作：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By definition, `missions[0]` and `missions[1]` overlap in memory. We, the programmers,
    know we're breaking the aliasing rules and the compiler, being conservative, assumes
    that the rules are being broken.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，`missions[0]` 和 `missions[1]` 在内存中重叠。我们，程序员，知道我们正在违反别名规则，而编译器出于保守考虑，假设规则正在被违反。
- en: Allocating and deallocating memory
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配和释放内存
- en: 'Deallocation happens in one of two ways, depending on whether the type is allocated
    on the stack or the heap. If it''s on the stack, the type is deallocated when
    the stack frame itself ceases to exist. Each Rust stack frame comes into the world
    fully allocated but uninitialized and exits the world when its associated function
    exits. Heap allocated types are deallocated when the last valid binding moves
    out of scope, either through the natural flow of the program or by an explicit
    `std::mem::drop` being called by the programmer. The implementation of `drop`
    is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 分配释放可以通过两种方式之一发生，这取决于类型是在栈上还是在堆上分配的。如果是在栈上，当栈帧本身不再存在时，类型就会被释放。每个Rust栈帧都是完全分配但未初始化地来到这个世界，并在其关联的函数退出时离开这个世界。堆分配的类型在最后一个有效的绑定移出作用域时被释放，无论是通过程序的正常流程还是通过程序员显式调用的`std::mem::drop`。`drop`的实现如下：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The value `_x` is moved into `drop` —meaning there are no other borrows of `_x`—and
    then immediately falls out of scope when `drop` exits. An explicit `drop` is not
    able to remove items from scope, however, so subtle interactions with structures
    where the Rust compiler is not able to prove non-overlapping aliases and the like
    will happen. The `drop` documentation discusses several cases and it is worth
    reviewing that material.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`_x`的值被移动到`drop`中——这意味着没有其他对`_x`的借用——然后当`drop`退出时立即超出作用域。然而，显式`drop`不能从作用域中删除项目，因此与结构体的微妙交互将发生，在这些结构体中，Rust编译器无法证明非重叠别名等情况。`drop`文档讨论了几个案例，值得回顾这些材料。'
- en: Any Rust type that can be deallocated—meaning it is not `Copy`—will implement
    the `Drop` trait, a trait whose sole function is `drop(&mut self)`. `Drop::drop`
    cannot be called explicitly and is called when the type goes out of scope or is
    invocable by `std::mem::drop`, as discussed  previously.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以被释放的Rust类型——这意味着它不是`Copy`——都将实现`Drop`特质，这是一个只有一个函数`drop(&mut self)`的特质。`Drop::drop`不能被显式调用，当类型超出作用域或可以被`std::mem::drop`调用时，它就会被调用，正如之前讨论的那样。
- en: 'So far in this chapter, we''ve discussed the layout of types in memory and
    allocation on the heap but without fully discussing how allocation itself works
    in the Rust memory model. The simplest way of forcing a heap allocation is with
    `std::boxed::Box`. In fact, the Rust documentation for `Box`—which is also just
    called box—describes it as the simplest form of heap allocation in Rust. That
    is, a `Box<T>` allocates enough space on the heap for a type `T` and acts as the
    owner of that allocation. When the box is dropped, the drop of `T` occurs. Here''s
    the definition of `Box<T>` straight from the standard library, in the file `src/liballoc/boxed.rs`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们讨论了内存中类型的布局和在堆上的分配，但没有完全讨论Rust内存模型中分配本身是如何工作的。强制堆分配的最简单方法就是使用`std::boxed::Box`。实际上，Rust对`Box`的文档——也简称为box——将其描述为Rust中最简单的堆分配形式。也就是说，`Box<T>`在堆上为类型`T`分配足够的空间，并作为该分配的所有者。当box被丢弃时，`T`的丢弃就会发生。以下是`Box<T>`的定义，直接来自标准库，在文件`src/liballoc/boxed.rs`中：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The size of a type
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型的大小
- en: 'There''s two important things here we have not come across yet in this book—`Sized`
    and `Unique`. First, `Sized`, or more properly, `std::marker::Sized`. `Sized`, is
    a Rust `trait` that bounds a type to have a known size at compile time. Almost
    everything in Rust has an implicit `Sized` bound, which we can inspect. For instance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的事情我们在这本书中还没有遇到——`Sized`和`Unique`。首先，`Sized`，或者更准确地说，`std::marker::Sized`。`Sized`是Rust的一个`trait`，它将类型约束为在编译时具有已知的大小。在Rust中几乎所有的东西都有一个隐式的`Sized`约束，我们可以检查它。例如：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`u8` is a single byte, Project is the byte to distinguish the enum variants
    plus the inner mission byte, pointers are the size of a machine word–a `usize-`
    and a `Vec<T>` is guaranteed to be a pointer and two `usize` fields no matter
    the size of `T`. There''s something interesting going on with `Vec<T>` and we''ll
    get into it in depth later in this chapter. Note that we said almost everything
    in Rust has an implicit `Sized` bound. Rust supports *dynamically sized types*,
    these being types that have no known size or alignment. Rust requires known size
    and alignment and so all DSTs must exist behind a reference or pointer. A slice—a
    view into contiguous memory—is one such type. In the following program, the compiler
    will not be able to determine the size of the slice of values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`u8` 是一个字节，Project 是用于区分枚举变体的字节以及内部任务字节，指针是机器字的大小——一个 `usize`，而 `Vec<T>` 保证是一个指针和两个
    `usize` 字段，无论 `T` 的大小如何。`Vec<T>` 和 `T` 之间有一些有趣的事情发生，我们将在本章后面深入探讨。请注意，我们几乎在 Rust
    中说到了所有东西都有一个隐式的 `Sized` 约束。Rust 支持 *动态大小类型*，这些类型没有已知的大小或对齐。Rust 需要已知的大小和对齐，因此所有
    DSTs 都必须位于引用或指针之后。切片——对连续内存的视图——就是这样一种类型。在以下程序中，编译器将无法确定值的切片的大小：'
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Slices are a view into a block of memory represented as a pointer and a length*, as
    the documentation for the primitive type slice puts it. The trick is that the
    length is determined at runtime. The following program will compile:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*切片是内存块的一种视图，该内存块以指针和长度表示，正如原始类型切片的文档所述*。技巧在于长度是在运行时确定的。以下程序将能够编译：'
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, the previous code will panic at runtime:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，之前的代码在运行时会引发恐慌：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Rust allows programmers to include DSTs as the last field of a `struct`, like
    so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许程序员将 DSTs（可变大小类型）作为 `struct` 的最后一个字段，如下所示：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, this causes the struct itself to become a DST.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会导致结构体本身成为 DST。
- en: Static and dynamic dispatch
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态和动态分发
- en: 'Trait objects likewise have no statically known size in Rust. Trait objects
    are the mechanism by which Rust performs dynamic dispatch. Preferentially, Rust
    is a static dispatch language as there are increased opportunities for inlining
    and optimization—the compiler simply knows more. Consider the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，特质对象同样没有静态已知的大小。特质对象是 Rust 执行动态分发的方式。优先考虑 Rust 是一种静态分发语言，因为存在更多的内联和优化机会——编译器知道得更多。考虑以下代码：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we define a function, `sd_add<T: Add<Output=T>>(x: T, y: T) -> T`. Rust,
    like C++, will perform monomorphization at compile time, emitting two `sd_add`
    functions, one for `u8` and the other for `u64`. Like C++, this potentially increases
    the code size of a Rust program and slows compilation but at the benefit of allowing
    inlining at the caller site, potentially more efficient implementations owing
    to type specialization, and fewer branches.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，我们定义了一个函数，`sd_add<T: Add<Output=T>>(x: T, y: T) -> T`。Rust，就像 C++ 一样，将在编译时进行单态化，生成两个
    `sd_add` 函数，一个用于 `u8`，另一个用于 `u64`。像 C++ 一样，这可能会增加 Rust 程序的代码大小并减慢编译速度，但好处是在调用者位置允许内联，由于类型特化，可能更有效的实现，以及更少的分支。'
- en: When static dispatch is not desirable, the programmer can construct trait objects
    to perform dynamic dispatch. Trait objects do not have a known size—indeed, they
    can be any `T` that implements the trait—and so, like slices, must exist behind
    a kind of pointer. Dynamic dispatch will not see much use in this book. The reader
    is warmly encouraged to consult the documentation for `std::raw::TraitObject`
    for full details on Rust's trait object notion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当静态分发不可取时，程序员可以构建特质对象以执行动态分发。特质对象没有已知的大小——实际上，它们可以是实现该特质的任何 `T` 类型——因此，就像切片一样，必须位于某种指针之后。在这本书中，动态分发不会得到太多应用。强烈建议读者查阅
    `std::raw::TraitObject` 的文档，以获取 Rust 特质对象概念的详细信息。
- en: Zero sized types
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零大小类型
- en: 'Rust also supports *zero sized types* or ZSTs; structs with no fields, the
    unit type `()`, or arrays with no size are all zero sized. The fact that the type
    has no size is a boon to optimization and dead-tree removal. Rust APIs often include
    return types like so: `Result<(), a_mod::ErrorKind>`. This type signals that while
    the function may error, its return value in the happy path is the unit type. These
    types are somewhat rare in practice but unsafe, and Rust must be aware of them.
    Many allocators return null when asked to allocate zero bytes—making the allocation
    of a ZST indistinguishable from the allocator being unable to find free memory—and
    pointer offsets from a ZST are of zero offset. Both of these considerations will
    be important in this chapter.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Rust还支持*零大小类型*或ZST；没有字段的struct、单位类型`()`或没有大小的数组都是零大小的。类型没有大小的事实对优化和死树移除是一个福音。Rust
    API通常包括如下返回类型：`Result<(), a_mod::ErrorKind>`。这种类型表示，虽然函数可能会出错，但在正常路径下的返回值是单位类型。这些类型在实践中相对较少，但它们是不安全的，Rust必须意识到它们。许多分配器在请求分配零字节时返回空指针——使得ZST的分配与分配器无法找到空闲内存的情况无法区分——并且从ZST的指针偏移量为零。这两个考虑因素在本章中都将非常重要。
- en: Boxed types
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带框的类型
- en: 'That''s the trait `Sized`, but what does `?Sized` mean? The `?` flags the relevant
    trait as optional. So, a box is a type in Rust parameterized over some other type
    `T` which may or may not have a size. A box is a kind of a pointer to heap allocated
    storage. Let''s look into its implementation further. What of `Unique<T>`? This
    type is a signal to the Rust compiler that some `*mut T` is non-null and that
    the unique is the sole owner of `T`, even though `T` was allocated outside the
    `Unique`. `Unique` is defined like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那是`Sized`特性，但`?Sized`是什么意思呢？`?`标志表示相关的特性是可选的。因此，一个框是Rust中参数化其他类型`T`的类型，`T`可能具有大小也可能不具有大小。一个框是一种指向堆分配存储的指针。让我们进一步看看它的实现。`Unique<T>`又是怎么回事呢？这个类型是向Rust编译器发出信号，表示某些`*mut
    T`是非空的，并且唯一所有者是`T`，即使`T`是在`Unique`外部分配的。`Unique`的定义如下：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`NonZero<T>` is a struct that the `rustc` source describes as a wrapper type
    for raw pointers and integers that will never be `NULL` or `0` that might allow
    certain optimizations. It''s annotated in a special way to admit those null pointer
    optimizations discussed elsewhere in this chapter. Unique is also of interest
    for its use of `PhantomData<T>`. `PhantomData` is, in fact, a zero sized type,
    defined as `pub struct PhantomData<T:?Sized>;`. This type instructs the Rust compiler
    to consider `PhantomData<T>` as owning `T` even though, ultimately, there''s nowhere
    for `PhantomData` to store its newfound `T`. This works well for `Unique<T>`,
    which must take ownership of `<T>` by maintaining a non-zero constant pointer
    to `T` but does not, itself, have `T` stored anywhere other than in the heap.
    A box is then, a unique, non-null pointer to a thing allocated somewhere in memory
    but not inside the storage space of the box.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`NonZero<T>`是一个`rustc`源代码描述为原始指针和整数的包装类型，这些指针和整数永远不会是`NULL`或`0`，这可能会允许某些优化。它以特殊方式注释，以允许本章其他地方讨论的空指针优化。`Unique`也因其使用`PhantomData<T>`而引起兴趣。实际上，`PhantomData`是一个零大小类型，定义为`pub
    struct PhantomData<T:?Sized>;`。此类型指示Rust编译器将`PhantomData<T>`视为拥有`T`，尽管最终`PhantomData`无处存储其新发现的`T`。这对于必须通过维护指向`T`的非零常量指针来拥有`<T>`的`Unique<T>`来说效果很好，但它本身并不在除堆以外的任何地方存储`T`。因此，一个框是一个唯一的、非空的指针，指向内存中某个地方分配的东西，但不在框的存储空间内。'
- en: 'The internals of box are compiler intrinsics: they sit at the interplay of
    the allocator and are a special consideration in Rust''s borrow checker. With
    that in mind, we will avoid chasing down the internal details of `Box` as they
    will change from compiler version to compiler version and this book is explicitly
    not a `rustc` internals book. For our purposes, however, it is worth considering
    the API exposed by box. The key functions are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 框的内部是编译器内建函数：它们位于分配器和借用检查器之间的交互中，在Rust的借用检查器中是一个特殊考虑。考虑到这一点，我们将避免深入挖掘`Box`的内部细节，因为它们会随着编译器版本的更新而变化，而这本书明确不是一本关于`rustc`内部机制的书籍。然而，就我们的目的而言，考虑由框暴露的API是有价值的。关键函数包括：
- en: '`fn from_raw(raw: *mut T) -> Box<T>`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn from_raw(raw: *mut T) -> Box<T>`'
- en: '`fn from_unique(u: Unique<T>) -> Box<T>`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn from_unique(u: Unique<T>) -> Box<T>`'
- en: '`fn into_raw(b: Box<T>) -> *mut T`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn into_raw(b: Box<T>) -> *mut T`'
- en: '`fn into_unique(b: Box<T>) -> Unique<T>`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn into_unique(b: Box<T>) -> Unique<T>`'
- en: '`fn leak<''a>(b: Box<T>) -> &''a mut T`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn leak<''a>(b: Box<T>) -> &''a mut T`'
- en: 'Both `from_raw` and `from_unique` are unsafe. Conversion from a raw pointer
    is unsafe if a raw pointer is *boxed* more than once or if a box is made from
    a pointer that overlaps with another, as examples. There are other possibilities.
    Conversion from a `Unique<T>` is unsafe as the `T` may or may not be owned by  `Unique`,
    resulting in a possibility of the box not being the sole owner of its memory.
    The `into_*` functions, however, are safe in the sense that the resulting pointers
    will be valid but the caller will not have full responsibility for managing the
    lifetime of the memory. The `Box` documentation notes that the caller can release
    the memory themselves or convert the pointer back into the type they came from
    and allow Rust to do it for them. The latter is the approach this book will take.
    Finally, there''s `leak`. Leak is a fun one and is not available on stable channel
    but is worth discussing for applications that will ship to embedded targets. A
    common memory management strategy for embedded systems is to pre-allocate all
    necessary memory and only operate on that memory for the lifetime of the program.
    In Rust, this is trivially accomplished if you desire uninitialized memory of
    a constant size: arrays and other primitive types. In the event you desire heap
    allocations at the start of your program, the situation is more complicated. That''s
    where leak comes in: it causes memory to leak from a box—a heap allocation—to
    wherever you please. When the leaked memory is intended to live for the lifetime
    of the program—into the `static` lifetime—there''s no issue. An example  is as
    follows, straight from the docs for `leak:`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_raw` 和 `from_unique` 都是 unsafe 的。如果原始指针被 *boxed* 多次，或者如果从一个与另一个重叠的指针创建了一个
    box，那么从原始指针的转换是不安全的，例如。还有其他可能性。从 `Unique<T>` 的转换是不安全的，因为 `T` 可能或可能不被 `Unique`
    所拥有，从而导致 box 不是其内存的唯一所有者。然而，`into_*` 函数是安全的，因为生成的指针将是有效的，但调用者不会对管理内存的生命周期承担全部责任。`Box`
    文档指出，调用者可以自己释放内存或将指针转换回它们原来的类型，并允许 Rust 为他们处理。本书将采用后一种方法。最后，还有 `leak`。`leak` 是一个有趣的概念，但在稳定渠道上不可用，但对于将软件部署到嵌入式目标的应用程序来说值得讨论。嵌入式系统的一种常见内存管理策略是在程序的生命周期内预分配所有必要的内存，并且只在该内存上操作。在
    Rust 中，如果你想要一个固定大小的未初始化内存：数组和其他原始类型，这是微不足道的。如果你在程序开始时需要堆分配，情况就更加复杂了。这就是 `leak`
    的作用：它使内存从 box（堆分配）泄漏到任何你想要的地方。当泄漏的内存打算在程序的生命周期内存在——进入 `static` 生命周期——就没有问题。以下是一个例子，直接来自
    `leak` 的文档：'
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we see a new `usize` allocated on the heap, leaked into `static_ref`—a
    mutable reference of static lifetime—and then fiddled with through the remaining
    lifetime of the program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到在堆上分配了一个新的 `usize`，泄漏到 `static_ref`——一个具有静态生命周期的可变引用——然后在整个程序的生命周期内对其进行操作。
- en: Custom allocators
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义分配器
- en: It is possible to plug in one's own allocator to Rust, as can be done in C++
    or similar system-level programming languages. By default, on most targets, Rust
    uses jemalloc with a backup alternative to the system-provided allocator. In embedded
    applications, there may not *be* a system, let alone an allocator, and the interested
    reader is recommended to peruse RFC 1183 ([https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md](https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md)),
    RFC 1398 ([https://github.com/rust-lang/rfcs/pull/1398](https://github.com/rust-lang/rfcs/pull/1398)),
    and related RFCs. As of writing this, an interface for plugging in custom allocators
    to stable Rust is under active discussion and any such capability is only available
    in nightly Rust. We will not make use of custom allocators in this book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将自定义分配器插入 Rust，就像在 C++ 或类似的系统级编程语言中做的那样。默认情况下，在大多数目标上，Rust 使用 jemalloc，并有一个系统提供的分配器的后备替代方案。在嵌入式应用程序中，可能没有系统，更不用说分配器了，因此建议感兴趣的读者查阅
    RFC 1183 ([https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md](https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md))、RFC
    1398 ([https://github.com/rust-lang/rfcs/pull/1398](https://github.com/rust-lang/rfcs/pull/1398))
    以及相关的 RFC。截至撰写本文时，将自定义分配器插入稳定 Rust 的接口正在积极讨论中，并且此类功能仅在 nightly Rust 中可用。本书将不会使用自定义分配器。
- en: Implementations
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: In [Chapter 2](8c61da2f-08c8-40be-89d4-d8afa8510850.xhtml), *Sequential Rust
    Performance and Testing,* we very briefly dipped into the implementation of `std::collections::HashMap`.
    Let's continue with that approach of dissecting the standard library, paying special
    attention to the concerns of memory that pop up.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](8c61da2f-08c8-40be-89d4-d8afa8510850.xhtml)，“顺序Rust性能和测试”中，我们非常简要地探讨了`std::collections::HashMap`的实现。让我们继续以这种方式剖析标准库，特别关注出现的内存问题。
- en: Option
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Option
- en: 'Let''s examine `Option<T>`. We''ve already discussed `Option<T>` in this chapter;
    that it''s subject to *null pointer optimization* on account of its empty `None`
    variant in particular. `Option` is as simple as you might imagine, being defined
    in `src/libcore/option.rs`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`Option<T>`。我们已经在本章中讨论了`Option<T>`；它由于特别空的`None`变体而受到*空指针优化*的影响。`Option`就像你可能想象的那样简单，它在`src/libcore/option.rs`中定义：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As is often the case with Rust internals, there are a great deal of flags around
    to control when and where new features land in which channel and how documentation
    is generated. A slightly tidier expression of `Option<T>` is:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Rust内部经常发生的那样，有许多标志用于控制新功能何时何地出现在哪个通道中，以及如何生成文档。`Option<T>`的一个稍微整洁的表达式是：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is refreshingly simple, much like how you may have implemented an option
    type yourself up on first thinking of it. `Option` is the owner of its inner `T`
    and is able to pass out references to that inner data per the usual restrictions.
    As an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，就像你第一次想到它时可能实现选项类型一样。`Option`是其内部`T`的所有者，并且能够根据通常的限制传递对该内部数据的引用。例如：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Rust exposes a special trait type inside each `trait: Self`. It desugars simply
    to the referent trait type, in this case, `Option<T>`. The `&mut self` is shorthand
    for `self: &mut Self`, as is `&self` for `self: &Self` . `as_mut`  is then allocating
    a new option whose inner type is a mutable reference to the original inner type.
    Now, consider the humble `map`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rust在每个`trait: Self`内部暴露一个特殊的特质类型。它简单地解糖为引用特质类型，在这种情况下，`Option<T>`。`&mut self`是`self:
    &mut Self`的缩写，同样`&self`是`self: &Self`的缩写。`as_mut`随后分配一个新的选项，其内部类型是原始内部类型的可变引用。现在，考虑一下谦逊的`map`：'
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Rust allows closures as arguments to functions. In this way, Rust is similar
    to higher-level and, especially, functional programming languages. Unlike these
    higher-level programming languages, Rust has restrictions on closures in terms
    of the way *variable capture* occurs and with regard to call totals and mutability.
    Here, we see the `FnOnce` trait being used, restricting the closure being passed
    in as `f` to the map function as being single-use. The function traits, all defined
    in `std::ops`, are:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Rust允许将闭包作为函数的参数。通过这种方式，Rust与高级语言，尤其是函数式编程语言相似。与这些高级编程语言不同，Rust对闭包的捕获方式、调用总数和可变性有约束。在这里，我们看到`FnOnce`特质被用来限制传递给map函数的闭包`f`为单次使用。函数特质，所有都在`std::ops`中定义，如下所示：
- en: '`Fn`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fn`'
- en: '`FnMut`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FnMut`'
- en: '`FnOnce`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FnOnce`'
- en: 'The first trait, `Fn`, is described by the Rust documentation as being a *call
    operator that takes an immutable receiver*. This is maybe a little obscure until
    we look at the definition of `Fn` in `src/libcore/ops/function.rs`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个特质`Fn`，Rust文档描述为是一个*接受不可变接收者的调用操作符*。这可能有点难以理解，直到我们查看`src/libcore/ops/function.rs`中`Fn`的定义：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now it''s more obscure! But, we can work that back. `Args` is distinct from
    `std::env::Args` but plays a similar role of being a placeholder for function
    arguments, save at a type-level. `: FnMut<Args>` means that the `FnMut<Args>`
    is a *supertrait* of `Fn<Args>:` all of the methods available to `FnMut` are available
    to `Fn` when used as a trait object. Recall that trait objects find use in dynamic
    dispatch, discussed previously. This also means that any instance of `Fn` can
    be used where an `FnMut` is expected, in cases of static dispatch. Of particular
    interest to understanding `Fn` is:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '现在它更难以理解了！但是，我们可以回溯。`Args`与`std::env::Args`不同，但扮演着类似的角色，即作为函数参数的占位符，只是在类型级别上。`:
    FnMut<Args>`意味着`FnMut<Args>`是`Fn<Args>`的*超特质*：所有`FnMut`的方法在用作特质对象时都可用。回想一下，特质对象在之前讨论的动态调度中找到了用途。这也意味着在静态调度的情况下，任何`Fn`的实例都可以用在期望`FnMut`的地方。对理解`Fn`特别感兴趣的是：'
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll approach this in parts. Firstly, `extern "rust-call"`. Here, we are
    defining an inline extern block that uses the `"rust-call"` ABI. Rust supports
    many ABIs, three of which are cross-platform and guaranteed to be supported no
    matter the platform:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分部分来处理这个问题。首先，`extern "rust-call"`。在这里，我们定义了一个使用 `"rust-call"` ABI 的内联 extern
    块。Rust 支持许多 ABIs，其中三个是跨平台的，并且无论平台如何都保证支持：
- en: '`extern "Rust" fn`, implicit for all Rust functions unless otherwise specified'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern "Rust" fn`，对于所有未指定其他情况的 Rust 函数是隐式的'
- en: '`extern "C" fn`, often used in FFI and shorthanded to `extern fn`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern "C" fn`，常用于 FFI，简写为 `extern fn`'
- en: '`extern "system" fn`, equivalent to `extern "C" fn` save for some special platforms'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern "system" fn`，相当于 `extern "C" fn`，但针对一些特殊平台'
- en: '`"rust-call"` does not appear in that list because it is a rust-specific ABI,
    which also includes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`"rust-call"` 不出现在该列表中，因为它是一个 Rust 特定的 ABI，它还包括：'
- en: '`extern "rust-intrinsic" fn`, specific to `rustc` intrinsics'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern "rust-intrinsic" fn`，特定于 `rustc` 内置函数'
- en: '`extern "rust-call" fn`, the ABI for all `Fn::call` functions'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern "rust-call" fn`，所有 `Fn::call` 函数的 ABI'
- en: '`extern "platform-intrinsic" fn`, which the documentation notes as being something
    the programmer should never have to deal with'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern "platform-intrinsic" fn`，文档指出程序员永远不需要处理的东西'
- en: 'Here, we''re signalling to the Rust compiler that the function is to be treated
    with a special call ABI. This particular `extern` is important when writing traits
    that implement the `Fn` trait, as box will when the unstable `fnbox` feature flag
    is enabled:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向 Rust 编译器发出信号，表示该函数应以特殊的调用 ABI 处理。当启用不稳定的 `fnbox` 功能标志时，这个特定的 `extern`
    在编写实现 `Fn` 特性的 traits 时非常重要，因为 `box` 也会这样做：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Secondly, `fn call(&self, args: Args)`. The implementing type is taken in as
    an immutable reference, in addition to the passed args; this is the immutable
    receiver mentioned in the documentation. The final piece here is `-> Self::Output`,
    the returned type after the call operator is used. This associated type defaults
    to `Self` but can be set by the implementer.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '其次，`fn call(&self, args: Args)`。实现类型以不可变引用的形式传入，除了传入的参数；这是文档中提到的不可变接收者。这里的最后一部分是
    `-> Self::Output`，这是在调用操作符使用后的返回类型。这个关联类型默认为 `Self`，但可以被实现者设置。'
- en: '`FnMut` is similar to `Fn` save that it takes `&mut self` rather than `&self`,
    and `FnOnce` is its supertrait:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`FnMut` 与 `Fn` 类似，只是它接受 `&mut self` 而不是 `&self`，而 `FnOnce` 是其超特化：'
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Only `FnOnce` deviates in its definition:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 `FnOnce` 在其定义中有所不同：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we see where `Self::Output` makes its appearance as an associated type
    and note that the implementations of `FnOnce` are in terms of `call_once` rather
    than `call.` Also, we now know that `FnOnce` is a supertrait of `FnMut`, which
    is a supertrait of `Fn` and it just so happens that this property is transitive:
    if an `FnOnce` is called for an `Fn`, it can be used. Much of the exact implementation
    of the function traits are kept internal to the compiler, the details of which
    kind of jump around some as internals change. In fact, the `"rust-call"`, `extern`
    means that `Fn traits` cannot be implemented outside of special, compiler-specific
    contexts; the exact feature flags that need to be enabled in a nightly build,
    their use, and upcoming changes are not documented. Happily, closures and function
    pointers implement function traits implicitly. For example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到 `Self::Output` 作为关联类型出现，并注意 `FnOnce` 的实现是以 `call_once` 而不是 `call` 为基础的。现在我们知道
    `FnOnce` 是 `FnMut` 的超特化，而 `FnMut` 是 `Fn` 的超特化，而且这个属性是传递的：如果对 `Fn` 调用 `FnOnce`，则可以使用它。函数特质的许多确切实现都保留在编译器内部，这些实现的细节会随着内部的变化而跳转。实际上，`"rust-call"`、`extern`
    的意思是指 `Fn traits` 不能在特殊、编译器特定的上下文中实现；需要启用在夜间构建中确切的功能标志、它们的用途和即将到来的更改并未记录。幸运的是，闭包和函数指针隐式地实现了函数特质。例如：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The compiler is good enough to figure out the details for us.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器足够智能，可以为我们找出细节。
- en: 'Conceptually, `Result<T>` is a type similar to `Option<T>`, save that it is
    able to communicate an extra piece of information in its `Err` variant. In fact,
    the implementation in `src/libcore/result.rs` is awfully similar to the way we''d
    likely write this at first though, as with `Option`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，`Result<T>` 是一个类似于 `Option<T>` 的类型，但它能够在其 `Err` 变体中传达额外的信息。实际上，`src/libcore/result.rs`
    中的实现与我们最初可能写的方式非常相似，尽管与 `Option` 类似：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Cell and RefCell
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cell 和 RefCell
- en: So far in this chapter, the mutable references we've been discussing have a
    property called, by Rust, inherited mutability. That is, values are made mutable
    when we inherit their ownership or the exclusive right—via a `&mut`—to mutate
    the value. Inherited mutability is preferred in Rust as it is statically enforcable—any
    defects in our program with regards to memory mutation will be caught at compilation
    time. Rust does provide facilities for interior mutability,  that being mutability
    that is available for pieces of an immutable type. The documentation calls interior
    mutability something of a last resort but, while not common, it is not exactly
    rare in practice, either. The two options for interior mutability in Rust are
    `Cell<T>` and `RefCell<T>`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们讨论的可变引用具有 Rust 所称的继承可变性的属性。也就是说，当我们继承其所有权或对值进行独占修改的权利——通过 `&mut`——时，值变得可变。在
    Rust 中，继承可变性是首选的，因为它在编译时是静态可强制执行的——我们程序中关于内存变异的任何缺陷都会在编译时被发现。Rust 提供了内部可变性的设施，即对不可变类型的一部分可用的可变性。文档将内部可变性称为一种最后的手段，但尽管不常见，在实践中也并不罕见。Rust
    中内部可变性的两种选择是 `Cell<T>` 和 `RefCell<T>`。
- en: 'Let''s consider `Cell<T>`. How is it used? As suggested, `Cell<T>` is useful
    when some field or fields of an otherwise immutable structure need to be mutable
    and the `T` you''re concerned with is `T: Copy`. Consider a graph structure where
    a search operation is performed. This is logically immutable—the graph structure
    does not need to be modified during search. But, also consider the case where
    we would like to record the total number of traversals along the graph''s edges.
    Our options are to violate the logical immutability of the graph search, require
    storage outside of the graph, or insert an interior, mutable counter into the
    graph. Which choice is best will depend on the specific situation. Here is a significantly
    less complicated example of `Cell<T>`, compared to a graph search:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们考虑 `Cell<T>`。它是如何使用的？正如建议的那样，`Cell<T>` 在某些字段或字段需要可变而您关心的 `T` 是 `T: Copy`
    时非常有用。考虑一个执行搜索操作的图结构。这在逻辑上是不可变的——在搜索过程中不需要修改图结构。但是，也考虑一下我们想要记录沿着图边沿的总遍历次数的情况。我们的选择是违反图搜索的逻辑不可变性、要求在图之外存储，或者将一个内部可变的计数器插入到图中。哪种选择最好将取决于具体情况。以下是一个
    `Cell<T>` 的例子，与图搜索相比，这个例子要简单得多：'
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Of course, that''s a bit contrived. Interior mutability shows up when the situation
    is non-trivial, generally speaking. Note that `Cell<u8>` had to be manipulated
    with `get` and `set` methods, contrary to the normal process of setting and reading
    directly or through a pointer. Let''s dig into the implementation of `Cell<T>`,
    defined in `src/libcore/cell.rs`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这有点人为。内部可变性通常在非平凡的情况下出现。请注意，`Cell<u8>` 必须通过 `get` 和 `set` 方法来操作，这与直接设置和读取或通过指针读取的正常过程相反。让我们深入探讨
    `Cell<T>` 的实现，它在 `src/libcore/cell.rs` 中定义：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As is common in Rust internals, a safe interface hides an unsafe inner core,
    as we saw in [Chapter 2](8c61da2f-08c8-40be-89d4-d8afa8510850.xhtml), *Sequential
    Rust Performance and Testing*, with `HashMap`. What is the definition of `UnsafeCell`?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 Rust 内部常见的那样，一个安全的接口隐藏了一个不安全的内部核心，正如我们在[第二章](8c61da2f-08c8-40be-89d4-d8afa8510850.xhtml)，“顺序
    Rust 性能和测试”中看到的那样，使用 `HashMap`。那么 `UnsafeCell` 的定义是什么？
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Of particular note is an implementation that follows shortly afterward:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是紧随其后的一个实现：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will discuss `Sync` in the following chapter in greater detail. Suffice
    it to say, for now, any type that is threadsafe must implement `Sync`—and many
    do automatically—and by disabling the `Sync` trait for `UnsafeCell<T>`—which is
    what `!Sync` means—the type is specifically being marked as not thread-safe. That
    is, any thread may be manipulating the data owned by `UnsafeCell` at any time.
    As we''ve previously discussed, Rust is able to make a good deal of optimizations
    off the back of the knowledge that `&T` is guaranteed to also not be mutable somewhere
    and that `&mut T` is unique. `UnsafeCell<T>` is the *only* method Rust provides
    to turn these compiler optimizations off; it is possible to dip into an unsafe
    block and transmute `&T` to `&mut T`, but this is specifically called out as undefined
    behavior. They key to `UnsafeCell<T>` is that it is possible for a client to retrieve
    multiple mutable references to the interior data, even if the `UnsafeCell<T>`
    is itself mutable. It is up to the caller to ensure that there is *only* one mutable
    reference at any time. The implementation of `UnsafeCell` —stripped of its comments
    for clarity''s sake—is brief:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地讨论 `Sync`。现在只需说，任何线程安全的类型都必须实现 `Sync`——许多类型会自动实现——通过禁用 `Sync` 特性为
    `UnsafeCell<T>`——即 `!Sync` 的含义——类型被特别标记为非线程安全。也就是说，任何线程都可以在任何时候操作 `UnsafeCell`
    所拥有的数据。正如我们之前讨论的，Rust 能够利用 `&T` 保证不会在任何地方是可变的以及 `&mut T` 是唯一的这一知识进行大量的优化。`UnsafeCell<T>`
    是 Rust 提供的 *唯一* 一种关闭这些编译器优化方法；虽然可以进入一个不安全块并将 `&T` 转换为 `&mut T`，但这被明确指出是未定义的行为。`UnsafeCell<T>`
    的关键是，客户端可以检索到多个对内部数据的可变引用，即使 `UnsafeCell<T>` 本身是可变的。确保在任何时候只有一个可变引用的责任在于调用者。`UnsafeCell`
    的实现——为了清晰起见，去掉了注释——是简短的：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This brings us back to `Cell<T>`. We know that `Cell<T>` is built on top of
    an unsafe abstraction and we will have to take care not to violate the `&mut T`
    uniqueness constraint. How is this done? First, construction of `Cell<T>` is straightforward,
    as you may expect:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这又带我们回到了 `Cell<T>`。我们知道 `Cell<T>` 是建立在不安全抽象之上的，我们必须要小心不要违反 `&mut T` 的唯一性约束。这是如何做到的？首先，`Cell<T>`
    的构建是直接的，正如你所期望的：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `const fn` is likely a surprise, on account of it being a nightly-only
    feature as of writing this book. In Rust, a constant function is evaluated at
    compile time. The benefit to the programmer of this particular definition is that
    the result of `Cell::new` can be assigned to a constant variable, one which will
    exist for the lifetime of the program. Both `as_ptr` and `get_mut` are different
    views of the underlying `T`, one a raw mutable pointer and the other a mutable
    reference:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`const fn` 可能会让人感到意外，因为截至撰写本书时，它是一个仅在夜间构建版本中存在的特性。在 Rust 中，常量函数是在编译时进行评估的。这种特定定义对程序员的益处在于，`Cell::new`
    的结果可以被分配给一个常量变量，这个变量将存在于程序的整个生命周期中。`as_ptr` 和 `get_mut` 是对底层 `T` 的不同视图，一个是原始可变指针，另一个是可变引用：'
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that while the internals of `get_mut` are unsafe, the borrow checker is
    brought to bear on the problem of keeping `&mut T` unique and so `Cell::get_mut`
    can itself be safe. `Cell::as_ptr` is not marked as unsafe—it''s safe to receive
    a raw pointer in Rust—but any caller will have to do deferencing of that raw pointer
    in an unsafe block: it''s possible that there will be more than one raw, mutable
    pointer floating around. Setting a new value into the cell is done in terms of
    replacement, discussed ahead, but with careful attention made towards forcefully
    dropping the `T` pulled from the cell:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然 `get_mut` 的内部是不安全的，但借用检查器被用来处理保持 `&mut T` 唯一性的问题，因此 `Cell::get_mut` 本身可以是安全的。`Cell::as_ptr`
    没有标记为不安全——在 Rust 中接收原始指针是安全的——但任何调用者都必须在一个不安全块中对那个原始指针进行解引用：可能存在多个原始的可变指针在浮动。将新值设置到单元格中是通过替换来完成的，这将在后面讨论，但需要仔细注意强制丢弃从单元格中拉出的
    `T`：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Cell::swap` and `Cell::replace` are done in terms of the lower-level memory
    manipulation tools from `std::ptr` and `std::mem`. `swap` is intended to replace
    the interior of one cell with another. Its definition is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cell::swap` 和 `Cell::replace` 是基于 `std::ptr` 和 `std::mem` 的底层内存操作工具完成的。`swap`
    的目的是用一个单元格的内部替换另一个单元格的内部。其定义如下：'
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`swap` is done in terms of `std::ptr::swap`, a function documented as copying
    the memory through the raw pointers passed to it as arguments*.* You''ll note
    that `Cell::swap` is careful to avoid the `swap` if the passed `other` is equivalent
    to `self`. The reason for this becomes clear when we take a peek at the definition
    of `std::ptr::swap`, defined in `src/libcore/ptr.rs`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap` 是通过 `std::ptr::swap` 来实现的，这是一个被文档化的函数，它通过传递给它的原始指针作为参数来复制内存。你会注意到 `Cell::swap`
    小心避免当传递的 `other` 等同于 `self` 时的 `swap`。当我们查看 `std::ptr::swap` 的定义时，这个原因就变得清晰了，该定义位于
    `src/libcore/ptr.rs`：'
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The exact details of `copy_nonoverlapping` and copy are unimportant here, except
    in noting that swapping does require allocation of uninitialized space and copying
    back and forth from that space. It''s wise to avoid the work if you don''t have
    to do it. `Cell::replace` works along similar lines:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`copy_nonoverlapping` 和复制的确切细节并不重要，除了注意交换确实需要分配未初始化的空间，并从这个空间中来回复制。如果你不需要这样做，避免这项工作是很明智的。`Cell::replace`
    的工作方式类似：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`std::mem::replace` takes a `&mut T` and a `T` and then replaces the value
    at `&mut T` with the passed in `val`, returning the old value and dropping neither.
    The definition of `std::mem::replace` is in `src/libcore/mem.rs` and is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mem::replace` 接受一个 `&mut T` 和一个 `T`，然后将 `&mut T` 中的值替换为传入的 `val`，返回旧值，并且不丢弃。`std::mem::replace`
    的定义在 `src/libcore/mem.rs` 中，如下所示：'
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Chasing the definition of `swap` in the same module, we find it is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪同一模块中 `swap` 的定义，我们发现它是这样的：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`std::ptr::swap_nonoverlapping` is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::ptr::swap_nonoverlapping` 的定义如下：'
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, the private `std::ptr::swap_nonoverlapping_bytes` is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，私有的 `std::ptr::swap_nonoverlapping_bytes` 定义如下：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Whew! That's some rabbit hole. Ultimately, what we've discovered here is that
    `std::mem::replace` is defined in terms of block copies from one non-overlapping
    location in memory to another, a process which the Rust developers have tried
    to make as efficient as possible by exploiting LLVM's ability to optimize a bitwise
    operation on common processors in terms of SIMD instructions. Neat.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这真是一个兔子洞。最终，我们在这里发现的是 `std::mem::replace` 是通过在内存中一个非重叠位置到另一个位置的块复制来定义的，这个过程是通过利用
    LLVM 在通用处理器上优化位操作的能力，Rust 开发者试图使其尽可能高效。真不错。
- en: 'What of `RefCell<T>`? It too is a safe abstraction over `UnsafeCell<T>` except
    that the copy restriction of `Cell<T>` is lifted. This makes the implementation
    a touch more complicated, as we''ll see:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `RefCell<T>` 呢？它也是一个在 `UnsafeCell<T>` 之上的安全抽象，除了 `Cell<T>` 的复制限制被取消。这使得实现稍微复杂一些，正如我们将看到的：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Like `Cell, RefCell` has an inner unsafe value, that much is the same. What''s
    fun here is `borrow: Cell<BorrowFlag>`. `RefCell<T>` is a client of `Cell<T>`,
    which makes good sense considering that the immutable `RefCell` is going to need
    interior mutability to track the total number of borrows of its inner data. `BorrowFlag`
    is defined like so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '与 `Cell` 一样，`RefCell` 也有一个内部不安全值，这一点是相同的。有趣的是 `borrow: Cell<BorrowFlag>`。`RefCell<T>`
    是 `Cell<T>` 的客户端，这很有道理，因为不可变的 `RefCell` 将需要内部可变性来跟踪其内部数据的借用总数。`BorrowFlag` 的定义如下：'
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The implementation of `RefCell<T>` is like to that of `Cell<T>`. `RefCell::replace`
    is also implemented in terms of `std::mem::replace`, `RefCell::swap` in terms
    of `std::mem::swap`. Where things get interesting are the functions new to `RefCell`,
     which are those to do with borrowing. We''ll look at `try_borrow` and `try_borrow_mut`
    first as they''re used in the implementations of the other borrowing functions.
    `try_borrow` is defined like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`RefCell<T>` 的实现类似于 `Cell<T>`。`RefCell::replace` 也是通过 `std::mem::replace` 来实现的，`RefCell::swap`
    是通过 `std::mem::swap` 来实现的。有趣的地方在于 `RefCell` 中新出现的函数，这些是与借用相关的函数。我们将首先查看 `try_borrow`
    和 `try_borrow_mut`，因为它们被用于其他借用函数的实现。`try_borrow` 的定义如下：'
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With `BorrowRef` being as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`BorrowRef` 的定义如下：'
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`BorrowRef` is a structure that holds a reference to the borrow field of `RefCell<T>`.
    Creating a new `BorrowRef` depends on the value of that borrow; if the value is
    `WRITING` then no `BorrowRef` is created—`None` gets returned—and otherwise the
    total number of borrows are incremented. This achieves the mutual exclusivity
    of writing needed while allowing for multiple readers—it''s not possible for `try_borrow`
    to hand out a reference when a write reference is out for the same data. Now,
    let''s consider `try_borrow_mut`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`BorrowRef` 是一个结构，它持有 `RefCell<T>` 的借用字段的引用。创建一个新的 `BorrowRef` 依赖于那个借用的值；如果值是
    `WRITING`，则不会创建 `BorrowRef`——返回 `None`——否则，总的借用次数会增加。这实现了在需要写入时的互斥性，同时允许有多个读取者——当有写入引用时，`try_borrow`
    不可能分配一个引用。现在，让我们考虑 `try_borrow_mut`：'
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Again, we find an implementation in terms of another type, `BorrowRefMut`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们发现了一个基于另一种类型 `BorrowRefMut` 的实现：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The key, as with `BorrowRef`, is in `BorrowRefMut::new`. Here, we can see that
    if the inner borrow from `RefCell` is unused then the borrow is set to write,
    excluding any potential read references. Likewise, if there is a read reference
    in existence, the creation of a mutable reference will fail. And so, exclusive
    mutable references and multiple immutable references are held at runtime by abstracting
    over an unsafe structure that allows for the breaking of that guarantee.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点，就像 `BorrowRef` 一样，在于 `BorrowRefMut::new`。在这里，我们可以看到如果 `RefCell` 的内部借用未被使用，则借用被设置为写入，排除任何潜在的读取引用。同样，如果存在读取引用，创建可变引用将失败。因此，在运行时通过抽象一个允许打破该保证的不安全结构，我们持有排他性可变引用和多个不可变引用。
- en: Rc
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rc
- en: 'Now, let''s consider one last single-item container before we get into a multi-item
    container. We''ll look into `Rc<T>`, described by the Rust documentation as being
    a single-threaded reference-counting pointer. Reference counting pointers are
    distinct from the usual Rust references in that, while they are allocated on the
    heap as a `Box<T>`, cloning a reference counter pointer does not cause a new heap
    allocation, bitwise copy. Instead, a counter inside the `Rc<T>` is incremented,
    somewhat analogously as to the way `RefCell<T>` works. The drop of an `Rc<T>`
    reduces that internal counter and when the counter''s value is equal to zero,
    the heap allocation is released. Let''s take a peek inside `src/liballoc/rc.s`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们进入多项目容器之前，让我们考虑一个最后的单项目容器。我们将探讨由 Rust 文档描述的 `Rc<T>`，它是一个单线程引用计数的指针。引用计数指针与
    Rust 的常规引用不同，因为它们虽然作为 `Box<T>` 在堆上分配，但克隆引用计数指针不会导致新的堆分配，而是进行位拷贝。相反，`Rc<T>` 内部的计数器会增加，这在某种程度上类似于
    `RefCell<T>` 的工作方式。`Rc<T>` 的释放会减少内部计数器，当计数器的值等于零时，堆分配就会被释放。让我们看一下 `src/liballoc/rc.s`
    的内部结构：
- en: '[PRE52]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We''ve already encountered `PhantomData<T>` in this chapter, so we know that
    `Rc<T>` will not directly hold the allocation of `T`, but the compiler will behave
    as if it does. Also, we know that `T` may or may not be sized. The pieces we need
    to catch up on then are `RcBox<T>` and `Shared<T>.` Let''s inspect `Shared<T>`
    first. Its full name is `std::ptr::Shared<T>` and it''s the same kind of pointer
    as `*mut X` except that it is non-zero. There are two variants for creating a
    new `Shared<T>`, `const unsafe fn new_unchecked(ptr: *mut X) -> Self` and  `fn
    new(ptr: *mut X) -> Option<Self>`. In the first variant, the caller is responsible
    for ensuring that the pointer is non-null, and in the second the nulled nature
    of the pointer is checked, like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在本章中已经遇到了 `PhantomData<T>`，所以我们知道 `Rc<T>` 不会直接持有 `T` 的分配，但编译器会表现得好像它持有一样。我们还知道
    `T` 可能是有大小的，也可能不是。我们需要了解的片段是 `RcBox<T>` 和 `Shared<T>`。让我们首先检查 `Shared<T>`。它的全名是
    `std::ptr::Shared<T>`，它与 `*mut X` 类似的指针，除了它是非零的。创建新的 `Shared<T>` 有两种变体，`const
    unsafe fn new_unchecked(ptr: *mut X) -> Self` 和 `fn new(ptr: *mut X) -> Option<Self>`。在第一种变体中，调用者负责确保指针是非空的，而在第二种变体中，会检查指针是否为空，如下所示：'
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We find the definition and implementation of `NonZero<T>` in `src/libcore/nonzero.rs ` like
    so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `src/libcore/nonzero.rs` 中找到了 `NonZero<T>` 的定义和实现，如下所示：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`Zeroable` is an unstable trait, which is pretty straightforward:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zeroable` 是一个不稳定特质，它相当直接：'
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Every pointer type implements an `is_null() -> bool` and this trait defers
    to that function, and `NonZero::new` defers to `Zeroable::is_zero`. The presence
    of a `Shared<T>`, then, gives the programmer the same freedom as `*mut T` but
    with added guarantees about the pointer''s nullable situation. Jumping back up
    to `Rc::new`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指针类型都实现了一个`is_null() -> bool`函数，这个特性将调用该函数，而`NonZero::new`则委托给`Zeroable::is_zero`。因此，存在`Shared<T>`时，给程序员提供的自由度与`*mut
    T`相同，但增加了关于指针可空情况的额外保证。回到`Rc::new`：
- en: '[PRE56]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Box::into_unique` converts a `Box<T>` into a `Unique<T>`—discussed previously
    in this chapter—which is then converted into a `Shared<T>`. This chain preserves
    the non-null guarantee needed and ensures uniqueness. Now, what about strong and
    weak in `RcBox`? `Rc<T>` provides a method, `Self::downgrade(&self) -> Weak<T>`,
    that produces a non-owning pointer, a pointer which does not guarantee the liveness
    of the referenced data and does not extend its lifetime. This is called a *weak
    reference*. Dropping a `Weak<T>`, likewise, does not imply that `T` is dropped.
    The trick here is that a strong reference does extend the liveness of the underlying
    `T`—the drop of `T` is only called when the internal counter of `Rc<T>` hits zero.
    For the most part, things rarely require a weak reference, except when a cycle
    of references exist. Suppose a graph structure were to be constructed where each
    node holds an `Rc<T>` to its connected nodes and a cycle exists in the graph.
    Calling drop on the current node will recursively call drop on the connected nodes,
    which will recurse again onto the current node and so forth. Were the graph to
    store a vector of all nodes and have each node store weak references to connections,
    then a drop of the vector would cause a drop of all nodes, cycles or not. We can
    see how this works in practice by inspecting the `Drop` implementation of `Rc<T>`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box::into_unique`将`Box<T>`转换为`Unique<T>`——在本章中已讨论过——然后将其转换为`Shared<T>`。这个链保留了所需的非空保证并确保了唯一性。现在，关于`RcBox`中的强引用和弱引用又是怎样的呢？`Rc<T>`提供了一个方法，`Self::downgrade(&self)
    -> Weak<T>`，它产生一个非拥有指针，一个不保证引用数据存活性的指针，并且不扩展其生命周期。这被称为*弱引用*。同样，释放`Weak<T>`也不意味着`T`被释放。这里的技巧是，强引用确实扩展了底层`T`的存活性——只有当`Rc<T>`的内部计数器达到零时，才会调用`T`的释放。在大多数情况下，很少需要弱引用，除非存在引用循环。假设要构建一个图结构，其中每个节点都持有对其连接节点的`Rc<T>`引用，并且图中存在循环。在当前节点上调用释放将递归地调用连接节点的释放，这将再次递归到当前节点，依此类推。如果图存储所有节点的向量，并且每个节点存储对连接的弱引用，那么向量的释放将导致所有节点被释放，无论是否存在循环。我们可以通过检查`Rc<T>`的`Drop`实现来了解这是如何在实际中工作的：'
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is trimmed some for clarity but the notion is as we''ve described—when
    the total number of strong references is zero, a full deallocation occurs. The
    referenced `Heap` and `Layout` are compiler internals and won''t be discussed
    further here, but the interested reader is warmly encouraged to go spelunking
    on their own. Recall that in `Rc<T>::new`, both strong and weak counters started
    at `1`. To avoid invalidating the weak pointers, the actual `T` is only deallocated
    if there are no strong or weak pointers available. Let''s have a look at `Drop
    for Weak<T>`, again trimmed some for clarity:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容为了清晰起见进行了适当的缩减，但概念与我们描述的是一样的——当强引用的总数为零时，将发生完全的释放。被引用的`Heap`和`Layout`是编译器内部实现，这里不再进一步讨论，但有兴趣的读者被鼓励自行探索。回想一下在`Rc<T>::new`中，强引用和弱引用计数器都是从`1`开始的。为了避免使弱指针无效，只有当没有强引用或弱引用可用时，实际的`T`才会被释放。让我们再次看看`Drop
    for Weak<T>`，为了清晰起见，这里也进行了适当的缩减：
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As expected, the `T` can only be deallocated when the weak pointer total falls
    to zero, which is only possible if there are no strong pointers left. That's `Rc<T>`—a
    handful of important traits, a specialized box, and a few compiler internals.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，只有当弱指针总数降至零时，`T`才能被释放，而这只有在没有剩余强指针的情况下才可能。这就是`Rc<T>`——一些重要的特性、一个专门的盒子和一些编译器内部实现。
- en: Vec
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vec
- en: As our last subject in this chapter, let's consider `Vec<T>`. The Rust vector
    is a growable array, that is, an area of contiguous, homogeneous storage that
    can be grown through reallocation as the need arises, or it cane be shrunk. The
    advantage compared to array is in not needing to know ahead of time exactly what
    size of storage you need, plus all the benefits of a slicable structure and additional
    functions in the type API. `Vec<T>` is an extremely common Rust structure, so
    much so that its actual name is `std::vec::Vec<T>` but Rust imports the type by
    default. Rust programs are full of vectors and it stands to reason we'd do well
    to understand how it interacts with the memory it holds.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的最后一个主题，让我们考虑`Vec<T>`。Rust 向量是一个可增长的数组，也就是说，一个连续、同质的存储区域，可以根据需要通过重新分配来增长，或者它可以缩小。与数组相比的优势在于不需要提前知道你需要多少存储空间，以及可切片结构和类型
    API 中额外函数的所有好处。`Vec<T>`是一个非常常见的 Rust 结构，如此之多，以至于它的实际名称是`std::vec::Vec<T>`，但 Rust
    默认导入此类型。Rust 程序充满了向量，因此理解它与所持内存的交互方式是很有道理的。
- en: '`Vec<T>` is defined in `src/liballoc/vec.rs` and is defined as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec<T>`在`src/liballoc/vec.rs`中定义，如下所示：'
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The Rust documentation declares that a `Vec<T>` will be laid out as a pointer,
    a capacity of `usize`, and a length of `usize.` The order of these fields is completely
    unspecified. As we''ve already discussed, Rust will reorder fields as it sees
    fit. Moreover, the pointer is guaranteed to be non-null, allowing for a null-pointer
    optimization. Previously, we saw the usual trick of Rust: define a higher-level
    structure in terms of a lower-level—or raw – structure, or even in terms of a
    fully unsafe structure. We see the length `usize` already, called `len`. This
    means there''s a distinct difference between capacity and length, the distinction
    of which we''ll come back to as we dig into `RawVec<T>`. Let''s take a peek at
    `RawVec<T>`, defined in `src/liballoc/raw_vec.rs`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 文档声明，`Vec<T>`将按指针、`usize`容量和`usize`长度的顺序布局。这些字段的顺序完全未指定。正如我们之前讨论的，Rust
    将根据需要重新排序字段。此外，指针保证不为空，允许进行空指针优化。之前，我们看到了 Rust 的常用技巧：用较低级（或原始）结构或甚至用完全不安全的结构来定义高级结构。我们已经看到了长度`usize`，称为`len`。这意味着容量和长度之间存在明显的区别，我们将在深入研究`RawVec<T>`时回到这一点。让我们看一下定义在`src/liballoc/raw_vec.rs`中的`RawVec<T>`：
- en: '[PRE60]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'What we have is a pointer to a `Unique<T>`, a `*mut T` with added guarantees
    that the `RawVec<T>` is the only possessor of the allocation and that the pointer
    is not null. The `cap` is the capacity of the raw vector. `a: A` is the allocator,
    `Heap` by default. Rust does allow for allocators to be swapped, so long as the
    implementation obeys—as of writing this book—the `std::heap::Alloc` trait. Swapping
    allocators is an unstable feature of Rust, available only in the nightly channel,
    but one that is stable enough to see common use in the embedded Rust community''s
    libraries. In this book, we won''t use anything other than the default allocator,
    but the reader is warmly encouraged to explore the topic in more detail. Allocator
    aside, there''s the pointers, length, and capacity that the Rust documentation
    promised. Let''s pop back to `Vec<T>` and take a look at `new`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '我们拥有的是一个指向`Unique<T>`的指针，这是一个添加了额外保证的`*mut T`，即`RawVec<T>`是唯一拥有分配的持有者，且指针不为空。`cap`是原始向量的容量。`a:
    A`是分配器，默认为`Heap`。Rust 允许交换分配器，只要实现遵守——截至撰写本书时——`std::heap::Alloc`特质。交换分配器是 Rust
    的一个不稳定特性，仅在夜间频道中可用，但足够稳定，足以在嵌入式 Rust 社区的库中看到其常见使用。在这本书中，我们不会使用除默认分配器以外的任何东西，但强烈鼓励读者更深入地探索这个主题。抛开分配器不谈，还有
    Rust 文档承诺的指针、长度和容量。让我们回到`Vec<T>`，看看`new`：'
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, the new of raw `vec`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看原始`vec`的`new`：
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This defers creation to `new_in`, a function on the same `trait`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建推迟到`new_in`，这是同一`trait`上的一个函数：
- en: '[PRE63]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `cap` computation is interesting. It''s possible to store a `T` in `Vec<T>`—and
    by extension `RawVec<T>`—that has zero size. The implementers knew this and came
    up with a fun solution: if the size of the type is zero, set the capacity to `usize::MAX`,
    else 0\. It''s not possible to cram `usize::MAX` elements into a vector since
    we''d run out of memory one allocation prior to hitting the cap and it''s now
    possible to discriminate the case of zero-sized types without having to introduce
    an enumeration or a flag variable. Tidy trick. If we bounce back to vector and
    inspect `with_capacity`, we''ll find that defers to `RawVec::with_capacity`, which
    defers to `RawVec::allocate_in`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`cap`计算很有趣。在`Vec<T>`——以及扩展的`RawVec<T>`——中可以存储一个`T`，其大小为零。实现者知道这一点，并提出了一种有趣的方法：如果类型的大小为零，则将容量设置为`usize::MAX`，否则为0。由于在达到容量之前就会耗尽内存，因此不可能将`usize::MAX`个元素塞入一个向量，现在可以区分零大小类型的案例，而无需引入枚举或标志变量。这是一个整洁的技巧。如果我们回到向量并检查`with_capacity`，我们会发现它委托给`RawVec::with_capacity`，它又委托给`RawVec::allocate_in`：'
- en: '[PRE64]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'There''s a lot going on here, but it''s important, so let''s break it into
    small pieces. Firstly, see the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行中，但这是非常重要的，所以让我们将其分解成小块。首先，看看以下内容：
- en: '[PRE65]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'At the head of the function, the size of the element is computed and the total
    allocation requested by the caller is confirmed to be no more than the available
    system memory. Note that `checked_mul` ensures we don''t overflow usize and accidentally
    allocate too little memory. Finally, a function called `alloc_guard` is called.
    That is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的开头，计算了元素的大小，并确认调用者请求的总分配量不超过可用的系统内存。注意，`checked_mul`确保我们不会溢出usize并意外分配过少的内存。最后，调用了一个名为`alloc_guard`的函数。如下所示：
- en: '[PRE66]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is a guarantee check. Remember that usize and isize are the signed and
    unsigned size of the system pointer. To understand this guard, we must understand
    the answer to two questions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个保证检查。记住，usize和isize是系统指针的带符号和无符号大小。为了理解这个保护措施，我们必须了解两个问题的答案：
- en: On a given machine, how much memory can I allocate?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定的机器上，我能分配多少内存？
- en: On a given machine, how much memory can I address?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定的机器上，我能访问多少内存？
- en: 'It''s possible to allocate usize bytes from the operating system but here,
    Rust is checking that the allocation size is less than the maximum isize. The
    Rust reference ([https://doc.rust-lang.org/stable/reference/types.html#machine-dependent-integer-types](https://doc.rust-lang.org/stable/reference/types.html#machine-dependent-integer-types))
    explains why:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从操作系统分配usize字节，但在这里，Rust正在检查分配的大小是否小于isize的最大值。Rust参考（[https://doc.rust-lang.org/stable/reference/types.html#machine-dependent-integer-types](https://doc.rust-lang.org/stable/reference/types.html#machine-dependent-integer-types)）解释了原因：
- en: '"The isize type is a signed integer type with the same number of bits as the
    platform''s pointer type. The theoretical upper bound on object and array size
    is the maximum isize value. This ensures that isize can be used to calculate differences
    between pointers into an object or array and can address every byte within an
    object along with one byte past the end."'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '"isize类型是一个与平台指针类型位数相同的有符号整数类型。对象和数组大小的理论上限是isize的最大值。这确保了isize可以用来计算指向对象或数组的指针之间的差异，并且可以访问对象内的每个字节以及末尾之后的一个字节。"'
- en: 'Combined with the capacity check from `checked_mul`, we know that the allocation
    is properly sized and that it''s addressable along the whole of itself:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 结合`checked_mul`的容量检查，我们知道分配的大小是合适的，并且在整个分配中都是可寻址的：
- en: '[PRE67]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the event that the desired capacity is zero *or* the size of `T` is zero,
    the implementation coerces the minimum alignment of `T` into a pointer to bytes,
    the `*mut u8`. This pointer is, well, it points nowhere useful but the implementation
    has avoided an allocation when there is nothing that could be allocated, whether
    there will never be anything to allocate because of zero-sized types or not. This
    is good, and all the implementation will have to do is be aware that when the
    capacity is zero, or if the type size is zero, the pointer cannot be dereferenced.
    Right:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所需的容量为零或`T`的大小为零，则实现将`T`的最小对齐方式强制转换为指向字节的指针，即`*mut u8`。这个指针，嗯，它指向没有用的地方，但实现避免了在没有可以分配的内容时进行分配，无论是由于零大小类型而永远不会分配，还是其他原因。这是好的，并且实现只需要意识到，当容量为零或类型大小为零时，指针不能被解引用。正确：
- en: '[PRE68]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This branch is hit when there''s memory to be allocated. Notably, two sub-possibilities,
    controlled by the `zeroed` argument: either memory is zeroed or it is left uninitialized.
    `Vec<T>` does not expose this option to the end user but we know from inspection
    that memory starts off uninitialized, an optimization for non-trivial allocations:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要分配内存时，会触发此分支。值得注意的是，有两个子可能性，由`zeroed`参数控制：要么内存被初始化为零，要么它保持未初始化状态。`Vec<T>`不向最终用户公开此选项，但我们通过检查知道内存开始时是未初始化的，这是一种对非平凡分配的优化：
- en: '[PRE69]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The lack of an initialization flag is kind of tricky in some cases. Consider
    `std::io::Read::read_exact`. This function takes a `&mut [u8]` and it''s common
    enough to create this slice from a specially created vec. This code will *not*
    read 1024 bytes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，缺乏初始化标志有点棘手。考虑`std::io::Read::read_exact`这个函数。它接受一个`&mut [u8]`，并且通常是从特别创建的vec中创建这个切片。以下代码将不会读取1024字节：
- en: '[PRE70]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Why? The slice that we pass in is actually of zero length! Rust dereferences
    are allowed on a type by two traits: `std::ops::Deref` and `std::ops::DerefMut`,
    depending on your desire for an immutable or mutable slide. The `Deref`  trait
    is defined as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？我们传递的切片实际上长度为零！Rust的解引用允许通过两个特质：`std::ops::Deref`和`std::ops::DerefMut`，这取决于你对不可变或可变切片的需求。`Deref`特质定义为以下：
- en: '[PRE71]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And the mutable version analogously. When we slice our vector as in the preceding
    code block, we''re calling this `DerefMut::deref`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以及可变版本的类似操作。当我们像前面的代码块那样切片我们的向量时，我们调用这个`DerefMut::deref`：
- en: '[PRE72]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is the very important part: `slice::from_raw_parts_mut(ptr, self.len)`.
    Vector slices are built by length, not capacity. The capacity of a vector serves
    to distinguish how much memory has been allocated versus how much memory has been
    initialized, either to zeros or some other inserted values. This is an important
    difference. It''s possible to initialize memory ourselves:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常重要的部分：`slice::from_raw_parts_mut(ptr, self.len)`。向量切片是通过长度构建的，而不是容量。向量的容量用于区分已分配的内存与已初始化的内存，无论是初始化为零还是插入其他值。这是一个重要的区别。我们有可能自行初始化内存：
- en: '[PRE73]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Or to rely on the `Vec` API to convert from a fixed-size array:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 或者依赖`Vec` API从固定大小的数组转换：
- en: '[PRE74]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Either will work. Which you choose depends on if you know the size of the buffer
    ahead of time or not.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都可行。你选择哪种取决于你是否提前知道缓冲区的大小。
- en: 'Befitting such an important type, there are a good many API functions on `Vec<T>`.
    In the remainder of this chapter, we''ll occupy ourselves with two mutations:
    `push` and `insert`. The `push` function is a constant operation, modulo any reallocations
    necessary to cope with the case of our capacity limit being reached. Here''s the
    `push` function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个重要的类型，`Vec<T>`上有许多API函数。在本章的剩余部分，我们将关注两个变异：`push`和`insert`。`push`函数是一个常数操作，除了任何必要的重新分配来应对容量限制达到的情况。以下是`push`函数：
- en: '[PRE75]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If you''ll recall, `self.buf` is the underlying `RawVec<T>`. The documentation
    for `Vec<T>` notes that when reallocation is required, the underlying memory will
    be doubled, which, it turns out, is handled by `RawVec<T>::double`. That function
    is fairly long and, as you might suspect, is a bunch of arithmetic to compute
    the new, doubled size matched with a realloc when there''s an existing allocation,
    else when there''s a new allocation. That is worth listing:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，`self.buf`是底层的`RawVec<T>`。`Vec<T>`的文档指出，当需要重新分配时，底层内存将加倍，这实际上是由`RawVec<T>::double`函数处理的。该函数相当长，并且正如你可能猜到的，它包含一系列计算新加倍大小的算术，并在存在现有分配时执行realloc，否则在存在新分配时。这是值得列出的：
- en: '[PRE76]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`Alloc::alloc_array` allocates space for contiguous memory, which is suitable
    to hold `new_cap` number of elements the size of `T`, returning the pointer to
    the first address of this newly allocated space. Here then, is the contiguous
    memory promised in the documentation of `Vec<T>`! Back in `Vec<T>`, now that the
    capacity is twice that of what it was, at least, the value `T` can be inserted:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Alloc::alloc_array`为连续内存分配空间，这适合容纳`new_cap`个大小为`T`的元素，并返回新分配空间第一个地址的指针。那么，这就是`Vec<T>`文档中承诺的连续内存！回到`Vec<T>`，现在容量至少是原来的两倍，值`T`可以插入：'
- en: '[PRE77]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Rust pointers are handy in that their offset function takes into account the
    size of `T`; there's no need to do additional multiplication as the caller. The
    implementation is determining the first of the unused `T` sized spaces in the
    contiguous allocation—denoted end—and then writes the moved `T` onto that address.
    The fact that the space is unused is important*, *`std::ptr::write` does not deallocate
    any memory that may have originally existed at the written-to pointer. If you
    `ptr::write` over the top of a live reference, wacky things will happen.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的指针很方便，因为它们的偏移函数会考虑到`T`的大小；调用者不需要做额外的乘法。实现是确定连续分配中第一个未使用的`T`大小空间——表示为`end`——然后将移动的`T`写入该地址。重要的是这个空间是未使用的，因为`std::ptr::write`不会释放可能原本存在于写入指针处的任何内存。如果你在活动引用上使用`ptr::write`，会发生奇怪的事情。
- en: 'Finally, `insert`. The `insert` function of `Vec<T>` allows for the insertion
    of `T` at any valid index in the vector. If the insertion is to the end of the
    vector, the method is functionally equivalent to pushing, though mechanically
    different, as we''ll see shortly. If, however, insertion occurs somewhere inside
    of the vector, all elements to the right of the insertion index are shifted over
    once, a non-trivial operation depending on the size of the allocation. Here''s
    the full listing of `insert`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是`insert`函数。`Vec<T>`的`insert`函数允许在向量的任何有效索引处插入`T`。如果插入到向量的末尾，该方法是功能上等同于推送的，尽管在机械上不同，我们很快就会看到。然而，如果插入发生在向量内部，则插入索引右侧的所有元素都会移动一次，这是一个依赖于分配大小的非平凡操作。以下是`insert`的完整列表：
- en: '[PRE78]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The index checking and potential buffering is straightforward at this point
    in the chapter. In the unsafe block, `p` is the proper offset for insertion. The
    two important lines are:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这个阶段，索引检查和潜在的缓冲是直接的。在`unsafe`块中，`p`是插入的正确偏移量。两条重要的行是：
- en: '[PRE79]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: When a value is inserted into a vector, no matter the location, all the memory
    starting from `p` to the end of the list is copied over the top of the memory,
    starting at `p+1`. Once this is done, the inserted value is written over the top
    of `p`. This is a non-trivial operation and can become incredibly slow, especially
    if the allocation to be shifted is fairly large. Performance-focused Rust will
    use `Vec::insert` sparingly, if at all. `Vec<T>` will almost surely make an appearance.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值被插入到向量中时，无论位置如何，从`p`开始到列表末尾的所有内存都会被复制到以`p+1`开始的内存上。一旦完成这个操作，插入的值就会覆盖`p`。这是一个非平凡的运算，可能会变得非常慢，尤其是如果需要移动的分配相当大时。以性能为导向的Rust会尽量少用，甚至不用`Vec::insert`。`Vec<T>`几乎肯定会出现在其中。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the layout of Rust objects in memory, the way references
    work across both safe and unsafe Rust, and have addressed the various allocation
    strategies of a Rust program. We did a deep-dive on types in the Rust standard
    library to make these concepts concrete and it is hoped that the reader will now
    feel comfortable further exploring the compiler and will do so with confidence.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Rust对象在内存中的布局，引用在安全和不安全Rust中的工作方式，并解决了Rust程序的多种分配策略。我们对Rust标准库中的类型进行了深入研究，以使这些概念具体化，并希望读者现在会感到舒适地进一步探索编译器，并充满信心地这样做。
- en: Further reading
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The memory model of a programming language is a broad topic. Rust's, as of writing
    this book, must be understood from the inspection of the Rust documentation, the
    rustc source code, and research into LLVM. That is, Rust's memory model is not
    formally documented, though there are rumblings in the community of providing
    it. Independent of that, it is also important for the working programmer to understand
    the underlying machine. There's a staggering amount of material to be covered.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的内存模型是一个广泛的话题。截至撰写本书时，Rust的内存模型必须通过检查Rust文档、rustc源代码和对LLVM的研究来理解。也就是说，Rust的内存模型没有正式的文档，尽管社区中有人提出要提供它。独立于这一点，对于工作的程序员来说，理解底层机器也很重要。有大量的材料需要覆盖。
- en: 'These notes are a small start, focusing especially on the Rust documentation
    that relates most to this chapter:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些笔记是一个小的开始，特别关注与本章最相关的Rust文档：
- en: '*High Performance Code 201: Hybrid Data Structures*, Chandler Carruth, available
    at [https://www.youtube.com/watch?v=vElZc6zSIXM&index=5&list=PLKW_WLANyJtqQ6IWm3BjzHZvrFxFSooey](https://www.youtube.com/watch?v=vElZc6zSIXM&index=5&list=PLKW_WLANyJtqQ6IWm3BjzHZvrFxFSooey).
    This, in point of fact, is a talk from CppCon 2016\. Carruth is an engaging speaker
    and is a member of the LLVM team focused on compiler performance. This talk is
    especially interesting from the point of view of building information-dense data
    structures that interact well with CPU caches. While the talk is in C++, the techniques
    apply directly to Rust.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高性能代码201：混合数据结构*，作者：Chandler Carruth，可在[https://www.youtube.com/watch?v=vElZc6zSIXM&index=5&list=PLKW_WLANyJtqQ6IWm3BjzHZvrFxFSooey](https://www.youtube.com/watch?v=vElZc6zSIXM&index=5&list=PLKW_WLANyJtqQ6IWm3BjzHZvrFxFSooey)找到。实际上，这是2016年CppCon的一次演讲。Carruth是一位富有魅力的演讲者，他是专注于编译器性能的LLVM团队的一员。从构建与CPU缓存良好交互的信息密集型数据结构的角度来看，这次演讲特别有趣。尽管演讲是用C++进行的，但其中的技术可以直接应用于Rust。'
- en: '*Cache-oblivious Algorithms*, Matteo Frigo, Charles Leiserson, Harald Prokop,
    and Sridhar Ramachandran. This paper introduces the concept of building data structures
    that are cache oblivious, or, native to machines with memory hierarchies and interact
    with them well, in addition to a machine model to analyze such data structures.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无缓存感知算法*，作者：Matteo Frigo, Charles Leiserson, Harald Prokop, 和 Sridhar Ramachandran。本文介绍了构建无缓存感知数据结构的概念，或者说是针对具有内存层次结构的机器的本地数据结构，以及如何与它们良好交互，此外还提供了一个机器模型来分析这样的数据结构。'
- en: '*Cache-Oblivious Algorithms and Data Structures*, Erik Demaine. This paper
    is a classic in the cache-oblivious space, building on the work presented in the
    last by Frigo et al and summarizing existing work. This is a highly recommended
    read, especially in conjunction with the previous paper. It is well worth scanning
    the bibliography as well.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无缓存感知算法与数据结构*，作者：Erik Demaine。这篇论文是无缓存感知领域的经典之作，基于Frigo等人之前提出的工作，并对现有工作进行了总结。这是一篇非常值得阅读的论文，特别是与之前的论文结合阅读。浏览其参考文献也是很有价值的。'
- en: '*The Stack and the Heap*, available at [https://doc.rust-lang.org/book/first-edition/the-stack-and-the-heap.html](https://doc.rust-lang.org/book/first-edition/the-stack-and-the-heap.html). This
    chapter from the first edition of the Rust book explains the difference between
    the hardware stack and heap, allocations to each, and the implications for Rust.
    This chapter has gone into further detail in some areas, but the Rust book''s
    chapter is warmly recommended for anyone needing a refresher or a more gentle
    climb.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*栈与堆*，可在[https://doc.rust-lang.org/book/first-edition/the-stack-and-the-heap.html](https://doc.rust-lang.org/book/first-edition/the-stack-and-the-heap.html)找到。Rust书的第一版中的这一章解释了硬件栈和堆之间的区别，以及各自的分配，以及这对Rust的影响。在某些方面，这一章已经进行了更深入的探讨，但强烈推荐Rust书中的这一章给任何需要复习或更温和地学习的人。'
- en: '*Splitting Borrows*, available at [https://doc.rust-lang.org/beta/nomicon/borrow-splitting.html](https://doc.rust-lang.org/beta/nomicon/borrow-splitting.html). The
    Nomicon is a Rust book intended to teach low-level Rust programming, not unlike
    this book. While it is a work-in-progress, the information in it is invaluable.
    *Splitting Borrows* explains the reasoning behind a common issue with new Rust
    developers: performing multiple mutable borrows out of a vector or array. The
    fact that this works with *structs* is often a source of great confusion and anguish.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拆分借用*，可在[https://doc.rust-lang.org/beta/nomicon/borrow-splitting.html](https://doc.rust-lang.org/beta/nomicon/borrow-splitting.html)找到。Nomicon是一本旨在教授低级Rust编程的Rust书籍，与这本书类似。虽然它还在不断完善中，但其中的信息非常有价值。“拆分借用”解释了新Rust开发者常见的一个问题：从向量或数组中执行多个可变借用。这种操作与*结构体*相关的事实常常是造成极大困惑和痛苦的原因。'
- en: '*Rust Reference*, available at [https://doc.rust-lang.org/reference/](https://doc.rust-lang.org/reference/). Like
    any established programming language, the Rust Reference is invaluable for understanding
    the subtle details of the language itself, which have been hashed out in mailing
    lists and over chat for years. The reference in its current form can be a touch
    hard to search—it used to be one long page—but it''s hoped the situation will
    be improved upon by the time our book here has gone to press.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rust参考手册*，可在[https://doc.rust-lang.org/reference/](https://doc.rust-lang.org/reference/)找到。像任何成熟的编程语言一样，Rust参考手册对于理解语言本身的微妙细节非常有价值，这些细节在多年的邮件列表和聊天中已经讨论过。当前形式的参考手册搜索起来可能有点困难——它曾经是一页长的单页文档——但希望在我们这本书付印时，情况会有所改善。'
- en: '*Closures: Anonymous Functions that can Capture their Environment*, available
    at [http://doc.rust-lang.org/1.23.0/book/second-edition/ch13-01-closures.html](http://doc.rust-lang.org/1.23.0/book/second-edition/ch13-01-closures.html).
    Rust closures have some subtle implications to them that can be hard to internalize
    for new Rust developers. This chapter in the second edition of the Rust Book is
    excellent in this regard.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*闭包：能够捕获其环境的匿名函数*，可在[http://doc.rust-lang.org/1.23.0/book/second-edition/ch13-01-closures.html](http://doc.rust-lang.org/1.23.0/book/second-edition/ch13-01-closures.html)找到。Rust闭包对新手Rust开发者来说有一些微妙的影响，可能难以内化。在Rust
    Book的第二版中，这一章节在这方面做得非常出色。'
- en: '*External blocks*, available at [https://doc.rust-lang.org/reference/items/external-blocks.html](https://doc.rust-lang.org/reference/items/external-blocks.html). External
    blocks are relatively rare in this book—and, perhaps, in most of the Rust code
    you''re likely to see—but there''s a fair few of them available. It is well worth
    having a passing knowledge of this document''s existence.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*外部块*，可在[https://doc.rust-lang.org/reference/items/external-blocks.html](https://doc.rust-lang.org/reference/items/external-blocks.html)找到。在这本书中，外部块相对较少——也许在大多数你可能会看到的Rust代码中也是如此——但确实有一些可用。了解这份文档的存在是非常有价值的。'
- en: '*Hacker''s Delight*, Henry Warren Jr.This book is a classic. Many of the tricks
    present in the book are now available as simple instructions on some chips, such
    as x86, but you''ll see the occasional delight here or there in the `rustc` source
    code, the `swap_nonoverlapping_bytes` trick especially.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*黑客的乐趣*，亨利·沃伦小儿子著。这本书是经典之作。书中许多技巧现在作为一些芯片（如x86）上的简单指令可用，但你仍会在`rustc`源代码中偶尔发现一些惊喜，尤其是`swap_nonoverlapping_bytes`技巧。'
