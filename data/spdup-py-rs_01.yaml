- en: '*Chapter 3*: Understanding Concurrency'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：理解并发'
- en: Speeding up our code with Rust is useful. However, understanding concurrency
    and utilizing threads and processes can take our ability to speed up our code
    to the next level. In this chapter, we will go through what processes and threads
    are. We then go through the practical steps of spinning up threads and processes
    in Python and Rust. However, while this can be exciting, we also must acknowledge
    that reaching for threads and processes without thinking about our approach can
    end up tripping us up. To avoid this, we also explore algorithm complexity and
    how this affects our computation time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rust 加速我们的代码是有用的。然而，理解并发以及利用线程和进程可以将我们加速代码的能力提升到下一个层次。在本章中，我们将探讨进程和线程是什么。然后，我们将通过在
    Python 和 Rust 中启动线程和进程的实际步骤进行讲解。然而，虽然这可能会令人兴奋，但我们还必须承认，在不考虑我们的方法的情况下盲目追求线程和进程可能会导致我们陷入困境。为了避免这种情况，我们还探讨了算法复杂度以及它如何影响我们的计算时间。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing concurrency
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍并发
- en: Basic asynchronous programming with threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程进行基本异步编程
- en: Running multiple processes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个进程
- en: Customizing threads and processes safely
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全地定制线程和进程
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be accessed via the following GitHub link:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以通过以下 GitHub 链接访问：
- en: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_three](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_three)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_three](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_three)'
- en: Introducing concurrency
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍并发
- en: As we explored in the introduction of [*Chapter 1*](B17720_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *An Introduction to Rust from a Python Perspective*, Moore's law is now failing,
    and therefore we have to consider other ways in which we can speed up our processing.
    This is where concurrency comes in. Concurrency is essentially running multiple
    computations at the same time. Concurrency is everywhere, and to give the concept
    full justice, we would have to write a whole book on it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 1 章*](B17720_01_Final_SK_ePub.xhtml#_idTextAnchor014) 的介绍中探讨的，*从 Python
    视角介绍 Rust*，摩尔定律现在正在失效，因此我们必须考虑其他我们可以加速处理的方法。这就是并发出现的地方。并发本质上是在同一时间运行多个计算。并发无处不在，为了充分阐述这一概念，我们可能需要写一本书来专门介绍它。
- en: However, for the scope of this book, understanding the basics of concurrency
    (and when to use it) can add an extra tool to our belt that enables us to speed
    up computations. Furthermore, threads and processes are how we can break up our
    program into computations that run at the same time. To start our concurrency
    tour, we will cover threads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于本书的范围，理解并发的基本知识（以及何时使用它）可以为我们的工具箱增添一个额外的工具，使我们能够加速计算。此外，线程和进程是我们将程序分解成可以同时运行的计算的方式。为了开始我们的并发之旅，我们将介绍线程。
- en: Threads
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程
- en: '**Threads** are the smallest unit of computation that we can process and manage
    independently. Threads are used to break a program into computational parts that
    can be run at the same time. It also has to be noted that threads can be run out
    of sequence. This brings forward an important distinction between concurrency
    and parallelism. **Concurrency** is the task of running and managing multiple
    computations at the same time, while **parallelism** is the task of running multiple
    computations at the same time. Concurrency has a non-deterministic control flow,
    while parallelism has a deterministic control flow. Threads share resources such
    as memory and processing power; however, they also block each other. For instance,
    if we spin off a thread that requires constant processing power, we will merely
    block the other thread, as seen in the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**是我们能够独立处理和管理的最小计算单元。线程用于将程序分解成可以同时运行的计算部分。还应注意，线程可以按顺序外发。这提出了并发和并行之间的重要区别。**并发**是在同一时间运行和管理多个计算的任务，而**并行**是在同一时间运行多个计算的任务。并发具有非确定性的控制流，而并行具有确定性的控制流。线程共享资源，如内存和处理能力；然而，它们也会相互阻塞。例如，如果我们启动一个需要恒定处理能力的线程，我们只会阻塞其他线程，如下面的图所示：'
- en: '![Figure 3.1 – Two threads over time'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 随时间变化的两个线程'
- en: '](img/Figure_3.01_B17720.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B17720.jpg)'
- en: Figure 3.1 – Two threads over time
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 随时间变化的两个线程
- en: 'Here, we can see that **Thread A** stops running when **Thread B** is running.
    This is demonstrated in Pan Wu''s 2020 article on understanding multithreading
    through simulations where different types of tasks were timed. The results in
    the article are summed up in the following chart:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，当 **线程 B** 运行时，**线程 A** 停止运行。这可以在潘武 2020 年关于通过模拟理解多线程的文章中得到证明，其中对各种类型的任务进行了计时。文章中的结果总结在下述图表中：
- en: '![Figure 3.2 – Times of different tasks](img/Figure_3.02_B17720.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 不同任务的耗时](img/Figure_3.02_B17720.jpg)'
- en: 'Figure 3.2 – Times of different tasks [Source: Pan Wu, https://towardsdatascience.com/understanding-python-multithreading-and-multiprocessing-via-simulation-3f600dbbfe31]'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 不同任务的耗时 [来源：潘武，https://towardsdatascience.com/understanding-python-multithreading-and-multiprocessing-via-simulation-3f600dbbfe31]
- en: Here, we can see that the times decrease as the number of workers decreases,
    *apart from* the **central processing unit** (**CPU**)-heavy multithreaded tasks.
    This is because, as demonstrated in *Figure 3.1*, the CPU-intensive threads are
    blocking, so only one worker can process at a time. It does not matter how many
    more workers you add. It must be noted that this is because of Python's **global
    interpreter lock** (**GIL**), which is covered in [*Chapter 6*](B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100),
    *Working with Python Objects in Rust*. In other contexts, such as Rust, they can
    be executed on different CPU cores and generally will not block each other.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，随着工作者数量的减少，时间也在减少，*除了* CPU 密集型多线程任务。这是因为，如 *图 3.1* 所示，CPU 密集型线程是阻塞的，所以一次只能有一个工作者处理。无论你添加多少工作者都没有关系。必须注意的是，这是因为
    Python 的 **全局解释器锁**（**GIL**），这在 [*第 6 章*](B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100)
    *在 Rust 中使用 Python 对象* 中有所介绍。在其他上下文中，例如 Rust，它们可以在不同的 CPU 核心上执行，并且通常不会相互阻塞。
- en: We can also see in *Figure 3.2* that the **input/output** (**I/O**)-heavy tasks
    do reduce in time taken when the workers increase. This is because there is idle
    time in I/O-heavy tasks. This is where we can really utilize threads. Let's say
    our task is making a call to a server. There is some idle time when waiting for
    a response, therefore utilizing threads to make multiple calls to servers will
    speed up the time. We also must note that processes work for CPU- and I/O-heavy
    tasks. Because of this, it is beneficial for us to explore what processes are.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 *图 3.2* 中看到，当工作者数量增加时，**输入/输出**（**I/O**）密集型任务所花费的时间确实减少了。这是因为 I/O 密集型任务中有空闲时间。这正是我们可以真正利用线程的地方。假设我们的任务是调用服务器。在等待响应时会有一些空闲时间，因此利用线程对服务器进行多次调用将加快时间。我们还必须注意，进程适用于
    CPU 和 I/O 密集型任务。正因为如此，探索进程是什么对我们来说是有益的。
- en: Processes
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: '**Processes** are more expensive to produce compared to threads. In fact, a
    process can host multiple threads. This is usually depicted in the following classic
    multithreading diagram, as seen everywhere (including the multiprocessing *Wikimedia*
    page):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程**的生产成本比线程高。实际上，一个进程可以托管多个线程。这通常在以下经典的线程图中表示，如图所示（包括 multiprocessing *维基媒体*
    页面）：'
- en: '![Figure 3.3 – Relationship between threads and processes](img/Figure_3.03_B17720.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 线程和进程之间的关系](img/Figure_3.03_B17720.jpg)'
- en: 'Figure 3.3 – Relationship between threads and processes [Source: Cburnett (2007)
    (https://commons.wikimedia.org/wiki/File:Multithreaded_process.svg), CC BY-SA
    3.0]'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 线程和进程之间的关系 [来源：Cburnett (2007) (https://commons.wikimedia.org/wiki/File:Multithreaded_process.svg),
    CC BY-SA 3.0]
- en: This is a classic diagram because it encapsulates the relationship between processes
    and threads so well. Here, we can see that threads are a subset of a process.
    We can also see why threads share memory, and as a result, we must note that processes
    are typically independent and do not share memory. We also must note that context
    switches are more expensive when using processes. A context switch refers to when
    the state of a process (or thread) is stored so that it can be restored and resumed
    at a later state. An example of this would be waiting for an **application programming
    interface** (**API**) response. The state can be saved, and another process/thread
    can run while we wait for the API response.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的图表，因为它很好地封装了进程和线程之间的关系。在这里，我们可以看到线程是进程的一个子集。我们还可以看到为什么线程共享内存，因此我们必须注意，进程通常是独立的，并且不共享内存。我们还必须注意，使用进程时上下文切换的成本更高。上下文切换是指将进程（或线程）的状态存储起来，以便可以在稍后的状态中恢复和继续。一个例子就是等待
    **应用程序编程接口**（**API**）响应。状态可以被保存，在我们等待 API 响应的同时，另一个进程/线程可以运行。
- en: Now that we understand the basic concepts behind threads and processes, we need
    to learn how to practically use threads in our programs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了线程和进程背后的基本概念，我们需要学习如何在程序中实际使用线程。
- en: Basic asynchronous programming with threads
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程的基本异步编程
- en: 'To utilize threading, we need to be able to start threads, allow them to run,
    and then join them. We can see the stages of practically managing our threads
    in the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用线程，我们需要能够启动线程、允许它们运行，然后合并它们。我们可以在以下图中看到管理线程的各个阶段：
- en: '![Figure 3.4 – Stages of threads'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 线程的阶段'
- en: '](img/Figure_3.04_B17720.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.04_B17720.jpg)'
- en: Figure 3.4 – Stages of threads
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 线程的阶段
- en: 'We start the threads, we then let them run, and once they have run, we join
    them. If we did not join them, the program would continue to run before the threads
    had finished. In Python, we create a thread by inheriting the `Thread` object,
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动线程，然后让它们运行，一旦它们运行完毕，我们就合并它们。如果我们不合并它们，程序将在线程完成之前继续运行。在Python中，我们通过继承`Thread`对象来创建线程，如下所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we can see that we have overwritten the `run` function in the `Thread`
    class. This function runs when the thread is running. We then overwrite the `join`
    method. However, we must note that in the `join` function, there is extra functionality
    going on under the hood; therefore, we must call the `Thread` class''s `join`
    method, and then return whatever we want at the end. We do not have to return
    anything if we do not want to. If this is the case, then there is no point overwriting
    the `join` function. We can then implement the threads by running the following
    code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到我们已覆盖了`Thread`类中的`run`函数。该函数在线程运行时执行。然后我们覆盖`join`方法。然而，我们必须注意，在`join`函数中，幕后正在进行额外的功能；因此，我们必须调用`Thread`类的`join`方法，然后在最后返回我们想要的任何内容。如果我们不想返回任何内容，则不必返回。如果这种情况成立，那么覆盖`join`函数就没有意义了。然后我们可以通过运行以下代码来实现线程：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then have to time the process of starting, running, and joining the outcomes,
    like so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要计时启动、运行和合并结果的过程，如下所示：
- en: '[PRE21]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we run this code, we get the following console printout:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，我们得到以下控制台输出：
- en: '[PRE35]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Straight away, we can see that it took just over 5 seconds to execute the whole
    process. If we were running our program sequentially, it would take 15 seconds.
    This shows that our threads are working!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 立即可以看出，整个过程仅用了5秒多。如果我们按顺序运行程序，则需要15秒。这表明我们的线程正在工作！
- en: It also must be noted that thread `three` finished before thread `two`, even
    though thread `two` started before. Don't worry if you get a finishing sequence
    of `one`, `two`, `three`; this is because threads finish in an indeterminate order.
    Even though the scheduling is deterministic, there are thousands of events and
    processes running under the hood of the CPU when the program is running. As a
    result, the exact time slices that each thread gets are never the same. These
    tiny changes add up over time, and as a result, we cannot guarantee that the threads
    will finish in a determinate order if the executions are close and the durations
    are roughly the same.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还必须注意的是，线程`three`在线程`two`之前完成，尽管线程`two`先开始。如果你得到`one`、`two`、`three`的完成顺序，不要担心；这是因为线程以不确定的顺序完成。尽管调度是确定的，但在程序运行时，CPU幕后有数千个事件和进程在运行。因此，每个线程得到的精确时间片永远不会相同。这些微小的变化随着时间的推移而累积，因此，如果执行接近且持续时间大致相同，我们无法保证线程将以确定的顺序完成。
- en: 'Now we have the basics of Python threads, we can move on to spinning off threads
    in Rust. However, before we start doing this, we must understand the concept of
    `main` function or inside other scopes including other functions. A simple example
    of a building closure is to print an input, like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Python线程的基础知识，我们可以继续学习在Rust中创建线程。然而，在我们开始这样做之前，我们必须理解`main`函数或其他作用域（包括其他函数）的概念。创建闭包的一个简单例子是打印输入，如下所示：
- en: '[PRE46]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'With this approach, we can exploit scopes. It also must be noted that as closures
    are scope-sensitive, we can also utilize the existing variables around a closure.
    To demonstrate this, we can create a closure that calculates the amount of interest
    we have to pay on a loan due to the external base rate. We will also define it
    in an inner scope, as seen here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们可以利用作用域。还必须注意的是，由于闭包是作用域敏感的，我们还可以利用闭包周围的现有变量。为了演示这一点，我们可以创建一个闭包，该闭包计算由于外部基准利率而产生的贷款利息。我们还将它在内部作用域中定义，如下所示：
- en: '[PRE52]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Running this code would give us the following printout in the console:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会在控制台输出以下内容：
- en: '[PRE60]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we can see that closures can return values, but we have not defined the
    type for the closure. This is the case even though it is returning a float. In
    fact, if we set `calculate_interest` to `f32`, the compiler would complain, stating
    that the types were mismatched. This is because the closure is a unique anonymous
    type that cannot be written out. A closure is a struct generated by the compiler
    that houses captured variables. If we try to call the closure outside the inner
    scope, our application will fail to compile as the closure cannot be accessed
    outside the scope.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到闭包可以返回值，但我们还没有为闭包定义类型。即使它返回的是浮点数，这也是如此。实际上，如果我们把 `calculate_interest`
    设置为 `f32`，编译器会报错，指出类型不匹配。这是因为闭包是一个独特的匿名类型，无法被写出来。闭包是由编译器生成的一个结构体，它包含了捕获的变量。如果我们尝试在内部作用域之外调用闭包，我们的应用程序将无法编译，因为闭包不能在作用域之外被访问。
- en: 'Now that we have covered Rust closures, we can replicate the Python threading
    example that we covered earlier in the section. Initially, we must import the
    standard module crates that are required by running the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 Rust 闭包，我们可以复制我们在本节中之前覆盖的 Python 线程示例。最初，我们必须导入标准模块，这些模块通过运行以下代码来要求：
- en: '[PRE61]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We are using `thread` to spawn off threads, `time` to keep track of how long
    our processes take, and the `JoinHandle` struct to join the threads. With these
    imports, we can build our own thread by running the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `thread` 来启动线程，使用 `time` 来跟踪我们的过程花费了多长时间，使用 `JoinHandle` 结构体来连接线程。有了这些导入，我们可以通过运行以下代码来构建自己的线程：
- en: '[PRE63]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, we can see that we create a `Duration` struct denoted as `total_seconds`.
    We then use the thread and `total_seconds` to put the function to sleep, returning
    the number of seconds when the whole process is finished. Right now, this is just
    a function, and running it by itself will not spin off different threads. Inside
    our `main` function, we start our timer and spawn off our three threads by running
    the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们创建了一个表示 `total_seconds` 的 `Duration` 结构体。然后我们使用线程和 `total_seconds`
    来使函数休眠，当整个过程完成时返回秒数。目前，这只是一个函数，单独运行它不会启动不同的线程。在我们的 `main` 函数中，我们开始计时器，并通过运行以下代码启动我们的三个线程：
- en: '[PRE71]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Here, we spawn threads and pass our function in with the right parameters in
    the closure. Nothing is stopping us from putting any code in the closure. The
    final line in the closure would be what is returned to the `JoinHandle` struct
    to unwrap. Once this is done, we join all the threads to hold the program until
    all the threads have finished before moving on with this code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建线程，并在闭包中传递正确的参数和我们的函数。没有什么阻止我们在闭包中放置任何代码。闭包中的最后一行将返回给 `JoinHandle` 结构体以解包的内容。一旦完成，我们将所有线程连接起来，保持程序直到所有线程完成，然后再继续执行此代码：
- en: '[PRE78]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `join` function returns a result with the `Result<i8, Box<dyn Any + Send>>`
    type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`join` 函数返回一个 `Result<i8, Box<dyn Any + Send>>` 类型的结果。'
- en: 'There are some new concepts here, but we can break them down, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的概念，但我们可以按以下方式分解它们：
- en: We remember that a `Result` struct in Rust either returns an `Ok` or an `Err`
    response. If the thread runs without any problems, then we will return the `i8`
    value that we are expecting. If not, then we have this rather ugly `Result<i8,
    Box<dyn Any + Send>>` output as the error.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们记得，Rust 中的 `Result` 结构体要么返回 `Ok` 响应，要么返回 `Err` 响应。如果线程运行没有问题，那么我们将返回我们期望的
    `i8` 值。如果不这样，那么我们将得到这个相当丑陋的 `Result<i8, Box<dyn Any + Send>>` 输出作为错误。
- en: The first thing we must address here is the `Box` struct. This is one of the
    most basic forms of a pointer and allows us to store data on the heap rather than
    the stack. What remains on the stack is the pointer to the data in the heap. We
    are using this because we do not know how big the data is when coming out of the
    thread.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须首先解决这里的 `Box` 结构体。这是指针最基本的形式之一，它允许我们在堆上而不是在栈上存储数据。留在栈上的只是指向堆上数据的指针。我们之所以使用它，是因为我们不知道数据的大小，当它从线程中出来时。
- en: The next expression that we must explain is `dyn`. This keyword is used to indicate
    that the type is a trait object. For instance, we might want to store a range
    of `Box` structs in an array. These `Box` structs might point to different structs.
    However, we can still ensure that they can be grouped together if they have a
    certain trait in common. For instance, if all the structs had to have `TraitA`
    implemented, we would denote this with `Box<dyn TraitA>`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须解释的下一个表达式是 `dyn`。这个关键字用于表示类型是一个特质对象。例如，我们可能想在数组中存储一系列的 `Box` 结构体。这些 `Box`
    结构体可能指向不同的结构体。然而，如果它们具有某种共同的特质，我们仍然可以确保它们可以一起分组。例如，如果所有结构体都必须实现 `TraitA`，我们将用
    `Box<dyn TraitA>` 来表示这一点。
- en: The `Any` keyword is a trait for dynamic typing. This means that the data type
    can be anything. The `Any` trait is combined with `Send` by using the `Any + Send`
    expression. This means that both traits must be implemented.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any` 关键字是动态类型的一个特质。这意味着数据类型可以是任何类型。`Any` 特质通过使用 `Any + Send` 表达式与 `Send` 特质结合。这意味着两个特质都必须实现。'
- en: The `Send` trait is for types that can be transferred across thread boundaries.
    `Send` is implemented automatically by the compiler if it is deemed appropriate.
    With all this, we can confidently state that the join of a thread in Rust returns
    a result that can either be the integer that we desire or a pointer to anything
    else that can be transferred across threads.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Send` 特质是用于可以在线程边界之间传输的类型。如果编译器认为这是合适的，`Send` 将自动实现。有了这一切，我们可以自信地声明 Rust 中线程的连接返回的结果可以是所需的整数或指向任何可以跨线程传输的其他类型的指针。'
- en: 'To process the results of the thread, we could just directly unwrap them. However,
    this would not be very useful when the demands of our multithreaded programs increase.
    We must be able to handle what potentially comes out of a thread, and to do this,
    we are going to have to downcast the outcome. Downcasting is Rust''s method of
    converting a trait into a concrete type. In this context, we will be converting
    `PyO3` structs that denote Python types into concrete Rust data types such as
    strings or integers. To demonstrate this, let''s build a function that handles
    the outcome of our thread, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理线程的结果，我们只需直接解包它们。然而，当我们的多线程程序的需求增加时，这不会很有用。我们必须能够处理线程可能输出的内容，为此，我们必须向下转换结果。向下转换是
    Rust 将特质转换为具体类型的方法。在这种情况下，我们将把表示 Python 类型的 `PyO3` 结构体转换为具体的 Rust 数据类型，如字符串或整数。为了演示这一点，让我们构建一个处理线程结果的函数，如下所示：
- en: 'First, we are going to have to import everything we need, as seen in the following
    code snippet:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须导入我们需要的所有内容，如下面的代码片段所示：
- en: '[PRE81]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'With these imports, we can create a function that unpacks the result and prints
    it using this code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些导入，我们可以创建一个函数来解包结果并使用以下代码打印它：
- en: '[PRE82]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we merely print out the result if it is a success. However, if it is an
    error, as pointed out earlier, we do not know what data type the error is. However,
    we would still like to handle this. This is where we downcast. Downcasting returns
    an option, which is why we have the `if let Some(string) = result.downcast_ref::<String>()`
    condition. If the downcast is successful, we can move the string into the scope
    and print out the error string. If it is not successful, we can move on and state
    that although there was an error, an error string was not provided. We can use
    multiple conditional statements to account for a range of data types if we want.
    We can write a lot of Rust code without having to rely on downcasting, as Rust
    has a strict typing section. However, when interfacing with Python this can be
    useful, as we know that Python objects are dynamic and could essentially be anything.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们只是如果成功就打印出结果。然而，如果出错，正如之前指出的，我们不知道错误的数据类型是什么。然而，我们仍然希望处理这种情况。这就是我们进行向下转换的地方。向下转换返回一个选项，这就是为什么我们有
    `if let Some(string) = result.downcast_ref::<String>()` 条件。如果向下转换成功，我们可以将字符串移动到作用域内并打印出错误字符串。如果它不成功，我们可以继续并声明尽管有错误，但没有提供错误字符串。如果我们想处理多种数据类型，我们可以使用多个条件语句。我们可以编写大量的
    Rust 代码而不必依赖向下转换，因为 Rust 有严格的类型检查。然而，当与 Python 交互时，这可能很有用，因为我们知道 Python 对象是动态的，本质上可以是任何东西。
- en: 'Now that we can process our threads when they have finished, we can stop the
    clock and process the outcomes by running the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在线程完成后处理它们，我们可以停止时钟并通过运行以下代码来处理结果：
- en: '[PRE83]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This gives us the following printout:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这给出了以下打印输出：
- en: '[PRE84]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And here we have it: we can run and process threads in Python and Rust. However,
    remember that if we try to run CPU-intensive tasks with the code that we have
    written, we will not get the speed up. However, it must be noted that in the Rust
    context of the code, there could be a speedup depending on the environment. For
    instance, if multiple CPU cores are available, the **operating system** (**OS**)
    scheduler can put those threads onto those cores to be executed in parallel. To
    write code that will speed up our code in this context, we will have to learn
    how to practically spin up multiple processes, which we cover in the next section.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这里，我们就有了：我们可以在 Python 和 Rust 中运行和处理线程。然而，记住，如果我们尝试使用我们编写的代码运行 CPU 密集型任务，我们不会得到速度提升。然而，必须注意的是，在
    Rust 代码的上下文中，根据环境可能会有速度提升。例如，如果有多个 CPU 核心可用，操作系统（**OS**）调度器可以将这些线程放到这些核心上并行执行。要编写在此上下文中加速我们代码的代码，我们必须学习如何实际创建多个进程，这将在下一节中介绍。
- en: Running multiple processes
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个进程
- en: 'Technically with Python, we can simply switch the inheritance of our thread
    from `Thread` to `Process` by running the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术上，我们可以通过运行以下代码简单地切换我们的线程从继承自`Thread`到`Process`：
- en: '[PRE85]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: However, there are some compilations. If we refer to *Figure 3.3*, we can see
    that processes have their own memory. This is where things can get complicated.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些限制。如果我们参考*图 3.3*，我们可以看到进程有自己的内存。这就是事情可能变得复杂的地方。
- en: For instance, there is nothing wrong with the process defined previously if
    the process is not returning anything directly but writing to a database or file.
    On the other hand, the `join` function will not return anything directly and will
    just have `None` instead. This is because `Process` is not sharing the same memory
    space as the main process. We also must remember that spinning off processes is
    more expensive, so we must be more careful with this.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果之前定义的进程不是直接返回任何内容，而是写入数据库或文件，那么这并没有什么问题。另一方面，`join`函数不会直接返回任何内容，而是返回`None`。这是因为`Process`与主进程不共享相同的内存空间。我们还必须记住，创建进程的成本更高，因此我们必须更加小心。
- en: 'Since we are getting more complex with the memory and the resources are getting
    more expensive, it makes sense to rein it in and keep it simple. This is where
    we utilize a **pool**. A pool is where we have several workers processing inputs
    simultaneously and then packaging them as an array, as seen here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理更复杂的内存，资源也变得更加昂贵，因此将其限制在简单状态是有意义的。这就是我们利用**池**的地方。池是我们有多个工作进程同时处理输入，然后将它们打包成数组的地方，如图所示：
- en: '![Figure 3.5 – Pool of processes'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 进程池'
- en: '](img/Figure_3.05_B17720.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.05_B17720.jpg)'
- en: Figure 3.5 – Pool of processes
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 进程池
- en: 'The advantage here is that we keep the expensive multiprocessing context to
    a small part of the program. We can also easily control the number of workers
    that we are willing to support. For Python, this means that we keep the interaction
    as lightweight as possible. As seen in the next diagram, we package an individual
    isolated function in a tuple with an array of inputs. This tuple gets processed
    in the pool by a worker, and then the result of the outcome is returned from the
    pool:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势在于，我们将昂贵的多进程上下文限制在程序的一小部分。我们还可以轻松控制我们愿意支持的工人数。对于 Python 来说，这意味着我们尽量保持交互尽可能轻量。如图所示，我们将单个隔离的函数包装在一个元组中，与输入数组一起。这个元组在池中被一个工作进程处理，然后从池中返回结果：
- en: '![Figure 3.6 – Pool data flow'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 池数据流'
- en: '](img/Figure_3.06_B17720.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.06_B17720.jpg)'
- en: Figure 3.6 – Pool data flow
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 池数据流
- en: 'To demonstrate multiprocessing via a pool, we can utilize the **Fibonacci sequence**.
    This is where the next number of the sequence is the sum of the previous number
    in the sequence and the number before that, as illustrated here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过池来演示多进程，我们可以利用**斐波那契数列**。这就是序列的下一个数字是序列中前一个数字和它前面的数字之和，如图所示：
- en: '![](img/B17720_03_001.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17720_03_001.jpg)'
- en: 'To calculate a number in the sequence, we will have to use **recursion**. There
    is a closed form of the Fibonacci sequence; however, this will not let us explore
    multiprocessing as the closed sequence by its very nature doesn''t scale in computation
    as *n* increases. To calculate a Fibonacci number in Python, we can write an isolated
    function, as seen in the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算序列中的数字，我们必须使用**递归**。斐波那契序列有一个闭合形式；然而，这不会让我们探索多进程，因为闭合序列本身在计算上不会随着 *n* 的增加而扩展。要在
    Python 中计算斐波那契数，我们可以编写一个独立的函数，如下面的代码片段所示：
- en: '[PRE99]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This function keeps going back until it hits the bottom of the tree at either
    1 or 0\. This function is terrible at scaling. To demonstrate this, let''s look
    at the recursion tree shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会一直回溯，直到它到达树的底部，即 1 或 0。这个函数在扩展性方面非常糟糕。为了演示这一点，让我们看看这里显示的递归树：
- en: '![Figure 3.7 – Fibonacci recursion tree'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 斐波那契递归树'
- en: '](img/Figure_3.07_B17720.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.07_B17720.jpg)'
- en: Figure 3.7 – Fibonacci recursion tree
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 斐波那契递归树
- en: We can see that these are not perfect trees, and if you go online and search
    for *big O notation of the Fibonacci sequence*, there are debates, and some equations
    will equate the scaling factor to the golden ratio. While this is interesting,
    it is outside the scope of this book as we are focusing on computational complexity.
    As a result, we will simplify the math and treat this as a perfectly symmetrical
    tree. Recursion trees scale at the rate of ![](img/B17720_03_002.png), where *n*
    is the depth of the tree. Referring to *Figure 3.7*, we can see that if we treat
    the tree as perfectly symmetrical, a *n* value of 3 has a depth of 3, and a *n*
    value of 4 has a depth of 4\. As *n* increases, the computation increases exponentially.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这些不是完美的树，如果你上网搜索 *斐波那契序列的大 O 表示法*，会有争论，有些方程会将扩展因子等同于黄金比例。虽然这很有趣，但这超出了本书的范围，因为我们专注于计算复杂性。因此，我们将简化数学，将其视为一个完美的对称树。递归树以
    ![](img/B17720_03_002.png) 的速率扩展，其中 *n* 是树的深度。参照 *图 3.7*，我们可以看到，如果我们把树视为完美的对称，*n*
    值为 3 时深度为 3，*n* 值为 4 时深度为 4。随着 *n* 的增加，计算呈指数增长。
- en: We have taken a slight detour of complexity to highlight the importance of taking
    this into account before reaching for multiprocessing. The reason why you bought
    this book as opposed to searching online for multiprocessing code snippets to
    copy and paste into your code is that you want to be guided through these concepts
    with pointers for further reading and an appreciation of their context. In the
    case of this sequence, reaching for a closed form or caching answers would reduce
    the computation time greatly. If we have an ordered list of numbers, getting the
    highest number in the list and then creating a full sequence up to the highest
    number would be a lot quicker than repeatedly calculating the sequence again and
    again for each number we want to calculate. Avoiding recursion altogether is a
    better option than reaching for multiprocessing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微偏离了复杂性的主题，以强调在寻求多进程之前考虑这一点的重要性。你之所以购买这本书而不是在网上搜索可以复制粘贴到你的代码中的多进程代码片段，是因为你希望在这些概念上得到指导，有进一步阅读的指针，并理解其背景。在这个序列的情况下，寻求闭合形式或缓存答案将大大减少计算时间。如果我们有一个有序的数字列表，获取列表中的最大数字，然后创建一个直到最大数字的完整序列，会比反复为每个要计算的数字重新计算序列要快得多。完全避免递归比寻求多进程是一个更好的选择。
- en: 'To implement and test our multiprocessing pool, we first need to time how long
    it would take to calculate a range of numbers sequentially. This can be done like
    so:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现和测试我们的多进程池，我们首先需要计算一系列数字按顺序计算所需的时间。这可以这样做：
- en: '[PRE104]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We have introduced a pretty long list; however, this is essential to see the
    difference. If we just had two Fibonacci numbers to compute, then the cost of
    spinning up processes could eclipse the gain in multiprocessing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个相当长的列表；然而，这是为了看到差异的必要条件。如果我们只计算两个斐波那契数，那么启动进程的成本可能会超过多进程带来的收益。
- en: 'Our multiple processing pool can be implemented as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个处理池实现如下：
- en: '[PRE120]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Please note that we have nested this code under `if __name__ ==` "`__main__`"`:`.
    This is because the whole script gets run again when spinning up another process,
    which can result in infinite loops. If the code is nested under `if __name__ ==`
    "`__main__`"`:` then it will not run again as there is only one main process.
    It also must be noted that we defined a pool of four workers. This can be changed
    to whatever we feel fit but there are diminishing returns when increasing this,
    as we will explore later. The tuples in the list are the arguments for each computation.
    Running the whole script gives us the following output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将此代码嵌套在 `if __name__ == "__main__"` 下。这是因为整个脚本在启动另一个进程时将再次运行，这可能导致无限循环。如果代码嵌套在
    `if __name__ == "__main__"` 下，则不会再次运行，因为只有一个主进程。还必须注意的是，我们定义了一个包含四个工作者的池。这可以更改为我们觉得合适的任何值，但增加这个值时，回报会递减，我们将在稍后探讨。列表中的元组是每个计算的参数。运行整个脚本会给我们以下输出：
- en: '[PRE129]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'We can see that the speed is not a quarter of the sequential calculations.
    However, the multiprocessing pool is slightly faster. If you run this multiple
    times, you will get some variance in the difference in times. However, the multiprocessing
    approach will always be faster. Now that we have run a multiprocessing tool in
    Python, we can implement our Fibonacci multithreading in the different context
    of a multiprocessing pool in Rust. Here''s how we''ll do this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，速度不是顺序计算的四分之一。然而，多进程池稍微快一点。如果你多次运行它，你将在时间差异中得到一些变化。然而，多进程方法始终更快。现在我们已经运行了
    Python 中的多进程工具，我们可以在 Rust 的多进程池的不同上下文中实现我们的斐波那契多线程。我们将这样进行：
- en: 'In our new Cargo project, we can code the following function in our `main.rs`
    file:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的新 Cargo 项目中，我们可以在 `main.rs` 文件中编写以下函数：
- en: '[PRE133]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We can see that our Rust function is not more complex than our Python version.
    The extra lines of code are just to account for unexpected inputs.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的 Rust 函数并不比我们的 Python 版本更复杂。额外的代码行只是为了处理意外的输入。
- en: 'To run this and time it, we must import the time crate at the top of the `main.rs`
    file by running the following code:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行此代码并计时，我们必须在 `main.rs` 文件的顶部导入 `time` crate，如下所示：
- en: '[PRE134]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Then, we must compute the exact same Fibonacci numbers as we did in the Python
    implementation, as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须计算与我们在 Python 实现中相同的斐波那契数，如下所示：
- en: '[PRE135]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'To run this, we are going to use the following command:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行这个程序，我们将使用以下命令：
- en: '[PRE136]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We are going to use the release version as that is what we will be using in
    production. Running it gives us the following output:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用发布版本，因为这是我们将在生产中使用的。运行它给我们以下输出：
- en: '[PRE137]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Running this several times will give us an average roundabout of 40 milliseconds.
    Considering that our multiprocessing Python code ran at roughly 3.1 seconds, our
    Rust single-threaded implementation runs 77 times faster than our Python multiprocessing
    code. Just let that sink in! The code was not more complex, and it is memory-safe.
    Therefore, fusing Rust with Python is such a quick win! Combining the aggressive
    typing with the compiler forces us to account for every input and outcome, and
    we are on the way to turbocharging our Python systems with safer, faster code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行几次将给我们一个平均大约 40 毫秒的周转时间。考虑到我们的多进程 Python 代码大约运行了 3.1 秒，我们的 Rust 单线程实现比我们的
    Python 多进程代码快 77 倍。这让人印象深刻！代码并不更复杂，而且它是内存安全的。因此，将 Rust 与 Python 结合起来是一个快速的成功！结合积极的类型检查和编译器强制我们考虑每个输入和输出，我们正在用更安全、更快的代码加速我们的
    Python 系统。
- en: 'Now, we are going to see what happens to the speed when we run our numbers
    through a multithreading tool. Here''s how we''ll go about this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看当我们通过多线程工具运行我们的数字时速度会发生什么。我们将这样进行：
- en: 'To do this, we are going to use the `rayon` crate. We define this dependency
    in our `Cargo.toml` file by running the following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将使用 `rayon` crate。我们通过运行以下代码在 `Cargo.toml` 文件中定义这个依赖项：
- en: '[PRE138]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Once this is done, we import it into our `main.rs` file, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们将其导入到 `main.rs` 文件中，如下所示：
- en: '[PRE139]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We can then run our multithreading pool in our `main` function below our sequential
    calculations by running the following code:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的 `main` 函数中，在我们的顺序计算下方运行我们的多线程池，如下所示：
- en: '[PRE140]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Here, we define the number of threads that our pool builder has. We then execute
    the `into_par_iter` function on the vector. This is achieved by implementing the
    `IntoParallelIterator` trait onto the vector, which is done when the `rayon` crate
    is imported. If it were not imported, then the compiler would complain, stating
    that a vector does not have the `into_par_iter` function associated with it.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们定义了我们的池构建器拥有的线程数量。然后，我们在向量上执行`into_par_iter`函数。这是通过在导入`rayon`crate时将`IntoParallelIterator`trait实现到向量上实现的。如果没有导入，编译器会抱怨，指出向量没有与`into_par_iter`函数相关联。
- en: We then map our Fibonacci function over the integers in the vector utilizing
    a closure and collect them. The calculated Fibonacci numbers are associated with
    the `outcomes` variable.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用闭包在向量中的整数上映射我们的斐波那契函数，并将它们收集起来。计算出的斐波那契数字与`outcomes`变量相关联。
- en: 'We then print them and print the time elapsed. Running this via a release gives
    us the following printout in the console:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打印它们并打印经过的时间。通过发布版运行此代码，控制台会显示以下输出：
- en: '[PRE141]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Running this several times will give you roughly the times stated in the preceding
    console printout. Calculating this gives us a 20% increase in speed. Considering
    that the Python multiprocessing only gave us a 5% increase, we can deduce that
    Rust is also more efficient at multithreading when the right context is applied.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此代码多次将给出前一个控制台输出中所述的大致时间。计算此代码给我们带来了20%的速度提升。考虑到Python的并行处理只给我们带来了5%的提升，我们可以推断出，当应用正确的上下文时，Rust在多线程方面也更为高效。
- en: 'We can go a little further to really see the advantages of these pools. Remember
    that our sequence increases exponentially. In our Rust program, we can add three
    computations for *n* being 46 to our sequential calculations and pooled calculations,
    and we get the following output:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以更进一步，真正看到这些池的优势。记住，我们的序列是指数增长的。在我们的Rust程序中，我们可以在`n`为46时向顺序计算和池计算中添加三个计算，我们得到以下输出：
- en: '[PRE142]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: First, we must acknowledge that the time went from milliseconds to double-digit
    seconds. Exponential scaling algorithms are painful, and just adding 10 to your
    calculation pushes it up greatly. We can also see that our savings have increased.
    Our pooled calculations are now 3.11 times faster as opposed to 1.2 times faster
    in the previous test!
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们必须承认时间从毫秒变成了两位数的秒。指数级缩放算法很痛苦，仅仅在计算中加上10就会极大地提升它。我们还可以看到我们的节省增加了。与之前的测试相比，我们的池计算现在是3.11倍快，而不是1.2倍快！
- en: 'If we add three extra computations for *n* being 46 for our Python implementation,
    we get the following console printout:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在Python实现中为`n`为46添加三个额外的计算，我们得到以下控制台输出：
- en: '[PRE143]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Here, we can see that our Python pooled processing is 2.85 times faster than
    our Python sequential processing. We also must note here that our Rust sequential
    processing is roughly 95 times faster than our Python sequential processing, and
    our Rust pool multithreading is roughly 96 times faster than our Python pool processing.
    As the number of points that need processing increases, so will the difference.
    This highlights even more motivation for plugging Rust into Python.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的Python池处理比Python顺序处理快2.85倍。我们还必须在这里指出，我们的Rust顺序处理大约比Python顺序处理快95倍，我们的Rust池多线程处理大约比Python池处理快96倍。随着需要处理的点的数量增加，这种差异也会增加。这更加突出了将Rust插入Python中的动机。
- en: 'It must be noted that we got our speed increase in our Rust program through
    multithreading as opposed to multiprocessing. Multiprocessing in Rust is not as
    straightforward as in Python—this is mainly down to Rust being a newer language.
    For instance, there is a crate called `mitosis` that will enable us to run functions
    in a separate process; however, this crate only has four contributors, and the
    last contribution at the time of writing this book was 13 months ago. Considering
    this, we should approach multiprocessing in Rust without any third-party crates.
    To achieve this, we need to code a Fibonacci calculation program and a multiprocessing
    program that will call this in different processes, as seen in the following diagram:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指出，我们在Rust程序中通过多线程而不是并行处理获得了速度提升。Rust中的并行处理不像Python中那么直接——这主要是因为Rust是一种较新的语言。例如，有一个名为`mitosis`的crate，它将使我们能够在单独的进程中运行函数；然而，这个crate只有四个贡献者，而本书撰写时的最后贡献是在13个月前。考虑到这一点，我们应该在没有第三方crate的情况下处理Rust中的并行处理。为了实现这一点，我们需要编写一个斐波那契计算程序和一个并行处理程序，该程序将在不同的进程中调用它，如下面的图所示：
- en: '![Figure 3.8 – Multiprocessing in Rust'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – Rust中的多进程'
- en: '](img/Figure_3.08_B17720.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.08_B17720.jpg](img/Figure_3.08_B17720.jpg)'
- en: Figure 3.8 – Multiprocessing in Rust
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – Rust中的多进程
- en: 'We are going to pass our data into these processes and parse the outputs handling
    them in our `multiprocessing.rs` file. To carry this out in the simplest way,
    we code both files in the same directory. First, we build our `fib_process.rs`
    file. We must import what we are going to do by running the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把数据传递给这些进程，并处理`multiprocessing.rs`文件中的输出。为了以最简单的方式执行此操作，我们在同一目录中编写这两个文件。首先，我们构建`fib_process.rs`文件。我们必须通过运行以下代码来导入将要执行的操作：
- en: '[PRE144]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'We want our processes to accept a list of integers to calculate, so we define
    Fibonacci `number` and `numbers` functions, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的进程能够接受一个整数列表来计算，因此我们定义了`Fibonacci`的`number`和`numbers`函数，如下所示：
- en: '[PRE146]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'We have seen these functions before as they have become the standard way to
    calculate Fibonacci numbers in this book. We now must take a list of integers
    from arguments, parse them into integers, pass them into our calculation function,
    and return the results, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过这些函数，因为它们已经成为这本书中计算斐波那契数的标准方式。现在我们必须从参数中获取一个整数列表，将其解析为整数，传递给我们的计算函数，并返回结果，如下所示：
- en: '[PRE165]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Here, we can see that we collect the input from the environment. Once the input
    integers have been parsed into `i32` integers and used to calculate the Fibonacci
    numbers, we merely print them out. Printing out to the console generally acts
    as `stdout`. Our process file is fully coded, so we can compile it with the following
    command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们从环境中收集输入。一旦输入的整数被解析为`i32`整数并用于计算斐波那契数，我们只需将它们打印出来。通常，将输出打印到控制台作为`stdout`。我们的进程文件已经完全编码，因此我们可以使用以下命令编译它：
- en: '[PRE179]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'This creates a binary of our file. Now that this is done, we can move on to
    our `multiprocessing.rs` file that will spawn multiple processes. We import what
    we need by running the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们文件的二进制版本。现在这个步骤完成后，我们可以继续处理我们的`multiprocessing.rs`文件，该文件将启动多个进程。我们通过运行以下代码来导入所需的模块：
- en: '[PRE180]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The `Command` struct is going to be used to spawn off a new process, the `Stdio`
    struct is going to be used to define the piping of data back from the process,
    and the `Child` struct is returned when the process is spawned. We will use them
    to access the output data and get the process to wait to finish. The `BufReader`
    struct is used to read the data from the child process. Now that we have imported
    everything we need, we can define a function that accepts an array of integers
    as strings and spins off the process, returning the `Child` struct, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Command`结构体将用于启动新的进程，`Stdio`结构体将用于定义从进程返回数据的管道，当进程启动时返回`Child`结构体。我们将使用它们来访问输出数据并使进程等待完成。`BufReader`结构体用于从子进程读取数据。现在我们已经导入了所有需要的模块，我们可以定义一个函数，该函数接受一个整数数组作为字符串，并启动进程，返回`Child`结构体，如下所示：'
- en: '[PRE182]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Here, we can see that we just must call our binary and pass in our array of
    strings in the `args` function. We then define the `stdout` and spawn the process,
    returning the `Child` struct. Now that this is done, we can fire off three processes
    in our `main` function and wait for them to complete by running the following
    code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们只需调用我们的二进制文件，并通过`args`函数传递我们的字符串数组。然后我们定义`stdout`并启动进程，返回`Child`结构体。现在这个步骤完成后，我们可以在`main`函数中启动三个进程，并通过运行以下代码等待它们完成：
- en: '[PRE187]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'We can now start extracting the data from these processes inside our `main`
    function by running the following code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`main`函数中通过运行以下代码开始从这些进程提取数据：
- en: '[PRE196]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Here, we can see that we have accessed the data using the `stdout` field, and
    then processed it using the `BufReader` struct. We can then loop through our extracted
    data, appending it to an empty vector and then printing it out by running the
    following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们使用`stdout`字段访问了数据，然后使用`BufReader`结构体进行处理。然后我们可以遍历提取的数据，将其追加到一个空向量中，并通过运行以下代码打印出来：
- en: '[PRE205]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'This code is a little repetitive, but it illustrates how to spawn and manage
    multiple processes in Rust. We then compile the file with the following command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点重复，但它说明了如何在Rust中启动和管理多个进程。然后我们使用以下命令编译文件：
- en: '[PRE216]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'We can then run our multiprocessing code with the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令运行我们的多进程代码：
- en: '[PRE217]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'We then get the output, as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们获取输出，如下所示：
- en: '[PRE218]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: We have now covered all we need to know about running processes and threads
    to speed up our computations. However, we need to be mindful and investigate how
    to customize our threads and processes safely to avoid pitfalls.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了关于运行进程和线程以加快计算所需的所有知识。然而，我们需要注意并调查如何安全地定制我们的线程和进程以避免陷阱。
- en: Customizing threads and processes safely
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地定制线程和进程
- en: In this section, we will cover some of the pitfalls that we have to avoid when
    being creative with threads and processes. We will not cover the concepts in depth,
    as advanced multiprocessing and concurrency is a big topic and there are books
    completely dedicated to this. However, it is important to understand what to look
    out for and which topics to read if you want to increase your knowledge of multiprocessing/threading.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些我们在使用线程和进程进行创新时必须避免的陷阱。我们不会深入探讨这些概念，因为高级多进程和并发是一个很大的主题，而且有专门为此主题编写的书籍。然而，了解需要注意的事项以及哪些主题需要阅读，如果你想要增加你对多进程/线程的知识。
- en: Looking back at our Fibonacci sequences, it might be tempting to spin off extra
    threads inside our thread to speed up the individual computations in the thread
    pool. However, to truly understand if this is a good idea, we need to understand
    **Amdahl's law**.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的斐波那契序列，可能会诱使我们在线程内部生成额外的线程以加快线程池中单个计算的速度。然而，要真正理解这是否是一个好主意，我们需要理解**Amdahl定律**。
- en: Amdahl's law
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Amdahl定律
- en: 'Amdahl''s law lets us describe the trade-off on adding more threads. If we
    spin off threads inside the threads, we will have exponential growth of threads.
    You may be forgiven for thinking this to be a good idea; however, Amdahl''s law
    states that there are diminishing returns when increasing the cores. Have a look
    at the following formula:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Amdahl定律让我们能够描述增加更多线程时的权衡。如果我们在线程内部生成线程，我们将会有线程的指数增长。你可能认为这是一个好主意；然而，Amdahl定律指出，当增加核心数时，收益是递减的。看看下面的公式：
- en: '![](img/B17720_03_003.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 通过Amdahl定律的收益递减](img/B17720_03_003.jpg)'
- en: 'Here, the following applies:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，以下规则适用：
- en: '*Speed*: This is the theoretical speedup of the execution of the whole task.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*速度*: 这是整个任务执行的理论加速。'
- en: '*s*: This is the speedup of the part of the task that benefits from improved
    system resources.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*s*: 这是指受益于改进系统资源的任务部分的加速。'
- en: '*p*: This is the proportion of execution time that the part benefiting from
    improved resources originally occupied.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p*: 这是指原本受益于改进资源的部分所占用执行时间的比例。'
- en: 'In general, increasing the cores does have an impact; however, the diminishing
    returns can be seen in the following screenshot:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，增加核心数确实有影响；然而，收益递减可以在以下屏幕截图中看到：
- en: '![Figure 3.9 – Diminishing returns through Amdahl''s law](img/Figure_3.09_B17720.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 通过Amdahl定律的收益递减](img/Figure_3.09_B17720.jpg)'
- en: 'Figure 3.9 – Diminishing returns through Amdahl''s law [Source: Daniels220
    (https://commons.wikimedia.org/w/index.php?curid=6678551), CC BY-SA 3.0]'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 通过Amdahl定律的收益递减 [来源：Daniels220 (https://commons.wikimedia.org/w/index.php?curid=6678551),
    CC BY-SA 3.0]
- en: Considering this, we might want to investigate using a broker to manage our
    multiprocessing. However, this can lead to using **clogging** up the broker, resulting
    in **deadlock**. To understand the gravity of this situation, we will explore
    deadlocks in the next section.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可能想要研究使用代理来管理我们的多进程。然而，这可能导致代理**拥堵**，从而导致**死锁**。为了理解这种情况的严重性，我们将在下一节中探讨死锁。
- en: Deadlocks
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁
- en: 'Deadlocks can arise when it comes to bigger applications, where it is common
    to manage the multiprocessing through a task broker. This is usually managed via
    a database or caching mechanism such as Redis. This consists of a queue where
    the tasks are added, as illustrated here:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到更大的应用程序时，死锁可能会出现，在这些应用程序中，通常通过任务代理来管理多进程。这通常是通过数据库或缓存机制（如Redis）来管理的。它包括一个任务队列，任务被添加到其中，如图所示：
- en: '![Figure 3.10 – The flow of tasks when multiprocessing with a broker or queue'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 使用代理或队列进行多进程时的任务流程'
- en: '](img/Figure_3.10_B17720.png)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B17720.png)'
- en: Figure 3.10 – The flow of tasks when multiprocessing with a broker or queue
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 使用代理或队列进行多进程时的任务流程
- en: Here, we can see that new tasks can be added to the queue. As time goes on,
    the oldest tasks get taken off the queue and passed into the pool. Throughout
    the application, our code can send functions and parameters to the queue anywhere
    in the application.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到可以添加新任务到队列。随着时间的推移，最旧的任务被从队列中移除并传递到池中。在整个应用程序中，我们的代码可以在应用程序的任何地方发送函数和参数到队列。
- en: 'In Python, the library that does this is called **Celery**. There is also a
    Celery crate for Rust. This approach is also utilized for multiple server setups.
    Considering this, we could be tempted to send tasks to the queue inside another
    task. However, we can see here that this approach can lock up our queue:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，执行此操作的库被称为**Celery**。还有为 Rust 定制的 Celery crate。这种方法也用于多个服务器设置。考虑到这一点，我们可能会倾向于在另一个任务内部发送任务到队列。然而，我们可以看到这种方法可能会锁定我们的队列：
- en: '![Figure 3.11 – Deadlock with task broker'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – 与任务代理的死锁'
- en: '](img/Figure_3.11_B17720.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B17720.jpg)'
- en: Figure 3.11 – Deadlock with task broker
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 与任务代理的死锁
- en: 'In *Figure 3.11*, we can see that the tasks in the pool have sent tasks to
    the queue. However, they cannot complete until their dependencies have been executed.
    The thing is, they will never execute because the pool is full of tasks waiting
    for their dependency to complete and the pool is full, so they cannot be processed.
    The issue with this problem is that there are no errors raised with this—the pool
    will just hang. Deadlock is not the only problem that will arise without helpful
    warnings. Considering this, we must cover our last concept that we should be aware
    of before being creative: **race conditions**.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3.11* 中，我们可以看到池中的任务已经将任务发送到队列。然而，它们无法完成，直到它们的依赖项被执行。问题是，它们永远不会执行，因为池中充满了等待依赖项完成的任务，并且池已满，因此无法处理。这个问题的问题是，没有错误被抛出——池将只是挂起。死锁不是唯一在没有有用警告的情况下会出现的问题。考虑到这一点，我们必须涵盖我们在创新之前应该注意的最后一个概念：**竞态条件**。
- en: Race conditions
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞态条件
- en: 'Race conditions occur when two or more threads access shared data that they
    both try to change. As we have noted when we were building and running our threads,
    they sometimes ran out of order. We can demonstrate this with a simple concept,
    as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程访问它们都试图更改的共享数据时，就会发生竞态条件。正如我们在构建和运行线程时所指出的，它们有时会运行得无序。我们可以用一个简单的概念来演示这一点，如下所示：
- en: If we were to have *thread one* calculate a price and write to a file and *thread
    two* to also calculate a price, read the price calculated from the *thread one*
    file, and add them together, there could be a chance that the price will not be
    written to the file before *thread two* reads it. What is even worse is that there
    could be an old price in the file. If this is the case, we will never know that
    the error occurred. The term *race conditions* is built upon the fact that both
    threads are racing to the data.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们让 *线程一* 计算价格并将结果写入文件，而 *线程二* 也计算价格并从 *线程一* 的文件中读取计算出的价格并将它们相加，那么价格可能不会在
    *线程二* 读取它之前写入文件。更糟糕的是，文件中可能有一个旧的价格。如果是这种情况，我们将永远不知道错误发生了。*竞态条件*这个术语是基于这样一个事实，即两个线程都在争夺数据。
- en: As a solution to race conditions, we can introduce **locks**. Locks can be utilized
    for stopping other threads from accessing certain things such as a file until
    your thread has finished with it. However, it has to be noted that these locks
    only work inside the process; therefore, other processes can access the file.
    Caching solutions such as Redis and general databases have already implemented
    these safeguards, and locks will not protect against the race condition described
    in this section. In my experience, when we get creative with thread concepts such
    as locks, it is usually a sign that we must take a step back and rethink our design.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决竞态条件的一种方法，我们可以引入**锁**。锁可以被用来阻止其他线程在您的线程完成之前访问某些东西，例如一个文件。然而，必须注意，这些锁只在进程内部起作用；因此，其他进程可以访问该文件。像
    Redis 和通用数据库这样的缓存解决方案已经实现了这些安全措施，并且锁不能保护本节中描述的竞态条件。根据我的经验，当我们对锁等线程概念进行创新时，通常是一个我们必须退一步重新思考设计的信号。
- en: Even an SQLite database file will manage our data race issues when reading and
    writing to a file, and if the data race condition described at the start of this
    section looks like it might happen, it is best to just not have them running at
    the same time at all. Sequential programming is safer and more useful.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是SQLite数据库文件也会在读写文件时管理我们的数据竞争问题，如果本节开头描述的数据竞争条件看起来可能发生，最好是根本不要让它们同时运行。顺序编程更安全且更有用。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the basics of multiprocessing and multithreading.
    We then went through practical ways to utilize threads and processes. We then
    explored the Fibonacci sequence to explore how processes can speed up our computations.
    We also saw through the Fibonacci sequence that how we compute our problems is
    the biggest factor over threads and processes. Algorithms that scale exponentially
    should be avoided before reaching for multiprocessing for speed gains. We must
    remember that while it might be tempting to reach for more complex approaches
    to multiprocessing, this can lead to problems such as deadlock and data races.
    We kept our multiprocessing tight by keeping it contained within a processing
    pool. If we keep these principles in mind and keep all our multiprocessing contained
    to a pool, we will keep our hard-to-diagnose problems to a minimum. This does
    not mean that we should never be creative with multiprocessing but it is advised
    to do further reading on this field, as there are books entirely dedicated to
    concurrency (as noted in the *Further reading* section, with particular chapters
    to focus on). This is just an introduction to enable us to use concurrency in
    our Python packages if needed. In the next chapter, we will be building our own
    Python packages so that we can distribute our Python code across multiple projects
    and reuse code.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了多进程和多线程的基础知识。然后，我们探讨了利用线程和进程的实用方法。接着，我们通过斐波那契数列来探讨进程如何加速我们的计算。我们还通过斐波那契数列看到，我们解决问题的方法比线程和进程更为重要。在追求多进程以获得速度提升之前，应该避免那些指数级扩展的算法。我们必须记住，虽然可能很诱人去寻求更复杂的多进程方法，但这可能导致死锁和数据竞争等问题。我们通过将多进程限制在处理池中，保持了多进程的紧凑性。如果我们牢记这些原则，并将所有多进程都包含在池中，我们将把难以诊断的问题降到最低。这并不意味着我们永远不应该在多进程中发挥创造性，但建议进一步阅读这一领域，因为有一些书籍完全致力于并发（如*进一步阅读*部分所述，特别章节关注）。这只是一个介绍，使我们能够在需要时在我们的Python包中使用并发。在下一章中，我们将构建自己的Python包，以便我们可以将我们的Python代码分发到多个项目中并重用代码。
- en: Questions
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a process and a thread?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程和线程之间的区别是什么？
- en: Why wouldn't multithreading speed up our Python Fibonacci sequence calculations?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么多线程不会加快我们的Python斐波那契数列计算？
- en: Why is a multiprocessing pool used?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用多进程池？
- en: Our threads in Rust return `Result<i8, Box<dyn Any + Send>>`. What does this
    mean?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Rust中的线程返回`Result<i8, Box<dyn Any + Send>>`。这是什么意思？
- en: Why should we avoid using a recursion tree if we can?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可以的话，为什么我们应该避免使用递归树？
- en: Should you just spin up more processes when you need a faster runtime?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要更快的运行时，你只是启动更多的进程吗？
- en: Why should you avoid complex multiprocessing if you can?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可以的话，为什么你应该避免复杂的多进程？
- en: What does `join` do for our program in multithreading?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`join`在多线程中对我们程序有什么作用？'
- en: Why does `join` not return anything in a process?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`join`在进程中不返回任何内容？
- en: Answers
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Threads are lightweight and enable multithreading, where we can run multiple
    tasks that could have idle time. A process is more expensive, enabling us to run
    multiple CPU-heavy tasks at the same time. Processes do not share memory, while
    threads do.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程轻量级，并支持多线程，我们可以运行可能存在空闲时间的多项任务。进程更昂贵，使我们能够同时运行多个CPU密集型任务。进程不共享内存，而线程则共享。
- en: Multithreading would not speed up our Fibonacci sequence calculations because
    calculating Fibonacci numbers is a CPU-heavy task that does not have any idle
    time; therefore, the threads would run sequentially in Python. However, we did
    demonstrate that Rust can run multiple threads at the same time, getting a significant
    speed increase.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多线程不会加快我们的斐波那契数列计算，因为计算斐波那契数是一个CPU密集型任务，没有空闲时间；因此，在Python中线程会顺序执行。然而，我们确实展示了Rust可以同时运行多个线程，从而获得显著的加速。
- en: Multiprocessing is expensive and the processes do not share memory, making the
    implementation potentially more complex. A processing pool keeps the multiprocessing
    part of a program to a minimum. This approach also enables us to easily control
    the different numbers of workers we need as they're all in one place, and we can
    also return all the outcomes in the same sequence as they are returned from the
    multiprocessing pool.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多进程成本高昂，并且进程不共享内存，这使得实现可能更加复杂。进程池将程序的并发部分保持在最低限度。这种方法还使我们能够轻松控制所需的工人数量，因为它们都在一个地方，我们还可以以与多进程池返回相同的顺序返回所有结果。
- en: Our Rust thread could fail. If it doesn't, then it will return an integer. If
    it fails, it could return anything of any size, which is why it's on the heap.
    It also has the `Send` trait, which means that it can be sent across threads.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 Rust 线程可能会失败。如果没有失败，它将返回一个整数。如果失败了，它可能返回任何大小的事物，这就是为什么它在堆上的原因。它还具有 `Send`
    特性，这意味着它可以跨线程传递。
- en: Recursion trees scale exponentially. Even if we are multithreading, our computation
    time will quickly scale, pushing our milliseconds into seconds once we've crossed
    a boundary.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归树呈指数级扩展。即使我们使用多线程，我们的计算时间也会迅速扩展，一旦我们越过边界，毫秒就会变成秒。
- en: No—as demonstrated in Amdahl's law, increasing the workers will give us some
    speedup, but we will have diminishing returns as the number of workers increases.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不——正如阿姆达尔定律所证明的，增加工人数量将给我们带来一些加速，但随着工人数量的增加，我们将获得递减的回报。
- en: Complex multiprocessing/multithreading can introduce a range of silent errors
    such as deadlock and data races that can be hard to diagnose and solve.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复杂的多进程/多线程可能会引入一系列静默错误，如死锁和数据竞争，这些错误可能难以诊断和解决。
- en: '`join` blocks the program until the thread has completed. It can also return
    the result of the thread if we overwrite Python''s `join` function.'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`join` 会阻塞程序，直到线程完成。它还可以返回线程的结果，如果我们重写 Python 的 `join` 函数。'
- en: Processes do not share the same memory space, therefore they cannot be accessed.
    We can, however, access data from other processes by saving data to files for
    our main process to access or pipe data via `stdin` and `stdout`, as we did in
    our Rust multiprocessing example.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程不共享相同的内存空间，因此它们无法被访问。然而，我们可以通过将数据保存到文件以供主进程访问或通过 `stdin` 和 `stdout` 管道数据来访问其他进程，就像我们在
    Rust 多进程示例中所做的那样。
- en: Further reading
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Pan Wu* (2020). *Understanding Python Multithreading and Multiprocessing via
    Simulation:* https://towardsdatascience.com/understanding-python-multithreading-and-multiprocessing-via-simulation-3f600dbbfe31'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*潘武* (2020). *通过模拟理解 Python 的多线程和多进程:* https://towardsdatascience.com/understanding-python-multithreading-and-multiprocessing-via-simulation-3f600dbbfe31'
- en: '*Brian Troutwine* (2018). *Hands-On Concurrency with Rust*'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布莱恩·特劳特温* (2018). *Rust 并发实战*'
- en: '*Gabriele Lanaro* and *Quan Nguyen* (2019). *Learning Path Advanced Python
    Programming*: [*Chapter 8*](B17720_08_Final_SK_ePub.xhtml#_idTextAnchor142) (*Advanced
    Introduction to Concurrent and Parallel Programming*)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加布里埃尔·拉纳罗和阮权* (2019). *高级 Python 编程学习路径*: [*第8章*](B17720_08_Final_SK_ePub.xhtml#_idTextAnchor142)
    (*高级并发和并行编程介绍*)'
- en: '*Andrew Johnson* (2018). *Hands-On Functional Programming in Rust*: [*Chapter
    8*](B17720_08_Final_SK_ePub.xhtml#_idTextAnchor142) (*Implementing Concurrency*)'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安德鲁·约翰逊* (2018). *Rust 函数式编程实战*: [*第8章*](B17720_08_Final_SK_ePub.xhtml#_idTextAnchor142)
    (*实现并发*)'
- en: '*Rahul Sharma and Vesa Kaihlavirta* (2018). *Mastering Rust*: [*Chapter 8*](B17720_08_Final_SK_ePub.xhtml#_idTextAnchor142)
    (*Concurrency*)'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拉胡尔·夏尔马和维萨·卡伊拉维塔* (2018). *精通 Rust*: [*第8章*](B17720_08_Final_SK_ePub.xhtml#_idTextAnchor142)
    (*并发*)'
