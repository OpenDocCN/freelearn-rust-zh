- en: Getting Started with Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust入门
- en: Learning a new language is like building a house – the foundation needs to be
    strong. With a language that changes the way you think and reason about your code,
    there's always more effort involved in the beginning, and it's important to be
    aware of that. The end result, however, is that you get to shift your thinking
    with these new-found concepts and tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门新语言就像建造一座房子——基础需要牢固。使用一门能改变你思考代码方式的语言，一开始总是需要更多的努力，并且重要的是要意识到这一点。然而，最终的结果是，你可以通过这些新发现的概念和工具来转变你的思维方式。
- en: This chapter will give you a whirlwind tour on the design philosophy of Rust,
    an overview of its syntax and the type system. We assume that you have a basic
    knowledge of mainstream languages such as C, C++, or Python, and the ideas that
    surround object-oriented programming. Each section will contain example code,
    along with an explanation of it. There will be ample code examples and output
    from the compiler, that will help you become familiar with the language. We'll
    also delve into a brief history of the language and how it continues to evolve.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带你快速了解Rust的设计理念，其语法和类型系统的概述。我们假设你具备主流语言（如C、C++或Python）的基本知识，以及围绕面向对象编程的思想。每个部分都将包含示例代码及其解释。将有大量的代码示例和编译器的输出，帮助你熟悉这门语言。我们还将简要介绍这门语言的历史以及它如何持续发展。
- en: Getting familiar with a new language requires perseverance, patience, and practice.
    I highly recommend to all readers that you manually write and don't copy/paste
    the code examples listed here. The best part of writing and fiddling with Rust
    code is the precise and helpful error messages you get from the compiler, which
    the Rust community often likes to call error-driven development. We'll see these
    errors frequently throughout this book to understand how the compiler thinks of
    our code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉一门新语言需要毅力、耐心和实践。我强烈建议所有读者手动编写代码，而不是复制粘贴这里列出的代码示例。编写和调试Rust代码的最好部分是来自编译器的精确且有用的错误信息，Rust社区通常喜欢称之为错误驱动开发。在这本书的整个过程中，我们将频繁地看到这些错误，以了解编译器是如何看待我们的代码的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is Rust and why should you care?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust是什么，为什么你应该关心？
- en: Installing the Rust compiler and the toolchain
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Rust编译器和工具链
- en: A brief tour of the language and its syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言及其语法的简要概述
- en: A final exercise, where we'll put what we've learned together
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的练习，我们将把所学的内容综合运用
- en: What is Rust and why should you care?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust是什么，为什么你应该关心？
- en: '" Rust is technology from the past came to save the future from itself. "'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '"Rust是来自过去的科技，用来拯救未来免于自身的问题。"'
- en: '*                                                                         
                                                                                 
                                                                                 
                                                                                 
                                                                                 
                                                 - Graydon Hoare*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*                                                                         
                                                                                 
                                                                                 
                                                                                 
                                                                                 
                                                 - 格雷顿·霍华德*'
- en: Rust is a fast, concurrent, safe, and empowering programming language originally
    started and developed by *Graydon Hoare* in ­2006\. It's now an open source language
    that's developed mainly by a team from Mozilla with collaboration from lots of
    open source folks. The first stable version, 1.0, was released in May 2015\. The
    project began with the hope of mitigating memory safety issues that came up in
    **gecko** with the use of C++. Gecko is the browser engine that's used in Mozilla's
    Firefox browser. C++ is not an easy language to tame and has concurrency abstractions
    that can be easily misused. With gecko using C++, a couple of attempts were made
    (in 2009 and 2011) to parallelize its **cascading style sheets** (**CSS**) parsing
    code to leverage modern parallel CPUs. They failed, as the concurrent C++ code
    was too hard to maintain and reason about. With a large number of developers collaborating
    on the mammoth code base that gecko has, writing concurrent code with C++ is not
    a joyride. In the hope of incrementally removing the painful parts of C++, Rust
    was born and, with it, Servo, a new research project of creating a browser engine
    from scratch was initiated. The Servo project provides feedback to the language
    team by using the bleeding edge language features that, in turn, influences the
    evolution of the language. Around November 2017, parts of the Servo project, particularly
    the **stylo** project (a parallel CSS parser in Rust) started shipping to the
    latest Firefox release (Project Quantum), which is a great feat in such a short
    amount of time. Servo's end goal is to incrementally replace components in gecko
    with its components.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种快速、并发、安全且赋予力量的编程语言，最初由 *Graydon Hoare* 在 2006 年启动并开发。现在它是一个开源语言，主要由来自
    Mozilla 的团队开发，同时得到了许多开源人士的合作。第一个稳定版本 1.0 在 2015 年 5 月发布。该项目始于缓解 C++ 在 **gecko**
    中使用时出现的内存安全问题。Gecko 是 Mozilla Firefox 浏览器中使用的浏览器引擎。C++ 并非易驯的语言，其并发抽象容易被误用。由于 Gecko
    使用 C++，在 2009 年和 2011 年尝试并行化其 **级联样式表**（**CSS**）解析代码以利用现代并行 CPU 时失败了。这是因为并发的 C++
    代码难以维护和推理。在众多开发者共同协作于 gecko 的庞大代码库时，用 C++ 编写并发代码并非易事。为了逐步消除 C++ 的痛苦部分，Rust 诞生了，随之而来的是
    Servo，一个从头开始创建浏览器引擎的新研究项目。Servo 项目通过使用最前沿的语言特性为语言团队提供反馈，反过来，这些特性又影响了语言的发展。大约在
    2017 年 11 月，Servo 项目的部分内容，尤其是 **stylo** 项目（一个用 Rust 编写的并行 CSS 解析器），开始随最新的 Firefox
    版本（Project Quantum）发布，这在如此短的时间内是一项了不起的成就。Servo 的最终目标是逐步用其组件替换 gecko 中的组件。
- en: Rust is inspired by a multitude of languages, the notable ones being Cyclone
    (a safe dialect of C language) for its ideas on region-based memory management
    techniques; C++ for its RAII principle, and Haskell for its type system, error
    handling types, and typeclasses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 吸收了许多语言的灵感，其中最值得注意的是 Cyclone（C 语言的安全方言）在基于区域的内存管理技术方面的理念；C++ 在 RAII 原则方面，以及
    Haskell 在类型系统、错误处理类型和类型类方面。
- en: '**RAII** stands for **Resource Acquisition Is Initialization**, a paradigm
    suggesting that resources must be acquired during the initialization of an object
    and must be released when their destructors are called or when they are deallocated.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAII** 代表 **资源获取即初始化**，这是一种范式，表明资源必须在对象的初始化期间获取，并在它们的析构函数被调用或它们被释放时必须释放。'
- en: The language has a very minimal runtime, does not need garbage collection, and
    prefers stack allocation by default over heap allocation (an overhead) for any
    value that's declared in a program. We'll explain all of this in [Chapter 5](db2c2723-8ca0-43be-b135-afd847342146.xhtml),
    *Memory Management and Safety*. The Rust compiler, **rustc**, was originally written
    in Ocaml (a functional language) and became a self-hosting one in 2011 after being
    written in itself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言具有非常小的运行时，不需要垃圾回收，并且默认优先使用栈分配（相对于堆分配的额外开销）来分配任何在程序中声明的值。我们将在 [第 5 章](db2c2723-8ca0-43be-b135-afd847342146.xhtml)
    中解释所有这些内容，*内存管理和安全性*。Rust 编译器 **rustc** 最初是用 Ocaml（一种函数式语言）编写的，并在 2011 年成为自宿主编译器，那时它已经用自己编写了。
- en: Self-hosting is when a compiler is built by compiling its own source code. This
    process is known as bootstrapping a compiler. Compiler its own source code acts
    as a really good test case for the compiler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自宿主编译器是指通过编译其自己的源代码来构建编译器。这个过程被称为编译器的引导。编译器自己的源代码作为编译器的一个非常好的测试用例。
- en: 'Rust is openly developed on GitHub at [https://github.com/rust-lang/rust](https://github.com/rust-lang/rust)
    and continues to evolve at a fast pace. New features are added to the language
    through a community-driven **Request For Comments** (**RFC**) process where anybody
    can propose new language features. These are then described in detail in an RFC
    document. A consensus is then sought after for the RFC and if agreed upon, the
    implementation phase begins for the feature. The implemented feature then gets
    reviewed by the community, where it is eventually merged to the master branch
    after undergoing several tests by users in nightly releases. Getting feedback
    from the community is crucial for the language''s evolution. Every six weeks,
    a new stable version of the compiler is released. Along with fast moving incremental
    updates, Rust also has this notion of editions, which is proposed to provide a
    consolidated update to the language. This includes tooling, documentation, its
    ecosystem, and to phase in any breaking changes. So far, there have been two editions:
    *Rust 2015*, which had a focus on stability, and *Rust 2018*, which is the current
    edition at the time of writing this book and focuses on productivity.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 语言在 GitHub 上公开开发，地址为 [https://github.com/rust-lang/rust](https://github.com/rust-lang/rust)，并且以较快的速度持续进化。新特性通过社区驱动的**请求评论**（**RFC**）流程添加到语言中，任何人都可以提出新的语言特性。这些特性随后在
    RFC 文档中详细描述。然后，对 RFC 进行共识寻求，如果达成一致，则开始该特性的实施阶段。实施后的特性将由社区进行审查，最终在经过用户在夜间版本中的多次测试后，合并到主分支。从社区获取反馈对于语言的进化至关重要。每六周，编译器会发布一个新的稳定版本。除了快速移动的增量更新外，Rust
    还具有版本的概念，旨在为语言提供综合更新。这包括工具、文档、其生态系统，以及逐步引入任何破坏性变更。到目前为止，已经有两个版本：*Rust 2015*，该版本侧重于稳定性，以及*Rust
    2018*，这是撰写本书时的当前版本，侧重于生产力。
- en: While being a general purpose multi-paradigm language, it is aiming for systems
    programming domain where C and C++ have been predominant. This means that you
    can write operating systems, game engines, and many performance critical applications
    with it. At the same time, it is also expressive enough that you can build high-performance web
    applications, network services, type-safe database **Object Relational Mapper**
    (**ORM**) libraries, and can also run on the web by compiling down to WebAssembly.
    Rust has also gained a fair share of interest in building safety-critical, real-time
    applications for embedded platforms such as the Arm's Cortex-M based microcontrollers,
    a domain mostly dominated by C at present. This gamut of applicability in various
    domains – which Rust exhibits quite well – is something that very rare to find
    in a single programming language. Moreover, established companies Cloudflare,
    Dropbox*,* Chuckfish*,* npm,and many more are already using it in production for
    their high-stakes projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Rust是一种通用多范式语言，但它旨在系统编程领域，在这个领域C和C++一直占据主导地位。这意味着你可以用它来编写操作系统、游戏引擎以及许多性能关键型应用。同时，它也足够表达，你可以用它构建高性能的Web应用、网络服务、类型安全的数据库**对象关系映射器**（**ORM**）库，并且可以通过编译成WebAssembly在Web上运行。Rust在构建用于嵌入式平台的安全关键型、实时应用方面也获得了相当的关注，例如基于Arm的Cortex-M的微控制器，目前这个领域主要被C所主导。Rust在各种领域中的应用范围——它表现得相当出色——在单一编程语言中是非常罕见的。此外，像Cloudflare、Dropbox*、Chuckfish*、npm等知名公司已经在他们的高风险项目中将其用于生产。
- en: 'Rust is characterized as a statically and strongly typed language. The static
    property means that the compiler has information about all of the variables and
    their types at compile time and does most of its checks at compile time, leaving
    very minimal type checking at runtime. Its strong nature means that it does not
    allow things such as auto-conversion between types, and that a variable pointing
    to an integer cannot be changed to point to a string later in code. For example,
    in weakly typed languages such as JavaScript, you can easily do something like `two
    = "2"; two = 2 + two;`. JavaScript weakens the type of `2` to be a string at runtime,
    thus storing `22` as a string in `two`, something totally contrary to your intent
    and meaningless. In Rust, the same code, that is, `let mut two = "2"; two = 2
    + two;`, would get caught at compile time, throwing the following error: `` cannot
    add `&str` to `{integer}` ``. This property enables safe refactoring of code and
    catches most bugs at compile time rather than causing issues at runtime.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 被描述为一种静态和强类型语言。静态属性意味着编译器在编译时对所有变量及其类型都有信息，并在编译时进行大部分检查，只在运行时进行非常少的类型检查。其强类型特性意味着它不允许类型之间的自动转换，例如，一个指向整数的变量不能在代码的后续部分被改变为指向字符串。例如，在弱类型语言如
    JavaScript 中，你可以轻松地做类似以下操作：`two = "2"; two = 2 + two;`。JavaScript 在运行时会将 `2` 的类型弱化为字符串，从而将
    `22` 作为字符串存储在 `two` 中，这与你的意图完全相反，并且毫无意义。在 Rust 中，相同的代码，即 `let mut two = "2"; two
    = 2 + two;`，将在编译时被捕获，并抛出以下错误：`cannot add `&str` to `{integer}``。这一特性使得代码重构更加安全，并在编译时而不是在运行时捕获大多数错误。
- en: Programs written in Rust are very expressive as well as performant, in the sense
    that you can have most of the features of high-level functional style languages
    such as higher-order functions and lazy iterators, yet it compiles down to efficient
    code like a C/C++ program. The defining principles that underline many of its
    design decisions are compile-time memory safety, fearless concurrency, and zero
    cost abstractions. Let's elaborate on these ideas.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rust 编写的程序既具有很高的表达性，又具有高性能，这意味着你可以拥有类似于高阶函数和惰性迭代器等高级函数式语言的大多数特性，同时它编译后的代码效率又像
    C/C++ 程序一样高效。支撑其许多设计决策的核心理念是编译时内存安全、无畏并发和零成本抽象。让我们详细阐述这些观点。
- en: '**Compile time memory safety**: The Rust compiler can track variables owning
    a resource in your program at compile time and does all of this without a garbage
    collector.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译时内存安全**：Rust 编译器可以在编译时跟踪程序中拥有资源的变量，并且这一切都不需要垃圾回收器来完成。'
- en: Resources can be memory address, a variable holding a value, shared memory reference,
    file handles, network sockets, or database connection handles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 资源可以是内存地址、一个持有值的变量、共享内存引用、文件句柄、网络套接字或数据库连接句柄。
- en: This means that you can't have infamous problems with pointers use after free,
    double free, or dangling pointers at runtime. Reference types in Rust (types with
    `&` before them) are implicitly associated with a lifetime tag (`'foo`) and sometimes
    annotated explicitly by the programmer. Through lifetimes, the compiler can track
    places in code where a reference is safe to use, reporting an error at compile
    time if it's illegal. To achieve this, Rust runs a borrow/reference checking algorithm
    by using these lifetime tags on references to ensure that you can never access
    a memory address that has been freed. It also does this so that you cannot free
    any pointer while it is being used by some other variable. We will go into the
    details of this in [Chapter 5](db2c2723-8ca0-43be-b135-afd847342146.xhtml), *Memory
    management and Safety*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不会在运行时遇到指针使用后释放、重复释放或悬垂指针等臭名昭著的问题。Rust 中的引用类型（在它们前面有 `&` 的类型）隐式地关联着一个生命周期标签（例如
    `'foo'），有时程序员还会显式地对其进行注释。通过生命周期，编译器可以跟踪代码中可以安全使用引用的地方，如果发现非法使用，则在编译时报告错误。为了实现这一点，Rust
    通过在引用上使用这些生命周期标签来运行借用/引用检查算法，确保你永远不能访问已经被释放的内存地址。它还确保在某个变量使用指针时，你不能释放该指针。我们将在[第
    5 章](db2c2723-8ca0-43be-b135-afd847342146.xhtml)“内存管理和安全性”中详细介绍这一点。
- en: '**Zero-cost abstractions**: Programming is all about managing complexity, which
    is facilitated by good abstractions. Let''s go through a fine example of abstraction
    in both Rust and Kotlin (a language targeting **Java virtual machines** (**JVM**)
    that lets us write high-level code and is easy to read and reason about. We''ll
    compare Kotlin''s streams and Rust''s iterators in manipulating a list of numbers
    and contrast the zero cost abstraction principle that Rust provides. The abstraction
    here is to be able to use methods that take other methods as arguments to filter
    numbers based on a condition without using manual loops. Kotlin is used here for
    its visual similarity with Rust. The code is fairly simple to understand and we
    aim to give a high-level explanation. We''ll be glossing over the details in code
    as the whole point of this example is to understand the zero cost property.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**零成本抽象**：编程全部关于管理复杂性，而良好的抽象有助于简化这一点。让我们通过 Rust 和 Kotlin（一个针对 **Java 虚拟机**（**JVM**）的语言，它允许我们编写高级代码，易于阅读和推理）中抽象的一个优秀例子来探讨抽象。我们将比较
    Kotlin 的流和 Rust 的迭代器在操作数字列表时的表现，并对比 Rust 提供的零成本抽象原则。这里的抽象是能够使用接受其他方法作为参数的方法来根据条件过滤数字，而不使用手动循环。在这里使用
    Kotlin 是因为它与 Rust 的视觉相似性。代码相当简单易懂，我们的目标是给出一个高级解释。我们将略过代码的细节，因为整个例子的主要目的是理解零成本属性。'
- en: 'First, let''s look at the code in Kotlin (the following code can be run online: [https://try.kotlinlang.org](https://try.kotlinlang.org/#/UserProjects/p1dcj8hnumcloa96jsq9t8q8ba/bjptps10adpigeoe1k4bdg1m46)):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，让我们看看 Kotlin 中的代码（以下代码可以在线运行：[https://try.kotlinlang.org](https://try.kotlinlang.org/#/UserProjects/p1dcj8hnumcloa96jsq9t8q8ba/bjptps10adpigeoe1k4bdg1m46)):'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create a stream of numbers (line 6) and call a chain of methods (`filter`
    and `map`) to transform the elements to collect only squares of even numbers.
    These methods can take a closure or a function (that is, `it -> it * it` at line
    8) to transform each element in the collection. In functional style languages,
    when we call these methods on the stream/iterator, for every such call, the language
    creates an intermediate object to keep any state or metadata in regard to the
    operation being performed. As a result, `evens` and `evenSquares` will be two
    different intermediate objects that are allocated on the JVM heap. Allocating
    things on the heap incurs a memory overhead. That's the extra cost of abstraction
    we have to pay in Kotlin !
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个数字流（第 6 行）并调用一系列方法（`filter` 和 `map`）来转换元素，只收集偶数的平方。这些方法可以接受一个闭包或函数（即第
    8 行的 `it -> it * it`）来转换集合中的每个元素。在函数式风格的语言中，当我们对流/迭代器调用这些方法时，对于每个这样的调用，语言都会创建一个中间对象来保持与正在执行的操作相关的任何状态或元数据。因此，`evens`
    和 `evenSquares` 将是两个不同的中间对象，它们在 JVM 堆上分配。在堆上分配东西会产生内存开销。这就是我们在 Kotlin 中必须支付的抽象额外成本！
- en: 'When we print the value of `evens` and `evenSquares`, we indeed get different
    objects, as show here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印 `evens` 和 `evenSquares` 的值时，我们确实得到不同的对象，如下所示：
- en: '`java.util.stream.ReferencePipeline$Head@51521cc1`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.stream.ReferencePipeline$Head@51521cc1`'
- en: '`java.util.stream.ReferencePipeline$3@1b4fb997`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.stream.ReferencePipeline$3@1b4fb997`'
- en: The hex value after the `@` is the object's hash code on the JVM. Since the
    hash codes are different, they are different objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@` 符号后面的十六进制值是在 JVM 上对象的哈希码。由于哈希码不同，它们是不同的对象。'
- en: 'In Rust, we do the same thing (the following code can be run online: [https://gist.github.com/rust-play/e0572da05d999cfb6eb802d003b33ffa](https://gist.github.com/rust-play/e0572da05d999cfb6eb802d003b33ffa)):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Rust 中，我们做同样的事情（以下代码可以在线运行：[https://gist.github.com/rust-play/e0572da05d999cfb6eb802d003b33ffa](https://gist.github.com/rust-play/e0572da05d999cfb6eb802d003b33ffa)):'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Glossing over the details, on line 2 we call `vec![]` to create a list of numbers
    on the heap, followed by calling `into_iter()` to make it a iterator/stream of
    numbers. The `into_iter()` method creates a wrapper Iterator type, `IntoIter([1,2,3,4,5,6,7,8,9,10])`,
    out of a collection (here, `Vec <i32>` is a list of signed 32 bit integers). This
    iterator type references the original list of numbers. We then perform filter
    and map transformations (lines 3 and 4), just like we did in Kotlin. Lines 7 and
    8 print the type of `evens` and `even_squares`, as follows (some details have
    been omitted for brevity):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 略过细节，在第 2 行我们调用 `vec![]` 来在堆上创建一个数字列表，然后调用 `into_iter()` 来使其成为数字的迭代器/流。`into_iter()`
    方法从一个集合（在这里，`Vec <i32>` 是一个有符号 32 位整数的列表）创建一个包装迭代器类型，`IntoIter([1,2,3,4,5,6,7,8,9,10])`。这个迭代器类型引用原始数字列表。然后我们执行过滤和映射转换（第
    3 和 4 行），就像我们在 Kotlin 中做的那样。第 7 和 8 行打印 `evens` 和 `even_squares` 的类型，如下（为了简洁起见，省略了一些细节）：
- en: '| `evens:`  | ` Filter { iter: IntoIter( <numbers> ) } ` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `evens:`  | ` Filter { iter: IntoIter( <numbers> ) } ` |'
- en: '| `even_squares:` | ` Map { iter: Filter { iter: IntoIter( <numbers> ) }}`
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `even_squares:` | ` Map { iter: Filter { iter: IntoIter( <numbers> ) }}`
    |'
- en: The intermediate objects, `Filter` and `Map`, are wrapper types (not allocated
    on the heap) on the base iterator structure, which itself is a wrapper that holds
    a reference to the original list of numbers at line 2\. The wrapper structures
    on lines 4 and 5 that get created on calling `filter` and `map`, respectively,
    do not have any pointer indirection in between and impose no heap allocation overhead,
    as was the case with Kotlin. All of this boils down to efficient assembly code,
    which would be equivalent to the manually written version using loops.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 中间对象`Filter`和`Map`是包装类型（不在堆上分配），它们本身是包装器，持有对第2行原始数字列表的引用。在第4行和第5行调用`filter`和`map`时创建的包装器结构之间没有任何指针间接引用，并且不产生堆分配开销，这与Kotlin的情况不同。所有这些都归结为高效的汇编代码，这与手动使用循环编写的版本相当。
- en: '**Fearless concurrency**: When we said Rust is concurrent-safe, we meant that
    the language has **Application Programming Interface** (**API**) and abstractions
    that make it really easy to write correct and safe concurrent code. Contrasting
    this with C++, the possibility of making mistakes in concurrent code is quite
    high. When synchronizing data access to multiple threads in C++, you are responsible
    for calling `mutex.lock()` every time you enter the critical section, and `mutex.unlock()`
    when you exit this section:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**无畏并发**：当我们说Rust是并发安全的，我们的意思是该语言具有**应用程序编程接口**（**API**）和抽象，使得编写正确且安全的并发代码变得非常容易。与C++相比，编写并发代码时出错的可能性相当高。在C++中对多个线程的数据访问进行同步时，你需要负责每次进入临界区时调用`mutex.lock()`，并在退出该区域时调用`mutex.unlock()`：'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Critical section: This is a group of instructions/statements that need to be
    executed atomically. Here, atomically means no other thread can interrupt the
    currently executing thread in the critical section, and no intermediate value
    is perceived by any thread during execution of code in the critical section.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 临界区：这是一组需要原子执行的指令/语句。在这里，“原子”意味着没有其他线程可以中断临界区中当前正在执行的线程，并且在临界区代码执行期间，任何线程都不会感知到中间值。
- en: In a large code base with many developers collaborating on the code, you might
    forget to call `mutex.lock()` before accessing the shared object from multiple
    threads, which can lead to data races. Others cases, you might forget to unlock
    the `mutex` and starve the other threads that want access to the data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型代码库中，许多开发者协作编写代码，你可能会忘记在从多个线程访问共享对象之前调用`mutex.lock()`，这可能导致数据竞争。在其他情况下，你可能会忘记解锁`mutex`，导致其他想要访问数据的线程饥饿。
- en: 'Rust has a different take on this. Here, you wrap your data in a `Mutex` type
    to ensuring synchronized mutable access to data from multiple threads:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Rust对此有不同的看法。在这里，你将数据包裹在`Mutex`类型中，以确保从多个线程对数据进行同步可变访问：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we were able to modify the data after calling `lock()`
    on `value`. Rust uses the notion of protecting the shared data itself and not
    code. The interaction with `Mutex` and the protected data is not independent,
    as is the case with C++. You cannot access the inner data without calling `lock`
    on the `Mutex` type. What about releasing the `lock` ? Well, calling `lock()`
    returns something called  `MutexGuard`, which automatically releases the lock
    when the variable goes out of scope. It's one of the many safe concurrency abstractions
    Rust provides. We'll go into detail on them in [Chapter 8](8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml),
    *Concurrency*. Another novel idea is the notion of marker traits, which validate
    and ensure synchronized and safe access to data in concurrent code at compile
    time. Traits are described in detail in [Chapter 4](93373ddb-63dc-4b4c-a42f-7a099818705c.xhtml),
    *Types, Generics, and Traits*. Types are annotated with marker traits called `Send`
    and `Sync` to indicate whether they are safe to send to threads or safe to share
    between threads, respectively. When a program sends a value to a thread, the compiler
    checks whether the value implements the required marker trait and forbids the
    usage of the value if it isn't the case. In this way, Rust allows you to write
    concurrent code without fear, where the compiler catches mistakes in multi-threaded
    code at compile time. Writing concurrent code is already hard. With C/C++, it
    gets even harder and more arcane. CPUs aren't getting more clock rates; instead,
    we have more cores being added. As a result, concurrent programming is the way
    forward. Rust makes it a breeze to write concurrent code and lowers the bar for
    many people to get into writing safe, concurrent code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在对 `value` 调用 `lock()` 之后能够修改数据。Rust 使用保护共享数据本身而不是代码的概念。与 C++ 不同，与
    `Mutex` 和受保护数据的交互不是独立的。你不能在不调用 `Mutex` 类型的 `lock` 的情况下访问内部数据。那么释放锁呢？好吧，调用 `lock()`
    会返回一个名为 `MutexGuard` 的东西，当变量超出作用域时会自动释放锁。这是 Rust 提供的许多安全并发抽象之一。我们将在 [第 8 章](8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml)
    中详细介绍它们，即 *并发*。另一个新颖的想法是标记特性概念，它在编译时验证并确保并发代码中对数据的同步和安全的访问。特性在 [第 4 章](93373ddb-63dc-4b4c-a42f-7a099818705c.xhtml)
    中详细描述，*类型、泛型和特性*。类型使用标记特性 `Send` 和 `Sync` 进行注释，以指示它们是否可以安全地发送到线程或线程之间共享。当程序向线程发送值时，编译器会检查该值是否实现了所需的标记特性，如果未实现，则禁止使用该值。这样，Rust
    允许你编写无需担心的并发代码，在编译时编译器会捕获多线程代码中的错误。编写并发代码已经很困难了。使用 C/C++，它变得更加困难且晦涩。CPU 的时钟频率并没有增加；相反，我们增加了更多的核心。因此，并发编程是未来的方向。Rust
    使编写并发代码变得轻而易举，并降低了许多人编写安全并发代码的门槛。
- en: Rust also employs C++'s RAII idiom for resource initialization. This technique
    basically ties a resource's lifetime to objects' lifetimes, whereas the deallocation
    of heap allocated types is performed through the `drop` method, which is provided
    by the `drop` trait. This is automatically called when the variable goes out of
    scope. It also replaces the concept of null pointers with `Result` and `Option`
    types, which we'll go into detail in [Chapter 6](35bd7e4b-a6ae-400d-bc25-2c3b92b3b630.xhtml),
    *Error Handling*. This means that Rust doesn't allow null/undefined values in
    code, except when interacting with other languages through foreign function interfaces
    and when using unsafe code. The language also puts emphasis on composition over
    inheritance and has a trait system, which is implemented by data types and is
    similar to **Haskell** typeclasses, also known as Java interfaces on steroids.
    Traits in Rust are the backbone to many of its features, as we'll see in upcoming
    chapters.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 还采用了 C++ 的 RAII 习惯用法进行资源初始化。这种技术基本上将资源的生命周期与对象的生存周期绑定在一起，而堆分配类型的释放则是通过
    `drop` 方法来完成的，该方法由 `drop` 特性提供。当变量超出作用域时，它会自动调用。它还用 `Result` 和 `Option` 类型替换了空指针的概念，我们将在
    [第 6 章](35bd7e4b-a6ae-400d-bc25-2c3b92b3b630.xhtml) 中详细介绍，即 *错误处理*。这意味着 Rust 不允许代码中出现空/未定义的值，除非通过外部函数接口与其他语言交互，或者在使用不安全代码时。该语言还强调组合优于继承，并具有一个特性系统，该系统由数据类型实现，类似于
    **Haskell** 类型类，也称为增强版的 Java 接口。Rust 中的特性是其许多功能的支柱，正如我们将在接下来的章节中看到的。
- en: Last but not least, Rust's community is quite active and friendly, and the language
    has comprehensive documentation, which can be found at [https://doc.rust-lang.org](https://doc.rust-lang.org).
    For the third year in a row (2016, 2017, and 2018), Stack Overflow's Developer
    Survey highlights Rust as the most-loved programming language, so it can be said
    that the overall programming community is very interested in it. To summarize,
    you should care about Rust if you aim to write high performing software with less
    bugs while enjoying many modern language features and an awesome community!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，Rust 的社区非常活跃和友好，该语言有全面的文档，可以在 [https://doc.rust-lang.org](https://doc.rust-lang.org)
    找到。连续三年（2016、2017 和 2018 年），Stack Overflow 的开发者调查将 Rust 评为最受欢迎的编程语言，因此可以说整个编程社区都非常关注它。总的来说，如果你旨在编写高性能软件，同时享受许多现代语言特性和一个出色的社区，那么你应该关注
    Rust！
- en: Installing the Rust compiler and toolchain
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Rust 编译器和工具链
- en: 'The Rust toolchain has two major components: the compiler, **rustc**, and the
    package manager, **cargo**, which helps manage Rust projects. The toolchain comes
    in three release channels:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 工具链有两个主要组件：编译器 **rustc** 和包管理器 **cargo**，它有助于管理 Rust 项目。工具链有三个发布渠道：
- en: '**Nightly**: The daily successful build from the master development branch.
    This contains all the latest features, many of which are unstable.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nightly**：来自主开发分支的每日成功构建。这包含了所有最新的功能，其中许多是不稳定的。'
- en: '**Beta**: This is released every six weeks. A new beta branch is taken from
    nightly. It contains only features that are flagged as stable.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Beta**：每六周发布一次。从一个新的 beta 分支中提取。它只包含标记为稳定的特性。'
- en: '**Stable**: This is released every six weeks. The previous beta branch becomes
    the new stable release.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stable**：每六周发布一次。之前的 beta 分支成为新的稳定发布。'
- en: Developers are encouraged to use the stable release channel. However, the nightly
    version enables bleeding edge features, and some libraries and programs require
    it. You can change to the nightly toolchain easily with rustup. We'll see how
    we can do that in a moment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励开发者使用稳定发布渠道。然而，nightly 版本提供了前沿特性，某些库和程序需要它。你可以使用 rustup 轻松切换到 nightly 工具链。我们稍后将看到如何做到这一点。
- en: Using rustup.rs
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 rustup.rs
- en: Rustup is a tool to that installs the Rust compiler on all supported platforms.
    To make it easier for developers on different platforms to download and use the
    language, the Rust team developed rustup. It's a command-line tool written in
    Rust that provides an easy way to install pre-built binaries of the compiler and
    binary builds of the standard library for cross compiling needs. It can also install
    other components, such as the Rust source code, documentation, **Rust formatting
    tool** (**rustfmt**), **Rust Language Server** (**RLS** for IDEs), and other developer
    tools, and it runs on all platforms, including Windows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Rustup 是一个工具，用于在所有支持的平台上安装 Rust 编译器。为了使不同平台上的开发者更容易下载和使用该语言，Rust 团队开发了 rustup。它是一个用
    Rust 编写的命令行工具，提供了一种简单的方式来安装编译器的预构建二进制文件和用于交叉编译的标准库的二进制构建。它还可以安装其他组件，例如 Rust 源代码、文档、**Rust
    格式化工具**（**rustfmt**）、**Rust 语言服务器**（**RLS** 用于 IDEs），以及其他开发者工具，并且它在所有平台上运行，包括
    Windows。
- en: 'From their official page at [https://rustup.rs](https://rustup.rs), the recommended
    way to install the toolchain is to run the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从他们的官方页面 [https://rustup.rs](https://rustup.rs) 可以看到，安装工具链的推荐方法是运行以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, the installer installs the stable version of the Rust compiler,
    its package manager, Cargo, and the language's standard library documentation
    so that it can be viewed offline. These are installed by default under the `~/.cargo`
    directory. Rustup also updates your `PATH` environment variable to point to this
    directory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，安装程序会安装 Rust 编译器的稳定版本、其包管理器 Cargo 以及语言的标准化库文档，以便可以离线查看。这些默认安装在 `~/.cargo`
    目录下。Rustup 还会更新你的 `PATH` 环境变量，使其指向此目录。
- en: 'The following is a screenshot of running the preceding command on Ubuntu 16.04:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Ubuntu 16.04 上运行先前命令的截图：
- en: '![](img/deb3c4ac-0769-4a91-817e-a205e3b7ae38.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/deb3c4ac-0769-4a91-817e-a205e3b7ae38.png)'
- en: 'If you need to make any changes to your installation, choose 2\. However, the
    defaults are fine for us, so we''ll go ahead and choose 1\. Here''s the output
    after the installation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对你的安装进行任何更改，请选择 2。然而，默认设置对我们来说已经足够好了，所以我们将继续选择 1。以下是安装后的输出：
- en: '![](img/d3465186-00cd-43e2-ae62-70af647a7760.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3465186-00cd-43e2-ae62-70af647a7760.png)'
- en: Rustup also has other capabilities, such as updating the toolchain to the latest
    version, which can be done by running `rustup update`. It can also update itself
    via `rustup self update`. It also provides directory-specific toolchain configuration.
    The default toolchain is set globally to whatever toolchain gets installed, which
    in most cases is the stable toolchain. You can view the default one by invoking
    `rustup show`. If you want to use the latest nightly toolchain for one of your
    projects, you can tell rustup to switch to nightly for that particular directory
    by running `rustup override set nightly`. If, for some reason, someone wants to
    use an older version of the toolchain or downgrade (say, the nightly build on
    2016-06-03), rustup can also download that if we were to run `rustup install nightly-2016-06-03`,
    followed by setting the same using the `override` sub-command. More information
    on rustup can be found at [https://github.com/rust-lang-nursery/rustup.rs](https://github.com/rust-lang-nursery/rustup.rs).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Rustup 还具有其他功能，例如通过运行 `rustup update` 更新工具链到最新版本。它也可以通过 `rustup self update`
    更新自身。它还提供了特定目录的工具链配置。默认工具链被全局设置为安装的工具链，在大多数情况下是稳定版工具链。你可以通过调用 `rustup show` 来查看默认的工具链。如果你想为你的某个项目使用最新的夜间版工具链，你可以通过运行
    `rustup override set nightly` 告诉 rustup 为特定目录切换到夜间版。如果出于某种原因，有人想使用工具链的旧版本或降级（比如，2016-06-03
    的夜间构建），如果运行 `rustup install nightly-2016-06-03`，rustup 也可以下载它，然后通过 `override`
    子命令设置相同的版本。有关 rustup 的更多信息，请参阅 [https://github.com/rust-lang-nursery/rustup.rs](https://github.com/rust-lang-nursery/rustup.rs)。
- en: '**Note**: All of the code examples and projects in this book are based on compiler
    version `rustc 1.32.0 (9fda7c223 2019-01-16)`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：本书中的所有代码示例和项目都是基于编译器版本 `rustc 1.32.0 (9fda7c223 2019-01-16)`。'
- en: Now, you should have everything you need to compile and run programs written
    in Rust. Let's get Rusty!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经拥有了编译和运行 Rust 编写的程序所需的一切。让我们开始 Rust 之旅吧！
- en: A tour of the language
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言之旅
- en: 'For the fundamental language features, Rust does not stray far from what you
    are used to in other languages. At a high level, a Rust program is organized into
    modules, with the root module containing a `main()` function. For executables,
    the root module is usually a `main.rs` file and for libraries, a `lib.rs` file.
    Within a module, you can define functions, import libraries, define types, create
    constants, write tests and macros, or even create nested modules. We''ll see all
    of them, but let''s start with the basics. Here''s a simple Rust program that
    greets you:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本语言特性，Rust 并没有偏离你在其他语言中习惯的内容太远。在高级层面，一个 Rust 程序被组织成模块，其中根模块包含一个 `main()`
    函数。对于可执行文件，根模块通常是 `main.rs` 文件，而对于库，则是 `lib.rs` 文件。在一个模块内部，你可以定义函数、导入库、定义类型、创建常量、编写测试和宏，甚至创建嵌套模块。我们将逐一了解它们，但让我们从基础开始。这是一个简单的
    Rust 程序，用于问候你：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s compile and run this program. Write it to a file called `greet.rs` and
    run `rustc` with the file name, and pass your name as the argument. I passed the
    name `Ferris`*,* Rust''s unofficial mascot,and got the following output on my
    machine:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行这个程序。将其写入名为 `greet.rs` 的文件中，并使用文件名运行 `rustc`，然后将你的名字作为参数传递。我传递了名字 `Ferris`，这是
    Rust 的非官方吉祥物，在我的机器上得到了以下输出：
- en: '![](img/6afa2bf0-2c92-4cae-b1dc-8548dec8d03c.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6afa2bf0-2c92-4cae-b1dc-8548dec8d03c.jpg)'
- en: Awesome! It greets `Ferris`. Let's get a cursory view of this program, line
    by line.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！它问候了 `Ferris`。让我们逐行浏览这个程序。
- en: On line 1, we import a module called `env` from the `std` crate (libraries are
    called **crates**). `std` is the standard library for Rust. On line 3, we have
    our usual function `main`. Then, on line 4, we call the function `args()` from
    the `env` module, which returns an iterator (sequence) of arguments that has been
    passed to our program. Since the first argument contains our program name, we
    want to skip it, so we call `skip` and pass in a number, which is how many elements
    (`1`) we want to skip. As iterators are lazy and do not pre-compute things in
    Rust, we have to explicitly ask it to give the next element, so we call `next()`,
    which returns an enum type called `Option`. This can be either a `Some(value)`
    value or a `None` value because a user might forget to provide an argument.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 行，我们从 `std` crate（库被称为 **crate**）中导入了一个名为 `env` 的模块。`std` 是 Rust 的标准库。在第
    3 行，我们有我们常用的 `main` 函数。然后，在第 4 行，我们调用 `env` 模块中的 `args()` 函数，该函数返回一个迭代器（序列），其中包含传递给我们的程序的参数。由于第一个参数包含我们的程序名称，我们想要跳过它，所以我们调用
    `skip` 并传入一个数字，这表示我们要跳过多少个元素（`1`）。由于迭代器在 Rust 中是惰性的，不会预先计算任何东西，因此我们必须明确要求它提供下一个元素，所以我们调用
    `next()`，它返回一个名为 `Option` 的枚举类型。这可以是 `Some(value)` 值或 `None` 值，因为用户可能会忘记提供参数。
- en: On line 5, we use Rust's awesome `match` expression on the variable `name` and
    check whether it's a `Some(n)` or a `None` value. `match` is like the `if else`
    construct, but more powerful. On line 6, when it's a `Some(n)`, we call `println!()`,
    passing in our inner string variable `n` (this gets auto-declared when using match
    expressions), which then greets our user. The `println!` call is not a function,
    but a *macro* (they all end with a !). Finally, on line 7, if it's a `None` variant
    of the enum, we just `panic!()` (another macro), which aborts the program, making
    it leave an error message.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 行，我们使用 Rust 的强大 `match` 表达式对变量 `name` 进行操作，并检查它是否是 `Some(n)` 或 `None` 值。`match`
    与 `if else` 构造类似，但更强大。在第 6 行，当它是 `Some(n)` 时，我们调用 `println!()`，传入我们的内部字符串变量 `n`（当使用
    `match` 表达式时，它会自动声明），然后问候我们的用户。`println!` 调用不是一个函数，而是一个 *宏*（它们都以 ! 结尾）。最后，在第 7
    行，如果它是枚举的 `None` 变体，我们只是 `panic!()`（另一个宏），这会导致程序终止，并留下一个错误消息。
- en: The `println!` macro, as we saw, accepts a string, which can contain placeholders
    for items using the `"{}"` syntax. These strings are called **format strings**,
    while the `"{}"` in the string are called **format specifiers**. For printing
    simple types such as primitives, we can use the `"{}"` format specifier, whereas
    for other types, we use the `"{:?}"` format specifier. There are more details
    to this, though. When `println!` encounters a format specifier, that is, `"{}"`,
    and a corresponding substitution value, it calls a method on that value, which
    returns a string representation of it. This method is part of a trait. For the `"{}"`
    specifier, it calls a method from the `Display` trait, whereas for `"{:?}"`, it
    calls a method from the `Debug` trait. The latter is mostly used for debugging,
    while the former is for displaying a human readable output of data types. It is
    somewhat similar to the `toString()` method in Java. When developing, you usually
    need to print your data types for debugging. The cases where these methods are
    not available on a type when using the `"{:?}"` specifier, we then need to add
    a `#[derive(Debug)]` **attribute** over the type to get those methods. We'll explain
    attributes in detail in subsequent chapters, but expect to see this in future
    code examples. We'll also revisit the `println!` macro in  [Chapter 9](7143ebcd-54cc-4e31-a2ad-07ce90268584.xhtml),
    *Metaprogramming with Macros*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`println!` 宏，正如我们所见，接受一个字符串，该字符串可以使用 `"{}"` 语法包含用于项的占位符。这些字符串被称为 **格式字符串**，而字符串中的
    `"{}"` 被称为 **格式说明符**。对于打印简单类型，如原始类型，我们可以使用 `"{}"` 格式说明符，而对于其他类型，我们使用 `"{:?}"`
    格式说明符。不过，这里还有一些细节。当 `println!` 遇到格式说明符，即 `"{}"`，以及相应的替换值时，它会调用该值上的一个方法，该方法返回其字符串表示形式。这个方法是
    trait 的一部分。对于 `"{}"` 说明符，它调用 `Display` trait 中的方法，而对于 `"{:?}"`，它调用 `Debug` trait
    中的方法。后者主要用于调试，而前者用于显示数据类型的人类可读输出。这与 Java 中的 `toString()` 方法有些相似。在开发过程中，你通常需要打印数据类型以进行调试。当使用
    `"{:?}"` 说明符时，如果这些方法在类型上不可用，我们则需要在该类型上添加一个 `#[derive(Debug)]` **属性**来获取这些方法。我们将在后续章节中详细解释属性，但预计你将在未来的代码示例中看到这一点。我们还将回顾第
    9 章中的 `println!` 宏，*使用宏进行元编程*。'
- en: 'Running **rustc** manually is not how you will do this for real programs, but
    it will do for these small programs in this chapter. In subsequent chapters, we
    will be using Rust''s package manager to build and run our programs. Apart from
    running the compiler locally, another tool that can be used to run the code examples
    is the official online compiler called **Rust playground**, which can be found
    at [http://play.rust-lang.org](http://play.rust-lang.org). Following is the screenshot
    from my machine:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 手动运行 **rustc** 并非真实程序的正确做法，但对于本章中的这些小程序来说，这样做是可以的。在后续章节中，我们将使用 Rust 的包管理器来构建和运行我们的程序。除了在本地运行编译器之外，还可以使用官方在线编译器
    **Rust playground** 来运行代码示例，该编译器可以在 [http://play.rust-lang.org](http://play.rust-lang.org)
    找到。以下是我机器上的截图：
- en: '![](img/0cf8b8e7-fc8d-4094-b323-3ef24a75dfea.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cf8b8e7-fc8d-4094-b323-3ef24a75dfea.png)'
- en: The Rust playground also supports external libraries to be imported and to be
    used when trying out sample programs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Rust playground 还支持导入和使用外部库，以便在尝试示例程序时使用。
- en: With the previous example, we got a high-level overview of a basic Rust program,
    but did not dive into all of the details and the syntax. In the following section,
    we will explain the language features separately and their syntax. The explanations
    that follow are here to give you enough context so that you can quickly get up
    and running in regard to writing Rust programs without going through all of the
    use cases exhaustively. To make it brief, each section also contains references
    to chapters that explain these concepts in more detail. Also, the Rust documentation
    page at [https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html)
    will help you get into the details and is very readable with its built-in search
    feature. You are encouraged to proactively search for any of the constructs that
    are explained in the following sections. This will help you gain more context
    about the concepts you're learning about.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们得到了一个基本的 Rust 程序的高级概述，但没有深入所有细节和语法。在下一节中，我们将分别解释语言特性和它们的语法。以下解释旨在为您提供足够的背景知识，以便您能够快速开始编写
    Rust 程序，而无需详尽地了解所有用例。为了简洁起见，每个部分还包含对解释这些概念的章节的引用。此外，Rust 文档页面 [https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html)
    将帮助您深入了解，并且具有内置的搜索功能，非常易于阅读。鼓励您积极搜索以下章节中解释的任何结构。这将帮助您更好地理解您正在学习的概念。
- en: All of the code examples in this chapter can be found in this book's GitHub
    repository ([PacktPublishing/Mastering-RUST-Second-Edition](https://github.com/PacktPublishing/Mastering-RUST-Second-Edition)).
    For this chapter, they are in [Chapter 1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml), *Getting
    Started with Rust* *Directory* – the same convention is followed for the rest
    of the chapters in this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的 GitHub 仓库中找到 ([PacktPublishing/Mastering-RUST-Second-Edition](https://github.com/PacktPublishing/Mastering-RUST-Second-Edition))。对于本章，它们位于
    [第 1 章](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml)，*Rust 入门* 目录 – 本书其余章节也遵循相同的约定。
- en: Some of the code files are deliberately presented to not compile so that you
    can fix them yourselves with the help of the compiler.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码文件被故意设计为无法编译，这样您就可以在编译器的帮助下自己修复它们。
- en: With that said, let's start with the fundamental primitive types in Rust.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们从 Rust 中的基本原始类型开始。
- en: Primitive types
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型
- en: 'Rust has the following built-in primitive types:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有以下内置原始类型：
- en: '`bool`: These are the usual booleans and can be either `true` or `false` .'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`: 这些是常规布尔值，可以是 `true` 或 `false`。'
- en: '`char`: Characters, such as `e`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`: 字符，例如 `e`。'
- en: 'Integer types: These are characterized by the bit width. Rust supports integers
    that are up to 128 bits wide:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型：这些类型以位宽为特征。Rust 支持宽度高达 128 位的整数：
- en: '| signed | unsigned |'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 有符号 | 无符号 |'
- en: '| `i8` | `u8` |'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `i8` | `u8` |'
- en: '| `i16` | `u16` |'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `i16` | `u16` |'
- en: '| `i32` | `u32` |'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `i32` | `u32` |'
- en: '| `i64` | `u64` |'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `i64` | `u64` |'
- en: '| `i128` | `u128` |'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `i128` | `u128` |'
- en: '`isize`: The pointer-sized signed integer type. Equivalent to `i32` on 32-bit
    CPU and `i64` on 64-bit CPU.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isize`: 指针大小的有符号整数类型。在 32 位 CPU 上相当于 `i32`，在 64 位 CPU 上相当于 `i64`。'
- en: '`usize`: The pointer-sized unsigned integer type. Equivalent to `i32` on 32-bit
    CPU and `i64` on 64-bit CPU.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usize`: 指针大小的无符号整数类型。在 32 位 CPU 上相当于 `i32`，在 64 位 CPU 上相当于 `i64`。'
- en: '`f32`: The 32-bit floating point type. Implements the IEEE 754 standard for
    floating point representation.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f32`: 32 位浮点类型。实现了 IEEE 754 浮点表示标准。'
- en: '`f64`: The 64-bit floating point type.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f64`: 64 位浮点类型。'
- en: '`[T; N]`: A fixed-size array, for the element type, `T`, and the non-negative
    compile-time constant size N.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[T; N]`：一个固定大小的数组，对于元素类型 `T` 和非负编译时常量大小 N。'
- en: '`[T]`: A dynamically-sized view into a contiguous sequence, for any type `T`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[T]`：任何类型 `T` 的连续序列的动态大小视图。'
- en: '`str`: String slices, mainly used as a reference, that is, `&str`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str`：字符串切片，主要用于引用，即 `&str`。'
- en: '`(T, U, ..)`: A finite sequence, (T, U, ..) where T and U can be different
    types.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(T, U, ..)`：一个有限序列，其中 T 和 U 可以是不同类型。'
- en: '`fn(i32) -> i32`: A function that takes an `i32` and returns an `i32`. Functions
    also have a type.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn(i32) -> i32`：一个接受 `i32` 并返回 `i32` 的函数。函数也有类型。'
- en: Declaring variables and immutability
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明变量和不可变性
- en: 'Variables allow us to store a value and easily refer to it later in code. In
    Rust, we use the `let` keyword to declare variables. We already had a glimpse
    of it in the `greet.rs` example in the previous section. In mainstream imperative
    languages such as C or Python, initializing a variable does not stop you from
    reassigning it to some other value. Rust deviates from the mainstream here by
    making variables immutable by default, that is, you cannot assign the variable
    to some other value after you have initialized it. If you need a variable to point
    to something else (of the same type) later, you need to put the `mut` keyword
    before it. Rust asks you to be explicit about your intent as much as possible.
    Consider the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 变量允许我们存储一个值，并在代码中稍后轻松地引用它。在 Rust 中，我们使用 `let` 关键字来声明变量。我们已经在上一节的 `greet.rs`
    示例中看到了它的身影。在主流的命令式语言，如 C 或 Python 中，初始化变量并不会阻止你将其重新赋值给其他值。Rust 在这里与主流做法不同，它默认使变量不可变，也就是说，你初始化变量后不能将其赋值给其他值。如果你需要变量稍后指向其他东西（同一类型），你需要在它前面加上
    `mut` 关键字。Rust 要求你尽可能明确地表达你的意图。考虑以下代码：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We declared two variables, `target` and `greeting`. `target` is an immutable
    binding, while `greeting` has a `mut` before it, which makes it a mutable binding.
    If we run this program, though, we get the following error:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个变量，`target` 和 `greeting`。`target` 是一个不可变绑定，而 `greeting` 前面有一个 `mut`，使其成为一个可变绑定。如果我们运行这个程序，则会得到以下错误：
- en: '![](img/e56e927a-9f3e-4f25-baef-6b460b72baba.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e56e927a-9f3e-4f25-baef-6b460b72baba.png)'
- en: 'As you can see from the preceding error message, Rust does not let you assign
    to `target` again. To make this program compile, we''ll need to add `mut` before
    `target` in the `let` statement and compile and run it again. The following is
    the output when you run the program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述错误信息所示，Rust 不允许你再次对 `target` 进行赋值。为了使这个程序编译，我们需要在 `let` 语句中的 `target` 前面添加
    `mut`，然后再次编译和运行它。以下是你运行程序时的输出：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`let` does much more than assign variables. It is a pattern-matching statement
    in Rust. In [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml), *Advanced
    Concepts,* we''ll take a closer look at `let`. Next, we''ll look at functions.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 在 Rust 中做的不只是赋值变量。它是一个模式匹配语句。在 [第 7 章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)
    的 *高级概念* 中，我们将更详细地探讨 `let`。接下来，我们将看看函数。'
- en: Functions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions abstract a bunch of instructions into named entities, which can be
    invoked later by other code and help manage complexity. We already used a function
    in our `greet.rs` program, that is, the `main` function. Let''s look at how we
    can define another one:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将一系列指令抽象成命名实体，可以在稍后通过其他代码调用，有助于管理复杂性。我们已经在我们的 `greet.rs` 程序中使用了一个函数，即 `main`
    函数。让我们看看我们如何定义另一个函数：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we created a new function named `add`. The `fn` keyword
    is used to create functions followed by its name, `add`, its parameters inside
    parentheses `a` and `b`, and the function body inside `{}` braces. The parameters
    have their type on the right, after the colon `:`. Return types in functions are
    specified using a `->`, followed by the type, `u64`, which can be omitted if the
    function has nothing to return. Functions also have types. The type of our `add`
    function is denoted as `fn(u64, u64) -> u64`. They can also be stored in variables
    and passed to other functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `add` 的新函数。使用 `fn` 关键字来创建函数，后面跟着其名称 `add`，括号内的参数 `a` 和 `b`，以及花括号
    `{}` 内的函数体。参数的类型位于冒号 `:` 的右侧。函数的返回类型使用 `->` 符号指定，后面跟着类型 `u64`，如果函数没有返回值，则可以省略。函数也有类型。我们的
    `add` 函数类型表示为 `fn(u64, u64) -> u64`。它们也可以存储在变量中，并传递给其他函数。
- en: If you look at the body of `add`, we don't need a `return` keyword to return
    `a + b` as in other languages. The last expression is returned automatically.
    However, we do have the `return` keyword available for early returns. Functions
    are basically expressions that return a value, which is a `()` (Unit) type by
    default, akin to the *void* return type in C/C++. They can also be declared within
    other functions. The use case for that is when you have a functionality within
    a function (say, `foo`) that is hard to reason as a sequence of statements. In
    this case, one can extract those lines in a local function, `bar`, which is then
    defined within the parent function, `foo.`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`add`函数的主体，我们不需要`return`关键字来返回`a + b`，就像在其他语言中那样。最后一个表达式会自动返回。然而，我们确实有`return`关键字可用于提前返回。函数基本上是返回值的表达式，默认情况下返回值类型为`()`（单元）类型，类似于C/C++中的`void`返回类型。它们也可以在其他函数内声明。这种用例是当你有一个在函数内部的功能（比如`foo`）难以作为语句序列进行推理时。在这种情况下，可以在局部函数`bar`中提取这些行，然后`bar`在父函数`foo`内部定义。
- en: In `main`, we declared two variables, `a` and `b`, using the `let` keyword.
    As is the case with `b`, we can even omit specifying the type as Rust is able
    to infer types of variables in most cases by examining your code. This is also
    the case with the `result`, which is a `u64` value. This feature helps prevent
    type signature clutter and improves the readability of code, especially when your
    types are nested inside several other types that have long names.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们使用`let`关键字声明了两个变量`a`和`b`。与`b`一样，我们甚至可以省略指定类型，因为Rust在大多数情况下能够通过检查你的代码来推断变量的类型。这也适用于`result`，它是一个`u64`值。这个特性有助于防止类型签名杂乱，并提高代码的可读性，尤其是在你的类型嵌套在具有长名称的其他类型内部时。
- en: Rust's type inference is based on the Hindly Milner type system. It's a set
    of rules and algorithms that enable type inference in a programming language.
    It's an efficient type inference method that performs in linear time, making it
    practical to type check large programs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的类型推断基于Hindley Milner类型系统。它是一组规则和算法，使编程语言能够进行类型推断。这是一种高效的类型推断方法，以线性时间执行，使得对大型程序进行类型检查变得实用。
- en: 'We can also have functions that modify their arguments. Consider the following
    code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以有修改其参数的函数。考虑以下代码：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We declare a  `score` variable with `2048` as the value, and call the `increase_by`
    function, passing score and the value `30` as the second argument. In the `increase_by`
    function, we have specified the first parameter as `mut val`, indicating that
    the parameter should be taken as mutable, which allows the variable to be mutated
    from inside the function. Our `increase_by` function modifies the `val` binding
    and prints the value. Following is the output when running the program:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个`score`变量，其值为`2048`，并调用了`increase_by`函数，将`score`和值`30`作为第二个参数传递。在`increase_by`函数中，我们指定第一个参数为`mut
    val`，表示该参数应被视为可变的，这允许从函数内部修改变量。我们的`increase_by`函数修改了`val`绑定并打印了值。以下是运行程序时的输出：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, let's look at closures.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看闭包。
- en: Closures
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Rust also has support for closures. Closures are like functions but have more
    information of the environment or scope in which they are declared. While functions
    have names associated with them, closures are defined without a name, but they
    can be assigned to a variable. Another advantage of Rust''s type inference is
    that, in most cases, you can specify parameters for a closure without their type.
    Here''s the the simplest possible closure: `let my_closure = || ();`. We just
    defined a no-parameter closure that does nothing. We can call this by invoking
    `my_closure()`, just like functions. The two vertical bars `||` hold the parameters
    for the closure (if any), such as `|a, b|`. Specifying the types of parameters
    (`|a: u32|`) is sometimes required when Rust cannot figure out the proper types.
    Like functions, closures can also be stored in variables and invoked later or
    passed to other functions. The body of the closure, however, can either have a
    single line expression or a pair of braces for multi-line expressions. A more
    involved closure would be as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rust也支持闭包。闭包类似于函数，但它们具有更多关于它们声明时的环境或作用域的信息。虽然函数与它们的名字相关联，但闭包是无名的定义，但可以赋值给变量。Rust类型推断的另一个优点是，在大多数情况下，你可以指定闭包的参数而不需要它们的类型。这里是最简单的闭包示例：`let
    my_closure = || ();`。我们定义了一个无参数的闭包，它什么也不做。我们可以通过调用`my_closure()`来调用它，就像函数一样。两个垂直条`||`包含闭包的参数（如果有），例如`|a,
    b|`。当Rust无法确定正确的类型时，有时需要指定参数的类型（`|a: u32|`）。像函数一样，闭包也可以存储在变量中，稍后调用或传递给其他函数。然而，闭包的主体可以是一行表达式，也可以是一对花括号，用于多行表达式。一个更复杂的闭包可能如下所示：'
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we have defined two closures: `doubler` and `big_closure`.
    `doubler` doubles a value given to it; in this case, it is passed `value` from
    the parent scope or environment, that is, the function `main`. Similarly, in `big_closure`,
    we use the variable `twice` from its environment. This closure has multi-line
    expressions within braces and needs to end with a semi-colon to allow us to assign
    it to the  `big_closure` variable. Later, we call `big_closure`, passing in `1,
    2`, and print `some_number`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个闭包：`doubler`和`big_closure`。`doubler`将给定的值加倍；在这种情况下，它从父作用域或环境（即`main`函数）传递`value`。同样，在`big_closure`中，我们使用其环境中的变量`twice`。这个闭包在花括号内有多行表达式，并且需要以分号结束，以便我们可以将其赋值给`big_closure`变量。稍后，我们调用`big_closure`，传递`1,
    2`，并打印`some_number`。
- en: The major use case for closures are as parameters to higher-order functions.
    A higher-order function is a function that takes another function or closure as
    its argument. For example, the `thread::spawn` function from the standard library
    takes in a closure where you can write code you want to run in another thread.
    Another example where closures provide a convenient abstraction is when you have
    a function that operates on collection such as `Vec` and you want to filter the
    items based on some condition. Rust's `Iterator` trait has a method called `filter`,
    which takes in a closure as an argument. This closure is defined by the user and
    it returns either `true` or `false`, depending on how the user wants to filter
    the items in the collection. We'll get more in-depth with closures in [Chapter
    7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml), *Advanced Concepts*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的主要用途是作为高阶函数的参数。高阶函数是一种接受另一个函数或闭包作为其参数的函数。例如，标准库中的`thread::spawn`函数接受一个闭包，在其中你可以编写你想要在另一个线程中运行的代码。另一个闭包提供便利抽象的例子是当你有一个操作集合（如`Vec`）的函数，而你想要根据某些条件过滤项目时。Rust的`Iterator`特质有一个名为`filter`的方法，它接受一个闭包作为参数。这个闭包由用户定义，它返回`true`或`false`，具体取决于用户想要如何过滤集合中的项目。我们将在第7章[高级概念](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)中更深入地了解闭包。
- en: Strings
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings are one of the most frequently used data types in any programming language.
    In Rust, they are usually found in two forms: the `&str` type (pronounced *stir*)
    and the `String` type. Rust strings are guaranteed to be valid UTF-8 encoded byte
    sequences. They are not null terminated as in C strings and can contain null bytes
    in-between them. The following program shows the two types in action:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是任何编程语言中最常用的数据类型之一。在Rust中，它们通常以两种形式存在：`&str`类型（发音为*stir*）和`String`类型。Rust字符串保证是有效的UTF-8编码字节序列。它们不像C字符串那样以空字符终止，并且可以在它们之间包含空字节。以下程序展示了这两种类型的作用：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, `person` and `namaste` are of type `String`, while `question`
    is of type `&str`. There are multiple ways you can create `String` types. Strings
    are allocated on the heap, while `&str` types are usually pointers to an existing
    string, which could either be on stack, the heap, or a string in the data segment
    of the compiled object code. The `&` is an operator that is used to create a pointer
    to any type. After initializing the strings in the preceding code, we then use
    the `println!` macro to print them together using format strings. That's the very
    basics of strings. Strings are covered in detail in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),  *Advanced
    Concepts*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`person`和`namaste`是`String`类型，而`question`是`&str`类型。你可以用多种方式创建`String`类型。字符串是在堆上分配的，而`&str`类型通常是现有字符串的指针，这些字符串可能位于栈上、堆上或在编译对象的代码段的数据段中。`&`是一个用于创建任何类型的指针的运算符。在初始化前面的代码中的字符串后，我们使用`println!`宏通过格式字符串将它们一起打印出来。这就是字符串的非常基础的知识。字符串将在[第7章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)，“高级概念”中详细讲解。
- en: Conditionals and decision making
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句和决策
- en: 'Conditionals are also similar to how they''re found in other languages. They
    follow the C-like `if {} else {}` structure:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句在其他语言中也有类似的结构。它们遵循类似于C语言的`if {} else {}`结构：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Rust, the `if` construct is not a statement, but an expression. In general
    programming parlance, *statements* do not return any value, but an *expression*
    does. This distinction means that `if else` conditionals in Rust always return
    a value. The value may be an empty `()` unit type, or it may be an actual value.
    Whatever remains in the last line inside the braces becomes the return value of
    the `if else` expression. It is important to note that both `if` and `else` branches
    should have the same return type. Also, we don''t need parentheses around the
    if condition expression, as you can see in the preceding code. We can even assign
    the value of `if else` blocks to a variable:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，`if`结构不是一个语句，而是一个表达式。在一般的编程术语中，*语句*不会返回任何值，但*表达式*会。这种区别意味着Rust中的`if else`条件语句总是返回一个值。这个值可能是一个空的`()`单元类型，也可能是一个实际值。括号内最后一行剩余的内容将成为`if
    else`表达式的返回值。重要的是要注意，`if`和`else`分支应该有相同的返回类型。此外，我们不需要在`if`条件表达式周围使用括号，正如你可以在前面的代码中看到的那样。我们甚至可以将`if
    else`块的值赋给一个变量：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When assigning values that have been returned from an `if else` expression,
    we need to end them with a semicolon. For example, `if { ...` is an expression,
    while `let` is a statement that expects us to have a semicolon at the end. In
    the case of assignment, if we were to remove the `else {}` block from the preceding
    code, the compiler would throw an error, like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`if else`表达式返回的值赋值时，我们需要在它们后面加上分号。例如，`if { ...`是一个表达式，而`let`是一个期望我们在末尾加上分号的语句。在赋值的情况下，如果我们从前面的代码中移除`else
    {}`块，编译器会抛出一个错误，如下所示：
- en: '![](img/ebd5760a-e52a-4c04-93ba-9d6d9d43deab.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebd5760a-e52a-4c04-93ba-9d6d9d43deab.png)'
- en: 'Without the `else` block, if the `if` condition evaluates to `false`, then
    the result will be `()`, and there would be two possible values for the `result`
    variable, that is, `()` and `&str`. Rust does not allow multiple types to be stored
    in one variable. So, in this case, we need both the `if {}` and `else {}` blocks
    returning the same types. Also, adding a semicolon in the conditional branches
    changes the meaning of the code. By adding a semicolon after the strings in the
    `if` block in the following code, the compiler would interpret it as you wanting
    to throw the value away:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`else`块，当`if`条件评估为`false`时，结果将是`()`，`result`变量将有两个可能的值，即`()`和`&str`。Rust不允许在一个变量中存储多个类型。因此，在这种情况下，我们需要`if
    {}`和`else {}`块返回相同类型的值。此外，在条件分支中添加分号会改变代码的含义。在以下代码中，在`if`块中的字符串后添加分号，编译器会将其解释为你想要丢弃该值：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, the result will be an empty `()`, which is why we had to change
    the `println!` expression slightly (the `{:?}`); this type cannot be printed out
    in the regular way. Now, for the more complex multi-valued decision making; Rust
    has another powerful construct called `match` expressions, which we'll look at
    next.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果将是一个空的`()`，这就是为什么我们不得不稍微改变`println!`表达式（即`{:?}`）；这种类型不能以常规方式打印出来。现在，对于更复杂的多值决策；Rust还有一个称为`match`表达式的强大结构，我们将在下一节中探讨。
- en: Match expressions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配表达式
- en: 'Rust''s `match` expressions are quite a joy to use. It''s basically C''s `switch`
    statement on steroids and allows you to make decisions, depending on what value
    the variable has and whether it has advanced filtering capabilities. Here''s a
    program that uses match expressions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的 `match` 表达式非常易于使用。它基本上是 C 语言的 `switch` 语句的强化版，允许你根据变量的值做出决策，并且它具有先进的过滤能力。以下是一个使用匹配表达式的程序：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we have a  `req_status`, function that returns a dummy
    HTTP request status code of `200`, which we call in `main` and assign to `status`.
    We then match on this value using the `match` keyword, followed by the variable
    we want to check the value of (`status`), followed by a pair of braces. Within
    braces, we write expressions – these are called **match arms***.* These arms represent
    the possible values that the variable being matched can take. Each match arm is
    written by writing the possible value of the variable, followed by a `=>`, and
    then the expression on the right. To the right, you can either have a single line
    expression or a multi-line expression within `{}` braces. When written in a single
    line expression, they need to be delimited with a comma. Also, every match arm
    must return the same type. In this case, each match arm returns a Unit type `()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个返回模拟 HTTP 请求状态码 `200` 的 `req_status` 函数，我们在 `main` 中调用它并将结果赋值给
    `status`。然后我们使用 `match` 关键字匹配这个值，后面跟着我们想要检查的变量（`status`），然后是一对大括号。在大括号内，我们写表达式——这些被称为
    **匹配分支**。这些分支代表了被匹配变量可能取的值。每个匹配分支是通过写出变量的可能值，然后跟一个 `=>`，再然后是右侧的表达式来编写的。在右侧，你可以有一个单行表达式或一个在大括号
    `{}` 内的多行表达式。当写成单行表达式时，它们需要用逗号分隔。此外，每个匹配分支必须返回相同的类型。在这种情况下，每个匹配分支返回 Unit 类型 `()`。
- en: Another nice feature or you can call guarantee of `match` expressions is that
    we have to match exhaustively against all possible cases of the value we are matching
    against. In our case, this would be listing all the numbers up until the maximum
    value of `i32`. However, practically, this is not possible, so Rust allows us
    to either ignore the rest of the possibilities by using a `catch all` variable
    (here, this is `other`) or an `_` (underscore) if we want to ignore the value.
    Match expressions are a primary way to make decisions around values when you have
    more than one possible value and they are very concise to write. Like `if else`
    expressions, the return value of a match expression can also be assigned to a
    variable in a `let` statement when it's delimited with a semicolon, with all match
    arms returning the same types.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 表达式的一个很好的特性或你可以称之为保证是，我们必须对所有可能的值进行穷举匹配。在我们的例子中，这将是列出所有直到 `i32` 最大值的数字。然而，实际上这是不可能的，所以
    Rust 允许我们通过使用一个 `catch all` 变量（这里，它是 `other`）或一个 `_`（下划线）来忽略其余的可能性，如果我们想忽略这个值。当有多个可能的值时，匹配表达式是做出关于值的决策的主要方式，而且它们写起来非常简洁。像
    `if else` 表达式一样，当用分号分隔时，匹配表达式的返回值也可以在 `let` 语句中分配给一个变量，并且所有匹配分支返回相同的类型。'
- en: Loops
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'Repeating things in Rust can be done using three constructs, namely `loop`, `while`,
    and `for`. In all of them, we have the usual `continue` and `break` keywords,
    which allow you to skip and break out of a loop, respectively. Here''s an example
    of using `loop`, which is equivalent to C''s `while(true)`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，重复操作可以通过三种结构实现，即 `loop`、`while` 和 `for`。在所有这些结构中，我们都有常用的 `continue`
    和 `break` 关键字，分别允许你跳过循环或从循环中退出。以下是一个使用 `loop` 的例子，它与 C 语言的 `while(true)` 等效：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`loop` represents an infinite loop. In the preceding code, we simply decrement
    the value `x` until it hits the if condition `x < 0`, where we break out of the
    loop. An extra feature of using `loop` in Rust is being able to tag the `loop`
    block with a name. This can be used in cases where you have two or more nested
    loops and want to break out from any one of them and not just the loop immediately
    enclosing the `break` statement. The following is an example of using loop labels
    to break out of the `loop`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop` 表示一个无限循环。在前面的代码中，我们简单地递减 `x` 的值，直到它达到条件 `x < 0`，在那里我们退出循环。在 Rust 中使用
    `loop` 的一个额外特性是能够给 `loop` 块加上一个标签。这可以在你有两个或更多嵌套循环，并且想要从任何一个循环中退出，而不仅仅是紧邻 `break`
    语句的循环时使用。以下是一个使用循环标签退出 `loop` 的例子：'
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we are doing a very inefficient subtraction just to demonstrate
    the usage of labels with nested loops. In the inner `'decrement` label, when `dec`
    equals `0`, we can pass a label to break (here, this is `'increment`) and break
    out of the outer `'increment` loop instead.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在进行一个非常低效的减法操作，只是为了演示在嵌套循环中使用标签的用法。在内层`'decrement`标签中，当`dec`等于`0`时，我们可以传递一个标签给`break`（这里，这是`'increment'`），然后跳出外层的`'increment'`循环。
- en: 'Now, let''s take a look at `while` loops. Nothing fancy here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`while`循环。这里没有太多花哨的东西：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Rust also has a `for` keyword and is similar to for loops used in other languages,
    but they are quite different in their implementation. Rust''s `for` is basically
    a syntax sugar for a more powerful repetition construct known as *iterators*.
    We''ll discuss them in more detail in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*. To put it simply, for loops in Rust only work on types that
    can be converted into iterators. One such type is the `Range` type. The `Range`
    type can refer to a range of numbers, such as `(0..10)`. They can be used in `for`
    loops like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Rust也有一个`for`关键字，与其他语言的for循环类似，但在实现上却大不相同。Rust的`for`实际上是一个更强大的重复构造的语法糖，称为*迭代器*。我们将在[第7章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)，*高级概念*中更详细地讨论它们。简单来说，Rust中的for循环只适用于可以转换为迭代器的类型。其中一种类型是`Range`类型。`Range`类型可以指代一个数字范围，例如`(0..10)`。它们可以用在for循环中，如下所示：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Apart from the normal range syntax, that is, `0..10`, which does not include
    `10`, Rust also has inclusive range syntax `0..=10`, which iterates all the way
    until `10`, as can be seen in the second `for` loop. Now, let's move on to user-defined
    data types.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常的范围语法，即`0..10`，它不包括`10`之外，Rust还有一个包含范围语法`0..=10`，它迭代直到`10`，如第二个`for`循环所示。现在，让我们继续讨论用户定义的数据类型。
- en: User-defined types
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义类型
- en: 'As the name says, user-defined types are types that are defined by you. These
    can be composed of several types. They may either be a wrapper over a primitive
    type or a composition of several user defined types. They come in three forms:
    structures, enumerations, and unions, or more commonly known as **structs**, **enums**,
    and **unions**. They allow you to easily express you data. The naming convention
    for user-defined types follows the CamelCase style. Structs and enums are more
    powerful than C''s structs and enums, while unions in Rust are very close to C
    and are there mainly to interact with C code bases. We''ll cover structs and enums
    in this section, while unions are covered in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，用户定义类型是由您定义的类型。这些可以由几个类型组成。它们可能是一个原始类型的包装，或者是由几个用户定义类型组成的组合。它们有三种形式：结构体、枚举和联合体，或者更常见地称为**结构体**、**枚举**和**联合体**。它们允许您轻松地表达您的数据。用户定义类型的命名约定遵循驼峰式风格。结构体和枚举比C语言的结构体和枚举更强大，而Rust中的联合体与C语言非常接近，主要是为了与C代码库交互。我们将在本节中介绍结构体和枚举，而联合体将在[第7章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)，*高级概念*中介绍。
- en: Structs
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: 'In Rust, there are three forms of structs that we can declare. The simplest
    of them is the **unit struct**, which is written with the `struct` keyword, followed
    by its name and a semicolon at the end. The following code example defines a unit
    struct:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们可以声明三种结构体形式。其中最简单的是**单元结构体**，它使用`struct`关键字编写，后面跟着其名称和结尾的分号。以下代码示例定义了一个单元结构体：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have defined a unit struct called `Dummy` in the preceding code. In `main`,
    we can initialize this type using only its name. `value` now contains an instance
    of `Dummy` and is a zero sized value. Unit structs do not take any size at runtime
    as they have no data associated with them. There are very few use cases for unit
    structs. They can be used to model entities with no data or state associated with
    them. Another use case is to use them to represent error types, where the struct
    itself is sufficient to understand the error without needing a description of
    it. Another use case is to represent states in a state machine implementation.
    Next, let's look at the second form of structs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为`Dummy`的单元结构体。在`main`函数中，我们可以仅使用其名称来初始化此类型。`value`现在包含了一个`Dummy`类型的实例，并且是一个零大小值。单元结构体在运行时不会占用任何大小，因为它们没有与之关联的数据。单元结构体的用途非常有限。它们可以用来模拟没有数据或状态关联的实体。另一个用途是使用它们来表示错误类型，其中结构体本身足以理解错误，而不需要对其描述。另一个用途是在状态机实现中表示状态。接下来，让我们看看结构体的第二种形式。
- en: 'The second form of struct is the **tuple struct**, which has associated data.
    Here, the individual fields are not named, but are referred to by their position
    in the definition. Let''s say you are writing a color conversion/calculation library
    for use in your graphics application and want to represent *RGB* color values
    in code. We can represent our `Color` type and the related items like so:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的第二种形式是**元组结构体**，它关联着数据。在这里，各个字段没有命名，而是通过在定义中的位置来引用。假设你正在编写一个用于图形应用程序的颜色转换/计算库，并想在代码中表示*RGB*颜色值。我们可以这样表示我们的`Color`类型和相关项：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, `Color(u8, u8, u8)` is a tuple struct that was created
    and stored in `white`. We then access the individual color components in `white`
    using the `white.0` syntax. Fields within the tuple struct can be accessed by
    the `variable.<index>` syntax, where the `index` refers to the position of the
    field in the struct, which starts with `0`. Another way to access the individual
    fields of a struct is by destructuring the struct using the `let` statement. In
    the second part, we created a color `orange`. Following that, we wrote the `let`
    statement with `Color(r, g, b)` on the left-hand side and to the right we put
    our `orange`. This results in three fields in `orange` getting stored within the `r`,
    `g`, and `b` variables. The types of `r`, `g`, and `b` are also inferred automatically
    for us.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Color(u8, u8, u8)`是一个元组结构体，它被创建并存储在`white`中。然后我们使用`white.0`语法访问`white`中的单个颜色组件。可以通过`variable.<index>`语法访问元组结构体内的字段，其中`index`指的是字段在结构体中的位置，从`0`开始。另一种访问结构体单个字段的方法是使用`let`语句解构结构体。在第二部分，我们创建了一个颜色`orange`。随后，我们编写了`let`语句，左侧是`Color(r,
    g, b)`，右侧是我们的`orange`。这导致`orange`中的三个字段被存储在`r`、`g`和`b`变量中。`r`、`g`和`b`的类型也会自动为我们推断。
- en: 'The tuple struct is an ideal choice when you need to model data that has less
    than four or five attributes. Anything more than that hinders readability and
    reasoning. For a data type that has more than three fields cases, it''s recommended
    to use a C-like struct, which is the third form and the most commonly used one.
    Consider the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要建模具有不到四个或五个属性的数据时，元组结构体是一个理想的选择。超过这个数量会阻碍可读性和推理。对于具有超过三个字段的情况，建议使用类似C的结构体，这是第三种形式，也是最常用的形式。考虑以下代码：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, structs  are created in the same way as tuple structs,
    that is, by writing the `struct` keyword followed by the name of the struct. However,
    they start with braces and their field declarations are named. Within braces,
    we can write fields as `field: type` comma-separated pairs. Creating an instance
    of a struct is also simple; we write `Player`, followed by a pair of braces, which
    contains comma-separated field initializations. When initializing a field from
    a variable that has the same name as the field name, we can use the **field init
    shorthand** feature, which is the case with the `name` field in the preceding
    code. We can then access the fields from the created instance easily by using
    the `struct.field_name` syntax. In the preceding code, we also have a function
    called `bump_player_score`, which takes the struct `Player` as a parameter. Function
    arguments are immutable by default, so when we want to modify the score of the
    player, we need to change the parameter to `mut player` in our function, which
    allows us to modify any of its fields. Having a `mut` on the struct implies mutability
    for all of its fields.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，结构体是以与元组结构体相同的方式创建的，即通过写出`struct`关键字后跟结构体的名称。然而，它们以大括号开始，并且它们的字段声明是有名的。在大括号内，我们可以将字段写成`field:
    type`逗号分隔的对。创建结构体实例也很简单；我们写出`Player`，然后跟上一对大括号，其中包含逗号分隔的字段初始化。当我们从与字段名称相同的变量初始化字段时，我们可以使用**字段初始化简写**功能，正如前面代码中的`name`字段那样。然后我们可以通过使用`struct.field_name`语法轻松访问创建的实例的字段。在前面的代码中，我们还有一个名为`bump_player_score`的函数，它接受结构体`Player`作为参数。默认情况下，函数参数是不可变的，所以当我们想要修改玩家的分数时，我们需要在我们的函数中将参数更改为`mut
    player`，这允许我们修改其任何字段。在结构体上有`mut`意味着所有字段都具有可变性。'
- en: The advantage of using a struct rather than a tuple struct is that we can initialize
    the fields in any order. It also allows us to provide meaningful names to the
    fields. As a side note, the size of a struct is simply the sum of its individual
    field members, along with any data alignment padding, if required. They don't
    have any extra metadata size overhead associated with them. Next, let's look at
    enumerations, also known as enums.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构体而不是元组结构体的优点在于我们可以以任何顺序初始化字段。它还允许我们为字段提供有意义的名称。作为旁注，结构体的大小仅仅是其各个字段成员的总和，以及如果需要的话，任何数据对齐填充。它们与它们没有任何额外的元数据大小开销相关联。接下来，让我们看看枚举，也称为枚举。
- en: Enums
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'When you need to model something that can be of different kinds, enums are
    the way to go. They are created using the `enum` keyword, followed by the name
    of the enum, followed by a pair of braces. Within braces, we can write all the
    possibilities of the type, which are called **variants**. These variants can be
    defined with or without data contained in them, and the data contained can be
    any primitive type, structs, tuple structs, or even an enum. However, in the recursive
    case, where you have an enum, `Foo`, and also a variant which holds `Foo`, the
    variant needs to be behind a pointer (`Box`, `Rc`, and so on) type to avoid having
    recursively infinite type definitions. Because enums can also be created on the
    stack, they need to have a predetermined size, and infinite type definitions makes
    it impossible to determine the size at compile time. Now, let''s take a look at
    how to create one:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要对一个可以有多种类型的对象进行建模时，枚举是最佳选择。它们通过使用`enum`关键字，后跟枚举名称，然后是一对花括号来创建。在花括号内，我们可以写出该类型的所有可能性，这些被称为**变体**。这些变体可以带或不带包含在其中的数据定义，包含的数据可以是任何原始类型、结构体、元组结构体，甚至是枚举。然而，在递归情况下，当你有一个枚举`Foo`和一个包含`Foo`的变体时，这个变体需要位于一个指针类型（如`Box`、`Rc`等）之后，以避免有递归无限类型定义。因为枚举也可以在栈上创建，所以它们需要有一个预定的尺寸，无限类型定义使得在编译时无法确定大小。现在，让我们看看如何创建一个枚举：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code defines two enum types: `Direction` and `PlayerAction`.
    We then create an instance of them by choosing any variant, such as `Direction::N`
    or `PlayerAction::Wait` using the double colon `::` in between. Note that we can''t
    have something like an uninitialized enum, and it needs to be one of the variants.
    Given an enum value, to see what variant an enum instance has, we use pattern
    matching by using *match* expressions. When we match on enums, we can directly
    destructure the contents of the variants by putting variables in place of fields
    such as `direction` in `PlayerAction::Attack(direction)`, which in turn means
    that we can use them inside our match arms.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了两种枚举类型：`Direction`和`PlayerAction`。然后我们通过选择任何变体，例如`Direction::N`或`PlayerAction::Wait`，使用双冒号`::`在它们之间创建它们的实例。请注意，我们不能有一个未初始化的枚举，它必须是其中一个变体。给定一个枚举值，要查看枚举实例具有哪个变体，我们使用模式匹配通过使用*match*表达式。当我们对枚举进行匹配时，我们可以通过将变量放在字段如`PlayerAction::Attack(direction)`中的`direction`等字段的位置来直接解构变体的内容，这反过来意味着我们可以在我们的匹配分支中使用它们。
- en: 'As you can see in our preceding `Direction` enum, we have a `#[derive(Debug)]`
    annotation. This is an attribute and it allows `Direction` instances to be printed
    using the `{:?}` format string in `println!()`. This is done by generating methods
    from a trait called `Debug`. The compiler tells us whether the `Debug` trait is
    missing and gives suggestions about how to fix it, and so we need the attribute
    there:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在我们之前的`Direction`枚举中看到的那样，我们有一个`#[derive(Debug)]`注解。这是一个属性，它允许`Direction`实例使用`println!()`中的`{:?}`格式字符串进行打印。这是通过从名为`Debug`的特质生成方法来完成的。编译器会告诉我们是否缺少`Debug`特质，并给出有关如何修复的建议，因此我们需要在那里使用这个属性：
- en: '![](img/0298324f-454c-4e88-b751-b4b5aa75fd08.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0298324f-454c-4e88-b751-b4b5aa75fd08.png)'
- en: From a functional programmer's perspective, structs and enums are also known
    as **Algebraic Data Types (ADTs)** because the possible range of values they can
    represent can be expressed using the rules of algebra. For instance, an enum is
    called a **sum type** because the range of values that it can hold is basically
    the sum of the range of values of its variants, while a struct is called a **product
    type** because its range of possible values is the cartesian product of their
    individual fields' range of values. We'll sometime refer to them as ADTs when
    talking about them in general.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数式程序员的视角来看，结构和枚举也被称为**代数数据类型（ADTs**），因为它们可以表示的可能值的范围可以用代数规则来表示。例如，枚举被称为**求和类型**，因为它可以持有的值范围基本上是其变体值范围的求和，而结构被称为**积类型**，因为其可能的值范围是其各个字段值范围的笛卡尔积。在一般讨论它们时，我们有时会称它们为ADTs。
- en: Functions and methods on types
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型上的函数和方法
- en: Types without behavior can be limiting, and it's often the case that we want
    to have functions or methods on types so that we can return new instances of them
    rather than constructing them manually or so that we have the ability to the manipulate
    fields of a user-defined type. We can do this via **impl** **blocks**, which is
    read as providing implementations for a type. We can provide implementations for
    all user-defined types or any wrapper type. First, let's take a look at how to
    write implementations for a struct.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 没有行为的类型可能有限制，通常我们希望在类型上有函数或方法，这样我们就可以返回它们的新实例而不是手动构建它们，或者这样我们就有能力操作用户定义类型的字段。我们可以通过**impl**
    **块**来实现这一点，这可以理解为为类型提供实现。我们可以为所有用户定义类型或任何包装类型提供实现。首先，让我们看看如何为结构编写实现。
- en: Impl blocks on structs
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构上的Impl块
- en: 'We can add behavior to our previously defined `Player` struct with two functionalities:
    a constructor-like function that takes a name and sets default values for the
    remaining fields in `Person`, and getter and setter methods for the friend count
    of `Person`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种功能向先前定义的`Player`结构添加行为：一个类似于构造函数的函数，它接受一个名称并设置`Person`中剩余字段的默认值，以及`Person`的getter和setter方法来设置朋友数量：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We use the `impl` keyword, followed by the type we are implementing the methods
    for, followed by braces. Within braces, we can write two kinds of methods:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`impl`关键字，后跟我们要实现方法的类型，然后是花括号。在花括号内，我们可以编写两种方法：
- en: '**Associated methods**: Methods without a `self` type as their first parameter.
    The `with_name` method is called an associated method because it does not have
    `self` as the first parameter. It is similar to a static method in object-oriented
    languages. These methods are available on the type themselves and do not need
    an instance of the type to invoke them. Associated methods are invoked by prefixing
    the method name with the struct name and double colons, like so:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联方法**：没有`self`类型作为其第一个参数的方法。`with_name`方法被称为关联方法，因为它没有`self`作为第一个参数。它类似于面向对象语言中的静态方法。这些方法在类型本身上可用，并且不需要类型的实例来调用它们。关联方法通过在方法名前加上结构名和双冒号来调用，如下所示：'
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Instance methods**: Functions that take a `self` value as its first argument.
    The `self` symbol here is similar to *self* in Python and points to the instance
    on which the method is implemented (here, this is `Player`). Therefore, the `get_friends()` method
    can only be called on already created instances of the struct:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例方法**：以`self`值作为其第一个参数的函数。这里的`self`符号与Python中的`self`类似，指向实现该方法的实例（在这里，这是`Player`）。因此，`get_friends()`方法只能在已经创建的结构实例上调用：'
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we were to call `get_friends` with the associated method syntax, that is, `Player::get_friends()`,
    the compiler gives the following error:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用关联方法语法调用`get_friends`，即`Player::get_friends()`，编译器会给出以下错误：
- en: '![](img/1e8237b1-c8a1-49c6-bd57-fd1a5e94069f.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e8237b1-c8a1-49c6-bd57-fd1a5e94069f.png)'
- en: The error is misleading here, but it indicates that instance methods are basically
    associated methods with `self` as the first parameter and that `instance.foo()`
    is a syntax sugar. This means that we can call it like this, too: `Player::get_friends(&player);`.
    In this invocation, we pass the method an instance of `Player`, that is, `&self`
    is `&player`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的错误具有误导性，但它表明实例方法基本上是与`self`作为第一个参数关联的方法，并且`instance.foo()`是一种语法糖。这意味着我们也可以这样调用它：`Player::get_friends(&player);`。在这个调用中，我们向方法传递了一个`Player`实例，即`&self`是`&player`。
- en: 'There are three variants of instance methods that we can implement on types:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型上，我们可以实现三种实例方法的变体：
- en: '`self` as the first parameter. In this case, calling this method won''t allow
    you to use the type later.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self` 作为第一个参数。在这种情况下，调用此方法不会允许你在之后使用该类型。'
- en: '`&self` as the first parameter. This method only provides read access to the
    instance of a type.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&self` 作为第一个参数。此方法仅提供对类型实例的读取访问。'
- en: '`&mut self` as the first parameter. This method provides mutable access to
    the instance of a type.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&mut self` 作为第一个参数。此方法提供了对类型实例的可变访问。'
- en: Our `set_friends` method is a `&mut self` method, which allows us to mutate
    the fields of `player`. We need the `&` operator before `self`, meaning that `self`
    is borrowed for the duration of the method, which is exactly what we want here.
    Without the ampersand, the caller would move the ownership to the method, which
    means that the value would get de-allocated after `get_friends` returns and we
    would not get to use our `Player` instance anymore. Don't worry if the terms move
    and borrowing does not make sense as we explain all of this in [Chapter 5](db2c2723-8ca0-43be-b135-afd847342146.xhtml),
    *Memory Management and Safety*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的 `set_friends` 方法是一个 `&mut self` 方法，它允许我们修改 `player` 的字段。我们需要在 `self` 前面使用
    `&` 操作符，这意味着 `self` 在方法执行期间被借用，这正是我们想要的。如果没有使用连字符，调用者会将所有权移动到方法中，这意味着值在 `get_friends`
    返回后会进行去分配，我们就无法再使用 `Player` 实例了。如果你对术语移动和借用还不理解，不要担心，我们将在[第 5 章](db2c2723-8ca0-43be-b135-afd847342146.xhtml)，*内存管理和安全性*中解释所有这些内容。 '
- en: Now, onto implementations for enums.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下枚举的实现。
- en: Impl blocks for enums
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举的 Impl 块
- en: 'We can also provide implementations for enums. For example, consider a payments
    library built in Rust, which exposes a single API called `pay`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为枚举提供实现。例如，考虑一个用 Rust 编写的支付库，它公开了一个名为 `pay` 的单一 API：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code has a method called `get_saved_payment_mode()`, which returns
    a user's saved payment mode. This can either be a *Credit* *Card*, *Debit Card*,
    or *Paypal*. This is best modeled as an enum, where different payment methods
    can be added as its variants. The library then provides us with a single `pay()`
    method to which we can conveniently provide an amount to pay. This method determines
    which variant of the enum it is and dispatches methods accordingly to the correct
    payment service provider, without the library consumer worrying about checking
    which payment method to use.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中有一个名为 `get_saved_payment_mode()` 的方法，它返回一个用户的保存支付方式。这可以是*信用卡*、*借记卡*或*Paypal*。这最好用枚举（enum）来建模，其中不同的支付方式可以作为其变体添加。然后库为我们提供了一个单一的
    `pay()` 方法，我们可以方便地提供要支付的金额。此方法确定枚举的哪个变体，并相应地调度到正确的支付服务提供商，而无需库消费者担心检查使用哪种支付方式。
- en: Enums are also widely used for modeling state machines, and when combined with
    match statements, they make state transition code very concise to write. They
    are also used to model custom error types. When enum variants don't have any data
    associated with them, they can be used like C enums, where the variants implicitly
    have integer values starting with `0`, but can also be manually tagged with integer
    (`isize`) values. This is useful when interacting with foreign C libraries.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举也广泛用于建模状态机，当与匹配语句结合使用时，它们使得状态转换代码非常简洁易写。它们还用于建模自定义错误类型。当枚举变体没有与之关联的数据时，它们可以像
    C 枚举一样使用，其中变体隐式地具有从 `0` 开始的整数值，但也可以手动标记为整型（`isize`）值。这在与外部 C 库交互时很有用。
- en: Modules, imports, and use statements
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块、导入和使用语句
- en: 'Languages often provide a way to split large code bases into multiple files
    to manage complexity. Java follows the convention of a single public class per
    `.java` file, while C++ provides us with header files and include statements.
    Rust is no different and provides us with **modules**. Modules are a way to namespace
    or organize code in a Rust program. To allow flexibility in organizing our code,
    there are multiple ways to create modules. Modules are a complex topic to understand
    and to make it brief for this section, we''ll highlight only the important aspects
    about using them. Modules are covered in detail in [Chapter 2](41099eaf-eb1e-4f75-bfdd-628152f59b58.xhtml),
    *Managing Projects with Cargo*. The following are the key takeaways about modules
    in Rust:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 语言通常提供一种方法将大型代码库拆分成多个文件以管理复杂性。Java遵循每个`.java`文件一个公共类的约定，而C++则提供了头文件和包含语句。Rust也不例外，它为我们提供了**模块**。模块是命名空间或组织Rust程序代码的一种方式。为了在组织代码时提供灵活性，有多种创建模块的方法。模块是一个复杂的概念，为了本节的简洁性，我们将只突出使用它们的重要方面。模块的详细内容在[第2章](41099eaf-eb1e-4f75-bfdd-628152f59b58.xhtml)，*使用Cargo管理项目*中有所介绍。以下是关于Rust中模块的关键要点：
- en: Every Rust program needs to have a root module. In executables, it is usually
    the `main.rs` file, and for libraries, it is `lib.rs`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Rust程序都需要有一个根模块。在可执行文件中，通常是`main.rs`文件，而对于库来说，则是`lib.rs`。
- en: Modules can be declared within other modules or can be organized as files and
    directories.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块可以在其他模块内部声明，也可以组织成文件和目录。
- en: To let the compiler know about our module, we need to declare it using the `mod`
    keyword, as in `mod my_module;`, in our root module.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了让编译器了解我们的模块，我们需要使用`mod`关键字来声明它，就像在根模块中使用`mod my_module;`一样。
- en: To use any of the items within the module, we need to use the `use` keyword,
    along with the name of the module. This is known as bringing the item into scope.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用模块内的任何项目，我们需要使用`use`关键字，以及模块的名称。这被称为将项目引入作用域。
- en: Items defined within modules are private by default, and you need to use the
    `pub` keyword to expose them to their consumers.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块内部定义的项目默认是私有的，你需要使用`pub`关键字来将它们暴露给消费者。
- en: That was modules in brief. Some of the advanced aspects of modules are also
    covered in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml), *Advanced
    Concepts*. Next, let's look at the commonly used collection types that are available
    in the standard library.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模块的简要介绍。模块的一些高级特性也在[第7章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)，*高级概念*中有所涉及。接下来，让我们看看标准库中可用的常用集合类型。
- en: Collections
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: It's often the case that your program has to process more than one instance
    of data. For that, we have collection types. Depending on what you want and where
    your data resides in memory, Rust provides many kinds of built-in types to store
    a collection of data. First, we have *arrays* and *tuples*. Then, we have dynamic
    collection types in the standard library, of which we'll cover the most commonly
    used ones, that is, *vectors* (list of items) and *maps* (key/value items). Then,
    we also have references to collection types, called *slices*, which are basically
    a view into a contiguous piece of data owned by some other variable. Let's start
    with arrays first.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你的程序需要处理多个数据实例。为此，我们有了集合类型。根据你的需求和数据在内存中的位置，Rust提供了许多内置类型来存储数据集合。首先，我们有*数组*和*元组*。然后，在标准库中，我们有动态集合类型，我们将介绍最常用的几种，即*向量*（项目列表）和*映射*（键/值项）。然后，我们还有集合类型的引用，称为*切片*，它基本上是某个其他变量拥有的连续数据片段的视图。让我们先从数组开始。
- en: Arrays
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays have a fixed length that can store items of the same type. They are
    denoted by `[T, N]`, where `T` is any type and `N` is the number of elements in
    array. The size of the array cannot be a variable, but has to be a literal `usize`
    value:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有一个固定长度，可以存储相同类型的项目。它们用`[T, N]`表示，其中`T`是任何类型，`N`是数组中的元素数量。数组的大小不能是变量，而必须是字面量`usize`值：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we declared an array, `numbers`, which contains `10`
    elements for which we specified the type on the left. In the second array, `floats`,
    we specified the type as a suffix to the first item of the array, that is, `0.1f64`.
    This is another way to specify types. Next, let's look at tuples.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个数组`numbers`，它包含`10`个元素，我们在左侧指定了类型。在第二个数组`floats`中，我们将类型指定为第一个数组项的后缀，即`0.1f64`。这是指定类型的另一种方式。接下来，让我们看看元组。
- en: Tuples
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples differ from arrays in the way that elements of an array have to be of
    the same type, while items in a tuple can be a mix of types. They are heterogeneous
    collections and are useful for storing distinct types together. They can also
    be used when returning multiple values from a function. Consider the following
    code that uses tuples:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与数组的不同之处在于，数组中的元素必须具有相同的类型，而元组中的项可以是不同类型的混合。它们是异构集合，用于存储不同类型的数据很有用。当从函数返回多个值时也可以使用。考虑以下使用元组的代码：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, `num_and_str` is a tuple of two items, `(u8, &str)`.
    We can also extract values from an already declared tuple into individual variables.
    After printing the tuple, we destructure it on the next line into the  `num` and
    `string` variables, and their types are inferred automatically. That's pretty
    neat.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`num_and_str` 是一个包含两个元素的元组，`(u8, &str)`。我们还可以从已声明的元组中提取值到单独的变量中。在打印元组后，我们在下一行将其解构为
    `num` 和 `string` 变量，它们的类型会自动推断。这相当方便。
- en: Vectors
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: 'Vectors are like arrays, except that their content or length doesn''t need
    to be known in advance and can grow on demand. They are allocated on the heap.
    They can be created by either calling the `Vec::new` constructor or by using the
    `vec![]` macro:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 向量类似于数组，但它们的长度或内容不需要预先知道，并且可以根据需要增长。它们在堆上分配。可以通过调用 `Vec::new` 构造函数或使用 `vec![]`
    宏来创建：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we created two vectors, `numbers_vec` and `vec_with_macro`,
    in different ways. We can push elements to our vector using `push()` method and
    can remove elements using `pop()`. There are more methods for you to explore if
    you go to their documentation page: [https://doc.rust-lang.org/std/vec/struct.Vec.html](https://doc.rust-lang.org/std/vec/struct.Vec.html)
    . Vectors can also be iterated using the `for` loop syntax as they also implement
    the `Iterator` trait.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们以不同的方式创建了两个向量，`numbers_vec` 和 `vec_with_macro`。我们可以使用 `push()` 方法向向量中添加元素，并使用
    `pop()` 方法移除元素。如果你访问它们的文档页面，还可以探索更多方法：[https://doc.rust-lang.org/std/vec/struct.Vec.html](https://doc.rust-lang.org/std/vec/struct.Vec.html)。向量也可以使用
    `for` 循环语法进行迭代，因为它们也实现了 `Iterator` 特性。
- en: Hashmaps
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希映射
- en: 'Rust also provides us with maps, which can be used to store key-value data.
    They come from the `std::collections` module and are named `HashMap`. They are
    created with the `HashMap::new` constructor function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 还为我们提供了映射，可以用来存储键值数据。它们来自 `std::collections` 模块，并命名为 `HashMap`。它们通过 `HashMap::new`
    构造函数创建：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we created a new `HashMap` called `fruits`. We then insert
    some fruits into our `fruits` map, along with their count, using the `insert`
    method. Following that, we iterate over the key value pairs using `for` loop,
    where in we take a reference to our fruit map by `&fruits`, because we only want
    read access to the key and value. By default, the value will be consumed by the
    `for` loop. The `for` loop in this case returns a two field tuple (`(k ,v)`).
    There are also seperate methods `keys()` and `values()` available to iterate over
    just keys and values, respectively. The hashing algorithm used for hashing the
    keys of the `HashMap` type is based on the *Robin hood* open addressing scheme,
    but can be replaced with a custom hasher depending on the use case and performance.
    That's about it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `fruits` 的新 `HashMap`。然后我们使用 `insert` 方法将一些水果及其数量插入到我们的 `fruits`
    映射中。随后，我们使用 `for` 循环遍历键值对，其中我们通过 `&fruits` 获取水果映射的引用，因为我们只想读取键和值。默认情况下，值将被 `for`
    循环消耗。在这种情况下，`for` 循环返回一个包含两个字段的元组（`（k，v）`）。还有单独的 `keys()` 和 `values()` 方法可用于分别遍历键和值。`HashMap`
    类型中用于哈希键的哈希算法基于 *Robin hood* 开放寻址方案，但可以根据用例和性能替换为自定义哈希器。这就说完了。
- en: Next, let's look at slices.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看切片。
- en: Slices
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: Slices are a generic way to get a view into a collection type. Most use cases
    are to get a read only access to a certain range of items in a collection type.
    A slice is basically a pointer or a reference that points to a continuous range
    in an existing collection type that's owned by some other variable. Under the
    hood, slices are fat pointers to existing data somewhere in the stack or the heap.
    By fat pointer, it means that they also have information on how many elements
    they are pointing to, along with the pointer to the data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是一种通用的方式来获取集合类型的一个视图。大多数用例是为了获取对集合类型中某个范围的只读访问。切片基本上是一个指针或引用，它指向由某个其他变量拥有的现有集合类型中的连续范围。在底层，切片是现有数据中的胖指针，这些数据位于栈或堆的某个位置。通过胖指针，意味着它们还包含它们指向的元素数量信息，以及数据指针。
- en: 'Slices are denoted by `&[T]`, where `T` is any type. They are quite similar
    to arrays in terms of usage:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 切片用 `&[T]` 表示，其中 `T` 是任何类型。在用法上，它们与数组非常相似：
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we have an array of `numbers`, which is a stack allocated
    value. We then take a slice into the array `numbers` using the `&numbers[..]`
    syntax and store in `all`, which has the type `&[u8]`. The `[..]` at the end means
    that we want to take a full slice of the collection. We need the `&` here as we
    can't have slices as bare values – only behind a pointer. This is because slices
    are **unsized types**. We'll cover them in detail in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*. We can also provide ranges (`[0..2]`) to get a slice from
    anywhere in-between or all of them. Slices can also be mutably acquired. `first_two`
    is a mutable slice through which we can modify the original `numbers` array.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个 `numbers` 数组，它是一个栈分配的值。然后我们使用 `&numbers[..]` 语法从数组 `numbers` 中取一个切片，并将其存储在
    `all` 中，其类型为 `&[u8]`。末尾的 `[..]` 表示我们想要获取整个集合的切片。这里我们需要 `&`，因为我们不能有裸值的切片——只能位于指针之后。这是因为切片是**无大小类型**。我们将在[第7章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)，*高级概念*中详细讲解它们。我们也可以提供范围（`[0..2]`）来从任何中间位置或全部获取切片。切片也可以被可变地获取。`first_two`
    是一个可变切片，通过它可以修改原始的 `numbers` 数组。
- en: To the astute observer, you can see that we have used extra pair of braces in
    the preceding code when taking slices. They are there to isolate code that takes
    mutable reference of the slice from the immutable reference. Without them, the
    code won't compile. These concepts will be made clearer to you in [Chapter 5](db2c2723-8ca0-43be-b135-afd847342146.xhtml),
    *Memory Management and Safety*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于敏锐的观察者来说，你可以看到在取切片时，我们使用了额外的成对花括号。它们的存在是为了隔离代码，这些代码获取切片的可变引用而不是不可变引用。没有它们，代码将无法编译。这些概念将在[第5章](db2c2723-8ca0-43be-b135-afd847342146.xhtml)，*内存管理和安全性*中更加清晰。
- en: '**Note**: The `&str` type also comes under the category of a slice type (a
    `[u8]`). The only distinction from other byte slices is that they are guaranteed
    to be UTF-8\. Slices can also be taken on Vecs or Strings.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：`&str` 类型也属于切片类型（一个 `[u8]`）。与其他字节切片的区别在于，它们保证是 UTF-8 编码。切片也可以从 Vec 或
    String 中获取。'
- en: Next, let's look at iterators.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看迭代器。
- en: Iterators
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: An iterator is a construct that provides an efficient way to act on elements
    of collection types. They are not a new concept, though. In many imperative languages,
    they are implemented as *objects* that are constructed from collection types such
    as lists or maps. For instance, Python's `iter(some_list)` or C++'s `vector.begin()`
    are ways to construct iterators from an existing collection. The main motivation
    for iterators to exist in the first place is that they provide a higher level
    abstraction of walking through items of a collection instead of using manual `for`
    loops, which are very much prone to off by one errors. Another advantage is that
    iterators do not read the whole collection in memory and are lazy. By lazy, we mean
    that the iterator only evaluates or accesses an element in a collection when needed.
    Iterators can also be chained with multiple transformation operations, such as
    filtering elements based on a condition, and do not evaluate the transformations
    until you need them. To access these items when you need them, iterators provide
    a `next()` method, which tries to read the next item from the collection. This
    occurs when the iterator evaluates the chain of computation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一种提供对集合类型元素进行高效操作的构造。尽管它不是一个新概念，但在许多命令式语言中，迭代器被实现为从列表或映射等集合类型构造的*对象*。例如，Python
    的 `iter(some_list)` 或 C++ 的 `vector.begin()` 是从现有集合构造迭代器的方法。迭代器最初存在的主要动机是它们提供了一种比使用手动
    `for` 循环更高层次的抽象，手动 `for` 循环很容易出现“少一个”的错误。另一个优点是迭代器不会在内存中读取整个集合，并且是惰性的。惰性意味着迭代器仅在需要时才会评估或访问集合中的元素。迭代器还可以与多个转换操作链式使用，例如根据条件过滤元素，并且只有在需要时才会评估这些转换。当需要访问这些元素时，迭代器提供了一个
    `next()` 方法，该方法尝试从集合中读取下一个元素。这发生在迭代器评估计算链时。
- en: In Rust, an iterator is any type that implements the `Iterator` trait. This
    type can then be used in a `for` loop to walk over its items. They are implemented
    for most standard library collection types such as `Vector`, `HashMap`, `BTreeMap`,
    and many more and one can also implement it for their own types.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，任何实现了 `Iterator` 特性的类型都是迭代器。这种类型可以用于 `for` 循环中遍历其元素。它们为大多数标准库集合类型（如
    `Vector`、`HashMap`、`BTreeMap` 等）实现了迭代器，也可以为它们自己的类型实现迭代器。
- en: '**Note**: It only makes sense to implement the `Iterator` trait if the type
    has a collection, such as semantics. For instance, it doesn''t make sense to implement
    the iterator trait for a `()` unit type.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：只有当类型具有集合，如语义时，才需要实现 `Iterator` 特性。例如，为 `()` 单位类型实现迭代器特性是没有意义的。'
- en: Iterators are frequently used whenever we are dealing with collection types
    in Rust. In fact, Rust's `for` loop is desugared into a normal match expression
    with `next` calls on the object being iterated over. Also, we can convert most
    collection types into an iterator by calling `iter()` or `into_iter()` on them.
    That's enough information on iterators – now, we can tackle the following exercise.
    We'll go deep into iterators and implement one ourselves in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，迭代器是任何实现了 `Iterator` 特性的类型。这种类型可以用于 `for` 循环中遍历其元素。它们为大多数标准库集合类型（如
    `Vector`、`HashMap`、`BTreeMap` 等）实现了迭代器，也可以为它们自己的类型实现迭代器。在 Rust 中，`for` 循环被转换为对正在迭代的对象的
    `next` 调用的正常 `match` 表达式。此外，我们可以通过在它们上调用 `iter()` 或 `into_iter()` 来将大多数集合类型转换为迭代器。关于迭代器的信息就这么多——现在，我们可以着手解决以下练习。我们将深入研究迭代器，并在第
    7 章 *高级概念* 中实现一个迭代器。
- en: Exercise – fixing the word counter
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 – 修复单词计数器
- en: 'Armed with the basics, it''s time to put our knowledge to use! Here, we have
    a program that counts instances of words in a text file, which is passed to it
    as an argument. It''s almost complete, but has a few bugs that the compiler catches
    and a couple of subtle ones. Here''s our incomplete program:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 带着基础知识，现在是时候将我们的知识付诸实践了！在这里，我们有一个程序，它计算文本文件中单词的实例，该文件作为参数传递给它。它几乎完成了，但有几个编译器捕获的错误和一些微妙的错误。以下是我们的不完整程序：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Go ahead and type the program into a file; try to compile and fix all the bugs
    with the help of the compiler. Try to fix one bug at a time and get feedback from
    the compiler by recompiling the code. The point of this exercise, in addition
    to covering the topics of this chapter, is to make you more comfortable with the
    error messages from the compiler, which is an important mental exercise in getting
    to know more about the compiler and how it analyzes your code. You might also
    be surprised to see how the compiler is quite smart in helping you removing errors
    from the code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将程序输入到一个文件中；尝试在编译器的帮助下编译并修复所有错误。一次修复一个错误，并通过重新编译代码从编译器那里获取反馈。这个练习的目的，除了涵盖本章的主题外，还在于让你更加熟悉编译器给出的错误信息，这是了解编译器及其如何分析你的代码的重要心理锻炼。你可能会惊讶地看到编译器在帮助你从代码中移除错误方面是多么的聪明。
- en: 'Once you are done fixing the code, here are some exercises for you to try so
    that you can flex your muscles a bit further:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成代码的修复，这里有一些练习供你尝试，以便你能够进一步锻炼你的能力：
- en: Add a `filter` parameter to the `display` method of `WordCounter` for filtering
    the output based on the count. In other words, display a key/value pair only if
    the value is greater than that filtering value.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`WordCounter`的`display`方法添加一个`filter`参数，以便根据计数过滤输出。换句话说，只有当值大于过滤值时才显示键/值对。
- en: Since HashMaps store their values randomly, the output is also random every
    time you run the program. Try to sort the output. The HashMap's `values` method
    may be useful.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于HashMap存储其值是随机的，所以每次运行程序时输出也是随机的。尝试对输出进行排序。HashMap的`values`方法可能很有用。
- en: Take a look at the `display` method's `self` parameter. What happens if you
    remove the `&` operator before `self`?
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看一下`display`方法的`self`参数。如果你在`self`之前移除`&`运算符会发生什么？
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We covered so many topics in this chapter. We got to know a bit about the history
    of Rust and the motivations behind the language. We had a brief walkthrough on
    its design principles and the basic features of the language. We also got a glimpse
    of how Rust provides rich abstractions through its type system. We learned how
    to install the language toolchain, and how to use `rustc` to build and run trivial
    example programs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了如此多的主题。我们了解了一些关于Rust的历史和语言背后的动机。我们对它的设计原则和语言的基本特性进行了简要的介绍。我们还瞥见了Rust如何通过其类型系统提供丰富的抽象。我们学习了如何安装语言工具链，以及如何使用`rustc`构建和运行简单的示例程序。
- en: In the next chapter, we'll take a look at the standard way of building Rust
    applications and libraries using its dedicated package manager, and also set up
    our Rust development environment with a code editor, which will provide the foundation
    for all the subsequent exercises and projects in this book.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用Rust的专用包管理器构建Rust应用程序和库的标准方法，并设置我们的Rust开发环境，包括代码编辑器，这将为本书中所有后续练习和项目提供基础。
