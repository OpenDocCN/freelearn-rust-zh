- en: Advanced Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级概念
- en: Quite a few concepts we learned in the previous chapters really deserve close
    attention so we can appreciate the design of Rust. Learning these advanced topics
    will also help you further when you need to understand complex code bases. These
    concepts are also helpful when you want to create libraries that provide idiomatic
    Rust APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中我们学到的许多概念确实值得密切关注，这样我们才能欣赏 Rust 的设计。学习这些高级主题也将帮助你在需要理解复杂代码库时更进一步。这些概念在你想要创建提供惯用
    Rust API 的库时也非常有用。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Type system tidbits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型系统小贴士
- en: Strings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Iterators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Closures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Type system tidbits
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型系统小贴士
- en: '"An algorithm must be seen to be believed"'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '"算法必须被看到才能被相信"'
- en: – *Donald Knuth*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: – *唐纳德·克努特*
- en: Before we go into more dense topics in this chapter, we'll first discuss some
    of the type system tidbits in statically typed programming languages in general,
    with focus on Rust. Some of these topics may already be familiar to you from [Chapter
    1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml), *Getting Started with Rust*, but
    we're going to dig into the details here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入本章更密集的主题之前，我们将首先讨论静态类型编程语言中的一些类型系统小贴士，重点关注 Rust。其中一些主题你可能已经从 [第 1 章](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml)
    *Rust 入门* 中熟悉，但我们将在这里深入探讨细节。
- en: Blocks and expressions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块和表达式
- en: Despite being a mix of statements and expressions, Rust is primarily an expression-oriented
    language. This means that most constructs are expressions that return a value.
    It's also a language that uses C-like braces `{}`, to introduce new scope for
    variables in a program. Let's get these concepts straight before we talk more
    about them later in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Rust 是语句和表达式的混合体，但它主要是一种面向表达式的语言。这意味着大多数结构都是返回值的表达式。它也是一种使用类似 C 的花括号 `{}`
    来在程序中为变量引入新作用域的语言。在我们更深入地讨论这些概念之前，让我们先把这些概念弄清楚。
- en: A **block expression** (hereby referred as blocks) is any item that starts with
    `{` and ends with `}`. In Rust, they include `if else` expressions, match expressions,
    `while` loops, loops, bare `{}` blocks, functions, methods, and closures, and
    all of them return a value which is the last line of the expression. If you put
    a semicolon in the last expression, the block expressions default to a return
    value of the unit `()` type.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**块表达式**（以下简称块）是任何以 `{` 开始并以 `}` 结束的项。在 Rust 中，它们包括 `if else` 表达式、match 表达式、`while`
    循环、循环、裸 `{}` 块、函数、方法和闭包，并且它们都返回一个值，即表达式的最后一行。如果你在最后一行表达式后放置一个分号，块表达式默认返回单位类型 `()`
    的值。'
- en: 'A related concept to blocks is the **scope**. A scope is introduced whenever
    a new block is created. When we a new block and create any variable bindings within
    it, the bindings are confined to that scope and any reference to them is valid
    only within the scope bounds. It''s like a new environment for variables to live
    in, isolated from the others. Items such as functions, `impl` blocks, bare blocks,
    if else expressions, match expressions, functions, and closures introduce new
    scope in Rust. Within a block/scope, we can declare structs, enums, modules, traits
    and their implementations, and even blocks. Every Rust program starts with one
    root scope, which is the scope introduced by the `main` function. Within that,
    many nested scopes can be created. The `main` scope becomes the parent scope for
    all inner scopes declared. Consider the following snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与块相关的一个概念是**作用域**。每当创建一个新的块时，都会引入一个作用域。当我们创建一个新的块并在其中创建任何变量绑定时，这些绑定被限制在该作用域内，并且对它们的引用仅在作用域范围内有效。这就像为变量提供了一个新的生活环境，与其他变量隔离开来。在
    Rust 中，函数、`impl` 块、裸块、if else 表达式、match 表达式、函数和闭包等项引入了新的作用域。在块/作用域内，我们可以声明结构体、枚举、模块、特性和它们的实现，甚至块。每个
    Rust 程序都以一个根作用域开始，这是由 `main` 函数引入的作用域。在其中，可以创建许多嵌套的作用域。`main` 作用域成为所有内部声明的父作用域。考虑以下片段：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We used a bare block `{}`, to introduce a new inner scope and created a variable
    `a`. Following the end of the scope, we are trying to assign `b` to the value
    of `a`, which comes from the inner scope. Rust throws a compile time error saying
    ``cannot find value `a` in this scope`` . The parent scope from `main` does not
    know anything about `a` as it comes from the inner scope. This property of scopes
    is also used sometimes to control how long we want a reference to be valid, as
    we saw in [Chapter 5](db2c2723-8ca0-43be-b135-afd847342146.xhtml), *Memory Management
    and Safety*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用裸块`{}`引入一个新的内部作用域，并创建了一个变量`a`。在作用域结束时，我们试图将`b`赋值给来自内部作用域的`a`的值。Rust会在编译时抛出一个错误，说“在这个作用域中找不到值`a`”。`main`的父作用域对`a`一无所知，因为它来自内部作用域。这种作用域的特性有时也用于控制我们希望引用保持有效的时长，正如我们在[第5章](db2c2723-8ca0-43be-b135-afd847342146.xhtml)，“内存管理和安全性”中看到的。
- en: But the inner scope can access values from their parent scope. Because of that,
    it is possible to write `34 + b` within our inner scope.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是内部作用域可以访问其父作用域中的值。正因为如此，我们可以在内部作用域中编写`34 + b`。
- en: 'Now we come to expressions. We can benefit from their property of returning
    a value and that they must be of the same type in all branches. This results in
    very concise code. For example, consider this snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈表达式。我们可以从它们返回值的属性以及它们在所有分支中都必须具有相同类型的属性中受益。这导致代码非常简洁。例如，考虑以下片段：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use bare blocks to chunk several lines of code together and assign the
    value at the end with an implicit return of the `a + b + c` expression to `precompute`
    as shown previously. Match expressions can also assign and return values from
    their match arms directly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用裸块将几行代码组合在一起，并在末尾隐式返回`a + b + c`表达式的值到`precompute`，如前所述。匹配表达式也可以直接从其匹配分支中赋值和返回值。
- en: '**Note**: Being similar to the `switch` statement in C, match arms in Rust
    do not suffer from the `case fall through` side effect that results in lots of
    bugs in C code.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：与C语言中的`switch`语句类似，Rust中的匹配分支不会受到C代码中导致大量错误的`case fall through`副作用的影响。'
- en: The C switch case requires every `case` statement within the `switch` block
    to have a `break` if we want to bail out after running the code in that `case`.
    If the `break` is not present, any `case` statement following that is also executed,
    which is called the fall-through behavior. A match expression, on the other hand,
    is guaranteed to evaluate only one of the match arms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的`switch`情况要求在`switch`块中的每个`case`语句在执行该`case`中的代码后退出时都必须有一个`break`。如果没有`break`，那么随后的任何`case`语句也会被执行，这被称为fall-through行为。另一方面，匹配表达式保证只评估一个匹配分支。
- en: '`If else` expressions provide the same conciseness:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`If else`表达式提供了相同的简洁性：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In statement-based languages such as Python*,* you would write something like
    this for the preceding snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于语句的语言如Python*中，你会为前面的片段编写如下内容：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the Python code, we had to declare `result` beforehand, followed by doing
    separate assignments in the if else branch. Rust is more concise here, with the
    assignment being done as a result of the if else expression. Also, in Python,
    you can forget to assign a value to a variable in either of the branches and the
    variable may be left uninitialized. Rust will report at compile time if you return
    and assign something from the `if` block and either miss or return a different
    type from the `else` block.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python代码中，我们必须先声明`result`，然后在if else分支中进行单独的赋值。在这里，Rust更简洁，赋值是if else表达式的结果。此外，在Python中，你可能会忘记在任一分支中为变量赋值，变量可能被未初始化。如果你从`if`块返回并赋值，而`else`块中遗漏或返回了不同的类型，Rust将在编译时报告。
- en: 'As an added note, Rust also supports declaring uninitialized variables:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加说明，Rust还支持声明未初始化的变量：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But they need to be initialized before we use them. If an uninitialized variable
    is attempted to be read from later, Rust will forbid that and report at compile
    time that the variable must be initialized:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们在使用之前必须被初始化。如果尝试从后来读取未初始化的变量，Rust将禁止这样做，并在编译时报告变量必须被初始化：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let statements
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令牌语句
- en: In [Chapter 1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml), *Getting Started
    with Rust*, we briefly introduced `let`, which is used to create new variable
    bindings—but `let` is more than that. In fact, `let` is a pattern-matching statement.
    Pattern matching is a construct mostly seen in functional languages such as Haskell
    and allows us to manipulate and make decisions about values based on their internal
    structure or can be used to extract values out of algebraic data types. We had
    already
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml)《Rust入门》中，我们简要介绍了`let`，它用于创建新的变量绑定——但实际上`let`不仅仅是这样。实际上，`let`是一个模式匹配语句。模式匹配是一种在函数式语言（如Haskell）中主要看到的构造，它允许我们根据值的内部结构来操作和做出决策，或者可以用来从代数数据类型中提取值。我们之前已经
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our first line is `let` in its simplest form and it declares an immutable variable
    binding, `a`. In the second line, we have `mut` after the `let` keyword for `b`
    . `mut` is part of the `let` pattern, which binds `b` mutably to `i32` types in
    this case. `mut` enables `b` to bind again to some other `i32` type. Another keyword
    that''s seen less frequently with `let` is the `ref` keyword. Now, we generally
    use the `&` operator to create a reference/pointer to any value. The other way
    to create a reference to any value is to use the `ref` keyword with `let`. To
    illustrate `ref` and `mut`, we have a snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一行是`let`的最简单形式，它声明了一个不可变的变量绑定，`a`。在第二行，我们在`let`关键字后面有`mut`用于`b`。`mut`是`let`模式的一部分，在这个例子中将`b`可变地绑定到`i32`类型。`mut`使得`b`可以再次绑定到其他`i32`类型。另一个在`let`中较少见的关键字是`ref`关键字。现在，我们通常使用`&`运算符来创建任何值的引用/指针。创建任何值的引用的另一种方式是使用`let`与`ref`关键字。为了说明`ref`和`mut`，我们有一个代码片段：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `items_ref` is a reference created using the usual `&` operator. The next
    line also creates the `items_ref` reference to the same `items` value using `ref`.
    We can confirm, with the `assert_eq!` call following it, that the two pointer
    variables point to the same `items` value. The cast to `*const Items` is used
    to compare whether two pointers point to the same memory location, where `*const
    Items` is a raw pointer type to `Items`. Additionally, by combining `ref` and
    `mut` as shown in the second to last part of the code, we can get a mutable reference
    to any owned value other than the usual way of doing so with the `&mut` operator.
    But we have to use an inner scope to modify `a` from `b`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`items_ref`是通过常用的`&`运算符创建的引用。下一行也使用`ref`创建了指向相同`items`值的`items_ref`引用。我们可以通过随后的`assert_eq!`调用确认，这两个指针变量指向相同的`items`值。将`*const
    Items`转换为原始指针类型用于比较两个指针是否指向相同的内存位置，其中`*const Items`是`Items`的原始指针类型。此外，通过将`ref`和`mut`结合，如代码的第二行末尾所示，我们可以得到对任何所有权的可变引用，而不仅仅是使用`&mut`运算符的常规方式。但是，我们必须使用内部作用域来从`b`修改`a`。
- en: 'Languages using pattern matching are not just limited to having identifiers
    on the left hand side of `` `=` `` but can additionally have patterns referring
    to the structure of types. So, another convenience `let` provides us with is the
    ability to extract values from fields of an algebraic data type, such as a struct
    or enum as new variables. Here, we have a snippet that demonstrates this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配的语言不仅限于在`=`的左侧有标识符，还可以有引用类型结构的模式。所以，`let`为我们提供的另一个便利是能够从代数数据类型的字段中提取值，例如结构体或枚举作为新变量。这里，我们有一个代码片段来演示这一点：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we created an instance of `Order`, which is bound to `food_order`. Let''s
    assume we got `food_order` from some method call and we want to access the `count`
    and `item` values. We can extract the individual fields, `count` and `item`, directly
    using `let`. `count` and `item` become new variables that hold the corresponding
    field values from the `Order` instance. This is technically called the **destructuring
    syntax** of **`let`**. The way the variables get destructured depends on whether
    the value on the right is an immutable reference, mutable reference, or an owned
    value or by how we reference it on the left-hand side using the `ref` or `mut`
    patterns. In the previous code, it was captured by the value because `food_order`
    owns the `Order` instance and we matched the members on the left-hand side without
    any `ref` or `mut` keyword. If we want to destructure the members by immutable
    reference, we would put an `&` symbol before `food_order` or use `ref` or `mut`
    alternatively:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `Order` 的实例，它绑定到 `food_order`。假设我们通过某个方法调用得到了 `food_order`，并且我们想要访问
    `count` 和 `item` 的值。我们可以直接使用 `let` 提取单个字段，`count` 和 `item`，它们成为新的变量，持有 `Order`
    实例中相应的字段值。这从技术上讲称为 **`let` 的解构语法**。变量的解构方式取决于右侧的值是一个不可变引用、可变引用、所有者值，或者我们如何使用 `ref`
    或 `mut` 模式在左侧引用它。在前面的代码中，它被值捕获，因为 `food_order` 拥有 `Order` 实例，并且我们在左侧没有使用任何 `ref`
    或 `mut` 关键字匹配成员。如果我们想要通过不可变引用解构成员，我们可以在 `food_order` 前面放置一个 `&` 符号，或者使用 `ref`
    或 `mut` 代替：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first style is generally preferred as it''s concise. If we want to have
    a mutable reference, we have to place `&mut` after making `food_order` itself
    mutable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种风格通常更受欢迎，因为它更简洁。如果我们想要有一个可变引用，我们必须在将 `food_order` 本身设置为可变之后放置 `&mut`：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Fields that we don''t care about can be ignored by using the `..`, as shown
    in the code. Also, a slight restriction of `let` destructuring is that we are
    not free to choose the mutability of individual fields. All variables must have
    the the same mutability—either all are immutable or all are mutable. Note that
    `ref` isn''t generally used to declare variable bindings and is mostly used in
    match expressions in cases where we want to match against a value by reference
    because the `&` operator does not work within match arms, as demonstrated here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `..` 来忽略我们不关心的字段，如代码所示。此外，`let` 解构的一个轻微限制是我们不能自由选择单个字段的可变性。所有变量都必须具有相同的可变性——要么全部不可变，要么全部可变。请注意，`ref`
    通常不用于声明变量绑定，它主要在匹配表达式中使用，在这些表达式中我们想要通过引用匹配值，因为 `&` 操作符在匹配分支中不起作用，如这里所示：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we want to use the inner value from `Person` struct by an immutable reference,
    our intuition would say to use something like `Person(&name)` in the match arm
    to match by reference. But we get this error upon compilation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要通过不可变引用使用 `Person` 结构体的内部值，我们的直觉可能会说在匹配分支中使用类似 `Person(&name)` 的方式来通过引用进行匹配。但在编译时我们得到了这个错误：
- en: '![](img/671b0a41-8760-460e-bcd3-0a7d5f440343.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/671b0a41-8760-460e-bcd3-0a7d5f440343.png)'
- en: This gives us a misleading error because `&name` is creating a reference out
    of `name` (`&` is an operator) and the compiler thinks that we want to match against `Person(&String)`
    but the `a` value is actually `Person(String)`. So, in this case `ref` has to
    be used to destructure it as a reference. To make it compile, we change it accordingly
    to `Person(ref name)` on the left-hand side.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个误导性的错误，因为 `&name` 是从 `name` 中创建了一个引用（`&` 是一个操作符），编译器认为我们想要匹配 `Person(&String)`，但实际上
    `a` 的值是 `Person(String)`。因此，在这种情况下，必须使用 `ref` 来将其解构为引用。为了使其编译通过，我们相应地将左侧的代码更改为
    `Person(ref name)`。
- en: 'The destructuring syntax is also applicable to enum types as well:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解构语法也适用于枚举类型：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have `maybe_item` as a `Container` enum. Combining `if let` and pattern
    matching, we can conditionally assign the value to `has_item` variable using the
    `if let <destructure pattern> = expression {}` syntax.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有 `maybe_item` 作为 `Container` 枚举。通过结合 `if let` 和模式匹配，我们可以使用 `if let <解构模式>
    = 表达式 {}` 语法有条件地将值赋给 `has_item` 变量。
- en: 'The destructuring syntax can be used in function parameters as well. For example,
    in the case of custom types, such as a struct when used in a function as arguments:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 解构语法也可以用在函数参数中。例如，在自定义类型的情况下，如一个结构体在作为函数参数使用时：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `calculate_cost` function has a parameter that's destructured as a struct
    with fields bound to the `items_count` variable. If we want to destructure mutably,
    we add the `mut` keyword before the member field as is the case with the `increment_item`
    function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`calculate_cost`函数有一个参数，它被解构为一个结构体，字段绑定到`items_count`变量。如果我们想要可变地解构，我们可以在成员字段之前添加`mut`关键字，就像`increment_item`函数那样。
- en: '**Refutable patterns**: Refutable pattern are `let` patterns where the left-hand
    side and the right-hand side are not compatible for pattern matching and, in those
    cases one has to use the exhaustive match expression instead. Up until now, all
    forms of `let` patterns we''ve seen were irrefutable patterns. Irrefutable means
    that they''re able to properly match against the value on the right side of `''=''`
    as a valid pattern.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**可反驳模式**：可反驳模式是`let`模式，其中左右两侧在模式匹配中不兼容，在这些情况下，必须使用穷尽匹配表达式。到目前为止，我们看到的`let`模式的所有形式都是不可反驳模式。不可反驳意味着它们能够作为有效的模式正确匹配`''=''`右侧的值。'
- en: 'But sometimes, pattern matching with `let` may fail because of invalid patterns,
    for example, when matching an enum `Container` that has two variants:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，由于无效的模式，使用`let`进行模式匹配可能会失败，例如，当匹配具有两个变体（`Item(u64)`和`Empty`）的枚举`Container`时：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Ideally, we expect `it` to store `56` as the value, after being destructured
    from `item`. If we try compiling this, we get the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们期望`it`在从`item`解构后存储`56`作为值。如果我们尝试编译这个，我们会得到以下：
- en: '![](img/fc30cd83-74e1-4e93-9a81-e4a783a82cfe.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc30cd83-74e1-4e93-9a81-e4a783a82cfe.png)'
- en: The reason this match does not succeed is because `Container` has two variants,
    `Item(u64)` and `Empty`. Even though we know that `item` contains the `Item` variant,
    `let` patterns can't rely on this fact, because if `item` is mutable, some code
    can assign an `Empty` variant there later, which would render the destructure
    an undefined operation. We have to cover all possible cases. Destructuring directly
    against a single variant violates the semantics of exhaustive pattern matching
    and hence our match fails.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个匹配失败的原因是因为`Container`有两个变体，`Item(u64)`和`Empty`。即使我们知道`item`包含`Item`变体，`let`模式也不能依赖这个事实，因为如果`item`是可变的，一些代码可以在之后将其分配为`Empty`变体，这将使解构成为未定义的操作。我们必须涵盖所有可能的情况。直接针对单个变体的解构违反了穷尽模式匹配的语义，因此我们的匹配失败。
- en: Loop as an expression
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环作为表达式
- en: 'In Rust, a loop is also an expression that returns `()` by default when we
    `break` out of it. The implication of this is that `loop` can also be used to
    assign value to a variable with `break`. For example, it can be used in something
    like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，循环也是一个表达式，当我们从中跳出时默认返回`()`。这个含义是`loop`也可以用来通过`break`给变量赋值。例如，它可以用于类似以下的情况：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Following the `break` keyword, we include the value we want to return and this
    gets assigned to `counter` variable when the loop breaks (if at all). This is
    really handy in cases where you assign the value of any variable within the loop
    after breaking from the loop and need to use it afterward.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`break`关键字之后，我们包括我们想要返回的值，并且当循环结束时（如果有的话），这个值会被分配给`counter`变量。这在循环结束后在循环内部赋值任何变量的值并需要在之后使用它的情况下非常有用。
- en: Type clarity and sign distinction in numeric types
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字类型的类型清晰度和符号区分
- en: 'While mainstream languages differentiate between numeric primitives such as
    an integer, a double*,* and a byte*,* a lot of newer languages such as Golang
    have started adding distinction between signed and unsigned numeric types too.
    Rust follows in the same footsteps by distinguishing signed and unsigned numeric
    types, providing them as separate types altogether. From a type-checking perspective,
    this adds another layer of safety to our programs. This allows us to write code
    that exactly specifies its requirements. For example, consider a database connection
    pool struct:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然主流语言区分了诸如整数、双精度浮点数和字节等数值原语，但许多新的语言，如Golang，已经开始在有符号和无符号数值类型之间添加区分。Rust也遵循同样的步伐，通过区分有符号和无符号数值类型，将它们作为完全不同的类型提供。从类型检查的角度来看，这为我们程序增加了另一层安全性。这允许我们编写精确指定其要求的代码。例如，考虑一个数据库连接池结构体：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For languages that provide a common integer type that incorporates both signed
    and unsigned values, you would specify the type of `pool_count` as an integer,
    which can also store negative values. It does not make sense for `pool_count`
    to be negative. With Rust, we can specify this clearly in code by using an unsigned
    type instead, such as `u32` or `usize`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提供包含有符号和无符号值的通用整数类型的语言，你会指定 `pool_count` 的类型为整数，它也可以存储负值。`pool_count` 为负值没有意义。使用
    Rust，我们可以通过使用无符号类型（如 `u32` 或 `usize`）在代码中清楚地指定这一点。
- en: 'One more aspect to note about primitive types is that Rust does not perform
    automatic casts when mixing signed and unsigned types in arithmetic operations.
    You have to be explicit about this and cast the value manually. An example of
    an unintended auto cast in C/C++ would be the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于原始类型，还有一个需要注意的方面是，Rust 在算术操作中混合有符号和无符号类型时不会执行自动转换。你必须明确这一点并手动转换值。C/C++ 中一个未预期的自动转换的例子如下：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code prints `4294967295`. Here, the difference won't be `-1` on
    subtracting `foo` and `bar`; instead C++ does its own thing without the programmer's
    consent. `int` (signed integer) is auto cast to `uint` (unsigned integer) and
    wraps to a maximum value of `uint` being `4294967295`. This code continues to
    run without complaining about underflow here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码打印 `4294967295`。在这里，从 `foo` 和 `bar` 减去时，差异不会是 `-1`；相反，C++ 会自行其是，而不需要程序员的同意。`int`（有符号整数）自动转换为
    `uint`（无符号整数），并包装到 `uint` 的最大值 `4294967295`。这段代码在这里继续运行而不会抱怨下溢。
- en: 'Translating the same program in Rust, we get the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中翻译相同的程序，我们得到以下结果：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Following will be the output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '![](img/b15dd415-e0d3-4148-b663-134157d69bc1.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b15dd415-e0d3-4148-b663-134157d69bc1.png)'
- en: Rust won't compile this, showing an error message. You have to explicitly cast
    either of the values according to your intent. Also, if we perform overflow/underflow
    operations on two unsigned or signed types, Rust will `panic!()` and abort your
    program when you build and run in `debug` mode. When built in `release` mode,
    it does a wrapping arithmetic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不会编译这段代码，会显示错误信息。你必须根据你的意图显式地转换其中一个值。此外，如果我们对两个无符号或有符号类型执行溢出/下溢操作，Rust
    将在 `debug` 模式下 `panic!()` 并终止你的程序。在发布模式下构建时，它执行包装算术。
- en: By wrapping arithmetic, we mean that adding `1` to `255` (a `u8`) will result
    in `0`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包装算术，我们是指将 `1` 加到 `255`（一个 `u8`）将得到 `0`。
- en: Panicking in debug mode is the right thing to do here because if such arbitrary
    values are allowed to propagate to other parts of code, they can taint your business
    logic and introduce further hard-to-track bugs in the program. So, a fail-stop
    approach is better in these cases where the user accidentally performs an overflow/underflow
    operation and this gets caught in debug mode. When the programmer wants to allow
    wrapping semantics on arithmetic operations, then they may choose to ignore the
    panic and proceed to compile in release mode. That's another aspect of safety
    that the language provides you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试模式下引发恐慌是正确的行为，因为如果允许这样的任意值传播到代码的其他部分，它们可能会污染你的业务逻辑，并在程序中引入更难以追踪的bug。因此，在这些情况下，当用户意外执行溢出/下溢操作并且这在调试模式下被捕获时，使用失败停止的方法更好。当程序员想要在算术操作中允许包装语义时，他们可以选择忽略恐慌并继续在发布模式下编译。这是语言为你提供的安全性的另一个方面。
- en: Type inference
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'Type inference is useful in statically typed languages as it makes the code
    easier to write, maintain, and refactor. Rust''s type system can figure out types
    for fields, methods, local variables, and most generic type arguments when you
    don''t specify them. Under the hood, a component of the compiler called the type
    checker uses the *Hindley Milner* type inference algorithm to decide what the
    types of local variables should be. It is a set of rules about establishing types
    of expressions based on their usage. As such, it can infer types based on the
    environment and the way a type is used. One such example is the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断在静态类型语言中很有用，因为它使得代码更容易编写、维护和重构。Rust 的类型系统可以在你不指定它们的情况下确定字段、方法、局部变量和大多数泛型类型参数的类型。在底层，编译器的一个组件，即类型检查器，使用
    *Hindley Milner* 类型推断算法来决定局部变量的类型。它是一组基于表达式使用情况建立类型的规则。因此，它可以基于环境和类型的使用方式推断类型。以下是一个这样的例子：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With only the first line initializing the vector, Rust's type checker is unsure
    of what the type for `v` should be. It's only when it reaches the next line, `v.push(2)`,
    that it knows that `v` is of the type, `Vec<i32>`. Now the type of `v` is frozen
    to `Vec<i32>`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在初始化向量的第一行中，Rust的类型检查器不确定`v`的类型应该是什么。只有当它到达下一行，`v.push(2)`时，它才知道`v`的类型是`Vec<i32>`。现在`v`的类型被固定为`Vec<i32>`。
- en: 'If we added another line, `v.push(2.4f32);`, then the compiler will complain
    of type mismatch as it already had inferred it from the previous line to be of
    `Vec<i32>`. But sometimes, the type checker cannot figure out types of variables
    in complex situations. But with some help from the programmer, the type checker
    is able to infer types. For example, for the next snippet, we read a file `foo.txt`,
    containing some text and read it as bytes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加另一行，`v.push(2.4f32);`，那么编译器将因为类型不匹配而报错，因为它已经从上一行推断出它应该是`Vec<i32>`类型。但有时，类型检查器无法在复杂情况下推断出变量的类型。但是，通过程序员的帮助，类型检查器能够推断类型。例如，对于下一个片段，我们读取一个名为`foo.txt`的文件，其中包含一些文本，并以字节的形式读取它：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Compiling this gives us this error:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编译这个代码会给我们这个错误：
- en: '![](img/90d9cd48-e50f-439a-8a16-7073beff3614.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![错误图](img/90d9cd48-e50f-439a-8a16-7073beff3614.png)'
- en: 'The `collect` method on iterators is basically an `aggregator` method. We''ll
    look at iterators later in this chapter. The resulting type it collects into can
    be any collection type. It can either be `LinkedList`, `VecDeque`, or `Vec`. Rust
    does not know what the programmer intends and, due to such ambiguity, it needs
    our help here. We made the following change for the second line in `main`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器上的`collect`方法基本上是一个`aggregator`方法。我们将在本章后面讨论迭代器。它收集到的结果类型可以是任何集合类型。它可以是`LinkedList`、`VecDeque`或`Vec`。Rust不知道程序员意图是什么，由于这种歧义，它需要我们的帮助。我们在`main`的第二行做了以下更改：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Calling `bytes()` returns `Result<u8, std::io::Error>`. After adding some type
    hint as to what to collect into (here, `Vec`), the program compiles fine. Note
    the `_` on the `Result` error variant. It was enough for Rust to hint that we
    need a `Vec` of `Result` of `u8`. The rest, it is able to figure out—the error
    type in `Result` needs to be of `std::io::Error` type. It was able to figure that
    out because there is no such ambiguity here. It gets the information from the
    `bytes()` method signature. Quite smart!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`bytes()`返回`Result<u8, std::io::Error>`。在添加一些类型提示以说明要收集到什么（在这里，`Vec`）之后，程序可以正常编译。注意`Result`错误变体上的`_`。对于Rust来说，这足以提示我们需要一个`u8`的`Result`的`Vec`。其余的，它能够自己推断出来——`Result`中的错误类型需要是`std::io::Error`类型。它能够推断出来，因为没有这种歧义。它从`bytes()`方法签名中获取信息。非常聪明！
- en: Type aliases
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'Type aliases are a feature not unique to Rust. C has the `typedef` keyword,
    while Kotlin has `typealias` for the same. They are there to make your code more
    readable and remove the type signature cruft that often piles up in statically
    typed languages, for example, if you have an API from your crate where you return
    a `Result` type, wrapping a complex object as depicted below:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名不是Rust独有的特性。C语言有`typedef`关键字，而Kotlin有`typealias`关键字用于相同的目的。它们的存在是为了使你的代码更易于阅读，并移除在静态类型语言中经常积累的类型签名冗余，例如，如果你有一个来自你的crate的API，返回一个`Result`类型，包装一个复杂对象，如下所示：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, for some of the methods, such as `parse_payload`, the type signature
    gets too large to fit in a line. Also, having to type `Result<ParsedPayload<T>,
    ParseError<E>>` every time they are used becomes cumbersome. What if we could
    refer to this type by a simpler name? This is the exact use case type aliases
    serve. They enable us to give another (desirably simpler) name to types with a
    complex type signature.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对于某些方法，例如`parse_payload`，类型签名变得太大，无法在一行中显示。而且，每次使用时都必须输入`Result<ParsedPayload<T>,
    ParseError<E>>`，这变得很繁琐。如果我们能通过一个更简单的名字来引用这个类型会怎样？这正是类型别名的作用。它们使我们能够给具有复杂类型签名的类型赋予另一个（更简单）的名字。
- en: 'So, we can give an alias to the return type of `parse_payload` as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以给`parse_payload`的返回类型起一个别名，如下所示：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This makes it more manageable if we later want to change the actual inner types.
    We can type alias any simple types too:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以后想更改实际的内部类型，这将使代码更易于管理。我们也可以为任何简单类型创建类型别名：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, now we can use `MyString` anywhere we use `String.` But this doesn''t mean
    that `MyString` is of a different type. During compilation, this just gets substituted/expanded
    to the original type. When creating type aliases for generic types, the type alias
    also needs a generic type parameter (`T`). So aliasing `Vec<Result<Option<T>>>`
    becomes the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以在任何使用`String.`的地方使用`MyString`。但这并不意味着`MyString`是不同类型的。在编译期间，这只是一个替换/展开到原始类型的操作。当为泛型类型创建类型别名时，类型别名也需要一个泛型类型参数（`T`）。因此，将`Vec<Result<Option<T>>>`别名为以下内容：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s assume you have a lifetime in your type, as in `SuperComplexParser<''a>`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的类型中有一个生命周期，就像`SuperComplexParser<'a>`一样：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When creating type aliases for them, we need to specify the lifetime as well,
    as is the case with the `Parser` type alias.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在为它们创建类型别名时，我们还需要指定生命周期，就像`Parser`类型别名的情况一样。
- en: With those type system niceties out of the way, let's talk about strings again!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类型系统的小优点之外，让我们再次谈谈字符串！
- en: Strings
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: In [Chapter 1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml), *Getting Started
    with Rust*, we mentioned that strings are of two types. In this section, we'll
    give a clearer picture on strings, their peculiarities, and how they differ from
    strings in other languages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml)《Rust入门》中，我们提到字符串有两种类型。在本节中，我们将更清晰地介绍字符串、它们的特性以及它们与其他语言中字符串的区别。
- en: 'While other languages have a pretty straightforward story on string types,
    the `String` type in Rust is one of the tricky and uneasy types to handle. As
    we know, Rust places distinction on whether a value is allocated on the heap or
    on the stack. Due to that, there are two kinds of strings in Rust: owned strings
    (`String`) and borrowed strings (`&str`). Let''s explore both of them.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他语言在字符串类型上有相当直接的故事，但Rust中的`String`类型是处理起来既复杂又困难的一种类型。正如我们所知，Rust区分值是在堆上还是在栈上分配的。因此，Rust中有两种字符串：拥有字符串（`String`）和借用字符串（`&str`）。让我们来探讨这两种。
- en: Owned strings – String
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有字符串 – String
- en: 'The `String` type comes from the standard library and is a heap-allocated UTF-8
    encoded sequence of bytes. They are simply `Vec<u8>` under the hood but have extra
    methods that are applicable to only strings. They are owned types, which means
    that a variable that holds a `String` value is its owner. You will usually find
    that `String` types can be created in multiple ways, as shown in the following
    code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类型来自标准库，是一个堆分配的UTF-8编码的字节序列。在底层，它们只是`Vec<u8>`，但具有仅适用于字符串的额外方法。它们是拥有类型，这意味着持有`String`值的变量是其所有者。你通常会发现在多种方式下可以创建`String`类型，如下面的代码所示：'
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we created four strings in four different ways. All of
    them create the same string type and have the same performance characteristics.
    The first variable, `a`, creates the string by calling the `to_string` method,
    which comes from the `ToString` trait with the string literal, `"Hello"`. A string
    literal such as `"Hello"` by itself also has a type of `&str`. We'll explain them
    when we get to borrowed versions of strings. We then create another string, `b`,
    by calling the `from` method, which is an associated method on `String`. The third
    string `c`, is created by calling a trait method, `to_owned`, from the `ToOwned`
    trait, which is implemented for `&str` types—literal strings. The fourth string,
    `d`, is created by cloning an existing string, `c`. The fourth way of creating
    strings is an expensive operation , which we should avoid as it involves copying
    the underlying bytes by iterating over them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们以四种不同的方式创建了四个字符串。它们都创建了相同的字符串类型，并且具有相同的性能特征。第一个变量`a`通过调用`to_string`方法创建字符串，该方法来自`ToString`特质，并带有字符串字面量`"Hello"`。像`"Hello"`这样的字符串字面量本身也有`&str`类型。我们将在介绍字符串的借用版本时解释它们。然后，我们通过调用`String`上的关联方法`from`创建了另一个字符串`b`。第三个字符串`c`是通过调用`ToOwned`特质中的特质方法`to_owned`创建的，该特质为`&str`类型（字面字符串）实现。第四个字符串`d`是通过克隆现有的字符串`c`创建的。创建字符串的第四种方式是一个昂贵的操作，我们应该避免它，因为它涉及到通过迭代底层的字节进行复制。
- en: As `String` is allocated on heap, it can be mutated and can grow at runtime.
    This means that strings have an associated overhead when manipulating them because
    they might possibly get reallocated as you keep adding bytes to them. Heap allocation
    is a relatively expensive operation but, fortunately, the way allocation happens
    for `Vec` (doubled every capacity limit), means this cost is amortized over usage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `String` 是在堆上分配的，它可以被修改并在运行时增长。这意味着在操作字符串时，它们有一个相关的开销，因为它们可能会在添加字节时被重新分配。堆分配是一个相对昂贵的操作，但幸运的是，`Vec`
    的分配方式（容量加倍）意味着这种成本被分摊到使用中。
- en: 'Strings also have a lot of convenient methods in the standard library. Following
    are the important ones:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串在标准库中也有许多方便的方法。以下是一些重要的方法：
- en: '`String::new()` allocates an empty `String` type.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String::new()` 分配一个空的 `String` 类型。'
- en: '`String::from(s: &str)` allocates a new `String` type and populates it from
    a string slice.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String::from(s: &str)` 分配一个新的 `String` 类型，并从字符串切片中填充它。'
- en: '`String::with_capacity(capacity: usize)` allocates an empty `String` type with
    a preallocated size. This is performant when you know the size of your string
    beforehand.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String::with_capacity(capacity: usize)` 分配一个具有预分配大小的空 `String` 类型。当你事先知道字符串的大小的时候，这是高效的。'
- en: '`String::from_utf8(vec: Vec<u8>)` tries to allocate a new `String` type from
    `bytestring`. The contents of the parameter must be UTF-8 or this will fail. It
    returns the `Result` wrapper type.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String::from_utf8(vec: Vec<u8>)` 尝试从 `bytestring` 分配一个新的 `String` 类型。参数的内容必须是
    UTF-8，否则将失败。它返回 `Result` 包装类型。'
- en: The `len()` method on string instances gives you the length of the `String` type, taking
    Unicode into account. As an example, a `String` type containing the word `yö`
    has a length of two, even though it takes three bytes in memory.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串实例上的 `len()` 方法会给你 `String` 类型的长度，考虑到 Unicode。例如，包含单词 `yö` 的 `String` 类型长度为两个，尽管它在内存中占用三个字节。
- en: 'The `push(ch: char)` and `push_str(string: &str)` methods add a character or
    a string slice to the string.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push(ch: char)` 和 `push_str(string: &str)` 方法向字符串中添加一个字符或一个字符串切片。'
- en: This is, of course, a non-exhaustive list. A complete list of all the operations
    can be found at [https://doc.rust-lang.org/std/string/struct.String.html](https://doc.rust-lang.org/std/string/struct.String.html).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然不是一个详尽的列表。所有操作的完整列表可以在 [https://doc.rust-lang.org/std/string/struct.String.html](https://doc.rust-lang.org/std/string/struct.String.html)
    找到。
- en: 'Here''s an example that uses all of the aforementioned methods:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用所有上述方法的示例：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With `String` explored, let's look at the borrowed version of strings known
    as string slices or the `&str` type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了 `String` 之后，让我们看看字符串的借用版本，即字符串切片或 `&str` 类型。
- en: Borrowed strings – &str
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用的字符串 – &str
- en: We can also have strings as references called string slices. These are denoted
    by `&str` (pronounced as *stir*), which is a reference to a `str` type. In constrast
    to the `String` type, `str` is a built-in type known to the compiler and is not
    something from the standard library. String slices are created as `&str` by default—a
    pointer to a UTF-8 encoded byte sequence. We cannot create and use values of the
    bare `str` type, as it represents a contiguous sequence of UTF-8 encoded bytes
    with a finite but unknown size. They are technically called unsized types. We'll
    explain unsized types later in this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以有字符串作为引用，称为字符串切片。这些用 `&str` 表示（发音为 *stir*），它是 `str` 类型的引用。与 `String` 类型相比，`str`
    是编译器已知的一个内置类型，不是标准库中的东西。字符串切片默认创建为 `&str`——指向一个 UTF-8 编码的字节序列的指针。我们不能创建和使用裸 `str`
    类型的值，因为它代表一个连续的 UTF-8 编码字节的序列，大小有限但未知。它们在技术上被称为无尺寸类型。我们将在本章后面解释无尺寸类型。
- en: '`str` can only be created as a reference type. Let''s assume we try to create
    a `str` type forcibly by providing the type signature on the left:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 只能作为引用类型创建。假设我们尝试通过提供左侧的类型签名强制创建一个 `str` 类型：'
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ll be presented with a confusing error:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会遇到一个令人困惑的错误：
- en: '![](img/d9213101-fb42-45e3-bab3-5146b26c780e.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9213101-fb42-45e3-bab3-5146b26c780e.png)'
- en: 'It says: all local variables must have a statically known size. This basically
    means that every local variable we define using a `let` statement needs to have
    a size as they are allocated on the stack and the stack has a fixed size. As we
    know, all variable declarations go on the stack either as values themselves or
    as pointers to heap allocated types. All stack-allocated values need to have a
    proper size known and, due to this, `str` cannot be initialized.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它说：所有局部变量都必须有一个静态已知的大小。这基本上意味着我们使用`let`语句定义的每个局部变量都需要有一个大小，因为它们是在栈上分配的，而栈的大小是固定的。正如我们所知，所有变量声明要么作为值本身，要么作为指向堆分配类型的指针放在栈上。所有栈分配的值都需要有一个适当的大小已知，因此`str`无法初始化。
- en: '`str` basically means a fixed-sized sequence of strings that''s agnostic to
    the location where it resides. It could either be a reference to a heap-allocated
    string, or it could be a `&''static str` string residing on the data segment of
    the process that lives for the entire duration of the program, which is what the
    `''static` lifetime denotes.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`基本上意味着一个固定大小的字符串序列，它与它所在的位置无关。它可以是堆分配字符串的引用，或者它可以是位于进程数据段上的`&''static
    str`字符串，它在整个程序运行期间都存在，这就是`''static`生命周期所表示的。'
- en: We can, however, create a borrowed version of `str`, as in `&str`, which is
    what gets created by default when we write a string literal. So string slices
    are only created and used behind a pointer—`&str`. Being a reference, they also
    have different lifetimes associated with them based on the scope of their owned
    variable. One of them is of `'static` lifetime, which is the lifetime of string
    literals.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以创建一个`str`的借用版本，例如`&str`，这是我们在编写字符串字面量时默认创建的。因此，字符串切片仅在指针——`&str`——的背后被创建和使用。作为一个引用，它们也根据它们所拥有的变量的作用域有不同的生命周期。其中之一是`'static`生命周期，这是字符串字面量的生命周期。
- en: 'String literals are any sequence of characters you declare within double quotes.
    For example, we create them like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量是你在双引号内声明的任何字符序列。例如，我们这样创建它们：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we have a `get_str_literal` function that returns a string
    literal. We also create a string literal `my_str` in `main`. `my_str` and the
    string returned by `get_str_literal` has the type, `&'static str`. The `'static`
    lifetime annotation denotes that the string stays for the entire duration of the
    program. The `&` prefix says that it's a pointer to the string literal, while
    `str` is the unsized type. Any other `&str` type you encounter are **borrowed
    string slices** of any owned `String` type on the heap. The `&str` types, once
    created, can't be modified as they are created immutable by default.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个`get_str_literal`函数，它返回一个字符串字面量。我们还在`main`函数中创建了一个字符串字面量`my_str`。`my_str`和`get_str_literal`返回的字符串具有类型`&'static
    str`。`'static`生命周期注解表示字符串在整个程序运行期间都存在。`&`前缀表示它是指向字符串字面量的指针，而`str`是无大小类型。你遇到的任何其他`&str`类型都是堆上任何拥有`String`类型的**借用字符串切片**。一旦创建，`&str`类型就不能被修改，因为它们默认是不可变的。
- en: We can also take a mutable slice to the string, and the type changes to `&mut
    str`, though it's uncommon to use them in this form except with a few methods
    in the standard library. The `&str` type is the recommended type to be used when
    passing strings around, either to functions or to other variables.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以获取字符串的可变切片，类型变为`&mut str`，尽管除了标准库中的几个方法之外，很少以这种形式使用它们。`&str`类型是在传递字符串时推荐的类型，无论是传递给函数还是传递给其他变量。
- en: Slicing and dicing strings
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串的切片和切块
- en: 'All strings in Rust are guaranteed to be UTF-8 by default, and indexing on
    string types in Rust does not work as you would use them in other languages. Let''s
    try accessing the individual characters of our string:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的所有字符串默认都保证是UTF-8，并且Rust中字符串类型的索引方式与其他语言中的使用方式不同。让我们尝试访问字符串的各个字符：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'On compiling this, we get the following error:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译这个程序时，我们得到以下错误：
- en: '![](img/12722a16-aaec-4fa4-8a72-9356a58b75cd.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12722a16-aaec-4fa4-8a72-9356a58b75cd.png)'
- en: That's not a very helpful message. But it refers to something called the `Index`
    trait. The `Index` trait is implemented on collection types whose elements can
    be accessed by the indexing operator `[]` using index type as a `usize` value.
    Strings are valid UTF-8-encoded byte sequences and a single byte does not equate
    to a single character. In UTF-8, a single character may also be represented by
    multiple bytes. So, indexing does not work on strings.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一条很有帮助的信息。但它指的是一个名为`Index`的特质。`Index`特质是在可以通过索引操作符`[]`使用`usize`类型作为索引值的集合类型上实现的。字符串是有效的UTF-8编码的字节序列，一个字节并不等同于一个字符。在UTF-8中，一个字符也可能由多个字节表示。因此，索引在字符串上不适用。
- en: 'Instead, we can have slices of strings. This can either be done as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以有字符串切片。这可以按照以下方式完成：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: But, as is the case with all indexing operation, this panics if the start or
    the end index is not on a valid `char` boundary.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，就像所有索引操作一样，如果起始索引或结束索引不在有效的`char`边界上，这会导致程序崩溃。
- en: 'Another way to iterator over all characters of a string is to use the `chars()`
    method, which turns the string into an iterator over its characters. Let''s change
    our code to use `chars` instead:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种迭代字符串中所有字符的方法是使用`chars()`方法，它将字符串转换为一个字符迭代器。让我们将我们的代码更改为使用`chars`：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `chars` method returns characters of the string at proper Unicode boundaries.
    We can also call other iterator methods on this to either skip or get a range
    of characters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`chars`方法返回字符串在适当的Unicode边界处的字符。我们也可以调用其他迭代器方法来跳过或获取字符的范围。'
- en: Using strings in functions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数中使用字符串
- en: 'It''s idiomatic and performant to pass string slices to functions. Here''s
    an example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串切片传递给函数是一种既自然又高效的编程方式。以下是一个例子：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To the astute observer, the `say_hello` method also worked with a `&String`
    type. Internally, `&String` automatically coerces to `&str`, due to the type coercion
    trait `Deref` implemented for `&String` to `&str`. This is because `String` implements
    `Deref` for the `str` type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于敏锐的观察者来说，`say_hello`方法也可以与`&String`类型一起工作。内部，`&String`会自动转换为`&str`，这是由于为`&String`到`&str`实现的类型转换特质`Deref`。这是因为`String`为`str`类型实现了`Deref`。
- en: 'Here, you can see why I stressed the point earlier. A string slice is an acceptable
    input parameter not only for actual string slice references but also for `String`
    references! So, once more: if you need to pass a string to your function, use
    the string slice, `&str`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到为什么我之前强调了这一点。字符串切片不仅可以作为实际字符串切片引用的输入参数，也可以作为`String`引用的输入参数！所以，再次强调：如果你需要将字符串传递给你的函数，请使用字符串切片，`&str`。
- en: Joining strings
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'Another source of confusion when dealing with strings in Rust is when concatenating
    two strings. In other languages, you have a very intuitive syntax for joining
    two strings. You just do `"Foo" + "Bar"` and you get a `"FooBar"`. Not quite the
    case with Rust:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Rust中的字符串时，另一个容易混淆的地方是连接两个字符串。在其他语言中，连接两个字符串有非常直观的语法。你只需这样做`"Foo" + "Bar"`，你就能得到`"FooBar"`。但在Rust中并非如此：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we compile this, we get the following error:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译这段代码，我们会得到以下错误：
- en: '![](img/bb3f608a-3b51-44ff-adf0-11ad37c59fa4.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb3f608a-3b51-44ff-adf0-11ad37c59fa4.png)'
- en: 'The error message is really helpful here. The concatenation operation is a
    two step process. First, you need to allocate a string and then iterate over both
    of them to copy their bytes to this newly allocated string. As such, there''s
    an implicit heap allocation involved, hidden behind the `+` operator. Rust discourages
    implicit heap allocation. Instead, the compiler suggests that we can concatenate
    two string literals by explicitly making the first one an owned string. So our
    code changes, like so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的错误信息非常有帮助。连接操作是一个两步的过程。首先，你需要分配一个字符串，然后遍历这两个字符串，将它们的字节复制到新分配的字符串中。因此，这里涉及到了隐式的堆分配，隐藏在`+`操作符后面。Rust不鼓励隐式的堆分配。相反，编译器建议我们可以通过显式地将第一个字符串变为拥有字符串来连接两个字符串字面量。因此，我们的代码会像这样改变：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So we made `foo` a `String` type by calling the `to_string()` method. With that
    change, our code compiles.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过调用`to_string()`方法将`foo`的类型定义为`String`。这次更改后，我们的代码可以编译。
- en: The main difference between both `String` and `&str` is that `&str` is natively
    recognized by the compiler, while `String` is a custom type from the standard
    library. You could implement your own similar `String` abstraction on top of `Vec<u8>`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`和`&str`之间的主要区别在于`&str`被编译器原生识别，而`String`是标准库中的一个自定义类型。你可以在`Vec<u8>`之上实现自己的类似`String`的抽象。'
- en: When to use &str versus String ?
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当使用`&str`与`String`时应该注意什么？
- en: 'To a programmer coming to Rust, often the confusion is around which one to
    use. Well, the best practice is to use APIs that take a `&str` type when possible,
    as when the string is already allocated somewhere, you can save copying and allocation
    costs just by referencing that string. Passing `&str` around your program is nearly
    free: it incurs nearly no allocation costs and no copying of memory.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始接触Rust的程序员来说，常常会困惑于该使用哪一个。好吧，最好的做法是在可能的情况下使用接受`&str`类型的API，因为当字符串已经分配在某处时，你只需通过引用该字符串就可以节省复制和分配的成本。在程序中传递`&str`几乎是不需要成本的：它几乎不产生分配成本，也不进行内存复制。
- en: Global values
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局值
- en: 'Apart from variable and type declarations, Rust also allows us to define global
    values that can be accessed from anywhere in the program. They follow the naming
    convention of every letter being uppercase. These are of two kinds: constants
    and statics. There are also constant functions, which can be called to initialize
    these global values. Let''s explore constants first.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了变量和类型声明之外，Rust还允许我们定义可以在程序中的任何地方访问的全局值。它们的命名约定是每个字母都大写。这些分为两种：常量和静态值。还有常量函数，可以用来初始化这些全局值。让我们首先来探讨常量。
- en: Constants
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: 'The first form of global values are constants. Here''s how we can define one:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 全局值的第一种形式是常量。下面是如何定义一个常量的示例：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We use the `const` keyword to create constants. As constants aren't declared
    with the `let` keyword, specifying types is a must when creating them. Now, we
    can use `HEADER` where we would use the byte literal, `Obj\`.  `b""` is a convenient
    syntax to create a sequence of bytes of the `&'static [u8; n]` type, as in a `'static`
    reference to a fixed-sized array of bytes. Constants represent concrete values
    and don't have any memory location associated with them. They are inlined wherever
    they are used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`const`关键字来创建常量。由于常量不是使用`let`关键字声明的，因此在创建它们时指定类型是必须的。现在，我们可以在原本使用字节字面量`Obj\`的地方使用`HEADER`。`b""`是一种方便的语法，用于创建`&'static
    [u8; n]`类型的字节序列，就像对固定大小字节数组的`'static`引用。常量代表具体的值，并且与它们没有关联的内存位置。它们在使用的任何地方都会内联。
- en: Statics
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态值
- en: 'Statics are proper global values, as in they have a fixed memory location and
    exist as a single instance in the whole program. These can also be made mutable.
    However, as global variables are a breeding ground for the nastiest bugs out there,
    there are some safety mechanisms in place. Both reading and writing to statics
    has to be done inside an `unsafe {}` block. Here''s how we crate and use statics:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 静态值是真正的全局值，因为它们有一个固定的内存位置，并且在整个程序中作为一个单独的实例存在。这些也可以被设置为可变的。然而，由于全局变量是那里最糟糕的bug的滋生地，所以有一些安全机制。对静态值的读取和写入都必须在`unsafe
    {}`块内进行。下面是如何创建和使用静态值的示例：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the code, we've declared two statics `BAZ` and `FOO`. We use the `static`
    keyword to create them along with specifying the type explicitly. If we want them
    to be mutable, we add the `mut` keyword after `static`. Statics aren't inlined
    like constants. When we read or write the static values, we need to use an `unsafe`
    block. Statics are generally combined with synchronization primitives for any
    kind of thread-safe use. They are also used to implement global locks and when
    integrating with C libraries.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们已经声明了两个静态值`BAZ`和`FOO`。我们使用`static`关键字来创建它们，并明确指定类型。如果我们想使它们可变，我们在`static`之后添加`mut`关键字。静态值不像常量那样内联。当我们读取或写入静态值时，我们需要使用`unsafe`块。静态值通常与同步原语结合使用，以实现任何类型的线程安全。它们也用于实现全局锁以及与C库集成。
- en: Generally, if you don't need to rely on singleton property of statics and its
    predefined memory location and just want a concrete value, you should prefer using
    `consts`. They allow the compiler to make better optimizations and are more straightforward
    to use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你不需要依赖于静态值的单例属性和预定义的内存位置，只是想要一个具体的值，你应该优先使用`consts`。它们允许编译器进行更好的优化，并且使用起来更直接。
- en: Compile time functions – const fn
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时函数 – const fn
- en: 'We can also define constant functions that evaluate their argument during compile
    time. This means that a `const` value declaration can have a value that''s from
    an invocation of a `const` function. `const` functions are pure functions and
    must be reproducible. This means that they cannot take mutable arguments to any
    type. They also cannot include operations that are dynamic such as a heap allocation.
    They can be called in non-const places where they act just like normal functions.
    But when they are called in const contexts, they are evaluated at compile time.
    Here''s how we define a const function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义在编译时评估其参数的常量函数。这意味着`const`值声明可以有一个来自`const`函数调用的值。`const`函数是纯函数，必须是可再现的。这意味着它们不能接受任何类型的可变参数。它们也不能包含动态操作，如堆分配。它们可以在非`const`位置调用，在那里它们的行为就像普通函数一样。但是，当它们在`const`上下文中调用时，它们将在编译时进行评估。以下是如何定义`const`函数的示例：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the code, we defined a `const` function, `salt`, that takes a `u32` value
    as parameter and does a `xor` operation with the hex value, `0xDEADBEEF`. Const
    functions are quite useful for operations that can be performed at compile time.
    For instance, let''s say you are writing a binary file parser and you need to
    read the first four bytes of the file as an initialization and validation step
    for the parser. The following code demonstrates how we can do this entirely at
    runtime:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们定义了一个`const`函数，名为`salt`，它接受一个`u32`值作为参数，并与十六进制值`0xDEADBEEF`进行`xor`操作。`const`函数对于可以在编译时执行的操作非常有用。例如，假设你正在编写一个二进制文件解析器，并且需要读取文件的前四个字节作为解析器的初始化和验证步骤。以下代码演示了如何在运行时完成这一操作：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the code, the `read_header` function receives a file as a bytes array using
    the `include_bytes!` macro, which also reads the file at compile time. We then
    pull `4` bytes out of it and return it as a four-element tuple. Without the `const`
    function, all this would be done at runtime.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，`read_header`函数使用`include_bytes!`宏接收一个文件作为字节数组，该宏也会在编译时读取文件。然后我们从其中提取`4`个字节，并返回一个包含四个元素的元组。如果没有`const`函数，所有这些操作都会在运行时完成。
- en: Dynamic statics using the lazy_static! macro
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`lazy_static!`宏的动态静态值
- en: 'As we have seen, global values can only be declared for types that are non-dynamic
    in their initialization and have a known size on the stack at compile time. For
    example, you can''t create a `HashMap` as a static value because it requires a
    heap allocation. Fortunately, we can have `HashMap` and other dynamic collection
    types such as `Vec` as global statics too, using a third-party crate called `lazy_static`.
    This crate exposes the `lazy_static!` macro, which can be used to initialize any
    dynamic type that''s accessible globally from anywhere in the program. Here''s
    a snippet of how to initialize a Vec that can be mutated from multiple threads:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，全局值只能声明为在初始化时非动态且在编译时在栈上有已知大小的类型。例如，你不能将`HashMap`作为静态值创建，因为它需要堆分配。幸运的是，我们可以使用名为`lazy_static`的第三方crate将`HashMap`和其他动态集合类型（如`Vec`）作为全局静态值。这个crate公开了`lazy_static!`宏，它可以用来初始化任何可以从程序中的任何地方全局访问的动态类型。以下是如何初始化一个可以从多个线程中修改的`Vec`的示例：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Items declared within the `lazy_static!` macro are required to implement the
    Sync trait. This means if we want a mutable static, we have to use a multithreaded
    type such as `Mutex` or `RwLock` instead of  `RefCell`. We'll explain these types
    when we get to [Chapter 8](8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml), *Concurrency*.
    We'll be using this macro frequently in future chapters. Head over to the crate
    repository to learn more about using `lazy_static`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lazy_static!`宏内部声明的项需要实现`Sync`特质。这意味着如果我们想要一个可变的静态变量，我们必须使用`Mutex`或`RwLock`等多线程类型，而不是`RefCell`。我们将在[第8章](8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml)中解释这些类型，*并发*。我们将在未来的章节中频繁使用这个宏。前往crate仓库了解如何使用`lazy_static`的更多信息。
- en: Iterators
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'We glimpsed iterators in [Chapter 1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml),
    *Getting Started with Rust*. To recap, an iterator is any ordinary type that can
    walk over elements of a collection type in one of three ways: via `self`, `&self`,
    or  `&mut self`. They are not a new concept and mainstream language such as C++
    and Python have them already though that in Rust, they can appear surprising at
    first due to their form as an associated type trait. Iterators are used quite
    frequently in idiomatic Rust code when dealing with collection types.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第一章](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml)“Rust入门”中简要介绍了迭代器。回顾一下，迭代器是任何可以以三种方式遍历集合类型元素的普通类型：通过`self`、`&self`或`&mut
    self`。虽然它们不是一个新概念，主流语言如C++和Python已经有了它们，但在Rust中，由于它们以关联类型特质的形态出现，可能会让人一开始感到惊讶。迭代器在处理集合类型时在惯用的Rust代码中非常频繁地被使用。
- en: 'To understand how they work, let''s look at the definition of the `Iterator`
    trait from the `std::iter` module:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它们是如何工作的，让我们看看`std::iter`模块中`Iterator`特质的定义：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Iterator` trait is an associated type trait which mandates the two items,
    to be defined for any implementing type. First is the associated type, `Item`,
    which specifies what item the iterator yields. Second is the `next` method, which
    is called every time we need to read a value from the type being iterated over.
    There are also other methods that we''ve omitted here, as they have default implementations.
    To make a type iterable, we only need to specify the `Item` type and implement
    the `next` method and all other methods with default implementations become available
    for the type. In this way, iterators are a really powerful abstraction. You can
    see the full set of default methods at: [https://doc.rust-lang.org/std/iter/trait.Iterator.html](https://doc.rust-lang.org/std/iter/trait.Iterator.html).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`特质是一个关联类型特质，它强制为任何实现类型定义两个项目。第一个是关联类型`Item`，它指定了迭代器产生的项。第二个是`next`方法，每次我们需要从正在迭代的类型中读取值时都会调用它。还有一些其他的方法我们没有在这里列出，因为它们有默认实现。要使类型可迭代，我们只需要指定`Item`类型并实现`next`方法，所有其他具有默认实现的方法都将对类型可用。以这种方式，迭代器是一个非常强大的抽象。您可以在[https://doc.rust-lang.org/std/iter/trait.Iterator.html](https://doc.rust-lang.org/std/iter/trait.Iterator.html)看到完整的默认方法集。'
- en: The `Iterator` trait has a sibling trait called `IntoIterator`, which is implemented
    by types that want to convert in to an iterator. It provides the `into_iter` method
    that takes the implementing type via `self` and consumes the elements of the type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`特质有一个兄弟特质叫做`IntoIterator`，它由想要转换为迭代器的类型实现。它提供了一个`into_iter`方法，该方法通过`self`接收实现类型，并消耗该类型的元素。'
- en: 'Let''s implement the `Iterator` trait for a custom type. Identify what you
    want to iterate over in your data type if it''s not a collection. Then, create
    a wrapper struct holding any state of the iterator. Often, we'' will find iterators
    being implemented for some wrapper type that references the collection type''s
    element either by ownership or by an immutable or mutable reference. The methods
    to convert a type in to an iterator are also named conventionally:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为自定义类型实现`Iterator`特质。如果您的数据类型不是集合，请确定您想要遍历的数据类型中的内容。然后，创建一个包装结构体来持有迭代器的任何状态。通常，我们会发现迭代器是为某些包装类型实现的，这些包装类型通过所有者或不可变或可变引用引用集合类型的元素。将类型转换为迭代器的这些方法也遵循了惯例的命名：
- en: '`iter()` takes elements by reference.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iter()`通过引用获取元素。'
- en: '`iter_mut()` takes mutable reference to elements.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iter_mut()`获取元素的可变引用。'
- en: '`into_iter()` takes ownership of the values and consumes the actual type once
    iterated completely. The original collection can no longer be accessed.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`into_iter()`获取值的所有权，并在迭代完成后消耗实际类型。原始集合将无法访问。'
- en: 'The type that implements the `Iterator` trait can be used in a `for` loop and
    under the hood, the next method of the item gets called. Consider the for loop
    as shown in the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '实现`Iterator`特质的类型可以用在`for`循环中，并且底层，项目的`next`方法会被调用。考虑以下所示的`for`循环： '
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding code would get de-sugared as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将被简化如下：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It' will repeatedly call `a.next()` until it matches a `Some(i)` variant. When
    it matches  `None`, the iteration stops.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它将反复调用`a.next()`直到匹配一个`Some(i)`变体。当它匹配`None`时，迭代停止。
- en: Implementing a custom iterator
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义迭代器
- en: 'To understand iterators more thoroughly, we''ll implement an iterator that
    generates prime numbers up to a certain limit that''s customizable by the user.
    First, let''s clarify the API expectations that we''ll need from our iterator:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地理解迭代器，我们将实现一个生成质数的迭代器，这些质数有一个用户可定制的上限。首先，让我们明确我们需要从我们的迭代器中获得的 API 期望：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So, we have a type called `Primes` that we can instantiate with the `new` method,
    providing the upper bound on the number of primes to generate. We can call `iter()`
    on this instance to convert it in to an iterator type, which can then be used
    in a `for` loop. With that said, let''s add the `new` and `iter` methods on it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个名为 `Primes` 的类型，我们可以使用 `new` 方法实例化它，提供要生成的质数的上限。我们可以在这个实例上调用 `iter()`
    来将其转换为迭代器类型，然后可以在 `for` 循环中使用它。有了这些，让我们添加 `new` 和 `iter` 方法：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `iter` method takes the `Primes` type via `&self` and returns a `PrimesIter`
    type containing two fields: `index`, which stores the `index` in the vector, and
    a `computed` field that stores the pre-computed primes in a vector. The `compute_primes`
    method is defined as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter` 方法通过 `&self` 接收 `Primes` 类型并返回一个包含两个字段的 `PrimesIter` 类型：`index` 字段存储向量中的
    `index`，以及一个 `computed` 字段，用于存储预先计算好的质数向量。`compute_primes` 方法定义如下：'
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This function implements the sieve of the eratosthenes algorithm for efficiently
    generating prime numbers up to a given limit. Next, there''s the definition of
    the `PrimesIter` struct along with its `Iterator` implementation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数实现了埃拉托斯特尼筛法算法，用于高效地生成给定限制内的质数。接下来是 `PrimesIter` 结构体的定义及其 `Iterator` 实现的定义：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `next` method, we loop and get the next prime number if the value at
    `self.index` is `true` in the `self.computed` `Vec`. If we went past the elements
    in our `computed` Vec, then we return `None` to signify that we are done. Here''s
    the complete code with the main function that generates `100` prime numbers:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `next` 方法中，我们循环并获取 `self.index` 在 `self.computed` `Vec` 中的值如果是 `true`，则下一个质数。如果我们超过了
    `computed` Vec 中的元素，则返回 `None` 以表示我们已经完成。以下是包含生成 `100` 个质数的主函数的完整代码：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We get the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下输出：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Great! Apart from `Vec`, there are a lot of types that implement the `Iterator`
    trait in the standard library, such as `HashMap`, `BTreeMap`, and `VecDeque`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！除了 `Vec` 之外，标准库中还有许多实现了 `Iterator` 特质的类型，例如 `HashMap`、`BTreeMap` 和 `VecDeque`。
- en: Advanced types
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级类型
- en: In this section, we'll look at some of the advanced types in Rust. Let's first
    start with unsized types.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 Rust 中的一些高级类型。让我们首先从无大小类型开始。
- en: Unsized types
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无大小类型
- en: 'Unsized types are categories of types that are first encountered if one tries
    to create a variable of the type, `str`. We know that we can create and use string
    references only behind references such as `&str`. Let''s see what error message
    we get if we try to create a `str` type:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 无大小类型是在尝试创建 `str` 类型的变量时首次遇到的类型类别。我们知道我们只能在 `&str` 等引用的后面创建和使用字符串引用。让我们看看如果我们尝试创建
    `str` 类型会得到什么错误信息：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We get the following error upon compilation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时我们遇到了以下错误：
- en: '![](img/4c64fca4-6cf4-41ab-a462-c38cd22f9e2d.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c64fca4-6cf4-41ab-a462-c38cd22f9e2d.png)'
- en: 'By default, Rust creates a reference type of `str` as `''static str`. The error
    message mentions that all local variables—values that live on the stack—must have
    a statically known size at compile time. This is because the stack memory is finite
    and we cannot have infinite- or dynamic-sized types. Similarly, there are other
    instances of types that are unsized:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Rust 创建了一个静态引用类型的 `str`，即 `'static str`。错误信息提到，所有局部变量——在栈上生存的值——必须在编译时具有静态已知的大小。这是因为栈内存是有限的，我们不能有无限或动态大小的类型。同样，还有其他无大小类型的实例：
- en: '`[T]`: This is a slice of type, `T`. They can only be used as `&[T]` or `&mut
    [T]`.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[T]`：这是一个类型 `T` 的切片。它们只能用作 `&[T]` 或 `&mut [T]`。'
- en: '`dyn Trait`: This is a trait object. They can only be used as a `&dyn Trait`
    or `&mut dyn Trait` type.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dyn Trait`：这是一个特质对象。它们只能用作 `&dyn Trait` 或 `&mut dyn Trait` 类型。'
- en: Any struct that has an unsized type as its last field is also considered an
    unsized type as well.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何以无大小类型作为其最后一个字段的 `struct` 也被视为无大小类型。
- en: There's `str`, which we already explored. `str` internally is just a `[u8]`
    but with the added guarantee that the bytes are valid UTF-8.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有 `str`，我们已经探讨了。`str` 内部只是一个 `[u8]`，但增加了字节是有效的 UTF-8 的保证。
- en: Function types
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'Functions in Rust also have a concrete type and they differ in terms of their
    argument types and also in their `arity`, as in how many arguments they take,
    as in the example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的函数也有一个具体的类型，它们在参数类型和`arity`（即它们接受的参数数量）方面有所不同，例如以下示例：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Functions in Rust are first class citizens. This means they can be stored in
    variables or passed to other functions or returned from functions. The preceding
    code declares a function `add_two`, which we store in `my_func` and later invoke
    with `3` and `4`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的函数是一等公民。这意味着它们可以被存储在变量中，或者传递给其他函数，或者从函数中返回。前面的代码声明了一个名为`add_two`的函数，我们将它存储在`my_func`中，稍后用`3`和`4`调用它。
- en: Function types are not to be confused with `Fn` closures as they both have `fn`
    as their type signature prefix.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型不要与`Fn`闭包混淆，因为它们两者的类型签名前缀都是`fn`。
- en: Never type ! and diverging functions
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Never类型`!`和发散函数
- en: We used a macro called `unimplemented!()`, which helps in letting the compiler
    ignore any unimplemented function and to compile our code. This works because
    the unimplemented macro returns something called a never type, denoted by `!`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个名为`unimplemented!()`的宏，它有助于让编译器忽略任何未实现的功能，并编译我们的代码。这是因为未实现宏返回一个称为never类型的东西，表示为`!`。
- en: Unions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unions
- en: 'For interoperability with C code, Rust also supports the `union` type, which
    maps directly to a C union. Unions are unsafe to read from. Let''s see an example
    of how to create and interact with them:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与C代码互操作，Rust还支持`union`类型，它直接映射到C联合。联合类型在读取时是不安全的。让我们看看如何创建和与之交互的示例：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We created a union type, `Metric`, that has two fields `rounded` and `precise`,
    and represents some measurement. In `main`, we initialize an instance of it in
    the `a` variable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个联合类型`Metric`，它有两个字段`rounded`和`precise`，代表某种测量。在`main`函数中，我们在变量`a`中初始化了它的一个实例。
- en: 'We can only initialize one of the variables, otherwise the compiler complains
    with the following message:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能初始化其中一个变量，否则编译器会显示以下消息：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We also had to use unsafe blocks to print fields of our union. Compiling and
    running the previous code gives us the following output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须使用不安全块来打印联合的字段。编译并运行前面的代码会给我们以下输出：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, we get a garbage value for the uninitialized field, `precise`.
    At the time of writing this book, union types only allow `Copy` types as their
    fields. They share the same memory space with all of their fields, exactly like
    C unions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们为未初始化的字段`precise`得到了一个垃圾值。在撰写本书时，联合类型仅允许`Copy`类型作为其字段。它们与所有字段共享相同的内存空间，就像C联合一样。
- en: Cow
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cow
- en: 'Cow is a smart pointer type that provides two versions of strings. It stands
    for Clone on Write. It has the following type signature:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Cow是一种智能指针类型，提供了两种字符串版本。它代表写时克隆。它有以下类型签名：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'First, we have the two variants:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有两种变体：
- en: Borrowed that represents the borrowed version of some type B. This B has to
    implement the `ToOwned` trait.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Borrowed表示某些类型B的借用版本。这个B必须实现`ToOwned`特质。
- en: There is also owned variant which contains the owned version of the type.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个所有者变体，它包含类型的所有者版本。
- en: This type is suitable for cases where one needs to avoid allocations where it's
    not needed. A real world example is the JSON parser crate called `serde_json`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型适用于需要避免不必要的分配的情况。一个现实世界的例子是名为`serde_json`的JSON解析器crate。
- en: Advanced traits
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Advanced traits
- en: In this section, we'll discuss some of the advanced traits that are important
    to know when we are dealing with complex code bases.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些在处理复杂代码库时非常重要的高级特质。
- en: Sized and ?Sized
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sized和?Sized
- en: The `Sized` trait is a marker trait that represents types whose sizes are known
    at compile time. It is implemented for most types in Rust except for unsized types.
    All type parameters have an implicit trait bound of `Sized` in their definition.
    We can also specify optional trait bounds using the `?` operator before a trait,
    but the `?` operator with traits only works for marker traits as the time of writing
    this book. It may be extended to other types in future.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sized`特质是一个标记特质，表示在编译时已知大小的类型。它在Rust中的大多数类型上实现，除了未定义大小的类型。所有类型参数在其定义中都有一个隐式的`Sized`特质约束。我们还可以使用在特质前的`?`运算符指定可选特质约束，但截至本书撰写时，`?`运算符与特质仅适用于标记特质。它可能在未来扩展到其他类型。'
- en: Borrow and AsRef
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Borrow和AsRef
- en: These are special traits that carry the notion of able to construct a out of
    any type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是特殊的特质，它们携带了从任何类型构造出某种类型的能力。
- en: ToOwned
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ToOwned
- en: This trait is meant to be implemented for types that can be converted in to
    an owned version. For example, the `&str` type has this trait implemented for
    `String`. This means the `&str` type has a method called `to_owned()` on it that
    can convert it in to a `String` type, which is an owned type.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性是为了实现可以转换为拥有版本类型的。例如，`&str`类型为`String`实现了这个特性。这意味着`&str`类型有一个名为`to_owned()`的方法，可以将它转换为`String`类型，这是一个拥有类型的。
- en: From and Into
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: From 和 Into
- en: 'To convert one type into another, we have the `From` and `Into` traits. The
    interesting part about both of these traits is that we only need to implement
    the `From` trait and we get the implementation of the `Into` trait for free, because
    of the following impl:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一种类型转换为另一种类型，我们拥有`From`和`Into`特性。这两个特性的有趣之处在于，我们只需要实现`From`特性，就可以免费获得`Into`特性的实现，这是因为以下实现方式：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Trait objects and object safety
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性对象和对象安全性
- en: 'Object safety is a set of rules and restrictions that does not allow trait
    objects to be constructed. Consider the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对象安全性是一组规则和限制，不允许构造特性对象。考虑以下代码：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We get the following error upon compilation:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时我们得到以下错误：
- en: '![](img/637e6031-d0a6-4e35-9ffe-ecad5de2e43d.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/637e6031-d0a6-4e35-9ffe-ecad5de2e43d.png)'
- en: 'This brings us to the idea of object safety, which is a set of restrictions
    that forbids creating a trait object from a trait. In this example, since our
    type doesn''t have a self reference, it''s not possible to create a trait object
    out of it. In this case, to convert any type into a trait object, methods on the
    type need to be an instance—one that takes `self` by reference. So, we change
    our trait method declaration, `foo`, to the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了对象安全性的概念，它是一组禁止从特性创建特性对象的限制。在这个例子中，由于我们的类型没有自我引用，因此不可能从中创建特性对象。在这种情况下，要将任何类型转换为特性对象，类型上的方法需要是一个实例——一个通过引用传递`self`的实例。因此，我们将特性方法声明`foo`更改为以下内容：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This makes the the compiler happy.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得编译器感到满意。
- en: Universal function call syntax
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用函数调用语法
- en: 'There are times when you are using a type that has the same set of methods
    as one of its implemented traits. In those situations, Rust provides us with the
    uniform function call syntax that works for calling methods that are either on
    types themselves or come from a trait. Consider the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你使用的是一个具有与其实现特性相同方法集的类型。在这些情况下，Rust为我们提供了统一的函数调用语法，它可以用于调用类型本身或来自特性的方法。考虑以下代码：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding code has two methods with the same name, `drive`. One of them
    is an inherent method and the other comes from the trait, `Driver`. If we compile
    and run this, we get the following output:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有两个同名的方法，`drive`。其中一个是一个固有方法，另一个来自特性`Driver`。如果我们编译并运行这个程序，我们会得到以下输出：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Well, what if we wanted to call the `Driver` trait's `drive` method? Inherent
    methods on types are given higher priority than other methods with the same name.
    To call a trait method, we can use the **Universal Function Call Syntax** (**UFCS**).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果我们想调用`Driver`特性的`drive`方法怎么办？类型上的固有方法比具有相同名称的其他方法具有更高的优先级。要调用特性方法，我们可以使用**通用函数调用语法**（**UFCS**）。
- en: Trait rules
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性规则
- en: Traits also have special properties and restrictions, which are important to
    know about when you are using them.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 特性也有特殊的属性和限制，这些属性和限制在你使用它们时非常重要。
- en: An important property of the type system in the context of traits is the **trait
    coherence** rule. The idea of trait coherence is that there should be exactly
    one implementation of a trait on a type that implements it. This should be quite
    obvious since, with two implementations there would be ambiguity in what to choose
    between the two.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在特性的上下文中，类型系统的一个重要属性是**特性一致性**规则。特性一致性的理念是，对于实现了该特性的类型，应该恰好有一个特性的实现。这一点应该是相当明显的，因为如果有两个实现，那么在两者之间选择就会产生歧义。
- en: Another rule that might confuse many about traits is the **orphan rule**. The
    orphan rule, in simple words, states that we cannot implement external traits
    on external types.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能会让许多人感到困惑的特性规则是**孤儿规则**。简单来说，孤儿规则指出我们不能在外部类型上实现外部特性。
- en: To word it in another way, either the trait must be defined by you if you are
    implementing something on an external type, or your type should be defined by
    you when you are implementing an external trait. This rules out the possibility
    of having conflicts in overlapping trait implementations across crates.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 用另一种方式来说，要么如果你在实现外部类型上的东西，特性必须由你定义，要么如果你在实现外部特性，你的类型应该由你定义。这排除了在跨crate的重叠特性实现中发生冲突的可能性。
- en: Closures in depth
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解闭包
- en: As we know already, closures are a fancier version of functions. They are also
    first-class functions, which means that they can be put into variables or can
    be passed as an argument to functions or even returned from a function. But what
    sets them apart from functions is that they are also aware of the environment
    they are declared within and can reference any variable from their environment.
    The way they reference variables from their environment is determined by how the
    variable is used inside the closure.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，闭包是函数的更高级版本。它们也是一等函数，这意味着它们可以被放入变量中，或者作为函数的参数传递，甚至可以从函数中返回。但使它们与函数区别开来的是，它们还知道它们被声明的环境，并且可以引用其环境中的任何变量。它们从环境中引用变量的方式取决于变量在闭包内部的使用方式。
- en: A closure, by default, will try to capture the variable in the most flexible
    way possible. Only when the programmer needs a certain way of capturing the value
    will they coerce to the programmer's intent. That won't make much sense unless
    we see different kinds of closures in action. Closures under the hood are anonymous
    structs that implement three traits that represent how closures access their environment.
    We will look at the three traits (ordered from least restrictive to most restrictive)
    next.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，闭包会以尽可能灵活的方式尝试捕获变量。只有当程序员需要以某种特定方式捕获值时，他们才会强制执行程序员的意图。除非我们看到不同类型的闭包在实际操作中的表现，否则这不会有什么意义。闭包底层是匿名结构体，实现了三个特性，这些特性代表了闭包如何访问其环境。我们接下来将查看这三个特性（从最不限制到最限制）。
- en: Fn closures
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FnOnce`闭包'
- en: 'Closures that access variables only for read access implement the `Fn` trait.
    Any value they access are as reference types (`&T`). This is the default mode
    of borrowing the closures assumes. Consider the following code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 只进行读取访问的闭包实现了`Fn`特性。它们访问的任何值都是引用类型（`&T`）。这是闭包默认的借用模式。考虑以下代码：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We get the following output upon compilation:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后我们得到以下输出：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `a` variable was still accessible even after invoking the closure as the
    closure used `a` by reference.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在调用闭包之后，`a`变量仍然可访问，因为闭包通过引用使用了`a`。
- en: FnMut closures
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FnMut`闭包'
- en: 'When the compiler figures out that a closure mutates a value referenced from
    the environment, the closure implements the `FnMut` trait. Adapting the same code
    as before, we have the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器确定闭包会修改从环境引用的值时，闭包实现了`FnMut`特性。将相同的代码进行适配，我们得到以下内容：
- en: '[PRE64]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The previous closure adds the  `"Alice"` string to `a`. `fn_mut_closure` mutates
    its environment.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的闭包将`"Alice"`字符串添加到`a`上。`fn_mut_closure`会修改其环境。
- en: FnOnce closures
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FnOnce`闭包'
- en: 'Closures that take ownership of the data they read from their environment get
    implemented with `FnOnce`. The name signifies that this closure can only be called
    once and, because of that, the variables are available only once. This is the
    least recommended way to construct and use closures, because you cannot use the
    referenced variables later:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获它们从环境中读取的数据的所有权的闭包使用`FnOnce`实现。这个名字意味着这个闭包只能调用一次，因此变量也只可用一次。这是构建和使用闭包最不推荐的方式，因为你不能在之后使用引用的变量：
- en: '[PRE65]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This fails with the following error:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这会失败，并出现以下错误：
- en: '![](img/2fedfd1b-c35a-4c96-b0de-71bbe8b31a4f.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fedfd1b-c35a-4c96-b0de-71bbe8b31a4f.png)'
- en: But there are use cases where `FnOnce` closures are the only applicable closures.
    One such example is the `thread::spawn` method in the standard library used for
    spawning new threads.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一些用例中，`FnOnce`闭包是唯一适用的闭包。一个这样的例子是标准库中用于创建新线程的`thread::spawn`方法。
- en: Consts in structs, enums, and traits
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体、枚举和特性中的常量
- en: 'Structs, enums, and traits definitions can also be provided with constant field
    members. They can be used in cases where you need to share a constant among them.
    Take, for example, a scenario where we have a `Circle` trait that''s is meant
    to be implemented by different circular shape types. We can add a `PI` constant
    to the `Circle` trait, which can be shared by any type that has an  `area` property
    and relies on value of `PI` for calculating the area:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体、枚举和特质定义也可以提供具有常量字段成员。它们可以在需要在这些成员之间共享常量的情况下使用。以一个场景为例，我们有一个 `Circle` 特质，它旨在由不同的圆形形状类型实现。我们可以在
    `Circle` 特质中添加一个 `PI` 常量，它可以被任何具有 `area` 属性并依赖于 `PI` 值来计算面积的类型共享：
- en: '[PRE66]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can also have consts in structs and enums:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在结构体和枚举中使用常量：
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Next, let's look at some of the advanced aspects of modules.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看模块的一些高级特性。
- en: Modules, paths, and imports
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块、路径和导入
- en: Rust provides us with a lot of flexibility in terms of how we organize our project,
    as we saw in [Chapter 2](41099eaf-eb1e-4f75-bfdd-628152f59b58.xhtml), *Managing
    Projects with Cargo*. Here, we'll go into some of the advanced aspects of modules
    and different ways to introduce more privacy in our code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 在如何组织我们的项目方面为我们提供了很多灵活性，正如我们在第 2 章 [使用 Cargo 管理项目](41099eaf-eb1e-4f75-bfdd-628152f59b58.xhtml)中看到的。在这里，我们将探讨模块的一些高级特性以及引入更多代码隐私的不同方法。
- en: Imports
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: 'We can do **nested imports** of items from modules. This helps in reducing
    the taken up by imports. Consider the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从模块中导入嵌套的项目。这有助于减少导入所占用的空间。考虑以下代码：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Re-exports
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新导出
- en: Re-exports allows one to selectively expose items from a module. We were already
    using the convenience of reexports when we used the `Option` and `Result` types.
    Re-exports also helps in reducing the import path one has to write if the module
    is created a nested directory containing many submodules.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 重新导出允许用户有选择性地从模块中公开项目。当我们使用 `Option` 和 `Result` 类型时，我们已经使用了重新导出的便利性。重新导出还有助于减少在创建包含许多子模块的嵌套目录的模块时需要编写的导入路径。
- en: 'For example, here we have a sub module named `bar.rs` from a cargo project
    we created called `reexports`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我们有一个名为 `bar.rs` 的子模块，来自我们创建的名为 `reexports` 的 cargo 项目：
- en: '[PRE69]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `Bar` is a publicly exposed struct module under `src/foo/bar.rs`. If the
    user wants to use `Bar` in their code, they will have to write something like
    the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bar` 是位于 `src/foo/bar.rs` 下的公开结构体模块。如果用户想在他们的代码中使用 `Bar`，他们必须编写如下内容：'
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The above `use` statement is quite verbose. When you have a lot of nested sub-modules
    in your project, this gets awkward and redundant. Instead, we can reexport `Bar`
    from the `bar` module all of the way to our crate root, like so, in our `foo.rs`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 `use` 语句相当冗长。当你在项目中有很多嵌套子模块时，这会变得尴尬且重复。相反，我们可以从 `bar` 模块重新导出 `Bar` 到我们的
    crate 根目录，如下所示，在我们的 `foo.rs` 中：
- en: '[PRE71]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: To re-export, we use the `pub use` keyword. Now we can easily use `Bar` as well
    as using `foo::Bar`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新导出，我们使用 `pub use` 关键字。现在我们可以轻松地使用 `Bar`，以及使用 `foo::Bar`。
- en: By default, Rust recommends **absolute imports** within root modules. Absolute
    imports are done starting with the `crate` keyword, whereas **relative imports**
    are done using the `self` keyword. When re-exporting sub-modules to their parent
    modules, we might benefit from relative imports, as using absolute imports becomes
    long and redundant.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Rust 推荐在根模块中使用 **绝对导入**。绝对导入是从 `crate` 关键字开始的，而 **相对导入** 是使用 `self` 关键字进行的。当将子模块重新导出到父模块时，我们可能会从相对导入中受益，因为使用绝对导入会变得很长且冗余。
- en: Selective privacy
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择性隐私
- en: The privacy of items in Rust starts at the module level. As a library author,
    to expose things to users from a module, we use the `pub` keyword. But there are
    items that we only want to expose to other modules within the crate, but not to
    the users. In such cases, we can use the `pub(crate)` modifier for the item, which
    allows the item to be exposed only within the crate.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中项目的隐私性从模块级别开始。作为库的作者，为了从模块中向用户公开事物，我们使用 `pub` 关键字。但是，有些项目我们只想向 crate 内部的其他模块公开，而不是向用户公开。在这种情况下，我们可以使用
    `pub(crate)` 修饰符来修饰项目，这允许项目仅在本 crate 内部公开。
- en: 'Consider the following code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE72]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Advanced match patterns and guards
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级匹配模式和守卫
- en: In this section, we'll take a look at some of the advanced usage of match and
    let patterns. First, let's look at match.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些 match 和 let 模式的先进用法。首先，让我们看看 match。
- en: Match guards
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配守卫
- en: We can also use match guards on arms (`if code > 400 || code <= 500`) to match
    on a subset of values. They start with an `if` expression.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在臂上使用匹配守卫（`if code > 400 || code <= 500`）来匹配值的一个子集。它们以一个`if`表达式开始。
- en: Advanced let destructure
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级`let`解构
- en: 'We have the following complex data that we want to match against:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下复杂的数据，我们想要与之匹配：
- en: '[PRE73]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Casting and coercion
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换与强制转换
- en: 'Casting is a mechanism of downgrading or upgrading a type to some other type.
    When the casting happens implicitly, it is called coercion. Rust also allows for
    casting types at various levels. The very obvious candidates are primitive numeric
    types. You may have the need to cast a `u8` type to promote to `u64` or to truncate `i64`
    to `i32`. To perform trivial casts, we use the `as` keyword, like so:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是一种将类型降级或升级到其他类型的机制。当类型转换隐式发生时，它被称为强制转换。Rust还允许在各个级别进行类型转换。最明显的候选者是原始数值类型。你可能需要将`u8`类型转换为`u64`，或者截断`i64`到`i32`。为了执行简单的转换，我们使用`as`关键字，如下所示：
- en: '[PRE74]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'It''s not only primitive types—casting is supported at higher-level types too.
    We can also cast a reference of a type to its trait object, if it implements that
    particular trait. So we can do something like the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅限于原始类型——也支持在高级类型中进行类型转换。如果我们想要将类型的引用转换为其实例化该特定特质的特质对象，我们也可以这样做。所以我们可以做如下操作：
- en: '[PRE75]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'There are other classes of casting supported by various pointer types:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 支持各种指针类型的其他类别的类型转换：
- en: Converting a `*mut T` to `*const T`. The other method is forbidden in safe Rust
    and requires an `unsafe` block
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`*mut T`转换为`*const T`。另一种方法在安全Rust中是禁止的，并需要一个`unsafe`块
- en: Converting  `&T`  in to `*const T` and vice versa
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`&T`转换为`*const T`和相反
- en: There is also another explicit and unsafe version of casting called `transmutes`
    and, because it's unsafe, it is very dangerous to use when you are unaware of
    the consequences. When used ignorantly, it leads you into situations similar to
    one where you create a pointer from an integer in C.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种称为`transmutes`的显式且不安全的类型转换版本，因为它不安全，所以在你不知道后果的情况下使用它是非常危险的。当无知地使用时，它会使你陷入类似于在C语言中从整数创建指针的情况。
- en: Types and memory
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型与内存
- en: In this section, we'll touch on some aspects and low-level details of types
    in programming languages that are important to know if you are someone writing
    systems software and care about performance.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨编程语言中类型的一些方面和低级细节，如果你是编写系统软件且关心性能的人，这些内容是重要的。
- en: Memory alignment
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存对齐
- en: 'This is one of those aspects of memory management that you will rarely have
    to care about unless performance is a strict requirement. Due to data access latency
    between memory and the processor, when the processor accesses data from memory,
    it does so in a chunk and not byte by byte. This is to help reduce the number
    of memory accesses. This chunk size is called the memory access granularity of
    the CPU. Usually, the chunk sizes are one word (32 bit), two word, four word,
    and so on, and they depend on the target architecture. Due to this access granularity,
    it is desired that the data resides in memory which is aligned to a multiple of
    the word size. If that is not the case, then the CPU has to read and then perform
    left or right shifts on the data bits and discard the unneeded data to read a
    particular value. This wastes CPU cycles. In most cases, the compiler is smart
    enough to figure out the data alignment for us, but in some cases, we need to
    tell it. There are two important terms we need to understand:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内存管理方面的一些方面，你很少需要关心，除非性能是一个严格的要求。由于内存和处理器之间的数据访问延迟，当处理器从内存访问数据时，它是以块的形式进行的，而不是逐字节。这是为了帮助减少内存访问次数。这个块大小称为CPU的内存访问粒度。通常，块大小是一个字（32位）、两个字、四个字等，它们取决于目标架构。由于这种访问粒度，数据驻留在内存中，对齐到字大小的倍数是期望的。如果不是这种情况，那么CPU必须读取数据，然后对数据位进行左移或右移操作，并丢弃不需要的数据来读取特定的值。这浪费了CPU周期。在大多数情况下，编译器足够聪明，可以为我们找出数据对齐，但在某些情况下，我们需要告诉它。有两个重要的术语我们需要理解：
- en: '**Word size:** Word size means the number of bits of data processed by the
    microprocessor as a unit.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字大小**：字大小是指微处理器作为一个单位处理的数据位数。'
- en: '**Memory access granularity:** The minimum chunk of data accessed by the CPU
    from the memory bus is called the memory access granularity.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存访问粒度**：CPU从内存总线访问的最小数据块称为内存访问粒度。'
- en: Data types in all programming languages have both a size and an alignment. The
    alignment of primitive types is equal to their size. So, usually, all primitive
    types are aligned and the CPU has no problem doing an aligned read for these.
    But when we create custom data types, compilers usually insert padding between
    our struct fields if they are not aligned to allow the CPU to access memory in
    an aligned manner.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言中的数据类型都具有大小和对齐。原始类型对齐等于它们的大小。因此，通常所有原始类型都是对齐的，CPU对这些类型的对齐读取没有问题。但是，当我们创建自定义数据类型时，编译器通常会在我们的结构字段之间插入填充，如果它们没有对齐，以允许CPU以对齐的方式访问内存。
- en: Having known about data type size and alignment, let's explore the `std::mem`
    module from the standard library that allows us to introspect data types and their
    sizes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解数据类型的大小和对齐之后，让我们探索标准库中的`std::mem`模块，它允许我们内省数据类型及其大小。
- en: Exploring the std::mem module
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索`std::mem`模块
- en: 'In regard to types and their size in memory, the `mem` module from the standard
    library provides us with convenient APIs to inspect sizes and alignment of types
    and functionalities for initializing raw memory. Quite a few of these functions
    are unsafe and must only be used when the programmer knows what they are doing.
    We''ll restrict our exploration to these APIs:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类型及其在内存中的大小，标准库中的`mem`模块为我们提供了方便的API来检查类型的大小和对齐，以及初始化原始内存的功能。其中相当多的函数都是不安全的，并且只有在程序员知道自己在做什么时才能使用。我们将限制我们的探索到这些API：
- en: '`size_of` returns the size of a type given via a generic type'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size_of`返回通过泛型类型提供的类型的大小'
- en: '`size_of_val` returns the size of a value given as a reference'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size_of_val`返回作为引用提供的值的大小'
- en: 'Being generic, these methods are meant to be called using the turbofish `::<>`
    operator. We are not actually giving these methods a type as a parameter; we''re
    just explicitly calling them against a type. If we were skeptical about the zero-cost
    claims of some of the preceding generic types, we could use these functions to
    check the overhead. Let''s take a look at some sizes of types in Rust:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些方法是泛型的，因此它们旨在使用涡轮鱼`::<>`运算符调用。我们实际上并没有将这些方法作为一个类型参数传递；我们只是明确地针对一个类型调用它们。如果我们对前面一些泛型类型的零成本声明持怀疑态度，我们可以使用这些函数来检查开销。让我们看看Rust中一些类型的大小：
- en: '[PRE76]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Another observation that''s important to notice, is the size of various pointers.
    Consider the following code:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要观察是各种指针的大小。考虑以下代码：
- en: '[PRE77]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We create pointers to a Coordinate struct in a bunch of different ways and
    we print their sizes by casting them as different kind of pointers. Compiling
    and running the code above, gives us the following output:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以多种方式创建指向`Coordinate`结构的指针，并通过将它们转换为不同类型的指针来打印它们的大小。编译并运行上面的代码，我们得到以下输出：
- en: '[PRE78]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This clearly shows that trait objects and references to traits are fat pointers
    double the size of a normal pointer.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明，特性和特质的引用是胖指针，其大小是正常指针的两倍。
- en: Serialization and deserialization using serde
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`serde`进行序列化和反序列化
- en: Serialization and deserialization are important concepts to understand for any
    kind of application needs to transfer or store data in a compact manner. **Serialization**
    is the process by which an in-memory data type can be converted into a sequence
    of bytes, while **deserilization** is the opposite of that, meaning it can read
    data. Many programming languages provide support for converting a data structure
    into a sequence of bytes. The beautiful part about `serde` is that it generates
    the serialization of any supported type at compile time, relying heavily on procedural
    macros. Serialization and deserialization is a zero cost operation with serde
    most of the time.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化是理解任何需要以紧凑方式传输或存储数据的应用程序的重要概念。**序列化**是将内存中的数据类型转换为一系列字节的进程，而**反序列化**则是其相反过程，意味着它可以读取数据。许多编程语言都提供了将数据结构转换为一系列字节的支撑。关于`serde`的美丽之处在于，它在编译时生成任何受支持的类型的序列化，这主要依赖于过程宏。在大多数情况下，使用`serde`进行序列化和反序列化是一个零成本操作。
- en: 'In this demo, we''ll explore the `serde` crate to serialize and deserialize
    a user defined type. Let''s create a new project by running `cargo new serde_demo`
    with the following contents in `Cargo.toml`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将探索`serde`包以序列化和反序列化一个用户定义的类型。让我们通过运行`cargo new serde_demo`并使用以下内容在`Cargo.toml`中创建一个新的项目：
- en: '[PRE79]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Following are the contents in `main.rs`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`main.rs`中的内容：
- en: '[PRE80]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: To serialize any native data type to a JSON-like format, we simply need to put
    a derive annotation over our types, which is the case of for our struct, `Foo`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任何原生数据类型序列化为类似 JSON 的格式，我们只需在我们的类型上放置一个 derive 注解，正如我们的结构体 `Foo` 的情况。
- en: '`serde` supports a lot of serializers implemented as crates. Popular examples
    are `serde_json`, `bincode` and  `TOML`. More supported formats can be found at:
    [https://github.com/TyOverby/bincode](https://github.com/TyOverby/bincode). These
    serialization implementors, such as the `serde_json` crate, provide methods such
    as `to_string` to convert'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`serde` 支持许多作为 crate 实现的序列化器。流行的例子包括 `serde_json`、`bincode` 和 `TOML`。更多支持的格式可以在：[https://github.com/TyOverBy/bincode](https://github.com/TyOverBy/bincode)
    找到。这些序列化实现者，例如 `serde_json` crate，提供了 `to_string` 等方法来转换'
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered quite a bit of detail on some of the advanced aspects
    of Rust's type system. We got to know the various traits that make writing ergonomic
    Rust code. We also saw advanced pattern matching constructs. In the end, we looked
    at the serde crate that is blazing fast in performing data serialization. The
    next chapter will be about how to do multiple things at the same time using concurrency.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了 Rust 类型系统的某些高级特性。我们了解了各种特性，这些特性使得编写 Rust 代码更加人性化。我们还看到了高级的模式匹配结构。最后，我们探讨了
    serde crate，它在执行数据序列化方面速度极快。下一章将介绍如何使用并发同时做多件事情。
