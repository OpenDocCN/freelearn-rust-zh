- en: '*Chapter 8*: Serving Static Assets and Templates'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：服务静态资源和模板'
- en: One of the common functions of a web application is serving static files such
    as **Cascading Style Sheets** (**CSS**) or **JavaScript** (**JS**) files. In this
    chapter, we are going to learn about serving static assets from the Rocket application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序的常见功能之一是服务静态文件，例如 **层叠样式表**（**CSS**）或 **JavaScript**（**JS**）文件。在本章中，我们将学习如何从
    Rocket 应用程序中服务静态资源。
- en: One common task for a web framework is rendering a template into HTML files.
    We are going to learn about using the Tera template to render HTML from the Rocket
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络框架的一个常见任务是渲染模板到 HTML 文件。我们将学习如何使用 Tera 模板从 Rocket 应用程序中渲染 HTML。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Serving static assets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务静态资源
- en: Introducing the Tera template
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Tera 模板
- en: Showcasing users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示用户
- en: Working with forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理表单
- en: Securing HTML forms from CSRF
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 HTML 表单免受 CSRF 攻击
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们与上一章有相同的技术要求。我们需要一个 Rust 编译器、一个文本编辑器、一个 HTTP 客户端和一个 PostgreSQL 数据库服务器。
- en: For the text editor, you can try adding an extension supporting the Tera template.
    If there is no extension for Tera, try adding an extension for a Jinja2 or Django
    template and set the file association to include the `*.tera` file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本编辑器，您可以尝试添加一个支持 Tera 模板的扩展。如果没有 Tera 扩展，请尝试添加一个支持 Jinja2 或 Django 模板的扩展，并将文件关联设置为包含
    `*.tera` 文件。
- en: We are going to add CSS to our application, and we are going to use stylesheets
    from [https://minicss.org/](https://minicss.org/) since it's small and open source.
    Feel free to use and modify the example HTML with other stylesheets.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向我们的应用程序添加 CSS，并使用来自 [https://minicss.org/](https://minicss.org/) 的样式表，因为它体积小且开源。请随意使用并修改示例
    HTML 文件以使用其他样式表。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08)
    找到本章的源代码。
- en: Serving static assets
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务静态资源
- en: 'Serving static assets (such as HTML files, JS files, or CSS files) is a very
    common task for a web application. We can make Rocket serve files as well. Let''s
    create the first function to serve a favicon. Previously you might have noticed
    that some web browsers requested a favicon file from our server, even though we
    did not explicitly mention it on our served HTML page. Let''s look at the steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 服务静态资源（如 HTML 文件、JS 文件或 CSS 文件）是网络应用程序的一个非常常见的任务。我们也可以让 Rocket 服务文件。让我们创建第一个服务
    favicon 的函数。之前您可能已经注意到，一些网络浏览器从我们的服务器请求 favicon 文件，尽管我们在提供的 HTML 页面上没有明确提及它。让我们看看步骤：
- en: In the application root folder, create a folder named `static`. Inside the `static`
    folder, add a file named `favicon.png`. You can find sample `favicon.png` files
    on the internet or use the file from the sample source code for this chapter.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序根目录中，创建一个名为 `static` 的文件夹。在 `static` 文件夹内，添加一个名为 `favicon.png` 的文件。您可以在互联网上找到样本
    `favicon.png` 文件，或者使用本章示例源代码中的文件。
- en: 'In `src/main.rs`, add a new route:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中添加一个新的路由：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `src/routes/mod.rs`, add a new route handling function to serve `favicon.png`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/routes/mod.rs` 中添加一个新的路由处理函数来服务 `favicon.png`：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `relative!` is a macro that generates a crate-relative version of a path.
    This means that the macro refers to the folder of the source file or the generated
    binary. For example, we have the source file for this application in `/some/source`,
    and by saying `relative!("static/favicon.png")`, it means the path is `/some/source/static/favicon.png`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`relative!` 是一个宏，它生成一个相对于 crate 的路径版本。这意味着该宏指的是源文件或生成的二进制文件的文件夹。例如，我们在这个应用程序中的源文件位于
    `/some/source`，通过说 `relative!("static/favicon.png")`，这意味着路径是 `/some/source/static/favicon.png`。
- en: Every time we want to serve a particular file, we can create a route handling
    function, return `NamedFile`, and mount the route to Rocket. But obviously, this
    approach is not good; we can create a function to return static files dynamically.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想要服务特定的文件时，我们都可以创建一个路由处理函数，返回 `NamedFile`，并将路由挂载到 Rocket 上。但显然，这种方法并不好；我们可以创建一个函数来动态返回静态文件。
- en: Let's reuse the `assets` function that we created when we made the application
    skeleton. Previously, in [*Chapter 3*](B16825_03_ePub.xhtml#_idTextAnchor046),
    *Rocket Requests and Responses*, we learned that we can use multiple segments
    in a route. We can leverage this and serve a file that has the same filename with
    the request's multiple segments.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重用我们在创建应用程序骨架时创建的`assets`函数。之前，在[*第3章*](B16825_03_ePub.xhtml#_idTextAnchor046)，*Rocket请求和响应*中，我们了解到我们可以在路由中使用多个段。我们可以利用这一点，为具有与请求多个段相同的文件名的文件提供服务。
- en: 'Delete the favicon function that we created earlier and remove the reference
    to the function from `src/main.rs`. In `src/routes/mod.rs`, modify the `use` declarations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 删除我们之前创建的favicon功能，并从`src/main.rs`中移除对该功能的引用。在`src/routes/mod.rs`中，修改`use`声明：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The application should return an HTTP `404` status code if the application
    cannot find the requested file. We can easily return `404` status code by wrapping
    `NamedFile` inside `Option`. If `NamedFile` is `None`, then the response will
    have `404` status automatically. Modify the `assets` function signature in `src/routes/mod.rs`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序找不到请求的文件，则应返回HTTP `404`状态码。我们可以通过将`NamedFile`包裹在`Option`中轻松地返回`404`状态码。如果`NamedFile`是`None`，则响应将自动具有`404`状态。修改`src/routes/mod.rs`中的`assets`函数签名：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can then implement the `assets` function:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以实现`assets`函数：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unfortunately, Rocket returns an HTTP `200` status code if filename is a directory,
    so an attacker can try attacking and mapping the folder structure inside the `static`
    folder. Let''s handle this case by adding these lines:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，Rocket如果文件名是目录，会返回HTTP `200`状态码，因此攻击者可以尝试攻击并映射`static`文件夹内的文件夹结构。让我们通过添加以下这些行来处理这种情况：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If an attacker tries to systematically check the path inside the static file,
    the attacker will be served with an HTTP `404` status code and will not be able
    to infer the folder structures inside the `static` folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者尝试系统地检查静态文件内的路径，攻击者将收到HTTP `404`状态码，并且无法推断出`static`文件夹内的文件夹结构。
- en: 'There''s another way to serve the static file: by using the built-in `rocket::fs::FileServer`
    struct. Remove the function to handle static assets in `src/routes/mod.rs`, and
    append the following lines in `src/main.rs`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有另一种提供静态文件的方法：使用内置的`rocket::fs::FileServer`结构。在`src/routes/mod.rs`中删除处理静态资源的函数，并在`src/main.rs`中追加以下行：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Even though web frameworks such as Rocket can serve static files, it's more
    common to serve static files behind web servers such as Apache Web Server or NGINX.
    In more advanced setups, people also utilize cloud storage, such as Amazon Web
    Services S3 or Google Cloud Storage, in conjunction with a **Content Delivery
    Network** (**CDN**).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像Rocket这样的Web框架可以提供静态文件，但在Web服务器（如Apache Web服务器或NGINX）后面提供静态文件更为常见。在更高级的设置中，人们还利用云存储，如Amazon
    Web Services S3或Google Cloud Storage，与**内容分发网络**（**CDN**）结合使用。
- en: In the next section, we are going to refine the HTML that we created in [*Chapter
    6*](B16825_06_ePub.xhtml#_idTextAnchor083), *Implementing User CRUD*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将对[*第6章*](B16825_06_ePub.xhtml#_idTextAnchor083)，*实现用户CRUD*中创建的HTML进行细化。
- en: Introducing the Tera template
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Tera模板
- en: In web applications, there's usually a part that works as a web template system.
    Web designers and web developers can create web templates, and the web application
    generates HTML pages from the templates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，通常有一个作为Web模板系统的部分。Web设计师和Web开发者可以创建Web模板，Web应用程序从模板生成HTML页面。
- en: 'There are different kinds of web templates: server-side web templates (in which
    the template is rendered on the server-side), client-side web templates (where
    client-side applications render the template), or hybrid web templates.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的Web模板：服务器端Web模板（其中模板在服务器端渲染），客户端Web模板（客户端应用程序渲染模板），或混合Web模板。
- en: There are a couple of templating engines in Rust. We can find templating engines
    for web development (such as **Handlebars**, **Tera**, **Askama**, or **Liquid**)
    at [https://crates.io](https://crates.io) or https:/lib.rs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中有几个模板引擎。我们可以在[https://crates.io](https://crates.io)或https:/lib.rs找到用于Web开发的模板引擎（例如**Handlebars**、**Tera**、**Askama**或**Liquid**）。
- en: 'The Rocket web framework has built-in support for templating in the form of
    the `rocket_dyn_templates` crate. Currently, the crate only supports two engines:
    **Handlebars** and **Tera**. In this book, we are going to use Tera as the template
    engine to simplify the development, but feel free to try the Handlebars engine
    as well.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket web框架以`rocket_dyn_templates`crate的形式内置了对模板的支持。目前，crate只支持两个引擎：**Handlebars**和**Tera**。在这本书中，我们将使用Tera作为模板引擎以简化开发，但也欢迎尝试Handlebars引擎。
- en: Tera is a template engine that is inspired by **Jinja2** and **Django** templates.
    You can find the documentation for Tera at https://tera.netlify.app/docs/. A Tera
    template is a text file with expressions, statements, and comments. The expressions,
    statements, and comments are replaced with variables and expressions when the
    template is rendered.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Tera是一个受**Jinja2**和**Django**模板启发的模板引擎。您可以在https://tera.netlify.app/docs/找到Tera的文档。Tera模板是一个包含表达式、语句和注释的文本文件。当模板被渲染时，表达式、语句和注释被替换为变量和表达式。
- en: 'For example, let''s say we have a file named `hello.txt.tera`, with the following
    content:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个名为`hello.txt.tera`的文件，其内容如下：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If our program has a `name` variable with the value `"Robert"`, we can create
    a `hello.txt` file with the following content:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的程序有一个名为`name`的变量，其值为`"Robert"`，我们可以创建一个包含以下内容的`hello.txt`文件：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, we can easily create HTML pages with Tera templates. In Tera,
    there are three delimiters we can use:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以轻松地使用Tera模板创建HTML页面。在Tera中，我们可以使用三个分隔符：
- en: '`{{ }}` for **expressions**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ }}`用于**表达式**'
- en: '`{% %}` for **statements**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% %}`用于**语句**'
- en: '`{# #}` for **comments**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{# #}`用于**注释**'
- en: 'Suppose we have a template named `hello.html.tera` with the following content:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`hello.html.tera`的模板，其内容如下：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can render that template into a `hello.html` file with the following content:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下内容的模板将其渲染成`hello.html`文件：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tera also has other capabilities such as embedding other templates in a template,
    basic data operation, control structures, and functions. Basic data operations
    include basic mathematic operations, basic comparison functions, and string concatenations.
    Control structures include `if` branching, `for` loops, and other templates. Functions
    are defined procedures that return some text to be used in the template.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Tera还具有其他功能，如在一个模板中嵌入其他模板、基本数据操作、控制结构和函数。基本数据操作包括基本的数学运算、基本的比较函数和字符串连接。控制结构包括`if`分支、`for`循环和其他模板。函数是返回一些用于模板的文本的定义过程。
- en: 'We are going to learn more about some of those capabilities by changing the
    `OurApplication` responses to use the Tera template engine. Let''s set up `OurApplication`
    to use the Tera template engine:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将`OurApplication`响应更改为使用Tera模板引擎来学习一些这些功能。让我们设置`OurApplication`以使用Tera模板引擎：
- en: 'In the `Cargo.toml` file, add the dependencies. We need the `rocket_dyn_templates`
    crate and the `serde` crate to serialize instances:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`文件中，添加依赖项。我们需要`rocket_dyn_templates`crate和`serde`crate来序列化实例：
- en: '[PRE18]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add a new configuration in `Rocket.toml` to designate a folder in which
    to place the template files:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Rocket.toml`中添加一个新的配置以指定放置模板文件的文件夹：
- en: '[PRE19]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `src/main.rs`, add the following lines to attach the `rocket_dyn_templates::Template`
    fairing to the application:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main.rs`中，添加以下行以将`rocket_dyn_templates::Template`fairing附加到应用程序：
- en: '[PRE20]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Adding the `Template` fairing is straightforward. We are going to learn about
    `Template` in the next section by replacing `RawHtml` with `Template`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`Template`fairing很简单。我们将在下一节通过将`RawHtml`替换为`Template`来学习`Template`。
- en: Showcasing users
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示用户
- en: 'We are going to modify routes for `/users/<uuid>` and `/users/` by taking the
    following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`/users/<uuid>`和`/users/`的路线，采取以下步骤：
- en: The first thing we need to do is to create a template. We already configured
    the folder for templates in `/src/views`, so create a `views` folder in the `src`
    folder and then, inside the `views` folder, create a template file named `template.html.tera`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个模板。我们已经在`/src/views`中配置了模板文件夹，所以请在`src`文件夹中创建一个名为`views`的文件夹，然后在`views`文件夹内部创建一个名为`template.html.tera`的模板文件。
- en: 'We are going to use the file as the base HTML template for all HTML files.
    Inside `src/views/template.html.tera`, add HTML tags as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用该文件作为所有HTML文件的基HTML模板。在`src/views/template.html.tera`内部添加以下HTML标签：
- en: '[PRE21]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we included a CSS file in the HTML file. You can download the open
    source CSS file from [https://minicss.org/](https://minicss.org/) and put it inside
    the `static` folder. Since we already created a route to serve the static file
    in `/assets/<filename..>`, we can just use the route directly inside the HTML
    file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在HTML文件中包含了一个CSS文件。您可以从 [https://minicss.org/](https://minicss.org/) 下载开源CSS文件并将其放入
    `static` 文件夹中。由于我们已经在 `/assets/<filename..>` 路径上创建了一个用于服务静态文件的路由，我们可以在HTML文件中直接使用该路由。
- en: 'For the next step, we need to include a part where we can put the HTML text
    we want to render and a part where we can insert `flash` messages. Modify `src/views/template.html.tera`
    as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一步，我们需要包含一个可以放置我们想要渲染的HTML文本的部分，以及一个可以插入 `flash` 消息的部分。修改 `src/views/template.html.tera`
    如下：
- en: '[PRE22]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By default, all variables are rendered escaped to avoid an XSS (Cross-Site Scripting)
    attack. We added the condition if there's a `flash` variable, we put the variable
    inside the `{{ flash }}` expression. To let the HTML tag render as it is and not
    escaped, we can use the `| safe` filter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有变量都会被转义渲染以避免XSS（跨站脚本）攻击。我们添加了条件，如果存在 `flash` 变量，我们将变量放在 `{{ flash }}`
    表达式内。为了使HTML标签以原始形式渲染而不被转义，我们可以使用 `| safe` 过滤器。
- en: Tera has other built-in filters such as `lower`, `upper`, `capitalize`, and
    many more. For the content, we are using `block` statements. The `block` statements
    mean we are going to include another template inside the statement. You can also
    see `block` ends with an `endblock` statement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Tera还有其他内置过滤器，如 `lower`、`upper`、`capitalize` 等。对于内容，我们使用 `block` 语句。`block`
    语句意味着我们将在语句中包含另一个模板。您也可以看到 `block` 以 `endblock` 语句结束。
- en: 'Tera can render any type that implements Serde''s `Serializable` trait. Let''s
    modify `User` and related types to implement the `Serializable` trait. In `src/models/user.rs`,
    modify the file as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Tera可以渲染实现Serde的 `Serializable` 特性的任何类型。让我们修改 `User` 和相关类型以实现 `Serializable`
    特性。在 `src/models/user.rs` 文件中，按如下修改文件：
- en: '[PRE23]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Modify `src/models/user_status.rs` as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `src/models/user_status.rs` 如下：
- en: '[PRE24]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Also, modify `src/models/our_date_time.rs` as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，修改 `src/models/our_date_time.rs` 如下：
- en: '[PRE25]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For `Pagination`, we can derive `Serialize` as it is, but using a timestamp
    in an URL does not look good, for example, `/users?pagination.next=``&pagination.limit=2`.
    We can make the pagination URL look better by converting `OurDateTime` into `i64`
    and vice versa. In `src/models/pagination.rs`, append the following lines:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `Pagination`，我们可以直接派生 `Serialize`，但使用URL中的时间戳看起来不太好，例如，`/users?pagination.next=``&pagination.limit=2`。我们可以通过将
    `OurDateTime` 转换为 `i64` 和反之亦然来使分页URL看起来更好。在 `src/models/pagination.rs` 文件中，追加以下行：
- en: '[PRE26]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since we are not going to use `RawHtml` anymore, remove the `use rocket::response::content::RawHtml;`
    directive from the `src/routes/mod.rs` file and modify the file as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不再使用 `RawHtml`，请从 `src/routes/mod.rs` 文件中删除 `use rocket::response::content::RawHtml;`
    指令，并按如下修改文件：
- en: '[PRE27]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `src/routes/user.rs`, remove the `use rocket::response::content::RawHtml`
    directive. We are going to add the `Template` directive to make the response return
    `Template`, but we also need help from Serde''s `Serialize` and `context!` macros
    to help convert objects into a Tera variable. Append the following lines:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/routes/user.rs` 文件中，删除 `use rocket::response::content::RawHtml` 指令。我们将添加
    `Template` 指令以使响应返回 `Template`，但我们还需要Serde的 `Serialize` 和 `context!` 宏的帮助来将对象转换为Tera变量。追加以下行：
- en: '[PRE28]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then, we can modify the `get_user` function. Inside the `get_user` function
    in `src/routes/user.rs`, delete everything related to `RawHtml`. Delete all the
    lines starting from `let mut html_string = String::from(USER_HTML_PREFIX);` to
    `Ok(RawHtml(html_string))`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以修改 `get_user` 函数。在 `src/routes/user.rs` 文件中的 `get_user` 函数内，删除所有与 `RawHtml`
    相关的内容。从 `let mut html_string = String::from(USER_HTML_PREFIX);` 到 `Ok(RawHtml(html_string))`
    的所有行都应删除。
- en: 'Then, replace the content of the deleted lines with the following lines:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将删除的行内容替换为以下行：
- en: '[PRE29]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Remember that the Tera template can use any Rust type that implements the `Serializable`
    trait. We define the `GetUser` struct that derives the `Serializable` trait. Since
    the `User` struct already implements `Serializable`, we can use it as a field
    inside the `GetUser` struct. After creating a new instance of `GetUser`, we then
    tell the application to render the `"users/show"` template file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 记住Tera模板可以使用实现 `Serializable` 特性的任何Rust类型。我们定义了派生 `Serializable` 特性的 `GetUser`
    结构体。由于 `User` 结构体已经实现了 `Serializable`，我们可以在 `GetUser` 结构体中使用它作为字段。创建 `GetUser`
    的新实例后，我们告诉应用程序渲染 `"users/show"` 模板文件。
- en: 'Since we have told the application that the template name is `"users/show"`,
    create a new folder named `users` inside `src/views`. Inside the `src/views/users`
    folder, create a new file, `src/views/users/show.html.tera`. After that, add these
    lines inside the file:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经告诉应用程序模板名称是`"users/show"`，所以在`src/views`内部创建一个名为`users`的新文件夹。在`src/views/users`文件夹内部，创建一个新文件，`src/views/users/show.html.tera`。之后，在文件中添加以下行：
- en: '[PRE30]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first statement, `{% extends "template" %}`, means we are extending `src/views/template.html.tera`,
    which we created earlier. The parent `src/views/template.html.tera` has a statement,
    `{% block body %}{% endblock body %}`, and we tell the Tera engine to override
    that block with content from the same block in `src/views/users/show.html.tera`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句`{% extends "template" %}`表示我们正在扩展我们之前创建的`src/views/template.html.tera`。父`src/views/template.html.tera`有一个语句`{%
    block body %}{% endblock body %}`，我们告诉Tera引擎用`src/views/users/show.html.tera`中相同块的内容覆盖该块。
- en: 'Inside that code, we also see `{% include "users/_user" %}`, so let''s create
    a `src/views/users/_user.html.tera` file and add the following lines:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这段代码中，我们还可以看到`{% include "users/_user" %}`，所以让我们创建一个`src/views/users/_user.html.tera`文件，并添加以下行：
- en: '[PRE31]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside both files, you will see there are many expressions, such as `{{ user.username
    }}`. These expressions are using the variable that we defined before: `let context
    = GetUser { user, flash: flash_message,};`. Then, we tell the application to render
    the template: `Ok(Template::render("users/show", &context))`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '在这两个文件中，您将看到许多表达式，例如`{{ user.username }}`。这些表达式使用我们之前定义的变量：`let context = GetUser
    { user, flash: flash_message,};`。然后，我们告诉应用程序渲染模板：`Ok(Template::render("users/show",
    &context))`。'
- en: You might be wondering why we split `show.html.tera` and `_user.html.tera`.
    One benefit of using a template system is that we can reuse a template. We want
    to reuse the same user HTML in the `get_users` function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们要将`show.html.tera`和`_user.html.tera`分开。使用模板系统的一个好处是我们可以重用模板。我们希望在`get_users`函数中重用相同的用户HTML。
- en: 'Let''s modify the `get_users` function inside the `src/routes/user.rs` files.
    Delete the lines from `let mut html_string = String::from(USER_HTML_PREFIX);`
    to `Ok(RawHtml(html_string))`. Replace those lines with the following lines:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`src/routes/user.rs`文件中的`get_users`函数。删除从`let mut html_string = String::from(USER_HTML_PREFIX);`到`Ok(RawHtml(html_string))`的行。将这些行替换为以下行：
- en: '[PRE32]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead of defining a new struct, such as `GetUser`, we are using the `context!`
    macro. By using the `context!` macro, we do not need to create a new type to be
    passed to the template. Now, create a new file named `src/views/users/index.html.tera`,
    and add the following lines to the file:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是定义一个新的结构体，例如`GetUser`，而是使用`context!`宏。通过使用`context!`宏，我们不需要创建一个新的类型传递给模板。现在，创建一个名为`src/views/users/index.html.tera`的新文件，并将以下行添加到文件中：
- en: '[PRE33]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We see two new things here: a `{% for user in users %}...{% endfor %}` statement,
    which can be used to iterate arrays, and `{{loop.index}}`, to get the current
    iteration inside the `for` loop.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到了两个新事物：一个`{% for user in users %}...{% endfor %}`语句，它可以用来迭代数组，以及`{{loop.index}}`，用于获取`for`循环中的当前迭代。
- en: We want to change the `new_user` and `edit_user` functions too, but before that,
    we want to see `get_user` and `get_users` in action. Since we already changed
    the `HtmlResponse` alias into `Result<Template, Status>`, we need to convert `Ok(RawHtml(html_string))`
    in `new_user` and `edit_user` to use a template too. Change `Ok(RawHtml(html_string))`
    in the `new_user` and `edit_user` functions to `Ok(Template::render("users/tmp",
    context!()))`, and create an empty `src/views/users/tmp.html.tera` file.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还想修改`new_user`和`edit_user`函数，但在那之前，我们想看看`get_user`和`get_users`的实际应用。由于我们已经将`HtmlResponse`别名改为`Result<Template,
    Status>`，我们需要在`new_user`和`edit_user`中将`Ok(RawHtml(html_string))`转换为使用模板。将`new_user`和`edit_user`函数中的`Ok(RawHtml(html_string))`改为`Ok(Template::render("users/tmp",
    context!()))`，并创建一个空的`src/views/users/tmp.html.tera`文件。
- en: 'Now, we can run the application and check the page that we have improved with
    CSS:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行应用程序并检查我们用CSS改进的页面：
- en: '![Figure 8.1 – get_user() rendered'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – get_user()渲染'
- en: '](img/Figure_8.1_B16825.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – get_user()渲染'
- en: Figure 8.1 – get_user() rendered
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – get_user()渲染
- en: We can see that the template is working along with the correct CSS file that
    the application served. In the next section, we will also modify the form to use
    the template.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到模板正在与应用程序提供的正确CSS文件一起工作。在下一节中，我们还将修改表单以使用模板。
- en: Working with forms
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单
- en: 'If we look at the structure of the form for `new_user` and `edit_user`, we
    can see that both forms are almost the same, with just a few differences. For
    example, the forms'' `action` endpoints are different, as there are two extra
    fields for `edit_user`: `_METHOD` and `old_password`. To simplify, we can make
    one template to be used by both functions. Let''s look at the steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`new_user`和`edit_user`表单的结构，我们可以看到这两个表单几乎相同，只有一些细微的差别。例如，表单的`action`端点不同，因为`edit_user`有两个额外的字段：`_METHOD`和`old_password`。为了简化，我们可以制作一个模板供这两个函数使用。让我们看看步骤：
- en: 'Create a template called `src/views/users/form.html.tera`, and insert the following
    lines:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/views/users/form.html.tera`的模板，并插入以下行：
- en: '[PRE34]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, let''s add the title to the form by adding a `legend` tag. Put this inside
    the `fieldset` tag:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们通过添加一个`legend`标签来给表单添加标题。将此放在`fieldset`标签内：
- en: '[PRE35]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Under the `legend` tag, we can add an extra field if we are editing the user:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`legend`标签下，如果我们正在编辑用户，可以添加一个额外的字段：
- en: '[PRE36]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Continuing with the field, add the fields for `username` and `email` as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续添加字段，按照以下方式添加`username`和`email`字段：
- en: '[PRE37]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add a conditional `old_password` field after the `email` field:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`email`字段之后添加一个条件`old_password`字段：
- en: '[PRE38]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the rest of the fields:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加其余的字段：
- en: '[PRE39]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, change the labels and fields to show the value (if there is a value):'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将标签和字段更改为显示值（如果有值）：
- en: '[PRE40]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: After we have created the form template, we can modify the `new_user` and `edit_user`
    functions. In `new_user`, remove the lines from `let mut html_string = String::from(USER_HTML_PREFIX);`
    to `Ok(Template::render("users/tmp", context!()))` to create `RawHtml`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建了表单模板之后，我们可以修改`new_user`和`edit_user`函数。在`new_user`中，从`let mut html_string
    = String::from(USER_HTML_PREFIX);`到`Ok(Template::render("users/tmp", context!()))`删除这些行以创建`RawHtml`。
- en: 'In `form.html.tera`, we added these variables: `form_url`, `edit`, and `legend`.
    We also need to convert `Option<FlashMessage<''_>>` into a `String` since the
    default implementation of the `Serializable` trait by `FlashMessage` is not human-readable.
    Add those variables and render the template in the `new_user` function as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`form.html.tera`中，我们添加了这些变量：`form_url`、`edit`和`legend`。我们还需要将`Option<FlashMessage<'_>>`转换为`String`，因为`FlashMessage`的`Serializable`特质的默认实现不是人类可读的。在`new_user`函数中添加这些变量并渲染模板，如下所示：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For `edit_user`, we can create the same variables, but this time, we know the
    data for `user` so we can include `user` in the context. Delete the lines in the
    `edit_user` function in `src/routes/user.rs` from `let mut html_string = String::from(USER_HTML_PREFIX);`
    to `Ok(Template::render("users/tmp", context!()))`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`edit_user`，我们可以创建相同的变量，但这次我们知道`user`的数据，因此我们可以将`user`包含在上下文中。在`src/routes/user.rs`的`edit_user`函数中删除从`let
    mut html_string = String::from(USER_HTML_PREFIX);`到`Ok(Template::render("users/tmp",
    context!()))`的行。
- en: 'Replace those lines with the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行替换为以下代码：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As the final touch, we can remove the `USER_HTML_PREFIX` and `USER_HTML_SUFFIX`
    constants from `src/routes/user.rs`. We should also remove the `src/views/users/tmp.html.tera`
    file since there''s no function using that file anymore. And, since we already
    enclose the flash message inside the `<div></div>` tag in the template, we can
    remove the `div` usage from flash messages. For example, in `src/routes/user.rs`,
    we can modify these lines:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的润色，我们可以从`src/routes/user.rs`中删除`USER_HTML_PREFIX`和`USER_HTML_SUFFIX`常量。我们还应该删除`src/views/users/tmp.html.tera`文件，因为再也没有函数使用该文件了。而且，因为我们已经在模板中用`<div></div>`标签包围了闪存消息，所以我们可以从闪存消息中删除`div`的使用。例如，在`src/routes/user.rs`中，我们可以修改以下行：
- en: '[PRE43]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can modify them into the following lines:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它们修改为以下行：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: One more thing that we can improve for the form is adding a token to secure
    the application from **cross-site request forgery** (**CSRF**) attacks. We will
    learn how to secure our form in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以改进表单的一个方面，那就是添加一个令牌来保护应用程序免受**跨站请求伪造**（**CSRF**）攻击。我们将在下一节学习如何保护我们的表单。
- en: Securing HTML forms from CSRF
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护HTML表单免受CSRF攻击
- en: One of the most common security attacks is CSRF, where a malicious third party
    tricks a user into sending a web form with different values than intended. One
    way to mitigate this attack is by sending a one-time token along with the form
    content. The web server then checks the token validity to ensure the request comes
    from the correct web browser.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的安全攻击之一是CSRF，恶意第三方诱使用户发送一个具有与预期不同的值的Web表单。减轻这种攻击的一种方法是在表单内容中发送一个一次性令牌。然后，Web服务器检查令牌的有效性，以确保请求来自正确的Web浏览器。
- en: 'We can create such a token in a Rocket application by creating a fairing that
    will generate a token and check the form value sent back. Let''s look at the steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Rocket应用程序中通过创建一个将生成令牌并检查发送回的表单值的公平性来创建这样的令牌。让我们看看步骤：
- en: First, we need to add the dependencies for this. We are going to need a `base64`
    crate to encode and decode binary values into a string. We also need the `secrets`
    feature from Rocket to store and retrieve private cookies. Private cookies are
    just like regular cookies, but they are encrypted by the key we configured in
    the `Rocket.toml` file with `secret_key`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要添加这个依赖项。我们将需要一个`base64`crate来将二进制值编码和解码为字符串。我们还需要Rocket的`secrets`功能来存储和检索私有cookie。私有cookie就像常规cookie一样，但它们被我们在`Rocket.toml`文件中配置的`secret_key`加密。
- en: 'For dependencies, we also need to add `time` as a dependency. Add the following
    lines in `Cargo.toml`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖项，我们还需要添加`time`作为依赖项。在`Cargo.toml`中添加以下行：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The steps for preventing CSRF are generating a random byte, storing the random
    byte in a private cookie, hashing the random byte as a string, and rendering the
    form template along with the token string. When the user sends the token back,
    we can retrieve the token from the cookie and compare both.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 防止CSRF的步骤是生成随机字节，将随机字节存储在私有cookie中，将随机字节作为字符串进行哈希处理，并渲染带有令牌字符串的表单模板。当用户发送令牌回来时，我们可以从cookie中检索令牌并比较两者。
- en: 'To make a CSRF fairing, add a new module. In `src/fairings/mod.rs`, add the
    new module:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个CSRF公平性，添加一个新的模块。在`src/fairings/mod.rs`中添加新的模块：
- en: '[PRE46]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After that, create a file named `src/fairings/csrf.rs` and add the dependencies
    and constants for the default value for the cookie to store the random bytes:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，创建一个名为`src/fairings/csrf.rs`的文件，并添加存储随机字节的cookie默认值的依赖项和常量：
- en: '[PRE47]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Then, we can extend Rocket's `Request` with a new method to retrieve the CSRF
    token. Because `Request` is an external crate, we cannot add another method, but
    we can overcome this by adding a trait and making the external crate type extend
    this trait. We cannot extend an external crate with an external trait, but extending
    an external crate with an internal trait is permissible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以扩展Rocket的`Request`以添加一个新的方法来检索CSRF令牌。因为`Request`是一个外部crate，我们无法添加另一个方法，但我们可以通过添加一个trait并使外部crate类型扩展此trait来克服这一点。我们不能使用外部trait扩展外部crate，但使用内部trait扩展外部crate是允许的。
- en: 'We want to create a method to retrieve CSRF tokens from private cookies. Continue
    with `src/fairings/csrf.rs` by appending the following lines:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要创建一个方法来从私有cookie中检索CSRF令牌。继续在`src/fairings/csrf.rs`中添加以下行：
- en: '[PRE48]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After that, we want to add a fairing that retrieves or generates, and stores
    random bytes if the cookie does not exist. Add a new struct to be managed as a
    fairing:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们想要添加一个检索或生成并存储随机字节（如果cookie不存在）的公平性。添加一个新的结构体来作为公平性管理：
- en: '[PRE49]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We want to retrieve the token first, and if the token does not exist, generate
    random bytes and add the bytes to the private token. Inside the `impl Fairing`
    block, add the `on_request` function:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要首先检索令牌，如果令牌不存在，则生成随机字节并将字节添加到私有令牌中。在`impl Fairing`块中，添加`on_request`函数：
- en: '[PRE50]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We need a request guard to retrieve the token string from the request. Append
    the following lines:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个请求保护者来从请求中检索令牌字符串。添加以下行：
- en: '[PRE51]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We return an HTTP `403` status code if the token is not found. We also need
    two more functions: generating a hash and comparing the token hash with other
    strings. Since we already use `argon2` for password hashing, we can reuse the
    `argon2` crate for those functions. Append the following lines:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找不到令牌，我们返回HTTP `403`状态码。我们还需要两个额外的函数：生成哈希和比较令牌哈希与其他字符串。由于我们已经在密码哈希中使用`argon2`，我们可以重用`argon2`crate来执行这些函数。添加以下行：
- en: '[PRE52]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After we set up the `Csrf` fairing, we can use it in the application. In `src/main.rs`,
    attach the fairing to the Rocket application:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们设置了`Csrf`公平性之后，我们可以在应用程序中使用它。在`src/main.rs`中，将公平性附加到Rocket应用程序：
- en: '[PRE53]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In `src/models/user.rs`, add a new field to contain the token sent from the
    form:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/user.rs`中添加一个新字段来包含从表单发送的令牌：
- en: '[PRE54]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `src/views/users/form.html.tera`, add the field to store the token string:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/views/users/form.html.tera`中添加一个字段来存储令牌字符串：
- en: '[PRE55]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we can modify `src/routes/user.rs`. Add the `Token` dependency:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以修改`src/routes/user.rs`。添加`Token`依赖项：
- en: '[PRE56]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can use `CsrfToken` as a request guard, pass the token to the template,
    and render the template as HTML:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将`CsrfToken`用作请求保护者，将令牌传递到模板中，并将模板作为HTML渲染：
- en: '[PRE57]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Modify the `create_user` function to verify the token and return if the hash
    does not match:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `create_user` 函数以验证令牌，如果哈希值不匹配则返回：
- en: '[PRE58]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Do the same with the `update_user`, `put_user`, and `patch_user` functions
    as well:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样对 `update_user`、`put_user` 和 `patch_user` 函数进行操作：
- en: '[PRE59]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: After that, try relaunching the application and sending the form without the
    token. We should see the application return an HTTP `403` status code. CSRF is
    one of the most common web attacks, but we have learned how to mitigate the attack
    by using Rocket features.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，尝试重新启动应用程序并发送不带令牌的表单。我们应该看到应用程序返回 HTTP `403` 状态码。CSRF 是最常见的网络攻击之一，但我们已经学习了如何通过使用
    Rocket 功能来减轻这种攻击。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about three things that are common for a web
    application. The first one is learning how to make the Rocket application serve
    static files by using either `PathBuf` or the `FileServer` struct.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了三个对于网络应用程序来说是常见的事情。第一点是学习如何通过使用 `PathBuf` 或 `FileServer` 结构来让 Rocket
    应用程序服务静态文件。
- en: Another thing we have learned is how to use `rocket_dyn_templates` to convert
    a template into a response to the client. We also learned about a template engine,
    Tera, and the various capabilities of the Tera template engine.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事是我们已经学到的，那就是如何使用 `rocket_dyn_templates` 将模板转换为客户端的响应。我们还了解了模板引擎 Tera 以及
    Tera 模板引擎的各种功能。
- en: 'By utilizing static assets and templates, we can easily create modern web applications.
    In the next chapter, we are going to learn about user posts: text, picture, and
    video.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用静态资源和模板，我们可以轻松地创建现代网络应用程序。在下一章中，我们将学习关于用户帖子：文本、图片和视频的内容。
