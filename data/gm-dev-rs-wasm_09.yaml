- en: '*Chapter 7*: Sound Effects and Music'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：音效和音乐'
- en: Take a moment and think of the game Tetris. If you're like me, you're probably
    already humming its theme song, *Korobeiniki*, because that song is so synonymous
    with the game itself. Beyond the appeal of music, sound effects are crucial for
    creating an immersive experience. We play games with more than just the touch
    of a keyboard or joystick and the use of our eyes; we hear Mario jump or Sonic
    catch a ring. While our game may be playable, it's just not a game without some
    sound. To play sound in our game, we'll need to learn how to use the browser's
    Web Audio API for both short and long sounds.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 抽空想想游戏俄罗斯方块。如果你像我一样，你可能已经哼起了它的主题曲《Korobeiniki》，因为这首歌与游戏本身如此同义。除了音乐的吸引力之外，音效对于创造沉浸式体验至关重要。我们玩游戏不仅仅是通过键盘或摇杆的触摸和我们的眼睛；我们听到马里奥跳跃或索尼克抓住一个圈。虽然我们的游戏可能是可玩的，但没有一些声音它就不是一个游戏。要在我们的游戏中播放声音，我们需要学习如何使用浏览器的
    Web Audio API 来播放短的和长的声音。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding the Web Audio API to the engine
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Web Audio API 添加到引擎中
- en: Playing sound effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音效
- en: Playing long music
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放长音乐
- en: By the end of this chapter, you won't just see RHB run, jump, and dodge obstacles,
    but you'll be able to hear him too after we add sound effects and music to our
    game. Let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你不仅会看到 RHB 跑、跳和躲避障碍，在我们为游戏添加音效和音乐后，你还将能够听到他的声音。让我们开始吧！
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements are largely unchanged from the previous chapters.
    You will need the `sound` assets from the `sound` directory in the assets download
    at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 技术要求与前面的章节基本相同。你需要从 [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)
    的资产下载中的 `sound` 目录获取 `sound` 资产。
- en: All sounds are from open sound collections and are used with permission. See
    the `sounds/credits.txt` file for more information. The code for this chapter
    is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_7](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_7).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有声音均来自开源声音集合，并已获得许可。更多信息请参阅 `sounds/credits.txt` 文件。本章的代码可在 [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_7](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_7)
    找到。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3JUdA2R](https://bit.ly/3JUdA2R)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://bit.ly/3JUdA2R](https://bit.ly/3JUdA2R)
- en: Adding the Web Audio API to the engine
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Web Audio API 添加到引擎中
- en: In this section, we'll be using the browser's Web Audio API to add sound to
    our game. The API is incredibly full-featured, allowing for mixing audio sources
    and special effects, but we're just going to use it to play background music and
    sounds. In fact, the Web Audio API is its own book and, if you're interested,
    you can find one at [https://webaudioapi.com/book/](https://webaudioapi.com/book/).
    While it would be fun to add things such as spatialized audio to our game, we're
    going to focus on just adding some music and sound effects. I encourage you to
    experiment on your own when making your own, more complicated games.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用浏览器的 Web Audio API 为我们的游戏添加声音。该 API 功能非常全面，允许混合音频源和特殊效果，但我们将仅使用它来播放背景音乐和声音。实际上，Web
    Audio API 是一本自己的书，如果你感兴趣，可以在 [https://webaudioapi.com/book/](https://webaudioapi.com/book/)
    找到。虽然添加诸如空间化音频到我们的游戏会很有趣，但我们将专注于添加一些音乐和音效。我鼓励你在制作自己的更复杂游戏时进行实验。
- en: Once we've got an overview of the Web Audio API, we'll create a module to play
    sounds in Rust, load the sounds in the same way as we load our images, and finally,
    add that sound to the engine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了 Web Audio API 的概览，我们将创建一个模块来在 Rust 中播放声音，以与加载我们的图片相同的方式加载声音，最后将那个声音添加到引擎中。
- en: The Web Audio API is a relatively new technology that is meant to replace older
    technology for audio, such as QuickTime and Flash, as well as being a more flexible
    solution than using audio elements. It's supported by all the major browsers,
    with only old versions of Internet Explorer being a potential problem. Given that
    the last release of Internet Explorer was in 2013, with Windows using the Edge
    browser instead, your game is probably okay with sacrificing that market.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Web Audio API是一种相对较新的技术，旨在取代旧的音频技术，如QuickTime和Flash，同时比使用音频元素提供更灵活的解决方案。它被所有主要浏览器支持，只有旧版本的Internet
    Explorer可能存在问题。鉴于Internet Explorer的最后一次发布是在2013年，Windows使用Edge浏览器代替，你的游戏可能不需要牺牲那个市场。
- en: 'The Web Audio API may initially look familiar when compared to Canvas. As with
    Canvas, you create a context that then provides an API for playing sounds. At
    that point, the similarity ends. Because the Web Audio API has all the features
    I mentioned earlier, it can be hard to figure out how to do the basic act of playing
    a sound. Unlike Canvas, there''s no `drawImage` equivalent called `playSound`
    or something like that. Instead, you have to get the sound data, create `AudioBufferSourceNode`,
    connect it to a destination, and then finally start it. This enables some really
    impressive effects (such as the ones found at [https://webaudiodemos.appspot.com/](https://webaudiodemos.appspot.com/))
    but means that, for our game, we''ll write the one-time code and forget all about
    it. In JavaScript, the code to load and prepare a sound for playback looks like
    the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与Canvas相比，Web Audio API可能一开始看起来很熟悉。与Canvas一样，你创建一个上下文，然后它提供了一个用于播放声音的API。在那个点上，相似之处就结束了。因为Web
    Audio API具有我之前提到的所有功能，所以很难弄清楚如何进行基本的播放声音操作。与Canvas不同，没有`drawImage`等价物称为`playSound`或类似的东西。相反，你必须获取声音数据，创建`AudioBufferSourceNode`，将其连接到目的地，然后最后启动它。这可以实现一些非常令人印象深刻的效果（例如在[https://webaudiodemos.appspot.com/](https://webaudiodemos.appspot.com/)上找到的），但对于我们的游戏来说，我们将编写一次性的代码，然后把它忘掉。在JavaScript中，加载和准备声音以供播放的代码如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It starts by creating a new `AudioContext`, which is built into the browser
    engine, then fetching a sound file from the server. The `fetch` call eventually
    returns a response, which we'll need to decode. We do this by first getting its
    `arrayBuffer`, which consumes it, and then we use the `audioContext` we created
    at the beginning to decode the buffer into a sound that can be played. Note how
    everything is asynchronous, which will cause us a little trouble in the Rust code
    as we map JavaScript promises to Rust futures. The previous code should only be
    done *once* for any sound resource since loading and decoding the file can take
    significant time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先创建一个新的`AudioContext`，这是内置在浏览器引擎中的，然后从服务器获取声音文件。`fetch`调用最终返回一个响应，我们需要对其进行解码。我们首先获取它的`arrayBuffer`，这会消耗它，然后我们使用我们最初创建的`audioContext`将缓冲区解码成可以播放的声音。注意，一切都是异步的，这将在我们将JavaScript承诺映射到Rust未来时给我们带来一点麻烦。之前的代码对于任何声音资源只应该执行一次，因为加载和解码文件可能需要很长时间。
- en: 'The following code will play a sound:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将播放声音：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ugh, that's not intuitive, but it's what we have. Fortunately, we can wrap it
    in a few simple functions that we'll be able to remember, and forget all about
    it. It creates the `AudioBufferSourceNode` we need with `createBufferSource`,
    assigns it the array that we decoded into audio data in the previous section,
    connects it to the `audioContext`, and finally, plays the sound with `start`.
    It's important to know that you cannot call `start` on `trackSource` twice, but
    fortunately, the creation of a buffer source is very fast and won't require us
    to cache it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这不太直观，但我们只能这样。幸运的是，我们可以用几个简单的函数把它包装起来，这样我们就能记住它，然后把它忘掉。它通过`createBufferSource`创建我们需要的`AudioBufferSourceNode`，将其分配给我们在上一节解码成音频数据的数组，连接到`audioContext`，最后用`start`播放声音。重要的是要知道，你不能对`trackSource`两次调用`start`，但幸运的是，缓冲源创建非常快，不需要我们缓存它。
- en: That's great! We know the eight lines of code to play a sound in JavaScript,
    but how do we get this into our engine?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们知道在JavaScript中播放声音的八行代码，但我们如何将其放入我们的引擎中？
- en: Playing a sound in Rust
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Rust中播放声音
- en: We're going to create a `sound` module that's very similar to our `browser`
    module, a series of functions that just delegate right to the underlying JavaScript.
    It will be a very bottom-up approach, where we'll create our utility functions
    and then create the final functions that use them. We'll start by focusing on
    the parts we need for a `play_sound` function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`sound`模块，它与我们的`browser`模块非常相似，一系列只是将权利委托给底层JavaScript的函数。这将是一个自下而上的方法，我们将创建我们的实用函数，然后创建使用它们的最终函数。我们将首先关注`play_sound`函数所需的各个部分。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you want these functions to be very small – it's a *thin* layer
    between Rust and JavaScript – but also to change the interface to better match
    what you want to do. So, eventually, rather than talking about buffer sources
    and contexts, we'll want to call that `play_sound` function we wish existed in
    the first place.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你希望这些函数非常小——这是Rust和JavaScript之间的*薄层*——但也要改变接口以更好地匹配你想要做的事情。所以，最终，我们不会谈论缓冲源和上下文，而是会调用我们最初希望存在的`play_sound`函数。
- en: 'We''ll start by creating the module in a file named `sound.rs` living alongside
    the rest of our modules in `src`. Don''t forget to add a reference to it in `src/lib.rs`,
    as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在名为`sound.rs`的文件中创建模块，这个文件位于`src`目录中我们其他模块旁边。别忘了在`src/lib.rs`中添加对其的引用，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That''s the part I always forget. Our first function will create an `AudioContext`
    in a *Rusty* way as opposed to the JavaScript way we already saw, and that''s
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我总是忘记的部分。我们的第一个函数将以一种*Rusty*的方式创建`AudioContext`，而不是我们已经看到的JavaScript方式，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As usual, the Rust version of the code is more verbose than the JavaScript
    version. That''s the price we pay for the positives of Rust. None of this code
    is particularly new; we''re mapping `new AudioContext` to `AudioContext::new`,
    and we''re mapping the `JsResult` error to an `anyhow` result that it might return,
    to be more Rust-friendly. This code doesn''t compile though; take a moment and
    think about why. It''s the infamous feature flags for `web-sys` in `Cargo.toml`
    that we haven''t added `AudioContext` to, so let''s add that now:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，Rust版本的代码比JavaScript版本更冗长。这是我们为Rust的优点所付出的代价。这些代码并没有什么特别新颖的地方；我们正在将`new
    AudioContext`映射到`AudioContext::new`，并将`JsResult`错误映射到可能返回的`anyhow`结果，使其更符合Rust的风格。然而，这段代码无法编译；花点时间思考一下原因。这是臭名昭著的`Cargo.toml`中`web-sys`的功能标志，我们还没有添加`AudioContext`，所以现在就添加它：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Documentation for the `AudioContext` bindings can be found at [https://bit.ly/3tv5PsD](https://bit.ly/3tv5PsD).
    Remember you can search the `web-sys` documentation for any JavaScript object
    to find its corresponding Rust library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioContext`绑定的文档可以在[https://bit.ly/3tv5PsD](https://bit.ly/3tv5PsD)找到。记住，你可以搜索`web-sys`文档中的任何JavaScript对象，以找到其对应的Rust库。'
- en: Tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Depending on your editor of choice, you may need to restart `rust-analyzer`
    to get correct compiler errors and code actions when adding a new file to the
    project (such as `sound.rs`) and/or adding feature flags to the `Cargo.toml` file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你选择的编辑器，你可能需要在向项目添加新文件（如`sound.rs`）和/或将功能标志添加到`Cargo.toml`文件时重新启动`rust-analyzer`，以获得正确的编译错误和代码操作。
- en: 'Now that we''ve set up the `sound` module, created the function to create `AudioContext`,
    and refreshed our memory on the process of adding a new feature to the `web-sys`
    dependency, we can go ahead and add a little more code to play sounds. Let''s
    introduce all the remaining feature flags you''ll need to add to `web-sys` in
    `Cargo.toml`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了`sound`模块，创建了创建`AudioContext`的函数，并且回顾了向`web-sys`依赖项添加新功能的过程，我们可以继续添加一些代码来播放声音。让我们介绍所有需要添加到`Cargo.toml`中的剩余功能标志：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The three features, `AudioBuffer`, `AudioBufferSourceNode`, and `AudioDestinationNode`,
    correspond to those same objects in the original JavaScript code. For instance,
    the `let trackSource = audioContext.createBufferSource();` function returned `AudioBufferSourceNode`.
    The `web-sys` authors have chosen to hide a large number of audio features under
    individual flags, so we need to name them one at a time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个功能，`AudioBuffer`、`AudioBufferSourceNode`和`AudioDestinationNode`，对应于原始JavaScript代码中的相同对象。例如，`let
    trackSource = audioContext.createBufferSource();`函数返回`AudioBufferSourceNode`。`web-sys`的作者选择将大量音频功能隐藏在单个标志下，因此我们需要逐个命名它们。
- en: Tip
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Remember to check the feature flags whenever you can''t use a `web-sys` feature.
    It''s always listed in the documentation with a note such as "This API requires
    the following crate features to be activated: `AudioContext`."'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在无法使用`web-sys`功能时检查功能标志。它总是在文档中列出，并带有如下注释：“此API需要以下crate功能被激活：`AudioContext`。”
- en: 'Now that we have the features ready, we can add the rest of the code without
    worrying about those errors. Back in the `sound` module, the code will look like
    this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了功能，我们可以添加剩余的代码，而不必担心那些错误。回到`sound`模块，代码将看起来像这样：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this book, we've typically gone through the code one function at a time,
    but for these two it's not necessary. These functions correspond to the calls
    to `audioContext.createBufferSource` and `trackSource.connect(audioContext.destionation)`
    respectively. We've converted the code from the object-oriented style of JavaScript
    into a slightly more procedural format with the functions taking parameters, in
    part so that we can map errors from the `JsValue` types into proper Rust `Error`
    types via the `anyhow!` macro.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们通常一次通过一个函数来查看代码，但对于这两个函数来说，这不是必要的。这些函数分别对应于`audioContext.createBufferSource`和`trackSource.connect(audioContext.destination)`的调用。我们将代码从JavaScript的面向对象风格转换为稍微更过程化的格式，函数接受参数，部分原因是为了能够通过`anyhow!`宏将`JsValue`类型中的错误映射到适当的Rust
    `Error`类型。
- en: 'Now that we have the three functions, we need to play a sound. We can go ahead
    and write the function that plays it right below them, shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了三个函数，我们需要播放一个声音。我们可以继续编写紧随其后的播放函数，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `play_sound` function accepts `AudioContext` and `AudioBuffer` as parameters,
    then returns the result of the `start` call, with `JsValue` mapped to `Error`.
    We haven''t created an `AudioBuffer` yet anywhere, so don''t worry that you don''t
    know how to as we''ll cross that bridge when we come to it. What we have here
    is a function that is very similar to the original JavaScript for playing a sound,
    but with the additional error handling that comes with Rust, including using the
    `?` operator to make it easier to read, and a little bit of additional work around
    `None` in the `track_source.set_buffer(Some(&buffer));` line, where we need to
    wrap a reference to `AudioBuffer` in `Some` because `track_source` has an optional
    buffer. In JavaScript, this is `null` or `undefined`, but in Rust, we need to
    use the `Option` type. Otherwise, both the JavaScript and Rust versions do the
    same thing to play a sound:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`play_sound`函数接受`AudioContext`和`AudioBuffer`作为参数，然后返回`start`调用的结果，将`JsValue`映射到`Error`。我们还没有在任何地方创建`AudioBuffer`，所以不必担心你不知道如何创建，因为我们将在需要的时候解决这个难题。这里有一个与原始JavaScript播放声音非常相似的功能，但增加了Rust带来的错误处理，包括使用`?`操作符使其更容易阅读，以及在`track_source.set_buffer(Some(&buffer));`行中围绕`None`进行的一点点额外工作，因为我们需要在`Some`中包装`AudioBuffer`的引用，因为`track_source`有一个可选的缓冲区。在JavaScript中，这是`null`或`undefined`，但在Rust中，我们需要使用`Option`类型。否则，JavaScript和Rust版本在播放声音时做的是同样的事情：'
- en: Create `AudioBufferSource` from `AudioContext`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AudioContext`创建`AudioBufferSource`。
- en: Set `AudioBuffer` on the source.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源上设置`AudioBuffer`。
- en: Connect `AudioBufferSource` to the `AudioContext` destination.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AudioBufferSource`连接到`AudioContext`的目标。
- en: Call `start` to play the sound.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`start`来播放声音。
- en: This seems like a lot, but in reality, it's very fast, so there's not much use
    in caching `AudioBufferSource`, especially since you can only call `start` once.
    Now that we can play a sound, it's time to load a sound resource and decode it,
    so that we have an `AudioBuffer` to play. Let's do that now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很多，但实际上非常快，所以缓存`AudioBufferSource`没有太大的用处，特别是因为你只能调用一次`start`。现在我们可以播放声音了，是时候加载声音资源并解码它，以便我们有`AudioBuffer`来播放。让我们现在就做吧。
- en: Loading the sound
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载声音
- en: 'To load a sound from the server, we''ll need to translate the following code,
    which you''ve already seen, into Rust:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要从服务器加载声音，我们需要将以下代码翻译成Rust，这些代码你已经见过：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Fetching the resource is something we can already do in our `browser` module,
    but we don''t have a handy way to get its `arrayBuffer`, so we''ll need to add
    that. We''ll also need to create a Rust version of `decodeAudioData`. Let''s start
    with the changes we need to add to `browser`, which are modifications to existing
    methods. We''ll want to split the old `fetch_json` function, which looks like
    this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 获取资源是我们已经在我们的`browser`模块中可以做到的事情，但我们没有一种方便的方法来获取它的`arrayBuffer`，所以我们需要添加这个功能。我们还需要创建一个Rust版本的`decodeAudioData`。让我们从需要添加到`browser`中的更改开始，这些是现有方法的修改。我们希望将旧的`fetch_json`函数拆分，如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We need to split it into two functions that first fetch `Result<Response>`,
    then a second that converts it into JSON:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其拆分为两个函数，第一个函数首先获取 `Result<Response>`，第二个函数将其转换为 JSON：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a classic case of *the second person pays for abstraction*, where we
    wrote the code we needed in [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038),
    *Drawing Sprites*, to load JSON, but now we need a version of `fetch` that can
    handle multiple kinds of responses, specifically, sound files that will be accessible
    as an `ArrayBuffer` instead. That code will need `fetch_response` but will convert
    it into a different object. Let''s write that code now, right below `fetch_json`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的“第二个人为抽象付费”的案例，我们在 [*第二章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)
    “绘制精灵”中编写的代码，用于加载 JSON，但现在我们需要一个可以处理多种响应的 `fetch` 版本，特别是那些可以作为 `ArrayBuffer` 访问的声音文件。这段代码将需要
    `fetch_response`，但会将其转换为不同的对象。现在，让我们编写这段代码，就在 `fetch_json` 下方：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just as `fetch_json` does, this starts by calling `fetch_response` with the
    passed-in resource. Then, it calls the `array_buffer()` function on that response,
    which will return a promise that resolves to `ArrayBuffer`. Then, we convert from
    a promise to `JsFuture` as usual, in order to use the `await` syntax. Finally,
    we call `dyn_into` to convert the `JsValue` that all `Promise` types return into
    `ArrayBuffer`. I've skipped over it, but at each step, we use `map_err` to convert
    the `JsValue` errors into `Error` types.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `fetch_json` 一样，它首先通过传入的资源调用 `fetch_response`。然后，它调用响应上的 `array_buffer()`
    函数，这将返回一个解析为 `ArrayBuffer` 的承诺。然后，我们像往常一样将承诺转换为 `JsFuture`，以便使用 `await` 语法。最后，我们调用
    `dyn_into` 将所有 `Promise` 类型返回的 `JsValue` 转换为 `ArrayBuffer`。我跳过了它，但在每个步骤中，我们都使用
    `map_err` 将 `JsValue` 错误转换为 `Error` 类型。
- en: The `ArrayBuffer` type is a JavaScript type that isn't available to our code
    yet. It's a core JavaScript type, defined in the ECMAScript standard, and in order
    to use it directly, we need to add the `js-sys` crate. This is somewhat surprising,
    as we are already pulling in `wasm-bindgen` and `web-sys`, which are both dependent
    on JavaScript, so why do we need to pull in yet another crate for `ArrayBuffer`?
    This has to do with how the various crates are arranged. The `web-sys` crate has
    all the web APIs where `js-sys` is limited to code that is in the ECMAScript standard.
    Up to now, we haven't had to use anything in core JavaScript except what was exposed
    by `web-sys`, but this changes with `ArrayBuffer`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBuffer` 类型是 JavaScript 的一种类型，目前我们的代码还无法使用。它是一个核心 JavaScript 类型，定义在 ECMAScript
    标准 中，为了直接使用它，我们需要添加 `js-sys` 包。这有些令人惊讶，因为我们已经引入了 `wasm-bindgen` 和 `web-sys`，这两个包都依赖于
    JavaScript，那么为什么我们还需要为 `ArrayBuffer` 引入另一个包呢？这与各种包的排列方式有关。`web-sys` 包包含了所有的 Web
    API，而 `js-sys` 只限于 ECMAScript 标准中的代码。到目前为止，我们除了 `web-sys` 暴露的内容外，还没有使用过核心 JavaScript
    中的任何东西，但现在随着 `ArrayBuffer` 的出现，这种情况发生了变化。'
- en: In order for this code to compile, you'll need to add `js-sys = "0.3.55"` to
    the list of dependencies in `Cargo.toml`. It is already in `dev-dependencies`,
    so you can just move it from there. You'll also need to add a `use` `js_sys::ArrayBuffer`
    declaration to import the `ArrayBuffer` struct`.`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码能够编译，您需要在 `Cargo.toml` 中的依赖项列表中添加 `js-sys = "0.3.55"`。它已经在 `dev-dependencies`
    中，所以您只需将其从那里移动即可。您还需要添加一个 `use` `js_sys::ArrayBuffer` 声明来导入 `ArrayBuffer` 结构体。
- en: Tip
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The various libraries are likely to change in small ways after the publication
    of this book. If you have any difficulties with these dependencies, check the
    documentation at [https://github.com/rustwasm/wasm-bindgen](https://github.com/rustwasm/wasm-bindgen).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书出版后，各种库可能会以小的方式发生变化。如果您在使用这些依赖项时遇到任何困难，请检查 [https://github.com/rustwasm/wasm-bindgen](https://github.com/rustwasm/wasm-bindgen)
    的文档。
- en: 'Now that we can fetch a sound file and get it as an `ArrayBuffer`, we''re ready
    to write our version of `await audioContext.decodeAudioData(soundBuffer)`. By
    now, you may have noticed that we''re following the same pattern for wrapping
    every JavaScript function like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以获取声音文件并将其作为 `ArrayBuffer` 获取，我们就可以编写我们自己的 `await audioContext.decodeAudioData(soundBuffer)`
    版本了。到现在为止，你可能已经注意到我们正在遵循相同的模式来包装每个 JavaScript 函数：
- en: Convert any function that returns a promise, such as `decode_audio_data`, into
    `JsFuture` so you can use it in asynchronous Rust code.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何返回承诺的函数，如 `decode_audio_data`，转换为 `JsFuture`，以便您可以在异步 Rust 代码中使用它。
- en: Map any errors from `JsValue` into your own error types; in this case, we're
    using `anyhow::Result` but you may want more specific errors.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `JsValue` 中的任何错误映射到您自己的错误类型中；在这种情况下，我们使用 `anyhow::Result`，但你可能需要更具体的错误。
- en: Use the `?` operator to propagate errors.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `?` 操作符来传播错误。
- en: Check for feature flags, particularly when using `web_sys` and you just *know*
    a library exists.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查特性标记，尤其是在使用 `web_sys` 并且你确信一个库存在时。
- en: To this, we'll add one more step.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们再添加一个步骤。
- en: Cast from `JsValue` types to more specific types using the `dyn_into` function.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dyn_into` 函数将 `JsValue` 类型转换为更具体的类型。
- en: 'Following that same pattern, the Rust version of `decodeAudioData` goes in
    the `sound` module, like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的模式，Rust 版本的 `decodeAudioData` 放在 `sound` 模块中，如下所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You'll need to make sure you add `use` declarations for `js_sys::ArrayBuffer`
    and `wasm_bindgen_futures::JsFuture`, and also `wasm_bindgen::JsCast` to bring
    the `dyn_into` function into scope. Once again instead of directly calling the
    method on `AudioContext`, in this case `decodeAudioData`, we've created a function
    that wraps the call. It borrows a reference to `AudioContext` as the first parameter
    and takes the `ArrayBuffer` type as the second parameter. This allows us to encapsulate
    the mapping of errors and casting of results into a function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保添加对 `js_sys::ArrayBuffer` 和 `wasm_bindgen_futures::JsFuture` 以及 `wasm_bindgen::JsCast`
    的 `use` 声明，以便将 `dyn_into` 函数引入作用域。再次提醒，我们不是直接在 `AudioContext` 上调用方法，在这个例子中是 `decodeAudioData`，而是创建了一个封装调用的函数。该函数将
    `AudioContext` 的引用作为第一个参数，并将 `ArrayBuffer` 类型作为第二个参数。这使得我们可以将错误映射和结果转换封装到函数中。
- en: This function then delegates to `ctx.decode_audio_data`, passing it `ArrayBuffer`,
    but if that's all it did we wouldn't really need it. It then takes any error from
    `ctx.decode_audio_data` and maps it to `Error` with `anyhow!`; in fact, as you
    can see, it will ultimately do this at every step in the process, pairing that
    with the `?` operator to propagate the error. It takes a promise from `decode_audio_data`
    and creates `JsFuture` from it, then immediately calls `await` to wait for completion,
    corresponding to the `await` call in JavaScript. After handling any errors converting
    the promise to `JsFuture`, we use the `dyn_into` function to cast it to `AudioBuffer`,
    ultimately handling any errors with that as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数随后将 `ctx.decode_audio_data` 作为参数传递，并传递 `ArrayBuffer`，但如果它只是这样做，我们实际上并不需要它。然后它将
    `ctx.decode_audio_data` 中的任何错误映射到 `Error` 上，使用 `anyhow!`；实际上，正如你所看到的，它将在处理过程中的每个步骤都这样做，并与
    `?` 操作符配对以传播错误。它从 `decode_audio_data` 中获取一个承诺，并从中创建 `JsFuture`，然后立即调用 `await`
    以等待完成，对应于 JavaScript 中的 `await` 调用。在处理将承诺转换为 `JsFuture` 的任何错误后，我们使用 `dyn_into`
    函数将其转换为 `AudioBuffer`，最终处理任何相关的错误。
- en: 'That function is the most complicated of the wrapper functions, so let''s reiterate
    the steps we did when translating from one line of JavaScript to nine lines of
    Rust:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是所有封装函数中最复杂的，所以让我们回顾一下从一行 JavaScript 转换为九行 Rust 时所采取的步骤：
- en: Convert any function that returns a promise into `JsFuture` so you can use it
    in asynchronous Rust code.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何返回承诺的函数转换为 `JsFuture`，以便你可以在异步 Rust 代码中使用它。
- en: In this case, `decode_audio_data` returned a promise, and we converted it into
    `JsFuture` with `JsFuture::from`, then immediately called `await` on it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`decode_audio_data` 返回了一个承诺，我们使用 `JsFuture::from` 将其转换为 `JsFuture`，然后立即调用
    `await`。
- en: Map any errors from `JsValue` into your own error type; in this case, we're
    using `anyhow::Result`, but you may want more specific errors.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `JsValue` 中的任何错误映射到你的自定义错误类型；在这种情况下，我们使用 `anyhow::Result`，但你可能需要更具体的错误。
- en: We did this three times, as every call seemed to return a `JsValue` version
    of the result, adding clarifying language to the error messages.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做三次，因为每个调用似乎都返回一个 `JsValue` 版本的结果，我们在错误信息中添加了说明性语言。
- en: Cast from `JsValue` types to more specific types using the `dyn_into` function.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dyn_into` 函数将 `JsValue` 类型转换为更具体的类型。
- en: We did this to convert the ultimate result of `decode_audio_data` from `JsValue`
    to `AudioBuffer`, and Rust's compiler could infer the appropriate type from the
    return value of the function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了将 `decode_audio_data` 的最终结果从 `JsValue` 转换为 `AudioBuffer`，并且 Rust 的编译器可以从函数的返回值推断出适当的数据类型。
- en: Don't forget to use the `?` operator to propagate errors; note how this function
    does that twice.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记使用 `?` 操作符来传播错误；注意这个函数是如何两次做到这一点的。
- en: We used the `?` operator twice to make the function easier to read.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `?` 操作符两次，使函数更容易阅读。
- en: Check for feature flags, particularly when using `web_sys` and you just *know*
    a library exists.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查特性标记，尤其是在使用 `web_sys` 并且你确信一个库存在时。
- en: '`AudioBuffer` is feature flagged, but we added that back at the beginning.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioBuffer` 是特性标记的，但我们又在开始时将其添加了回来。'
- en: This process is a bit more complicated to explain than it is in practice. For
    the most part, you can follow the compiler and use tools such as `rust-analyzer`
    to do things such as automatically add `use` declarations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程比实际操作要复杂一些。大部分情况下，你可以遵循编译器并使用像`rust-analyzer`这样的工具来自动添加`use`声明。
- en: Now that we've got all the utilities, we need to play a sound. It's time to
    add that feature to the `engine` module so our game can use it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有这些实用工具，我们需要播放一个声音。是时候将这个功能添加到`engine`模块中，以便我们的游戏可以使用它。
- en: Adding audio to the engine
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将音频添加到引擎中
- en: 'The functions we just created in the `sound` module could be used by the engine
    directly via delegation functions, but we don''t want to make the game worry about
    `AudioContext`, `AudioBuffer`, and things like that. Just like `Renderer`, we''ll
    create an `Audio` struct that encapsulates the details of that implementation.
    We''ll also create a `Sound` struct to convert `AudioBuffer` into a friendlier
    type for the rest of the system. Those will be very small, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`sound`模块中刚刚创建的函数可以直接通过委托函数由引擎使用，但我们不想让游戏担心`AudioContext`、`AudioBuffer`和类似的东西。就像`Renderer`一样，我们将创建一个`Audio`结构体来封装该实现的细节。我们还将创建一个`Sound`结构体，将`AudioBuffer`转换为对整个系统更友好的类型。这些结构体将会非常小，如下所示：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These structs are added to the bottom of the `engine` module, but they can really
    be put anywhere in the file. Don't forget to import `AudioContext` and `AudioBuffer`!
    If you're finding yourself getting confused as `engine` and `game` get larger,
    you're welcome to break that up into multiple files with a `mod.rs` file and a
    directory, but to follow along, everything needs to end up in the `engine` module.
    I'm not going to do that because, while it makes the code a bit easier to navigate,
    it makes it harder to explain and follow along with. Breaking it up into smaller
    chunks later is an excellent exercise to make sure you understand the code we're
    writing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构体被添加到`engine`模块的底部，但它们实际上可以放在文件的任何地方。别忘了导入`AudioContext`和`AudioBuffer`！如果你发现自己随着`engine`和`game`的增大而感到困惑，你可以通过创建一个`mod.rs`文件和目录将其拆分成多个文件，但为了跟上进度，所有内容都需要最终放在`engine`模块中。我不会这样做，因为虽然这样做可以使代码更容易导航，但它会使解释和跟进变得更加困难。稍后将其拆分成更小的块是一个很好的练习，以确保你理解我们正在编写的代码。
- en: 'Now that we have a struct representing `Audio` holding `AudioContext`, and
    a corresponding `Sound` holding `AudioBuffer`, we can add `impl` to `Audio`, which
    uses the functions we wrote earlier to play a sound. Now, we''ll want to add `impl`
    to the `Audio` struct to play sounds and load them. Let''s start with the load
    implementation, which is probably the hardest, as seen here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个表示`Audio`并持有`AudioContext`的结构体，以及一个相应的`Sound`结构体，它持有`AudioBuffer`，我们可以向`Audio`添加`impl`，使用我们之前编写的函数来播放声音。现在，我们将向`Audio`结构体添加`impl`来播放和加载声音。让我们从加载实现开始，这可能是最难的，如下所示：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `impl` will start with two methods, the familiar `new` method that creates
    an `Audio` struct with `AudioContext`. Pay attention to the fact that `new` returns
    a result in this case, because `create_audio_context` can fail. Then, we have
    the `load_sound` method, which also returns a result, this time of the `Sound`
    type, which is only three lines. This is a sign we did something right with the
    way we organized our functions in the `sound` and `browser` modules, as we can
    simply call our `fetch_array_buffer` and `decode_audio_data` functions to get
    `AudioBuffer` and then wrap it in a `Sound` struct. We return a result and propagate
    errors via `?`. If loading a sound was simple, then playing it is easy in this
    method on the `Audio` implementation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`impl`将从两个方法开始，一个是熟悉的`new`方法，它使用`AudioContext`创建一个`Audio`结构体。请注意，在这种情况下`new`返回一个结果，因为`create_audio_context`可能会失败。然后，我们有`load_sound`方法，它也返回一个结果，这次是`Sound`类型，只有三行。这是我们正确组织`sound`和`browser`模块中的函数的一个迹象，因为我们只需简单地调用我们的`fetch_array_buffer`和`decode_audio_data`函数来获取`AudioBuffer`，然后将其包装在一个`Sound`结构体中。我们返回一个结果并通过`?`传播错误。如果加载声音很简单，那么在这个`Audio`实现的方法中播放它就很容易：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For `play_sound`, we really just delegate, passing along `AudioContext` that
    `Audio` holds and `AudioBuffer` from the passed-in sound.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`play_sound`，我们实际上只是委托，传递`Audio`持有的`AudioContext`和从传入的声音中获取的`AudioBuffer`。
- en: We've written a module to play sounds in the API, added loading sounds to the
    browser, and finally created an audio portion of our game engine. That's enough
    to play a sound effect in the engine; now we need to add it to our game, and here
    it's going to get complicated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个模块来在API中播放声音，添加了加载声音到浏览器，并最终创建了游戏引擎的音频部分。这足以在引擎中播放音效；现在我们需要将其添加到我们的游戏中，这将会变得复杂。
- en: Playing sound effects
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音效
- en: 'Adding sound effects to our game is a challenge for several reasons:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将音效添加到我们的游戏是一个挑战，原因有几个：
- en: 'Effects must only occur once:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效果必须只发生一次：
- en: 'We''ll be adding a sound effect for jumping (*boing!*) and want to make sure
    that it only happens one time. Fortunately, we have something for that already,
    our state machine! We can use `RedHatBoyContext` to play a sound when something
    happens, something like this (don''t add it yet):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为跳跃（*boing!*）添加音效，并确保它只发生一次。幸运的是，我们已经有了一个解决方案，那就是我们的状态机！我们可以使用`RedHatBoyContext`在发生某些事情时播放声音，如下所示（现在不要添加它）：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This leads directly into our second challenge.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接引出了我们的第二个挑战。
- en: 'Playing audio on transitions:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过渡时播放音频：
- en: We want to play the sound at the moment of transition, but most transitions
    won't play a sound. Remember our state machine uses `transition` to transition
    from one event to another, and while we could pass in the audio there it would
    only be used by a small portion of the code in that method. It's a code smell,
    so we won't do that. `RedHatBoyContext` will have to own the audio and the sound.
    This isn't ideal, we'd prefer there to be only one audio in the system, but that's
    not workable with our state machine. That leads to our third problem.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在过渡时刻播放声音，但大多数过渡不会播放声音。记住我们的状态机使用`transition`从一个事件过渡到另一个事件，虽然我们可以在那里传递音频，但它只会被该方法中一小部分代码使用。这是一个代码问题，所以我们不会这样做。`RedHatBoyContext`将必须拥有音频和声音。这不是理想的，我们更希望系统中只有一个音频，但这对我们的状态机来说不可行。这导致了我们的第三个问题。
- en: '`AudioContext` and `AudioBuffer` are not `Copy`:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioContext`和`AudioBuffer`不是`Copy`：'
- en: In order to use syntax such as `self.state = self.state.jump();` in the `RedHatBoy`
    implementation and have each state transition consume `RedHatBoyContext`, we needed
    `RedHatBoyContext` to be `Copy`. Unfortunately, `AudioContext` and `AudioBuffer`
    are not `Copy`, which means `Audio` and `Sound` cannot be `Copy` and, therefore,
    if `RedHatBoyContext` is going to hold audio and a sound, it cannot also be a
    copy. This stinks, but we can fix it by refactoring `RedHatBoyContext` and `RedHatBoy`
    to use the `clone` function as needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`RedHatBoy`实现中使用`self.state = self.state.jump();`这样的语法，并让每个状态过渡消耗`RedHatBoyContext`，我们需要`RedHatBoyContext`是`Copy`。不幸的是，`AudioContext`和`AudioBuffer`不是`Copy`，这意味着`Audio`和`Sound`不能是`Copy`，因此，如果`RedHatBoyContext`要持有音频和声音，它也不能是一个副本。这很糟糕，但我们可以通过重构`RedHatBoyContext`和`RedHatBoy`以使用所需的`clone`函数来修复它。
- en: Having `RedHatBoyContext` own an audio means that there will be more than one
    `Audio` object in the system potentially, where the other will play music. This
    is redundant but mostly harmless, so it's the solution we'll go with. It gets
    us moving forward with development, and in the end, the solution works well. When
    in doubt, choose the solution that ships.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让`RedHatBoyContext`拥有音频意味着系统中可能存在多个`Audio`对象，其中另一个将播放音乐。这是多余的，但大多数情况下是无害的，所以我们选择这个解决方案。它使我们能够继续开发，最终，这个解决方案效果很好。如果有疑问，选择现成的解决方案。
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may wonder why we don't store a reference to `Audio` in `RedHatBoyContext`.
    Ultimately, `Game` is static in our engine, and therefore, an `Audio` reference
    must be guaranteed to live as long as `Game` if it's stored as a reference on
    `RedHatBoyContext`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能会想知道为什么我们不在`RedHatBoyContext`中存储`Audio`的引用。最终，在我们的引擎中`Game`是静态的，因此，如果将`Audio`引用存储在`RedHatBoyContext`上，它必须保证与`Game`一样长命。 '
- en: There are other options, including using the service locator pattern ([https://bit.ly/3A4th2f](https://bit.ly/3A4th2f))
    or passing in the audio into the `update` function as a parameter, but they all
    take longer to get us to our end goal of playing a sound, which is the real goal
    of this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他选项，包括使用服务定位器模式([https://bit.ly/3A4th2f](https://bit.ly/3A4th2f))或将音频作为参数传递到`update`函数中，但它们都需要更长的时间才能达到我们的最终目标——播放声音，这是本章的真实目标。
- en: Before we can add a sound effect to the game, we're going to refactor the code
    to hold an `Audio` element. Then we'll play the sound effect.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将音效添加到游戏中之前，我们需要重构代码以包含一个`Audio`元素。然后我们将播放音效。
- en: Refactoring RedHatBoyContext and RedHatBoy
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构RedHatBoyContext和RedHatBoy
- en: 'We''re going to prepare `RedHatBoyContext` and `RedHatBoy` to hold audio and
    a song before we actually do it because that will make it easier to add the sound.
    Let''s start by making `RedHatBoyContext` just `clone`, as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正这样做之前，我们将准备`RedHatBoyContext`和`RedHatBoy`来存储音频和一首歌，因为这会使添加声音更容易。让我们首先将`RedHatBoyContext`设置为`clone`，如下所示：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All we''ve done is removed the `Copy` trait from the `derive` declaration.
    This will cause compiler errors on `RedHatBoyStateMachine` and `RedHatBoyState<S>`,
    which both derive `Copy`, so you''ll need to remove that declaration on those
    structures as well. Once you''ve done that, you''ll see a bunch of errors like
    this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的一切就是从`derive`声明中移除了`Copy`特质。这将在`RedHatBoyStateMachine`和`RedHatBoyState<S>`上引起编译错误，这两个结构都派生了`Copy`，因此你还需要从这些结构中移除那个声明。一旦你这样做，你将看到一大堆类似这样的错误：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As expected, the calls to `self.state.<method>`, where the method takes `self`,
    all fail to compile, because `RedHatBoyStateMachine` doesn''t implement `Copy`
    anymore. The solution, and we''ll do this on every line with this compiler error,
    is to explicitly clone the state when we want to make the change. Here''s the
    `run_right` function with the error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，调用`self.state.<method>`，其中方法接受`self`，所有调用都未能编译，因为`RedHatBoyStateMachine`不再实现`Copy`。解决方案，我们将在每一行遇到这个编译错误时这样做，就是在我们需要进行更改时显式地克隆状态。以下是带有错误的`run_right`函数：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And, here it is with the fix:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这是修复后的结果：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Perhaps the most teeth-grindingly offensive instance of this is in the `transition`
    method, where we will get a move because of the `match` statement, shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最令人牙痒痒的例子是在`transition`方法中，我们将因为`match`语句而得到一个移动，如下所示：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The trouble with this section is that `self` is moved into the `match` statement
    and cannot be returned in the default case. Trying to use `match` and `self` to
    get around the issue causes all of the typestate methods, such as `land_on` and
    `knock_out`, to fail because they need to consume `self`. The *cleanest* fix is
    shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分的问题在于`self`被移动到了`match`语句中，并且在默认情况下无法返回。试图使用`match`和`self`来解决这个问题会导致所有的类型状态方法，例如`land_on`和`knock_out`，失败，因为它们需要消耗`self`。*最干净*的修复方法如下所示：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It's gross, I admit, but we are able to keep progressing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认这很糟糕，但我们能够继续进步。
- en: Tip
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: I know what you're thinking – performance! We're cloning on each transition!
    You're absolutely right, but do you know that the performance is adversely impacted?
    The first rule of performance is *measure first*, and until we measure this, we
    don't actually know if the final version of this code is a problem. I spent a
    lot of time trying to avoid this `clone` call because of performance concerns,
    and it turned out not to make much of a difference at all. Make it work, then
    make it fast.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么——性能！我们在每个转换时都在克隆！你完全正确，但你知道性能会受到负面影响吗？性能的第一条规则是*先测量*，在我们测量这个之前，我们实际上不知道这个代码的最终版本是否是问题。我花了很多时间试图避免这个`clone`调用，因为担心性能问题，结果发现这并没有多大影响。先让它工作，然后再让它变得更快。
- en: Once you fix that error a few times, you're ready to add the audio and the sound
    to `RedHatBoyContext`, but what sound will we play?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你修复那个错误几次，你就可以为`RedHatBoyContext`添加音频和声音了，但我们会播放什么声音呢？
- en: Adding a sound effect
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加音效
- en: Using the Web Audio API, we can play any sound format that is supported by the
    `audio` HTML element, which includes all the common formats of WAV, MP3, MP4,
    and Ogg. In addition, in 2017, the MP3 license expired, so if you're concerned
    about that, don't be; you can use MP3 files for sounds without worry.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web Audio API，我们可以播放任何由`audio`HTML元素支持的音频格式，包括所有常见的WAV、MP3、MP4和Ogg格式。此外，2017年，MP3许可证到期，所以如果你对此担心，不要担心；你可以无忧无虑地使用MP3文件作为声音。
- en: Since the Web Audio API is compatible with so many audio formats, you can use
    sound from all over the internet, provided it's released under the appropriate
    license. The sound effect we'll be using for jumping is available at [https://opengameart.org/content/8-bit-jump-1](https://opengameart.org/content/8-bit-jump-1)
    and is released under the *Creative Commons public domain* license, so we can
    use it without concern. You don't need to download that bundle and browse through
    it, although you can, but the jump sound is already bundled with this book's assets
    at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)
    in the `sounds` directory. The specific file we want is `SFX_Jump_23.mp3`. You'll
    want to copy that file into the `static` directory of your Rust project so that
    it will be available for your game.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Web Audio API 与许多音频格式兼容，因此只要它是在适当的许可下发布的，你可以使用来自互联网任何地方的声音。我们将用于跳跃的声音效果可在
    [https://opengameart.org/content/8-bit-jump-1](https://opengameart.org/content/8-bit-jump-1)
    找到，并且它是在 *Creative Commons 公共领域* 许可下发布的，因此我们可以放心使用。你不需要下载那个捆绑包并浏览它，尽管你可以这样做，但跳跃声音已经捆绑在这本书的资产中，位于
    [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)
    的 `sounds` 目录下。我们想要的特定文件是 `SFX_Jump_23.mp3`。你需要将这个文件复制到你的 Rust 项目的 `static` 目录中，以便它可以在你的游戏中使用。
- en: 'Now that `RedHatBoyContext` is ready to hold the `Audio` struct, and the `SFX_Jump_23.mp3`
    file is available to be loaded, we can start adding that code. Start with adding
    `Audio` and `Sound` to `RedHatBoyContext` as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`RedHatBoyContext` 已经准备好容纳 `Audio` 结构体，并且 `SFX_Jump_23.mp3` 文件可供加载，我们可以开始添加代码。从添加
    `Audio` 和 `Sound` 到 `RedHatBoyContext`，如下所示：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Remember to add `use` declarations for `Audio` and `Sound` to the `red_hat_boy_states`
    module. The code will stop compiling because `RedHatBoyContext` is being initialized
    without `audio` or `jump_sound`, so we''ll need to add that. `RedHatBoyContext`
    is initialized in the `new` method of the `RedHatBoyState<Idle>` implementation
    so we''ll change that method to take `Audio` and `Sound` objects that we''ll pass
    into `RedHatBoyContext` as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将 `Audio` 和 `Sound` 的 `use` 声明添加到 `red_hat_boy_states` 模块中。代码将无法编译，因为 `RedHatBoyContext`
    在没有 `audio` 或 `jump_sound` 的情况下被初始化，所以我们需要添加它。`RedHatBoyContext` 在 `RedHatBoyState<Idle>`
    实现的 `new` 方法中被初始化，所以我们将该方法更改为接受 `Audio` 和 `Sound` 对象，并将它们传递给 `RedHatBoyContext`，如下所示：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We could create an `Audio` object here, but then the `new` method would need
    to return `Result<Self>` and I don't think that's appropriate. This will move
    the compiler error, because where we call `RedHatBoyState<Idle>::new` is now wrong.
    That is in `RedHatBoy::new`, which can now also take `Audio` and `Sound` objects
    and pass them through.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里创建一个 `Audio` 对象，但这样 `new` 方法就需要返回 `Result<Self>`，我认为这不合适。这将移动编译器错误，因为我们调用
    `RedHatBoyState<Idle>::new` 的地方现在是不正确的。那就是在 `RedHatBoy::new` 中，它现在也可以接受 `Audio`
    和 `Sound` 对象并将它们传递下去。
- en: 'This leads us to our infamous `initialize` function in our `Game` implementation,
    which fails to compile because it calls `RedHatBoy::new` without `Audio` or `Sound`.
    This is the appropriate place to load a file, both because it is `async` and because
    it returns a result. We''ll create an `Audio` object in `initialize`, load up
    the sound we want, and pass it to the `RedHatBoy::new` function, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们来到 `Game` 实现中臭名昭著的 `initialize` 函数，因为它在没有任何 `Audio` 或 `Sound` 的情况下调用 `RedHatBoy::new`，因此无法编译。这是一个加载文件的合适位置，因为它既是
    `async` 的，又返回一个结果。我们将在 `initialize` 中创建一个 `Audio` 对象，加载我们想要的音效，并将其传递给 `RedHatBoy::new`
    函数，如下所示：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will get the app compiling again, but we don''t do anything with `audio`
    or `sound`. Remember that all this work was done because we wanted to make sure
    the sound is only played *once* when we jump, and the way to ensure that is to
    put the playing of the sound in the transition from `Running` to `Jumping`. Transitions
    are done in the various `From` implementations via methods on `RedHatBoyContext`.
    Let''s write a small function called `play_jump_sound` on `RedHatBoyContext`,
    as shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使应用程序再次编译，但我们没有对 `audio` 或 `sound` 做任何事情。记住，所有这些工作都是因为我们想确保在跳跃时声音只播放 *一次*，而确保这一点的方法是将声音播放放在从
    `Running` 到 `Jumping` 的转换中。转换是通过 `RedHatBoyContext` 上的各种 `From` 实现通过方法完成的。让我们在
    `RedHatBoyContext` 上编写一个名为 `play_jump_sound` 的小函数，如下所示：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function is written a little differently than the other transition side
    effect functions in this implementation, because `play_sound` returns a result,
    but in order to be consistent with the other transition methods, `play_jump_sound`
    really shouldn''t. Fortunately, failing to play a sound, while annoying, isn''t
    fatal, so we''ll log the error and continue if the sound couldn''t be played.
    The code now compiles, but we need to add the call to `play_jump_sound` to the
    transition. Look for `jump` on `RedHatBoyState<Running>` and modify that transition
    to call `play_jump_sound`, as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的编写方式与这个实现中其他过渡副作用函数略有不同，因为`play_sound`返回一个结果，但为了与其他过渡方法保持一致，`play_jump_sound`实际上不应该这样做。幸运的是，未能播放声音虽然令人烦恼，但不会致命，所以如果声音无法播放，我们将记录错误并继续。现在代码可以编译，但我们需要将`play_jump_sound`的调用添加到过渡中。在`RedHatBoyState<Running>`上查找`jump`，并将该过渡修改为调用`play_jump_sound`，如下所示：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When this compiles, run the game and you'll see, and hear, RHB jump onto a platform.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个程序编译完成后，运行游戏，你就会看到，也会听到RHB跳上平台。
- en: '![Figure 7.1 – Can you hear it?](img/Figure_7.01_B17151.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 你能听到吗？](img/Figure_7.01_B17151.jpg)'
- en: Figure 7.1 – Can you hear it?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 你能听到吗？
- en: Tip
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If, like most developers I know, you have 20+ browser tabs open right now, you
    may want to close them. It can slow down the browser's sound playback and make
    the sound timing off.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我认识的许多开发者一样，现在有20多个浏览器标签页打开，你可能想关闭它们。这可能会减慢浏览器的声音播放，并使声音时间不准确。
- en: Now that you've played one sound effect, consider adding more, for example,
    when RHB crashes into an obstacle, or lands cleanly, or slides. The choices are
    up to you! After you've had a little fun with sound effects, let's add some background
    music.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经播放了一个音效，考虑添加更多，例如，当RHB撞到障碍物，或者平稳着陆，或者滑动时。选择权在你！在你对音效玩得有点乐趣之后，让我们添加一些背景音乐。
- en: Playing long music
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放长音乐
- en: 'You might think that playing music will mean detecting whether the sound is
    complete and restarting it. This is probably true for the browser''s implementation,
    but fortunately, you don''t have to do it. The Web Audio API already has a flag
    on the `AudioBufferSourceNode` loop that will play the sound on a loop until it
    is explicitly stopped. This will make playing background audio rather simple.
    We can add a flag to the `play_sound` function in the `sound` module for the `loop`
    parameter, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为播放音乐意味着检测声音是否播放完成并重新开始。这可能对于浏览器的实现来说是正确的，但幸运的是，你不必这样做。Web Audio API已经在`AudioBufferSourceNode`的循环上设置了一个标志，可以在声音被明确停止之前循环播放声音。这将使播放背景音频变得相当简单。我们可以在`sound`模块的`play_sound`函数中添加一个标志到`loop`参数，如下所示：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This starts with the `create_track_source` function, which is actually a refactoring
    of the `play_sound` function. It takes the first three lines of it and extracts
    them into a separate function for readability. After that, we create a `LOOPING`
    enum and use it to check whether we should call `set_loop` on `track_source`.
    You might wonder why we don''t just pass `bool` as the third parameter, and the
    answer is that it is going to be much easier to read the first line of code shown
    here than the second:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`create_track_source`函数开始的，实际上是对`play_sound`函数的重构。它提取了它的前三行，并将它们提取到一个单独的函数中以提高可读性。之后，我们创建了一个`LOOPING`枚举，并使用它来检查我们是否应该在`track_source`上调用`set_loop`。你可能想知道为什么我们不直接传递`bool`作为第三个参数，答案是，阅读这里显示的第一行代码将比第二行代码容易得多：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Six months from now, when I don''t know what that Boolean is for, I''ll have
    to look it up, whereas the version with the enum is obvious. By adding this flag,
    our program stops compiling because `Audio` in the engine is still calling `play_sound`
    with two parameters. We can quickly fix that, as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 六个月后，当我不知道那个布尔值是做什么的时候，我不得不去查找，而使用枚举的版本则很明显。通过添加这个标志，我们的程序停止编译，因为引擎中的`Audio`仍然使用两个参数调用`play_sound`。我们可以快速修复这个问题，如下所示：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''ll also add a new method to play background music, which is just playing
    a sound with looping turned on:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一种播放背景音乐的新方法，即通过开启循环播放来播放声音：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'I like how the engine has progressively less flexibility than the `sound` module.
    The `sound` and `browser` modules are wrappers around the browser functionality;
    the engine provides utilities to help you make a game. Now that the engine provides
    a way to play background music, we can actually add it to the game. In the assets,
    there''s a second file in the `sounds` directory, `background_song.mp3`, which
    you can copy into the `static` directory of this project. Once you''ve done that,
    we can load and play the background music in our `Game::initialize` function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢引擎比`sound`模块的灵活性逐渐减少。`sound`和`browser`模块是浏览器功能的包装器；引擎提供了帮助您制作游戏的工具。现在，引擎提供了一种播放背景音乐的方式，我们实际上可以将它添加到游戏中。在资源中，`sounds`目录中有一个第二个文件，`background_song.mp3`，您可以将其复制到本项目的`static`目录中。一旦完成，我们就可以在`Game::initialize`函数中加载并播放背景音乐：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Check out [https://gamesounds.xyz/](https://gamesounds.xyz/) for royalty-free
    sounds for your games.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 查看https://gamesounds.xyz/获取您游戏的无版权声音。
- en: Here, we load the second song, `background_song.mp3`, and play it immediately
    with `play_looping_sound`. On most browsers, you won't hear the music until you
    click the canvas to give it focus, so check that if you don't hear anything. One
    thing to note is that, even though that sound is going to go out of scope, the
    browser will happily keep playing it. We've passed along the song to the browser
    and it's in charge now. Nothing changes about the creation of `RedHatBoy` as the
    audio is moved into it, and it will eventually be in charge of playing sound effects
    for the game.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们加载第二首歌曲`background_song.mp3`，并使用`play_looping_sound`立即播放。在大多数浏览器上，您可能需要点击画布以将其聚焦，才会听到音乐，所以如果听不到任何声音，请检查一下。需要注意的是，尽管那个声音即将超出作用域，浏览器仍然会愉快地继续播放它。我们已经将歌曲传递给浏览器，现在由它负责。当音频移动到`RedHatBoy`中时，`RedHatBoy`的创建没有发生变化，它最终将负责播放游戏的声音效果。
- en: Tip
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may want to mute your browser while developing, as each time the browser
    refreshes, the song will restart.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你可能想静音浏览器，因为每次浏览器刷新时，歌曲都会重新开始播放。
- en: There you have it! A proper game with music and sound effects! Now to add a
    UI, so we can actually click **New Game** on it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！一个带有音乐和声音效果的完整游戏！现在要添加UI，这样我们就可以点击它上的**新游戏**了。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you added sounds to your game using the Web Audio API and got
    an overview of the API itself. The Web Audio API is very broad and has a ton of
    features, and I'd encourage you to explore it. Your first challenge is to use
    the `gain` property to change the volume of the music, which is rather loud at
    the moment. The Web Audio API also supports features such as stereo surround sound
    and programmatically generated music. Have some fun and try it out!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您使用Web Audio API为您的游戏添加了声音，并对API本身进行了概述。Web Audio API非常广泛，具有众多功能，我鼓励您去探索它。您的第一个挑战是使用`gain`属性来改变音乐的音量，目前音量相当大。Web
    Audio API还支持立体声环绕声和程序生成音乐等功能。尽情享受并尝试一下吧！
- en: You also added a new module to the game, and further extended the game engine
    to support it. We even covered refactoring and made some trade-offs to ensure
    the game would finish without requiring a time-consuming *ideal* design. I encourage
    you to take some time to add more sound effects to the game; you have the skills
    now to make RHB *thud* when he lands or crashes into a rock. Speaking of crashing
    into rocks, you're probably sick of having to hit *refresh* every time you do
    that, so in the next chapter, we'll add a small UI with a wonderful **New Game**
    button.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您还为游戏添加了一个新模块，并进一步扩展了游戏引擎以支持它。我们甚至涵盖了重构，并做出了一些权衡，以确保游戏可以在不要求耗时*理想*设计的情况下完成。我鼓励您花些时间给游戏添加更多声音效果；您现在有技能让RHB在着陆或撞到岩石时发出*砰*的声音。说到撞到岩石，你可能已经厌倦了每次都不得不点击*刷新*，所以在下一章中，我们将添加一个小型UI，并带有一个精彩的**新游戏**按钮。
