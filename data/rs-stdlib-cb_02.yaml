- en: Working with Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与集合一起工作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using a vector
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用向量
- en: Using a string
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串
- en: Accessing collections as iterators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将集合作为迭代器访问
- en: Using a `VecDeque`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`VecDeque`
- en: Using a `HashMap`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HashMap`
- en: Using a `HashSet`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HashSet`
- en: Creating an own iterator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的迭代器
- en: Using a slab
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用slab
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Rust** provides a very broad set of collections to use. We will look at most
    of them, see how they''re used, discuss how they''re implemented, and when to
    use and choose them. A big part of this chapter focuses on iterators. Much of
    Rust''s flexibility comes from them, as all collections (and more!) can be used
    as iterators. Learning how to use them is crucial.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rust**提供了一组非常广泛的集合供使用。我们将查看大多数集合，了解它们的使用方法，讨论它们的实现方式，以及何时使用和选择它们。本章的大部分内容都集中在迭代器上。Rust的许多灵活性都来自于它们，因为所有集合（以及更多！）都可以用作迭代器。学习如何使用它们是至关重要的。'
- en: Throughout this chapter, we are going to use the *big O notation* to show how
    effective certain algorithms are. In case you don't know it yet, it is a way of
    telling how much longer an algorithm takes when working with more elements. Let's
    look at it briefly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用*大O表示法*来展示某些算法的有效性。如果您还不知道，这是一种描述算法在处理更多元素时所需时间增长的方式。让我们简要地看看它。
- en: '![](img/2d8a2575-71ea-413d-b7dc-12001272e5c0.png) means that an algorithm is
    going to take the same time, no matter how much data is stored in a collection.
    It doesn''t tell us how fast exactly it is, just that it''s not going to slow
    down with size. This is the realistic ideal for a function. A practical example
    for this is accessing the first number in an infinite list of numbers: no matter
    how many numbers there are, you''re always going to be able to instantly pick
    out the first one.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/2d8a2575-71ea-413d-b7dc-12001272e5c0.png)表示无论在集合中存储多少数据，算法所需的时间都将相同。它并没有告诉我们它有多快，只是它不会随着大小的增加而变慢。这是函数的现实理想。一个实际的例子是访问一个无限数字列表中的第一个数字：无论有多少数字，您总是能够立即挑选出第一个。'
- en: '![](img/d6bf9ef3-9e89-4e76-aeb5-a125f45e6a12.png) means that an algorithm is
    going to slow down by the same degree for every element. This is not good, but
    still okay. An example for this is printing all data in a `for` loop.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/d6bf9ef3-9e89-4e76-aeb5-a125f45e6a12.png)表示算法将按相同程度减慢每个元素。这并不好，但还可以接受。一个例子是在`for`循环中打印所有数据。'
- en: '![](img/6cf884d4-c07a-4ba2-8d1c-2eaf8363dfa5.png) is really bad. It tells us
    that an algorithm is going to be slower and slower with every element. An example
    of it would be accessing data in a `for` loop nested in another `for` loop over
    the same data.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/6cf884d4-c07a-4ba2-8d1c-2eaf8363dfa5.png)非常糟糕。它告诉我们算法将随着每个元素的加入而变得越来越慢。一个例子是在另一个`for`循环中访问相同数据的数据。'
- en: Using a vector
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用向量
- en: The most basic collection is the vector, or `Vec` for short. It is essentially
    a variable-length array with a very low overhead. As such, it is the collection
    that you will use most of the time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的集合是向量，或简称为`Vec`。它本质上是一个具有非常低开销的变长数组。因此，它是在您将使用的大部分时间中的集合。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the command line, jump one folder up with `cd ..` so you're not in `chapter-one`
    anymore. In the next chapters, we are going to assume that you always started
    with this step.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，使用`cd ..`向上跳一个文件夹，这样您就不再在`chapter-one`中。在接下来的章节中，我们将假设您总是从这一步开始。
- en: Create a Rust project to work on during this chapter with `cargo new chapter-two`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new chapter-two`创建一个Rust项目，在本章中对其进行工作。
- en: Navigate into the newly-created `chapter-two` folder. For the rest of this chapter,
    we will assume that your command line is currently in this directory.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`chapter-two`文件夹。在本章的其余部分，我们将假设您的命令行当前位于此目录。
- en: Inside the folder `src`, create a new folder called `bin`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹内，创建一个名为`bin`的新文件夹。
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的`lib.rs`文件，因为我们不是创建一个库。
- en: In the folder `src/bin`, create a file called `vector.rs`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中创建一个名为`vector.rs`的文件。
- en: 'Add the following code blocks to the file and run them with `cargo run --bin
    vector`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码块添加到文件中，并使用`cargo run --bin vector`运行它们：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is how you can access single elements in a vector:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是您如何访问向量中的单个元素：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next few methods apply to the whole vector:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的几个方法适用于整个向量：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can split a vector into two and combine them again:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将一个向量分成两个，然后再将它们合并：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You might remember the `splice` method from JavaScript:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还记得JavaScript中的`splice`方法：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are working with very big datasets, you can optimize the performance
    of your vector:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在处理非常大的数据集，您可以优化您向量的性能：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe is going to be a bit longer than the others, because:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将比其他菜谱长一些，因为：
- en: The vector is the most important collection
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量是最重要的集合
- en: Many of its core principles, like preallocation, apply to other collections
    as well
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其核心原则，如预分配，也适用于其他集合
- en: It includes methods used on slices, which are also usable by many other collections
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括用于切片的方法，这些方法也可由许多其他集合使用
- en: Let's start at the beginning.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一开始。
- en: A vector can be created [9] by using the constructor pattern we mentioned earlier
    ([Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics,
    Using the Constructor Pattern*), and filled by calling `push` on it for every
    element we want to store [10]. Because this is such a common pattern, Rust provides
    you with a convenient macro called `vec!`[3]. While its end effect is the same,
    the macro is implemented with some nice performance optimizations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 向量可以通过我们之前提到的构造函数模式 [9] 创建，并通过对每个我们想要存储的元素调用`push`来填充 [10]。因为这是一个非常常见的模式，Rust为您提供了一个方便的宏，称为`vec!`[3]。虽然其最终效果相同，但该宏通过一些性能优化来实现。
- en: 'Because of the convenience `vec!` provides, other Rustacians have implemented
    similar macros for the other collections, which you can find here: [https://crates.io/crates/maplit.](https://crates.io/crates/maplit)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`vec!`提供的便利性，其他Rustacians已经为其他集合实现了类似的宏，您可以在以下链接中找到：[https://crates.io/crates/maplit.](https://crates.io/crates/maplit)
- en: If you want to initialize a vector by repeating an element over and over, you
    can use the special calling syntax described in line [52] to do so.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要通过重复一个元素来初始化向量，您可以使用第 [52] 行中描述的特殊调用语法来这样做。
- en: 'The opposite of `push` is `pop`: it removes the last element of the vector,
    and returns it if the vector wasn''t empty before. Because of the memory layout
    of `Vec`, which we are going to look at in the next section, this operation is
    done in ![](img/0eab5654-6646-4a88-b72b-0e4e435476b8.png) complexity. If you don''t
    know what that means, let me rephrase that: it''s pretty fast. This is why vectors
    can be nicely used as **First In, Last Out (FILO)** stacks.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`的反面是`pop`：它移除向量的最后一个元素，如果向量在之前不为空，则返回它。由于`Vec`的内存布局，我们将在下一节中讨论，此操作以 ![](img/0eab5654-6646-4a88-b72b-0e4e435476b8.png)
    复杂度完成。如果您不知道这意味着什么，让我重新表述一下：它非常快。这就是为什么向量可以很好地用作**先进后出（FILO）**栈。'
- en: If you need to modify the contents of a vector, `insert`[22],  `remove` [58],
    and `swap` [26] should be self-explanatory. Sometimes, though, you want to access
    a specific element in the vector. You can use `get` to borrow an element at an
    index [40], and `get_mut` to mutate it. Both return an `Option` that only contains
    `Some` element if the index was valid. Most times, though, this fine grade of
    error checking is unnecessary for vector access, as an out-of-bounds index is
    usually not recoverable, and will just be handled by unwrapping the `Option`.
    For this reason, Rust lets you call the `Index` operator, `[]`, on a `Vec` [45].
    This will automatically deduce its mutability and perform an unwrap for you.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要修改向量的内容，`insert`[22]、`remove` [58] 和 `swap` [26] 应该是显而易见的。有时，尽管如此，您可能想要访问向量中的特定元素。您可以使用`get`来借用索引
    [40] 处的元素，并使用`get_mut`来修改它。两者都返回一个只包含`Some`元素的`Option`，如果索引是有效的。然而，大多数时候，这种精细的错误检查对于向量访问是不必要的，因为越界索引通常无法恢复，并且将仅通过解包`Option`来处理。因此，Rust允许您在`Vec`上调用`Index`运算符，`[]`。这将自动推断其可变性并为您执行解包。
- en: There are a bunch of methods that help us work with the entire vector at once.
    `retain` is a very useful one that is also implemented by most other collections
    [64]. It accepts a so-called **predicate**, which is a fancy word for a function
    that returns `true` or `false`. It applies that predicate to every element, and
    only keeps the ones where it returned `true`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以帮助我们一次性处理整个向量。`retain`是一个非常实用的方法，也被大多数其他集合 [64] 实现。它接受一个所谓的**谓词**，这是一个返回`true`或`false`的函数。它将谓词应用于每个元素，并且只保留返回`true`的元素。
- en: '`dedup` removes all *consecutive* duplicates [74]. This means that for the
    vector `[1, 2, 2, 3, 2, 3]`, `dedup` would result in `[1, 2, 3, 2, 3]`, as only
    the duplicate 2s were consecutive. Always remember this when using it, as it can
    cause bugs that are hard to find. If you want to remove *all* duplicates, you
    need to make them consecutive by sorting the vector first. If your elements are
    comparable, this is as simple as calling `.sort()` [84].'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`dedup`移除所有*连续*的重复项 [74]。这意味着对于向量 `[1, 2, 2, 3, 2, 3]`，`dedup`的结果将是 `[1, 2,
    3, 2, 3]`，因为只有重复的2是连续的。使用它时始终记住这一点，因为它可能会引起难以发现的错误。如果你想移除*所有*重复项，你需要通过首先对向量进行排序来使它们连续。如果你的元素是可比较的，这就像调用`.sort()`
    [84]一样简单。'
- en: Using `drain` creates a consuming iterator over your vector, accessing all elements
    and removing them in the process, leaving your vector empty [96]. This is useful
    when you have to *work through* your data and reuse your empty vector again afterwards
    to collect more work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`drain`创建一个消费迭代器，在访问所有元素的同时移除它们，使你的向量变为空 [96]。这在你需要*处理*你的数据并在之后再次使用空向量来收集更多工作时有用。
- en: If you've never seen `splice` in another language, you're probably going to
    feel a bit confused at first about what it does. Let's take a look at it, shall
    we?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未在其他语言中见过`splice`，你一开始可能会对它做什么感到有些困惑。让我们来看看它，好吗？
- en: '`splice` does three things:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice`做三件事：'
- en: It takes a range. This range will be *removed* from the vector.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要一个范围。这个范围将被从向量中*移除*。
- en: It takes an iterator. This iterator will be *inserted* into the space left open
    by the removal from the last step.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要一个迭代器。这个迭代器将被插入到上一步移除后留下的空间中。
- en: It *returns* the removed elements as an iterator.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它*返回*移除的元素作为迭代器。
- en: How to handle the returned iterator is going to be the topic of the recipe in
    the *Access collections as iterators* section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理返回的迭代器将是*访问集合作为迭代器*部分中食谱的主题。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The vector should always be your go-to collection. Internally, it is implemented
    as a continuous chunk of memory stored on the heap:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 向量应该是你首选的集合。在内部，它被实现为存储在堆上的连续内存块：
- en: '![](img/f6cc6a9c-c751-4371-8826-14b279ace5fd.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6cc6a9c-c751-4371-8826-14b279ace5fd.jpg)'
- en: 'The important keyword here is *continuous*, which means that the memory is
    very cache-friendly. In other words, the vector is pretty fast! The vector even
    allocates a bit of extra memory in case you want to extend it. Be careful, though,
    when inserting a lot of data at the beginning of the vector: the entire stack
    will have to be moved.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的关键字是*连续的*，这意味着内存非常缓存友好。换句话说，向量相当快！向量甚至分配了一些额外的内存，以防你想扩展它。但是，当在向量的开头插入大量数据时要小心：整个堆栈将不得不移动。
- en: At the end, you can see a bit of *extra capacity*. This is because `Vec` and
    many other collections preallocate a bit of extra memory each time you have to
    move the block, because it has grown too large. This is done in order to prevent
    as many reallocations as possible. You can check the exact amount of total space
    of a vector by calling `capacity`[140] on it. You can influence the preallocation
    by initializing your vector with `with_capacity`[137]. Use it when you have a
    rough idea about how many elements you plan on storing. This can be a big difference
    in capacity when working with big amounts of data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以看到一点*额外容量*。这是因为`Vec`和许多其他集合在每次需要移动块并且它变得太大时都会预先分配一些额外的内存。这是为了尽可能减少重新分配。你可以通过调用`capacity`
    [140]来检查向量的确切总空间量。你可以通过使用`with_capacity` [137]来影响预分配。当你大致知道你打算存储多少元素时使用它。当处理大量数据时，这可能会在容量上产生很大差异。
- en: The extra capacity doesn't go away when shortening the vector. If you had a
    vector with a length of 10,000 and a capacity of 100,000 and called `clear` on
    it, you would still have a capacity of 100,000 preallocated. When working on systems
    with memory limitations, like microcontrollers, this can become a problem. The
    solution is calling `shrink_to_fit` periodically on such vectors [143]. This will
    bring the capacity as close as possible to the length, but it is allowed to still
    leave a little bit of preallocated space ready.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在缩短向量时，额外的容量并不会消失。如果你有一个长度为10,000，容量为100,000的向量，并在其上调用`clear`，你仍然会有100,000预先分配的容量。当在内存受限的系统上工作时，如微控制器，这可能会成为一个问题。解决方案是定期在这些向量上调用`shrink_to_fit`
    [143]。这将使容量尽可能接近长度，但仍允许留下一小部分预先分配的空间。
- en: Another way to optimize really big vectors is to call `swap_remove` [150]. Normally,
    when removing an element from a vector, all elements after it will be shifted
    to the left in order to preserve continuous memory. This is a lot of work when
    removing the first element in a big vector. If you don't care about the exact
    order of your vector, you can call `swap_remove` instead of `remove`. It works
    by swapping the element that is to be removed with the last element, and adjusting
    the length. This is great, because you don't create a *hole* that needs to be
    filled by shifting, and because swapping memory is a really fast operation in
    today's processors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种优化非常大的向量的方法是调用 `swap_remove` [150]。通常，当你从一个向量中移除一个元素时，它后面的所有元素都会向左移动以保持连续的内存。当在一个大向量中移除第一个元素时，这是一项大量工作。如果你不关心向量中元素的精确顺序，你可以调用
    `swap_remove` 而不是 `remove`。它通过交换要移除的元素和最后一个元素，并调整长度来实现。这很好，因为你不需要通过移动来填充需要填充的“空洞”，并且因为交换内存是当今处理器中非常快速的操作。
- en: Using a string
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串
- en: Rust provides an unusually large functionality for its string. Knowing it can
    save you quite some headache when dealing with raw user input.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 为其字符串提供了异常大的功能。了解它可以在处理原始用户输入时节省你很多麻烦。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the folder `src/bin`, create a file called `string.rs`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中创建一个名为 `string.rs` 的文件。
- en: 'Add the following code, and run it with `cargo run --bin string`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin string` 运行它：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the following code to split a string in various ways:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码以各种方式拆分字符串：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Remove whitespace:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 移除空白：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Modify the string:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 修改字符串：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Essentially, being a kind of vector, a string can be created the same way by
    combining `new` and `push`; however, because this is really inconvenient, a `string`,
    which is an owned chunk of memory, can be created from a string slice (`&str`),
    which is either a borrowed string or a literal. Both of the ways to do it, that
    are shown in this recipe, are equivalent:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，作为一种向量，字符串可以通过组合 `new` 和 `push` 来以相同的方式创建；然而，因为这样做非常不方便，所以可以从字符串切片（`&str`）创建一个
    `string`，它可以是借用字符串或字面量。这两种在本文档中展示的方法都是等效的：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Out of pure personal preference, we will use the first variant.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 出于纯粹的个人偏好，我们将使用第一个变体。
- en: Before Rust `1.9`, `to_owned()` was the fastest way to create a string. Now,
    `to_string()` is equally performant and should be preferred, because it offers
    more clarity over what is done. We mention this because many old tutorials and
    guides have not been updated since then, and still use `to_owned()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust `1.9` 之前，`to_owned()` 是创建字符串最快的方式。现在，`to_string()` 的性能同样出色，应该优先使用，因为它提供了对所做操作的更多清晰度。我们提到这一点是因为许多旧的教程和指南自那时起就没有更新，仍然使用
    `to_owned()`。
- en: 'All strings in Rust are valid Unicode in UTF-8 encoding. This can lead to some
    surprises, as a *character*, as we know it, is an inherently Latin invention.
    For instance, look at languages that have a modifier for a letter—is `ä` an own
    character, or is it merely a variation of `a`? What about languages that allow
    many combinations in extreme? What would that keyboard even look like? For this
    reason, Unicode lets you compose your *characters* from different *Unicode scalar
    values*. With `.chars()`, you can create an iterator that goes through these scalars
    [28]. If you work with non-Latin characters, you might get surprised by this when
    accessing composing characters —`y̆` is not one, but two scalars, `y` and  `̆`
    [36]. You can get around this by using the `Unicode-segmentation` crate, which
    supports iteration over graphemes: [https://crates.io/crates/unicode-segmentation.](https://crates.io/crates/unicode-segmentation)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的所有字符串在 UTF-8 编码中都是有效的 Unicode。这可能会带来一些惊喜，因为我们所知的“字符”本质上是一种拉丁发明。例如，看看那些有字母修饰符的语言——`ä`
    是一个独立的字符，还是 `a` 的变体？对于允许极端组合的语言呢？那样的键盘会是什么样子？因此，Unicode 允许你从不同的 Unicode 标量值中组合你的“字符”。使用
    `.chars()`，你可以创建一个迭代器，遍历这些标量 [28]。如果你处理非拉丁字符，当你访问组合字符时可能会感到惊讶——`y̆` 不是单个标量，而是两个标量，`y`
    和 `̆` [36]。你可以通过使用支持遍历图形的 `Unicode-segmentation` crate 来解决这个问题：[https://crates.io/crates/unicode-segmentation.](https://crates.io/crates/unicode-segmentation)
- en: When splitting a string on a pattern that is at the beginning, is at the end,
    or occurs multiple times after each other, each instance gets split into an empty
    string `""`[107]. This is especially nasty when splitting on spaces (`' '`). In
    this case, you should use `split_whitespace` instead [110]. Otherwise, `split_terminator`
    will remove the empty strings from the end of the string [68].
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当在开始处、结束处或连续多次出现模式时分割字符串，每个实例都会分割成空字符串 `""`[107]。当在空格（`' '`）上分割时，这尤其令人讨厌。在这种情况下，你应该使用
    `split_whitespace`[110]。否则，`split_terminator` 将从字符串末尾删除空字符串[68]。
- en: 'By the way, when we talk about a *pattern* in this recipe, we mean one of three
    things:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，当我们在这个菜谱中提到*模式*时，我们指的是以下三种情况之一：
- en: '- A character'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '- 一个字符'
- en: '- A string'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '- 一个字符串'
- en: '- A predicate that takes one `char`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '- 一个接受一个 `char` 的谓词'
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The implementation of `String` should not be much of a surprise—it''s just
    a kind of vector:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 的实现不应该令人惊讶——它只是一种向量：'
- en: '![](img/f412c3fb-e496-4985-af5b-64a327a58aba.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f412c3fb-e496-4985-af5b-64a327a58aba.jpg)'
- en: Accessing collections as iterators
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将集合作为迭代器访问
- en: Welcome to one of the most flexible parts of the Rust standard library. Iterators
    are, as the name suggests, a way of applying actions of items in a collection.
    If you come from C#, you will already be familiar with iterators because of Linq.
    Rust's iterators are kind of similar, but come with a more functional approach
    to things.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 Rust 标准库中最灵活的部分之一。正如其名所示，迭代器是一种对集合中项目应用操作的方式。如果你来自 C#，你可能会因为 Linq 而对迭代器已经很熟悉了。Rust
    的迭代器在某种程度上是相似的，但它们采用了一种更函数式的方法来处理事物。
- en: Because they are an extremely fundamental part of the standard library, we are
    going to dedicate this recipe entirely to a showcase of all the different things
    you can do with them in isolation. For real-world use cases, you can simply continue
    reading the book, as a big portion of the other recipes features iterators in
    some way or another.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是标准库中极其基础的部分，我们将把这个菜谱完全奉献给展示你可以独立使用它们的各种不同方式。对于实际用例，你可以简单地继续阅读这本书，因为其他大部分菜谱以某种方式或另一种方式使用迭代器。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the folder `src/bin`, create a file called `iterator.rs`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中，创建一个名为 `iterator.rs` 的文件。
- en: 'Add the following code, and run it with `cargo run --bin iterator`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin iterator` 运行它：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Access individual items:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问单个项：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Collect the iterator into a collection:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将迭代器收集到集合中：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Change which items are being iterated over:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改正在迭代的项：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Check if an iterator contains an element:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查迭代器是否包含元素：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Useful operations for numeric items:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于数值项的有用操作：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Combine iterators:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合迭代器：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Apply functions to all items:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数应用于所有项：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The real strength of iterators comes from combining them:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器的真正优势来自于它们的组合：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '*This recipe is incredibly important*. No matter what you do, or which library
    you use, it''s going to use iterators somewhere. All of the operations presented
    can be used on any collection and all types that implement the `iterator` trait.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个方法非常重要*。无论你做什么，或者使用哪个库，它都将在某个地方使用迭代器。所有展示的操作都可以用于任何集合和实现了 `iterator` 特性的所有类型。'
- en: 'In the first section, we looked at different ways to create iterators. I mention
    that ranges are *limited* because, in order to be iterable, the range-type has
    to implement `Step`. `char` doesn''t, so you wouldn''t be able to use `''A''..''D''`
    as an iterator. For this reason, in line [209], we iterate over the characters
    as bytes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们探讨了创建迭代器的不同方法。我提到范围是*有限的*，因为为了可迭代性，范围类型必须实现 `Step`。`char` 不实现，所以你不能将
    `'A'..'D'` 作为迭代器使用。因此，在 [209] 行中，我们以字节的形式迭代字符：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have to set the limit of the range to `b'z' + 1`, because ranges are non-inclusive.
    You might have noticed that this fact makes using ranges confusing sometimes.
    This is why, on the nightly compiler, you can use inclusive ranges ([Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*, *Iterating over an inclusive range*).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将范围的上限设置为 `b'z' + 1`，因为范围是非包含的。你可能已经注意到，这个事实有时会使使用范围变得令人困惑。这就是为什么在夜间编译器上，你可以使用包含范围（[第
    10 章](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml)，*使用实验性夜间功能*，*迭代包含范围*）。
- en: 'Let''s return to our recipe here, though. While iterating, you have the option
    to use `enumerate` in order to get an iteration counter [22]. This is the reason
    that Rust gets away with not supporting traditional, C-style `for` loop syntax.
    You most probably have seen some variation of the following C code in some language
    or another:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们回到我们的配方。在迭代过程中，你可以选择使用`enumerate`来获取一个迭代计数器 [22]。这就是为什么Rust可以避开不支持传统的C风格`for`循环语法。你很可能在其他语言中看到过以下C代码的某种变体：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Rust disallows this, because a range-based `for` loop is almost always cleaner
    to use, which you are going to know if you come from a Python background, as it
    pioneered this restriction. In fact, most programming languages have shifted their
    paradigm to promote range-based loops. In the rare cases where you really actually
    would like to know your iteration count, you can use `enumerate` to emulate this
    behavior.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Rust禁止这样做，因为基于范围的`for`循环几乎总是更简洁，如果你来自Python背景，你将会知道这一点，因为它开创了这种限制。事实上，大多数编程语言都已经将它们的范式转向促进基于范围的循环。在极少数情况下，如果你真的实际上想了解你的迭代计数，你可以使用`enumerate`来模拟这种行为。
- en: 'When accessing single items with `nth`[41], you have to keep two things in
    mind:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`nth`[41]访问单个项时，你必须注意两件事：
- en: It accesses an item by going through all items until it reaches the one you
    want. In the worst case, this is an ![](img/792fb25a-7101-4b90-9b5c-555fc2e85980.png)access.
    If you can, use your collection's native access method (most of the time, this
    would be `.get()`).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过遍历所有项目直到找到你想要的项目来访问一个项。在最坏的情况下，这是一种 ![](img/792fb25a-7101-4b90-9b5c-555fc2e85980.png)访问。如果你可以的话，使用你收藏的本地访问方法（大多数情况下，这将是通过`.get()`）。
- en: It consumes the iterator up to the specified index. This means that calling
    `nth` twice with the exact same parameters is going to result in two different
    returned values [54]. Don't let this catch you by surprise.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它消耗迭代器直到指定的索引。这意味着使用相同参数两次调用`nth`将导致两个不同的返回值 [54]。不要对此感到惊讶。
- en: Another thing to take note of when using an iterator's various accessors is
    that they all return an `Option` that will be `None` if the iterator has no more
    items left.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用迭代器的各种访问器时，要注意的另一件事是，它们都返回一个`Option`，如果迭代器没有更多项目，它将是`None`。
- en: 'When collecting an iterator into a collection, the following two forms of annotation
    are completely equivalent:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当将迭代器收集到集合中时，以下两种形式的注解是完全等价的：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just use the one that you like most. In this book, we stick to the first form
    because of personal preference. The second form, by the way, is called the *turbofish*.
    This is because `::<>` kinda looks like a certain family of fish. Cute, isn't
    it? Both forms are also able to deduce their exact type automatically, so you
    don't need to write `Vec<i32>`. The inner type can be omitted with an underscore
    (`_`), as shown.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用你最喜欢的一种。在这本书中，我们坚持使用第一种形式，因为这是个人偏好的原因。顺便说一下，第二种形式被称为*turbofish*。这是因为`::<>`看起来像某种鱼类的家族。可爱，不是吗？两种形式也能自动推断出它们的确切类型，所以你不需要写`Vec<i32>`。内部类型可以用下划线（`_`）省略，如下所示。
- en: '`cycle` [163] takes an iterator and repeats it endlessly. `[1, 2, 3]` would
    become `[1, 2, 3, 1, 2, 3, 1, ...]`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle` [163] 接受一个迭代器，并无限重复它。`[1, 2, 3]` 将变成 `[1, 2, 3, 1, 2, 3, 1, ...]`。'
- en: '`zip` [175] takes two iterators and creates one out of them by putting items
    that are at the same index into a tuple, and then chaining them. If the iterators
    have different sizes, it just ignores the extra items of the longer one. For example,
    `[1, 2, 3]` zipped with `[''a'', ''b'', ''c'', ''d'']` would become `[(1, ''a''),
    (2, ''b''), (3, ''c'')]`, because `''d''` will be thrown away as it has no partner
    to zip with. If you zip two infinite ranges, you will have no problem, as `zip`
    is lazy, which means it will only actually start zipping your iterators when it''s
    really necessary; for example, when using `take` to extract the first few tuples
    [81].'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip` [175] 接受两个迭代器，通过将相同索引的项放入元组中，然后链接它们来创建一个。如果迭代器的大小不同，它将忽略较长迭代器的额外项。例如，`[1,
    2, 3]` 与 `[''a'', ''b'', ''c'', ''d'']` 进行`zip`将变成 `[(1, ''a''), (2, ''b''), (3,
    ''c'')]`，因为 `''d''` 将被丢弃，因为它没有可以与之`zip`的伙伴。如果你将两个无限范围`zip`在一起，你不会有问题，因为`zip`是惰性的，这意味着它只有在真正需要时才会开始`zip`你的迭代器；例如，当使用`take`提取前几个元组
    [81]。'
- en: 'If you need to mutate all of your items, you can use `map`. It can also be
    used to change the underlying type of the iterator, as shown in line [182]. `for_each`
    is really similar, with one big difference: it doesn''t return anything. It''s
    basically the same as manually using a `for` loop on an iterator. The intended
    use case for it is situations in which you have a lot of chained method calls
    on an iterator, where it can be more elegant to chain `for_each` as well, as a
    kind of *consumer*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要修改所有项，可以使用 `map`。它也可以用来更改迭代器的底层类型，如第 [182] 行所示。“for_each”与之非常相似，但有一个很大的区别：它不返回任何内容。它基本上就是在迭代器上手动使用
    `for` 循环。它的预期用例是在你有很多链式方法调用迭代器的情况下，将 `for_each` 链接起来会更优雅，作为一种 *消费者*。
- en: Iterators are very often chained together to weave complex transformations together.
    If you find yourself calling many methods on a single iterator, don't worry, as
    this is exactly what you should be doing. On the other hand, when you see yourself
    doing a lot of complicated stuff in a `for` loop, you should probably rewrite
    that code with iterators.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器经常被链在一起，以编织复杂的转换。如果你发现自己在一个迭代器上调用很多方法，不要担心，因为这正是你应该做的。另一方面，当你发现自己在一个 `for`
    循环中做了很多复杂的事情时，你可能需要用迭代器重写那段代码。
- en: When using `filter_map`[199], you can keep an item by returning it, wrapped
    in `Some`. If you want to filter it out, return `None`. Before that, you're allowed
    to change the item in whatever way you want, which is the `map` part of the deal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `filter_map`[199] 时，你可以通过返回一个包裹在 `Some` 中的项来保留一个项。如果你想过滤掉它，就返回 `None`。在此之前，你可以以任何你想要的方式更改项，这就是交易中的
    `map` 部分。
- en: There's more...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`iter()` creates an iterator that *borrows* items. If you want to create an
    iterator that *consumes* items—for example, takes ownership of them by moving
    them – you can use `into_iter()`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter()` 创建了一个 *借用* 项的迭代器。如果你想创建一个 *消费* 项的迭代器——例如，通过移动它们来获取所有权——你可以使用 `into_iter()`。'
- en: See also
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*The Iterating over an inclusive range* recipe in [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 10 章 [“遍历包含范围”](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml)，*使用实验性夜间功能* 中的配方
- en: Using a VecDeque
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 VecDeque
- en: When you need to insert or remove elements regularly into or from the beginning
    of the vector, your performance might take quite a hit, as it will force the vector
    to reallocate all data that comes after it. This is especially bothersome when
    implementing a queue. For this reason, Rust provides you with the `VecDeque`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要定期在向量的开始处插入或移除元素时，你的性能可能会受到很大的影响，因为这将迫使向量重新分配其后的所有数据。在实现队列时，这尤其令人烦恼。因此，Rust
    为你提供了 `VecDeque`。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the folder `src/bin`, create a file called `vecdeque.rs`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中创建一个名为 `vecdeque.rs` 的文件。
- en: 'Add the following code, and run it with `cargo run --bin vecdeque`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin vecdeque` 运行它：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Most of the interface of `VecDeque` is identical to `Vec`. You can even optimize
    them the same way with `with_capacity` and its `swap_remove` equivalents. The
    differences come from the fact that `VecDeque` is more oriented around access
    from both ends. As such, multiple methods from `Vec` that implicitly affect the
    last element have two equivalents in `VecDeque`: one for the front, and one for
    the back. These are:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`VecDeque` 的大多数接口与 `Vec` 相同。你甚至可以用 `with_capacity` 和其 `swap_remove` 等效方法以相同的方式优化它们。差异来自于
    `VecDeque` 更倾向于从两端进行访问。因此，`Vec` 中影响最后一个元素的多个方法在 `VecDeque` 中有两个等效方法：一个用于前端，一个用于后端。这些是：'
- en: '`push`, which becomes `push_front` [46] and `push_back` [11]'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push` 变成了 `push_front` [46] 和 `push_back` [11]'
- en: '`pop`, which becomes `pop_front` [16] and `pop_back` [55]'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop` 变成了 `pop_front` [16] 和 `pop_back` [55]'
- en: '`swap_remove`, which becomes `remove_front` [78] and `remove_back` [73]'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap_remove` 变成了 `remove_front` [78] 和 `remove_back` [73]'
- en: A `VecDeque` has the ability to freely append or remove elements from both ends
    in a performant way, which makes it an ideal candidate for a **First In, First
    Out** (**FIFO**) queue [24]. In fact, this is how it's nearly always used.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`VecDeque` 有能力以高效的方式从两端自由地追加或移除元素，这使得它成为 **先进先出**（**FIFO**）队列 [24] 的理想候选者。实际上，它几乎总是这样使用的。'
- en: When you see yourself in a situation where you want to respond to any kind of
    requests in the order they arrive in and remove them again afterwards, a `VecDeque`
    is an ideal tool for the job.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现自己处于一个想要按到达顺序响应任何请求并在之后再次移除它们的情境中时，`VecDeque` 是完成这项工作的理想工具。
- en: There's more...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Internally, the `VecDeque` is implemented as a *ring buffer*, also known as
    a *circular buffer*. It''s called like this because it behaves like a circle:
    the end touches the beginning.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`VecDeque` 被实现为一个 *环形缓冲区*，也称为 *循环缓冲区*。之所以这样称呼，是因为它的行为就像一个圆圈：末端触及起始端。
- en: It works by allocating a continuous block of memory, like the `Vec`; however,
    where the `Vec` always leaves its extra capacity at the end of the block, the
    `VecDeque` has nothing against leaving spots inside the block empty. It follows
    that when you remove the first element, the `VecDeque` doesn't move all elements
    to the left, but simply leaves the first spot empty. If you then push an element
    into the beginning via `push_front`, it will take the spot freed earlier while
    leaving the elements after it untouched.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过分配一个连续的内存块来工作，就像 `Vec` 一样；然而，`Vec` 总是在块的末尾留下额外的容量，而 `VecDeque` 对在块内部留下空位没有任何异议。因此，当你移除第一个元素时，`VecDeque`
    并不会将所有元素向左移动，而是简单地留下第一个空位。如果你然后通过 `push_front` 在开始处推入一个元素，它将占用之前释放的位置，而不会触及它后面的元素。
- en: 'The circular catch in the story is that if you have some capacity in the front
    of the block but none in the back while using `push_back`, the `VecDeque` will
    simply use that space to allocate the extra element, leading to the following
    situation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 故事中的循环陷阱在于，如果你在使用 `push_back` 时在块的前端有一些容量，但在后端没有，`VecDeque` 将会简单地使用那个空间来分配额外的元素，导致以下情况：
- en: '![](img/ecba1589-7d12-447b-8b59-88bc93e537c1.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecba1589-7d12-447b-8b59-88bc93e537c1.jpg)'
- en: This is great, because you will not have to worry about this at all while using
    it, as its iterating methods hide the implementation by always showing you the
    *correct* order!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为在使用它的时候，你根本不必担心这一点，因为它的迭代方法总是显示给你 *正确的* 顺序！
- en: Like the vector, `VecDeque` will resize itself and move all its elements into
    a new block when its capacity runs out.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像向量一样，当 `VecDeque` 的容量耗尽时，它会自动调整大小并将所有元素移动到一个新的块中。
- en: Using a HashMap
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HashMap
- en: If you imagine a `Vec` as a collection that assigns an index (0, 1, 2, and so
    on) to data, the `HashMap` is a collection that assigns any data to any data.
    It allows you to map arbitrary, hashable data to other arbitrary data. Hashing
    and mapping, that's where the name comes from!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想象一下 `Vec` 是一个将索引（0、1、2 等等）分配给数据的集合，那么 `HashMap` 就是一个将任何数据分配给任何数据的集合。它允许你将任意可哈希的数据映射到其他任意数据。哈希和映射，这就是名字的由来！
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the folder `src/bin`, create a file called `hashmap.rs`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中，创建一个名为 `hashmap.rs` 的文件。
- en: 'Add the following code, and run it with `cargo run --bin hashmap`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin hashmap` 运行它：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you don''t need to access both keys and values at the same time, you can
    iterate over either individually:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要同时访问键和值，你可以单独迭代任何一个：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can use the entry API to assign default values to keys if they''re not
    yet in the `HashMap`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 entry API 为不在 `HashMap` 中的键分配默认值：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As mentioned earlier, a `HashMap` is a collection to map one type of data to
    another. You do this by calling `insert`, and passing your key and its value [9].
    If the key already had a value, it will be overwritten. This is why `insert` returns
    an `Option`: if there was a value before, it returns the old value [27], or otherwise
    `None`. If you want to make sure that you''re not overwriting anything, make sure
    to check the result of `contains_key` [16] before inserting your value.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`HashMap` 是一个将一种类型的数据映射到另一种类型的集合。你是通过调用 `insert` 并传递你的键及其值 [9] 来做到这一点的。如果键已经有一个值，它将被覆盖。这就是为什么
    `insert` 返回一个 `Option`：如果之前有一个值，它返回旧值 [27]，否则返回 `None`。如果你想确保你没有覆盖任何东西，确保在插入你的值之前检查
    `contains_key` 的结果 [16]。
- en: Both `get` and `remove` won't crash when called with an invalid key. Instead,
    they return a `Result`. In the case of `remove`, said `Result` contains the removed
    value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用无效键调用 `get` 和 `remove` 时，它们都不会崩溃。相反，它们返回一个 `Result`。在 `remove` 的情况下，这个 `Result`
    包含被移除的值。
- en: 'As with most collections, you have the options to iterate over your data, by
    borrowing the key-value pairs[43], borrowing the keys while mutating the values
    [49], or moving them all [55]. Due to its nature, `HashMap` additionally allows
    you three more options: borrowing all values [74], mutating all values [80], or
    borrowing all keys [68]. You probably noticed that one combination is missing:
    you cannot mutate a key. Ever. This is part of the contract you sign when using
    a `HashMap`. Further down, where we explain how `HashMap` is implemented, you''re
    going to see that, because the key''s hash is actually an index, mutating a key
    is equivalent to deleting an entry and recreating it. This is reflected nicely
    in the design choice of not letting you modify keys.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数集合一样，你可以选择迭代你的数据，通过借用键值对[43]、在修改值的同时借用键[49]，或者移动它们全部[55]。由于其性质，`HashMap`
    还允许你另外三个选项：借用所有值[74]、修改所有值[80]或借用所有键[68]。你可能已经注意到，有一个组合是缺失的：你不能修改键。永远不能。这是你使用
    `HashMap` 时签订的合同的一部分。在下面解释 `HashMap` 的实现时，你会看到，因为键的哈希实际上是索引，修改键相当于删除条目并重新创建它。这一点在设计选择中得到了很好的体现，即不允许你修改键。
- en: 'Last but not least, the `Entry` API lets you access an abstraction of a value
    that might or might not be there. Most of the time, it''s used while being paired
    with `or_insert` in order to insert a default value if the key was not found [88].
    If you want to insert a default value based on a closure, you can use `or_insert_with`.
    Another use for the entry object is to match it against its variants: `Occupied`,
    or `Vacant`. This results in the same thing as calling `get` directly on a key.
    Note that in our example, we had to scope the entry access like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`Entry` API 允许你访问可能存在或不存在的一个值的抽象。大多数时候，它与 `or_insert` 配合使用，以便在找不到键时插入一个默认值
    [88]。如果你想根据闭包插入一个默认值，可以使用 `or_insert_with`。entry 对象的另一个用途是将其与其变体匹配：`Occupied`
    或 `Vacant`。这相当于直接在键上调用 `get`。请注意，在我们的例子中，我们必须这样限定 entry 的访问范围：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is because `or_insert` returns a mutable reference to a value. If we had
    omitted the scope, the second call of `entry` would have borrowed our `age` object
    at the same time as a mutable reference to it existed, which is an error in Rust's
    borrowing concept in order to guarantee data race-free access to resources.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `or_insert` 返回对值的可变引用。如果我们省略了范围，`entry` 的第二次调用就会在存在可变引用的同时借用我们的 `age` 对象，这在
    Rust 的借用概念中是一个错误，以确保对资源的无数据竞争访问。
- en: If you need to fine-tune your `HashMap` for performance, you can call your usual
    friends —`with_capacity` [60], `shrink_to_fit`, and `reserve` are also available
    for it, and work the same way as in other collections.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要针对性能微调你的 `HashMap`，你可以调用你的常用朋友——`with_capacity` [60]、`shrink_to_fit` 和
    `reserve` 也适用于它，并且以与其他集合相同的方式工作。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Internally, you can imagine the `HashMap` as being implemented as two vectors:
    a table, and a buffer. Of course, we''re simplifying here; there are actually
    no vectors in the implementation. But this analogy is accurate enough.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，你可以想象 `HashMap` 是作为两个向量实现的：一个表和一个缓冲区。当然，我们在这里简化了；实际上实现中并没有向量。但这个类比足够准确。
- en: 'If you want to look at the actual implementation, feel free to do so, as Rust
    is completely open source: [https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/table.rs.](https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/table.rs)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看实际的实现，请随意查看，因为Rust是完全开源的：[https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/table.rs.](https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/table.rs)
- en: 'In the background, the buffer stores our values in a sequential fashion. In
    the front, we have a table storing buckets that don''t do much more than point
    to the element they stand for. When you insert a key-value pair, what happens
    is:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，缓冲区以顺序方式存储我们的值。在前端，我们有一个表，存储着不做什么更多事情的桶，它们仅仅指向它们所代表的元素。当你插入一个键值对时，发生的情况是：
- en: The value gets put in the buffer.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值被放入缓冲区。
- en: The key goes through a hashing function and becomes an index.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键会通过一个哈希函数并成为索引。
- en: 'The table creates a bucket at said index that points to the actual value:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表在指定索引处创建一个指向实际值的桶：
- en: '![](img/5f00482e-36a3-42ad-8d5d-3c297234858a.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f00482e-36a3-42ad-8d5d-3c297234858a.jpg)'
- en: Rust's hashing algorithm doesn't actually generate unique indices, for performance
    reasons. Instead, Rust uses a clever way to handle hash collisions called **Robin
    Hood bucket stealing** ([http://codecapsule.com/2013/11/11/robin-hood-hashing/](http://codecapsule.com/2013/11/11/robin-hood-hashing/)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的哈希算法实际上并不生成唯一的索引，出于性能原因。相反，Rust 使用一种巧妙的方式来处理哈希冲突，称为 **罗宾汉桶偷窃** ([http://codecapsule.com/2013/11/11/robin-hood-hashing/](http://codecapsule.com/2013/11/11/robin-hood-hashing/))。
- en: The default hashing algorithm of the standard library has been chosen specifically
    to protect you from HashDoS attacks ([https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/](https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/)).
    If you want to squeeze out every bit of performance, you can do that, of your
    `HashMap` without caring about this particular risk, or you can specify a custom
    hasher by constructing it with `with_hasher`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的默认哈希算法被特别选择来保护你免受 HashDoS 攻击（[https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/](https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/)）。如果你想榨取每一分性能，你可以做到，在你的
    `HashMap` 中不考虑这个特定的风险，或者你可以通过使用 `with_hasher` 构造函数指定一个自定义的哈希器。
- en: Many people have already implemented various hashers on [crates.io](https://crates.io/),
    so make sure to check them out before rolling with your own solution.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人已经在 [crates.io](https://crates.io/) 上实现了各种哈希器，所以在自己动手实现解决方案之前，请务必检查它们。
- en: Using a HashSet
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HashSet
- en: 'The best way to describe a `HashSet` is by describing how it''s implemented:
    `HashMap<K, ()>`. It''s just a `HashMap` without any values!'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 `HashSet` 的最好方法就是描述它的实现方式：`HashMap<K, ()>`。它只是一个没有值的 `HashMap`！
- en: 'The two best reasons to choose a `HashSet` are:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `HashSet` 的两个最佳理由是：
- en: You don't want to deal with duplicate values at all, as it doesn't even include
    them.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你根本不想处理重复的值，因为它甚至不包括它们。
- en: You plan on doing a lot (and I mean a *lot*) of item lookup - that is the question, *Does
    my collection contain this particular item?*. In a vector, this is done in ![](img/c56fbb37-99dd-43e3-ade3-62e3fa3b3bbb.png),
    while a `HashSet` can do it in ![](img/935f6d04-873f-475c-9118-f78c55c2738a.png).
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你计划进行大量的（我指的是大量）项目查找——这是问题，*我的集合中是否包含这个特定的项目？* 在向量中，这是通过 ![](img/c56fbb37-99dd-43e3-ade3-62e3fa3b3bbb.png)
    完成的，而 `HashSet` 可以通过 ![](img/935f6d04-873f-475c-9118-f78c55c2738a.png) 完成它。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In the folder `src/bin`, create a file called `hashset.rs`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中创建一个名为 `hashset.rs` 的文件。
- en: 'Add the following code, and run it with `cargo run --bin hashset`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin hashset` 运行它：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compare different `HashSet`s:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较不同的 `HashSet`：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Join two `HashSet`s in various ways:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以各种方式连接两个 `HashSet`：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As a `HashSet` is a kind of `HashMap`, most of its interface is pretty similar.
    The major difference is that the methods that would return a key's value in the
    `HashMap` instead simply return a `bool` on the `HashSet` in order to tell if
    a key already existed or not [14].
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `HashSet` 是一种 `HashMap`，所以它的接口大部分都很相似。主要区别在于，在 `HashMap` 中会返回键的值的方法，在 `HashSet`
    中只是简单地返回一个 `bool` 来告诉是否已经存在该键 [14]。
- en: Additionally, `HashSet` brings a few methods for analyzing two sets [46 to 92]
    and joining them [96 to 131]. If you've ever heard of set theory or Venn diagrams,
    or done a bit of SQL, you're going to recognize it all. Otherwise, I advise you
    to run the example, and study the outputs in combination with the relevant comments.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`HashSet` 还提供了一些用于分析两个集合 [46 到 92] 和合并它们 [96 到 131] 的方法。如果你曾经听说过集合论或文氏图，或者做过一些
    SQL，你将能够识别所有这些。否则，我建议你运行示例，并结合相关的注释研究输出结果。
- en: 'Some illustrations might help you. For the analytical methods, the dark green
    part is the object of reference:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些插图可能有助于你。对于分析方法，深绿色部分是参考对象：
- en: '![](img/10d70a1a-add1-4a70-9aa8-4171a0333bfc.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10d70a1a-add1-4a70-9aa8-4171a0333bfc.png)'
- en: 'For the selecting methods, the dark green part is the one that is returned:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择方法，深绿色部分是返回的内容：
- en: '![](img/8e2fe489-c9f3-4564-bdeb-5ccc79a72941.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e2fe489-c9f3-4564-bdeb-5ccc79a72941.png)'
- en: There's more...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: No big surprises in the implementation of the `HashSet`, since it's exactly
    the same as the `HashMap`, just without any values!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet` 的实现没有太多惊喜，因为它与 `HashMap` 完全相同，只是没有任何值！'
- en: '![](img/3cdac45c-92c6-467d-9886-0dab7038cbaa.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cdac45c-92c6-467d-9886-0dab7038cbaa.jpg)'
- en: Creating an own iterator
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的迭代器
- en: When you create an infinitely applicable algorithm or a collection-like structure,
    it's really nice to have the dozens of methods that an iterator provides at your
    disposal. For this, you will have to know how to tell Rust to implement them for
    you.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个无限适用的算法或类似集合的结构时，拥有迭代器提供的数十种方法是非常有用的。为此，你必须知道如何告诉Rust为你实现它们。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the folder `src/bin`, create a file called `own_iterator.rs`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`own_iterator.rs`的文件。
- en: 'Add the following code, and run it with `cargo run --bin own_iterator`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin own_iterator`运行它：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In our little example here, we are going to look at two different uses for
    an iterator:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小例子中，我们将探讨迭代器的两种不同用途：
- en: '`fibonacci()`, which returns an infinite range of the **Fibonacci sequence**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fibonacci()`，它返回**斐波那契数列**的无穷范围'
- en: '`SquaredVec`, which implements a (very) small subset of a `Vec` with a twist:
    it squares all items'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SquaredVec`，它实现了一个（非常）小的`Vec`子集，有一个特点：它将所有项目平方'
- en: 'The Fibonacci sequence is defined as a series of numbers, starting from 0 and
    1, where the next number is the sum of the last two. It starts like this: 0, 1,
    1, 2, 3, 5, 8, 13, 21, and so on.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列被定义为一系列数字，从0和1开始，下一个数字是前两个数字的和。它开始如下：0, 1, 1, 2, 3, 5, 8, 13, 21，等等。
- en: The first two are 0 and 1 per definition. The next one is their sum — *0 + 1
    = 1*. After that comes *1 + 1 = 2*. Then *2 + 1 = 3*. *3 + 2 = 5*. Repeat ad infinitum.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，前两个数是0和1。下一个数是它们的和——*0 + 1 = 1*。然后是*1 + 1 = 2*。然后*2 + 1 = 3*。*3 + 2 = 5*。无限重复。
- en: An algorithm can be turned into an iterator by implementing the `Iterator` trait.
    This is pretty simple, as it only expects you to provide the type you're iterating
    over and a single method, `next`, which fetches the next item. If the iterator
    doesn't have any items left, it should return `None`, otherwise `Some`. Our Fibonacci
    iterator always returns `Some` item, which makes it an infinite iterator [31].
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`Iterator`特质，可以将一个算法转换为一个迭代器。这很简单，因为它只期望你提供正在迭代的类型和一个单一的方法`next`，该方法获取下一个项目。如果迭代器没有剩余的项目，它应该返回`None`，否则返回`Some`。我们的斐波那契迭代器总是返回`Some`项目，这使得它成为一个无穷迭代器[31]。
- en: Our `SquaredVec`, on the other hand, is more of a collection than an algorithm.
    In lines [37] to [53], we wrap the minimum of the `Vec` interface — we can create
    a `SquaredVec`, and we can fill it. Our type constraints `Mul + Copy` mean that
    the item the user wants to store has to be able to be copied and to be multiplied.
    We need this in order to square it, but it's not relevant for the iterator. `T::Output`
    is just the type that a multiplication would return, which most of the time is
    going to be `T` itself.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们的`SquaredVec`更像是一个集合而不是一个算法。在第[37]行到[53]行，我们包装了`Vec`接口的最小值——我们可以创建一个`SquaredVec`，并且可以填充它。我们的类型约束`Mul
    + Copy`意味着用户想要存储的项目必须能够被复制并且能够被乘。我们需要这样做以便平方它，但对于迭代器来说并不相关。`T::Output`只是一个乘法会返回的类型，通常情况下它将是`T`本身。
- en: We could implement the `Iterator` trait again, but there's an easier option
    that will provide you with even more methods. We can allow our struct to be implicitly
    convertible into a slice `[T]`, which will not only implement `Iterator` for you,
    but also a whole bunch of other methods. Because `Vec` implements it already,
    you can just return it like that [67]. If your underlying collection didn't provide
    a slice conversion, you could still go the same way as before and implement the
    `Iterator` trait manually.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次实现`Iterator`特质，但有一个更简单的方法可以为你提供更多方法。我们可以允许我们的结构体隐式转换为切片`[T]`，这将不仅为你实现`Iterator`，还会实现一大堆其他方法。因为`Vec`已经实现了它，所以你可以直接返回它[67]。如果你的底层集合没有提供切片转换，你仍然可以像以前一样手动实现`Iterator`特质。
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you have a lot of complex logic to perform in the iterator and want to separate
    it a bit from your collection, you can do so by providing your collection with
    the `IntoIterator` trait instead. This would allow you to return a struct specifically
    made for your iteration, which itself provides the `Iterator` trait.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在迭代器中执行很多复杂的逻辑，并且想要将它们与集合稍微分离，你可以通过为你的集合提供`IntoIterator`特质来实现这一点。这将允许你返回一个专门为迭代制作的struct，它本身提供了`Iterator`特质。
- en: Using a slab
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用一块板
- en: Some algorithms require you to hold access tokens to data that may or may not
    exist. This could be solved in Rust by using  `Vec<Option<T>>`, and treating the
    index of your data as a token. But we can do better! `slab` is an optimized abstraction
    of exactly this concept.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法要求你持有可能存在或不存在的数据的访问令牌。在Rust中，可以通过使用`Vec<Option<T>>`并把你数据索引当作令牌来解决。但我们可以做得更好！`slab`正是这个概念的优化抽象。
- en: While it is not meant as a general-purpose collection, `slab` can help you a
    lot if you use it in the right places.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不是一种通用集合，但如果使用得当，`slab`可以为你提供很多帮助。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`下添加以下行：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you want, you can go to slab's crates.io page ([https://crates.io/crates/slab](https://crates.io/crates/slab))
    to check for the newest version, and use that one instead.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想，你可以访问slab的crates.io页面([https://crates.io/crates/slab](https://crates.io/crates/slab))来检查最新版本，并使用那个版本。
- en: In the folder `bin`, create a file called `slab.rs`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中创建一个名为`slab.rs`的文件。
- en: 'Add the following code, and run it with `cargo run --bin slab`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin slab`运行它：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A slab is very similar to a vector, with one quintessential difference: you
    don''t get to choose your index. Instead, when inserting data [15], you receive
    the data''s index as a kind of *key* that you can use to access it again. It is
    your responsibility to store this key somewhere; otherwise, the only way to retrieve
    your data is by iterating over your slab. The flipside is that you don''t have
    to provide any key either. In contrast to a `HashMap`, you don''t need any hashable
    objects at all.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 块非常类似于向量，有一个本质的区别：你无法选择你的索引。相反，在插入数据[15]时，你会收到数据的索引作为一种*密钥*，你可以用它再次访问它。这是你的责任，将这个密钥存储在某个地方；否则，检索你的数据的唯一方法就是遍历你的块。另一方面，你也不需要提供任何密钥。与`HashMap`不同，你根本不需要任何可哈希的对象。
- en: 'A situation in which this is useful is in a connection pool: if you have multiple
    clients who want to access individual resources, you can store said resources
    in a slab and provide the clients with their key as a kind of token.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在连接池中很有用：如果你有多个客户端想要访问单个资源，你可以在块中存储这些资源，并为客户提供其密钥作为令牌。
- en: This example suits the second use case of a slab really well. Suppose you only
    accept a certain amount of connections at a given time. When accepting a connection,
    you don't care about the exact index, or the way it is stored. Instead, you care
    only that it is stored in a retrievable way, and that it doesn't exceed your limit.
    This fits the bill of the slab quite nicely, which is why most of the time you
    won't be creating a slab with `Slab::new()`, but with `with_capacity`, set to
    a constant upper limit [9].
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常适合块的第二种用途。假设你只在特定时间内接受一定数量的连接。在建立连接时，你并不关心确切的索引或存储方式。相反，你只关心它以可检索的方式存储，并且不超过你的限制。这非常适合块，这也是为什么大多数时候你不会使用`Slab::new()`创建块，而是使用`with_capacity`，将其设置为常数上限[9]。
- en: 'The slab, however, does not impose this limit by itself, as it behaves exactly
    like the vector in the way it handles capacity: as soon as the length exceeds
    the capacity, the slab reallocates all objects to a bigger block of memory and
    ups the capacity. This is why, when dealing with upper bonds, you should insert
    your data with some kind of variation of line [38]:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，块本身并不通过这种方式设置限制，因为它在处理容量方面与向量表现得完全一样：一旦长度超过容量，块就会将所有对象重新分配到更大的内存块中，并提高容量。这就是为什么在处理上限时，你应该使用某种变体的行[38]插入你的数据：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Other valid approaches would be to wrap an insertion in a function that returns
    a `Result`, or an `Option`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有效的方法包括将插入操作包裹在一个返回`Result`或`Option`的函数中。
- en: There's more...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A slab is backed by a `Vec<Entry>`. You might remember the `Entry` from our
    recipe about the `HashMap` earlier. It is the same as an `Option`, with the difference
    that its variants are not called `Some(...)` and `None`, but `Occupied(...)` and
    `Vacant`. This means that, in a nutshell, a slab is implemented as a vector with
    holes in it:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个块由一个`Vec<Entry>`支持。你可能还记得我们之前关于`HashMap`的配方中的`Entry`。它与`Option`相同，区别在于其变体不称为`Some(...)`和`None`，而是`Occupied(...)`和`Vacant`。这意味着简而言之，一个块被实现为一个带有空位的向量：
- en: '![](img/cbef86f3-406c-4974-b3a9-5779da64a90e.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbef86f3-406c-4974-b3a9-5779da64a90e.jpg)'
- en: Additionally, in order to guarantee fast occupation of vacant spots, the slab
    keeps a linked list of all vacant entries.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了保证快速占用空位，该板保留了一个所有空条目的链表。
