- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Coroutines and async/await
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程和async/await
- en: Now that you’ve gotten a brief introduction to Rust’s async model, it’s time
    to take a look at how this fits in the context of everything else we’ve covered
    in this book so far.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经对Rust的异步模型有了简要的了解，是时候看看它如何与我们在这本书中迄今为止所涵盖的其他内容相契合了。
- en: Rust’s futures are an example of an asynchronous model based on stackless coroutines,
    and in this chapter, we’ll take a look at what that really means and how it differs
    from stackful coroutines (fibers/green threads).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的未来是一个基于无栈协程的异步模型示例，在本章中，我们将探讨这究竟意味着什么，以及它与有栈协程（纤程/绿色线程）有何不同。
- en: We’ll center everything around an example based on a simplified model of futures
    and `async/await` and see how we can use that to create suspendable and resumable
    tasks just like we did when creating our own fibers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以基于简化模型的未来和`async/await`的示例为中心，看看我们如何使用它来创建可挂起和可恢复的任务，就像我们创建自己的纤程时做的那样。
- en: The good news is that this is a lot easier than implementing our own fibers/green
    threads since we can stay in Rust, which is safer. The flip side is that it’s
    a little more abstract and ties into programming language theory as much as it
    does computer science.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，这比实现我们自己的纤程/绿色线程容易得多，因为我们可以留在Rust中，这更安全。不利的一面是，它稍微抽象一些，并且与编程语言理论以及计算机科学紧密相关。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Introduction to stackless coroutines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无栈协程简介
- en: An example of hand-written coroutines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手写协程的例子
- en: '`async/await`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async/await`'
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples in this chapter will all be cross-platform, so the only thing you
    need is Rust installed and the repository that belongs to the book downloaded
    locally. All the code in this chapter will be found in the `ch07` folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都将跨平台，所以你唯一需要的是安装Rust以及下载属于本书的本地存储库。本章中的所有代码都将位于`ch07`文件夹中。
- en: We’ll use `delayserver` in this example as well, so you need to open a terminal,
    enter the `delayserver` folder at the root of the repository, and write `cargo
    run` so it’s ready and available for the examples going forward.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们也将使用`delayserver`，所以你需要打开一个终端，进入存储库根目录下的`delayserver`文件夹，并运行`cargo
    run`，以便它为后续的示例准备好并可用。
- en: Remember to change the ports in the code if you for some reason have to change
    what port `delayserver` listens on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因为某种原因你需要更改`delayserver`监听的端口号，请记住更改代码中的端口号。
- en: Introduction to stackless coroutines
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无栈协程简介
- en: So, we’ve finally arrived at the point where we introduce the last method of
    modeling asynchronous operations in this book. You probably remember that we gave
    a high-level overview of stackful and stackless coroutines in [*Chapter 2*](B20892_02.xhtml#_idTextAnchor043).
    In [*Chapter 5*](B20892_05.xhtml#_idTextAnchor092), we implemented an example
    of stackful coroutines when writing our own fibers/green threads, so now it’s
    time to take a closer look at how stackless coroutines are implemented and used.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们终于到达了介绍本书中建模异步操作最后一种方法的点。你可能还记得，我们在[*第二章*](B20892_02.xhtml#_idTextAnchor043)中给出了关于有栈和无栈协程的高级概述。在[*第五章*](B20892_05.xhtml#_idTextAnchor092)中，我们在编写自己的纤程/绿色线程时实现了一个有栈协程的例子，所以现在我们该更深入地看看无栈协程是如何实现和使用的。
- en: A stackless coroutine is a way of representing a task that can be interrupted
    and resumed. If you remember all the way back in [*Chapter 1*](B20892_01.xhtml#_idTextAnchor014),
    we mentioned that if we want tasks to run concurrently (be *in progress* at the
    same time) but not necessarily in parallel, we need to be able to **pause and
    resume** the task.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在[*第一章*](B20892_01.xhtml#_idTextAnchor014)中我们提到，如果我们想让任务并发运行（同时进行），但不一定并行，我们需要能够**暂停和恢复**任务。
- en: In its simplest form, a coroutine is just a task that can stop and resume by
    yielding control to either its caller, another coroutine, or a scheduler.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，协程只是一个可以通过将控制权交还给其调用者、另一个协程或调度器来暂停和恢复的任务。
- en: Many languages will have a coroutine implementation that also provides a runtime
    that handles scheduling and non-blocking I/O for you, but it’s helpful to make
    a distinction between what a coroutine is and the rest of the machinery involved
    in creating an asynchronous system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言都将有一个协程实现，它还提供了一个运行时，为你处理调度和非阻塞I/O，但区分协程是什么以及创建异步系统所涉及的其余机制是有帮助的。
- en: This is especially true in Rust, since Rust doesn’t come with a runtime and
    only provides the infrastructure you need to create coroutines that have native
    support in the language. Rust makes sure that everyone programming in Rust uses
    the same abstraction for tasks that can be paused and resumed, but it leaves all
    the other details of getting an asynchronous system up and running for the programmer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Rust 中尤其如此，因为 Rust 没有提供运行时，只提供了创建具有语言原生支持的协程所需的基础设施。Rust 确保所有使用 Rust 编程的人使用相同的抽象来处理可以暂停和恢复的任务，但它将所有其他使异步系统启动和运行的具体细节留给程序员。
- en: Stackless coroutines or just coroutines?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无栈协程或仅仅是协程？
- en: Most often you’ll see *stackless coroutines* simply referred to as *coroutines*.
    To try to keep some consistency (you remember I don’t like to introduce terms
    that mean different things based on the context), I’ve consistently referred to
    coroutines as either *stackless* or *stackful*, but going forward, I’ll simply
    refer to stackless coroutines as **coroutines**. This is also what you’ll have
    to expect when reading about them in other sources.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是，你会看到*无栈协程*简单地被称为*协程*。为了保持一致性（你还记得我不喜欢根据上下文引入具有不同含义的术语），我一直将协程称为*无栈*或*有栈*，但今后，我只需简单地称无栈协程为**协程**。这也是你在其他来源阅读关于它们时可以期待的内容。
- en: Fibers/green threads represent this kind of resumable task in a very similar
    way to how an operating system does. A task has a stack where it stores/restores
    its current execution state, making it possible to pause and resume the task.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 纤维/绿色线程以与操作系统非常相似的方式表示这种可恢复的任务。一个任务有一个栈，其中存储/恢复其当前执行状态，使其能够暂停和恢复任务。
- en: A state machine in its simplest form is a data structure that has a predetermined
    set of states it can be in. In the case of coroutines, each state represents a
    possible pause/resume point. We don’t store the state needed to pause/resume the
    task in a separate stack. We save it in a data structure instead.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机在其最简单的形式中是一个具有预定义状态集的数据结构。在协程的情况下，每个状态代表一个可能的暂停/恢复点。我们不将暂停/恢复任务的所需状态存储在单独的栈中，而是将其保存在数据结构中。
- en: This has some advantages, which I’ve covered before, but the most prominent
    ones are that they’re very efficient and flexible. The downside is that you’d
    never want to write these state machines by hand (you’ll see why in this chapter),
    so you need some kind of support from the compiler or another mechanism for rewriting
    your code to state machines instead of normal function calls.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些优点，我之前已经介绍过，但最突出的是它们非常高效和灵活。缺点是，你永远不会想手动编写这些状态机（你将在本章中看到原因），因此你需要来自编译器或其他机制的支持来重写你的代码，使其成为状态机而不是正常函数调用。
- en: The result is that you get something that looks very simple. It looks like a
    function/subroutine that you can easily map to something that you can run using
    a simple `call` instruction in assembly, but what you actually get is something
    pretty complex and different from this, and it doesn’t look anything like what
    you’d expect.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，你得到的是一个看起来非常简单的东西。它看起来像是一个函数/子程序，你可以很容易地将其映射到可以使用简单的汇编`call`指令运行的东西，但实际上你得到的是一个相当复杂且与预期不同的东西，它看起来也不像你期望的那样。
- en: Generators vs coroutines
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器与协程的比较
- en: Generators are state machines as well, exactly the kind we’ll cover in this
    chapter. They’re usually implemented in a language to create state machines that
    yield values to the calling function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器也是状态机，正是我们将在本章中介绍的那种。它们通常在一种语言中实现，以创建向调用函数产生值的州机。
- en: Theoretically, you could make a distinction between coroutines and generators
    based on what they yield to. Generators are usually limited to yielding to the
    calling function. Coroutines can yield to another coroutine, a scheduler, or simply
    the caller, in which case they’re just like generators.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，你可以根据它们产生的结果来区分协程和生成器。生成器通常仅限于向调用函数产生结果。协程可以产生结果给另一个协程、调度器或简单地给调用者，在这种情况下，它们就像生成器一样。
- en: In my eyes, there is really no point in making a distinction between them. They
    represent the same underlying mechanism for creating tasks that can pause and
    resume their executions, so in this book, we’ll treat them as basically the same
    thing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，在它们之间做出区分实际上没有意义。它们代表了创建可以暂停和恢复执行的任务的相同底层机制，因此在这本书中，我们将它们视为基本上是同一件事。
- en: Now that we’ve covered what coroutines are in text, we can start looking at
    what they look like in code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用文字描述了什么是协程，我们可以开始看看它们在代码中的样子。
- en: An example of hand-written coroutines
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手写协程的例子
- en: 'The example we’ll use going forward is a simplified version of Rust’s asynchronous
    model. We’ll create and implement the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要使用的例子是 Rust 异步模型的简化版本。我们将创建和实现以下内容：
- en: Our own simplified `Future` trait
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们自己的简化版 `Future` trait
- en: A simple HTTP client that can only make GET requests
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个只能执行 GET 请求的简单 HTTP 客户端
- en: A task we can pause and resume implemented as a state machine
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以暂停和恢复的任务，实现为一个状态机
- en: Our own simplified `async/await` syntax called `coroutine/wait`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们自己的简化版 `async/await` 语法称为 `coroutine/wait`
- en: A homemade preprocessor to transform our `coroutine/wait` functions into state
    machines the same way `async/await` is transformed
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自制的预处理器，将我们的 `coroutine/wait` 函数转换成状态机，就像 `async/await` 被转换一样
- en: So, to actually demystify coroutines, futures, and `async/await`, we will have
    to make some compromises. If we didn’t, we’d end up re-implementing everything
    that is `async/await` and futures in Rust today, which is too much for just understanding
    the underlying techniques and concepts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正揭开协程、未来和 `async/await` 的神秘面纱，我们不得不做一些妥协。如果我们不这样做，我们最终会重新实现今天 Rust 中所有的 `async/await`
    和未来，这对于仅仅理解底层技术和概念来说太多了。
- en: 'Therefore, our example will do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的例子将做以下事情：
- en: Avoid error handling. If anything fails, we panic.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免错误处理。如果发生任何失败，我们将引发恐慌。
- en: Be specific and not generic. Creating generic solutions introduces a lot of
    complexity and makes the underlying concepts harder to reason about since we consequently
    have to create extra abstraction levels. Our solution will have some generic aspects
    where needed, though.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要具体，而不是泛化。创建泛型解决方案会引入很多复杂性，并使得底层概念更难推理，因为我们随后不得不创建额外的抽象层。尽管如此，我们的解决方案在需要的地方将有一些泛型方面。
- en: Be limited in what it can do. You are of course free to expand, change, and
    play with all the examples (I encourage you to do so), but in the example, we
    only cover what we need and not anything more.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在它能做什么方面有限制。你当然可以自由地扩展、更改和玩转所有这些例子（我鼓励你这样做），但在例子中，我们只涵盖我们需要的内容，而不是更多。
- en: Avoid macros.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免宏。
- en: So, with that out of the way, let’s get started on our example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在解决完这些问题后，让我们开始我们的例子。
- en: The first thing you need to do is to create a new folder. This first example
    can be found in `ch07/a-coroutine` in the repository, so I suggest you name the
    folder `a-coroutine` as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是创建一个新的文件夹。这个第一个例子可以在仓库中的 `ch07/a-coroutine` 目录下找到，所以我建议你也将其命名为 `a-coroutine`。
- en: Then, initialize a new crate by entering the folder and write `cargo init`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进入文件夹并运行 `cargo init` 来初始化一个新的 crate。
- en: 'Now that we have a new project up and running, we can create the modules and
    folders we need:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新项目正在运行，我们可以创建我们需要的模块和文件夹：
- en: 'First, in `main.rs`, declare two modules as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `main.rs` 中，声明两个模块如下：
- en: ch07/a-coroutine/src/main.rs
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/main.rs
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, create two new files in the `src` folder:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `src` 文件夹中创建两个新文件：
- en: '`future.rs`, which will hold our future-related code'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`future.rs`，将包含我们的未来相关代码'
- en: '`http.rs`, which will be the code related to our HTTP client'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.rs`，它将包含我们 HTTP 客户端相关的代码'
- en: 'One last thing we need to do is to add a dependency on `mio`. We’ll be using
    `TcpStream` from `mio`, as we’ll build on this example in the following chapters
    and use `mio` as our non-blocking I/O library since we’re already familiar with
    it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的一件事是添加对 `mio` 的依赖。我们将使用 `mio` 中的 `TcpStream`，因为我们将在接下来的章节中构建这个例子，并使用
    `mio` 作为我们的非阻塞 I/O 库，因为我们已经熟悉它：
- en: ch07/a-coroutine/Cargo.toml
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/Cargo.toml
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s start in `future.rs` and implement our future-related code first.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `future.rs` 开始，并首先实现我们的未来相关代码。
- en: Futures module
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Futures 模块
- en: 'In `futures.rs`, the first thing we’ll do is define a `Future` trait. It looks
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `futures.rs` 中，我们首先将定义一个 `Future` trait。它看起来如下：
- en: ch07/a-coroutine/src/future.rs
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/future.rs
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we contrast this with the `Future` trait in Rust’s standard library, you’ll
    see it’s very similar, except that we don’t take `cx: &mut Context<''_>` as an
    argument and we return an `enum` with a slightly different name just to differentiate
    it so we don’t mix them up:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们将它与 Rust 标准库中的 `Future` trait 进行对比，你会发现它们非常相似，除了我们不取 `cx: &mut Context<''_>`
    作为参数，并且我们返回一个具有不同名称的 `enum`，只是为了区分它们，以免混淆：'
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next thing we do is to define a `PollState<T>` `enum`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的是定义一个 `PollState<T>` `enum`：
- en: ch07/a-coroutine/src/future.rs
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/future.rs
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Again, if we compare this to the `Poll` `enum` in Rust’s standard library,
    we see that they’re practically the same:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们将其与 Rust 标准库中的 `Poll` 枚举进行比较，我们会发现它们实际上是一样的：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For now, this is all we need to get the first iteration of our example up and
    running. Let’s move on to the next file: `http.rs`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使我们的示例的第一个迭代能够运行，我们只需要这些。让我们继续到下一个文件：`http.rs`。
- en: HTTP module
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 模块
- en: In this module, we’ll implement a very simple HTTP client. This client can only
    make GET requests to our `delayserver` since we just use this as a representation
    of a typical I/O operation and don’t care specifically about being able to do
    more than we need.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我们将实现一个非常简单的 HTTP 客户端。这个客户端只能向我们的 `delayserver` 发送 GET 请求，因为我们只是用它来表示典型的
    I/O 操作，并不关心能否做更多我们不需要的事情。
- en: 'The first thing we’ll do is import some types and traits from the standard
    library as well as our `Futures` module:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将一些类型和特质从标准库以及我们的 `Futures` 模块导入：
- en: ch07/a-coroutine/src/http.rs
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/http.rs
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we create a small helper function to write our HTTP requests. We’ve used
    this exact bit of code before in this book, so I’ll not spend time explaining
    it again here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个小的辅助函数来编写我们的 HTTP 请求。我们之前在这本书中已经使用过这段代码，所以在这里我不会再次解释它：
- en: ch07/a-coroutine/src/http.rs
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/http.rs
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, now we can start writing our HTTP client. The implementation is very short
    and simple:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以开始编写我们的 HTTP 客户端了。实现非常简短且简单：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We don’t really need a struct here, but we add one since we might want to add
    some state at a later point. It’s also a good way to group functions belonging
    to the HTTP client together.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实际上并不需要一个结构体，但我们添加了一个，因为我们可能在以后某个时刻想要添加一些状态。这也是将属于 HTTP 客户端的功能分组在一起的好方法。
- en: 'Our HTTP client only has one function, `get`, which, eventually, will send
    a GET request to our `delayserver` with the path we specify (remember that the
    path is everything in bold in this example URL: `http://127.0.0.1:8080`**/1000/HelloWorld)**,'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 HTTP 客户端只有一个函数，即 `get`，它最终会向我们的 `delayserver` 发送一个带有指定路径的 GET 请求（记住，在这个示例
    URL 中，路径是所有加粗的内容：`http://127.0.0.1:8080`**/1000/HelloWorld**），
- en: The first thing you’ll notice in the function body is that there is not much
    happening here. We only return `HttpGetFuture` and that’s it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，你首先会注意到这里并没有发生太多事情。我们只返回 `HttpGetFuture`，就这么多。
- en: In the function signature, you see that it returns an object implementing the
    `Future` trait that outputs a `String` when it’s resolved. The string we return
    from this function will be the response we get from the server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名中，你可以看到它返回一个实现 `Future` 特质的对象，当它解析时输出一个 `String`。从这个函数返回的字符串将是来自服务器的响应。
- en: Now, we could have implemented the future trait directly on the `Http` struct,
    but I think it’s a better design to allow one `Http` instance to give out multiple
    `Futures` instead of making the `Http` implement `Future` itself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们本可以直接在 `Http` 结构体上实现 future 特质，但我认为更好的设计是允许一个 `Http` 实例提供多个 `Futures`，而不是让
    `Http` 本身实现 `Future`。
- en: Let’s take a closer look at `HttpGetFuture` since there is much more happening
    there.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `HttpGetFuture`，因为那里发生的事情更多。
- en: Just to point this out so that there is no doubt going forward, `HttpGetFuture`
    is an example of a **leaf future**, and it will be the only leaf future we’ll
    use in this example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了指出，以免将来有疑问，`HttpGetFuture` 是一个**叶子未来**的例子，并且它将是我们在本例中使用的唯一叶子未来。
- en: 'Let’s add the struct declaration to the file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在文件中添加结构体声明：
- en: ch07/a-coroutine/src/http.rs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/http.rs
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This data structure will hold onto some data for us:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据结构将为我们保存一些数据：
- en: '`stream`: This holds an `Option<mio::net::TcpStream>`. This will be an `Option`
    since we won’t connect to the stream at the same point as we create this structure.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream`：这保存了一个 `Option<mio::net::TcpStream>`。这将是 `Option`，因为我们不会在创建此结构的同时连接到流。'
- en: '`buffer`: We’ll read the data from the `TcpStream` and put it all in this buffer
    until we’ve read all the data returned from the server.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`：我们将从 `TcpStream` 读取数据并将其全部放入这个缓冲区，直到我们读取了服务器返回的所有数据。'
- en: '`path`: This simply stores the path for our GET request so we can use it later.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这个简单地存储了我们的 GET 请求的路径，以便我们以后可以使用它。'
- en: 'The next thing we’ll take a look at is the `impl` block for our `HttpGetFuture`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的是 `HttpGetFuture` 的 `impl` 块：
- en: ch07/a-coroutine/src/http.rs
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/http.rs
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `impl` block defines two functions. The first is `new`, which simply sets
    the initial state.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`impl` 块定义了两个函数。第一个是 `new`，它只是设置初始状态。'
- en: The next function is `write_requst`, which sends the GET request to the server.
    You’ve seen this code before in the example in [*Chapter 4*](B20892_04.xhtml#_idTextAnchor081),
    so this should look familiar.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是`write_requst`，它将GET请求发送到服务器。您在[*第4章*](B20892_04.xhtml#_idTextAnchor081)的示例中已经看到过这段代码，所以这应该看起来很熟悉。
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When *creating* `HttpGetFuture`, we don’t actually *do* anything related to
    the GET request, which means that the call to `Http::get` returns immediately
    with just a simple data structure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当*创建* `HttpGetFuture`时，我们实际上并没有做任何与GET请求相关的事情，这意味着对`Http::get`的调用会立即返回，只带有一个简单的数据结构。
- en: In contrast to earlier examples, we pass in the *IP address* for `localhost`
    instead of the DNS name. We take the same shortcut as before and let `connect`
    be blocking and everything else be non-blocking.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期示例相比，我们传递了`localhost`的*IP地址*而不是DNS名称。我们采取与之前相同的捷径，让`connect`是阻塞的，而其他一切都是非阻塞的。
- en: The next step is to write the GET request to the server. This will be non-blocking,
    and we don’t have to wait for it to finish since we’ll be waiting for the response
    anyway.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向服务器发送GET请求。这将是非阻塞的，我们不需要等待它完成，因为我们无论如何都会等待响应。
- en: 'The last part of this file is the most important one—the implementation of
    the `Future` trait we defined:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的最后一部分是最重要的——我们定义的`Future`特质的实现：
- en: ch07/a-coroutine/src/http.rs
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/http.rs
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Okay, so this is where everything happens. The first thing we do is set the
    associated type called `Output` to `String`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以这里就是一切发生的地方。我们首先做的事情是将关联类型`Output`设置为`String`。
- en: The next thing we do is to check whether this is the first time `poll` was called
    or not. We do this by checking if `self.stream` is `None`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的就是检查这是否是第一次调用`poll`。我们通过检查`self.stream`是否为`None`来完成这个操作。
- en: If it’s the first time we call `poll`, we print a message (just so we can see
    the first time this future was polled), and then we write the GET request to the
    server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是我们第一次调用`poll`，我们会打印一条消息（只是为了看到第一次这个future被轮询的情况），然后我们将GET请求写入服务器。
- en: On the first poll, we return `PollState::NotReady`, so `HttpGetFuture` will
    have to be polled at least once more to actually return any results.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次轮询时，我们返回`PollState::NotReady`，因此`HttpGetFuture`至少还需要被轮询一次才能返回任何结果。
- en: The next part of the function is trying to read data from our `TcpStream`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的下一部分尝试从我们的`TcpStream`读取数据。
- en: 'We’ve covered this before, so I’ll make this brief, but there are basically
    five things that can happen:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过这个问题，所以我会简要说明，但基本上有五件事情可能发生：
- en: The call successfully returns with `0` bytes read. We’ve read all the data from
    the stream and have received the entire GET response. We create a `String` from
    the data we’ve read and wrap it in `PollState::Ready` before we return.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用成功返回，读取了`0`个字节。我们已经从流中读取了所有数据，并收到了整个GET响应。我们在返回之前，从读取的数据中创建一个`String`并将其包装在`PollState::Ready`中。
- en: The call successfully returns with `n > 0` bytes read. If that’s the case, we
    read the data into our buffer, append the data into `self.buffer`, and immediately
    try to read more data from the stream.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用成功返回，读取了`n > 0`个字节。如果是这种情况，我们将数据读取到我们的缓冲区中，将数据追加到`self.buffer`中，并立即尝试从流中读取更多数据。
- en: We get an error of kind `WouldBlock`. If that’s the case, we know that since
    we set the stream to non-blocking, the data isn’t ready yet or there is more data
    but we haven’t received it yet. In that case, we return `PollState::NotReady`
    to communicate that more calls to the poll are needed to finish the operation.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到一个`WouldBlock`类型的错误。如果是这种情况，我们知道由于我们将流设置为非阻塞，数据尚未准备好或者有更多数据但我们尚未收到。在这种情况下，我们返回`PollState::NotReady`以表明需要更多轮询调用来完成操作。
- en: We get an error of kind `Interrupted`. This is a bit of a special case since
    reads can be interrupted by a signal. If it does, the usual way to handle the
    error is to simply try reading once more.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到一个`Interrupted`类型的错误。这是一个特殊情况，因为读取可以被信号中断。如果发生这种情况，处理错误的通常方式是简单地再次尝试读取。
- en: We get an error that we can’t handle, and since our example does no error handling,
    we simply `panic!`
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到一个我们无法处理的错误，并且由于我们的示例没有进行错误处理，我们简单地`panic!`
- en: 'There is one subtle thing I want to point out. We can view this as a very simple
    state machine with three states:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个微妙的地方我想指出。我们可以将其视为一个非常简单的具有三个状态的状态机：
- en: Not started, indicated by `self.stream` being `None`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未开始，由`self.stream`为`None`表示
- en: Pending, indicated by `self.stream` being `Some` and a read to `stream.read`
    returning `WouldBlock`
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待中，由`self.stream`为`Some`且对`stream.read`的读取返回`WouldBlock`表示
- en: Resolved, indicated by `self.stream` being `Some` and a call to `stream.read`
    returning `0` bytes
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已解决，通过`self.stream`为`Some`以及调用`stream.read`返回`0`字节来指示
- en: As you see, this model maps nicely to the states reported by the OS when trying
    to read our `TcpStream`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个模型很好地映射到了操作系统在尝试读取我们的`TcpStream`时报告的状态。
- en: Most leaf futures such as this will be quite simple, and although we didn’t
    make the states explicit here, it still fits in the state machine model that we’re
    basing our coroutines around.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数像这样的叶子未来将会非常简单，尽管我们没有在这里明确状态，但它仍然适合我们基于协程构建的状态机模型。
- en: Do all futures have to be lazy?
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有未来都必须是懒加载的吗？
- en: A lazy future is one where no work happens before it’s polled the first time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载的未来是在它第一次被轮询之前不执行任何工作。
- en: This will come up a lot if you read about futures in Rust, and since our own
    `Future` trait is based on that exact same model, the same question will arise
    here. The simple answer to this question is no!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读关于 Rust 中的未来的内容，这会经常出现，并且由于我们的`Future`特例正是基于这个模型，同样的问题也会在这里出现。对这个问题的简单回答是：不！
- en: There is nothing that forces leaf futures, such as the one we wrote here, to
    be lazy. We could have sent the HTTP request when we called the `Http::get` function
    if we wanted to. If you think about it, if we did just that, it would have caused
    a potentially big change that would impact how we achieve concurrency in our program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么强制叶子未来，比如我们在这里写的，必须是懒加载的。如果我们想在调用 `Http::get` 函数时发送 HTTP 请求，我们可以这样做。如果你这么想，如果我们只是这样做，这可能会引起一个可能很大的变化，从而影响我们在程序中实现并发的方式。
- en: The way it works now is that someone has to call `poll` at least one time to
    actually send the request. The consequence is that whoever calls `poll` on this
    future will have to call `poll` on many futures to kick off the operation if they
    want them to run concurrently.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的工作方式是，必须有人至少调用一次 `poll` 来实际发送请求。结果是，调用这个未来的 `poll` 的人将不得不对许多未来调用 `poll`，如果他们想让它们并发运行的话。
- en: If we kicked off the operation immediately when the future was created, you
    could create many futures and they would all run concurrently even though you
    polled them to completion one by one. If you poll them to completion one by one
    in the current design, the futures would *not* progress concurrently. Let that
    sink in for a moment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在创建未来时立即启动操作，你可以创建许多未来，即使你逐个轮询它们以完成，它们也会并发运行。如果你在当前设计中逐个轮询它们以完成，未来将不会并发地前进。请稍作思考。
- en: Languages such as JavaScript start the operation when the coroutine is created,
    so there is no “one way” to do this. Every time you encounter a coroutine implementation,
    you should find out whether they’re lazy or eager since this impacts how you program
    with them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 JavaScript 这样的语言在协程创建时就开始执行操作，因此没有“一种方式”来做这件事。每次遇到协程实现时，你应该找出它们是懒加载的还是急加载的，因为这将影响你如何使用它们编程。
- en: Even though we could make our future eager in this case, we really shouldn’t.
    Since programmers in Rust expect futures to be lazy, they might depend on nothing
    happening before you call `poll` on them, and there may be unexpected side effects
    if the futures you write behave differently.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这种情况下我们可以使我们的未来变得急加载，但我们实际上不应该这样做。由于 Rust 中的程序员期望未来是懒加载的，他们可能会依赖于在你对它们调用
    `poll` 之前不发生任何事情，如果你写的未来行为不同，可能会有意外的副作用。
- en: Now, when you read that Rust’s futures are always lazy, a claim that I see very
    often, it refers to the compiler-generated state machines resulting from using
    `async/await`. As we’ll see later, when your async functions are rewritten by
    the compiler, they’re constructed in a way so that nothing you write in the body
    of an `async` function will execute before the first call to `Future::poll`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你读到 Rust 的未来总是懒加载的，这是一个我经常看到的说法，它指的是使用 `async/await` 生成的编译器生成的状态机。正如我们稍后将会看到的，当你的异步函数被编译器重写时，它们是以一种方式构建的，这样你在一个
    `async` 函数体中写的任何内容都不会在第一次调用 `Future::poll` 之前执行。
- en: Okay, so we’ve covered the `Future` trait and the leaf future we named `HttpGetFuture`.
    The next step is to create a task that we can stop and resume at predefined points.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们已经涵盖了`Future`特性和我们命名为`HttpGetFuture`的叶子未来。下一步是创建一个可以在预定义点停止和恢复的任务。
- en: Creating coroutines
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建协程
- en: We’ll continue to build our knowledge and understanding from the ground up.
    The first thing we’ll do is create a task that we can stop and resume by modeling
    it as a state machine by hand.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从零开始构建我们的知识和理解。我们首先要做的是创建一个可以通过将其建模为手动状态机来停止和恢复的任务。
- en: Once we’ve done that, we’ll take a look at how this way of modeling pausable
    tasks enables us to write a syntax much like `async/await` and rely on code transformations
    to create these state machines instead of writing them by hand.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成，我们将看看这种建模暂停任务的方式如何使我们能够编写类似于`async/await`的语法，并依赖于代码转换来创建这些状态机，而不是手动编写它们。
- en: 'We’ll create a simple program that does the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的程序，它将执行以下操作：
- en: Prints a message when our pausable task is starting.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们的暂停任务开始时打印一条消息。
- en: Makes a GET request to our `delayserver`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的`delayserver`发起GET请求。
- en: Waits for the GET request.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待GET请求。
- en: Prints the response from the server.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印来自服务器的响应。
- en: Makes a second GET request to our `delayserver`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的`delayserver`发起第二次GET请求。
- en: Waits for the second response from the server.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待来自服务器的第二次响应。
- en: Prints the response from the server.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印来自服务器的响应。
- en: Exits the program.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出程序。
- en: In addition, we’ll execute our program by calling `Future::poll` on our hand-crafted
    coroutine as many times as required to run it to completion. There’s no runtime,
    reactor, or executor yet since we’ll cover those in the next chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将通过在自定义协程上多次调用`Future::poll`来执行我们的程序，直到运行完成。目前还没有运行时、反应器或执行器，因为我们将这些内容留到下一章介绍。
- en: 'If we wrote our program as an `async` function, it would look as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将程序编写为一个`async`函数，它将如下所示：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `main.rs`, start by making the necessary imports and module declarations:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.rs`中，首先进行必要的导入和模块声明：
- en: ch07/a-coroutine/src/main.rs
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/main.rs
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next thing we write is our stoppable/resumable task called `Coroutine`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要写的是我们的可停止/可恢复任务，称为`Coroutine`：
- en: ch07/a-coroutine/src/main.rs
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/main.rs
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once that’s done, we write the different states this task could be in:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们将编写这个任务可能处于的不同状态：
- en: ch07/a-coroutine/src/main.rs
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/main.rs
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This specific coroutine can be in four states:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的协程可以处于四种状态：
- en: '`Coroutine` has been created but it hasn’t been polled yet'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Coroutine`已创建，但尚未被轮询。'
- en: '`Http::get`, we get a `HttpGetFuture` returned that we store in the `State`
    `enum`. At this point, we return control back to the calling function so it can
    do other things if needed. We chose to make this generic over all `Future` functions
    that output a `String`, but since we only have one kind of future right now, we
    could have made it simply hold a `HttpGetFuture` and it would work the same way.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Http::get`，我们得到一个存储在`State` `enum`中的`HttpGetFuture`返回值。在此点，我们将控制权交回调用函数，以便它可以在需要时执行其他操作。我们选择使其对所有输出`String`的`Future`函数是通用的，但由于我们目前只有一种类型的未来，我们也可以简单地使其仅持有`HttpGetFuture`，它将以相同的方式工作。'
- en: '`Http::get` is the second place where we’ll pass control back to the calling
    function.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Http::get`是我们将控制权交回调用函数的第二个地方。'
- en: '**Resolved**: The future is resolved and there is no more work to do.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已解决**：未来已解决，没有更多的工作要做。'
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We could have simply defined `Coroutine` as an `enum` since the only state it
    holds is an `enum` indicating its state. But, we’ll set up this example so we
    can add some state to `Coroutine` later on in this book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以直接将`Coroutine`定义为`enum`，因为它只持有表示其状态的`enum`。但我们将设置这个示例，以便我们可以在本书的后面部分添加一些状态到`Coroutine`。
- en: 'Next is the implementation of `Coroutine`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Coroutine`的实现：
- en: ch07/a-coroutine/src/main.rs
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/main.rs
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So far, this is pretty simple. When creating a new `Coroutine`, we simply set
    it to `State::Start` and that’s it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这相当简单。当创建一个新的`Coroutine`时，我们只需将其设置为`State::Start`即可。
- en: 'Now we come to the part where the work is actually done in the `Future` implementation
    for `Coroutine`. I’ll walk you through the code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了实际工作在`Coroutine`的`Future`实现部分。我将带您浏览代码：
- en: ch07/a-coroutine/src/main.rs
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/main.rs
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s start from the top:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从顶部开始：
- en: The first thing we do is set the `Output` type to `()`. Since we won’t be returning
    anything, it just makes our example simpler.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将`Output`类型设置为`()`。由于我们不会返回任何内容，这仅仅使我们的示例更简单。
- en: Next up is the implementation of the `poll` method. The first thing you notice
    is that we write a `loop` instance that matches `self.state`. We do this so we
    can drive the state machine forward until we reach a point where we can’t progress
    any further without getting `PollState::NotReady` from one of our child futures.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`poll`方法的实现。首先您会注意到我们写了一个匹配`self.state`的`loop`实例。我们这样做是为了推动状态机向前发展，直到我们达到一个点，没有从我们的子未来中获得`PollState::NotReady`我们就无法进一步进展。
- en: If the state is `State::Start`, we know that this is the first time it was polled,
    so we run whatever instructions we need until we reach the point where we get
    a new future that we need to resolve.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果状态是`State::Start`，我们知道这是第一次被轮询，所以我们运行我们需要运行的任何指令，直到我们到达需要解决的新未来的点。
- en: When we call `Http::get`, we receive a future in return that we need to poll
    to completion before we progress any further.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们调用`Http::get`时，我们返回一个需要在我们进一步进展之前完成轮询的未来。
- en: At this point, we change the state to `State::Wait1` and we store the future
    we want to resolve so we can access it in the next state.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们将状态更改为`State::Wait1`，并存储我们想要解析的未来，以便在下一个状态中访问它。
- en: Our state machine has now changed its state from `Start` to `Wait1`. Since we’re
    looping on the `match` statement, we immediately progress to the next state and
    will reach the match arm in `State::Wait1` on the next iteration.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的状态机现在已从`Start`变为`Wait1`。由于我们在`match`语句上循环，我们立即进入下一个状态，并在下一次迭代中到达`State::Wait1`的匹配分支。
- en: The first thing we do in `Wait1` to call `poll` on the `Future` instance we’re
    waiting on.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Wait1`中，我们首先对等待的`Future`实例调用`poll`。
- en: If the future returns `PollState::NotReady`, we simply bubble that up to the
    caller by breaking out of the loop and returning `NotReady`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未来返回`PollState::NotReady`，我们只需将其冒泡到调用者处，通过跳出循环并返回`NotReady`。
- en: If the future returns `PollState::Ready` together with our data, we know that
    we can execute the instructions that rely on the data from the first future and
    advance to the next state. In our case, we only print out the returned data, so
    that’s only one line of code.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未来返回`PollState::Ready`并附带我们的数据，我们知道我们可以执行依赖于第一个未来数据的指令，并进入下一个状态。在我们的情况下，我们只打印出返回的数据，所以这只有一行代码。
- en: Next, we get to the point where we get a new future by calling `Http::get`.
    We set the state to `Wait2`, just like we did when going from `State::Start` to
    `State::Wait1`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用`Http::get`获得一个新的未来。我们将状态设置为`Wait2`，就像我们从`State::Start`到`State::Wait1`所做的那样。
- en: Like we did the first time we got a future that we needed to resolve before
    we continue, we save it so we can access it in `State::Wait2`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像第一次我们得到一个需要在继续之前解决的未来一样，我们将其保存起来，以便在`State::Wait2`中访问它。
- en: Since we’re in a loop, the next thing that happens is that we reach the matching
    arm for `Wait2`, and here, we repeat the same steps as we did for `State::Wait1`
    but on a different future.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们处于循环中，接下来发生的事情是我们到达`Wait2`的匹配分支，在这里，我们重复与`State::Wait1`相同的步骤，但针对不同的未来。
- en: 'If it returns `Ready` with our data, we act on it and we set the final state
    of our `Coroutine` to `State::Resolved`. There is one more important change: this
    time, we want to communicate to the caller that this future is done, so we break
    out of the loop and return `PollState::Ready`.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它返回带有我们的数据的`Ready`，我们就采取行动，并将我们的`Coroutine`的最终状态设置为`State::Resolved`。还有一个重要的变化：这次，我们希望通知调用者这个未来已经完成，所以我们跳出循环并返回`PollState::Ready`。
- en: 'If anyone tries to call `poll` on our `Coroutine` again, we will panic, so
    the caller must make sure to keep track of when the future returns `PollState::Ready`
    and make sure to not call `poll` on it ever again. The last thing we do before
    we get to our `main` function is create a new `Coroutine` in a function we call
    `async_main`. This way, we can keep the changes to a minimum when we start talking
    about `async/await` in the last part of this chapter:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人试图再次在我们的`Coroutine`上调用`poll`，我们将引发恐慌，因此调用者必须确保跟踪未来何时返回`PollState::Ready`，并确保永远不再调用它。在我们到达`main`函数之前做的最后一件事是在我们称为`async_main`的函数中创建一个新的`Coroutine`。这样，当我们在本章的最后部分讨论`async/await`时，我们可以将更改保持在最小：
- en: ch07/a-coroutine/src/main.rs
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/main.rs
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, at this point, we’re finished writing our coroutine and the only thing left
    is to write some logic to drive our state machine through its different stages
    of the `main` function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个点上，我们已经完成了协程的编写，剩下要做的就是编写一些逻辑来通过`main`函数的不同阶段驱动状态机。
- en: 'One thing to note here is that our main function is just a regular main function.
    The loop in our main function is what drives the asynchronous operations to completion:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的一点是，我们的主函数只是一个普通的主函数。我们主函数中的循环驱动异步操作完成：
- en: ch07/a-coroutine/src/main.rs
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/a-coroutine/src/main.rs
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function is very simple. We first get the future returned from `async_main`
    and then we call `poll` on it in a loop until it returns `PollState::Ready`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单。我们首先获取`async_main`返回的未来，然后在一个循环中对其调用`poll`，直到它返回`PollState::Ready`。
- en: Every time we receive a `PollState::NotReady` in return, the control is yielded
    back to us. we could do other work here, such as scheduling another task, if we
    want to, but in our case, we just print `Schedule` `other tasks`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们收到 `PollState::NotReady` 的返回值时，控制权就交回到了我们这里。如果我们想的话，我们在这里可以做一些其他的工作，比如安排另一个任务，但在这个例子中，我们只是打印
    `安排` `其他任务`。
- en: We also limit how often the loop is run by sleeping for 100 milliseconds on
    every call. This way we won’t be overwhelmed with printouts and we can assume
    that there are roughly 100 milliseconds between every time we see `"Schedule other
    tasks"` printed to the console.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过在每次调用时暂停100毫秒来限制循环的运行频率。这样我们不会因为打印输出而感到不知所措，并且我们可以假设每次我们在控制台看到 `"安排其他任务"`
    打印出来之间大约有100毫秒的时间间隔。
- en: 'If we run the example, we get this output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个例子，我们会得到以下输出：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By looking at the printouts, you can get an idea of the program flow.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看打印输出，你可以了解程序流程。
- en: First, we see `Program starting`, which executes at the start of our coroutine.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们看到 `程序开始`，这是在协程开始时执行的。
- en: We then see that we immediately move on to the `FIRST POLL – START OPERATION`
    message that we only print when the future returned from our HTTP client is polled
    the first time.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着看到，我们立即跳转到 `第一次轮询 – 开始操作` 的消息，我们只在从我们的HTTP客户端返回的未来对象第一次轮询时打印这个消息。
- en: Next, we can see that we’re back in our `main` function, and at this point,
    we could theoretically go ahead and run other tasks if we had any
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到我们又回到了 `main` 函数中，在这个时候，如果我们有其他任务，理论上我们可以继续运行其他任务
- en: Every 100 ms, we check if the task is finished and get the same message telling
    us that we can schedule other tasks
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每100毫秒，我们检查任务是否完成，并得到同样的消息，告诉我们可以安排其他任务
- en: Then, after roughly 600 milliseconds, we receive a response that’s printed out
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，大约600毫秒后，我们收到一个打印出来的响应
- en: We repeat the process once more until we receive and print out the second response
    from the server
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复这个过程，直到我们收到并打印出从服务器返回的第二响应
- en: Congratulations, you’ve now created a task that can be paused and resumed at
    different points, allowing it to be in progress.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你现在创建了一个可以在不同点暂停和恢复的任务，允许它在进行中。
- en: Who on earth wants to write code like this to accomplish a simple task?
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谁会想写这样的代码来完成一个简单的任务呢？
- en: The answer is no one!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是没有一个人！
- en: Yes, it’s a bit bombastic, but I dare guess that very few programmers prefer
    writing a 55-line state machine when you compare it to the 7 lines of normal sequential
    code you’d have to write to accomplish the same thing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这听起来有点夸张，但我敢猜测，与编写55行状态机相比，很少有程序员更喜欢编写7行正常的顺序代码来完成相同的事情。
- en: 'If we recall the goals of most userland abstractions over concurrent operations,
    we’ll see that this way of doing it only checks one of the three boxes that we’re
    aiming for:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下大多数用户空间并发操作的抽象目标，我们会发现这种做法只检查了我们想要达到的三个目标中的一个：
- en: Efficient
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效
- en: Expressive
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达性
- en: Easy to use and hard to misuse
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用且难以误用
- en: Our state machine will be efficient, but that’s pretty much it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态机将会是高效的，但这基本上就是全部了。
- en: However, you might also notice that there is a system to the craziness. This
    might not come as a surprise, but the code we wrote could be much simpler if we
    tagged the start of each function and each point we wanted to yield control back
    to the caller with a few keywords and had our state machine generated for us.
    And that’s the basic idea behind `async/await`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也可能注意到，这种疯狂中其实有一定的规律。这可能不会让你感到惊讶，但如果我们在每个函数的开始和每个我们想要将控制权交还给调用者的点使用几个关键字进行标记，并且由系统为我们生成状态机，那么我们编写的代码可能会简单得多。这正是
    `async/await` 的基本理念。
- en: Let’s go and see how this would work in our example.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去看看在我们的例子中这会如何工作。
- en: async/await
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async/await
- en: 'The previous example could simply be written as the following using `async/await`
    keywords:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子可以简单地用 `async/await` 关键字写成以下形式：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That’s seven lines of code, and it looks very familiar to code you’d write in
    a normal subroutine/function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有七行代码，看起来非常熟悉，就像你在一个普通的子例程/函数中编写的代码一样。
- en: It turns out that we can let the compiler write these state machines for us
    instead of writing them ourselves. Not only that, we could get very far just using
    simple macros to help us, which is exactly how the current `async/await` syntax
    was prototyped before it became a part of the language. You can see an example
    of that at [https://github.com/alexcrichton/futures-await](https://github.com/alexcrichton/futures-await).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们可以让编译器为我们编写这些状态机，而不是自己编写。不仅如此，我们只需使用简单的宏来帮助我们，这正是当前的 `async/await` 语法在成为语言一部分之前的原型设计方式。您可以在[https://github.com/alexcrichton/futures-await](https://github.com/alexcrichton/futures-await)中看到一个例子。
- en: The downside is of course that these functions look like normal subroutines
    but are in fact very different in nature. With a strongly typed language such
    as Rust, which borrow semantics instead of using a garbage collector, it’s impossible
    to hide the fact that these functions are different. This can cause a bit of confusion
    for programmers, who expect everything to behave the same way.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，缺点是这些函数看起来像普通的子程序，但实际上在本质上非常不同。在像 Rust 这样的强类型语言中，它使用借用语义而不是垃圾回收器，不可能隐藏这些函数是不同的这一事实。这可能会让程序员感到困惑，因为他们期望一切都能以相同的方式表现。
- en: Coroutine bonus example
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Coroutine bonus example
- en: To show how close our example is to the behavior we get using the `std::future:::Future`
    trait and `async/await` in Rust, I created the exact same example as we just did
    in `a-coroutines` using “proper” futures and the `async/await` syntax instead.
    The first thing you’ll notice is that it only required very minor changes to the
    code. Secondly, you can see for yourself that the output shows the exact same
    program flow as it did in the example where we hand-wrote the state machine ourselves.
    You will find this example in the `ch07/a-coroutines-bonus` folder in the repository.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们的例子与使用 Rust 中的 `std::future:::Future` 特性和 `async/await` 所获得的行为有多接近，我创建了一个与我们在
    `a-coroutines` 中所做的完全相同的例子，使用“正确”的未来和 `async/await` 语法。您首先会注意到，这只需要对代码进行非常小的修改。其次，您可以亲自看到输出显示了与我们在自己编写状态机的例子中完全相同的程序流程。您将在存储库的
    `ch07/a-coroutines-bonus` 文件夹中找到这个例子。
- en: So, let’s take this a step further. To avoid confusion, and since our coroutines
    only yield to the calling function right now (there is no scheduler, event loop,
    or anything like that yet), we use a slightly different syntax called `coroutine/wait`
    and create a way to have these state machines generated for us.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们更进一步。为了避免混淆，并且由于我们的协程目前只向调用函数让步（还没有调度器、事件循环或类似的东西），我们使用一种稍微不同的语法，称为 `coroutine/wait`，并创建一种让我们自己生成这些状态机的方法。
- en: coroutine/wait
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: coroutine/wait
- en: The `coroutine/wait` syntax will have clear similarities to the `async/await`
    syntax, although it’s a lot more limited.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`coroutine/wait` 语法将与 `async/await` 语法有明显的相似之处，尽管它要有限得多。'
- en: 'The basic rules are as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 基本规则如下：
- en: Every function prefixed with `coroutine` will be rewritten to a state machine
    like the one we wrote.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个以 `coroutine` 前缀的函数都将被重写为类似于我们编写的状态机。
- en: The return type of functions marked with `coroutine` will be rewritten so they
    return `-> impl Future<Output = String>` (yes, our syntax will only deal with
    futures that output a `String`).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数上标记为 `coroutine` 的返回类型将被重写，以便它们返回 `-> impl Future<Output = String>`（是的，我们的语法将仅处理输出为
    `String` 的未来）。
- en: Only objects implementing the `Future` trait can be postfixed with `.wait`.
    These points will be represented as separate stages in our state machine.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有实现了 `Future` 特性的对象才能后缀 `.wait`。这些点将在我们的状态机中表示为单独的阶段。
- en: Functions prefixed with `coroutine` can call normal functions, but normal functions
    can’t call `coroutine` functions and expect anything to happen unless they call
    `poll` on them repeatedly until they return `PollState::Ready`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `coroutine` 前缀的函数可以调用普通函数，但普通函数不能调用 `coroutine` 函数并期望有任何动作发生，除非它们反复调用 `poll`
    直到返回 `PollState::Ready`。
- en: 'Our implementation will make sure that if we write the following code, it will
    compile to the same state machine we wrote at the start of this chapter(with the
    exception that all coroutines will return a String):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现将确保如果我们编写以下代码，它将编译为我们在本章开头编写的相同状态机（除了所有协程都将返回一个 String）：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But wait. `coroutine/wait` aren’t valid keywords in Rust. I would get a compilation
    error if I wrote that!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。`coroutine/wait` 在 Rust 中不是有效的关键字。如果我那样写，我会得到编译错误！
- en: You’re right. So, I created a small program called `corofy` that rewrites the
    `coroutine/wait` functions into these state machines for us. Let’s explain that
    quickly.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你是对的。所以，我创建了一个名为`corofy`的小程序，它将`coroutine/wait`函数重写为我们这些状态机。让我们快速解释一下。
- en: corofy—the coroutine preprocessor
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: corofy——协程预处理器
- en: The best way of rewriting code in Rust is using the macro system. The downside
    is that it’s not clear exactly what it compiles down to, and expanding the macros
    is not optimal for our use case since one of the main goals is to take a look
    at the differences between the code we write and what it transforms into. In addition
    to that, macros can get quite complex to read and understand unless you work a
    lot with them on a regular basis.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中重写代码的最佳方式是使用宏系统。缺点是它并不清楚它最终编译成什么样子，而且对于我们的使用场景来说，展开宏并不是最优的，因为我们的主要目标之一是查看我们编写的代码与它转换成的内容之间的差异。此外，除非你经常使用宏，否则宏可能会变得相当复杂，难以阅读和理解。
- en: Instead, corofy is a normal Rust program you can find in the repository under
    `ch07/corofy`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，corofy是你可以从仓库中的`ch07/corofy`下找到的正常Rust程序。
- en: 'If you enter that folder, you can install the tool globally by writing the
    following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入那个文件夹，你可以通过写下以下内容来全局安装该工具：
- en: '[PRE23]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now you can use the tool from anywhere. It works by providing it with an input
    file containing the `coroutine/wait` syntax, such as `corofy ./src/main.rs [optional
    output file]`. If you don’t specify an output file, it will create a file in the
    same folder postfixed with `_corofied`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以从任何地方使用这个工具了。它通过提供一个包含`coroutine/wait`语法的输入文件来工作，例如`corofy ./src/main.rs
    [可选输出文件]`。如果你没有指定输出文件，它将在同一文件夹中创建一个以`_corofied`后缀命名的文件。
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The tool is extremely limited. The honest reason why is that I want to finish
    this example before we reach the year 2300, and I finished rewriting the entire
    Rust compiler from scratch just to give a robust experience using the `coroutine/wait`
    keywords.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的功能极其有限。诚实的理由是我想在我们到达2300年之前完成这个示例，而且我重新从头开始重写了整个Rust编译器，只是为了提供一个使用`coroutine/wait`关键字时的稳健体验。
- en: It turns out that writing transformations like this without access to Rust’s
    type system is very difficult. The main use case for this tool will be to transform
    the examples we write here, but it would probably work for slight variations of
    the same examples as well (like adding more wait points or doing more interesting
    tasks in between each wait point). Take a look at the README for `corofy` for
    more information about its limitations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在没有访问Rust的类型系统的情况下编写这样的转换是非常困难的。这个工具的主要用途将是转换我们在这里编写的示例，但它可能也适用于相同示例的微小变化（比如添加更多的等待点或在每个等待点之间执行更有趣的任务）。有关`corofy`的限制，请参阅README。
- en: 'One more thing: I assume that you specified no explicit output file going forward
    so the output file will have the same name as the input file postfixed with `_corofied`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：我假设你指定了没有明确的输出文件，所以输出文件将与输入文件同名，后缀为`_corofied`。
- en: The program reads the file you give it and searches for usages of the `coroutine`
    keyword. It takes these functions, comments them out (so they’re still in the
    file), puts them last in the file, and writes out the state machine implementation
    directly below, indicating what parts of the state machine are the code you actually
    wrote between the `wait` points.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 程序读取你给出的文件，并搜索`coroutine`关键字的用法。它将这些函数注释掉（这样它们仍然在文件中），将它们放在文件末尾，并在`wait`点下面直接写出状态机实现，指出状态机的哪些部分是你实际上在`wait`点之间编写的代码。
- en: Now that I’ve introduced our new tool, it’s time to put it to use.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经介绍了我们的新工具，是时候开始使用了。
- en: b-async-await—an example of a coroutine/wait transformation
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: b-async-await——一个协程/wait转换的示例
- en: Let’s start by expanding our example slightly. Now that we have a program that
    writes out our state machines, it’s easier for us to create some examples and
    cover some more complex parts of our coroutine implementation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先稍微扩展一下我们的示例。现在我们有一个程序可以输出我们的状态机，这样我们更容易创建一些示例并涵盖我们协程实现的一些更复杂的部分。
- en: We’ll base the following examples on the exact same code as we did in the first
    one. In the repository, you’ll find this example under `ch07/b-async-await`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下面的示例将基于与第一个示例完全相同的代码。在仓库中，你可以在`ch07/b-async-await`下找到这个示例。
- en: 'If you write every example from the book and don’t rely on the existing code
    in the repository, you can do one of two things:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从书中编写每个示例并且不依赖于仓库中的现有代码，你可以做两件事之一：
- en: Keep changing the code in the first example
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不断更改第一个示例中的代码
- en: Create a new cargo project called `b-async-await` and copy everything in the
    `src` folder and the `dependencies` section from `Cargo.toml` from the previous
    example over to the new one.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的cargo项目，命名为`b-async-await`，并将上一个示例中的`src`文件夹和`Cargo.toml`中的`dependencies`部分的所有内容复制到新的项目中。
- en: No matter what you choose, you should have the same code in front of you.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择什么，你都应该在你面前有相同的代码。
- en: 'Let’s simply change the code in `main.rs` to this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单地将`main.rs`中的代码更改为以下内容：
- en: ch07/b-async-await/src/main.rs
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/b-async-await/src/main.rs
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code contains a few changes. First, we add a convenience function for creating
    new paths for our GET request called `get_path` to create a path we can use in
    our GET request with a delay and a message based on the integer we pass in.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了一些更改。首先，我们添加了一个方便的函数`get_path`，用于创建新的路径，以便我们可以在GET请求中使用它，并基于我们传递的整数添加延迟和消息。
- en: Next, in our `async_main` function, we create five requests with delays varying
    from `0` to `4` seconds.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的`async_main`函数中，我们创建了五个具有从`0`到`4`秒不同延迟的请求。
- en: The last change we’ve made is in our `main` function. We no longer print out
    a message on every call to poll, and therefore, we don’t use `thread::sleep` to
    limit the number of calls. Instead, we measure the time from when we enter the
    `main` function to when we exit it because we can use that as a way to prove whether
    our code runs concurrently or not.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的最后一个更改是在我们的`main`函数中。我们不再在每次调用`poll`时打印消息，因此，我们不再使用`thread::sleep`来限制调用次数。相反，我们测量从我们进入`main`函数到退出它的时间，因为我们可以用这个作为证明我们的代码是否并发运行的方法。
- en: 'Now that our `main.rs` looks like the preceding example, we can use `corofy`
    to rewrite it into a state machine, so assuming we’re in the root folder of `ch07/b-async-await`,
    we can write the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于我们的`main.rs`看起来与前面的示例相同，我们可以使用`corofy`将其重写为一个状态机，所以假设我们处于`ch07/b-async-await`的根目录中，我们可以编写以下内容：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That should output a file called `main_corofied.rs` in the `src` folder that
    you can open and inspect.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在`src`文件夹中输出一个名为`main_corofied.rs`的文件，你可以打开并检查它。
- en: Now, you can copy all the contents of `main_corofied.rs` in this file and paste
    it into `main.rs`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以复制这个文件中`main_corofied.rs`的所有内容，并将其粘贴到`main.rs`中。
- en: Note
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For convenience, there is a file called `original_main.rs` in the root of the
    project that contains the code for `main.rs` that we presented, so you don’t need
    to save the original content of `main.rs`. If you write out every example yourself
    by copying it from the book in your own project, it would be smart to store the
    original contents of `main.rs` somewhere before you overwrite it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，项目根目录中有一个名为`original_main.rs`的文件，其中包含我们之前展示的`main.rs`的代码，所以你不需要保存`main.rs`的原始内容。如果你通过从书中的项目复制它来自己编写每个示例，在你覆盖它之前将`main.rs`的原始内容存储在某个地方是明智的。
- en: 'I won’t show the entire state machine here since the 39 lines of code using
    `coroutine/wait` end up being 170 lines of code when written as a state machine,
    but our `State` `enum` now looks like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里展示整个状态机，因为使用`coroutine/wait`编写的39行代码在作为状态机编写时变成了170行代码，但我们的`State` `enum`现在看起来像这样：
- en: '[PRE26]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run the program using `cargo run`, you now get the following output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`cargo run`运行程序，你现在会得到以下输出：
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, you see that our code runs as expected.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你看，我们的代码按预期运行。
- en: Since we called `wait` on every call to `Http::get`, the code ran sequentially,
    which is evident when we look at the elapsed time of 10 seconds.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在每次调用`Http::get`时都调用了`wait`，代码是顺序执行的，当我们查看10秒的经过时间时，这一点很明显。
- en: That makes sense since the delays we asked for were `0 + 1 + 2 + 3 + 4`, which
    equals 10 seconds.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意义的，因为我们请求的延迟是`0 + 1 + 2 + 3 + 4`，等于10秒。
- en: What if we want our futures to run concurrently?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让我们的未来运行并发呢？
- en: Do you remember we talked about these futures being *lazy*? Good. So, you know
    that we won’t get concurrency just by creating a future. We need to poll them
    to start the operation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们讨论过这些未来是*懒的*吗？很好。所以，你知道仅仅创建一个未来并不能获得并发性。我们需要轮询它们以启动操作。
- en: To solve this, we take some inspiration from `join_all`. It takes a collection
    of futures and drives them all to completion concurrently.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们借鉴了`join_all`的一些灵感。它接受一组未来，并将它们并发地驱动到完成。
- en: Let’s create the last example for this chapter where we do just this.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这一章创建最后一个示例，其中我们只做这件事。
- en: c-async-await—concurrent futures
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: c-async-await—并发未来
- en: Okay, so we’ll build on the last example and do just the same thing. Create
    a new project called `c-async-await` and copy `Cargo.toml` and everything in the
    `src` folder over.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们将基于上一个示例继续进行，并做同样的事情。创建一个名为 `c-async-await` 的新项目，并将 `Cargo.toml` 和 `src`
    文件夹中的所有内容复制过来。
- en: 'The first thing we’ll do is go to `future.rs` and add a `join_all` function
    below our existing code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的事情是去 `future.rs` 并在我们的现有代码下方添加一个 `join_all` 函数：
- en: ch07/c-async-await/src/future.rs
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/c-async-await/src/future.rs
- en: '[PRE28]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function takes a collection of futures as an argument and returns a `JoinAll<F>`
    future.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个未来集合作为参数，并返回一个 `JoinAll<F>` 未来。
- en: The function simply creates a new collection. In this collection, we will have
    tuples consisting of the original futures we received and a `bool` value indicating
    whether the future is resolved or not.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是创建一个新的集合。在这个集合中，我们将有由我们收到的原始未来和一个表示未来是否解决的 `bool` 值组成的元组。
- en: 'Next, we have the definition of our `JoinAll` struct:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们 `JoinAll` 结构体的定义：
- en: ch07/c-async-await/src/future.rs
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ch07/c-async-await/src/future.rs
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This struct will simply store the collection we created and a `finished_count`.
    The last field will make it a little bit easier to keep track of how many futures
    have been resolved.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体将简单地存储我们创建的集合和一个 `finished_count`。最后一个字段将使跟踪有多少未来被解决变得稍微容易一些。
- en: 'As we’re getting used to by now, most of the interesting parts happen in the
    `Future` implementation for `JoinAll`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所习惯的，大多数有趣的部分都发生在 `JoinAll` 的 `Future` 实现中：
- en: '[PRE30]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We set `Output` to `String`. This might strike you as strange since we don’t
    actually return anything from this implementation. The reason is that `corofy`
    will only work with futures that return a `String` (it’s one of its many, many
    shortcomings), so we just accept that and return an empty string on completion.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Output` 设置为 `String`。这可能会让你感到奇怪，因为我们实际上并没有从这个实现中返回任何东西。原因是 `corofy` 只与返回
    `String` 的未来一起工作（这是它许多缺点之一），所以我们只是接受这一点，并在完成时返回一个空字符串。
- en: 'Next up is our `poll` implementation. The first thing we do is to loop over
    each (flag, future) tuple:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `poll` 实现的下一步。我们首先对每个（标志，未来）元组进行循环：
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Inside the loop, we first check if the flag for this future is set to `finished`.
    If it is, we simply go to the next item in the collection.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们首先检查这个未来的标志是否设置为 `finished`。如果是，我们只需转到集合中的下一个项目。
- en: If it’s not finished, we `poll` the future.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它还没有完成，我们 `poll` 这个未来。
- en: If we get `PollState::Ready` back, we set the flag for this future to `true`
    so that we won’t poll it again and we increase the finished count.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到 `PollState::Ready`，我们将这个未来的标志设置为 `true`，这样我们就不会再次轮询它，并增加完成计数。
- en: Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s worth noting that the `join_all` implementation we create here will not
    work in any meaningful way with futures that return a value. In our case, we simply
    throw the value away, but remember, we’re trying to keep this as simple as possible
    for now and the only thing we want to show is the concurrency aspect of calling
    `join_all`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在这里创建的 `join_all` 实现不会以任何有意义的方式与返回值的未来一起工作。在我们的例子中，我们只是扔掉了这个值，但请记住，我们现在试图尽可能保持简单，我们只想展示调用
    `join_all` 的并发方面。
- en: Tokio’s `join_all` implementation puts all the returned values in a `Vec<T>`
    and returns them when the `JoinAll` future resolves.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Tokio 的 `join_all` 实现将所有返回的值放入一个 `Vec<T>` 中，并在 `JoinAll` 未来解决时返回它们。
- en: If we get `PollState::NotReady`, we simply continue to the next future in the
    collection.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到 `PollState::NotReady`，我们只需继续到集合中的下一个未来。
- en: After iterating through the entire collection, we check if we’ve resolved all
    the futures we originally received in `if self.finished_count ==` `self.futures.len()`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历整个集合之后，我们检查我们是否已经解决了最初收到的所有未来，在 `if self.finished_count == self.futures.len()`。
- en: If all our futures have been resolved, we return `PollState::Ready` with an
    empty string (to make `corofy` happy). If there are still unresolved futures,
    we return `PollState::NotReady`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们所有的未来都已经被解决，我们将返回 `PollState::Ready` 并带一个空字符串（为了使 `corofy` 满意）。如果还有未解决的未来，我们将返回
    `PollState::NotReady`。
- en: Important
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: There is one subtle point to make a note of here. The first time `JoinAll::poll`
    is called, it will call `poll` on each future in the collection. Polling each
    future will kick off whatever operation they represent and allow them to *progress
    concurrently*. This is one way to achieve concurrency with lazy coroutines, such
    as the ones we’re dealing with here.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个需要注意的微妙之处。第一次调用`JoinAll::poll`时，它将对集合中的每个future调用`poll`。对每个future进行轮询将启动它们所代表的任何操作，并允许它们*并发地进步*。这是通过懒协程实现并发的一种方式，就像我们在这里处理的那样。
- en: Next up are the changes we’ll make in `main.rs`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对`main.rs`进行的更改。
- en: 'The `main` function will be the same, as well as the imports and declarations
    at the start of the file, so I’ll only present the `coroutine/await` functions
    that we’ve changed:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数将保持不变，以及文件开头的导入和声明，所以我只会展示我们更改的`coroutine/await`函数：'
- en: '[PRE32]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the repository, you’ll find the correct code to put in `main.rs` in `ch07/c-async-await/original_main.rs`
    if you ever lose track of it with all the copy/pasting we’re doing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中，如果你在所有复制粘贴的过程中丢失了跟踪，你可以在`ch07/c-async-await/original_main.rs`中找到放入`main.rs`的正确代码。
- en: 'Now we have two `coroutine/wait` functions. `async_main` stores a set of coroutines
    created by `read_request` in a `Vec<T: Future>`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们有两个`coroutine/wait`函数。`async_main`将`read_request`创建的一组协程存储在`Vec<T: Future>`中。'
- en: Then it creates a `JoinAll` future and calls `wait` on it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它创建了一个`JoinAll` future，并对其调用`wait`。
- en: The next `coroutine/wait` function is `read_requests`, which takes an integer
    as input and uses that to create GET requests. This coroutine will in turn wait
    for the response and print out the result once it arrives.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`coroutine/wait`函数是`read_requests`，它接受一个整数作为输入，并使用该整数创建GET请求。这个协程将等待响应，并在响应到达时打印出结果。
- en: Since we create the requests with delays of `0, 1, 2, 3, 4` seconds, we should
    expect the entire program to finish in just over four seconds because all the
    tasks will be in progress *concurrently*. The ones with short delays will be finished
    by the time the task with a four-second delay finishes.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建的请求延迟为`0, 1, 2, 3, 4`秒，因此我们预计整个程序将在四秒多一点的时间内完成，因为所有任务都将*并发地进行*。那些延迟短的将在四秒延迟的任务完成时完成。
- en: We can now transform our `coroutine/await` functions into state machines by
    making sure we’re in the folder `ch07/c-async-await` and writing `corofy ./src/main.rs`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过确保我们位于`ch07/c-async-await`文件夹中，并编写`corofy ./src/main.rs`，将我们的`coroutine/await`函数转换为状态机。
- en: You should now see a file called `main_corofied.rs` in the `src` folder. Copy
    its contents and replace what’s in `main.rs` with it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该在`src`文件夹中看到一个名为`main_corofied.rs`的文件。复制其内容，并用它替换`main.rs`中的内容。
- en: 'If you run the program by writing `cargo run`, you should get the following
    output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过编写`cargo run`来运行程序，你应该会得到以下输出：
- en: '[PRE33]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The thing to make a note of here is the elapsed time. It’s now just over four
    seconds, just like we expected it would be when our futures run concurrently.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的是经过的时间。现在正好超过四秒，就像我们预期的那样，当我们的future并发运行时。
- en: 'If we take a look at how `coroutine/await` changed the experience of writing
    coroutines from a programmer’s perspective, we’ll see that we’re much closer to
    our goal now:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看`coroutine/await`是如何从程序员的视角改变编写协程的体验的，我们会看到我们现在离目标更近了：
- en: '**Efficient**: State machines require no context switches and only save/restore
    the data associated with that specific task. We have no growing vs segmented stack
    issues, as they all use the same OS-provided stack.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效**：状态机不需要上下文切换，只需保存/恢复与该特定任务相关的数据。我们没有增长与分段栈的问题，因为它们都使用相同的操作系统提供的栈。'
- en: '**Expressive**: We can write code the same way as we do in “normal” Rust, and
    with compiler support, we can get the same error messages and use the same tooling'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达性**：我们可以像在“正常”Rust中一样编写代码，并且有了编译器的支持，我们可以得到相同的错误消息并使用相同的工具。'
- en: '`async` function from a normal function and expect anything meaningful to happen;
    you have to actively poll it to completion somehow, which gets more complex as
    we start adding runtimes into the mix. However, for the most part, we can write
    programs just the way we’re used to.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个普通函数到`async`函数，并期望发生任何有意义的事情；你必须以某种方式主动轮询它以完成，随着我们开始添加运行时，这会变得更加复杂。然而，就大部分而言，我们可以像我们习惯的那样编写程序。
- en: Final thoughts
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的想法
- en: Before we round off this chapter, I want to point out that it should now be
    clear to us why coroutines aren’t really **pre-emptable**. If you remember back
    in [*Chapter 2*](B20892_02.xhtml#_idTextAnchor043), we said that a *stackful*
    coroutine (such as our fibers/green threads example) could be *pre-empted* and
    its execution could be paused at any point. That’s because they have a stack,
    and pausing a task is as simple as storing the current execution state to the
    stack and jumping to another task.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，我想指出，现在应该对我们来说已经很清楚为什么协程实际上并不是**可抢占的**。如果你还记得在[*第二章*](B20892_02.xhtml#_idTextAnchor043)中，我们提到一个*堆栈型*协程（例如我们纤维/绿色线程的例子）可以被*抢占*，并且可以在任何点上暂停其执行。这是因为它们有一个堆栈，暂停一个任务就像将当前执行状态存储到堆栈中并跳转到另一个任务一样简单。
- en: That’s not possible here. The only places we can stop and resume execution are
    at the pre-defined suspension points that we manually tagged with `wait`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这在这里是不可能的。我们能停止和恢复执行的地方只有预先定义的挂起点，这些挂起点是我们手动用`wait`标记的。
- en: In theory, if you have a tightly integrated system where you control the compiler,
    the coroutine definition, the scheduler, and the I/O primitives, you could add
    additional states to the state machine and create additional points where the
    task could be suspended/resumed. These suspension points could be opaque to the
    user and treated differently than normal wait/suspension points.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，如果你有一个紧密集成的系统，你控制编译器、协程定义、调度器和I/O原语，你可以向状态机添加额外的状态，并创建额外的挂起/恢复点。这些挂起点对用户来说是透明的，并且与正常的等待/挂起点不同对待。
- en: For example, every time you encounter a normal function call, you could add
    a suspension point (a new state to our state machine) where you check in with
    the scheduler if the current task has used up its time budget or something like
    that. If it has, you could schedule another task to run and resume the task at
    a later point even though this didn’t happen in a cooperative manner.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每次你遇到一个正常的函数调用时，你可以在我们的状态机中添加一个挂起点（一个新的状态），在那里你检查当前任务是否已经用完了其时间预算或类似的事情。如果是这样，你可以安排另一个任务运行，并在稍后某个时间点恢复任务，尽管这并没有以协作的方式进行。
- en: However, even though this would be invisible to the user, it’s not the same
    as being able to stop/resume execution from any point in your code. It would also
    go against the usually implied cooperative nature of coroutines.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这对用户来说是不可见的，但这并不等同于能够在代码的任何点停止/恢复执行。这也会违反协程通常隐含的协作性质。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Good job! In this chapter, we introduced quite a bit of code and set up an example
    that we’ll continue using in the following chapters.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在本章中，我们介绍了很多代码，并设置了一个示例，我们将在接下来的章节中继续使用。
- en: So far, we’ve focused on futures and `async/await` to model and create tasks
    that can be paused and resumed at specific points. We know this is a prerequisite
    to having tasks that are in progress at the same time. We did this by introducing
    our own simplified `Future` trait and our own `coroutine/wait` syntax that’s way
    more limited than Rust’s futures and `async/await` syntax, but it’s easier to
    understand and get a mental idea of how this works in contrast to fibers/green
    threads (at least I hope so).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于使用`futures`和`async/await`来模拟和创建可以在特定点暂停和恢复的任务。我们知道这是同时拥有正在执行的任务的先决条件。我们通过引入我们自己的简化版`Future`特性和我们自己的`coroutine/wait`语法来实现这一点，这些语法比Rust的`futures`和`async/await`语法要有限得多，但更容易理解，并且更容易在心理上理解这与纤维/绿色线程（至少我希望是这样）是如何工作的。
- en: We have also discussed the difference between eager and lazy coroutines and
    how they impact how you achieve concurrency. We took inspiration from Tokio’s
    `join_all` function and implemented our own version of it.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了急切协程和懒协程之间的区别以及它们如何影响你实现并发的方式。我们从Tokio的`join_all`函数中汲取了灵感，并实现了我们自己的版本。
- en: In this chapter, we simply created tasks that could be paused and resumed. There
    are no event loops, scheduling, or anything like that yet, but don’t worry. They’re
    exactly what we’ll go through in the next chapter. The good news is that getting
    a clear idea of coroutines, like we did in this chapter, is one of the most difficult
    things to do.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只是创建了可以暂停和恢复的任务。目前还没有事件循环、调度或其他类似的东西，但不用担心。它们正是我们将在下一章中探讨的内容。好消息是，像本章这样清晰地理解协程是非常困难的事情之一。
