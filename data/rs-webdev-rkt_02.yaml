- en: '*Chapter 1*: Introducing the Rust Language'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：介绍 Rust 语言'
- en: Almost every programmer has heard about the **Rust** programming language or
    even tried or used it. Saying "the Rust programming language" every time is a
    little bit cumbersome, so let's just call it Rust, or the Rust language from this
    point forward.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个程序员都听说过 **Rust** 编程语言，甚至尝试或使用过它。每次都说“Rust 编程语言”有点繁琐，所以从现在起我们就叫它 Rust，或者
    Rust 语言。
- en: In this chapter, we will talk a little bit about Rust to help you if you are
    new to this language or as a refresher if you have tried it already. This chapter
    might also help seasoned Rust language programmers a bit. Later in the chapter,
    we will learn how to install the Rust toolchain and create a simple program to
    introduce the features of the Rust language. We will then use third-party libraries
    to enhance one of our programs, and finally, we will see how we can get help for
    the Rust language and its libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍 Rust，以帮助你是 Rust 语言的新手，或者如果你已经尝试过，作为复习。本章也可能对经验丰富的 Rust 语言程序员有所帮助。在章节的后面部分，我们将学习如何安装
    Rust 工具链并创建一个简单的程序来介绍 Rust 语言的特性。然后，我们将使用第三方库来增强我们的一个程序，最后，我们将了解如何为 Rust 语言及其库获取帮助。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: An overview of the Rust language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 语言的概述
- en: Installing the Rust compiler and toolchain
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Rust 编译器和工具链
- en: Writing Hello World
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Hello World
- en: Exploring Rust crates and Cargo
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Rust 包和 Cargo
- en: Exploring other tools and where to get help
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索其他工具和获取帮助的地方
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the content of this book, you will need a computer running a Unix-like
    operating system such as Linux, macOS, or Windows with Windows Subsystem for Linux
    (WSLv1 or WSLv2) installed. Don't worry about the Rust compiler and toolchain;
    we will install it in this chapter if you don't have it installed already.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本书的内容，你需要一台运行类似 Unix 的操作系统（如 Linux、macOS 或安装了 Windows Subsystem for Linux
    (WSLv1 或 WSLv2) 的 Windows）的计算机。不用担心 Rust 编译器和工具链；如果尚未安装，我们将在本章中安装它。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter01](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter01).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter01](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter01)
    找到。
- en: An overview of the Rust language
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 语言的概述
- en: To build web applications using the **Rocket** framework, we must first learn
    a bit about the Rust language since Rocket is built using that language. According
    to [https://www.rust-lang.org](https://www.rust-lang.org), the Rust language is
    "*a language empowering everyone to build reliable and efficient software*." It
    began as a personal project for a programmer named Graydon Hoare, an employee
    at Mozilla, around 2006\. The Mozilla Foundation saw the potential of the language
    for their product; they started sponsoring the project in 2009 before announcing
    it to the public in 2010.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 **Rocket** 框架构建网络应用程序，我们首先需要了解一点 Rust 语言，因为 Rocket 是用那种语言构建的。根据 [https://www.rust-lang.org](https://www.rust-lang.org)，Rust
    语言是 "*一种赋予每个人构建可靠和高效软件能力的语言*。" 它始于 2006 年左右程序员 Graydon Hoare 的一个个人项目，他是 Mozilla
    的员工。Mozilla 基金会看到了这种语言对他们的产品的潜力；他们在 2009 年开始赞助这个项目，并在 2010 年向公众宣布。
- en: Since its inception, the focus of Rust has always been on performance and safety.
    Building a web browser is not an easy job; an unsafe language can have very fast
    performance, but programmers working with system languages without adequate safety
    measures in place can make a lot of mistakes, such as missing pointer references.
    Rust was designed as a system language and learned many mistakes from older languages.
    In older languages, you can easily shoot yourself in the foot with a null pointer,
    and nothing in the language prevents you from compiling such mistakes. In contrast,
    in the Rust language, you cannot write a code that resulted in null pointer because
    it will be detected during compile time, and you must fix the implementation to
    make it compile.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自从诞生以来，Rust 的重点始终是性能和安全。构建一个网络浏览器并不是一件容易的事情；一种不安全的语言可以拥有非常快的性能，但如果没有适当的安全措施，使用系统语言的程序员可能会犯很多错误，例如丢失指针引用。Rust
    被设计成一种系统语言，并从较老的语言中吸取了许多教训。在较老的语言中，你可以轻易地因为空指针而“自伤”，而且语言中没有任何东西可以阻止你编译这样的错误。相比之下，在
    Rust 语言中，你不能编写出会导致空指针的代码，因为这将会在编译时被检测到，你必须修复实现以使其能够编译。
- en: A lot of the Rust language design is borrowed from the functional programming
    paradigm, as well as from the object-oriented programming paradigm. For example,
    it has elements of a functional language such as closures and iterators. You can
    easily make a pure function and use the function as a parameter in another function;
    there are syntaxes to easily make closures and data types such as `Option` or
    `Result`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust语言的设计在很大程度上借鉴了函数式编程范式以及面向对象编程范式。例如，它具有函数式语言的一些元素，如闭包和迭代器。你可以轻松地创建一个纯函数，并将该函数作为另一个函数的参数使用；有语法可以轻松创建闭包和数据类型，如`Option`或`Result`。
- en: On the other hand, there are no class definitions, but you can easily define
    a data type, for example, a **struct**. After defining that data type, you can
    create a block to implement its methods.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，没有类定义，但你可以轻松地定义一个数据类型，例如，一个**结构体**。在定义了这种数据类型之后，你可以创建一个块来实现其方法。
- en: Even though there is no inheritance, you can easily group objects by using `MakeSound`
    trait. Then, you can determine what methods should be in that trait by writing
    the method signatures. If you define a data type, for example, a struct named
    `Cow`, you can tell the compiler that it implements a `MakeSound` trait. Because
    you say the `Cow` struct implements the `MakeSound` trait, you have to implement
    the methods defined in the trait for the `Cow` struct. Sounds like an object-oriented
    language, right?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有继承，但你可以通过使用`MakeSound`特质轻松地将对象分组。然后，你可以通过编写方法签名来确定该特质中应该有哪些方法。如果你定义一个数据类型，例如，一个名为`Cow`的结构体，你可以告诉编译器它实现了`MakeSound`特质。因为你说`Cow`结构体实现了`MakeSound`特质，所以你必须为`Cow`结构体实现特质中定义的方法。听起来像面向对象语言，对吧？
- en: The Rust language went through several iterations before a stable version was
    released (Rust 1.0) on May 15, 2015\. Some of the early language design was scrapped
    before releasing the stable release. At one point, Rust had a class feature but
    this was scrapped before the stable release because Rust design was changed to
    have data and behavior separation. You write data (for example, in the form of
    a `struct` or `enum` type), and then you write a behavior (for example, `impl`)
    separately. To categorize those `impl` in the same group, we can make a **trait**.
    So, all the functionality you would want from an object-oriented language can
    be had thanks to that design. Also, Rust used to have garbage collection, but
    it was then scrapped because another design pattern was used. When objects get
    out of scope, such as exiting a function, they are deallocated automatically.
    This type of automatic memory management made garbage collection unnecessary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Rust语言在发布稳定版本（Rust 1.0）之前经历了多次迭代（2015年5月15日）。在发布稳定版本之前，一些早期的语言设计被废弃了。在某个时刻，Rust有一个类特性，但在稳定发布之前被废弃了，因为Rust的设计被改为数据和行为分离。你写数据（例如，以`struct`或`enum`类型的形式），然后你分别写行为（例如，`impl`）。为了将这些`impl`归类到同一组中，我们可以创建一个**特质**。因此，你可以从面向对象语言中获得所有想要的功能。此外，Rust曾经有过垃圾回收，但后来因为使用了另一种设计模式而被废弃。当对象超出作用域时，例如退出函数，它们会自动释放。这种类型的自动内存管理使得垃圾回收变得不必要。
- en: After the first stable release, people added more functionalities to make Rust
    more ergonomic and usable. One of the biggest changes was **async/await**, which
    was released in version 1.39\. This feature is very useful for developing applications
    that handle I/O, and web application programming handles a lot of I/O. Web applications
    have to handle database and network connections, reading from files, and so on.
    People agree that async/await was one of the most needed features to make the
    language suitable for web programming, because in async/await, the program doesn't
    need to make a new thread, but it's also not blocking like a conventional function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个稳定版本发布后，人们添加了更多功能，使Rust更加易用和可用。其中最大的变化是**async/await**，它在1.39版本中发布。这个特性对于开发处理I/O的应用程序非常有用，而Web应用程序编程处理大量的I/O。Web应用程序必须处理数据库和网络连接、从文件中读取等。人们普遍认为，async/await是使语言适合Web编程的最需要的特性之一，因为在async/await中，程序不需要创建新的线程，但它也不像传统函数那样阻塞。
- en: Another important feature is `const fn`, a function that will be evaluated at
    compile-time instead of runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要特性是`const fn`，这是一个将在编译时而不是运行时评估的函数。
- en: In recent years, many large companies have started to build a talent pool of
    Rust developers, which highlights its significance in business.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，许多大型公司开始建立Rust开发者的人才库，这突出了它在商业中的重要性。
- en: Why use the Rust language?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用 Rust 语言？
- en: 'So, why should we use the Rust language for web application development? Aren''t
    existing established languages good enough for web development? Here are a few
    reasons why people would want to use the Rust language for creating web applications:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们应该使用 Rust 语言进行 Web 应用程序开发？现有的成熟语言不是足够好吗？以下是一些人们想要使用 Rust 语言创建 Web 应用程序的原因：
- en: Safety
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: No garbage collection
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无垃圾回收
- en: Speed
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度
- en: Multithreading and asynchronous programming
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程和异步编程
- en: Statically typed
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型
- en: Safety
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性
- en: Although writing applications using a system programming language is advantageous
    because it's powerful (a programmer can access the fundamental building block
    of a program such as allocating computer memory to store important data and then
    deallocating that memory as soon as it is not in use), it's very easy to make
    mistakes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用系统编程语言编写应用程序有其优势，因为它们功能强大（程序员可以访问程序的基本构建块，例如分配计算机内存以存储重要数据，然后在不使用时立即释放该内存），但很容易出错。
- en: There's nothing in a traditional system language to prevent a program from storing
    data in memory, creating a pointer to that data, deallocating the data stored
    in memory, and trying to access the data again through that pointer. The data
    is already gone but the pointer is still pointing to that part of the memory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的系统语言中，没有任何东西可以阻止程序在内存中存储数据，创建指向该数据的指针，释放内存中存储的数据，然后尝试通过该指针再次访问数据。数据已经消失，但指针仍然指向内存的该部分。
- en: Seasoned programmers might easily spot such mistakes in a simple program. Some
    companies force their programmers to use a static analysis tool to check the code
    for such mistakes. But, as programming techniques become more sophisticated, the
    complexity of the application grows, and these kinds of bugs can still be found
    in many applications. High-profile bugs and hacks found in recent years, such
    as *Heartbleed*, can be prevented if we use a memory-safe language.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的程序员很容易在简单的程序中找到这样的错误。一些公司强迫他们的程序员使用静态分析工具来检查代码中的此类错误。但是，随着编程技术的日益复杂，应用程序的复杂性也在增长，这些类型的错误仍然可以在许多应用程序中找到。近年来发现的一些高调的漏洞和黑客攻击，如
    *Heartbleed*，如果我们使用内存安全语言，就可以防止。
- en: Rust is a memory-safe language because it has certain rules regarding how a
    programmer can write their code. For example, when the code is compiled, it checks
    the lifetime of a variable, and the compiler will show an error if another variable
    still tries to access the already out-of-scope data. Ralf Jung, a postdoctoral
    researcher, already made the first formal verification in 2020 that the Rust language
    is indeed a safe language. Built-in data types, such as `Option` or `Result`,
    handle null-like behavior in a safe manner.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种内存安全语言，因为它对程序员如何编写代码有一系列规则。例如，当代码编译时，它会检查变量的生命周期，如果另一个变量仍然尝试访问已经超出作用域的数据，编译器将显示错误。2020
    年，博士后研究员 Ralf Jung 已经进行了第一次正式验证，证明 Rust 语言确实是一种安全语言。内置的数据类型，如 `Option` 或 `Result`，以安全的方式处理类似
    null 的行为。
- en: No garbage collection
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无垃圾回收
- en: 'Many programmers create and use different techniques for memory management
    due to safety problems. One of these techniques is garbage collection. The idea
    is simple: memory management is done automatically during runtime so that a programmer
    doesn''t have to think about memory management. A programmer just needs to create
    a variable, and when the variable is not used anymore, the runtime will automatically
    remove it from memory.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员由于安全问题，会创建和使用不同的内存管理技术。其中一种技术是垃圾回收。其理念很简单：内存管理在运行时自动完成，这样程序员就不必考虑内存管理。程序员只需创建一个变量，当变量不再使用时，运行时系统会自动将其从内存中移除。
- en: Garbage collection is an interesting and important part of computing. There
    are many techniques such as reference counting and tracing. Java, for example,
    even has several third-party garbage collectors besides the official garbage collector.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是计算中的一个有趣且重要的部分。有许多技术，如引用计数和追踪。例如，Java 除了官方的垃圾回收器外，还有几个第三方垃圾回收器。
- en: The problem with this language design choice is that garbage collection usually
    takes significant computing resources. For example, a part of the memory is still
    not usable for a while because the garbage collector has not recycled that memory
    yet. Or, even worse, the garbage collector is not able to remove used memory from
    the heap, so it will accumulate, and most of the computer memory will become unusable,
    or what we usually call a **memory leak**. In the **stop-the-world** garbage collection
    mechanism, the whole program execution is paused to allow the garbage collector
    to recycle the memory, after which the program execution is resumed. As such,
    some people find it hard to develop real-time applications with this kind of language.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言设计选择的问题在于垃圾回收通常需要大量的计算资源。例如，一部分内存因为垃圾收集器还没有回收这部分内存而暂时不可用。或者，更糟糕的是，垃圾收集器无法从堆中移除已使用的内存，因此它会积累，大多数计算机内存将变得不可用，或者我们通常所说的**内存泄漏**。在**停止世界**的垃圾回收机制中，整个程序执行被暂停，以便垃圾收集器回收内存，之后程序执行继续。因此，有些人发现很难用这种语言开发实时应用程序。
- en: Rust takes a different approach called **resource acquisition is initialization**
    (**RAII**), which means an object is deallocated automatically as soon as it's
    out of scope. For example, if you write a function, an object created in the function
    will be deallocated as soon as the function exits. But obviously, this makes Rust
    very different compared to programming languages that deallocate memory manually
    or programming languages with garbage collection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Rust采取了一种不同的方法，称为**资源获取即初始化**（**RAII**），这意味着一个对象一旦超出作用域就会自动释放。例如，如果你编写一个函数，在该函数中创建的对象将在函数退出时被释放。但显然，这使得Rust与手动释放内存的编程语言或具有垃圾回收的编程语言非常不同。
- en: Speed
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度
- en: If you are used to doing web development with an interpreted language or a language
    with garbage collection, you might say that we don't need to worry about computing
    performance as web development is I/O bound; in other words, the bottleneck is
    when the application accesses the database, disk, or another network, as they
    are slower than a CPU or memory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于使用解释型语言或具有垃圾回收的语言进行Web开发，你可能会说我们不需要担心计算性能，因为Web开发是I/O密集型的；换句话说，瓶颈在于应用程序访问数据库、磁盘或另一个网络时，因为它们的速度比CPU或内存慢。
- en: The adage might be primarily true but it all depends on application usage. If
    your application processes a lot of JSON, the processing is CPU-bound, which means
    it is limited by the speed of your CPU and not the speed of disk access or the
    speed of network connection. If you care about the security of your application,
    you might need to work with hashing and encryption, which are CPU-bound. If you
    are writing a backend application for an online streaming service, you want the
    application to work as optimally as possible. If you are writing an application
    serving millions of users, you want the application to be very optimized and return
    the response as fast as possible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谚语可能主要是正确的，但一切都取决于应用程序的使用。如果你的应用程序处理大量的JSON，处理是CPU密集型的，这意味着它受限于CPU的速度，而不是磁盘访问速度或网络连接速度。如果你关心应用程序的安全性，你可能需要处理散列和加密，这些都是CPU密集型的。如果你正在为在线流媒体服务编写后端应用程序，你希望应用程序尽可能优化。如果你正在编写服务于数百万用户的应用程序，你希望应用程序非常优化，并且尽可能快地返回响应。
- en: The Rust language is a compiled language, so the compiler will convert the program
    into machine code, which a computer processor can execute. A compiled language
    usually runs faster than an interpreted language because, in an interpreted language,
    there is an overhead when the runtime binary interprets the program into native
    machine code. In modern interpreters, the speed gap is reduced by using modern
    techniques such as a **just-in-time** (**JIT**) compiler to speed up the program
    execution, but in dynamic languages such as Ruby, it's still slower than using
    a compiled language.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Rust语言是一种编译型语言，因此编译器会将程序转换为机器代码，计算机处理器可以执行。编译型语言通常比解释型语言运行得更快，因为在解释型语言中，当运行时二进制将程序解释为本地机器代码时，会有额外的开销。在现代解释器中，通过使用现代技术，如**即时编译器**（**JIT**）来加速程序执行，速度差距已经缩小，但在像Ruby这样的动态语言中，它仍然比使用编译型语言慢。
- en: Multithreading and asynchronous programming
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多线程和异步编程
- en: In traditional programming, synchronous programming means the application has
    to wait until CPU has processed a task. In a web application, the server waits
    until an HTTP request is processed and responded to; only then does it go on to
    handle another HTTP request. This is not a problem if the application just directly
    creates responses such as simple text. It becomes a problem when the web application
    has to take some time to do the processing; it has to wait for the database server
    to respond, it has to wait until the file is fully written on the server, and
    it has to wait until the API call to the third-party API service is done successfully.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统编程中，同步编程意味着应用程序必须等待 CPU 处理完一个任务。在 Web 应用程序中，服务器必须等待 HTTP 请求被处理并响应；只有在此之后，它才会继续处理另一个
    HTTP 请求。如果应用程序只是直接创建响应，如简单的文本，这并不是问题。但当 Web 应用程序需要花费一些时间来处理时，它必须等待数据库服务器响应，必须等待文件在服务器上完全写入，以及必须等待对第三方
    API 服务的 API 调用成功完成，这时就会变成问题。
- en: One way to overcome the problem of waiting is multithreading. A single process
    can create multiple threads that share some resources. The Rust language has been
    designed to make it easy to create safe multithreaded applications. It's designed
    with multiple containers such as `Arc` to make it easy to pass data between threads.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 克服等待问题的方法之一是多线程。单个进程可以创建多个线程，这些线程共享一些资源。Rust 语言被设计成易于创建安全的多线程应用程序。它通过多个容器，如
    `Arc`，来简化线程间数据传递。
- en: The problem with multithreading is that spawning a thread means allocating significant
    CPU, memory, and OS resources, or what is colloquially known as being *expensive*.
    The solution is to use a different technique called **asynchronous programming**,
    where a single thread is reused by different tasks without waiting for the first
    task to finish. People can easily write an async program in Rust because it's
    been incorporated into the language since November 7, 2019.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程的问题在于，创建一个线程意味着分配大量的 CPU、内存和操作系统资源，或者如俗话所说，成本高昂。解决方案是使用一种称为**异步编程**的不同技术，其中单个线程被不同的任务重用，而不必等待第一个任务完成。人们可以很容易地在
    Rust 中编写异步程序，因为自 2019 年 11 月 7 日起，它已被纳入语言中。
- en: Statically-typed
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态类型
- en: In programming languages, a dynamically-typed language is one where a variable
    type is checked at runtime, while a statically-typed language checks the data
    type at compile time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，动态类型语言是指在运行时检查变量类型的语言，而静态类型语言则在编译时检查数据类型。
- en: Dynamic typing means it's easier to write code, but it's also easier to make
    mistakes. Usually, a programmer has to write more unit tests in dynamically-typed
    languages to compensate for not checking the type at compile time. A dynamically-typed
    language is also considered more expensive because every time a function is called,
    the routine has to check the passed parameters. As a result, it's difficult to
    optimize a dynamically-typed language.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型意味着编写代码更容易，但也更容易出错。通常，程序员需要在动态类型语言中编写更多的单元测试来补偿编译时没有检查类型。动态类型语言也被认为成本更高，因为每次函数被调用时，程序都需要检查传递的参数。因此，优化动态类型语言变得困难。
- en: Rust, on the other hand, is statically-typed, so it's very hard to make mistakes
    such as passing a string as a number. The compiler can optimize the resulting
    machine code and reduce programming bugs significantly before the application
    is released.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Rust 是静态类型的，因此很难犯将字符串作为数字传递的错误。编译器可以在应用程序发布之前优化生成的机器代码，并显著减少编程错误。
- en: Now that we have provided an overview of the Rust language and its strengths
    compared to other languages, let's learn how to install the Rust compiler toolchain,
    which will be used to compile Rust programs. We'll be using this toolchain throughout
    this book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了 Rust 语言及其与其他语言的比较优势，让我们学习如何安装 Rust 编译器工具链，该工具链将用于编译 Rust 程序。我们将在这本书中使用这个工具链。
- en: Installing the Rust compiler toolchain
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Rust 编译器工具链
- en: 'Let''s start by installing the Rust compiler toolchain. Rust has three official
    channels: *stable*, *beta*, and *nightly*. The Rust language uses Git as its version
    control system. People add new features and bug fixes to the master branch. Every
    night, the source code from the master branch is compiled and released to the
    nightly channel. After six weeks, the code will be branched off to the beta branch,
    compiled, and released to the beta channel. People will then run various tests
    in the beta release, most often in their CI (Continuous Integration) installation.
    If a bug is found, the fix will be committed to the master branch and then backported
    to the beta branch. Six weeks after the first beta branch-off, the stable release
    will be created from the beta branch.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装Rust编译器工具链开始。Rust有三个官方渠道：*稳定版*、*测试版*和*夜间版*。Rust语言使用Git作为其版本控制系统。人们将新功能和错误修复添加到master分支。每晚，master分支的源代码都会被编译并发布到夜间版渠道。六周后，代码将从beta分支分叉出来，编译并发布到beta渠道。然后，人们将在beta发布版中运行各种测试，通常是在他们的CI（持续集成）安装中。如果发现错误，修复将被提交到master分支，然后回滚到beta分支。第一次beta分支六周后，稳定版将从beta分支创建。
- en: We will use the compiler from the stable channel throughout the book, but if
    you feel adventurous, you can use the other channels as well. There's no guarantee
    the program we're going to create will compile if you use another channel though
    because people add new features and there might be regression introduced in the
    new version.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中使用稳定渠道的编译器，但如果您想尝试冒险，您也可以使用其他渠道。不过，如果您使用其他渠道，我们无法保证我们将要创建的程序会编译，因为人们会添加新功能，并且新版本中可能引入了回归。
- en: There are several ways to install the Rust toolchain in your system, such as
    bootstrapping and compiling it from scratch or using your OS package manager.
    But, the recommended way to install the Rust toolchain in your system is by using
    `rustup`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统中安装Rust工具链有几种方法，例如从头开始引导和编译，或者使用您的操作系统包管理器。但是，在您的系统中安装Rust工具链的推荐方法是使用`rustup`。
- en: 'The definition on its website ([https://rustup.rs](https://rustup.rs)) is very
    simple: "*rustup is an installer for the systems programming language Rust*."
    Now, let''s try following these instructions to install `rustup`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在其网站上的定义（[https://rustup.rs](https://rustup.rs)）非常简单："*rustup是系统编程语言Rust的安装程序*。"现在，让我们尝试按照这些说明来安装`rustup`。
- en: Installing rustup on the Linux OS or macOS
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux OS或macOS上安装rustup
- en: 'These instructions apply if you are using a Debian 10 Linux distribution, but
    if you are already using another Linux distribution, we''re going to assume you
    are already proficient with the Linux OS and can adapt these instructions suitable
    to your Linux distribution:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Debian 10 Linux发行版，则这些说明适用，但如果您已经使用其他Linux发行版，我们将假设您已经熟悉Linux操作系统，并且可以适应适合您Linux发行版的这些说明：
- en: Open your terminal of choice.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的终端。
- en: 'Make sure you have cURL installed by typing this command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令确保您已安装cURL：
- en: '[PRE0]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If cURL is not installed, let''s install it:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果cURL尚未安装，让我们来安装它：
- en: '[PRE1]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are using macOS, you will most likely already have cURL installed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，您可能已经安装了cURL。
- en: 'After that, follow the instructions on [https://rustup.rs](https://rustup.rs):'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，按照[https://rustup.rs](https://rustup.rs)上的说明进行操作：
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It will then show a greeting and information, which you can customize; for
    now, we''re just going to use the default setup:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它会显示问候和信息，您可以自定义；目前，我们只是使用默认设置：
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Type `1` to use the default installation.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`1`以使用默认安装。
- en: 'After that, reload your terminal or type this in the current terminal:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，重新加载您的终端或在此当前终端中输入以下内容：
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can confirm whether the installation was successful or not by typing `rustup`
    in the Terminal and you should see the usage instruction for rustup.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在终端中输入`rustup`来确认安装是否成功，您应该会看到rustup的使用说明。
- en: 'Now, let''s install the stable Rust toolchain. Type the following in the terminal:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们安装稳定的Rust工具链。在终端中输入以下内容：
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the toolchain has been installed into your OS, let's confirm whether we
    can run the Rust compiler. Type `rustc` in the terminal and you should see the
    instructions on how to use it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具链安装到您的操作系统后，让我们确认我们是否可以运行Rust编译器。在终端中输入`rustc`，您应该会看到如何使用它的说明。
- en: Installing a different toolchain and components
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装不同的工具链和组件
- en: 'Right now, we have the stable toolchain installed, but there are two other
    default channels that we can install: *nightly* and *beta*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经安装了稳定工具链，但还有两个其他默认通道可以安装：*nightly*和*beta*。
- en: 'Sometimes, you might want to use a different toolchain for various reasons.
    Maybe you want to try a new feature, or maybe you want to test regression in your
    application against an upcoming version of Rust. You can simply install it by
    using `rustup`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能出于各种原因想要使用不同的工具链。也许你想尝试一个新功能，或者也许你想测试你的应用程序对即将到来的Rust版本的回归。你可以简单地使用`rustup`来安装它：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each toolchain has components, some of which are required by the toolchain,
    such as `rustc`, which is the Rust compiler. Other components are not installed
    by default, for example, `clippy`, which provides more checks not provided by
    the `rustc` compiler and gives code style suggestions as well. To install it is
    also very easy; you can use `rustup component add <component>` as shown in this
    example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工具链都有组件，其中一些是工具链必需的，例如`rustc`，这是Rust编译器。其他组件默认不安装，例如`clippy`，它提供了`rustc`编译器未提供的更多检查，并给出代码风格建议。安装它也非常简单；你可以使用`rustup
    component add <component>`，如本例所示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Updating the toolchain, rustup, and components
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新工具链、rustup和组件
- en: 'The Rust toolchain has a regular release schedule of around every three months
    (six weeks plus six weeks), but sometimes there''s an emergency release for a
    major bug fix or a fix for a security problem. As a result, you sometimes need
    to update your toolchain. Updating is very easy. This command will also update
    the components installed in the toolchain:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Rust工具链有一个大约每三个月（六周加六周）的定期发布计划，但有时会有针对重大错误修复或安全问题的紧急发布。因此，有时你需要更新你的工具链。更新非常简单。此命令还将更新工具链中安装的组件：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Besides the toolchain, `rustup` itself might also be updated. You can update
    it by typing the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了工具链之外，`rustup`本身也可能需要更新。你可以通过输入以下内容来更新它：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have the Rust compiler toolchain installed in our system, let's
    write our first Rust program!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将Rust编译器工具链安装到我们的系统中，让我们编写我们的第一个Rust程序！
- en: Writing Hello World!
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Hello World！
- en: 'In this section, we are going to write a very basic program, *Hello World!*.
    After we successfully compile that, we are going to write a more complex program
    to see the basic capabilities of the Rust language. Let''s do it by following
    these instructions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个非常基础的程序，*Hello World！*。在我们成功编译之后，我们将编写一个更复杂的程序，以查看Rust语言的基本功能。让我们按照以下指示进行操作：
- en: Let's create a new folder, for example, `01HelloWorld`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件夹，例如，`01HelloWorld`。
- en: Create a new file inside the folder and give it the name `main.rs`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹内创建一个新的文件，并将其命名为`main.rs`。
- en: 'Let''s write our first code in Rust:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在Rust中编写我们的第一个代码：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that, save your file, and in the same folder, open your terminal, and
    compile the code using the `rustc` command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，保存你的文件，在同一文件夹中，打开你的终端，并使用`rustc`命令编译代码：
- en: '[PRE11]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see there''s a file inside the folder called `main`; run that file
    from your terminal:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到文件夹内有一个名为`main`的文件；从你的终端运行该文件：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Congratulations! You just wrote your first `Hello World` program in the Rust
    language.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚用Rust语言编写了你的第一个`Hello World`程序。
- en: Next, we're going to step up our Rust language game; we will showcase basic
    Rust applications with control flow, modules, and other functionalities.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提高我们的Rust语言水平；我们将展示带有控制流、模块和其他功能的Rust基本应用程序。
- en: Writing a more complex program
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写更复杂的程序
- en: 'Of course, after making the `Hello World` program, we should try to write a
    more complex program to see what we can do with the language. We want to make
    a program that captures what the user inputted, encrypts it with the selected
    algorithm, and returns the output to the terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在制作了`Hello World`程序之后，我们应该尝试编写一个更复杂的程序，看看我们能用这个语言做什么。我们想要编写一个程序，它可以捕获用户输入的内容，使用选定的算法对其进行加密，并将输出返回到终端：
- en: 'Let''s make a new folder, for example, `02ComplexProgram`. After that, create
    the `main.rs` file again and add the `main` function again:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件夹，例如，`02ComplexProgram`。之后，再次创建`main.rs`文件并再次添加`main`函数：
- en: '[PRE13]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, use the `std::io` module and write the part of the program to tell the
    user to input the string they want to encrypt:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`std::io`模块编写程序的这部分，提示用户输入他们想要加密的字符串：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s explore what we have written line by line:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行探索我们所写的：
- en: The first line, `use std::io;`, is telling our program that we are going to
    use the `std::io` module in our program. `std` should be included by default on
    a program unless we specifically say not to use it.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行，`use std::io;`，是在告诉我们的程序，我们将在程序中使用 `std::io` 模块。除非我们明确表示不使用它，否则 `std` 应该默认包含在程序中。
- en: The `let...` line is a variable declaration. When we define a variable in Rust,
    the variable is immutable by default, so we must add the `mut` keyword to make
    it mutable. `user_input` is the variable name, and the right hand of this statement
    is initializing a new empty `String` instance. Notice how we initialize the variable
    directly. Rust allows the separation of declaration and initialization, but that
    form is not idiomatic, as a programmer might try to use an uninitialized variable
    and Rust disallows the use of uninitialized variables. As a result, the code will
    not compile.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let...` 行是一个变量声明。当我们定义一个变量在 Rust 中时，该变量默认是不可变的，因此我们必须添加 `mut` 关键字来使其可变。`user_input`
    是变量名，而此语句的右侧是初始化一个新的空 `String` 实例。注意我们是如何直接初始化变量的。Rust 允许分离声明和初始化，但那种形式不是惯用的，因为程序员可能会尝试使用未初始化的变量，而
    Rust 禁止使用未初始化的变量。因此，代码将无法编译。'
- en: The next piece of code, that is, the `stdin()` function, initializes the `std::io::Stdin`
    struct. It reads the input from the terminal and puts it in the `user_input` variable.
    Notice that the signature for `read_line()` accepts `&mut String`. We have to
    explicitly tell the compiler we are passing a mutable reference because of the
    Rust borrow checker, which we will discuss later in [*Chapter 9*](B16825_09_ePub.xhtml#_idTextAnchor109)*,*
    *Displaying User's Post*. The `read_line()` output is `std::result::Result`, an
    enum with two variants, `Ok(T)` and `Err(E)`. One of the `Result` methods is `expect()`,
    which returns a generic type `T`, or if it's an `Err` variant, then it will cause
    panic with a generic error `E` combined with the passed message.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码，即 `stdin()` 函数，初始化了 `std::io::Stdin` 结构体。它从终端读取输入并将其放入 `user_input` 变量中。注意
    `read_line()` 的签名接受 `&mut String`。我们必须明确告诉编译器我们正在传递一个可变引用，因为 Rust 的借用检查器，我们将在稍后的
    [*第 9 章*](B16825_09_ePub.xhtml#_idTextAnchor109)*,* *显示用户帖子* 中讨论。`read_line()`
    的输出是 `std::result::Result`，这是一个有两个变体的枚举，`Ok(T)` 和 `Err(E)`。`Result` 中的一个方法是 `expect()`，它返回一个泛型类型
    `T`，如果它是 `Err` 变体，则它将结合传递的消息引发一个泛型错误 `E` 并导致程序崩溃。
- en: Two Rust enums (`std::result::Result` and `std::option::Option`) are very ubiquitous
    and important in the Rust language, so by default, we can use them in the program
    without specifying `use`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rust 语言中有两个非常普遍且重要的枚举类型（`std::result::Result` 和 `std::option::Option`），因此默认情况下，我们可以在程序中使用它们而不需要指定
    `use`。
- en: 'Next, we want to be able to encrypt the input, but right now, we don''t know
    what encryption we want to use. The first thing we want to do is make a **trait**,
    a particular code in the Rust language that tells the compiler what functionality
    a type can have:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要能够加密输入，但到目前为止，我们还不知道我们想要使用哪种加密。我们想要做的第一件事是创建一个 **特质**，这是 Rust 语言中的一种特定代码，它告诉编译器一个类型可以有什么功能：
- en: 'There are two ways to create a module: create `module_name.rs` or create a
    folder with `module_name` and add a `mod.rs` file inside that folder. Let''s create
    a folder named `encryptor` and create a new file named `mod.rs`. Since we want
    to add a type and implementation later, let''s use the second way. Let''s write
    this in `mod.rs`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模块有两种方式：创建 `module_name.rs` 或创建一个名为 `module_name` 的文件夹并在其中添加一个 `mod.rs` 文件。让我们创建一个名为
    `encryptor` 的文件夹并创建一个名为 `mod.rs` 的新文件。由于我们想要稍后添加类型和实现，让我们使用第二种方式。让我们在 `mod.rs`
    中写下这些内容：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By default, a type or trait is private, but we want to use it in `main.rs` and
    implement the encryptor on a different file, so we should denote the trait as
    public by adding the `pub` keyword.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，类型或特质是私有的，但我们在 `main.rs` 中想要使用它，并在不同的文件中实现加密器，所以我们应该通过添加 `pub` 关键字来将特质标记为公共的。
- en: That trait has one function, `encrypt()`, which has self-reference as a parameter
    and returns `String`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该特质有一个名为 `encrypt()` 的函数，它以自引用作为参数并返回 `String`。
- en: 'Now, we should define this new module in `main.rs`. Put this line before the
    `fn` main block:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该在 `main.rs` 中定义这个新模块。将此行放在 `fn main` 块之前：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, let''s make a simple type that implements the `Encryptable` trait. Remember
    the Caesar cipher, where the cipher substitutes a letter with another letter?
    Let''s implement the simplest one called `ROT13`, where it converts `''a''` to
    `''n''` and `''n''` to `''a''`, `''b''` to `''o''` and `''o''` to `''b''`, and
    so on. Write the following in the `mod.rs` file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个简单的类型，它实现了`Encryptable`特质。记得凯撒密码，其中密码替换一个字母为另一个字母吗？让我们实现最简单的一个叫做`ROT13`的，其中它将`'a'`转换为`'n'`，将`'n'`转换为`'a'`，将`'b'`转换为`'o'`和将`'o'`转换为`'b'`，依此类推。在`mod.rs`文件中写下以下内容：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's make another file named `rot13.rs` inside the `encryptor` folder.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`encryptor`文件夹内创建另一个名为`rot13.rs`的文件。
- en: 'We want to define a simple struct that only has one piece of data, a string,
    and tell the compiler that the struct is implementing the `Encryptable` trait.
    Put this code inside the `rot13.rs` file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要定义一个简单的结构体，它只包含一个数据项，即一个字符串，并告诉编译器这个结构体正在实现`Encryptable`特质。将此代码放入`rot13.rs`文件中：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You might notice we put `pub` in everything from the module declaration, to
    the trait declaration, struct declaration, and field declaration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们在模块声明、特质声明、结构体声明和字段声明中到处都使用了`pub`。
- en: 'Next, let''s try compiling our program:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试编译我们的程序：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What is going on here? Clearly, the compiler found an error in our code. One
    of Rust's strengths is helpful compiler messages. You can see the line where the
    error occurs, the reason why our code is wrong, and sometimes, it even suggests
    the fix for our code. We know that we have to implement the `super::Encryptable`
    trait for the `Rot13` type.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？显然，编译器在我们的代码中找到了错误。Rust的一个优点是它提供了有用的编译器消息。你可以看到错误发生的行，我们代码错误的原因，有时甚至建议修复我们的代码。我们知道我们必须为`Rot13`类型实现`super::Encryptable`特质。
- en: If you want to see more information, run the command shown in the preceding
    error, `rustc --explain E0046`, and the compiler will show more information about
    that particular error.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到更多信息，运行前面错误中显示的命令，`rustc --explain E0046`，编译器将显示关于那个特定错误的更多信息。
- en: 'We now can continue implementing our `Rot13` encryption. First, let''s put
    the signature from the trait into our implementation:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续实现我们的`Rot13`加密。首先，让我们将特质的签名放入我们的实现中：
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The strategy for this encryption is to iterate each character in the string
    and add 13 to the char value if it has a character before `'n'` or `'N'`, and
    remove 13 if it has `'n'` or `'N'` or characters after it. The Rust language handles
    Unicode strings by default, so the program should have a restriction to operate
    only on the Latin alphabet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种加密的策略是对字符串中的每个字符进行迭代，如果它在`'n'`或`'N'`之前有一个字符，就将其字符值加13，如果它在`'n'`或`'N'`或其后有字符，就减去13。Rust语言默认处理Unicode字符串，所以程序应该有一个限制，只能操作拉丁字母。
- en: 'On our first iteration, we want to allocate a new string, get the original
    `String` length, start from the zeroeth index, apply a transformation, push to
    a new string, and repeat until the end:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的第一次迭代中，我们想要分配一个新的字符串，获取原始`String`的长度，从零索引开始，应用一个转换，将其推入一个新的字符串，并重复直到结束：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s try compiling that program. You will quickly find it is not working,
    with all errors being `` `String` cannot be indexed by `usize` ``. Remember that
    Rust handles Unicode by default? Indexing a string will create all sorts of complications,
    as Unicode characters have different sizes: some are 1 byte but others can be
    2, 3, or 4 bytes. With regard to index, what exactly are we saying? Is index means
    the byte position in a `String`, grapheme, or Unicode scalar values?'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试编译那个程序。你很快会发现它不起作用，所有的错误都是`String`不能通过`usize`索引。记住Rust默认处理Unicode吗？索引一个字符串将会产生各种复杂情况，因为Unicode字符有不同的尺寸：有些是1字节，但有些可以是2、3或4字节。关于索引，我们究竟在说什么？索引是指`String`中的字节位置、grapheme还是Unicode标量值？
- en: In the Rust language, we have primitive types such as `u8`, `char`, `fn`, `str`,
    and many more. In addition to those primitive types, Rust also defines a lot of
    modules in the standard library, such as `string`, `io`, `os`, `fmt`, and `thread`.
    These modules contain many building blocks for programming. For example, the `std::string::String`
    struct deals with `String`. Important programming concepts such as comparison
    and iteration are also defined in these modules, for example, `std::cmp::Eq` to
    compare an instance of a type with another instance. The Rust language also has
    `std::iter::Iterator` to make a type iterable. Fortunately, for `String`, we already
    have a method to do iteration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 语言中，我们有原始类型，如 `u8`、`char`、`fn`、`str` 以及更多。除了这些原始类型之外，Rust 还在标准库中定义了许多模块，例如
    `string`、`io`、`os`、`fmt` 和 `thread`。这些模块包含了编程的许多构建块。例如，`std::string::String` 结构体处理
    `String`。重要的编程概念，如比较和迭代，也定义在这些模块中，例如，`std::cmp::Eq` 用于比较类型的实例。Rust 语言还有 `std::iter::Iterator`
    使类型可迭代。幸运的是，对于 `String`，我们已经有了一个进行迭代的方法。
- en: 'Let''s modify our code a little bit:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们稍微修改一下我们的代码：
- en: '[PRE22]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are two ways of returning; the first one is using the `return` keyword
    such as `return new_string;`, or we can write just the variable without a semicolon
    in the last line of a function. You will see that it's more common to use the
    second form.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两种返回方式；第一种是使用 `return` 关键字，如 `return new_string;`，或者我们可以在函数的最后一行不写分号。你会看到第二种形式更常见。
- en: 'The preceding code works just fine, but we can make it more idiomatic. First,
    let''s process the iterator without the `for` loop. Let''s remove the new string
    initialization and use the `map()` method instead. Any type implementing `std::iter::Iterator`
    will have a `map()` method that accepts a closure as the parameter and returns
    `std::iter::Map`. We can then use the `collect()` method to collect the result
    of the closure into its own `String`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码运行正常，但我们可以让它更加符合 Rust 的风格。首先，让我们在不使用 `for` 循环的情况下处理迭代器。让我们移除新的字符串初始化，并使用
    `map()` 方法。任何实现了 `std::iter::Iterator` 的类型都将有一个接受闭包作为参数并返回 `std::iter::Map` 的
    `map()` 方法。然后我们可以使用 `collect()` 方法将闭包的结果收集到它自己的 `String` 中：
- en: '[PRE23]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `map()` method accepts a closure in the form of `|x|...`. We then use the
    captured individual items that we get from `chars()` and process them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 方法接受形式为 `|x|...` 的闭包。然后我们使用从 `chars()` 获取的捕获的单独项进行处理。'
- en: If you look at the closure, you'll see we don't use the `return` keyword either.
    If we don't put the semicolon in a branch and it's the last item, it will be considered
    as a `return` value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看闭包，你会发现我们也没有使用 `return` 关键字。如果我们不在分支中放置分号，并且它是最后一项，它将被视为返回值。
- en: Using the `if` block is good, but we can also make it more idiomatic. One of
    the Rust language's strengths is the powerful `match` control flow.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if` 块是好的，但我们可以让它更加符合 Rust 的风格。Rust 语言的一个优点是强大的 `match` 控制流。
- en: 'Let''s change the code again:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次更改代码：
- en: '[PRE24]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That looks a lot cleaner. The pipe (`|`) operator is a separator to match items
    in an arm. The Rust matcher is exhaustive, which means that the compiler will
    check whether all possible values of the matcher are included in the matcher or
    not. In this case, it means all characters in Unicode. Try removing the last arm
    and compiling it to see what happens if you don't include an item in a collection.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更干净。管道 (`|`) 操作符是一个分隔符，用于匹配臂中的项。Rust 匹配器是详尽的，这意味着编译器会检查匹配器是否包含所有可能的匹配值。在这种情况下，这意味着
    Unicode 中的所有字符。尝试移除最后一个臂并编译它，看看如果不包含集合中的项会发生什么。
- en: You can define a range by using `..` or `..=`. The former means we are excluding
    the last element, and the latter means we are including the last element.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `..` 或 `..=` 来定义一个范围。前者表示我们排除了最后一个元素，而后者表示我们包含了最后一个元素。
- en: 'Now that we have implemented our simple encryptor, let''s use it in our main
    application:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经实现了我们的简单加密器，让我们在主应用程序中使用它：
- en: '[PRE25]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Right now, when we try to compile it, the compiler will show an error. Basically,
    the compiler is saying you cannot use a trait function if the trait is not in
    the scope, and the help from the compiler is showing what we need to do.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当我们尝试编译它时，编译器会显示一个错误。基本上，编译器是在说，如果特性行不在作用域内，就不能使用特性行为，编译器提供的帮助信息显示了我们需要做什么。
- en: 'Put the following line above the `main()` function and the compiler should
    produce a binary without any error:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行放在 `main()` 函数上方，编译器应该生成一个没有错误的二进制文件：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s try running the executable:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试运行可执行文件：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have finished our program and we improved it with real-world encryption.
    In the next section, we're going to learn how to search for and use third-party
    libraries and incorporate them into our application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的程序，并使用现实世界的加密对其进行了改进。在下一节中，我们将学习如何搜索和使用第三方库，并将它们集成到我们的应用程序中。
- en: Packages and Cargo
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包和 Cargo
- en: Now that we know how to create a simple program in Rust, let's explore **Cargo**,
    the Rust package manager. Cargo is a **command-line application** that manages
    your application dependencies and compiles your code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何在 Rust 中创建一个简单的程序，让我们探索 **Cargo**，Rust 的包管理器。Cargo 是一个 **命令行应用程序**，用于管理您的应用程序依赖项并编译您的代码。
- en: Rust has a community package registry at [https://crates.io](https://crates.io).
    You can use that website to search for a library that you can use in your application.
    Don't forget to check the license of the library or application that you want
    to use. If you register on that website, you can use Cargo to publicly distribute
    your library or binary.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 在 [https://crates.io](https://crates.io) 有一个社区包注册处。您可以使用该网站搜索您可以在应用程序中使用的库。别忘了检查您想要使用的库或应用程序的许可证。如果您在该网站上注册，您可以使用
    Cargo 公开分发您的库或二进制文件。
- en: How do we install Cargo into our system? The good news is Cargo is already installed
    if you install the Rust toolchain in the stable channel using `rustup`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将 Cargo 安装到我们的系统中？好消息是，如果您使用 `rustup` 在稳定通道中安装 Rust 工具链，Cargo 已经安装好了。
- en: Cargo package layout
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cargo 包布局
- en: 'Let''s try using Cargo in our application. First, let''s copy the application
    that we wrote earlier:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的应用程序中尝试使用 Cargo。首先，让我们复制我们之前编写的应用程序：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since we already have an existing application, we can initialize our existing
    application with `cargo init`. Notice we add the `--name` option because we are
    prefixing our folder name with a number, and a Rust package name cannot start
    with a number.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个现有的应用程序，我们可以使用 `cargo init` 初始化我们的现有应用程序。注意我们添加了 `--name` 选项，因为我们正在将数字作为文件夹名称的前缀，而
    Rust 包名称不能以数字开头。
- en: If we are creating a new application, we can use the `cargo new package_name`
    command. To create a library-only package instead of a binary package, you can
    pass the `--lib` option to `cargo new`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在创建一个新的应用程序，我们可以使用 `cargo new package_name` 命令。要创建一个仅包含库的包而不是二进制包，您可以将
    `--lib` 选项传递给 `cargo new`。
- en: You will see two new files, `Cargo.toml` and `Cargo.lock`, inside the folder.
    The `.toml` file is a file format commonly used as a configuration file. The `lock`
    file is generated automatically by Cargo, and we don't usually change the content
    manually. It's also common to add `Cargo.lock` to your source code versioning
    application ignore list, such as `.gitignore`, for example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到文件夹内有两个新文件，`Cargo.toml` 和 `Cargo.lock`。`.toml` 文件是一种常用作配置文件的文件格式。`lock`
    文件是由 Cargo 自动生成的，我们通常不会手动更改其内容。通常也会将 `Cargo.lock` 添加到您的源代码版本控制应用程序的忽略列表中，例如 `.gitignore`。
- en: 'Let''s check the content of the `Cargo.toml` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `Cargo.toml` 文件的内容：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, we can define basic things for our application such as `name`
    and `version`. We can also add important information such as authors, homepage,
    repository, and much more. We can also add dependencies that we want to use in
    the Cargo application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以为我们的应用程序定义基本内容，例如 `name` 和 `version`。我们还可以添加重要信息，如作者、主页、仓库等。我们还可以添加在
    Cargo 应用程序中想要使用的依赖项。
- en: 'One thing that stands out is the edition configuration. The Rust edition is
    an optional marker to group various Rust language releases that have the same
    compatibility. When Rust 1.0 was released, the compiler did not have the capability
    to know the `async` and `await` keywords. After `async` and `await` were added,
    it created all sorts of problems with older compilers. The solution to that problem
    was to introduce Rust editions. Three editions have been defined: 2015, 2018,
    and 2021.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的一个特点是版本配置。Rust 版本是一个可选的标记，用于将具有相同兼容性的各种 Rust 语言版本分组。当 Rust 1.0 发布时，编译器没有能力知道
    `async` 和 `await` 关键字。在添加了 `async` 和 `await` 之后，它为旧编译器带来了各种问题。解决这个问题的方法是引入 Rust
    版本。已经定义了三个版本：2015、2018 和 2021。
- en: 'Right now, the Rust compiler can compile our package perfectly fine, but it
    is not very idiomatic because a Cargo project has conventions on file and folder
    names and structures. Let''s change the files and directory structure a little
    bit:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Rust 编译器可以完美地编译我们的包，但它并不非常符合惯例，因为 Cargo 项目在文件和文件夹名称及结构上有约定。让我们稍微改变一下文件和目录结构：
- en: A package is expected to reside in the `src` directory. Let's change the `Cargo.toml`
    file `[[bin]]` path from `"main.rs"` to `"src/main.rs"`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期一个包位于`src`目录中。让我们将`Cargo.toml`文件中的`[[bin]]`路径从`"main.rs"`更改为`"src/main.rs"`。
- en: Create the `src` directory inside our application folder. Then, move the `main.rs`
    file and the `encryptor` folder to the `src` folder.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序文件夹内创建`src`目录。然后，将`main.rs`文件和`encryptor`文件夹移动到`src`文件夹。
- en: 'Add these lines to `Cargo.toml` after `[[bin]]`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`中的`[[bin]]`之后添加这些行：
- en: '[PRE39]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s create the `src/lib.rs` file and move this line from `src/main.rs` to
    `src/lib.rs`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`src/lib.rs`文件，并将此行从`src/main.rs`移动到`src/lib.rs`：
- en: '[PRE40]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can then simplify using both the `rot13` and `Encryptable` modules in our
    `main.rs` file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在`main.rs`文件中简化使用`rot13`和`Encryptable`模块：
- en: '[PRE41]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can check whether there''s an error that prevents the code from being compiled
    by typing `cargo check` in the command line. It should produce something like
    this:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在命令行中输入`cargo check`来检查是否有错误阻止代码编译。它应该产生类似以下的内容：
- en: '[PRE42]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After that, we can build the binary using the `cargo build` command. Since
    we didn''t specify any option in our command, the default binary should be unoptimized
    and contain debugging symbols. The default location for the generated binary is
    in the `target` folder at the root of the workspace:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以使用`cargo build`命令构建二进制文件。由于我们没有在命令中指定任何选项，默认的二进制文件应该是未优化的，并包含调试符号。生成的二进制文件的默认位置是在工作区根目录下的`target`文件夹：
- en: '[PRE43]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can then run the binary in the `target` folder as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以按照以下方式在`target`文件夹中运行二进制文件：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`debug` is enabled by the default dev profile, and `our_package` is the name
    that we specify in `Cargo.toml`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug`默认由开发配置启用，`our_package`是我们指定在`Cargo.toml`中的名称。'
- en: If you want to create a release binary, you can specify the `--release` option,
    `cargo build --release`. You can find the release binary in `./target/release/our_package`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个发布版本的二进制文件，你可以指定`--release`选项，使用`cargo build --release`。你可以在`./target/release/our_package`中找到发布版本的二进制文件。
- en: You can also type `cargo run`, which will compile and run the application for
    you.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以输入`cargo run`，这将为你编译和运行应用程序。
- en: Now that we have arranged our application structure, let's add real-world encryption
    to our application by using a third-party crate.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安排好了应用程序结构，让我们通过使用第三方crate为我们的应用程序添加实际的加密功能。
- en: Using third-party crates
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用第三方crate
- en: 'Before we implement another encryptor using a third-party module, let''s modify
    our application a little bit. Copy the previous `03Packages` folder to the new
    folder, `04Crates`, and use the folder for the following steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用第三方模块实现另一个加密器之前，让我们稍微修改一下我们的应用程序。将之前的`03Packages`文件夹复制到新的文件夹`04Crates`中，并使用该文件夹进行以下步骤：
- en: 'We will rename our Encryptor trait as a Cipher trait and modify the functions.
    The reason is that we only need to think about the output of the type, not the
    encrypt process itself:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重命名我们的Encryptor特质为Cipher特质并修改函数。原因是我们只需要考虑类型的输出，而不是加密过程本身：
- en: Let's change the content of `src/lib.rs` to `pub mod cipher;`.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们将`src/lib.rs`的内容更改为`pub mod cipher;`。
- en: After that, rename the `encryptor` folder as `cipher`.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，将`encryptor`文件夹重命名为`cipher`。
- en: 'Then, modify the Encryptable trait into the following:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将Encryptable特质修改为以下内容：
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The reality is we only need functions to show the original string and the encrypted
    string. We don't need to expose the encryption in the type itself.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们只需要函数来显示原始字符串和加密字符串。我们不需要在类型本身暴露加密。
- en: 'After that, let''s also change `src/cipher/rot13.rs` to use the renamed trait:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，让我们也将`src/cipher/rot13.rs`修改为使用重命名的特质：
- en: '[PRE46]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s also modify `main.rs` to use the new trait and function:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也修改`main.rs`以使用新的特性和函数：
- en: '[PRE47]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The next step is to determine what encryption and library we want to use for
    our new type. We can go to [https://crates.io](https://crates.io) and search for
    an available crate. After searching for a real-world encryption algorithm on the
    website, we found [https://crates.io/crates/rsa](https://crates.io/crates/rsa).
    We found that the RSA algorithm is a secure algorithm, the crate has good documentation
    and has been audited by security researchers, the license is compatible with what
    we need, and there's a huge number of downloads. Aside from checking the source
    code of this library, all indications show that this is a good crate to use. Luckily,
    there's an install section on the right side of that page. Besides the `rsa` crate,
    we are also going to use the `rand` crate, since the RSA algorithm requires a
    random number generator. Since the generated encryption is in bytes, we must encode
    it somehow to `string`. One of the common ways is to use `base64`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定我们想要为我们新的类型使用什么加密和库。我们可以访问[https://crates.io](https://crates.io)并搜索可用的包。在网站上搜索实际的加密算法后，我们找到了[https://crates.io/crates/rsa](https://crates.io/crates/rsa)。我们发现RSA算法是一个安全的算法，该包有良好的文档，并且已经由安全研究人员审核过，许可证与我们的需求兼容，并且下载量巨大。除了检查这个库的源代码外，所有迹象都表明这是一个很好的包来使用。幸运的是，在那个页面的右侧有一个安装部分。除了`rsa`包外，我们还将使用`rand`包，因为RSA算法需要一个随机数生成器。由于生成的加密是字节形式，我们必须以某种方式将其编码为`string`。常见的方法之一是使用`base64`。
- en: 'Add these lines in our `Cargo.toml` file, under the `[dependencies]` section:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Cargo.toml`文件中，在`[dependencies]`部分添加以下行：
- en: '[PRE48]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The next step should be adding a new module and typing using the `rsa` crate.
    But, for this type, we want to modify it a little bit. First, we want to create
    an **associated function**, which might be called a constructor in other languages.
    We want to then encrypt the input string in this function and store the encrypted
    string in a field. There's a saying that all data not in processing should be
    encrypted by default, but the fact is that we as programmers rarely do this.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步应该是添加一个新的模块并使用`rsa`包。但是，对于这个类型，我们想稍作修改。首先，我们想要创建一个**关联函数**，在其他语言中可能被称为构造函数。我们想要在这个函数中加密输入字符串并将加密后的字符串存储在一个字段中。有句话说是所有不在处理中的数据都应该默认加密，但事实是，作为程序员，我们很少这样做。
- en: Since RSA encryption is dealing with byte manipulation, there's a possibility
    of errors, so the return value of the associated function should be wrapped in
    the `Result` type. There's no compiler rule, but if a function cannot fail, the
    return should be straightforward. Regardless of whether or not a function can
    produce a result, the `return` value should be `Option`, but if a function can
    produce an error, it's better to use `Result`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RSA加密涉及字节操作，存在错误的可能性，因此关联函数的返回值应该被包裹在`Result`类型中。虽然没有编译器规则，但如果一个函数不能失败，其返回值应该是直接的。无论函数是否可以产生结果，返回值应该是`Option`，但如果函数可以产生错误，使用`Result`会更好。
- en: The `encrypted_string()` method should return the stored encrypted string, and
    the `original_string()` method should decrypt the stored string and return the
    plain text.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`encrypted_string()`方法应该返回存储的加密字符串，而`original_string()`方法应该解密存储的字符串并返回纯文本。'
- en: 'In `src/cipher/mod.rs`, change the code to the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/cipher/mod.rs`中，将代码更改为以下内容：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since we changed the definition of the trait, we have to change the code in
    `src/cipher/rot13.rs` as well. Change the code to the following:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们改变了特性的定义，我们不得不将`src/cipher/rot13.rs`中的代码也进行更改。将代码更改为以下内容：
- en: '[PRE50]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s add the following line in the `src/cipher/mod.rs` file:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`src/cipher/mod.rs`文件中添加以下行：
- en: '[PRE51]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After that, create `rsa.rs` inside the `cipher` folder and create the `Rsa`
    struct inside it. Notice that we use `Rsa` instead of `RSA` as the type name.
    The convention is to use `CamelCase` for type:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`cipher`文件夹内创建`rsa.rs`文件，并在其中创建`Rsa`结构体。请注意，我们使用`Rsa`而不是`RSA`作为类型名。按照惯例，类型名应使用`CamelCase`格式：
- en: '[PRE52]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There are a couple of things we can observe. The first one is the `data` field
    does not have the `pub` keyword since we want to make it private. You can see
    that we have two `impl` blocks: one is for defining the methods of the `Rsa` type
    itself, and the other is for implementing the `Cipher` trait.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到一些事情。首先，`data`字段没有`pub`关键字，因为我们想将其设置为私有。你可以看到我们有两个`impl`块：一个是用于定义`Rsa`类型的自身方法，另一个是用于实现`Cipher`特质。
- en: Also, the `new()` function does not have `self`, `mut self`, `&self`, or `&mut
    self` as the first parameter. Consider it as a static method in other languages.
    This method is returning `Result`, which is either `Ok(Self)` or `Box<dyn Error>`.
    The `Self` instance is the instance of the `Rsa` struct, but we'll discuss `Box<dyn
    Error>` later when we talk about error handling in [*Chapter 7*](B16825_07_ePub.xhtml#_idTextAnchor091),
    *Handling Errors in Rust and Rocket*. Right now, we haven't implemented this method,
    hence the usage of the `unimplemented!()` macro. Macros in Rust look like a function
    but with an extra bang (!).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`new()`函数没有`self`、`mut self`、`&self`或`&mut self`作为第一个参数。在其他语言中，将其视为一个静态方法。此方法返回`Result`，要么是`Ok(Self)`，要么是`Box<dyn
    Error>`。`Self`实例是`Rsa`结构体的实例，但我们将稍后讨论`Box<dyn Error>`，当我们在[*第7章*](B16825_07_ePub.xhtml#_idTextAnchor091)中讨论Rust和Rocket的错误处理时。现在，我们还没有实现此方法，因此使用了`unimplemented!()`宏。Rust中的宏看起来像函数，但有一个额外的感叹号（!）。
- en: 'Now, let''s implement the associated function. Modify `src/cipher/rsa.rs`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现关联函数。修改`src/cipher/rsa.rs`：
- en: '[PRE53]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first thing we do is declare the various types we are going to use. After
    that, we define a constant to denote what size key we are going to use.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明我们将要使用的各种类型。之后，我们定义一个常量来表示我们将使用什么大小的密钥。
- en: 'If you understand the RSA algorithm, you already know that it''s an asymmetric
    algorithm, meaning we have two keys: a public key and a private key. We use the
    public key to encrypt data and use the private key to decrypt the data. We can
    generate and give the public key to the other party, but we don''t want to give
    the private key to the other party. That means we must store the private key inside
    the struct as well.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解RSA算法，你已经知道它是一个非对称算法，这意味着我们有两个密钥：一个公钥和一个私钥。我们使用公钥加密数据，使用私钥解密数据。我们可以生成公钥并将其提供给另一方，但我们不希望将私钥提供给另一方。这意味着我们必须将私钥存储在结构体内部。
- en: The `new()` implementation is pretty straightforward. The first thing we do
    is declare a random number generator, `rng`. We then generate the RSA private
    key. But, pay attention to the question mark operator (`?`) on the initialization
    of the private key. If a function returns `Result`, we can quickly return the
    error generated by calling any method or function inside it by using (`?`) after
    that function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`new()`的实现相当直接。我们首先声明一个随机数生成器，`rng`。然后，我们生成RSA私钥。但请注意私钥初始化时的问号运算符（`?`）。如果一个函数返回`Result`，我们可以在调用其内部任何方法或函数后快速返回由该函数生成的错误，只需在该函数后使用（`?`）即可。'
- en: Then, we generate the RSA public key from a private key, encode the input string
    as bytes, and encrypt the data. Since encrypting the data might have resulted
    in an error, we use the question mark operator again. We then encode the encrypted
    bytes as a `base64` string and initialize `Self`, which means the `Rsa` struct
    itself.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从私钥生成RSA公钥，将输入字符串编码为字节，并加密数据。由于加密数据可能会导致错误，我们再次使用问号运算符。然后，我们将加密的字节编码为`base64`字符串，并初始化`Self`，这意味着`Rsa`结构体本身。
- en: 'Now, let''s implement the `original_string()` method. We should do the opposite
    of what we do when we create the struct:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现`original_string()`方法。我们应该做与我们创建结构体时相反的操作：
- en: '[PRE54]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: First, we decode the `base64` encoded string in the `data` field. Then, we decrypt
    the decoded bytes and convert them back to a string.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们解码`data`字段中的`base64`编码字符串。然后，我们解密解码的字节并将它们转换回字符串。
- en: 'Now that we have finished our `Rsa` type, let''s use it in our `main.rs` file:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`Rsa`类型，让我们在`main.rs`文件中使用它：
- en: '[PRE55]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Some of you might wonder why we redeclared the `user_input` variable. The simple
    explanation is that Rust already moved the resource to the new `Rot13` type, and
    Rust does not allow the reuse of the moved value. You can try commenting on the
    second variable declaration and compile the application to see the explanation.
    We will discuss the Rust borrow checker and moving in more detail in [*Chapter
    9*](B16825_09_ePub.xhtml#_idTextAnchor109)*, Displaying Users' Post*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会想知道为什么我们重新声明了`user_input`变量。简单的解释是Rust已经将资源移动到了新的`Rot13`类型，而Rust不允许重复使用已移动的值。你可以尝试注释掉第二个变量声明并编译应用程序以查看解释。我们将在[*第9章*](B16825_09_ePub.xhtml#_idTextAnchor109)中更详细地讨论Rust的借用检查器和移动。
- en: 'Now, try running the program by typing `cargo run`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试通过输入`cargo run`来运行程序：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You will see that Cargo automatically downloaded the dependencies and builds
    them one by one. Also, you might notice that encrypting using the `Rsa` type took
    a while. Isn't Rust supposed to be a fast system language? The RSA algorithm itself
    is a slow algorithm, but that's not the real cause of the slowness. Because we
    are running the program in a development profile, the Rust compiler generates
    an application binary with all the debugging information and does not optimize
    the resulting binary. On the other hand, if you build the application using the
    `--release` flag, the compiler generates an optimized application binary and strips
    the debugging symbols. The resulting binary compiled with the release flag should
    execute faster than the debug binary. Try doing it yourself so you'll remember
    how to build a release binary.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现Cargo会自动下载依赖并逐个构建它们。此外，你可能注意到使用`Rsa`类型加密花费了一些时间。Rust不是应该是一个快速的系统语言吗？RSA算法本身就是一个慢速算法，但这并不是速度慢的真正原因。因为我们是在开发配置下运行程序，Rust编译器生成一个包含所有调试信息的应用程序二进制文件，并且不对生成的二进制文件进行优化。另一方面，如果你使用`--release`标志构建应用程序，编译器会生成一个优化的应用程序二进制文件并删除调试符号。使用发布标志编译的结果二进制文件应该比调试二进制文件执行得更快。试着亲自做一下，这样你会记住如何构建发布二进制文件。
- en: In this section, we have learned about Cargo and third-party packages, so next,
    let's find out where to find help and documentation for the tools that we have
    used.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了Cargo和第三方包，所以接下来，让我们了解一下如何找到我们使用的工具的帮助和文档。
- en: Tools and getting help
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具和获取帮助
- en: Now that we have created a pretty simple application, you might be wondering
    what tools we can use for development, and how to find out more about Rust and
    get help.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个相当简单的应用程序，你可能想知道我们可以使用哪些工具进行开发，以及如何了解更多关于Rust和获取帮助。
- en: Tools
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具
- en: 'Besides Cargo, there are a couple more tools we can use for Rust application
    development:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Cargo，我们还可以使用一些其他工具来开发Rust应用程序：
- en: '**rustfmt**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rustfmt**'
- en: This program is for formatting your source code so it follows the Rust style
    guide. You can install it by using `rustup` (`rustup component add rustfmt`).
    Then, you can integrate it with your favorite text editor or use it from the command
    line. You can read more about `rustfmt` at [https://github.com/rust-lang/rustfmt](https://github.com/rust-lang/rustfmt).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序用于格式化你的源代码，使其遵循Rust风格指南。你可以通过使用`rustup`（`rustup component add rustfmt`）来安装它。然后，你可以将其集成到你的
    favorite text editor 或者在命令行中使用它。你可以在[https://github.com/rust-lang/rustfmt](https://github.com/rust-lang/rustfmt)了解更多关于`rustfmt`的信息。
- en: '**clippy**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**clippy**'
- en: 'Does the name remind you of something? `clippy` is useful for linting your
    Cargo application using various lint rules. Right now, there are more than 450
    lint rules you can use. You can install it using this command: `rustup component
    add clippy`. Afterward, you can use it in the Cargo application by running `cargo
    clippy`. Can you try it in the Cargo application that we wrote earlier? You can
    read more about `clippy` at [https://github.com/rust-lang/rust-clippy](https://github.com/rust-lang/rust-clippy).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字让你想起了什么吗？`clippy`通过使用各种lint规则对你的Cargo应用程序进行linting非常有用。目前，你可以使用超过450个lint规则。你可以使用以下命令安装它：`rustup
    component add clippy`。之后，你可以通过运行`cargo clippy`在Cargo应用程序中使用它。你能在我们之前写的Cargo应用程序中尝试一下吗？你可以在[https://github.com/rust-lang/rust-clippy](https://github.com/rust-lang/rust-clippy)了解更多关于`clippy`的信息。
- en: Text editor
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: 'Most likely, the text editor of your choice already supports the Rust language,
    or at least syntax highlighting Rust. You can install the Rust language server
    if you want to add important functionalities such as go to definition, go to implementation,
    symbol search, and code completion. Most popular text editors already support
    the language server, so you can just install an extension or other integration
    method to your text editor:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你选择的文本编辑器已经支持Rust语言，或者至少支持Rust的语法高亮。如果你想添加诸如跳转到定义、跳转到实现、符号搜索和代码补全等重要功能，你可以安装Rust语言服务器。大多数流行的文本编辑器已经支持语言服务器，所以你只需在你的文本编辑器中安装扩展或其他集成方法即可：
- en: '**The Rust language server**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust语言服务器**'
- en: 'You can install it using the `rustup` command: `rustup component add rls rust-analysis
    rust-src`. Then, you can integrate it into your text editor. For example, if you
    are using `rls`.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`rustup`命令安装它：`rustup component add rls rust-analysis rust-src`。然后，你可以将其集成到你的文本编辑器中。例如，如果你正在使用`rls`。
- en: You can read more about it at [https://github.com/rust-lang/rls](https://github.com/rust-lang/rls).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/rust-lang/rls](https://github.com/rust-lang/rls)了解更多关于它的信息。
- en: '**Rust analyzer**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust analyzer**'
- en: This application is poised to be the Rust language server 2.0\. It's still considered
    to be in alpha as of the writing of this book, but in my experience, this application
    works well with regular updates. You can find the executable for this one at [https://github.com/rust-analyzer/rust-analyzer/releases](https://github.com/rust-analyzer/rust-analyzer/releases),
    and then configure your editor language server to use this application. You can
    read more about it at [https://rust-analyzer.github.io](https://rust-analyzer.github.io).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序有望成为Rust语言服务器2.0。截至本书编写时，它仍被视为处于alpha阶段，但根据我的经验，这个应用程序与常规更新配合得很好。你可以在[https://github.com/rust-analyzer/rust-analyzer/releases](https://github.com/rust-analyzer/rust-analyzer/releases)找到这个应用程序的可执行文件，然后配置你的编辑器语言服务器以使用此应用程序。你可以在[https://rust-analyzer.github.io](https://rust-analyzer.github.io)了解更多关于它的信息。
- en: Getting help and documentation
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取帮助和文档
- en: 'There are a few important documents that you might want to read to find help
    or references:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有几份重要的文档，你可能想要阅读以获取帮助或参考：
- en: '**The Rust programming language book**: This is the book that you want to read
    if you want to understand more about the Rust programming language. You can find
    it online at [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**《Rust编程语言书籍》**：如果你想了解更多关于Rust编程语言的信息，这本书是你想要阅读的。你可以在[https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)在线找到它。'
- en: '**Rust by Example**: This documentation is a collection of small examples that
    show the concepts of the Rust language and its standard library''s capabilities.
    You can read it online at [https://doc.rust-lang.org/rust-by-example/index.html](https://doc.rust-lang.org/rust-by-example/index.html).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust示例**：这份文档是关于Rust语言及其标准库功能概念的示例集合。你可以在[https://doc.rust-lang.org/rust-by-example/index.html](https://doc.rust-lang.org/rust-by-example/index.html)在线阅读它。'
- en: '**Standard library documentation**: As a programmer, you will refer to this
    standard library documentation. You can read more about standard libraries, their
    modules, the function signatures, what standard libraries'' functions do, read
    the examples, and more. Find it at [https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准库文档**：作为一名程序员，你将参考这份标准库文档。你可以了解更多关于标准库、它们的模块、函数签名、标准库函数的功能、阅读示例等内容。你可以在[https://doc.rust-lang.org/std/index.html](https://doc.rust-lang.org/std/index.html)找到它。'
- en: '`Cargo.toml` manifest format, you can read more about it at [https://doc.rust-lang.org/cargo/index.html](https://doc.rust-lang.org/cargo/index.html).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cargo.toml`清单格式，你可以在[https://doc.rust-lang.org/cargo/index.html](https://doc.rust-lang.org/cargo/index.html)了解更多关于它的信息。'
- en: '**Rust style guidelines**: The Rust language, like other programming languages,
    has style guidelines. These guidelines tell a programmer what the convention for
    naming is, about whitespaces, how to use constants, and other idiomatic conventions
    for a Rust program. Read more about it at [https://doc.rust-lang.org/1.0.0/style/](https://doc.rust-lang.org/1.0.0/style/).'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust风格指南**：Rust语言，像其他编程语言一样，有风格指南。这些指南告诉程序员命名约定是什么，关于空白，如何使用常量，以及Rust程序的其它惯用约定。你可以在[https://doc.rust-lang.org/1.0.0/style/](https://doc.rust-lang.org/1.0.0/style/)了解更多关于它的信息。'
- en: '`rsa` crate that we used earlier. To find documentation for that library, you
    can go to [https://crates.io](https://crates.io) and search for the crate''s page,
    then go to the right pane and go to the documentation section. Or, you can go
    to [https://docs.rs](https://docs.rs) and search for the crate name and find the
    documentation for it.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前使用的`rsa`包。要找到该库的文档，你可以访问[https://crates.io](https://crates.io)，搜索该包的页面，然后转到右侧面板并进入文档部分。或者，你可以访问[https://docs.rs](https://docs.rs)，搜索包名并找到它的文档。
- en: '`rustup` (`rustup component add rust-docs`). Then, you can open documentation
    in your browser while offline using the `rustup doc` command. If you want to open
    standard library documentation offline, you can type `rustup doc --std`. There
    are other documents you can open; try and see what they are by using `rustup doc
    --help`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustup`（`rustup component add rust-docs`）。然后，你可以使用`rustup doc`命令在离线状态下打开文档。如果你想离线打开标准库文档，你可以输入`rustup
    doc --std`。还有其他可以打开的文档；尝试使用`rustup doc --help`来查看它们是什么。'
- en: '**The Rust user forum**: If you want to get help or help other Rust programmers,
    you can find it all over the internet. There''s a dedicated forum to discuss Rust-related
    topics at [https://users.rust-lang.org/](https://users.rust-lang.org/).'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust用户论坛**：如果你想得到帮助或帮助其他Rust程序员，你可以在互联网上找到所有这些。在[https://users.rust-lang.org/](https://users.rust-lang.org/)有一个专门的论坛来讨论与Rust相关的话题。'
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a brief overview of the Rust language. We learned about
    the Rust toolchain and how to install it as well as the tools required for Rust
    development. After that, we created two simple programs, used Cargo, and imported
    third-party modules to improve our program. Now that you can write a small program
    in the Rust language, explore! Try creating more programs or experimenting with
    the language. You can try *Rust by Example* to see what features we can use in
    our programs. In subsequent chapters, we will learn more about Rocket, a web framework
    written in the Rust language.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对 Rust 语言进行了简要概述。我们学习了 Rust 工具链及其安装方法，以及 Rust 开发所需的工具。之后，我们创建了两个简单的程序，使用了
    Cargo，并导入第三方模块以改进我们的程序。现在，你已经可以用 Rust 语言编写小程序了，去探索吧！尝试创建更多程序或对语言进行实验。你可以尝试使用 *Rust
    by Example* 来查看我们可以在程序中使用哪些特性。在随后的章节中，我们将学习更多关于 Rocket 的内容，这是一个用 Rust 语言编写的网络框架。
