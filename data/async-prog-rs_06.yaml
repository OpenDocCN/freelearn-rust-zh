- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Futures in Rust
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust中的future
- en: 'In [*Chapter 5*](B20892_05.xhtml#_idTextAnchor092), we covered one of the most
    popular ways of modeling concurrency in a programming language: fibers/green threads.
    Fibers/green threads are an example of stackful coroutines. The other popular
    way of modeling asynchronous program flow is by using what we call stackless coroutines,
    and combining Rust’s futures with `async/await` is an example of that. We will
    cover this in detail in the next chapters.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B20892_05.xhtml#_idTextAnchor092)中，我们介绍了一种在编程语言中建模并发最流行的方式：纤程/绿色线程。纤程/绿色线程是堆栈式协程的一个例子。建模异步程序流的另一种流行方式是使用我们所说的无堆栈协程，将Rust的future与`async/await`结合就是一个例子。我们将在下一章中详细讨论这一点。
- en: 'This first chapter will introduce Rust’s futures to you, and the main goals
    of this chapter are to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一章将向您介绍Rust的future，本章的主要目标是完成以下内容：
- en: Give you a high-level introduction to concurrency in Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给您一个Rust中并发的概述
- en: Explain what Rust provides and not in the language and standard library when
    working with async code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Rust在处理异步代码时提供的内容以及语言和标准库中不提供的内容
- en: Get to know why we need a runtime library in Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解为什么我们需要在Rust中使用运行时库
- en: Understand the difference between a leaf future and a non-leaf future
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解叶未来和非叶未来的区别
- en: Get insight into how to handle CPU-intensive tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何处理CPU密集型任务
- en: 'To accomplish this, we’ll divide this chapter into the following sections:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个目标，我们将把本章分为以下部分：
- en: What is a future?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是future？
- en: Leaf futures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叶未来
- en: Non-leaf futures
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非叶未来
- en: Runtimes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时
- en: A mental model of an async runtime
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步运行时的心理模型
- en: What the Rust language and standard library take care of
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust语言和标准库负责的内容
- en: I/O vs CPU-intensive tasks
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O与CPU密集型任务
- en: Advantages and disadvantages of Rust’s async model
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust异步模型的优缺点
- en: What is a future?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是future？
- en: A future is a representation of some operation that will be completed in the
    future.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: future是对未来完成的某个操作的表示。
- en: 'Async in Rust uses a poll-based approach in which an asynchronous task will
    have three phases:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的异步使用基于poll的方法，其中异步任务将经历三个阶段：
- en: '**The poll phase**: A future is polled, which results in the task progressing
    until a point where it can no longer make progress. We often refer to the part
    of the runtime that polls a future as an executor.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮询阶段**：对future进行轮询，这会导致任务进展到它不能再进一步进展的点。我们通常将轮询future的运行时部分称为executor。'
- en: '**The wait phase**: An event source, most often referred to as a reactor, registers
    that a future is waiting for an event to happen and makes sure that it will wake
    the future when that event is ready.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待阶段**：事件源，通常被称为reactor，注册了一个future正在等待某个事件发生，并确保当该事件准备好时唤醒future。'
- en: '**The wake phase**: The event happens and the future is woken up. It’s now
    up to the executor that polled the future in *step 1* to schedule the future to
    be polled again and make further progress until it completes or reaches a new
    point where it can’t make further progress and the cycle repeats.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**唤醒阶段**：事件发生，future被唤醒。现在取决于在*步骤1*中轮询future的executor来安排future再次被轮询并进一步进展，直到它完成或达到它不能再进一步进展的新点，然后循环重复。'
- en: Now, when we talk about futures, I find it useful to make a distinction between
    **non-leaf** futures and **leaf** futures early on because, in practice, they’re
    pretty different from one another.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们谈论未来时，我认为一开始就区分**非叶**未来和**叶**未来是有用的，因为在实践中，它们彼此之间相当不同。
- en: Leaf futures
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 叶未来
- en: Runtimes create leaf futures, which represent a resource such as a socket.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时创建叶future，它代表一个资源，如套接字。
- en: 'This is an example of a leaf future:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个叶未来示例：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Operations on these resources, such as a reading from a socket, will be non-blocking
    and return a future, which we call a leaf future since it’s the future that we’re
    actually waiting on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些资源进行的操作，例如从套接字读取，将是非阻塞的，并返回一个future，我们称之为叶future，因为它是我们实际等待的future。
- en: It’s unlikely that you’ll implement a leaf future yourself unless you’re writing
    a runtime, but we’ll go through how they’re constructed in this book as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您不太可能自己实现叶future，除非您正在编写运行时，但我们将在这本书中介绍它们是如何构建的。
- en: It’s also unlikely that you’ll pass a leaf future to a runtime and run it to
    completion alone, as you’ll understand by reading the next paragraph.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您也不太可能将叶future传递给运行时并单独运行到完成，正如您将在下一段中阅读到的。
- en: Non-leaf futures
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非叶未来
- en: Non-leaf futures are the kind of futures we as users of a runtime write ourselves
    using the `async` keyword to create a task that can be run on the executor.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 非叶未来是我们作为运行时用户使用 `async` 关键字自己编写的，可以在执行器上运行的任务。
- en: The bulk of an async program will consist of non-leaf futures, which are a kind
    of pause-able computation. This is an important distinction since these futures
    represent a set of operations. Often, such a task will `await` a leaf future as
    one of many operations to complete the task.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 异步程序的大部分将包括非叶未来，这是一种可暂停的计算。这是一个重要的区别，因为这些未来代表了一组操作。通常，这样的任务会将叶未来作为许多操作之一 `await`，以完成任务。
- en: 'This is an example of a non-leaf future:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非叶未来示例：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The two highlighted lines indicate points where we pause the execution, yield
    control to a runtime, and eventually resume. In contrast to leaf futures, these
    kinds of futures do not themselves represent an I/O resource. When we poll them,
    they will run until they get to a leaf future that returns `Pending` and then
    yields control to the scheduler (which is a part of what we call the runtime).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 两个突出显示的行表示我们暂停执行、将控制权交给运行时，并最终恢复的点。与叶未来相比，这类未来本身并不代表 I/O 资源。当我们轮询它们时，它们会一直运行，直到到达返回
    `Pending` 的叶未来，然后才会将控制权交给调度器（这是我们所说的运行时的一部分）。
- en: Runtimes
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时
- en: Languages such as C#, JavaScript, Java, Go, and many others come with a runtime
    for handling concurrency. So, if you’re used to one of those languages, this will
    seem a bit strange to you. Rust is different from these languages in the sense
    that Rust doesn’t come with a runtime for handling concurrency, so you need to
    use a library that provides this for you.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C#、JavaScript、Java、Go 以及许多其他语言都自带用于处理并发的运行时。因此，如果你习惯了这些语言之一，这对你来说可能有点奇怪。与这些语言不同，Rust
    并没有自带用于处理并发的运行时，所以你需要使用一个提供此功能的库。
- en: Quite a bit of complexity attributed to futures is actually complexity rooted
    in runtimes; creating an efficient runtime is hard.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给未来的相当一部分复杂性实际上源于运行时；创建一个高效的运行时是困难的。
- en: Learning how to use one correctly requires quite a bit of effort as well, but
    you’ll see that there are several similarities between this kind of runtime, so
    learning one makes learning the next much easier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何正确使用它也需要相当多的努力，但你会发现这类运行时之间有几种相似之处，因此学习一个会使学习下一个变得容易得多。
- en: The difference between Rust and other languages is that you have to make an
    active choice when it comes to picking a runtime. Most often, in other languages,
    you’ll just use the one provided for you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 与其他语言的区别在于，在选择运行时时要做出一个积极的选择。在其他语言中，你通常会使用为你提供的那个。
- en: A mental model of an async runtime
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步运行时的心理模型
- en: I find it easier to reason about how futures work by creating a high-level mental
    model we can use. To do that, I have to introduce the concept of a runtime that
    will drive our futures to completion.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现通过创建一个我们可以使用的高级心理模型来推理未来的工作方式更容易。为了做到这一点，我必须引入一个概念，即运行时将推动我们的未来完成。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The mental model I create here is not the only way to drive futures to completion,
    and Rust’s futures do not impose any restrictions on how you actually accomplish
    this task.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里创建的心理模型并不是驱动未来完成的唯一方式，Rust 的未来也不会对如何实际完成这项任务施加任何限制。
- en: 'A fully working async system in Rust can be divided into three parts:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完全工作的 Rust 异步系统可以分为三个部分：
- en: Reactor (responsible for notifying about I/O events)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应器（负责通知 I/O 事件）
- en: Executor (scheduler)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行器（调度器）
- en: Future (a task that can stop and resume at specific points)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来（可以在特定点停止和恢复的任务）
- en: So, how do these three parts work together?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这三个部分是如何协同工作的呢？
- en: 'Let’s take a look at a diagram that shows a simplified overview of an async
    runtime:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个展示异步运行时简化概述的图表：
- en: '![Figure 6.1 – Reactor, executor, and waker](img/B20892_07_1.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 反应器、执行器和唤醒器](img/B20892_07_1.jpg)'
- en: Figure 6.1 – Reactor, executor, and waker
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 反应器、执行器和唤醒器
- en: In *step 1* of the figure, an executor holds a list of futures. It will try
    to run the future by polling it (the poll phase), and when it does, it hands it
    a `Waker`. The future either returns `Poll:Ready` (which means it’s finished)
    or `Poll::Pending` (which means it’s not done but can’t get further at the moment).
    When the executor receives one of these results, it knows it can start polling
    a different future. We call these points where control is shifted back to the
    executor *yield points*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在图象的*步骤 1*中，执行者持有一个未来列表。它将通过轮询（轮询阶段）尝试运行未来，当它这样做时，它会将一个`Waker`传递给它。未来要么返回`Poll:Ready`（这意味着它已完成）或`Poll::Pending`（这意味着它尚未完成，但此刻无法进一步执行）。当执行者收到这些结果之一时，它知道它可以开始轮询另一个未来。我们将这些控制权返回给执行者的点称为*yield点*。
- en: In *step 2*, the reactor stores a copy of the `Waker` that the executor passed
    to the future when it polled it. The reactor tracks events on that I/O source,
    usually through the same type of event queue that we learned about in [*Chapter
    4*](B20892_04.xhtml#_idTextAnchor081).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，反应器存储了执行者在轮询未来时传递给它的`Waker`的副本。反应器跟踪该I/O源上的事件，通常是通过我们在[*第 4 章*](B20892_04.xhtml#_idTextAnchor081)中学到的相同类型的事件队列。
- en: In *step 3*, when the reactor gets a notification that an event has happened
    on one of the tracked sources, it locates the `Waker` associated with that source
    and calls `Waker::wake` on it. This will in turn inform the executor that the
    future is ready to make progress so it can poll it once more.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 3*中，当反应器收到通知，表明跟踪的源之一发生了事件时，它会定位与该源关联的`Waker`，并在其上调用`Waker::wake`。这将反过来通知执行者，未来已准备好继续前进，因此它可以再次轮询它。
- en: 'If we write a short async program using pseudocode, it will look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用伪代码编写一个简短的异步程序，它将看起来像这样：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The line where we write `await` is the one that will return control back to
    the scheduler. This is often called a *yield point* since it will return either
    `Poll::Pending` or `Poll::Ready` (most likely it will return `Poll::Pending` the
    first time the future is polled).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写入`await`的行是返回控制权给调度器的行。这通常被称为*yield点*，因为它将返回`Poll::Pending`或`Poll::Ready`（最可能的情况是，第一次轮询未来时将返回`Poll::Pending`）。
- en: Since the `Waker` is the same across all executors, reactors can, in theory,
    be completely oblivious to the type of executor, and vice-versa. *Executors and
    reactors never need to communicate with one* *another directly.*
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Waker`在所有执行者中都是相同的，因此反应器在理论上可以完全忽略执行者的类型，反之亦然。*执行者和反应器无需直接相互通信*。
- en: This design is what gives the futures framework its power and flexibility and
    allows the Rust standard library to provide an ergonomic, zero-cost abstraction
    for us to use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计赋予了未来框架其力量和灵活性，并允许Rust标准库为我们提供一个易于使用、零成本的抽象。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I introduced the concept of reactors and executors here like it’s something
    everyone knows about. I know that’s not the case, and don’t worry, we’ll go through
    this in detail in the next chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里介绍了反应器和执行者的概念，就像它是每个人都了解的东西一样。我知道情况并非如此，不用担心，我们将在下一章中详细讲解。
- en: What the Rust language and standard library take care of
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust语言和标准库负责处理的事项
- en: 'Rust only provides what’s necessary to model asynchronous operations in the
    language. Basically, it provides the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Rust只为在语言中建模异步操作提供必要的功能。基本上，它提供了以下功能：
- en: A common interface that represents an operation, which will be completed in
    the future through the `Future` trait
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示操作的通用接口，该操作将通过`Future`特质在未来完成
- en: An ergonomic way of creating tasks (stackless coroutines to be precise) that
    can be suspended and resumed through the `async` and `await` keywords
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`async`和`await`关键字创建可以挂起和恢复的任务（确切地说，是无栈协程）的便捷方式
- en: A defined interface to wake up a suspended task through the `Waker` type
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`Waker`类型定义的唤醒挂起任务的方式
- en: That’s really what Rust’s standard library does. As you see there is no definition
    of non-blocking I/O, how these tasks are created, or how they’re run. There is
    no non-blocking version of the standard library, so to actually run an asynchronous
    program, you have to either create or decide on a runtime to use.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Rust标准库所做的事情。正如你所看到的，没有非阻塞I/O的定义，也没有说明这些任务是如何创建或运行的。没有标准库的非阻塞版本，因此要实际运行异步程序，你必须创建或选择一个运行时来使用。
- en: I/O vs CPU-intensive tasks
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O任务与CPU密集型任务
- en: 'As you know now, what you normally write are called non-leaf futures. Let’s
    take a look at this `async` block using pseudo-Rust as an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在所知，您通常编写的被称为非叶子future。让我们以伪Rust为例，看看这个`async`块：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I’ve highlighted the points where we yield control to the runtime executor.
    It’s important to be aware that the code we write between the yield points runs
    on the *same thread* as our executor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了我们将控制权交给运行时执行器的地方。重要的是要意识到，我们在yield点之间编写的代码与我们的执行器在**同一线程**上运行。
- en: That means that while our `analyzer` is working on the dataset, the executor
    is busy doing calculations instead of handling new requests.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们的`analyzer`正在处理数据集时，执行器正忙于进行计算，而不是处理新的请求。
- en: 'Fortunately, there are a few ways to handle this, and it’s not difficult, but
    it’s something you must be aware of:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有几种处理这种问题的方法，而且并不困难，但这是您必须注意的事情：
- en: We could create a new leaf future, which sends our task to another thread and
    resolves when the task is finished. We could `await` this leaf-future like any
    other future.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的叶子future，将我们的任务发送到另一个线程，并在任务完成时解决。我们可以像其他future一样`await`这个叶子future。
- en: The runtime could have some kind of supervisor that monitors how much time different
    tasks take and moves the executor itself to a different thread so it can continue
    to run even though our `analyzer` task is blocking the original executor thread.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时可能有一种监督器，可以监控不同任务花费的时间，并将执行器本身移动到不同的线程，这样即使我们的`analyzer`任务阻塞了原始执行器线程，它也可以继续运行。
- en: You can create a reactor yourself that is compatible with the runtime, which
    does the analysis any way you see fit and returns a future that can be awaited.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以创建一个与运行时兼容的反应器，以任何您认为合适的方式进行分析，并返回一个可以被`await`的future。
- en: 'Now, the first way is the usual way of handling this, but some executors implement
    the second method as well. The problem with #2 is that if you switch runtime,
    you need to make sure that it supports this kind of supervision as well or else
    you will end up blocking the executor.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一种方法是处理这种情况的常规方法，但一些执行器也实现了第二种方法。问题在于，如果您切换运行时，您需要确保它也支持这种类型的监督，否则您最终会阻塞执行器。
- en: The third method is more of theoretical importance; normally, you’d be happy
    to send the task to the thread pool that most runtimes provide.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个方法在理论上有更多的重要性；通常，您会乐意将任务发送到大多数运行时提供的线程池。
- en: 'Most executors have a way to accomplish #1 using methods such as `spawn_blocking`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数执行器都有一种方法，可以使用如`spawn_blocking`之类的函数来实现#1。
- en: These methods send the task to a thread pool created by the runtime where you
    can either perform CPU-intensive tasks or blocking tasks that are not supported
    by the runtime.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法将任务发送到由运行时创建的线程池中，您可以在其中执行CPU密集型任务或运行时不支持的阻塞任务。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, in this short chapter, we introduced Rust’s futures to you. You should now
    have a basic idea of what Rust’s async design looks like, what the language provides
    for you, and what you need to get elsewhere. You should also have an idea of what
    a leaf future and a non-leaf future are.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们向您介绍了Rust的futures。现在，您应该对Rust的异步设计有一个基本的了解，语言为您提供了什么，以及您需要在哪里获取什么。您也应该对叶子future和非叶子future有一个概念。
- en: These aspects are important as they’re design decisions built into the language.
    You know by now that Rust uses stackless coroutines to model asynchronous operations,
    but since a coroutine doesn’t do anything in and of itself, it’s important to
    know that the choice of how to schedule and run these coroutines is left up to
    you.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面很重要，因为它们是内置到语言中的设计决策。您现在知道Rust使用无栈协程来模拟异步操作，但既然协程本身不做什么，了解如何调度和运行这些协程的选择留给了您。
- en: We’ll get a much better understanding as we start to explain how this all works
    in detail as we move forward.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始详细解释这一切是如何工作的，我们将对它有一个更深入的理解。
- en: Now that we’ve seen a high-level overview of Rust’s futures, we’ll start explaining
    how they work from the ground up. The next chapter will cover the concept of futures
    and how they’re connected with coroutines and the `async/await` keywords in Rust.
    We’ll see for ourselves how they represent tasks that can pause and resume their
    execution, which is a prerequisite to having multiple tasks be *in progress* concurrently,
    and how they differ from the pausable/resumable tasks we implemented as fibers/green
    threads in [*Chapter 5*](B20892_05.xhtml#_idTextAnchor092).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 Rust 的 futures 的高级概述，我们将从底层开始解释它们是如何工作的。下一章将涵盖 futures 的概念以及它们与 Rust
    中的协程和 `async/await` 关键字的关系。我们将亲自看到它们如何表示可以暂停和恢复执行的任务，这是多个任务能够同时 *进行中* 的先决条件，以及它们与我们实现为
    fibers/green threads 的可暂停/可恢复任务有何不同。[第 5 章](B20892_05.xhtml#_idTextAnchor092)。
