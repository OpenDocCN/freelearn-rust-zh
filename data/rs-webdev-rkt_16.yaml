- en: '*Chapter 13*: Launching a Rocket Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：启动Rocket应用程序'
- en: After development and testing, an important part of development is preparing
    the application to serve its intended users. In this chapter, we are going to
    learn some techniques to generate a production-ready binary. After we generate
    the binary, we are going to learn about configuring the application behind a general-purpose
    web server. And finally, we will learn how to generate Docker images for a Rocket
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和测试之后，开发的一个重要部分是准备应用程序以服务于其目标用户。在本章中，我们将学习一些生成生产就绪二进制文件的技术。在我们生成二进制文件之后，我们将学习配置位于通用Web服务器后面的应用程序。最后，我们将学习如何为Rocket应用程序生成Docker镜像。
- en: After learning the information in this chapter, you will be able to optimize
    binaries using Rust compiler flags and Cargo configurations. You will also learn
    techniques to prepare your applications to serve their intended users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习本章中的信息后，您将能够使用Rust编译器标志和Cargo配置来优化二进制文件。您还将学习准备您的应用程序以服务于其目标用户的技术。
- en: 'In this chapter, we are going to cover these main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Optimizing production binaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化生产二进制文件
- en: Setting up the Apache HTTP Server with a Rocket application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rocket应用程序设置Apache HTTP服务器
- en: Generating Docker images for a Rocket application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Rocket应用程序生成Docker镜像
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we are going to serve HTTP requests using the Apache HTTP
    Server ([https://httpd.apache.org/](https://httpd.apache.org/)). If you have a
    Unix-based operating system, you can usually find the Apache HTTP Server in your
    operating system package manager. If you have a Windows operating system, there
    are recommended downloads at the following link: [https://httpd.apache.org/docs/2.4/platform/windows.html](https://httpd.apache.org/docs/2.4/platform/windows.html).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Apache HTTP服务器([https://httpd.apache.org/](https://httpd.apache.org/))来处理HTTP请求。如果您有基于Unix的操作系统，您通常可以在操作系统的软件包管理器中找到Apache
    HTTP服务器。如果您有Windows操作系统，以下链接中有推荐的下载：[https://httpd.apache.org/docs/2.4/platform/windows.html](https://httpd.apache.org/docs/2.4/platform/windows.html)。
- en: 'You also need to generate a TLS (Transport Layer Security) certificate using
    OpenSSL. If you have a Unix-based operating system, you can usually find the OpenSSL
    binary using the distribution''s package manager. If you have a Windows operating
    system, you can find the recommended binary at the following link: [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要使用OpenSSL生成一个TLS（传输层安全性）证书。如果您有基于Unix的操作系统，您通常可以使用发行版的软件包管理器找到OpenSSL二进制文件。如果您有Windows操作系统，您可以在以下链接中找到推荐的二进制文件：[https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)。
- en: 'For generating Docker images, you can use Docker Desktop from the following
    link: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生成Docker镜像，您可以使用以下链接中的Docker Desktop：[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)。
- en: You can find the source code of this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter13](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter13)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到本章的源代码：[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter13](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter13)
- en: Optimizing production binaries
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化生产二进制文件
- en: After we create the application, we want to prepare the application to accept
    a real connection. In software development, there's a production environment,
    also called a release environment or deployment environment. The production environment
    contains the configuration of the system and software to make it available to
    the intended customer. In [*Chapter 2*](B16825_02_ePub.xhtml#_idTextAnchor032),
    *Building Our First Rocket Web Application*, we learned that we can tell the Rust
    compiler to build release binary when compiling the Rust application. We can use
    `cargo build` or `cargo run` with the extra `--release` flag.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建应用程序之后，我们希望准备应用程序以接受真实连接。在软件开发中，有一个生产环境，也称为发布环境或部署环境。生产环境包含系统的配置和软件，使其能够提供给目标客户。在[*第2章*](B16825_02_ePub.xhtml#_idTextAnchor032)，“构建我们的第一个Rocket
    Web应用程序”，我们了解到我们可以告诉Rust编译器在编译Rust应用程序时构建发布二进制文件。我们可以使用带有额外`--release`标志的`cargo
    build`或`cargo run`。
- en: 'To refresh, Cargo will read the configuration in `Cargo.toml` in the `[profile.release]`
    section. There are some compilation optimizations we can do to improve the resulting
    image:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新，Cargo 将读取 `[profile.release]` 部分中的 `Cargo.toml` 配置。我们可以进行一些编译优化来提高生成的镜像：
- en: 'The first one is the number of `codegen-units` of compilation. Rust compilation
    can take significant time, and to solve this, the compiler may try to split it
    into parts and compile them in parallel. But, compiling binaries or libraries
    in parallel might omit some optimization. By default, the number of `codegen-units`
    is `3`. We can sacrifice the compilation speed and make `codegen-units` into `1`
    to optimize the resulting binary further. For example, in `Cargo.toml`, we can
    have the following:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个设置是编译的 `codegen-units` 数量。Rust 编译可能需要很长时间，为了解决这个问题，编译器可能会尝试将其分割成多个部分并行编译。但是，并行编译二进制文件或库可能会遗漏一些优化。默认情况下，`codegen-units`
    的数量是 `3`。我们可以牺牲编译速度，将 `codegen-units` 设置为 `1` 以进一步优化生成的二进制文件。例如，在 `Cargo.toml`
    中，我们可以有如下设置：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`codegen` backend, LLVM, can perform various LTOs to produce output with optimized
    code. To enable LTO, we can set `lto = yes` or `lto = "fat"`. The following is
    an example of `lto` in `Cargo.toml`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`codegen` 后端，LLVM，可以执行各种 LTO（链接时优化）以生成优化后的代码输出。要启用 LTO，我们可以设置 `lto = yes` 或
    `lto = "fat"`。以下是在 `Cargo.toml` 中 `lto` 的一个示例：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Set the optimization level. We can set optimization levels from `0`, `1`, `2`,
    and `3`, with the default value being `0` (no optimization) up to `3` (all optimization)
    as in the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设置优化级别。我们可以设置从 `0`、`1`、`2` 和 `3` 的优化级别，默认值是 `0`（无优化）到 `3`（所有优化），如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Besides optimization level `0` to `3`, we can also also set `"s"` and `"z"`,
    with `"s"` for binary size optimization and `"z"` for binary size optimization
    and turn of loop vectorization.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了优化级别 `0` 到 `3`，我们还可以设置 `"s"` 和 `"z"`，其中 `"s"` 用于二进制大小优化，而 `"z"` 用于二进制大小优化并关闭循环向量化。
- en: 'Disable `panic` unwinding. We can set `panic` to not show the stack trace.
    The result is a more optimized binary. Set the following in `Cargo.toml` to disable
    stack unwinding:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用 `panic` 回溯。我们可以设置 `panic` 不显示堆栈跟踪。结果是更优化的二进制文件。在 `Cargo.toml` 中设置以下内容以禁用堆栈回溯：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The second optimization is compiling the correct architecture. CPU producers
    will always create a new CPU with better optimization or instruction sets that
    can improve the performance of an application. For example, the SSE (Streaming
    SIMD Extensions) instruction set was introduced by Intel with the release of Intel
    Pentium III.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个优化是编译正确的架构。CPU 生产商总是会创建一个新的 CPU，具有更好的优化或指令集，这可以提高应用程序的性能。例如，SSE（Streaming
    SIMD Extensions）指令集是由英特尔在发布英特尔奔腾 III 时引入的。
- en: By default, the Rust compiler will produce binary with a reasonable amount of
    CPU support. But, this means newer instruction sets or optimizations are not used
    when compiling a library or a binary. We can tell the Rust compiler to produce
    a binary that supports newer optimizations or instruction sets of the target machine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Rust 编译器会生成具有合理 CPU 支持的二进制文件。但这意味着在编译库或二进制文件时不会使用新的指令集或优化。我们可以告诉 Rust
    编译器生成支持目标机器新优化或指令集的二进制文件。
- en: 'To see the list of the target architecture supported by the Rust compiler,
    we can use this command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Rust 编译器支持的目标架构列表，我们可以使用以下命令：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, if we know the target machine is AMD Ryzen, which supports *znver3*
    architecture, we can compile the Rust program as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们知道目标机器是支持 *znver3* 架构的 AMD Ryzen，我们可以按照以下方式编译 Rust 程序：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The reason we use the `RUSTFLAGS` environment variable is that `target-cpu`
    is not a recognized option in `Cargo.toml`. Cargo will also use any other `rustc`
    option set in the `RUSTFLAGS` environment variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `RUSTFLAGS` 环境变量的原因是 `target-cpu` 选项在 `Cargo.toml` 中不被认可。Cargo 还会使用在 `RUSTFLAGS`
    环境变量中设置的任何其他 `rustc` 选项。
- en: Now we know how to compile a Rust application for a production environment,
    let's learn about deploying a Rocket application behind a web server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何为生产环境编译 Rust 应用程序，让我们学习如何在 Web 服务器后面部署 Rocket 应用程序。
- en: Setting up the Apache HTTP Server with a Rocket application
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Apache HTTP 服务器与 Rocket 应用程序
- en: We know that Rocket has TLS support in its configuration, so we can set the
    TCP port to `443`, the default HTTPS connection port. In some cases, it might
    be acceptable to run web applications directly, for example, when we want to serve
    content for microservices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Rocket在其配置中支持TLS，因此我们可以将TCP端口设置为`443`，这是默认的HTTPS连接端口。在某些情况下，直接运行Web应用程序可能是可接受的，例如，当我们想要为微服务提供服务内容时。
- en: 'One of the reasons why we don''t want to run the Rocket application directly
    is because of this warning in the Rocket guide:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想直接运行Rocket应用程序的一个原因是因为Rocket指南中的这个警告：
- en: Rocket's built-in TLS implements only TLS 1.2 and 1.3\. It may not be suitable
    for production use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket内置的TLS仅实现了TLS 1.2和1.3。它可能不适合生产使用。
- en: The TLS library used by the Rocket framework might not be suitable for production
    use for various reasons, such as security reasons or it is not yet audited.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket框架使用的TLS库可能由于各种原因（如安全原因或尚未经过审计）不适合生产使用。
- en: There are other reasons why we do not want to serve content directly from Rocket
    aside from the TLS library problem. One example is when we want to serve multiple
    applications from a single computer. We might want to serve PHP applications from
    the same machine too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了TLS库问题之外，还有其他原因我们不希望直接从Rocket服务内容。一个例子是我们想要从同一台计算机上服务多个应用程序。我们也可能想要在同一台机器上服务PHP应用程序。
- en: 'One of the techniques people use when serving a Rust application is putting
    it behind a general-purpose web server that can do a reverse proxy:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们服务Rust应用程序时，会使用的一种技术是将它放在一个通用的Web服务器后面，该服务器可以执行反向代理：
- en: '![Figure 13.1 ‒ General purpose web server performing a reverse proxy on a
    Rocket application'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 - 执行Rocket应用程序反向代理的通用Web服务器]'
- en: '](img/Figure_13.1_B16825.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.1_B16825.jpg](img/Figure_13.1_B16825.jpg)'
- en: Figure 13.1 ‒ General purpose web server performing a reverse proxy on a Rocket
    application
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 - 执行Rocket应用程序反向代理的通用Web服务器
- en: One of the most used reverse proxy applications is the Apache HTTP Server. The
    Apache HTTP Server also has other features besides the reverse proxy, including
    serving static files and compressing files to serve requests faster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的反向代理应用程序之一是Apache HTTP服务器。Apache HTTP服务器除了反向代理之外，还有其他功能，包括服务静态文件和压缩文件以更快地处理请求。
- en: 'Let''s try serving our application using the Apache HTTP Server and configuring
    the server to act as a reverse proxy by following these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用Apache HTTP服务器来服务我们的应用程序，并按照以下步骤配置服务器以作为反向代理：
- en: Download the Apache HTTP Server for your operating system or from [https://httpd.apache.org/](https://httpd.apache.org/).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载适用于您操作系统的Apache HTTP服务器或从[https://httpd.apache.org/](https://httpd.apache.org/)下载。
- en: 'Try starting the application using the following command line:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用以下命令行启动应用程序：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Apache HTTP Server''s default port is `8080`. Check that Apache is running
    by using the cURL command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apache HTTP服务器的默认端口是`8080`。使用cURL命令检查Apache是否正在运行：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Apache HTTP Server's functionalities can be extended by modules, and several
    modules are installed alongside it. We want to enable several modules to enable
    HTTP requests to our application using a reverse proxy. Find `httpd.conf`, the
    configuration file for your operating system. In some Linux distributions, the
    configuration might be in `/etc/httpd/httpd.conf`. In other distributions or operating
    systems, the file location might be in `/usr/local/etc/httpd/httpd.conf`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apache HTTP服务器的功能可以通过模块进行扩展，并且安装了几个模块。我们想要启用几个模块，以便通过反向代理使用HTTP请求来访问我们的应用程序。找到`httpd.conf`，这是您操作系统的配置文件。在某些Linux发行版中，配置可能位于`/etc/httpd/httpd.conf`。在其他发行版或操作系统上，文件位置可能位于`/usr/local/etc/httpd/httpd.conf`。
- en: 'Edit the `httpd.conf` file and remove the comment to enable the required modules:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`httpd.conf`文件并取消注释以启用所需的模块：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the same `httpd.conf` file, find these lines and uncomment these lines as
    well:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`httpd.conf`文件中，找到这些行并取消注释这些行：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We need a server name. In a real server, we can acquire a domain by buying
    the rights to it from a domain registrar and pointing the `ourapplication.example.net`.
    Edit `/etc/hosts` and some test domains as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个服务器名称。在真实服务器中，我们可以通过从域名注册商购买域名权利并将`ourapplication.example.net`指向它来获取一个域名。按照以下方式编辑`/etc/hosts`和一些测试域名：
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Install `openssl` for your operating system. After that, generate a certificate
    for `ourapplication.example.net` using the `openssl` command line, as in the following:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的操作系统安装`openssl`。之后，使用`openssl`命令行生成`ourapplication.example.net`的证书，如下所示：
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The command line will generate two files, `ourapplication.example.com.crt` and
    `ourapplication.example.com.key`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行将生成两个文件，`ourapplication.example.com.crt` 和 `ourapplication.example.com.key`。
- en: 'Generate a PEM file, a file format that contains certificate as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个 PEM 文件，该文件格式包含以下证书：
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Edit `httpd-vhosts.conf`. The file might be in `/usr/local/etc/httpd/extra/`,
    depending on your operating system configuration. Add a new virtual host. We want
    the virtual host to point to our Rocket application at `http://127.0.0.1:8000`.
    Add the following lines:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `httpd-vhosts.conf` 文件。该文件可能位于 `/usr/local/etc/httpd/extra/`，具体取决于您的操作系统配置。添加一个新的虚拟主机。我们希望虚拟主机指向
    `http://127.0.0.1:8000` 的我们的 Rocket 应用程序。添加以下行：
- en: '[PRE13]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Check whether the configuration is correct by running the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来检查配置是否正确：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Restart and open [https://ourapplication.example.com](https://ourapplication.example.com)
    in your web browser. The web browser might complain because the root certificate
    is unknown. We can add our generated certificate so it''s accepted in our browser.
    For example, in Firefox, we can go to **Preferences** | **Privacy & Security**
    | **View Certificates**. After that, choose **Servers Tab** and click **Add Exception**.
    Then, ensure that **Permanently store this exception** is checked. Finally, click
    on **Confirm Security Exception** to store the security exception. If everything
    goes well, we can use the example domain in the browser, as in the following figure:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中重新启动并打开 [https://ourapplication.example.com](https://ourapplication.example.com)。网络浏览器可能会抱怨根证书未知。我们可以添加我们生成的证书，以便它在我们的浏览器中被接受。例如，在
    Firefox 中，我们可以转到 **首选项** | **隐私和安全** | **查看证书**。之后，选择 **服务器标签** 并点击 **添加异常**。然后，确保
    **永久存储此异常** 被选中。最后，点击 **确认安全异常** 以存储安全异常。如果一切顺利，我们可以在浏览器中使用示例域名，如图所示：
- en: '![Figure 13.2 ‒ Using a domain and TLS certificate'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.2 – 使用域名和 TLS 证书'
- en: '](img/Figure_13.2_B16825.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.2_B16825.jpg](img/Figure_13.2_B16825.jpg)'
- en: Figure 13.2 ‒ Using a domain and TLS certificate
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.2 – 使用域名和 TLS 证书'
- en: Now that we have deployed the Rocket application behind a reverse proxy, we
    can use the same principle with a real server. Set up the Apache HTTP Server or
    NGINX as a reverse proxy and run the Rocket application behind the reverse proxy.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 Rocket 应用程序部署在反向代理后面，我们可以使用同样的原理与真实服务器一起使用。设置 Apache HTTP 服务器或 NGINX
    作为反向代理，并在反向代理后面运行 Rocket 应用程序。
- en: To run the Rocket application automatically when the operating system starts,
    we can set up some kind of service for the operating system. If we are running
    a Linux distribution with systemd as a service manager, for example, we can create
    a `systemd` service file and run the application automatically.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在操作系统启动时自动运行 Rocket 应用程序，我们可以为操作系统设置某种类型的服务。如果我们运行的是以 systemd 作为服务管理器的 Linux
    发行版，例如，我们可以创建一个 `systemd` 服务文件并自动运行应用程序。
- en: In the next section, we are going to learn a different way to deploy an application.
    We are going to use Docker to package and create a Docker container for our Rocket
    application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习一种不同的部署应用程序的方法。我们将使用 Docker 打包并创建我们的 Rocket 应用程序的 Docker 容器。
- en: Generating Docker images for a Rocket application
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Rocket 应用程序生成 Docker 镜像
- en: Containerization has been a popular choice to ship production applications for
    a while. One of the most popular applications for containerization is Docker.
    In this section, we are going to learn how to set up Docker to run our Rocket
    application. To use the `docker` command line, please install Docker Desktop from
    [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化已经是一段时间内用于打包生产应用程序的热门选择。容器化最流行的应用程序之一是 Docker。在本节中，我们将学习如何设置 Docker 以运行我们的
    Rocket 应用程序。要使用 `docker` 命令行，请从 [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)
    安装 Docker Desktop。
- en: 'Follow these steps to create and run a Docker image of the Rocket application:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建和运行 Rocket 应用程序的 Docker 镜像：
- en: In the root folder of the application, create a Dockerfile.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录中创建一个 Dockerfile。
- en: There are some base images we can use to build and run the application. We are
    going to use Rust's official Docker image from [https://hub.docker.com/_/rust](https://hub.docker.com/_/rust).
    For the Linux distribution, we are going to use *Alpine base* because it's one
    of the smallest base images for Docker.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用一些基础镜像来构建和运行应用程序。我们将使用来自 [https://hub.docker.com/_/rust](https://hub.docker.com/_/rust)
    的 Rust 官方 Docker 镜像。对于 Linux 发行版，我们将使用 *Alpine base*，因为它是最小的 Docker 基础镜像之一。
- en: 'In the Dockerfile, add the first line:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dockerfile 中添加第一行：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set the working directory. Append this line to the Dockerfile:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作目录。将此行追加到 Dockerfile 中：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use Cargo to install the dependencies, but there is another way to quickly
    compile the application. We can vendorize the dependencies and use the vendor
    dependencies to build the application. Run this command on the root folder of
    the application source code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 Cargo 安装依赖项，但还有一种快速编译应用程序的方法。我们可以供应商化依赖项并使用供应商依赖项来构建应用程序。在应用程序源代码的根目录下运行此命令：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We want to override the source of the dependencies from the internet to the
    vendor folder. Create a `.cargo` folder in the root application folder, and create
    `config.toml` inside the `.cargo` folder.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望覆盖从互联网到供应商文件夹的依赖项来源。在根应用程序文件夹中创建一个 `.cargo` 文件夹，并在 `.cargo` 文件夹内创建 `config.toml`。
- en: 'Append these lines to the `.cargo/config.toml` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行追加到 `.cargo/config.toml` 文件中：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We want to add the required files to build the application as a Docker image.
    We don''t need `Rocket.toml`, templates, or static files to build the application.
    Append these lines to the Dockerfile:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望添加构建应用程序为 Docker 镜像所需的文件。我们不需要 `Rocket.toml`、模板或静态文件来构建应用程序。将这些行追加到 Dockerfile
    中：
- en: '[PRE19]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the instructions to build the image. We want to use another stage and install
    the dependencies to build the image. Add the following lines:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加构建镜像的指令。我们希望使用另一个阶段并安装依赖项来构建镜像。添加以下行：
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Try building the application by running the following command:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令尝试构建应用程序：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After testing, add a new part to run the application in the Dockerfile. We
    want to open port `8000`. We also want to add a default time zone and configure
    the user to run the application. Append the following lines:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试之后，向 Dockerfile 中添加一个新的部分以运行应用程序。我们希望打开端口 `8000`。我们还希望添加默认时区并配置用户以运行应用程序。追加以下行：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We want the image to have the latest libraries. Append the following lines
    to the Dockerfile:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望镜像包含最新的库。将以下行追加到 Dockerfile 中：
- en: '[PRE23]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Set the working directory. Append the following line to the Dockerfile:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作目录。将此行追加到 Dockerfile 中：
- en: '[PRE24]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Set `Rocket.toml` to run from `0.0.0.0`. We want to tell the application to
    use the host''s running database. In Docker, we can reference the host machine
    using a special domain, host.docker.internal. Edit `Rocket.toml` as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Rocket.toml` 设置为从 `0.0.0.0` 运行。我们希望告诉应用程序使用主机运行的数据库。在 Docker 中，我们可以使用特殊域名
    host.docker.internal 来引用主机机器。按照以下方式编辑 `Rocket.toml`：
- en: '[PRE25]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Copy the resulting binary, `Rocket.toml`, assets, and templates to the final
    image. Append the following lines to the Dockerfile:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的二进制文件、`Rocket.toml`、资产和模板复制到最终镜像中。将这些行追加到 Dockerfile 中：
- en: '[PRE26]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the folder to store the log file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加存储日志文件的文件夹：
- en: '[PRE27]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add changing permission to `$USER` as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加更改权限到 `$USER`，如下所示：
- en: '[PRE28]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, run the entry point to the application to the Dockerfile:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将应用程序的入口点运行到 Dockerfile 中：
- en: '[PRE29]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Build the image and create a tag for it using this command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令构建镜像并为其创建标签：
- en: '[PRE30]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After building the Docker image, it''s time to run it. Use the following command
    line:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建了 Docker 镜像之后，是时候运行它了。使用以下命令行：
- en: '[PRE31]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After everything is done, we should see the Docker container is running and
    showing the `our_application` output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一切完成后，我们应该看到 Docker 容器正在运行并显示 `our_application` 输出：
- en: '![Figure 13.3 ‒ Docker Desktop showing the running container and our_application'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.3 - Docker Desktop 显示正在运行的容器和我们的应用程序'
- en: '](img/Figure_13.3_B16825.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.3_B16825.jpg)'
- en: Figure 13.3 ‒ Docker Desktop showing the running container and our_application
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 - Docker Desktop 显示正在运行的容器和我们的应用程序
- en: Deploying a Rocket application using Docker is just like deploying other applications.
    We need to copy the source, build, and run the resulting image. There are some
    actions that we can perform to ensure proper deployment, such as vendoring the
    libraries and opening the correct ports to ensure requests can be made to the
    running container and applications running inside the container.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 部署 Rocket 应用程序就像部署其他应用程序一样。我们需要复制源代码、构建并运行生成的镜像。有一些操作可以执行以确保正确部署，例如供应商库和打开正确的端口以确保可以向正在运行的容器和容器内运行的应用程序发送请求。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about production-ready compilation options.
    We can use them to ensure the resulting binary is as optimized as possible. We
    also learned about setting up a general-purpose HTTP server to work in conjunction
    with a Rocket application. And finally, we learned to create and run Docker images
    for the Rocket application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了生产就绪的编译选项。我们可以使用它们来确保生成的二进制文件尽可能优化。我们还学习了如何设置一个通用目的的 HTTP 服务器与 Rocket
    应用程序协同工作。最后，我们学习了如何为 Rocket 应用程序创建和运行 Docker 镜像。
- en: After learning these techniques, we expanded them to set up the Rocket application
    to serve its intended users.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习这些技术之后，我们将它们扩展到设置 Rocket 应用程序以服务于其目标用户。
- en: In the next chapter, we are going to learn about using Rust to create a frontend
    WebAssembly application in conjunction with a Rocket application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Rust 与 Rocket 应用程序结合创建前端 WebAssembly 应用程序。
