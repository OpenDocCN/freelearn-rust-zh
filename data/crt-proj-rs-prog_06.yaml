- en: Creating a WebAssembly Game Using Quicksilver
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quicksilver 创建 WebAssembly 游戏
- en: In this chapter, you will see how Rust can be used to build a simple 2D game
    that can be compiled to run as a desktop app or as a web app. To run it as a web
    app, we will use the tools seen in the previous chapter to generate a **WebAssembly**
    (**Wasm**) application. As seen in that chapter, Wasm is a powerful new technology
    to run applications inside a browser. The appropriate tools translate Rust source
    code into a pseudo-machine language, named Wasm, that is loaded and run at top
    speed by browsers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解如何使用 Rust 构建一个简单的 2D 游戏，该游戏可以编译为桌面应用程序或网络应用程序。要将其作为网络应用程序运行，我们将使用上一章中看到的工具生成一个
    **WebAssembly** (**Wasm**) 应用程序。正如该章节所示，Wasm 是一种运行在浏览器内部的新技术，它可以将 Rust 源代码转换为伪机器语言，名为
    Wasm，浏览器以最高速度加载和运行。
- en: 'The Quicksilver open source framework will be described and used in this chapter.
    It has the powerful feature of being able to generate the following applications
    from a single source code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将描述并使用 Quicksilver 开源框架。它具有从单个源代码生成以下应用程序的强大功能：
- en: A standalone **graphical user interface** (**GUI**) application, to be run in
    a desktop system such as Windows, macOS, or Linux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独立的 **图形用户界面** (**GUI**) 应用程序，可在 Windows、macOS 或 Linux 等桌面系统中运行
- en: A Wasm app that runs in a JavaScript-enabled web browser
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启用 JavaScript 的网络浏览器中运行的 Wasm 应用程序
- en: 'Quicksilver is oriented toward game programming, and so, as an example, we
    will develop an interactive graphical game using it: a slalom ski race, in which
    the player must drive a ski along a slope, entering the gates found along the
    ski run.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Quicksilver 面向游戏编程，因此，作为一个例子，我们将使用它开发一个交互式图形游戏：一项滑雪回转比赛，玩家必须沿着滑雪道驾驶滑雪板，进入沿途的障碍门。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the animation loop architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解动画循环架构
- en: Building an animated application (`ski`) using the Quicksilver framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Quicksilver 框架构建一个动画应用程序（`ski`）
- en: Building a simple game using the Quicksilver framework (`silent_slalom`)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Quicksilver 框架（`silent_slalom`）构建一个简单的游戏
- en: Adding text and sound to a game (`assets_slalom`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向游戏中添加文本和声音（`assets_slalom`）
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You need to read the section on Wasm of the previous chapter, but no other knowledge
    is required. To run the projects in this chapter, it is enough to install a Wasm
    code generator.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要阅读上一章中关于 Wasm 的部分，但不需要其他知识。要运行本章中的项目，只需安装一个 Wasm 代码生成器即可。
- en: The complete source code for this chapter is in the `Chapter06` folder of the
    repository, found at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码位于存储库的 `Chapter06` 文件夹中，可在[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers) 找到。
- en: For macOS users, you may struggle to install `coreaudio-sys`. Upgrading the
    patch version of `coreaudio-sys` to 0.2.3 resolves this issue.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS 用户，您可能难以安装 `coreaudio-sys`。将 `coreaudio-sys` 的补丁版本升级到 0.2.3 可以解决这个问题。
- en: Project overview
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will see how to develop games to be run in modern web browsers,
    or in GUI windows.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何开发在现代网络浏览器或 GUI 窗口中运行的游戏。
- en: For that purpose, we will first describe the typical architecture of any interactive
    game that is based on the animation loop concept.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们首先将描述基于动画循环概念的任何交互式游戏的典型架构。
- en: Then, the Quicksilver crate will be introduced. This is a framework that allows
    us to create a graphical application based on an animation loop. It allows us
    to generate a Wasm executable to be run in a web browser, or a native executable
    to be run in a desktop environment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将介绍 Quicksilver crate。这是一个框架，允许我们基于动画循环创建图形应用程序。它允许我们生成可在网络浏览器中运行的 Wasm
    可执行文件，或在桌面环境中运行的本地可执行文件。
- en: 'The first project (`ski`) will be very simple: just a page containing one ski
    that can be rotated by pressing arrow keys. This project will show the general
    architecture of a game, how to draw on a page, and how to handle input.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目（`ski`）将非常简单：仅包含一个可以按箭头键旋转的滑雪板页面。这个项目将展示游戏的一般架构，如何在页面上绘制，以及如何处理输入。
- en: The second project (`silent_slalom`) will add features to the first project,
    creating a complete—albeit very simple—game. However, it will not use loadable
    resources such as images, fonts, or sounds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个项目（`silent_slalom`）将为第一个项目添加功能，创建一个完整——尽管非常简单——的游戏。然而，它将不会使用可加载的资源，例如图像、字体或声音。
- en: The third project (`assets_slalom`) will add features to the second project,
    loading a font and some recorded sounds, and showing how to display some text
    on the page, and how to play the loaded sound files.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个项目（`assets_slalom`）将为第二个项目添加功能，加载字体和一些录音声音，并展示如何在页面上显示一些文本，以及如何播放加载的声音文件。
- en: Understanding the animation loop architecture
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动画循环架构
- en: As described in the previous chapter, the typical architecture of interactive
    software is** event-driven architecture**. In such an architecture, the software
    just waits for input commands, and it responds to such commands when they arrive.
    Until any command arrives, the software does nothing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，交互式软件的典型架构是**事件驱动架构**。在这种架构中，软件只是等待输入命令，当命令到达时，它会对这些命令做出响应。在收到任何命令之前，软件什么都不做。
- en: 'This architecture is efficient and responsive for many kinds of applications,
    but it is not optimal for some other kinds of applications, such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构对许多类型的应用程序来说既高效又响应迅速，但它对某些其他类型的应用程序来说并不理想，例如以下情况：
- en: Games with animations
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有动画的游戏
- en: Continuous-simulation software
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续模拟软件
- en: Multimedia software
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多媒体软件
- en: Some kind of educational software
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些教育软件
- en: Machine monitoring software (known as **Human-Machine Interface** (**HMI**)
    software)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器监控软件（通常称为**人机界面**（**HMI**）软件）
- en: Systems monitoring software (known as **Supervisory Control and Data Acquisition**
    (**SCADA**) software)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统监控软件（通常称为**监督控制与数据采集**（**SCADA**）软件）
- en: 'In such systems, the software has always something to do, as in the following
    examples:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的系统中，软件总是有事情要做，如下面的例子所示：
- en: In games with animations, such as sports games or combat games or racing games,
    both those against other human players and those against machine-simulated players, even
    if the user does nothing, the opponents move, and time flows; so, the screen must
    be constantly updated to show what the opponents have done, and what the current
    time is.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在带有动画的游戏中，例如体育游戏或战斗游戏或赛车游戏，无论是与其他玩家对战还是与机器模拟玩家对战，即使用户没有操作，对手也会移动，时间会流逝；因此，屏幕必须不断更新以显示对手所做的一切，以及当前的时间。
- en: In continuous-simulation software, such as the graphical simulation of a car
    crash, the objects continue to move, even if you don't press any key; so, the
    screen must show the new positions of the objects at any time.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在持续模拟软件中，例如汽车碰撞的图形模拟，物体即使在您没有按任何键的情况下也会继续移动；因此，屏幕必须随时显示物体的新位置。
- en: In multimedia software, such as software that reproduces an audio or video clip,
    the data continues to flow, until you pause or stop the reproduction.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多媒体软件中，例如播放音频或视频剪辑的软件，数据会持续流动，直到您暂停或停止播放。
- en: There are many kinds of educational software, but some of them are just games
    with animations, continuous-simulation software, or multimedia software.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教育软件有很多种，但其中一些只是带有动画的游戏、持续模拟软件或多媒体软件。
- en: Most mechanical machines, to let a user monitor them, display on a screen a
    constantly updated representation of their internal status, even when the user
    does not request an update.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数机械机器为了让用户监控它们，即使在用户没有请求更新时，也会在屏幕上显示其内部状态的持续更新表示。
- en: Many complex systems, such as industrial plants, office buildings, and—recently—also
    residential buildings, display on a screen a constantly updated representation
    of the status of the devices operating in the system.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多复杂的系统，如工业设施、办公楼，以及最近也开始应用于住宅建筑，会在屏幕上显示系统内运行的设备状态的持续更新表示。
- en: Actually, such kinds of software can even be developed using an event-driven
    architecture. It is enough to use a specific widget known as a *timer*. A timer
    is a software component that triggers an event at a fixed time interval.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这类软件甚至可以使用事件驱动架构来开发。只需要使用一个称为**计时器**的特定小部件。计时器是一个软件组件，会在固定的时间间隔触发一个事件。
- en: For example, in an electronic thermometer, there is a timer that executes a
    routine every minute. Such a routine reads the temperature from a sensor and displays
    the read value on the small screen.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在电子温度计中，有一个每分钟执行一次例程的计时器。这个例程从传感器读取温度，并在小屏幕上显示读取值。
- en: For some kinds of applications, the use of an event-driven environment, possibly
    including one or more timers, is appropriate. For example, event-driven programming
    is optimal for business applications such as an accounting application. In such
    applications, the user screen is split into several input widgets, such as labels,
    buttons, and textboxes. In such software, no application code is run until the
    user clicks the mouse or presses a key. Such input events trigger the action.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的应用，使用事件驱动环境，可能包括一个或多个计时器，是合适的。例如，事件驱动编程对于会计应用等商业应用来说是最优的。在这些应用中，用户屏幕被分成几个输入小部件，如标签、按钮和文本框。在这样的软件中，直到用户点击鼠标或按下一个键，才运行应用程序代码。这些输入事件触发动作。
- en: However, event-driven programming is not quite appropriate for the kind of software
    that displays a scene that fills the window, with no widgets, and that always
    has some code running even if the user does not act on input devices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事件驱动编程并不完全适合显示填充窗口的场景，这种软件没有小部件，并且即使在用户没有对输入设备进行操作的情况下，也始终有一些代码在运行。
- en: 'For such software, the so-called **animation loop architecture** is more appropriate.
    Its simplest structure is the following one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类软件，所谓的 **动画循环架构** 更为合适。其最简单的结构如下：
- en: First, a draw routine is defined as the one responsible for checking the status
    of the input devices and for redrawing the screen according to the status.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，绘制例程被定义为负责检查输入设备的状态并根据状态重新绘制屏幕的程序。
- en: Then, a screen area is defined as a scene, and an update rate is defined for
    it.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一个屏幕区域被定义为场景，并为它定义一个更新率。
- en: When the program starts, it first opens a window (or a subwindow) for the scene,
    and then invokes the draw routine at regular intervals, using an internal timer.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序启动时，它首先为场景打开一个窗口（或子窗口），然后使用内部计时器以固定间隔调用绘制例程。
- en: Such periodic invocations of the draw routine are usually named *frames*, and
    the invocation rate is measured in **Frames Per Second** (**FPS**).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种周期性的绘制例程通常被称为 *帧*，其调用频率以每秒 **帧数**（**FPS**）来衡量。
- en: 'The animation loop is sometimes named *game-loop*, as it is very often used
    for games. This is quite a misnomer, however, for the following two reasons:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 动画循环有时被称为 *游戏循环*，因为它经常用于游戏。然而，这个名称并不准确，原因如下：
- en: There are several other kinds of apps that should use an animation loop, such
    as continuous-simulation software, industrial machine monitoring software, or
    multimedia software. So, an animation loop is not only for games.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他几种应用应该使用动画循环，例如连续模拟软件、工业机器监控软件或多媒体软件。因此，动画循环不仅限于游戏。
- en: There are some games that do not need an animation loop. For example, a chess
    game, a card game, or an adventure game, provided they are not based on animations,
    can be implemented perfectly well using an event-driven architecture. So, games
    are not necessarily based on animation loop.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些游戏不需要动画循环。例如，棋盘游戏、纸牌游戏或冒险游戏，只要它们不是基于动画的，就可以使用事件驱动架构完美实现。因此，游戏不一定基于动画循环。
- en: Notice that, while in an event-driven architecture user input triggers the action,
    in an animation loop architecture some action happens anyway, but if there is
    some user input such actions change accordingly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然在事件驱动架构中用户输入会触发动作，但在动画循环架构中，某些动作仍然会发生，但如果存在用户输入，这些动作会相应地改变。
- en: Consider a user who presses a keyboard key or a mouse button. In event-driven
    programming, that input operation sends exactly one command. Instead, in animation
    loop programming, the program, at any frame, checks whether any key is pressed.
    If the key is pressed for a very short time, it is possible that such an operation
    goes unnoticed as, when the keyboard is checked in one cycle, that key has not
    been pressed yet, and when the keyboard is checked in the next cycle, that key
    has been already released.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个按下键盘键或鼠标按钮的用户。在事件驱动编程中，这种输入操作发送一条精确的命令。相反，在动画循环编程中，程序在任何一帧都会检查是否有任何键被按下。如果按键时间非常短，那么这种操作可能会被忽略，因为在检查键盘的一个周期中，那个键还没有被按下，而在下一个周期中，那个键已经被释放了。
- en: This is quite unusual, though. Typical frame rates are from 20 to 60 FPS, and
    so the corresponding intervals are from 50 to 16.7 milliseconds. It is very difficult
    to press a key for a shorter time than that. Instead, it is quite typical that
    a key-press is much longer than a frame, and so the key is seen pressed in several
    successive frames.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当不寻常。典型的帧率是从20到60 FPS，因此相应的间隔是从50到16.7毫秒。很难按下比这更短的时间。相反，按键时间通常比帧长得多，因此按键在几个连续帧中被看到按下。
- en: If you use such a key-press to insert text, you would want to allow the user
    to press a key to insert just one letter. If you use a mouse click to press a
    button on the screen, you want that screen button to be pressed just once. To
    avoid such multiple hits, you must disable input for a short time the first time
    you get it. This is quite a nuisance, and so, for typical widget-based GUI apps,
    event-driven programming is more appropriate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这样的按键来插入文本，你希望允许用户按下一个键来插入一个字母。如果你使用鼠标点击来在屏幕上按一个按钮，你希望那个屏幕按钮只按一次。为了避免这种多次点击，你必须在你第一次得到输入时暂时禁用输入。这相当麻烦，因此，对于典型的基于小部件的GUI应用程序，事件驱动编程更合适。
- en: Instead, animation loop programming is appropriate whenever a key-press must
    have an effect proportional to the duration of the press. For example, if the
    arrow keys are used to move a character on the screen, and if you keep the right
    arrow pressed for 1 second, that character moves by a short distance; while if
    you keep pressed that key for 2 seconds, that character moves double that distance. In
    general, a short press should change little, and a long press should change much.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当必须使按键的效果与按键持续时间成比例时，动画循环编程是合适的。例如，如果使用箭头键在屏幕上移动一个角色，并且如果你按住右箭头键1秒钟，那个角色会移动一段短距离；而如果你按住那个键2秒钟，那个角色会移动两倍的距离。一般来说，短按应该改变很少，而长按应该改变很多。
- en: Regarding the output, when using event-driven programming, the effect of the
    operation is usually shown by changing some property of a widget (such as changing
    the text contents in a textbox, or loading a bitmap in a picture box). After that
    change, the widget is capable of refreshing itself whenever it needs, using its
    internal state. The event that triggers refreshing is the invalidation of the
    screen portion containing the widget. For example, if another window overlaps
    our window, and then it moves away, the discovered portion of our window is invalidated,
    and so it must be refreshed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关于输出，当使用事件驱动编程时，操作的效果通常是通过改变小部件的一些属性（例如，在文本框中更改文本内容，或在图片框中加载位图）来显示的。在更改之后，小部件能够在其需要时使用其内部状态自行刷新。触发刷新的事件是小部件包含的屏幕部分的无效化。例如，如果另一个窗口覆盖了我们的窗口，然后它移动开去，我们窗口被发现的区域就无效了，因此它必须刷新。
- en: This kind of graphic is named **retained-mode**, as there is an inner data structure
    that retains the information needed to refresh the screen when there is a need.
    Instead, when using animation loop programming, all the images must be regenerated
    at every frame, and so there is no need to wait for a specific event. This kind
    of graphic is named **immediate-mode**, as the drawing is performed immediately
    by application code when it must be seen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图形被称为**保留模式**，因为有一个内部数据结构保留在需要刷新屏幕时所需的信息。相反，当使用动画循环编程时，必须在每一帧重新生成所有图像，因此不需要等待特定事件。这种图形被称为**即时模式**，因为绘图是在需要看到时立即由应用程序代码执行的。
- en: In the previous chapter, we saw that for event-driven applications, the **Model-View-Controller**
    (**MVC**) architectural pattern allows you to give a better structure to your
    code. Also, for animation loop applications, there is a kind of MVC architectural
    pattern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了对于事件驱动应用程序，**模型-视图-控制器**（**MVC**）架构模式允许你给你的代码提供更好的结构。同样，对于动画循环应用程序，也存在一种MVC架构模式。
- en: The **Model** is the data structure that contains all the variables that must
    persist between frames.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**是包含所有必须在帧之间持续存在的变量的数据结构。'
- en: The **Controller** is a function that has input but no output. It checks the
    status of input devices (which keyboard keys are pressed; which mouse keys are
    pressed; where the mouse is; which are the values of possible other input channels),
    reads the fields of the model, and updates them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**是一个有输入但没有输出的函数。它检查输入设备的状态（哪些键盘键被按下；哪些鼠标键被按下；鼠标的位置；其他可能的输入通道的值），读取模型的字段，并更新它们。'
- en: The **View** is a function that has output but no input. It reads the fields
    of the model and draws on the screen according to the read values.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**是一个有输出但没有输入的功能。它读取模型的字段并根据读取的值在屏幕上绘制。'
- en: Here is how the Quicksilver framework implements this pattern.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Quicksilver框架实现此模式的方式。
- en: 'The model is any data type, typically a struct, that must implement the `State`
    trait. Such a trait contains the following three functions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是任何数据类型，通常是结构体，必须实现`State`特质。这样的特质包含以下三个函数：
- en: '`fn new() -> Result<Screen>`: This is the only way to create the model. It
    will return a valid model (if it can) or an error.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn new() -> Result<Screen>`: 这是创建模型的唯一方法。它将返回一个有效的模型（如果可能的话）或一个错误。'
- en: '`fn update(&mut self, window: &mut Window) -> Result<()>`: This is the controller.
    It is invoked periodically by the framework. The `window` argument allows you
    to get some context information. In this framework, it is mutable, but in the
    proper implementation of the MVC pattern, it shouldn''t be changed. Instead, `self`—that
    is, the model—is rightly mutable.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn update(&mut self, window: &mut Window) -> Result<()>`: 这是个控制器。它由框架定期调用。`window`参数允许你获取一些上下文信息。在这个框架中，它是可变的，但在MVC模式的正确实现中，它不应该被改变。相反，`self`——即模型——应该是可变的。'
- en: '`fn draw(&mut self, window: &mut Window) -> Result<()>`: This is the view.
    It is invoked periodically by the framework. The `self` argument allows information
    to be obtained from the model. In this framework, it is mutable, but in the proper
    implementation of the MVC pattern, it shouldn''t be changed. Instead, the `window` argument—that
    is, the output device—is rightly mutable.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn draw(&mut self, window: &mut Window) -> Result<()>`: 这是个视图。它由框架定期调用。`self`参数允许从模型中获取信息。在这个框架中，它是可变的，但在MVC模式的正确实现中，它不应该被改变。相反，`window`参数——即输出设备——应该是可变的。'
- en: Now, let's examine the first project in the repository using the Quicksilver
    framework.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Quicksilver框架检查存储库中的第一个项目。
- en: Implementing the ski project
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施滑雪项目
- en: 'The first project we are going to see is quite simple. It just shows a geometric
    shape on the screen and it allows the user to rotate it using the arrow keys:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看到的第一个项目相当简单。它只是在屏幕上显示一个几何形状，并允许用户使用箭头键旋转它：
- en: 'To run it as a desktop app, go into the `ski` folder, and type the following
    command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将其作为桌面应用程序运行，请进入`ski`文件夹，并输入以下命令：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `--release` argument is recommended to optimize the generated code. For
    this simple example, it is pointless, but in more complex examples, the code generated
    without specifying it is so inefficient that the resulting app is noticeably slowed
    down.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用`--release`参数来优化生成的代码。对于这个简单的例子，这是没有意义的，但在更复杂的例子中，没有指定它生成的代码效率如此低，以至于生成的应用程序运行速度明显减慢。
- en: 'After a few minutes of download and compilation, the following desktop window
    will appear:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过几分钟的下载和编译后，以下桌面窗口将出现：
- en: '![](img/e55047b9-f621-40c7-bd6f-1a2dca7d0a3a.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e55047b9-f621-40c7-bd6f-1a2dca7d0a3a.png)'
- en: It is just an 800 x 600-pixels white rectangle, with a small purple rectangle
    and a small indigo triangle on top of it. They represent a monoski with its pointed
    end, in a snowy ski slope.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是一个800 x 600像素的白色矩形，上面有一个小紫色矩形和一个小靛蓝色三角形。它们代表一个尖端的单板滑雪板，位于雪坡上。
- en: If you press the left or right arrow keys (*←*/*→*) on your keyboard, you will
    see the ski rotate around its tip.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你按下键盘上的左箭头键（*←*）或右箭头键（*→*），你会看到滑雪板在其尖端旋转。
- en: Now, close this window using the appropriate command in your windowing environment.
    Typically, you click on a cross icon in the caption bar or press the *Alt* + *F4*
    key combination.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请使用你的窗口环境中的适当命令关闭此窗口。通常，你会在标题栏中点击一个叉号图标，或者按*Alt* + *F4*键组合。
- en: 'Now, let''s see another way to launch this application. Type the following
    command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种启动此应用程序的方法。输入以下命令：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We saw in the previous chapter that this command helps us to create a Wasm app
    and to launch a command-line program that serves it through the HTTP protocol.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了这个命令如何帮助我们创建Wasm应用程序，并通过HTTP协议启动一个命令行程序来提供服务。
- en: 'At the end of the compilation, a server program starts and suggests the address
    where you can access the app. On your preferred browser, you can type this address:
    `localhost:8000`. Only modern 64-bit browsers support WebGL2\. If this is not
    true in your case, then nothing happens; instead, if your browser supports this
    standard, you will see in the browser just the same graphics that before were
    shown in the desktop window.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编译结束时，一个服务器程序启动并建议你可以访问应用的地址。在你的浏览器中，你可以输入此地址：`localhost:8000`。只有现代 64 位浏览器支持
    WebGL2。如果在你这里不是这样，那么什么都不会发生；相反，如果你的浏览器支持这个标准，你将在浏览器中看到之前在桌面窗口中显示的相同图形。
- en: This is possible as the Quicksilver framework, used by our app, has multi-target
    capability. When compiled for the Wasm target, it generates a web browser application;
    and when compiled for a **central processing unit** (**CPU**) target, it generates
    a desktop application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为我们的应用程序使用的 Quicksilver 框架具有多目标能力。当编译为 Wasm 目标时，它生成一个网页浏览器应用程序；当编译为 **中央处理器**（**CPU**）目标时，它生成一个桌面应用程序。
- en: This compile-time portability is very useful for debugging purposes. Actually,
    it is not easy to debug a Wasm application; but if you first debug the desktop
    application, a few bugs will remain in the Wasm version.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编译时便携性对于调试目的非常有用。实际上，调试 Wasm 应用程序并不容易；但如果你首先调试桌面应用程序，Wasm 版本中会剩下一些错误。
- en: Understanding the code behind this
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解此代码背后的含义
- en: Now, let's see the code used to create such a project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看创建此类项目所使用的代码。
- en: 'Before starting the project, a note about this is required. All the projects
    in this chapter show a monoski on a ski slope. There is a convention about the
    coordinates of the ski and other objects: the horizontal coordinate, usually named
    *X*, is actually named *across*; and the vertical coordinate, usually named *Y*,
    is actually named *along*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始项目之前，需要对此进行说明。本章中的所有项目都展示了一个滑雪板在滑雪道上的场景。关于滑雪板和其他对象的坐标有一个约定：水平坐标，通常称为 *X*，实际上称为
    *across*；而垂直坐标，通常称为 *Y*，实际上称为 *along*。
- en: So, the *across speed* is the speed of a movement from left to right (or vice
    versa, if negative), and the *along speed* is the speed of a movement from bottom
    to top (or vice versa, if negative).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*横向速度* 是从左到右（或反之，如果为负）移动的速度，而 *纵向速度* 是从底部到顶部（或反之，如果为负）移动的速度。
- en: 'First of all, the `Cargo.toml` file must contain the `quicksilver = "0.3"` dependency. Then,
    there is just a `main.rs` source file. It contains some constants, as shown in
    the following code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Cargo.toml` 文件必须包含 `quicksilver = "0.3"` 依赖项。然后，只有一个 `main.rs` 源文件。它包含一些常量，如下代码片段所示：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s look at what the terms suggest in this code, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码中的术语意味着什么，如下所示：
- en: '`SCREEN_WIDTH` and `SCREEN_HEIGHT` are the size in pixels of the client area
    in the desktop window or the size of the canvas in the web page.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCREEN_WIDTH` 和 `SCREEN_HEIGHT` 是桌面窗口中的客户端区域或网页中画布的大小（以像素为单位）。'
- en: '`SKI_WIDTH`, `SKI_LENGTH`, and `SKI_TIP_LEN` are the sizes of the ski.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKI_WIDTH`、`SKI_LENGTH` 和 `SKI_TIP_LEN` 是滑雪板的大小。'
- en: '`STEERING_SPEED` is the number of degrees by which the ski is rotated at every
    step. Steps have a frequency (that is, 25 per second), and so this constant represents
    an angular speed (3.5 degrees per step * 25 steps per second = 87.5 degrees per
    second).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STEERING_SPEED` 是滑雪板每次步骤旋转的度数。步骤有一个频率（即每秒 25 次），因此这个常量代表角速度（每步 3.5 度 * 每秒
    25 步 = 每秒 87.5 度）。'
- en: '`MAX_ANGLE` is a limit to rotational capability, both to the right and to the
    left, to ensure the ski is always downhill.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAX_ANGLE` 是旋转能力的限制，无论是向右还是向左，以确保滑雪板始终向下。'
- en: 'Then, there is the model of our MVC architecture, as shown in the following
    code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是我们的 MVC 架构模型，如下代码片段所示：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The meaning of these fields is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段的意义如下：
- en: '`ski_across_offset` represents the across displacement of the tip of the ski
    with respect to the center of the screen. Actually, in this project, it is always
    zero, as the tip of the ski never moves. It is a variable just because in future
    projects, it will change.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ski_across_offset` 代表滑雪板尖端相对于屏幕中心的横向位移。实际上，在这个项目中，它始终为零，因为滑雪板的尖端从不移动。它是一个变量，因为在未来项目中，它将发生变化。'
- en: '`direction` is the angle in degrees of the ski with respect to the downhill
    direction. It is initially zero but can vary from -75 to +75\. It is the only
    portion of our model that can change.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction` 是滑雪板相对于下山方向的度数。它最初为零，但可以从 -75 到 +75 变化。它是我们模型中唯一可以改变的部分。'
- en: 'The constructor of the model is quite simple, as illustrated in the following
    code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的构造函数相当简单，如下代码片段所示：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It simply initializes to zero both fields of the model. The body of the controller
    (the `update` function) is created with this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型简单地初始化了模型的两个字段为零。控制器的主体（`update`函数）是用以下代码创建的：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The purpose of this routine is to steer the ski a bit to the right, if the right-arrow
    key is pressed, and a bit to the left if the left-arrow key is pressed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此例程的目的是在按下右箭头键时将滑雪板稍微向右引导，如果按下左箭头键则稍微向左引导。
- en: The `window.keyboard()` expression gets a reference to the keyboard associated
    with the current window, and then the `[Key::Right]` expression gets a reference
    to the right-arrow key of such a keyboard. The `is_down` function returns `true`
    if the specified key is in a pressed state in this instant.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.keyboard()`表达式获取与当前窗口关联的键盘的引用，然后`[Key::Right]`表达式获取该键盘的右箭头键的引用。`is_down`函数在指定键在此瞬间处于按下状态时返回`true`。'
- en: 'The steering is performed by the `steer` method, whose body consists of the
    following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 导航是通过`steer`方法执行的，其主体由以下代码组成：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, the value of the `direction` field of the model is incremented or decremented
    by the `STEERING_SPEED` constant. Then, it is ensured that the new value does
    not exceed the designed limits.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，模型`direction`字段的值通过`STEERING_SPEED`常量递增或递减。然后，确保新值不超过设计限制。
- en: 'The view is more complex. It must redraw all the scene even if it has not changed
    at all. The first drawing operation is always to draw the white background, as
    follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 视图更复杂。即使场景完全没有变化，也必须重新绘制整个场景。第一次绘制操作始终是绘制白色背景，如下所示：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the rectangle is drawn, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，绘制矩形，如下所示：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `draw_ex` method is used to draw shapes. Its first argument is a reference
    to the shape to draw; in this case, it is `Rectangle`. Its second argument, in
    the fifth line, is the background color of the shape; in this case, it is `PURPLE`.
    Its third argument is a plane affine transformation matrix; in this case, it is
    a translation, followed by a rotation, followed by a translation. And its fourth
    argument, in the last line, is a *Z* elevation; its purpose is to give an overlapping
    order to shapes. Let's examine these arguments in more detail.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_ex`方法用于绘制形状。它的第一个参数是要绘制的形状的引用；在这种情况下，它是`Rectangle`。它的第二个参数，在第五行，是形状的背景颜色；在这种情况下，它是`紫色`。它的第三个参数是一个平面仿射变换矩阵；在这种情况下，它是一个平移，然后是旋转，然后是平移。它的第四个参数，在最后一行，是一个*Z*高度；其目的是为形状提供重叠顺序。让我们更详细地检查这些参数。'
- en: The `Rectangle::new` method receives two arguments. The first argument is a
    tuple made up of the *x* and *y* coordinates on the top-left vertex of the rectangle.
    The second argument is a tuple made up of the width and height of the rectangle.
    The origin of the coordinate system is the top left of the window, with the *x*
    coordinate that grows toward the right, and the *y* coordinate that grows downward.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle::new`方法接收两个参数。第一个参数是由矩形左上角顶点的*x*和*y*坐标组成的元组。第二个参数是由矩形的宽度和高度组成的元组。坐标系的原点是窗口的左上角，*x*坐标向右增长，*y*坐标向下增长。'
- en: In those formulas, the only variable is `self.ski_across_offset`, which represents
    the displacement of the ski to the right of the center of the window when positive,
    and to the left when negative. In this project, it is always zero, and so the
    ski's *x* coordinate is always at the center of the window. The vertical position
    is such that the center of the rectangle is near the bottom of the window, at
    15/16 of the height of the window.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些公式中，唯一的变量是`self.ski_across_offset`，它表示当为正时，滑雪板相对于窗口中心的位移向右，当为负时向左。在这个项目中，它始终为零，因此滑雪板的*x*坐标始终位于窗口中心。垂直位置是使得矩形的中心接近窗口底部，大约是窗口高度的15/16。
- en: Rectangles are always created with their sides parallel to the sides of the
    window. To have a rotated angle, a geometric transformation must be applied. There
    are several elementary transformations that can be combined by multiplying them.
    To draw a shape in a translated position, a transformation is created using the `Transform::translate`
    method, which receives a `Vector` (not a `Vec`!) specifying the displacements
    along *x* and *y*. To draw a shape in a rotated position, a transformation is
    created using the `Transform::rotate` method, which receives an angle in degrees specifying
    the angle by which to rotate the shape.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形总是与其边平行于窗口的边创建。为了有一个旋转角度，必须应用几何变换。有几种基本的变换可以通过乘法组合。要绘制一个在平移位置上的形状，使用 `Transform::translate`
    方法创建一个变换，该方法接收一个 `Vector`（不是 `Vec`！）指定沿 *x* 和 *y* 方向的位移。要绘制一个在旋转位置上的形状，使用 `Transform::rotate`
    方法创建一个变换，该方法接收一个角度（以度为单位），指定旋转形状的角度。
- en: The rotation is performed around the centroid of the shape, but we want to rotate
    around the tip of the ski. So, we need first to translate the rectangle so that
    its centroid is where the tip of the ski was, then rotate it around its centroid,
    and then translate it back to the original centroid. By multiplying the three
    transformations, a rotation around the tip of the ski is obtained. In the case
    of a rectangle, the centroid is just the center of the rectangle.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转是围绕形状的质心进行的，但我们想围绕滑雪板的尖端旋转。因此，我们需要首先平移矩形，使其质心位于滑雪板的尖端处，然后围绕其质心旋转，最后将其平移回原始质心。通过乘以这三个变换，我们得到了围绕滑雪板尖端的旋转。在矩形的例子中，质心就是矩形的中心。
- en: The last argument of `draw_ex` is a *z* coordinate. This is a 2D framework,
    and so no *z* coordinate would be required, but this coordinate allows us to specify
    the order of the appearance of the shapes. Actually, if two shapes overlap, and
    they have the same *z* coordinate, WebGL (used by Quicksilver) does not necessarily
    draw them in the order in which you have drawn them. The actual order is undefined.
    To specify that a shape must appear above another, it must have a larger *z* coordinate.
    It doesn't matter how much larger.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_ex` 的最后一个参数是一个 *z* 坐标。这是一个二维框架，因此不需要 *z* 坐标，但这个坐标允许我们指定形状出现的顺序。实际上，如果有两个形状重叠，并且它们具有相同的
    *z* 坐标，Quicksilver（使用 WebGL）并不一定按照你绘制的顺序绘制它们。实际的顺序是未定义的。为了指定一个形状必须出现在另一个形状之上，它必须具有更大的
    *z* 坐标。它的大小并不重要。'
- en: To draw the triangular-pointed end on top of the rectangle, a similar statement
    is executed. The `Triangle::new` method creates a `Triangle` shape, using three
    `Vector` variables as its vertices. To rotate it around its tip, we need to know
    the centroid of the triangle. With a bit of geometry, you can calculate that the
    centroid of that triangle is the point above the center of the base of the triangle
    by a distance equal to one-third of the height of the triangle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要在矩形上方绘制三角形尖端，执行一个类似的语句。`Triangle::new` 方法创建一个 `Triangle` 形状，使用三个 `Vector` 变量作为其顶点。为了使其围绕尖端旋转，我们需要知道三角形的质心。通过一点几何知识，你可以计算出该三角形的质心位于三角形底边中心上方，距离等于三角形高度的1/3。
- en: 'By the end of the program, there is a `main` function that must initialize
    the app. The body of the function contains this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到程序结束时，有一个必须初始化应用的 `main` 函数。函数的主体包含以下内容：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This statement just runs the model, with some arguments. The first argument
    is the caption of the title bar, the second one is the size of the window, and
    the third one is a structure containing some optional settings.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句只是运行模型，并带有一些参数。第一个参数是标题栏的标题，第二个参数是窗口的大小，第三个参数是一个包含一些可选设置的结构的实例。
- en: 'The following two settings are specified here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面两个设置在这里指定：
- en: '`draw_rate`: This is the interval in milliseconds between each successive invocation
    of the `draw` function'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw_rate`：这是 `draw` 函数连续调用之间的时间间隔（以毫秒为单位）'
- en: '`update_rate`: This is the interval in milliseconds between each successive
    invocation of the `update` function'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_rate`：这是 `update` 函数连续调用之间的时间间隔（以毫秒为单位）'
- en: This project was quite trivial, but it showed many concepts that will be used
    in the other projects of this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目相当简单，但它展示了将在本章其他项目中使用的许多概念。
- en: Implementing the silent_slalom project
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 silent_slalom 项目
- en: The previous project just showed a ski on a ski slope. In this section, we will
    show a possibly amusing game using a ski—a slalom. For simplicity, no text is
    displayed and no sound effects are played in this project. Its source code is
    contained in the `silent_slalom` folder.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的项目只显示了一个滑雪场上的滑雪板。在本节中，我们将展示一个可能有趣的游戏，使用滑雪板进行障碍滑雪。为了简单起见，在这个项目中没有显示文本，也没有播放音效。它的源代码包含在
    `silent_slalom` 文件夹中。
- en: 'After compiling and running its desktop version, a window similar to this will
    appear to you:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行其桌面版本后，将出现一个类似于这样的窗口：
- en: '![](img/542d2008-a2b5-436f-ab73-9dc8f2cb70ee.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/542d2008-a2b5-436f-ab73-9dc8f2cb70ee.png)'
- en: In addition to the ski, some blue dots are drawn. There are four dots in the
    middle of the window, and two half dots that come out at the top border. Each
    pair of blue dots is the poles of a slalom gate. The purpose of the game is to
    make the ski pass through each of the gates. Now, you can see just three gates,
    but the course contains seven intermediate gates, plus the finish gate. The remaining
    five gates will appear when the ski proceeds along the slope.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了滑雪板，还画了一些蓝色的小点。窗口中间有四个点，顶部边界上有两个半点。每一对蓝色点是一个障碍门的柱子。游戏的目的是通过每个障碍门。现在，你可以看到只有三个门，但赛道包含七个中间门，加上结束门。剩下的五个门将在滑雪板沿着斜坡前进时出现。
- en: The actual position of the poles will be different in your case because their
    horizontal (across) position is generated at random. If you stop and relaunch
    the program, you will see other poles' positions. The size of the gates—that is,
    the distance between the two poles of any gate—is kept constant, though; and also,
    the distance, along the *y* coordinate, between any gate and the gate following
    it is constant.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，柱子的实际位置将不同，因为它们的水平（横跨）位置是随机生成的。如果你停止并重新启动程序，你会看到其他柱子的位置。尽管如此，门的尺寸——即任何门的两柱之间的距离——保持不变；此外，任何门与其后门之间的
    *y* 坐标距离也是恒定的。
- en: To start the game, press the spacebar. The blue dots will begin to move slowly
    downward, giving the impression of the ski going forward. By rotating the ski,
    you change its direction, and you should try to ensure that its tip passes between
    the poles of every gate.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始游戏，请按空格键。蓝色的小点将开始缓慢向下移动，给人一种滑雪板向前滑行的印象。通过旋转滑雪板，你可以改变它的方向，你应该尝试确保滑雪板的尖端通过每个门的柱子之间。
- en: 'The finish gate is distinguished by having green poles instead of blue. If
    you pass through it, the game finishes, showing a window similar to this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结束门通过绿色柱子而不是蓝色柱子来区分。如果你通过了它，游戏结束，显示一个类似于这样的窗口：
- en: '![](img/bdb950e4-4056-4d02-8d02-9c6bfc547c00.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdb950e4-4056-4d02-8d02-9c6bfc547c00.png)'
- en: You can restart the game by pressing the *R* key. If you fail to pass a gate
    correctly, the game stops and ends. You can restart it by pressing the *R* key.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按 *R* 键重新启动游戏。如果你未能正确通过一个门，游戏将停止并结束。你可以通过按 *R* 键重新启动它。
- en: Of course, this project has something in common with the previous project. Let's
    see the differences within it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个项目与之前的项目有一些共同之处。让我们看看其中的不同之处。
- en: The first difference is the insertion into the `Cargo.toml` file of the `rand
    = "0.6"` dependency. The gates are positioned at a random *x* position, and so
    the random number generator contained in this crate is required.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个不同之处在于在 `Cargo.toml` 文件中插入了 `rand = "0.6"` 依赖项。门被定位在随机的 *x* 位置，因此需要这个包中包含的随机数生成器。
- en: 'Then, the following constants are defined:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义以下常量：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s have a look at these constants in detail, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些常量，如下所示：
- en: '`N_GATES_IN_SCREEN` is the number of gates that will appear in the window at
    once. The along separation between successive gates is the window height divided
    by this number. Therefore, this number must be positive.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N_GATES_IN_SCREEN` 是一次在窗口中出现的门的数量。连续门之间的距离是窗口高度除以这个数字。因此，这个数字必须是正数。'
- en: '`GATE_POLE_RADIUS` is the radius in pixels of each circle drawn to represent
    a pole.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GATE_POLE_RADIUS` 是用来表示柱子的每个圆的像素半径。'
- en: '`GATE_WIDTH` is the distance in pixels between the centers of the poles in
    each gate. This number must be positive.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GATE_WIDTH` 是每个门中柱子中心之间的像素距离。这个数字必须是正数。'
- en: '`SKI_MARGIN` is the distance in pixels between the leftmost position that can
    be reached by the tip of the ski to the left border of the window, and between
    the rightmost position that can be reached by the tip of the ski to the right
    border of the window.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKI_MARGIN` 是滑雪板尖端能够到达的最左侧位置到窗口左边的像素距离，以及滑雪板尖端能够到达的最右侧位置到窗口右边的像素距离。'
- en: '`ALONG_ACCELERATION` is the acceleration, in pixels per frame for each frame,
    for the movement of the ski, due to the slope, when the ski is in downhill position—that
    is, vertical. For example, for an acceleration value of 0.06 and an update rate
    of 40 milliseconds, or 25 frames per second, in a second the speed would go from
    zero to *0.06 * 25 = 1.5* pixels per frame—that is, a speed of *1.5 * 25 = 37.5*
    pixels per second. The actual acceleration will be lower if the ski has an inclination
    with respect to the slope.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALONG_ACCELERATION` 是滑雪板由于斜坡而移动的加速度，以每帧像素为单位，对于每一帧，当滑雪板处于下山位置——即垂直时。例如，对于加速度值为
    0.06 和更新率为 40 毫秒，或每秒 25 帧，一秒钟内速度将从零增加到 *0.06 * 25 = 1.5* 像素每帧——即速度为 *1.5 * 25
    = 37.5* 像素每秒。如果滑雪板相对于斜坡有倾斜，实际加速度将更低。'
- en: '`DRAG_FACTOR` represents the deceleration caused by air friction. The actual
    deceleration is this factor multiplied by the module of the speed.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRAG_FACTOR` 代表由空气摩擦引起的减速。实际减速是此因子乘以速度的模量。'
- en: '`TOTAL_N_GATES` is the number of gates, including the finish gate.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TOTAL_N_GATES` 是门的总数，包括终点门。'
- en: 'While in the previous project you could do just one thing all the time—that
    is, rotate the ski—in this project, you can do different things according to the
    current situation. So, there is a need to distinguish among four possible states,
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目中，你一直只能做一件事——那就是旋转滑雪板——在这个项目中，你可以根据当前情况做不同的事情。因此，需要区分四种可能的状态，如下所示：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The initial mode is `Ready`, when you are eager to start the run, at the top
    of the slope. After the `start` command, you are in `Running` mode, until you
    complete the run correctly, ending in `Finished` mode, or get out of a gate, ending
    in `Failed` mode.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 初始模式是 `Ready`，当你渴望开始滑行，位于斜坡顶部时。在发出 `start` 命令后，你处于 `Running` 模式，直到你正确完成滑行，结束于
    `Finished` 模式，或者从门中出来，结束于 `Failed` 模式。
- en: 'Some fields have been added to the model of the application, to track some
    other state information, as illustrated in the following code block:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 已经向应用程序的模型中添加了一些字段，以跟踪一些其他状态信息，如下面的代码块所示：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The meaning of these fields is described as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段的意义如下所述：
- en: '`gates` is a list of the along positions of the poles. For them, the origin
    is the center of the window.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gates` 是杆的沿位置列表。对于它们，原点是窗口的中心。'
- en: '`forward_speed` is the module of the velocity in pixels per frame.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forward_speed` 是每帧像素速度的模量。'
- en: '`gates_along_offset` is the *Y* translation of all the shown gates toward the
    bottom, which represents the advancement of the ski. It is a number between zero
    and the along spacing between successive gates.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gates_along_offset` 是所有显示的门的 *Y* 方向平移，这代表着滑雪板的前进。它是一个介于零和连续门之间沿间距之间的数字。'
- en: '`mode` is the state described previously.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode` 是之前描述的状态。'
- en: '`entered_gate` indicates whether the tip of the ski has already entered the
    lowest gate shown in the window. This flag is initialized as `false`; it becomes
    `true` when the ski passes a gate correctly and becomes `false` again when that
    gate exits the window from the bottom because now it refers to the next gate.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entered_gate` 指示滑雪板的尖端是否已经进入窗口中显示的最低门。这个标志被初始化为 `false`；当滑雪板正确通过一个门时，它变为 `true`，当那个门从底部退出窗口时再次变为
    `false`，因为现在它指的是下一个门。'
- en: '`disappeared_gates` counts the gates exited from the window. Of course, it
    is initialized at zero and is incremented every time a gate exits the window.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disappeared_gates` 计算从窗口中退出的门。当然，它被初始化为零，每次门退出窗口时都会增加。'
- en: 'A function added to the `Screen` type generates a random gate, as illustrated
    in the following code block:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到 `Screen` 类的一个函数生成一个随机门，如下面的代码块所示：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function receives the `gate_is_at_right` flag, which indicates in which
    part of the slope the generated gate will be. If such an argument is `true`, the
    new gate will be at the right of the center of the window; otherwise, it will
    be at the left of the center of the window. This function creates a random number
    generator and uses it to generate a reasonable position for a pole. The other
    pole position is computed using the argument of the function and the fixed gate
    size (`GATE_WIDTH`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接收`gate_is_at_right`标志，该标志指示生成的门将在斜率的哪个部分。如果此参数为`true`，则新门将位于窗口中心的右侧；否则，它将位于窗口中心的左侧。此函数创建一个随机数生成器，并使用它生成一个合理的杆位置。另一个杆位置是通过使用函数参数和固定的门大小（`GATE_WIDTH`）计算得出的。
- en: 'Another utility function is `deg_to_rad`, which converts angles from degrees
    to radians. It is needed because Quicksilver uses degrees, but trigonometric functions
    use radians. The `new` method creates all the gates, alternating them at right
    and at left, and initializes the model. The `update` function does a lot more
    than the function with that name seen in the previous project. Let''s look at
    the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个实用函数是`deg_to_rad`，它将角度从度转换为弧度。这是必需的，因为Quicksilver使用度，但三角函数使用弧度。`new`方法创建所有门，交替在右侧和左侧，并初始化模型。`update`函数所做的比之前项目中看到的名字相同的函数要多得多。让我们看看下面的代码片段：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'According to the current mode, different operations are performed. If the mode
    is `Ready`, it checks whether the spacebar key is pressed, and, in such a case,
    it sets the current mode to `Running`. This means that it starts the race. If
    the mode is `Running`, the following code is executed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前模式，执行不同的操作。如果模式是`Ready`，则检查空格键是否被按下，如果是这样，则将当前模式设置为`Running`。这意味着它开始比赛。如果模式是`Running`，则执行以下代码：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this mode, a lot of things are computed. First, the ski direction is converted
    from degrees to radians.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，计算了很多东西。首先，将滑雪方向从度转换为弧度。
- en: Then, the forward speed is incremented because of the slope, and it is decremented
    because of the friction of the air, which is proportional to the speed itself.
    The net effect is that the speed will tend to a maximum value. In addition, the
    more the ski direction is rotated with respect to the slope, the slower it is.
    This effect is implemented using the `cos` cosine trigonometric function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于斜率，前进速度增加，由于空气阻力（与速度本身成比例）而减少。净效应是速度将趋向于最大值。此外，滑雪方向相对于斜率的旋转越多，它就越慢。这种效果是通过使用`cos`余弦三角函数实现的。
- en: 'Then, the forward speed is split into its components: the along speed, which
    causes the downward movement of the poles, and the across speed, which increments
    the across ski offset. They are computed by applying, respectively, the `cos`
    and `sin` trigonometric functions to the forward speed, as shown in the following
    code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将前进速度分解为其分量：沿速度，它导致极点的向下移动，以及横速度，它增加横滑雪偏移量。它们分别通过应用`cos`和`sin`三角函数来计算前进速度，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, it checks that the ski position is not too far to the left or to the
    right, and, if it is so, it is kept within the defined margins, as illustrated
    in the following code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它检查滑雪位置是否没有太偏向左边或右边，如果是这样，它将被保持在定义的边框内，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The new along speed is used to move down the gates, by incrementing the `gates_along_offset`
    field. If its new value is larger than the distance between successive gates,
    one gate is dropped out of the bottom of the window, and all the gates are moved
    backward by one step and the number of disappeared gates is incremented, as illustrated
    in the following code snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 新的沿速度用于向下移动门，通过增加`gates_along_offset`字段。如果其新值大于连续门之间的距离，则从窗口底部移除一个门，所有门向后移动一步，消失的门数增加，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, the two coordinates of the tip of the ski are computed: `ski_tip_along`
    is the constant *y* coordinate, from the top of the window, and `ski_tip_across`
    is the variable *x* coordinate, from the center of the window.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，计算滑雪尖端的两个坐标：`ski_tip_along`是常数 *y* 坐标，从窗口顶部开始，而`ski_tip_across`是变量 *x* 坐标，从窗口中心开始。
- en: 'Then, the positions inside the next gate are computed: `left_pole_offset` is
    the *x* position of the right side of the left pole, and `right_pole_offset` is
    the *x* position of the left side of the right pole. These coordinates are computed
    from the left border of the window. And then, `next_gate_along` is the *y* position
    of such points, as illustrated in the following code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，计算下一个门内的位置：`left_pole_offset`是左侧极点的*x*位置，而`right_pole_offset`是右侧极点的*x*位置。这些坐标是从窗口的左侧边框计算的。然后，`next_gate_along`是这些点的*y*位置，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the *y* coordinate of the tip of the ski (`ski_tip_along`) is less than that
    of the gate (`next_gate_along`), then we can say that the tip of the ski has passed
    to the next gate. Though, if the `entered_gate` field, which records such passing,
    is still `false`, we can say that in the previous frame the ski hadn't yet passed
    the gate. Therefore, in such a case, we are in the situation in which the ski
    has just passed a gate. So, we must check whether the gate has been passed correctly
    or wrongly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果滑雪板尖端(`ski_tip_along`)的*y*坐标小于门的坐标(`next_gate_along`)，那么我们可以说滑雪板的尖端已经通过了下一个门。尽管如此，如果记录这种通过的`entered_gate`字段仍然是`false`，那么我们可以说明在上一帧滑雪板还没有通过门。因此，在这种情况下，我们处于滑雪板刚刚通过门的情形。所以，我们必须检查门是否正确或错误地通过了。
- en: If the *x* coordinate of the tip is *not* between the two coordinates of the
    poles, we are outside the gate, and so we go into the `Failed` mode. Otherwise,
    we must check whether this gate is the last gate of the course—that is, the finish
    gate. If it is the case, we go into the `Finish` mode; otherwise, we make a note
    that we have entered the gate, to avoid checking it again at the next frame, and
    the race goes on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果滑雪板尖端的*x*坐标不在两个极点坐标之间，那么我们就处于门外，因此进入`Failed`模式。否则，我们必须检查这个门是否是课程的最后一个门——即终点门。如果是这种情况，我们进入`Finish`模式；否则，我们记录我们已经进入了门，以避免在下一帧再次检查它，比赛继续进行。
- en: If the *y* coordinate is such that we haven't reached the next gate yet, we
    take note that `entered_gate` is still false. With this, we have completed the
    computations for the `Running` case.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*y*坐标表明我们还没有到达下一个门，我们记录`entered_gate`仍然是`false`。有了这个，我们就完成了`Running`情况下的计算。
- en: 'Two modes remain to be considered, as illustrated in the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 还剩下两种模式需要考虑，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both in the `Failed` mode and in the `Finished` mode, the *R* key is checked.
    If it is pressed, the model is reinitialized, going to the same state as when
    the game was just launched.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Failed`模式和`Finished`模式下，都会检查*R*键。如果按下，则重新初始化模型，回到游戏启动时的相同状态。
- en: 'Lastly, the steering key is checked for any mode, just as in the previous project.
    Regarding the `draw` function, what has been added in this project, with respect
    to the previous project, is the drawing of the poles. The code can be seen in
    the following snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，检查转向键是否处于任何模式，就像在之前的项目中一样。关于`draw`函数，与之前的项目相比，本项目新增的功能是绘制极点。代码可以在以下代码片段中查看：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A loop scans the gates that appear in the window. The indices of the gates go
    from zero to `TOTAL_N_GATES`, but we must ski the ones that have already exited
    from the bottom, whose number is `self.disappeared_gates`. We must show at least
    the `N_GATES_IN_SCREEN` gates and must stop at the last gate.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个循环扫描窗口中出现的门。门的索引从零到`TOTAL_N_GATES`，但我们必须跳过那些已经从底部消失的门，其数量为`self.disappeared_gates`。我们必须显示至少`N_GATES_IN_SCREEN`个门，并且必须停在最后一个门上。
- en: 'To show the player which is the finish gate, it has a different color, as can
    be seen in the following code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向玩家显示哪个是终点门，它有不同的颜色，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last gate is green. To compute the *y* coordinate of the poles of a gate,
    the following formula is used:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个门是绿色的。为了计算门的极点的*y*坐标，使用以下公式：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It adds the position of the ski between two successive gates (`gates_along_offset`)
    to the initial position of the first three gates.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它将两个连续门之间的滑雪板位置(`gates_along_offset`)添加到前三个门的初始位置。
- en: 'And then, two small circles are drawn for each gate. The left circle is drawn
    by executing the following statement:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为每个门绘制两个小圆圈。左边的圆圈是通过执行以下语句绘制的：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The argument of the `Circle` constructor is a tuple composed of the *x* and
    *y* coordinates of the center and the radius. Here, the `draw` method of the window
    object is used, instead of the `draw_ex` method. It is simpler, as it does not
    require a transformation nor a *z* coordinate.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`构造函数的参数是一个由中心点的*x*和*y*坐标以及半径组成的元组。在这里，使用的是窗口对象的`draw`方法，而不是`draw_ex`方法。它更简单，因为它不需要变换也不需要*z*坐标。'
- en: And so, we have examined all the code of this project. In the next project,
    we'll show how we can add text and sound to our game.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经检查了这个项目的所有代码。在下一个项目中，我们将展示如何将文字和声音添加到我们的游戏中。
- en: Implementing the assets_slalom project
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`assets_slalom`项目
- en: The previous project built was a valid slalom race, but that game had no sound
    or text to explain what was happening. This project, contained in the `assets_slalom`
    folder, just adds sound and text to the game of the previous project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个构建的项目是一个有效的回转滑雪比赛，但那个游戏没有声音或文字来解释正在发生的事情。这个项目包含在`assets_slalom`文件夹中，只是为前一个项目的游戏添加了声音和文字。
- en: 'Here is a screenshot that was taken during a race:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是比赛期间拍摄的一张截图：
- en: '![](img/dcb74ea0-5d42-41a3-80f9-e507c120179b.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcb74ea0-5d42-41a3-80f9-e507c120179b.png)'
- en: 'In the top left of the window, there is the following information:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口的左上角，有如下信息：
- en: '**Elapsed time**: This tells us how many seconds or hundreds of seconds have
    elapsed since the start of the current race.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已过时间**：这告诉我们从当前比赛开始以来有多少秒或百秒已经过去。'
- en: '**Speed**: This tells us how much is the current forward speed in pixels per
    second.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：这告诉我们当前每秒向前移动多少像素。'
- en: '**Remaining gates**: This tells us how many gates remain to pass.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剩余门数**：这告诉我们还有多少门需要通过。'
- en: Then, a help message explains which commands are available.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一条帮助信息解释了哪些命令可用。
- en: 'In addition, four sounds have been added, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还增加了四个声音，如下所示：
- en: A tick at any start of a race
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛任何开始时的滴答声
- en: A whoosh at any turn
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛任何转弯时的呼啸声
- en: A bump at any fail
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛任何失败时的碰撞声
- en: A chime at any finish
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛任何结束时的铃声
- en: You have to run the game to hear them. Notice that not all web browsers are
    equally capable of reproducing sounds.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须运行游戏才能听到它们。请注意，并非所有网络浏览器都能同样有效地播放声音。
- en: 'Now, let''s see how Quicksilver can show text and play sounds. Sounds and text
    are not so simple to use because of the fact that they need files; for text, one
    or more font files are needed; and for sounds, a sound file for any sound effect
    is needed. Such files must be stored in a folder named `static` in the root of
    the project. If you look in the said folder, you''ll find the following files:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Quicksilver如何显示文字和播放声音。由于声音和文字需要文件，它们的使用并不简单；对于文字，需要一个或多个字体文件；对于声音，需要一个声音效果文件。这些文件必须存储在项目根目录下的名为`static`的文件夹中。如果您查看该文件夹，您将找到以下文件：
- en: '`font.ttf`: This is a font in TrueType format.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font.ttf`：这是一个TrueType格式的字体。'
- en: '`click.ogg`: This is a short click sound, to be played at the start of a race.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click.ogg`：这是一个短促的点击声音，将在比赛开始时播放。'
- en: '`whoosh.ogg`: This is a short friction sound, to be played when the ski is
    turning during a race.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whoosh.ogg`：这是一个短促的摩擦声音，将在滑雪板在比赛中转弯时播放。'
- en: '`bump.ogg`: This is a bump sound to express disapproval, to be played when
    the ski misses a gate.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bump.ogg`：这是一个表示不满的碰撞声音，将在滑雪板错过门时播放。'
- en: '`two_notes.ogg`: This is a pair of notes to express satisfaction, to be played
    when the ski passes the finish gate.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`two_notes.ogg`：这是一对音符，表示满意，将在滑雪板通过终点门时播放。'
- en: Such a `static` folder and its contained files must be deployed together with
    the executable program, as they are loaded at runtime by the program. They are
    usually also named *assets* as they are just data, not executable code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的`static`文件夹及其包含的文件必须与可执行程序一起部署，因为它们在程序运行时被程序加载。它们通常也被称为*assets*，因为它们只是数据，而不是可执行代码。
- en: Quicksilver has chosen to load such assets in an asynchronous way, using the
    *future* *concept*. To load a sound from a file, the `Sound::load(«filename»)` expression is
    used. It receives a value implementing a reference to a path, such as a string,
    and it returns an object implementing the `Future` trait.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Quicksilver选择以异步方式加载这些资源，使用*future*概念。要从文件中加载声音，使用`Sound::load(«filename»)`表达式。它接收一个实现路径引用的值，例如一个字符串，并返回一个实现`Future`特质的对象。
- en: An asset—that is, an object that encapsulates a future that is loading a file—is
    created by the `Asset::new(«future value»)` expression. It receives a value implementing
    a future, and it returns an `Asset` instance of the specific type. For instance,
    the `Asset::new(Sound::load("bump.ogg"))` expression returns a value of the `Asset<Sound>` type.
    Such a value is an asset that encapsulates a future—that is, reading a sound from
    the `bump.ogg` file. The sounds in this project are in the `.ogg` format, but
    Quicksilver is capable of reading several audio formats.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Asset::new(«future value»)` 表达式创建了一个资产——即封装正在加载文件的未来的对象。它接收一个实现未来的值，并返回特定类型的
    `Asset` 实例。例如，`Asset::new(Sound::load("bump.ogg"))` 表达式返回一个 `Asset<Sound>` 类型的值。这样的值是一个封装未来的资产——即从
    `bump.ogg` 文件中读取声音。在这个项目中，声音是 `.ogg` 格式，但 Quicksilver 能够读取多种音频格式。
- en: Once you have an asset encapsulating a future loading a file, you can access
    such a file in an expression such as `sound_future.execute(|sound_resource| sound_resource.play())`.
    Here, the `sound_future` variable is our asset. As it is a future, you have to
    wait for it to be ready. This is done using the `execute` method of the `Asset`
    type. It invokes the closure received as an argument, passing to it the encapsulated
    resource, which in this case is of the `Sound` type.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个封装未来加载文件的资产，你可以在表达式 `sound_future.execute(|sound_resource| sound_resource.play())`
    中访问这样的文件。在这里，`sound_future` 变量是我们的资产。由于它是一个未来，你必须等待它准备好。这是通过 `Asset` 类型的 `execute`
    方法完成的。它调用作为参数接收的闭包，并将封装的资源传递给它，在这种情况下是 `Sound` 类型。
- en: 'The `Sound` type has the `play` method, which starts to reproduce the sound.
    As usual in multimedia systems, such reproduction is asynchronous: you don''t
    have to wait for the end of the sound to proceed with the game. If you call `play`
    on a sound when the previous sound is still reproducing, the two sounds overlap,
    and if you play many of them, the resulting volume typically becomes very high.
    Therefore, you should keep your sounds very short, or play them seldom.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sound` 类型有 `play` 方法，它开始播放声音。在多媒体系统中，这种播放通常是异步的：你不必等待声音播放完毕就可以继续游戏。如果你在先前的声音仍在播放时调用
    `play`，两个声音会重叠，如果你播放很多声音，结果音量通常会非常高。因此，你应该让你的声音非常短，或者很少播放。'
- en: Similarly, the `Asset::new(Font::load("font.ttf"))` expression returns a value
    of the `Asset<Font>`. type. Such a value is an asset that encapsulates a future—that
    is, reading a font from the `font.ttf` file. You can use that font with the `font_future.execute(|font_resource|
    image = font_resource.render(&"Hello", &style))` expression. Here, the `font_future` variable
    is our asset. As it is a future, you have to wait for it using the `execute` method
    of the `Asset` type, which invokes the closure received as an argument, passing
    to it the encapsulated resource, which in this case is of the `Font` type.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`Asset::new(Font::load("font.ttf"))` 表达式返回一个 `Asset<Font>` 类型的值。这样的值是一个封装未来的资产——即从
    `font.ttf` 文件中读取字体。你可以使用这个字体，如下所示 `font_future.execute(|font_resource| image =
    font_resource.render(&"Hello", &style))`。在这里，`font_future` 变量是我们的资产。由于它是一个未来，你必须使用
    `Asset` 类型的 `execute` 方法等待它，该方法调用作为参数接收的闭包，并将封装的资源传递给它，在这种情况下是 `Font` 类型。
- en: The `Font` type has the `render` method, which receives a string and a reference
    to a `FontStyle` value and creates an image containing that text, printed using
    that font and that font style.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Font` 类型有 `render` 方法，它接收一个字符串和一个 `FontStyle` 值的引用，并创建一个包含该文本的图像，使用该字体和字体样式打印。'
- en: Analyzing the code
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析代码
- en: 'And now, let''s see all the code of the project that differs from the previous
    project. There is a new constant, as can be seen in the following code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看与上一个项目不同的所有项目代码。如下代码片段所示，有一个新的常量：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is to solve the following problem. If the game has a frame rate of 50 FPS,
    the window is redrawn 50 times per second, and each time using the latest values
    of the variables. Regarding time, it is a number that would change so rapidly
    that it would be impossible to read. Therefore, this constant sets the maximum
    rate of change of the displayed time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了解决以下问题。如果游戏帧率为50 FPS，窗口每秒重绘50次，并且每次使用变量的最新值。关于时间，它是一个变化如此之快的数字，以至于无法读取。因此，这个常量设置了显示时间的最大变化率。
- en: 'The model has several new fields, as can be seen in the following code snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 模型有几个新的字段，如下代码片段所示：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The meaning of these fields is described as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段的意义如下所述：
- en: '`elapsed_sec` is the fractional number of seconds elapsed since the start of
    the current race, using the maximum resolution available.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elapsed_sec` 是从当前比赛开始以来经过的秒数的分数，使用可用的最大分辨率。'
- en: '`elapsed_shown_sec` is the fractional number to show to the user as the number
    of elapsed seconds since the start of the current race.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elapsed_shown_sec` 是显示给用户的分数，表示从当前比赛开始以来经过的秒数。'
- en: '`font_style` contains the size and color of the text to print.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font_style` 包含要打印的文本的大小和颜色。'
- en: '`font` is the future value of the font to use to print the text of the screen.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font` 是用于打印屏幕文本的字体预期值。'
- en: '`whoosh_sound` is the future value of the sound to play during the turns of
    the running ski.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whoosh_sound` 是在滑雪运行过程中要播放的声音的预期值。'
- en: '`bump_sound` is the future value of the sound to play when a gate is missed.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bump_sound` 是在错过一个门时要播放的声音的预期值。'
- en: '`click_sound` is the future value of the sound to play when a race is started.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click_sound` 是在比赛开始时要播放的声音的预期值。'
- en: '`two_notes_sound` is the future value of the sound to play when the finish
    gate is crossed.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`two_notes_sound` 是在通过终点门时要播放的声音的预期值。'
- en: 'A routine to play sounds has been defined, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义了一个播放声音的例程，如下所示：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It receives a future value of a sound and a volume. It calls `execute` to ensure
    the sound is loaded, and then sets the specified volume and plays that sound.
    Notice that the `execute` method returns a `Result`, to allow for possible errors.
    As in games sounds are not essential, we want to ignore possible errors regarding
    sounds, and so, we always return `Ok(())`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收一个声音的预期值和一个音量。它调用 `execute` 方法以确保声音已加载，然后设置指定的音量并播放该声音。请注意，`execute` 方法返回一个
    `Result`，以允许可能的错误。由于在游戏中声音不是必需的，我们希望忽略有关声音的可能的错误，因此，我们总是返回 `Ok(())`。
- en: 'In the `steer` function, when a turn operation is performed and the ski is
    not already at an extreme angle, the following statement is performed:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `steer` 函数中，当执行转向操作且滑雪板尚未达到极端角度时，执行以下语句：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It plays the whoosh sound and a volume that is proportional to the speed of
    the ski. In this way, if you rotate the ski when you are not running, you are
    silent.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它播放“呼啸”声音和与滑雪速度成比例的音量。这样，如果你在未运行时旋转滑雪板，你将是安静的。
- en: 'The new fields of the model are initialized like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的新字段初始化如下：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that, as `font_style`, a size of 16 points and a black color are set.
    We already described the other kind of expressions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`font_style` 设置了16点的大小和黑色颜色。我们已描述了其他类型的表达式。
- en: 'In the `update` function, when the race is started by pressing the spacebar,
    the following statement is executed:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `update` 函数中，当通过按空格键开始比赛时，执行以下语句：
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It plays a click sound with a normal volume. When running, the elapsed time
    is computed like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它以正常音量播放点击声音。当运行时，经过时间的计算方式如下：
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `update_rate` function actually returns the time between frames, in milliseconds.
    So, if you divide it by 1,000, you get the seconds between each frame.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_rate` 函数实际上返回帧之间的时间，以毫秒为单位。因此，如果你将其除以1,000，你将得到每帧之间的秒数。'
- en: If there is a high frame rate, such as 25 frames per second or more, showing
    the user different text at any frame can be confusing, as people cannot read a
    text that changes so rapidly. So, the second statement in the previous code snippet
    shows a technique to update the text at a lower rate. The `elapsed_shown_sec`
    field keeps the time of the last update, and the `elapsed_sec` field keeps the
    current time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果帧率很高，例如每秒25帧或更多，在任何帧显示不同的文本可能会令人困惑，因为人们无法阅读变化如此之快的文本。因此，前一个代码片段中的第二个语句展示了更新文本的较低速率的技术。`elapsed_shown_sec`
    字段保持上次更新的时间，而 `elapsed_sec` 字段保持当前时间。
- en: The `MIN_TIME_DURATION` constant keeps the minimum duration by which a text
    must remain unchanged on screen before it can be updated. So, if the time elapsed
    from the time of the previous update to the current time is larger than such minimum
    duration, the text can be updated. In this particular case, the text to update
    is just the elapsed time in seconds, and so, if enough time has passed, the `elapsed_shown_sec` field
    is set to the current time. The `draw` routine will use that value to print the
    elapsed time on the screen.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`MIN_TIME_DURATION` 常量用于保持文本在屏幕上必须保持不变的最小时长，以便更新。因此，如果从上次更新时间到当前时间的经过时间大于这个最小时长，文本就可以更新。在这个特定情况下，要更新的文本只是经过的秒数，所以，如果时间足够长，`elapsed_shown_sec`
    字段就会被设置为当前时间。`draw` 例程将使用这个值在屏幕上打印经过的时间。'
- en: Two other sounds are emitted. When the `mode` becomes `Failed`, the `play_sound`
    is called to play a bump sound. And when the `mode` becomes `Finished`, the `play_sound` is
    called to play a chime.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 发出了另外两个声音。当`mode`变为`Failed`时，调用`play_sound`来播放碰撞声音。当`mode`变为`Finished`时，调用`play_sound`来播放铃声。
- en: 'Then, it''s up to the draw routine to print all the text. First, the text is
    formatted in a new multi-line string, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，绘制例程负责打印所有文本。首先，文本被格式化为一个新的多行字符串，如下所示：
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The elapsed time and the speed are printed using two decimals; the remaining
    gates are computed by subtracting the disappeared gates to the total number of
    gates. In addition, if the current gate has been entered, the count of remaining
    gates is decremented by one. Then, some different words are printed according
    to the current mode.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两位小数打印已过时间以及速度；剩余的关卡通过从总关卡数中减去消失的关卡来计算。此外，如果当前关卡已被进入，剩余关卡的数量将减一。然后，根据当前模式打印一些不同的单词。
- en: 'After having prepared the multiline string, the string is printed on a new
    image and stored in the `image` local variable, and the image is drawn on the
    window using the `draw` method, as a textured background. The method receives
    as a first argument the rectangular area to print, large as the whole bitmap,
    and, as a second argument, the `Img` variant of the `Background` type, constructed
    using the image, as illustrated in the following code snippet:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好多行字符串后，该字符串被打印到一个新的图像上，并存储在`image`局部变量中，然后使用`draw`方法将图像绘制到窗口上，作为一个纹理背景。该方法接收的第一个参数是要打印的矩形区域，大小与整个位图相同，第二个参数是使用图像构建的`Background`类型的`Img`变体，如以下代码片段所示：
- en: '[PRE33]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So, we have completed our examination of this simple but interesting framework.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了对这个简单但有趣的框架的考察。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen how a complete game, running both on desktop and on the web, can
    be built using Rust and the Quicksilver framework, with the web version using
    the `cargo-web` command and the Wasm code generator. This game was structured
    according to the animation loop architecture and the MVC architectural pattern.
    We created three apps—`ski`, `silent_slalom`, and `assets_slalom`—and understood
    the implementation behind them.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，一个完整的游戏，既可以在桌面运行，也可以在网络上运行，可以使用Rust和Quicksilver框架构建，网络版本使用`cargo-web`命令和Wasm代码生成器。这个游戏是根据动画循环架构和MVC架构模式构建的。我们创建了三个应用程序——`ski`、`silent_slalom`和`assets_slalom`——并理解了它们的实现。
- en: In the next chapter, we will be seeing another 2D game framework, the `ggez`
    framework, oriented toward desktop applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍另一个面向桌面应用的2D游戏框架，即`ggez`框架。
- en: Questions
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the animation loop, and what are its advantages with respect to an event-driven
    architecture?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动画循环是什么，它与事件驱动架构相比有哪些优势？
- en: When is an event-driven architecture better than an animation loop architecture?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时事件驱动架构比动画循环架构更好？
- en: Which kinds of software can use the animation loop?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的软件可以使用动画循环？
- en: How can you draw triangles, rectangles, and circles using Quicksilver?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Quicksilver绘制三角形、矩形和圆形？
- en: How can you receive input from the keyboard using Quicksilver?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Quicksilver接收键盘输入？
- en: How are the controller and the view of MVC implemented using Quicksilver?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC中的控制器和视图是如何在Quicksilver中实现的？
- en: How can you vary the frame rate of animation using Quicksilver?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Quicksilver来调整动画的帧率？
- en: How can you load assets from files using Quicksilver, and where should you keep
    such assets?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Quicksilver从文件中加载资源，并且这些资源应该保存在哪里？
- en: How can you play sounds using Quicksilver?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Quicksilver播放声音？
- en: How can you draw text on the screen using Quicksilver?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Quicksilver在屏幕上绘制文本？
- en: Further reading
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Quicksilver project can be downloaded from here: [https://github.com/ryanisaacg/quicksilver](https://github.com/ryanisaacg/quicksilver). This
    repository contains a link to a very short tutorial and some examples.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里下载Quicksilver项目：[https://github.com/ryanisaacg/quicksilver](https://github.com/ryanisaacg/quicksilver)。此存储库包含一个指向非常简短的教程和一些示例的链接。
- en: You can find more information about generating Wasm code from a Rust project
    at [https://github.com/koute/cargo-web](https://github.com/koute/cargo-web).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/koute/cargo-web](https://github.com/koute/cargo-web)找到有关从Rust项目生成Wasm代码的更多信息。
