- en: Chapter 7. Organizing Code and Macros
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。组织和宏
- en: 'We start this chapter by discussing the large-scale code-organizing structures
    in Rust, namely modules and crates. We will look at the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从讨论 Rust 中的大规模代码组织结构开始这一章，即模块和 crate。我们将探讨以下主题：
- en: Building crates
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 crate
- en: Defining a module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模块
- en: Visibility of items
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目的可见性
- en: Importing modules and file hierarchy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入模块和文件层次结构
- en: Importing external crates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入外部 crate
- en: Exporting a public interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出公共接口
- en: Adding external crates to a project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将外部 crate 添加到项目中
- en: The test module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试模块
- en: 'We will also touch upon how to build macros in order to generate code and save
    time and effort, particularly in these topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论如何构建宏以生成代码并节省时间和精力，特别是在以下主题中：
- en: The reason for using macros
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用宏的原因
- en: Developing macros
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发宏
- en: Using macros from crates
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 crate 中的宏
- en: Modules and crates
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和 crate
- en: Until now, we only looked at the situation where our code fitted in one file.
    However, when a project evolves, we will want to split the code across several
    files, for example, if we put all the data structures and methods that describe
    a certain functionality in the same file, how will the main code file be able
    to call these functions in other files?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了我们的代码适合一个文件的情况。然而，当项目发展时，我们希望将代码拆分到几个文件中，例如，如果我们把描述特定功能的全部数据结构和方法放在同一个文件中，主代码文件将如何调用其他文件中的这些函数？
- en: In addition, when we start using multiple functions in varied files, it sometimes
    happens that we want to use the same name for two different functions. How can
    we properly differentiate between such functions? How can we make it so that some
    functions are callable everywhere and others are not? For this, we need what other
    languages call namespaces and access modifiers; in Rust, this is done through
    the module system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们开始在多个文件中使用不同的函数时，有时我们会希望为两个不同的函数使用相同的名称。我们如何正确区分这些函数？我们如何使某些函数可以在任何地方调用，而其他函数则不行？为此，我们需要其他语言中称为命名空间和访问修饰符的东西；在
    Rust 中，这是通过模块系统实现的。
- en: Building crates
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 crate
- en: At the highest level of building crates, there is the crate. The Rust distribution
    contains a number of crates, such as the `std` crate of the standard library,
    which we have already used often. Other built-in crates are the `collections`
    crate, with the functionality to work with strings, vectors, lists, and key-value
    maps, and the `test` crate, with unit-testing and micro-benchmarking functionalities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 crate 的最高级别，有 crate。Rust 分发版包含许多 crate，例如我们经常使用的标准库中的 `std` crate。其他内置 crate
    包括具有处理字符串、向量、列表和键值映射功能的 `collections` crate，以及具有单元测试和微基准测试功能的 `test` crate。
- en: 'A crate is the equivalent of a package or library in other languages. It is
    also the unit of compilation; `rustc` only compiles one crate at a time. What
    does this mean? When our project has a code file containing a `main()` function,
    then it is clear that our project is an executable program (which is also called
    a binary) that starts execution in `main()`. For example, if we compile `structs.rs`
    as `rustc structs.rs, a .exe` file `structs.exe` will be produced in Windows (and
    equivalent formats on other operating systems) that can be executed on its own.
    This is the standard behavior when you invoke `rustc`. When working with Cargo
    (refer to [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Starting with Rust"),
    *Starting with Rust*), we have to indicate that we want a binary project at its
    creation with the `--bin` flag: `cargo new projname --bin`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，crate 等同于包或库。它也是编译的单位；`rustc` 一次只编译一个 crate。这意味着什么？当我们的项目包含一个包含 `main()`
    函数的代码文件时，那么我们的项目就是一个可执行程序（也称为二进制文件），它从 `main()` 开始执行。例如，如果我们编译 `structs.rs` 为
    `rustc structs.rs`，在 Windows 上（以及其他操作系统的等效格式）将生成一个可以独立执行的 `.exe` 文件 `structs.exe`。当你调用
    `rustc` 时，这是标准的行为。当使用 Cargo（参考[第1章](part0014.xhtml#aid-DB7S1 "第1章。从 Rust 开始")，*从
    Rust 开始*），在创建项目时，我们必须使用 `--bin` 标志来指定我们想要一个二进制项目：`cargo new projname --bin`。
- en: 'However, often your intention is to write a project whose code will be called
    from other projects, a so-called shared library (this is a `.dll` file in Windows,
    a `.so` file in Linux, and a `.dylib` file in Mac OS X.) In this case, your code
    will only contain the data structures and functions to work on them. Then, you
    must explicitly indicate this to the compiler using the `--crate-type` flag with
    the `lib` option: `rustc --crate-type=lib structs.rs`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常您的意图是编写一个可以从其他项目调用的项目代码，即所谓的共享库（在Windows中是`.dll`文件，在Linux中是`.so`文件，在Mac
    OS X中是`.dylib`文件。）在这种情况下，您的代码将只包含处理这些数据结构及其函数。然后，您必须使用带有`lib`选项的`--crate-type`标志显式地通知编译器：`rustc
    --crate-type=lib structs.rs`。
- en: 'The resulting file is far smaller in size and is called `libstructs.rlib`;
    the suffix is now `.rlib` (for the Rust library) and `lib` is prepended before
    the filename. If you want the crate to have another name such as `mycrate`, then
    use the `--crate-name` flag as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件大小远小于原来的文件，称为`libstructs.rlib`；后缀现在是`.rlib`（对于Rust库）并在文件名前加上`lib`。如果您希望集合具有另一个名称，例如`mycrate`，则可以使用以下`--crate-name`标志：
- en: '`rustc --crate-type=lib --crate-name=mycrate structs.rs`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustc --crate-type=lib --crate-name=mycrate structs.rs`'
- en: 'This creates a `libmycrate.rlib` as the output file. An alternative to using
    the `rustc` flags is to put this information as an attribute at the top of the
    code file, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`libmycrate.rlib`作为输出文件。使用`rustc`标志的替代方法是，将此信息作为属性放在代码文件顶部，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `crate_type` attribute can take the `bin`, `lib`, `rlib`, `dylib`, or `staticlib`
    values, according to whether you want an executable binary or a library of a certain
    type that is dynamic or statically linked. (In general, when an `attr` attribute
    applies to a whole crate, the syntax to use in the code is `#![crate_attr]`.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`crate_type`属性可以取`bin`、`lib`、`rlib`、`dylib`或`staticlib`值，具体取决于您是否想要一个可执行的二进制文件或某种类型的库，该库是动态链接或静态链接的。（一般来说，当`attr`属性应用于整个集合时，代码中使用的语法是`#![crate_attr]`。）'
- en: Each library used in an application is a separate crate. In any case, you need
    an executable (binary) crate that uses the library crates.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中使用的每个库都是一个独立的集合。在任何情况下，你需要一个可执行（二进制）集合，它使用库集合。
- en: Cargo's job is to handle crates (for more information on Cargo, refer to the
    *Working with Cargo* section of [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Starting
    with Rust"), *Starting with Rust*); it creates a library project by default. You
    can install other crates into your project from the crates repository at [https://crates.io](https://crates.io);
    in the *Adding external crates to a project* section of this chapter, we will
    see how this is done.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo的职责是处理集合（有关Cargo的更多信息，请参阅[第1章](part0014.xhtml#aid-DB7S1 "第1章。从Rust开始")的*使用Cargo*部分，*从Rust开始*）；它默认创建一个库项目。您可以从[https://crates.io](https://crates.io)的集合存储库中将其他集合安装到您的项目中；在本章的*将外部集合添加到项目*部分，我们将看到如何做到这一点。
- en: Defining a module
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个模块
- en: Crates are the compiled entities that get distributed on machines to execute.
    All of the code of a crate is contained in an implicit root module. This code
    can then be split up by the developer into code units called modules, which in
    fact, form a hierarchy of submodules under the root module. This way the organization
    of our code can be greatly improved. An evident candidate for a module is the
    test code—we'll use this in the *The test module* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是编译后的实体，它们被分发到机器上执行。一个集合的所有代码都包含在一个隐式的根模块中。然后，开发者可以将这些代码分割成称为模块的代码单元，实际上，这些模块在根模块下形成了一个子模块的层次结构。这样，我们代码的组织结构可以得到极大的改善。一个明显的模块候选者是测试代码——我们将在*测试模块*部分使用它。
- en: Modules can also be defined inside other modules as the so-called nested modules.
    Modules do not get compiled individually; only crates get compiled. All the module's
    code is inserted into the crate's source file before compilation starts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可以定义在其他模块内部，称为嵌套模块。模块不会单独编译；只有集合会被编译。在编译开始之前，所有模块的代码都会插入到集合的源文件中。
- en: In the previous chapters, we used built-in modules, such as `io`, `str`, and
    `vec` from the `std` crate. The `std` crate contains many modules and functions
    that are used in real projects; the most common types, traits, functions, and
    macros (such as `println!`) are declared in the prelude module.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了内置的模块，例如来自`std`集合的`io`、`str`和`vec`。`std`集合包含了许多在真实项目中使用的模块和函数；最常见的类型、特性、函数和宏（如`println!`）都在导入模块中声明。
- en: 'A module typically contains a collection of code items such as traits, structs,
    methods, other functions, and even nested modules. The module''s name defines
    a namespace for all the objects that it contains. We define a module with the
    `mod` keyword and a lowercase name (such as `game1`) as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块通常包含一系列代码项，如特性、结构体、方法、其他函数，甚至嵌套模块。模块的名称定义了它包含的所有对象的命名空间。我们使用`mod`关键字和一个小写名称（例如`game1`）来定义一个模块，如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similar as in Java each file is a module, for every code file the compiler defines
    an implicit module, even when it does not contain the `mod` keyword. As we will
    see in the *Importing modules and file hierarchy* section, such a code file can
    be imported into the current code file with `mod` filename. Suppose `game1` is
    the name of a module that contains a `func2` function. If you want to use this
    function in a code that is external to this module, you would address it as `game1::func2`.
    However, whether this is possible will depend on the visibility of `func2`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java类似，每个文件都是一个模块，对于每个代码文件，编译器都会定义一个隐式模块，即使它不包含`mod`关键字。正如我们将在*导入模块和文件层次结构*部分中看到的那样，这样的代码文件可以使用`mod`文件名导入到当前代码文件中。假设`game1`是一个包含`func2`函数的模块的名称。如果你想在模块外部的代码中使用这个函数，你应该将其地址指定为`game1::func2`。然而，这是否可行将取决于`func2`的可见性。
- en: The visibility of items
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目的可见性
- en: 'Items in a module are by default, only visible in the module itself; they are
    private to the module. If you want to make an item callable from a code that is
    external to the module, you must explicitly indicate this by prefixing the item
    with `pub` (which stands for public). In the following code, trying to call `func1()`
    is not allowed by the compiler: ``error: function `func1` is private:``.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '模块中的项目默认情况下只在模块内部可见；它们对模块是私有的。如果你想让一个项目可以从模块外部的代码中调用，你必须通过在项目前加上`pub`（代表公共）来显式地表示这一点。在以下代码中，尝试调用`func1()`是不允许的，编译器会报错：`error:
    函数`func1`是私有的：`'
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, if you call `func2()`, it will work without any problem because it
    is public, and this prints out: `You called func2 in game1!`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你调用`func2()`，它将没有任何问题，因为它被声明为公共的，并且会打印出：`你在game1中调用了func2！`
- en: 'A function in a nested module can only be called if it is public, provided
    the nested module itself is declared public, as shown in this code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套模块中的函数只有在嵌套模块本身被声明为公共的情况下才能被调用，如下代码片段所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It prints out: `You called subfunc1 in subgame1!`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印出：`你在subgame1中调用了subfunc1！`
- en: A function in a module must be prefixed with its module name when it is called.
    This distinguishes it from another function with the same name so that no name
    conflicts occur.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中调用的函数必须用其模块名称作为前缀。这可以将其与具有相同名称的另一个函数区分开来，以避免名称冲突。
- en: 'When a struct is accessed from outside the module in which it is defined, it
    is only visible when it is declared with `pub`. Moreover, its fields are private
    by default, so you have to explicitly declare as `pub` the fields that you want
    to be visible outside. This is the encapsulation property (also called information
    hiding) from traditional object-oriented languages. In the following example,
    the name and age fields of the `Magician` struct belong to the public interface
    but `power` does not:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当从定义它的模块外部访问结构体时，它只有在声明为`pub`时才可见。此外，它的字段默认是私有的，所以你必须显式声明为`pub`的字段，以便它们可以在模块外部可见。这是传统面向对象语言中的封装属性（也称为信息隐藏）。在以下示例中，`Magician`结构体的`name`和`age`字段属于公共接口，但`power`字段不属于：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So this statement:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个语句：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This leads to the compiler error: `field ''power'' of struct ''game1::Magician''
    is private`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致编译器错误：`field 'power' of struct 'game1::Magician' is private`
- en: 'Perform the following exercise:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: Does this mean that we cannot make instances from a struct with private fields?
    Try to think of a way around this. (As a hint, think about a constructor-like
    `new` function; refer to `Chapter 7/code/priv_struct.rs`.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们不能从具有私有字段的`struct`中创建实例？试着想一个绕过这个问题的方法。（作为一个提示，想想类似于构造函数的`new`函数；参考`Chapter
    7/code/priv_struct.rs`。）
- en: Importing modules and file hierarchy
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入模块和文件层次结构
- en: The `use` keyword in `use game1::func2;` imports a `func2` function from the
    `game1` module so that it can be simply called with its name, `func2()`. You can
    even give it a shorter name with `use game1::func2` as `gf2`; so that it can be
    called as `gf2()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`use game1::func2;`中使用`use`关键字从`game1`模块导入一个`func2`函数，以便可以简单地使用其名称`func2()`来调用它。你甚至可以用`use
    game1::func2`给它一个更短的名字，比如`gf2`；这样就可以调用为`gf2()`。
- en: When the `game1` module contains two (or more) functions such as `func2` and
    `func3` that we want to import, this can be done with `use game1::{func2, func3};`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当`game1`模块包含两个（或更多）我们想要导入的函数，如`func2`和`func3`时，可以使用`use game1::{func2, func3};`来完成。
- en: 'If you want to import all the (public) functions of the `game1` module, you
    can do it with `*`: `use game1::*;`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要导入`game1`模块的所有（公共）函数，你可以使用`*`：`use game1::*;`。
- en: However, using such a global import is not the best practice, except in modules
    for testing. The main reason for this is that a global import makes it harder
    to see where names are bound. Furthermore, they are forwards-incompatible, since
    new upstream exports can clash with existing names.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在测试模块之外，使用这样的全局导入并不是最佳实践。主要原因是一个全局导入使得难以看到名称的绑定位置。此外，它们与未来的版本不兼容，因为新的上游导出可能与现有名称冲突。
- en: Inside a module, `self::` and `super::` can be prepended to a path similar to
    `game1::func2` to distinguish between a function in the current module itself
    and a function in the parent scope, outside of the module. The `use` statements
    are preferably written at the top of the code file, so that they work for the
    whole of the code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内部，`self::`和`super::`可以添加到类似于`game1::func2`的路径前面，以区分当前模块本身中的函数和模块外部父作用域中的函数。`use`语句最好写在代码文件的最顶部，这样它们就可以作用于整个代码。
- en: 'In the previous example, the module was defined in the main source file itself;
    in most cases, a module will be defined in another source file. So, how do we
    import such modules? In Rust, we can insert the entire contents of a module''s
    source file into the current file by declaring the module at the top of the code
    (but after any `use` statements) like this: `mod modul1;`, this can be optionally
    preceded by `pub`. This statement will look for a `modul1.rs` file in the same
    folder as the current source file and import its code within the current code
    inside a `modul1` module. If a `modul1.rs` file is not found, it will look for
    a `mod.rs` file in the `modul1` subfolder and insert its code.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，模块是在主源文件本身中定义的；在大多数情况下，模块将在另一个源文件中定义。那么，我们如何导入这样的模块呢？在Rust中，我们可以通过在代码顶部（但在任何`use`语句之后）声明模块来将整个模块的源文件内容插入到当前文件中，如下所示：`mod
    modul1;`，这个声明可以可选地前面加上`pub`。这个语句将在当前源文件相同的文件夹中查找`modul1.rs`文件，并在当前代码中的`modul1`模块内导入其代码。如果没有找到`modul1.rs`文件，它将在`modul1`子文件夹中查找`mod.rs`文件，并插入其代码。
- en: 'Here is a simple `import_modules.rs` example that contains the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的`import_modules.rs`示例，其中包含以下代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `modul1` subfolder, we have the `mod.rs` file that contains the following
    code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`modul1`子文件夹中，我们有一个包含以下代码片段的`mod.rs`文件：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `modul2.rs` file in the same folder as `import_modules.rs` contains the
    following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与`import_modules.rs`文件相同的文件夹中的`modul2.rs`文件包含以下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that these source files of the module don't contain the `mod` declaration
    anymore because they were already declared in `import_modules.rs`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些模块的源文件不再包含`mod`声明，因为它们已经在`import_modules.rs`中声明过了。
- en: 'Executing `import_modules` prints out the following output: `called func1 from
    modul1 and called func1 from modul2`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`import_modules`会打印出以下输出：`called func1 from modul1 and called func1 from modul2`。
- en: 'What happens if you simply call `func1()` in `main()`? Now, the compiler doesn''t
    know which `func1` to call, from `modul1` or from `modul2`, resulting in the error:
    `unresolved name ''func1''` message. However, if we add `use modul1::func1` and
    then call `func1()`, it will work as the ambiguity is resolved.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你简单地在`main()`中调用`func1()`会发生什么？现在，编译器不知道应该调用哪个`func1`，是从`modul1`还是从`modul2`，结果出现错误信息：`unresolved
    name 'func1'`。然而，如果我们添加`use modul1::func1`然后调用`func1()`，它将正常工作，因为歧义得到了解决。
- en: Importing external crates
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入外部crate
- en: In the *Traits* section of [Chapter 5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing
    Code with Higher-order Functions and Parametrization"), *Generalizing Code with
    Higher-order Functions and Parametrization*, we developed the `traits.rs` structs
    for `Alien`, `Zombie`, and `Predator` characters that implemented a `Monster`
    trait. The code file contained a `main()` function to make it executable. We will
    now incorporate this code (without the `main()` part) in a library project called
    monsters and see how we can call this code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0046.xhtml#aid-1BRPS1 "第5章。使用高阶函数和参数化泛化代码")的*特质*部分中，*使用高阶函数和参数化泛化代码*，我们为`Alien`、`Zombie`和`Predator`角色实现了`Monster`特质的`traits.rs`结构体。代码文件包含一个`main()`函数以使其可执行。我们现在将这个代码（不包括`main()`部分）整合到一个名为monsters的库项目中，看看我们如何调用这段代码。
- en: 'Create the project with cargo new monsters and create a folder structure in
    the `monsters/src/lib.rs` file with the `template` code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cargo new monsters 创建项目，并在 `monsters/src/lib.rs` 文件中创建一个带有 `template` 代码的文件夹结构：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Remove this code and replace it with the code from `traits.rs`, but omit the
    `main()` function. In addition, add a simple `print_from_monsters()` function
    to test whether you can call it from the library:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 删除此代码，并用来自 `traits.rs` 的代码替换它，但省略 `main()` 函数。此外，添加一个简单的 `print_from_monsters()`
    函数来测试是否可以从库中调用它：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then, compile the library with cargo build, producing a `libmonsters-hash.rlib`
    library file in the `target`/`debug` folder (where hash is a random string similar
    to `547968b7c0a4d435`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 cargo build 编译库，在 `target`/`debug` 文件夹中生成一个 `libmonsters-hash.rlib` 库文件（其中
    hash 是类似于 `547968b7c0a4d435` 的随机字符串）。
- en: 'Now, we create a `main.rs` file in the `src` folder to make an executable file
    that can call into our `monsters` library and copy the original `main()` code
    from `traits.rs` in it, adding a call to `print_from_monsters()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在 `src` 文件夹中创建一个 `main.rs` 文件，以创建一个可执行文件，该文件可以调用我们的 `monsters` 库，并将来自 `traits.rs`
    的原始 `main()` 代码复制到其中，并添加对 `print_from_monsters()` 的调用：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a common design pattern—a library project containing an executable program
    that can be used to demonstrate or test the library.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的设计模式——一个包含可执行程序的库项目，可以用来演示或测试库。
- en: 'The `cargo build` function will now compile both the projects if there are
    no problems. However, the code will not compile, and the compiler will give the
    error: `unresolved name ''print_from_monsters''` message, clearly the code for
    the function is not found.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo build` 函数现在在没有问题的情况下会编译两个项目。然而，代码将无法编译，编译器会给出错误信息：`未解析的名称 ''print_from_monsters''`，显然函数的代码没有找到。'
- en: 'The first thing that we have to do is make the library code available to our
    program, which can be done by placing the following statement at the start:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是让库代码对我们程序可用，这可以通过在开头放置以下语句来实现：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This statement will import all the (public) items contained in the crate monsters
    under a module with the same name. However, this is not enough; we must also indicate
    that the `print_from_monsters` function can be found in the `monsters` module.
    Indeed, the monsters crate creates an implicit module with the same name. So,
    we have to call our function as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句将导入包含在 crate monsters 中的所有（公共）项目，并在具有相同名称的模块下导入。然而，这还不够；我们必须还表明 `print_from_monsters`
    函数可以在 `monsters` 模块中找到。实际上，monsters crate 创建了一个具有相同名称的隐式模块。因此，我们必须按照以下方式调用我们的函数：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we get the error: `function ''print_from_monsters'' is private` message,
    which tells us that the function is found, but it is inaccessible. This is easy
    to fix. In the *Visibility of Items* section, we saw how to remedy this; we must
    prefix the function header with `pub`, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到错误：`函数 'print_from_monsters' 是私有的` 信息，这告诉我们函数已被找到，但无法访问。这很容易修复。在 *项目的可见性*
    部分，我们看到了如何解决这个问题；我们必须在函数头前加上 `pub`，如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, this part of our code works! Open a terminal, go (`cd`) to the `target/debug`
    folder and start the monsters executable. This will give the output as `Printing
    from crate monsters!`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们代码的这一部分可以正常工作！打开终端，进入 (`cd`) 到 `target/debug` 文件夹，并启动 monsters 可执行文件。这将输出
    `从 crate monsters 打印！`。
- en: You will see that `extern crate abc` (with `abc` a crate name) is often used
    in code, but you will never see `extern crate std;` why does this happen? The
    reason is that `std` is imported by default in every other crate. For the same
    reason, the contents of the prelude module are imported by default in to every
    module.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 `extern crate abc`（其中 `abc` 是一个 crate 名称）在代码中经常被使用，但你永远不会看到 `extern crate
    std;` 为什么会这样？原因是 `std` 在每个其他 crate 中默认导入。出于同样的原因，预置模块的内容在默认情况下导入到每个模块中。
- en: Exporting a public interface
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出公共接口
- en: 'The compiler throws the following error at us: `error: Zombie does not name
    a structure`. Clearly, the code for the `Zombie` struct is not found. Since this
    struct also resides in the monsters module, the solution to fix this is easy;
    prefix `Zombie` with `monsters::` as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器向我们抛出了以下错误：`错误：Zombie 没有命名结构`。显然，`Zombie` 结构体的代码没有找到。由于这个结构体也位于 monsters
    模块中，所以修复这个问题的解决方案很简单；在 `Zombie` 前加上 `monsters::`，如下所示：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another error: `struct ''Zombie'' is private`, makes it clear that we must
    mark the `Zombie` struct with `pub`, that is, `pub struct Zombie { … }`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误：`struct 'Zombie' 是私有的`，清楚地表明我们必须用 `pub` 标记 `Zombie` 结构体，即 `pub struct
    Zombie { … }`。
- en: 'Now, we will get an error on the line that contains `zmb1.noise()`: `error:
    type ''monsters::Zombie''` does not implement any method in scope named `''noise''`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们将在包含 `zmb1.noise()` 的行上得到一个错误：`error: type ''monsters::Zombie''` 不实现任何作用域内名为
    `''noise''` 的方法'
- en: 'The accompanying help note explains to us what to do and why we should do it:
    ``help: methods from traits can only be called if the trait is in scope; the following
    trait is implemented but not in scope, perhaps add a `use` for it:``'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的帮助说明向我们解释了我们应该做什么以及为什么应该这样做：``帮助：如果特质在作用域内，则可以调用特质的方法；以下特质已实现但不在作用域内，可能需要添加一个
    `use`：```
- en: '`help: candidate #1: use ''monsters::Monster''`. So, let''s add this to the
    following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`帮助：候选 #1：使用 ''monsters::Monster''`。因此，让我们将其添加到以下代码中：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last error—`error: trait ''Monster'' is private - source trait is private`—
    that we have to solve occurs at the `use` line. Again very logical; if we want
    to use a trait, it must be publicly visible: `p` `ub trait Monster { … }`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '我们必须解决的最后一个错误——`error: trait ''Monster'' is private - source trait is private`——发生在
    `use` 行。再次非常合乎逻辑；如果我们想使用一个特质，它必须对公众可见：`p` `ub trait Monster { … }`。'
- en: 'Now, cargo build is successful, if we execute monsters the output will be as
    follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果执行 `cargo build`，如果成功，输出将如下所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This makes it clear that the things we want to make visible in our module (or
    put in another way, that we want to export) must be annotated with `pub`; they
    form the interface that our module exposes to the outside world.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们想要在模块中使其可见的（或者说，我们想要导出的）内容必须用 `pub` 进行标注；它们构成了我们的模块对外界暴露的接口。
- en: Adding external crates to a project
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将外部 crate 添加到项目中
- en: How to use libraries written by others (that is, choose from the multitude of
    libraries available at [https://crates.io](https://crates.io)) in our project?
    Cargo makes this very easy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在我们的项目中使用他人编写的库（即，从[https://crates.io](https://crates.io)提供的众多库中选择）？Cargo
    使得这一过程变得非常简单。
- en: Suppose we want to use both the `log` and the `mac` libraries in the monsters
    project. The `log` function is a simple logging framework by the Rust Project
    Developers that gives us a number of macros such as `info!`, `warn!`, and `trace!`
    to log information messages. The `mac` function is an amazing collection of useful
    macros, which is maintained by Jonathan Reem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在怪物项目中同时使用 `log` 和 `mac` 库。`log` 函数是由 Rust 项目开发者提供的简单日志框架，它为我们提供了 `info!`、`warn!`
    和 `trace!` 等宏来记录信息消息。`mac` 函数是一个包含有用宏的惊人集合，由 Jonathan Reem 维护。
- en: 'To get these libraries, we need to edit our `Cargo.toml` configuration file
    and add a `[dependencies]` section when it isn''t already present. Beneath it,
    we specify the versions of the libraries that we want to use:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取这些库，我们需要编辑我们的 `Cargo.toml` 配置文件，并在尚未存在的情况下添加一个 `[dependencies]` 部分。在其下方，我们指定我们想要使用的库的版本：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A `*` character denotes that any version is okay, and the most recent version
    will be installed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 字符表示任何版本都可以，并将安装最新版本。'
- en: 'Save the file and, in the `monsters` folder, issue the `cargo build` command.
    Cargo will take care of locally installing and compiling the libraries:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，在 `monsters` 文件夹中，执行 `cargo build` 命令。Cargo 将负责本地安装和编译库：
- en: '![Adding external crates to a project](img/image00182.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![将外部 crate 添加到项目中](img/image00182.jpeg)'
- en: It will also automatically update the `Cargo.lock` file to register the installed
    versions of the libraries so that subsequent project builds will always use the
    same versions (here, `log v0.3.1` and `mac v0.0.1`). If you later want to update
    to the most recent version of a library, for example for the `log` library, do
    a cargo update `–p log` or a `cargo` update to update all libraries. This will
    download the latest crate versions for the crates that are indicated with the
    `*` version. If you want a higher version for a crate, change its version number
    in `Cargo.toml`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将自动更新 `Cargo.lock` 文件以注册已安装的库版本，以便后续的项目构建始终使用相同的版本（这里，`log v0.3.1` 和 `mac
    v0.0.1`）。如果您稍后想更新到某个库的最新版本，例如 `log` 库，请执行 `cargo update –p log` 或 `cargo update`
    以更新所有库。这将下载带有 `*` 版本的最新 crate 版本。如果您想要一个更高版本的 crate，请更改其在 `Cargo.toml` 中的版本号。
- en: 'Start using the libraries by importing their crates in the code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在代码中导入它们的 crate 来开始使用这些库：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `#[macro_use]` attribute allows the use of macros defined in the external
    crate. (See the next section for more information). Then, we can for example,
    use the `info!` macro from `crate mac` as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[macro_use]` 属性允许使用外部 crate 中定义的宏。（有关更多信息，请参阅下一节）。然后，例如，我们可以像下面这样使用 `crate
    mac` 中的 `info!` 宏：'
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The test module
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试模块
- en: 'Let''s apply this code organization to a module that contains our tests. In
    a larger project, tests are separated from the application code as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种代码组织应用到包含我们的测试的模块中。在一个更大的项目中，测试代码与应用程序代码分离如下：
- en: Unit tests are collected in a `test` module
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试被收集在`test`模块中
- en: Integration tests are collected in a `lib.rs` file in a `tests` directory
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试被收集在`tests`目录下的`lib.rs`文件中
- en: 'Let''s make a concrete example by using our `cube` function from [Chapter 3](part0032.xhtml#aid-UGI01
    "Chapter 3. Using Functions and Control Structures"), *Using Functions and Control
    Structures*, and start its project with cargo new cube. We must replace the code
    in `src\lib.rs` with this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用来自[第3章](part0032.xhtml#aid-UGI01 "第3章。使用函数和控制结构")的`cube`函数来做一个具体的例子，*使用函数和控制结构*，并使用`cargo
    new cube`开始其项目。我们必须用以下代码替换`src\lib.rs`中的代码：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`#[cfg(test)]` ensures that the test module is only compiled when testing.
    In the second line, we declare our `test` module, which is preceded by the `test`
    attribute. The code of this module goes into a `test.rs` file in the same folder:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[cfg(test)]`确保只有当进行测试时才会编译测试模块。在第二行，我们声明我们的`test`模块，它前面有`test`属性。这个模块的代码放入同一文件夹中的`test.rs`文件中：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We need to use `super::*` to import all the functions that need to test; here,
    this is cube.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`super::*`来导入所有需要测试的函数；这里，这是cube。
- en: 'Integration tests go into a `lib.rs` file in a tests folder:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试会放入一个位于测试文件夹中的`lib.rs`文件中：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we need to import the `cube` crate with an `extern` command and qualify
    the `cube` function name with its module name, `cube` (or else do a `use cube::cube;`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要使用`extern`命令导入`cube`包，并用其模块名`cube`（或者也可以使用`use cube::cube;`）来限定`cube`函数名。
- en: 'The test code will only be compiled and run when we give the `cargo test` command,
    which will give these results:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入`cargo test`命令时，测试代码才会被编译和运行，这将给出以下结果：
- en: '![The test module](img/image00183.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![测试模块](img/image00183.jpeg)'
- en: We can see that our two tests passed. The end of the output also shows that
    tests in the documentation are also executed if they are present.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的两个测试都通过了。输出结果的末尾还显示，如果存在，文档中的测试也会被执行。
- en: Macros
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: Macros are not new to you as we have already used them. Every time we called
    an expression that ended with an exclamation mark (`!`), we called a built-in
    macro; the `!` sign distinguishes it from a function. In our code until now, we
    have already used `println!`, `assert_eq!`, `panic!`, and `vec!` macros.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 宏对你来说并不陌生，因为我们已经使用过它们了。每次我们调用以感叹号（`!`）结尾的表达式时，我们都是在调用一个内置宏；感叹号符号将其与函数区分开来。到目前为止，在我们的代码中，我们已经使用了`println!`、`assert_eq!`、`panic!`和`vec!`宏。
- en: Why do we use macros?
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么要使用宏？
- en: Macros make powerful language or syntax extensions; therefore, they make metaprogramming
    possible. For example, Rust has a `regex!` macro that allows you to define regular
    expressions in your program, which are compiled while your code is compiled. This
    way the regular expressions are verified, they can be optimized at compile time,
    and there is no runtime overhead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 宏使得语言或语法扩展变得强大；因此，它们使得元编程成为可能。例如，Rust有一个`regex!`宏，允许你在程序中定义正则表达式，这些正则表达式在代码编译时被编译。这样，正则表达式得到验证，它们可以在编译时优化，并且没有运行时开销。
- en: 'Macros can capture repetitive or resembling code patterns and replace them
    with other source code: the macro expands the original code into new code. This
    expansion happens early in compilation, before any static checking is done, so
    the resulting code is compiled together with the original code. In this sense,
    they resemble Lisp macros much more than C macros. Rust macros allow you to write
    **Don''t Repeat Yourself** (**DRY**) code by factoring out the common parts of
    functions. However, a macro is at a higher level than a function because a macro
    allows you to generate the code for many functions at compile time.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 宏可以捕获重复或相似的代码模式，并用其他源代码来替换它们：宏将原始代码扩展成新代码。这种扩展发生在编译的早期阶段，在执行任何静态检查之前，因此生成的代码与原始代码一起编译。从这个意义上说，它们与Lisp宏比C宏更相似。Rust宏允许你通过提取函数的公共部分来编写**不要重复自己**（**DRY**）的代码。然而，宏比函数处于更高的层次，因为宏允许你在编译时为许多函数生成代码。
- en: A Rust developer can also write his/her own macros, replacing repetitive code
    with much simpler code and thereby automating tasks. On the other side of the
    spectrum, it could even make it possible to write domain-specific languages. Macro
    coding follows a specific set of declarative pattern-based rules. Rust's macro
    system is also hygienic, which means that no conflict is possible between the
    variables used in the macro and those outside the macro. Each macro expansion
    happens in a distinct syntax context, and each variable is tagged with the syntax
    context where it was introduced.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 开发者也可以编写自己的宏，用更简单的代码替换重复的代码，从而自动化任务。在光谱的另一端，它甚至可能使编写特定领域的语言成为可能。宏编码遵循一组特定的声明性基于模式的规则。Rust
    的宏系统也是卫生的，这意味着宏中使用的变量和宏外部的变量之间不可能发生冲突。每个宏展开都在一个独特的语法上下文中发生，每个变量都带有它在其中引入的语法上下文标签。
- en: Macro code itself is harder to understand than normal Rust code, so it is not
    that easy to make. However, you won't code macros every day; if a macro is tested,
    just use it. The full story of macro writing extends into advanced regions of
    Rust, but in the following sections, we will discuss the basic techniques to develop
    macros.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 宏代码本身比正常的 Rust 代码更难理解，因此编写起来并不容易。然而，你不会每天编写宏；如果宏经过测试，就使用它。宏编写的完整故事深入 Rust 的高级领域，但在接下来的章节中，我们将讨论开发宏的基本技术。
- en: Developing macros
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发宏
- en: 'The basic structure of a macro definition for a macro with the `mac1` name
    is of the following form:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `mac1` 的宏的基本结构如下所示：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The definition of a macro is also done through a macro, that is, the `macro_rules`
    macro! As you can see a macro is similar to a match block as it defines one or
    more rules for pattern matching, and each rule ends with a semicolon. Every rule
    consists of a pattern before the `=>` sign (which also called a matcher) that
    is replaced with the expansion part during compilation, and not while executing
    the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的定义也是通过宏来完成的，即 `macro_rules` 宏！正如你所见，宏类似于一个 match 块，因为它定义了一个或多个用于模式匹配的规则，并且每个规则都以分号结束。每个规则由
    `=>` 符号之前的模式组成（也称为匹配器），在编译期间替换为展开部分，而不是在执行代码时替换。
- en: 'The following `welcome!` macro expects no pattern and expands into a print
    statement by using the `println!` macro; this is simple, but it demonstrates how
    macros work:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `welcome!` 宏不期望任何模式，通过使用 `println!` 宏扩展为一个打印语句；这很简单，但它展示了宏是如何工作的：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is invoked by adding an exclamation sign (`!`) to its name:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过在其名称后添加一个感叹号（`!`）来调用：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This prints out: `Welcome to the Game!`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出：`欢迎来到游戏！`
- en: 'A matcher can contain an expression of the `$arg:frag` form:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器可以包含 `$arg:frag` 形式的表达式：
- en: The `$arg` function binds an `arg` meta-variable to a value when the macro is
    called. Variables used inside a macro such as `$arg`, are prefixed with a `$`
    sign to distinguish them from normal variables in the code.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当宏被调用时，`$arg` 函数将一个 `arg` 元变量绑定到一个值。在宏内部使用的变量，如 `$arg`，前面带有 `$` 符号，以区分代码中的普通变量。
- en: The `frag` function is a *fragment specifier* and can be either `expr`, `item`,
    `block`, `stmt`, `pat`, `ty` (type), `ident`, `path`, or `tt`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frag` 函数是一个 *片段指定器*，可以是 `expr`、`item`、`block`、`stmt`、`pat`、`ty`（类型）、`ident`、`path`
    或 `tt`。'
- en: (You can find more information on the meaning of these fragments in the official
    documentation at [http://doc.rust-lang.org/1.0.0/book](http://doc.rust-lang.org/1.0.0/book).)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: （你可以在官方文档中找到有关这些片段含义的更多信息，请参阅[http://doc.rust-lang.org/1.0.0/book](http://doc.rust-lang.org/1.0.0/book)。）
- en: 'Any other Rust literals (tokens) that appear in a matcher must match exactly.
    For example, the following `mac1` macro:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配器中出现的任何其他 Rust 文字（标记）都必须完全匹配。例如，以下 `mac1` 宏：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you call `mac1!(42);`, it will print out `arg is 42`. The `mac1` function
    looks at its argument, `42`, as an expression (`expr`) and binds `arg` to the
    value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `mac1!(42);` 时，它将打印出 `arg is 42`。`mac1` 函数将其参数 `42` 视为一个表达式（`expr`）并将 `arg`
    绑定到该值。
- en: 'Perform the following exercises:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: 'Write a `mac2` macro that triples its argument. Test it out for these arguments:
    5 and 2 + 3.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `mac2` 宏，使其参数乘以三。测试以下参数：5 和 2 + 3。
- en: Write a `mac3` macro that takes an identifier name and replaces it with a binding
    of that name to 42\. (As a hint, use `$arg:ident` instead of `$arg:expr; ident`
    is used for variable and function names.)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `mac3` 宏，它接受一个标识符名称，并用该名称的绑定替换它，绑定值为 42。（作为一个提示，使用 `$arg:ident` 而不是 `$arg:expr`；`ident`
    用于变量和函数名称。）
- en: Write a `mac4` macro that when invoked like `mac4!("Where am I?");`, prints
    out `start - Where am I? - end`. (Refer to the example code in `Chapter 7/exercises/macro_ex.rs`.)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `mac4` 宏，当像 `mac4!("Where am I?");` 这样调用时，打印出 `start - Where am I? - end`。（请参阅
    `第 7 章/exercises/macro_ex.rs` 中的示例代码。）
- en: Repetition
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复
- en: 'What would we do if there is more than one argument? We will enclose the pattern
    with a `$(...)*`, where `*` means zero or more (instead of `*`, you can use `+`,
    which means one or more). For example, the following `printall` macro invokes
    `println!` on each of its arguments, which can be of the arbitrary type and are
    separated by `a`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个参数怎么办？我们将模式用 `$(...)*` 包围起来，其中 `*` 表示零个或多个（而不是 `*`，你可以使用 `+`，表示一个或多个）。例如，以下
    `printall` 宏对其每个参数调用 `println!`，这些参数可以是任意类型，并且由 `a` 分隔：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When called with `printall!("hello", 42, 3.14);` it will print out: `hello
    / 42 / 3.14 /`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当用 `printall!("hello", 42, 3.14);` 调用时，它将打印出：`hello / 42 / 3.14 /`。
- en: In the example, each argument (separated by commas) is substituted by a corresponding
    invocation of `print!` that is separated by a `/`. Note that on the right-hand
    side, we have to make a code block of the resulting print statements by enclosing
    them in `{ }`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，每个参数（由逗号分隔）被替换为相应的 `print!` 调用，这些调用由 `/` 分隔。注意，在右侧，我们必须通过将它们括在 `{}` 中来创建结果打印语句的代码块。
- en: Creating a new function
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新函数
- en: 'Here is a `create_fn` macro to create a new function at compile time:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在编译时创建新函数的 `create_fn` 宏：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `stringify!` macro simply makes a string from its argument. Now, we can
    invoke this macro with `create_fn!(fn1);`. This statement does not sit inside
    `main()` or another function; it is transformed during compilation into the function
    definition. Then, a normal call to the `fn1()` function will call it, here printing
    `Called the function "fn1"()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringify!` 宏只是将其参数转换成字符串。现在，我们可以用 `create_fn!(fn1);` 调用这个宏。这个语句不在 `main()`
    或另一个函数内部；它在编译期间被转换成函数定义。然后，对 `fn1()` 函数的正常调用将调用它，这里打印 `Called the function "fn1"()`。'
- en: 'In the following `massert` macro, we mimic the behavior of the `assert!` macro,
    which does nothing when its expression argument is true but panics when it is
    false:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 `massert` 宏中，我们模仿了 `assert!` 宏的行为，当其表达式参数为真时什么也不做，但当其为假时引发恐慌：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For example, `massert!(1 == 42);` will print out `thread '<main>' panicked at
    'Assertion failed!'`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`massert!(1 == 42);` 将打印出 `thread '<main>' panicked at 'Assertion failed!'`。
- en: 'In the following statements, we test whether the `v` vector contains certain
    elements:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下语句中，我们测试 `v` 向量是否包含某些元素：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `unless` macro mimics an `unless` statement where a branch is executed
    if the `arg` condition is not true. For example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`unless` 宏模仿了一个 `unless` 语句，其中如果 `arg` 条件不为真，则执行分支。例如：'
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This should print out `v does not contain 25` because the condition is not true.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会打印出 `v does not contain 25`，因为条件不成立。
- en: 'This is also a one-line macro:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个单行宏：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last example combines the techniques that we have seen so far. In the *Attributes
    - Testing* section of [Chapter 3](part0032.xhtml#aid-UGI01 "Chapter 3. Using Functions
    and Control Structures"), *Using Functions and Control Structures*, we saw how
    to make a test function with the `#[test]` attribute. Let us create a `test_eq`
    macro that generates a test function when it is invoked with this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子结合了我们迄今为止看到的技术。在 [第 3 章](part0032.xhtml#aid-UGI01 "第 3 章。使用函数和控制结构") 的
    *属性 - 测试* 部分，*使用函数和控制结构*，我们看到了如何使用 `#[test]` 属性创建测试函数。让我们创建一个 `test_eq` 宏，当它被调用时，会生成一个测试函数：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The test function is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数如下：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also want a test that fails:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要一个失败的测试：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first argument of `test_eq` is the test''s name and the second and third
    arguments are values to be compared for equality, so in general, the format is:
    `test_eq!(name, left, right);`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_eq` 的第一个参数是测试的名称，第二个和第三个参数是要比较相等性的值，所以通常的格式是：`test_eq!(name, left, right);`。'
- en: Here, `name` is an identifier; `left` and `right` are expressions. Like the
    `create_fn` invocation, the `test_eq!` calls are written outside a function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name` 是一个标识符；`left` 和 `right` 是表达式。就像 `create_fn` 调用一样，`test_eq!` 调用是在函数外部编写的。
- en: 'Now, we can compose our macro as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样组合我们的宏：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can create the test runner by calling `rustc --test macros.rs`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `rustc --test macros.rs` 来创建测试运行器。
- en: 'When the macros executable is run, it prints out:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当宏可执行文件运行时，它将打印出：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A macro can also be recursive and call itself in the expansion branch. This
    is useful for processing tree-structured input, for example, when parsing HTML
    code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 宏也可以是递归的，并在展开分支中调用自身。这对于处理树状结构输入很有用，例如在解析HTML代码时。
- en: Using macros from crates
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用crates中的宏
- en: 'As we demonstrated at the end of the *Adding external crates to a project*
    section, loading all the macros from an external crate should done by preceding
    the extern crate `abc` with the `#[macro_use]` attribute. If you only need the
    `mac1` and `mac2` macros, you can write this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在“将外部crates添加到项目”部分的结尾所展示的，应该通过在`extern crate abc`前加上`#[macro_use]`属性来加载外部crate中的所有宏。如果你只需要`mac1`和`mac2`宏，你可以这样写：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the attribute is not present, no macros are loaded from `abc`. Moreover,
    inside the `abc` module, only macros defined with the `#[macro_export]` attribute
    can be loaded in another module. To distinguish macros with the same name in different
    modules, use the `$crate` variable in the macro. Within the code of a macro imported
    from an `abc` crate, the special `$crate` macro variable will expand to `::abc`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有该属性，则不会从`abc`加载任何宏。此外，在`abc`模块内部，只有使用`#[macro_export]`属性定义的宏可以在另一个模块中加载。为了区分不同模块中具有相同名称的宏，请在宏中使用`$crate`变量。在从`abc`crate导入的宏的代码中，特殊的`$crate`宏变量将展开为`::abc`。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to structure modules into crates to make our
    code more flexible and modular. Now, you also know the basic rules for writing
    macros for more compact and less repetitive code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将模块结构化到crates中，使我们的代码更加灵活和模块化。现在，你也知道了编写宏的基本规则，以使代码更加紧凑且重复性更低。
- en: In the following chapter, we will explore the power of Rust when it comes to
    the concurrent and parallel execution of code, and how Rust also preserves memory
    safety in this area.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Rust在代码并发和并行执行方面的强大功能，以及Rust如何在这一领域保持内存安全。
