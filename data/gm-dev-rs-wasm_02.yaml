- en: '*Chapter 1*: Hello WebAssembly'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*: 欢迎来到 WebAssembly'
- en: Let's cut to the chase – if you're holding this book, you probably already know
    you love Rust, and you think **WebAssembly** is a great way to deploy your Rust
    programs to the web. Good news – you're right! Rust and WebAssembly are a match
    made in programmer heaven, and while WebAssembly is still in its early days, game
    development is an ideal candidate for WebAssembly. I am excited to be guiding
    you through building a game for the web in Stack Overflow's "most-loved" language,
    Rust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直奔主题——如果你拿着这本书，你可能已经知道你喜欢 Rust，并且认为 **WebAssembly** 是将你的 Rust 程序部署到网页上的绝佳方式。好消息——你是对的！Rust
    和 WebAssembly 是程序员天堂中的完美搭配，尽管 WebAssembly 仍处于早期阶段，但游戏开发是 WebAssembly 的理想候选者。我很高兴能引导你使用
    Stack Overflow 的“最受欢迎”的语言 Rust 来构建网页游戏。
- en: 'This chapter is all about equipping yourself with the tools for the game development
    journey. In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于为你提供游戏开发旅程的工具。在本章中，我们将涵盖以下主题：
- en: What is WebAssembly?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 WebAssembly？
- en: Creating a Rust and WebAssembly project skeleton
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Rust 和 WebAssembly 项目的骨架
- en: Translating JavaScript code into Rust code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JavaScript 代码转换为 Rust 代码
- en: Drawing to the screen with HTML5 Canvas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML5 Canvas 绘制到屏幕上
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the project skeleton, you'll need to install `rustup` to
    install the Rust toolchains. This can be found at [https://rustup.rs/](https://rustup.rs/).
    While you can install Rust and its various toolchains without using the `rustup`
    tool, it's not trivial, and I won't be documenting it here. You'll also need an
    editor for writing Rust code, and while you can use virtually any editor with
    rust-analyzer, if you're new to writing Rust, I'd recommend Visual Studio Code
    and the Rust extension found at [https://bit.ly/3tAUyH2](https://bit.ly/3tAUyH2).
    It's easy to set up and works right out of the box.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随项目骨架，你需要安装 `rustup` 来安装 Rust 工具链。这可以在 [https://rustup.rs/](https://rustup.rs/)
    找到。虽然你可以使用 `rustup` 工具之外的方式安装 Rust 和其各种工具链，但这并不简单，我这里不会记录它。你还需要一个用于编写 Rust 代码的编辑器，虽然你可以使用几乎任何带有
    rust-analyzer 的编辑器，如果你是 Rust 编写的初学者，我推荐 Visual Studio Code 和可在 [https://bit.ly/3tAUyH2](https://bit.ly/3tAUyH2)
    找到的 Rust 扩展。它很容易设置，并且开箱即用。
- en: Finally, you'll need a web browser, and in this chapter, you'll need some familiarity
    with the terminal and **Node.js**. If you get stumped, the code for this chapter
    is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1).
    The final code for the entire book is in the main branch at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要一个网络浏览器，在本章中，你需要对终端和 **Node.js** 有一定的了解。如果你遇到困难，本章的代码可以在 [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1)
    找到。整本书的最终代码在主分支 [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3qMV44E](https://bit.ly/3qMV44E)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3qMV44E](https://bit.ly/3qMV44E)
- en: What is WebAssembly?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 WebAssembly？
- en: 'You picked up this book (thanks!) so in all likelihood, you have some idea
    of what WebAssembly is, but just in case, let''s grab a definition from [https://WebAssembly.org](https://WebAssembly.org):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择了这本书（谢谢！）所以很可能会对 WebAssembly 有一些了解，但以防万一，让我们从 [https://WebAssembly.org](https://WebAssembly.org)
    捕获一个定义：
- en: '"WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based
    virtual machine. Wasm is designed as a portable compilation target for programming
    languages, enabling deployment on the web for client and server applications."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '"WebAssembly（简称 Wasm）是一种基于栈的虚拟机的二进制指令格式。Wasm 被设计为编程语言的便携式编译目标，使得部署在客户端和服务器应用程序的网页上成为可能。"'
- en: In other words, **Wasm** is a binary format that we can compile other languages
    to so that we can run them in the browser. This is different than transpiling
    or source-to-source compiling, where languages such as TypeScript are converted
    into JavaScript for running in JavaScript environments. Those languages are still
    ultimately running JavaScript, whereas Wasm is bytecode. This makes it a smaller
    download and parsing and compiling steps are removed when running it, which can
    lead to significant performance improvements. But let's be honest – you're not
    using Rust and Wasm for the performance improvements, which aren't guaranteed
    anyway. You're using it because you like Rust.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，**Wasm**是一种二进制格式，我们可以将其编译为其他语言，以便在浏览器中运行。这与将语言如TypeScript转换为JavaScript进行源到源编译或转译不同，这些语言在JavaScript环境中运行时仍然是JavaScript。这些语言最终仍然是在运行JavaScript，而Wasm是字节码。这使得下载更小，并且在运行时去除了解析和编译步骤，这可以带来显著的性能提升。但说真的——你使用Rust和Wasm并不是为了性能提升，这些提升也并不保证。你使用它是因为你喜欢Rust。
- en: And that's okay!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 没关系！
- en: Rust has a great type system, excellent developer tooling, and a fantastic community.
    While WebAssembly was originally created with C and C++ in mind, Rust is a fantastic
    language for WebAssembly for all the reasons you love Rust and more. Now, for
    most of the web's existence, writing applications to run in a browser meant writing
    JavaScript, and over the years, JavaScript has evolved into a suitably modern
    language for that purpose. I'm not here to tell you that if you like JavaScript
    you should stop, but if you love Rust, you should absolutely start compiling to
    Wasm and running apps in the browser.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Rust拥有出色的类型系统、优秀的开发者工具和出色的社区。虽然WebAssembly最初是为C和C++设计的，但Rust是WebAssembly的绝佳语言，原因有很多，这些原因也是你喜爱Rust的原因。现在，对于Web存在的大部分时间来说，编写在浏览器中运行的应用程序意味着编写JavaScript，而且多年来，JavaScript已经发展成为一个适合该目的的现代语言。我并不是在这里告诉你，如果你喜欢JavaScript，你应该停止使用它，但如果你热爱Rust，你绝对应该开始编译为Wasm并在浏览器中运行应用程序。
- en: Important Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This book is focused on making web-based games with Rust and Wasm, but you can
    absolutely run Wasm apps in server-side environments such as Node.js. If you're
    interested in that, you can check out the book *Learn WebAssembly* by Mike Rourke,
    which can be found at [https://bit.ly/2N89prp](https://bit.ly/2N89prp), or the
    official `wasm-bindgen` guide at [https://bit.ly/39WC63G](https://bit.ly/39WC63G).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书专注于使用Rust和Wasm制作基于Web的游戏，但你绝对可以在Node.js等服务器端环境中运行Wasm应用程序。如果你对此感兴趣，你可以查看Mike
    Rourke的书籍《Learn WebAssembly》，可在[https://bit.ly/2N89prp](https://bit.ly/2N89prp)找到，或者查看官方的`wasm-bindgen`指南，可在[https://bit.ly/39WC63G](https://bit.ly/39WC63G)找到。
- en: Important Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This book assumes some familiarity with Rust, although you do not need to be
    an expert. If at any time you're confused by a Rust concept, I highly encourage
    you to stop and check *"the book"*, *The Rust Programming Language*, available
    for free at [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你对Rust有一定的了解，尽管你不需要成为专家。如果你在任何时候对Rust的概念感到困惑，我强烈建议你停下来查看*"这本书"*，《Rust编程语言》，可在[https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)免费获取。
- en: 'So, now that I''ve convinced you to do what you were already going to do anyway,
    let''s go over some of the tools you''ll need to write a game for the web in Rust:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我已经说服你去做你本来就要做的事情，让我们来看看你需要的一些工具，以便用Rust编写Web游戏：
- en: '`rustup`: Most likely you''re already using `rustup` if you''re writing Rust
    code. If you''re not, you should, as it''s the standard way to install Rust. It
    allows for easy installations of toolchains, Rust compilers, and even launches
    the Rust documentation. You''ll need it to install the **Wasm toolchain**, and
    you can install it from the previous link. The code in this book has been tested
    on Rust version 1.57.0.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustup`：如果你正在编写Rust代码，那么你很可能已经在使用`rustup`了。如果不是，你应该使用它，因为它是安装Rust的标准方式。它允许轻松安装工具链、Rust编译器，甚至可以启动Rust文档。你需要它来安装**Wasm工具链**，你可以从之前的链接中安装它。本书中的代码已在Rust版本1.57.0上进行了测试。'
- en: '**Node.js**: I know – I promised you that we''d be writing in Rust! We will,
    but this is still a web application and you''ll be using Node.js to run the application.
    I recommend installing the current long-term support version (**16.13.0** at the
    time of writing). Older versions of Node.js may not work with the package creation
    tools as expected. If you''re using Ubuntu Linux, be especially cautious when
    using the Debian distribution, which installs a very old version at this time.
    When in doubt, use tools for managing multiple versions, such as the **Node Version
    Manager** (**nvm**) tool for Linux/Mac or the corresponding nvm-windows tool for
    Windows, to ensure that you''re using the long-term release version. I use the
    asdf tool ([https://asdf-vm.com/](https://asdf-vm.com/)) for managing multiple
    versions myself, although I don''t usually recommend it to people that haven''t
    used a version management tool before.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**: 我知道——我承诺我们会用Rust来编写！我们会的，但这仍然是一个Web应用程序，你将使用Node.js来运行应用程序。我建议安装当前的长期支持版本（写作时为**16.13.0**）。较老的Node.js版本可能无法与包创建工具按预期工作。如果你使用Ubuntu
    Linux，在使用Debian发行版时要特别小心，因为它现在安装了一个非常旧的版本。如果有疑问，请使用管理多个版本的工具，如Linux/Mac的**Node
    Version Manager**（**nvm**）工具或Windows的相应nvm-windows工具，以确保你使用的是长期发布版本。我本人使用asdf工具（[https://asdf-vm.com/](https://asdf-vm.com/)）来管理多个版本，尽管我不太推荐那些之前没有使用过版本管理工具的人使用它。'
- en: '**webpack**: We''ll use webpack to bundle our application for release and run
    a development server. Most of the time, you won''t have to worry about it, but
    it''s there.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**webpack**: 我们将使用webpack来打包我们的应用程序以供发布并运行开发服务器。大多数时候，你不必担心它，但它是存在的。'
- en: Important Note
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: The current template uses webpack 4\. Make sure to check that when looking up
    documentation.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当前模板使用webpack 4。确保在查找文档时检查这一点。
- en: '`wasm-pack`: This is a Rust tool for building Rust-generated WebAssembly code.
    Like webpack, most of the time you won''t know it''s there, as it''s managed by
    webpack, and your Rust application will largely be managed by Rust build tools.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wasm-pack`: 这是一个用于构建由Rust生成的WebAssembly代码的Rust工具。像webpack一样，大多数时候你不会知道它的存在，因为它由webpack管理，你的Rust应用程序将主要由Rust构建工具管理。'
- en: '`wasm-bindgen`: This is one of the crates you''ll need to get to know to write
    Rust-generated WebAssembly code. One limitation of WebAssembly is that you cannot
    access the `wasm-bindgen` does is create those bindings and the boilerplate needed
    to call JavaScript functions from your Rust code, as well as provide tools to
    create bindings in the other direction so that JavaScript code can call back into
    the Rust code. We''ll cover the details of how `wasm-bindgen` works as we go through
    the book, but to avoid getting bogged down in details right now, you can just
    think of it as a library to call JavaScript from your Rust code.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wasm-bindgen`: 这是你需要了解的一个crate，以便编写由Rust生成的WebAssembly代码。WebAssembly的一个限制是，你不能访问`wasm-bindgen`创建的绑定以及调用JavaScript函数所需的样板代码，同时它还提供了创建反向绑定的工具，以便JavaScript代码可以回调到Rust代码。随着我们阅读本书，我们将详细介绍`wasm-bindgen`的工作原理，但为了避免现在就陷入细节，你可以将其视为一个库，用于从Rust代码中调用JavaScript。'
- en: '`web-sys`: This is a crate made up of many pre-generated bindings, using `wasm-bindgen`,
    for the web. We''ll use `web-sys` to call browser APIs such as the canvas and
    `requestAnimationFrame`. This book assumes at least a passing familiarity with
    web development but doesn''t require expertise in this area, and in fact, one
    of the advantages of game development in Rust is that we can just treat the browser
    as a platform library that we call functions on. The `web-sys` crate means we
    don''t have to create all those bindings ourselves.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web-sys`: 这是一个由许多预生成的绑定组成的crate，使用`wasm-bindgen`为Web创建。我们将使用`web-sys`来调用浏览器API，如canvas和`requestAnimationFrame`。本书假设您至少对Web开发有一定的了解，但不需要在这个领域有专业知识，实际上，Rust游戏开发的一个优点就是我们只需将浏览器视为一个平台库，在上面调用函数。`web-sys`
    crate意味着我们不必自己创建所有这些绑定。'
- en: '`Canvas`: HTML Canvas is a `<canvas>` browser element, such as headers or paragraphs,
    only it allows you to draw directly to it. This is how we can make a video game!
    There are many ways to draw to the canvas, including `WebGL` and `WebGPU`, but
    we''re going to use the built-in Canvas API for most of this project. While this
    isn''t the absolute fastest way of making a game, it''s fast enough for learning
    purposes and avoids adding more technologies to our stack.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Canvas`：HTML Canvas 是一个 `<canvas>` 浏览器元素，例如标题或段落，但它允许你直接在其上绘制。这就是我们制作视频游戏的方法！有许多方法可以将内容绘制到画布上，包括
    `WebGL` 和 `WebGPU`，但我们将使用此项目的大部分内置 Canvas API。虽然这不是制作游戏的绝对最快方式，但对于学习目的来说足够快，并且避免了向我们的技术栈添加更多技术。'
- en: Finally, while googling `web-sys`, `web-bindgen`, or other Rust packages for
    WebAssembly, you are likely to come across references to `cargo-web` and `stdweb`.
    While both of those projects were important to the development of Rust as a WebAssembly
    source, neither has been updated since 2019 and can be safely ignored. Now that
    we know the tools we'll be using, let's start building our first Rust project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在搜索 `web-sys`、`web-bindgen` 或其他用于 WebAssembly 的 Rust 包时，你可能会遇到对 `cargo-web`
    和 `stdweb` 的引用。虽然这两个项目对于 Rust 作为 WebAssembly 源的开发很重要，但它们自 2019 年以来都没有更新，可以安全忽略。现在我们已经知道了我们将使用的工具，让我们开始构建我们的第一个
    Rust 项目。
- en: A Rust project skeleton
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 Rust 项目骨架
- en: Important Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: These directions are based on the status of `rust-webpack-template` at the time
    of writing. It's likely to have changed at the time of reading this, so pay close
    attention to the changes we are making. If they don't make sense, check the documents
    for `wasm-pack` and use your best judgment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些说明是基于撰写时 `rust-webpack-template` 的状态。在阅读此内容时，它可能已经发生变化，所以请密切关注我们所做的更改。如果它们没有意义，请检查
    `wasm-pack` 的文档，并使用你的最佳判断。
- en: 'At this point, I''m going to assume you''ve installed `rustup` and Node.js.
    If you haven''t, go ahead and follow the instructions for your platform to install
    them, and then follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我将假设你已经安装了 `rustup` 和 Node.js。如果你还没有安装，请按照你平台的说明进行安装，然后按照以下步骤操作：
- en: '**Initialize the project**'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化项目**'
- en: 'Let''s start by creating a project skeleton for your application, which will
    be the Rust webpack Template from the Rust Wasm group. It''s found on GitHub at
    [https://github.com/rustwasm/rust-webpack-template](https://github.com/rustwasm/rust-webpack-template),
    but you don''t want to download it. Instead, use `npm init` to create it, like
    this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为你的应用程序创建一个项目骨架，它将是 Rust Wasm 小组的 Rust webpack 模板。它可以在 GitHub 上找到 [https://github.com/rustwasm/rust-webpack-template](https://github.com/rustwasm/rust-webpack-template)，但你不需要下载它。相反，使用
    `npm init` 来创建它，如下所示：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下内容：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Congratulations! You have created your project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经创建了你的项目。
- en: '**Install dependencies**'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装依赖项**'
- en: 'You can install the dependencies with `npm`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `npm` 安装依赖项：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you prefer to use `yarn`, you can, with the exception of the `npm init` command.
    I'll be using `npm` for this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用 `yarn`，你可以，除了 `npm init` 命令之外。我将在这本书中使用 `npm`。
- en: '**Run the server**'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行服务器**'
- en: 'After the installation completes, you can now run a development server with
    `npm run start`. You may see an error, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你现在可以使用 `npm run start` 运行开发服务器。你可能看到如下错误：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If that happens, you'll need to install `wasm-pack` manually.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，你需要手动安装 `wasm-pack`。
- en: '**Install wasm-pack**'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装 wasm-pack**'
- en: 'On Linux and macOS systems `wasm-pack` is installed with a simple cURL script:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 系统上，`wasm-pack` 可以通过一个简单的 cURL 脚本安装：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Windows users have a separate installer that can be found at [https://rustwasm.github.io](https://rustwasm.github.io).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户有一个单独的安装程序，可以在 [https://rustwasm.github.io](https://rustwasm.github.io)
    找到。
- en: '**Run the server – take two**'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行服务器 – 第二部分**'
- en: 'Now that `wasm-pack` is installed, webpack can use it, and you should be able
    to run the app:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `wasm-pack` 已经安装，webpack 可以使用它，你应该能够运行应用程序：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you see `｢``wdm``｣``: Compiled successfully.` , you can browse your app
    at `http://localhost:8080`. Okay, yes, it''s a blank page, but if you open the
    developer tools console, you should see the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '当你看到 `｢``wdm``｣``: 编译成功。` 时，你可以在 `http://localhost:8080` 浏览你的应用程序。好吧，是的，它是一个空白页面，但如果你打开开发者工具控制台，你应该会看到以下内容：'
- en: '![Figure 1.1 – Hello WebAssembly!](img/Figure_1.01_B17151.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – Hello WebAssembly！](img/Figure_1.01_B17151.jpg)'
- en: Figure 1.1 – Hello WebAssembly!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Hello WebAssembly！
- en: You've got the application running in the browser, but the Rust ecosystem updates
    faster than the template you used can keep up.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将应用程序在浏览器中运行，但 Rust 生态系统更新速度比你所使用的模板能够跟上得更快。
- en: '**Update the Rust edition**'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新 Rust 版本**'
- en: 'The latest Rust edition, with the most recent Rust idioms and conventions,
    is 2021\. This is changed in the generated `Cargo.toml` file in the `package`
    section, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的 Rust 版本，包含最新的 Rust 习惯用法和约定，是 2021 版。这在生成的 `Cargo.toml` 文件中的 `package` 部分进行了更改，如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is only the `edition` field that is changed here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只更改了 `edition` 字段。
- en: '**Update the dependencies**'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新依赖**'
- en: 'The dependencies in the generated `Cargo.toml` file are not going to be the
    latest and greatest unless you happened to pull the template down the moment it
    was updated. Since neither of us is that lucky, you''re going to want to open
    up that file and modify the dependencies to the following. Please note that the
    ellipses are just there to mark a gap in the file and are not meant to be typed
    in:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你恰好在模板更新时下载了它，否则生成的 `Cargo.toml` 文件中的依赖项不会是最新的和最好的。由于我们两个都不那么幸运，你将需要打开该文件并修改依赖项到以下内容。请注意，省略号只是用来标记文件中的空白，并不需要输入：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Those are the versions I used while writing this book. If you're feeling adventurous,
    you can go to [http://crates.io](http://crates.io) and find the most recent version
    of each dependency, which is what I would do, but I am a glutton for punishment.
    You're probably smarter than me and will use the versions specified here so that
    the sample code works.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我写这本书时使用的版本。如果你喜欢冒险，你可以去 [http://crates.io](http://crates.io) 找到每个依赖项的最新版本，这正是我会做的，但我是个受苦的贪吃鬼。你可能比我聪明，所以你会使用这里指定的版本，以确保示例代码能正常工作。
- en: '**Update console_error_panic_hook**'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新 console_error_panic_hook**'
- en: '`console_error_panic_hook` is a very useful crate during the development of
    a WebAssembly application. It takes panics in Rust code and forwards them to the
    console so that you can debug them. The current template attempts to hide it behind
    a feature flag, but unfortunately, there''s a bug and it doesn''t work. Remember
    to double-check your generated code; if it doesn''t look like what I''ve reproduced
    here, the bug may have been fixed, but in the meantime, delete the following code
    (still in `Cargo.toml`).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`console_error_panic_hook` 是在 WebAssembly 应用程序开发期间非常实用的 crate。它将 Rust 代码中的
    panic 转发到控制台，以便你可以调试它们。当前的模板试图通过功能标志将其隐藏起来，但不幸的是，有一个错误，它不起作用。请记住仔细检查你生成的代码；如果它看起来不像我在这里复制的样子，那么错误可能已经被修复，但在此期间，请删除以下代码（仍然在
    `Cargo.toml` 中）。'
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then add the to the [dependencies] section, under wasm-bindgen is a good spot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将它添加到 [dependencies] 部分，在 wasm-bindgen 下方是一个好位置：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Later, we'll make this a conditional dependency so that you don't deploy it
    during release builds, but for now, this is enough progress. Who wants to continue
    messing with `config` files anyway? I want to draw stuff to the screen!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将将其作为一个条件依赖项，这样你就不需要在发布构建时部署它，但到目前为止，这已经足够进步了。谁还愿意继续与 `config` 文件纠缠呢？我想在屏幕上绘制东西！
- en: Tip
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'While this application uses an `npm init` template to create itself, you can
    use its output to create a `cargo generate` template so that you don''t have to
    redo these changes every time you create an application, simply by creating a
    `git` repository. Of course, if you do that, you''ll fall behind changes to the
    `rust-webpack` template, so it''s a trade-off. If you''re curious about using
    `cargo generate` to create your own templates, you can find more information here:
    [https://bit.ly/3hCFWTs](https://bit.ly/3hCFWTs).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个应用程序使用一个 `npm init` 模板来创建自身，但你也可以使用它的输出创建一个 `cargo generate` 模板，这样你就不必每次创建应用程序时都重做这些更改，只需创建一个
    `git` 仓库即可。当然，如果你这么做，你将落后于 `rust-webpack` 模板的更新，所以这是一个权衡。如果你对使用 `cargo generate`
    来创建自己的模板感兴趣，你可以在这里找到更多信息：[https://bit.ly/3hCFWTs](https://bit.ly/3hCFWTs)。
- en: Drawing to the canvas
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制到画布上
- en: To write our game in Rust, we're going to need to draw to the screen, and for
    that, we'll use the HTML Canvas element using the 2D context. What the canvas
    provides is an API for drawing directly to the screen, without knowledge of WebGL
    or using an external tool. It's not the fastest technology in the world but it's
    perfectly suitable for our small game. Let's start converting our Rust app from
    *"Hello World"* to an application that draws a **Sierpiński triangle**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要用 Rust 编写我们的游戏，我们需要在屏幕上绘制图形，为此，我们将使用 HTML Canvas 元素和 2D 上下文。Canvas 提供了一个直接在屏幕上绘制的
    API，无需了解 WebGL 或使用外部工具。虽然这不是世界上速度最快的科技，但对于我们的小型游戏来说，它完全适用。让我们开始将我们的 Rust 应用从 *"Hello
    World"* 转换为能够绘制 **Sierpiński 三角形** 的应用程序。
- en: Important Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The Sierpiński triangle is a fractal image that is created by drawing a triangle,
    then subdividing that triangle into four triangles, and then subdividing those
    triangles into four triangles, and so on. It sounds complicated but, as with many
    fractals, is created from only a few lines of math:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Sierpiński 三角形是一种通过绘制一个三角形，然后将该三角形细分为四个三角形，接着再将这些三角形细分为四个三角形，以此类推而创建的分形图像。听起来很复杂，但就像许多分形一样，它仅由几行数学公式构成：
- en: '**Add the canvas**'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加画布**'
- en: 'Canvas is an HTML element that lets us draw to it freely, making it an ideal
    candidate for games. Indeed, at the time of writing, Adobe Flash is officially
    dead, and if you see a game on the internet, be it 2D or 3D, it''s running in
    a `canvas` element. Canvas can use WebGL or WebGPU for games, and WebAssembly
    will work quite well with those technologies, but they are out of the scope of
    this book. We''ll be using the built-in Canvas 2D API and its 2D context. This
    means you won''t have to learn a shading language, and we''ll be able to get images
    on the screen very quickly. It also means that if you need to, you can find excellent
    documentation on the **Mozilla Developer Network** (**MDN**) Web Docs website:
    [https://mzl.la/3tX5qPC](https://mzl.la/3tX5qPC).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 是一个让我们可以自由绘制的 HTML 元素，使其成为游戏的理想选择。实际上，在撰写本文时，Adobe Flash 已经正式退役，如果你在网上看到一款游戏，无论是
    2D 还是 3D，它都是在 `canvas` 元素中运行的。Canvas 可以用于游戏中的 WebGL 或 WebGPU，WebAssembly 也会与这些技术很好地配合，但它们超出了本书的范围。我们将使用内置的
    Canvas 2D API 和其 2D 上下文。这意味着你不需要学习着色语言，我们能够非常快速地将图像显示在屏幕上。这也意味着，如果你需要的话，你可以在 **Mozilla
    开发者网络**（**MDN**）Web 文档网站上找到优秀的文档：[https://mzl.la/3tX5qPC](https://mzl.la/3tX5qPC)。
- en: To draw to the canvas, we'll need to add it to the web page. Open up `static/index.html`
    and add underneath `<body> tag <canvas id="canvas" tabindex="0" height="600" width="600">Your
    browser does not support the canvas.</canvas>`. The width and height are pretty
    arbitrary but seem appropriate for now. The "`Your browser does not support the
    canvas.`" message will show up on browsers that don't support HTML Canvas, but
    there aren't many of those anymore.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在画布上绘制图形，我们需要将其添加到网页中。打开 `static/index.html` 文件，在 `<body>` 标签下添加 `<canvas id="canvas"
    tabindex="0" height="600" width="600">您的浏览器不支持 canvas。</canvas>`。宽度和高度相当随意，但看起来现在很合适。"您的浏览器不支持
    canvas。" 这条消息将在不支持 HTML Canvas 的浏览器上显示，但现在已经很少见了。
- en: Important Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure you don't delete the `<script>` tag. That's running the JavaScript
    and WebAssembly you're building in this project!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要删除 `<script>` 标签。它正在运行你在这个项目中构建的 JavaScript 和 WebAssembly！
- en: '**Clean up errors**'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**清理错误**'
- en: 'Finally, we get to write some Rust code! Well, we get to delete some Rust code
    anyway. In the `src/lib.rs` file, you''ll see a function named `main_js()` with
    the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始编写一些 Rust 代码了！好吧，我们至少可以删除一些 Rust 代码。在 `src/lib.rs` 文件中，你会看到一个名为 `main_js()`
    的函数，其代码如下：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can go ahead and remove the comments and the `[cfg(debug_annotations)]`
    annotation. For the time being, we'll leave that running in our build and will
    remove it when preparing for production with a feature flag.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续删除注释和 `[cfg(debug_annotations)]` 注解。目前，我们将保留它在构建中运行，并在准备生产时使用功能标志将其移除。
- en: Important Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you''re seeing an error in your editor that says the `console::log_1(&JsValue::from_str("Hello
    world!"))` code is missing an unsafe block, don''t worry – that error is wrong.
    Unfortunately, it''s a bug in rust-analyzer that''s been addressed in this issue:
    [https://bit.ly/3BbQ39m](https://bit.ly/3BbQ39m). You''ll see this error with
    anything that uses procedural macros under the hood. If you''re using an editor
    that supports experimental settings, you may be able to fix the problem; check
    the `rust-analyzer.experimental.procAttrMacros` setting. When in doubt, check
    the output from `npm run start`, as that is the more accurate source for compiler
    errors.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编辑器中出现了错误，说 `console::log_1(&JsValue::from_str("Hello world!"))` 代码缺少一个不安全块，不要担心——这个错误是错误的。不幸的是，这是
    rust-analyzer 中的一个错误，已经在这次问题中得到了解决：[https://bit.ly/3BbQ39m](https://bit.ly/3BbQ39m)。你会在任何使用底层过程宏的东西上看到这个错误。如果你使用的编辑器支持实验性设置，你可能能够解决这个问题；检查
    `rust-analyzer.experimental.procAttrMacros` 设置。如果有疑问，请检查 `npm run start` 的输出，因为这是编译器错误的更准确来源。
- en: Tip
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you diverge from this book and decide to deploy, go to [*Chapter 10*](B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226),
    *Continuous Deployment*, and learn how to hide that feature behind a feature flag
    in release mode, so you don't deploy code you don't need into production.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你偏离这本书并决定部署，请转到 [*第10章*](B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226)，*持续部署*，学习如何在发布模式下通过功能标志隐藏该功能，这样你就不需要将不需要的代码部署到生产环境中。
- en: 'Removing that code will remove the `warning: Found ''debug_assertions'' in
    ''target.''cfg(...)''.dependencies''.` message on startup of the app. At this
    point, you may have noticed that I''m not telling you to restart the server after
    changes, and that''s because `npm start` runs the `webpack-dev-server`, which
    automatically detects changes and then rebuilds and refreshes the app. Unless
    you''re changing the webpack config, you shouldn''t have to restart.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '删除这段代码将在应用程序启动时移除 `warning: Found ''debug_assertions'' in ''target.''cfg(...)''.dependencies''.`
    消息。此时，你可能已经注意到我没有告诉你更改后要重新启动服务器，这是因为 `npm start` 运行 `webpack-dev-server`，它会自动检测更改，然后重新构建并刷新应用程序。除非你正在更改
    webpack 配置，否则你不需要重新启动。'
- en: The current code
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前代码
- en: Up to now, I've been telling you what to do, and you've been blindly doing it
    because you're following along like a good reader. That's very diligent of you,
    if a little trusting, and it's time to take a look at the current source and see
    just what we have in our WebAssembly library. First, let's start with the `use`
    directives.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直都在告诉你该做什么，而你一直在盲目地做，因为你像一位好读者一样跟随着。你非常勤奋，虽然有点过于信任，但现在该看看当前源代码，看看我们的
    WebAssembly 库里到底有什么。首先，让我们从 `use` 指令开始。
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first import is the `prelude` for `wasm_bindgen`. This brings in the macros
    you'll see shortly, and a couple of types that are pretty necessary for writing
    Rust for the web. Fortunately, it's not a lot, and shouldn't pollute the namespace
    too much.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个导入是 `wasm_bindgen` 的 `prelude`。这会引入你很快就会看到的宏，以及一些对于编写 Web Rust 非常必要的类型。幸运的是，这并不多，而且不应该过多地污染命名空间。
- en: Important Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '"`*`'' syntax and import everything from a given module. If the module has
    a lot of exported names, you have now those same names in your project, and they
    aren''t obvious when you''re coding. If, for instance, `wasm_bindgen::prelude`
    had a function named `add` in it and you also had a function named `add` in your
    namespace, they would collide. You can work around this by using explicit namespaces
    when you call the functions, but then why use `*` in the first place? By convention,
    many Rust packages have a module named `prelude`, which can be imported via `*`
    for ease of use; other modules should be imported with their full name.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `*` 语法并从给定的模块导入所有内容。如果模块有很多导出的名称，你现在在你的项目中也有这些相同的名称，并且在编码时并不明显。例如，如果 `wasm_bindgen::prelude`
    中有一个名为 `add` 的函数，而你命名空间中也有一个名为 `add` 的函数，它们就会冲突。你可以通过在调用函数时使用显式命名空间来解决这个问题，但为什么要一开始就使用
    `*` 呢？按照惯例，许多 Rust 包都有一个名为 `prelude` 的模块，可以通过 `*` 导入以方便使用；其他模块应该使用它们的完整名称导入。
- en: The other import is `web_sys::console`, which brings in the `console` namespace
    from `web_sys`, which in turn mimics the `console` namespace in JavaScript. This
    is a good time to talk a little more in detail about what these two modules do.
    I've said it before but it probably bears repeating – `wasm_bindgen` provides
    the capability to bind JavaScript functions so you can call them in WebAssembly
    and to expose your WebAssembly functions to JavaScript. There's that language
    again, the one we're trying to avoid by writing Rust, but it can't be avoided
    because we're working in a browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的是 `web_sys::console`，它从 `web_sys` 中引入了 `console` 命名空间，而 `web_sys` 又模仿了
    JavaScript 中的 `console` 命名空间。现在是详细讨论这两个模块功能的好时机。我之前已经说过，但可能需要重复一遍 —— `wasm_bindgen`
    提供了绑定 JavaScript 函数的能力，这样你就可以在 WebAssembly 中调用它们，并且可以将你的 WebAssembly 函数暴露给 JavaScript。又是那种语言，我们通过编写
    Rust 来试图避免的语言，但在这里我们无法避免，因为我们是在浏览器中工作的。
- en: In fact, one of the limitations of WebAssembly is that it cannot manipulate
    the DOM, which is a fancy way of saying that it can't change the web page. What
    it can do is call functions in JavaScript, which in turn do that work. In addition,
    JavaScript knows nothing about your WebAssembly types, so any data that is passed
    to a JavaScript object is marshaled into shared memory and then pulled back out
    by JavaScript so that it can turn it into something it understands. This is a
    LOT of code to write over and over again, and that is what the `wasm-bindgen`
    crate does for you. Later, we'll use it to bind our own custom bindings to third-party
    JavaScript code, but what about all the functions already built into the browser,
    such as `console.log`? That's where `web-sys` comes in. It uses `wasm-bindgen`
    to bind to all the functions in the browser environment so that you don't have
    to manually specify them. Think of it as a helper crate that says, *"Yeah, I know
    you'll need all these functions so I created them for you."*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，WebAssembly 的一项限制是它不能操作 DOM，这是一个比较委婉的说法，意思是它不能改变网页。它能做的是调用 JavaScript 中的函数，而这些函数再去做实际的工作。此外，JavaScript
    对你的 WebAssembly 类型一无所知，所以任何传递给 JavaScript 对象的数据都会被打包到共享内存中，然后由 JavaScript 取出，以便将其转换为它理解的形式。这需要编写大量的重复代码，而
    `wasm-bindgen` crate 就是为了解决这个问题而存在的。稍后，我们将使用它来将我们自己的自定义绑定绑定到第三方 JavaScript 代码上，但已经内置在浏览器中的所有函数，比如
    `console.log` 呢？这就是 `web-sys` 发挥作用的地方。它使用 `wasm-bindgen` 来绑定浏览器环境中的所有函数，这样你就不需要手动指定它们。可以把它想象成一个辅助
    crate，它会说：“是的，我知道你需要所有这些函数，所以我为你创建了它们。”
- en: 'So, to sum up, `wasm-bindgen` gives you the capability to communicate between
    WebAssembly and JavaScript, and `web-sys` contains a large number of pre-created
    bindings. If you''re particularly interested in how the calls between WebAssembly
    and JavaScript work, check out this article by Lin Clark, which explains it in
    great detail, and with pictures: [https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/](https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，`wasm-bindgen` 给你提供了在 WebAssembly 和 JavaScript 之间通信的能力，而 `web-sys` 包含了大量预先创建的绑定。如果你特别感兴趣于了解
    WebAssembly 和 JavaScript 之间的调用是如何工作的，可以查看 Lin Clark 的这篇文章，它详细解释了这一点，并且配有图片：[https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/](https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/)。
- en: The wee allocator
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小型分配器
- en: After the use statements you'll see a comment block referring to the `wee_alloc`
    feature, which is a WebAssembly allocator that uses much less memory than the
    default Rust allocator. We're not using it, and it was disabled in the `Cargo.toml`
    file, so you can delete it from both the source code and `Cargo.toml`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用语句之后，你会看到一个关于 `wee_alloc` 功能的注释块，这是一个比默认 Rust 分配器使用更少内存的 WebAssembly 分配器。我们没有使用它，并且在
    `Cargo.toml` 文件中已经禁用了它，所以你可以从源代码和 `Cargo.toml` 中删除它。
- en: The main
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主函数
- en: 'Finally, we get to the main part of our program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了程序的主体部分：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `wasm_bindgen(start)` annotation exports `main_js` so that it can be called
    by JavaScript, and the `start` parameter identifies it as the starting point of
    the program. If you're curious, you can take a look at `pkg/index_bg.wasm.d.ts`
    to see what was generated by it. You'll also want to take note of the return value,
    `Result`, where the error type can be `JsValue`, which represents an object owned
    by JavaScript and not Rust.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm_bindgen(start)` 注解导出 `main_js` 以便它可以被 JavaScript 调用，而 `start` 参数标识它是程序的起点。如果你好奇，可以查看
    `pkg/index_bg.wasm.d.ts` 来看看它生成了什么。你还会想注意返回值，`Result`，其中错误类型可以是 `JsValue`，它代表
    JavaScript 拥有的对象，而不是 Rust。'
- en: At this point, you may start to wonder how you'll keep track of what's JavaScript
    and what's Rust, and I'd advise you to not worry too much about it right now.
    There's a lot of jargon popping up and there's no way you'll keep it all in your
    head; just let it swim around in there and when it comes up again, I'll explain
    it again. `JsValue` is just a representative JavaScript object in your Rust code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能开始想知道你将如何跟踪 JavaScript 和 Rust 的区别，我建议你现在不要过于担心这个问题。有很多术语冒了出来，而且你不可能全部记住；只需让它在那里游荡，当它再次出现时，我会再次解释。`JsValue`
    只是 Rust 代码中的一个代表 JavaScript 对象。
- en: 'Finally, let''s look at the contents:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看内容：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first line sets the panic hook, which just means that any panics will be
    redirected to the web browser's console. You'll need it for debugging, and it's
    best to keep it at the beginning of the program. Our one line, our *Hello World*,
    is `console::log_1(&JsValue::from_str("Hello world!"));`. That calls the JavaScript
    `console.log` function, but it's using the version that's `log_1` because the
    JavaScript version takes varying parameters. This is something that's going to
    come up again and again when using `web-sys`, which is that JavaScript supports
    `varargs` and Rust doesn't. So instead, many variations are created in the `web-sys`
    module to match the alternatives. If a JavaScript function you expect doesn't
    exist, then take a look at the Rust documents for `web-sys` ([https://bit.ly/2NlRmOI](https://bit.ly/2NlRmOI))
    and see whether there are versions that are similar but built to account for multiple
    parameters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行设置了 panic 钩子，这意味着任何 panic 都会被重定向到网页浏览器的控制台。你将需要它来进行调试，最好将其放在程序的开始部分。我们这一行，我们的
    *Hello World*，是 `console::log_1(&JsValue::from_str("Hello world!"));`。这调用了 JavaScript
    的 `console.log` 函数，但它使用的是 `log_1` 版本，因为 JavaScript 版本接受可变参数。这是在使用 `web-sys` 时会反复出现的事情，JavaScript
    支持 `varargs` 而 Rust 不支持。因此，`web-sys` 模块中创建了多种变体来匹配替代方案。如果你期望的 JavaScript 函数不存在，那么查看
    Rust 的 `web-sys` 文档（[https://bit.ly/2NlRmOI](https://bit.ly/2NlRmOI)），看看是否有类似但为处理多个参数而构建的版本。
- en: Tip
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: A series of macros for several of the more commonly used functions (such as
    `log`) could solve this problem, but that's an exercise for the reader.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列宏，用于解决一些常用函数（如 `log`）的问题，但这将是读者的练习。
- en: Finally, the function returns `Ok(())`, as is typical of Rust programs. Now
    that we've seen the generated code, let's break it down with our own.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数返回 `Ok(())`，这是 Rust 程序的典型做法。现在我们已经看到了生成的代码，让我们用我们自己的方式来分析它。
- en: Drawing a triangle
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制三角形
- en: We've spent a lot of time digging into the code we currently have, and it's
    a lot to just write *"Hello World"* to the console. Why don't we have some fun
    and actually draw to the canvas?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经花费了很多时间深入研究我们目前拥有的代码，仅仅向控制台输出 *"Hello World"* 就已经足够多了。为什么我们不玩点有趣的东西，实际上在画布上画点东西呢？
- en: 'What we''re going to do is mimic the following JavaScript code in Rust:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要模仿以下 JavaScript 代码在 Rust 中实现：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code grabs the canvas element we put in `index.html`, grabs its 2D context,
    and then draws a black triangle. One way to draw a shape on the context is to
    draw a line path, then stroke, and, in this case, fill it. You can actually see
    this in the browser using the web developer tools built into most browsers. This
    screenshot is from Firefox:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码获取我们在 `index.html` 中放置的画布元素，获取其 2D 上下文，然后绘制一个黑色三角形。在上下文中绘制形状的一种方法是通过绘制线路径，然后描边，在这个例子中，填充它。你实际上可以在大多数浏览器内置的网页开发者工具中使用浏览器查看这个。这个截图来自
    Firefox：
- en: '![Figure 1.2 – A simple canvas triangle](img/Figure_1.02_B17151.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 一个简单的画布三角形](img/Figure_1.02_B17151.jpg)'
- en: Figure 1.2 – A simple canvas triangle
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 一个简单的画布三角形
- en: 'Let''s do the same thing in our Rust program. You''ll see that it''s a little…different.
    Start with the quick addition of a `use` statement at the top:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Rust 程序中做同样的事情。你会看到它有点…不同。从顶部快速添加一个 `use` 语句开始：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, replace the existing `main_js` function with the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用以下内容替换现有的 `main_js` 函数：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are a few differences that stand out, but at a glance, you may just feel
    like Rust code is a lot *noisier* than JavaScript code, and that's true. You might
    be inclined to say that it's less elegant or isn't as clean, but I'd say that's
    in the eye of the beholder. JavaScript is a dynamically typed language and it
    shows. It ignores `undefined` and `null`, and can just crash if any of the values
    are not present. It uses duck typing to call all the functions on the context,
    which means that if the function is present, it simply calls it; otherwise, it
    throws exceptions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些明显的差异，但乍一看，你可能只是觉得 Rust 代码比 JavaScript 代码要“嘈杂”得多，这是真的。你可能会倾向于认为它不够优雅或者不够干净，但我认为这取决于个人观点。JavaScript
    是一种动态类型语言，这很明显。它忽略了 `undefined` 和 `null`，如果任何值不存在，它可能会崩溃。它使用鸭子类型来调用上下文中的所有函数，这意味着如果函数存在，它就会简单地调用它；否则，它会抛出异常。
- en: Rust code takes a very different approach, one that favors explicitness and
    safety but at the cost of the code having extra noise. In Rust, you have to be
    more explicit when calling methods on structs, hence the casting, and you have
    to acknowledge `null` or failed `Result` types, hence all the unwraps. I've spent
    years using dynamic languages, including JavaScript, and I like them a lot. I
    certainly liked them a lot better than writing in C++, which I find overly verbose
    without really granting some of the safety advantages, but I think that with some
    tweaks, we can make Rust code nearly as elegant as JavaScript without glossing
    over exceptions and results.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 代码采取了一种非常不同的方法，这种方法更倾向于显式性和安全性，但代价是代码有额外的噪声。在 Rust 中，当你对结构体调用方法时，你必须更加显式，这就是为什么需要类型转换，你必须承认
    `null` 或失败的 `Result` 类型，这就是为什么有所有的 unwraps。我多年来一直在使用动态语言，包括 JavaScript，我非常喜欢它们。我确实非常喜欢它们，比写
    C++ 更好，我发现 C++ 过于冗长，实际上并没有真正提供一些安全优势，但我认为通过一些调整，我们可以使 Rust 代码几乎和 JavaScript 一样优雅，而不会忽略异常和结果。
- en: My rant aside, if you're still running the program, you'll notice one minor
    detail – the Rust code doesn't compile! This leads me to the first thing we'll
    need to cover when translating JavaScript code to Rust code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不谈我的牢骚，如果你还在运行程序，你会注意到一个小的细节——Rust 代码无法编译！这让我想到，当我们从 JavaScript 代码翻译到 Rust 代码时，我们需要覆盖的第一个问题。
- en: web-sys and feature flags
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: web-sys 和功能标志
- en: The `web-sys` crate makes heavy use of feature flags to keep its size down.
    This means that every time you want to use a function and it doesn't exist, you'll
    need to check which feature flag it's tied to, which is in its documentation,
    and add it to `Cargo.toml`. Fortunately, this is well documented and easy enough
    to do; we don't even need to restart the server!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`web-sys` 包大量使用功能标志来保持其大小。这意味着每次你想使用一个函数但该函数不存在时，你都需要检查它关联的功能标志，这可以在其文档中找到，并将其添加到
    `Cargo.toml` 文件中。幸运的是，这有很好的文档记录，并且足够容易完成；我们甚至不需要重新启动服务器！'
- en: 'Looking at our errors, we should see the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的错误，我们应该看到以下内容：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are a few more errors of the same kind, but what you see here is that
    `window` is not in the `web_sys` module. Now, if you check the documentation for
    the `window` function in `web-sys` at [https://bit.ly/3ak3sAR](https://bit.ly/3ak3sAR),
    you''ll see that, yes, it does exist, but there is the `This API requires the
    following crate features to be activated: Window` message.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个同类的错误，但这里我们看到的是 `window` 不在 `web_sys` 模块中。现在，如果你查看 `web-sys` 中 `window`
    函数的文档，在 [https://bit.ly/3ak3sAR](https://bit.ly/3ak3sAR)，你会看到，是的，它确实存在，但有一个消息：“此
    API 需要以下 crate 功能被激活：Window”。
- en: Open the `cargo.toml` file and look for `dependencies.web-sys`. You'll see that
    it has a `features` entry with just `["console"]` in it; go ahead and add `"Window"`,
    `"Document"`, `"HtmlCanvasElement"`, `"CanvasRenderingContext2d"`, and `"Element"`
    to that list. To be clear, you don't need all those feature flags for just the
    `window` function; that's all of the functions we're using.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `cargo.toml` 文件，查找 `dependencies.web-sys`。你会看到它有一个 `features` 条目，其中只包含 `["console"]`；继续添加
    `"Window"`、`"Document"`、`"HtmlCanvasElement"`、`"CanvasRenderingContext2d"` 和 `"Element"`
    到这个列表中。为了明确，你不需要所有这些功能标志只是为了 `window` 函数；这是我们使用到的所有函数。
- en: You'll notice the project will rebuild automatically and should build successfully.
    If you look in the browser, you'll see your own black triangle! Let's extend it
    and learn a bit more about how we did it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到项目会自动重新构建，并且应该能够成功构建。如果你在浏览器中查看，你会看到你自己的黑色三角形！让我们扩展它，并了解我们是如何做到这一点的。
- en: Tip
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When a function you expect to exist on `web-sys` doesn't, go and check the feature
    flags in the documents.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当您期望在 `web-sys` 上存在的函数不存在时，请去检查文档中的功能标志。
- en: DOM interaction
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM 交互
- en: 'You''ll notice that the method for drawing the triangle after you get the context
    looks essentially the same as the method in JavaScript – draw a line path, stroke,
    and fill it. The code at the top that interacted with the DOM looks…different.
    Let''s break down what''s going on here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在获取上下文之后绘制三角形的函数与方法在 JavaScript 中看起来几乎相同——绘制线路径、描边和填充。与 DOM 交互的顶部代码看起来……不同。让我们分析一下这里发生了什么：
- en: Unwrapping option
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包选项
- en: 'Getting the `Window` is just a function in the `web-sys` crate, one you enabled
    when you added the `Window` feature to `Cargo.toml`. However, you''ll notice it''s
    got `unwrap` at the end:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `Window` 只是在 `web-sys` 包中的一个函数，您在将 `Window` 功能添加到 `Cargo.toml` 时启用了它。然而，您会注意到它的末尾有
    `unwrap`：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In JavaScript, `window` can be `null` or `undefined`, at least theoretically,
    and in Rust, this gets translated into `Option<Window>`. You can see that `unwrap`
    is applied to the result of `window()`, `document()`, and `get_element_by_id()`
    because all of them return `Option<T>`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`window` 可以是 `null` 或 `undefined`，至少在理论上是这样，在 Rust 中，这被翻译成 `Option<Window>`。您可以看到
    `unwrap` 被应用于 `window()`、`document()` 和 `get_element_by_id()` 的结果，因为它们都返回 `Option<T>`。
- en: '`dyn_into`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dyn_into`'
- en: What the heck is `dyn_into`? Well, this oddity accounts for the difference between
    the way JavaScript does typing and the way Rust does. When we retrieve the canvas
    with `get_element_by_id`, it returns `Option<Element>`, and `Element` does not
    have any functions relating to the canvas. In JavaScript, you can use dynamic
    typing to assume the element has the `get_context` method, and if you're wrong,
    the program will throw an exception. This is anathema to Rust; indeed, this is
    a case where one developer's convenience is another developer's potential bug
    in hiding, so in order to use `Element`, we have to call the `dyn_into` function
    to cast it into `HtmlCanvasElement`. This method was brought into scope with the
    `use wasm_bindgen::JsCast` declaration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: “dyn_into”究竟是什么意思？嗯，这个奇怪之处解释了 JavaScript 和 Rust 在类型处理方式上的差异。当我们使用 `get_element_by_id`
    获取画布时，它返回 `Option<Element>`，而 `Element` 没有任何与画布相关的函数。在 JavaScript 中，您可以使用动态类型假设元素有
    `get_context` 方法，如果您错了，程序将抛出异常。这与 Rust 的原则相悖；实际上，这是一个开发者方便的地方，可能是另一个开发者潜在错误的隐藏之处，因此为了使用
    `Element`，我们必须调用 `dyn_into` 函数将其转换为 `HtmlCanvasElement`。这个方法是通过 `use wasm_bindgen::JsCast`
    声明引入作用域的。
- en: Important Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that `HtmlCanvasElement`, `Document`, and `Element` were all also feature
    flags you had to add in `web-sys`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`HtmlCanvasElement`、`Document` 和 `Element` 都是在 `web-sys` 中需要添加的功能标志。
- en: Two unwraps?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两次解包？
- en: After calling `get_context("2d")`, we actually call `unwrap` twice; that's not
    a typo. What's going on is that `get_context` returns a `Result<Option<Object>>`,
    so we unwrap it twice. This is another case where the game can't recover if this
    fails, so `unwrap` is okay, but I wouldn't complain if you replaced those with
    `expect` so that you can give a clearer error message.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `get_context("2d")` 之后，我们实际上调用了两次 `unwrap`；这不是一个打字错误。实际情况是 `get_context`
    返回一个 `Result<Option<Object>>`，所以我们两次解包它。这是一个游戏在失败时无法恢复的情况，所以 `unwrap` 是可以接受的，但如果您用
    `expect` 替换它们，以便可以提供更清晰的错误信息，我并不会抱怨。
- en: A Sierpiński triangle
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 Sierpiński 三角形
- en: Now let's have some real fun, and draw a Sierpiński triangle a few levels deep.
    If you're up for a challenge, you can try and write the code yourself before following
    along with the solution presented here. The way the algorithm works is to draw
    the first triangle (the one you are already drawing) and then draw another three
    triangles, where the first triangle has the same top point but its other two points
    are at the halfway point on each side of the original triangle. Then, draw a second
    triangle on the lower left, with its top at the halfway point of the left side,
    its lower-right point at the halfway point of the bottom of the original triangle,
    and its lower-left point at the lower-left point of the original triangle. Finally,
    you create a third triangle in the lower-right corner of the original triangle.
    This leaves a "hole" in the middle shaped like an upside-down triangle. This is
    much easier to visualize than it is to explain, so how about a picture?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来点真正的乐趣，绘制一个几级深的 Sierpiński 三角形。如果你愿意接受挑战，你可以在跟随这里提供的解决方案之前尝试自己编写代码。算法的工作方式是先绘制第一个三角形（你正在绘制的那个），然后绘制另外三个三角形，其中第一个三角形具有相同的顶点，但它的其他两个点位于原始三角形的每一边的中点。然后，在左下角绘制第二个三角形，其顶点位于左侧的中点，其右下角位于原始三角形底部的中点，其左下角位于原始三角形的左下角。最后，在原始三角形的右下角创建第三个三角形。这会在中间留下一个倒三角形形状的“洞”。这比解释起来更容易可视化，所以让我们看看一张图片？
- en: '![Figure 1.3 – A one-level Sierpiński triangle](img/Figure_1.03_B17151.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 一级 Sierpiński 三角形](img/Figure_1.03_B17151.jpg)'
- en: Figure 1.3 – A one-level Sierpiński triangle
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 一级 Sierpiński 三角形
- en: Each of the numbered triangles was one that was drawn. The upside-down blue
    triangle is what's left of the original triangle because we didn't draw over it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编号的三角形都是已经绘制的。倒置的蓝色三角形是原始三角形留下的部分，因为我们没有覆盖它。
- en: 'So that''s one triangle subdivided into four. Now, the algorithm works recursively,
    taking each triangle and subdividing again. So, two levels deep, it looks like
    this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个被细分成四个的三角形。现在，算法是递归的，它将每个三角形再次细分。所以，二级深，它看起来像这样：
- en: '![Figure 1.4 – A two-level Sierpiński triangle'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 二级 Sierpiński 三角形'
- en: '](img/Figure_1.04_B17151.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_1.04_B17151.jpg)'
- en: Figure 1.4 – A two-level Sierpiński triangle
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 二级 Sierpiński 三角形
- en: Note that it *doesn't* subdivide the upside-down triangle in the center, just
    the three purple ones that you created. Indeed, all the triangles with their points
    down are just "happy accidents" that make the shape look cool. You now know enough
    at this point to draw your own Sierpiński triangle, with one catch – you should
    remove the `fill` statement on context. Otherwise, all the triangles will be filled
    black and you won't be able to see them. Go ahead and give it a try.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它**不会**细分中心倒置的三角形，只会细分你创建的三个紫色三角形。实际上，所有点朝下的三角形只是“快乐的意外”，让形状看起来很酷。现在，你已经有足够的知识来绘制自己的
    Sierpiński 三角形了，有一个例外——你应该在上下文中移除 `fill` 语句。否则，所有三角形都会被填充成黑色，你将无法看到它们。试试看吧。
- en: Drawing the Sierpiński triangle
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制 Sierpiński 三角形
- en: 'So, did you give it a try? No, I wouldn''t either; I guess we have a lot in
    common. To get started with creating a Sierpiński triangle, let''s replace the
    hardcoded triangle with a triangle function. Here''s the first pass at `draw_triangle`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你尝试了吗？不，我也不会；我想我们有很多共同之处。要开始创建 Sierpiński 三角形，让我们用三角形函数替换硬编码的三角形。这是 `draw_triangle`
    的第一次尝试：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are a couple of small changes from the hard-coded version that we started
    with. The function takes a reference to the context and a list of three points.
    Points themselves are represented by tuples. We''ve also gotten rid of the `fill`
    function, so we only have an empty triangle. Replace the inline `draw_triangle`
    with the function call, which should look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们最初开始的硬编码版本相比，有一些小的变化。函数接受对上下文的引用和一个包含三个点的列表。点本身由元组表示。我们还去掉了 `fill` 函数，所以我们只有一个空三角形。将内联的
    `draw_triangle` 替换为函数调用，它应该看起来像这样：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that you''re drawing one empty triangle, you''re ready to start drawing
    the recursive triangles. Rather than starting with recursion, let''s draw the
    first subdivision by drawing three more triangles. The first will have the same
    top point and two side points:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在绘制一个空三角形，你就可以开始绘制递归三角形了。与其从递归开始，不如先绘制三个更多的三角形。第一个将具有相同的顶点和两个侧面点：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that the third tuple has an x halfway between `300.0` and `600.0`, not
    between `0` and `600.0`, because the top point of the triangle is halfway between
    the other two points. Also note that y gets larger as you go down, which is upside-down
    compared to many 3D systems. Now, let''s add the lower-left and lower-right triangles:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第三个元组在`300.0`和`600.0`之间有一个中点，而不是在`0`和`600.0`之间，因为三角形的顶点位于其他两个点的中点之间。还要注意，随着向下移动，y坐标会变大，这与许多3D系统相反。现在，让我们添加左下角和右下角的三角形：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Your triangles should look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你的三角形应该看起来像这样：
- en: '![Figure 1.5 – Your triangles](img/Figure_1.05_B17151.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 你的三角形](img/Figure_1.05_B17151.jpg)'
- en: Figure 1.5 – Your triangles
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 你的三角形
- en: 'You will start to see a pattern at this point, and we can begin to turn our
    hardcoded triangles into an algorithm. We''ll create a function called `sierpinski`
    that takes the context, the triangle dimensions, and a depth function so that
    we only draw as many triangles as we want, instead of drawing them to infinity
    and crashing the browser. Then, we''ll move those functions we called into that
    function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该开始看到一种模式，我们可以开始将硬编码的三角形转换成算法。我们将创建一个名为`sierpinski`的函数，它接受上下文、三角形尺寸和深度函数，这样我们就可以只绘制我们想要的三角形数量，而不是无限绘制并导致浏览器崩溃。然后，我们将那些调用该函数的函数移动到该函数中：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This function currently ignores everything except the context, but you can
    replace those four `draw_triangle` calls from `main_js` and replace them with
    a call to `sierpinski`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数目前忽略除上下文之外的所有内容，但你可以将`main_js`中的那四个`draw_triangle`调用替换为对`sierpinski`的调用：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It''s important that you only send a depth of `2` for now so that the image
    will continue to look the same as we progress. Think of this call as a proto-unit
    test, guaranteeing our behavior doesn''t change while we refactor. Now, in `sierpinski`,
    take the first triangle and have it use the passed-in points:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在非常重要，你只发送深度为`2`，这样图像在进展过程中将继续保持相同。将这个调用视为一个原型单元测试，确保我们在重构过程中行为没有改变。现在，在`sierpinski`中，取第一个三角形并让它使用传入的点：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, after drawing the triangle, reduce the depth by one and see if it is
    still greater than `0`. Then, draw the rest of the triangles:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在绘制三角形之后，减少深度值一个单位，并查看它是否仍然大于`0`。然后，绘制剩余的三角形：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, to complete the recursion, you can replace all those `draw_triangle` calls
    with calls into `sierpinski`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完成递归，你可以将所有的`draw_triangle`调用替换为对`sierpinski`的调用：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So far so good – you should still see a triangle subdivided into four triangles.
    Finally, we can actually calculate the midpoints of each line on the original
    triangle and use those to create the recursive triangles, instead of hardcoding
    them:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利——你应该仍然看到一个被细分成四个三角形的三角形。最后，我们可以实际上计算原始三角形上每条线的中点，并使用这些点来创建递归三角形，而不是硬编码它们：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Calculating the midpoint of a line segment is done by taking the *x* and *y*
    coordinates of each end, adding those together, and then dividing them by two.
    While the preceding code works, let''s make it clearer by writing a new function,
    as shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 计算线段中点的方法是取每端的*x*和*y*坐标，将它们相加，然后除以二。虽然前面的代码可以工作，但让我们通过编写一个新函数来使其更清晰，如下所示：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can use that in the preceding function, for clarity:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在前面的函数中使用它，以增加清晰度：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you''ve been following along, you should make sure you''re still showing
    a triangle with four inside to ensure you haven''t made any mistakes. Now for
    the big reveal – go ahead and change the depth to `5` in the original `Sierpinski`
    call:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随，你应该确保你仍然显示一个有四个内部三角形的三角形，以确保你没有犯任何错误。现在，进行重大揭秘——将原始`Sierpinski`调用中的深度更改为`5`：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see a recursive drawing of triangles, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个像这样的三角形递归绘制：
- en: '![Figure 1.6 – A recursive drawing of triangles'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 – 三角形的递归绘制'
- en: '](img/Figure_1.06_B17151.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.06_B17151.jpg](img/Figure_1.06_B17151.jpg)'
- en: Figure 1.6 – A recursive drawing of triangles
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 三角形的递归绘制
- en: Looking good! But what about those colors we saw in the original diagrams? They
    make it much more interesting.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！但那些我们在原始图中看到的颜色呢？它们使它变得更加有趣。
- en: When libraries aren't compatible
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当库不兼容时
- en: The earlier examples of this image had the triangles filled in with a different
    random color at each recursive layer. So, the first triangle was one color, three
    and four were another, the next nine another, and so on. It makes for a more interesting
    image *and* it provides a good example of what to do when a library isn't completely
    WebAssembly-compatible.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像的早期示例在每个递归层中用不同的随机颜色填充了三角形。因此，第一个三角形是一种颜色，第三个和第四个是另一种颜色，接下来的九个又是另一种颜色，以此类推。这使得图像更加有趣，*并且*提供了一个很好的例子，说明当库不完全兼容WebAssembly时应该怎么做。
- en: 'To create a random color, we''ll need a random number generator, and that is
    not part of the standard library but instead found in a crate. You can add that
    crate by changing the `Cargo.toml` file to include it as a dependency:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个随机颜色，我们需要一个随机数生成器，而这不是标准库的一部分，而是在一个crate中找到的。你可以通过更改`Cargo.toml`文件将其作为依赖项添加：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When you do this, you''ll get a compiler error that looks like the following
    (although your message may differ slightly):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你会得到一个看起来像以下内容的编译器错误（尽管你的消息可能略有不同）：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is a case where a transitive dependency, in this case `getrandom`, does
    not compile on the WebAssembly target. In this case, it''s an extremely helpful
    error message, and if you follow the link, you''ll get the solution in the documentation.
    Specifically, you need to enable `js` in the feature flags for `getrandom`. Go
    back to your `Cargo.toml` file and add the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个递归依赖项，在这种情况下是`getrandom`，在WebAssembly目标上无法编译的情况。在这种情况下，这是一个非常有帮助的错误信息，如果你点击链接，你将在文档中找到解决方案。具体来说，你需要为`getrandom`启用`js`功能标志。回到你的`Cargo.toml`文件，并添加以下内容：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This adds the `getrandom` dependency with the `js` feature enabled, and your
    code will begin compiling again. The lesson to take away from this is that not
    every Rust crate will compile on the WebAssembly target, and when that happens,
    you'll need to check the documents.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了带有`js`功能的`getrandom`依赖项，你的代码将开始重新编译。从这个例子中我们可以吸取的教训是，并非每个Rust crate都能在WebAssembly目标上编译，当这种情况发生时，你需要检查文档。
- en: Tip
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When a crate won't compile *slowly*, read the error message and follow the instructions.
    It's very easy to skim right over the reason the build is breaking, especially
    when you're frustrated.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个crate无法*缓慢*编译时，阅读错误信息并遵循指示。当你感到沮丧时，很容易忽略构建中断的原因。
- en: Random colors
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机颜色
- en: 'Now that we''ve got the random create building with our project, let''s change
    the color of the triangles as we draw them to a random color. To do that, we''ll
    set `fillStyle` with a color before we draw the triangle, and we''ll add a `fill`
    command. This is, generally, how the `Context2D` API works. You set up the state
    of the context and then execute commands with that state set. It takes a little
    getting used to but you''ll get the hang of it. Let''s add `color` as a parameter
    of the three `u8` tuples to `draw_triangle`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让随机crate与我们的项目一起构建，让我们在绘制三角形时将其颜色改为随机颜色。为此，我们将在绘制三角形之前设置`fillStyle`的颜色，并添加一个`fill`命令。这通常是`Context2D`
    API的工作方式。你设置上下文的状态，然后使用该状态执行命令。这需要一点时间来适应，但你会习惯的。让我们将`color`作为三个`u8`元组的参数添加到`draw_triangle`中：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Important Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Colors are represented here as three components, red, green, and blue, where
    each value can go from `0` to `255`. We're using tuples in this chapter because
    we can make progress quickly, but if it's starting to bother you, you're welcome
    to make proper `struct`s.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色在这里表示为三个组件，红色、绿色和蓝色，每个值可以从`0`到`255`。我们在这章中使用元组是因为我们可以快速取得进展，但如果这开始让你感到烦恼，你可以创建合适的`struct`s。
- en: 'Now that `draw_triangle` needs a color, our application doesn''t compile. Let''s
    move to the `sierpinski` function and pass a color to it as well. We''re going
    to send the color to the `sierpinski` function, instead of generating it there,
    so that we can get one color at every level. The first generation will be one
    solid color, then the second will all be one color, and then the third a third
    color, and so on. So let''s add that:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`draw_triangle`需要一个颜色，我们的应用程序无法编译。让我们转到`sierpinski`函数，并给它传递一个颜色。我们将把颜色发送到`sierpinski`函数，而不是在那里生成它，这样我们就可以在每一层得到一个颜色。第一代将是一种纯色，然后第二代将都是一种颜色，然后第三代是第三种颜色，以此类推。所以让我们添加这个：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I put `color` as the third parameter and not the fourth because I think it
    looks better that way. Remember to pass color to the other calls. Finally, so
    that we can compile, we''ll send a color to the initial `sierpinski` call:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`color`作为第三个参数而不是第四个，因为我认为这样看起来更好。请记住将颜色传递给其他调用。最后，为了我们可以编译，我们将向初始的`sierpinski`调用发送一个颜色：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since this is an RGB color, `(0, 255, 0)` represents green. Now, we''ve made
    our code compile, but it doesn''t do anything, so let''s work back downward from
    the original call and into the `sierpinski` function again. Instead of just passing
    the color through, let''s create a new tuple that has a random number for each
    component. You''ll need to add `use rand::prelude::*;` to the use declarations
    at the top. Then, add the following code to the `sierpinski` function, after the
    `if depth > 0` check:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个RGB颜色，`(0, 255, 0)`代表绿色。现在，我们已经使代码编译成功，但它没有任何作用，所以让我们从原始调用向下工作，再次进入`sierpinski`函数。我们不仅传递颜色，还要创建一个新的元组，其中每个组件都有一个随机数。你需要在顶部的使用声明中添加`use
    rand::prelude::*;`。然后，在`sierpinski`函数中，在`if depth > 0`检查之后，添加以下代码：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside the depth check, we randomly generate `next_color` and then pass it
    along to all the recursive `sierpinski` calls. But of course, our output *still*
    doesn''t look any different. We never changed `draw_triangle` to change the color!
    This is going to be a little weird because the `context.fillStyle` property takes
    `DOMString` in JavaScript, so we''ll need to do a conversion. At the top of `draw_triangle`,
    add two lines:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度检查内部，我们随机生成`next_color`，然后将其传递给所有的递归`sierpinski`调用。但当然，我们的输出仍然没有变化。我们从未更改`draw_triangle`来改变颜色！这会有一点奇怪，因为`context.fillStyle`属性在JavaScript中接受`DOMString`，所以我们需要进行转换。在`draw_triangle`的顶部添加两行：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: On line one, we convert our tuple of three unsigned integers to a string reading
    `"rgb(255, 0, 255)"`, which is what the `fillStyle` property expects. On the second
    line, we use `set_fill_style` to set it, doing that funky conversion. There are
    two things that you need to understand with this function. The first is that,
    generally, JavaScript properties are just public and you set them, but `web-sys`
    generates `getter` and `setter` functions. The second is that these generated
    functions frequently take `JsValue` objects, which represent an object owned by
    JavaScript. Fortunately, `wasm_bindgen` has factory functions for these, so we
    can create them easily and use the compiler as our guide.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将三个无符号整数的元组转换为字符串`"rgb(255, 0, 255)"`，这是`fillStyle`属性所期望的。在第二行，我们使用`set_fill_style`来设置它，进行那种奇特的转换。关于这个函数，你需要理解两件事。第一是，通常，JavaScript属性是公开的，你可以设置它们，但`web-sys`生成`getter`和`setter`函数。第二是，这些生成的函数通常接受`JsValue`对象，它们代表JavaScript拥有的对象。幸运的是，`wasm_bindgen`为这些提供了工厂函数，所以我们可以轻松地创建它们并使用编译器作为我们的指南。
- en: Tip
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whenever you translate from JavaScript code to Rust, make sure that you check
    the documentation of the corresponding functions to see what types are needed.
    Passing a string to JavaScript isn't always as simple as you might think.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时从JavaScript代码转换为Rust，请确保检查相应函数的文档，以查看所需的类型。将字符串传递给JavaScript并不像你想象的那么简单。
- en: Finally, we actually need to fill the triangles to see those colors, so after
    `context.stroke()`, you need to restore that `context.fill()` method you deleted
    earlier, and ta-da!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实际上需要填充三角形才能看到那些颜色，所以在`context.stroke()`之后，你需要恢复你之前删除的`context.fill()`方法，然后就是大功告成了！
- en: '![Figure 1.7 – Filled triangles](img/Figure_1.07_B17151.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 填充的三角形](img/Figure_1.07_B17151.jpg)'
- en: Figure 1.7 – Filled triangles
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 填充的三角形
- en: You've done it, and you're ready to start creating a real game.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了，你现在可以开始创建真正的游戏了。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we''ve done a *lot*. We''ve written our first WebAssembly
    app using Rust, moving from *"Hello World"* to drawing in the browser with HTML
    Canvas. You''ve added crates, run a development server, and interacted with the
    DOM. You''ve learned a lot about interacting with the browser, including the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做了很多。我们使用Rust编写了第一个WebAssembly应用程序，从*"Hello World"*过渡到使用HTML Canvas在浏览器中绘图。你添加了crate，运行了开发服务器，并与DOM进行了交互。你学到了很多关于与浏览器交互的知识，包括以下内容：
- en: Creating the main entry point with `#[wasm_bindgen(start)]`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`#[wasm_bindgen(start)]`创建主入口点
- en: Translating JavaScript code to Rust code
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JavaScript代码转换为Rust代码
- en: Dealing with crates that compile to JavaScript
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理编译为JavaScript的crate
- en: You've also been introduced to HTML Canvas. Frankly, it's been a bit of a whirlwind,
    so don't worry if some information flew over your head, as we'll cover many of
    these topics again – including in the next chapter, where we'll start drawing
    sprites.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你也已经接触到了HTML Canvas。坦白说，这有点像一场旋风，所以如果你觉得有些信息没有跟上，请不要担心，因为我们会再次涵盖这些主题——包括在下一章，我们将开始绘制精灵。
