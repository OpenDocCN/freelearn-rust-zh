- en: Integrating Rust with Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Rust 与其他语言集成
- en: 'We will be covering the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Calling C operations from Rust
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Rust 调用 C 操作
- en: Calling Rust commands from C
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C 调用 Rust 命令
- en: Calling Rust operations from Node.js apps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Node.js 应用程序调用 Rust 操作
- en: Calling Rust operations from Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Python 调用 Rust 操作
- en: Writing a Python module in Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中编写 Python 模块
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will cover the techniques and steps that will help us create
    Rust units in our existing applications that are written in other languages, such
    as C, Node.js, and Python. We will deep dive into the concept of foreign function
    interface, which helps us in writing bindings for a foreign code base. Rust outperforms
    many programming languages in the aspect of stability and safer parallelism. It
    would be ideal for production level application developers to try out Rust for
    building small units in the code, and test to see if there is a considerable amount
    of performance change. This chapter helps to facilitate these kinds of thoughts
    and ideas.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍技术和步骤，帮助我们创建在用其他语言（如 C、Node.js 和 Python）编写的现有应用程序中的 Rust 单元。我们将深入探讨外部函数接口的概念，这有助于我们为外部代码库编写绑定。Rust
    在稳定性和更安全的并行性方面优于许多编程语言。对于生产级应用程序开发者来说，尝试使用 Rust 构建代码中的小单元，并测试是否有显著的性能变化是理想的。这一章有助于促进这些想法和观点。
- en: Calling C operations from Rust
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Rust 调用 C 操作
- en: In this recipe, we will call an external C function from a Rust application.
    This technique can be really helpful when a developer wants to use some project-specific
    C library dependencies in the Rust code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从一个 Rust 应用程序中调用外部 C 函数。当开发者想在 Rust 代码中使用一些特定项目的 C 库依赖项时，这项技术非常有帮助。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following crate before we can go ahead and create
    the binding between Rust and C. Follow the given steps to download and set up
    the `libc` crate, `gcc` crate, and `gcc` compiler for your project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建 Rust 和 C 之间的绑定之前，我们必须安装以下 crate。按照以下步骤下载和设置您的项目中的 `libc` crate、`gcc`
    crate 和 `gcc` 编译器：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: 'Create a Rust library project using the Cargo tool:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 工具创建 Rust 库项目
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Enter the newly created Rust library project:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入新创建的 Rust 库项目：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot. Here, we''ll use `libc` version `0.1` and `gcc`
    version `0.3`, and we''ll also mention the `build` script, which is `build.rs`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中打开 `Cargo.toml` 文件，并按照以下截图进行修改。这里，我们将使用 `libc` 版本 `0.1` 和 `gcc` 版本
    `0.3`，同时还会提到 `build` 脚本，即 `build.rs`：
- en: '![](img/c7b38900-6992-40b6-a9d5-d7c05456eac6.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7b38900-6992-40b6-a9d5-d7c05456eac6.png)'
- en: 'Install the `gcc` compiler on your machine, which is usually present by default:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的机器上安装 `gcc` 编译器，这通常默认存在：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此菜谱：
- en: Create a file named `build.rs` in the root location of the project and open
    it your text editor.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根位置创建一个名为 `build.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头信息：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Enter the following code in the script:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中输入以下代码：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change to the `src` directory in the project:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目切换到 `src` 目录：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the `double.c` script, which is the C application:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `double.c` 的脚本，这是一个 C 应用程序：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a `double_input` function in the `double.c` application, which we will
    use in the Rust application:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `double.c` 应用程序中创建一个 `double_input` 函数，我们将在 Rust 应用程序中使用它：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Enter the `main.rs` script and enter the following code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `main.rs` 脚本并输入以下代码：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们代码成功执行后，我们将得到以下输出：
- en: '![](img/b8ca9761-3f76-4e74-801d-b0d27d75bd15.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8ca9761-3f76-4e74-801d-b0d27d75bd15.png)'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Rust project that can be used as a third-party
    package C application in the Rust code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个 Rust 项目，它可以作为 Rust 代码中的第三方包 C 应用程序使用。
- en: We used the `libc` crate, which is used as a library for types and bindings
    to native C functions that are often found in other common platform libraries.
    This project dependency is mentioned in the `Cargo.toml` file under the `dependencies`
    field, and, then, in the `build-dependencies` section of the manifest, we have
    `gcc` = `0.3`, which is the dependency of the `build` script.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`libc` crate，它被用作类型和绑定到原生C函数的库，这些函数通常在其他通用平台库中找到。这个项目依赖项在`Cargo.toml`文件的`dependencies`字段中提到，然后在清单的`build-dependencies`部分，我们有`gcc`
    = `0.3`，这是`build`脚本的依赖项。
- en: The `build` script does not have the access to dependencies listed in the dependencies
    of the `Cargo.toml` manifest section. The `build` dependencies will not be available
    to the package files; this is done by the Cargo tool so that the package and the
    build script are compiled separately, so their dependencies need not coincide.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`脚本无法访问`Cargo.toml`清单部分依赖项中列出的依赖项。`build`依赖项将不可用于包文件；这是由Cargo工具完成的，以便包和构建脚本分别编译，因此它们的依赖项不需要一致。'
- en: Rust provides a `build` script support where some packages need to compile third-party
    non-Rust code; for example, in our case we have a C script called `double.c`.
    The packages needed to link to C script, which can either be located on the system
    or possibly need to be built from source. Cargo does not replace other tools for
    building these packages, but it integrates them with the `build` configuration
    option, like, in our case, in the `package` section of the manifest, where we
    have a file named `build` with the `build.rs` script.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Rust提供了一个`build`脚本支持，其中一些包需要编译第三方非Rust代码；例如，在我们的案例中，我们有一个名为`double.c`的C脚本。需要链接到C脚本的包，这些包可以位于系统上，或者可能需要从源代码构建。Cargo不会替换用于构建这些包的其他工具，但它通过`build`配置选项将它们集成，例如，在我们的案例中，在清单的`package`部分，我们有一个名为`build`的文件，其中包含`build.rs`脚本。
- en: The Rust file designated by the `build` command, which, in our case, is `build.rs`,
    will be compiled first, before anything else is compiled in the package. This
    allows your Rust code to depend on the built or generated artifacts. In the `build.rs`
    script, we are building the native C code as part of the package; this package
    will later be used by the Rust code. We use an external crate named `gcc`, which
    invokes the externally maintained C compiler.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由`build`命令指定的Rust文件，在我们的案例中是`build.rs`，将首先编译，在包中的其他任何内容之前。这允许你的Rust代码依赖于构建或生成的工件。在`build.rs`脚本中，我们将原生C代码作为包的一部分进行构建；这个包将被Rust代码后来使用。我们使用一个名为`gcc`的外部crate，它调用外部维护的C编译器。
- en: The `build` script starts out in the `main` function where `gcc::Config::new().file("src/double.c").compile("libdouble.a")`
    starts off by compiling our C file into an object file (by invoking `gcc`) and
    then converting the object file (`double.o`) into a static library (`libdouble.a`).
    The object file is stored in `target/debug/build/<package>/out location`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`脚本从`main`函数开始，其中`gcc::Config::new().file("src/double.c").compile("libdouble.a")`首先通过调用`gcc`将我们的C文件编译成目标文件（对象文件），然后将对象文件（`double.o`）转换成静态库（`libdouble.a`）。对象文件存储在`target/debug/build/<package>/out`位置。'
- en: In the `src` directory, we have the Rust project package file in which we have
    the native C script, `double.c`. The `double.c` script has a function named `double_input`,
    which takes in an integer argument named `input` and returns `input * 2`, which
    basically doubles the value passed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`目录中，我们有Rust项目包文件，其中包含原生C脚本`double.c`。`double.c`脚本有一个名为`double_input`的函数，它接受一个名为`input`的整数参数并返回`input
    * 2`，这基本上是双倍传递的值。
- en: 'In `main.rs`, we first import the `libc` crate and then define the function
    signature in the `extern` block (since it''s a third-party package) as `fn double_input(input:
    libc::c_int) -> libc::c_int`. Here, we use the `libc` type so that there is a
    smooth conversion of types between Rust and C, which we do not have to handle
    while calling the foreign function, `double_input`. From the `main` function,
    we place it in the `unsafe` block.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '在`main.rs`中，我们首先导入`libc` crate，然后在`extern`块中定义函数签名（因为它是一个第三方包）为`fn double_input(input:
    libc::c_int) -> libc::c_int`。在这里，我们使用`libc`类型，以便在Rust和C之间平滑地转换类型，我们不需要在调用外部函数`double_input`时处理它。从`main`函数中，我们将其放在`unsafe`块中。'
- en: The `extern` block is a list of function signatures in a foreign library and
    the foreign functions are assumed to be unsafe. So, when we call them, they need
    to be wrapped with the `unsafe` block as a promise to the compiler that everything
    contained within is truly safe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern`块是外库中函数签名的一个列表，外函数被认为是不可安全的。因此，当我们调用它们时，需要用`unsafe`块包装，向编译器承诺其中包含的一切都是真正安全的。'
- en: Calling Rust commands from C
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C调用Rust命令
- en: In this recipe, we will perform the exact opposite operation of the last recipe.
    Here, we will call a Rust function from the C script. This technique can be really
    helpful when the developer wants to build a specific Rust unit in their C project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将执行上一个菜谱的相反操作。在这里，我们将从C脚本中调用Rust函数。当开发者想在C项目中构建特定的Rust单元时，这种技术非常有帮助。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'We will have to install the following system dependencies before we can go
    ahead and create a Rust unit for the C project. Follow the given steps to download
    and install the `build-essential` package for your project:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建C项目的Rust单元之前，我们必须安装以下系统依赖项。按照以下步骤下载并安装您项目的`build-essential`包：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: 'Create a Rust library project using the Cargo tool:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cargo工具创建一个Rust库项目：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Enter the newly created Rust library project:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入新创建的Rust库项目：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您最喜欢的文本编辑器中打开`Cargo.toml`文件，并按照以下截图进行修改：
- en: '![](img/3432406c-c878-41d2-8a5e-a4ba0d8b6af1.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3432406c-c878-41d2-8a5e-a4ba0d8b6af1.png)'
- en: 'Install the `build-essential` tool on your machine, which is usually present
    by default:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的机器上安装`build-essential`工具，该工具通常默认存在：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个菜谱：
- en: Create a file named `lib.rs` and open it in your text editor.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`lib.rs`的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the `double_input` function in `lib.rs` Rust script with the given attributes:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lib.rs` Rust脚本中创建名为`double_input`的函数，并使用给定的属性：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the file `main.c` in the `c_to_rust`/`src` directory, which is the C
    script:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`c_to_rust/src`目录下创建名为`main.c`的文件，这是一个C脚本：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create `Makefile` in the root location of the project directory, `c_to_rust`,
    for creating the `build` rules:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录`c_to_rust`的根位置创建`Makefile`，用于创建`build`规则：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码成功执行后得到以下输出：
- en: '![](img/7cb5a30d-14f0-4b52-b39a-7641619ddfd3.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7cb5a30d-14f0-4b52-b39a-7641619ddfd3.png)'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created an external library in Rust, which can be used by
    other foreign code. The `lib.rs` file inside the `src` folder is the entry point
    for packages and libraries in Rust.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们在Rust中创建了一个外部库，它可以被其他外国代码使用。`src`文件夹中的`lib.rs`文件是Rust中包和库的入口点。
- en: In `Cargo.toml`, while setting up the project, we set the `crate-type` field
    as `["staticlib"]`, which lets Cargo know the project should be compiled as a
    library.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`中设置项目时，我们将`crate-type`字段设置为`["staticlib"]`，这样Cargo就会知道项目应该被编译为库。
- en: The `lib` section helps when building a specific target. In our case, it is
    to `build` a package. The `name` field of a target is the name of the library
    that will be generated and it is the default name of the package or project. The
    dashes in the name of the project will be replaced with underscores.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib`部分在构建特定目标时很有帮助。在我们的例子中，它是用来`build`一个包。目标中的`name`字段是生成的库的名称，也是包或项目的默认名称。项目名称中的破折号将被下划线替换。'
- en: In `lib.rs`, we created a `staticlib` type crate where we have the `double_input`
    function, which takes an integer input and returns an integer output by multiplying
    the input by `2`. We set the `double_input` function as public using the `pub`
    keyword, which allows external sources to call the function and the `extern` keyword
    makes this function stick to the C calling conventions. The `no_mangle` attribute
    turns off Rust's name mangling so that it is easier to link.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lib.rs`中，我们创建了一个包含`double_input`函数的`staticlib`类型crate，该函数接受一个整数输入，通过将输入乘以`2`返回一个整数输出。我们使用`pub`关键字将`double_input`函数设置为公共，允许外部源调用该函数，而`extern`关键字使该函数遵循C调用约定。`no_mangle`属性关闭了Rust的名称修饰，这使得链接更容易。
- en: In the `main.c` file, we call the externally created `double_input` function
    using the `extern` keyword with the declaration of `int32_t double_input(int32_t
    input)`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.c`文件中，我们使用`extern`关键字和`int32_t double_input(int32_t input)`的声明调用外部创建的`double_input`函数。
- en: In order to compile and run this program, we used the `make` tool and created
    some rules, which are sequential steps for executing the project. We created `Makefile`
    where we first determined the shell using the command `($(shell uname),Darwin)`
    for detecting the OS type for setting the corresponding flags. If the OS is `Darwin`,
    then the `LDFLAGS` would be `-Wl,-dead_strip`; else `LDFLAGS` is set as `-Wl,--gc-sections
    -lpthread`. These are the flags to the linker (lD). The `all` rule is dependant
    on the `target/double` rule and it executes the same rule once the rules dependant
    to`target/double` are satisfied.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和运行此程序，我们使用了`make`工具并创建了一些规则，这些规则是执行项目的顺序步骤。我们在`Makefile`中首先使用命令`($(shell
    uname),Darwin)`确定shell，用于检测操作系统类型以设置相应的标志。如果操作系统是`Darwin`，则`LDFLAGS`将是`-Wl,-dead_strip`；否则`LDFLAGS`设置为`-Wl,--gc-sections
    -lpthread`。这些是链接器（lD）的标志。`all`规则依赖于`target/double`规则，并在依赖于`target/double`的规则满足后执行相同的规则。
- en: The `target` rule creates the target directory using the command `mkdir -p $@`,
    where `$@` refers to the left of the `:` in the rule. The `target/double` is dependent
    on the rules, `target/main.o` and `target/debug/libdouble_input.a`. When `target/main.o`
    runs, we are basically running `cc -o target/main.o -c src/main.c`, which creates
    the `main.o` in the `target` directory. The `target/debug/libdouble_input.a` runs
    `cargo build` command, which creates `libdouble_input.a`. The `target/double`
    is run with `cc -o target/double target/main.o target/debug/libdouble_input.a
    -Wl,--gc-sections -lpthread`, where the links are created. Finally, the executable
    `double` is run.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`规则使用命令`mkdir -p $@`创建目标目录，其中`$@`指的是规则中`:`左侧的部分。`target/double`依赖于规则，`target/main.o`和`target/debug/libdouble_input.a`。当`target/main.o`运行时，我们基本上运行`cc
    -o target/main.o -c src/main.c`，在`target`目录中创建`main.o`。`target/debug/libdouble_input.a`运行`cargo
    build`命令，创建`libdouble_input.a`。`target/double`使用`cc -o target/double target/main.o
    target/debug/libdouble_input.a -Wl,--gc-sections -lpthread`运行，其中创建了链接。最后，运行可执行文件`double`。'
- en: Calling Rust operations from Node.js apps
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Node.js应用程序中调用Rust操作
- en: In this recipe, we will create a Rust function, which can be called from JavaScript,
    and this technique can be really helpful when the developer wants to improve the
    performance of a certain unit of their web application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将创建一个可以从JavaScript中调用的Rust函数，当开发者想要提高他们Web应用程序中某个单元的性能时，这项技术非常有帮助。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following system dependencies before we can go
    ahead and create a Rust unit for the Node.js project. Follow the given steps to
    download and install the node dependencies package for your project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建Node.js项目的Rust单元之前，我们必须安装以下系统依赖项。按照以下步骤下载并安装项目所需的node依赖项包：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: 'Create a Rust library project using the Cargo tool:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cargo工具创建Rust库项目：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Enter the newly created Rust library project:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入新创建的Rust库项目：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的文本编辑器中打开`Cargo.toml`文件，并按照以下截图进行修改：
- en: '![](img/df0bb655-741d-4c15-8969-504e2df7d602.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df0bb655-741d-4c15-8969-504e2df7d602.png)'
- en: 'Install Node.js and `npm` in your machine:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的机器上安装Node.js和`npm`：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此配方：
- en: Open a file named `lib.rs` located in the `node_to_rust/src` directory and open
    it your text editor.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`node_to_rust/src`目录下的名为`lib.rs`的文件，并使用你的文本编辑器打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `double_input` function in the Rust script with the given attributes:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Rust脚本中创建具有给定属性的`double_input`函数：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the `main.js` file in the `node_to_rust/src` directory, which is the
    JavaScript code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`node_to_rust/src`目录下创建`main.js`文件，这是JavaScript代码：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create `Makefile` in the `node_to_rust/` directory for creating `build` rules:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`node_to_rust/`目录下创建`Makefile`以创建`build`规则：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行我们的代码后，我们将得到以下输出：
- en: '![](img/08534f2a-ec5f-4494-a862-47a2acec8385.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08534f2a-ec5f-4494-a862-47a2acec8385.png)'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we create an external library in Rust, which can be used by
    other foreign code. The `lib.rs` file inside the `src` folder is the entry point
    for packages and libraries in Rust.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 Rust 创建了一个外部库，该库可以被其他外国代码使用。`src` 文件夹内的 `lib.rs` 文件是 Rust 中包和库的入口点。
- en: In `Cargo.toml`, while setting up the project, we set the `crate-type` field
    as `["dylib"]`, which lets Cargo know the project should be compiled as a dynamic
    library.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 中，在设置项目时，我们将 `crate-type` 字段设置为 `["dylib"]`，这会让 Cargo 知道项目应该被编译为动态库。
- en: In `lib.rs`, we created a `dylib` type crate and we have a `double_input` function,
    which takes an integer input and returns an integer output by doubling the given
    input. We can see that it's the `pub` keyword that allows external sources to
    call the function, and `extern` makes this function stick to the Js calling conventions.
    The `no_mangle` attribute turns off Rust's name mangling so that it is easier
    to link.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `lib.rs` 中，我们创建了一个 `dylib` 类型的 crate，并有一个 `double_input` 函数，它接受一个整数输入，通过将给定输入加倍来返回一个整数输出。我们可以看到，是
    `pub` 关键字允许外部源调用该函数，而 `extern` 使此函数符合 Js 调用约定。`no_mangle` 属性关闭了 Rust 的名称混淆，这使得链接更容易。
- en: In the `main.js` file, where we call the externally created `double_input` function
    using the `ffi` node package, we create a variable, `ffi`, which is loaded with
    the units of `ffi` node module using the `require` keyword. Using the inbuilt
    `ffi.library` function, we load the `build` package at `target/debug/libdouble_input`
    and assign the return object type to the variable `lib`, which contains the method
    `double_input`. Later, we can use this function as `lib.double_int(input)`, where
    the `input` variable is assigned to a value of `4` in the previous statements
    of the Js code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.js` 文件中，我们使用 `ffi` 节点包调用外部创建的 `double_input` 函数，我们创建一个变量 `ffi`，它使用 `require`
    关键字加载 `ffi` 节点模块的单位。使用内置的 `ffi.library` 函数，我们在 `target/debug/libdouble_input`
    加载 `build` 包，并将返回的对象类型分配给变量 `lib`，它包含 `double_input` 方法。稍后，我们可以使用此函数作为 `lib.double_int(input)`，其中
    `input` 变量在 Js 代码的前述语句中分配了一个值为 `4`。
- en: In order to compile and run this program, we use the `make` tool and create
    certain rules, which are sequential steps for executing the project. We create
    `Makefile` where we first determine the `($(shell uname),Darwin)` shell for detecting
    the OS type to set the flags. If the OS is `Darwin`, then `EXT` would be `EXT
    := dylib`; else `EXT` is set to `so`. The `all` rule runs `target/debug/libdouble_input.$(EXT)`
    and `node_modules/ffi` before executing `node src/main.js`, which will run the
    JavaScript and produce the logs. The first rule is `target/debug/libdouble_input.$(EXT)`,
    which creates the crate by building the Rust project using the `cargo build` command,
    and the next rule is `node_modules/ffi`, which installs the node package `ffi`
    by `npm install ffi`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和运行此程序，我们使用 `make` 工具并创建某些规则，这些规则是执行项目的顺序步骤。我们创建 `Makefile`，在其中首先确定用于检测操作系统类型的
    `($(shell uname),Darwin)` shell，以设置标志。如果是 `Darwin`，则 `EXT` 将为 `EXT := dylib`；否则
    `EXT` 设置为 `so`。`all` 规则运行 `target/debug/libdouble_input.$(EXT)` 和 `node_modules/ffi`，然后执行
    `node src/main.js`，这将运行 JavaScript 并生成日志。第一个规则是 `target/debug/libdouble_input.$(EXT)`，它通过使用
    `cargo build` 命令构建 Rust 项目来创建 crate，下一个规则是 `node_modules/ffi`，它通过 `npm install
    ffi` 安装节点包 `ffi`。
- en: Calling Rust operations from Python
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Python 调用 Rust 操作
- en: In this recipe, we will follow the steps that we implemented for the last two
    recipes where we created a Rust function and used it in other languages as integral
    units. Here, we will call the Rust unit using Python.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将遵循我们在前两个菜谱中实施的步骤，其中我们创建了一个 Rust 函数，并在其他语言中将其用作基本单元。这里，我们将使用 Python
    调用 Rust 单元。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following system dependencies before we can go
    ahead and create a Rust unit for the Python project. Follow the given steps to
    download and install the node dependencies package for your project:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够继续创建 Python 项目的 Rust 单元之前，我们必须安装以下系统依赖项。按照以下步骤下载并安装项目所需的节点依赖包：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: 'Create a Rust library project using the Cargo tool:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 工具创建 Rust 库项目：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Enter the newly created Rust library project:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入新创建的 Rust 库项目：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的首选文本编辑器中打开 `Cargo.toml` 文件，并按照以下截图进行修改：
- en: '![](img/e7b81156-7984-4ddb-b310-c8f80b010461.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7b81156-7984-4ddb-b310-c8f80b010461.png)'
- en: 'Install Python on your machine, which is pre-installed on your machine:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的机器上安装 Python，它已预装在您的机器上：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此配方：
- en: Create a file named `lib.rs` and open it your text editor.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `lib.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头部，包含相关信息：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the `double_input` function in the Rust script with the given attributes:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Rust 脚本中创建具有给定属性的 `double_input` 函数：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create the `main.py` file, which is the Python code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `main.py` 的文件，这是 Python 代码：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create `Makefile` for creating the `build` rules:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Makefile` 以创建 `build` 规则：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们代码成功执行后，将得到以下输出：
- en: '![](img/991e769c-87fe-42aa-8b20-8f80b407658a.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/991e769c-87fe-42aa-8b20-8f80b407658a.png)'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created an external library in Rust, which can be used by
    other foreign code. The `lib.rs` file inside the `src` folder is the entry point
    for packages and libraries in Rust.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用 Rust 创建了一个外部库，该库可以被其他外国代码使用。`src` 文件夹中的 `lib.rs` 文件是 Rust 中包和库的入口点。
- en: In `Cargo.toml`, while setting up the project, we set the `crate-type` field
    as `["dylib"]`, which lets Cargo know the project should be compiled as a dynamic
    library.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 中，在设置项目时，我们将 `crate-type` 字段设置为 `["dylib"]`，这会让 Cargo 知道项目应该被编译为动态库。
- en: In `lib.rs`, we created a `dylib` type crate and we have a `double_input` function,
    which takes an integer input and returns an integer output by doubling the given
    input. We can see that it's the `pub` keyword that allows external sources to
    call the function, and `extern` makes this function stick to the Js calling conventions.
    The `no_mangle` attribute turns off Rust's name mangling so that it is easier
    to link.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `lib.rs` 中，我们创建了一个 `dylib` 类型的 crate，并有一个 `double_input` 函数，该函数接受一个整数输入，通过加倍给定输入返回一个整数输出。我们可以看到，是
    `pub` 关键字允许外部源调用该函数，而 `extern` 使此函数符合 Js 调用约定。`no_mangle` 属性关闭 Rust 的名称混淆，使其更容易链接。
- en: In the `main.py` file, we call the externally created `double_input` function
    build using Rust code by using the `cdll` unit of the `ctypes` Python module where
    we use the `LoadLibrary` function. We pass the location of the `so`(shared object)
    file generated after compilation of the Rust project to the `LoadLibrary` Python
    function, which in our case is located at `target/debug/libdouble_input.so`. On
    successful loading of the `so` file, we assign `double_input` as `lib.double_input`
    and call it later in the script.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.py` 文件中，我们使用 `ctypes` Python 模块的 `cdll` 单元调用使用 Rust 代码构建的外部 `double_input`
    函数。我们将 Rust 项目的编译后生成的 `so`（共享对象）文件的路径传递给 `LoadLibrary` Python 函数，在我们的例子中位于 `target/debug/libdouble_input.so`。在成功加载
    `so` 文件后，我们将 `double_input` 赋值为 `lib.double_input` 并在脚本中稍后调用它。
- en: In order to compile and run this program, we use the `make` tool and create
    certain rules, which are sequential steps for executing the project. We create
    a `Makefile` where we first determine the `($(shell uname),Darwin)` shell for
    detecting the OS type to set the flags. If the OS is `Darwin` then `EXT` would
    be `EXT := dylib`; else `EXT` is set as `so`. The `all` rule runs `target/debug/libdouble_input.$(EXT)`
    before running the Python `src/main.py`. The other rule basically builds the Rust
    project to build the `libdouble_input.so` file, which is used by the Python script
    to run the corresponding `double_input` function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和运行此程序，我们使用 `make` 工具并创建某些规则，这些规则是执行项目的顺序步骤。我们创建一个 `Makefile`，在其中首先确定用于检测操作系统类型的
    `($(shell uname),Darwin)` shell。如果操作系统是 `Darwin`，则 `EXT` 将被设置为 `EXT := dylib`；否则
    `EXT` 被设置为 `so`。`all` 规则会在运行 Python 的 `src/main.py` 之前运行 `target/debug/libdouble_input.$(EXT)`。其他规则基本上构建
    Rust 项目以生成 `libdouble_input.so` 文件，该文件由 Python 脚本用于运行相应的 `double_input` 函数。
- en: Writing a Python module in Rust
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中编写 Python 模块
- en: In this recipe, we will create a Python module or library in Rust and import
    the `create` module in the Python script. Rust provides a great list of safe production-level
    type systems, so the current Python units of a project can be rewritten in Rust
    to achieve faster processing and a safer application. Here, we create a library
    in Rust named `example` with a function named `fibo`, which takes in an index
    value and produces the Fibonacci sequence value at the index.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Rust 创建一个 Python 模块或库，并在 Python 脚本中导入 `create` 模块。Rust 提供了一系列安全的生产级类型系统，因此可以将项目的当前
    Python 单元重写为 Rust，以实现更快的处理和更安全的应用。在这里，我们使用 Rust 创建了一个名为 `example` 的库，其中包含一个名为
    `fibo` 的函数，该函数接受一个索引值并生成该索引处的斐波那契数列值。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following system dependencies before we can go
    ahead and create a Python module using Rust. Follow the given steps to download
    and install the dependencies package for your project:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以继续创建使用 Rust 的 Python 模块之前，我们必须安装以下系统依赖项。按照以下步骤下载并安装项目的依赖项包：
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: 'Create a Rust library project using the Cargo tool:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 工具创建 Rust 库项目：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Enter the newly created Rust library project:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入新创建的 Rust 库项目：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你最喜欢的文本编辑器中打开 `Cargo.toml` 文件，并按照以下截图进行修改：
- en: '![](img/72a8d93d-4ab0-4b37-bb86-b46b5208027e.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72a8d93d-4ab0-4b37-bb86-b46b5208027e.png)'
- en: 'We need to have Python installed on the machine for the executing the steps
    in this recipe. In most of the systems Python comes pre-installed on the machine,
    if not run the following commands below:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在机器上安装 Python 以执行这个菜谱中的步骤。在大多数系统中，Python 默认已经安装在机器上，如果没有，请运行以下命令：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个菜谱：
- en: Create a file named `lib.rs` and open it in your text editor.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `lib.rs` 的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Import the `cpython` library and the corresponding module:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `cpython` 库和相应的模块：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the `fibo` function in the Rust language, which is an implementation
    of the Fibonacci sequence:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Rust 语言中创建 `fibo` 函数，这是斐波那契数列的实现：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the Python module interface, which exposes the `fibo` function to Python
    calls:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Python 模块接口，将 `fibo` 函数暴露给 Python 调用：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create the `test.py` file outside the `src` directory, which is the Python
    code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 目录外创建一个名为 `test.py` 的文件，这是 Python 代码：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create `Makefile` for creating `build` rules:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于创建 `build` 规则的 `Makefile`：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will get the following output on the successful execution of our code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们代码成功执行后，我们将得到以下输出：
- en: '![](img/d1d5f620-4601-4b7b-a74a-44283692f9ba.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1d5f620-4601-4b7b-a74a-44283692f9ba.png)'
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we create an external library in Rust, which can be used by
    other foreign code. The `lib.rs` file inside the `src` folder is the entry point
    for packages and libraries in Rust.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个 Rust 的外部库，它可以被其他外部代码使用。`src` 文件夹内的 `lib.rs` 文件是 Rust 中包和库的入口点。
- en: In `Cargo.toml`, while setting up the project, we set the `crate-type` field
    as `["dylib"]`, which lets Cargo know that the project should be compiled as a
    dynamic library. The name of the library is `example`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 中设置项目时，我们将 `crate-type` 字段设置为 `["dylib"]`，这样 Cargo 就知道项目应该编译为动态库。库的名称是
    `example`。
- en: We installed the latest `rust-cpython` crate from git, which makes it possible
    to execute Python code from Rust and build a module in Rust for Python. The Python
    module created can be used for both Python 2.7 and 3; for Python 2.7 we have to
    enable `features = ["python27-sys"]` while building the Rust project for the first
    time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 git 中安装了最新的 `rust-cpython` crate，这使得从 Rust 中执行 Python 代码并构建 Rust 中的模块成为可能。创建的
    Python 模块可以用于 Python 2.7 和 3；对于 Python 2.7，在第一次构建 Rust 项目时必须启用 `features = ["python27-sys"]`。
- en: 'In `lib.rs`, we import the `cpython` crate and use the modules `Python` and
    `PyResult`. Then, we create a Rust function named `fibo`, which has taken in arguments
    of the `py: Python` and `n : u64` types, and the return type is `PyResult<u64>`.
    Here the `py` argument is of the `Python` type and the return value is wrapped
    to be a `PyResult` type, which is an alias to the Result type curated for custom
    made Python operations. Since we have these types in the `rust-cpython` project,
    we don''t have to explicitly handle type conversions from Python to Rust. In the
    `fibo` function, we implement the sequence.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '在`lib.rs`中，我们导入`cpython`包并使用`Python`和`PyResult`模块。然后，我们创建一个名为`fibo`的Rust函数，它接受`py:
    Python`和`n : u64`类型的参数，返回类型为`PyResult<u64>`。在这里，`py`参数是`Python`类型，返回值被包装为`PyResult`类型，它是为自定义Python操作量身定制的Result类型的别名。由于我们在`rust-cpython`项目中已经有了这些类型，我们不需要显式处理从Python到Rust的类型转换。在`fibo`函数中，我们实现了序列。'
- en: 'If the entered `n` value is less than `2`, we return `OK(1)`, and, for all
    other values greater than `2`, we have two mutable variable `prev1` and `prev2`
    initially assigned to `1`. We then iterate using a `for` loop till `n`. Inside
    the `for` loop, we create an immutable variable, `new`, which is the sum of `prev1`
    and `prev2`. After the sum operation, the `prev1` value is assigned to `prev2`
    and `new` is assigned to `prev1`. We then return `OK(prev1)` once the loop ends.
    The next step is to expose the `fibo` function as part of the module; this can
    be done with the `py_module_initializer!` and `py_fn!` macros. The `py_module_initializer`
    macro basically creates a Python-compatible module. We need an initializer that
    exposes the public interface. To expose the `fibo` function, we use the `try!`
    macro by calling `m.add(py, "fibo", py_fn!(py, fibo(rand_int: u64)))`, where `m.add`
    adds the `fibo` function with the `py_fn!` macro defining the Python module. The
    initializer''s macro needs a `Result<>` as the return value. So, we return `Ok(())`
    at the end of the macro.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '如果输入的`n`值小于`2`，我们返回`OK(1)`，而对于所有大于`2`的其他值，我们初始化两个可变变量`prev1`和`prev2`为`1`。然后我们使用`for`循环迭代到`n`。在`for`循环内部，我们创建一个不可变变量`new`，它是`prev1`和`prev2`的和。在求和操作后，将`prev1`的值赋给`prev2`，将`new`的值赋给`prev1`。一旦循环结束，我们返回`OK(prev1)`。下一步是将`fibo`函数作为模块的一部分暴露出来；这可以通过使用`py_module_initializer!`和`py_fn!`宏来实现。`py_module_initializer`宏基本上创建了一个兼容Python的模块。我们需要一个初始化器来暴露公共接口。为了暴露`fibo`函数，我们使用`try!`宏通过调用`m.add(py,
    "fibo", py_fn!(py, fibo(rand_int: u64)))`来实现，其中`m.add`使用`py_fn!`宏定义Python模块添加`fibo`函数。初始化器的宏需要一个`Result<>`作为返回值。因此，我们在宏的末尾返回`Ok(())`。'
- en: In the `test.py` file, we import the `example` module and print the result of
    the Fibonacci function for an input index `4` using `print(example.fibo(4))`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test.py`文件中，我们导入`example`模块，并使用`print(example.fibo(4))`打印出输入索引`4`的斐波那契函数的结果。
- en: In order to compile and run this program, we use the `make` tool and create
    certain rules, which are sequential steps for executing the project. We create
    `Makefile` where we have the `all` rule, which depends on `run`. The `run` rule,
    in turn, depends on `build`. In the `build` step, the Rust projects are built
    using `cargo build --release`, which creates the external shared object file `libexample.so`
    in `target/release`. Post building, we copy the created `so` file as `example.so`
    in the home directory of the project where the `test.py` code is located. We then
    execute the `run` rule, which basically runs the `test.py` code and prints the
    result.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和运行这个程序，我们使用`make`工具并创建某些规则，这些规则是执行项目的顺序步骤。我们创建`Makefile`，其中包含`all`规则，它依赖于`run`。`run`规则反过来又依赖于`build`。在`build`步骤中，使用`cargo
    build --release`构建Rust项目，这将在`target/release`中创建外部共享对象文件`libexample.so`。构建完成后，我们将创建的`so`文件复制为`example.so`，位于包含`test.py`代码的项目的主目录中。然后我们执行`run`规则，该规则基本上运行`test.py`代码并打印结果。
