- en: Built-in Macros and Configuration Items
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置宏和配置项
- en: Now that we know how to improve our code efficiency, we can learn how to make
    it work on multiple platforms and how to make sure we take advantage of all possible
    native optimizations, while we make the code faster and easier to implement. Metaprogramming
    allows us to do all that with really easy code snippets, and you probably know
    some of these features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何提高我们的代码效率，我们可以学习如何使它在多个平台上工作，并确保我们充分利用所有可能的本地优化，同时使代码更快、更容易实现。元编程允许我们通过非常简单的代码片段来完成所有这些，你可能已经了解其中的一些特性。
- en: 'In this chapter, you will learn how to use the following macros and configuration
    items built in with the compiler and the standard library:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用以下宏和编译器以及标准库内置的配置项：
- en: Attributes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Crate features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Crate功能
- en: Macros
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏
- en: Nightly functionality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nightly功能
- en: Understanding attributes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解属性
- en: Rust allows us to conditionally compile certain parts of the code depending
    on what we call attributes. These attributes can be applied to either complete
    crates/modules or to specific functions, scopes, or even structure fields or enumeration
    variants. We saw some examples when we talked about Clippy, but these attributes
    allow for so much more that we will now look at them in depth.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Rust允许我们根据我们调用的属性有条件地编译代码的某些部分。这些属性可以应用于完整的crate/module，也可以应用于特定的函数、作用域，甚至是结构字段或枚举变体。我们在讨论Clippy时看到了一些例子，但这些属性允许我们做更多的事情，我们现在将深入探讨它们。
- en: 'Let''s first see how an attribute works. An attribute that you want to apply
    to the whole current module/crate will be written like this: `#![{attribute}]`.
    Ones that apply to the scope/function/field/variant next to it will be written
    like this: `#[{attribute}]`. Note that the first has the `!` symbol between the
    hash tag and the attribute.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看属性是如何工作的。要应用于整个当前模块/crate的属性将写成这样：`#![{attribute}]`。应用于紧邻的作用域/函数/字段/变体的属性将写成这样：`#[{attribute}]`。请注意，第一个在井号和属性之间有一个`!`符号。
- en: You have probably seen attributes such as `#[macro_use]` or `#[derive(Debug)]`
    somewhere in some code. The first one will allow using macros from an external
    crate, while the second one will derive the `Debug` trait in the given structure
    or enumeration. Let's start by checking what can we avoid typing thanks to the
    derivation of traits.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在某些代码中看到过如`#[macro_use]`或`#[derive(Debug)]`之类的属性。第一个将允许使用外部crate中的宏，而第二个将推导给定结构或枚举中的`Debug`特性。让我们先检查一下我们可以通过特性推导避免输入什么。
- en: Trait derivations
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性推导
- en: 'There are two types of trait derivations: built-in derives and custom derives.
    We will talk about the second ones in [Chapter 9](e869a4d7-e2a8-488a-a767-8c75364a8962.xhtml),
    *Creating Your Own Macros*, but let''s see what deriving can help us achieve.
    Let''s imagine the following structure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 特性推导有两种类型：内置推导和自定义推导。我们将在[第9章](e869a4d7-e2a8-488a-a767-8c75364a8962.xhtml)“创建您的宏”中讨论第二种，但现在让我们看看推导能帮助我们实现什么。让我们想象以下结构：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s recommended that every structure implements the `Debug` trait so that
    if, for example, we need to debug what is happening with some part of the code,
    we can use the `println!("{:?}", element);` syntax. It should show the contents
    of the fields, so we could imagine something like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 建议每个结构实现`Debug`特性，这样，例如，如果我们需要调试代码中某个部分的运行情况，我们可以使用`println!("{:?}", element);`语法。它应该显示字段的值，因此我们可以想象以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will print the field information. For example, suppose we have the following
    code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印字段信息。例如，假设我们有以下代码：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will receive this output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is good, since it enables us to get information about our structure, but
    it's difficult to maintain and adds a lot of boilerplate code to our code base.
    Let's suppose we have a 20-field structure, and we need to remove 2 fields, and
    add 4 new ones. This rapidly escalates to a big mess. We will need to modify the
    trait implementation, maybe change the order of the fields, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为它使我们能够获取有关我们结构的信息，但它难以维护，并且给我们的代码库添加了大量样板代码。假设我们有一个20个字段的结构，我们需要删除2个字段，并添加4个新字段。这迅速演变成一个混乱的局面。我们需要修改特性实现，可能改变字段的顺序，等等。
- en: 'This is where the `#[derive]` attribute comes into play: it will write that
    code for us, and if we change our structure it will rewrite that code. And, even
    better, it will not pollute our code base, since that code will be written at
    compile time. The whole `Debug` trait implementation can be replaced by adding
    `#[derive(Debug)]` to the beginning of the structure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`#[derive]`属性发挥作用的地方：它会为我们编写代码，并且如果我们的结构发生变化，它将重新编写代码。而且，更好的是，它不会污染我们的代码库，因为这段代码将在编译时编写。整个`Debug`特性实现可以通过在结构的开始处添加`#[derive(Debug)]`来替换：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And, if we run the program again, we will see that nothing has changed. There
    are multiple traits that can be derived: comparison traits (`PartialEq`, `Eq`,
    `PartialOrd`, and `Ord`), `Copy`, `Clone`, `Hash`, `Default` and, as we saw, `Debug`.
    Let''s see what each of these traits does. We already talked about the `Debug`
    trait, so let''s start with comparison traits.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行程序，我们会看到没有任何变化。可以派生出多个特性：比较特性（`PartialEq`、`Eq`、`PartialOrd`和`Ord`）、`Copy`、`Clone`、`Hash`、`Default`以及我们看到的`Debug`。让我们看看这些特性各自的作用。我们已经讨论了`Debug`特性，所以让我们从比较特性开始。
- en: The first two derivable traits are `PartialEq` and `Eq`. Both of them make it
    possible to use the `==` and the `!=` operators with the structure, but how do
    they work?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个可派生的特性是`PartialEq`和`Eq`。两者都使得可以使用`==`和`!=`运算符与结构一起使用，但它们是如何工作的呢？
- en: '`PartialEq` is meant to describe a partial equivalence relation, which means
    that if *A* is partially equal to *B*, *B* is partially equal to *A*, and if,
    in that example, *B* is partially equal to *C*, *A* is also partially equal to
    *C*, since the property is symmetric and transitive.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`PartialEq`旨在描述部分等价关系，这意味着如果*A*部分等于*B*，*B*部分等于*A*，并且如果在这个例子中*B*部分等于*C*，*A*也部分等于*C*，因为这种性质是对称的和传递的。'
- en: When derived for structures or enumerations, it will only be available if all
    members of the structure or enumeration already implement `PartialEq`, and it
    will consider two structures or enumerations equal if all of their fields are
    equal.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当为结构或枚举派生时，它只有在结构或枚举的所有成员已经实现了`PartialEq`时才可用，并且如果所有字段都相等，它将考虑两个结构或枚举相等。
- en: The `Eq` trait requires an extra condition, and it cannot be checked at compile
    time. It requires that *A* is equal to *A*. This might sound strange if we are
    talking about structures with simple fields, but there is a simple type in the
    standard library that shows the opposite behavior. The floating point types (`f32`
    and `f64`) do not respect this when they are **NaN** (**Not a Number**). Two `NaN`
    are not equal, even if both of them are `NaN`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Eq`特性需要额外的条件，并且不能在编译时检查。它要求*A*等于*A*。如果我们谈论具有简单字段的结构，这可能会听起来很奇怪，但在标准库中有一个简单的类型显示了相反的行为。浮点类型（`f32`和`f64`）在它们是**NaN**（**不是一个数字**）时不尊重这一点。两个`NaN`不相等，即使它们都是`NaN`。'
- en: To derive the `Eq` trait, it requires all the fields in the structure or enumeration
    to implement `Eq`. This means that you will not be able to implement `Eq` for
    any structure or enumeration containing a floating point number. This trait does
    not require any method implementation, it just tells the compiler that the structure
    or enumeration is always equal to itself, without any extra code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要派生`Eq`特性，结构或枚举中的所有字段都必须实现`Eq`。这意味着你将无法为包含浮点数的任何结构或枚举实现`Eq`。这个特性不需要任何方法实现，它只是告诉编译器结构或枚举总是等于自身，而不需要任何额外的代码。
- en: The next two traits, `PartialOrd` and `Ord`, work similarly to `PartialEq` and
    `Eq`, but they add the ability to compare two elements to know their order, so
    it allows you to use the `<`, `<=`, `=>` and `>` operators with the structure
    or enumeration. Both require that if *A < B* and *B < C*, then *A < C* (and the
    same for `==` and `>`), and that if *A > B*, then *A < B* is false. The `Ord`
    trait also requires that one and only one of *A < B*, *A == B*, or *A > B* is
    true.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个特性`PartialOrd`和`Ord`与`PartialEq`和`Eq`的工作方式类似，但它们增加了比较两个元素以了解它们顺序的能力，因此允许你使用`<`、`<=`、`=>`和`>`运算符与结构或枚举一起使用。两者都需要满足如果*A
    < B*且*B < C*，则*A < C*（对于`==`和`>`也是如此），并且如果*A > B*，则*A < B*是错误的。`Ord`特性还要求只有一个*A
    < B*、*A == B*或*A > B*是正确的。
- en: As an extra point of information, the `PartialOrd` trait adds a `partial_cmp()`
    function, while the `Ord` trait adds the `cmp()` function. Both return an `Ordering`,
    but for the first function, it is optional (`Option<Ordering>`) and for the second
    one, it is mandatory. This is because a partial comparison could not have any
    defined order for a particular value; remember the `NaN` case for floats.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外信息点，`PartialOrd` 特性添加了一个 `partial_cmp()` 函数，而 `Ord` 特性添加了 `cmp()` 函数。两者都返回一个
    `Ordering`，但对于第一个函数，它是可选的（`Option<Ordering>`），而对于第二个函数，则是强制的。这是因为部分比较可能对于某个特定值没有定义的顺序；记住浮点数的
    `NaN` 情况。
- en: 'Implementing this function for structures that contain only `PartialOrd` or
    `Ord` fields is pretty easy: define which is the most relevant field for ordering
    and compare them between structures, then, if equal, compare the next relevant
    field. This can be avoided by using `#[derive(PartialOrd)]` or `#[derive(PartialOrd,
    Ord)]`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只包含 `PartialOrd` 或 `Ord` 字段的结构的函数实现相当简单：定义哪个字段对于排序是最相关的，然后在结构之间比较它们，然后，如果相等，比较下一个相关字段。这可以通过使用
    `#[derive(PartialOrd)]` 或 `#[derive(PartialOrd, Ord)]` 来避免。
- en: The derivation will compare fields from first to last, so make sure you put
    the most relevant fields first. In the case of enumerations, it will consider
    first variants *smaller* than latest variants. If you want to change that, you
    can either change the order of fields or variants, or implement the trait yourself.
    You might also want to only compare one of the fields of a structure and consider
    the rest irrelevant. In this case, you will need to implement the trait yourself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 派生将按从第一个到最后一个的顺序比较字段，所以请确保您将最相关的字段放在前面。在枚举的情况下，它将考虑第一个变体比最新变体*小*。如果您想改变这一点，您可以通过更改字段的顺序或变体，或者自己实现特性来实现。您可能还只想比较结构的一个字段，并认为其余字段无关紧要。在这种情况下，您将需要自己实现特性。
- en: 'To implement any of these traits, you can simply compare the fields one by
    one. Note that `Ord` requires `Eq`, so we need to implement `PartialEq` to check
    only the day, month, and year and then derive `Eq`. You can check the details
    of the implementation as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现任何这些特性，您只需逐个比较字段。请注意，`Ord` 需要 `Eq`，因此我们需要实现 `PartialEq` 来检查日期、月份和年份，然后派生
    `Eq`。您可以按照以下方式检查实现的细节：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we compare the date by first checking the year. If the year
    is the same, we compare the month, and if the month is equal, we compare the day.
    We do not check which comments are associated to the date because we do not need
    to. The `PartialOrd` trait implementation only returns the result from the `Ord`
    trait wrapped in an `Option::Some`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先检查年份来比较日期。如果年份相同，我们比较月份，如果月份相等，我们比较日期。我们不需要检查与日期关联的评论，因为我们不需要。`PartialOrd`
    特性的实现只返回 `Ord` 特性包裹在 `Option::Some` 中的结果。
- en: The next two, the `Copy` and `Clone` traits, allow for a structure to be copied
    in memory. This means that you will be able to copy, one by one, all the contents
    of the instance to another instance. The `Clone` trait enables this by adding
    the `clone()` method, which usually only calls the `clone()` method of each of
    the fields. It can run any arbitrary code, though, and you never know whether
    it will be expensive to clone the object or not. This is why using it requires
    an explicit call to the `clone()` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个特性，`Copy` 和 `Clone`，允许在内存中复制结构。这意味着您将能够逐个复制实例的所有内容到另一个实例。`Clone` 特性通过添加
    `clone()` 方法来实现这一点，通常它只调用每个字段的 `clone()` 方法。但它可以运行任何任意的代码，您永远不知道复制对象是否会昂贵。这就是为什么使用它需要显式调用
    `clone()` 方法的原因。
- en: The `Copy` trait, on the other hand, makes it implicit to copy one element.
    It means that, for example, when moving a variable to a function, if it's a `Copy`
    variable, you will be able to still use it after the move, because only a copy
    of it will be moved. We saw some examples of the benefits and drawbacks of this
    approach in [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml),* Common Performance
    Pitfalls*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Copy` 特性使得复制一个元素是隐式的。这意味着，例如，当将变量移动到函数中时，如果它是 `Copy` 变量，您在移动后仍然可以使用它，因为只有它的副本会被移动。我们在[第1章](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml)，*常见性能陷阱*中看到了这种方法的一些优点和缺点。
- en: You cannot implement the `Copy` trait, though, since Rust requires it to be
    extremely inexpensive and it's implemented using compiler intrinsics. So, you
    can safely use a `Copy` type knowing it will not be expensive to copy it, but
    you cannot implement it by yourself. You can derive it though. Deriving `Copy`
    for a structure or an enumeration requires the structure or enumeration to implement
    `Clone` (you can derive it too if all elements inside implement `Clone`) and all
    elements inside to implement `Copy`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能为具有复杂不可复制类型的结构实现`Copy`特质，因为Rust要求它必须非常便宜，并且它使用编译器内建函数实现。所以，你可以安全地使用`Copy`类型，知道复制它不会很昂贵，但你不能自己实现它。你可以推导它。为结构或枚举推导`Copy`需要该结构或枚举实现`Clone`（如果所有内部元素都实现了`Clone`，你也可以推导它）以及所有内部元素都实现`Copy`。
- en: 'So, you can derive `Copy` for a structure with basic types such as the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以为以下基本类型结构的结构推导出`Copy`：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But, you cannot derive it for structures with complex non-copyable types:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你不能为具有复杂不可复制类型的结构推导它：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can derive `Clone` in most cases, though, since most of the standard library
    types implement it. But, remember that the `clone()` method is usually expensive
    and should not be used too much. In fact, it's commonly said that if you use the
    `clone()` method directly, you are probably doing something wrong, and in most
    cases, it's true that other methods, such as `to_owned()` or `into()`, will do
    the trick more efficiently.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在大多数情况下，你可以推导出`Clone`，因为大多数标准库类型都实现了它。但请记住，`clone()`方法通常成本较高，不应过度使用。实际上，通常认为如果你直接使用`clone()`方法，你可能在做错事，而且在大多数情况下，其他方法，如`to_owned()`或`into()`，会更有效地完成任务。
- en: '`to_owned()` will get the owned version of a variable, which in slices and
    strings means only to `memcpy()` the heap. The `into()` method, on the other hand,
    will use the specialized conversion implementation so that it produces the best
    output code. Both of them will change the type of the variable. Finally, `clone()`
    is usually generic, which means it will call `clone()` for each of its member
    attributes, making it slower sometimes.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_owned()`将获取变量的所有者版本，在切片和字符串中这意味着只进行`memcpy()`堆操作。另一方面，`into()`方法将使用专门的转换实现，以便产生最佳输出代码。这两个方法都会改变变量的类型。最后，`clone()`通常是通用的，这意味着它将为每个成员属性调用`clone()`，有时会使其变慢。'
- en: Let's now talk about the `Hash` trait. This trait enables the use of the given
    structure or enumeration as a key in hashed structures such as `HashMap`. It gives
    us the possibility to hash the structure with a `Hasher` to get a hash of the
    information contained. A `Hasher` is a trait that receives input such as bytes
    or numbers, and once you call `finish()` on it, it will return a `u64` with the
    hash value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈`Hash`特质。这个特质允许将给定的结构或枚举用作哈希结构（如`HashMap`）中的键。它使我们能够使用`Hasher`对结构进行哈希处理，以获取包含的信息的哈希值。`Hasher`是一个特质，它接收输入，如字节或数字，一旦你在它上面调用`finish()`，它将返回一个包含哈希值的`u64`。
- en: 'Since `Hasher` is a trait, implementation details are not provided by the trait
    itself, but as we saw in [Chapter 2](da2d0480-3314-408b-9cad-60987754f45d.xhtml),
    *Extra Performance Enhancements*, some default implementations are provided in
    the standard library: `SipHasher`, `SipHasher13`, `SipHasher24`, and `DefaultHasher`.
    We have already seen some differences between them.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Hasher`是一个特质，特质本身不提供实现细节，但正如我们在[第2章](da2d0480-3314-408b-9cad-60987754f45d.xhtml)“额外性能增强”中看到的，标准库中提供了一些默认实现：`SipHasher`、`SipHasher13`、`SipHasher24`和`DefaultHasher`。我们已经看到了它们之间的一些区别。
- en: The main idea behind the `Hash` trait is that it enables hashing any structure
    and does not limit `HashMap` keys, for example, to be bytes or numbers. You could
    implement the trait yourself for your structure (if you want to fine-tune how
    the hashing is done), but if what you want is to simply be able to use your structure
    or enumeration as a key in a `HashMap`, you can simply derive the `Hash` trait
    and the compiler will write that code for you.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hash`特质背后的主要思想是它允许对任何结构进行哈希处理，而不限制`HashMap`键必须是字节或数字。你可以为你自己的结构实现这个特质（如果你想要微调哈希过程），但如果你的目的是能够简单地将你的结构或枚举用作`HashMap`中的键，你只需推导出`Hash`特质，编译器就会为你编写代码。'
- en: 'Not only that, you will probably want to also implement the `Eq` trait for
    it since, for `HashMap` keys, it''s required. If you implement it yourself, you
    will need to make sure that if *A = B* then *hash(A) = hash(B)*, which might not
    be trivial. The best thing is to simply derive both. Let''s check this example
    code with the structure we defined earlier:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，您可能还希望实现它的 `Eq` 特性，因为对于 `HashMap` 键来说，这是必需的。如果您自己实现它，您需要确保如果 *A = B*，则
    *hash(A) = hash(B)*，这可能不是显而易见的。最好的办法是简单地推导两者。让我们用我们之前定义的结构来检查这个示例代码：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we first derive `Hash`, `PartialEq`, and `Eq` in the `MyData` structure,
    then we create two identical keys and a different one. I used clone for easier
    understanding, but creating another one with the same values would work too. We
    add a value to the map using the first key and check whether we can retrieve the
    element with the clone of the key without any issues. If we try with a different
    key, though, we won't be able to get the value. You can also check that if the
    `MyData` structure does not implement `Eq` or `Hash`, you won't be able to use
    the `HashMap` with it as a key.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先在 `MyData` 结构中推导 `Hash`、`PartialEq` 和 `Eq`，然后创建两个相同的键和一个不同的键。我使用了 `clone`
    以便于理解，但使用具有相同值的另一个键也会起作用。我们使用第一个键向映射中添加一个值，并检查是否可以无问题地使用键的副本检索元素。然而，如果我们尝试使用不同的键，我们就无法获取值。您还可以检查，如果
    `MyData` 结构没有实现 `Eq` 或 `Hash`，您将无法将其用作 `HashMap` 的键。
- en: 'As before, the only requirement for a structure to derive `Hash` is that all
    of its members already implement it, and most of the standard library types implement
    `Hash`. The default implementation will simply hash all attributes one by one
    with the given `Hasher`, which is what you would probably implement manually.
    An example of this implementation could be the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，一个结构要推导 `Hash` 的唯一要求是它的所有成员已经实现了它，而大多数标准库类型都实现了 `Hash`。默认实现将简单地使用给定的 `Hasher`
    逐个哈希所有属性，这可能是您手动实现的内容。这种实现的例子可能如下所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it's simple code, but you will keep everything cleaner and easier
    to maintain if you derive it. Implementing it yourself, though, can help you deal
    with fields that do not implement `Hash`, custom hashing techniques or avoiding
    some fields to be hashed for a little better performance if the comparison of
    the structure is still valid without taking them into account.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一段简单的代码，但如果您自己推导它，可以使代码更加整洁且易于维护。尽管如此，自己实现它可以帮助您处理那些没有实现 `Hash` 的字段，或者使用自定义哈希技术，或者在比较结构时忽略某些字段以获得更好的性能（如果忽略这些字段结构比较仍然有效的话）。
- en: Finally, the last trait that you can derive out of the box with Rust is the
    `Default` trait. This trait gives the structure, or enumeration, a `default()`
    method that will create a structure with default values. These default values
    are, for example, `0` for numbers, empty strings for strings, empty vectors for
    vectors, and so on. It's usually used as a placeholder for future calculations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Rust 可以直接推导的最后一个特性是 `Default` 特性。这个特性为结构或枚举提供了一个 `default()` 方法，该方法将创建具有默认值的结构。这些默认值是，例如，数字的
    `0`，字符串的空字符串，向量的空向量等等。它通常用作未来计算的占位符。
- en: 'If you have a structure where you would like to have a default value, you can
    implement the `Default` trait. And, doing it can be as simple as giving a value
    to each of the attributes. If you don''t need particular default value (all zeros
    is OK with you), you will probably prefer to simply derive the `Default` trait.
    Let''s check an example with the `MyData` structure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个希望具有默认值的结构，您可以实现 `Default` 特性。而且，这样做可能只需要为每个属性提供一个值。如果您不需要特定的默认值（所有零对您来说都很好），您可能更愿意简单地推导
    `Default` 特性。让我们用 `MyData` 结构来检查一个示例：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, I derived the `Default` trait (and the `Debug` trait, just
    to print the structure). This allows to create the `test2` variable by only calling
    `MyData::default()`. You can also call `Default::default()` if you give a type
    hint for the variable:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我推导了 `Default` 特性（以及 `Debug` 特性，仅用于打印结构）。这允许您通过仅调用 `MyData::default()`
    来创建 `test2` 变量。如果您为变量提供了类型提示，也可以调用 `Default::default()`。
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, if some fields of a structure implement `Default`, you can use
    the trait to complete the fields you don't want to specify, as you can see with
    the `test1` variable. Simply specify the non-default fields, and then, after the
    last comma, add a couple of periods (`..`) and then `Default::default()`, so that
    the compiler uses the `Default` trait to fill the other fields. You can use any
    function that is generic over the rest of the fields with this syntax.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果结构体的一些字段实现了 `Default`，您可以使用该特性来完成您不想指定的字段，就像您在 `test1` 变量中看到的那样。只需指定非默认字段，然后在最后一个逗号之后添加几个点（`..`），然后是
    `Default::default()`，这样编译器就会使用 `Default` 特性来填充其他字段。您可以使用任何对其他字段通用的函数，并使用此语法。
- en: 'As you can see, the `Default` trait is a pretty useful trait and if you don''t
    need any special treatment of any field for the default value of your structure,
    deriving it is a great idea. A potential implementation that you would be avoiding
    by doing this is the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Default` 特性是一个非常实用的特性，如果您不需要对结构体的任何字段进行特殊处理以设置默认值，那么使用它是一个很好的主意。您可能会避免以下潜在实现：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, deriving it makes your work much easier. You can use this implementation,
    though, to customize any of the fields for a default instance of your structure,
    which could be a good idea if, for example, you would like all your structures
    to have the string field set to `"This is my data"` by default. Implementing it
    yourself will also enable you to customize it if any of your fields do not implement
    `Default`, which is rarely the case if using types of the standard library.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用它可以使您的工作变得容易得多。尽管如此，您可以使用此实现来自定义结构体默认实例的任何字段，如果，例如，您希望所有结构体默认将字符串字段设置为
    `"This is my data"`，这可能是一个好主意。如果您自己实现它，还可以在您的任何字段没有实现 `Default` 的情况下自定义它，这在使用标准库类型时很少见。
- en: Crate features
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 铁盒功能
- en: The second, very interesting, attribute use is to enable crate features. These
    features might encapsulate some functionality that some people using the crate
    don't need, therefore making it optional to compile. The Rust compiler will remove
    any unused code during the compilation, but not having some part of the code compile
    from the beginning will speed up the process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个、非常有趣的属性用途是启用铁盒功能。这些功能可能封装了一些某些使用铁盒的人不需要的功能，因此使编译成为可选操作。Rust 编译器将在编译过程中删除任何未使用的代码，但如果没有从开始就编译某些代码部分，这将加快处理速度。
- en: 'You can define crate features in the `Cargo.toml` file by using the `[features]`
    section. You can specify some default features for the crate that will be built
    if nothing is specified:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 `Cargo.toml` 文件中使用 `[features]` 部分，来定义铁盒功能。您可以指定一些默认功能，如果未指定任何内容，这些功能将被构建：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, two features have been defined, the `add` feature and the
    `multiply` feature. The `add` feature does not have any extra dependency, but
    the `multiply` feature depends on the `expensive_dependency` crate. By default,
    only the `add` feature will be built. If this were a binary crate, you could specify
    which features to build with the `--features` command-line option for `cargo`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，定义了两个功能，即 `add` 功能和 `multiply` 功能。`add` 功能没有额外的依赖项，但 `multiply` 功能依赖于
    `expensive_dependency` 铁盒。默认情况下，仅构建 `add` 功能。如果这是一个二进制铁盒，您可以使用 `cargo` 的 `--features`
    命令行选项来指定要构建的功能：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you want to opt out of default features, simply run it with the `--no-default-features`
    command-line option. If you want to use a crate that has features as a dependency
    for your project, you can specify which features to include when declaring the
    dependency in the `Cargo.toml` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想禁用默认功能，只需使用 `--no-default-features` 命令行选项运行即可。如果您想将具有功能的铁盒作为项目依赖项，您可以在 `Cargo.toml`
    文件中声明依赖项时指定要包含哪些功能：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `[section.subsection]` syntax is only so that we do not need to add an inline
    object to the `dependencies` section. In this case, it opts out of the default
    features and requests the `nice_feat` feature.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`[section.subsection]` 语法仅用于我们不需要在 `dependencies` 部分添加内联对象。在这种情况下，它禁用了默认功能并请求了
    `nice_feat` 功能。'
- en: 'But, how does this look in the code? Let''s see. If we have an `add` feature
    as we saw before, we might add an attribute to enable one function, or module,
    only for that case:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这在代码中看起来如何呢？让我们看看。如果我们有一个 `add` 功能，就像我们之前看到的那样，我们可能添加一个属性来仅为此情况启用一个函数或模块：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will only be compiled when the `add` feature is requested. We already saw
    a similar syntax when using `cargo clippy`, since it will request the `cargo-clippy`
    feature from our crate, enabling us to cherry-pick the lints.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 這將只在請求 `add` 特性時編譯。我們在使用 `cargo clippy` 時已經看到過類似的語法，因為它會從我們的包中請求 `cargo-clippy`
    特性，使我們能夠挑選lints。
- en: Configuration attributes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置屬性
- en: The final type of attributes are `#[cfg]` attributes. These attributes are incredibly
    powerful, enabling us to compile certain parts of the code depending on the target
    we are compiling to. For example, we might want to use a specific Windows function
    and have a backup one for the rest, or we might want the code to do different
    things in little- and big-endian machines.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最終類型的屬性是 `#[cfg]` 屬性。這些屬性非常強大，使我們能夠根據我們要編譯到的目標編譯代碼的某些部分。例如，我們可能想使用特定的 Windows
    函數，並為其他部分提供一個備用版本，或者我們可能希望代碼在小端和大端機器上執行不同的操作。
- en: The syntax is pretty easy. For example, if you want to check the system architecture,
    you can use `#[cfg(target_arch = "arm")]`, and instead of ARM, you can check for
    `"x86"`, `"x86_64"`, `"mips"`, `"powerpc"`, `"powerpc64"`, or `"aarch64"` too.
    To compile something only for FreeBSD, we can use `#[cfg(target_os = "freebsd")]`.
    You can compare the `target_os` configuration attribute with `"windows"`, `"macos"`,
    `"ios"`, `"linux"`, `"android"`, `"freebsd"`, `"dragonfly"`, `"bitrig"` , `"openbsd"`,
    or `"netbsd"`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 語法相對簡單。例如，如果你想檢查系統架構，你可以使用 `#[cfg(target_arch = "arm")]`，而不是 ARM，你也可以檢查 `"x86"`、`"x86_64"`、`"mips"`、`"powerpc"`、`"powerpc64"`
    或 `"aarch64"`。要僅為 FreeBSD 編譯某個東西，我們可以使用 `#[cfg(target_os = "freebsd")]`。你可以比較
    `target_os` 配置屬性與 `"windows"`、`"macos"`、`"ios"`、`"linux"`、`"android"`、`"freebsd"`、`"dragonfly"`、`"bitrig"`、`"openbsd"`
    或 `"netbsd"`。
- en: If you only care about Windows/Unix differences, you can use `#[cfg(target_family
    = "windows")]` or `#[cfg(target_family = "unix")]`, or even directly `#[windows]`
    and `#[unix]`. This can be specified further by using `#[cfg(target_env = "gnu")]`,
    or `"msvc"`, or `"musl"`. The endianness of the system can be checked with `#[cfg(target_endian
    = "little")]` or `#[cfg(target_endian = "big")]`, and the pointer width (32 or
    64 bits) with `#[cfg(target_pointer_width = "32")]` or `#[cfg(target_pointer_width
    = "64")]` respectively.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只關心 Windows/Unix 的差異，你可以使用 `#[cfg(target_family = "windows")]` 或 `#[cfg(target_family
    = "unix")]`，或者甚至直接使用 `#[windows]` 和 `#[unix]`。這可以通過使用 `#[cfg(target_env = "gnu")]`、`"msvc"`
    或 `"musl"` 進一步指定。你可以使用 `#[cfg(target_endian = "little")]` 或 `#[cfg(target_endian
    = "big")]` 檢查系統的端序，並使用 `#[cfg(target_pointer_width = "32")]` 或 `#[cfg(target_pointer_width
    = "64")]` 依次檢查指針寬度（32 或 64 位）。
- en: More complex details can also be checked, such as whether the target has atomic
    integer types, and what size those atomic integers are. For example, to check
    whether the target platform has atomic 8 bit integers, you will use `#[cfg(target_has_atomic
    = "8")]`. You can check for `8`, `16`, `32`, `64`, and pointer width integers
    (with `"ptr"`). You can even check the vendor of the target architecture by checking
    `#[cfg(target_vendor = "apple")]`. You can check for `"apple"`, `"pc"`, or `"unknown"`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以檢查更複雜的細節，例如目標是否具有原子整數類型，以及這些原子整數的大小。例如，要檢查目標平台是否具有原子 8 位整數，你將使用 `#[cfg(target_has_atomic
    = "8")]`。你可以檢查 `8`、`16`、`32`、`64` 和指針寬度整數（使用 `"ptr"`）。你甚至可以通過檢查 `#[cfg(target_vendor
    = "apple")]` 檢查目標架構的供應商。你可以檢查 `"apple"`、`"pc"` 或 `"unknown"`。
- en: Finally, a couple of attributes let you know whether you are doing a test (using
    `#[test]`) and whether the debug assertions are turned on (using `#[debug_assertions]`).
    The first one could be useful if you want to change any particular behavior only
    for tests (not recommended; tests should run the same code as in production),
    and the second one lets you, for example, add some debug information if the application
    was compiled in debug mode.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最後，有幾個屬性可以告訴你你是否正在進行測試（使用 `#[test]`）以及是否已啟用调试斷言（使用 `#[debug_assertions]`）。第一個可能在你只想為測試更改特定行為時有用（不推薦；測試應該運行與生產環境相同的代碼），而第二個則允許你在應用程序以调试模式編譯時添加一些调试信息。
- en: You can set/use a configuration item selectively by using `#[cfg_attr(a, b)]`.
    This will have the same effect as doing `#[b]`, but will only do something if
    `a` is true. If it's false, it will be like nothing was written. This is useful,
    for example, if you want to enable or disable lints depending on other attributes,
    or if you want to derive a trait only for certain targets, and implement it for
    the rest.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `#[cfg_attr(a, b)]` 选择性地设置/使用配置项。这将产生与 `#[b]` 相同的效果，但只有在 `a` 为真时才会执行某些操作。如果它是假的，就像什么都没写一样。这在例如你想根据其他属性启用或禁用
    lint，或者你想只为某些目标派生 trait 并为其余部分实现它时很有用。
- en: 'You can also check these configuration attributes in the code inside the logic
    by using the `cfg!()` macro. Simply use the same syntax as with attributes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 `cfg!()` 宏在逻辑代码内部检查这些配置属性。只需使用与属性相同的语法：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Macros
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: One of the most useful Rust functionalities is its macro ecosystem. You probably
    already know the `println!()` macro, but there are many more. These macros allow
    you to write complex boilerplate code (such as `stdio` handling in the `println!()`
    case) in a simple way and without having to add a ton of boilerplate code. Let's
    check out some of the most used ones.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 最有用的功能之一是其宏生态系统。你可能已经知道 `println!()` 宏，但还有更多。这些宏允许你以简单的方式编写复杂的样板代码（例如 `println!()`
    中的 `stdio` 处理），而不必添加大量的样板代码。让我们来看看最常用的几个。
- en: Console printing
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台打印
- en: When you need to lock the standard I/O interface, then write bytes to it, and
    finally flush it for each call, the `print!()` and `println!()` macros allow you
    to do that by just giving them a formatting static string and a series of parameters.
    Not only that, you can use the whole `std::fmt` module to specify number precision,
    format things in debug mode, and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要锁定标准 I/O 接口，然后写入字节到它，最后在每个调用中刷新它时，`print!()` 和 `println!()` 宏允许你通过只向它们提供一个格式化的静态字符串和一系列参数来实现这一点。不仅如此，你还可以使用整个
    `std::fmt` 模块来指定数字精度，以调试模式格式化事物，等等。
- en: Similar macros exist for the standard error output interface or `stderr`. They
    are called `eprint!()` and `eprintln!()`, and allow you to easily print in `stderr`
    with the same format as `print!()` and `println!()`. The four macros use the syntax
    from the `format!()` macro, which we will see next.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准错误输出接口或 `stderr`，也存在类似的宏。它们被称为 `eprint!()` 和 `eprintln!()`，允许你以与 `print!()`
    和 `println!()` 相同的格式轻松地在 `stderr` 中打印。这四个宏使用来自 `format!()` 宏的语法，我们将在下一节中看到。
- en: String formatting
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'Creating strings is easy: you just call `String::new()` and then use a static
    string or add characters to it. Sometimes, you might want easier access to how
    the string gets created. If you, for example, want the string to say `Hello {user}!`,
    even though you can probably do something such as creating a `String` with `Hello` in
    it, then appending the username and then the exclamation mark, this is not ideal.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字符串很简单：你只需调用 `String::new()`，然后使用静态字符串或向其中添加字符。有时，你可能想要更容易地访问字符串的创建方式。例如，如果你想字符串显示为
    `Hello {user}!`，即使你可能会创建一个包含 `Hello` 的 `String`，然后追加用户名和感叹号，这并不理想。
- en: This is where the `std::fmt` module comes in handy, with its `format!()` macro
    and all of its formatting options. These options apply to console printing, string
    formatting, and even buffer writing with `write!()` and `writeln!()` macros. You
    can find the complete guide in the `std::fmt` module documentation at the standard
    library documentation, by running `rustup doc --open`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `std::fmt` 模块及其 `format!()` 宏和所有格式化选项派上用场的地方。这些选项适用于控制台打印、字符串格式化，甚至使用 `write!()`
    和 `writeln!()` 宏进行缓冲区写入。你可以在标准库文档中找到完整的指南，通过运行 `rustup doc --open` 来查看 `std::fmt`
    模块的文档。
- en: Compilation environment
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译环境
- en: 'You can check environment variables at compile time by using the `env!("VAR")`
    and `option_env!("VAR")` macros. The first will retrieve the environment variable
    as `&''static str`. If the variable is not defined, the compilation will fail.
    The `option_env!()` macro avoids this by returning an `Option::None` if the environment
    variable is not set and an `Option::Some(&''static str)` if the variable is set:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `env!("VAR")` 和 `option_env!("VAR")` 宏在编译时检查环境变量。第一个将检索环境变量作为 `&'static
    str`。如果变量未定义，编译将失败。`option_env!()` 宏通过在环境变量未设置时返回 `Option::None`，在变量设置时返回 `Option::Some(&'static
    str)` 来避免这种情况：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Loading byte arrays and strings at compile time
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编译时加载字节数组和字符串
- en: You can load various types of constants at compile time. The `include_bytes!()`
    macro will create a byte (`u8`) array with the contents of the specified file.
    The `include_str!()` macro, on the other hand, will get the contents of the file
    as a string and create a `&static str`. Both will make the compilation fail if
    the file does not exist at compile time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在编译时加载各种类型的常量。`include_bytes!()` 宏将创建一个包含指定文件内容的字节数组（`u8`）。另一方面，`include_str!()`
    宏将获取文件内容作为字符串并创建一个 `&static str`。两者都会在编译时如果文件不存在而使编译失败。
- en: 'You can also use the `include!()` macro that will include the code of the given
    file and add it to the current file at compile time. The compilation will also
    fail if the code in that file is not valid Rust code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `include!()` 宏，该宏将在编译时将指定文件的代码包含到当前文件中。如果该文件中的代码不是有效的Rust代码，编译将失败：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Code paths
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码路径
- en: Some paths should never be traversed and, in our code, that is usually a condition
    for our code to work properly. If we are receiving bad input data, we might want
    to return an error, but if our library is being misused, we might prefer to panic.
    Sometimes, we also want to make sure that it's impossible for a variable to be
    out of some bounds once it gets to the logic of our function, to avoid security
    flaws, for example. In those cases, the `unreachable!()` macro, or even the explicit
    `panic!()` macro, can help us.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有些路径永远不应该被遍历，在我们的代码中，这通常是代码正常工作的条件。如果我们收到不良的输入数据，我们可能希望返回一个错误，但如果我们的库被误用，我们可能更愿意引发panic。有时，我们还想确保变量在到达函数的逻辑时不可能超出某些界限，以避免安全漏洞，例如。在这些情况下，可以使用
    `unreachable!()` 宏，甚至显式的 `panic!()` 宏来帮助我们。
- en: There is another path that might not be ready to be traversed yet. While our
    crate is being implemented, we can use the `unimplemented!()` macro, as we saw
    before in some examples, to indicate that the code we are writing is not implemented.
    This will enable the code to compile but, if executed, it will panic with the
    *not yet implemented* message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一条可能尚未准备好遍历的路径。当我们的crate正在实现时，我们可以使用之前在某些示例中看到的 `unimplemented!()` 宏，来指示我们正在编写的代码尚未实现。这将使代码能够编译，但如果执行，它将带有
    *尚未实现* 消息的panic。
- en: Checking preconditions and postconditions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查先决条件和后置条件
- en: When testing, and even in our everyday code, we probably want to have some preconditions
    to our functions, or we might want to check some postconditions. We use assertions
    for this. They come in two variants, debug assertions and normal assertions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，甚至在我们的日常代码中，我们可能希望我们的函数有一些先决条件，或者我们可能想检查一些后置条件。我们使用断言来做这件事。它们有两种变体，调试断言和正常断言。
- en: Normal assertions will always be checked, but will slow down your production
    code since they need to run every time. Debug assertions will only run when compiling
    in debug mode, so you will be able to catch errors then, and the production code
    will run without performance issues.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正常断言总是会进行检查，但它们会减慢你的生产代码，因为它们需要每次运行。调试断言只有在调试模式下编译时才会运行，因此你可以在那时捕获错误，而生产代码将不会出现性能问题。
- en: In general, you should use all the debug assertions you can, and use normal
    assertions only in places where you receive output from the user or another crate
    (if building a library).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该尽可能使用所有调试断言，只在从用户或其他crate（如果构建库）接收输出时使用正常断言。
- en: The three macros are `assert!()`, `assert_eq!()`, and `assert_ne!()`, and their
    debug counterparts are `debug_assert!()`, `debug_assert_eq!()`, and `debug_assert_ne!()`.
    The first accepts a Boolean returning expression as the first argument and an
    optional second argument can contain a message that will be printed when panicking
    if the first argument is false.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 三个宏分别是 `assert!()`、`assert_eq!()` 和 `assert_ne!()`，它们的调试版本分别是 `debug_assert!()`、`debug_assert_eq!()`
    和 `debug_assert_ne!()`。第一个宏接受一个返回布尔值的表达式作为第一个参数，可选的第二个参数可以包含一个消息，当第一个参数为假时，这个消息将在panic时被打印出来。
- en: The other two macros accept two arguments that will be compared between them
    and a third optional comment string. The `assert_eq!()` macro will panic if the
    two elements are different and the `assert_ne!()` will panic if they are equal.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个宏接受两个参数，它们之间将进行比较，还有一个可选的注释字符串。如果两个元素不同，`assert_eq!()` 宏将引发panic，而如果它们相等，`assert_ne!()`
    将引发panic。
- en: Others
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他
- en: There are many more macros. We have already used some of them, such as the `cfg!()`
    and `vec![]` macros. You can also cause an explicit compile error with the `compile_error!("message")`
    macro, or use the `file!()`, `line!()`, and `column!()` macros to get the current
    position in the code, or even the `module_path!()` macro to get the current module.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多宏。我们已经使用了一些，例如`cfg!()`和`vec![]`宏。您还可以使用`compile_error!("message")`宏来引发显式的编译错误，或者使用`file!()`、`line!()`和`column!()`宏来获取当前代码的位置，甚至可以使用`module_path!()`宏来获取当前模块。
- en: If you want to know more, open the standard library documentation by running
    `rustup doc --open` and check out the rest of the macros there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多信息，可以通过运行`rustup doc --open`来打开标准库文档，并查看那里的其他宏。
- en: Nightly Rust
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 夜间Rust
- en: 'Nightly Rust can speed up your code even more in certain situations. If you
    don''t need compatibility with stable Rust, you might want to check all the nightly
    features. In some cases, such as kernel development, it''s impossible to get all
    the required functionality using stable Rust. You can use nightly Rust by overriding
    the default compiler:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，夜间Rust甚至可以进一步加快您的代码。如果您不需要与稳定版Rust兼容，您可能想检查所有夜间功能。在某些情况下，例如内核开发，使用稳定版Rust无法获得所有所需的功能。您可以通过覆盖默认编译器来使用夜间Rust：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Or, you can call cargo with the `+nightly` flag. These methods will only work
    if you use `rustup` to manage your Rust installation, which you probably should
    if you have the option.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用带有`+nightly`标志的cargo。这些方法只有在您使用`rustup`管理您的Rust安装时才会生效，如果您有这个选项，那么您可能应该这样做。
- en: To use nightly features, you will need to use the `#![feature]` attribute at
    the crate level. For example, if you want to use the `conservative_impl_trait`
    feature, you will need to add `#![feature(conservative_impl_trait)]` to the beginning
    of your `main.rs` or `lib.rs` files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用夜间功能，您需要在crate级别使用`#![feature]`属性。例如，如果您想使用`conservative_impl_trait`功能，您需要将`#![feature(conservative_impl_trait)]`添加到您的`main.rs`或`lib.rs`文件的开始部分。
- en: Let's see some of the most interesting unstable features. Note that these features
    will probably change rapidly, and they might have already changed by the time
    you read this book. Always check the latest Rust's unstable feature list ([https://doc.rust-lang.org/unstable-book/the-unstable-book.html](https://doc.rust-lang.org/unstable-book/the-unstable-book.html))
    to get the latest information. There are dozens of features and it's impossible
    to check all of them in this chapter, but here you can find an explanation of
    the most relevant ones so that you understand what can they do for you and how
    you can use them to improve the performance of your applications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些最有趣的不稳定功能。请注意，这些功能可能会迅速变化，并且它们在您阅读这本书的时候可能已经发生了变化。始终检查最新的Rust不稳定功能列表（[https://doc.rust-lang.org/unstable-book/the-unstable-book.html](https://doc.rust-lang.org/unstable-book/the-unstable-book.html)）以获取最新信息。这里有数十个功能，在这个章节中不可能检查所有这些功能，但在这里您可以找到最相关的一些功能的解释，以便您了解它们能为您做什么，以及您如何使用它们来提高您应用程序的性能。
- en: Conservative trait return
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保守特型返回
- en: 'This feature enables you to directly return a trait from a function. This means
    that in stable Rust, you will need to write this if you want to return a type
    that implements a trait without specifying the type:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能使您能够直接从函数中返回一个特型。这意味着在稳定版Rust中，如果您想返回一个实现了特型的类型而不指定类型，您需要编写以下内容：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means that, before returning the iterator, you will need to move all of
    its information to the heap (this is done easily, but is costly with `Box::new()`)
    and then return it. This should not be necessary, since Rust should be able to
    know what type you are returning at compile time and allocate stack accordingly,
    then only let you use the trait, since it's what you specified beforehand.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在返回迭代器之前，您需要将所有相关信息移动到堆上（这很容易完成，但使用`Box::new()`会非常昂贵），然后返回它。这不应该必要，因为Rust应该在编译时知道您返回的类型，并相应地分配栈，然后只允许您使用特型，因为这是您事先指定的。
- en: 'Well, this has already been implemented in nightly Rust, but you will need
    to use the `conservative_impl_trait` feature:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这已经在夜间Rust中实现了，但您需要使用`conservative_impl_trait`功能：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This allows Rust to use the stack directly, which will avoid a costly allocation
    and make your code faster.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许Rust直接使用栈，这将避免昂贵的分配，并使您的代码运行更快。
- en: Constant functions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量函数
- en: The `const_fn` feature enables you to declare some functions as constant so
    that they can receive constant arguments at compile time and be executed then
    instead of at runtime. This is particularly useful for constructors or for constants
    that need to create an object as soon as possible.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`const_fn` 功能允许您将一些函数声明为常量，这样它们就可以在编译时接收常量参数并在那时执行，而不是在运行时执行。这对于构造函数或需要尽快创建对象的常量特别有用。'
- en: For this last option, we have the `lazy_static!{}` macro, as we will see in
    the next chapter, but this macro runs all of its code at its first use, and not
    at compile time. Doing it at compile time would make compilations take a bit longer,
    but when running, it would not require computing anything as everything would
    already be a constant. It seems that not all `lazy_static!{}` cases can be solved
    with `const_fn`, though.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个选项，我们有 `lazy_static!{}` 宏，正如我们将在下一章中看到的，但这个宏在其首次使用时运行所有代码，而不是在编译时。在编译时这样做会使编译时间稍微长一些，但在运行时，它不需要计算任何东西，因为所有东西都已经是一个常量。尽管如此，似乎并不是所有的
    `lazy_static!{}` 情况都可以用 `const_fn` 解决。
- en: 'Let''s see what it looks like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是什么样子：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this case, as you can see, we created two constants that use the `MyData::new()`
    method to create them. The same method is then used at runtime in the `main()`
    function. The things you can do in a constant function are very limited. You cannot,
    for example, create bindings, and if you call another function or macro, it must
    also be constant. But you can still do pretty complex operations that won''t affect
    the performance of the application. As you can imagine, this is the output of
    this code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正如您所看到的，我们创建了两个使用 `MyData::new()` 方法创建的常量。然后在运行时的 `main()` 函数中使用了相同的方法。在常量函数中可以做的事情非常有限。例如，您不能创建绑定，如果您调用另一个函数或宏，它也必须是常量。但您仍然可以执行一些复杂的操作，这些操作不会影响应用程序的性能。正如您所想象的，这是这段代码的输出：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inline assembly and naked functions
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联汇编和裸函数
- en: This might be one of the most interesting nightly features of Rust. Using `#[feature(asm)]`,
    we will get a new macro, `asm!()`, which we will be able to use in our code. With
    this macro, we can write inline assembly to perform fine-grained operations in
    the code if we need further performance optimizations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是 Rust 中最有趣的夜间功能之一。使用 `#[feature(asm)]`，我们将获得一个新的宏 `asm!()`，我们将在代码中使用它。使用这个宏，如果我们需要进一步的性能优化，我们可以在代码中编写内联汇编以执行细粒度操作。
- en: The exact syntax is still being worked on, but it already enables you to write
    arbitrary assembly code within your functions. This is a must for kernel development,
    for example, where access to CPU features can only be done by direct CPU instructions.
    Make sure you thoroughly test this code, since it will be unsafe to use it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的语法仍在开发中，但它已经允许您在函数中编写任意汇编代码。这对于内核开发来说是一个必须的功能，例如，在这种情况下，只能通过直接 CPU 指令来访问
    CPU 功能。确保您彻底测试这段代码，因为它在使用时是不安全的。
- en: Furthermore, `#[feature(naked_functions)]` allows you to add the `#[naked]`
    attribute to a function. This will remove some boilerplate assembly that gets
    added before and after each function so that you can write plain assembly code.
    Many times, this is essential for using some CPU intrinsics.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`#[feature(naked_functions)]` 允许您将 `#[naked]` 属性添加到函数中。这将删除在函数前后添加的一些样板汇编代码，这样您就可以编写纯汇编代码。很多时候，这对于使用某些
    CPU 内置函数是必不可少的。
- en: Using bigger integers
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更大的整数
- en: 'The `i128_type` feature gives us the `i128` and `u128` integers, which work
    the same way as `i64` and `u64` types, but with 128 bits instead of 64, which
    gives them more capacity. They have the same API as the rest of the integers,
    so you can perform the same kind of operations. Sometimes it''s great to have
    a bigger, full-precision integer and, in this case, since it uses LLVM intrinsics,
    the type is almost as lightweight as a `u64` or `i64` (more or less double the
    processing time in a 64-bit machine; it should be around the same in a 128-bit
    machine). A simple example is given in the main documentation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`i128_type` 功能为我们提供了 `i128` 和 `u128` 整数，它们的工作方式与 `i64` 和 `u64` 类型相同，但使用 128
    位而不是 64 位，这使它们具有更大的容量。它们具有与整数其余部分相同的 API，因此您可以执行相同类型的操作。有时拥有一个更大、全精度的整数是非常好的，在这种情况下，因为它使用了
    LLVM 内置函数，所以这个类型几乎与 `u64` 或 `i64` 一样轻量级（在 64 位机器上大约是双倍的处理时间；在 128 位机器上应该差不多）。主文档中给出了一个简单的例子：'
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Single instruction multiple data
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单指令多数据
- en: The **single instruction multiple data** (**SIMD**) CPU features have revolutionized
    the way operations are performed in our CPUs. Using processor-specific features,
    we can now run the same operation with multiple inputs simultaneously. Let's suppose
    that we need to add four numbers in pairs. We could first add the first two and
    then the second two, and get the two results. SIMD allows us to compute both results
    at the same time, by applying that adding operation to both pairs at the same
    time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**单指令多数据**（**SIMD**）CPU特性已经彻底改变了我们在CPU中执行操作的方式。使用处理器特定的特性，我们现在可以同时运行相同的操作。假设我们需要成对地添加四个数字。我们首先可以添加前两个，然后添加后两个，并得到两个结果。SIMD允许我们同时计算这两个结果，通过同时将加法操作应用于这两对。'
- en: This requires assembly, though, and even though LLVM does the best job it can
    to use as much SIMD as possible, it's sometimes not enough for some high-performance
    applications. We could use inline assembly, of course, but it's not rare to mess
    things up when using assembly, and you will need to rewrite it for each target,
    so a SIMD specific frontend is being developed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这需要汇编，尽管LLVM尽可能地使用尽可能多的SIMD指令，但对于一些高性能应用来说，有时这还不够。当然，我们可以使用内联汇编，但使用汇编时出错并不罕见，并且您需要为每个目标重新编写它，因此正在开发一个针对SIMD的特定前端。
- en: The API is still a work in progress, but check the `simd` feature to get a grasp
    on how it will be done. It seems, for now, that an external crate will be developed
    with all the intrinsics. You will be able to generate groups of data and apply
    simultaneous operations to every element in supporting processors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: API仍在开发中，但请查看`simd`功能，以了解它将如何实现。目前看来，似乎将开发一个包含所有内建的独立包。您将能够生成数据组，并支持处理器的每个元素应用同时操作。
- en: Allocation API
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配API
- en: Some specific projects require the ability to change the default heap allocation
    algorithm. Rust uses jemalloc by default for targets that allow it. As we saw
    in previous chapters, one of the features of this allocator is that, in collections,
    it will allocate the multiple of two of the last allocations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特定的项目需要改变默认的堆分配算法的能力。Rust默认使用jemalloc，对于允许它的目标。正如我们在前面的章节中看到的，这个分配器的特性之一是，在集合中，它将分配上一次分配的两倍。
- en: You can change that by using the `alloc`, `allocator_api`, `alloc_jemalloc`,
    and `alloc_system` features. The last two specify the global allocator of the
    crate, which, in cases such as kernel development, must be specified and some
    functions implemented so that collections work. The other two allow for more customized
    allocator manipulation, even giving you the option to change the allocator for
    each collection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`alloc`、`allocator_api`、`alloc_jemalloc`和`alloc_system`功能来改变这一点。后两个指定了包的全局分配器，在例如内核开发的情况下，必须指定并实现一些函数，以便集合能够工作。其他两个允许进行更定制的分配器操作，甚至给您提供更改每个集合分配器的选项。
- en: Compiler plugins
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器插件
- en: To finish with this list, we will talk about the compiler plugins. These plugins
    can be used by adding `#![feature(plugin)]` to the top of the `main.rs` or `lib.rs`
    files, as with the rest of the nightly features. If you want to actually create
    a plugin, you will need to use the `plugin_registrar` and `rustc_private` features.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个列表后，我们将讨论编译器插件。这些插件可以通过在`main.rs`或`lib.rs`文件的顶部添加`#![feature(plugin)]`来使用，就像使用其他夜间功能一样。如果您实际上要创建一个插件，您将需要使用`plugin_registrar`和`rustc_private`功能。
- en: The unstable feature list has an interesting guide to create plugins, which
    will be extended in [Chapter 9](e869a4d7-e2a8-488a-a767-8c75364a8962.xhtml), *Creating
    Your Own Macros*. You will need to use the `libsyntax` crate, along with the internals
    of the compiler syntax, and the compiler internals themselves, so that you can
    parse the **advanced source tree (AST****)** tokens, and perform the operations
    required by your plugin.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定的特性列表提供了一个有趣的指南来创建插件，这些插件将在[第9章](e869a4d7-e2a8-488a-a767-8c75364a8962.xhtml)“创建您自己的宏”中扩展。您需要使用`libsyntax`包，以及编译器语法的内部结构和编译器本身的内部结构，以便您能够解析**高级源树（AST）**标记，并执行插件所需的操作。
- en: Plugins enable big syntax extensions to the language, which can let you run
    arbitrary Rust code inside a macro or derive any kind of boilerplate code. We
    will see a real example of a crate that makes heavy use of plugins to create a
    great web development experience in the next chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 插件允许对语言进行大语法扩展，这可以让您在宏内部运行任意Rust代码或生成任何类型的样板代码。我们将在下一章看到一个真实示例，该示例通过大量使用插件来创建出色的Web开发体验。
- en: Some of these features might not get stabilized in the short term, some might
    change a lot, and some might not even get implemented, even though I doubt it
    will happen for the list you just read. These changes could make your code obsolete
    from one day to the next, so you have to make sure that, if you use some of these
    features, you can maintain an always changing ecosystem.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些特性可能短期内不会得到稳定，一些可能会发生很大变化，还有一些甚至可能不会实现，尽管我对您刚才读到的列表表示怀疑。这些变化可能会使您的代码在一夜之间变得过时，因此您必须确保，如果您使用了一些这些特性，您能够维护一个不断变化的生态系统。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with metaprogramming by learning about attributes
    and macros. Both of them will help you write less code and make sure that you
    get the best possible implementation for trivial details.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过学习属性和宏开始了元编程的学习。两者都将帮助您编写更少的代码，并确保您为琐碎的细节获得最佳实现。
- en: We then learned about nightly Rust and how some nightly features give us new
    language extensions that can greatly help improve the efficiency, performance,
    and clarity of our code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后学习了夜间Rust版本，以及一些夜间特性如何为我们提供新的语言扩展，这些扩展可以极大地帮助我们提高代码的效率、性能和清晰度。
- en: In the next chapter, we will see how crates in [crates.io](https://crates.io/)
    bring new macros and plugins to the ecosystem, and we will go through the most-used
    ones that improve the performance and development time for your applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到[crates.io](https://crates.io/)上的crates如何为生态系统带来新的宏和插件，我们将探讨其中最常用的那些，它们可以提升您应用程序的性能和开发时间。
