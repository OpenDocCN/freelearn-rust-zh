- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Configuring HTTPS with NGINX on AWS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS上使用NGINX配置HTTPS
- en: 'When it comes to deploying our applications, a lot of tutorials and books go
    through simple deployments and smooth over the concept of encrypting traffic to
    and from the server using HTTPS. However, HTTPS is essential and usually the biggest
    hurdle that a developer must overcome to get their website or API out into the
    world. While this book’s title is *Rust Web Programming*, it is essential to dedicate
    a chapter to truly understanding how HTTPS works so that you can implement HTTPS
    locally and then on the **Amazon Web Services** (**AWS**) cloud. This chapter
    will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到部署我们的应用程序时，许多教程和书籍都只涉及简单的部署，并忽略了使用HTTPS加密服务器与客户端之间流量这一概念。然而，HTTPS是至关重要的，通常也是开发者必须克服的最大障碍，以便将他们的网站或API推向世界。尽管这本书的标题是《Rust
    Web Programming》，但为真正理解HTTPS的工作原理而专门奉献一章是至关重要的，这样你就可以在本地和**Amazon Web Services**（**AWS**）云上实施HTTPS。本章将涵盖以下主题：
- en: What is HTTPS?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是HTTPS？
- en: Implementing HTTPS locally with `docker-compose`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker-compose`在本地实施HTTPS
- en: Attaching a URL to our deployed application on AWS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将URL附加到我们在AWS上部署的应用程序
- en: Enforcing HTTPS on our application on AWS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS上强制实施HTTPS
- en: By the end of this chapter, you will be able to build infrastructure in Terraform
    code that can encrypt traffic and lock down unwanted traffic to our **Elastic
    Compute Cloud** (**EC2**) instances so that they can only accept traffic from
    the load balancer, which will be explained later in the chapter. What is best
    is that most of this is automated, and seeing as we are using Docker to deploy
    our applications, you will be able to transfer this skill to any web project that
    you want to deploy in the future. While this is not the best implementation as
    there are entire books dedicated to cloud computing, you will be able to implement
    a solid, safe deployment that will continue to serve users even if an EC2 instance
    is out of service as the load balancer can route to other instances. It will also
    be able to scale if traffic demand increases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用Terraform代码构建基础设施，以加密流量并锁定对**Elastic Compute Cloud**（**EC2**）实例的不希望接收的流量，这样它们就只能接受来自负载均衡器的流量，这将在本章后面进行解释。最好的是，这一切大部分都是自动化的，鉴于我们使用Docker来部署应用程序，你将能够将这项技能转移到你未来想要部署的任何Web项目上。虽然这并不是最佳实现，因为还有整本书是关于云计算的，但你将能够实施一个稳固、安全的部署，即使EC2实例出现故障，负载均衡器也能路由到其他实例，继续为用户提供服务。如果流量需求增加，它也能进行扩展。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’ll build on the code built in [*Chapter 10*](B18722_10.xhtml#_idTextAnchor200),
    *Deploying Our Application on AWS*. This can be found at the following URL: [](
    https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter10/deploying_our_application_on_aws)
    [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter10/deploying_our_application_on_aws](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter10/deploying_our_application_on_aws).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于在[*第10章*](B18722_10.xhtml#_idTextAnchor200)中构建的代码，即*在AWS上部署我们的应用程序*。这可以在以下URL找到：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter10/deploying_our_application_on_aws](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter10/deploying_our_application_on_aws)。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11)找到。
- en: What is HTTPS?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是HTTPS？
- en: 'So far, our frontend and backend applications have been running through HTTP.
    However, this is not secure and has some drawbacks. To secure the traffic between
    our browser and our NGINX server, we are going to have to ensure that our application
    is using the HTTP/2 protocol. The HTTP/2 protocol has the following differences
    from the standard HTTP/1 protocol:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的前端和后端应用程序都是通过HTTP运行的。然而，这并不安全，存在一些缺点。为了确保我们浏览器和NGINX服务器之间的流量安全，我们必须确保我们的应用程序正在使用HTTP/2协议。HTTP/2协议与标准HTTP/1协议有以下不同之处：
- en: Binary protocol
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制协议
- en: Compressed headers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩头
- en: Persistent connections
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久连接
- en: Multiplex streaming
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多路复用流
- en: We can go through the preceding laid-out points and discuss the differences.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以讨论前面列出的要点之间的差异。
- en: Binary protocol
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制协议
- en: HTTP uses a text-based protocol whereas HTTP/2 uses a binary protocol. A binary
    protocol uses bytes to transmit data as opposed to human-readable characters,
    which are encoded using the **American Standard Code for Information Interchange**
    (**ASCII**). Using bytes reduces the number of possible errors and the size needed
    to transfer data. It will also enable us to encrypt our data stream, which is
    the basis of HTTPS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP使用基于文本的协议，而HTTP/2使用二进制协议。二进制协议使用字节来传输数据，而不是使用人类可读的字符，这些字符使用**美国信息交换标准代码**（**ASCII**）进行编码。使用字节可以减少可能的错误数量和传输数据所需的大小。它还将使我们能够加密我们的数据流，这是HTTPS的基础。
- en: Compressed headers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩头部
- en: HTTP/2 compresses headers when sending requests. Compressing headers has similar
    benefits to the binary protocol, which results in a lower size of data needed
    to transfer the same request. The HTTP/2 protocol uses the HPACK format.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2在发送请求时压缩头部信息。压缩头部信息与二进制协议有类似的好处，这导致传输相同请求所需的数据量更小。HTTP/2协议使用HPACK格式。
- en: Persistent connections
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久连接
- en: When using HTTP, our browser must make a request every time a resource is needed.
    For instance, we could get our NGINX server to serve an HTML file. This will result
    in one request to get the HTML file. Inside the HTML file, there could be a reference
    to a CSS file, and this would result in another request to the NGINX server. It
    is also not uncommon to have a reference to a JavaScript file in the HTML file.
    This would result in another request. Therefore, to load a standard web page,
    our browser requires up to three requests. This does not scale well when we are
    running a server with multiple users. With HTTP/2, we can have persistent connections.
    This means that we can make three requests for the HTML, CSS, and JavaScript files
    in one connection.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用HTTP时，我们的浏览器每次需要资源时都必须发出一个请求。例如，我们可以让我们的NGINX服务器提供HTML文件。这将导致一个获取HTML文件的请求。在HTML文件中，可能有一个对CSS文件的引用，这将导致对NGINX服务器的另一个请求。在HTML文件中引用JavaScript文件也很常见。这将导致另一个请求。因此，为了加载一个标准的网页，我们的浏览器可能需要最多三个请求。当我们运行一个有多个用户的服务器时，这并不好。使用HTTP/2，我们可以有持久连接。这意味着我们可以在一个连接中发出对HTML、CSS和JavaScript文件的三个请求。
- en: Multiplex streaming
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多路复用流
- en: Making requests using HTTP/1 means that we must send our requests sequentially.
    This means that we make one request, wait for this request to be resolved, and
    then send another request. With HTTP/2, we use multiplex streaming, which means
    that we can send multiple requests at the same time and resolve them when the
    responses are returned. Combining multiplex streaming with a persistent connection
    results in a faster loading time. Any reader who used to use the internet in the
    1990s will remember having to wait a long time for a simple page to be loaded.
    Granted—the internet connection back then was not as fast, but it also was a result
    of making multiple HTTP sequential requests with different connections to load
    multiple pictures, HTML, and CSS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP/1发出请求意味着我们必须按顺序发送我们的请求。这意味着我们发出一个请求，等待这个请求被解决，然后发送另一个请求。使用HTTP/2，我们使用多路复用流，这意味着我们可以同时发送多个请求，并在响应返回时解决它们。将多路复用流与持久连接相结合，可以缩短加载时间。任何在1990年代使用过互联网的读者都会记得，加载一个简单的页面需要等待很长时间。当然——那时的互联网连接速度没有现在快，但这也是由于通过多个不同连接的多个HTTP顺序请求来加载多个图片、HTML和CSS的结果。
- en: Now that we have explored the difference between HTTP and HTTP/2, we can explore
    HTTPS, which is built on top of HTTP/2\. Before we go forward, however, it must
    be stated that security is a field in itself. Learning the high-level concepts
    around HTTPS is enough to make us understand the importance of what we are implementing
    and why we take certain steps. However, it does not make us security experts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了HTTP与HTTP/2之间的区别，我们可以探讨建立在HTTP/2之上的HTTPS。然而，在继续前进之前，必须指出，安全是一个独立的领域。了解HTTPS周围的高级概念足以让我们理解我们所实施的重要性以及我们为何采取某些步骤。然而，这并不意味着我们成为了安全专家。
- en: 'Before we explore the steps of HTTPS, we need to understand what a middleman
    attack is because this attack inspires the steps of HTTPS. A middleman attack
    is exactly what it sounds like: a malicious eavesdropper that can intercept communication
    packets between the user and the server. This also means that the eavesdropper
    can also obtain encryption if they are passed over a network. Simply googling
    “middleman attacks” will result in loads of tutorials and software that can be
    downloaded to implement such attacks. There are more caveats to security that
    are beyond the scope of this book, but to conclude, if you are hosting a website
    that you expect users to connect and log in to, there is no excuse to not use
    HTTPS.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索 HTTPS 的步骤之前，我们需要了解什么是中间人攻击，因为这种攻击启发了 HTTPS 的步骤。中间人攻击正是其名称所暗示的那样：一个恶意窃听者可以拦截用户和服务器之间的通信数据包。这也意味着窃听者还可以在数据通过网络传输时获取加密信息。简单地搜索“中间人攻击”将会出现大量教程和可以下载以实施此类攻击的软件。本书范围之外还有更多关于安全性的注意事项，但为了总结，如果你正在托管一个你希望用户连接并登录的网站，没有理由不使用
    HTTPS。
- en: 'When it comes to HTTPS, there is a range of steps that need to take place.
    First, before any requests are made to the server, the owner of the server and
    domain must get a certificate from a trusted central authority. There are not
    many trusted central authorities around. What these authorities do is get some
    identification of the person who owns the domain and some proof that the person
    applying for the certificate owns the domain. This might sound like a headache,
    but a lot of URL providers such as AWS have streamlined the process using information,
    such as payment details, to send to the central trusted authority in the backend
    when you are pointing and clicking to buy the domain. We will have to fill in
    some extra forms, but if you have a working AWS account, this will not be too
    taxing. These central authorities are limited because anyone with a computer can
    create a digital certificate. For instance, if we were intercepting traffic between
    a server and a user, we could generate our own digital certificates with a key
    and forward them to the user. Because of this, mainstream browsers only recognize
    certificates that have been issued by a small number of recognized authorities.
    If the browser gets a certificate that is not recognized, these browsers will
    give a warning, such as in the following Chrome example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 HTTPS 时，需要采取一系列步骤。首先，在向服务器发送任何请求之前，服务器和域的所有者必须从受信任的中心机构获取一个证书。可信赖的中心机构并不多。这些机构所做的是获取域名所有者的某些身份证明以及申请证书的人拥有该域的某些证据。这听起来可能像是一个头疼的问题，但许多
    URL 提供商，如 AWS，通过使用诸如支付详情等信息简化了流程，在您点击购买域名时将这些信息发送到后端的后台受信任中心机构。我们可能需要填写一些额外的表格，但如果您有一个有效的
    AWS 账户，这不会太费事。这些中心机构是有限的，因为任何拥有计算机的人都可以创建数字证书。例如，如果我们正在拦截服务器和用户之间的流量，我们可以使用密钥生成自己的数字证书并将其转发给用户。正因为如此，主流浏览器只认可由少数认可机构签发的证书。如果浏览器收到一个未认可的证书，这些浏览器将会给出警告，如下面的
    Chrome 示例所示：
- en: '![Figure 11.1 – Chrome blocking access due to unrecognized certificate](img/Figure_11.1_B18722.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 由于未识别的证书，Chrome 阻止访问](img/Figure_11.1_B18722.jpg)'
- en: Figure 11.1 – Chrome blocking access due to unrecognized certificate
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 由于未识别的证书，Chrome 阻止访问
- en: It is not advised to click on **ADVANCED** to proceed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议点击**高级**以继续。
- en: 'Once the owner of the domain and server has the certificate from the central
    authority, the user can make requests. Before any meaningful data to the application
    is exchanged, the server sends over the certificate with the public key to the
    user. The user then creates a session key and encrypts this session key and the
    public key of the certificate, which is then sent back to the server. The server
    can then decrypt the key using the private key that was not sent over the network.
    Therefore, even if the eavesdropper manages to intercept the messages and get
    the session key, it is encrypted, so they cannot use it. Both the server and client
    can check the validity of mutually encrypted messages. We can use the session
    key to send encrypted messages to and from the server and the user, as seen in
    the following diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦域名和服务器所有者从中央机构获得证书，用户就可以发起请求。在交换任何有意义的数据到应用程序之前，服务器会将带有公钥的证书发送给用户。然后用户创建一个会话密钥，并加密这个会话密钥和证书的公钥，然后将它发送回服务器。服务器随后可以使用未通过网络发送的私钥解密这个密钥。因此，即使窃听者设法拦截消息并获取会话密钥，它也是加密的，所以他们无法使用它。服务器和客户端都可以检查相互加密消息的有效性。我们可以使用会话密钥向服务器和用户发送加密消息，如以下图所示：
- en: '![Figure 11.2 – Steps required when making an HTTPS connection](img/Figure_11.2_B18722.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 建立HTTPS连接所需的步骤](img/Figure_11.2_B18722.jpg)'
- en: Figure 11.2 – Steps required when making an HTTPS connection
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 建立HTTPS连接所需的步骤
- en: Do not worry—there are packages and tools that will help us manage the HTTPS
    process; we will not have to implement our own protocol. You will understand why
    we must carry out certain steps and how to troubleshoot problems when they arise.
    In the next section, we will implement a basic HTTPS protocol with NGINX locally.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心——有各种软件包和工具可以帮助我们管理HTTPS过程；我们不需要实现自己的协议。您将了解为什么我们必须执行某些步骤，以及如何在出现问题时进行故障排除。在下一节中，我们将使用NGINX在本地实现基本的HTTPS协议。
- en: Implementing HTTPS locally with docker-compose
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用docker-compose在本地实现HTTPS
- en: 'When it comes to implementing HTTPS, most of the work is going to be achieved
    through NGINX. Although we have worked a little with NGINX, the NGINX configuration
    is a powerful tool. You can implement conditional logic, pull variables and data
    from the request and act on them, redirect traffic, and much more. In this chapter,
    we are going to do enough to implement HTTPS, but it is advised if you have time
    to read up on the fundamentals of NGINX configurations; reading material is provided
    in the *Further reading* section. For our `deployment/nginx_config.yml` file,
    we need to have the following layout:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到实现HTTPS时，大部分工作将通过NGINX来完成。尽管我们与NGINX有过一些合作，但NGINX配置是一个强大的工具。您可以实现条件逻辑，从请求中提取变量和数据并对其操作，重定向流量，等等。在本章中，我们将足够地实现HTTPS，但如果您有时间，建议您阅读有关NGINX配置基础的知识；阅读材料在*进一步阅读*部分提供。对于我们的`deployment/nginx_config.yml`文件，我们需要以下布局：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we can see that we have two `server` scopes in our `http` scope. This
    is because we need to enforce HTTPS. We must remember that our outside port is
    `80`. However, if we want to carry out an HTTPS connection, we instead need to
    connect to port `443`, which is the standard for HTTPS. Typing `https://` into
    the browser will target port `443`, and typing `http://` into the browser will
    target port `80`. If we allow port `80` to be open, loads of users will access
    our site in an unsecured way because some people will type `http://` into the
    browser. Hackers would also spread the HTTP links around because they want as
    many people as possible to not use a secure network. However, if we block port
    `80`, people who put `http://` into the browser will just get blocked from accessing
    the website. It is unlikely that the average user is going to understand the differences
    in ports, look at what they typed in, and correct it. Instead, they are just going
    to think that the site is down. Therefore, we are going to have to listen to both
    ports `443` and `80`. However, when a request is made to port `80`, we going to
    redirect the request to port `443` instead. Our first server scope can redirect
    with the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到在我们的`http`作用域中存在两个`server`作用域。这是因为我们需要强制执行HTTPS。我们必须记住我们的外部端口是`80`。然而，如果我们想进行HTTPS连接，我们反而需要连接到端口`443`，这是HTTPS的标准端口。在浏览器中输入`https://`将针对端口`443`，而在浏览器中输入`http://`将针对端口`80`。如果我们允许端口`80`开放，大量的用户将以不安全的方式访问我们的网站，因为有些人会在浏览器中输入`http://`。黑客也会传播HTTP链接，因为他们希望尽可能多的人不使用安全网络。然而，如果我们阻止端口`80`，将`http://`输入到浏览器中的人将无法访问网站。普通用户不太可能理解端口之间的差异，查看他们输入的内容，并更正它。相反，他们只会认为网站已关闭。因此，我们必须监听端口`443`和`80`。然而，当请求端口`80`时，我们将请求重定向到端口`443`。我们的第一个服务器作用域可以使用以下代码进行重定向：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we can see that we listen to port `80`, and then return the same request
    that was sent but with the HTTPS protocol, which means that it will hit our `443`
    port. We can also see that we reference `$host` and `$request_uri` variables.
    These variables are standard variables in NGINX that are automatically populated.
    We can define our own variables with the following line of code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们监听端口`80`，然后返回相同的请求，但使用HTTPS协议，这意味着它将击中我们的`443`端口。我们还可以看到我们引用了`$host`和`$request_uri`变量。这些变量是NGINX中的标准变量，它们会自动填充。我们可以使用以下代码行定义自己的变量：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, we want our NGINX instance to work on our server and localhost, so
    using the standard variables is the best choice here. Now that we have defined
    our rerouting rule, we can move on to the next server scope; we listen to port
    `443` with the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望我们的NGINX实例在我们的服务器和本地主机上运行，因此使用标准变量是这里最好的选择。现在我们已经定义了重定向规则，我们可以继续到下一个服务器作用域；我们使用以下代码监听端口`443`：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Looking at the preceding code, it must be noted that we are handling and directing
    traffic for both the frontend and backend applications in the same NGINX instance.
    Alongside the port definition, we also declare that we are using the `ssl` and
    `http2` NGINX modules. This is not surprising as HTTPS is essentially SSL on top
    of HTTP/2\. We then define where our server certificate is in the NGINX container.
    We will add these later in the `docker-compose` volume. We can also see that we
    pass our HTTPS request to the appropriate application via HTTP. If we try to change
    these proxies to the HTTPS protocol, then we would get a bad gateway error. This
    is because the handshake between NGINX and our services would fail. It is not
    essential because we must remember that the ports that the frontend and backend
    applications expose are not available to anyone outside of localhost. Yes—on our
    local machine we can access them, but this is because they are running on our
    local machine. If we were to deploy our application server, it will look like
    this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的代码，必须注意我们正在同一个NGINX实例中处理和引导前端和后端应用的流量。在端口定义的同时，我们还声明我们正在使用`ssl`和`http2`
    NGINX模块。这并不奇怪，因为HTTPS本质上是在HTTP/2之上的SSL。然后我们定义服务器证书在NGINX容器中的位置。我们将在`docker-compose`卷中稍后添加这些。我们还可以看到我们将HTTPS请求通过HTTP传递到适当的应用程序。如果我们尝试将这些代理更改为HTTPS协议，那么我们会得到一个不良网关错误。这是因为NGINX和我们的服务之间的握手将失败。这不是必需的，因为我们必须记住，前端和后端应用暴露的端口对于本地主机之外的人来说是不可用的。是的——在我们的本地机器上我们可以访问它们，这是因为它们运行在我们的本地机器上。如果我们部署我们的应用程序服务器，它将看起来像这样：
- en: '![Figure 11.3 – Traffic flow if deployed on a server](img/Figure_11.3_B18722.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 如果在服务器上部署，流量流向](img/Figure_11.3_B18722.jpg)'
- en: Figure 11.3 – Traffic flow if deployed on a server
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 如果在服务器上部署，流量流向
- en: Our NGINX configuration is not optimum. There are settings that can be tweaked
    in terms of ciphers, caching, and managing timeouts. However, this is enough to
    get an HTTPS protocol working. If you get to the point that you need to optimize
    the caching and encryption methods of your NGINX configuration, it is suggested
    that you seek further education materials on DevOps and NGINX.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 NGINX 配置并非最佳。有一些设置可以在密码、缓存和管理超时方面进行调整。然而，这已经足够让 HTTPS 协议工作。如果你需要优化 NGINX
    配置的缓存和加密方法，建议你寻找更多关于 DevOps 和 NGINX 的教育资源。
- en: Now that we have defined our NGINX configuration, we must define our certificates.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的 NGINX 配置，我们必须定义我们的证书。
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To define our own certificates, we must install the `openssl` package by following
    the steps using the next links:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义我们自己的证书，我们必须通过以下链接中的步骤安装 `openssl` 包：
- en: '**Linux**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux**:'
- en: '[https://fedingo.com/how-to-install-openssl-in-ubuntu/](https://fedingo.com/how-to-install-openssl-in-ubuntu/)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[如何在 Ubuntu 上安装 OpenSSL](https://fedingo.com/how-to-install-openssl-in-ubuntu/)'
- en: '**Windows**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**:'
- en: '[https://linuxhint.com/install-openssl-windows/](https://linuxhint.com/install-openssl-windows/)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[在 Windows 上安装 OpenSSL](https://linuxhint.com/install-openssl-windows/)'
- en: '**Mac**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mac**:'
- en: '[https://yasar-yy.medium.com/installing-openssl-library-on-macos-catalina-6777a2e238a6](https://yasar-yy.medium.com/installing-openssl-library-on-macos-catalina-6777a2e238a6)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[在 macOS Catalina 上安装 OpenSSL 库](https://yasar-yy.medium.com/installing-openssl-library-on-macos-catalina-6777a2e238a6)'
- en: 'This can be done with the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下命令完成：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This creates a key with `x509`, which is the international telecommunication
    union standard. We state that the certificate will expire in 10 days and that
    the key and certificate will have the name `self`. They can be called anything;
    however, for us, it makes sense to call the certificate `self` because it is a
    self-issued certificate. The command shown in the previous code snippet will push
    several prompts. It does not matter what you say to these prompts as we will just
    be making localhost requests with them, meaning that they will never go anywhere
    outside of our local computer. We can now stash the key and certificate anywhere
    within the `deployment` directory if you can reference the key and certificate
    placed in the `docker-compose.yml` file. In our `docker-compose.yml` file, our
    NGINX service now takes the following form:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个 `x509` 密钥，这是国际电信联盟的标准。我们声明证书将在 10 天后过期，密钥和证书的名称为 `self`。它们可以命名为任何东西；然而，对我们来说，将证书命名为
    `self` 是有意义的，因为它是一个自签发的证书。之前代码片段中显示的命令将推送几个提示。对于这些提示，你可以说什么并不重要，因为我们只是会用它们进行本地主机请求，这意味着它们永远不会超出我们的本地计算机之外。现在，如果你可以在
    `docker-compose.yml` 文件中引用密钥和证书，我们就可以将密钥和证书存储在 `deployment` 目录中的任何位置。在我们的 `docker-compose.yml`
    文件中，我们的 NGINX 服务现在具有以下形式：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can see that I chose to store the key and certificate inside a directory
    called `nginx_configs/ssl/`. This is because I have added several simple NGINX
    configs into the GitHub repo under the `nginx_configs` directory if you want some
    easy quick references on handling variables, conditional logic, and serving HTML
    files directly from NGINX. While where you get your key and certificate from may
    vary, it is important that you put the key and the certificate inside the `etc/nginx/ssl/`
    directory inside the NGINX container.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我选择将密钥和证书存储在一个名为 `nginx_configs/ssl/` 的目录中。这是因为我在 `nginx_configs`
    目录下添加了几个简单的 NGINX 配置到 GitHub 仓库中，如果你想要一些关于处理变量、条件逻辑和直接从 NGINX 服务器上服务 HTML 文件的快速参考。虽然你从哪里获取密钥和证书可能不同，但将密钥和证书放在
    NGINX 容器内的 `etc/nginx/ssl/` 目录中是很重要的。
- en: 'We are now at the point where you can test our application to see if the local
    HTTPS is working. If you spin up your `docker-compose` instance and then go to
    the `https://localhost` URL in your browser, you should get a warning that it
    is not secure, and you will not be able to instantly connect to the frontend.
    This is reassuring because we are not a central authority, so our browser will
    not recognize our certificate. There is a multitude of browsers, and we would
    waste a lot of space in this book describing how to get past this for every browser.
    Considering browsers are free to download, we can get around the blocking of our
    application in Chrome by going to the `flags` URL, as seen here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试我们的应用程序以查看本地 HTTPS 是否工作。如果你启动你的 `docker-compose` 实例，然后在浏览器中访问 `https://localhost`
    URL，你应该会收到一个警告，表明它不安全，你将无法立即连接到前端。这令人放心，因为我们不是中央权威机构，所以我们的浏览器将不会识别我们的证书。有众多浏览器，我们在这本书中描述如何绕过每个浏览器的限制会浪费很多空间。考虑到浏览器可以免费下载，我们可以通过访问
    `flags` URL 来绕过 Chrome 对我们应用程序的阻止，如下所示：
- en: '![Figure 11.4 – Allowing our application certificate to pass in Chrome](img/Figure_11.4_B18722.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 在 Chrome 中允许我们的应用程序证书通过](img/Figure_11.4_B18722.jpg)'
- en: Figure 11.4 – Allowing our application certificate to pass in Chrome
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 在 Chrome 中允许我们的应用程序证书通过
- en: 'Here, we can see that I have allowed invalid certificates from localhost. Now
    that our invalid certificate is enabled in our browser, we can access our application,
    as seen here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我已经允许来自 localhost 的无效证书。现在，在我们的浏览器中启用了无效证书后，我们可以访问我们的应用程序，如下所示：
- en: '![Figure 11.5 – Accessing our application through HTTPS](img/Figure_11.5_B18722.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 通过 HTTPS 访问我们的应用程序](img/Figure_11.5_B18722.jpg)'
- en: Figure 11.5 – Accessing our application through HTTPS
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 通过 HTTPS 访问我们的应用程序
- en: 'Here, we are using the HTTPS protocol; however, as we can see in the preceding
    screenshot, Chrome is complaining stating that it is not secure. We can inspect
    the reason why by clicking on the **Not Secure** statement, giving the following
    view:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用的是 HTTPS 协议；然而，正如我们在前面的截图中所见，Chrome 正在抱怨说它不安全。我们可以通过点击 **不安全** 提示来检查原因，如下所示：
- en: '![Figure 11.6 – Explaining why the connection is not secure](img/Figure_11.6_B18722.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 解释连接不安全的原因](img/Figure_11.6_B18722.jpg)'
- en: Figure 11.6 – Explaining why the connection is not secure
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 解释连接不安全的原因
- en: Here, we can see that our certificate is not valid. We expected the certificate
    to not be valid because we issued it, which makes it not officially recognized.
    However, our HTTPS connection is working! This is interesting to see how HTTPS
    works; however, it is not useful with a self-signed certificate running on our
    localhost. If we want to utilize HTTPS, we are going to have to apply it to our
    application on AWS. There are a couple of steps we need to carry out before we
    implement HTTPS on AWS. In the next section, we will assign a URL to our application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的证书是无效的。我们预期证书将无效，因为我们自己签发了它，这使得它没有得到官方认可。然而，我们的 HTTPS 连接正在工作！这很有趣，可以看到
    HTTPS 的工作原理；然而，在我们的 localhost 上运行的自签名证书并没有什么用。如果我们想利用 HTTPS，我们必须将其应用到 AWS 上的应用程序中。在
    AWS 上实现 HTTPS 之前，我们需要执行几个步骤。在下一节中，我们将为我们的应用程序分配一个 URL。
- en: Attaching a URL to our deployed application on AWS
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 URL 附接到 AWS 上部署的应用程序
- en: 'In the previous chapter, we managed to deploy our to-do application onto a
    server on AWS and access this application directly by putting the IP address of
    the server into our browser. When it comes to registering our URL, you will be
    exposed to multiple acronyms. To feel comfortable when navigating AWS routing,
    it makes sense to be familiar with URL acronyms by reading the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们成功将待办事项应用程序部署到 AWS 服务器上，并通过将服务器的 IP 地址输入我们的浏览器来直接访问此应用程序。当我们注册我们的 URL
    时，你会遇到多个缩写词。为了在 AWS 路由导航时感到舒适，熟悉以下图表中的 URL 缩写词是有意义的：
- en: '![Figure 11.7 – Anatomy of a URL](img/Figure_11.7_B18722.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – URL 的结构](img/Figure_11.7_B18722.jpg)'
- en: Figure 11.7 – Anatomy of a URL
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – URL 的结构
- en: 'When we are associating a URL with our application, we are going to be configuring
    a **Domain Name System** (**DNS**). A DNS is a system that translates a user-friendly
    URL to an IP address. For a DNS system to work, we will need the following components:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 URL 与我们的应用程序关联时，我们将配置一个 **域名系统**（**DNS**）。DNS 是一个将用户友好的 URL 转换为 IP 地址的系统。为了
    DNS 系统能够工作，我们需要以下组件：
- en: '**Domain registrar**: An organization such as AWS, Google Cloud, Azure, GoDaddy,
    and so on that will register a domain if it receives payment for the domain and
    personal details of the person responsible for the domain. This organization will
    also handle reports of abuse if the URL is used in illegal activity.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域名注册商**：一个像AWS、Google Cloud、Azure、GoDaddy等组织，如果收到域名的付款和负责人的个人信息，就会注册一个域名。如果URL被用于非法活动，该组织也会处理滥用报告。'
- en: '**DNS record**: A registered URL can have multiple DNS records. A DNS record
    essentially defines a routing rule for the URL. For instance, a simple DNS record
    will forward the URL to an IP address of a server.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DNS记录**：一个已注册的URL可以有多个DNS记录。DNS记录本质上定义了URL的路由规则。例如，一个简单的DNS记录会将URL转发到服务器的IP地址。'
- en: '**Zone file**: A container for DNS records (in our case, the zone file will
    be managed by AWS).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域文件**：DNS记录的容器（在我们的情况下，区域文件将由AWS管理）。'
- en: 'The DNS records and registrars are essential for our URL to work. Even though
    we can directly connect to IP addresses, there are a couple of middlemen if we
    want to connect to a URL, as laid out here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: DNS记录和注册商对我们的URL工作至关重要。尽管我们可以直接连接到IP地址，但如果我们想连接到URL，这里有几个中间人，如下所述：
- en: '![Figure 11.8 – Steps required to connect a URL to an IP address](img/Figure_11.8_B18722.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 连接URL到IP地址所需的步骤](img/Figure_11.8_B18722.jpg)'
- en: Figure 11.8 – Steps required to connect a URL to an IP address
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 连接URL到IP地址所需的步骤
- en: As we can see from the preceding diagram, if we want to connect to a server,
    we send the URL to the local DNS server. This server then makes three calls in
    sequential order from top to bottom. By the end of the three requests, the local
    DNS server will have the IP address related to the URL. We can see that the registrar
    is responsible for part of the mapping. This is where our DNS records are configured.
    If we remove our DNS records, then the URL is no longer available on the internet.
    We do not have to make the calls laid out in *Figure 11**.8* every time we enter
    a URL. Our browsers and the local DNS server will cache the URL to the IP address
    mapped to reduce the number of calls to the other three servers. There is a problem,
    however; when we have been building our production server, you might have realized
    that the IP address has changed every time we tear down and spin up a production
    server. There’s nothing wrong going on here; when we create an EC2 instance, we
    must take a server that is available. A cloud provider such as AWS cannot hold
    the server aside just for us unless we want to pay for it. In the next section,
    we will keep our IP consistent with elastic IP addresses.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，如果我们想连接到服务器，我们将URL发送到本地DNS服务器。然后，该服务器从上到下按顺序进行三次调用。在三次请求结束时，本地DNS服务器将拥有与URL相关的IP地址。我们可以看到注册商负责部分映射。这就是我们配置DNS记录的地方。如果我们删除我们的DNS记录，那么URL将不再在互联网上可用。我们不必每次输入URL时都执行图*11.8*中列出的调用。我们的浏览器和本地DNS服务器会缓存URL到IP地址的映射，以减少对其他三个服务器的调用次数。然而，这里有一个问题；当我们构建我们的生产服务器时，你可能已经意识到每次我们拆解和启动生产服务器时，IP地址都会改变。这里并没有发生什么问题；当我们创建EC2实例时，我们必须选择一个可用的服务器。像AWS这样的云提供商不能为了我们而保留服务器，除非我们愿意为此付费。在下一节中，我们将保持IP地址与弹性IP地址的一致性。
- en: Attaching an elastic IP to our server
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将弹性IP附加到我们的服务器
- en: Elastic IP addresses are essentially fixed IP addresses that we keep. We can
    then attach these elastic IP addresses to any one EC2 instance at one point in
    time as we see fit. This is very helpful when it comes to routing. We can set
    up the routing of a URL to an elastic IP and then switch the allocation of the
    elastic IP to the server that we need. This means that we can deploy a new application
    to another server, test it, and then switch our elastic IP to the new deployment
    server without having to touch the routing for our URL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性IP地址本质上是我们保留的固定IP地址。我们可以在任何时候将这弹性IP地址附加到任何一个EC2实例上，只要我们觉得合适。这在路由方面非常有帮助。我们可以设置将URL路由到弹性IP的配置，然后切换弹性IP的分配到我们需要的服务器。这意味着我们可以将新应用程序部署到另一台服务器上，测试它，然后无需触及URL的路由即可将我们的弹性IP切换到新的部署服务器。
- en: 'We will not be creating an elastic IP every time we spin up a production server.
    Because of this, it is OK to point and click in the AWS console to create and
    attach the elastic IP address. Before we do this, however, we need to deploy our
    production server with the previous NGINX config file that does not have HTTPS
    defined, but instead has the following form:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会每次启动生产服务器时都创建一个弹性IP。因此，在AWS控制台中点击创建和附加弹性IP地址是可以的。然而，在我们这样做之前，我们需要使用之前定义的没有HTTPS定义的NGINX配置文件部署我们的生产服务器，如下所示：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should make sense to you now, as the NGINX config merely listens to HTTP
    requests through the outside port `80` and then passes them through to our applications.
    We also must remove our reference to our self-signed certificates because we will
    not need them, and we will also not be uploading those certificates to our server.
    Considering our lack of reference to our certificates, our `docker-compose` instance
    in our `deployment` directory should have the following NGINX definition:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该已经明白了，因为NGINX配置只是通过外部端口`80`监听HTTP请求，然后将它们传递给我们的应用程序。我们还必须删除我们对自己签名的证书的引用，因为我们不需要它们，也不会将这些证书上传到我们的服务器。考虑到我们没有引用我们的证书，我们`deployment`目录中的`docker-compose`实例应该有以下的NGINX定义：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are now ready to deploy our build on our production server. Remember—we can
    do this using the `deployment/run_build.py` Python script that we set up in the
    previous chapter. Once the server is built, we know that there is an EC2 instance
    live with the `"to-do production server"` tag. We are now ready to allocate an
    elastic IP address to our EC2 instance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始在生产服务器上部署我们的构建了。记住——我们可以使用之前章节中设置的`deployment/run_build.py` Python脚本来完成这项工作。一旦服务器构建完成，我们知道有一个带有`"待办生产服务器"`标签的EC2实例正在运行。我们现在可以为我们的EC2实例分配一个弹性IP地址。
- en: 'To allocate elastic IPs, we first need to navigate to the EC2 service by searching
    for EC2 in the search bar in the AWS dashboard at the top and clicking on the
    service, resulting in the following view:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配弹性IP，我们首先需要通过在AWS仪表板顶部的搜索栏中搜索EC2并点击服务来导航到EC2服务，这将导致以下视图：
- en: '![Figure 11.9 – EC2 dashboard view](img/Figure_11.9_B18722.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – EC2仪表板视图](img/Figure_11.9_B18722.jpg)'
- en: Figure 11.9 – EC2 dashboard view
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – EC2仪表板视图
- en: 'We can see that **Elastic IPs** can be accessed on the right of the **Resources**
    panel and on the left of the screen. Once we are in the elastic IP address dashboard,
    we will have a list of elastic IP addresses that you have. On the top right of
    the screen, there will be an orange button labeled **Allocate Elastic IP address**.
    If you click this button, you will get the following creation form:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，**弹性IP**可以在**资源**面板的右侧和屏幕的左侧访问。一旦我们进入弹性IP地址仪表板，我们将有一个您拥有的弹性IP地址列表。在屏幕右上角，将有一个标有**分配弹性IP地址**的橙色按钮。如果您点击此按钮，您将获得以下创建表单：
- en: '![Figure 11.10 – Allocating (creating) an elastic IP address](img/Figure_11.10_B18722.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 分配（创建）弹性IP地址](img/Figure_11.10_B18722.jpg)'
- en: Figure 11.10 – Allocating (creating) an elastic IP address
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 分配（创建）弹性IP地址
- en: What we are doing here is grabbing an elastic IP address from a pool of IP addresses
    for the area you are working on. There is a limit of five elastic IP addresses
    per account. If you think this is not enough for you, you will need to get more
    creative with your networking infrastructure. You can also investigate creating
    sub-accounts for the main account. As with clean code, there are benefits to having
    clean accounts that only work on one project at a time. This will help you keep
    track of costs, and shutting down all infrastructure for a project will be clean
    as you can be sure that everything for that project has been cleared by deleting
    the account.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是从您正在工作的区域的一个IP地址池中获取一个弹性IP地址。每个账户的弹性IP地址限制为五个。如果您认为这不足以满足您的需求，您将需要更具有创造性来设计您的网络基础设施。您还可以调查为主账户创建子账户。就像干净的代码一样，只针对一个项目进行清洁账户操作是有好处的。这将帮助您跟踪成本，并且关闭一个项目的所有基础设施将非常干净，因为您可以确信该项目的所有内容都已通过删除账户而被清除。
- en: 'Moving on to our allocation of the elastic IP to our EC2 server, we can allocate
    our elastic IP by highlighting the desired elastic IP address in the elastic IP
    dashboard and clicking on the **Actions** button at the top right of the dashboard,
    as seen here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，关于我们将弹性IP分配给EC2服务器，我们可以在弹性IP仪表板中突出显示所需的弹性IP地址，然后点击仪表板右上角的**操作**按钮，如下所示：
- en: '![Figure 11.11 – Actions on our elastic IP](img/Figure_11.11_B18722.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – 对我们的弹性 IP 执行操作](img/Figure_11.11_B18722.jpg)'
- en: Figure 11.11 – Actions on our elastic IP
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – 对我们的弹性 IP 执行操作
- en: 'Under **Actions**, we must click on the **Associate Elastic IP address** option,
    giving us the following display:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **操作** 下，我们必须点击 **关联弹性 IP 地址** 选项，这将显示以下内容：
- en: '![Figure 11.12 – Associating an elastic IP address](img/Figure_11.12_B18722.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 关联弹性 IP 地址](img/Figure_11.12_B18722.jpg)'
- en: Figure 11.12 – Associating an elastic IP address
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 关联弹性 IP 地址
- en: 'The `"to-do production server"` tag that we defined in Terraform. However,
    if we do not have a tag, we can still choose an instance from the drop-down menu.
    We can then click the **Associate** button. Once this is done, we can go to our
    elastic IP address in our browser, and we should be able to access our to-do application,
    as seen here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Terraform 中定义的 `"to-do 生产服务器"` 标签。然而，如果我们没有标签，我们仍然可以从下拉菜单中选择一个实例。然后我们可以点击
    **关联** 按钮。完成此操作后，我们可以在浏览器中访问我们的弹性 IP 地址，我们应该能够访问我们的待办事项应用程序，如图所示：
- en: '![Figure 11.13 – Accessing our to-do application using a static IP](img/Figure_11.13_B18722.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 使用静态 IP 访问我们的待办事项应用程序](img/Figure_11.13_B18722.jpg)'
- en: Figure 11.13 – Accessing our to-do application using a static IP
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 使用静态 IP 访问我们的待办事项应用程序
- en: And here we have it—our application can be accessed with an elastic IP!! We
    can now spin up a new server if we want, test it, and redirect our elastic IP
    to the new server if we are happy, providing seamless updates without our users
    knowing. However, getting users to type in the raw IP address is not desirable.
    In the next section, we will register a domain and connect it to our elastic IP
    address.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是我们想要的——我们的应用程序可以通过弹性 IP 访问！！如果我们想的话，现在可以启动一个新的服务器，测试它，如果我们满意，可以将弹性 IP 重定向到新服务器，从而提供无缝更新，而用户不会察觉。然而，让用户输入原始
    IP 地址并不理想。在下一节中，我们将注册一个域名并将其连接到我们的弹性 IP 地址。
- en: Registering a domain name
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册域名
- en: 'When it comes to registering a domain, it can all be handled in AWS with the
    Route 53 service. First, we navigate to Route 53, which is the service that handles
    routing and URL registration. On the left side of the **Route 53** dashboard web
    page, we can click on the **Registered domains** section, as seen in the following
    screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到注册域名时，所有这些都可以通过 AWS 的 Route 53 服务来处理。首先，我们导航到 Route 53，这是处理路由和 URL 注册的服务。在
    **Route 53** 控制台网页的左侧，我们可以点击 **已注册域名** 部分，如下面的截图所示：
- en: '![Figure 11.14 – Navigation to registered domains in the Route 53 dashboard](img/Figure_11.14_B18722.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 在 Route 53 控制台中导航到已注册域名](img/Figure_11.14_B18722.jpg)'
- en: Figure 11.14 – Navigation to registered domains in the Route 53 dashboard
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 在 Route 53 控制台中导航到已注册域名
- en: 'We will then see a list of registered domains that we already own and the option
    to register a domain, as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将看到我们已拥有的已注册域名列表以及注册域名的选项，如下面的截图所示：
- en: '![Figure 11.15 – Registered domains view](img/Figure_11.15_B18722.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 已注册域名视图](img/Figure_11.15_B18722.jpg)'
- en: Figure 11.15 – Registered domains view
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 已注册域名视图
- en: If you click on the **Register Domain** button, you will be led through a straightforward
    series of forms to register your domain. Screenshotting these steps would be excessive.
    The forms ask you for the domain you want to register. They will then tell you
    if the domain and other domains such as this are available. Domains cost about
    $12 a year on average at the time of writing this book. Once you have selected
    your domain and clicked on the checkout, you will be passed through a series of
    personal information forms. These forms include a contact address and whether
    the domain is for personal use or for a company. Screenshotting these forms would
    result in excessive pages with little educational advantage as these forms are
    personal and easy to fill in. It is recommended that you select the validation
    through DNS because this is automated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击 **注册域名** 按钮，您将进入一系列简单的表单以注册您的域名。截图这些步骤将是过度的。表单会要求您输入想要注册的域名。然后它们会告诉您该域名和其他类似域名是否可用。在撰写本书时，域名平均每年花费约
    12 美元。一旦您选择了域名并点击结账，您将进入一系列个人信息表单。这些表单包括联系地址以及域名是用于个人使用还是公司。截图这些表单会导致页面过多，教育优势很小，因为这些表单是个人且容易填写。建议您选择通过
    DNS 进行验证，因为这将是自动化的。
- en: 'Once your domain is registered, you can go to the **Hosted zones** section
    in the main Route 53 dashboard. Here, we will see a list of hosted zones for each
    URL that you own. A hosted zone is essentially a collection of DNS records. If
    we click on a hosted zone for a URL, there will be two DNS records: NS and SOA
    (NS—name server; SOA—start of authority). These records should not be deleted,
    and if they are, somebody else who knows what these records are could hijack your
    URL by implementing those records themselves. DNS records are essentially records
    on how to route traffic for a domain name. Each DNS record has the following attributes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的域名注册完成，你可以进入Route 53主控制台中的**主机区域**部分。在这里，我们将看到你拥有的每个URL的主机区域列表。主机区域本质上是一组DNS记录。如果我们点击一个URL的主机区域，将会有两个DNS记录：NS和SOA（NS—名称服务器；SOA—权威开始）。这些记录不应被删除，如果它们被删除，知道这些记录的人可能会通过实施这些记录来劫持你的URL。DNS记录本质上是如何为域名路由流量的记录。每个DNS记录都有以下属性：
- en: '**Domain/subdomain name**: The name of the URL the record belongs to'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域名/子域名名称**：记录所属的URL名称'
- en: '**Record type**: The type of record (A, AAAA, CNAME, or NS)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录类型**：记录类型（A、AAAA、CNAME或NS）'
- en: '**Value**: Target IP address'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：目标IP地址'
- en: '**Routing policy**: How Route 53 responds to queries'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由策略**：Route 53对查询的响应方式'
- en: '**TLL (Time to Live)**: The amount of time the record is cached in the DNS
    resolvers in the client so that we do not have to query the Route 53 servers too
    often, with the trade-off of reducing traffic to DNS servers versus time for updates
    to roll onto clients'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLL (Time to Live)**: 记录在客户端DNS解析器中缓存的时长，这样我们就不必频繁查询Route 53服务器，以减少DNS服务器流量与更新传播到客户端的时间之间的权衡'
- en: 'The attributes just defined are self-explanatory, apart from the record type.
    There are advanced record types that we can build in Route 53\. However, the following
    record types are needed for us to route our domain to our IP:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如定义的属性一样，除了记录类型。我们可以在Route 53中构建高级记录类型。然而，以下记录类型是我们将域名路由到IP地址所必需的：
- en: '**A**: The simplest record type. Type A merely routes traffic from the URL
    to an IPv4 IP address.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**：最简单的记录类型。类型A仅仅是将流量从URL路由到IPv4 IP地址。'
- en: '**AAAA**: Routes traffic from the URL to an IPv6 address.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AAAA**：将流量从URL路由到IPv6地址。'
- en: '**CNAME**: Maps a hostname to another hostname (target must be an A or AAAA
    record type).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CNAME**：将主机名映射到另一个主机名（目标必须是A或AAAA记录类型）。'
- en: '**NS**: Name server for the hosted zone (controls how the traffic is routed).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NS**: 主机区域的名称服务器（控制流量路由方式）。'
- en: 'For us, we are going to create an DNS `A` record by clicking on the **Create
    record** button, as seen in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，我们将通过点击**创建记录**按钮创建一个DNS `A`记录，如以下截图所示：
- en: '![Figure 11.16 – Creating a DNS record](img/Figure_11.16_B18722.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图11.16 – 创建DNS记录](img/Figure_11.16_B18722.jpg)'
- en: Figure 11.16 – Creating a DNS record
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 – 创建DNS记录
- en: 'Once we have clicked on this, we get the following layout:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 点击后，我们得到以下布局：
- en: '![Figure 11.17 – Creating a DNS record form](img/Figure_11.17_B18722.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17 – 创建DNS记录表单](img/Figure_11.17_B18722.jpg)'
- en: Figure 11.17 – Creating a DNS record form
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – 创建DNS记录表单
- en: 'We can see that record type `A` is the default. We can also see that we can
    add a subdomain. This gives us some flexibility. For instance, if we wanted, the
    `api.freshcutswags.com` URL could point to a different IP address from `freshcutswags.com`.
    For now, we are going to just leave the subdomain empty. We are then going to
    put the elastic IP address that we set up in the previous section in the `www`.
    Once this is done, we should have two `A` records. We can then check where our
    URL is mapping the traffic using the [www.digwebinterface.com](https://www.digwebinterface.com)
    website. Here, we can enter URLs, and the website will tell us where the URLs
    are being mapped. We can see here that our URLs are both mapping to the correct
    elastic IP:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到记录类型 `A` 是默认的。我们还可以看到我们可以添加一个子域名。这给了我们一些灵活性。例如，如果我们想的话，`api.freshcutswags.com`
    URL可以指向与`freshcutswags.com`不同的IP地址。现在，我们将保持子域名为空。然后，我们将把在前一节中设置的弹性IP地址放入`www`中。一旦完成，我们应该有两个`A`记录。然后我们可以使用[www.digwebinterface.com](https://www.digwebinterface.com)网站检查我们的URL映射流量。在这里，我们可以输入URL，网站会告诉我们URL被映射到了哪里。我们可以看到，我们的URL都映射到了正确的弹性IP：
- en: '![Figure 11.18 – Inspecting our URL mapping](img/Figure_11.18_B18722.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18 – 检查我们的URL映射](img/Figure_11.18_B18722.jpg)'
- en: Figure 11.18 – Inspecting our URL mapping
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 – 检查我们的URL映射
- en: 'With the mapping result confirmed, as seen in the preceding screenshot, we
    can visit our URL and expect to see the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 确认映射结果后，如前一个屏幕截图所示，我们可以访问我们的 URL 并期待看到以下内容：
- en: '![Figure 11.19 – Accessing our application through the registered URL](img/Figure_11.19_B18722.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.19 – 通过注册的 URL 访问我们的应用程序](img/Figure_11.19_B18722.jpg)'
- en: Figure 11.19 – Accessing our application through the registered URL
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 – 通过注册的 URL 访问我们的应用程序
- en: We can see that our URL is now working. However, the connection is not secure.
    In the next section, we will enforce an HTTPS protocol for our application and
    lock it down, as right now, even though we can access our application through
    the URL, there is nothing stopping us from accessing the IP of the server directly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的 URL 现在正在工作。然而，连接并不安全。在下一节中，我们将强制执行 HTTPS 协议以保护我们的应用程序，并对其进行锁定，因为现在，尽管我们可以通过
    URL 访问我们的应用程序，但没有任何阻止我们直接访问服务器 IP 地址的措施。
- en: Enforcing HTTPS on our application on AWS
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 应用程序上强制执行 HTTPS
- en: 'Right now, our application kind of works, but it is a nightmare in terms of
    security. By the end of this section, we will not have the most secure application,
    as further reading of a networking and DevOps textbook is suggested to achieve
    gold-standard security. However, we will have configured security groups, locked
    down our EC2 instances so that they cannot be directly accessed by outsiders,
    and enforced encrypted traffic through a load balancer that will then direct traffic
    to our EC2 instances. The result of our efforts will be the following system:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序在某种程度上是可行的，但在安全性方面却是个噩梦。在本节结束时，我们不会拥有最安全的应用程序，因为建议进一步阅读网络和 DevOps
    教科书以实现金标准的安全性。然而，我们将已配置安全组，锁定我们的 EC2 实例，使其不能被外部人员直接访问，并通过负载均衡器强制执行加密流量，然后流量将被导向我们的
    EC2 实例。我们努力的成果将是以下系统：
- en: '![Figure 11.20 – Layout of our desired system to achieve HTTPS](img/Figure_11.20_B18722.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.20 – 实现HTTPS的所需系统布局](img/Figure_11.20_B18722.jpg)'
- en: Figure 11.20 – Layout of our desired system to achieve HTTPS
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20 – 实现 HTTPS 的所需系统布局
- en: 'To achieve the system shown in *Figure 11**.20*, we need to carry out the following
    steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 *图 11.20* 中所示的系统，我们需要执行以下步骤：
- en: Get certificates approved for our URL and variations.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的 URL 和变体获取证书审批。
- en: Create multiple EC2 instances to distribute traffic and ensure that the service
    survives outages.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建多个 EC2 实例以分发流量并确保服务在故障时仍能正常运行。
- en: Create a load balancer to handle incoming traffic.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个负载均衡器来处理传入流量。
- en: Create security groups.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建安全组。
- en: Update our Python build script to support multiple EC2 instances.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的 Python 构建脚本以支持多个 EC2 实例。
- en: Attach our URL to the load balancer using the Route 53 wizard.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Route 53 向导将我们的 URL 附接到负载均衡器。
- en: In the previous section on attaching a URL to our application on AWS, we did
    a lot of pointing and clicking. As said in the previous chapter, pointing and
    clicking should be avoided if possible as it is not repeatable and we as humans
    forget what we did. Sadly, with URL approvals pointing and clicking is the best
    option. In this section, only the first and sixth steps will require pointing
    and clicking. The rest will be achieved with Terraform and Python. We are going
    to be making some big changes to our Terraform config, so it is advised that you
    run a `terraform destroy` command before altering your Terraform config. Before
    we can do any of the coding, however, we are going to have to get our certificates
    for our URL.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节关于将 URL 附接到我们 AWS 应用程序的部分，我们进行了大量的点击操作。正如前一章所述，如果可能的话，应尽量避免点击操作，因为它不可重复，而且我们人类会忘记我们做了什么。遗憾的是，在
    URL 审批过程中，点击操作是最好的选择。在本节中，只有第一步和第六步需要点击操作。其余的将通过 Terraform 和 Python 完成。我们将对 Terraform
    配置进行一些重大更改，因此建议在修改 Terraform 配置之前运行 `terraform destroy` 命令。然而，在我们进行任何编码之前，我们必须获取我们
    URL 的证书。
- en: Getting certificates for our URL
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取我们 URL 的证书
- en: 'Because we brought our URL through Route 53, which is handled by AWS, and our
    servers are running in AWS, the certification and implementation of those certificates
    is a straightforward process. We need to navigate to Certificate Manager by typing
    `certificate manager` into the services search bar and clicking on it. Once there,
    we are displayed with a page that only has one orange button labeled **Request
    a certificate**. Click on this, and we will be transported to the following page:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通过 Route 53 带入了我们的 URL，这是由 AWS 处理的，并且我们的服务器在 AWS 上运行，因此证书的颁发和实施是一个简单的过程。我们需要通过在服务搜索栏中输入`证书管理器`并点击它来导航到证书管理器。一旦到达那里，我们将看到一个只有一个小按钮的页面，该按钮标有**请求证书**。点击此按钮，我们将被带到以下页面：
- en: '![](img/Figure_11.21_B18722.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_11.21_B18722.jpg)'
- en: 'Figure 11.21 – Certificate Manager: start of journey'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.21 – 证书管理器：旅程开始
- en: 'We are going to want our certificate to be public facing; therefore, we are
    happy with the default selection, and we click **Next**. We are then presented
    with the following form:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的证书是公开的；因此，我们对默认选择感到满意，然后点击**下一步**。随后，我们将看到一个以下形式的表单：
- en: '![Figure 11.22 – Defining certificate request](img/Figure_11.22_B18722.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22 – 定义证书请求](img/Figure_11.22_B18722.jpg)'
- en: Figure 11.22 – Defining certificate request
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 – 定义证书请求
- en: 'Here, we type in the URL we want to associate with the certificate. We could
    add another, but we will do a separate certificate for our URL that has prefixes
    as we want to explore how to attach multiple certificates in Terraform. We can
    also see that DNS validation is already highlighted, and this is recommended as
    we have our servers on AWS, meaning we will have to take no more action to get
    the certificate issued. We can then click on the button labeled **Request**, and
    we will be redirected to a page with the list of certificates. I find that the
    new certificate request is not present nearly every time I have done this. My
    guess is that there is a delay. Do not worry—merely refresh the page, and you
    will see the pending certificate request listed. Click on this listing, and you
    will be directed to a detailed view of this certificate request. In the middle
    of the screen on the right, you need to click the **Create records in Route 53**
    button, as seen here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们输入我们希望与证书关联的 URL。我们可以添加另一个，但我们将为我们的 URL 创建一个单独的证书，因为我们想探索如何在 Terraform
    中附加多个证书。我们还可以看到 DNS 验证已经突出显示，这是推荐的，因为我们有服务器在 AWS 上，这意味着我们不需要采取任何更多行动来颁发证书。然后我们可以点击标有**请求**的按钮，我们将被重定向到一个包含证书列表的页面。我发现每次我这样做时，新的证书请求几乎都不在。我的猜测是存在延迟。不要担心——只需刷新页面，您将看到挂起的证书请求列在列表中。点击此条目，您将被引导到该证书请求的详细视图。在屏幕中间的右侧，您需要点击此处所示的**在
    Route 53 中创建记录**按钮：
- en: '![Figure 11.23 – Creating records for DNS confirmation](img/Figure_11.23_B18722.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.23 – 为 DNS 确认创建记录](img/Figure_11.23_B18722.jpg)'
- en: Figure 11.23 – Creating records for DNS confirmation
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23 – 为 DNS 确认创建记录
- en: 'Follow the prompts after clicking the button, and the CNAME record will be
    created. If you do not do this, then the pending status for the ticket will go
    on indefinitely because the cloud provider needs the route to issue the certificate,
    considering we selected DNS validation. After a few minutes, the certificate should
    be issued. Once this is done, carry out the same steps for the prefix wildcard.
    Once this is done, your certificate lists should look something like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，请按照提示操作，CNAME 记录将被创建。如果您不这样做，则票证的挂起状态将无限期持续，因为云服务提供商需要路由来颁发证书，考虑到我们选择了
    DNS 验证。几分钟后，证书应该会被颁发。一旦完成，为前缀通配符执行相同的步骤。一旦完成，您的证书列表应该看起来像以下这样：
- en: '![Figure 11.24 – Issued certificates](img/Figure_11.24_B18722.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.24 – 已颁发证书](img/Figure_11.24_B18722.jpg)'
- en: Figure 11.24 – Issued certificates
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24 – 已颁发证书
- en: 'In the preceding screenshot, we can see that I have two certificates: one for
    if a user directly types in the URL with no prefix, and the wildcard that covers
    all prefixes. We are ready to use these certificates, but before we do this, we
    are going to have to carry out some other steps. Before we define rules around
    the traffic, we are going to have to build the infrastructure where the traffic
    is going. In the next section, we will build two EC2 instances.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到我有两个证书：一个用于用户直接输入URL而没有前缀的情况，以及覆盖所有前缀的通配符。我们准备使用这些证书，但在这样做之前，我们必须执行一些其他步骤。在我们定义关于流量的规则之前，我们必须构建流量将流向的基础设施。在下一节中，我们将构建两个EC2实例。
- en: Creating multiple EC2 instances
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多个EC2实例
- en: 'We will be using a load balancer. Because of this, we need a minimum of two
    EC2 instances. This means that if one EC2 instance is down, we can still use the
    other EC2 instance. We can also scale our application. For instance, if everyone
    in the world suddenly realized that they needed a to-do app to sort out their
    lives, there is nothing stopping us from increasing the number of EC2 instances
    to distribute the traffic across. We can increase our EC2 instances to two by
    going into our `deployment/main.tf` file and having the following definition of
    our EC2 instances:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用负载均衡器。因此，我们需要至少两个EC2实例。这意味着如果一个EC2实例宕机，我们仍然可以使用另一个EC2实例。我们还可以扩展我们的应用程序。例如，如果世界上所有人突然意识到他们需要一个待办事项应用来整理他们的生活，我们无法阻止我们增加EC2实例的数量以分配流量。我们可以通过进入我们的`deployment/main.tf`文件并使用以下定义来增加我们的EC2实例到两个：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we can see that we have added a `count` parameter and defined it as `2`.
    We have also altered the tag. We can also see that we access the number of EC2
    instances being created with `index`. The index starts at zero and increases by
    one every time a resource is made. Now that we have two instances, we must update
    the outputs at the bottom of the `deployment/main.tf` file with the following
    code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们添加了一个`count`参数并将其定义为`2`。我们还更改了标签。我们还可以看到我们使用`index`访问正在创建的EC2实例的数量。索引从零开始，每次创建资源时增加一。现在我们有两个实例，我们必须使用以下代码更新`deployment/main.tf`文件底部的输出：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we can see that apart from the database endpoint, all the other outputs
    have been changed to lists. This is because they all reference our multiple EC2
    instances. Now that we have our EC2 instances defined, we can route traffic to
    our instances with a load balancer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，除了数据库端点外，所有其他输出都已更改为列表。这是因为它们都引用了我们的多个EC2实例。现在我们已经定义了我们的EC2实例，我们可以使用负载均衡器将流量路由到我们的实例。
- en: Creating a load balancer for our traffic
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的流量创建负载均衡器
- en: 'There is a range of different load balancers that we can pick from. We have
    already discussed NGINX, which is a popular load balancer. For this chapter, we
    are going to use the application load balancer to route the traffic to our EC2
    instances and implement the HTTPS protocol. There are multiple features that load
    balancers can offer, and they protect against `deployment/load_balancer.tf` file.
    First, we collect the data that we need with the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一系列不同的负载均衡器中进行选择。我们已经讨论了NGINX，它是一个流行的负载均衡器。对于本章，我们将使用应用程序负载均衡器来路由流量到我们的EC2实例并实现HTTPS协议。负载均衡器可以提供多种功能，并且它们可以保护`deployment/load_balancer.tf`文件。首先，我们使用以下代码收集所需的数据：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that instead of `resource`, we used the `data` declaration. This
    is where we make queries to AWS for specific types of data to be used in the rest
    of the Terraform script. We get the **virtual private cloud** (**VPC**) ID. In
    Terraform, we can define and build a VPC, but throughout this book, we have been
    using the default VPC. We can get the default VPC ID for our load balancer. We
    then get the data for the certificates that we have defined in the previous section
    with the preceding code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们使用的是`data`声明而不是`resource`，这是我们在Terraform脚本中查询AWS以获取特定类型数据的地方。我们获取了**虚拟私有云**（**VPC**）ID。在Terraform中，我们可以定义和构建一个VPC，但在这本书的整个过程中，我们一直在使用默认的VPC。我们可以获取用于我们的负载均衡器的默认VPC
    ID。然后，我们使用前面的代码获取我们在上一节中定义的证书的数据。
- en: 'We now must define a target for our load balancer. This is done in the form
    of a target group where we can bunch a group of instances together for the load
    balancer to target with the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须为我们的负载均衡器定义一个目标。这是通过以下代码形式的target group来完成的，我们可以将一组实例聚集在一起，以便负载均衡器可以针对这些实例：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we can see that we define the parameters for a health check. The parameters
    for the health check are self-explanatory. The health check will alert a service
    targeting the health status of the target group. We would not want to route traffic
    to a target group that is down. We then define the protocol and port of the traffic,
    the type of resource in the target group, and the ID of the VPC. Now that our
    target group is defined, we can attach our EC2 instances to it with the following
    code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们定义了健康检查的参数。健康检查的参数是自解释的。健康检查将向一个针对目标组健康状态的服务发出警报。我们不希望将流量路由到已关闭的目标组。然后我们定义了流量的协议和端口，目标组中的资源类型，以及VPC的ID。现在我们的目标组已经定义好了，我们可以用以下代码将其与我们的EC2实例关联起来：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see that we get the IDs of the EC2 servers for the target ID. With this,
    our EC2 instances can be targeted by the load balancer. Now that we have a target,
    we can create our load balancer with the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们获取了目标ID的EC2服务器的ID。有了这个，我们的EC2实例就可以被负载均衡器所针对。现在我们有了目标，我们可以用以下代码创建我们的负载均衡器：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see that the parameters in the load balancer definition are straightforward.
    However, you may have noticed the security group definition. We are referencing
    a security group even though we have not defined any security groups. If you do
    not know what a security group is, do not worry—we will cover and build all the
    security groups we need in the next section. Before we do that, however, we might
    as well define listening and routing rules for the load balancer. First, we can
    define the HTTP listener for port `80`. If you remember the first section of this
    chapter when getting HTTPS working on our localhost, what do you think we need
    to do for the HTTP traffic? You don’t have to know the specific Terraform code,
    but what is the general behavior that we want to facilitate? With this in mind,
    we can achieve that behavior with the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到负载均衡器定义中的参数非常直接。然而，你可能已经注意到了安全组定义。尽管我们没有定义任何安全组，但我们正在引用一个安全组。如果你不知道什么是安全组，不要担心——我们将在下一节中涵盖并构建我们需要的所有安全组。但在我们这样做之前，我们不妨先为负载均衡器定义监听和路由规则。首先，我们可以为端口`80`定义HTTP监听器。如果你还记得本章的第一节，当我们在本地主机上使HTTPS工作的时候，你认为我们需要对HTTP流量做些什么？你不需要知道具体的Terraform代码，但我们希望促进的一般行为是什么？有了这个想法，我们可以用以下代码实现这种行为：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That’s right! We receive HTTPS traffic from port `80` and we then redirect
    it to port `443` with the HTTPS protocol. We can see that we have attached this
    listener using the **Amazon Resource Name** (**ARN**) of the load balancer that
    we created. We can now define our HTTPS listener with the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 没错！我们从端口`80`接收HTTPS流量，然后将其重定向到端口`443`，使用HTTPS协议。我们可以看到我们使用我们创建的负载均衡器的ARN附加了这个监听器。我们现在可以用以下代码定义我们的HTTPS监听器：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we can see that we accept HTTPS traffic and then forward HTTP traffic
    to our target group that we defined using the ARN of the target group. We can
    also see that we have attached one of the certificates to the listener. However,
    this does not cover all our URL combinations. Remember—we have another certificate
    that we want to attach. We can attach our second certificate with the following
    code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们接受HTTPS流量，然后将HTTP流量转发到我们定义的目标组，使用目标组的ARN。我们还可以看到我们已将一个证书附加到监听器上。然而，这并不涵盖我们所有的URL组合。记住——我们还有一个想要附加的证书。我们可以用以下代码附加我们的第二个证书：
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This connection should be easy to understand. Here, we merely reference the
    ARN of the HTTPS listener and the ARN of the certificate that we want to attach.
    We have now defined everything we need for the resources of the load balancer.
    However, what of the traffic? We have defined the load balancer, EC2 instances,
    and the routing for HTTPS for the load balancer. However, what is stopping someone
    just directly connecting to the EC2 instance, bypassing the load balancer and
    HTTPS completely? This is where security groups come in. In the next section,
    we will lock down the traffic by creating security groups so that users cannot
    bypass our load balancer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个连接应该很容易理解。在这里，我们仅仅引用了HTTPS监听器的ARN和我们要附加的证书的ARN。我们现在已经为负载均衡器的资源定义了所有需要的东西。然而，关于流量呢？我们已经定义了负载均衡器、EC2实例和负载均衡器的HTTPS路由。但是，有什么阻止某人直接连接到EC2实例，完全绕过负载均衡器和HTTPS呢？这就是安全组发挥作用的地方。在下一节中，我们将通过创建安全组来锁定流量，这样用户就不能绕过我们的负载均衡器。
- en: Creating security groups to lock down and secure traffic
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建安全组以锁定和确保流量
- en: 'Security groups are essentially firewalls. We can define the traffic to and
    from a resource that has a security group implemented. The rules of the traffic
    can be fine-grained. A single security group can have multiple rules defining
    the origin (even specific IP addresses if needed) and the protocol of the traffic.
    When it comes to our security groups, we are going to need two. One will accept
    HTTP and HTTPS traffic from all IPs anywhere in the world. This is going to be
    for our load balancer because we want our application to be available to everyone.
    The other security group will be implemented by our EC2 instances; this one blocks
    all HTTP traffic apart from the first security group. We will also enable SSH
    inbound traffic because we need to SSH into the servers to deploy the applications,
    giving us the following traffic layout:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 安全组本质上等同于防火墙。我们可以定义实现了安全组的资源之间的流量。流量的规则可以非常细致。一个安全组可以定义多个规则，以定义流量的来源（甚至如果需要，可以指定特定的IP地址）和协议。当我们谈到我们的安全组时，我们将需要两个。一个将接受来自世界各地的所有IP地址的HTTP和HTTPS流量。这将用于我们的负载均衡器，因为我们希望应用程序对每个人可用。另一个安全组将由我们的EC2实例实现；这个安全组除了第一个安全组之外，将阻止所有HTTP流量。我们还将启用SSH入站流量，因为我们需要SSH到服务器以部署应用程序，从而得到以下流量布局：
- en: '![Figure 11.25 – Security groups for our deployment system](img/Figure_11.25_B18722.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图11.25 – 我们部署系统的安全组](img/Figure_11.25_B18722.jpg)'
- en: Figure 11.25 – Security groups for our deployment system
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25 – 我们部署系统的安全组
- en: 'This is where you must be careful with online tutorials. There is no shortage
    of *YouTube* videos and *Medium* articles that will get a load balancer up and
    running with some pointing and clicking. However, they leave the EC2 instances
    exposed and do not bother exploring security groups. Even with this section, we
    are going to leave the database exposed. I am doing this because it is a good
    question to be asked in the *Questions* section. However, I’m highlighting it
    here because you need to be warned that it is exposed. The way to lock down the
    database will be covered in the *Answers* section of this chapter. When it comes
    to our security groups, we can define them in the `deployment/security_groups.tf`
    file. We can start with the load balancer security group with the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你必须小心对待在线教程的地方。YouTube视频和Medium文章中不乏一些通过点击和指向就能让负载均衡器启动运行的内容。然而，它们没有暴露EC2实例，也没有去探索安全组。即使在这个部分，我们也将数据库暴露在外。我这样做是因为这是一个在*问题*部分值得提出的好问题。然而，我在这里强调它，是因为你需要被警告它已经被暴露。锁定数据库的方法将在本章的*答案*部分中介绍。当我们谈到我们的安全组时，我们将在`deployment/security_groups.tf`文件中定义它们。我们可以从以下代码开始定义负载均衡器的安全组：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we have two inbound rules under the `ingress` tag and one outbound rule
    under the `egress` tag. Our first inbound rule is to allow HTTP data from anywhere
    with the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`ingress`标签下有两个入站规则，在`egress`标签下有一个出站规则。我们的第一个入站规则是允许来自任何地方的HTTP数据，以下代码：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `cidr` blocks of all zeros means *from anywhere*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所有零的`cidr`块意味着*来自任何地方*。
- en: 'Our second inbound rule is HTTPS traffic from anywhere. How do you think this
    will be defined? It can be defined with the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个入站规则是从任何地方来的HTTPS流量。你认为这将如何定义？它可以定义为以下代码：
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now for our outbound rule. We must allow all traffic and protocols out of the
    load balancer as they are coming from our resources. This can be achieved with
    the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来定义我们的出站规则。我们必须允许所有流量和协议从负载均衡器流出，因为它们来自我们的资源。这可以通过以下代码实现：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It must be noted that `from_port` and `to_port` are zero, meaning that we allow
    outgoing traffic from all ports. We also have set `protocol` to `-1`, meaning
    we are allowing all protocols as outgoing traffic. We have now defined the security
    group for the load balancer. We can now move on to defining our security group
    for the EC2 instances with the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，`from_port`和`to_port`为零，这意味着我们允许从所有端口流出流量。我们还设置了`protocol`为`-1`，这意味着我们允许所有协议作为流出流量。我们现在已经定义了负载均衡器的安全组。现在我们可以继续定义我们的EC2实例的安全组，以下代码：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The outbound rules are going to be the same as the load balancer because we
    want to return data to anywhere that is available to request it. When it comes
    to our HTTP inbound rules, we only want to accept traffic from the load balancer
    with the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 出站规则将与负载均衡器相同，因为我们希望将数据返回到任何可以请求它的位置。当我们谈到我们的 HTTP 入站规则时，我们只想接受来自以下代码的负载均衡器的流量：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we can see that instead of defining the `cidr` blocks, we rely on the
    security group of the load balancer. Now that all the user traffic is defined,
    we only need to define the SSH traffic for deployment with the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们不是定义 `cidr` 块，而是依赖于负载均衡器的安全组。现在所有用户流量都已定义，我们只需定义以下代码的 SSH 流量以进行部署：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we access SSH through port `22`. This will enable us to SSH into our
    servers and deploy our applications. Nearly everything is done. We only must attach
    our EC2 instances to our EC2 security group, which can be done with the following
    code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过端口 `22` 访问 SSH。这将使我们能够 SSH 进入我们的服务器并部署我们的应用程序。几乎所有的事情都完成了。我们只需将我们的 EC2
    实例附加到我们的 EC2 安全组，这可以通过以下代码完成：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our Terraform scripts are now complete and will be able to spin up multiple
    EC2 instances, a database, and a load balancer while locking down traffic. This
    is a good template for other projects if you want to get a basic web app with
    HTTPS and access to a database off the ground with restricted traffic.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地毯脚本现在已完成，并且能够启动多个 EC2 实例、数据库和负载均衡器，同时锁定流量。如果您想以受限流量启动一个基本的带有 HTTPS 和数据库访问的
    Web 应用程序，这是一个很好的模板。
- en: Now that we have two different EC2 instances, we are going to have to change
    our deployment scripts so that both have applications installed in the next section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个不同的 EC2 实例，我们将在下一节中更改我们的部署脚本，以便两个实例都安装了应用程序。
- en: Updating our Python deployment script for multiple EC2 instances
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的 Python 部署脚本以支持多个 EC2 实例
- en: 'There are ways in which we can optimize the deployment process, such as running
    multiple processes at the same time. This will speed up your deployment the more
    EC2 instances that we have. However, we must remember that this is a book on Rust
    and web programming, with some deployment chapters included so that you can use
    what you create. We could write an entire book on optimizing and improving our
    deployment pipeline. When it comes to supporting multiple EC2 instances in our
    `deployment/run_build.py` file, at the end of the file, we merely loop through
    the list of global IPs from the output with the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过同时运行多个进程等方式优化部署过程。这将随着我们拥有的 EC2 实例数量的增加而加快我们的部署。然而，我们必须记住，这是一本关于 Rust
    和网络编程的书，其中包含了一些部署章节，以便您可以使用您所创建的内容。我们本可以写一本关于优化和改进我们的部署管道的整本书。当我们谈到在 `deployment/run_build.py`
    文件中支持多个 EC2 实例时，在文件的末尾，我们只需通过以下代码遍历全局 IP 地址列表：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is it. Multiple servers are now supported. Here, we can see the effectiveness
    of separating the logic behind managing the data around the deployment in the
    Python file and the individual Bash script for deploying the applications on the
    individual server. Keeping things isolated keeps technical debt down, enabling
    easy refactoring. Now, all our code infrastructure is done! We can run this Python
    script and deploy our build onto AWS. Everything is nearly done; all we must do
    is connect our URL to our load balancer in the next section.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在支持了多个服务器。在这里，我们可以看到在 Python 文件中管理部署数据背后的逻辑与在单个服务器上部署应用程序的单独 Bash 脚本之间分离的有效性。保持事物隔离可以降低技术债务，使重构变得容易。现在，我们的代码基础设施已经完成！我们可以运行这个
    Python 脚本并将我们的构建部署到 AWS。几乎所有的事情都完成了；我们接下来必须做的只是将我们的 URL 连接到负载均衡器。
- en: Attaching our URL to the load balancer
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的 URL 附加到负载均衡器
- en: 'This is the home run. We are finally near the end. I appreciate you sticking
    with me on this chapter as it is not as exciting as coding in Rust. However, it
    is important if you want to use your Rust server. To connect our URL to the load
    balancer, we must navigate to the hosted zone for your URL. Once there, click
    on the **Create record** button. When in the **Create record** display, if you
    are not using the wizard, click on the **Switch to wizard** link at the top right
    of the **Create record** display to get the following wizard view:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本垒打。我们终于接近了尾声。感谢你一直陪伴我完成这一章，因为它并不像 Rust 编程那样令人兴奋。然而，如果你想要使用你的 Rust 服务器，它是非常重要的。为了将我们的
    URL 连接到负载均衡器，我们必须导航到你的 URL 的托管区域。一旦到达那里，点击 **创建记录** 按钮。在 **创建记录** 显示中，如果你没有使用向导，请点击
    **创建记录** 显示右上角的 **切换到向导** 链接以获取以下向导视图：
- en: '![Figure 11.26 – Create record wizard view](img/Figure_11.26_B18722.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.26 – 创建记录向导视图](img/Figure_11.26_B18722.jpg)'
- en: Figure 11.26 – Create record wizard view
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.26 – 创建记录向导视图
- en: 'Here, we can see a range of fancy ways to route traffic. However, we are going
    to merely select **Simple routing** as we just need to pass traffic to the load
    balancer, which is doing the distribution of traffic between EC2 instances. Selecting
    **Simple routing** gives us the following form to fill in:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一系列用于路由流量的花哨方式。然而，我们只是选择 **简单路由**，因为我们只需要将流量传递给负载均衡器，它负责在 EC2 实例之间分配流量。选择
    **简单路由** 会给我们以下表单来填写：
- en: '![Figure 11.27 – Define simple record wizard view](img/Figure_11.27_B18722.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.27 – 定义简单记录向导视图](img/Figure_11.27_B18722.jpg)'
- en: Figure 11.27 – Define simple record wizard view
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.27 – 定义简单记录向导视图
- en: 'Here, we can see that I have selected `ToDoApplicationLb` load balancer to
    select. When you click the **Define simple record** button, you are then navigated
    to a list of records that are to be created. We carry out the creation wizard
    process one more time to account for all prefixes with the wildcard, and then
    confirm our creation of records. With this, our HTTPS now works with our application,
    as seen here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我已经选择了 `ToDoApplicationLb` 负载均衡器进行选择。当你点击 **定义简单记录** 按钮，你将被导航到一个要创建的记录列表。我们再次执行创建向导过程，以考虑所有带有通配符的前缀，然后确认我们创建的记录。有了这个，我们的
    HTTPS 现在可以与我们的应用程序一起工作，如下所示：
- en: '![Figure 11.28 – HTTPS working with our application on the internet](img/Figure_11.28_B18722.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.28 – HTTPS 与互联网上的我们的应用程序一起工作](img/Figure_11.28_B18722.jpg)'
- en: Figure 11.28 – HTTPS working with our application on the internet
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.28 – HTTPS 与互联网上的我们的应用程序一起工作
- en: With this, our chapter is complete. If you try to access one of our EC2 instances
    directly through an IP address, you will be blocked. Therefore, we cannot directly
    access our EC2 instances but can access them through HTTPS through our URL. If
    you give users any variation of your URL, even an HTTP link to the URL, your users
    will happily use your application with the HTTPS protocol.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的章节就完成了。如果你尝试直接通过 IP 地址访问我们的任何一个 EC2 实例，你将被阻止。因此，我们无法直接访问我们的 EC2 实例，但可以通过
    HTTPS 通过我们的 URL 访问它们。如果你向用户提供任何你 URL 的变体，即使是到 URL 的 HTTP 链接，你的用户也会高兴地使用你的应用程序，并使用
    HTTPS 协议。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: For now, we have done all we need to do to deploy a robust and secure application
    on AWS with locked-down traffic and HTTPS enforced. We have covered a lot to get
    here, and the skillset that you have gained in this chapter can be applied to
    pretty much any other project you want to deploy on AWS if you can package it
    in Docker. You now understand the advantages of HTTPS and the steps needed to
    not only achieve the HTTPS protocol but also to map your URL to the IP address
    of a server or a load balancer. What is more, we automated the attachment of certificates
    that we created using Certificate Manager to our load balancer in Terraform using
    the powerful data query resource that Terraform has to offer. Finally, this all
    came together when we managed to access our application using HTTPS and only HTTPS.
    Not only have we developed some practical skills that will become useful in many
    future projects, but we have also explored the nature of how HTTPS and DNS work,
    giving us a deeper understanding and appreciation of how the internet generally
    works when we type in a URL to the browser.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，我们已经完成了部署在AWS上具有锁定流量和强制HTTPS的健壮且安全的应用程序所需的所有工作。我们覆盖了大量的内容才达到这里，你在本章中获得的技术技能可以应用于你想要在AWS上部署的几乎所有其他项目，只要你能够将其打包到Docker中。你现在理解了HTTPS的优势以及实现HTTPS协议所需的步骤，不仅能够实现HTTPS协议，还能将你的URL映射到服务器或负载均衡器的IP地址。更重要的是，我们使用Terraform提供的强大数据查询资源，自动化了使用证书管理器创建的证书附加到我们的负载均衡器。最后，当我们能够使用HTTPS和仅HTTPS访问我们的应用程序时，这一切都汇聚在一起。这不仅使我们获得了一些将在许多未来的项目中变得有用的实用技能，而且还探索了HTTPS和DNS的工作原理，这使我们更深入地理解和欣赏了当我们输入URL到浏览器时互联网通常是如何工作的。
- en: In the next chapter, we will explore the Rocket framework. Due to how we have
    built our Rust modules in our Actix web application, we will be able to lift modules
    directly from the Actix web application and slot them into the Rocket application.
    Considering what we have done in this chapter, we will also be able to wrap our
    Rocket application in Docker and slot it into the build pipeline here by merely
    changing one line of code in the deployment `docker-compose` file. In the next
    chapter, you will see firsthand that when everything is well structured and isolated,
    changing features and frameworks is not going to be a headache and is, in fact,
    fairly joyful.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Rocket框架。由于我们在Actix web应用程序中构建Rust模块的方式，我们能够直接从Actix web应用程序中提取模块，并将它们插入到Rocket应用程序中。考虑到我们在本章中所做的工作，我们还将能够通过仅更改部署`docker-compose`文件中的一行代码，将我们的Rocket应用程序包装在Docker中，并将其插入到这里的构建管道中。在下一章中，您将亲身体验到，当一切结构良好且隔离时，更改功能和框架不会成为头痛的问题，实际上，这会相当愉快。
- en: Further reading
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Application load balancers documentation: [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/load-balancer-types.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/load-balancer-types.html)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序负载均衡器文档：[https://docs.aws.amazon.com/AmazonECS/latest/developerguide/load-balancer-types.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/load-balancer-types.html)
- en: 'Security group documentation: [https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全组文档：[https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html)
- en: Questions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Once we remember that our system still has the database exposed to the rest
    of the world, how would we lock it down?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们记住我们的系统数据库仍然暴露给全世界，我们该如何将其锁定？
- en: Why should we use an elastic IP in some cases?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在某些情况下我们应该使用弹性IP？
- en: How could we automate the association of an existing elastic IP to an EC2 instance?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何自动化将现有的弹性IP关联到EC2实例上？
- en: How do we utilize security groups to lock down traffic between a URL and EC2
    instances?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何利用安全组来锁定URL和EC2实例之间的流量？
- en: Let’s say that the traffic for our application greatly increased and our two
    instances cannot handle the pressure. What could we do to enable our system to
    handle the increase?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们应用的流量大幅增加，我们的两个实例无法处理压力。我们该如何使我们的系统能够处理这种增加？
- en: What is the basic premise of a DNS record?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DNS记录的基本前提是什么？
- en: What is a URL hosted zone?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是URL托管区域？
- en: Answers
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We would create a security group for the database that only accepts traffic
    to and from the EC2 instance security group. If we were having to make a migration,
    we can SSH into an EC2 instance and use it as a proxy to connect to a database.
    You can also do this with database viewing software such as DataGrip. Sometimes
    you can have an EC2 instance that is just there for a user to use as a proxy to
    access the database. This is known as a bastion server.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个只接受从EC2实例安全组到和从的数据库安全组。如果我们需要进行迁移，我们可以SSH到EC2实例并使用它作为代理连接到数据库。您也可以使用DataGrip等数据库查看软件这样做。有时您可能有一个仅用于用户将其用作代理以访问数据库的EC2实例。这被称为堡垒服务器。
- en: When we destroy and create EC2 instances, the IP address of the EC2 instance
    will change. We can use an elastic IP to ensure that the IP address remains consistent,
    which can be helpful for automation pipelines as we can continue to point to that
    IP address. However, if we are using a load balancer, we do not need to use an
    elastic IP address as we will point our URL to the load balancer.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们销毁和创建EC2实例时，EC2实例的IP地址将改变。我们可以使用弹性IP来确保IP地址保持一致，这对于自动化管道可能很有帮助，因为我们可以继续指向该IP地址。然而，如果我们使用负载均衡器，我们不需要使用弹性IP地址，因为我们将我们的URL指向负载均衡器。
- en: We can automate the association of an elastic IP to an EC2 instance using Terraform
    and its powerful data resource. This means we get the data of the existing elastic
    IP with a data query, and then attach this IP to an EC2 instance that we are creating.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用Terraform及其强大的数据资源来自动将弹性IP关联到EC2实例。这意味着我们可以通过数据查询获取现有弹性IP的数据，然后将此IP关联到我们正在创建的EC2实例。
- en: Ensure that the security group for the EC2 instances in the target group that
    the load balancer is attached to can only accept HTTP traffic from the load balancer.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保负载均衡器附加的目标组中的EC2实例的安全组只能接受来自负载均衡器的HTTP流量。
- en: Considering that everything in our system is automated and piped into each other,
    all we must do is increase the count in our EC2 instance definition from 2 to
    3\. This will increase the number of EC2 instances handling the traffic from 2
    to 3.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到我们系统中的所有内容都是自动化的，并且相互连接，我们只需将我们的EC2实例定义中的计数从2增加到3即可。这将把处理流量的EC2实例数量从2增加到3。
- en: A DNS record is essentially a routing rule that will tell us how to route traffic
    from the URL to a server IP, URL namespace, or AWS service.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DNS记录本质上是一个路由规则，它将告诉我们如何将流量从URL路由到服务器IP、URL命名空间或AWS服务。
- en: A URL hosted zone is a collection of DNS records for a URL.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个URL托管区域是一组URL的DNS记录。
- en: Part 5:Making Our Projects Flexible
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5部分：使我们的项目更灵活
- en: We now have a fully working application deployed on AWS with HTTPS and a database.
    However, there are a lot of moving parts to get there. In this part, we transfer
    the application that we have built over the book into a Rocket application to
    see how structuring our code well will give us flexibility when choosing a web
    framework. We then cover practices on how to keep our web application repository
    clean and flexible with build/deployment pipelines and automated migration Docker
    containers that fire once to apply database migrations and then die. We also cover
    multi-stage builds and how to build distroless server Docker images that are roughly
    50 MB.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在AWS上部署了一个完全工作的应用程序，具有HTTPS和数据库。然而，要到达那里有很多移动部件。在本部分中，我们将我们将书籍中构建的应用程序转移到Rocket应用程序中，以了解良好的代码结构如何在我们选择Web框架时提供灵活性。然后，我们将介绍如何通过构建/部署管道和自动迁移Docker容器（这些容器一次性应用数据库迁移然后死亡）来保持我们的Web应用程序存储库干净和灵活的实践。我们还介绍了多阶段构建以及如何构建大约50MB的distroless服务器Docker镜像。
- en: 'This part includes the following chapters:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 12*](B18722_12.xhtml#_idTextAnchor246), *Recreating Our Application
    in Rocket*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18722_12.xhtml#_idTextAnchor246)，*在Rocket中重新创建我们的应用程序*'
- en: '[*Chapter 13*](B18722_13.xhtml#_idTextAnchor264), *Best Practices for a Clean
    Web App Repository*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18722_13.xhtml#_idTextAnchor264)，*干净Web应用程序存储库的最佳实践*'
