- en: Creating a Linux Kernel Module
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Linux 内核模块
- en: Any decent operating system can be extended by loadable modules. This is required
    to support hardware that is not specifically supported by the organization that
    created the operating system, and so these loadable modules are often named **device
    drivers**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何合理的操作系统都可以通过可加载模块进行扩展。这是为了支持操作系统创建组织未特别支持的硬件，因此这些可加载模块通常被称为**设备驱动程序**。
- en: However, this extensibility of operating systems can also be exploited for other
    purposes. For example, a specific filesystem or network protocol can be supported
    by the kernel itself through loadable modules without changing and recompiling
    the actual kernel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，操作系统的这种可扩展性也可以被用于其他目的。例如，可以通过可加载模块在内核本身中支持特定的文件系统或网络协议，而无需更改和重新编译实际的内核。
- en: In this chapter, we will look at how to build a kernel-loadable module, specifically
    for the Linux operating system and the x86_64 CPU architecture. The concepts and
    commands that are described here are also applicable to other CPU architectures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何构建内核可加载模块，特别是针对 Linux 操作系统和 x86_64 CPU 架构。这里描述的概念和命令也适用于其他 CPU 架构。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Preparing the environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备环境
- en: Creating a boilerplate module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板模块
- en: Using the global variable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局变量
- en: Allocating memory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配内存
- en: Creating a driver for a character device
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为字符设备创建驱动程序
- en: By the end of this chapter, you will have learned some general concepts regarding
    operating system-extension modules and, in particular, how to create, manage,
    and debug Linux kernel modules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学习一些关于操作系统扩展模块的一般概念，特别是如何创建、管理和调试 Linux 内核模块。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To understand this chapter, some concepts of the Linux operating system should
    be known. In particular, you need to know the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解本章内容，应了解一些 Linux 操作系统的概念。特别是，你需要了解以下内容：
- en: How to use the Linux command interpreter (that is, the **shell**)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Linux 命令解释器（即，**shell**）
- en: How to understand C language source code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何理解 C 语言源代码
- en: How to use the GCC compiler or the Clang compiler
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 GCC 编译器或 Clang 编译器
- en: 'If you don''t have this knowledge, you can refer to the following web resources:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这方面的知识，可以参考以下网络资源：
- en: There are many tutorials that teach you how to use the Linux command interpreter.
    One that is suitable for beginners of the Ubuntu Linux distribution can be found
    at [https://ubuntu.com/tutorials/command-line-for-beginners#1-overview](https://ubuntu.com/tutorials/command-line-for-beginners#1-overview).
    A more advanced and complete free book can be found at [https://wiki.lib.sun.ac.za/images/c/ca/TLCL-13.07.pdf](https://wiki.lib.sun.ac.za/images/c/ca/TLCL-13.07.pdf).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多教程教你如何使用 Linux 命令解释器。其中一个适合 Ubuntu Linux 分发初学者的教程可以在[https://ubuntu.com/tutorials/command-line-for-beginners#1-overview](https://ubuntu.com/tutorials/command-line-for-beginners#1-overview)找到。一个更高级和完整的免费书籍可以在[https://wiki.lib.sun.ac.za/images/c/ca/TLCL-13.07.pdf](https://wiki.lib.sun.ac.za/images/c/ca/TLCL-13.07.pdf)找到。
- en: There are many tutorials that teach you about the C programming language. One
    of them is [https://www.tutorialspoint.com/cprogramming/index.htm](https://www.tutorialspoint.com/cprogramming/index.htm).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多教程教你关于 C 编程语言。其中之一是[https://www.tutorialspoint.com/cprogramming/index.htm](https://www.tutorialspoint.com/cprogramming/index.htm)。
- en: A reference for the Clang compiler can be found at [https://clang.llvm.org/docs/ClangCommandLineReference.html](https://clang.llvm.org/docs/ClangCommandLineReference.html).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 编译器的参考可以在[https://clang.llvm.org/docs/ClangCommandLineReference.html](https://clang.llvm.org/docs/ClangCommandLineReference.html)找到。
- en: The code examples in this chapter have only been developed and tested on a specific
    version of Linux—a Linux Mint distribution with the 4.15.0-72-generic kernel version—and
    so they are only guaranteed to work with this version. The Mint distribution is
    derived from the Debian distribution and so it shares most of Debian's commands.
    The desktop environment is irrelevant.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例仅在特定的 Linux 版本上开发和测试过——一个使用 4.15.0-72-generic 内核版本的 Linux Mint 分发——因此它们仅保证与这个版本兼容。Mint
    分发源自 Debian 分发，因此它共享了 Debian 大多数命令。桌面环境无关紧要。
- en: To run the examples in this chapter, you should have access as a superuser (root)
    to a system running the preceding distribution based on a CPU with the x86_64
    architecture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的示例，你应该有超级用户（root）权限访问基于 x86_64 架构的先前分布的系统。
- en: To build a kernel module, a lot of boilerplate code needs to be written. This
    work has already been done for you in an open source project available on GitHub
    at [https://github.com/lizhuohua/linux-kernel-module-rust](https://github.com/lizhuohua/linux-kernel-module-rust). Parts
    of this GitHub project have been copied into a framework to write Linux kernel
    modules, which will be used in this chapter. This can be found in the `linux-fw` folder
    of the repository associated with this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个内核模块，需要编写大量的模板代码。这项工作已经在GitHub上的开源项目中为你完成了，GitHub地址为[https://github.com/lizhuohua/linux-kernel-module-rust](https://github.com/lizhuohua/linux-kernel-module-rust)。该GitHub项目的一部分已经被复制到一个框架中，用于编写Linux内核模块，这些模块将在本章中使用。这可以在与本章相关的存储库的`linux-fw`文件夹中找到。
- en: Also, for simplicity, no cross-compilation will be done—that is, the kernel
    module will be built in the same operating system in which it will be used. This
    is a bit unusual as often, loadable modules are developed for operating systems
    or architectures that are not suitable for software development; in some cases,
    the target system is too constrained to run a convenient development environment,
    such as a micro-controller.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了简化，不会进行交叉编译——也就是说，内核模块将在它将被使用的相同操作系统中构建。这有点不寻常，因为通常，可加载模块是为不适合软件开发的操作系统的或架构开发的；在某些情况下，目标系统过于受限，无法运行方便的开发环境，例如微控制器。
- en: In other cases, the opposite applies—the target system is too costly to be used
    by a single developer, such as a supercomputer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，情况正好相反——目标系统对于单个开发者来说成本过高，例如超级计算机。
- en: The complete source code for this chapter can be found in the `Chapter10` folder of
    the repository at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在存储库[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)的`Chapter10`文件夹中找到。
- en: Project overview
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'In this chapter, we''ll look at four projects that will show you how to build
    increasingly complex Linux kernel modules:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨四个项目，展示如何构建越来越复杂的Linux内核模块：
- en: '`boilerplate`: An extremely simple kernel module that shows the minimal requirements
    to build your own module'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boilerplate`: 一个非常简单的内核模块，展示了构建你自己的模块所需的最小要求'
- en: '`state`: A module that keeps some global static variables—that is, a **static**
    state'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`: 一个保持一些全局静态变量的模块——即一个**静态**状态'
- en: '`allocating`: A module that allocates heap memory—that is, a **dynamic** state'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allocating`: 一个分配堆内存的模块——即一个**动态**状态'
- en: '`dots`: A module that implements a read-only character device that can be associated
    with a filesystem pathname, and then it can be read as a file'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dots`: 一个实现只读字符设备的模块，它可以与文件系统路径名关联，然后可以像文件一样读取'
- en: Understanding kernel modules
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内核模块
- en: Kernel modules must satisfy certain requirements imposed by the operating system,
    and so it is quite unreasonable to try to write a kernel module in an application-oriented
    programming language, such as Java or JavaScript. Usually, kernel modules are only written
    in assembly language or in C, and sometimes in C++. However, Rust is designed
    to be a system programming language, and so it is actually possible to write kernel-loadable modules
    in Rust.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块必须满足操作系统强加的某些要求，因此尝试用面向应用的编程语言（如Java或JavaScript）编写内核模块是非常不合理的。通常，内核模块只使用汇编语言或C编写，有时也使用C++。然而，Rust被设计成一种系统编程语言，因此实际上可以使用Rust编写可加载的内核模块。
- en: While Rust is usually a portable programming language—the same source code can
    be recompiled for different CPU architectures and for different operating systems—this
    is not the case for kernel modules. A specific kernel module must be designed
    and implemented for a specific operating system. In addition, a specific machine
    architecture must usually be targeted, although the core logic can be architecture-independent.
    So, the examples in this chapter will only target the Linux operating system and
    the x86_64 CPU architecture.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Rust 通常是一种可移植的编程语言——相同的源代码可以重新编译为不同的CPU架构和不同的操作系统——但对于内核模块来说并非如此。特定的内核模块必须为特定的操作系统设计和实现。此外，通常还需要针对特定的机器架构进行目标定位，尽管核心逻辑可以是架构无关的。因此，本章中的示例将仅针对
    Linux 操作系统和 x86_64 CPU 架构。
- en: Preparing the environment
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备环境
- en: 'Some of the installation work must be performed with superuser privileges.
    So, you should prefix the `sudo` command before any command that installs a system-wide
    package or that changes something in the kernel. Alternatively, you should routinely work
    as a superuser. Needless to say, this is dangerous as you can jeopardize the whole
    system with a wrong command. To work as a superuser, type the following command
    into a terminal:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些安装工作必须以超级用户权限执行。因此，您应该在安装系统范围包或更改内核中的任何命令之前，在命令前加上`sudo`。或者，您应该定期以超级用户身份工作。不用说，这是危险的，因为一个错误的命令可能会危及整个系统。要作为超级用户工作，请在终端中输入以下命令：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, type in your superuser password.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入您的超级用户密码。
- en: The Linux operating system expects its modules to only be written in C. If you
    want to write a kernel module in Rust, a glue software must be used to interface
    your Rust code to the C language of Linux.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Linux操作系统期望其模块只使用C语言编写。如果您想用Rust编写内核模块，必须使用粘合软件将您的Rust代码与Linux的C语言接口。
- en: So, a C compiler must be used to build this glue software. Here the `clang`
    compiler will be used. This is part of the **Low-Level Virtual Machine** **(****LLVM**)
    project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，必须使用C编译器来构建这个粘合软件。这里将使用`clang`编译器。这是**低级虚拟机**（**LLVM**）项目的一部分。
- en: The Rust compiler also uses libraries of the LLVM project to generate machine
    code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Rust编译器还使用LLVM项目的库来生成机器代码。
- en: 'You can install the `clang` compiler in your Linux system by typing the following
    commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入以下命令在您的Linux系统中安装`clang`编译器：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the `apt` command is typical of Debian-derived distributions and
    is not available on many Linux distributions, nor on other operating systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`apt`命令是Debian派生的发行版的典型命令，在许多Linux发行版和其他操作系统中不可用。
- en: 'Then, you need to ensure that the C language headers of your current operating
    system are installed. You can discover what the version of your current operating
    system is by typing the `uname -r` command. This will print something similar
    to `4.15.0-72-generic`. You can install the headers for the specific version of
    the kernel by using a command similar to the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要确保您的当前操作系统的C语言头文件已安装。您可以通过输入`uname -r`命令来发现您当前操作系统的版本。这将打印出类似`4.15.0-72-generic`的内容。您可以通过使用类似以下命令来安装特定版本的内核的头文件：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can combine the two commands by typing the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入以下命令来组合这两个命令：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will generate the correct command for your system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您的系统生成正确的命令。
- en: 'At the time of writing, Linux kernel modules can only be created using the
    `nightly` version of the Rust compiler. To install the latest version of this
    compiler, type the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Linux内核模块只能使用Rust编译器的`nightly`版本创建。要安装此编译器的最新版本，请输入以下命令：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, the source code of the Rust compiler and the tool to format Rust source
    code are needed. You can ensure they are installed by typing the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要Rust编译器的源代码和格式化Rust源代码的工具。您可以通过输入以下命令来确保它们已安装：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To ensure that the `nightly` toolchain of Rust for the x86_64 architecture
    and Linux will be used by default, run this command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保默认使用Rust的x86_64架构和Linux的`nightly`工具链，运行以下命令：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This can be shortened to `rustup default nightly` if there are no other target
    platforms installed on your system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统上没有安装其他目标平台，这可以缩短为`rustup default nightly`。
- en: 'We know that the `cargo` utility has several subcommands, such as `new`, `build`,
    and `run`. For this project, an additional `cargo` subcommand will be needed—the
    `xbuild` subcommand. This name stands for **cross-build**, which means to compile
    for another platform. Actually, it is used to generate machine code for a platform
    different from the one running the compiler. In this case, it means that while
    the compiler we are running is a standard executable that is running in user space,
    the code we are generating will run in kernel space, and so it will need a different
    standard library. You can install that subcommand by typing this line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`cargo`实用程序有几个子命令，例如`new`、`build`和`run`。对于这个项目，还需要一个额外的`cargo`子命令——`xbuild`子命令。这个名字代表**交叉构建**，意味着为另一个平台编译。实际上，它用于为不同于编译器运行的平台生成机器代码。在这种情况下，这意味着虽然我们正在运行的编译器是一个在用户空间运行的标准可执行文件，但我们正在生成的代码将在内核空间运行，因此它需要一个不同的标准库。您可以通过输入以下行来安装该子命令：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, after you have downloaded the source code associated with this chapter from
    GitHub, you are ready to run the examples.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你从GitHub下载了与本章相关的源代码之后，你就可以运行示例了。
- en: Notice that in the downloaded source code, there is a folder for every project,
    plus a folder named `linux-fw`. This contains the framework to develop Linux kernel
    modules, and the examples assume that it is located in this position.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在下载的源代码中，每个项目都有一个文件夹，还有一个名为`linux-fw`的文件夹。这个文件夹包含开发Linux内核模块的框架，示例假设它位于这个位置。
- en: A boilerplate module
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个模板模块
- en: The first project is the minimal, loadable kernel module, and so it is called
    **boilerplate**. It will just print a message when the module is loaded and another
    message when it is unloaded.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目是最小、可加载的内核模块，因此被称为**模板**。当模块加载时，它将打印一条消息，当模块卸载时，它将打印另一条消息。
- en: 'In the `boilerplate` folder, there are the following source files:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`boilerplate`文件夹中，有以下源文件：
- en: '`Cargo.toml`: The build directives for the Rust project'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cargo.toml`: Rust项目的构建指令'
- en: '`src/lib.rs`: The Rust source code'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/lib.rs`: Rust源代码'
- en: '`Makefile`: The build directives to generate and compile the C language glue
    code and to link the generated object code into a kernel module'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile`: 生成和编译C语言粘合代码以及将生成的目标代码链接到内核模块的构建指令'
- en: '`bd`: A shell script to build a debug configuration of the kernel module'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bd`: 一个用于构建内核模块调试配置的shell脚本'
- en: '`br`: A shell script to build a released configuration of the kernel module'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`br`: 一个用于构建内核模块发布配置的shell脚本'
- en: Let's start with building the kernel module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建内核模块开始。
- en: Building and running the kernel module
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行内核模块
- en: 'To build the kernel module for debugging purposes, open the `boilerplate` folder
    and type in this command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要为调试目的构建内核模块，打开`boilerplate`文件夹并输入以下命令：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, this file must have executable permissions. However, it should already
    have them when it is installed from the GitHub repository.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个文件必须具有可执行权限。然而，当它从GitHub仓库安装时，它应该已经具有这些权限。
- en: The first time you run this script, it will build the framework itself, and
    so it will take quite a while. After that, it will build the `boilerplate` project
    in a couple of minutes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此脚本时，它将构建框架本身，因此需要相当长的时间。之后，它将在几分钟内构建`boilerplate`项目。
- en: After the completion of the `build` command, several files should appear in
    the current folder. Among them is one named `boilerplate.ko`, where `ko` (short
    for **kernel object**) is the kernel module we want to install. Its size is huge
    because it contains a lot of debugging information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build`命令完成后，当前文件夹中应该会出现几个文件。其中一个是名为`boilerplate.ko`的文件，其中`ko`（代表**内核对象**）是我们想要安装的内核模块。它的大小非常大，因为它包含大量的调试信息。
- en: 'A Linux command that gives information about a Linux module file is `modinfo`.
    You can use it by typing the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个提供Linux模块文件信息的Linux命令是`modinfo`。你可以通过输入以下命令来使用它：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This should print some information about the specified file. To load the module
    into the kernel, type the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会打印出有关指定文件的一些信息。要将模块加载到内核中，请输入以下命令：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `insmod` (insert module) command loads a Linux module from the specified
    file and adds it to the running kernel. Of course, this is a privileged operation
    that can jeopardize the safety and security of the whole computer system, and
    so only a superuser can run it. This explains the need to use the `sudo` command.
    If the command is successful; nothing is printed to the terminal.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`insmod`（插入模块）命令从指定的文件加载Linux模块并将其添加到正在运行的内核中。当然，这是一个特权操作，可能会危及整个计算机系统的安全性和安全性，因此只有超级用户才能运行它。这就解释了为什么需要使用`sudo`命令。如果命令成功；终端上不会打印任何内容。'
- en: 'The `lsmod` (list module) command prints a list of all the currently loaded
    modules. To select the one you are interested in, you can filter the output using
    the `grep` utility. So, you can type the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsmod`（列出模块）命令打印出所有当前已加载的模块的列表。要选择你感兴趣的模块，你可以使用`grep`实用程序过滤输出。因此，你可以输入以下命令：'
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If `boilerplate` is loaded, you will get a line similar to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`boilerplate`已加载，你将得到类似以下的一行：
- en: '![](img/d6593d77-acd5-453f-ac0c-05c578940982.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6593d77-acd5-453f-ac0c-05c578940982.png)'
- en: This line contains the name of the module, the memory used by it in bytes, and
    the number of current uses of these modules.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这行包含模块的名称、它使用的内存字节数以及这些模块的当前使用次数。
- en: 'To unload the loaded module, you can type the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载已加载的模块，你可以输入以下命令：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `rmmod` (remove module) command unloads the specified module from the running
    Linux kernel. If the module is not currently loaded, this command prints an error
    message and does nothing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmmod`（移除模块）命令从正在运行的Linux内核中卸载指定的模块。如果模块当前未加载，则此命令将打印错误消息并执行无操作。'
- en: 'Now, let''s look at the behavior of this module. Linux has a memory-only log
    area called the **kernel buffer**. Kernel modules can append lines of text to
    this buffer. When the `boilerplate` module is loaded, it appends the `boilerplate:
    Loaded` text to the kernel buffer. When the `boilerplate` module is unloaded,
    it appends the `boilerplate: Unloaded` text. Only the kernel and its modules can
    write to it, but everyone can read it using the `dmesg` (short for **display messages**)
    utility.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们看看这个模块的行为。Linux有一个仅内存的日志区域，称为**内核缓冲区**。内核模块可以向该缓冲区追加文本行。当`boilerplate`模块被加载时，它将`boilerplate:
    Loaded`文本追加到内核缓冲区。当`boilerplate`模块被卸载时，它将`boilerplate: Unloaded`文本追加。只有内核及其模块可以写入它，但每个人都可以使用`dmesg`（即**显示消息**）实用程序来读取它。'
- en: 'If you type `dmesg` into the terminal, the whole content of the kernel buffer
    will be printed to the terminal. Typically, there are thousands of messages in
    the kernel buffer, written by several modules since the last reboot of the system,
    but the last two lines should be those appended by the `boilerplate` module. To
    view just the last 10 lines while keeping their colors, type the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`dmesg`输入到终端中，内核缓冲区的全部内容将被打印到终端。通常，内核缓冲区中有数千条消息，自系统上次重启以来由几个模块写入，但最后两行应该是`boilerplate`模块附加的。要查看仅最后10行并保持其颜色，请输入以下命令：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last two lines should look something like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行看起来应该如下所示：
- en: '![](img/98cc4ca1-f1c6-4db5-9ff7-0c97923ff550.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98cc4ca1-f1c6-4db5-9ff7-0c97923ff550.png)'
- en: The first part of any line, enclosed in brackets, is a **timestamp **written
    by the kernel. This is the time in seconds and microseconds since the start of
    the kernel. The rest of the line is written by the module code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一行的第一部分，括号内的内容，是内核写入的时间戳。这是自内核开始以来的秒和微秒数。该行的其余部分由模块代码写入。
- en: Now, we can see how the `bd` script built this kernel module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到`bd`脚本是如何构建这个内核模块的。
- en: The build commands
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建命令
- en: 'The `bd` script has the following content:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`bd`脚本的内容如下：'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s see what happened in the code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码中发生了什么：
- en: The first line declares that this is a shell script, and so the Bourne shell
    program will be used to run it.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行声明这是一个shell脚本，因此将使用Bourne shell程序来运行它。
- en: The second line saves the path of the current folder in a temporary variable.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行将当前文件夹的路径保存到一个临时变量中。
- en: The third, fourth, and fifth lines enter the framework folder, build the framework
    for a debug configuration, and return back to the original folder.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三、第四和第五行进入框架文件夹，为调试配置构建框架，然后返回到原始文件夹。
- en: 'The last line builds the module itself. Notice that it ends with `&& make`.
    This means that after having successfully run the command in the first part of
    the line, the command in the second part (the `make` command) must be run. Instead,
    if the command in the first part fails, the second command will not be run. The
    line begins with the `RUST_TARGET_PATH=$(pwd)/../linux-fw` clause. It creates
    an environment variable named `RUST_TARGET_PATH`, which is only valid for the
    rest of the command line. It contains the absolute pathname of the `framework`
    folder. Then, the `cargo` tool is invoked, with an `xbuild --target x86_64-linux-kernel-module` argument.
    This is an `xbuild` subcommand to compile for a different platform than the current
    one, and the rest of the command specifies that the target is `x86_64-linux-kernel-module`.
    This target is specific to the framework we are using. To explain how this target
    is used, it is necessary to examine the `Cargo.toml` file, which consists of the
    following code:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行构建了该模块本身。注意，它以`&& make`结束。这意味着在成功运行该行第一部分的命令后，必须运行该行第二部分的命令（`make`命令）。相反，如果第一部分的命令失败，则不会运行第二命令。该行以`RUST_TARGET_PATH=$(pwd)/../linux-fw`子句开始。它创建了一个名为`RUST_TARGET_PATH`的环境变量，该变量仅对命令行其余部分有效。它包含`framework`文件夹的绝对路径名。然后，调用`cargo`工具，并带有`xbuild
    --target x86_64-linux-kernel-module`参数。这是一个`xbuild`子命令，用于编译不同于当前平台的程序，其余的命令指定目标为`x86_64-linux-kernel-module`。这个目标是特定于我们使用的框架。为了解释如何使用此目标，有必要检查`Cargo.toml`文件，该文件包含以下代码：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `package` section is the usual one. The `crate-type` item of the `lib` section
    specifies that the target of the compilation is a static-link library.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`package` 部分是常规的。`lib` 部分的 `crate-type` 项指定编译目标是静态链接库。'
- en: The `linux-kernel-module` module of the `dependencies` section specifies the
    relative path of the folder containing the framework. If you prefer to install
    the `framework` folder in another position relative to this project or with another
    name, you should change this path, as well as the `RUST_TARGET_PATH` environment
    variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies` 部分的 `linux-kernel-module` 模块指定了包含框架的文件夹的相对路径。如果你希望将 `framework`
    文件夹安装在这个项目的另一个相对位置或使用另一个名称，你应该更改此路径，以及 `RUST_TARGET_PATH` 环境变量。'
- en: Thanks to this directive, it is possible to use the target specified in the
    `cargo` command line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个指令，才可能使用 `cargo` 命令行中指定的目标。
- en: The remaining sections specify that in case of panic, an immediate abort should
    be done (with no output) and that in the release configuration, **Link-Time Optimization**
    (**LTO**) should be activated.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的部分指定，在发生恐慌时，应立即执行立即中止（无输出）操作，并且在发布配置中，**链接时优化**（**LTO**）应被激活。
- en: After completing this `cargo` command, the `target/x86_64-linux-kernel-module/debug/libboilerplate.a` static-link
    library should have been created. As with any other Linux static-link library,
    its name starts with `lib` and ends with `.a`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个 `cargo` 命令后，应该已经创建了 `target/x86_64-linux-kernel-module/debug/libboilerplate.a`
    静态链接库。与其他任何 Linux 静态链接库一样，它的名称以 `lib` 开头，以 `.a` 结尾。
- en: The last part of the command line runs the `make` utility, which is a `build`
    tool used mainly when developing in C. Just as the `cargo` tool uses the `Cargo.toml`
    file to know what to do, the `make` tool uses the `Makefile` file for the same
    purposes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行的最后一部分运行 `make` 工具，这是一个主要用于 C 语言开发的 `build` 工具。正如 `cargo` 工具使用 `Cargo.toml`
    文件来知道要做什么一样，`make` 工具使用 `Makefile` 文件来完成同样的目的。
- en: Here, we don't examine `Makefile`, but we just say that it reads the static
    library generated by `cargo` and encapsulates it with some C language glue code
    to generate the `boilerplate.ko` file, which is the kernel module.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不检查 `Makefile`，但只是说它读取由 `cargo` 生成的静态库，并用一些 C 语言粘合代码封装它，以生成 `boilerplate.ko`
    文件，这是内核模块。
- en: 'In addition to the `bd` file, there is a `br` file, which is similar but runs
    both `cargo` and `make` with a `release` option, and so it generates an optimized
    kernel module. You can run it by typing the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `bd` 文件外，还有一个 `br` 文件，它与 `bd` 类似，但使用 `release` 选项同时运行 `cargo` 和 `make`，因此生成一个优化的内核模块。你可以通过输入以下命令来运行它：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The generated module will overwrite the `boilerplate.ko` file, which was created
    by `bd`. You can see that the new file is much smaller on disk and, using the
    `lsmod` utility, you can see that it is also much smaller in memory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模块将覆盖由 `bd` 创建的 `boilerplate.ko` 文件。你可以看到新文件在磁盘上要小得多，并且使用 `lsmod` 工具可以看到它在内存中也要小得多。
- en: The source code of the boilerplate module
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板模块的源代码
- en: 'Now, let''s examine the Rust source code of this project. It is contained in
    the `src/lib.rs` file. The first line is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查这个项目的 Rust 源代码。它包含在 `src/lib.rs` 文件中。第一行如下：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a directive to avoid loading the Rust standard library in this project.
    Actually, many routines of the standard library assume to be run as application
    code—in user-space, not inside a kernel—and so they cannot be used in this project.
    Of course, after this directive, many Rust functions that we are accustomed to
    using are no longer automatically available.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个指令，用于避免在这个项目中加载 Rust 标准库。实际上，标准库中的许多例程都假设作为应用程序代码运行——在用户空间，而不是内核内部——因此它们不能在这个项目中使用。当然，在这个指令之后，我们习惯使用的许多
    Rust 函数将不再自动可用。
- en: In particular, no heap memory allocator is included by default and so, by default,
    vectors and strings that need heap memory allocation are not allowed. If you try
    to use `Vec` or the `String` type, you will get a `use of undeclared type or module`
    error message.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，默认情况下不包含堆内存分配器，因此默认情况下不允许向量或字符串进行堆内存分配。如果你尝试使用 `Vec` 或 `String` 类型，你会得到一个
    `use of undeclared type or module` 错误信息。
- en: 'The next lines are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行如下：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These lines import some names into the current source file. These names are
    defined in the framework.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将一些名称导入当前源文件。这些名称在框架中定义。
- en: The first line imports the declarations of some data types corresponding to
    the C language data types. They are needed to interface with the kernel, which
    expects that modules are written in C. After this declaration, you can use, for
    example, the `c_types::c_int` expression, which corresponds to the C language `int` data
    type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入了与C语言数据类型相对应的一些数据类型的声明。它们是必需的，以便与内核接口，内核期望模块是用C语言编写的。在此声明之后，您可以使用例如`c_types::c_int`表达式，它对应于C语言的`int`数据类型。
- en: The second line imports a macro named `println`, just like that of the standard
    library, which is no longer available. Actually, it can be used in the same way,
    but instead of printing on the terminal, it appends a line to the kernel buffer,
    prefixed by a timestamp.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行导入了一个名为`println`的宏，就像标准库中的那样，现在已经不再可用。实际上，它可以以相同的方式使用，但不是打印到终端，而是将一行追加到内核缓冲区，前面带有时间戳。
- en: 'Then, there are two entry points of the module—the `init_module` function,
    which is invoked by the kernel when the module is loaded, and the `cleanup_module`
    function, which is invoked by the kernel when the module is unloaded. They are
    defined by the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，模块有两个入口点——`init_module`函数，当模块被加载时由内核调用，以及`cleanup_module`函数，当模块被卸载时由内核调用。它们由以下代码定义：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Their `no_mangle` attribute is a directive to the linker to keep this exact
    function name so that the kernel can find this function by its name. Its `extern
    "C"` clause specifies that the *function-calling* convention must be the one normally
    used by C.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的`no_mangle`属性是向链接器发出的指令，以保留这个确切函数名，以便内核可以通过其名称找到这个函数。它的`extern "C"`子句指定函数调用约定必须是C语言通常使用的约定。
- en: These functions get no arguments, but the first one returns a value that indicates
    the outcome of the initialization. A `0` result represents success and a `1` result
    represents failure. It is specified by Linux that the type of this value is the
    C language `int` variable and the `c_types::c_int` type of the framework represents
    just that binary type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数不接受任何参数，但第一个函数返回一个值，表示初始化的结果。`0`表示成功，而`1`表示失败。Linux规定这个值的类型是C语言的`int`变量，而框架中的`c_types::c_int`类型正好代表这种二进制类型。
- en: Both functions print the messages that we saw in the previous section to the
    kernel buffer. Also, both functions are optional, but if the `init_module` function
    is absent, a warning is emitted by the linker.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将我们在上一节中看到的消息打印到内核缓冲区。此外，这两个函数都是可选的，但如果`init_module`函数缺失，链接器将发出警告。
- en: 'The last two lines of the file are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的最后两行如下：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: They define a string resource for the linker to insert into the resulting executable. The name
    of that string resource is `.modinfo` and its value is `licence=GPL`. That value
    must be a null-terminated ASCII string because that is the string type normally
    used in C. This section is not required, but if it is absent, a warning is emitted
    by the linker.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 他们为链接器定义了一个字符串资源，以便将其插入到生成的可执行文件中。该字符串资源的名称是`.modinfo`，其值是`licence=GPL`。该值必须是一个以空字符终止的ASCII字符串，因为这是C语言中通常使用的字符串类型。本节不是必需的，但如果它缺失，链接器将发出警告。
- en: Using global variables
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全局变量
- en: The module boilerplate of the preceding project just printed some static text.
    However, it is quite typical for a module to have some variables that must be
    accessed during the lifetime of the module. Usually, Rust does not use mutable
    global variables because they are not safe and just defines them in the `main`
    function and passes them as arguments to the functions called by `main`. However,
    kernel modules do not have a `main` function. They have entry points called by
    the kernel and so, to keep shared mutable variables, some unsafe code must be
    used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前项目的模块模板只是打印了一些静态文本。然而，对于模块来说，通常有一些变量必须在模块的生命周期内访问。通常，Rust不使用可变的全局变量，因为它们不安全，只是在`main`函数中定义它们，并将它们作为参数传递给由`main`调用的函数。然而，内核模块没有`main`函数。它们有内核调用的入口点，因此，为了保持共享的可变变量，必须使用一些不安全的代码。
- en: 'The `State` project shows you how to define and use shared mutable variables.
    To run it, enter the `state` folder and type `./bd`. Then, type the following
    four commands:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`State`项目展示了如何定义和使用共享的可变变量。要运行它，进入`state`文件夹并输入`./bd`。然后，输入以下四个命令：'
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s see what we did there:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们做了什么：
- en: The first command will load the module into the kernel with no output to the
    console.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个命令将模块加载到内核中，不会向控制台输出任何内容。
- en: The second command will show that the module is loaded by fetching all the loaded
    modules and filtering the one called `state`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个命令将显示通过检索所有已加载的模块并过滤名为`state`的模块来加载模块。
- en: The third command will unload the module from the kernel with no output to the
    console.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个命令将从内核卸载模块，不会在控制台输出任何内容。
- en: 'The last command will show the two lines added by this module to the kernel
    buffer. They will look like this:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个命令将显示此模块添加到内核缓冲区的两行。它们看起来像这样：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Apart from the timestamps, they differ from the `boilerplate` example due to
    the name of the module and the addition of the number `1001` to the second line.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了时间戳之外，它们与`boilerplate`示例的不同之处在于模块的名称以及第二行添加了数字`1001`。
- en: 'Let''s see the source code of this project, showing the differences compared
    with the boilerplate source code. The `lib.rs` file contains the following additional
    lines:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个项目的源代码，展示它与`boilerplate`源代码相比的不同之处。`lib.rs`文件包含以下附加行：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first line defines a data structure type, named `GlobalData`, containing
    only a 16-bit unsigned number. The second line defines and initializes a static
    mutable variable of this type, named `GLOBAL` .
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个名为`GlobalData`的数据结构类型，它只包含一个16位的无符号数。第二行定义并初始化了这个类型的静态可变变量，命名为`GLOBAL`。
- en: 'Then, the `init_module` function contains the following additional statement:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`init_module`函数包含以下附加语句：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This increments the global variable. As it was initialized to `1000`, after
    the module is loaded, the value of this variable is `1001`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了全局变量。由于它被初始化为`1000`，在模块加载后，这个变量的值变为`1001`。
- en: 'Finally, the statement in the `cleanup_module` function is replaced by the
    following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`cleanup_module`函数中的语句被以下内容替换：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This formats and prints the value of the global variable. Notice that both reading
    and writing a global variable is an *unsafe operation* as it provides access to
    a mutable static object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将格式化和打印全局变量的值。请注意，读取和写入全局变量是一个*不安全操作*，因为它提供了对可变静态对象的访问。
- en: The `bd` and `br` files are identical to those in the `boilerplate` project.
    The `Cargo.toml` and `Makefile` files differ from those in the `boilerplate` project
    due to the replacement of the `boilerplate` string with the `state` string.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`bd`和`br`文件与`boilerplate`项目中的文件相同。`Cargo.toml`和`Makefile`文件与`boilerplate`项目中的文件不同，因为将`boilerplate`字符串替换为`state`字符串。'
- en: Allocating memory
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配内存
- en: The preceding project defined a global variable, but it did not carry out memory
    allocation. Even in kernel modules, it is possible to allocate memory, as shown
    in the `allocating` project.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个项目定义了一个全局变量，但没有执行内存分配。即使在内核模块中，也可以分配内存，如`allocating`项目所示。
- en: 'To run this project, open the `allocating` folder and type in `./bd`. Then,
    type the following four commands:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此项目，打开`allocating`文件夹，输入`./bd`。然后，输入以下四个命令：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These commands have a behavior quite similar to the corresponding commands
    for the preceding project, but the last one will print a line that, after the
    timestamp, will contain the following text:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的行为与上一个项目的相应命令非常相似，但最后一个命令会在时间戳之后打印一行文本：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s examine the source code of this project and see its differences compared
    with the `boilerplate` source code. The `lib.rs` file contains the following additional
    lines:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个项目的源代码，看看它与`boilerplate`源代码相比有哪些不同。`lib.rs`文件包含以下附加行：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first line explicitly declares that a memory allocator is needed. Otherwise,
    as the standard library is not used, no memory allocator will be linked to the
    executable module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行明确声明需要一个内存分配器。否则，由于没有使用标准库，将不会将内存分配器链接到可执行模块。
- en: 'The second and third lines are required to include the `String` and `Vec` types in
    the source code, respectively. Otherwise, they will not be available to the source
    code. Then, there are the following global declarations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行和第三行需要分别在源代码中包含`String`和`Vec`类型。否则，它们将不可用于源代码。然后，还有以下全局声明：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, the data structure contains three fields. Two of them, `msg` and `values`,
    use heap memory when they are not empty, and the `GLOBAL` variable initializes
    all of them. Here, no memory allocation is allowed, and so these dynamic fields
    must be empty.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数据结构包含三个字段。其中两个字段`msg`和`values`在它们不为空时使用堆内存，而`GLOBAL`变量初始化了所有这些。在这里不允许内存分配，因此这些动态字段必须是空的。
- en: 'In the `init_module` function, as in other entry points, allocations are allowed,
    and so the following code is valid:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init_module` 函数中，与其他入口点一样，允许分配，因此以下代码是有效的：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This changes all the fields of the global variable, allocating memory for both
    the `msg` string and the `values` vector. Finally, the global variable is accessed
    to print its values by using the following statement in the `cleanup_module` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更改全局变量的所有字段，为 `msg` 字符串和 `values` 向量分配内存。最后，在 `cleanup_module` 函数中使用以下语句访问全局变量以打印其值：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The rest of the code is unchanged.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其他部分保持不变。
- en: A character device
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符设备
- en: Unix-like systems are famous for their feature that maps I/O devices to the
    filesystem. In addition to the predefined I/O devices, it is possible to define
    your own devices as kernel modules. A kernel device can be attached to real hardware
    or it can be **virtual**. In this project, we will build a virtual device.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类Unix系统以其将I/O设备映射到文件系统的功能而闻名。除了预定义的I/O设备外，还可以将自定义设备定义为内核模块。内核设备可以连接到真实硬件，也可以是**虚拟的**。在本项目中，我们将构建一个虚拟设备。
- en: 'In Unix-like systems, there are two kinds of I/O devices: **block devices**
    and **character devices**. The former handle packets of bytes in a single operation
    (that is, they are buffered), while the latter can handle only one byte at a time,
    with no buffering.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix系统中，有两种类型的I/O设备：**块设备**和**字符设备**。前者在一次操作中处理字节数组（即它们是缓冲的），而后者一次只能处理一个字节，没有缓冲。
- en: In general, a device can be read, written, or both. Our device will be a read-only
    device. So, we are going to build a filesystem-mapped, virtual, read-only character
    device.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设备可以读取、写入或两者兼而有之。我们的设备将是一个只读设备。因此，我们将构建一个文件系统映射的、虚拟的、只读字符设备。
- en: Building the character device
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建字符设备
- en: Here, we are going to build a character device driver (or **character device** for
    short). A character device is a device driver that can handle only one byte at
    a time with no buffering. The behavior of our device will be quite simple— for
    every byte read from it, it will return a dot character, but for every 10 characters,
    an asterisk will be returned instead of a dot.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将构建一个字符设备驱动程序（或简称为**字符设备**）。字符设备是一种一次只能处理一个字节且没有缓冲的设备驱动程序。我们设备的操作将非常简单——对于从它读取的每个字节，它将返回一个点字符，但对于每10个字符，将返回一个星号而不是点。
- en: To build it, open the `dots` folder and type in `./bd`. Several files will be
    created in the current folder, including the `dots.ko` file, which is our kernel
    module.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建它，打开 `dots` 文件夹，并输入 `./bd`。当前文件夹中将创建几个文件，包括我们的内核模块 `dots.ko` 文件。
- en: 'To install it and check whether it is loading, type the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它并检查是否已加载，请输入以下命令：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, the kernel module is loaded as a character device, but it is not yet mapped
    to a special file. However, you can find it among the loaded devices by using
    the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，内核模块已作为字符设备加载，但尚未映射到特殊文件。然而，您可以使用以下命令在已加载的设备中找到它：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `/proc/devices` virtual file contains a list of all the loaded device modules.
    Among them, in the `Character devices` section, there should be a line like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/devices` 虚拟文件包含所有已加载设备模块的列表。其中，在 `Character devices` 部分，应该有一行如下所示：'
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This means that there is a loaded character device driver named `dots` whose
    internal identifier is `236`. This internal identifier is also named a **major
    number** because it is the first number of a pair of numbers that actually identifies
    the device. The other number, known as a **minor number**, is not used but can
    be set to `0`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着存在一个名为 `dots` 的加载字符设备驱动程序，其内部标识符为 `236`。这个内部标识符也被称为**主设备号**，因为它是一对数字中的第一个数字，实际上用于识别设备。另一个数字，称为**次设备号**，未使用，但可以设置为
    `0`。
- en: The major number may vary from system to system and from loading to loading
    because it is assigned by the kernel when the module is loaded. Anyway, it is
    a small, positive integer number.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 主设备号可能因系统而异，也可能因加载而异，因为它是内核在模块加载时分配的。无论如何，它是一个小的正整数。
- en: 'Now, we must associate these device drivers with a special file, which is an
    entry point in the filesystem, that can be used as a file, but is actually a handle
    to a device driver. This operation is performed by the following command, in which
    you should replace `236` with the major number you found in the `/proc/devices`
    file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将这些设备驱动程序与一个特殊文件相关联，这是一个文件系统中的入口点，可以用作文件，但实际上是一个指向设备驱动程序的句柄。这个操作是通过以下命令完成的，你应该用你在
    `/proc/devices` 文件中找到的主设备号替换 `236`：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `mknod` Linux command creates a special device file. The preceding command
    creates a special file named `dots1` in the `dev` folder.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`mknod` Linux 命令创建一个特殊设备文件。前面的命令在 `dev` 文件夹中创建了一个名为 `dots1` 的特殊文件。'
- en: 'This is a privileged command for two reasons:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有特权的命令，原因有两个：
- en: Only a superuser can create special files.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有超级用户可以创建特殊文件。
- en: Only a superuser can create a file in the `dev` folder.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有超级用户可以在 `dev` 文件夹中创建文件。
- en: The `c` character means that the created device will be a character device.
    The following two numbers—`236` and `0`—are the major and minor numbers of the
    new virtual device.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`c` 字符表示创建的设备将是一个字符设备。接下来的两个数字——`236` 和 `0`——是新虚拟设备的主设备号和次设备号。'
- en: Notice that the name of the special file (`dots1`) can be different from the
    name of the device (`dots`) because the association between the special file and
    the device driver is performed through the major number.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，特殊文件（`dots1`）的名称可以与设备（`dots`）的名称不同，因为特殊文件与设备驱动程序之间的关联是通过主设备号来完成的。
- en: 'After creating the special file, you can read some bytes from it. The `head`
    command reads the first lines or bytes of a text file. So, type the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建特殊文件后，你可以从中读取一些字节。`head` 命令读取文本文件的第一行或字节。所以，输入以下命令：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will print the following text to the console:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台打印以下文本：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This command reads the first 42 bytes from the specified file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令从指定的文件中读取前42个字节。
- en: When asked for the first byte, the module returns a dot. When asked for the
    second byte, the module returns another dot, and so on for the first nine bytes.
    However, when asked for the 10^(th) byte, the module returns an asterisk. Then,
    this behavior is repeated—after nine dots, an asterisk is returned over and over
    again. In fact, only 42 characters are returned because the `head` command requested
    42 characters from our device.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当询问第一个字节时，模块返回一个点。当询问第二个字节时，模块返回另一个点，以此类推，直到前九个字节。然而，当询问第10个字节时，模块返回一个星号。然后，这种行为会重复——在九个点之后，会不断地返回星号。实际上，只返回了42个字符，因为
    `head` 命令从我们的设备请求了42个字符。
- en: In other words, if the character generated by the module has an ordinal number
    that is a multiple of 10, then it is an asterisk; otherwise, it is a dot.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果模块生成的字符的序号是10的倍数，那么它就是一个星号；否则，它是一个点。
- en: 'You can create other special files based on the `dots` module. For example,
    type the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据 `dots` 模块创建其他特殊文件。例如，输入以下内容：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, type the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will print the following text to the console:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台打印以下文本：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that 12 characters are printed, as requested by the `head` command, but
    this time, the asterisk is at the 8^(th) character, instead of the 10^(th). This
    happens because both the `dots1` and `dots2` special files are associated with
    the same kernel module, with an identifier (`236, 0`) and the name `dots`. This
    module remembers it has already generated 42 characters, and so after it has generated
    seven dots, it has to generate its 50^(th) character, which must be an asterisk
    as it is a multiple of 10.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，打印了12个字符，这是 `head` 命令要求的，但这次，星号在第8个字符处，而不是第10个。这是因为 `dots1` 和 `dots2` 这两个特殊文件都与同一个内核模块相关联，标识符为
    (`236, 0`)，名称为 `dots`。该模块记得它已经生成了42个字符，因此，在生成七个点之后，它必须生成它的第50个字符，这个字符必须是星号，因为它是一个10的倍数。
- en: 'You can try to type the whole file, but these operations will never end spontaneously
    because the module will continue to generate characters, as if it were an infinite
    file. Try to type the following command, and then stop it by pressing *Ctrl* +* C*:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试输入整个文件，但这些操作永远不会自发结束，因为模块会继续生成字符，就像它是一个无限文件。尝试输入以下命令，然后通过按下 *Ctrl* +* C*
    来停止它：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A fast stream of characters will be printed until you stop it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将会打印出一串快速流动的字符，直到你停止它。
- en: 'You can remove the special files by typing the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下命令删除特殊文件：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can unload the module by typing the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下命令卸载模块：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you unload the module without removing the special files, they will be invalid.
    If you then try to use one of them, such as by typing `head -c4 /dev/dots1`, you
    will get the following error message:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你卸载模块而不删除特殊文件，它们将无效。如果你然后尝试使用其中一个，例如通过输入`head -c4 /dev/dots1`，你会得到以下错误信息：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s see what has been appended to the kernel buffer by typing the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过输入以下内容来查看附加到内核缓冲区的信息：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You will see that the last two lines that are printed will be similar to the
    following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到打印出的最后两行将与以下内容相似：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first line, printed at module loading, also shows the major number of the
    module. The last line, printed at module unloading, also shows the total number
    of bytes generated by the module (*42 + 12 = 54*, if you didn't run the `cat`
    command). Now, let's see the implementation of this module.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，在模块加载时打印，也显示了模块的主要编号。最后一行，在模块卸载时打印，也显示了模块生成的总字节数（如果你没有运行`cat`命令，则为*42 +
    12 = 54*）。现在，让我们看看这个模块的实现。
- en: The source code of the dots module
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dots模块的源代码
- en: The only relevant differences that you will find from the other projects are
    in the `src/lib.rs` file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在其他项目中找到的唯一相关差异是在`src/lib.rs`文件中。
- en: 'First, the `src/lib.rs` file declares the use of the `Box` generic type, which
    is not included by default, similar to `String` and `Vec` in the preceding project.
    Then, it declares some other bindings to the kernel:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`src/lib.rs`文件声明了使用`Box`泛型类型，这与前一个项目中的`String`和`Vec`类似，默认情况下不包括。然后，它声明了一些其他与内核的绑定：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Their meanings are as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的含义如下：
- en: '`__register_chrdev`: The function to register a character device in the kernel.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__register_chrdev`：在内核中注册字符设备的函数。'
- en: '`__unregister_chrdev`: The function to unregister a character device from the
    kernel.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__unregister_chrdev`：从内核中注销字符设备的函数。'
- en: '`_copy_to_user`: The function to copy a sequence of bytes from kernel space
    to user space.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_copy_to_user`：从内核空间到用户空间复制一系列字节的函数。'
- en: '`file`: The data type representing a file. This is not really used in this
    project.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`：表示文件的数据类型。这个项目实际上并没有使用它。'
- en: '`file_operations`: The data type containing the implemented operation on files.
    Only the `read` operation is implemented by this module. Consider this to be the
    perspective of the user code. When the user code *reads*, the kernel module *writes*.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_operations`：包含在文件上实现的操作的数据类型。只有此模块实现了`read`操作。这可以看作是用户代码的视角。当用户代码*读取*时，内核模块*写入*。'
- en: '`loff_t`: The data type representing a long memory offset, as used by the kernel.
    This is not really used in this project.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loff_t`：表示长内存偏移量的数据类型，如内核所使用。这个项目实际上并没有使用它。'
- en: The global information
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局信息
- en: 'The global information is kept in the following data type:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 全局信息保存在以下数据类型中：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s understand the preceding code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解前面的代码：
- en: The first field (`major`) is the major number of the device.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字段（`major`）是设备的主要编号。
- en: The second field (`name`) is the name of the module.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个字段（`name`）是模块的名称。
- en: The third field (`fops`, short for **file operations**) is the set of references
    to the functions that implement the required file operations. This set of references
    will be allocated to the heap, and so it is encapsulated in a `Box` object. Any
    `Box` object must encapsulate a valid value since its creation, but the set of
    references to file operations referenced by the `fops` field can only be created
    when the kernel initializes the module; so, this field is encapsulated in an `Option` object,
    which will be initialized as `None` by Rust and will receive a `Box` object when
    the kernel initializes the module.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个字段（`fops`，简称**文件操作**）是实现所需文件操作的函数引用集合。这个引用集合将被分配到堆上，因此它被封装在一个`Box`对象中。任何`Box`对象必须从其创建时起封装一个有效的值，但`fops`字段引用的文件操作集合只能在内核初始化模块时创建；因此，这个字段被封装在一个`Option`对象中，它将被Rust初始化为`None`，并在内核初始化模块时接收一个`Box`对象。
- en: The last field (`count`) is the counter of generated bytes.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个字段（`count`）是生成的字节数计数器。
- en: 'As anticipated, the following is the declaration and initialization of the
    global object:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，以下是全球对象的声明和初始化：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The module contains only three functions: `init_module`, `cleanup_module`, and `read_dot`.
    The first two functions are the ones invoked by the kernel when the module is
    loaded and unloaded, respectively. The third function is called by the kernel
    every time some user code tries to read a byte from this module.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块只包含三个函数：`init_module`、`cleanup_module` 和 `read_dot`。前两个函数分别在模块加载和卸载时由内核调用。第三个函数在每次有用户代码尝试从这个模块读取字节时由内核调用。
- en: While the `init_module` and `cleanup_module` functions are linked using their
    name (so they must have exactly these names) and must be preceded by the `#[no_mangle]`
    directive to avoid that their name is changed by Rust, the `read_dot` function
    will be passed to the kernel through its address, and not its name. Therefore,
    it can have any name you like, and the `#[no_mangle]` directive is not required
    for it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `init_module` 和 `cleanup_module` 函数通过它们的名称（因此它们必须具有确切的这些名称）链接，并且必须先于 `#[no_mangle]`
    指令以避免 Rust 改变它们的名称，但 `read_dot` 函数将通过其地址而不是其名称传递给内核。因此，它可以有您喜欢的任何名称，并且对于它不需要 `#[no_mangle]`
    指令。
- en: The initialization call
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化调用
- en: 'Let''s see the first part of the body of the `init_module` function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `init_module` 函数体的一部分：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the first statement, a `file_operations` structure, containing the references
    to the file operations, is created with default values and put into a `Box` object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个语句中，创建了一个包含文件操作引用的 `file_operations` 结构体，并使用默认值放入一个 `Box` 对象中。
- en: The default value of any file operation is `None`, meaning that nothing is performed
    when this kind of operation is required. We will use just the `read` file operation
    and we will need this operation to call the `read_dot` function. Therefore, in
    the second statement, this function is assigned to the `read` field of the newly
    created structure.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 任何文件操作的默认值是 `None`，这意味着当需要此类操作时不会执行任何操作。我们将仅使用 `read` 文件操作，并且我们需要调用 `read_dot`
    函数进行此操作。因此，在第二个语句中，此函数被分配给新创建的结构体的 `read` 字段。
- en: 'The third statement calls the `__register_chrdev` kernel function, which registers
    a character device. This function is officially documented on a web page, available
    at [https://www.kernel.org/doc/html/latest/core-api/kernel-api.html?highlight=__register_chrdev#c.__register_chrdev](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html?highlight=__register_chrdev#c.__register_chrdev). The
    five arguments of this function have the following purposes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个语句调用了 `__register_chrdev` 内核函数，该函数用于注册字符设备。此函数在网页上正式文档化，可在[https://www.kernel.org/doc/html/latest/core-api/kernel-api.html?highlight=__register_chrdev#c.__register_chrdev](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html?highlight=__register_chrdev#c.__register_chrdev)找到。此函数的五个参数具有以下用途：
- en: The first argument is the required major number of the device. However, if it
    is `0`, as in our case, a major number will be generated by the kernel and returned
    by the function.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是设备所需的主设备号。然而，如果它是 `0`，就像我们的情况一样，内核将生成主设备号并由函数返回。
- en: The second argument is the value to start from in order to generate the minor
    number. We will start from `0`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是从中生成次设备号的起始值。我们将从 `0` 开始。
- en: The third argument is the number of minor numbers that we request to allocate.
    We will allocate 256 minor numbers, from `0` to `255`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是我们请求分配的次设备号的数量。我们将分配 256 个次设备号，从 `0` 到 `255`。
- en: The fourth argument is the name of the range of devices we are registering.
    The kernel expects a null-terminated ASCII string. Therefore, the `name` field
    has been declared with an ending binary of `0`, and here, a rather complex expression
    just changes the data type of this name. The `as_bytes()` call converts the string
    slice into a byte slice. The `as_ptr()` call gets the address of the first byte
    of this slice. The `as *const i8` clause converts this Rust pointer into a raw
    pointer to bytes.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数是我们正在注册的设备范围的名称。内核期望一个以空字符终止的 ASCII 字符串。因此，`name` 字段已声明为以二进制 `0` 结尾，在这里，一个相当复杂的表达式只是改变了这个名称的数据类型。`as_bytes()`
    调用将字符串切片转换为字节切片。`as_ptr()` 调用获取此切片的第一个字节的地址。`as *const i8` 子句将此 Rust 指针转换为字节的原始指针。
- en: The fifth argument is the address of the file operation structure. Only its `read`
    field will be used by the kernel when a read operation is performed.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数是文件操作结构体的地址。当执行读取操作时，内核将仅使用其 `read` 字段。
- en: 'Now, let''s see the rest of the body of the `init_module` function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `init_module` 函数的其余部分：
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The major number returned by the call to `__register_chrdev` should be a non-negative
    number generated by the kernel. It is only a negative number in the case of an
    error. As we want to fail the loading of the module in case of a registration
    fail, we return `1`—in this case, meaning there has been a failure in the loading
    of the module.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `__register_chrdev` 返回的主要数字应该是由内核生成的一个非负数。只有在出错的情况下才会返回负数。由于我们希望在注册失败时失败模块的加载，因此我们返回
    `1`——在这种情况下，表示模块加载失败。
- en: In case of success, the major number is stored in the `major` field of our global
    structure. Then, a success message is added to the kernel buffer, containing the
    generated major number.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，主要数字存储在我们全局结构的 `major` 字段中。然后，将成功消息添加到内核缓冲区，包含生成的次要数字。
- en: Finally, the `fops` file operation structure is stored in the global structure.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `fops` 文件操作结构存储在全局结构中。
- en: Notice that after the registration call, the kernel keeps the address of the
    `fops` structure, and so this address should never be changed while the function
    is registered. This holds, however, because this structure is allocated by the
    `Box::new` call and the assignment of `fops` moves just the `Box` object, which
    is the pointer to the heap object, not the heap object itself. This explains why
    a `Box` object has been used.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在注册调用之后，内核保留 `fops` 结构的地址，因此在此函数注册期间不应更改此地址。然而，这成立，因为此结构是由 `Box::new` 调分配的，并且
    `fops` 的赋值只是移动 `Box` 对象，即堆对象的指针，而不是堆对象本身。这解释了为什么使用 `Box` 对象。
- en: The cleanup call
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理调用
- en: 'Now, let''s look at the body of the `cleanup_module` function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `cleanup_module` 函数的主体：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first statement prints the unloading message to the kernel buffer, including
    the total count of bytes read from this module since its loading.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句将卸载消息打印到内核缓冲区，包括自模块加载以来从该模块读取的总字节数。
- en: The second statement calls the `__unregister_chrdev` kernel function, which
    unregisters a previously registered character device. This function is officially
    documented on a web page, available at [https://www.kernel.org/doc/html/latest/core-api/kernel-api.html?highlight=__unregister_chrdev#c.__unregister_chrdev](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html?highlight=__unregister_chrdev#c.__unregister_chrdev).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条语句调用 `__unregister_chrdev` 内核函数，该函数注销先前注册的字符设备。此函数在网页上正式文档化，可在[https://www.kernel.org/doc/html/latest/core-api/kernel-api.html?highlight=__unregister_chrdev#c.__unregister_chrdev](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html?highlight=__unregister_chrdev#c.__unregister_chrdev)找到。
- en: Its arguments are quite similar to the first four arguments of the function
    used to register the device. They must be identical to the corresponding registered
    values. However, while, in the registering function, we specified `0` as the major
    number, here we must specify the actual major number.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 其参数与用于注册设备的函数的前四个参数相当相似。它们必须与相应的注册值相同。然而，在注册函数中，我们指定 `0` 作为主要数字，而在这里我们必须指定实际的主要数字。
- en: The reading function
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取函数
- en: 'Finally, let''s see the definition of the function that will be invoked by
    the kernel every time some user code tries to read a byte from this module:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看内核每次某些用户代码尝试从该模块读取一个字节时将调用的函数的定义：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Also, this function must be decorated by the `extern "C"` clause to ensure that
    its calling convection is the same as the one used by the kernel, which is the
    one used by the system's C language compiler.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此函数必须由 `extern "C"` 子句装饰，以确保其调用约定与内核使用的相同，即系统C语言编译器使用的约定。
- en: This function has four arguments, but we will only use the second one. This
    argument is a pointer to a structure in user-space where the generated character
    must be written. The body of the function contains only three statements.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有四个参数，但我们只会使用第二个。此参数是指向用户空间中结构的指针，其中必须写入生成的字符。函数的主体只包含三条语句。
- en: The first statement increments the total count of bytes read by the user code
    (which is written by the kernel module).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句增加用户代码（由内核模块编写）读取的总字节数。
- en: The second statement is a call to the `_copy_to_user` kernel function. This
    is the function to use when you want to copy one or more bytes from a memory area
    controlled by kernel code to a memory area controlled by the user code because
    a simple assignment is not allowed for this operation. This function is officially
    documented at [https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-to-user.html](https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-to-user.html)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个语句是对内核函数`_copy_to_user`的调用。当你想要从一个由内核代码控制的内存区域复制一个或多个字节到由用户代码控制的内存区域时，可以使用此函数，因为此操作不允许简单的赋值。此函数在[https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-to-user.html](https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-to-user.html)有官方文档说明。
- en: Its first argument is the destination address, which is the memory position
    where we want to write our byte. In our case, this is simply the second argument
    of the `read_dot` function, converted into the proper data type.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 它的第一个参数是目标地址，这是我们想要写入字节的内存位置。在我们的例子中，这仅仅是`read_dot`函数的第二个参数，转换成适当的数据类型。
- en: 'The second argument is the source address, which is the memory position where
    we put the byte we want to return to the user. In our case, we want to return
    an asterisk after every nine dots. So, we check whether the total number of read
    characters is a multiple of `10`. For this case, we use a static string slice
    containing only an asterisk: otherwise, we have a string slice containing a dot.
    The call to `as_ptr()` gets the address of the first byte of the string slice
    and the `as *const c_types::c_void` clause converts it into the expected data
    type that corresponds to the `const void *` C language data type.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是源地址，这是我们想要返回给用户的字节的内存位置。在我们的例子中，我们希望在九个点之后返回一个星号。因此，我们检查读取字符的总数是否是`10`的倍数。在这种情况下，我们使用只包含一个星号的静态字符串切片：否则，我们有一个包含点的字符串切片。对`as_ptr()`的调用获取字符串切片的第一个字节的地址，而`as
    *const c_types::c_void`子句将其转换为与C语言的`const void *`数据类型相对应的预期数据类型。
- en: The third argument is the number of bytes to copy. Of course, in our case, this
    is `1`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是要复制的字节数。当然，在我们的例子中，这是`1`。
- en: That's all that is needed to emit dots and asterisks.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是生成点和星号所需的所有内容。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the tools and techniques that can be used to create
    loadable modules for the kernel of the Linux operating system using Rust, instead
    of the typical C programming language.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了可以使用Rust语言而不是典型的C编程语言来创建Linux操作系统内核的可加载模块的工具和技术。
- en: In particular, we saw the sequence of commands that can be used in a Mint distribution
    on an x86_64 architecture to configure the appropriate environment to build and
    test loadable kernel modules. We also looked at the `modinfo`, `lsmod`, `insmod`, `rmmod`, `dmesg`,
    and `mknod` command-line tools.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们看到了在Mint发行版和x86_64架构上可以使用的一系列命令，用于配置构建和测试可加载内核模块的适当环境。我们还研究了`modinfo`、`lsmod`、`insmod`、`rmmod`、`dmesg`和`mknod`命令行工具。
- en: We saw that to create a kernel module, it is useful to have a framework of code
    that implements a target framework for the Rust compiler. The Rust source code
    is compiled to a Linux static library using this target. Then, this library is
    linked with some C language glue code into a loadable kernel module.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，为了创建内核模块，拥有一个针对Rust编译器的目标框架的代码框架是有用的。使用这个目标，Rust源代码被编译成Linux静态库。然后，这个库与一些C语言的粘合代码链接，形成一个可加载的内核模块。
- en: We created four projects of increasing complexity—`boilerplate`, `state`, `allocating`,
    and `dots`. In particular, the `dots` project created a module that can be mapped
    to a special file using the `mknod` command; after this mapping, when this special
    file is read, a stream of dots and asterisks is generated.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了四个逐渐增加复杂性的项目——`boilerplate`、`state`、`allocating`和`dots`。特别是，`dots`项目创建了一个模块，可以使用`mknod`命令将其映射到特殊文件；在此映射之后，当读取这个特殊文件时，会生成一系列点和星号。
- en: In the next and final chapter, we'll consider the advancements of the Rust ecosystem
    over the next few years—the language, the standard library, the standard tooling,
    and the freely available libraries and tools. A description of the newly supported
    asynchronous programming is also included.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将考虑Rust生态系统在未来几年内的进步——语言、标准库、标准工具以及免费提供的库和工具。还包括对新增的异步编程的支持的描述。
- en: Questions
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a Linux loadable kernel module?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Linux可加载内核模块？
- en: What is the programming language expected to be used by the Linux kernel for
    its modules?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux内核期望使用哪种编程语言为其模块编写？
- en: What is the kernel buffer and what is the first part of every line in it?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是内核缓冲区以及它每一行的第一部分是什么？
- en: What is the purpose of the `modinfo`, `lsmod`, `insmod`, and `rmmod` Linux commands?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`modinfo`、`lsmod`、`insmod`和`rmmod`Linux命令的目的是什么？'
- en: Why, by default, are the `String`, `Vec`, and `Box` data types not available
    to Rust code for building kernel modules?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么默认情况下，`String`、`Vec`和`Box`数据类型在Rust代码构建内核模块时不可用？
- en: What is the purpose of the `#[no_mangle]` Rust directive?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#[no_mangle]`Rust指令的目的是什么？'
- en: What is the purpose of the `extern "C"` Rust clause?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`extern "C"`Rust子句的目的是什么？'
- en: What is the purpose of the `init_module` and `cleanup_module` functions?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`init_module`和`cleanup_module`函数的目的是什么？'
- en: What is the purpose of the `__register_chrdev` and `__unregister_chrdev` functions?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__register_chrdev`和`__unregister_chrdev`函数的目的是什么？'
- en: Which function should be used to copy a sequence of bytes from kernel space
    memory to user-space memory?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪个函数将字节序列从内核空间内存复制到用户空间内存？
- en: Further reading
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The framework used for the projects in this chapter is a modification of the
    open source repository that can be found at [https://github.com/lizhuohua/linux-kernel-module-rust](https://github.com/lizhuohua/linux-kernel-module-rust).
    This repository contains further examples and documentation pertaining to this
    topic.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本章项目中使用的框架是对开源仓库的修改，该仓库可以在[https://github.com/lizhuohua/linux-kernel-module-rust](https://github.com/lizhuohua/linux-kernel-module-rust)找到。此仓库包含有关此主题的更多示例和文档。
- en: The documentation for the Linux kernel can be found at [https://www.kernel.org/doc/html/latest/](https://www.kernel.org/doc/html/latest/).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核的文档可以在[https://www.kernel.org/doc/html/latest/](https://www.kernel.org/doc/html/latest/)找到。
