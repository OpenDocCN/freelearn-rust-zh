- en: Conditions, Recursion, and Loops
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件、递归和循环
- en: Loops and conditions within any programming language are a fundamental aspect
    of operation. You may be looping around a list attempting to find when something
    matches, and when a match occurs, branching out to perform some other task; or,
    you may just want to check a value to see whether it meets a condition. In any
    case, Rust allows you to do this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中的循环和条件都是操作的基本方面。你可能正在遍历一个列表，试图找到匹配项，当匹配发生时，分支执行其他任务；或者，你可能只想检查一个值是否满足条件。在任何情况下，Rust都允许你这样做。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Types of loop available
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的循环类型
- en: Different types of branching within loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环中的不同类型分支
- en: Recursive methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归方法
- en: When the semicolon (`;`) can be omitted and what it means
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当分号（`;`）可以省略及其含义
- en: Loops
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'Rust has essentially three types of loops:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Rust本质上具有三种类型的循环：
- en: '`loop` is the simplest one—it just goes through a block of code again and again
    until one of the loop-breaking keywords is used'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`是最简单的一种——它只是重复执行代码块，直到使用到循环中断关键字。'
- en: '`while` is like loop, but with a condition—the block of code is looped again
    and again as long as the condition is true'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`类似于循环，但有一个条件——只要条件为真，代码块就会重复执行'
- en: '`for` is different from the above two—it is for iterating through sequences'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`与上述两种不同——它是用于遍历序列的'
- en: The for loop
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'The `for` loops are slightly different from the same construct in C-like languages.
    In C, the `for` loops consist of three things: an initialization, a stopping condition,
    and a stepping instruction. Rust `for` loops are a bit higher-level though: they
    are for iterating through sequences.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环与C-like语言中的相同结构略有不同。在C中，`for`循环由三部分组成：初始化、停止条件和步进指令。Rust的`for`循环则更高级一些：它们用于遍历序列。'
- en: 'Let''s take a simple example to start with—a loop that goes from 0 to 10 and
    outputs the value:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始——一个从`0`到`10`的循环，并输出值：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create a variable `x` that takes an element from the range (`0..10`), one
    by one, and does something with it. In Rust terminology, `0..10` is not only a
    variable but also an **iterator**, as it gives back a value from a series of elements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个变量`x`，它从范围（`0..10`）中逐个获取元素，并对它进行一些操作。在Rust术语中，`0..10`不仅是一个变量，也是一个**迭代器**，因为它从一系列元素中返回一个值。
- en: 'This is obviously a very simple example. We can also define the iterator to
    work in the opposite direction. In C, you will expect something akin to `for (i
    = 10; i > 0; --i)`. In Rust, we use the `rev()` method to reverse the iterator,
    as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个非常简单的例子。我们也可以定义迭代器以相反的方向工作。在C中，你可能会期望类似`for (i = 10; i > 0; --i)`的东西。在Rust中，我们使用`rev()`方法来反转迭代器，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is worth noting that the range excludes the last number. So, for the previous
    example, the values outputted are `9` to `0`; essentially, the program generates
    the output values from 0 to 10 and then outputs them in reverse.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，范围不包括最后一个数字。所以，对于前面的例子，输出的值是`9`到`0`；本质上，程序生成从`0`到`10`的输出值，然后以相反的顺序输出。
- en: 'The general syntax for the `for` loops is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的一般语法如下：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The C# equivalent for the preceding code is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的C#等价代码如下：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using enumerate
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`enumerate`
- en: 'A `loop` condition can also be more complex, using multiple conditions and
    variables. For example, the `for` loop can be tracked using `enumerate`. This
    will keep track of how many times the loop has executed, as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`条件也可以更复杂，使用多个条件和变量。例如，可以使用`enumerate`来跟踪`for`循环。这将跟踪循环执行了多少次，如下所示：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/00029.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00029.jpeg)'
- en: 'Say we have an array that we need to iterate over to obtain the values. Here,
    the `enumerate` method can be used to obtain the value of the array members. The
    value returned in the condition will be a reference, so a code such as the one
    shown in the following example will fail to execute (`line` is a `&` reference
    whereas an `i32` is expected):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个数组需要遍历以获取值。在这里，可以使用`enumerate`方法来获取数组成员的值。条件返回的值将是一个引用，所以如下所示的代码将无法执行（`line`是一个`&`引用，而期望的是`i32`）：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can be simply converted back from the reference value, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简单地从引用值转换回来，如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `iter().enumerate()` method can equally be used with the `Vec` type (or
    any other type that implements the iterator trait), as shown in the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter().enumerate()` 方法同样可以与 `Vec` 类型（或任何实现了迭代器特质的类型）一起使用，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In both cases, the value given at the end will be `49`, as shown in the following
    screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，最后的值都将是 `49`，如下面的截图所示：
- en: '![](img/00030.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: The _ parameter
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`_` 参数'
- en: You may be wondering what the `_` parameter is. In Rust, it is often not allowed
    to omit variable bindings even if we don't use them. We can use `_` to signify
    that we know that this place needs a variable binding, but we are never going
    to use it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 `_` 参数是什么。在 Rust 中，即使我们不使用变量绑定，通常也不允许省略变量绑定。我们可以使用 `_` 来表示我们知道这个位置需要一个变量绑定，但我们永远不会使用它。
- en: The simple loop
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单循环
- en: 'A simple form of the loop is called `loop`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的一种简单形式被称为 `循环`：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code has no loop-ending keywords, such as break; it will output
    `Hello` until the application is terminated manually.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码没有循环结束关键字，如 `break`；它将一直输出 `Hello`，直到手动终止应用程序。
- en: The while condition
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while 条件
- en: 'The `while` condition extends the loop with a condition, as you will see in
    the following code snippet:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 条件通过条件扩展循环，正如你将在下面的代码片段中看到的那样：'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s take a look at the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code will output `done = 0` to `done = 31`. The loop terminates
    when `done` equals `32`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将输出 `done = 0` 到 `done = 31`。循环将在 `done` 等于 `32` 时终止。
- en: Prematurely terminating a loop
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提前终止循环
- en: Depending on the size of the data being iterated over within a loop, the loop
    can be costly on processor time. For example, say the server is receiving data
    from a data-logging application, such as measuring values from a gas chromatograph;
    over the entire scan, it may record roughly half a million data points with an
    associated time position.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据循环内迭代的 数据大小，循环可能会在处理器时间上花费较多。例如，假设服务器正在从数据记录应用程序接收数据，例如从气相色谱仪测量值；在整个扫描过程中，它可能记录大约五十万个数据点及其相关的时间位置。
- en: For our purposes, we want to add all of the recorded values until the value
    is over 1.5 and once that is reached, we can stop the loop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们想要将所有记录的值相加，直到值超过 1.5，一旦达到这个值，我们就可以停止循环。
- en: 'Sound easy? There is one thing not mentioned: there is no guarantee that the
    recorded value will ever reach over 1.5, so how can we terminate the loop if the
    value is reached?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单？但有一件事没有提到：没有保证记录的值会超过 1.5，那么如果值达到了，我们如何终止循环？
- en: 'We can do this in one of two ways. The first is to use a `while` loop and introduce
    a Boolean to act as the test condition. In the following example, `my_array` represents
    a very small subsection of the data sent to the server:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式之一来完成这个操作。第一种是使用 `while` 循环并引入一个布尔值作为测试条件。在以下示例中，`my_array` 代表发送到服务器的数据的一个非常小的子集：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result here is `4.4`. This code is perfectly acceptable, if slightly long-winded.
    Rust also allows the use of the `break` and `continue` keywords (if you're familiar
    with C, they work in the same way).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里结果是 `4.4`。这段代码完全可接受，尽管稍微有些冗长。Rust 还允许使用 `break` 和 `continue` 关键字（如果你熟悉 C，它们的工作方式相同）。
- en: 'Our code using `break` will be as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `break` 的代码如下：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, this will give an answer of `4.4`, indicating that the two methods used
    are equivalent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这将给出 `4.4` 的答案，表明所使用的两种方法是等效的。
- en: If we replace `break` with `continue` in the preceding code example, we will
    get the same result (`4.4`). The difference between `break` and `continue` is
    that `continue` jumps to the next value in the iteration rather than jumping out,
    so if we had the final value of `my_array` as `1.3`, the output at the end should
    be `5.7`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在前面的代码示例中将 `break` 替换为 `continue`，我们将得到相同的结果（`4.4`）。`break` 和 `continue`
    的区别在于 `continue` 跳转到迭代中的下一个值而不是跳出，所以如果我们 `my_array` 的最终值为 `1.3`，最后的输出应该是 `5.7`。
- en: When using `break` and `continue`, always keep in mind this difference. While
    it may not crash the code, mistaking `break` and `continue` may lead to results
    that you may not expect or want.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `break` 和 `continue` 时，始终要记住这个区别。虽然这可能会导致代码崩溃，但错误地使用 `break` 和 `continue`
    可能会导致你意想不到或不想得到的结果。
- en: Using loop labels
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环标签
- en: Rust allows us to label our loops. This can be very useful, for example with
    nested loops. These labels act as symbolic names for the loop and as we have a
    name for the loop, we can instruct the application to perform a task on that name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Rust允许我们给循环添加标签。这可以非常有用，例如在嵌套循环中。这些标签作为循环的符号名称，并且因为我们有一个循环的名称，我们可以指示应用程序在该名称上执行任务。
- en: 'Consider the following simple example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的例子：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What will this code do?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会做什么？
- en: Here, `x % 2 == 0` (or `y % 2 == 0`) means that if a variable divided by two
    returns no remainder, then the condition is met and it executes the code in the
    braces. When `x % 2 == 0`, or when the value of the loop is an even number, we
    will tell the application to skip to the next iteration of `outer_loop`, which
    is an odd number. However, we will also have an inner loop. Again, when `y % 2`
    is an even value, we will tell the application to skip to the next iteration of
    `inner_loop`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x % 2 == 0`（或`y % 2 == 0`）意味着如果一个变量除以二没有余数，那么条件就满足，并且执行花括号中的代码。当`x % 2
    == 0`，或者当循环的值是偶数时，我们将告诉应用程序跳到`outer_loop`的下一个迭代，而`outer_loop`是一个奇数。然而，我们还有一个内层循环。同样，当`y
    % 2`是偶数时，我们将告诉应用程序跳到`inner_loop`的下一个迭代。
- en: 'In this case, the application will output the following results:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应用程序将输出以下结果：
- en: '![](img/00031.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00031.jpeg)'
- en: While this example may seem very simple, it does allow for a great deal of speed
    when checking data. Let's go back to our previous example of data being sent to
    the web service. Recall that we have two values—the recorded data and some other
    value; for ease, it will be a data point. Each data point is recorded 0.2 seconds
    apart; therefore, every fifth data point is one second.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子可能看起来非常简单，但它确实在检查数据时提供了很大的速度。让我们回到我们之前将数据发送到网络服务的例子。回想一下，我们有两个值——记录的数据和一些其他值；为了方便，它将是一个数据点。每个数据点相隔0.2秒记录；因此，每第五个数据点是一秒。
- en: This time, we want all of the values where the data is greater than 1.5 and
    the associated time of that data point, but only on a time when it's dead on a
    second. As we want the code to be understandable and human-readable, we can use
    a loop label on each loop.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们想要所有数据大于1.5的数据点及其相关的时间，但只在该数据点正好在一秒时。因为我们希望代码易于理解和阅读，我们可以在每个循环上使用循环标签。
- en: 'The following code is not quite correct. Can you spot why? The code compiles
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码并不完全正确。你能找出原因吗？代码编译如下：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example is a very good one to demonstrate the correct operator in use.
    The issue is the `if *time_value % 5f32 == 0f32` line. We are taking a float value
    and using the modulus of another float to see whether we end up with 0 as a float.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一个非常好的例子，可以展示正确的运算符的使用。问题是`if *time_value % 5f32 == 0f32`这一行。我们正在取一个浮点值，并使用另一个浮点数的模来查看我们最终是否得到一个浮点数的0。
- en: Comparing any value that is not a `string`, `int`, `long`, or `bool` type to
    another is never a good plan, especially if the value is returned by some form
    of calculation. We can also not simply use `continue` on the time loop, so how
    can we solve this problem?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何非`string`、`int`、`long`或`bool`类型的值与另一个值进行比较，从来不是一个好主意，尤其是如果该值是由某种形式的计算返回的。我们也不能简单地使用`continue`在时间循环中，那么我们该如何解决这个问题呢？
- en: 'If you recall, we''re using `_` instead of a named parameter for the enumeration
    of the loop. These values are always an integer; therefore, if we replace `_`
    for a variable name, then we can use `% 5` to perform the calculation and the
    code becomes the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们正在使用`_`而不是命名参数来进行循环的枚举。这些值始终是整数；因此，如果我们用一个变量名替换`_`，那么我们可以使用`% 5`来进行计算，代码就变成了以下这样：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next problem is that the output isn''t correct. The code gives the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题在于输出并不正确。代码给出了以下：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The data point is correct, but the time is way out and continually repeats.
    We still need the `continue` statement for the data point step, but the time step
    is incorrect. There are a couple of solutions, but possibly the simplest will
    be to store the data and the time in a new vector and then display that data at
    the end.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据点是正确的，但时间完全错误，并且不断重复。我们仍然需要在数据点步骤中使用`continue`语句，但时间步骤是错误的。有几个解决方案，但可能最简单的方法是将数据和时间存储在一个新的向量中，然后在最后显示这些数据。
- en: 'The following code gets closer to what is required:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码更接近所需的结果：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will now get the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将得到以下输出：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yes, we now have the correct data, but the time starts again. We're close, but
    it's not right yet. We aren't continuing the `time_loop` loop and we will also
    need to introduce a `break` statement. To trigger the `break`, we will create
    a new variable called `done`. When `v`, the enumerator for `my_array`, reaches
    the length of the vector (this is the number of elements in the vector), we will
    change this from `false` to `true`. This is then tested outside of the `data_loop`.
    If `done == true`, break out of the loop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们现在有了正确的数据，但时间又重新开始。我们很接近，但还不是正确的。我们没有继续`time_loop`循环，我们还需要引入一个`break`语句。为了触发`break`，我们将创建一个新的变量`done`。当`v`，`my_array`的枚举器达到向量的长度（这是向量中的元素数量）时，我们将这个值从`false`改为`true`。然后，在`data_loop`外部进行测试。如果`done
    == true`，则跳出循环。
- en: 'The final version of the code is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最终版本如下：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our final output from the code is this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从代码中得到的最终输出如下：
- en: '![](img/00032.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: Recursive functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: 'The final form of loop to consider is known as a **recursive function**. This
    is a function that calls itself until a condition is met. In pseudocode, the function
    looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要考虑的循环形式被称为**递归函数**。这是一个在满足条件之前会调用自身的函数。在伪代码中，函数看起来是这样的：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An actual implementation of a recursive function would look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的实际实现看起来是这样的：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The idea of a recursive function is very simple, but we need to consider two
    parts of this code. The first is the `let` line in the `recurse` function and
    what it means:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的想法非常简单，但我们需要考虑这个代码的两个部分。第一部分是`recurse`函数中的`let`行及其含义：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another way of writing this is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种写法如下：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second part is that the semicolon is not being used everywhere. Consider
    the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是分号并不在所有地方使用。考虑以下示例：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What is the difference between having and not having a semicolon?
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有分号和没有分号之间有什么区别？
- en: In Rust, almost everything is an expression. This means that almost everything
    returns a value. One exception is the variable binding statement `let`. In a `let`
    statement, and many others, the ending semicolon is a mandatory part of the syntax.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，几乎一切都是表达式。这意味着几乎每件事都返回一个值。一个例外是变量绑定语句`let`。在`let`语句以及许多其他语句中，结尾的分号是语法的一个强制部分。
- en: 'However, in expressions, the semicolon has a double role: it throws away a
    return value of the expression in addition to allowing further expressions. So
    if the expression is the last in a block, having a semicolon there means that
    the last value is thrown away, and not having a semicolon there means to return
    the last value.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在表达式的情况下，分号有两个作用：它丢弃表达式的返回值，同时允许进一步的语句。所以如果表达式是块中的最后一个，那么在它那里有分号意味着最后一个值被丢弃，而没有分号则意味着返回最后一个值。
- en: 'An example should make it clear:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子，应该会使它变得清楚：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have two different uses of the semicolon. Let''s look at the `let y` line
    first:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 分号有两种不同的用法。让我们首先看看`let y`这一行：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code does the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: The code within the braces is processed
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大括号内的代码将被处理
- en: The final line, without the semicolon, is assigned to `y`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的行，没有分号，被分配给`y`
- en: Essentially, this is considered as an inline function that returns the line
    without the semicolon into the variable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这被视为一个内联函数，它将没有分号的行返回到变量中。
- en: 'The second line to consider is for `z`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑的第二行是关于`z`的：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, the code within the braces is evaluated. In this case, the line ends
    with a semicolon, so the result is thrown away and the empty value `()` gets bound
    to `z`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，大括号内的代码将被评估。在这种情况下，行以分号结尾，因此结果被丢弃，空值`()`被绑定到`z`。
- en: 'When it is executed, we will get the following results:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当它执行时，我们将得到以下结果：
- en: '![](img/00033.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: In the code example, the line within `fn main` calling `recurse` gives the same
    result with or without the semicolon, because the Rust runtime doesn't use `main`'s
    return value for anything.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，`fn main`中调用`recurse`的行，有分号和无分号都会给出相同的结果，因为Rust运行时不使用`main`的返回值做任何事情。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered the different types of loops that are available
    within Rust, as well as gained an understanding of when to use a semicolon and
    what it means to omit it. We have also considered enumeration and iteration over
    a vector and an array and how to handle the data held within them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Rust中可用的不同类型的循环，以及理解何时使用分号以及省略分号意味着什么。我们还考虑了枚举和遍历向量以及数组，以及如何处理它们所包含的数据。
- en: 'In the next chapter, we will see why Rust is a good choice for server applications:
    memory handling.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解为什么 Rust 是服务器应用程序的良好选择：内存管理。
