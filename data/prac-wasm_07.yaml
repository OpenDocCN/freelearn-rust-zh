- en: '*Chapter 5*: Understanding Sections in WebAssembly Modules'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：理解WebAssembly模块中的部分'
- en: A WebAssembly module is composed of zero or more sections. Each section has
    its own functionality. In the previous chapters, we saw how functions are defined
    inside a WebAssembly module. A function is a section inside a WebAssembly module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly模块由零个或多个部分组成。每个部分都有其自身的功能。在前几章中，我们看到了如何在WebAssembly模块内部定义函数。函数是WebAssembly模块内部的一个部分。
- en: 'In this chapter, we will explore the various other sections inside a WebAssembly
    module. Understanding the various sections inside a WebAssembly module will make
    it easier for us to identify, debug, and write efficient WebAssembly modules.
    We will cover the following sections in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨WebAssembly模块内部的各个其他部分。了解WebAssembly模块内部的各个部分将使我们更容易识别、调试和编写高效的WebAssembly模块。在本章中，我们将涵盖以下部分：
- en: Exports and imports
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出和导入
- en: Globals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量
- en: Start
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始
- en: Memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections](https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中存在的代码文件，地址为[https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections](https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections)。
- en: Exports and imports
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出和导入
- en: A WebAssembly module consists of export and import sections. These sections
    are responsible for exporting functions out of and importing functions into the
    WebAssembly module.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly模块由导出和导入部分组成。这些部分负责将函数导出和导入到WebAssembly模块中。
- en: Exports
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出
- en: In order to call the functions defined in a WebAssembly module from JavaScript,
    we need to export the functions from the WebAssembly module. The export section
    is where we will define all the functions that are exported out of the WebAssembly
    module.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从JavaScript中调用WebAssembly模块中定义的函数，我们需要从WebAssembly模块中导出这些函数。导出部分是我们将定义所有从WebAssembly模块导出的函数的地方。
- en: 'Let''s go back to our classic `add.wat` example from the previous chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到前一章中的经典`add.wat`示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have exported the `add` function using the `(export "add" (func $add))`
    statement. To export a function, we have used the `export` keyword followed by
    the name of the function and then the pointer to the exported function itself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`(export "add" (func $add))`语句导出了`add`函数。为了导出一个函数，我们使用了`export`关键字，后跟函数名称，然后是导出函数本身的指针。
- en: 'Remember that WebAssembly is compact-sized. Thus, we can represent the export
    statement along with the function definition itself, like so:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 记住WebAssembly是紧凑型的。因此，我们可以将导出语句及其本身的函数定义一起表示，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s use WABT''s `wat2wasm` tool to convert the WebAssembly text format into
    a WebAssembly module with the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用WABT的`wat2wasm`工具，通过以下命令将WebAssembly文本格式转换为WebAssembly模块：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s analyze the generated byte code using the `hexdump` tool:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`hexdump`工具分析生成的字节码：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As expected, the first byte consists of the magic header and version of the
    binary `00 61 73 6d 01 00 00 00`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，第一个字节是二进制文件的魔术头和版本`00 61 73 6d 01 00 00 00`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next bit is `01`, which represents the section index of the type section.
    Following that, we have the size of the type section, which is `07`. The next
    seven bits are the type section. `01` represents the number of type definitions
    available:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的位是`01`，代表类型部分的索引。随后，我们有类型部分的大小，为`07`。接下来的七个位是类型部分。`01`代表可用的类型定义数量：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we have `60`, which represents `func`. Following that, we have `02`,
    representing the two parameters. `7f` is the opcode for defining the i32 type.
    Since both the parameters are i32, we have consecutive `7f` opcodes. Following
    that, the last two bits represent the return type and there is also `7f` representing
    i32:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`60`，代表`func`。随后，我们有`02`，代表两个参数。`7f`是定义i32类型的操作码。由于两个参数都是i32类型，所以我们有连续的`7f`操作码。随后，最后两个位代表返回类型，还有一个`7f`代表i32：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the `type` section, we have the `func` section. The unique identifier
    for the `func` section is `03`. Following that, we have `02`, which defines the
    size of the function section. That is the size of the function section is just
    2 bits. But we defined the function definition for `add` in the WebAssembly text
    format and the function is more than 2 bits in size. So, how is it possible? The
    reason is that the function section does not have the body of the function; instead,
    it just defines the available functions. The functions are defined in the code
    section. The next `01` defines that there is only one function defined in the
    module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `type` 部分之后，我们有 `func` 部分。`func` 部分的唯一标识符是 `03`。随后是 `02`，它定义了函数部分的大小。这意味着函数部分的大小仅为
    2 位。但我们在 WebAssembly 文本格式中定义了 `add` 的函数定义，而函数的大小超过 2 位。那么这是怎么可能的呢？原因是函数部分没有函数体；相反，它只是定义了可用的函数。函数定义在代码部分。下一个
    `01` 定义了模块中定义了一个函数：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we have the export section, which starts with `07`. The next `07` represents
    the size of the export section. Then, we define the number of exports exported
    in the export section. The next bit represents the length of the exported function
    name. The next `03` bits represent the function name, `add`. Then, the export
    section has the kind of export and function index of the exported function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有导出部分，它以 `07` 开头。下一个 `07` 代表导出部分的大小。然后，我们定义导出部分中导出的数量。下一个位表示导出函数名的长度。接下来的
    `03` 位表示函数名，`add`。然后，导出部分有导出类型和导出函数的索引：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The last segment starts with `0a`. `0a` is a unique identifier for the code
    section. The code section is of length `09`. Next, `01` represents the number
    of functions defined in the code block.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段以 `0a` 开头。`0a` 是代码部分的唯一标识符。代码部分的长度为 `09`。接下来，`01` 代表代码块中定义的函数数量。
- en: 'Next, `07` represents the length of the function definition. The next seven
    bits actually define the function block. `00` indicates that the function block
    does not have any local declarations. `20` is the opcode for `get_local` and we
    take the `00` index, and then again we have `20` opcode to `get_local` and we
    take the `01` index. Then, we add them using `i32.add`. The opcode for the i32
    addition is `6a`. Finally, we use `0b` to end the function code block:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`07` 代表函数定义的长度。接下来的七个位实际上定义了函数块。`00` 表示函数块没有任何局部声明。`20` 是 `get_local` 的操作码，我们使用
    `00` 索引，然后再次使用 `20` 操作码来 `get_local` 并使用 `01` 索引。然后，我们使用 `i32.add` 将它们相加。i32 加法的操作码是
    `6a`。最后，我们使用 `0b` 来结束函数代码块：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have seen how the export section is represented in a WebAssembly module.
    In the next section, let's see how the import section is represented in a WebAssembly
    module.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了导出部分在 WebAssembly 模块中的表示。在下一节中，让我们看看导入部分在 WebAssembly 模块中的表示。
- en: Imports
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入
- en: In order to import a function from another WebAssembly module or JavaScript
    module, we need to import the functions in the WebAssembly module. The import
    section is where we will import all the external dependencies into the WebAssembly
    module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从另一个 WebAssembly 模块或 JavaScript 模块导入一个函数，我们需要在 WebAssembly 模块中导入这些函数。导入部分是我们将所有外部依赖项导入
    WebAssembly 模块的地方。
- en: 'Now, let''s imagine that a JavaScript module exports a function named `jsAdd`.
    We can import the `jsAdd` function using the `import` keyword. Create a file called
    `jsAdd.wat` and add the following content to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一个名为 `jsAdd` 的 JavaScript 模块导出了一个函数。我们可以使用 `import` 关键字导入 `jsAdd` 函数。创建一个名为
    `jsAdd.wat` 的文件，并向其中添加以下内容：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we are defining a function with the `func` keyword, followed by the name
    of the function, `$i`. We use `$i` to call the function inside the WebAssembly
    module. Then, we have the `import` keyword. The `import` keyword is followed by
    the module name. The module name here refers to the JavaScript module, and then
    we have the name of the function to import from the JavaScript module.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `func` 关键字定义了一个函数，后面跟着函数的名称，`$i`。我们使用 `$i` 在 WebAssembly 模块内部调用该函数。然后，我们有了
    `import` 关键字。`import` 关键字后面跟着模块名称。这里的模块名称指的是 JavaScript 模块，然后是我们要从 JavaScript
    模块中导入的函数名称。
- en: Finally, we have `param`. Since a WebAssembly module is typed, we have to define
    the input parameters and return types in the function definition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `param`。由于 WebAssembly 模块是强类型的，我们必须在函数定义中定义输入参数和返回类型。
- en: 'Let''s use WABT''s `wat2wasm` to convert the WebAssembly text format into a
    WebAssembly module with the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 WABT 的 `wat2wasm` 将 WebAssembly 文本格式转换为以下命令的 WebAssembly 模块：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s analyze the generated byte code using the `hexdump` tool:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `hexdump` 工具分析生成的字节码：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The binary consists of the import section, which starts at the index of 16\.
    The import section starts with `02` because the unique section index of the import
    section is `02`. After that, we have `11`, which represents the size of the import
    section in the binary. The next bit represents the number of imports, `01`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件由导入部分组成，从索引 16 开始。导入部分以 `02` 开始，因为导入部分的唯一部分索引是 `02`。之后，我们有 `11`，表示二进制中导入部分的大小。下一个位表示导入的数量，`01`。
- en: 'Then, we have the definition for the import. `07` here represents the length
    of the imported function. The next seven bits represent the name of the import
    module. The next bit represents the length of the function name, `05`, and the
    next five bits represent the function name. Finally, we have the kind and type
    signature of the index:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有导入的定义。`07` 这里表示导入函数的长度。接下来的七个位表示导入模块的名称。下一个位表示函数名称的长度，`05`，接下来的五个位表示函数名称。最后，我们有索引的类型和签名：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, you can call the `jsAdd` function like you would other functions inside
    a WebAssembly module using the `$i` identifier.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像在 WebAssembly 模块内部的其他函数一样使用 `$i` 标识符调用 `jsAdd` 函数。
- en: We have explored how both the import and export sections are defined inside
    a WebAssembly module and how they help to import and export a function. Now, let's
    explore how to import and export values in and out of a WebAssembly module.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何在 WebAssembly 模块内部定义导入和导出部分，以及它们如何帮助导入和导出函数。现在，让我们探讨如何导入和导出 WebAssembly
    模块中的值。
- en: Globals
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: The globals section is where we can import and export values in and out of WebAssembly
    modules. In a WebAssembly module, you can import either mutable or immutable values
    from JavaScript. Additionally, WebAssembly also supports `wasmValue`, an internal
    immutable value inside the WebAssembly module itself.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 全局部分是我们可以在 WebAssembly 模块中导入和导出值的地方。在 WebAssembly 模块中，你可以从 JavaScript 导入可变或不可变值。此外，WebAssembly
    还支持 `wasmValue`，这是 WebAssembly 模块内部的内部不可变值。
- en: 'Let''s create a file called `globals.wat` and add the following contents to
    it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `globals.wat` 的文件，并将以下内容添加到其中：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We created a module (`module`) and three global variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模块（`module`）和三个全局变量：
- en: '`$mutableValue` – This value is imported from the `js` JavaScript module and
    the `mutableGlobal` variable. We also define the global variable to be of the
    `mut i32` type.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$mutableValue` – 这个值是从 `js` JavaScript 模块和 `mutableGlobal` 全局变量导入的。我们还定义全局变量为
    `mut i32` 类型。'
- en: '`$immutableValue` – This value is imported from the `js` JavaScript module
    and the `immutableGlobal` variable. We also define the global variable to be of
    the `i32` type.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$immutableValue` – 这个值是从 `js` JavaScript 模块和 `immutableGlobal` 全局变量导入的。我们还定义全局变量为
    `i32` 类型。'
- en: '`$wasmValue` – This is a global constant. We define the `global` keyword followed
    by the name of the global variable, `$wasmValue`, then the type of `i32`, and
    finally the actual value (`i32.const 10`).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$wasmValue` – 这是一个全局常量。我们定义 `global` 关键字后跟全局变量的名称 `$wasmValue`，然后是 `i32` 类型，最后是实际值（`i32.const
    10`）。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`$wasmValue` is immutable and cannot be exported to the external world.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$wasmValue` 是不可变的，不能导出到外部世界。'
- en: Then, we have a set of functions that helps to get and set the global variables.
    `getWasmValue`, `getImmutableValue`, and `getMutableValue` get the values of the
    `wasmValue` global constant, the `immutableValue` global constant, and the `mutableValue`
    global variable, respectively.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一组帮助获取和设置全局变量的函数。`getWasmValue`、`getImmutableValue` 和 `getMutableValue`
    分别获取 `wasmValue` 全局常量、`immutableValue` 全局常量和 `mutableValue` 全局变量的值。
- en: Finally, a function that sets `mutableValue` to a new value is `setMutableValue`.
    `setMutableValue` takes in `param $v`, which sets the value to `$mutableValue`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个将 `mutableValue` 设置为新值的函数是 `setMutableValue`。`setMutableValue` 接收 `param
    $v` 参数，将值设置为 `$mutableValue`。
- en: 'Let''s use WABT to convert the WebAssembly text format into a WebAssembly module
    with the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WABT 将 WebAssembly 文本格式转换为 WebAssembly 模块，可以使用以下命令：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a `globals.html` with the following content:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 `globals.html` 文件：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's define the `run` function inside `<script>`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `<script>` 标签内定义 `run` 函数。
- en: 'A `WebAssembly.Global` object represents a global variable instance, accessible
    from JavaScript and importable/exportable across one or more `WebAssembly.Module`
    instances. The `WebAssembly.Global` constructor expects a descriptor and value.
    The descriptor defines the type and mutability of the global variable defined:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly.Global`对象代表一个全局变量实例，可以从JavaScript访问，并在一个或多个`WebAssembly.Module`实例之间导入/导出。`WebAssembly.Global`构造函数期望一个描述符和值。描述符定义了全局变量的类型和可变性：'
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This global variable constructor provides an option to dynamically link multiple
    WebAssembly modules.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个全局变量构造函数提供了一个选项，可以动态链接多个WebAssembly模块。
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We create two global values using the `WebAssembly.Global` constructor. They
    are `immutableGlobal` and `mutableGlobal`. The former is `mutable:false`, while
    the latter is `mutable:true`. So, we can change the value of the latter using
    `mutableGlobal.value` but not the former. If we try changing the value of `immutableGlobal`,
    then we will receive an error:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`WebAssembly.Global`构造函数创建两个全局值。它们是`immutableGlobal`和`mutableGlobal`。前者是`mutable:false`，而后者是`mutable:true`。因此，我们可以使用`mutableGlobal.value`更改后者的值，但不能更改前者。如果我们尝试更改`immutableGlobal`的值，我们将收到一个错误：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After that, we fetch the `globals.wasm` WebAssembly module. Then, we instantiate
    `arrayBuffer` with the response and `arrayBuffer` with the `WebAssembly.instantiate`
    constructor. In addition to this, the `WebAssembly.instantiate` constructor accepts
    `importsObject`. We can send the JavaScript module via `importsObject`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们获取`globals.wasm` WebAssembly模块。然后，我们使用响应和`arrayBuffer`以及`WebAssembly.instantiate`构造函数实例化`arrayBuffer`。此外，`WebAssembly.instantiate`构造函数接受`importsObject`。我们可以通过`importsObject`发送JavaScript模块：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, we are sending in the `js` module along with the `mutableGlobal`
    and `immutableGlobal` values. The `wasm` variable now holds the WebAssembly module.
    We invoke `wasm.instance.exports` to get all the exported functions from the WebAssembly
    module:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们发送了`js`模块以及`mutableGlobal`和`immutableGlobal`值。`wasm`变量现在持有WebAssembly模块。我们调用`wasm.instance.exports`以获取WebAssembly模块中所有导出的函数：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`getWasmValue`, `getMutableValue`, `setMutableValue`, and `getImmutableValue`
    are the functions exported from the WebAssembly module.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWasmValue`、`getMutableValue`、`setMutableValue`和`getImmutableValue`是WebAssembly模块导出的函数。'
- en: 'The `getWasmValue` function returns the value of the `wasmValue` inside the
    WebAssembly module:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWasmValue`函数返回WebAssembly模块内`wasmValue`的值：'
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `getMutableValue` and `setMutableValue` functions return and set the `mutableGlobal`
    field defined in JavaScript and passed into the WebAssembly module:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`getMutableValue`和`setMutableValue`函数返回并设置在JavaScript中定义并传递到WebAssembly模块中的`mutableGlobal`字段：'
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we get the immutable value using the `getImmutableValue` function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`getImmutableValue`函数获取不可变值：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s run an example in the browser using the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中使用以下命令运行一个示例：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, launch the URL `http://localhost:8000/globals.html` and open the developer
    tools.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动URL `http://localhost:8000/globals.html`并打开开发者工具。
- en: The WebAssembly binary contains an import section. The import section has a
    unique identifier, `02`, followed by the size of the section, which is `2b` (which
    is 43 in decimal). The next 43 bits represent the import section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly二进制包含一个导入部分。导入部分有一个唯一的标识符`02`，后面是部分的长度，为`2b`（十进制为43）。接下来的43位代表导入部分。
- en: '`02` at the `000015` index represents the number of imports. Then, we have
    two sections that define the imported global functions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`000015`索引处的`02`代表导入的数量。然后，我们有两个部分定义了导入的全局函数：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Each global segment consists of the module string length and the module name,
    followed by the function string length and the function name. Finally, it has
    the kind of import, the type, and the mutability of the variable:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个全局段由模块字符串长度和模块名称组成，接着是函数字符串长度和函数名称。最后，它包含导入的类型、变量类型和可变性：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After that, we have the `Global` section. The `Global` section has the unique
    section ID of `6`. The next bit defines the size of the `Global` section, which
    is `06`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有`Global`部分。`Global`部分具有唯一的部分ID `6`。下一个位定义了`Global`部分的大小，为`06`。
- en: 'After that, we have the number of globals available. The number of globals
    is `01`. This is because the other two globals are imported. The type, mutability,
    and value are the next 4 bytes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有可用的全局变量数量。全局变量的数量是`01`。这是因为其他两个全局变量被导入。类型、可变性和值是接下来的4个字节：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first `function` body inside the code section looks as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码部分内的第一个`function`体如下所示：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`function` is four bits in length. The first `00` says that the function has
    no local declaration. The next `23` is the opcode for getting the global value.
    The next `02` defines the index of the global value. Even though the preceding
    global section specifies there is only one global value, the entire module takes
    the imported globals into account. Since there are two imported global values,
    we index the local global values after the imported global value. So, the `$wasmValue`
    global has an index of 3\. Finally, we end the function code with the `0b` opcode.
    Similarly, the second and third function bodies define how we get the other two
    imported global values:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`function` 的长度为四位。前两位 `00` 表示该函数没有局部声明。接下来的 `23` 是获取全局值的操作码。接下来的 `02` 定义了全局值的索引。尽管前面的全局部分指定只有一个全局值，但整个模块会考虑导入的全局值。由于有两个导入的全局值，我们在导入的全局值之后索引局部全局值。因此，`$wasmValue`
    全局值的索引为 3。最后，我们使用 `0b` 操作码结束函数代码。同样，第二个和第三个函数体定义了如何获取其他两个导入的全局值：'
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In function body 4, we set the global value using `global.set`, which has an
    opcode of `24`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体 4 中，我们使用 `global.set` 设置全局值，其操作码为 `24`。
- en: We have explored how to import and export values in and out of WebAssembly modules.
    Now, let's explore the special `start` function in the WebAssembly module.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何在 WebAssembly 模块中导入和导出值。现在，让我们探索 WebAssembly 模块中的特殊 `start` 函数。
- en: Start
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 起始
- en: 'Start is a special function that runs after the WebAssembly module is initialized.
    Let''s take the same example that we used for the globals. We add the following
    content to `globals.wat`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Start 是一个特殊函数，它在 WebAssembly 模块初始化后运行。让我们使用与全局变量相同的示例。我们将以下内容添加到 `globals.wat`
    文件中：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We define the `initMutableValue` function, which sets `mutableValue` to `200`.
    After that, we add a start block, which starts with `startkeyword` followed by
    the name of the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `initMutableValue` 函数，该函数将 `mutableValue` 设置为 `200`。之后，我们添加一个起始块，该块以 `startkeyword`
    开头，后跟函数的名称。
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The function referenced at the start should not return any value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在起始处引用的函数不应返回任何值。
- en: 'Let''s use WABT to convert the WebAssembly text format into a WebAssembly module
    with the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 WABT 将 WebAssembly 文本格式转换为 WebAssembly 模块，以下命令：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s run the example in a browser using the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在浏览器中运行示例：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, launch the URL `http://localhost:8000/globals.html` and open the developer
    tools.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动 URL `http://localhost:8000/globals.html` 并打开开发者工具。
- en: The start function is similar to other functions, except that it is not classified
    into any type. The types may or may not be initialized at the time of the function.
    The start section of a WebAssembly module points to a function index (the index
    of the location of the function section inside the function component).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 起始函数与其他函数类似，但它们没有被分类到任何类型中。类型可能在函数初始化时初始化，也可能不初始化。WebAssembly 模块的起始部分指向一个函数索引（函数部分在函数组件内的位置索引）。
- en: 'The section ID of the start function is `8`. When decoded, the start function
    represents the start component of the module:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 起始函数的节 ID 为 `8`。解码后，起始函数表示模块的起始组件：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At this moment, tools such as webpack do not support the `start` function. The
    start section is rewritten into a normal function and then the function is invoked
    when the JavaScript is initialized by the bundler itself.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，工具如 webpack 不支持 `start` 函数。起始部分被重写为一个普通函数，然后当打包器本身初始化 JavaScript 时调用该函数。
- en: '`start` is an interesting and useful function that enables setting up some
    values when the module is initialized to prevent unnecessary side effects that
    the module might cause. Now, let''s explore the memory section. The memory section
    is responsible for transferring memory between JavaScript and WebAssembly.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 是一个有趣且有用的函数，它允许在模块初始化时设置一些值，以防止模块可能引起的不必要的副作用。现在，让我们探索内存部分。内存部分负责在
    JavaScript 和 WebAssembly 之间传输内存。'
- en: Memory
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存
- en: Transferring data between JavaScript and WebAssembly is an expensive operation.
    In order to reduce the transfer of data between JavaScript and WebAssembly modules,
    WebAssembly uses `sharedArrayBuffer`. With `sharedArrayBuffer` both the JavaScript
    and WebAssembly modules can access the same memory and use it to share the data
    from one to the other.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 和 WebAssembly 之间传输数据是一个昂贵的操作。为了减少 JavaScript 和 WebAssembly 模块之间的数据传输，WebAssembly
    使用 `sharedArrayBuffer`。使用 `sharedArrayBuffer`，JavaScript 和 WebAssembly 模块都可以访问相同的内存，并使用它来在两者之间共享数据。
- en: The memory section of a WebAssembly module is a vector of linear memories. The
    linear memory model is a memory addressing technique in which the memory is organized
    in a single contiguous address space. It is also known as a flat memory model.
    The linear memory model makes it easier to understand, program, and represent
    the memory. But the linear memory model comes with a huge disadvantage of high
    execution time for rearranging elements in the memory and the wastage of memory
    space. Here, the memory represents a vector of raw bytes of uninterpreted data.
    They use resizable array buffers to hold the raw bytes of memory. We use `sharedArrayBuffers`
    for defining and maintaining this memory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 模块的内存部分是一个线性内存的向量。线性内存模型是一种内存寻址技术，其中内存组织在一个单一的连续地址空间中。它也被称为平面内存模型。线性内存模型使得理解、编程和表示内存变得更加容易。但是，线性内存模型存在一个巨大的缺点，即内存中元素重新排列的执行时间很高，并且会浪费内存空间。在这里，内存代表了一个未解释数据的原始字节的向量。它们使用可调整大小的数组缓冲区来存储内存的原始字节。我们使用
    `sharedArrayBuffers` 来定义和维护这个内存。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that this memory is accessible and mutable by JavaScript
    and WebAssembly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这个内存可以通过 JavaScript 和 WebAssembly 访问和修改。
- en: 'We allocate the memory using the `WebAssembly.Memory()` constructor. The constructor
    can accept an argument that defines the initial and maximum value of memory, like
    so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `WebAssembly.Memory()` 构造函数来分配内存。构造函数可以接受一个参数，用于定义内存的初始值和最大值，如下所示：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we define that `WebAssembly.Memory` has an initial memory of `10` and
    a maximum memory of `100`. Then, we instantiate the WebAssembly module with the
    following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义 `WebAssembly.Memory` 具有初始内存 `10` 和最大内存 `100`。然后，我们使用以下代码实例化 WebAssembly
    模块：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Similar to the global example, here we are passing `importObject`, which takes
    in the `js` module and the memory object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与全局示例类似，这里我们传递 `importObject`，它接受 `js` 模块和内存对象。
- en: 'Let''s create a new file called `memory.wat` and add the following content
    to it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `memory.wat` 的新文件，并将以下内容添加到其中：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Inside the module, we import the memory from the `js` module with the name memory.
    After that, we define a function sum and export the function outside the module.
    The function accepts two parameters as arguments and returns an i32 as an output.
    The first parameter is named `$ptr`. It is a pointer to the index of where the
    value is present in `sharedArrayBuffer`. The next argument is `$len`, which defines
    the length of the shared memory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内部，我们使用名为 `memory` 的名称从 `js` 模块导入内存。之后，我们定义一个名为 sum 的函数并将该函数导出至模块外部。该函数接受两个参数作为输入，并返回一个
    i32 类型的输出。第一个参数命名为 `$ptr`，它是一个指向 `sharedArrayBuffer` 中值所在索引的指针。下一个参数是 `$len`，它定义了共享内存的长度。
- en: Then, we create two local variables, `$end` and `$sum`. First, we set `$end`
    to the value of `$ptr` plus four times the value of `$len`. Then, we create a
    block and start a loop. The loop ends when the value of `$end` is equal to the
    value of `$ptr`. We then set the value of `$sum` by adding the existing value
    of `$sum` with the value of `$ptr`. Then, we increment `$ptr` to the next value.
    Finally, we exit the loop and return `$sum`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建两个局部变量，`$end` 和 `$sum`。首先，我们将 `$end` 设置为 `$ptr` 加上 `$len` 的四倍值。然后，我们创建一个块并开始一个循环。循环在
    `$end` 的值等于 `$ptr` 的值时结束。然后，我们将 `$sum` 的值通过将现有的 `$sum` 值与 `$ptr` 的值相加来设置。然后，我们将
    `$ptr` 增加到下一个值。最后，我们退出循环并返回 `$sum`。
- en: 'The previous code is analogous to the following in JavaScript:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码与 JavaScript 中的以下代码类似：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s go back to `memory.html` and initialize the buffer:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `memory.html` 并初始化缓冲区：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We create an unsigned array using `Uint32Array` using the memory object we
    created. Then, we populate the array buffer with the cube of numbers from 1 to
    50:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Uint32Array` 和我们创建的内存对象创建一个无符号数组。然后，我们将从 1 到 50 的数字的立方填充到数组缓冲区中：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, we call the sum inside the WebAssembly module and ask it to provide
    the sum of all the cubic numbers in the shared array buffer starting at 0 up to
    the length of 50.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 WebAssembly 模块内部调用 sum 函数，并要求它提供从 0 开始到长度为 50 的共享数组缓冲区中所有立方数的总和。
- en: 'Let''s use WABT to convert the WebAssembly text format into a WebAssembly module
    with the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 WABT 将 WebAssembly 文本格式转换为 WebAssembly 模块，使用以下命令：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s run an example in the browser using the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中使用以下命令运行一个示例：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, launch the URL `http://localhost:8000/globals.html` and open the developer
    tools.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动 URL `http://localhost:8000/globals.html` 并打开开发者工具。
- en: Memory sections are very useful when we have to transfer a large amount of data
    between two worlds. The memory sections make it easier to define, share, and access
    memory between the WebAssembly and JavaScript world.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在两个世界之间传输大量数据时，内存部分非常有用。内存部分使得在 WebAssembly 和 JavaScript 世界之间定义、共享和访问内存变得更加容易。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the import, export, start, and memory sections
    in a WebAssembly module. We saw how they are structured and defined inside a WebAssembly
    module. Each of these sections carries one specific function and it is essential
    to understand, analyze, and debug the WebAssembly modules. In the next chapter,
    we will explore Binaryen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 WebAssembly 模块中的导入、导出、启动和内存部分。我们看到了它们在 WebAssembly 模块中的结构和定义方式。每个部分都承载着一个特定的功能，理解、分析和调试
    WebAssembly 模块时，这些部分是至关重要的。在下一章中，我们将探索 Binaryen。
