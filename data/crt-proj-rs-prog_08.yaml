- en: Using a Parser Combinator for Interpreting and Compiling
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解析器组合进行解释和编译
- en: Rust is a system programming language. A typical task of system programming
    is processing *formal languages*. Formal languages are languages specified by
    well-defined logical rules and used everywhere in computer technology. They can
    be broadly classified into command, programming, and markup languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust是一种系统编程语言。系统编程的典型任务之一是处理*形式语言*。形式语言是由良好定义的逻辑规则指定的语言，在计算机技术的各个方面都得到广泛应用。它们可以广泛地分为命令、编程和标记语言。
- en: To process formal languages, the first step is to parse. **Parsing **means analyzing
    the grammatical structure of a piece of code to check whether it respects the
    rules of the grammar it is supposed to use, and then, if the grammar is respected,
    to generate a data structure that describes the structure of the parsed piece
    of code, in a way that such code can be further processed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理形式语言，第一步是解析。**解析**意味着分析一段代码的语法结构，以检查它是否遵守其应使用的语法规则，然后，如果语法得到遵守，生成一个描述解析代码片段结构的数据库结构，以便进一步处理该代码。
- en: In this chapter, we will see how to process text written in a formal language,
    starting from the parsing step and proceeding with several possible outcomes—simply
    checking the grammar, interpreting a program, and translating a program into the
    Rust language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何处理用形式语言编写的文本，从解析步骤开始，并继续进行几个可能的输出——简单地检查语法、解释程序以及将程序翻译成Rust语言。
- en: To show such features, an extremely simple programming language will be defined,
    and four tools (syntax checker, semantic checker, interpreter, and translator)
    will be built around it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这些特性，将定义一种极其简单的编程语言，并围绕它构建四个工具（语法检查器、语义检查器、解释器和翻译器）。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: Defining a programming language using a formal grammar
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形式语法定义编程语言
- en: Classifying programming languages into three categories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编程语言分为三类
- en: Learning two popular techniques for building parsers—compiler-compilers and
    parser combinators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习构建解析器的两种流行技术——编译器编译器和解析器组合器
- en: Using a parser combinator library for Rust named **Nom**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用名为**Nom**的Rust解析器组合库
- en: Processing a source code to check its syntax following a **context-free grammar**,
    using the Nom library (`calc_parser`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Nom库根据**上下文无关语法**处理源代码以检查其语法（`calc_parser`）
- en: Verifying the consistency of variable declarations and their usage in some source
    code, and at the same time preparing the required structure for optimal execution
    of the code (`calc_analyzer`)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证变量声明及其在某些源代码中的使用的一致性，同时为代码的最佳执行准备所需的结构（`calc_analyzer`）
- en: Executing the preprocessed code, in a process named **inter****pretation** (`calc_interpreter`)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行预处理代码，在名为**解释**（`calc_interpreter`）的过程中
- en: Translating the preprocessed code into another programming language, in a process
    named **compilation **(`calc_compiler`); as an example, translation to Rust code
    will be shown
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将预处理代码翻译成另一种编程语言，在名为**编译**（`calc_compiler`）的过程中；例如，将翻译成Rust代码
- en: After reading this chapter, you will be able to write the grammar for a simple formal
    language or understand the grammar for an existing formal language. You will also
    be able to write an interpreter for any programming language by following its
    grammar. Also, you will be able to write a translator for a formal language into
    another formal language, following their grammar.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你将能够编写简单形式语言的语法或理解现有形式语言的语法。你还将能够通过遵循其语法编写任何编程语言的解释器。此外，你还将能够编写将一种形式语言翻译成另一种形式语言的翻译器，遵循它们的语法。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To read this chapter, knowledge of the preceding chapters is not required. Some
    knowledge of formal language theory and techniques is useful but not required,
    because the required knowledge will be explained in this chapter. The Nom library
    will be used to build such tools, and so it will be described in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章内容，不需要了解前几章的知识。对形式语言理论和技术的了解有帮助但不是必需的，因为所需的知识将在本章中解释。将使用Nom库来构建此类工具，因此它将在本章中描述。
- en: The complete source code for this chapter is in the `Chapter08` folder of the
    GitHub repository, located at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码位于GitHub仓库的`Chapter08`文件夹中，网址为[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)。
- en: Project overview
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'In this chapter, we will build four projects of increasing complexity, listed
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建四个递增复杂性的项目，如下所示：
- en: The first project (`calc_parser`) will just be a syntax checker for the `Calc`
    language. Actually, it is just a parser, followed by a formatted debugging print of
    the parsing result.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个项目（`calc_parser`）将仅是`Calc`语言的语法检查器。实际上，它只是一个解析器，随后是对解析结果的格式化调试打印。
- en: The second project (`calc_analyzer`) uses the parsing result of the first project
    to add the verification of the consistency of the variable declarations and of
    their usage, followed by a formatted debugging print of the analysis result.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个项目（`calc_analyzer`）使用第一个项目的解析结果来验证变量声明的完整性和使用的一致性，然后以格式化的调试打印分析结果。
- en: The third project (`calc_interpreter`) uses the analysis result to execute the
    preprocessed code, in an interactive interpreter.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个项目（`calc_interpreter`）使用分析结果在交互式解释器中执行预处理后的代码。
- en: The fourth project (`calc_compiler`) uses the analysis result again to translate
    the preprocessed code into equivalent Rust code.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个项目（`calc_compiler`）再次使用分析结果将预处理后的代码翻译成等效的Rust代码。
- en: Introducing Calc
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Calc
- en: 'To make the following explanations, we will first define a *toy* programming
    language that we will name `Calc` (from the calculator). A toy programming language is
    a programming language used to demonstrate or prove something, not designed to
    develop real-world software. A simple program written in `Calc` is shown as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使以下解释更加清晰，我们首先定义一个*玩具*编程语言，我们将称之为`Calc`（来自计算器）。玩具编程语言是一种用于演示或证明某事的编程语言，不是用于开发现实世界软件的。以下是一个用`Calc`编写的简单程序示例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding program asks the user to type two numbers and then prints the
    sum and the product of those numbers on the console. Let''s examine one statement
    at a time, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序要求用户输入两个数字，然后在控制台上打印这些数字的和与积。让我们逐个语句进行分析，如下所示：
- en: The first two statements (`@first` and `@second`) declare two variables. Any
    variable in `Calc` represents a 64-bit floating-point number.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个语句（`@first`和`@second`）声明了两个变量。`Calc`中的任何变量都代表一个64位浮点数。
- en: The third and fourth statements (`> first` and `> second`) are input statements.
    Each of these prints a question mark and waits for the user to type a number and
    press *Enter*. Such a number, if valid, is stored in the specified variable. If
    no number or an invalid number is typed before pressing *Enter*, the value `0` is
    assigned to the variable.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三和第四个语句（`> first`和`> second`）是输入语句。每个语句都会打印一个问号，等待用户输入一个数字并按*Enter*键。如果按*Enter*键之前没有输入数字或输入了无效的数字，则将值`0`赋给变量。
- en: The fifth statement declares the `sum` variable.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个语句声明了`sum`变量。
- en: The sixth statement (`sum := first + second`) is a Pascal-style assignment.
    It computes the sum of the `first` and `second` variables and assigns the result
    to the `sum` variable.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六个语句（`sum := first + second`）是一个帕斯卡风格的赋值语句。它计算`first`和`second`变量的和，并将结果赋值给`sum`变量。
- en: The seventh and eight statements perform output. The seventh statement (`< sum`)
    prints on the console the current value of the `sum` variable. The eighth statement
    (`< first * second`) computes the multiplication between the current values of
    the `first` and `second` variables, and then prints on the console the result
    of such multiplication.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第七和第八个语句执行输出。第七个语句（`< sum`）在控制台上打印`sum`变量的当前值。第八个语句（`< first * second`）计算`first`和`second`变量的当前值的乘积，然后在控制台上打印这种乘积的结果。
- en: 'The `Calc` language has two other operators—`-` (minus) and `/` (divide)— to
    specify subtraction and division, respectively. In addition, the following code
    shows that the operations can be combined in expressions, and so these are valid
    assignment statements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calc`语言有两个其他运算符——`-`（减号）和`/`（除号）——分别用于指定减法和除法。此外，以下代码显示操作可以在表达式中组合，因此这些是有效的赋值语句：'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Operations are performed left to right, but multiplication and division have
    higher precedence than addition and subtraction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 操作是从左到右执行的，但乘法和除法的优先级高于加法和减法。
- en: 'In addition to variables, numeric literals are also allowed. So, you can write
    the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了变量之外，还允许使用数值字面量。因此，你可以编写以下代码：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This statement assigns `22.1` to `a`, as multiplication is performed before
    addition. To force different precedence, parentheses are allowed, as illustrated
    in the following code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句将`22.1`赋值给`a`，因为在执行加法之前会先执行乘法。为了强制不同的优先级，允许使用括号，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code snippet assigns `30.5` to `a`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将`30.5`赋值给`a`。
- en: 'In the preceding code snippet, there are no characters that separate a statement
    from the next one, in addition to the newline characters. Actually, the `Calc`
    language has no symbols used to separate statements, and also, it does not need
    them. So, the first program should be equivalent to this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，除了换行符之外，没有字符将一个语句与下一个语句分开。实际上，`Calc`语言没有用于分隔语句的符号，而且它也不需要这些符号。因此，第一个程序应该等同于以下内容：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code snippet, there is no ambiguity because the `@` character
    marks the start of a declaration, the `>` character marks the start of an input
    operation, the `<` character marks the start of an output operation, and a variable
    in a location where the current statement does not allow a variable marks the
    start of an assignment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，没有歧义，因为`@`字符标记了声明的开始，`>`字符标记了输入操作的开始，`<`字符标记了输出操作的开始，而在当前语句不允许变量的位置上的变量标记了赋值的开始。
- en: 'To understand this syntax, some grammatical terms must be explained, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这种语法，必须解释一些语法术语，如下所述：
- en: The whole text is a **program**.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个文本是一个**程序**。
- en: Any program is a sequence of **statements**. In the first example program, there
    is exactly one statement for each line.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何程序都是一系列**语句**。在第一个示例程序中，每一行恰好有一个语句。
- en: In some statements, there can be an arithmetic formula that can be evaluated,
    such as `a * 3 + 2`. This formula is an **expression**.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些语句中，可能有一个可以评估的算术公式，例如`a * 3 + 2`。这个公式是一个**表达式**。
- en: Any expression can contain sums or subtractions of simpler expressions. The
    simpler expressions that contain neither sums nor subtractions are named **terms**.
    Therefore, any expression can be a term (if it contains neither sums nor subtractions),
    or it can be the sum of an expression and a term, or it can be the subtraction
    of an expression and a term.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何表达式都可以包含更简单表达式的和或差。不包含和或差的简单表达式被称为**项**。因此，任何表达式都可以是一个项（如果它不包含和或差），或者它可以是表达式和项的和，或者它可以是表达式和项的差。
- en: 'Any term can contain multiplications or divisions of simpler expressions. The
    simpler expressions that contain neither multiplications nor divisions are named **factors**.
    Therefore, any term can be a factor (if it contains neither multiplications nor
    divisions), or it can be the multiplication of a term and a factor, or it can
    be the division of a term and a factor. There are three possible kinds of factors,
    listed here:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何项都可以包含更简单表达式的乘法或除法。不包含乘法或除法的简单表达式被称为**因子**。因此，任何项都可以是一个因子（如果它不包含乘法或除法），或者它可以是项和因子的乘积，或者它可以是项和因子的除法。以下列出了三种可能的因子类型：
- en: Names of variables, named **identifiers**
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的名称，称为**标识符**
- en: Numerical constants, represented by sequences of digits, named **literals**
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值常数，由数字序列表示，称为**字面量**
- en: Full expressions enclosed in parentheses, to force their precedence
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号内的完整表达式，以强制它们的优先级
- en: In the `Calc` language, for the sake of simplicity and unlike in most programming
    languages, digits and underscores are not allowed in identifiers. So, any identifier
    is a non-empty sequence of letters. Or, put another way, any identifier can be
    a letter or an identifier followed by a letter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Calc`语言中，为了简单起见，并且与大多数编程语言不同，标识符中不允许使用数字和下划线。因此，任何标识符都是一个非空字母序列。或者换句话说，任何标识符可以是一个字母，或者是一个字母后跟一个标识符。
- en: 'The syntax of formal languages can be specified by a notation that is known
    as **Backus–Naur** form. Using this notation, our `Calc` language can be specified
    by the following rules:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 形式语言的语法可以通过称为**巴科斯-诺尔**形式的符号来指定。使用这种符号，我们的`Calc`语言可以通过以下规则来指定：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The explanation for all the rules used in the preceding code snippet is described
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段中使用的所有规则的说明如下：
- en: The first rule specifies that a program is an empty string or a program followed
    by a statement. This amounts to saying that a program is a list of zero or more
    statements.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条规则规定，一个程序是一个空字符串或一个程序后跟一个语句。这相当于说，一个程序是一系列零个或多个语句。
- en: The second rule specifies that a statement is either a `@` character followed
    by an identifier, a `>` character followed by an identifier, a `<` character followed
    by an expression, or an identifier followed by the `:=` pair of characters and
    then by an expression.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条规则规定，一个语句要么是一个 `@` 字符后跟一个标识符，要么是一个 `>` 字符后跟一个标识符，要么是一个 `<` 字符后跟一个表达式，或者是一个标识符后跟
    `:=` 字符对，然后是一个表达式。
- en: The third rule specifies that an expression is either a term or an expression
    followed by the `+` character and a term, or an expression followed by the `-` character and
    a term. This amounts to saying that an expression is a term followed by zero or
    more term items, where a term-item is a `+` or a `-` operator followed by a term.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三条规则规定，一个表达式要么是一个项，要么是一个项后跟一个 `+` 字符和一个项，或者是一个表达式后跟一个 `-` 字符和一个项。这相当于说，一个表达式是一个项后跟零个或多个项项，其中项项是一个
    `+` 或 `-` 操作符后跟一个项。
- en: Similarly, the fourth rule specifies that a term is either a factor or a term
    followed by the `*` character and a factor, or a term followed by the `/` character and
    a factor. This amounts to saying that a term is a factor followed by zero or more
    factor items, where a factor-item is a multiply or a divide operator followed
    by a factor.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，第四条规则规定，一个项要么是一个因子，要么是一个项后跟一个 `*` 字符和一个因子，或者是一个项后跟一个 `/` 字符和一个因子。这相当于说，一个项是一个因子后跟零个或多个因子项，其中因子项是一个乘法或除法操作符后跟一个因子。
- en: The fifth rule specifies that a factor is either an identifier or a literal,
    or an expression enclosed in parentheses. This rule is satisfied only if the parentheses
    are correctly paired in code.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五条规则规定，一个因子要么是一个标识符或一个文字面量，要么是一个括号内的表达式。只有当括号在代码中正确配对时，此规则才成立。
- en: The sixth rule specifies that an identifier is a letter or an identifier followed
    by a letter. This amounts to saying that an identifier is a sequence of one or
    more letters. This syntax does not specify how case-sensitiveness is handled,
    but we will assume identifiers are case-sensitive.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六条规则规定，一个标识符是一个字母或一个标识符后跟一个字母。这相当于说，一个标识符是一系列一个或多个字母。此语法没有指定如何处理大小写敏感性，但我们将假设标识符是大小写敏感的。
- en: 'This syntax leaves undefined what is meant by the `<letter>` symbol and by
    the `<literal>` symbol, therefore these are explained here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法未定义 `<letter>` 符号和 `<literal>` 符号的意思，因此在这里进行解释：
- en: The `<letter>` symbol means any character for which the `is_alphabetic` Rust
    standard library function returns `true`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<letter>` 符号表示任何 `is_alphabetic` Rust 标准库函数返回 `true` 的字符。'
- en: The `<literal>` symbol means any floating-point number. In fact, as we are going
    to use Rust code to parse it, store it, and handle it, the `Calc` definition of
    `literal` is the same as the Rust definition of `f64` literals. For example `-4.56e300`
    will be allowed, but `1_000` and `3f64` will not be allowed.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<literal>` 符号表示任何浮点数。实际上，由于我们将使用 Rust 代码来解析、存储和处理它，`Calc` 对 `literal` 的定义与
    Rust 对 `f64` 文字面量的定义相同。例如 `-4.56e300` 将被允许，但 `1_000` 和 `3f64` 将不被允许。'
- en: Another simplification has been done regarding white spaces. Spaces, tabs, and
    newline characters are allowed in all positions of code, except inside an identifier,
    inside a literal, and inside the `:=` symbol. They are optional, but the only
    position where white space is required is between the ending identifier of a statement
    and the beginning identifier of an assignment because, otherwise, the two identifiers
    would merge into one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于空白符，已经进行了简化。空白符、制表符和换行符在代码的所有位置都是允许的，除了在标识符内、在文字面量内和在 `:=` 符号内。它们是可选的，但唯一需要空白符的位置是在语句的结束标识符和赋值的开始标识符之间，因为否则这两个标识符将合并成一个。
- en: In this section, we have defined the syntax of the `Calc` language. Such a formal
    definition is called a **grammar**. It is a very simple grammar, but it is similar
    to the grammar of real-world programming languages. Having a formal grammar for
    a language is useful for building software that processes code written in such
    a language.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们定义了`Calc`语言的语法。这样的形式定义被称为**语法**。这是一个非常简单的语法，但它与现实世界编程语言的语法相似。为一种语言拥有形式语法对于构建处理用这种语言编写的代码的软件是有用的。
- en: Now that we have seen our toy language, we are ready to process code written
    in it. The first task is to build a syntax checker that verifies the structural
    validity of any program in this language.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了我们的玩具语言，我们准备好处理用这种语言编写的代码了。第一个任务是构建一个语法检查器，用于验证该语言中任何程序的结构的有效性。
- en: Understanding formal languages and their parsers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解形式语言及其解析器
- en: 'As we''ve seen, a typical task of system programming is processing *formal
    languages*. Several kinds of operations are customarily performed in such formal
    languages. The most typical ones are listed here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，系统编程的典型任务之一是处理**形式语言**。在这样的一些形式语言中，通常执行几种操作。这里列出了其中最典型的：
- en: To check the syntax validity of a line or of a file
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查一行或文件的语法有效性
- en: To format a file according to formatting rules
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据格式规则格式化文件
- en: To execute a command written in a command language
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行用命令语言编写的命令
- en: To interpret a file written in a programming language—that is, execute it immediately
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释用编程语言编写的文件——即立即执行它
- en: To compile a file written in a programming language—that is, translate it into
    another programming language, such as an assembly language or a machine language
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用编程语言编写的文件编译成另一种编程语言——即将其翻译成汇编语言或机器语言
- en: To translate a markup file into another markup language
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标记文件转换为另一种标记语言
- en: To render a markup file in a browser
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中渲染标记文件
- en: 'All these operations have in common the first step of the procedure—parsing. The
    process of examining a string to extract its structure according to the grammar
    is called **parsing**. There are at least three kinds of possible parsing techniques,
    according to the category of the formal language we want to parse. These categories,
    which we are going to see in this section, are: **regular languages**, **context-free
    languages**, and **context-dependent languages**.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都有共同的第一步——解析。检查一个字符串以根据语法提取其结构的过程称为**解析**。根据我们想要解析的形式语言的类别，至少有三种可能的解析技术。我们将在本节中看到这些类别：**正则语言**、**上下文无关语言**和**上下文相关语言**。
- en: Regular languages
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则语言
- en: The category of the simplest languages is that of regular languages, which can
    be defined using regular expressions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单语言的类别是正则语言，它可以使用正则表达式来定义。
- en: 'In the simplest way, a regular expression is a pattern using the following
    operators between substrings:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以最简单的方式，正则表达式是使用以下运算符在子字符串之间创建的模式：
- en: '**Concatenation** **(or sequence)**: This means that a substring must follow
    another substring; for example, `ab` means that `b` must follow `a`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接** **（或序列）**：这意味着一个子字符串必须跟随另一个子字符串；例如，`ab`意味着`b`必须跟随`a`。'
- en: '**Alternation** **(or choice)**: This means that a substring can be used instead
    of another substring; for example, `a|b` means that `a` or `b` can be used alternatively.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交替** **（或选择）**：这意味着一个子字符串可以用另一个子字符串代替；例如，`a|b`意味着`a`或`b`可以交替使用。'
- en: '**Kleene star** **(or repetition)**: This means that a substring can be used
    zero or more times; for example, `a*` means that `a` can be used zero, one, two,
    or more times.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kleene星号** **（或重复）**：这意味着一个子字符串可以使用零次或多次；例如，`a*`意味着`a`可以使用零次、一次、两次或更多次。'
- en: 'To apply such operators, parentheses can be used. So, the following is a regular
    expression:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的运算符时，可以使用括号。因此，以下是一个正则表达式：
- en: '*a(bcd|(ef)*)g*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*a(bcd|(ef)*)g*'
- en: 'This means that a valid string must begin with an *a*, followed by two possible
    substrings— one is the string *bcd* and the other is an empty string or the string *ef*,
    or any multiple repetitions of the string *ef,* and then, there must be *g*. The
    following are some strings belonging to such regular languages:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个有效的字符串必须以一个*a*开头，后面跟着两个可能的子字符串——一个是字符串*bcd*，另一个是空字符串或字符串*ef*，或者字符串*ef*的任何多次重复，然后必须有*g*。以下是一些属于这种正则语言的字符串：
- en: '*abcdg*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*abcdg*'
- en: '*ag*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ag*'
- en: '*aefg*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*aefg*'
- en: '*aefefg*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*aefefg*'
- en: '*aefefefg*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*aefefefg*'
- en: '*aefefefefg*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*aefefefefg*'
- en: An advantage of regular languages is that their parsing requires an amount of
    memory that depends only on the grammar and does not depend on the text being
    parsed; so, typically, they require little memory even to parse huge texts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正则语言的一个优点是它们的解析所需的内存量仅取决于语法，而不取决于正在解析的文本；因此，通常它们即使解析巨大的文本也只需要很少的内存。
- en: The regex crate is the most popular way to parse regular languages using regular
    expressions. If you have regular languages to parse, then it is recommended to
    use such a library. For example, detecting a valid identifier or a valid floating-point
    number is a regular language parser's job.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式crate是使用正则表达式解析正则语言的最受欢迎的方法。如果您有正则语言要解析，那么建议使用这样的库。例如，检测一个有效的标识符或一个有效的浮点数是正则语言解析器的任务。
- en: Context-free languages
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文无关语言
- en: Since programming languages are not simply regular languages, regular expressions
    cannot be used to parse them. A typical language feature that does not belong
    to regular languages is the use of parentheses. Most programming languages allow
    the `((5))` string but not the `((5)` string because any open parenthesis must
    be matched by a closing parenthesis. Such a rule cannot be expressed by a regular
    expression.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编程语言不是简单的正则语言，因此不能使用正则表达式来解析它们。不属于正则语言的典型语言特性是括号的使用。大多数编程语言允许使用`((5))`字符串，但不允许使用`((5)`字符串，因为任何开括号都必须由一个闭括号匹配。这样的规则不能用正则表达式表示。
- en: A more general (and so more powerful) category of languages is that of context-free
    languages. These languages are defined by grammar, as with the one seen in the
    preceding section on the `Calc` language, including the fact that some elements
    must be matched (such as parentheses, brackets, braces, and quotes).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般（因此更强大）的语言类别是上下文无关语言。这些语言由语法定义，就像在前一节关于`Calc`语言的章节中看到的那样，包括某些元素必须匹配的事实（例如括号、方括号、花括号和引号）。
- en: Differing from regular languages, context-free languages require a variable
    amount of memory depending on the parsed text. Every time an open parenthesis
    is encountered, it must be stored somewhere to match it with the corresponding
    closed parentheses. Although such memory usage is usually quite small and it is
    accessed in a **Last-In-First-Out** (**LIFO**) fashion (as it would be in a stack
    data structure), it is quite efficient because no heap allocation is required.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与正则语言不同，上下文无关语言所需的内存量取决于解析的文本。每次遇到一个开括号时，它必须被存储起来以匹配相应的闭括号。尽管这种内存使用通常相当小，并且以**后进先出**（**LIFO**）的方式访问（就像在堆栈数据结构中一样），但它非常高效，因为不需要堆分配。
- en: Even context-free languages are enough for real-world usage, though, because
    real-world languages need to be context-dependent, as explained in the following
    section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使是上下文无关语言也足以用于现实世界的应用，因为现实世界的语言需要是上下文相关的，如下一节所述。
- en: Context-dependent languages
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文相关语言
- en: Unfortunately, even CFGs are not powerful enough to represent real-world programming
    languages. The problem lies in the usage of identifiers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使是上下文无关文法（CFGs）也不足以表示现实世界的编程语言。问题在于标识符的使用。
- en: In many programming languages, before using a variable, you must declare it.
    In any location of the code, only the variables defined up to that point can be
    used. Such a set of available identifiers is taken as the context in which the
    next statement is parsed. In many programming languages, such a context contains
    not only the name of the variable but also its type, and the fact that it surely
    has already received a value or it may be still uninitialized.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，在使用变量之前必须声明它。在任何代码位置，只能使用到该点定义的变量。这样一组可用的标识符被视为解析下一个语句的上下文。在许多编程语言中，这样的上下文不仅包含变量的名称，还包括其类型，以及它肯定已经接收了一个值或它可能仍然未初始化的事实。
- en: To capture such constraints, context-dependent languages can be defined, though
    such formalism is quite unwieldy and the resulting grammar is inefficient to parse.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕捉这样的约束，可以定义上下文相关的语言，尽管这种形式主义相当难以操作，并且生成的语法解析效率不高。
- en: 'Therefore, the usual way to parse a programming language text is to split parsing
    into several conceptual passes, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解析编程语言文本的通常方法是将解析分为几个概念上的遍历，如下所示：
- en: '**Pass 1**: Use regular expressions where you can—that is, to parse identifiers,
    literals, operators, and separators. This pass generates a stream of *tokens*,
    where each token represents one of the parsed items. So, for example, any identifier
    is a different token, while white space and comments are skipped. This pass is
    usually named **lexical analysis** or **lexing**.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1步**：在可能的情况下使用正则表达式——即解析标识符、字面量、运算符和分隔符。这一步生成一个*标记流*，其中每个标记代表一个解析项。例如，任何标识符都是不同的标记，而空白和注释则被跳过。这一步通常被称为**词法分析**或**lexing**。'
- en: '**Pass 2**: Use a context-free parser where you can—that is, to apply the grammar
    rules to the stream of tokens. This pass creates a tree-shaped structure representing
    the program. This structure is named a **syntax tree**. The tokens are stored
    as the leaves (that is, terminal nodes) of this tree. This tree can still contain
    context-dependent errors, such as the usage of an undeclared identifier. This
    pass is usually named **syntax analysis**.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2步**：使用上下文无关解析器，即应用语法规则到标记流中。这一步创建了一个表示程序的树形结构，这个结构被称为**语法树**。标记被存储为树的叶子（即终端节点）。这个树仍然可能包含上下文相关的错误，例如未声明的标识符的使用。这一步通常被称为**语法分析**。'
- en: '**Pass 3**: Process the syntax tree to associate any variable use with the
    declaration of such a variable, and possibly check its type. This pass creates
    a new data structure, named **symbol table**, that describes all the identifiers
    found in the syntax tree, and it decorates the syntax tree with references to
    such a symbol table. This pass is usually named **semantic analysis** because
    it usually also regards type checking.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3步**：处理语法树，将任何变量使用与该变量的声明关联起来，并可能检查其类型。这一步创建了一个新的数据结构，称为**符号表**，它描述了语法树中找到的所有标识符，并且用对这样的符号表的引用装饰了语法树。这一步通常被称为**语义分析**，因为它通常也涉及类型检查。'
- en: 'When we have a decorated syntax tree and its relative symbol table, the parsing
    operation is completed. Now, the developer can perform the following operations with
    such data structures:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个装饰的语法树及其相关的符号表时，解析操作就完成了。现在，开发者可以使用这些数据结构执行以下操作：
- en: Get the syntax errors, in case the code is invalid
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取语法错误，如果代码无效
- en: Get suggestions about how to improve the code
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取有关如何改进代码的建议
- en: Get some metrics about the code
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取有关代码的一些度量
- en: Interpret the code (in case the language is a programming language)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释代码（如果语言是编程语言）
- en: Translate the code into another language
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码翻译成另一种语言
- en: 'In this chapter, the following operations will be performed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将执行以下操作：
- en: The lexical analysis pass and the syntax analysis pass will be grouped in a
    single pass that will process source code and will generate a syntax tree (in
    the `calc_parser` project).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词法分析步骤和语法分析步骤将被组合成一个单一的步骤，该步骤将处理源代码并生成语法树（在`calc_parser`项目中）。
- en: The semantic analysis pass will use the syntax tree generated by the parser
    to create a symbol table and a decorated syntax tree (in the `calc_analyser` project).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义分析步骤将使用解析器生成的语法树来创建符号表和装饰的语法树（在`calc_analyser`项目中）。
- en: The symbol table and the decorated syntax tree will be used to execute the program
    written in the `Calc` language (in the `calc_interpreter` project).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号表和装饰的语法树将被用来执行用`Calc`语言编写的程序（在`calc_interpreter`项目中）。
- en: The symbol table and the decorated syntax tree will also be used to translate
    the program into the Rust language (in the `calc_complier` project).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号表和装饰的语法树还将被用来将程序翻译成Rust语言（在`calc_complier`项目中）。
- en: In this section, we have seen a useful classification of programming languages.
    Even if every programming language belongs to the context-dependent category,
    the other categories are still useful because interpreters and compilers use regular
    grammars and CFGs as a part of their operation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了编程语言的有用分类。即使每种编程语言都属于上下文相关类别，其他类别仍然有用，因为解释器和编译器将正则语法和CFG作为它们操作的一部分。
- en: But before seeing a complete project, let's have a look at the techniques used
    to build a parser, and in particular, the technique used by the Nom library.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但在看到完整的项目之前，让我们看看构建解析器所使用的技巧，特别是Nom库所使用的技巧。
- en: Using Nom to build parsers
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nom构建解析器
- en: Before starting to write a parser for the `Calc` language, let's have a look
    at the most popular parsing techniques used for building both interpreters and
    compilers. This is needed to understand the Nom library, which uses one of these
    techniques.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写`Calc`语言的解析器之前，让我们先看看用于构建解释器和编译器的最流行的解析技术。这是为了理解Nom库，它使用这些技术之一。
- en: Learning about compiler-compilers and parser combinators
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习关于编译器-编译器和解析器组合器
- en: 'To obtain an extremely fast and flexible parser, you need to build it from
    scratch. But for decades, an easier approach was used to build parsers by using
    tools named **compiler-compilers** or **compiler generators**: programs that generate
    compilers. These programs get input as a decorated specification of the syntax
    and generate the source code of a parser for such a syntax. These generated source
    code must then be compiled, together with other source files, to get an executable
    compiler.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个极其快速和灵活的解析器，你需要从头开始构建它。但是，几十年来，一种更简单的方法被用来构建解析器，即使用名为**编译器-编译器**或**编译器生成器**的工具：生成编译器的程序。这些程序接收输入为一个装饰过的语法规范，并为这种语法生成解析器的源代码。然后，这些生成的源代码必须与其他源文件一起编译，以获得可执行的编译器。
- en: This traditional approach is now somewhat out of fashion and another one has
    emerged, named **parser combinator**. A parser combinator is a set of functions
    that allow several parsers to be combined to obtain another parser.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传统方法现在已有些过时，另一种名为**解析器组合器**的方法已经出现。解析器组合器是一组函数，允许将多个解析器组合起来以获得另一个解析器。
- en: We have seen that any `Calc` program is just a sequence of `Calc` statements.
    If we had a parser of single `Calc` statements and the ability to apply such a
    parser in sequence, then we could parse any `Calc` program.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，任何`Calc`程序只是`Calc`语句的序列。如果我们有一个单行`Calc`语句的解析器，并且能够按顺序应用这样的解析器，那么我们就可以解析任何`Calc`程序。
- en: We should know that any `Calc` statement is either a `Calc` declaration, a `Calc`
    assignment, a `Calc` input operation, or a `Calc` output operation. If we had
    a parser for each of such statements and the ability to apply any such parsers
    alternatively, we could parse any `Calc` statement. We can go on until we get
    to single characters (or to tokens if we use the output of a lexical analyzer).
    So, a parser of a program can be obtained by combining the parsers of its component
    items.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该知道，任何`Calc`语句要么是`Calc`声明，要么是`Calc`赋值，要么是`Calc`输入操作，要么是`Calc`输出操作。如果我们为每个这样的语句都有一个解析器，并且能够交替地应用这些解析器，我们就可以解析任何`Calc`语句。我们可以继续进行，直到我们得到单个字符（或者如果我们使用词法分析器的输出，则是到标记）。因此，一个程序的解析器可以通过组合其组成部分的解析器来获得。
- en: But what is a parser written in Rust? It is a function that gets a string of
    source code as input and returns a result. The result can be `Err` (if that string
    couldn't be parsed) or `Ok` (containing a data structure representing the parsed
    item).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，用Rust编写的解析器是什么？它是一个接收源代码字符串作为输入并返回结果的函数。结果可以是`Err`（如果该字符串无法解析）或`Ok`（包含表示解析项的数据结构）。
- en: So, while normal functions receive data as input and return data as output, our
    parser combinators receive one or more parsers that have functions as input and
    return a parser as output. Functions that receive functions as input and return
    a function as output are named **second-order** **functions** because they process
    functions instead of data. In computer science, the concept of second-order functions
    originates from functional languages, and the concept of parser combinators also
    comes from such languages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然正常函数接收数据作为输入并返回数据作为输出，我们的解析器组合器接收一个或多个具有函数作为输入的解析器，并返回一个解析器作为输出。接收函数作为输入并返回函数作为输出的函数被称为**二阶**函数，因为它们处理函数而不是数据。在计算机科学中，二阶函数的概念起源于函数式语言，解析器组合器的概念也来自这样的语言。
- en: In Rust, second-order functions were not feasible before the 2018 edition, because
    Rust functions could not return functions without allocating a closure. Therefore,
    the Nom library (up to version 4) used macros instead of functions as combinators
    to maintain top performance. When Rust introduced the `impl Trait` feature (included
    in the 2018 edition), an efficient implementation of parser combinators using
    functions instead of macros became possible. So, version 5 of Nom is entirely
    based on functions, keeping macros only for backward compatibility.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 的 2018 版本之前，二阶函数是不可行的，因为 Rust 函数不能返回函数而不分配闭包。因此，Nom 库（直到版本 4）使用宏而不是函数作为组合器以保持高性能。当
    Rust 引入了`impl Trait`特性（包含在 2018 版本中）时，使用函数而不是宏实现解析器组合器的有效方法成为可能。因此，Nom 的第 5 版完全基于函数，仅保留宏以保持向后兼容性。
- en: In the next section, we will see the basic features of the Nom library, which
    we are going to use to build both an interpreter and a compiler.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到 Nom 库的基本功能，我们将使用这些功能来构建解释器和编译器。
- en: Learning the basics of Nom
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习 Nom 的基础知识
- en: The Nom crate is essentially a collection of functions. Most of them are parser
    combinators—that is, they get one or more parsers as arguments and return a parser
    as a return value. You can think of them as machines that get one or more parsers
    as input and emit a combined parser as output.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Nom crate 实质上是一个函数集合。其中大部分是解析器组合器——也就是说，它们将一个或多个解析器作为参数，并以解析器作为返回值。你可以把它们看作是输入一个或多个解析器并输出组合解析器的机器。
- en: Some of the Nom function are parsers—that is, they get a sequence of `char`
    values as an argument and return an error if the parse fails, or a data structure
    representing the parsed text, in the case of success.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Nom 函数是解析器——也就是说，它们将一个`char`值的序列作为参数，如果解析失败则返回错误，或者在成功的情况下返回表示解析文本的数据结构。
- en: 'Now, we''ll see the most basic features of Nom, using very simple programs.
    In particular, we''ll see the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过非常简单的程序来查看 Nom 的最基本功能。特别是，我们将看到以下内容：
- en: 'The `char` parser: To parse single fixed characters'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 解析器：解析单个固定字符'
- en: 'The `alt` parser combinator: To accept alternative parsers'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alt` 解析器组合器：接受替代解析器'
- en: 'The `tuple` parser combinator: To accept a fixed sequence of parsers'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuple` 解析器组合器：接受一组固定的解析器'
- en: 'The `tag` parser: To parse fixed strings of a character'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag` 解析器：解析固定字符的字符串'
- en: 'The `map` parser combinator: To transform the output value of parsers'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 解析器组合器：转换解析器的输出值'
- en: 'The `Result::map` function: To apply more complex transformations on the output
    of a parser'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Result::map` 函数：在解析器的输出上应用更复杂的转换'
- en: 'The `preceded`, `terminated`, and `delimited` parser combinators: To accept
    a fixed sequence of parsers and discard some of them from the output'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preceded`、`terminated`和`delimited`解析器组合器：用于接受一组固定的解析器并从输出中丢弃其中的一些'
- en: 'The `take` parser: To accept a defined number of characters'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take` 解析器：接受定义数量的字符'
- en: 'The `many1` parser combinator: To accept a sequence of one or more repetitions
    of a parser'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`many1` 解析器组合器：接受一个或多个解析器的重复序列'
- en: Parsing an alternative of characters
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析字符的替代方案
- en: As an example of a parser, let's see how to parse an alternative of fixed characters. We
    want to parse an extremely simple language, a language that has only three words—*a*, *b*,
    and *c*. Such a parser would succeed only if its input is the string *a* or the
    string *b* or the string *c*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解析器的例子，让我们看看如何解析固定字符的替代方案。我们想要解析一个非常简单的语言，这种语言只有三个单词——*a*、*b*和*c*。这样的解析器只有在它的输入是字符串*a*、字符串*b*或字符串*c*时才会成功。
- en: If the parsing is successful, we want a couple of things as a result—the remaining
    input (that is, after the valid part has been processed) and a representation
    of the processed text. As our words are made up of single characters, we want
    (as a representation of that) a value of the `char` type, containing just the
    parsed character.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析成功，我们想要的结果是一对东西——剩余的输入（即在有效部分被处理后）和已处理文本的表示。由于我们的单词由单个字符组成，我们想要（作为这种表示）一个`char`类型的值，其中只包含解析的字符。
- en: 'The following snippet is our first code using Nom:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们使用 Nom 的第一个代码片段：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you compile this program, including the dependency of the Nom crate, and
    you run it, it should print the following output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译这个程序，包括 Nom crate 的依赖项，并运行它，它应该打印以下输出：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We named our parser `parse_abc`. It gets a string slice as input and returns
    a value of the `IResult<&str, char>` type. Such a return value type is a kind
    of `Result`. The `Ok` case of such a `Result` type is a tuple of two values—a
    string slice containing the remaining input, and a character—that is, the information
    we got by parsing the text. The `Err` case of such a `Result` type is defined
    internally by the Nom crate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的解析器命名为 `parse_abc`。它接受一个字符串切片作为输入，并返回 `IResult<&str, char>` 类型的值。这种返回值类型是一种
    `Result`。这种 `Result` 类型的 `Ok` 情况是两个值的元组——包含剩余输入的字符串切片和一个字符，即通过解析文本获得的信息。这种 `Result`
    类型的 `Err` 情况是由 Nom 包内部定义的。
- en: As you can see in the output, the `parse_abc("a")` expression returns `Ok(("",
    'a'))`. This means that when the `a` string is parsed, the parsing is successful;
    no input is left to process, and the character extracted is `'a'`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`parse_abc("a")` 表达式返回 `Ok(("", 'a'))`。这意味着当解析 `a` 字符串时，解析成功；没有剩余的输入需要处理，并且提取的字符是
    `'a'`。
- en: Instead, the `parse_abc("x")` expression returns `Err(Error(("x", Char)))`.
    This means that when the `x` string is parsed, the parsing fails; the `x` string
    remains to process, and the kind of error is `Char`, meaning that a `Char` item
    was expected. Notice that `Char` is a type defined by Nom.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`parse_abc("x")` 表达式返回 `Err(Error(("x", Char)))`。这意味着当解析 `x` 字符串时，解析失败；`x`
    字符串仍然需要处理，并且错误类型是 `Char`，意味着期望一个 `Char` 项目。请注意，`Char` 是由 Nom 定义的一种类型。
- en: Lastly, the `parse_abc("bjk")` expression returns `Ok(("jk", 'b'))`. This means
    that when the string `bjk` is parsed, the parsing is successful; the `jk` input
    remains to be processed, and the character extracted is `'b'`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`parse_abc("bjk")` 表达式返回 `Ok(("jk", 'b'))`。这意味着当解析字符串 `bjk` 时，解析成功；`jk` 输入仍然需要处理，并且提取的字符是
    `'b'`。
- en: And now, let's see how our parser is implemented. The signature of all parsers
    built for Nom must have a similar signature, and their body must be a function
    call that has the function argument as its argument (in this case, `(input)`).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的解析器是如何实现的。为 Nom 构建的任何解析器的签名都必须相似，并且它们的主体必须是一个函数调用，该函数的参数作为其参数（在这种情况下，`(input)`）。
- en: The interesting part is `alt((char('a'), char('b'), char('c')))`. This expression
    means that we want to build a parser by combining the three parsers, `char('a')`, `char('b')`,
    and `char('c')`. The `char` function (not to be confused with the Rust type having
    the same name) is a built-in Nom parser that recognizes the specified character
    and returns a value of the `char` type containing that character. The `alt` function
    (short for alternative) is a parser combinator. It has just one argument, which
    is a tuple composed of several parsers. The `alt` parser chooses one of the specified
    parsers that match the input.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是 `alt((char('a'), char('b'), char('c')))`. 这个表达式意味着我们想要通过组合三个解析器，`char('a')`、`char('b')`
    和 `char('c')` 来构建一个解析器。`char` 函数（不要与具有相同名称的 Rust 类型混淆）是一个内置的 Nom 解析器，它识别指定的字符并返回一个包含该字符的
    `char` 类型的值。`alt` 函数（简称 alternative，即“选择”）是一个解析器组合器。它只有一个参数，即由几个解析器组成的元组。`alt`
    解析器会选择一个与输入匹配的指定解析器。
- en: It's your responsibility to guarantee that there is at most one parser accepting
    the input, for any given input. Otherwise, the grammar is ambiguous. Here is an
    example of an ambiguous parser—`alt((char('a'), char('b'), char('a')))`. The `char('a')`
    sub-parser is repeated, but this will not be spotted by the Rust compiler.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确保对于任何给定的输入，最多只有一个解析器接受输入，这是你的责任。否则，语法是模糊的。以下是一个模糊解析器的示例——`alt((char('a'), char('b'),
    char('a')))`。`char('a')` 子解析器被重复，但 Rust 编译器不会注意到这一点。
- en: In the next section, we will see how to parse a sequence of characters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何解析字符序列。
- en: Parsing a sequence of characters
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析字符序列
- en: 'Now, let''s see another parser, given as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个解析器，如下所示：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After running it, it should print the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，它应该打印以下内容：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This time, the letters `a`, `b`, and `c` must be in this exact sequence, and
    a tuple containing these characters is returned by the `parse_abc_sequence` function.
    For the `abc` input, there is no remaining input, and the `('a', 'b', 'c')` tuple
    is returned. The `bca` input is not accepted, as it starts with a `b` character
    instead of `a`. The `abcjk` input is accepted, as in the first case, but this
    time, there is a remaining input.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，字母 `a`、`b` 和 `c` 必须按照这个确切的顺序出现，并且 `parse_abc_sequence` 函数返回包含这些字符的元组。对于 `abc`
    输入，没有剩余的输入，并且返回 `('a', 'b', 'c')` 元组。`bca` 输入不被接受，因为它以 `b` 字符开头而不是 `a`。`abcjk`
    输入被接受，就像第一种情况一样，但这次有一个剩余的输入。
- en: The combination of parsers is `tuple((char('a'), char('b'), char('c')))`. This
    is similar to the preceding program, but by using the `tuple` parser combinator,
    a parser is obtained that requires that all the specified parsers are satisfied,
    in their order.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器的组合是`tuple((char('a'), char('b'), char('c')))`。这与前面的程序类似，但通过使用`tuple`解析器组合器，获得了一个需要按顺序满足所有指定解析器的解析器。
- en: In the next section, we'll see how to parse a fixed string of text.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何解析固定文本字符串。
- en: Parsing a fixed string
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析固定字符串
- en: In the `parse_abc_sequence` function discussed previously, to recognize the `abc` sequence,
    the `char` parser had to be specified three times, and the result was a tuple
    of `char` values.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论的`parse_abc_sequence`函数中，为了识别`abc`序列，必须指定三次`char`解析器，结果是`char`值的元组。
- en: 'For longer strings (such as the keywords of a language), this is inconvenient,
    as they are more easily seen as strings than as sequences of characters. The Nom
    library also contains a parser for fixed strings, named `tag`. The preceding program
    can be rewritten using this built-in parser, shown in the following code block:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较长的字符串（如语言的关键字），这不太方便，因为它们更容易被视为字符串而不是字符序列。Nom库还包含一个用于固定字符串的解析器，名为`tag`。前面的程序可以使用此内置解析器重写，如下面的代码块所示：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It will print the following output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下输出：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Instead of the `tuple((char('a'), char('b'), char('c')))` expression, there
    is now a simple call to `tag("abc")`, and the parser returns a string slice, instead
    of a tuple of `char` values.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是`tuple((char('a'), char('b'), char('c')))`表达式，现在有一个简单的调用`tag("abc")`，并且解析器返回一个字符串切片，而不是`char`值的元组。
- en: In the next section, we'll see how to transform the value resulting from a parser
    to another value, possibly of another type.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何将解析器产生的值转换成另一个值，可能是另一种类型。
- en: Mapping parsed items to other objects
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将解析后的项映射到其他对象
- en: So far, we get as a result just what we found in the input. But often, we want
    to transform the parsed input before returning its result.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们得到的结果只是我们在输入中找到的内容。但通常，我们在返回结果之前想要转换解析后的输入。
- en: Say that we want to parse alternatively three letters (`a`, `b`, or `c`) but
    we want, as a result of the parsing, the number `5` for the letter `a`, the number
    `16` for the letter `b`, and the number `8` for the letter `c`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要解析三个字母（`a`、`b`或`c`），但我们想要在解析的结果中，对于字母`a`返回数字`5`，对于字母`b`返回数字`16`，对于字母`c`返回数字`8`。
- en: 'So, we want a parser that parses a letter, but, instead of returning that letter,
    it returns a number, if the parsing is successful. We also want to map the character `a`
    to the number `5`, the character `b` to the number `16`, and the character `c`
    to the number `8`. The original result type was `char`, while the mapped result
    type is `u8`. The following code block shows the program that performs such a
    transformation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想要一个解析器，它可以解析一个字母，但，如果解析成功，它返回一个数字，而不是返回那个字母。我们还想将字符`a`映射到数字`5`，字符`b`映射到数字`16`，字符`c`映射到数字`8`。原始的结果类型是`char`，而映射的结果类型是`u8`。以下代码块显示了执行这种转换的程序：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When it runs, it should print the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行时，它应该打印以下输出：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the `a` input, `5` is extracted. For the `x` input, a parse error is obtained.
    For the `bjk` input, `16` is extracted, and the `jk` string remains as input to
    be parsed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`a`输入，提取出`5`。对于`x`输入，得到一个解析错误。对于`bjk`输入，提取出`16`，并且`jk`字符串作为待解析的输入保留。
- en: The implementation, for each one of the three characters, contains something
    such as `map(char('a'), |_| 5)`. The `map` function is another parser combinator
    that takes a parser and a closure. If the parser matches, then it generates a
    value. The closure is invoked on such a value, and it returns a transformed value.
    In this case, the argument of the closure was not needed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这三个字符中的每一个，实现中包含类似`map(char('a'), |_| 5)`的内容。`map`函数是另一个解析器组合器，它接受一个解析器和闭包。如果解析器匹配，则生成一个值。闭包在这样一个值上被调用，并返回一个转换后的值。在这种情况下，闭包的参数是不需要的。
- en: 'An alternative equivalent implementation of the same parser is given as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个解析器的另一种等效实现如下：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It defines the `transform_letter` inner function that applies the transformation
    and passes just that function as the second argument of the `map` combinator.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个`transform_letter`内部函数，该函数应用转换并将该函数仅作为`map`组合器的第二个参数传递。
- en: In the next section, we'll see how to manipulate the output of a parser in a
    more complex way, as we will be omitting or swapping some fields of the resulting
    tuple.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何以更复杂的方式操作解析器的输出，因为我们将会省略或交换结果元组中的某些字段。
- en: Creating custom parsing results
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义解析结果
- en: So far, the results of parsing have been determined by the parsers and combinators
    used in it—if a parser uses the `tuple` combinator with three items, the result
    is a tuple of three items. This is seldom what is desired. For example, we want
    to either omit some items of the resulting tuple or add a fixed item, or to swap
    the items.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，解析的结果是由其中使用的解析器和组合器决定的——如果一个解析器使用三个项目的`tuple`组合器，结果就是一个包含三个项目的元组。这很少是我们想要的。例如，我们可能想要省略结果元组中的某些项目，或者添加一个固定项目，或者交换项目。
- en: 'Assume that we want to parse the `abc` string, but in the result we want to
    omit `b`, keeping only `ac`. For that purpose, we must postprocess the result
    of the parsing in the following way:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要解析`abc`字符串，但在结果中我们想要省略`b`，只保留`ac`。为此，我们必须以下述方式后处理解析结果：
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It will print the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下输出：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Of course, the result of our parser now contains just a pair—`(char, char)`.
    The postprocessing is seen in the second line of the body. It uses a `map` function
    that is not the one seen in the preceding example; it belongs to the `Result`
    type. Such a method receives a closure that gets the `Ok` variant of the result
    and returns a new `Ok` variant with the appropriate types. If the type had been
    made explicit, then that code would have been as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们解析器的结果现在只包含一对——`(char, char)`。后处理在代码体的第二行中体现。它使用了一个`map`函数，这个函数与前面的例子中看到的不同；它属于`Result`类型。这种方法接收一个闭包，该闭包获取结果的`Ok`变体，并返回一个新的`Ok`变体，具有适当的数据类型。如果类型已经明确指定，那么代码将如下所示：
- en: '[PRE17]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From the preceding code, the call to `tuple` returns a result whose `Ok` variant
    has the `(&str, (char, char, char))` type. The first element is the remaining
    input, assigned to the `rest` variable, and the second element is the sequence
    of parsed `char` values, assigned to the `result` variable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，`tuple`的调用返回一个结果，其`Ok`变体具有`(&str, (char, char, char))`类型。第一个元素是剩余的输入，分配给`rest`变量，第二个元素是解析的`char`值序列，分配给`result`变量。
- en: Then, we must construct a pair with two items—that is, what we want as the *remaining
    input*, and the pair of characters that we want as a *result*. As a remaining
    input, we specify the same pair provided by `tuple`, while as a result, we specify `(result.0,
    result.2)`—that is, the first and third parsed characters, which will be `'a'`
    and `'c'`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须构造一个包含两个项目的对——即我们想要的*剩余输入*，以及我们想要的*结果*的字符对。作为剩余输入，我们指定由`tuple`提供的相同对，而作为结果，我们指定`(result.0,
    result.2)`——即第一个和第三个解析的字符，它们将是`'a'`和`'c'`。
- en: 'Some of the following cases are quite typical:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的一些情况相当典型：
- en: A sequence of two parsers, needing to keep the result of the first parser and
    discard the result of the second parser.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个解析器的序列，需要保留第一个解析器的结果并丢弃第二个解析器的结果。
- en: A sequence of two parsers, needing to discard the result of the first parser
    and keep the result of the second parser.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个解析器的序列，需要丢弃第一个解析器的结果并保留第二个解析器的结果。
- en: A sequence of three parsers, needing to keep the result of the second parser
    and discard the results of the first and third parsers. This is typical of parenthesized
    expressions or quoted text.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个解析器的序列，需要保留第二个解析器的结果并丢弃第一个和第三个解析器的结果。这在括号表达式或引号文本中很典型。
- en: 'For these previous cases, the mapping technique can be applied too, but Nom
    contains some specific combinators, detailed as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些先前的情况，映射技术同样适用，但Nom包含一些特定的组合器，具体如下：
- en: '`preceded(a, b)`: This keeps only the result of `b`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preceded(a, b)`：这仅保留`b`的结果。'
- en: '`terminated(a, b)`: This keeps only the result of `a`.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terminated(a, b)`：这仅保留`a`的结果。'
- en: '`delimited(a, b, c)`: This keeps only the result of `b`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delimited(a, b, c)`：这仅保留`b`的结果。'
- en: In the next section, we'll see how to parse a specified number of characters
    and return the parsed characters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何解析指定数量的字符并返回解析的字符。
- en: Parsing a variable text
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析可变文本
- en: The parsing we have done so far is of very limited usefulness, as we just checked
    that the input respected a language, without the possibility of accepting arbitrary
    text or numbers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所进行的解析非常有局限性，因为我们只是检查了输入是否遵循了一种语言，而没有接受任意文本或数字的可能性。
- en: 'Say we want to parse a text that begins with an `n` character followed by two
    other arbitrary characters, and we want to process only the latter two characters.
    This can be done with the `take` built-in parser, shown in the following code
    snippet:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要解析一个以`n`字符开头，后跟两个其他任意字符的文本，并且我们只想处理后面的两个字符。这可以通过`take`内置解析器来完成，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It will print the following output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下输出：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first invocation is a successful one. The `n` character is skipped by `char('n')`,
    and two other characters are read by `take(2usize)`. This parser reads as many
    characters as specified by its argument (that must be an unsigned number), and
    it returns this sequence of bytes as a string slice. To read a single character,
    just call `take(1usize)`, which will return a string slice anyway.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用是成功的一次。`n`字符被`char('n')`跳过，然后通过`take(2usize)`读取另外两个字符。这个解析器读取由其参数指定的字符数（必须是无符号数），并将这个字节序列作为字符串切片返回。要读取单个字符，只需调用`take(1usize)`，它将返回一个字符串切片。
- en: The second invocation fails because the starting `n` is missing. The third invocation
    fails because after the starting `n`, there are fewer than two characters, and
    so the `Eof` (short for **End-Of-File**) error is generated.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用失败，因为缺少起始的`n`。第三次调用失败，因为起始的`n`之后字符少于两个，因此生成了`Eof`（代表**文件结束**）错误。
- en: In the next section, we will see how to parse a sequence of one or more patterns
    by applying a given parser repeatedly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何通过重复应用给定的解析器来解析一个或多个模式序列。
- en: Repeating a parser
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复解析器
- en: It is quite common to need to parse a sequence of repeated expressions, each
    recognized by a parser. So, that parser must be applied several times, until it
    fails. Such repetition is done by a couple of combinators—namely, `many0` and
    `many1`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解析由解析器识别的重复表达式序列的情况相当常见。因此，必须多次应用该解析器，直到它失败。这种重复是通过几个组合器完成的——即`many0`和`many1`。
- en: 'The former will succeed even if no occurrence of the expression is parsed—that
    is, it is a zero-or-more combinator. The latter will succeed only if at least
    one occurrence of the expression is parsed—that is, it is a one-or-more combinator. Let''s
    see how to recognize a sequence of one or more `abc` strings, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前者即使没有解析到表达式的任何实例也会成功——即它是零或更多组合器。后者只有在至少解析到表达式的至少一个实例时才会成功——即它是一或更多组合器。让我们看看如何识别一个或多个`abc`字符串序列，如下所示：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It will print the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下输出：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first invocation fails because the empty string does not contain any occurrences
    of `abc`. If the `many0` combinator had been used, this invocation would have
    succeeded.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用失败，因为空字符串不包含任何`abc`的实例。如果使用了`many0`组合器，这次调用将成功。
- en: The two other invocations succeed anyway and return a `Vec` of the occurrences
    found.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两次调用仍然成功，并返回找到的实例的`Vec`。
- en: 'In this section, we have presented the most popular parsing techniques: compiler-compilers
    and parser combinators. They are useful both to build interpreters and compilers.
    Then, we introduced the Nom parser combinator library that will be used in the
    rest of this chapter, and also in part of the next chapter.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了最流行的解析技术：编译器编译器和解析器组合器。它们在构建解释器和编译器时都很有用。然后，我们介绍了将在本章剩余部分以及下一章部分使用的Nom解析器组合器库。
- en: Now, we have seen enough of Nom to begin to see the first project of this chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经对Nom有了足够的了解，可以开始看到本章的第一个项目。
- en: The calc_parser project
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: calc_parser项目
- en: This project is a parser of the `Calc` language. It is a program that can examine
    a string and detect if it respects the syntax of the `Calc` language, using a
    context-free parser, and, in such cases, extracts the logical structure of such
    a string, according to the grammar of the language. Such a structure is often
    named a **syntax tree **as it has the shape of a tree, and it represents the syntax
    of the parsed text.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是`Calc`语言的解析器。它是一个程序，可以检查一个字符串并检测它是否遵循`Calc`语言的语法，使用上下文无关解析器，并在这种情况下，根据语言的语法提取字符串的逻辑结构。这样的结构通常被称为**语法树**，因为它具有树形结构，并且它代表了解析文本的语法。
- en: A syntax tree is an internal data structure, and so usually it is not to be
    seen by a user, nor to be exported. For debugging purposes, though, this program
    will pretty-print this data structure to the console.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 语法树是一个内部数据结构，因此通常用户看不到，也不需要导出。但是，出于调试目的，这个程序将把这个数据结构格式化打印到控制台。
- en: The program built by this project expects a `Calc` language file as a command-line
    argument. In the `data` folder of the project, there are two example programs—namely, `sum.calc`
    and `bad_sum.calc`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由本项目构建的程序期望一个 `Calc` 语言文件作为命令行参数。在项目的 `data` 文件夹中，有两个示例程序——即 `sum.calc` 和 `bad_sum.calc`。
- en: 'The first one is `sum.calc`, given as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是 `sum.calc`，如下所示：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It declares the two variables `a` and `b`, then it asks the user to enter values
    for them, and it prints the sum of their value.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它声明了两个变量 `a` 和 `b`，然后要求用户为它们输入值，并打印它们的和。
- en: The other program, `bad_sum.calc`, is identical to the former, except for the
    second line—that is, `@d`—representing a typo because later on, the undeclared
    `b` variable is used.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个程序，`bad_sum.calc`，与前者相同，除了第二行——即 `@d`——表示一个错误，因为后来使用了未声明的 `b` 变量。
- en: 'To run the project on the first example `Calc` program, go into the `calc_parser` folder, and
    type the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要在第一个示例 `Calc` 程序上运行项目，请进入 `calc_parser` 文件夹，并输入以下内容：
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Such a command should print the following text on the console:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的命令应该在控制台上打印以下文本：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From the preceding code, first, there is a declaration of the `"a"` identifier,
    then of the `"b"` identifier, then an input operation on a variable named `"a"`,
    then one on a variable named `"b"`, and then there is an output operation with
    a lot of parentheses.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，首先声明了 `"a"` 标识符，然后是 `"b"` 标识符，接着是对名为 `"a"` 的变量的输入操作，然后是对名为 `"b"` 的变量的输入操作，最后是一个带有许多括号的输出操作。
- en: The first open parenthesis under `OutputOperation` represents the beginning
    of the expression item that, according to the grammar presented previously, must
    appear in any output operation statement. Such an expression contains two items—a
    term and a list of operator-term pairs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OutputOperation` 下的第一个开括号代表表达式项的开始，根据之前提出的语法，它必须出现在任何输出操作语句中。这样的表达式包含两个项——一个项和一个操作符-项对列表。
- en: The first term contains two items—a factor and a list of operator-factor pairs.
    The factor is the `"a"` identifier, and the list of operator-factor pairs is empty.
    Then, let's pass this to the list of operator-term pairs. It contains just one
    item, in which the operator is `Add`, and the term is again a factor followed
    by a list of operator-factor pairs. The factor is the `"b"` identifier, and the
    list is empty.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项包含两个项——一个因子和一个操作符-因子对列表。因子是 `"a"` 标识符，操作符-因子对列表为空。然后，让我们将这个传递给操作符-项对列表。它只包含一个项，其中操作符是
    `Add`，项是一个因子后跟一个操作符-因子对列表。因子是 `"b"` 标识符，列表为空。
- en: If the `cargo run data/bad_sum.calc` command runs, no error is detected, as
    this program only performs a syntax analysis without checking the semantic context.
    The output is the same, except for the sixth line—that is, `"d"` instead of `"b"`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行 `cargo run data/bad_sum.calc` 命令，不会检测到错误，因为这个程序只执行语法分析而不检查语义上下文。输出与之前相同，除了第六行——即
    `"d"` 而不是 `"b"`。
- en: Now, let's examine the source code of the Rust program. The only external crate
    is **Nom**, a library used just for the lexical and syntax analysis passes (and
    therefore used by all the projects of this chapter, because all of them need parsing).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查 Rust 程序的源代码。唯一的第三方库是 **Nom**，这是一个仅用于词法和语法分析阶段的库（因此被本章的所有项目使用，因为它们都需要解析）。
- en: There are two source files—`main.rs` and `parser.rs`. Let's look at the `main.rs`
    source file first.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个源文件——`main.rs` 和 `parser.rs`。让我们首先看看 `main.rs` 源文件。
- en: Understanding the main.rs source file
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 main.rs 源文件
- en: The `main.rs` source file contains just the `main` function and the `process_file`
    function. The `main` function just checks if the command line contains an argument
    and passes it to the `process_file` function, together with the path of the executable
    Rust program.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.rs` 源文件只包含 `main` 函数和 `process_file` 函数。`main` 函数只是检查命令行是否包含参数，并将其传递给
    `process_file` 函数，同时附带可执行 Rust 程序的路径。'
- en: The `process_file` function checks that the command-line argument ends with
    `.calc`—that is, the only expected file type, then it reads the contents of that
    file into the `source_code` string and parses that string by calling `parser::parse_program(&source_code)`,
    contained in the `parser.rs` source file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_file` 函数检查命令行参数是否以 `.calc` 结尾——即唯一期望的文件类型，然后它将文件的 内容读取到 `source_code`
    字符串中，并通过调用 `parser::parse_program(&source_code)`（位于 `parser.rs` 源文件中）来解析该字符串。'
- en: 'Such a file is, of course, a parser for the whole program, and so it returns
    a `Result` value. The `Ok` variant of such a return value is a pair composed of
    the remaining code and the syntax tree. The syntax tree is then pretty-printed
    by the statement given as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样一个文件是一个整个程序的解析器，因此它返回一个`Result`值。这种返回值的`Ok`变体是由剩余代码和语法树组成的对。然后，通过以下给出的语句将语法树格式化输出：
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the small `sum.calc` file, having only five lines and 17 characters, is
    processed, this single `println!` statement emits the long output shown before,
    having 35 lines and 604 bytes. Of course, the output is longer for longer programs.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理只有五行和17个字符的小型`sum.calc`文件时，这个单独的`println!`语句会输出之前显示的长输出，共有35行和604字节。当然，对于更长的程序，输出会更长。
- en: Next, let's look at the `parser.rs` source file.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`parser.rs`源文件。
- en: Learning about the parser.rs source file
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解`parser.rs`源文件
- en: 'The `parser.rs` source file contains a parser function for each syntax element
    of the grammar of the language. These functions are detailed as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`parser.rs`源文件包含一个针对语言语法中每个语法元素的解析函数。这些函数的详细说明如下：'
- en: '| **Function** | **Description** |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `parse_program` | This parses a whole `Calc` program. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `parse_program` | 这解析整个`Calc`程序。|'
- en: '| `parse_declaration` | This parses a `Calc` declaration statement, such as `@total`.
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `parse_declaration` | 这解析一个`Calc`声明语句，例如`@total`。|'
- en: '| `parse_input_statement` | This parses a `Calc` input statement, such as `>addend`.
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `parse_input_statement` | 这解析一个`Calc`输入语句，例如`>addend`。|'
- en: '| `parse_output_statement` | This parses a `Calc` output statement, such as  `<total`.
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `parse_output_statement` | 这解析一个`Calc`输出语句，例如`<total`。|'
- en: '| `parse_assignment` | This parses a `Calc` assignment statement, such as `total
    := addend * 2`. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `parse_assignment` | 这解析一个`Calc`赋值语句，例如`total := addend * 2`。|'
- en: '| `parse_expr` | This parses a `Calc` expression, such as  `addend * 2 + val
    / (incr + 1)`. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `parse_expr` | 这解析一个`Calc`表达式，例如`addend * 2 + val / (incr + 1)`。|'
- en: '| `parse_term` | This parses a `Calc` term, such as `val / (incr + 1)`. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `parse_term` | 这解析一个`Calc`项，例如`val / (incr + 1)`。|'
- en: '| `parse_factor` | This parses a `Calc` factor, such as `incr`, or `4.56e12`,
    or `(incr + 1)`. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `parse_factor` | 这解析一个`Calc`因子，例如`incr`，或`4.56e12`，或`(incr + 1)`。|'
- en: '| `parse_subexpr` | This parses a `Calc` parenthesized expression, such as `(incr
    + 1)`. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `parse_subexpr` | 这解析一个`Calc`括号表达式，例如`(incr + 1)`。|'
- en: '| `parse_identifier` | This parses a `Calc` identifier, such as `addend`. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `parse_identifier` | 这解析一个`Calc`标识符，例如`addend`。|'
- en: '| `skip_spaces` | This parses a sequence of zero or more white spaces. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `skip_spaces` | 这解析零个或多个空白字符序列。|'
- en: With respect to the grammar previously declared, some explanation is due—the
    `parse_subexpr` parser has the task to parse the  `( <expr> )` sequence, discarding
    the parentheses and parsing the `<expr>` initial expression using `parse_expr`.
    The `skip_spaces` function is a parser whose task is to parse zero or more white
    spaces (spaces, tabs, newline characters), with the purpose of ignoring them.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 关于先前声明的语法，有一些解释是必要的——`parse_subexpr`解析器的任务是解析`( <expr> )`序列，丢弃括号，并使用`parse_expr`解析`<expr>`初始表达式。`skip_spaces`函数是一个解析器，其任务是解析零个或多个空白字符（空格、制表符、换行符），目的是忽略它们。
- en: All the other preceding functions, in the case of success, return a data structure
    representing the parsed code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，所有其他前面的函数都返回一个表示解析代码的数据结构。
- en: There is no parser for literal numbers, as the built-in `double` parser will
    be used to parse floating-point numbers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内置的`double`解析器将用于解析浮点数，因此没有为文字数字提供解析器。
- en: Understanding the types needed by the parser
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解解析器所需类型
- en: 'In this file, in addition to the parsers, several types are defined to represent
    the structure of the parsed program. The most important type is defined as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，除了解析器之外，还定义了几个类型来表示解析程序的结构。最重要的类型定义如下：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code snippet just says that a parsed program is a vector of parsed
    statements.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段只是说明解析后的程序是一个解析语句的向量。
- en: Notice the lifetime specification. To keep the best performance, memory allocation
    is minimized. Of course, vectors are allocated, but the parsed string is not allocated;
    they are string slices referencing the input string. Therefore, the syntax tree
    is dependent on the input string, and its lifetime must be shorter than that of
    the input string.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意生命周期指定。为了保持最佳性能，最小化内存分配。当然，会分配向量，但解析的字符串不会分配；它们是引用输入字符串的字符串切片。因此，语法树依赖于输入字符串，其生命周期必须短于输入字符串。
- en: 'The preceding declaration uses the `ParsedStatement` type, which is declared
    in the following way:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明使用了 `ParsedStatement` 类型，其声明方式如下：
- en: '[PRE27]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code snippet says that a parsed statement can be one of the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段说明一个解析语句可以是以下之一：
- en: A declaration encapsulating the name of the variable that is being declared
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个封装正在声明的变量名称的声明
- en: An input statement encapsulating the name of the variable that is going to receive
    an input value
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个封装将要接收输入值的变量名称的输入语句
- en: An output operation encapsulating a parsed expression whose value is going to
    be printed
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个封装将要打印的解析表达式值的输出操作
- en: An assignment encapsulating the name of the variable that is going to receive
    a calculated value and a parsed expression, whose value is going to be assigned
    to the variable
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个封装将要接收计算值的变量名称和解析表达式的赋值语句，其值将被分配给该变量
- en: 'This declaration uses the `ParsedExpr` type, which is declared as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明使用了 `ParsedExpr` 类型，它声明如下：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: From the preceding code snippet, a parsed expression is a pair composed of a
    parsed term and zero or more pairs, with each pair composed of an expression operator
    and a parsed term.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，一个解析表达式是一个由一个解析项和零个或多个对组成的对，其中每个对由一个表达式运算符和一个解析项组成。
- en: 'An expression operator is defined as `enum ExprOperator { Add, Subtract }`,
    while a parsed term is defined as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式运算符定义为 `enum ExprOperator { Add, Subtract }`，而解析项定义为以下内容：
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can see that a parsed term is a pair composed of a parsed factor and zero
    or more pairs, with each pair composed of a term operator and a parsed factor.
    A term operator is defined as `enum TermOperator { Multiply, Divide }`, while
    a parsed factor is defined as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，一个解析项是一个由一个解析因子和零个或多个对组成的对，其中每个对由一个项运算符和一个解析因子组成。项运算符定义为 `enum TermOperator
    { Multiply, Divide }`，而解析因子定义为以下内容：
- en: '[PRE30]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This declaration says that a parsed factor can be a literal encapsulating a
    number, or an identifier encapsulating the name of that variable, or a subexpression
    encapsulating a parsed expression.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明说明一个解析因子可以是一个封装数字的文本，或者是一个封装变量名称的标识符，或者是一个封装解析表达式的子表达式。
- en: Notice the use of `Box`. This is required because any parsed expression contains
    a parsed term that contains a parsed factor of an `enum` capable of containing
    a parsed expression. And so, we have an endless recursion of containment. If we
    use a `Box`, we allocate memory out of the main structure.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Box` 的使用。这是必需的，因为任何解析表达式都包含一个包含一个能够包含解析表达式的 `enum` 解析因子的解析项。因此，我们有一个包含的无限递归。如果我们使用一个
    `Box`，我们就在主结构之外分配内存。
- en: So, we have seen all the definitions of the types that will be used by the parser
    code. Now, let's see the code, in a top-down fashion.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了将要被解析器代码使用的所有类型的定义。现在，让我们以自顶向下的方式查看代码。
- en: Looking at the parser code
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看解析器代码
- en: 'We can now see the code used to parse a whole program. The following code snippet
    shows the entry point of the parser:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查看用于解析整个程序的代码。以下代码片段显示了解析器的入口点：
- en: '[PRE31]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that its result type is `ParsedProgram`, which is a vector of parsed
    statements.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到其结果类型是 `ParsedProgram`，它是一个解析语句的向量。
- en: The body uses the `many0` parser combinator to accept zero or more statements
    (an empty program is considered valid). Actually, to parse a statement, the `preceded`
    combinator is used, to combine two parsers and discard the output of the first
    one. Its first argument is the `skip_spaces` parser, and so it simply skips possible
    spaces between statements. The second argument is the `alt` combinator, to accept
    alternatively one of the four possible statements.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 主体使用 `many0` 解析组合子来接受零个或多个语句（一个空程序被认为是有效的）。实际上，为了解析一个语句，使用 `preceded` 组合子来组合两个解析器并丢弃第一个解析器的输出。它的第一个参数是
    `skip_spaces` 解析器，因此它简单地跳过语句之间的可能空格。第二个参数是 `alt` 组合子，用于接受四种可能语句中的任何一个。
- en: The `many0` combinator generates a vector of objects, with such objects generated
    by the argument of the combinator. Such arguments generate parsed statements,
    and so we have the needed vector of parsed statements.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`many0` 组合子生成一个对象向量，这些对象由组合子的参数生成。这些参数生成解析语句，因此我们有了所需的解析语句向量。'
- en: So, to summarize, this function accepts zero or more statements, possibly separated
    by white spaces. The accepted statements can be declarations, input statements,
    output statements, or assignments. The value returned by the function in the case
    of success is a vector whose elements are representations of the parsed statements.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，这个函数接受零个或多个语句，可能由空白字符分隔。在成功的情况下，函数返回的值是一个向量，其元素是解析语句的表示。
- en: 'The parser of `Calc` declarations is given as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calc`声明的解析器如下所示：'
- en: '[PRE32]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: From the preceding code snippet, a declaration must be a sequence of the `@`
    character, optional spaces, and an identifier; so, the `tuple` combinator is used
    to chain such parsers. However, we are not interested in that initial character
    nor in those white spaces. We want just the text of the identifier, encapsulated
    in `ParsedStatement`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，一个声明必须是一个由`@`字符、可选的空白字符和一个标识符组成的序列；因此，使用`tuple`组合器来链式调用这样的解析器。然而，我们并不关心那个初始字符也不关心那些空白字符。我们只想得到标识符的文本，封装在`ParsedStatement`中。
- en: Therefore, after applying the `tuple`, the result is mapped to a `Declaration`
    object whose argument is the third item generated by the `tuple`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在应用`tuple`之后，结果是映射到一个`Declaration`对象，其参数是由`tuple`生成的第三个项。
- en: 'The following code snippet shows the parser of a `Calc` input statement:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`Calc`输入语句的解析器：
- en: '[PRE33]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The parser of a `Calc` input statement is quite similar to the preceding parser.
    It just looks for the `>` character and returns an `InputOperation` variant that
    encapsulates the string returned by `parse_identifier`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calc`输入语句的解析器与前面的解析器非常相似。它只是查找`>`字符，并返回一个封装由`parse_identifier`返回的字符串的`InputOperation`变体。'
- en: 'The following code snippet shows the parser of a `Calc` output statement:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`Calc`输出语句的解析器：
- en: '[PRE34]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Also, the parser from the preceding code is similar to the two preceding parsers.
    It just looks for the `<` character, parses an expression instead of an identifier,
    and returns an `OutputOperation` that encapsulates the parsed expression returned
    by `parse_expr`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从前面代码的解析器与前面两个解析器相似。它只是查找`<`字符，解析一个表达式而不是标识符，并返回一个封装由`parse_expr`返回的解析表达式的`OutputOperation`。
- en: 'The last kind of `Calc` statement is an assignment. Its parser is shown in
    the following code snippet:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种`Calc`语句是赋值。它的解析器如下所示：
- en: '[PRE35]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is somewhat different from the preceding statement's parsers. It chains
    five parsers—for an identifier, some possible spaces, the `:=` string, some possible
    spaces, and an expression. The result is an `Assignment` variant that encapsulates
    the first and the last parsed items of the tuple—that is, the identifier string
    and the parsed expression.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面的语句解析器有所不同。它链式调用五个解析器——一个标识符、一些可能的空白字符、字符串`:=`、一些可能的空白字符和一个表达式。结果是封装了元组中解析的第一个和最后一个项的`Assignment`变体——即标识符字符串和解析的表达式。
- en: 'We have encountered the use of the expression parser, which is defined as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了表达式解析器的使用，它定义如下：
- en: '[PRE36]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From the preceding code, to parse an expression, a term must first be parsed
    (`parse_term`), and then zero or more (`many0`) pairs (`tuple`) of an operator
    and a term (`parse_term`). The operator can be preceded by white spaces (`skip_spaces`)
    that must be discarded (`preceded`), and it can be alternatively (`alt`) a plus
    character (`char('+'`) or a minus character (`char('-'`). But we want to replace
    (`map`) such characters with the `ExprOperator` values. The resulting object already
    has the expected type, and so no other `map` transformation is needed.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，要解析一个表达式，首先必须解析一个项（`parse_term`），然后是零个或多个（`many0`）由一个运算符和一个项（`parse_term`）组成的对（`tuple`）。运算符可以由空白字符（`skip_spaces`）前导，这些空白字符必须被丢弃（`preceded`），并且它可以是加号字符（`char('+'`）或减号字符（`char('-'`）。但我们想用`ExprOperator`值替换这些字符。结果对象已经具有预期的类型，因此不需要其他`map`转换。
- en: 'The parser of a term is similar to the parser of an expression. Here it is:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 项的解析器与表达式的解析器类似。如下所示：
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The only differences between `parse_expr` and `parse_term` are the following
    ones:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_expr`和`parse_term`之间的唯一区别如下：'
- en: Where `parse_expr` calls `parse_term`, `parse_term` calls `parse_factor`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`parse_expr`调用`parse_term`时，`parse_term`调用`parse_factor`。
- en: Where `parse_expr` maps the `'+'` character to the `ExprOperator::Add` value,
    and the `'-'` character to the `ExprOperator::Subtract` value, `parse_term` maps
    the `'*'` character to the `TermOperator::Multiply` value, and the `'/'` character
    to the `TermOperator::Divide` value.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中`parse_expr`将`'+'`字符映射到`ExprOperator::Add`值，将`'-'`字符映射到`ExprOperator::Subtract`值，`parse_term`将`'*'`字符映射到`TermOperator::Multiply`值，将`'/'`字符映射到`TermOperator::Divide`值。
- en: Where `parse_expr` has a `ParsedExpr` type in the return value type, `parse_term`
    has a `ParsedTerm` type.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中`parse_expr`在返回值类型中有`ParsedExpr`类型，`parse_term`有`ParsedTerm`类型。
- en: 'The parser of a factor again follows the relative grammar rule, and the definition
    of its return type, `ParsedFactor`, as illustrated in the following code snippet:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因子的解析器再次遵循相对语法规则，其返回类型的定义`ParsedFactor`如下代码片段所示：
- en: '[PRE38]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This parser discards possible initial spaces and then parses alternatively an
    identifier, a number, or a subexpression. The parser of the number is `double`,
    a Nom built-in function that parses numbers according to the syntax of Rust `f64`
    literals.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此解析器会丢弃可能的初始空格，然后交替解析一个标识符、一个数字或一个子表达式。数字解析器是`double`，这是一个Nom内置函数，它根据Rust `f64`字面量的语法解析数字。
- en: All the returned types of these parses are wrong, so, the `map` combinator is
    used to generate their return value. For identifiers, it is enough to cite the
    `Identifier` variant that will be constructed automatically using as an argument
    the value returned by the `parse_identifier` function. An equivalent and more
    verbose code would be `map(parse_identifier, |id| ParsedFactor::Identifier(id))`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些解析的返回类型都是错误的，因此，使用`map`组合器来生成它们的返回值。对于标识符，只需要引用将自动使用`parse_identifier`函数返回的值作为参数构建的`Identifier`变体。一个等效但更冗长的代码将是`map(parse_identifier,
    |id| ParsedFactor::Identifier(id))`。
- en: Similarly, literals are converted from the `f64` type to the `ParsedFactor::Literal(f64)`
    type, and subexpressions are boxed and encapsulated in a `SubExpression` variant.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，字面量从`f64`类型转换为`ParsedFactor::Literal(f64)`类型，子表达式被装箱并封装在`SubExpression`变体中。
- en: 'The parse of the subexpression must just match and discard spaces and parentheses,
    shown in the following code snippet:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 子表达式的解析必须仅匹配并丢弃空格和括号，如下代码片段所示：
- en: '[PRE39]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The inner `parse_expr` parser is the only one that passes its output to the
    result. To parse an identifier, a built-in parser is used, shown as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的`parse_expr`解析器是唯一一个将其输出传递给结果的。为了解析一个标识符，使用了一个内置解析器，如下所示：
- en: '[PRE40]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `alpha1` parser returns a string of one or more letters. Digits and other
    characters are not allowed. Usually, this would not be named *parser*, but lexical
    analyzer, or lexer, or scanner, or tokenizer, but Nom makes no distinction.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`alpha1`解析器返回一个由一个或多个字母组成的字符串。不允许数字和其他字符。通常，这不会命名为*解析器*，而是词法分析器、词法分析器、扫描器或标记器，但Nom没有区分。'
- en: 'And lastly, the small parser (or lexer) to process spaces is shown as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，处理空格的小解析器（或词法分析器）如下所示：
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It uses a combinator we have not yet seen—`take_while`. It receives as argument
    a closure returning a Boolean (that is, predicate). Such a closure is invoked
    on any input character. If the closure returns `true`, the parser goes on or otherwise
    stops. So, it returns the maximum sequence of input characters for which the predicate
    value is *true*.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用我们尚未见过的组合器`take_while`。它接收一个返回布尔值（即谓词）的闭包作为参数。这样的闭包会在任何输入字符上被调用。如果闭包返回`true`，解析器将继续，否则停止。因此，它返回输入字符序列的最大序列，对于该序列，谓词值为*true*。
- en: In our case, the predicate checks whether the character is contained in a slice
    of four characters.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，谓词检查字符是否包含在四个字符的切片中。
- en: So, we have seen all our parsers for the `Calc` language. Of course, real-world
    parsers are much more complex, but the concepts are the same.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了`Calc`语言的全部解析器。当然，现实世界的解析器要复杂得多，但概念是相同的。
- en: In this section, we have seen how the Nom library can be used to parse a program
    written in the `Calc` language, using a CFG. This is preliminary to applying a
    **context-sensitive grammar** (**CSG**), and then an interpreter or a compiler.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用Nom库通过CFG解析用`Calc`语言编写的程序。这是应用**上下文相关语法**（**CSG**）以及随后解释器或编译器的先决条件。
- en: Notice that this program parser considers any sequence of characters to be a
    valid identifier, without checking whether a variable is defined before being
    used, or whether a variable is not defined several times. For such checks, further
    processing must be performed. This will be seen in the next project.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个程序解析器将任何字符序列都视为有效的标识符，而不检查变量在使用前是否已定义，或者变量是否被多次定义。对于此类检查，必须进行进一步的处理。这将在下一个项目中看到。
- en: The calc_analyzer project
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: calc_analyzer项目
- en: 'The preceding project followed a CFG to construct a parser. This is very nice,
    but there is a big problem: the `Calc` language is not context-free. In fact,
    there are two problems, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个项目遵循CFG来构建解析器。这很好，但有一个大问题：`Calc`语言不是上下文无关的。事实上，有两个问题，如下所示：
- en: Any use of a variable in input statements, output statements, and assignments
    must be preceded by a declaration of that variable.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入语句、输出语句和赋值语句中，任何变量的使用都必须先声明该变量。
- en: Any variable must not be declared more than once.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何变量都不应被声明多次。
- en: Such requirements cannot be expressed in a context-free language.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的要求无法在上下文无关语言中表达。
- en: In addition, `Calc` has just one data type—that is, floating-point numbers—but
    consider if it also had a string type. You can add subtract two numbers, but you
    cannot subtract two strings. If a variable named `a` is declared of type `number`
    and a variable named `b` is declared of type `string`, you cannot assign `a` to
    `b`, or vice versa.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Calc`只有一个数据类型——即浮点数——但考虑一下如果它也有字符串类型会怎样。你可以加减两个数字，但不能减去两个字符串。如果声明了一个名为`a`的变量为`number`类型，而另一个名为`b`的变量为`string`类型，你不能将`a`赋值给`b`，反之亦然。
- en: In general, the operations allowed on a variable depend on the type used to
    declare that variable. And also, this constraint cannot be expressed in a CFG.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，对一个变量的操作取决于声明该变量时使用的类型。此外，这种约束无法在CFG中表达。
- en: Instead of defining a formal **context-dependent grammar** (**CDG**) that would
    be hard to specify and to parse, the usual path is to define such rules, called *semantic*
    rules, in an informal way, and then to postprocess the syntax tree to check the
    validity of such rules.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免定义一个难以指定和解析的正式**上下文相关语法**（**CDG**），通常的做法是以非正式的方式定义这样的规则，称为**语义**规则，然后对语法树进行后处理以检查这些规则的有效性。
- en: Here, we will call the module that performs such semantic checks `analyzer`
    (using a semantic checker that verifies some constraints on variables, such as
    the fact that they must be defined before being used, and the fact that variables
    cannot be defined more than once), and `calc_analyzer` is the project that adds
    the module to the parser.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将执行此类语义检查的模块称为`analyzer`（使用一个语义检查器来验证变量的一些约束，例如变量在使用前必须被定义，以及变量不能被定义多次的事实），而`calc_analyzer`项目则是将此模块添加到解析器中的项目。
- en: In the next section, we will see the architecture of the `analyzer` module.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到`analyzer`模块的架构。
- en: Checking the variables of the parsed program
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查解析程序的变量
- en: The analyzer starts where the parser finished—with a syntax tree containing
    strings of identifiers, values of literals, and operators. So, it no longer needs
    the source code. To accomplish its task, it visits such a tree and, every time
    it encounters a variable declaration, it must ensure that it has not been declared
    already, while every time it encounters a variable use, it must ensure it has
    already been declared.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器从解析器结束的地方开始——一个包含标识符字符串、文字值和运算符的语法树。因此，它不再需要源代码。为了完成其任务，它遍历这样的树，每次遇到变量声明时，都必须确保它尚未被声明，而每次遇到变量使用时，都必须确保它已经被声明。
- en: To perform such tasks without wandering around the syntax tree, another data
    structure is needed. Such a data structure is a collection of the variables already
    declared so far, while the syntax tree is visited. When a variable declaration
    is encountered, the analyzer looks in such a collection for a preceding declaration
    of the same variable; if it is found, it is a double-declaration error; otherwise,
    an entry is added to the collection.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不遍历语法树的情况下执行此类任务，还需要另一个数据结构。这样的数据结构是在遍历语法树时收集已声明的变量集合，当遇到变量声明时，分析器会在此集合中查找该变量的先前声明；如果找到，则是一个重复声明的错误；否则，将向集合中添加一个条目。
- en: Also, when a variable use is encountered, the analyzer looks in such a collection
    for a preceding declaration of the same variable, though this time, if it is not
    found, it is a missing-declaration error. For our simple language, such a collection
    contains only variables, but in more complex languages it will contain any kind
    of identifiers—constants, functions, namespaces, and so on. An alternative name
    for the identifier is a **symbol**; so, usually, this collection is named **symbol
    table**.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当遇到变量使用时，分析器会在这样的集合中查找相同变量的先前声明，尽管这次，如果没有找到，则是一个缺少声明的错误。对于我们的简单语言，这样的集合只包含变量，但在更复杂的语言中，它将包含任何类型的标识符——常量、函数、命名空间等等。标识符的另一个名称是**符号**；因此，通常，这个集合被称为**符号表**。
- en: To perform variable checking of a `Calc` program, our symbol table just needs
    to store the names of the variables, although we want our analyzer to perform
    some other tasks, which will be useful if we want to build an interpreter. An
    interpreter, when it is running a program, must store the *values* of the identifiers
    somewhere, not only their name, and as we already have a collection of variables
    storing the name of each variable, we can reserve space in the entry of a variable
    for the value of each variable. This will be useful when we build an interpreter
    for `Calc`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对`Calc`程序进行变量检查，我们的符号表只需要存储变量的名称，尽管我们希望我们的分析器执行一些其他任务，这些任务在构建解释器时将非常有用。解释器在运行程序时必须在某处存储标识符的*值*，而不仅仅是它们的名称，因为我们已经有一个存储每个变量名称的变量集合，我们可以在变量的条目中为每个变量的值预留空间。当我们为`Calc`构建解释器时，这将非常有用。
- en: But that is more than what we can do in the analyzer, in preparation of an interpreter.
    The interpreter must scan a kind of syntax tree to execute the statements, and
    when it encounters a variable it must look for its value. The syntax tree generated
    by the parser contains the identifiers of the variables, not their values, so
    the interpreter, every time it finds a variable, should search the symbol table
    for that string.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 但这超出了分析器在为解释器做准备时能做的事情。解释器必须扫描一种语法树来执行语句，当它遇到变量时，它必须查找其值。解析器生成的语法树包含变量的标识符，而不是它们的值，所以每当解释器找到一个变量时，它都应该在符号表中搜索那个字符串。
- en: But we want a fast interpreter, and string lookup is not so fast as using a
    pointer or an index into an array. So, to prepare for fast interpretation, while
    the analyzer visits the syntax tree, it replaces every identifier with an index
    of its position in the symbol table. Well, a string cannot be replaced by a number
    in Rust, so one possible technique would be to reserve an index field in the syntax
    tree, and fill that index when the variable is found in the symbol table.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们想要一个快速的解释器，而字符串查找并不像使用指针或数组索引那样快。所以，为了准备快速解释，当分析器访问语法树时，它会将每个标识符替换为其在符号表中的位置索引。嗯，在Rust中，字符串不能被数字替换，所以一种可能的技术是在语法树中预留一个索引字段，并在变量在符号表中找到时填充该索引。
- en: Here, another technique has been chosen. The analyzer, while visiting the syntax
    tree, constructs a parallel analyzed tree, very similar in structure, but having
    indexes into the symbol table instead of identifiers. Such a tree, together with
    the symbol table that reserves space for the values of the variables, will be
    optimal for interpreting the program.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，选择了另一种技术。分析器在访问语法树的同时，构建了一个并行分析的树，结构非常相似，但使用符号表中的索引而不是标识符。这样的树，加上为变量值预留空间的符号表，将非常适合解释程序。
- en: 'So, first of all, let''s see what is done by this project. Open the `calc_analyzer`
    folder and type the following: `cargo run data/sum.calc`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们看看这个项目做了什么。打开`calc_analyzer`文件夹，并输入以下命令：`cargo run data/sum.calc`。
- en: 'The following output should appear on the console:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出应出现在控制台上：
- en: '[PRE42]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding code program, as with the one before that, does not have an output
    for the user. It parses the source code into a syntax tree, and then analyzes
    that syntax tree, constructing a symbol table and an analyzed program. The output
    is just the pretty-print of such data structures.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码程序，就像之前的那个一样，没有为用户输出。它将源代码解析成语法树，然后分析该语法树，构建符号表和分析程序。输出只是这些数据结构的格式化打印。
- en: The first structure dumped is the symbol table. It has two entries—the `a` variable,
    with `0.0` as its initial value, and the `b` variable, with `0.0` as its initial
    value.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 首先输出的结构是符号表。它有两个条目——`a`变量，其初始值为`0.0`，以及`b`变量，其初始值也为`0.0`。
- en: Then, there is the analyzed program that is very similar to the parsed program
    printed by the previous project. The only differences are that all the occurrences
    of `"a"` are replaced by `0`, and all the occurrences of `"b"` are replaced by
    `1`. These numbers are the positions of such variables inside the symbol table.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是分析后的程序，它与上一个项目中打印的解析程序非常相似。唯一的不同之处在于，所有`"a"`的出现都被替换为`0`，所有`"b"`的出现都被替换为`1`。这些数字是这些变量在符号表中的位置。
- en: The project extends the preceding project. The `parser.rs` source file is identical,
    and two other files are added—`symbol_table.rs` and `analyzer.rs`. But let's start
    with the `main.rs` file first.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目扩展了前面的项目。`parser.rs`源文件是相同的，另外增加了两个文件——`symbol_table.rs`和`analyzer.rs`。但让我们首先从`main.rs`文件开始。
- en: Understanding the main.rs file
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`main.rs`文件
- en: 'This file performs all that is done by the preceding project, except the final
    pretty-print, which is replaced by the following lines:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件执行了前面项目中执行的所有操作，除了最后的格式化打印，它被以下行替换：
- en: '[PRE43]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From the preceding code snippet, the two data structures constructed by the
    analyzer are first declared—`analyzed_program` is the syntax tree with the indexes
    to the variables, and `variables` is the symbol table.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，分析器构建的两个数据结构首先声明——`analyzed_program`是带有变量索引的语法树，而`variables`是符号表。
- en: All the analysis is performed by the `analyze_program` function. If it succeeds,
    it will return the analyzed program, and, in the end, the two structures are printed.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的分析都是由`analyze_program`函数执行的。如果成功，它将返回分析后的程序，最后打印出这两个结构。
- en: Now, let's examine the symbol table (`symbol_table.rs`) implementation.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查符号表（`symbol_table.rs`）的实现。
- en: Looking at the symbol_table.rs file
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看symbol_table.rs文件
- en: In the `symbol_table.rs` file, there is an implementation of the `SymbolTable`
    type, which is a collection of the identifiers found in the source code. Each
    entry of a symbol table describes a variable. Such an entry must contain at least
    the name of the variable. In a typed language, it must also contain a representation
    of the data type of that variable, though `Calc` doesn't need that, as it has
    only one data type.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在`symbol_table.rs`文件中，有一个`SymbolTable`类型的实现，这是一个包含源代码中找到的标识符的集合。符号表的每个条目描述一个变量。这样的条目必须至少包含变量的名称。在类型语言中，它还必须包含该变量的数据类型的表示，尽管`Calc`不需要那个，因为它只有一个数据类型。
- en: If the language supports scoping in blocks, functions, classes, or larger structures
    (compilation units, modules, namespaces, or packages), there must be several symbol
    tables or a symbol table that specifies such scoping, though `Calc` doesn't need
    that, as it has only one scope.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语言支持在块、函数、类或更大的结构（编译单元、模块、命名空间或包）中进行作用域，那么必须有多个符号表或一个指定这种作用域的符号表，尽管`Calc`不需要那个，因为它只有一个作用域。
- en: A symbol table is useful primarily for checking identifiers and for translating
    code into another language, although it can also be used for interpreting code.
    When an interpreter is evaluating an expression, it needs to get the current value
    of the variables used in such an expression. A symbol table can be used to store
    the current value of any variable and provide such values to the interpreter.
    So, if you want to support an interpreter, your symbol table should also reserve
    space for the current values of the defined variables.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 符号表主要用于检查标识符和将代码翻译成另一种语言，尽管它也可以用于解释代码。当解释器评估一个表达式时，它需要获取该表达式中使用的变量的当前值。符号表可以用来存储任何变量的当前值，并提供这些值给解释器。因此，如果你想支持解释器，你的符号表也应该为定义的变量的当前值预留空间。
- en: In the next project, we will create an interpreter, and so, to support it, here,
    we add to any entry of our symbol table a field where the current value of the
    variable is stored. The type of each entry of our symbol table will be `(String,
    f64)`, where the first field is the name of the variable, and the second one is
    the current value of the variable. This value field will be accessed when interpreting
    a program.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，我们将创建一个解释器，因此，为了支持它，在这里，我们在符号表的每个条目中添加了一个字段，用于存储变量的当前值。我们符号表的每个条目的类型将是`(String,
    f64)`，其中第一个字段是变量的名称，第二个字段是变量的当前值。这个值字段将在解释程序时被访问。
- en: 'How can our code access the entries of a symbol table? When analyzing the program,
    we must search for a string, and so a hash table would offer top performance.
    However, when interpreting the code, we can replace identifiers with indexes,
    and so using indexes into a vector would offer top performance. Here, for simplicity,
    a vector has been chosen, which anyway is good enough if there aren''t many variables.
    So, our definition is given as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何访问符号表中的条目？在分析程序时，我们必须搜索一个字符串，因此哈希表将提供最佳性能。然而，在解释代码时，我们可以用索引替换标识符，因此使用向量中的索引将提供最佳性能。在这里，为了简单起见，选择了一个向量，如果没有很多变量，这已经足够好了。因此，我们的定义如下所示：
- en: '[PRE44]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the `SymbolTable` type, three methods are implemented, as shown in the
    following code snippet:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `SymbolTable` 类型，实现了三种方法，如下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `new` method simply creates an empty symbol table.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 方法简单地创建一个空的符号表。'
- en: 'The `insert_symbol` method tries to insert the specified identifier into a symbol
    table. If there is no identifier with such a name, an entry is added for that
    name, with zero as the default value, and the `Ok` result is the index of the
    new entry. Otherwise, the `Error: Identifier ''{}'' declared several times.` message is
    returned in the `Err` result.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_symbol` 方法试图将指定的标识符插入到符号表中。如果没有具有该名称的标识符，则为此名称添加一个条目，默认值为零，并且 `Ok`
    结果是新条目的索引。否则，在 `Err` 结果中返回错误消息 `Error: Identifier ''{}'' declared several times.`。'
- en: 'The `find_symbol` method tries to find the specified identifier in the symbol
    table. If it is found, the `Ok` result is the index of the found entry. Otherwise, the `Error:
    Identifier ''{}'' used before having been declared.` error message is returned
    in the `Err` result.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_symbol` 方法试图在符号表中找到指定的标识符。如果找到，则 `Ok` 结果是找到条目的索引。否则，在 `Err` 结果中返回错误消息
    `Error: Identifier ''{}'' used before having been declared.`。'
- en: Now, let's see the analyzer source file.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看分析器的源文件。
- en: Glancing at the analyzer.rs file
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单地查看 analyzer.rs 文件
- en: 'As discussed before, the analysis phase reads the hierarchical structure created
    by the parsing phase and constructs another hierarchical structure, having the `AnalyzedProgram` type.
    So, this module must declare such a `type` and all the types it needs, paralleling
    the `ParsedProgram` type, as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，分析阶段读取解析阶段创建的分层结构，并构建另一个具有 `AnalyzedProgram` 类型的分层结构。因此，此模块必须声明此类以及它需要的所有类型，与
    `ParsedProgram` 类型并行，如下所示：
- en: '[PRE46]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Any analyzed program is a sequence of analyzed statements, as illustrated in
    the following code snippet:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 任何分析程序是一系列分析语句，如下面的代码片段所示：
- en: '[PRE47]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Any analyzed statement is any one of the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 任何分析语句都是以下之一：
- en: A declaration referring a variable by index
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过索引引用变量的声明
- en: An input operation referring a variable by index
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过索引引用变量的输入操作
- en: An output operation containing an analyzed expression
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含分析表达式的输出操作
- en: An assignment referring a variable by index and containing an analyzed expression
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过索引引用变量并包含分析表达式的赋值操作
- en: 'Any analyzed expression is a pair of an analyzed term and a sequence of zero
    or more pairs of an expression operator and an analyzed term, as illustrated in
    the following code snippet:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 任何分析表达式是一个分析项和一个表达式运算符与一个分析项的零个或多个对的序列，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Any analyzed term is a pair of an analyzed factor and a sequence of zero or
    more pairs of a term operator and an analyzed factor, as illustrated in the following
    code snippet:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 任何分析项是一个分析因子和一个项运算符与一个分析因子的零个或多个对的序列，如下面的代码片段所示：
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Any analyzed factor is a literal containing a 64-bit floating-point number,
    or an identifier referring a variable by index, or a subexpression containing
    a reference to a heap-allocated analyzed expression, as illustrated in the following
    code snippet:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 任何分析因子是一个包含64位浮点数的字面量，或通过索引引用变量的标识符，或包含对堆分配的分析表达式的引用的子表达式，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The entry point of the analyzer is shown in the following code snippet:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器的入口点如下面的代码片段所示：
- en: '[PRE51]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `analyze_program` function, as with all the functions of this module, gets
    a mutable reference to the symbol table, as they all must, directly or indirectly
    read and write symbols. In addition, it gets a reference to a parsed program.
    If the function is successful, it updates the symbol table and it returns an analyzed
    program; otherwise, it may leave partially updated the symbol table and return
    an error message.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`analyze_program`函数，如同此模块的所有函数一样，获取符号表的可变引用，因为它们都必须直接或间接地读取和写入符号。此外，它获取一个解析程序的引用。如果函数成功，它将更新符号表并返回一个分析程序；否则，它可能留下部分更新的符号表并返回一个错误消息。'
- en: The body simply creates an empty analyzed program and processes all the parsed
    statements, by calling `analyze_statement`. Any parsed statement is analyzed,
    and the resulting analyzed statement is added to the analyzed program. For any
    failing analysis of a statement, the generated error is returned immediately as
    an error of this function.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 主体简单地创建一个空的已分析程序并处理所有解析语句，通过调用`analyze_statement`。任何解析语句都会被分析，分析后的语句被添加到已分析程序中。对于任何语句分析失败，将立即返回此函数的错误。
- en: 'So, we need to know how to analyze statements, which is shown as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要了解如何分析语句，如下所示：
- en: '[PRE52]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `analyze_statement` function matches the received parsed statements against
    the four kinds of statements, extracting the member of the respective variants.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`analyze_statement`函数将接收到的解析语句与四种语句类型进行匹配，提取相应变体的成员。'
- en: The identifier contained in declarations should never have been defined, and
    so it should be absent from the symbol table. Therefore, when processing this
    kind of statement, this identifier is inserted in the symbol table using the `let
    handle = variables.insert_symbol(identifier)?` Rust statement. If the insertion
    fails, the error is propagated out of this function. If the insertion succeeds,
    the position of the symbol is stored in a local variable.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明中包含的标识符从未被定义过，因此它应该不存在于符号表中。因此，在处理这类语句时，此标识符将通过使用`let handle = variables.insert_symbol(identifier)?`Rust语句插入到符号表中。如果插入失败，错误将传递出此函数。如果插入成功，符号的位置将存储在一个局部变量中。
- en: The identifier contained in assignments and in the input operations should have
    already been defined, and so it should be contained in the symbol table. Therefore,
    when processing this kind of statement, the identifiers are looked up in the symbol
    table using the `let handle = variables.find_symbol(identifier)?` Rust statement.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值和输入操作中包含的标识符应该已经被定义，因此它应该包含在符号表中。因此，在处理这类语句时，标识符将通过使用`let handle = variables.find_symbol(identifier)?`Rust语句在符号表中查找。
- en: The expressions contained in assignments and in output operations are analyzed
    by the `let analyzed_expr = analyze_expr(variables, expr)?` Rust statement. If
    the analysis fails, the error is propagated out of this function. If the analysis
    succeeds, the resulting analyzed expression is stored in a local variable.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值和输出操作中包含的表达式通过`let analyzed_expr = analyze_expr(variables, expr)?`Rust语句进行分析。如果分析失败，错误将传递出此函数。如果分析成功，分析后的结果表达式将存储在一个局部变量中。
- en: For any of the four `Calc` statement kinds, if no errors have been encountered,
    the function returns a success result containing the respective analyzed statement
    variant.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四种`Calc`语句类型中的任何一种，如果没有遇到错误，函数将返回一个包含相应分析语句变体的成功结果。
- en: 'So, we need to know how to analyze expressions, shown as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要了解如何分析表达式，如下所示：
- en: '[PRE53]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The received parsed expression is a pair—`&parsed_expr.0` is a parsed term and
    `&parsed_expr.1` is a vector of pairs of an expression operator and an analyzed
    term. We want to construct an analyzed expression that has the same structure.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的解析表达式是一个对——`&parsed_expr.0`是一个解析项，`&parsed_expr.1`是一个包含表达式运算符和分析项对的向量。我们想要构建一个具有相同结构的分析表达式。
- en: So, first, the first term is analyzed. Then, an empty list of pairs of an expression
    operator and an analyzed term is created; this is the analyzed vector. Then, for
    each item of the parsed vector, an item is constructed and added to the analyzed
    vector. Lastly, the pair of the first analyzed term and the vector of the other
    analyzed terms are returned.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先分析第一个项。然后，创建一个空的包含表达式运算符和分析项对的列表；这就是分析向量。然后，对于解析向量的每个项目，构建一个项目并添加到分析向量中。最后，返回第一个分析项和其他分析项的向量对。
- en: 'So, we need to know how to analyze terms, through the following code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要了解如何通过以下代码分析项：
- en: '[PRE54]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding routine is quite similar to the one before that. The first parsed
    factor is analyzed to get the first analyzed factor, and the other parsed factors
    are analyzed to get the other analyzed factors.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序与之前的程序非常相似。首先解析的因子被分析以获得第一个分析因子，其他解析因子被分析以获得其他分析因子。
- en: 'So, we need to know how to analyze factors. This is shown as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要了解如何分析因子。如下所示：
- en: '[PRE55]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The logic of the `analyze_factor` function is this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`analyze_factor` 函数的逻辑如下：'
- en: If the parsed factor to analyze is a literal, an analyzed literal is returned,
    containing the same value.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要分析解析的因子是一个字面量，则返回一个分析后的字面量，其中包含相同的值。
- en: If it is an identifier, an analyzed identifier is returned, containing the index
    into the symbol table where the parsed identifier is found. If it is not found,
    an error is returned.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个标识符，则返回一个分析后的标识符，其中包含解析到的标识符在符号表中的索引。如果未找到，则返回错误。
- en: If the parsed factor to analyze is a subexpression, a subexpression is returned,
    containing a boxed analyzed expression, obtained by analyzing the parsed expression,
    if successful. If it fails, an error is returned.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要分析解析的因子是一个子表达式，则返回一个子表达式，其中包含一个通过分析解析表达式获得的包装分析表达式，如果成功。如果失败，则返回错误。
- en: So, we have completed the examination of the analyzer module.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了分析器模块的审查。
- en: In this section, we have seen how the result of the parser created in the previous
    section can be analyzed, applying a CSG, which is needed to build an interpreter
    or a compiler. The next project will show us how to use and execute an analyzed
    program.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何分析上一节创建的解析器的结果，应用了 CSG（这是构建解释器或编译器所需的）。下一个项目将展示我们如何使用和执行分析程序。
- en: The calc_interpreter project
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: calc_interpreter 项目
- en: At last, we have reached the project in which we can actually run our `Calc`
    programs.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了可以实际运行我们的 `Calc` 程序的项目。
- en: 'To run it, enter the `calc_interpreter` folder, and type `cargo run`. After
    compilation, the following text will appear on the console:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，进入 `calc_interpreter` 文件夹，并输入 `cargo run`。编译后，以下文本将出现在控制台上：
- en: '[PRE56]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The first line is an introduction message, and the second one is a prompt.
    Now, we type the following as an example:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是介绍信息，第二行是提示符。现在，我们输入以下内容作为示例：
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After you press *Ent**er*, this `Calc` program is executed. The `a` variable
    is declared, and when the input statement is executed, a question mark will appear
    on the console. Type `5` and press *Enter*.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在您按下 *Enter* 后，此 `Calc` 程序将被执行。声明了 `a` 变量，当执行输入语句时，控制台将出现一个问号。输入 `5` 并按 *Enter*。
- en: The program goes on by declaring the `b` variable, assigning to it the value
    of the `a + 2` expression,  and then printing `7` as the value of `b`. Then, the
    program finishes, and the prompt reappears.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 程序继续声明 `b` 变量，将其赋值为 `a + 2` 表达式的值，然后打印 `b` 的值为 `7`。然后，程序结束，提示符重新出现。
- en: 'So, on the screen, there will be the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在屏幕上，将有以下内容：
- en: '[PRE58]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The interpreter, in addition, has some specific commands to be able to run
    `Calc` programs. If instead of a command, you type `v` (for *variables*) and then
    *Enter*, you will see the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器此外还有一些特定命令，以便能够运行 `Calc` 程序。如果您输入 `v`（代表 *变量*）然后按 *Enter*，您将看到以下内容：
- en: '[PRE59]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This command has dumped the contents of the symbol table, showing all the variables
    declared so far, with their current value. Now, you can type other `Calc` commands,
    using such variables with their current values.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令已转储符号表的内容，显示迄今为止声明的所有变量及其当前值。现在，您可以使用这些变量及其当前值输入其他 `Calc` 命令。
- en: Another interpreter command is `c` (for clear variables), which empties the
    symbol table. The last one is `q` (for quit), which terminates the interpreter.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解释器命令是 `c`（代表清除变量），它清空符号表。最后一个命令是 `q`（代表退出），它终止解释器。
- en: And how are `Calc` commands executed? If you have an analyzed program tree,
    and the associated symbol table containing space for the value of the variables,
    it is quite easy. It is enough to apply semantics (that is, a behavior) to any
    analyzed element, and the program will run by itself.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `Calc` 命令是如何执行的？如果您有一个分析程序树，以及包含变量值空间的关联符号表，这相当简单。只需将语义（即行为）应用于任何分析元素，程序就会自行运行。
- en: Also, this project extends the previous project. The `parser.rs` and `analyzer.rs`
    source files are identical; some lines are added to the `symbol_table.rs` file,
    and one other file is added—`executor.rs`. But let's start with the `main.rs` file.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此项目扩展了先前的项目。`parser.rs`和`analyzer.rs`源文件是相同的；向`symbol_table.rs`文件中添加了一些行，并添加了一个其他文件——`executor.rs`。但让我们从`main.rs`文件开始。
- en: Learning about the main.rs file
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解main.rs文件
- en: This file contains two functions in addition to the `main` functions—`run_interpreter` and
    `input_command`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含两个函数，除了`main`函数外，还有`run_interpreter`和`input_command`。
- en: 'The `main` function just calls `run_interpreter`, as that is the purpose of
    an interpreter. This function has the following structure:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数仅调用`run_interpreter`，因为这是解释器的目的。此函数具有以下结构：'
- en: '[PRE60]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: After printing an introduction message and creating a symbol table, the function
    enters an endless loop.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印介绍消息并创建符号表后，函数进入一个无限循环。
- en: The first statement of the loop is a call to the `input_command` function, which
    reads a command from the console (or from a file or a pipe, if the standard input
    is redirected). Then, if EOF has been reached, the loop is exited, and so is the
    whole program.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的第一个语句是调用`input_command`函数，该函数从控制台（或从文件或管道，如果标准输入被重定向）读取命令。然后，如果到达EOF，则退出循环，整个程序也随之退出。
- en: Otherwise, the interpreter-specific commands are handled, and if in the input
    text there is no such command, it is handled like a `Calc` program by parsing
    it and then analyzing the parsed program, and then executing the analyzed program.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，处理解释器特定的命令，如果在输入文本中没有这样的命令，它将被解析并分析为一个`Calc`程序，然后执行分析后的程序。
- en: 'The following code block shows how interpreter commands are implemented:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了解释器命令的实现方式：
- en: '[PRE61]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A `q` (quit) command simply breaks out from the loop. A `c` (clear) command replaces
    the symbol table with a new one. A `v` (variables) command iterates the symbol
    table entries, and prints the name and the current value of each of them.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`q`（退出）命令简单地跳出循环。一个`c`（清除）命令用一个新的符号表替换当前的符号表。一个`v`（变量）命令遍历符号表条目，并打印每个条目的名称和当前值。
- en: 'If the input text is not one of such one-letter commands, it is treated by
    the following code:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入文本不是这样的单字母命令之一，它将被以下代码处理：
- en: '[PRE62]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `parser::parse_program` function, if successful, creates a parsed program
    object. In the case of an error or in the case that some input remains to be parsed,
    an error message is printed and the command is discarded.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`parser::parse_program`函数，如果成功，创建一个解析程序对象。在出错或输入中仍有待解析的内容的情况下，打印错误消息并丢弃命令。'
- en: Otherwise, `analyzer::analyze_program` uses such a parsed program to create,
    if successful, an analyzed program object. In the case of error, an error message
    is printed and the command is discarded.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`analyzer::analyze_program`使用这样的解析程序创建（如果成功）一个分析程序对象。在出错的情况下，打印错误消息并丢弃命令。
- en: Lastly, the analyzed program is executed by the call to `executor::execute_program`.
    Now, let's see what has changed in the `symbol_table.rs` file.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用`executor::execute_program`执行分析程序。现在，让我们看看`symbol_table.rs`文件中有什么变化。
- en: Glancing at the symbol_table.rs file
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速查看symbol_table.rs文件
- en: 'Three functions having the following signatures have been added to the implementation
    of the `SymbolTable` type:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 已向`SymbolTable`类型的实现中添加了以下签名的三个函数：
- en: '[PRE63]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `get_value` function gets the value of a variable, given its index. The
    `set_value` function sets the value of a variable, given its index and the value
    to assign. The `iter` function returns a read-only iterator on the variables stored
    in the symbol table. For each variable, a pair of the name and the value is returned.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_value`函数根据变量的索引获取变量的值。`set_value`函数根据索引和要分配的值设置变量的值。`iter`函数返回一个只读迭代器，用于遍历符号表中存储的变量。对于每个变量，返回一个包含名称和值的对。'
- en: And next, we see the module that implements the core of the interpreter.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到实现解释器核心的模块。
- en: Understanding the executor.rs file
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解executor.rs文件
- en: 'This module does not declare types as it uses only the ones declared in the
    other modules. The entry point is the function capable of executing whole programs,
    shown as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块没有声明类型，因为它只使用其他模块中声明的类型。入口点是能够执行整个程序的功能，如下所示：
- en: '[PRE64]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It receives a mutable reference to a symbol table and a reference to an analyzed
    program, and simply calls the `execute_statement` function on any statement of
    that program.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收一个可变引用到符号表和一个引用到已分析程序，并简单地对该程序中的任何语句调用`execute_statement`函数。
- en: 'The following code block shows the last function (this is more complex):'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了最后一个函数（这更复杂）：
- en: '[PRE65]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: According to the kind of statement being used, it performs different actions. For
    assignments, it calls the `evaluate_expr` function to get the value of the associated
    expression and uses `set_value` to assign that value to the associated variable.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所使用的语句类型，执行不同的操作。对于赋值，它调用`evaluate_expr`函数以获取相关表达式的值，并使用`set_value`将该值赋给相关变量。
- en: For declarations, nothing needs to be done, because the insertion of the variable
    into the symbol table and its initialization has already been done by the analyzer.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 对于声明，不需要做任何事情，因为变量插入符号表及其初始化已经由分析器完成。
- en: For input operations, a question mark is printed as a prompt, and a line is
    read and parsed to an `f64` number. If the conversion fails, zero is used. The
    value is then stored into the symbol table as a new value of the variable.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入操作，打印一个问号作为提示，然后读取一行并将其解析为`f64`数字。如果转换失败，则使用零。然后将该值存储到符号表中作为变量的新值。
- en: 'For output operations, the expression is evaluated and the resulting value
    is printed. The following code shows how to evaluate `Calc` expressions:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输出操作，评估表达式并打印结果值。以下代码显示了如何评估`Calc`表达式：
- en: '[PRE66]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: First, the first term is evaluated by calling the `evaluate_term` function,
    and its value is stored as a provisional result.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过调用`evaluate_term`函数来评估第一个项，并将其值存储为一个临时结果。
- en: Then, for every other term, the term is evaluated and the obtained value is
    added or subtracted to the provisional result, according to the kind of expression
    operator being used.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于其他每个项，根据所使用的表达式运算符的类型，评估该项并获得的值加到或减去临时结果。
- en: 'The following code block shows how to evaluate `Calc` terms:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了如何评估`Calc`项：
- en: '[PRE67]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding code block shows a function that is similar to the one before
    it. It uses the `evaluate_factor` function to evaluate all the factors of the
    current term, as illustrated in the following code snippet:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块显示了与之前类似的功能。它使用`evaluate_factor`函数评估当前项的所有因子，如下面的代码片段所示：
- en: '[PRE68]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: To evaluate a factor, the *kind of factor* is taken into account. The value
    of `literal` is just the contained value. The value of `identifier` is obtained
    for the symbol table, by calling `get_value`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估一个因子，需要考虑因子的类型。`literal`的值只是包含的值。`identifier`的值通过调用`get_value`从符号表中获得。
- en: The value of `SubExpression` is obtained by evaluating the expression contained
    in it. So, we have seen all that is needed to execute a `Calc` program interactively.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 通过评估它包含的表达式来获得`SubExpression`的值。因此，我们已经看到了执行一个`Calc`程序所需的所有内容。
- en: In this section, we have seen how the result of the context-sensitive analysis
    of a `Calc` program can be used to interpret that program. Such an interpretation
    can be interactive, through a **read-eval-print loop** (**REPL**) or by processing
    a file written in the `Calc` language.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用上下文相关分析的结果来解释`Calc`程序。这种解释可以是交互式的，通过**读取-评估-打印循环**（REPL）或通过处理用`Calc`语言编写的文件。
- en: In the next project, we will see how to translate a `Calc` program into a Rust
    program.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，我们将看到如何将`Calc`程序翻译成Rust程序。
- en: The calc_compiler project
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: calc_compiler项目
- en: Having an analyzed program (and its matching symbol table), it is easy also
    to create a program that translates it into another language. To avoid introducing
    a new language, the Rust language has been used here as a target language, but
    translating to other high-level languages would be no more difficult.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个已分析程序（及其匹配的符号表），也容易创建一个将其翻译成另一种语言的程序。为了避免引入一种新语言，这里使用了Rust语言作为目标语言，但翻译到其他高级语言也不会更困难。
- en: 'To run it, go into the `calc_compiler` folder and type `cargo run data/sum.calc`.
    After compiling the project, the program will print the following:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，进入`calc_compiler`文件夹并输入`cargo run data/sum.calc`。在编译项目后，程序将打印以下内容：
- en: '[PRE69]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you go into the `data` subfolder, you will find the new `sum.rs` file, containing
    the following code:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入`data`子文件夹，你会找到一个名为`sum.rs`的新文件，其中包含以下代码：
- en: '[PRE70]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you like, you can compile it using the `rustc sum.rs` command, and then you
    can run the executable generated.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢，你可以使用`rustc sum.rs`命令来编译它，然后你可以运行生成的可执行文件。
- en: This file is always the same for any `Calc` program compiled, up to the line
    containing `fn main() {`. The `input` routine is the `Calc` runtime library.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何编译的`Calc`程序，此文件始终相同，直到包含`fn main() {`的行。`input`例程是`Calc`运行时库。
- en: The remaining part of the Rust-generated code corresponds to the `Calc` statements.
    Notice that all variables are mutable and initialized to `0.0`, and so their type
    is `f64`. The name of the variables begins with an underscore to prevent conflicts
    with Rust keywords.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: Rust生成的代码的其余部分对应于`Calc`语句。注意，所有变量都是可变的，并初始化为`0.0`，因此它们的类型是`f64`。变量的名称以前缀下划线开头，以防止与Rust关键字冲突。
- en: Actually, this project also contains the interpreter seen in the preceding project.
    If you run the project with no command-line argument, an interactive interpreter
    starts.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个项目还包含了前面项目中看到的解释器。如果你不带命令行参数运行项目，将启动一个交互式解释器。
- en: Let's see the source code next. Also, this project extends the preceding project.
    The `parser.rs`, `analyzer.rs`, and `executor.rs` source files are identical;
    some lines are added to the `symbol_table.rs` file, and one other file is added—`compiler.rs`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一部分的源代码。此外，这个项目扩展了前面的项目。`parser.rs`、`analyzer.rs`和`executor.rs`源文件相同；向`symbol_table.rs`文件添加了一些行，并添加了一个其他文件——`compiler.rs`。
- en: 'To the `symbol_table.rs` file, only one small function has been added. Its signature
    is shown as follows:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 只向`symbol_table.rs`文件添加了一个小的函数。其签名如下所示：
- en: '[PRE71]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It allows the name of an identifier to be obtained, given its index.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许根据索引获取标识符的名称。
- en: But let's start with the `main.rs` file.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们从`main.rs`文件开始。
- en: Glancing at the main.rs file
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简要查看`main.rs`文件
- en: The `main` function begins by examining the command-line arguments. If there
    are no arguments, the `run_interpreter` function is called, identical to that
    used in the `calc_interpreter` project.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数首先检查命令行参数。如果没有参数，则调用`run_interpreter`函数，与`calc_interpreter`项目中使用的相同。'
- en: 'Instead, if there is one argument, the `process_file` function is called on
    it. This is similar to that used in the `calc_analyzer` project. There are only
    two differences. One is the insertion of the statement, shown in the following
    code snippet:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果有单个参数，则会在其上调用`process_file`函数。这与`calc_analyzer`项目中使用的类似。只有两个区别。一个是插入的语句，如下面的代码片段所示：
- en: '[PRE72]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This generates the path of the resulting Rust file. The other is the replacement
    of the two ending statements, which print the result of the analysis, with the
    following code:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了结果Rust文件的路径。另一个是替换两个结束语句，这些语句打印分析的结果，如下所示：
- en: '[PRE73]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This performs the translation into Rust code, obtaining a multiline string,
    and writes that string into the target file.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这将翻译成Rust代码，获取一个多行字符串，并将该字符串写入目标文件。
- en: So, we need to examine the `compiler` module, defined in the `compiler.rs` source
    file.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要检查定义在`compiler.rs`源文件中的`compiler`模块。
- en: Understanding the compiler.rs file
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`compiler.rs`文件
- en: This module does not define types, as it uses those defined in the other modules.
    As with the parser, the analyzer, and the interpreter, it has a function for every
    language construct, and it performs the translation by visiting the analyzed program
    tree.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块不定义类型，因为它使用其他模块中定义的类型。与解析器、分析器和解释器一样，它为每种语言构造有一个函数，并通过遍历已分析程序树来执行翻译。
- en: 'The entry point begins with the following code:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点从以下代码开始：
- en: '[PRE74]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This function, as with all the others in this module, gets immutable references
    to the symbol table and to the analyzed program. It returns a `String` containing
    Rust code. An empty string is first created, and then the required lines are appended
    to it.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数，就像这个模块中的所有其他函数一样，获取对符号表和已分析程序的不可变引用。它返回一个包含Rust代码的`String`。首先创建一个空字符串，然后将所需的行附加到它。
- en: 'The final part of this function is shown in the following code block:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的最后部分如下所示：
- en: '[PRE75]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: For any `Calc` statement, the `translate_to_rust_statement` function is called,
    and the Rust code returned by it is appended to the string.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何`Calc`语句，都会调用`translate_to_rust_statement`函数，并将它返回的Rust代码附加到字符串上。
- en: 'The body of the function that translates a `Calc` statement into Rust code
    is shown as follows:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Calc`语句翻译成Rust代码的函数体如下所示：
- en: '[PRE76]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: To translate an assignment, the name of the variable is obtained from the symbol
    table by calling the `get_name` function, and the code corresponding to the expression
    is obtained by calling the `translate_to_rust_expr` function. The same is done
    for the other statements.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 为了翻译一个赋值，通过调用`get_name`函数从符号表中获取变量的名称，并通过调用`translate_to_rust_expr`函数获取对应表达式的代码。对于其他语句也执行同样的操作。
- en: 'To translate an expression, the following function is used:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 为了翻译一个表达式，使用了以下函数：
- en: '[PRE77]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The terms are translated by calling the `translate_to_rust_term` function. The
    additions and subtractions are translated using the `" + "` and `" - "` Rust string
    literals.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语通过调用`translate_to_rust_term`函数进行翻译。加法和减法使用Rust字符串字面量`" + "`和`" - "`进行翻译。
- en: The translation of a term is quite similar to that of an expression, but using
    the term operators and calls to the `translate_to_rust_factor` function instead.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 项的翻译与表达式的翻译非常相似，但使用项运算符和调用`translate_to_rust_factor`函数。
- en: 'The body of this function is defined as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数体定义如下：
- en: '[PRE78]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: For translating a literal, it is converted to a string and `"f64"` is appended
    to force its type. For translating an identifier, its name is taken from the symbol
    table. For translating a subexpression, the inner expression is translated, and
    the result is enclosed in parentheses.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字面量的翻译，它被转换成字符串，并附加`"f64"`来强制其类型。对于标识符的翻译，其名称从符号表中获取。对于子表达式的翻译，内部表达式被翻译，结果被括号包围。
- en: In this section, we have seen how to build a program in Rust that reads a `Calc`
    program and writes an equivalent Rust program. Such a resulting program can then
    be compiled using the `rustc` command.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了如何在Rust中构建一个程序，该程序读取`Calc`程序并生成等效的Rust程序。这样的程序然后可以使用`rustc`命令进行编译。
- en: Summary
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen some amount of theory of programming languages
    and the algorithms used to process them.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一些编程语言的理论以及处理它们的算法。
- en: In particular, we have seen that the syntax of programming languages can be
    expressed using a formal grammar. There is a useful classification of formal grammars—regular
    languages, context-free languages, and context-dependent languages.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们可以看到，编程语言的语法可以用形式文法来表示。形式文法有一个有用的分类——正则语言、上下文无关语言和上下文相关语言。
- en: Programming languages belong to the third category, but usually, they are first
    parsed as a regular language by a lexer. The result is parsed as a context-free
    language by a parser and is then analyzed to keep into account the context-dependent
    features.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言属于第三类，但通常它们首先被词法分析器解析为正则语言。结果是作为上下文无关语言由解析器解析，然后分析以考虑上下文相关特性。
- en: We have seen the most popular techniques to process texts written in a formal
    language, such as a programming language or a markup language—the compiler-compiler
    and the parser combinator. In particular, we saw how to use the Nom crate, which
    is a parser combinator library.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了处理形式语言（如编程语言或标记语言）文本的最流行技术——编译器-编译器和解析器组合器。特别是，我们看到了如何使用Nom crate，这是一个解析器组合器库。
- en: We saw many built-in parsers and parser combinators of Nom, and how to use them
    to create our own parsers, writing many Rust programs that used Nom to parse simple
    patterns. We defined the grammar of an extremely simple programming language,
    which we named `Calc`, and we built some tiny programs using it. We built a context-free
    parser for `Calc` that dumped on the console the data structure resulting from
    such a parsing (`calc_parser`).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了许多内置的Nom解析器和解析器组合器，以及如何使用它们来创建我们自己的解析器，编写了许多使用Nom解析简单模式的Rust程序。我们定义了一个极其简单的编程语言的语法，我们称之为`Calc`，并使用它构建了一些小程序。我们为`Calc`构建了一个上下文无关解析器，该解析器在控制台上输出解析后的数据结构（`calc_parser`）。
- en: We built a context-dependent analyzer for `Calc` that dumped on the console
    the data structure resulting from such an analysis (`calc_analyzer`). We built
    an interpreter for `Calc`, using the parser and analyzer described in the preceding
    projects (`calc_interpreter`). We built a compiler for `Calc` that could be used
    to translate a `Calc` program to an equivalent Rust program (`calc_compiler`).
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`Calc`构建了一个上下文相关分析器，该分析器在控制台上输出分析后的数据结构（`calc_analyzer`）。我们使用前面项目中描述的解析器和分析器为`Calc`构建了一个解释器（`calc_interpreter`）。我们还构建了一个编译器，可以将`Calc`程序翻译成等效的Rust程序（`calc_compiler`）。
- en: In the next chapter, we will be seeing another use of Nom and of parsing techniques,
    for processing binary data.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到Nom和解析技术处理二进制数据的另一种用途。
- en: Questions
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are regular languages, context-free languages, and context-dependent languages?
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则语言、上下文无关语言和上下文相关语言是什么？
- en: What is the Backus-Naur form to specify the grammar of a language?
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 巴科斯-诺尔范式是用来指定语言语法的什么？
- en: What is a compiler-compiler?
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器-编译器是什么？
- en: What is a parser combinator?
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器组合器是什么？
- en: Why did Nom have to use only macros before the 2018 edition of Rust?
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么Nom在2018年Rust版本之前必须只使用宏？
- en: What do the `tuple`, `alt`, and `map` functions of the Nom library do?
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nom库中的`tuple`、`alt`和`map`函数做什么？
- en: What are the possible phases of an interpreter of a programming language, without
    passing through an intermediate language?
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不通过中间语言，编程语言的解释器可能有哪些阶段？
- en: What are the possible phases of a compiler?
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器可能有哪些阶段？
- en: What is the purpose of a symbol table, when analyzing the use of variables?
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当分析变量使用时，符号表有什么作用？
- en: What is the purpose of a symbol table, when interpreting a program?
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当解释程序时，符号表有什么作用？
- en: Further reading
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Nom project can be downloaded from [https://github.com/Geal/nom](https://github.com/Geal/nom).
    This repository also contains some examples.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从[https://github.com/Geal/nom](https://github.com/Geal/nom)下载Nom项目。此存储库还包含一些示例。
- en: There are many textbooks about formal languages and about the software that
    manipulates them. In particular, you may search Wikipedia for the following terms: compiler-compiler, parser
    combinator, Backus-Naur form, syntax-directed translation.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 关于形式语言及其处理软件有许多教科书。特别是，你可以在维基百科上搜索以下术语：编译器-编译器、解析器组合器、巴科斯-诺尔范式、语法驱动翻译。
