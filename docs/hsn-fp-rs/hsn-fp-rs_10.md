# 第十章：评估

# 函数式编程——比较

1.  函数是什么？

函数定义了一个转换，接受数据，并返回转换的结果。

1.  函子是什么？

函子定义数据，接受一个转换，并返回转换的结果。

1.  元组是什么？

一个元组是一个固定数量不同值的容器。

1.  为与枚举一起使用而设计的控制流表达式是什么？

模式匹配表达式是枚举的匹配，反之亦然。

1.  函数作为参数的函数的名称是什么？

函数的函数被称为高阶函数。

1.  在记忆化的`fib(20)`中，`fib`将被调用多少次？

`fib`将被调用 39 次。`fib`将被调用 21 次。

1.  哪些数据类型可以通过通道发送？

发送的数据必须实现`Send`，这通常由编译器自动派生。

1.  为什么函数在从函数返回时需要被封装？

函数是特性，因此在编译时没有已知的大小。因此，它们必须被参数化或通过类似`Box`的方式转换为特性对象。

1.  `move`关键字的作用是什么？

`move`关键字将变量的所有权转移到新的上下文中。

1.  两个变量如何共享单个变量的所有权？

间接引用，如`Rc`，允许共享对同一数据的引用。

# 函数式控制流

1.  三元运算符是什么？

如果条件是三元运算符，但具有 Rust 独特的语法`if a { b } else { c }`。

1.  单元测试的另一个名字是什么？

单元测试也被称为**白盒测试**。

1.  集成测试的另一个名字是什么？

集成测试也被称为**黑盒测试**。

1.  什么是声明式编程？

声明式编程在描述程序时避免实现细节。

1.  命令式编程是什么？

命令式编程在描述程序时关注实现细节。

1.  迭代器特质中定义了什么？

迭代器特质由一个关联的`Item`类型和所需的`next`方法定义。

1.  折叠操作将遍历迭代器序列的方向是什么？

`fold`将从左到右遍历迭代器，或者更具体地说，从第一个到最后一个。

1.  依赖图是什么？

依赖图是一个有向图，描述了节点之间的依赖关系。在我们的情况下，我们使用它来描述形式为*x*必须在*y*之前发生的关联。

1.  `Option`的两个构造函数是什么？

`Option`可以创建为`Some(x)`或`None`。

# 函数式数据结构

1.  有什么好的库可以用来序列化和反序列化数据？

我们推荐`serde`。

1.  `physics.rs`中结构声明前面的`# derive`行的作用是什么？

这些是自动为这些数据结构派生特质实现的宏。

1.  参数化声明中哪个先来——生命周期还是特质？

生命周期参数必须在参数声明中的特性参数之前。

1.  在特质实现中，impl、trait 或类型上的参数之间有什么区别？

`impl<A,...>` 语法定义了哪些符号将被参数化。`Trait<A,...>` 语法定义了正在实现的特质。`Type<A,...>` 语法定义了特质正在为哪种类型实现。

1.  特质和数据类之间有什么区别？

术语 **数据类** 不是一个 Rust 术语。将数据类想象成一个特质，但比 Rust 可能施加的限制要少。

1.  应该如何声明一个包有多个二进制文件？

在 `Cargo.toml` 中，列出所有二进制文件及其入口点：

```rs
[[bin]]
name = "binary1"
path = "binary1.rs"

[[bin]]
name = "binary2"
path = "binary2.rs"
```

1.  如何声明结构字段为私有？

不要声明为 `public`。字段默认是 `private`。

# 泛型和多态

1.  什么是代数数据类型？

代数数据类型是一种由其他类型组合而成的复合类型。

1.  什么是多态？

多态是具有多种形式的质量。

1.  什么是参数化多态？

参数化多态是根据参数具有多种形式的质量。

1.  什么是基础类型？

基础类型是一种没有任何参数、修饰符或替换的类型。例如，`i32` 或 `String`。

1.  什么是通用函数调用语法？

通用函数调用语法用于区分函数或方法。它看起来像 `Foo::f(&b)` 而不是 `b.f()`。

1.  特质对象的可能类型签名有哪些？

特质对象是任何在编译时将具有已知大小的特质签名。常见的例子有 `&Trait` 或 `Box<Trait>`。

1.  有哪两种方法可以隐藏类型信息？

特质对象和特质通常隐藏信息。关联类型也减少了与代码交互所需的信息量。

1.  如何声明子特质？

```rs
trait SuperTrait: SubTrait1 + SubTrait2 {}
```

# 代码组织和应用程序架构

1.  有哪四种方式将代码分组到模块中？

我们的工作坊模型有四种方式将代码分组：按类型、按目的、按层和按便利性。

1.  FFI 代表什么？

FFI 代表 Foreign Function Interface。

1.  为什么需要 unsafe 块？

Rust 中的 `unsafe` 语法表示你想要使用超级能力，并且你接受相应的责任。

1.  是否在某个时候可以使用 unsafe 块是安全的？

没有什么是安全的。核心 Rust 开发者正在进行一项持续的努力，将标准库代码重写为使用更少的 `unsafe` 功能。尽管如此，根据你观察的深度，任何上下文中都没有绝对的安全性。例如，核心编译器只是假设在安全性检查方面始终逻辑上一致（希望它是）。

1.  `libc::c_int` 和 `i32` 之间有什么区别？

`c_int` 是一个直接别名——`type c_int = i32;`。

1.  链接库能否定义具有相同名称的函数？

C++ 使用名为名称混淆的技术来导出具有相同名称的符号。然而，Rust 目前不通过 `extern` 识别这种格式。

1.  可以将哪种类型的文件链接到 Rust 项目中？

链接库可以是以下形式之一：`name.a`*、`name.lib`、`name.so`、`name.dylib`、`name.dll`或`name.rlib`，每种都有其自己的格式。

# 可变性、所有权和纯函数

1.  `Rc`代表什么？

`Rc`代表引用计数。

1.  `Arc`代表什么？

`Arc`代表原子引用计数。

1.  什么是弱引用？

弱引用是一种不计入引用计数或以其他方式管理的引用。

1.  在不安全块中启用了哪些超能力？

在不安全块中，你可以取消引用原始指针，调用不安全函数或方法，访问或修改可变静态变量，或者实现不安全特质。

1.  对象何时会被丢弃？

当其所有者被丢弃或超出作用域时，对象将被丢弃。

1.  生命周期和所有权的区别是什么？

生命周期是编译时检查。所有权是编译时以及运行时概念。这两个概念都描述了变量的跟踪、值以及它们的使用者。

1.  如何确保一个函数是安全的？

在 Rust 中，无法在函数中声明不存在不安全行为。

1.  什么是内存损坏以及它会如何影响程序？

存在两种类型的内存损坏——物理内存损坏和软件内存损坏。如果你的物理内存损坏了，那么你需要更换你的硬件。软件内存损坏是指程序对其自身程序语义结构的破坏。当内存损坏时，一切都会出错；这是最难诊断和处理的 bug 类别之一。

# 设计模式

1.  什么是函子？

函子定义数据，接受一个函数，并返回数据的转换。

1.  什么是反变函子？

反变函子是一种接受函数可能产生 0、1 或多个返回值的函子。相比之下，函子的接受函数必须返回恰好 1 个值。

1.  什么是单子？

单子是一个参数化单一类型`A`的值，它有一个特质暴露两个操作，通常命名为`return`和`bind`。`return`是一个从提供的`A`值构建新的`monad<A>`的函数。`bind`应该结合新信息以产生一个相关但分离的`monad<B>`。

1.  什么是单子法则？

这些等价性必须对严格单子成立。三个水平条表示等价性：

```rs
_return(v).bind(f) ≡ f(v)

m.bind(_return) ≡ m

m.bind(f).bind(g) ≡ (|x| f(x).bind(g))
```

1.  什么是组合器？

函数组合器结合函数。一个更生成型的组合器结合事物。

1.  为什么 impl 关键字对于闭包返回值是必要的？

闭包是特质，而不是类型。因此，它们在编译时没有已知的大小。`impl`用于返回类型告诉编译器参数化返回类型。

1.  什么是惰性求值？

惰性求值是在未来某个时刻延迟计算。这与立即求值相对，立即求值是指计算立即发生。

# 实现并发

1.  什么是子进程？

子进程是由父进程启动的子进程。子进程必须保持在父进程下，才能继续被称为**子进程**。

1.  为什么 fork 被称为 fork？

fork 意味着一个分裂（进程），就像道路上的分叉，或者分叉的舌头。

1.  fork 仍然有用吗？

是的！如果你可以在你的系统上访问它。例如，心跳模式使用 fork 会更优雅。

1.  线程是在何时标准化的？

线程从未被普遍标准化。Posix 标准在 1995 年引入了线程。值得注意的是，Windows 没有提供关于线程行为的标准或保证。有相似之处，但没有标准。

1.  为什么有时需要移动线程闭包？

Move 告诉编译器，将捕获的变量的所有权转移到闭包中是可以的。

1.  `Send`和`Sync`特质的区别是什么？

`Sync`是对线程安全的一个更强声明——如果一个类型是`Send`，那么它可以安全地发送到另一个线程。一个类型是`Sync`，如果它可以安全地在线程之间共享。

1.  我们可以锁定什么，然后在不使用 unsafe 块的情况下突变互斥锁（Mutex）？

编译器已确定互斥锁（Mutex）已经足够安全以使用，并满足某些安全要求。但这并不意味着不会发生坏事——如果在恐慌期间丢失了其`MutexGuards`（当获取锁时返回的对象）之一，互斥锁会自我中毒。任何未来的尝试锁定互斥锁都将返回一个`Err`或`panic!`。

# 性能、调试和元编程

1.  发布模式与调试模式有何不同？

这取决于你的 Cargo 配置。默认情况下，有几个编译器标志在发布和调试模式下有不同的默认值。其中一个标志是发送到 llvm 代码生成的 opt-level，默认的调试 opt-level 是 2，默认的发布 opt-level 是 3。这些默认值可以在`Cargo.toml`中更改。

1.  一个空循环将运行多长时间？

尝试一下。否则，很难在每一个平台上确定。循环将始终是一个无限循环。`while true`可能也是一个无限循环，但会生成一个警告。`for _ in 0..99999999 {}`将在 opt-level 3 时被移除，但在 opt-level 2 时则不会。

1.  大 O 记号中的线性时间是什么？

线性时间是*O*(*n*)时间。

1.  命名一个比指数增长更快的函数。

阶乘*O*(*n*)!比指数增长增长得更快。

1.  磁盘读取和网络读取哪个更快？

测量一下。这里有许多物理因素需要考虑。

1.  你会如何返回包含多个错误条件的`Result`？

Rust 建议使用枚举类型来描述多个错误条件。由于懒惰，你也可以使用`std::any::Any`类型。

1.  令牌树是什么？

令牌树是一个包含令牌的树形数据结构。由于 Rust 的词法分析，(...), [...], 和 {...} 令牌组将变成它们自己的分支。

1.  抽象语法树（AST）是什么？

抽象语法树就像一个标记树，但它有一个严格的结构，只有格式良好的（Rust）代码才能由它表示。

1.  为什么过程宏需要单独编译？

过程宏是用常规 Rust 代码编写的。为了在编译中使用，过程宏需要已经被编译。
