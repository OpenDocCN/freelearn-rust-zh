# 记住，记住

使用 Rust 而不是 C 等语言的主要优势之一是其内存管理。例如，如果你尝试在数组的末尾或使用`malloc`预留的区域之后写入，C 程序将遇到缓冲区溢出和相关的不确定行为。Rust 在保持效率的同时，保护了大多数这些问题。

在本章中，我们将深入探讨 Rust 如何处理内存，并将涵盖以下主题：

+   理解 Rust 中使用的内存系统

+   如果你不小心，可能会出错

+   查看指针、引用、栈溢出和防止崩溃

+   分配和释放内存

# 让我们从一开始说起

在第二章*，变量*中，我简要介绍了数据在内存中的存储方式，我说非复合类型，如`i32`，存储在栈上，而`String`、`Vector<T>`等类型则存储在堆上。

默认情况下，Rust 将数据存储在栈上，因为它非常快。但是，也存在一些缺点。栈的大小有限，分配仅持续到函数的生存期。

问题是，一个函数需要多少内存？

# 栈帧

```rs
int values and the single float32 type:
```

```rs
    fn main() 
    { 
        let a = 10; 
        let b = 20; 
        let pi = 3.14f32; 
    } 
```

一旦`main`退出，在进入时分配的栈帧将被释放。分配和释放的美丽之处在于，它们在没有用户需要做任何事情的情况下完成。内存量也可以提前计算，因为编译器知道哪些局部变量正在使用。这再次提高了速度。

对于每一个优点，都有一个缺点：存储的值仅存在于方法的生存期内。

# 什么是栈？

考虑栈的最简单方式是将内存视为一系列盒子。对于这些示例，请将盒子分为四组：函数名、地址、变量名和值。以下是一个包含单个局部变量的`main`函数示例：

```rs
    fn main() 
    { 
        let i = 32; 
    } 
```

栈盒子将看起来像这样：

| **函数名** | **地址** | **变量名** | **值** |
| --- | --- | --- | --- |
| `main` | `0` | `i` | `32` |

以下是一个略有不同的示例：

```rs
    fn second() 
    { 
        let a = 32; 
        let b = 12; 
    } 
    fn main() 
    { 
        let d = 100; 
    } 
```

在这里，我们将有两个未连接的栈盒子。由于`second`函数从未被调用，我们实际上从未为它分配栈内存。因此，内存分配与第一个示例完全相同。

我们的第三个示例是`main`函数调用`second`函数的情况；在这种情况下，我们实际上为`second`函数预留了内存：

```rs
    fn second() 
    { 
        let a = 32; 
        let b = 12; 
    } 
    fn main() 
    { 
        let d = 100; 
        second(); 
    } 
```

就我们的栈盒子而言，我们有以下内容：

| **函数名** | **地址** | **变量名** | **值** |
| --- | --- | --- | --- |
| `second` | `2` | `a` | `32` |
|  | `1` | `b` | `12` |
| `main` | `0` | `d` | `100` |

`main`函数中的变量地址为 0，因为它来自最顶层帧——调用其他函数的帧。地址的值纯粹是为了这个例子；它可以在任何地方，并且通常，不同类型需要不同数量的栈空间来存储它们。例如，如果`number`类型长度为 4 字节，则地址将是存储`d`的栈的基地址，然后是地址+4 的`b`，最后是地址+8 的`a`。

一旦`foo`函数返回，栈将恢复到以下状态：

| **函数名** | **地址** | **变量名** | **值** |
| --- | --- | --- | --- |
| `main` | `0` | `d` | `100` |

一旦`main`函数执行完毕，栈就为空。

这种堆叠会持续到应用程序中有多少不同的函数，并且它们总是以相同的方式工作。

# 让我们考虑堆

如前所述，堆通常用于复杂类型。栈帧模型仍然可以使用，但需要修改，因为栈需要指向堆上复杂类型的基地址。

让我们为以下代码片段构建一个栈帧：

```rs
    fn main() 
    { 
        let f = 42; 
        let my_ids: Vec<i64> = Vec::with_capacity(5); 
    } 
```

| **函数名** | **地址** | **变量名** | **值** |
| --- | --- | --- | --- |
| `main` | `1` | `f` | `42` |
|  | `0` | `my_ids` | `(一个 Vector 实例)` |

空间已正确分配给`f`，但`my_ids`不同；它是一个预分配了五个`i64`值空间的`Vector<i64>`。虽然向量本身存储在栈上，但其内容是在堆上分配的。

堆中的值被认为比栈中的值更持久。这意味着，与栈中的值不同，它们的生命周期不必像它们定义的块那样短。

# 释放

与在栈上释放内存不同，当你从堆上释放内存时，你会在堆中留下空洞。这些是空的，可以被重新分配给其他变量。与内存相关的任何事物一样，重新分配由操作系统处理。

释放由 Rust 以通常称为**资源获取即初始化**的风格自动处理。这个名称令人困惑的概念意味着资源（如堆内存，但也包括文件指针等其他事物）在对象创建时分配，在对象销毁时释放。Rust 中的对象销毁发生在绑定超出作用域时。如果您需要为您的对象定义自定义析构函数，您可以实现`std::ops::Drop()`特质。它包含一个方法，`drop`，当您的对象失去最后一个绑定时会被调用。

# 函数参数怎么办？

考虑以下代码片段：

```rs
    fn main() 
    { 
        let a = 32; 
        let b = &a; 
    } 
```

我们创建了两个变量绑定，第二个绑定（`b`）指向`a`的地址。`b`变量不包含`a`变量的值，而是指向`a`值所在的位置，从中它可以获取值（换句话说，`b`的值是从`a`借用的）。

在我们的栈图中，我们有以下内容：

| **函数名** | **地址** | **变量名** | **值** |
| --- | --- | --- | --- |
| `main` | `1` | `b` | `→ 地址 0` |
|  | `0` | `a` | `32` |

如果我们有一个函数调用另一个函数，但带有参数，我们的栈将略有不同：

```rs
    fn second(i: &i32) 
    { 
        let c = 42; 
        println!("{}", *i); 
    } 

    fn main()  
    { 
        let a = 32; 
        let b = &a; 
        second(b); 
    } 

```

| **函数名** | **地址** | **变量名** | **值** |
| --- | --- | --- | --- |
|  | `3` | `c` | `42` |
| second | `2` | `i` | `→ 地址 0` |
|  | `1` | `b` | `→ 地址 0` |
| main | `0` | `a` | `32` |

`i` 绑定指向 `地址 0`，而 `b` 变量也指向 `地址 0`，这就是传递给 `second` 的参数。

如果你喜欢，可以使用这种方法来考虑复杂情况中的内存。

# 静态内存分配

当我们有栈和堆时，Rust 还有另一种类型的内存分配，那就是静态分配的内存。这不是在运行时分配的，而是在程序运行之前，随着程序的代码移动到内存中。

`static` 和 `const` 变量是静态分配的好例子。

静态内存分配的生存期与应用程序相同。

# 垃圾回收时间与所有权

如果你习惯了任何.NET 语言，你将非常习惯于**垃圾回收器**（**GC**）。本质上，当一个对象的引用全部超出作用域时，垃圾回收器会释放该对象的堆分配。垃圾回收器时不时地出现，基本上会检查整个已分配内存空间，看看是否有不再使用的内容，并将此类内容从内存中移除；换句话说，回收并移除未分配指针留下的垃圾。

Rust 有一个原始的垃圾回收器，以引用计数容器`Rc<T>`的形式存在。尽管如此，在大多数情况下并不需要，因为 Rust 使用一种称为**分配所有权**的系统。

到目前为止，当我们创建变量时，我们创建的变量大多在栈上。它们的生存期非常短。当我们创建一个在堆上生存的对象时，我们创建一个指向它的单个变量，但然后我们可以有任意数量的对象指向它，或者甚至通过指针的副本，使副本成为基础并释放原始指针。这会变得混乱，堆内存的释放可能导致各种内存问题。

我们可以将任何类型包裹在泛型容器`Box<T>`中。这会在 Rust 中创建一个所有者指针，它只能有一个所有者，当这个指针超出作用域时，内存会自动释放。这样，Rust 可以防止我们在其他语言中看到的大量问题。这个所有者盒子的目的是我们可以将盒子分发给其他函数，从而能够返回堆分配的变量。

# 所有权指针示例

考虑以下代码片段：

```rs
    struct MyRectangle 
    { 
        x: i32, 
        y: i32, 
        length: i32, 
        breadth: i32, 
    } 

    fn allocate_rect() 
    { 
        let x: Box<MyRectangle> = Box::new (MyRectangle {x: 5, y: 5, length: 25, breadth:15}); 
    } 
```

`x` 变量是堆上 `my_rectangle` 对象的唯一所有者。一旦 `allocate_rect()` 完成，分配给 `x` 的堆内存就会被释放，因为最后一个所有者已经不存在了。

编译器强制执行单一所有者。以下示例演示了所有权转移。一旦转移完成，原始对象就不能再使用了：

```rs
fn swap_around() 
{ 
    let my_rect: Box<MyRectangle> = Box::new(MyRectangle{x:5, y:5, length:25, breadth:15}); 
    let dup_rect = my_rect; // dup_rect is now the owner 
    println!("{}", dup_rect.x); 
    println!("{}", my_rect.x); // won't work - use of moved value 
} 
```

# 与 C 的比较

考虑以下 C 代码：

```rs
    void myFunction() 
    { 
        int *memblock = malloc(sizeof(int)); 
        *memblock = 256; 
        printf("%d\n", *memblock); 
        free(memblock); 
    } 
```

以下代码做了什么：

1.  `int` 行分配了一个足够存储整数值的内存块。`memblock` 变量将在栈上，它指向的内存块将在堆上。

1.  在 `x` 指向的位置放置了一个值 `256`。

1.  打印出由 `x` 指向的内存位置的值。

1.  分配给 `memblock` 的内存被释放。

这工作得很好，但有以下三个主要缺点：

+   一旦内存被释放，仍然完全有可能使用 `memblock`。如果你尝试这样做，应用程序将表现出未定义的行为；最可能的情况是应用程序会直接退出，但也有可能它会导致内存损坏，从而引起系统崩溃。编译器不会尝试警告你做了这件事，因为它假设你知道你在做什么。

+   如果你分配了一个比 `sizeof` 中放置的类型更大的类型，这也会引发未定义的行为。你本质上是在试图把一夸脱的液体放进一品的罐子里。

+   如果没有调用 `free`，即使没有任何指针指向它，内存仍然被保留，这会导致内存泄漏。

你可以在 Rust 中执行类似操作，但正如我们将看到的，Rust 会自动防止这种未定义的行为：

```rs
    fn myMemory() 
    { 
        let memblock: Box<i64> = Box::new(256); 
        println!("{}", memblock); 
    } 
```

C 和 Rust 代码版本之间存在许多差异。具体如下：

+   在 C 中，你使用 `malloc` 函数分配堆内存。在 Rust 中，我们使用 `Box<T>` 泛型来通过所有者指针。

+   C 中的 `malloc` 调用返回一个 `int` 指针（`int *`）。在 Rust 中，返回一个智能指针（`Box<T>`），在这种情况下指向 `i64`。智能指针之所以被称为智能，是因为它控制着对象何时被释放。这可能是当指针超出作用域而没有将指针传递出去时。Rust 会跟踪对象以及如何清理内存。

另一个有用的智能指针类型是引用计数的指针，`Rc<T>`。这个泛型类型允许在多个位置共享其内部的数据。它的工作原理是，每当 `Rc` 绑定被克隆时，引用计数就会增加。每当这样的绑定被释放时，引用计数就会减少。只有当引用计数达到零时，底层值才会被释放。请注意，`Rc<T>` 只在单线程场景中工作。

它的使用方式如下：

```rs
   // 05/rc-1/src/main.rs 
   use std::rc::Rc; 

    fn main() 
    { 
        let memblock: Rc<i64> = Rc::new(256); 
        // allocate space on the heap and assign 
        secondMethod(memblock.clone()); 
        // clone a new reference counted pointer and pass it on to the method 
        println!("{}", memblock); 
        // output the value 
    } // free memory here 

    fn secondMethod(memblock: Rc<i64>) 
    { 
        println!("In secondMethod and memblock is {}", memblock); 
        let secMemblock: Rc<i64> = memblock.clone(); 
        // yet another reference counted pointer to memblock 
    } 
    // secMemblock goes out of scope, but the memory is not deallocated 
```

在此代码中，我们创建了几个引用计数的指针副本。在峰值（`secondMethod` 函数的第二行），我们总共有三个指向底层堆的指针。当我们离开 `secondMethod` 时，通过 `secMemBlock` 变量分配的指针被销毁。然后 `memBlock` 副本被释放。最后，当我们退出主函数时，最后一个指针消失，堆内存被释放。

# 让我们回顾一下旧代码

回到第四章*，条件、递归和循环*，我们有一些看起来像这样的代码：

```rs
let x = 2; 
let y =  
    { 
        let x_squared = x * x; 
        let x_cube = x_squared * x; 
        x_cube + x_squared + x 
    }; 
```

解释说，它所做的操作是将 `x_cube + x_squared + x` 的结果赋值给 `y`。如果在这个范围之外，我们尝试访问 `x_squared` 或 `x_cubed`，那么我们就无法访问，因为它们只存在于计算 `y` 的那个计算范围内。

考虑，如果我们将 `y` 设置为引用并尝试将其指向一个临时值会发生什么：

```rs
    // 05/refs-1/src/main.rs
    fn main() { 
        let x = 2; 
        let y: &i32; 
        { 
            let x_squared = x * x; 
            let x_cube = x_squared * x; 
            y = &(x_cube + x_squared + x); 
            // this value goes away after this line 
        }; 
        println!("Y = {}", *y); 
    } 
```

我们将 `y` 赋值给一个仅在小型作用域中存在的变量的值（计算中的临时未命名值），然后我们尝试访问这个值，从而产生未定义的行为。正如我们所看到的，Rust 编译器会尽一切努力防止这种错误。在这种情况下，编译器会跟踪每一个引用，如果引用的持续时间超过正在使用的指针，则无法构建。

# 让我们不要急于前进！

与内存相关的任何事物一样，我们确实有内存在指针之间共享的时候。通常，当我们编写应用程序时，我们不会考虑在任何给定时间可能有多个线程同时运行，虽然我们可以通过遵循流程相当准确地预测会发生什么，但我们有时会遇到一个称为竞争条件的问题。简单地说，我们不知道哪个条件会首先*击中*。

让我们看看以下示例：

```rs
    // 05/threads-1/src/main.rs
    use std::thread; 
    use std::rc::Rc; 

    struct MyCounter 
    { 
        count: i32 
    } 

    fn wont_work() 
    { 
        let mut counter = Rc::new(MyCounter {count: 0}); 
        thread::spawn(move || // new thread  
        { 
            counter.count += 1; 
        }); 
        println!("{}", counter.count); 
    } 
```

这将无法编译，因为编译器不知道哪个线程将是 `0` 或 `1`，因为它们都试图同时访问 `counter`。在 Rust 术语中，`counter` 被移动到内部线程，这意味着它不能在其他任何地方被访问。通过 `Rc` 类型的引用计数在这里没有帮助，因为它不是线程安全的。

# 停止竞争...

如何避免这种错误？

还有一个具有非常酷名字的引用计数类型：Atomic RC。在这种情况下，原子性指的是不可分割的操作和/或容器，这意味着它们是线程安全的。此外，我们还需要将 `Arc` 类型与 `Mutex` 配对，以便我们可以锁定数据以进行访问。以下是线程实现的全代码：

```rs
    // 05/threads-2/src/main.rs
    use std::thread; 
    use std::sync::{Arc, Mutex}; 

    struct MyCounter 
    { 
        count: i32 
    } 

    fn wont_work() 
    { 
        let counter = Arc::new(Mutex::new(MyCounter {count: 0})); 
        let another_counter = counter.clone(); 
        thread::spawn(move || // new thread  
        { 
            let mut counter = another_counter.lock().expect("Locking of cloned counter failed"); 
            counter.count += 1; 
        }); 
        println!("{}", counter.lock().unwrap().count); 
    } 
```

通常，这段代码将打印 `0`，因为打印方法往往在线程中的突变发生之前被调用。

# 摘要

在内存处理方面，Rust 为开发者做了很多工作，几乎确保了不可能遇到像在 C 中发现的那种问题。从堆中释放内存是自动的，而且在使用指针时还有独特的保护机制，即拥有唯一和多个受保护的指针。

在下一章中，我们将从学习中暂时休息一下，看看你如何将我们所学的内容应用到自己的应用程序中。
