# 第十二章：现在轮到你了！

我们正迅速接近本书的结尾，是时候将我们所学的内容付诸实践了。就像 第六章，*创建您的 Rust 应用程序* 一样，这一章将采取一系列挑战的形式。这一章没有示例代码，所以一切都要靠你自己。大多数挑战将基于 第十章，*创建您的自己的 crate* 中介绍的 `mathlib` 库，以及使用 第六章，*创建您的 Rust 应用程序* 中创建的代码。

# 任务 1 – 清理代码（第一部分）

如果你考虑 `temperature.rs` 中的代码示例，你会看到有些使用元组，有些使用单个类型 `return`。虽然对于开发来说这是一个相当可接受的方法，但对于发布版本，我们可能希望有更结构化的东西。

考虑两个函数 `kelvin_to_celcius` 和 `celcius_to_farenheit`；为了使用它们，我们需要有两个变量：

```rs
let ktoc = kelvin_to_celcius(14.5f32); 
let ctof = celcius_to_fahrenheit(24.3f32); 
```

有多种可能的解决方案。

+   什么也不做！许多库在函数返回不同类型时使用多个变量。

+   在模块内实现一个特例，该特例测试返回值为假时的情况，并返回一个包含答案的 `String` 或 *计算失败*。

+   定义一个单一的 `struct` 用于形式化的答案，然后将其传递回调用者，如下所示：

```rs
pub struct maths_answersMathsAnswers { 
    calc_complete : bool, 
    fanswer : f32, 
    ianswer : i32, 
}  
```

如果我们移除第一个选项（毕竟，在一个专门用于测试我们所学内容的章节中这样做有什么意义？），我们就只剩下选项 2 - 4 或 3。

# 每个选项的问题

每个选项都有其独特的相关问题。

# 字符串选项

第二个选项的问题在于，如果我们返回一个 `String`，然后想对答案做其他处理（可能是一个来自其他模块的进一步计算），我们需要一种方法将字符串（在检查它不包含错误代码之后）转换回 `f32` 以传递给第二个函数。

# 结构体选项

第三个选项的问题在于，当我们库内调用时，我们要么返回类型为 `tuple(bool, f32)` 或 `f32`。因此，在只返回单个类型的函数中，我们需要将 `calc_completed` 设置为 `true`。

可以通过派生或实现 `std::Default` 在 `struct` 上设置默认值（我们将在 第十三章，*标准库*，和 第十四章，*外部函数接口*)中介绍标准库）。这是一个派生版本：

```rs
#[derive(Default)] 
pub struct MathsAnswers { 
    calc_complete : bool, 
    fanswer : f32, 
    ianswer : i32, 
}  
```

Rust 中所有原始类型都有合理的默认值：数字为零，布尔值为假，字符串为空字符串，等等。前面的代码等同于以下手动实现的 `Default`：

```rs
impl Default for MathsAnswers { 
  fn default () -> MathsAnswers { 
    MathsAnswers {calc_complete: false, fanswer: 0f32, ianswer: 0i32 } 
  } 
} 
```

然而，我们希望`calc_complete`的默认值为 true，因此我们将使用此实现：

```rs
impl Default for MathsAnswers { 
  fn default () -> MathsAnswers { 
    MathsAnswers {calc_complete: false, fanswer: 0f32, ianswer: 0i32 } 
  } 
} 
```

在`Default`实现之后，我们可以在创建实例时只填充一些值，并为其余部分提供`Default::default()`：

```rs
// do calculation then
let answers =  MathsAnswers { fanswer: calc_ans, ..Default::default() }; 
return MathsAnswers; 
```

可能的问题在于将 struct 放在什么范围内。在哪里放置它最好？

# 任务

您需要决定哪种代码重构选项最适合，然后实现它。您应该创建多个单元测试以确保检查正常工作，然后在您的测试应用中测试以确保 crate 和作用域没有出现问题。

# 任务 2 - 清理代码（第二部分）

虽然每个函数在 crate 中都是分开的，但我们总是可以清理代码以使其更安全（我们有一个公共函数，并将计算远离好奇的目光）。

# 任务

每个函数都接受一个参数，该参数为`f32`或`i32`类型，幸运的是，我们可以将模块分开，使其返回`f32`或`i32`（所有基础返回值都是`i32`：其他所有答案都在`f32`中）。

如果我们查看温度模块，所有返回值都将作为`f32`（在任务 1 之后，如何实现这一点取决于您）。因此，我们可以创建一个单函数，该函数将转换作为第一个参数，值作为第二个参数。

当单个函数识别出第一个参数时，它将调用现在私有的函数并返回值。

与第一个任务一样，您需要实现这一点并为新库创建文档。您应该为 crate 创建一个新的单元测试，并在您的测试应用中测试它。

# 任务 3 - 扩展 crate（第一部分）

您会注意到，在示例库中，`regression_analysis`模块根本没有任何代码。这是故意的。

回到第六章，*创建您的 Rust 应用程序*，其中一个任务是创建代码，使您能够根据提供的公式执行回归分析。现在创建的代码可以明确地分为两部分：

+   直线的方程，*y = mx + c*，这将给出*x*和*y*轴上的截距

+   标准差和回归分析

# 任务

在这个任务中，您需要将您的代码放入`mathslib`crate 中。这可能不像看起来那么简单。库需要接受：

+   存储数据的文件名

+   包含一个`struct`或`tuple`的向量，该向量用于存储数据

然而，问题不在于数据，而在于每次进行计算时，都必须执行整个回归分析。例如，要计算标准差，您不能只传递直线方程的结果——这样不会工作，但会导致整个计算再次执行。

就库的速度而言，这非常低效；你应该计算一次，然后能够从那里提取所有答案。至于你的代码，这需要一些重新组织

完成这些后，你应该为每个函数创建单元测试，并在你的测试应用中用向量以及文件名来测试它们

你需要将此任务的文档添加到你的当前文档中

# 任务 4 – 扩展 crate（第二部分）

到现在为止，你将牢固掌握 crate 的工作方式、所需的测试规范以及创建测试应用。本节你最后的任务是创建自己的 crate 扩展。不过，你的扩展也有一些标准：

+   其中一个函数必须返回一个非原始类型

+   计算应该是私有的；应该有一种形式来访问函数调用

+   应该有一个函数，它接受一个 XML 文件作为参数来执行计算

+   新模块必须完全文档化，并包含其自身的测试

# 摘要

我们已经完成了书籍的主要部分。我们已经涵盖了 Rust 语言的大部分内容，这些章节的结尾应该有助于你巩固你的知识

在书的最后一部分，我们将介绍标准库以及如何将你的 Rust 应用程序与外部库接口
