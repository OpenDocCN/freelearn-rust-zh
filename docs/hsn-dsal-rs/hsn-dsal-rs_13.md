# 评估

# 第一章

**什么是特性，它们与接口有何不同？**

特性是跨组件共享的功能块。它们可以包含代码以及关联类型，并且可以为任何类型和泛型独立实现。另一方面，接口描述了一个类提供的公共方法，没有实现，通常带有继承。Rust 只有特性。

**为什么 Rust 没有垃圾回收器？**

垃圾回收是释放由程序运行生成的未使用堆内存所必需的。Rust 通过在编译时提供静态代码分析来避免这一点，这迫使用户思考变量的生命周期。这些生命周期定义得非常严格，并且需要生命周期作用域来拥有或借用内存，以便编译器知道何时没有使用到它们，而不需要显式声明。

**请列举 Rust 中创建生命周期（显式和隐式）的三个例子**

**隐式地！**

你能想到的任何三个都是很好的，但这里是我的：函数、作用域（只需使用 `{}` 创建一个），以及闭包（lambda 函数）。

**为什么变量的不可变性很重要？**

它保证只进行读取操作，从而避免任何副作用。

**同步标记特性有什么作用？**

它将一个结构标记为可以从多个线程安全访问。

**你可以在哪里参与 Rust 社区？**

前往 [`github.com/rust-lang`](https://github.com/rust-lang)（打开问题、提交代码、讨论等）或 [www.rust-lang.org/community](https://www.rust-lang.org/community)，那里保存了所有当前社区资源（如论坛和聊天）。

**为什么 RFC 比 PR 更受欢迎？**

要向 Rust 编程语言、`cargo` 或 `crates.io` 贡献更改，传统的“分叉-更改-PR（pull request）”方法不会工作（特别是如果存在重大更改）。RFC 是对这三个项目中的任何一个进行重大更改所需的正式流程，并允许更广泛的社区讨论和评估所提出的更改，以及为它们做出贡献。这是 Rust 社区为有效地管理像编程语言这样基本的东西所做的努力。

# 第二章

**cargo 做什么？**

对仓库的读写访问、运行测试、依赖管理（下载、更新和管理依赖树）、执行构建过程，以及提供用于额外工具的中心接口。

**cargo 提供了 linting 支持吗？**

`cargo` 本身不做，但有额外的工具，如 `clippy` ([`github.com/rust-lang/rust-clippy`](https://github.com/rust-lang/rust-clippy))，它们可以无缝地与 `cargo` 一起工作。

**在哪些情况下，Cargo.lock 文件对发布很重要？**

对于库。该文件由 cargo 用于确定依赖树的精确版本。因此，不应由于意外更新依赖项而产生任何版本问题。

**发布到 crates.io 需要满足哪些要求？**

通过测试，仓库中没有未提交的文件，拥有有效的账户，以及`crates.io`上的可用位置。

**Wasm 是什么？为什么你应该关心它？**

Wasm 是一个编译目标，可以在传统的 JavaScript 环境中执行，例如浏览器或 Node 运行时。这跳过了 JavaScript 及其垃圾回收所需的编译步骤，因此 Wasm 二进制文件更适合具有浏览器 UI 组件的（近）实时应用程序。它们可以在 JavaScript 世界中简单地运行。

**Rust 项目中测试是如何组织的？**

测试可以添加到模块中的每个文件，通过`#[tests]`和`#[test]`以及`#[bench]`进行注释。这些也可以放置在组件目录下的`test/`中的自己的文件结构中。此外，Rust 支持 doctests，当 docstring（`///`）包含包含代码的示例部分时，它们会被执行。

# 第三章

**Sized 类型与其他类型有何不同？**

大小意味着类型实例的大小在运行时已知，因此它不包含增长的数据类型。例如，`str`通常不是一个大小类型——`String`是。

**Clone 与 Copy 有何区别？**

Clone 是对`clone()`函数的显式调用；复制是隐式的，例如在赋值时发生。由于 Clone 是显式调用的，它通常在底层数据结构上执行深拷贝。

**不可变数据结构的主要缺点是什么？**

不可变数据结构可能具有较差的绝对性能，因为它们不能使用常规数据结构提供的优化。此外，对包含的数据的更新是不可能的，这使得它对于不断变化的数据是一个非常低效的选择。

**应用程序如何从不可变数据结构中受益？**

它们隐式地跟踪更改，并且在没有副作用或锁定需求的情况下跨线程工作得很好。

**考虑一个你想要工作的不可变列表——你将如何将其** ****分配到多个线程中？**

根据任务，它可以分成*n*个块，其中*n*是线程的数量。然而，这需要你创建列表的*n*个副本——或者至少每个副本至少移动一次。或者，列表可以跨线程访问，只提供索引来表示要工作的块。

# 第四章

**为什么在 Rust 中实现链表很棘手？**

Rust 的所有权原则使得实现非层次结构，如双链表变得困难。在那里，不清楚哪个节点拥有内存的哪个区域，因为邻居都持有无法无效的引用。

**Rust 的标准库 LinkedList<T>是如何工作的？**

它是一个双链表：单个节点相互连接，就像本章中的实现一样。

**双链表与跳表有什么区别？**

跳表有多个层级，节点通过链接在一起以实现类似树状搜索的性能。因此，跳表必须是有序的，并存储多个指向后继和前驱的指针。双链表只有两个链接（前向和后向），不需要排序，并且在最佳情况下实现线性搜索性能。

**动态数组在元素访问方面是否优于跳表？**

是的，如果跳表不使用动态数组作为基础的话！

**为什么动态数组是 CPU 缓存的绝佳选择？**

数据存储在内存的一个大连续部分中，元素一个接一个地存储。缓存始终建立在内存块上，这就是为什么缓存几个可能依次处理的元素使动态数组非常适合这一点。

**动态数组还有另一种增长策略吗？**

内存可以加倍，每次增加一定量，或者以对数方式增长，这样在开始时增长快，后来变慢。

**Rust 认真对待数组，那么动态数组内部使用什么？**

它使用一个带框的切片。

# 第五章

**二叉搜索树在搜索时如何跳过多个节点？**

通过跟随一个分支，每次做出一个分支的决定时，它就会跳过一个子树。子树可以是单个节点，也可以是除了一个节点之外的所有节点。

**什么是自平衡树？**

使用某种逻辑来（大致）平衡每个子树中节点数量的树。这确保了所有树算法都以最佳可能的效率工作。

**为什么树中的平衡很重要？**

如果树是倾斜的，任何在其上操作的算法都会遇到根据它操作的子树而不同量的工作。这种不匹配是假设树的每个分支都会导致相同量的工作（例如，进行相同数量的比较），这就是为什么树数据结构是高效的。

**堆是不是二叉树？**

是的。每个节点有两个子节点。

**tries 有哪些好的应用场景？**

这里是我的：一个 trie 集合是保证唯一性的非常高效的数据结构，有基于 tries 的序列预测方法，它们可以进行无损数据压缩。

**什么是 B-树？**

B-树是一种具有定义级别的树，该级别与每个节点中的子节点数量相关。因此，它是所有树的自我平衡泛化：一个级别 2 的 B-树类似于二叉树，但更多的子节点会使数据结构更高效，并避免不必要的层数。

**图的基本组成部分是什么？**

图是通过边连接的节点。这些节点通常具有值；边上的值被称为权重。在一般图中，边没有方向，但进一步的约束可以使它有向、无环或有限制。图是所有列表和树的超结构。

# 第六章

**什么使一个好的哈希函数？**

这取决于用例。密码学应最小化冲突，消息摘要应最大化在微小输入差异上的哈希差异，而布隆过滤器应做相反的事情。

**如何估计哈希函数对特定任务的适用性？**

通过使用图表和测试来了解输出哈希的分布情况以及是否是你所寻找的。直方图和散点图可以很好地显示值的分布。此外，在网上搜索潜在的漏洞或弱点以及原始论文。

**校验和哈希在其他方面有用吗？**

它们还可以用来确定两个文本或文件是否相等，这可以用于快速查找匹配项或检查内容是否是传输的内容，或者内容是否已被篡改。

**实现映射有两种方式吗？**

使用树或使用哈希。

**什么是桶？**

桶是映射到底层数据结构的哈希值。哈希可能输出`u64`，但`Vec<T>`的长度只有 100。因此，多个哈希共享`Vec<T>`中的一个索引，这被称为桶。

**集合能否替代列表？**

只有当唯一性是内容所需约束时。

**什么使集合有用？**

快速且专业的集合操作，例如并集、交集、差集和快速的“包含”查找，以及以更好的效率保证唯一性的能力。

# 第七章

**这里没有讨论哪个 std::collections 数据结构？**

`BinaryHeap` ([`doc.rust-lang.org/std/collections/struct.BinaryHeap.html`](https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html)).

**截至 2018 年，Vec<T>或 VecDeque<T>是如何增长的？**

当需要更多空间时，它们会加倍（或更多）其大小。

**LinkedList<T>是一个好的默认数据结构吗？**

不。它不提供索引访问，并且由于内部内存结构，通常比`Vec<T>`慢，但提供相同的基本功能。

**2018 年的 HashMap<T>默认使用哪种哈希实现？**

SipHashing。还有其他一些正在进入标准库，例如`hashbrown` crate ([`github.com/Amanieu/hashbrown`](https://github.com/Amanieu/hashbrown))。

**BTreeMap<T>相对于 HashMap<T>有哪些三个优点？**

使用任意三个，但这里有一些建议：

+   有序键

+   较低的计算强度（不需要哈希）

+   不需要哈希函数——无论何种情况都有良好的性能

**BTreeMap<T>的内部树是更宽还是更高？**

更宽，因为有更多的子节点（最多*2*级 - 1），这有助于高效的 CPU 缓存。

# 第八章

**为什么估计运行时复杂度要超过诸如语句数量之类的因素？**

运行时间复杂度更多地关注与主要输入参数并行的预期增长。从某种意义上说，它确实是在计算语句的数量，你很可能会得出相同的结论。被计算出的语句是其中最重要的子集。

**运行时间复杂度如何与数学函数相关？**

有两种方式：数学函数可以像编程中的函数一样描述，因为它们建立在相同的基本构造上；并且数学函数用于表达运行时间复杂度本身，特别是对数和指数函数。

**通常提供的复杂度类是最好或最坏的情况吗？**

最坏的情况，因为这将是速度最慢/效率最低的情况。

**为什么循环在估计复杂度时很重要？**

循环是重复执行语句的强大构造，根据增长参数，将推动函数的运行时间复杂度。

**O(n log(n))的运行时间复杂度比 O(log(n))好还是差？**

*O(log(n))*显然是更好的运行时间复杂度。试着用你选择的三个数字替换*n*，并计算*log(n)*与*n * log(n)*。

**一些常见的已知复杂度类有哪些？**

*O(n)*, *O(log(n)*, *O(n²)*, 和 *O(2^n)*。

# 第九章

**什么是信息检索？**

所有围绕存储、搜索、排名、标记化、分析和对信息结构的一般理解的相关学科。这是一切好的搜索引擎都能做得很好的事情。

**现代搜索引擎和数据库是否使用简单的搜索算法？**

是的。无论在搜索索引之上采用何种抽象，标记的存储通常是以线性、追加的方式进行的，这允许在这些段上进行高效的搜索（二分搜索）。

**为什么线性搜索有 O(n)的运行时间复杂度？**

如果序列中不存在元素，它必须遍历所有*n*个元素以确保。

**跳跃查找比线性查找做得更好是什么？**

它跳过了列表的一部分，因为在有序列表中，可以根据排序规则排除某些位置。因此，它显著减少了线性搜索中要搜索的元素数量。

**什么是二分查找以及为什么它和树形结构相似？**

二分搜索将输入序列分成两半，并且只继续包含该元素的半个部分。将这些部分可视化（包括那些被跳过的部分）看起来就像一棵二叉树，这就是为什么这两个部分实际上是分支一样。

# 第十章

**为什么排序是编程中的重要方面？**

建立可预测的顺序，以便算法可以根据内容（例如，搜索）做出假设，这将使其性能大大提高。另一个重要方面是用户界面中的用户体验，或者建立数据点之间的语义链接（例如，时间序列现在可以具有趋势）。

**冒泡排序中是什么使得值向上冒泡？**

通过在遍历序列时反复交换一对元素，属于对立端（或接近它）的元素将不得不与其他每个元素交换位置。因此，较大的数字“冒泡”到上面。

**为什么希尔排序是有用的？**

它实现了稳定的排序性能，但不如归并排序复杂，使用的计算资源也更少。这使得它在硬件可能成为瓶颈（嵌入式设备）或没有其他排序方法可用（例如，如果标准库不受支持）的情况下非常出色。

**堆排序在其最佳情况下能否优于冒泡排序？**

不。冒泡排序的最佳情况仅仅是遍历列表 – *O(n)*。另一方面，堆排序始终需要构建一个堆，无论序列是否已经排序 – *O(n log n)*。

**归并排序和快速排序有什么共同点？**

分而治之的方法：两者都将序列分割成更小的部分，以便它们可以分别处理。

**什么是混合排序算法？**

混合排序算法使用至少两种不同方法的优势。例如，Timsort 使用插入排序处理较小的序列（例如，小于 20 个项），但对于较大的序列则使用归并排序。

# 第十一章

**PRNGs 和 RNGs 之间的区别是什么？**

伪随机数生成器（PRNGs）使用一个过程来生成尽可能统计独立的接近随机的数字序列。随机数生成器（RNGs）试图使用真正的随机性（例如，物理世界中无法预测的现象）来生成随机数。

**哪个 crate 在 Rust 中提供随机数生成器？**

`rand` 是最重要的一个。

**回溯如何解决组合问题？**

回溯递归地尝试可能的组合，并尽快评估它们的有效性。这允许你回溯不良的解决方案并保存好的解决方案。

**什么是动态规划？**

一种编程技术，通过保存和使用常见的中间解决方案来提高算法的运行时间复杂度。

**元启发式是如何成为解决难题的无问题方法的？**

元启发式使用普遍适用的策略来找到最佳解决方案。这些策略可以受到自然的启发（自然选择、动物行为、物理过程），并反复生成和评估参数以改进下一个解决方案。如果问题的生成和验证由用户提供，则该方法可以是无问题的，并且由于策略负责收敛到最佳解决方案，它们可以在可预测的时间内提供最佳猜测。

# 第十二章

**Rust 在集合上的泛型算法实现在哪里？**

切片原始类型。

**何时线性搜索比二分搜索更好？**

如果序列短且未排序——排序它所需的时间将长于简单的线性搜索。

***潜在面试问题：*什么是稳定排序算法和不稳定排序算法？**

稳定排序算法在相等元素之间保持相对顺序，而不稳定排序算法则不这样做。这意味着如果有相同数字的序列，整个块在排序集合中会按照完全相同的顺序出现。

**快速排序的哪种不良行为是模式破坏快速排序缓解的？**

选择不良的枢轴是缓解的最重要问题。这是通过采用策略来改进选择，或者在所有其他方法都失败的情况下，使用堆排序以实现至少*O(n log n)*的运行时间复杂度（而不是快速排序的*O(n²)*）。
