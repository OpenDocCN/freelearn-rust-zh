# 第二章：Rust 语言基础

好的，我们现在准备开始编写一些 Rust 代码。在本章中，我们将探讨 Rust 程序的结构，以及如何在语言中表达各种常见的编程元素。我们将从函数和模块开始，然后转向基本语言特性，如分支、循环和数据结构。本章中涵盖的几乎所有内容在大多数其他编程语言中都有对应；这些都是编程的基础。

具体来说，本章描述了以下内容：

+   函数，它们类似于大型程序中的一部分小程序

+   模块，用于组织程序

+   表达式，这是我们告诉程序实际执行特定事情的方式

+   分支，这是我们告诉程序做出决策的方式

+   循环，这是我们告诉程序执行扩展操作的方式

+   结构体，这是我们组织信息以便程序处理的方式

+   将函数附加到结构或其他数据类型上，使它们更有用

# 函数

在上一章中，当我们查看由`cargo new`自动生成的样板代码时，我们顺便看到了几个函数。我们实际上看到了什么？

**函数**是一系列计算机需要遵循的指令。它有点像食谱。如果我们知道他们已经有了一个饼干食谱，我们就不必告诉一个人如何使用多少面粉、糖和牛奶来烤饼干。我们只需说：*请烤一些饼干*。函数也是类似的。我们不必告诉计算机如何确切地将一些信息保存到数据库中；如果有`save_to_database`函数，我们可以用它来完成这项工作。

在 Rust 中，能够告诉计算机采取行动的指令只能写在函数内部。一切始于一个名为`main`的函数，它可以启动其他函数的运行，而这些函数又可以启动更多函数，以此类推。再次使用我们的食谱类比，就像一个馅饼食谱说：*使用第 57 页的食谱制作饼皮面团*。

# 定义一个函数

在 Rust 中，函数以`fn`关键字开始。关键字是一系列字母或符号，在语言中有固定的含义。我们在程序中所做的一切都不能改变关键字的含义，我们使用的库也不能改变其含义。关键字在不同的上下文中偶尔有不同的含义，但它们在以相同方式使用时始终具有相同的含义。关键字是构建其他一切的基础。

因此，`fn`关键字用于告诉 Rust 编译器我们即将告诉它一个新函数。之后，通过一个空格隔开，接着是函数的名称。函数名称的规则如下：

+   它必须由以下内容组成：

    +   英语字母（从`A`到`Z`的大写或小写形式）

    +   阿拉伯数字（数字 `0` 到 `9`）

    +   下划线（`_`）

+   它不能以数字开头（因此 `7samurai` 不是一个有效的名称）

+   如果它以下划线开头，它必须至少有一个后续字符（`_` 单独具有特殊含义）

然后是一个开括号 `(` 和一个闭括号 `)`，它们之间是参数列表。我们现在暂时跳过参数列表，稍后再回来讨论。如果函数不需要参数，括号之间不需要有任何内容，这就是我们现在要这样做的方式。

在参数列表的闭括号之后，我们可以选择性地包含一个 `→` 符号，后面跟着返回类型，这是我们稍后会更详细讨论的另一件事。

接下来是一个 `{` 符号，它告诉 Rust 我们即将开始一系列命令，然后是 Rust 需要的命令，以便 Rust 知道我们希望函数做什么，最后是一个 `}` 符号来标记结束。

回到样板代码，让我们再次看看自动生成的 `main` 函数：

```rs
fn main() {
     println!("Hello, world!");
 }
```

在这里，我们可以看到 `fn` 关键字、函数名和空参数列表。可选的返回类型已被省略。然后，在 `{` 和 `}` 之间，我们看到一条单独的指令，它告诉计算机，每当它被要求运行 `main` 函数时，我们希望它打印出 Hello, world!。

在我们理解了在 `{` 和 `}` 符号之间我们可以给计算机下达哪些指令之前，关于函数就没有太多可以说的了。主要思想是我们可以将许多指令捆绑成一个函数，然后在程序的其他地方使用一条单独的指令来告诉计算机 *执行所有这些操作*。

# 模块

模块为我们提供了一种将函数（以及具有名称的其他项目，如数据结构）组织成类别的途径。这有助于我们保持事物有序，并允许我们在模块中多次使用相同的名称，只要我们每次只使用一次。它还让我们大多数时候可以使用该事物的简短版本，但在那些简短名称可能令人困惑或含糊不清的情况下，我们可以使用较长的版本。

# 定义模块

定义模块很简单。在任何编译器将要查看的 `.rs` 文件中，我们可以使用 `mod` 关键字来开始一个新的模块。尽管如此，使用该关键字有两种不同的方式，这取决于我们是否希望将模块定义为当前文件的一部分或作为单独的文件。

# 模块作为文件的一部分

要将模块定义为文件的一部分，我们使用 `mod` 关键字后跟一个名称，然后是一个 `{` 符号，然后是模块的内容，最后是一个 `}` 符号来完成。

因此，如果我们定义一个新的模块，包含几个函数，它看起来可能就像这样：

```rs
pub mod module_a {
    pub fn a_thing() {
         println!("This is a thing");
    }

    pub fn a_second_thing() {
         a_thing();
         println!("This is another thing");
    }
}
```

我们创建了一个名为 `module_a` 的模块，并将 `a_thing` 和 `a_second_thing` 函数放入其中。我们之前没有见过它，但 `a_second_thing` 中的 `a_thing();` 这一行是给计算机运行的 `a_thing` 函数的指令。所以，当 `a_second_thing` 运行时，它首先运行 `a_thing`，然后打印出它自己的消息。

`pub` 关键字表示 `module_a` 是当前模块的公共接口的一部分，而不仅仅是内部数据。我们很快就会更多地讨论这一点。

# 模块作为一个独立的文件

更多的时候，我们希望给我们的模块它们自己的文件。尽可能地将事物分开并包含起来会更好，因为这有助于保持代码的可管理性。幸运的是，这同样简单。在我们的 `.rs` 文件中，我们可以简单地写下以下内容：

```rs
pub mod module_b;
```

这看起来与之前的例子非常相似，只不过它没有在 `{` 和 `}` 之间直接包含模块内容。相反，Rust 编译器会寻找一个名为 `module_b.rs` 或 `module_b/mod.rs` 的文件，并使用整个文件作为 `module_b` 模块的内容。所以，如果文件包含一些与我们之前看到的类似的功能：

```rs
pub fn a_thing() {
    println!("This is a module_b thing");
}

pub fn a_second_thing() {
    a_thing();
    println!("This is another module_b thing");
}
```

那么 `module_b` 将包含两个名为 `a_thing` 和 `a_second_thing` 的函数。这些函数与之前 `module_a` 模块中的函数同名并不是问题，因为它们在不同的模块中。

为什么编译器在两个地方寻找 `module_b` 的源代码？这使我们能够更灵活地安排我们程序的源代码目录结构。

# 从外部访问模块内容

在 *模块作为文件的一部分* 部分中，`a_second_thing` 函数是 `a_thing` 函数所在模块的一部分，因此它自动允许使用其他函数的短名称来引用它。然而，模块外的代码需要使用全名来引用模块内的项。这可以通过两种方式完成。可以直接这样做，如果我们不经常引用该项，这是一个不错的选择，或者我们可以告诉 Rust 我们想要在不同的模块中使用项的短名称，如果我们打算在代码中经常使用该项，这也是一个好的选择。

# 直接使用项目的全名

项目的全名由模块名、一个 `::` 符号和项目的短名组成。如果我们需要通过多层模块才能找到我们想要的项，我们按顺序列出这些模块的名称，每个名称之间用 `::` 隔开。例如，我们可能会引用 `std::path::Path` 来从 `std` 模块的 `path` 模块中获取 `Path` 项。

我们可以在任何地方使用全名，并且对所讨论的项目完全明确无误。

# 使用项目的短名

我们还可以使用`use`关键字来告诉 Rust 我们想要通过短名来引用不同模块中的项。这只需写下`use`后跟我们要使用的项的完整名称即可。例如，`use std::path::Path;`允许我们在后续指令中使用该项的短名（在这个例子中是`Path`），直到我们遇到关闭我们`use`关键字所在代码段的大括号`}`（或者我们到达模块文件末尾，这效果相同）。

我们可以使用相同的语法来告诉 Rust 我们想要使用模块的名称，而不是模块中的项。例如，`std::path`是一个有效的命令。这将允许我们使用`path::Path`作为后续代码中`Path`项的名称。这通常很方便，因为它仍然将外部项封装并分离，同时提供了合理简短且信息丰富的名称来工作。

# 公共和私有模块项

在许多前面的例子中，我们看到了`pub`关键字。该关键字使其附加的项变为`public`，这意味着它对不属于同一模块的代码是可用的。如果我们省略项上的`pub`关键字，则该项是`private`，这意味着它只能在定义它的模块内访问。`private`是默认的，因此我们需要明确标记那些我们希望作为模块外部可访问接口部分的项为`public`，通过使用`pub`关键字。

将项设置为私有并不是一种安全机制。如果你担心你的代码将与恶意代码链接，可能会滥用你的代码或数据，将代码或数据设置为私有将不会防止此类攻击。相反，公共和私有之间的区别存在是为了帮助我们明确哪些代码部分是*打算*在当前模块之外使用的，哪些是打算仅内部使用的。这有助于我们维护软件，因为我们可以在私有项上自由做出任何我们想要的更改，而对于公共项，我们必须小心我们的更改不会破坏我们可能甚至不知道存在的外部事物。

# 表达式

告诉计算机在 Rust 程序中执行某事的指令几乎都是表达式。表达式告诉计算机如何计算特定值，并产生该值作为其结果。在数学中，`2 + 2`是一个结果值为 4 的表达式。同样，`(2 + 2) - 1`是一个结果值为 3 的表达式，它本身由一个加法表达式和一个减法表达式组成。在 Rust 中，同样的基本思想适用：表达式告诉计算机如何找到一个值，并且它们可以组合在一起，因为使用产生值的表达式与直接使用该值具有相同的结果，就像写作`(2 + 2) - 1`与写作`4 - 1`具有相同的结果一样。

虽然 Rust 中的所有表达式看起来并不像数学。Rust 是一种编程语言，而不仅仅是一个计算器。重要的是表达式的概念，它们将值组合起来产生新的值。

# 字面量表达式

Rust 最简单的表达式就是我们直接写出我们想要的值的表示。例如，当 Rust 看到`2`时，它知道我们要求它给出数字`2`。同样，当 Rust 看到`"Hello, world!"`时，它知道我们要求它产生拼写为`Hello, world!`的字母序列。

Rust 识别以下字面量表达式：

+   数字

+   引号文本

+   字节序列

+   单个 Unicode 点

+   单个字节

+   布尔值

数字可以写成整数、十进制数或工程记数法，对于引号文本和字节序列也有几种变体。布尔值写作`true`或`false`。在这本书中，我们不需要任何引号文本的变体，也不需要字节序列，所以不会详细介绍这些。如果你好奇，请参阅[`doc.rust-lang.org/`](https://doc.rust-lang.org/)。

# 运算符表达式

同样，像数学一样，Rust 有许多可以应用于值以将它们转换为新值的符号**运算符**。例如，`+`是 Rust 运算符，用于将两个值相加。所以，`2 + 2`是一个 Rust 表达式，将数字 2 加到自身，产生数字 4。Rust 还使用`-`作为减法运算符，`*`作为乘法运算符，`/`作为除法运算符，`%`作为余数运算符。

Rust 不仅限于数学运算符。在 Rust 中，`&`表示`and`，`|`表示`or`，`^`表示`exclusive or`，`!`表示`not`（例如，`!true`是`false`），`<<`表示`leftward bit shift`，`>>`表示`rightward bit shift`。有时这些运算符的含义取决于它们所作用值的类型。例如，当应用于整数时，`|`表示`bitwise or`，但当应用于布尔值时，表示`logical or`。

然后是比较运算符。`==`运算符表示`check whether two values are equal`。围绕`==`运算符构建的表达式，如果被比较的两个值相等，则产生布尔值`true`，如果不相等，则产生`false`。所以，例如，`5 == 4`是一个产生`false`结果的表达式。同样，`!=`表示`not equal`，`>`表示`greater than`，`<`表示`less than`，`>=`表示`greater than or equal`，`<=`表示`less than or equal`。所有这些在关系正确时都产生`true`，在关系不正确时产生`false`。

最后，Rust 识别 `&&` 和 `||` 操作符。这些只能应用于布尔值（`true` 或 `false`），并且当应用于相同的值时，它们会产生与 `&` 和 `|` 相同的结果。区别在于 `&&` 和 `||` 是所谓的 *懒* 或 *短路* 操作符，这意味着如果左侧操作数提供了足够的信息来确定操作符产生的值，它们将不会麻烦去评估其右侧操作数。例如，对于表达式 `false && some_expensive_calculation()`，Rust 将永远不会麻烦去运行 `some_expensive_calculation` 函数，因为无论该函数产生什么结果，`&&` 操作的结果都将为 `false`。

在大多数情况下，当我们会在布尔值上使用 `&` 或 `|` 时，我们应该使用 `&&` 或 `||`，因为这样可以使得 Rust 更有效率，特别是如果我们足够细心，将更昂贵的操作放在操作符的右侧。

这不是 Rust 操作符的完整列表，随着我们继续学习这门语言，我们将看到一些更专业的操作符。这些是我们表达程序中大多数计算、计算和决策所需的操作符。

# 数组和元组表达式

**数组**是一系列数据值的顺序集合。有许多使用和操作它们的方法，但在这里我们感兴趣的是创建它们并访问其内部数据值的专用表达式。要告诉 Rust 我们想要创建一个新的数组，我们只需要写一个 `[` 符号，然后是一个逗号分隔的表达式列表，这些表达式产生我们想要存储在数组中的值，最后是一个 `]` 符号。如果我们想要一个空数组，那么在开始和结束符号之间不需要有任何内容。因此，我们可以将 `[]` 写作产生空数组的表达式，或者将 `[1, 3, 5]` 写作产生包含三个数字的数组的表达式。数组中存储的所有值都需要具有相同的数据类型——在这个例子中是整数——所以如果我们尝试将第二个元素设置为文本字符串，例如 `"nope"`，那么在尝试编译程序时会产生编译器错误。

这对于需要创建短数组的场景来说非常好，但想象一下编写包含一千个值的数组的表达式！我们不想逐个写出它们。幸运的是，我们可以做类似 `[0; 1000]` 的事情，这将产生一个包含一千个零值的数组。然后，代码的另一个部分可以填充这些槽位中的不同值。

一旦我们有一个数组值，我们通常需要访问存储在其中的值。这也通过使用 `[` 和 `]` 符号来实现。如果我们有一个名为 `an_array` 的数组（我们将在本章的 *变量、类型和可变性* 部分中看到如何给值命名），我们可以通过 `an_array[0]` 访问数组中的第一个值，通过 `an_array[1]` 访问第二个值，依此类推。请注意，第一个值用 `0` 编号，而第二个值用 `1` 编号。许多编程语言都是这样计数的，因为这简化了它们经常需要与数组和其他值序列一起进行的某些数学运算。

除了数组之外，Rust 允许我们创建 **元组**。创建元组的表达式与数组类似：（1，`wow`，true）是一个包含数字值 `1`、文本值 `wow` 和布尔值 `true` 的元组。如果我们有一个名为 `a_tuple` 的元组，那么 `a_tuple.1` 将产生元组中的第二个值，在这种情况下是单词 `wow`。但是，没有简化的方式来创建包含一千个重复值的元组，因为它们不是为此而设计的。与数组不同，单个元组可以包含多个不同类型的值，它们旨在作为轻量级的数据结构，而不是作为许多相似数据值的集合。

在某些语言中，元组的元素内容不能被更改。然而，在 Rust 中并非如此，Rust 中的元组遵循与其他数据结构相同的规则。

如果我们需要创建一个只包含一个元素的元组（这并不常见，因为元组的主要目的是将多个值关联在一起），我们需要在值后面包含一个逗号。因此，包含数字 5 的单元素元组看起来是这样的：（5，）

# 块表达式

有时候，确定表达式结果值的必要步骤根本不适合我们之前看到的单表达式。也许它们需要暂时存储一个数据值以执行效率更高，或者在其他方面过于复杂，无法以 *1 + ((2 * 57) / 13)* 的风格合理编写。

这就是块表达式的作用。块表达式看起来很像函数的主体，因为函数的主体就是一个块表达式。它们以 `{` 开始，以 `}` 结束。在这两个标记之间，我们可以编写所需的任何指令，包括定义变量或其他命名项。

在块的末尾应该出现产生块最终结果值的表达式。例如，块表达式 `{ 2 + 2; 19 % 3; println!("In a block"); true}` 是一个（有点愚蠢的）块表达式，其结果为布尔值 `true`，但不是在它计算出 2 加 2 等于 4、计算出 19 除以 3 的余数是 1、并将 *In a block* 打印到控制台之后。

顺便说一下，Rust 编译器会警告我们关于那个块表达式，因为它计算了两个值，然后又把它们丢弃了。这是浪费的，所以 Rust 会指出这一点。如果启用了优化，编译器实际上会跳过生成计算这些值的代码，但这只是一个优化，程序和编译器仍然应该像它们确实执行了计算一样行事。

注意块表达式中的分号（`;`）。块中的每个顶级指令后面都有一个分号，*除了最后一个之外*。这是因为分号告诉 Rust，它前面的表达式应该被视为一个**语句**，这意味着它不会产生值，或者即使产生了值，我们也不关心那个值是什么。在某些情况下，可以在块中最后一个表达式之前省略分号，但我不建议这样做，因为明确地丢弃我们不会使用的表达式的结果，可以让编译器有更多的自由来做出推断和优化，并且可以帮助避免一些相当隐晦的编译器错误。

如果我们在块中的最后一个表达式后面放一个 `;`，这意味着该块根本没有任何有意义的返回值。在这种情况下，它最终会有一个 `()` 作为其返回值。这是一个空元组，这是一个很好的方式来说明：*这里没有什么可看的*。`()` 在 Rust 语言和库中就是这样使用的。

# 分支表达式

程序真正有用的一个特点就是它们能够做出决策。在 Rust 中，我们可以通过使用 `if` 表达式来实现这一点。一个 `if` 表达式看起来可能像这样：

```rs
if 3 > 4 {
    println!("Uh-oh. Three is greater than four.");
}
else if 3 == 4 {
    println!("There seems to be something wrong with math.");
}
else {
    println!("Three is not greater than or equal to four.");
};
```

如果你熟悉其他编程语言，你可能会想知道条件表达式周围为什么没有括号。Rust 的语法并不要求在那里使用括号。实际上，如果我们把条件放在括号里，编译器会警告我们这些括号是不必要的。

我们这里有一个展示 `if` 所有功能的表达式。它从关键字 `if` 开始，后面跟着一个产生 `true` 或 `false` 的*条件表达式*，然后是一个块表达式。如果条件表达式产生 `true`，则执行块表达式，但如果条件表达式产生 `false`，则不执行块表达式。

使用 `3 > 4` 作为我们的条件表达式并不是很有用。我们完全可以只写 `false`，或者完全省略那个块表达式，因为它永远不会被执行。然而，在实际代码中，我们会使用一个条件表达式，其结果在我们编写代码时我们并不知道。例如，*是否在上午 8 点到下午 5 点之间*、*用户是否从菜单中选择了这个值*，以及*值是否与数据库中存储的值匹配*，这些都是更现实的条件，尽管当然它们必须用 Rust 表达出来。

之后，我们有一个 `else if` 和另一个条件表达式和代码块。这意味着，如果第一个条件表达式返回 `false`，计算机应该检查第二个是否返回 `true`，如果是，就运行相关的代码块。

我们可以在初始 `if` 之后链式连接尽可能多的 `else if` 表达式，因此我们可以提供给计算机的不同选项数量没有限制。然而，在任何给定的决策之后，只有一个会运行。计算机将从初始 `if` 开始，逐个检查条件表达式的值，直到找到一个返回 `true` 的，然后它会运行相关的代码块，然后它会完成 `if` 表达式并继续后续指令。

在 `if` 和我们可能希望包含的任何 `else if` 之后，我们可以放置一个 `else` 后跟一个代码块。这是一个没有条件的分支，它的意思是 *如果没有任何条件表达式产生* `true`，*就执行这个操作*。换句话说，它允许我们告诉计算机在没有提供特殊情况的默认情况下应该做什么。

# 循环表达式

程序变得有用的基本能力之一是循环。Rust 有几种不同的循环类型，但我们将在这里查看两种：`while` 循环和 `for` 循环。

# `while` 循环

`while` 循环与 `if` 表达式非常相似。区别在于，`while` 循环不是只检查一次条件表达式，然后根据结果运行或跳过代码块，之后结束，而是会重复这个过程，直到条件表达式产生 `false`。所以，如果条件表达式一开始就返回 `false`，代码块就不会运行。另一方面，如果条件表达式第一次检查就返回 `true`，代码块就会运行，然后再次评估条件表达式。如果它再次返回 `true`，代码块会再次运行，以此类推，直到条件表达式最终返回 `false`。

这意味着代码块必须改变影响条件表达式结果的内容非常重要。如果条件表达式返回 `true` 而代码块没有机会改变这一点，程序将会陷入不断循环执行该代码块，直到程序被强制终止。这是导致程序冻结的最简单方法。

所以，这是一个简单的 `while` 循环：

```rs
while i < 3 {
    i = i + 1;
    println!("While loop {}", i);
}
```

我们在这里使用了一个名为 `i` 的变量，我们将在本章的 *变量和可变性* 部分详细讨论。现在，只需将 `i` 视为一个可以在不同时间赋予不同值的名称，有点像我们可以在不同时间让不同的人坐在同一把椅子上。

因此，我们有`while`关键字后跟一个条件表达式。这个条件表达式使用一个变量，我们在块表达式中改变其值，所以我们不会陷入无限循环的危险。如果`i`的初始值为`0`，我们应该看到块表达式运行三次：一次当`i`为`0`时，一次当`i`为`1`时，一次当`i`为`2`时。当`i`达到`3`时，条件表达式产生`false`作为其结果（3 不小于 3），循环停止。

# for 循环

有时，`while`循环正是我们所需要的，但循环的两个最常见需求是循环特定次数或使用循环来处理数组或类似数据结构中的每个元素。在这两种情况下，`for`循环表现更好。

一个`for`循环会对其块表达式进行一次迭代，每次迭代都会产生一个由**迭代器**生成的值。迭代器是一种特殊的数据值，其任务是逐个返回一系列值。例如，数组的迭代器每次被请求值时，都会产生数组的一个不同成员。

要循环特定次数，我们可以使用`for`循环和**范围表达式**，这是一个产生一系列数字的迭代器的表达式。让我们看看一个具体的例子：

```rs
for num in 3..7 {
    println!("for loop {}", num);
}
```

我们从`for`关键字开始，然后是`num`，这是将要赋予迭代器逐个产生的每个值的名称，当这些值被`for`循环处理时，一次一个。然后是另一个关键字`in`。最后，产生我们的迭代器的表达式。在这种情况下，我们有一个范围表达式，它表示值`3`、`4`、`5`和`6`。注意，`7`不包括在范围内。与从零开始计数一样，这使计算机的一些数学运算变得更容易，在这种情况下，这也使我们的操作更容易。如果我们想循环七次，我们只需写`0..7`。

我们可以使用一个变体来包含输出中的最后一个数字，如果我们需要的话：`3..=7`。只需记住，如果你通过`0..=7`循环，你将运行块表达式八次。

`for`循环闪耀的另一个时刻是我们有一个想要处理的实际值的集合，如下面的例子所示：

```rs
for word in ["Hello", "world", "of", "loops"].iter() {
    println!("{}", word);
}
```

这个循环会打印出数组中的每个单词，每个单词占一行。`word`名称被设置为迭代器产生的第一个值`"Hello"`，然后运行块表达式。然后`word`被设置为迭代器产生的第二个值`"world"`，再次运行块表达式。这会一直持续到迭代器没有更多的值可以产生，然后停止。

在这里，我们的迭代器正在生成数组中存储的值。那个表达式的`.iter()`部分基本上是在说：*数组知道如何为自己创建迭代器，所以请求数组给我们一个迭代器*。我们将在后面的章节中看到更多关于如何实现特定于数据类型的函数的内容，但就现在而言，我们只需要知道`.`符号的含义：点右侧的东西是点左侧东西的特定部分。我们要求计算机运行的不是任何`iter`函数，而是与我们的数组关联的`iter`函数。

# 变量、类型和可变性

变量是一个可以存储数据值的命名盒子。变量本身不是数据值，就像一盒牛奶不等于牛奶（它是由蜡纸和类似物质*包含*牛奶）。

另一方面，如果有人需要牛奶，你递给他们一盒满牛奶，他们不会抱怨，对于 Rust 也是如此。如果一个 Rust 表达式需要一个整数，而我们提供了一个包含整数的变量，Rust 会对此感到非常满意。

变量通常使用`let`关键字创建：

`let x = 10;`

这个语句创建了一个名为`x`的变量，其中包含`10`值。一旦完成，我们就可以将`x`作为表达式的一部分来引用。例如，`x + 5`现在是一个有效的表达式，其结果值为`15`。

`for`循环使用的名称也是变量，函数参数也是如此，尽管它们不是用`let`关键字创建的。

除了有名称之外，变量还以其可以存储的值的类型为特征。每个变量可以存储一种类型的值，并且永远不能存储任何其他类型的信息。Rust 通常可以确定给定变量可以存储的信息类型，但我们始终有明确指定它的选项。如果我们告诉 Rust`let x: i32 = 99;`，Rust 将确保`x`变量可以存储 32 位有符号整数，如果我们尝试存储其他东西，它会报告一个错误。另一方面，`let x: f64 = 999.0;`告诉 Rust 我们希望`x`存储 64 位浮点数，并且尝试存储其他任何东西都是错误的。

我们不必为变量提供一个初始值。例如，我们可以说`let x: u16;`来告诉 Rust，`x`变量需要能够存储 16 位无符号整数。这是可以的。然而，如果有可能我们的某些代码会尝试使用变量的内容，而在此之前没有存储任何内容，Rust 编译器会认为这是一个错误。通常在创建变量时直接提供一个起始值会更容易一些。

变量被称为 **变量**，因为它们包含的值可以改变。但在 Rust 中，默认情况下，它们不能。Rust 允许我们使用多个 `let` 语句创建与旧变量具有相同名称的新变量，但我们不能只是给现有变量赋新值，除非该变量是 **可变的**。

使用与现有变量相同名称创建新变量被称为**遮蔽**旧变量。被遮蔽的变量仍然包含其之前的值，但不能再通过名称访问，因为那个名称现在属于另一个变量。如果还有任何对旧变量的引用仍在使用中，它们仍然会访问旧变量，而不是新变量。

可变只是意味着变量将接受更改，包括完全新的值。我们使用 `mut` 关键字告诉 Rust 一个变量应该是可变的：

`let mut x = 17;`

新的 `x` 变量是可变的。这意味着我们可以修改其内容：

`x = 0;`

现在 `x` 不再包含 `17`，而是包含 `0`。

我们用于变量的等号（`=`）不是数学等式的陈述。它并不意味着：“这两个东西被定义为相同”。相反，它意味着：“在这里，现在，右侧表达式的值要存储在左侧的变量中”。这在数学中是荒谬的，但在 Rust 中却完全合理：

```rs
for i in 0..5 {
    x = x + i;
}
```

Rust 有相当多的内置数据类型。我们已经看到了 `i32`、`f64` 和 `u16`，分别是 32 位有符号整数、64 位浮点数和 16 位无符号整数。还有更多遵循相同模式的数据类型，例如 `u64` 用于无符号 64 位整数，以及如 `bool` 用于布尔值；`isize` 和 `usize` 用于与目标架构上的内存地址占用相同数量的位的有符号和无符号整数；以及 `char` 和 `str` 用于单个 Unicode 代码点和它们的序列。

这些被称为原始类型，因为它们是语言固有的。然而，Rust 也允许我们创建新的类型，因此 Rust 标准库包含许多适合各种特定用途的数据类型，第三方库中还有更多。

# 类型推断

正如我们之前注意到的，我们可以指定变量的类型，但通常不必这样做。这是因为 Rust 有一个名为类型推断的功能，它通常可以通过观察我们对变量的操作来推断变量的类型。例如，如果我们使用 Tokio 网络库，我们可能会使用如下代码：

```rs
let addr = "127.0.0.1:12345".parse()?;
let tcp = TcpListener::bind(&addr)?;
```

我们没有指定 `addr` 变量应该有什么类型。更有趣的是，我们没有告诉文本地址我们需要它解析成什么类型的信息。

**解析**意味着*将表示形式转换为可用的数据*，大约如此。许多东西都可以表示为文本字符串，如果你知道如何将文本解析成你真正想要的信息。

在这个例子中的问号是 Rust 的错误处理机制的一部分，而&符号是一个影响`addr`变量如何与函数共享的运算符。我们很快就会看到这两个方面的更多内容。

然而，Rust 可以看到我们正在将`addr`变量（或者更确切地说，它的引用，但下一章会详细介绍）作为`TcpListener::bind`函数的参数传递，并且它知道该函数需要一个`SocketAddr`的引用，所以`addr`必须是`SocketAddr`。然后，由于它已经确定`addr`是`SocketAddr`，它进一步确定应该使用产生`SocketAddr`的字符串解析函数作为其结果值。

类型推断可以在像 Rust 这样严格的编程语言中节省大量的时间。另一方面，如果你看到一条关于你从未听说过的数据类型的错误消息，可能会感到惊讶，因为 Rust 决定这正是你需要的数据类型。如果发生这种情况，尝试将你实际期望的类型分配给你的变量，并看看 Rust 编译器之后会说什么。

# 数据结构

创建数据结构是将新数据类型添加到 Rust 中的方法之一。数据结构是一组相互关联的变量，它们组合成一个新的数据类型，意味着*所有这些一起*。

使用`struct`关键字定义一个新的结构体：

```rs
pub struct Constrained {
    pub min: i32,
    pub max: i32,
    current: i32,
}
```

注意，在定义每个包含变量之后都有逗号。在那里使用分号可能会很有诱惑力，但那会导致编译器错误。最后的逗号是可选的，但建议使用，因为它意味着可以重新排列行，而无需注意逗号可能缺失的位置，以及其他原因。

在这里，我们定义了一个名为`Constrained`的结构体，它由三个不同的 32 位无符号整数变量组成。该结构体本身是公共的，这意味着它可以在定义它的模块外部使用。

`min`和`max`包含的变量也是公共的，但这意味着略有不同。这意味着在任何我们有`Constrained`值的地方，我们都可以直接访问包含的`min`和`max`值。另一方面，`current`值是私有的，这意味着它只能直接在定义结构的模块内访问。我们可以在该模块中定义具有明确访问私有结构成员数据的目的的函数，但成员本身并不是结构公共接口的一部分，即使结构体本身是公共的。

要访问`min`和`max`，我们可以使用之前在几个地方看到的相同的`.`符号。所以，如果`cons`是一个可变的`Constrained`值，那么我们可以做类似这样的事情：

```rs
cons.min = 5;
```

# 数据结构的可变性

我们不能使用 `mut` 关键字来使结构体内部包含的值可变，并且省略关键字也不会使它们不可变。相反，整个结构体在特定情况下是可变或不可变的。例如，参见以下内容：

```rs
let change_no: Constrained;
let mut change_yes: Constrained;
```

上述代码意味着有两个变量，它们的数据类型都是 `Constrained`，但存储在 `change_no` 中的值是不可变的，而存储在 `change_yes` 中的值是可变的。

# 更多关于函数

现在，我们将通过讨论参数和返回类型来填补之前关于函数讨论中留下的空白。

# 参数

参数允许我们在请求函数运行时提供信息。

请求一个函数运行被称为 *调用* 它。

当我们定义一个函数时，我们可以告诉它我们希望它使用的变量名和类型，以便接收参数，如下面的例子所示：

```rs
pub fn set(&mut self, value: i32) {
    self.current = value;
}
```

我们将在本章的 *实现类型行为* 部分讨论 `self`。现在，忽略它，看看 `value`。在这里，我们提供了一个名称和数据类型，就像我们使用 `let` 创建新变量时一样。我们没有为 `value` 变量提供值，因为那是在函数调用时发生的。

我们一直看到函数调用，但为了清晰起见，它们看起来是这样的：

```rs
some_function(2 + 2, false)
```

在那个例子中，`some_function` 是一个函数的名称，分配给其参数的值是表达式 `2 + 2` 和 `false` 的结果。参数表达式在函数调用之前被评估，所以参数的实际值是数字 `4` 和布尔值，`false`。

# 返回类型

调用一个函数是一个表达式，这意味着它会产生一个结果值。我们一直忽略了这一点。如果一个函数将要产生一个结果值，我们必须告诉编译器这个结果值的数据类型。我们这样做：

```rs
pub fn get(&self) -> i32 {
    if self.current < self.min {
        return self.min;
    }
    else if self.current > self.max {
        return self.max;
    }
    else {
        return self.current;
    };
}
```

这是一个较长的例子，但目前为止我们专注于第一行。在函数参数之后，我们看到 `->  i32`。这告诉 Rust 语言，`get` 函数的结果数据类型是 `i32`。一旦它知道了这一点，编译器将确保它是正确的。在这个例子中，没有一条路径在函数中不会产生 `i32` 值，所以编译器对此很满意。

在那个例子中，我们也使用了 `return` 关键字。`return` 语句停止当前正在运行的函数（这意味着在 `return` 语句之后本应运行的任何指令实际上并没有运行）并为函数调用表达式提供结果值。在这个例子中，如果当前值小于最小值，则返回最小值。如果当前值大于最大值，则返回最大值。否则，返回当前值。

你可能还记得，在 Rust 中，函数体是块表达式，`if`及其相关内容也是一个表达式，这意味着它们都会自然地产生一个结果值，即使我们没有使用`return`关键字。这意味着我们可以这样编写示例函数并得到相同的结果：

```rs
pub fn alternate_get(&self) -> i32 {
    if self.current < self.min {
        self.min
    }
    else if self.current > self.max {
        self.max
    }
    else {
        self.current
    }
}
```

你看到区别了吗？之前，我们使用`return`来明确终止函数并提供一个结果值。在这里，函数的块表达式的结果值是`if`表达式的结果值，也就是它所跟随的块表达式的结果值，无论是`self.min`、`self.max`还是`self.current`。最终结果是相同的，但表达方式不同。

# 错误处理

有时候，我们可以预测到可能会出错的可能性，或者我们正在使用一个知道它可能不会成功的库函数。当这种情况发生时，我们会发现自己正在使用特殊的`Result`数据类型。结果是**泛型类型**，我们将在后面的章节中讨论，但它对于使用函数是如此关键，我们将在这里以机械的方式展示如何使用它。

一个可能会失败的功能将有一个类似于这样的返回类型：`Result<i32, &'static str>`。我承认，乍一看这有点疯狂。让我们分解一下。类型从`Result`开始，然后是一个`<`，然后是`i32`，然后是一个`,`，然后是`&'static str`，最后是一个`>`。这意味着如果功能成功，它将产生一个`i32`，如果失败，它将产生一个`&'static str`。`&'static str`恰好是字面文本表达式的类型，比如`oops, it broke`，所以我们在这里真正说的是，该函数将返回一个整数或错误消息。

通常有一个专门用于表示错误的类型，比如一个`Error`结构体，而不是仅仅使用文本错误消息。

# 使用 Result 来表示成功或失败

在我们的例子基础上扩展，我们如何编写一个既能成功也能失败的功能？请看以下示例：

```rs
fn can_fail(x: bool) -> Result<i32, &'static str> {
    if x {
        return Ok(5);
    }
    else {
        return Err("x is false");
    };
}
```

首先，我们将返回类型设置为使用`Result`，然后在函数体中，我们使用`Ok()`或`Err()`来表示我们正在返回一个有效值或错误。

如果一个功能可能会失败，但在成功时没有任何有意义的返回值，我们可以使用`()`作为成功的返回类型。所以，在这种情况下，返回类型可能看起来像这样：`Result<(), &'static str>`。成功的返回值将是`Ok(())`。

# 调用返回 Result 类型的功能

当我们调用返回`Result`类型的功能时，返回值正如请求的那样是一个`Result`，而不是我们真正需要的的数据类型。根据我们的具体需求，有几种处理方式。

处理 `Result` 的最简单方法是用 `?` 操作符，它从成功的 `Result` 中提取存储的值，如果查看的 `Result` 指示错误，则返回包含错误值的 `Result`。因为 `?` 可能以与 `return` 语句相同的方式从当前函数返回，所以 `?` 只能在自身返回 `Result` 并使用相同的数据类型来表示错误的函数中使用。使用 `?` 的样子如下：

```rs
let mut cons: Constrained = new_constrained(0, 10, 5)?; 
```

在这里，我们调用 `new_constrained` 函数，它返回一个成功的结果或错误信息。然而，我们赋值的变量类型是 `Constrained`，而不是 `Result`。这之所以可行，是因为末尾的 `?`，它会在函数调用成功时提取 `Constrained` 值，如果函数调用失败则返回。

处理返回的 `Result` 的下一个简单方法是使用 `expect` 函数。这个函数与 `?` 类似，如果 `Result` 指示成功，则提取成功值，但处理失败的方式不同。`expect` 不是从当前函数返回错误，而是终止整个程序并打印出错误信息。使用 `expect` 的函数不需要返回 `Result`，因此它可以在 `?` 不可用的情况下使用。使用 `expect` 的样子如下：

```rs
let mut cons: Constrained = new_constrained(0, 10, 5).expect("Something went very wrong");
```

传递给 `expect` 的参数是它在失败时应该显示的错误信息。还有一些其他与 `expect` 类似的函数，以不同的方式处理错误，例如调用错误处理函数。

最后，我们可以通过检查返回的 `Result` 是 `Ok` 还是 `Err` 来实际处理错误。这是通过使用 `match` 或 `if let` 表达式来完成的，我们将在第四章（700c26ca-e1de-4069-afaf-d9acb22dd6ab.xhtml）中学习，即通过模式匹配做出决策。

# 实现类型的行为

在前面的例子中，我们看到了看似调用包含在数据值中的函数的情况，例如 `"127.0.0.1:12345".parse()` 或 `["Hello", "world", "of", "loops"].iter()`。这些是在这些值的类型上实现的函数。在类型上实现函数的样子如下：

```rs
impl Constrained {
    pub fn set(&mut self, value: i32) {
        self.current = value;
    }

    pub fn get(&self) -> i32 {
        if self.current < self.min {
            return self.min;
        }
        else if self.current > self.max {
            return self.max;
        }
        else {
            return self.current;
        };
    }
}
```

这是一个数据类型（在这个例子中是我们在前面创建的 `Constrained` 类型）的实现块（它不是表达式块）。实现块通过 `impl` 关键字引入，然后是我们要在其中放置函数的类型名称，然后是我们想要添加到数据类型的函数，在 `{` 和 `}` 符号之间。

虽然我们可以像访问包含在数据值中的变量一样访问在类型上实现的函数，但它们实际上并不存储在包含数据值的内存中。没有必要让每个数据值都有函数的副本，因为所有的副本都将完全相同。

在类型上实现的函数可以是公开的或私有的，这取决于我们是否希望外部用户使用数据类型，或者只允许当前模块内的其他函数使用。

当一个函数在某个类型上实现时，第一个参数是特殊的。即使在我们调用函数时没有将其作为函数参数传递，它也会自动提供给函数。这个自动参数传统上被称为`self`。`self`的职责是让函数能够访问通过它被调用的数据值，这意味着如果我们做类似`"127.0.0.1".parse()`的操作，解析函数将`"127.0.0.1"`作为其`self`参数。`self`参数可以写成`self`、`&self`或`&mut self`，这个选择将在下一章讨论。

实现块的语法允许我们指定我们要在哪种数据类型上实现函数。我们能否在未创建的类型上实现函数，比如`i32`或`SocketAddr`？答案是肯定的，但前提是我们必须创建一个*特质*。我们将在第五章中了解更多关于特质的内容，*一种数据类型表示多种数据类型*。不使用特质，我们只能在我们同一项目中创建的数据类型上实现函数，尽管它们不必在同一个模块中。

# 摘要

当我们将本章学到的知识付诸实践时，我们对这些知识的掌握将会更加牢固。我们学习了 Rust 程序的基本结构，以及如何编写函数、循环和分支。此外，我们还学习了 Rust 的类型系统以及如何将行为附加到数据类型上。这些为我们提供了一个基础，让我们可以在此基础上学习使 Rust 真正区别于其他编程语言的特点。

在下一章，我们将探讨 Rust 的基本概念——所有权和借用是如何工作的。
