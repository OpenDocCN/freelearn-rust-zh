评估

# 第一章

1.  是的，这是由 Steve Klabnik 和 Carol Nichols 编著的 **《Rust 编程语言》**。

1.  在 2015 年，它是长 64 位（或 8 字节）。到 2018 年底，它是长 128 位（或 16 字节）。

1.  它们是网络、命令行应用程序、WebAssembly 和嵌入式软件。

1.  它检查非惯用语法，并建议对代码进行更改以实现更好的可维护性。

1.  它将 2015 版本的项目转换为 2018 版本的项目。

1.  将此依赖项添加到 `Cargo.toml` 文件中：

```rs
rand = "0.6"
```

然后，将此代码添加到 `main.rs` 文件中：

```rs
use rand::prelude::*;
fn main() {
    let mut rng = thread_rng();
    let mut numbers = vec![];
    for _ in 0..10 {
        numbers.push(rng.gen_range(100_f32, 400_f32));
    }
    println!("{:?} ", numbers)
}
```

1.  使用前一个问题中使用的依赖项，将此代码添加到 `main.rs` 文件中：

```rs
use rand::prelude::*;
fn main() {
    let mut rng = thread_rng();
    let mut numbers = vec![];
    for _ in 0..10 {
        numbers.push(rng.gen_range(100_i32, 401_i32));
    }
    println!("{:?} ", numbers)
}
```

1.  将此依赖项添加到 `Cargo.toml` 文件中：

```rs
lazy_static = "1.2"
```

然后，将此代码插入到 `main.rs` 文件中：

```rs
use lazy_static::lazy_static;
lazy_static! {
    static ref SQUARES_FROM_1_TO_200: Vec<u32> = {
        let mut v = vec![];
        for i in 1.. {
            let ii = i * i;
            if ii > 200 { break; }
            v.push(ii);
        }
        v
    };
}
fn main() {
    println!("{:?}", *SQUARES_FROM_1_TO_200);
}
```

1.  首先，将此依赖项添加到 `Cargo.toml` 文件中：

```rs
log = "0.4"
env_logger = "0.6"
```

然后，将此代码插入到 `main.rs` 文件中并执行 `RUST_LOG=warn cargo run`：

```rs
#[macro_use]
extern crate log;
fn main() {
    env_logger::init();
    warn!("Warning message");
    info!("Information message");
}
```

1.  将此依赖项添加到 `Cargo.toml` 文件中：

```rs
structopt = "0.2"
```

然后，将此代码添加到 `main.rs` 文件中：

```rs
use structopt::StructOpt;
#[derive(StructOpt, Debug)]
struct Opt {
    #[structopt(short = "l", long = "level")]
    level: u32,
}

fn main() {
    let options = Opt::from_args();
    if options.level < 1 || options.level > 20 {
        println!("Invalid level (1 to 20 is expected): {}", options.level);
    } else {
        println!("Level is {}", options.level);
    }
}
```

# 第二章

1.  因为软件应用的变化会丢失用户插入的所有注释，并按字母顺序排序项目。

1.  当你不确定文件中哪些字段将存在，并希望允许一些缺失字段时，动态类型解析更好。当你想要丢弃不遵守预期格式的文件时，静态类型解析更好。

1.  当你需要将数据结构从你的软件中发送（写入）时，需要一个从 `Serialize` 派生的类型。当你想要接收（读取）数据结构时，需要一个从 `Deserialize` 派生的类型。

1.  这是一个字段缩进以直观显示数据结构的格式。

1.  因为它通过分批将数据加载到内存中来最小化内存的使用。

1.  SQLite 在你想节省磁盘空间、内存空间、启动时间和有时也提高吞吐量时更好。PostgreSQL 在你有复杂的安全需求，或者你的数据必须同时供多个用户访问时更好。

1.  这是一个指向可以转换为 `ToSql` 的对象的引用的切片的引用。

1.  这替换了 SQL `SELECT` 语句中的参数，然后创建并返回由该语句选择的行的迭代器。

1.  `get` 函数读取值；`set` 函数写入值。

1.  让我们使用一个包含关联 *aKey => a string* 的本地 Redis 实例。将此依赖项添加到 `Cargo.toml` 文件中：

```rs
redis = "0.16"
```

然后，将此代码添加到 `main.rs` 文件中：

```rs
use redis::Commands;

fn main() -> redis::RedisResult<()> {
    let id = std::env::args().nth(1).unwrap();

    let client = redis::Client::open("redis://localhost/")?;
    let mut conn = client.get_connection()?;

    if let Ok(value) = conn.get::<_, String>(&id) {
        println!("Value of '{}' is '{}'.", id, value);
    } else {
        println!("Id '{}' not found.", id);
    }
    Ok(())
}
```

# 第三章

1.  `GET` 请求下载资源；`PUT` 发送数据以替换现有数据；`POST` 发送一些服务器应视为新数据的数据；`DELETE` 请求删除资源。

1.  Curl 工具。

1.  处理器声明一个参数，例如 `info: Path<(String,)>`，然后 `&info.0` 表达式的值是第一个 URI 参数的引用。

1.  通过使用 `HttpResponse` 类型的 `content_type` 方法——例如，`HttpResponse::Ok().content_type("application/json")`。

1.  使用伪随机数生成器生成一个大整数，将其格式化为字符串，并将其附加到前缀。然后，你尝试创建一个具有该名称的新文件。如果创建失败，因为另一个文件已存在且具有该名称，你将尝试生成另一个文件名，直到找到一个未使用的组合。

1.  为了缓存可以使用任何请求再次获取的信息，但这样做成本较高。

1.  因为状态被所有请求共享，并且 Actix web 使用多个线程来处理请求，所以状态必须是线程安全的。在 Rust 中声明线程安全对象的典型方式是将它封装在 Mutex 对象中。

1.  因为服务器可能需要等待从数据库、文件系统或另一个进程获取数据，在此等待期间，它可以处理其他请求。多线程是另一种可能的解决方案，但性能较差。

1.  它将另一个 future 链接到当前 future 上。第一个 future 完成后，第二个闭包将异步执行。

1.  `serde` 用于序列化任何内容；`serde_derive` 用于自动为某些数据类型实现序列化；以及 `serde_json` 用于自动为 JSON 数据实现序列化。

# 第四章

1.  创建包含可变部分的 HTML 代码的可能策略如下：

+   **仅代码**：你有一个包含许多打印字符串以创建所需 HTML 页面的编程语言源文件。

+   **带有标签的 HTML**：你编写一个包含所需常量 HTML 元素和所需常量文本的 HTML 文件，但它还包含一些用特定标记括起来的语句。

+   **HTML 模板**：你编写包含标签和填充这些标签的应用代码的 HTML 模板。

1.  使用双花括号，例如，`{{id}}`。

1.  这里使用 `{%` 和 `%}` 标记，如下所示：

```rs
{%if person%}Id: {{person.id}}\
{%else%}No person\
{%endif%}
```

1.  首先，创建一个 `tera::Context` 类型的对象，然后使用其 `insert` 方法向该对象添加必要的名称-值关联。最后，将此上下文作为参数传递给 Tera 引擎的 `render` 方法。

1.  在架构层面，可以将请求视为数据操作命令，或视为请求在浏览器中显示文档。传统上，这两种类型的请求合并为一个数据操作命令，其响应是当前页面的新内容。

1.  因为一些部分（元数据、脚本、样式，以及可能还有页面头部和页脚）在会话期间不会改变或很少改变。其他部分（通常是中心部分或较小部分）会随着用户的任何点击而改变。通过只重新加载改变的部分，应用程序具有更好的性能和可用性。

1.  所有模板文件都是在运行时加载的，因此必须部署模板的子树。

1.  内置的 JavaScript `XMLHttpRequest` 类可以被实例化，并且这些实例有发送 HTTP 请求的方法。

1.  它应该存储在当前网页中的全局 JavaScript 变量中。

1.  处理器可以有一个`BasicAuth`类型的参数，该参数封装了 HTTP 请求的授权头。这样的对象具有`user_id`和`password`方法。

# 第五章

1.  它是一种类似于标准机器语言的编程语言，被所有主要网络浏览器接受。它可以比 JavaScript 更高效，但比其他类似机器语言的编程语言更便携。

1.  它是一种交互式软件的架构模式。它使用*模型*的概念，即包含应用程序状态的数据库结构；*视图*，即使用模型的当前值来显示窗口或窗口一部分的代码；以及*控制器*，即由用户在窗口上的操作激活的代码，更新模型值并激活视图刷新。

1.  Yew 和 Elm 语言使用的 MVC 实现的具体版本基于程序员定义的可能事件集合，称为*消息*。当视图检测到此类可能事件时，控制器通过与事件类型相关联的消息通知。

1.  Yew 组件是 MVC 模式的一个实例。每个三联模型-视图-控制器都是一个组件。

1.  Yew 属性是任何父组件在创建它们时传递给其子组件的数据。它们在组件层次结构中共享数据时是必需的。

1.  你创建两个 Yew 组件——一个处理内部部分，另一个处理页眉和页脚——并且后者包含前者作为其子组件。

1.  回调是可以作为属性传递给其子组件的可调用对象，以便它能够访问父组件的功能。

1.  你将其作为属性传递，将其封装为`std::rc::Rc<std::cell::RefCell>`类型的对象。

1.  因为如果你只将其保留在局部变量中，它将在创建它的函数结束时被销毁。为了确保它能够在从服务器收到响应之前存活，这个对象必须保留在一个寿命较长的结构中。

1.  在你的模型中，你声明一个`DialogService`类型的对象，并使用其`alert`和`confirm`方法。

1.  这留给读者。我在书的 GitHub 仓库中创建了一个示例。

# 第六章

1.  它是一种交互式软件架构，主要用于游戏。在周期性间隔内，框架检查输入设备的状态，相应地修改模型，然后调用绘图例程。其优点是它更好地对应于输入设备具有连续输入的情况，例如某个键被按了一段时间，或者屏幕输出连续变化，即使用户没有进行任何操作。

1.  当输入事件是离散的，例如在按钮上点击鼠标或输入框中输入文本时，并且当输出仅因为用户操作发生时。

1.  连续仿真软件、工业机器监控软件或多媒体软件。

1.  要绘制一个形状，你调用当前窗口的 `draw_ex` 方法。该方法的第一参数描述了要绘制的形状；它可能是一个 `Triangle`、`Rectangle` 或 `Circle` 类型的实例。

1.  在 `update` 函数中，你可以检查键盘上任何键的状态。例如，`window.keyboard()[Key::Right].is_down()` 表达式在右箭头键被按下时返回 `true`。

1.  模型必须实现 `State` 特性。在该特性中，`update` 方法是控制器，`draw` 方法是视图。

1.  Quicksilver 有两个速率，一个用于 `update` 方法，一个用于 `draw` 方法。它们有默认值，但如果你想改变它们，设置传递给启动应用程序的 `run` 函数的 `Settings` 结构中的 `update_rate` 和 `draw_rate` 字段。

1.  你可以通过调用 `Font::load(filename)` 函数来开始加载字体，通过调用 `Sound::load(filename)` 函数来开始加载声音，等等。这样的调用会返回一个等待实际资源加载的 future。然后，你调用 `Asset::new` 函数，指定 future 作为其参数。第一次使用时，它将等待资源的完整加载。资源必须位于项目根目录下名为 `static` 的文件夹中。

1.  在一个变量中加载了记录的声音资源之后，你可以调用 `play_sound` 函数，并将该资源作为参数传递。

1.  在一个变量中加载了字体资源之后，在 `draw` 方法中，你可以调用该资源的 `execute` 方法，该方法等待字体完全加载，然后你调用已加载资源的 `render` 方法来在图像中绘制文本。然后，你可以通过调用窗口的 `draw` 方法在该窗口上绘制该图像。

# 第七章

1.  向量是一个可以添加到另一个向量中并且可以乘以一个数的实体。将两个点相加或对一个点乘以一个数是没有意义的。

1.  在几何学中，向量是一个平移或位移；点是一个位置。

1.  因为某些事件是离散的。例如，当我点击一个按钮时，我对鼠标按下多少毫秒不感兴趣；我只想要得到一个点击事件。如果我输入一个单词，我想要在每次按键时得到一个字符输入。

1.  因为资源通常只在应用程序启动时加载，或者当进入或退出关卡时。

1.  可以为 `EventHandler` 特性定义可选的 `key_down_event`、`key_up_event`、`mouse_button_down_event` 和 `mouse_button_up_event` 方法。这些方法在模型中注册它们已被调用（即，在时间范围内发生了相应的事件）。然后，`update` 方法检查并重置模型中的这些设置。

1.  它是一组要绘制的形状。要绘制一个形状，首先，你创建一个新的 `Mesh` 实例，然后向其中添加形状（矩形、三角形等），然后你可以在屏幕上绘制该网格。

1.  通用方法是使用 `MeshBuilder::new()` 创建一个 `MeshBuilder` 实例；向该构建器添加形状，使用其方法（`rectangle`、`polygon` 等）；然后调用 `build` 方法，该方法返回一个 `Mesh` 实例。但还有更简短的方法，例如 `Mesh::new_circle` 函数，它返回一个包含单个圆的 `Mesh` 实例。

1.  `update` 方法总是以最高速度调用，但它会反复检查内部计时器，以确保其主体只执行所需的次数。

1.  `draw` 函数使用接收绘图上下文、要绘制的网格和 `DrawParam` 结构作为参数。这个结构可以包含在绘制网格时应用到网格上的几何变换。

1.  `audio::Source` 对象有几个方法，包括 `play` 和 `play_detached` 方法。第一个方法在播放指定声音之前会自动停止之前的音效；第二个方法会与现有音效重叠。

# 第八章

1.  正则语言是可以由正则表达式定义的，它是由三个运算符的组合：连接、交替和重复。上下文无关语言是可以包含正则运算符，以及匹配符号（如括号）。上下文相关语言是其中任何表达式的有效性可能依赖于之前定义的任何其他表达式的语言。

1.  它是一组规则，其中程序是一个符号，每个符号都被定义为符号或字符的连接或交替。

1.  它是一个接收编程语言的正式定义作为输入并生成编译器作为输出的程序，编译器是一个解析（甚至编译成机器语言）指定语言编写的程序的程序。

1.  它是一个接收一个或多个解析器作为输入并返回以某种方式组合输入解析器的解析器的函数。

1.  因为在 Rust 语言的 2018 年版本之前，Rust 语言不允许返回函数而不将它们封装在分配的对象中。允许函数无分配返回的功能被称为 `impl Trait`。

1.  `tuple` 解析器组合器接收一系列解析器，并返回一个按顺序应用它们的解析器。`alt` 解析器组合器接收一系列解析器，并返回一个交替应用它们的解析器。`map` 解析器组合器接收一个解析器和闭包，并返回一个应用该解析器然后使用闭包转换其输出的解析器。

1.  词法分析、语法分析、语义分析和解释。

1.  词法分析、语法分析、语义分析、中间代码生成、中间代码优化、可重定位机器代码生成和链接。

1.  当定义一个标识符时，需要符号表来检查在当前作用域中该名称尚未被定义，如果语言不允许标识符的遮蔽。当使用标识符时，需要符号表来检查该名称已经定义，并且它具有与使用兼容的类型。

1.  当定义一个标识符时，需要符号表来存储标识符的初始值。当使用标识符时，需要符号表来获取或设置与该标识符关联的值。

# 第九章

1.  可能的用途：

+   当计算机不可用时要运行二进制程序

+   当源代码不可用时，调试或分析二进制程序

+   反汇编机器代码

+   将二进制程序翻译成另一种机器语言

+   将二进制程序翻译成高级编程语言

1.  它是主要的数据寄存器。它是任何指令的默认源和目标。

1.  它是主要地址寄存器。它包含将要被检索和执行的下一个指令的地址。

1.  一个原因是使用数字比使用名称更容易出错。另一个原因是当添加或删除指令或变量时，所有后续指令或变量的地址都会改变，因此代码中的许多地址必须增加或减少。

1.  为每种指令类型定义一个变体。变体的名称是指令的符号名称，其参数是指令操作数的类型。

1.  小端表示法是指一个字的低字节具有较低的内存地址，而大端表示法是指高字节具有较低的内存地址。

1.  对于接受文本的解析器，输入是字符串切片的引用，具有`&str`类型，而对于接受二进制数据的解析器，输入是字节切片的引用，具有`&[u8]`类型。

1.  需要遵守的规则如下：

+   它以包含进程大小的字节数的小端字开始。

+   在初始单词之后，有一系列有效的机器语言指令，没有交错的空间或数据。

+   `Terminate`指令只出现一次，作为最后一个指令，以标记指令序列的结束。之后，只剩下数据。

+   没有语句写入指令；只有数据可以更改。因此，程序不是自修改的；换句话说，程序指令与过程指令相同。

1.  因为有时一个 16 位数字可以有用地被视为一对字节，有时又是一个单独的数字。十六进制格式满足这两个要求，因为每对十六进制数字是一个字节，整个四位数序列是一个 16 位数字。

1.  通过将其封装在一个新类型中，然后为该类型实现`Debug`特质。

# 第十章

1.  它是 Linux 操作系统内核的一个扩展，可以在运行时添加或删除。

1.  C 编程语言，带有 GCC 扩展。

1.  这是一个仅用于记录内存的区域，每个内核模块都可以向其中写入。当内核模块向其写入时，会在每行的开头添加一个括号包围的时间戳；这是自内核启动以来的秒数和微秒数。

1.  `ModInfo`打印有关 Linux 模块文件的一些信息；`LsMod`打印当前所有已加载模块的列表；`InsMod`从指定的文件加载 Linux 模块并将其添加到正在运行的内核中；`RmMod`从正在运行的 Linux 内核卸载指定的模块。

1.  因为`![no_std]`指令阻止了标准堆分配器的使用以及所有使用它的标准类型。任何内核模块都需要一个自定义分配器，所以这个指令是必需的。

1.  它是向链接器的一个指令，以保留以下函数的确切名称，以便内核可以通过名称找到该函数。

1.  它指定函数调用约定必须是 C 语言通常使用的那个。

1.  它是模块的两个入口点：当模块被加载时，内核会调用`init_module`函数，当模块被卸载时，内核会调用`cleanup_module`函数。

1.  `__register_chrdev`用于在内核中注册字符设备；`__unregister_chrdev`用于注销它。

1.  `_copy_to_user`函数。
