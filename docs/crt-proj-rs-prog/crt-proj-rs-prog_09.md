使用 Nom 创建计算机模拟器

在最后一章中，我们看到了如何解析文本文件——特别是如何用简单的编程语言编写源文件。文本文件并不是你需要解析的唯一东西——几种类型的系统软件需要解析二进制文件（如二进制可执行文件、多媒体文件和进程间通信消息）。

在本章中，我们将探讨如何应对解析二进制文件的需求以及如何使用`nom`库来简化这项任务。首先，我们将探讨如何在不使用外部库的情况下解析和解释一个非常简单的机器语言，然后我们将探讨如何使用`nom`库来简化这项任务。

为了做到这一点，我们将涵盖以下主题：

+   介绍一种仅使用 16 位字的最简单机器语言

+   用这种语言编写几个程序

+   为这种语言编写解析器和解释器，并在之前展示的程序上运行它

+   定义一个从之前版本派生出的字节寻址机器语言

+   解释当字节寻址的机器语言必须处理包含多个字节的单词时出现的寻址问题（字节序）

+   以新机器语言的形式展示之前展示的机器语言程序版本

+   使用`nom`库为这种语言编写解析器和解释器，并在机器语言程序上运行它

+   编写一个 C 语言翻译器，将机器语言程序转换为等效的 C 语言程序

+   编写几个反汇编器——将机器语言程序转换为汇编语言的程序，并将它们应用于我们的机器语言程序

到本章结束时，你将学会 CPU 架构、解释和翻译机器语言的主要概念。

# 第十章：技术要求

对于本章中涉及`nom`库的部分，需要了解前一章的内容。

本章的完整源代码位于[`github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers`](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)存储库的`Chapter09`文件夹中。

# 项目概述

在本章中，首先将介绍有关机器语言的一般概念。然后，将介绍一个非常简单的机器语言。当然，这在使用上相当不切实际，因为没有真实的硬件来运行它。它将仅用于演示如何处理它。

然后，将在机器语言中编写一个非常简单的算法——整数数字的格式化器。将编写一个 Rust 程序来解释这个程序，而无需使用外部库（`word_machine_convert`）。

然后，将用这种机器语言编写一个更复杂的程序——著名的埃拉托斯特尼发明来寻找素数的算法（称为**埃拉托斯特尼筛法**）。之前的 Rust 程序将用于解释这个机器语言程序（`word_machine_sieve`）。

之后，将定义一种更接近现实世界的机器语言，它能够处理单个字节而不是字。这种机器语言提出的问题将被解释。将用这种更新的机器语言编写一个新的埃拉托斯特尼筛法版本，并编写一个 Rust 解释器来运行它。此外，这个 Rust 程序将把机器语言程序翻译成 C 语言。这个解释器和编译器将使用在前一章中已介绍过的`nom`库来生成程序的中间版本。这个中间数据结构将被解释和编译成 C 语言（`nom_byte_machine`）。

最后，将为这种机器语言构建一个**反汇编器**（`nom_disassembler`）。它将再次使用`nom`库，并展示两种类型的反汇编——一种旨在帮助调试，另一种旨在为汇编器生成源代码；也就是说，一个将符号代码翻译成机器语言的程序。

# 介绍一个非常简单的机器语言

真实的机器语言和真实的计算机过于复杂，无法在一个章节中涵盖；因此，我们将使用一种更容易处理和理解的玩具机器语言。实际上，将使用两种机器语言：

+   我们将使用的第一种语言是更简单的一种。为了简单起见，它处理 16 位字，而不是内存字节。

+   第二种语言可以处理单个字节，就像大多数现代计算机一样。

因此，我们将使用的第一种语言只是一个 16 位字的序列，任何用其编写的程序只能操作 16 位字。

这两种机器语言都只使用一个包含机器代码和数据的内存段。在这里，代码和数据之间没有真正的区别；指令可以读取或写入代码和数据，数据可能错误地被执行，就像它是指令一样。通常，代码和一些数据（所谓的**常量**）是不打算改变的，但在这里，没有保证。

在大多数计算机架构中，任何进程使用的内存由几个部分组成，称为**段**。最常见的内存段是机器代码（通常称为文本）、静态数据、堆栈和堆。一些段可能是只读的，而其他段可能是可写的。一些段可能有固定的大小，而其他段可能可以调整大小。一些段可以与其他进程共享。

让我们看看为什么我们可能需要处理机器语言软件的一些原因：

+   当计算机不可用（因为购买成本太高或尚未建造）时运行计算机的二进制程序

+   当没有源代码且必须运行的计算机资源受限，以至于无法在其上运行调试器时，调试或分析二进制程序

+   拆解机器码——即将其翻译成汇编代码

+   将二进制程序翻译成另一种机器语言以在更快的速度本地运行，比通过解释它运行要快得多

+   将二进制程序翻译成高级编程语言以方便修改，然后再将其重新编译成任何机器语言

直接用机器码编写程序非常容易出错，所以没有人这样做。任何需要编写一些机器语言的人首先会用一种称为**汇编语言**的符号语言编写代码，然后将其翻译成机器语言。这种翻译可以手动完成或使用一个名为**汇编器**的特定程序完成。在这里，我们没有为我们的程序提供汇编器，所以我们将手动翻译汇编代码。然而，在描述我们的机器语言之前，让我们先看看一些与机器语言相关的概念。

## 与机器语言最相关的最重要的概念

在任何编程语言中，你需要一种方式来指定变量和语句。此外，为了记录代码，你需要一种方式在程序中插入注释。以下是一个非常简单的汇编语言程序，包含一些变量的声明、一些指令和一些注释：

```rs
// data
n
    word 17
m
    word 9
sum
    word 0
// code
    load n
    add m
    store sum
    terminate 0
```

双反斜杠(`//`)开始注释。第一条注释声明（对人类而言）`data`部分开始的位置。第二条注释声明`code`部分开始的位置。

注意，除了注释外，一些行是缩进的，而另一些行则没有。实际的声明和指令必须缩进。第一列的行是**标签**，用于标记程序中的位置。

在前面的代码中，有一些数据，如第一行所示。每个数据项都是一个字，因此它使用`word`关键字声明。在位置`n`处有一个初始值为`17`的字。在位置`m`处有一个初始值为`9`的字，在`sum`位置处有一个初始值为`0`的字。

然后，有四条指令，每条指令都在不同的行上。每条指令有两个部分：

+   **操作码**（**opcode**）：这是给处理器的命令。

+   **操作数**：这是操作码命令的参数——即命令所操作的数据。

所有机器语言都是为特定的计算机架构设计的。运行此程序的计算机只有两个 16 位 CPU 寄存器：

+   一个用于保存要操作的数据字，称为**累加器**

+   一个用于保存下一个要执行的指令地址，称为**指令指针**（或**程序计数器**）

程序的第一条指令是`load n`。这条指令等同于 Rust 语句`accumulator = n;`。它将地址为`n`的当前字值复制到累加器中。

第二条指令是 `add m`。这相当于 Rust 中的 `accumulator += m;` 语句。它将标签为 `m` 的地址处的字值加到累加器当前包含的值上，并将结果存储到累加器中。

第三条指令是 `store sum`。这相当于 Rust 中的 `sum = accumulator;` 语句。它将累加器的当前值复制到标签为 `sum` 的地址处的字。

最后一条指令是 `terminate 0`。这终止了程序的执行（如果有的话，返回到操作系统），并返回 `0` 值给启动此程序的进程（如果有的话）。

因此，如果我们跟随指令对数据的影响，我们发现这个程序以包含 `17`、`9` 和 `0` 的三个数据字开始，并以它们包含 `17`、`9` 和 `26` 结束。

然而，为了运行这个程序，我们需要将其翻译成机器语言。

这里，需要对 **程序** 和 **进程** 之间的区别进行区分。机器语言程序是在运行之前存在的机器代码。`t` 要么存储在存储设备或 ROM 中。相反，进程是在程序加载并运行的 RAM 区域中找到的。这种区别在多进程系统中尤为重要，在这种系统中，你可能有多个进程在同一个程序上运行，但在一次只运行一个进程的系统中也很重要。

让我们假设我们的机器要求任何程序都必须具有以下结构：

| 进程长度 |
| --- |
| 第一条指令 |
| 第二条指令 |
| 第三条指令 |
| ... |
| 最后一条指令 |
| 数据的第一字 |
| 第二字数据 |
| 数据的第三字 |
| ... |

这个表显示程序的第一个字意味着整个进程的字长度。它后面的字意味着机器语言中的指令。程序的最后一条指令后面的字意味着数据。

在前面的程序中，我们有四个指令，每个指令使用一个字作为操作码和一个字作为操作数。因此，四个指令共占用八个字。如果我们把包含进程长度的初始字和三个变量占用的三个字（每个变量一个字）加起来，我们得到 *1 + 8 + 3 = 12* 个字。这是该程序使用的内存空间的大小，以字为单位。如果我们把这个数字设置为程序的初始字，这意味着我们需要在进程中恰好有那么多内存。

如果我们布置指令和数据，我们得到以下字数组用于我们的进程：

| **位置** | **内容** |
| --- | --- |
| `0` | 进程长度 |
| `1` | `load` 指令的操作码 |
| `2` | `n` 操作数 |
| `3` | `add` 指令的操作码 |
| `4` | `m` 操作数 |
| `5` | `store` 指令的操作码 |
| `6` | `sum` 操作数 |
| `7` | `terminate` 指令的操作码 |
| `8` | `0` 操作数 |
| `9` | 数据 17 |
| `10` | 数据 9 |
| `11` | 数据 0 |

任何单词的位置是其从程序开始处的距离，以单词为单位。任何位置都被称为单词的 **地址**，因为这个数字允许我们在过程中访问该单词。

机器语言不使用 **标签**；它只使用 **地址**。因此，为了将汇编代码翻译成机器语言，我们必须用内存地址替换标签的使用。第一个单词的地址，根据定义，是 `0`。第一个指令的地址是 `1`。任何指令都是两个单词长，因此第二个指令的地址是 *1 + 2 = 3*。最后一个指令之后的地址，即第一个数据单词的地址，标记为 `n`，是 `9`。第二个数据单词的地址，标记为 `m`，是 `10`。最后一个数据单词的地址，标记为 `sum`，是 `11`。

在添加初始长度、将指令移动到数据之前并替换标签之后，我们的程序变成了以下形式：

```rs
12
load 9
add 10
store 11
terminate 0
word 17
word 9
word 0
```

然后，我们必须将每个符号代码替换为其对应的机器语言操作码，这是一个唯一的数字。

让我们假设操作码和符号指令代码之间的以下对应关系：

```rs
0 = terminate
1 = load
2 = store
3 = add
```

`word` 关键字实际上并不生成指令。因此，我们的程序变成了以下形式：

```rs
12
1: 9
3: 10
2: 11
0: 0
17
9
0
```

当然，这些数字将作为二进制数字的向量存储。所以，在 Rust 中，它将是以下形式：

```rs
let mut program: Vec<u16> = vec![12, 1, 9, 3, 10, 2, 11, 0, 0, 17, 9, 0];
```

因此，我们已经能够手动将汇编语言程序翻译成机器语言程序。然而，我们使用了一个非常小的机器语言，只包含四种类型的指令——也就是说，只有四种不同的操作码。为了执行有用的工作，需要更多种类的指令。

## 扩展我们的机器语言

我们在前一节中看到的机器语言只能进行加法操作，并且没有输入/输出能力。这样的有限语言并不很有趣。因此，为了有一个可以用来构建有意义程序的编程语言，让我们向我们的机器语言添加一些 **种类** 的指令。

我们的汇编语言（及其对应的机器语言）由以下表格定义：

| **操作码** | **汇编语法** | **描述** |
| --- | --- | --- |
| `0` | `terminate operand` | 这将终止程序，将操作数返回给调用者。 |
| `1` | `set operand` | 这会将操作数复制到累加器中。 |
| `2` | `load address` | 这会将此地址的值复制到累加器中。 |
| `3` | `store address` | 这会将累加器的值复制到这个地址。  |
| `4` | `间接加载地址` | 这会将指定在此地址的地址的值复制到累加器中。 |
| `5` | `间接存储地址` | 这会将累加器的值复制到指定在此地址的地址。   |
| `6` | `输入长度` | 这会要求用户在按下*Enter*键之前从控制台接收输入。然后，最多将输入行的`length`个字符复制到连续的内存字中。这个内存字的序列从累加器中包含的地址开始。每个内存字包含恰好一个字符。如果用户输入的字符少于`length`个，则剩余的字被设置为二进制零（`0`）。因此，无论如何，此指令都会设置`length`个内存字。 |
| `7` | `输出长度` | 将`length`个 ASCII 字符（其代码在连续的内存字中）输出到控制台。要输出的内存字序列从累加器中包含的地址开始。仅正确支持 7 位 ASCII 字符。 |
| `8` | `加地址` | 将该地址的值加到累加器的值上，并将结果保留在累加器中。它使用 16 位整数算术并带有环绕——即在整数溢出的情况下，获得 65,536 的模值。 |
| `9` | `减地址` | 使用环绕算术从累加器的值中减去该地址的值，并将结果保留在累加器中。 |
| `10` | `乘地址` | 使用环绕算术将累加器的值乘以该地址的值，并将结果保留在累加器中。 |
| `11` | `除地址` | 使用整数算术（截断）将累加器的值除以该地址的值，并将结果（商）保留在累加器中。 |
| `12` | `余数地址` | 这使用整数算术（截断）将累加器的值除以该地址的值，并将整数余数保留在累加器中。 |
| `13` | `跳转地址` | 这将继续执行`address`处的指令。 |
| `14` | `如果累加器为零跳转地址` | 只有当累加器的值等于`0`时，才继续执行`address`处的指令。否则，继续执行下一条指令。 |
| `15` | `如果累加器非零跳转地址` | 如果累加器的值不为`0`，则继续执行`address`处的指令。 |
| `16` | `如果累加器为正跳转地址` | 如果累加器的值是正数，则继续执行`address`处的指令。 |
| `17` | `如果累加器为负跳转地址` | 如果累加器的值是负数，则继续执行`address`处的指令。 |
| `18` | `如果累加器非正跳转地址` | 只有当累加器的值非正——即它是负数或等于`0`时，才继续执行`address`处的指令。 |
| `19` | `jump_if_nonnegative address` | 如果累加器的值为非负值——也就是说，如果它是一个正数或者等于 `0`，则执行 `address` 处的指令。 |
|  – | `word value` | 这为数据保留一个字。其初始内容由 `value` 指定。 |
|  –  | `array length` | 这为 `length` 个字保留一个数组。所有这些字都被初始化为 `0`。 |

注意到 `set` 指令类型（操作码 `1`）非常简单；它将操作数赋值给累加器。几乎所有其他赋值和算术指令类型都有一个间接级别——它们的操作数是必须操作的数据的内存地址。然而，有两个指令——`indirect_load`（操作码 `4`）和 `indirect_store`（操作码 `5`）——有两个间接级别。它们的操作数是一个字的内存地址，即必须操作的数据的内存地址。

现在我们有了足够强大的机器语言，我们可以用它编写一个有意义的程序。

## 编写一个非常简单的程序

为了向您展示如何使用这种语言，让我们用一些代码来写一些程序。我们将创建一个程序，当给定一个存储在内存字中的正整数（二进制格式）时，以十进制表示法打印它。

假设要打印的数字硬编码为 `6710`。当我们用 Rust 编写算法时，它如下所示：

```rs
fn main() {
    let mut n: u16 = 6710;
    let mut digits: [u16; 5] = [0; 5];
    let mut pos: usize;
    let number_base: u16 = 10;
    let ascii_zero: u16 = 48;

    pos = 5;
    loop {
        pos -= 1;
        digits[pos] = ascii_zero + n % number_base;
        n /= number_base;
        if n == 0 { break; }
    }
    for pos in pos..5 {
        print!("{}", digits[pos] as u8 as char);
    }
}
```

在前面的代码中，`n` 变量是要转换和打印的无符号 16 位数字。`digits` 变量是一个缓冲区，将包含生成的数字的 ASCII 值。由于 16 位数字最多有五个十进制数字，五个数字的数组就足够了。`pos` 变量是 `digits` 数组中当前数字的位置。

`number_base` 变量是 `10`，因为我们使用十进制表示法。`ascii_zero` 变量包含零字符的 ASCII 码（即 `48`）。

第一个循环通过使用 `%` 运算符计算 `n` 除以 10 的余数，并将其添加到 `ascii_zero` 来计算任何 ASCII 十进制数字。然后，`n` 被除以 `number_base` 变量，以从其中移除最低位的十进制数字。第二个循环将生成的五个数字打印到控制台。

这个程序的问题在于它需要使用数组索引。实际上，`pos` 是 `digits` 数组的索引。机器语言使用地址，而不是索引；因此，为了模仿机器语言，我们必须将 `pos` 的类型替换为原始指针的类型，在 Rust 中，原始指针的解引用操作是不安全的。我们不是数到五，而是设置一个 `end` 指针。当 `pos` 达到这个指针时，它将完成数组。

因此，让我们将我们的 Rust 程序翻译成一种更接近使用原始指针转换成机器语言的格式：

```rs
fn main() {
    let mut n: u16 = 6710;
    let mut digits: [u16; 5] = [0; 5];
    let mut pos: *mut u16;
    let number_base: u16 = 10;
    let ascii_zero: u16 = 48;
    let end = unsafe {
        (&mut digits[0] as *mut u16).offset(digits.len() as isize)
    };
    pos = end;
    loop {
        pos = unsafe { pos.offset(-1) };
        unsafe { *pos = ascii_zero + n % number_base };
        n /= number_base;
        if n == 0 { break; }
    }
    while pos != end {
        print!("{}", unsafe { *pos } as u8 as char);
        pos = unsafe { pos.offset(1) };
    }
}
```

在前面的程序中，使用了原始指针的不安全`offset`方法。当给定一个原始指针时，它通过在内存中前进指定的位置生成另一个原始指针。

要使程序更类似于机器语言程序，我们应该将所有 Rust 语句拆分为对应机器指令的基本语句。

然而，还有一个问题——我们的累加器寄存器有时会包含数字，有时会包含地址。在 Rust 中使用这是不方便的，因为数字和地址在 Rust 中有不同的类型。因此，在这里，我们将使用两个变量——`acc`（当它用于存储数字时代表累加器）和`ptr_acc`（当它用于存储地址时代表累加器，即内存指针）。

下面是获得的程序，它与机器语言程序非常相似：

```rs
fn main() {
    let mut ptr_acc: *mut u16; // pointer accumulator
    let mut acc: u16; // accumulator
    let mut n: u16 = 6710;
    let mut digits: [u16; 5] = [0; 5];
    let mut pos: *mut u16;
    let number_base: u16 = 10;
    let ascii_zero: u16 = 48;
    let one: u16 = 1;

    ptr_acc = unsafe {
        (&mut digits[0] as *mut u16).offset(digits.len() as isize)
    };
    pos = ptr_acc;
    loop {
        ptr_acc = pos;
        ptr_acc = unsafe { ptr_acc.offset(-(one as isize)) };
        pos = ptr_acc;
        acc = n;
        acc %= number_base;
        acc += ascii_zero;
        unsafe { *pos = acc };
        acc = n;
        acc /= number_base;
        n = acc;
        if n == 0 { break; }
    }
    for &digit in &digits {
        print!("{}",
            if digit == 0 { ' ' }
            else { digit as u8 as char}
        );
    }
}
```

注意，现在，除了最后的`for`循环之外，空行之后的语句相当简单。它们只是赋值，可能还结合了一个操作，例如`%=`, `+=`, 或`/=`。此外，还有一个`if`语句用于在`n`变量为`0`时跳出循环。

这可以很容易地翻译成我们的汇编语言，如下所示：

```rs
n
    word 6710
digits
    array 5
pos
    word 0
number_base
    word 10
ascii_zero
    word 48
one
    word 1

    set pos
    store pos
before_generating_digits
    load pos
    subtract one
    store pos
    load n
    remainder number_base
    add ascii_zero
    store_indirect pos
    load n
    divide number_base
    store n
    jump_if_nonzero before_generating_digits
    set digits
    output 5
    terminate 0
```

这个汇编语言程序可以手动翻译成机器语言。

由于有 5 个数据字，1 个包含 5 个字的数据数组，16 条指令，每条指令占用两个字，以及初始字，我们总共有*5 + 1 * 5 + 16 * 2 + 1 = 43*个字。这个数字将是我们的程序第一个字的值。

然后，考虑到所需的布局（过程长度，随后是指令，然后是数据），我们可以计算跳转目标地址和数据地址，得到以下代码：

```rs
0: 43
1: set 39 // pos
3: store 39 // pos
5: before_generating_digits
5: load 39 // pos
7: subtract 42 // one
9: store 39 // pos
11: load 33 // n
13: remainder 40 // number_base
15: add 41 // ascii_zero
17: store_indirect 39 // pos
19: load 33 // n
21: divide 40 // number_base
23: store 33 // n
25: jump_if_nonzero 5 // before_generating_digits
27: set 34 // digits
29: output 5
31: terminate 0
33: n: 6710
34: digits: 0, 0, 0, 0, 0
39: pos: 0
40: number_base: 10
41: ascii_zero: 48
42: one: 1
```

在前面的代码中，注意地址的符号名称已被注释掉。

然后，通过用操作码替换符号代码，并移除注释和行地址，我们得到机器语言程序，作为以逗号分隔的十进制数字列表：

```rs
43,
1, 39,
3, 39,
2, 39,
9, 42,
3, 39,
2, 33,
12, 40,
8, 41,
5, 39,
2, 33,
11, 40,
3, 33,
15, 5,
1, 34,
7, 5,
0, 0,
6710,
0, 0, 0, 0, 0,
0,
10,
48,
1
```

例如，我们开始于以下行：

```rs
1: set 39 // pos
```

前一行变为以下内容：

```rs
1, 39,
```

因为`1:`行地址已经被移除，所以`set`符号代码被其操作码（`1`）所替换，`// pos`注释被移除，并且添加了两个逗号来分隔数字。

现在，我们可以构建一个 Rust 程序来解释这个程序。你可以在`word_machine_convert`项目中找到它。

如果你在这个项目上执行`cargo run`命令，由于没有依赖项，程序将很快编译。执行将简单地以空格开头打印`6710`。这个项目的名字意味着使用使用字寻址的机器语言来转换数字。

这个 Rust 程序的`main`函数只是将前面的数字列表传递给`execute`函数。

这个函数以以下代码开始：

```rs
fn execute(program: &[u16]) -> u16 {
    let mut acc: u16 = 0;
    let mut process = vec![0u16; program[0] as usize];
    process[..program.len()].copy_from_slice(program);
    let mut ip = 1;
    loop {
        let opcode = process[ip];
        let operand = process[ip + 1];
        //println!("ip: {} opcode: {} operand: {} acc: {}",
        //ip, opcode, operand, acc);
        ip += 2;
```

之前提到的函数（`execute`）模拟了一个极其简单的机器语言处理器，将内存视为 16 位字的一个片段。如果这个函数返回，它将返回可能执行的`terminate`指令的操作数。

`acc`变量表示累加器寄存器。`process`变量表示内存的实际运行时内容。其大小，以字为单位，是程序的第一字指定的数字。拥有比运行它的程序更短的过程是没有意义的，因为会丢失一些数据。

然而，拥有比运行它的程序更大的过程是有意义的，因为这样做，它分配了将被无声明需求的代码使用的内存。这样，你可以有一个只有几个字的程序，使用高达 65,536 字的内存空间，这是 128 **Kibibytes** (**KiB**)。

`process`变量的第一部分使用`program`的内容初始化，`program`是`execute`函数的参数。

`ip`变量是指令指针，初始化为`1`——也就是说，它指向第二个单词，那里有一个要执行的第一条指令。

然后，是处理循环。每条指令恰好有一个操作码和一个操作数，因此它们被加载到相应的变量中。然后，有一个被注释掉的调试语句；如果你的程序没有按预期工作，这可能很有用。

执行任何指令后，通常将执行其后的指令，因此指令指针立即增加两个字以跳过当前指令。例外的是`jump`指令和`terminate`指令。如果`jump`指令的条件得到满足，它将再次更改指令指针，而`terminate`指令将跳出处理循环，甚至跳出`execute`函数。

函数的其余部分是一个大的`match`语句，这是处理当前指令所需的。以下是它的前几行：

```rs
match opcode {
    0 => // terminate
        { return operand }
    1 => // set
        { acc = operand }
    2 => // load
        { acc = process[operand as usize] }
```

这种`match`语句的每个分支的行为都非常简单，因为它旨在由硬件执行。例如，如果当前指令是`terminate`，函数返回操作数；如果是`set`，则操作数被分配给累加器；如果是`load`，则将地址为操作数的内存字分配给累加器；等等。

这里有一对算术指令：

```rs
9 => // subtract
    { acc = acc.wrapping_sub(process[operand as usize]) }
10 => // multiply
    { acc = acc.wrapping_mul(process[operand as usize]) }
```

在所有现代计算机中，整数数字以两种互补的格式存储，并且它们根据这些格式执行操作。这有几个优点：

+   如果操作数都被解释为有符号数或无符号数（但不能是一个有符号数和一个无符号数），则单个算术操作可以工作。

+   如果加法或减法导致整数溢出，然后另一个操作导致结果回到允许的范围内，结果仍然是有效的。

在高级语言中，如 Rust，默认情况下通常不允许算术溢出。在 Rust 中，基本运算符的溢出算术会在显示消息“尝试溢出加法”时引发恐慌。为了允许两种互补的算术，Rust 标准库为任何运算符提供了相应的包装方法，这通常是在机器语言中实现的。要使用它，而不是写 `a + b`，你写 `a.wrapping_add(b)`；而不是写 `a - b`，你写 `a.wrapping_sub(b)`，以及其他运算符也是如此。

`jump` 指令与其他指令略有不同，如下所示：

```rs
15 => // jump_if_nonzero
    { if acc != 0 { ip = operand as usize } }
16 => // jump_if_positive
    { if (acc as i16) > 0 { ip = operand as usize } }
```

在前面的代码中，`jump_if_nonzero` 指令检查累加器的值，并且只有当这个值不是 `0` 时，才将指令指针设置到指定的值。

`jump_if_positive` 指令检查累加器的值是否为正，将其解释为有符号数。如果没有 `as i16` 子句，检查将始终成功，因为 `acc` 变量是无符号的。

注意，在 Rust 中，一个无符号数可以被转换成有符号数，即使结果是负数；例如，表达式 `40_000_u16 as i16 == -25_536_i16` 是正确的。

`input` 和 `output` 指令非常复杂，它们甚至与操作系统交互。当然，它们不是真实世界的机器语言指令。它们被添加到这种伪机器语言中，只是为了能够以合理的努力编写一个完整的程序。在实践中，在真实世界的机器语言中，输入/输出是通过一系列复杂的指令或通过调用操作系统服务来执行的。

因此，我们已经看到了如何解释机器语言程序。然而，这是一个相当简单的程序；所以，在下一节中，我们将查看一个更有趣且更复杂的机器语言程序。

## 一个更复杂的程序——埃拉托斯特尼筛法

现在，让我们考虑一个更现实但具有挑战性的问题——实现一个算法来打印小于一个数 `N` 的所有素数，其中 `N` 是用户在运行时输入的。这被称为**埃拉托斯特尼筛法**算法。

下面是这个程序的 Rust 版本：

```rs
fn main() {
    let limit;
    loop {
        let mut text = String::new();
        std::io::stdin()
            .read_line(&mut text)
            .expect("Cannot read line.");
        if let Ok(value) = text.trim().parse::<i16>() {
            if value >= 2 {
                limit = value as u16;
                break;
            }
        }
        println!("Invalid number (2..32767). Re-enter:")
    }

    let mut primes = vec![0u8; limit as usize];
    for i in 2..limit {
        if primes[i as usize] == 0 {
            let mut j = i + i;
            while j < limit {
                primes[j as usize] = 1;
                j += i;
            }
        }
    }

    for i in 2..limit {
        if primes[i as usize] == 0 {
            print!("{} ", i);
        }
    }
}
```

在前面的代码中，`main` 函数的前 14 行要求用户输入一个数字，直到输入的数字在 `2` 和 `32767` 之间。

接下来的一组语句分配一个字节数组来存储被检测为非素数的数字。最初，它包含所有零，这意味着在所需范围内每个数字都可能是一个素数。然后，按顺序扫描范围内的所有数字，对于每个数字，如果它仍然被认为是素数，则将其所有倍数标记为非素数。

最后的一组语句再次扫描所有数字，并只打印那些仍然标记为素数的数字。

这个程序的难度在于它需要为向量分配内存。我们的机器语言不允许内存分配。我们可以预先分配一个最大所需大小的数组，比如说，400 个单词。

为了预先分配这样的数组，只需指定进程大小等于程序大小加 400 个单词即可。这样做时，当进程开始执行时，它将分配所需的空间，并将其初始化为零的序列。

如您所想象，相应的汇编和机器语言程序相当复杂。它可以在`word_machine_sieve`项目中找到。

如果您运行它并输入一个不超过 400 的数字，所有小于输入数字的质数将被打印到控制台。解释器与前面项目中使用的解释器相同，但在`main`函数中还有一个机器语言程序。

这个机器语言程序比前一个项目的要大得多，并且通过注释进行解释。汇编语言在注释中的任何指令或数据项都是等效的。以下是初始部分，包含四个指令：

```rs
600, // 0:
// Let the user input the digits of the limit number.
1, 190, // 1: set digits
6, 5, // 3: input 5
// Initialize digit pointer.
1, 190, // 5: set digits
3, 195, // 7: store pos 
```

进程大小`600`是 400 个单词，比程序大小多 200 个单词。

其中穿插了一些解释性注释，例如第二行和第五行。

第三行是一个`set`指令（操作码 1），操作数为`190`。注释解释说，这个指令从地址`1`开始，与`set digits`汇编指令相对应。

如您所想象，直接编写机器语言程序而不通过其汇编语言版本几乎是不可能的，手动将汇编语言翻译成机器语言是一项容易出错且繁琐的工作。幸运的是，编写一个为您完成这项工作的汇编器程序相当简单。您可以通过使用前一章中解释的编译技术来完成这项工作。

在下一节中，我们将探讨一个更现实的机器语言以及如何使用`nom`解析库来简化其解释。

# 定义字节寻址的机器语言

在前一个章节中，我们看到了不同类型的机器语言。然而，这种机器语言由于几个原因而相当不现实：

+   它按字寻址内存。这在计算机技术早期是很常见的，直到大约 1970 年。然后，拥有可以寻址单个内存字节的处理器的趋势越来越普遍。今天，可能每个正在生产的处理器都可以寻址单个内存字节。

+   它具有相同长度的指令。可能从未有过所有指令长度都相同的机器语言。一个非常简单的指令，例如一个**无操作**（**NOP**），可以占用一个字节，而有些处理器具有跨越多个字节的指令。

+   对于现实世界的处理器，任何类型的操作都在 16 位字上操作，例如加法。可能有一个指令操作单个字节，将一个 8 位字节加到另一个字节上，另一个指令执行相同操作但是在 16 位字上，将一个字加到另一个字上，另一个指令用于 32 位双字，甚至还有操作更大位序列的指令。

+   它只有一个处理器寄存器——累加器。现实世界的处理器有更多的处理器寄存器。

+   它提供的操作很少。现实世界的机器语言有更多可能的操作，例如逻辑操作、函数调用和函数返回指令、堆栈操作操作以及递增和递减运算符。

在这里，我们将改变我们的机器语言以引入以下缺失的功能：

+   字节寻址

+   可变长度指令

+   加载或存储单个字节的指令，除了加载或存储字节的指令之外

因此，我们对字节寻址的机器语言应用以下更改：

+   每个地址代表内存字节的位位置，而不是内存字的位位置。

+   每个操作码只占用一个字节，而不是像先前语言那样占用一个字。

+   虽然大多数指令类型仍然有一个字操作数，但三种指令类型有一个 1 字节操作数。它们是`终止操作数`、`输入长度`和`输出长度`。

+   语言中增加了四种指令类型来操作单个字节。

要理解这种新的机器语言，重要的是要认识到每个 16 位字包含 2 个字节，一个包含数字的 8 个最低有效位，另一个包含数字的 8 个最高有效位。第一个字节被称为**低字节**，另一个被称为**高字节**。当操作一个字内的字节时，知道它是该字的低字节还是高字节是很重要的。

新的指令类型定义在以下表中：

| **操作码** | **汇编语法** | **描述** |
| --- | --- | --- |
| `20` | `加载字节地址` | 这会将指定地址的字节值复制到累加器的低字节。累加器的高字节被设置为 `0`。 |
| `21` | `存储字节地址` | 这会将累加器值的低字节复制到该地址。累加器的高字节未使用。 |
| `22` | `间接加载字节地址` | 这会将指定地址的字节值复制到累加器的低字节。累加器的高字节被设置为 `0`。 |
| `23` | `间接存储字节地址` | 这会将累加器值的低字节复制到指定地址。累加器的高字节未使用。 |

需要这四个指令是因为`加载`、`存储`、`间接加载`和`间接存储`指令类型仍然传输整个字，而我们还需要读取或写入指定地址旁边的单个字节而不读取或写入该字节。

由于这些变化，在之前的机器语言中，每个指令占用四个字节。然而，在这种新的语言中，三种指令类型——`终止`、`输入`和`输出`——仅占用 2 个字节，而所有其他指令类型占用 3 个字节。

注意，所有其他指令类型保持不变，累加器和指令指针的大小仍然是 16 位。

虽然有了字节寻址能力，并且单词跨越多个字节，但这引发了一个问题。这就是所谓的**字节序**问题，将在下一节中描述。

## 应对字节序问题

考虑累加器中的一个值为 `256` 的字。这个字的低字节是 `0`，高字节是 `1`。这个字将被存储在 `1000` 内存地址。因为这个地址现在指的是一个字节，而不是一个双字节字，所以`存储`指令也必须访问另一个内存字节来存储一个字。对于每个计算机系统，所需的另一个字节是具有以下连续地址的字节，因此它在地址 `1001`。

因此，我们的累加器将存储在地址 `1000` 和 `1001` 的 2 个字节中。然而，数值为 `256` 的低字节，其值为 `0`，可能存储在地址 `1000` 或 `1001`。

在第一种情况下，当低字节存储在地址 `1000` 时，其值为 `1` 的高字节将被存储在地址 `1001`。以下是这种情况下的内存布局：

| **地址** | **内存内容** |
| --- | --- |
| `1000` | 00000000 |
| `1001` | 00000001 |

在第二种情况下，当低字节存储在地址 `1001` 时，高字节将被存储在地址 `1000`。以下是这种情况下的内存布局：

| **地址** | **内存内容** |
| --- | --- |
| `1000` | 00000001 |
| `1001` | 00000000 |

这只是一个约定问题。

不幸的是，一些重要的计算机供应商选择了一种约定，而另一些重要的计算机供应商选择了另一种约定。甚至有些计算机硬件可以被编程在运行时更改约定，因此选择约定取决于操作系统。

低字节具有较低内存地址的约定被称为**小端序**，这在前面两个表中的第一个表中显示。另一种约定，即高字节具有较低内存地址的约定，被称为**大端序**，它在前面两个表中的第二个表中显示。这个问题本身被称为**字节序**问题。

对于我们的机器语言，我们选择了小端序。

现在我们已经定义了新的字节寻址机器语言，并且我们选择了采用小端序约定，我们可以为这种机器语言编写一个解释器。

# nom_byte_machine 项目

现在我们有了新的机器语言，我们可以用它编写一些程序，并尝试为这些程序构建一个解释器。此外，可以使用已在第八章中提到的`nom`库，*使用解析器组合进行解释和编译*，以简化此类解释器的构建。

然而，在我们开始编码之前，让我们考虑执行机器语言程序的可能技术。实际上，至少有三种可能的方式在没有真实硬件的情况下执行机器语言程序：

+   **技术 1**：就像硬件解释它一样解释它。这是在前面章节中用于解释`word_machine_sieve`项目中埃拉托斯特尼筛法程序的技术。

+   **技术 2**：首先，解析整个程序并将其转换成高级数据结构，然后解释这个数据结构。

+   **技术 3**：将其翻译成另一种编程语言，然后使用该编程语言的解释器或编译器。

*技术 1*是三种技术中唯一能够为任何可能的程序获得正确结果的技术。其他两种技术**仅**在程序格式良好，遵循以下规则时才有效：

1.  它以一个包含进程大小的字节的 little-endian 单词开始。

1.  在初始单词之后，是一系列有效的机器语言指令，没有交错的空间或数据。

1.  `Terminate`指令只出现一次，作为最后一个指令，以标记指令序列的结束。之后，只剩下数据。

1.  没有语句会在指令上写入；只有数据可以被更改。因此，程序不是自我修改的；或者说，另一种说法是，程序指令与过程指令相同。

`nom_byte_machine`项目实现了所有三种技术，并将它们应用于一个格式良好的机器语言程序。这个程序是前面章节中看到的筛法算法的版本，为字节寻址的机器语言实现。

首先，让我们尝试通过在`project`文件夹中键入`cargo run`来构建和运行项目。构建将花费一些时间，因为它使用了`nom`库。执行开始于创建包含机器语言程序 C 语言版本的`prog.c`文件，并在控制台上打印以下内容：

```rs
Compiled to prog.c.
```

然后，程序使用前面描述的第一种技术解释程序。这导致它等待用户输入一个数字。你应该输入一个介于`0`和`400`之间的数字，然后按*Enter*键。

将使用*技术 1*打印一些素数，然后程序再次使用*技术 2*解释相同的程序，因此它再次等待用户输入一个数字。你应该再次输入一个数字并按*Enter*键。

例如，如果你第一次输入 `100`，第二次输入 `40`，那么控制台应该显示以下内容：

```rs
Compiled to prog.c.
100
 2    3    5    7   11   13   17   19   23   29   31   37   41   43   47   53
 59   61   67   71   73   79   83   89   97
Return code: 0
40
 2    3    5    7   11   13   17   19   23   29   31   37
Return code: 0
```

执行后，`prog.c` 文件将存在于 `project` 文件夹中。在类 Unix 环境中，你可以使用以下命令编译它：

```rs
cc prog.c -o prog.exe
```

这将创建 `prog.exe` 文件。然后，你可以使用以下命令运行它：

```rs
./prog.exe
```

当然，这个程序与之前解释的程序具有相同的行为。它首先请求一个数字，例如，如果你输入 `25`，输出将是以下内容：

```rs
25
 2    3    5    7   11   13   17   19   23
```

由于这个项目相对复杂，其源代码已被拆分为几个源文件。它们如下：

+   `main.rs`：这个文件包含机器语言程序和对其他源文件中包含的函数的调用。

+   `instructions.rs`：这个文件包含机器语言指令的定义和 `nom` 解析器以识别它们。

+   `emulator.rs`：这是机器码的低级解释器。每条指令首先被解析，然后执行。

+   `parsing_interpreter.rs`：首先解析所有机器码指令，构建一个数据结构，然后执行这个数据结构。

+   `translator.rs`：这个文件将所有机器码指令翻译成 C 语言代码，并添加一些 C 语言行以创建一个有效的 C 程序。

让我们看看以下各节中的每个文件。

## 理解 `main.rs` 源文件

`main.rs` 文件包含 `main` 函数，它以以下行开始：

```rs
let prog = vec![
    187, 2, // 0: 699
    // Let the user input the digits of the limit number.
    1, 28, 1, // 2, 0: set digits
    6, 5, // 5, 0: input 5
    // Initialize digit pointer.
    1, 28, 1, // 7, 0: set digits
    3, 33, 1, // 10, 0: store pos
```

这个机器语言程序与 `word_machine_sieve` 项目中使用的类似。在这些程序中，数字代表单词 (`u16`)，而现在它们代表字节 (`u8`)。

首先，阅读注释，除了那些单独占一行的描述性注释。这些注释包含当前指令或数据的地址，后面跟着一个冒号，然后是汇编语句。

第一行表示从地址 `0` 开始的内容。在这种情况下，这是数字 `699`，它是进程所需的长度。正如我们在上一节所说，我们采用了小端序约定来存储单词，因此这个数字被存储为字节对，`187, 2`，这意味着 *2 x 256 + 187*。

第二行是一个描述性注释。第三行表示从地址 `2` 开始的内容，以小端序表示为 `2, 0`。内容是 `set` 指令，其操作数是 `digits` 标签的地址。`set` 指令的操码是 `1`，`digits` 标签位于地址 `284`，以小端序表示为 `28, 1`。因此，这一行上有 `1, 28, 1`。

第四行表示从地址 `5` 开始的内容，这是一个汇编中为 `input 5`、机器码中为 `6, 5` 的指令。程序的其他部分类似。

程序的最后部分是数据部分。以下是其中的一段：

```rs
0, 0, 0, 0, 0, // 28, 1: digits: array 5
0, 0, // 33, 1: pos: word 0
10, 0, // 35, 1: number_base: word 10
```

第一行代表一个 5 字节的数组，所有这些都被初始化为`0`。它的标签是`digits`，其地址是`284`，由`28, 1`对表示。

第二行代表一个初始化为`0`的单词，其标签为`pos`，地址是`33, 1`对，这是在`digits`地址之后的 5 个字节。

第三行代表一个初始化为 10（由`10, 0`对表示）的单词，其标签为`number_base`，其地址是`35, 1`对，这是在`pos`地址之后的两个字节。

主函数以以下行结束：

```rs
let _ = translator::translate_program_to_c(&prog, "prog.c");

let return_code = emulator::execute_program(&prog).unwrap();
println!("\nReturn code: {}", return_code);

let mut parsed_program = parsing_interpreter::parse_program(&prog).unwrap();
let return_code = parsing_interpreter::execute_parsed_program(&mut parsed_program);
println!("\nReturn code: {}", return_code);
```

从前面的代码中，第一条语句调用一个函数，该函数将`prog`机器语言程序翻译成具有指定名称的 C 语言文件。

第二个语句逐条指令解释程序。

最后一段语句首先调用`parse_program`语句，该语句将程序翻译成数据结构并存储在`parsed_program`变量中，然后调用`execute_parsed_program`函数来执行这个数据结构。

Rust 程序的其余部分实现了这些功能，我们将使用`nom`库来完成这个目的。

## 使用 Nom 库

实现本节所描述功能的代码可以在`instructions.rs`源文件中找到。

在前面的章节中，我们看到了如何使用`nom`库来解析文本，即字符串切片。嗯，`nom`不仅限于文本；它还可以用于解析二进制数据，即字节切片。事实上，它就是为了这个目的而创建的，后来才添加了解析字符串的能力。

这里，我们将使用`nom`的二元解析能力来处理我们的机器语言。

解析二进制文件并不比解析文本文件更困难。它们之间的唯一区别在于，当解析文本文件时，解析的文本是字符串切片的引用，具有`&str`类型，而当解析二进制文件时，解析的文本是字节切片的引用，具有`&[u8]`类型。

例如，这是识别`add`指令的解析器的签名：

```rs
fn parse_add(input: &[u8]) -> IResult<&[u8], Instruction> {
```

`parse_add`函数接受一个字节切片的引用作为输入，当然，它的剩余序列仍然是一个字节切片的引用。我们希望它的返回值能够完全描述解析的指令，因此使用了自定义的`Instruction`类型。

这种类型可以按以下方式定义：

```rs
#[derive(Debug, Clone, Copy)]
enum Instruction {
    Terminate(u8),
    Set(u16),
    Load(u16),
    Store(u16),
    IndirectLoad(u16),
    IndirectStore(u16),
    Input(u8),
    Output(u8),
    Add(u16),
    Subtract(u16),
    Multiply(u16),
    Divide(u16),
    Remainder(u16),
    Jump(u16),
    JumpIfZero(u16),
    JumpIfNonZero(u16),
    JumpIfPositive(u16),
    JumpIfNegative(u16),
    JumpIfNonPositive(u16),
    JumpIfNonNegative(u16),
    LoadByte(u16),
    StoreByte(u16),
    IndirectLoadByte(u16),
    IndirectStoreByte(u16),
    Byte(u8),
}
```

从前面的代码片段中，每个指令类型都是`Instruction`枚举的一个变体，这些变体有一个参数来存储操作符的值。`Terminate`、`Input`和`Output`变体有一个`u8`参数，而其他指令类型有一个`u16`参数。注意，最后一个变体不是一个指令；它是`Byte(u8)`，表示在过程中包含的数据字节。

使用 Rust 枚举，很容易将指令的操作数封装在一个变体中，即使有多个，这在现实世界的机器语言中很典型。操作数总是相对较小的对象，因此为 `Instruction` 枚举派生 `Copy` 特性是高效的。

`parse_add` 函数的主体如下：

```rs
preceded(tag("\x08"), map(le_u16, Instruction::Add))(input)
```

在前面的章节中已经看到的 `preceded` 解析器组合器获取两个解析器，按顺序应用它们，丢弃第一个的结果，并返回第二个的结果。

它的第一个解析器是 `tag("\x08")`。在前面的章节中，我们已经看到了 `tag` 函数作为可以识别字面字符串切片的解析器。实际上，它还可以识别字面序列的字节，指定为字面字符串。要使用数字而不是 ASCII 字符来指定字节，十六进制转义序列是合适的。因此，这个解析器识别一个值为 `8` 的字节，这是 `add` 指令的操作码。

`preceded` 处理的第二个解析器必须识别小端 2 字节操作数。因此，使用 `le_u16` 解析器。它的名字意味着小端 u16。还有一个相应的 `be_u16` 解析器，用于识别使用大端字节顺序的词。

`le_u16` 解析器只返回一个 `u16` 值。然而，我们想要一个 `Instruction::Add` 对象来封装这个值。因此，使用 `map` 函数创建一个包含解析字的 `Add` 对象。

因此，`parse_add` 函数的主体首先检查是否有 8 个字节，然后丢弃它们；然后，它读取一对字节，根据小端字节顺序构建一个 16 位数字，然后返回一个包含此字的 `Add` 对象。

对于所有具有字操作数的指令，可以创建类似的解析器。然而，对于具有字节操作数的指令，必须使用不同的操作数解析器。在解析单个字节时，没有端序问题；然而，为了术语一致性，将使用 `le_u8` 解析器，即使 `be_u8` 解析器同样可以使用，因为它们是相同的。

因此，这里解析器被用来识别一个 `terminate` 指令，操作码为 `0`：

```rs
fn parse_terminate(input: &[u8]) -> IResult<&[u8], Instruction> {
    preceded(tag("\x00"), map(le_u8, Instruction::Terminate))(input)
}
```

当我们想要识别 `add` 指令时，我们调用 `parse_add`，当我们想要识别 `terminate` 指令时，我们调用 `parse_terminate`；然而，当我们想要识别任何可能的指令时，我们必须使用 `alt` 解析器组合器将所有指令的解析器作为替代组合起来，如前所述章节中看到的。

这个解析器组合器有一个限制，然而——它不能组合超过 20 个解析器。实际上，我们有 24 种指令类型，因此需要组合 24 个解析器。这个问题可以通过嵌套使用 `alt` 来轻松解决。下面是生成的函数：

```rs
fn parse_instruction(input: &[u8]) -> IResult<&[u8], Instruction> {
    alt((
        alt((
            parse_terminate,
            parse_set,
            parse_load,
            parse_store,
            parse_indirect_load,
            parse_indirect_store,
            parse_input,
            parse_output,
            parse_add,
            parse_subtract,
            parse_multiply,
            parse_divide,
            parse_remainder,
            parse_jump,
            parse_jump_if_zero,
            parse_jump_if_nonzero,
            parse_jump_if_positive,
            parse_jump_if_negative,
            parse_jump_if_nonpositive,
            parse_jump_if_nonnegative,
        )),
        alt((
            parse_load_byte,
            parse_store_byte,
            parse_indirect_load_byte,
            parse_indirect_store_byte,
        )),
    ))(input)
}
```

从前面的代码中，`parse_instruction` 函数使用 `alt` 来组合恰好两个解析器；第一个解析器使用 `alt` 来组合 20 个指令的解析器，而另一个解析器使用 `alt` 来组合剩余 4 个指令的解析器。当将字节切片传递给此函数时，它返回可以从其中解析出的唯一指令或错误，如果没有识别到指令。

`Instruction` 枚举实现了 `len` 方法，这对于找出指令的长度很有用。它如下所示：

```rs
impl Instruction {
    pub fn len(self) -> usize {
        use Instruction::*;
        match self {
            Byte(_) => 1,
            Terminate(_) | Input(_) | Output(_) => 2,
            _ => 3,
        }
    }
}
```

在前面的代码中，`Byte` 占用 `1` 个字节，`Terminate`、`Input` 和 `Output` 指令占用 `2` 个字节，其他指令占用 `3` 个字节。

`get_process_size` 函数用于从程序的第一个字节读取进程的长度。请注意，除了 `parse_instruction` 之外，本模块的所有解析器都是私有的，这样我们就可以解析机器代码指令。

现在我们有了指令的解析器，我们可以使用它构建一个低级解释器（即仿真器）。

## `emulator.rs` 源文件

此仿真器在 `emulator.rs` 源文件中实现。解释器的入口点是以下函数：

```rs
pub fn execute_program(program: &[u8]) -> Result<u8, ()> {
    let process_size_parsed: u16 = match get_process_size(program) {
        Ok(ok) => ok,
        Err(_) => return Err(()),
    };
    let mut process = vec![0u8; process_size_parsed as usize];
    process[0..program.len()].copy_from_slice(&program);
    let mut registers = RegisterSet { ip: 2, acc: 0 };
    loop {
        let instruction = match parse_instruction(&process[registers.ip as usize..]) {
            Ok(instruction) => instruction.1,
            Err(_) => return Err(()),
        };
        if let Some(return_code) = execute_instruction(&mut process, &mut registers, instruction) {
            return Ok(return_code);
        }
    }
}
```

前面的函数接收一个程序作为参数，并通过逐条解析和执行指令来执行它。如果由于指令格式不正确而导致解析错误，则函数返回该解析错误。如果没有发生解析错误，程序将继续执行，直到遇到 `Terminate` 指令。然后，程序返回 `Terminate` 指令的操作数。

第一条语句获取进程所需的大小。然后，创建一个 `process` 变量，它是一个具有指定长度的字节向量。程序的内容被复制到进程的第一部分，然后进程的其余部分初始化为零。

然后，在前面代码的第八行，声明了 `registers` 变量，其类型为 `RegisterSet`，声明如下：

```rs
pub struct RegisterSet {
    ip: u16,
    acc: u16,
}
```

在这个简单的机器架构中，将指令指针和累加器封装在结构体中并没有带来太大的好处，但对于具有许多寄存器的更复杂处理器来说，这将很方便。

最后，是解释循环。它由两个步骤组成：

1.  对 `parse_instruction` 的调用从指令指针的当前位置解析进程并返回 `Instruction`。

1.  对 `execute_instruction` 的调用执行了前面步骤生成的指令，考虑到整个进程和寄存器集。

`execute_instruction` 函数只是一个以以下内容开始的大的 `match` 语句：

```rs
match instruction {
    Terminate(operand) => {
        r.ip += 2;
        return Some(operand);
    }
    Set(operand) => {
        r.acc = operand;
        r.ip += 3;
    }
    Load(address) => {
        r.acc = get_le_word(process, address);
        r.ip += 3;
    }
    Store(address) => {
        set_le_word(process, address, r.acc);
        r.ip += 3;
    }
```

对于每种指令类型，都采取适当的操作。注意以下内容：

+   `Terminate` 指令会导致函数返回 `Some`，而对于任何其他指令，返回 `None`。这允许调用者终止执行循环。

+   `Set`指令将累加器（`r.acc`）设置为操作数的值。

+   `Load`指令使用`get_le_word`函数从`process`的`address`位置读取一个 little-endian 格式的字，并将其赋值给累加器。

+   `Store`指令使用`set_le_word`函数将来自累加器的 little-endian 格式的字赋值到`process`的`address`位置。

+   所有指令都会将指令指针（`r.ip`）增加指令本身的长度。

让我们看看每次指令需要读取或写入内存中的字时使用的辅助函数：

```rs
fn get_le_word(slice: &[u8], address: u16) -> u16 {
    u16::from(slice[address as usize]) + (u16::from(slice[address as usize + 1]) << 8)
}

fn set_le_word(slice: &mut [u8], address: u16, value: u16) {
    slice[address as usize] = value as u8;
    slice[address as usize + 1] = (value >> 8) as u8;
}

```

在前面的代码中，`get_le_word`函数从`address`读取一个字节，并从下一个位置读取另一个字节。在 little-endian 表示法中，第二个字节是最重要的，因此它的值在添加到其他字节之前被左移 8 位。

`set_le_word`函数保存一个字节，连同地址位置，以及下一个位置的一个字节。第一个字节是通过将字转换为`u8`类型获得的，第二个字节是通过将字向右移动 8 位获得的。

当然，`jump`指令是不同的。例如，看看下面的代码片段：

```rs
    JumpIfPositive(address) => {
        if (r.acc as i16) > 0 {
            r.ip = address;
        } else {
            r.ip += 3;
        }
    }
```

将`JumpIfPositive`指令的操作数视为一个有符号数。如果这个值是正的，指令指针被设置为操作数。否则，执行常规的增量操作。

作为另一个例子，让我们看看如何间接加载一个字节：

```rs
    IndirectLoadByte(address) => {
        r.acc = get_byte(process, get_le_word(process, address));
        r.ip += 3;
    }
```

使用`get_le_word`函数，从`process`的`address`位置读取 16 位值。这个值是一个字节的地址，因此使用`get_byte`函数读取这个字节并将其赋值给累加器。

因此，在本节中，我们看到了第一种执行技术——逐条解析和执行指令的技术。

## `parsing_interpreter.rs`源文件

现在，我们可以看看其他的执行技术——首先解析整个程序，然后执行解析结果。

`parsing_interpreter`模块有两个入口点：

1.  `parse_program`

1.  `execute_parsed_program`

第一个步骤是调用一次`get_process_size`函数来从前两个字节中获取进程大小，然后使用以下循环来解析程序指令：

```rs
let mut parsed_program = vec![Instruction::Byte(0); process_size_parsed];
let mut ip = 2;
loop {
    match parse_instruction(&program[ip..]) {
        Ok(instruction) => {
            parsed_program[ip] = instruction.1;
            ip += instruction.1.len();
            if let Instruction::Terminate(_) = instruction.1 {
                break;
            }
        }
        Err(_) => return Err(()),
    };
}
```

在下面的代码中，我们要构建的数据结构是`parsed_program`变量。这个变量是一个指令或字节数据的向量。它通过初始化为具有零值的单个数据字节来初始化，但随后一些字节被替换为指令。

从位置`2`开始，程序会重复使用`parse_instruction`函数进行解析。这个函数返回一个指令，并将其存储在程序位置对应的向量中。当解析到`Terminate`指令时，循环结束。

`parse_instruction`函数与我们在`instructions`模块中看到的相同。

在此循环之后，我们需要将数据值设置到向量中。这是通过以下循环完成的：

```rs
for ip in ip..program.len() {
    parsed_program[ip] = Instruction::Byte(program[ip]);
}
```

这将用另一个字节替换向量的任何字节，其值来自程序。`execute_parsed_program` 函数具有以下结构：

```rs
let mut registers = ParsedRegisterSet { ip: 2, acc: 0 };
loop {
    if let Some(return_code) = execute_parsed_instruction(parsed_program, &mut registers) {
        return return_code;
    };
}
```

上述代码定义了一个寄存器集，然后反复调用 `execute_parsed_instruction` 直到它返回 `Some`。此函数与 `emulator` 模块的 `execute_instruction` 函数非常相似。

主要区别在于使用 `get_parsed_le_word`、`set_parsed_le_word`、`get_parsed_byte` 和 `set_parsed_byte` 函数，而不是 `get_le_word`、`set_le_word`、`get_byte` 和 `set_byte`。

这些函数，而不是在 `u8` 对象的切片中获取或设置 `u8` 值，而是在 `Instruction` 对象的切片中获取或设置 `Instruction::Byte` 值。这个切片是解析后的程序。

我们现在将转向最后一种技术。

## `translator.rs` 源文件

现在，我们可以看看最后一种执行技术——将程序翻译成 C 语言程序，以便可以使用任何 C 编译器进行编译。

`translator.rs` 模块只有一个入口点：

```rs
pub fn translate_program_to_c(program: &[u8], target_path: &str) -> Result<()> {
```

此函数获取要翻译的机器语言程序以及要创建的文件路径，并返回一个表示其成功或失败的结果。

其主体创建一个文本文件，并使用如下语句将其写入：

```rs
 writeln!(file, "#include <stdio.h>")?;
```

它将字符串写入 `file` 流。请注意，与 `println` 宏类似，`writeln` 宏也支持通过成对的大括号进行字符串插值：

```rs
writeln!(file, " addr_{}: acc = {};", *ip, operand)?;
```

因此，任何实际的括号都必须成对出现：

```rs
writeln!(file, "unsigned char memory[] = {{")?;
```

翻译算法相当简单。首先，发出全局字节数组的声明：

```rs
unsigned char memory[];
```

然后，我们有两个实用函数的定义。它们的签名如下：

```rs
unsigned short bytes_to_u16_le(unsigned int address)
void u16_to_bytes_le(unsigned int address, unsigned short operand)
```

第一个读取 `memory` 数组中两个位置的两位字节——`address` 和 `address + 1`——并将它们解释为小端 16 位数字，然后返回该数字。第二个生成构成 `operand` 值的两个字节，并将它们作为小端 16 位数字写入内存的 `address` 和 `address + 1` 位置。

然后，发出 `main` C 函数。它首先声明 `acc` 变量，该变量将用作累加器寄存器。

可能令人惊讶的是，不需要包含指令指针的变量。这意味着在 C 程序执行期间，当前 C 语言语句对应于当前机器语言指令。

机器语言跳转是通过臭名昭著的 `goto` 语句实现的。为了能够跳转到任何指令，必须将跳转目标指令之前放置一个 C 语言唯一的标签。为了简单起见，在翻译任何指令时，生成一个不同的标签，即使其中大多数标签将永远不会被 `goto` 语句使用。

作为例子，让我们考虑`store pos`汇编语言指令，对应于`3, 33, 1`机器语言指令，其中`3`是`store`指令的操作码，`33, 1`代表小端表示法中的`289`。假设这个指令从程序的位置`10`开始。对于这个指令，将生成以下 C 语言语句：

```rs
addr_10: u16_to_bytes_le(289, acc);
```

首先，有一个标签作为可能的`jump`指令的目标。标签是通过将指令的位置与`addr_`常量连接来创建的。然后，有一个函数调用，它将`acc`变量的值复制到`memory`数组中位置`289`和`230`的字节，使用小端表示法。

为了创建这些语句，执行了一个循环，每次使用`parse_instruction`函数解析一条指令，然后使用`translate_instruction_to_c`函数生成相应的 C 语言语句。

这个函数包含一个大的`match`语句，为每种指令类型都有一个分支。例如，将`Store`指令翻译的分支如下：

```rs
Store(address) => {
    writeln!(file, " addr_{}: u16_to_bytes_le({}, acc);", *ip, address)?;
    *ip += 3;
}
```

在循环处理完`Terminate`语句之后，`main` C 函数被关闭，而刚刚声明的`memory`数组现在被定义为使用整个机器语言程序的内容进行初始化。

事实上，由于 C 语言代码没有使用机器语言指令，因此可以从这个数组中省略这些指令，但这样做更简单。

因此，我们已经看到了如何从一个机器语言程序生成一个等效的 C 语言程序，假设它是正确形成的。只要存在`goto`语句，这种技术可以用来生成其他编程语言中的程序。

既然我们已经看到了执行机器语言程序的好几种方法，我们可以看看机器语言解析器的另一种用途。

# `nom_disassembler`项目

我们已经看到，通常机器语言程序是用汇编语言编写的，然后翻译成机器语言。所以，如果我们想理解或调试我们公司编写的机器语言程序，我们应该查看用于生成它的汇编语言程序。

然而，如果这个程序不是由我们公司编写的，我们没有它的汇编语言源代码可用，那么有一个工具尝试将其尽可能好地翻译成相应的汇编语言程序是有用的。这个工具被称为反汇编器，但由于以下原因，它不能创建一个优秀的汇编语言程序：

+   代码中不能插入任何有意义的注释。

+   数据变量没有符号名称来使其有意义。它们只是放置某些数据的位置的内存字节，因此它们通过地址来引用。

+   跳转的目标没有符号名称来使其有意义。它们只是某些指令开始的内存位置，因此它们通过地址来引用。

关于 16 位字，有时将它们视为单个数字是有用的，有时将它们视为字节的成对组合。如果你正在反汇编一个程序以对其进行更改并将其更改后的汇编程序提交给汇编器（以获得更改后的机器语言程序），最好为每个 16 位数字只生成一个数字（对于我们的处理器类型，以小端序表示）。

相反，如果你只是为了深入理解程序而反汇编程序，最好为每个 16 位数字生成一个数字表示法及其字节对的表示。

典型的反汇编器使用十六进制表示法。一个 16 位数字由四个十六进制数字表示，其中两个数字代表一个字节，另外两个数字代表另一个字节。

相反，为了继续使用十进制表示法，`nom_disassembler`项目从同一机器语言程序生成两个输出：

+   一个`FOR DEBUG`输出，其中每个 16 位数字都显示为单个数字和字节对

+   一个`FOR ASSEMBLING`输出，其中每个 16 位数字只显示为单个数字

我们现在将在下一小节学习如何运行项目。

## 运行项目

如果你为这个项目输入`cargo run`，你会看到一个以以下内容开始的冗长输出：

```rs
FOR DEBUG
Program size: 299
Process size: 699
 2: Set(284: 28, 1)
 5: Input(5)
 7: Set(284: 28, 1)
 10: Store(289: 33, 1)
 13: IndirectLoadByte(289: 33, 1)
```

几行之后，你会找到以下内容：

```rs
 297: Byte(2)
 298: Byte(0)

FOR ASSEMBLING
process size 699
 2: set 284
 5: input 5
 7: set 284
 10: store 289
 13: indirect load byte 289
```

最后，你会找到以下内容：

```rs
 297: data byte 2
 298: data byte 0
```

输出的第一部分是`FOR DEBUG`反汇编。在显示程序大小和进程后，开始显示反汇编指令。第一个是`Set`指令，其 16 位操作数是数字`284`，由`28`和`1`字节按小端序组成。第二个指令是`Input`，它有一个 8 位操作数。

任何指令都由指令的第一个字节的地址 precedes。因此，`Set`由`2` precedes（它是程序的第三个字节），`Input`由`5` precedes（它是程序的第六个字节）。

程序以一系列字节结束。由于机器语言没有字数据的概念，数据只是字节序列。

输出的第二部分是`FOR ASSEMBLING`反汇编。这与第一种反汇编技术有以下不同之处：

+   没有程序大小。任何汇编程序都可以计算相应的机器语言程序的大小。在汇编程序的源代码中不需要指定它。

+   指令的符号名称只包含小写字母，并且可以由多个单词组成，单词之间用空格分隔。这样，它们更容易阅读和编写。相反，`FOR DEBUG`输出只使用指令枚举变体的名称。

+   操作数是一个数字。

我们现在将查看源代码以帮助我们进一步理解它。

## 检查源代码

现在，让我们通过检查`main.rs`文件中的源代码来查看这个项目是如何获得这种输出的。这个函数在定义了`prog`变量（如前一个项目所示）之后，只包含以下语句：

```rs
    println!("FOR DEBUG");
    let _ = disassembly_program_for_debug(&prog);
    println!();
    println!("FOR ASSEMBLING");
    let _ = disassembly_program(&prog);
```

`disassembly_program_for_debug`函数产生第一种输出，而`disassembly_program`函数产生第二种输出。让我们看看这些函数做了什么。

## 生成对调试有用的反汇编代码

`disassembly_program_for_debug`函数的有趣部分是以下代码片段：

```rs
loop {
    let instruction = parse_instruction(rest)?;
    println!("{:5}: {:?}", offset, instruction.1);
    offset += instruction.1.len();
    rest = instruction.0;
    if let Terminate(_) = instruction.1 {
        break;
    }
}
for byte in rest {
    let instr = Byte(*byte);
    println!("{:5}: {:?}", offset, instr);
    offset += instr.len();
}
```

在前面的代码中，首先有一个循环使用`parse_instruction`函数解析每个指令，然后有一个循环扫描每个数据字节。对于每个解析的指令，通过`println`打印获得的指令，并将其大小添加到程序中的当前位置，即`offset`。

这个循环在找到`Terminate`指令时结束。对于数据字节，构建一个`Byte`变体，并以类似的方式打印。这引发了如何打印`Instruction`类型对象的问题。

要使用`println`的`{:?}`占位符打印，必须实现`Debug`特性。然而，如果你打印一个如前几章中定义的`Instruction`对象，我们不会得到我们想要的输出。例如，如果你执行`print!("{:?}", Instruction::Set(284))`语句，你会得到以下输出：

```rs
 Set(284)
```

但我们希望得到以下输出：

```rs
 Set(284: 28, 1)
```

为了获得期望的格式化，必须以下述方式定义一个新的类型：

```rs
#[derive(Copy, Clone)]
struct Word(u16);
```

`Word`类型以以下方式封装了`Instruction`变体的所有`u16`参数：

```rs
#[derive(Debug, Copy, Clone)]
enum Instruction {
    Terminate(u8),
    Set(Word),
    Load(Word),
    ...
```

当然，这会导致任何`Instruction`对象构造时在其内部构造一个`Word`对象，并且`Instruction`实现的每个特性和`Word`也必须实现。`Copy`和`Clone`特性使用默认派生实现。

相反，`Debug`特性以以下方式实现：

```rs
impl std::fmt::Debug for Word {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}: {}, {}", self.0, self.0 as u8, self.0 >> 8)
    }
}
```

`fmt`函数的主体写入三个数字——整个参数（`self.0`）、其低字节（`self.0 as u8`）和其高字节（`self.0 >> 8`）。这样我们就得到了期望的格式化。

`Instruction`对象是由指令解析器创建的。因此，根据项目`nom_byte_machine`，这些解析器必须进行更改。在那个项目中，我们看到了一些解析器接受 16 位数字，例如这个：

```rs
fn parse_set(input: &[u8]) -> IResult<&[u8], Instruction> {
    preceded(tag("\x01"), map(le_u16, Instruction::Set))(input)
}
```

对于所有这些解析器，必须将`le_u16`解析器的使用替换为`le_word`解析器的使用，从而得到以下结果：

```rs
fn parse_set(input: &[u8]) -> IResult<&[u8], Instruction> {
    preceded(tag("\x01"), map(le_word, Instruction::Set))(input)
}
```

这个解析器定义如下：

```rs
fn le_word(input: &[u8]) -> IResult<&[u8], Word> {
    le_u16(input).map(|(input, output)| (input, Word(output)))
}
```

它仍然调用`le_u16`解析器，但随后它获取生成的`(input, output)`对，并将`output`项封装在一个`Word`对象中，从而获得`(input, Word(output))`对。

我们已经看到了如何将机器语言程序转换为一种汇编代码。这种反汇编代码对于调试目的很有用，但不容易更改和重新组装以生成新的机器语言程序。在下一节中，我们将探讨另一种有用的反汇编代码，它可以再次进行组装。

## 生成可用于重新组装的反汇编代码

关于另一种输出类型，`FOR ASSEMBLING`，我们必须检查 `disassembly_program` 函数，它与 `disassembly_program_for_debug` 函数的相应部分非常相似。唯一的不同之处在于以下几点：

+   程序大小不会被输出。

+   两个 `println` 语句的格式字符串为 `"{:5}: {}"`，而不是 `"{:5}: {:?}"`。

对于这种格式占位符，`Display` 特性必须由 `Instruction` 类型实现：

```rs
impl std::fmt::Display for Instruction {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        use Instruction::*;
        match self {
            Terminate(byte) => write!(f, "terminate {}", byte),
            Set(word) => write!(f, "set {}", word),
            Load(word) => write!(f, "load {}", word),
            ...
            Byte(byte) => write!(f, "data byte {}", byte),
        }
    }
}
```

对于任何变体，使用 `write` 宏来输出指令的符号名称，后跟字节或字的格式化值。这种格式化还需要为参数实现 `Display` 特性。字节是 `u8` 类型，它已经实现了 `Display` 特性。而对于字，需要以下声明：

```rs
impl std::fmt::Display for Word {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
```

这只是简单地产生封装在 `Word` 对象中的数值。因此，我们已经看到了如何将机器语言程序转换为两种可能的反汇编文本格式。

我们还看到了另一种反汇编方式。作为一个练习，你应该为这种机器语言编写一个汇编器，在由这个反汇编器生成的代码上运行它，并检查生成的机器代码是否与原始代码相同。

# 摘要

在本章中，我们首先定义了一种极其简单的玩具机器语言，然后定义了一种稍微复杂一点的机器语言来实验机器语言操作技术。

第一定义的机器语言假设内存是一系列 16 位字，任何指令都由两个部分组成，每个部分是一个字——操作码和操作数。第二种机器语言假设内存是一系列字节，某些指令可以操作单个字节，而其他指令可以操作整个字。

这引入了端序问题，它涉及到如何解释两个连续的字节作为一个字。例如，欧几里得筛法算法最初是用 Rust 编写的，然后被翻译成两种机器语言。

对于第一种机器语言，编写了一个不使用任何外部库的解释器。它首先用于解释一个小型数字转换程序（`word_machine_convert`），然后是更复杂的筛法算法（`word_machine_sieve`）。

对于第二种机器语言，在单个项目中（`nom_byte_machine`）编写了三个过程。所有这些过程都使用了 `nom` 解析库。第一个过程是逐条指令的解析器。第二个过程首先解析整个程序，然后解析并解释该程序。第三个过程将程序翻译成 C 语言。

对于第二种机器语言，使用了 `nom` 库（`nom_disassembler`）构建了两种反汇编器——一个反汇编器输出的内容对调试有用，另一个反汇编器输出的内容在编辑后重新组装有用。

因此，在阅读完这一章后，你现在应该理解机器语言是什么，它的对应汇编语言是什么，如何将汇编语言翻译成机器语言以及相反，如何将机器语言翻译成 C 语言，如何解释机器语言，以及如何使用 `nom` 解析库来完成这些任务。

在下一章中，我们将学习如何创建 Linux 内核模块。

# 问题

1.  机器语言模拟器有什么用途？

1.  处理器的累加器是什么？

1.  处理器的指令指针是什么？

1.  为什么直接用机器语言编写非常困难，因此最好使用汇编器？

1.  Rust 枚举如何表示机器语言指令？

1.  小端表示法和大端表示法是什么？

1.  接受文本的 `nom` 解析器和接受二进制数据的 `nom` 解析器之间有什么区别？

1.  机器语言程序必须遵守哪些规则才能被完全解析，或者能够将其翻译成另一种编程语言？

1.  为什么在反汇编器中可能会偏好不同类型的输出，或者十六进制输出格式？

1.  如何以不同的方式打印一个单一的数字？
