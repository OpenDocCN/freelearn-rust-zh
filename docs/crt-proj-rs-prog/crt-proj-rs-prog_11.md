Rust 的未来

2015 版 Rust 的热门词汇是*稳定性*，因为 1.0 版本承诺将与后续版本兼容。

2018 版 Rust 的热门词汇是*生产力*，因为 1.31 版本提供了一个成熟的工具生态系统，使得桌面操作系统（Linux、Windows、macOS）的命令行开发者可以更加高效。

有意向在未来几年推出一个新的 Rust 版本，但对于这个版本，其发布日期、功能以及热门词汇都尚未定义。

然而，在 2018 版发布后，全球 Rust 生态系统开发者正在针对 Rust 开发者的几个需求进行开发。很可能新的热门词汇将出自这些开发路线之一。

最有趣的发展方向如下：

+   **集成开发环境**（**IDEs**）和交互式编程

+   Crate 成熟度

+   异步编程

+   优化

+   嵌入式系统

到本章结束时，我们将看到 Rust 生态系统最可能的发展方向：语言、工具和可用库。你将了解未来几年可以期待什么。

Rust 语言中最激动人心的两个新特性是*异步编程*范式和*const 泛型*语言特性。到 2019 年底，前者已经被添加到语言中，而后者仍在开发中。本章将通过代码示例进行解释，因此你将获得关于它们的实际知识。

# IDEs 和交互式编程

许多开发者更喜欢在包含或协调所有开发工具的图形应用程序中工作，而不是使用终端命令行。这类图形应用程序通常被称为**开发环境**——或简称**DEs**。

目前，最受欢迎的 IDE 可能是以下这些：

+   **Eclipse**: 这主要用于 Java 语言的开发。

+   **Visual Studio**: 这主要用于 C#和 Visual Basic 语言的开发。

+   **Visual Studio Code**: 这主要用于 JavaScript 语言的开发。

在 20 世纪，为单一编程语言从头开始创建 IDE 是典型的做法。但这确实是一项重大任务。因此，在过去的几十年里，创建可定制的 IDE 变得更加典型，然后添加扩展（或插件）以支持特定的编程语言。对于大多数编程语言，至少有一个成熟的扩展用于流行的 IDE。然而，在 2018 年，Rust 的 IDE 支持非常有限，这意味着有一些扩展可以在一对 IDE 中使用 Rust，但它们提供的功能很少，性能不佳，而且也存在很多错误。

此外，许多程序员更喜欢交互式开发风格。在创建一个软件系统的新功能时，他们不喜欢写很多软件然后编译和测试所有这些。相反，他们更喜欢写一行或几行代码，并立即测试这些代码片段。在成功测试这些代码片段后，他们将它们集成到系统的其余部分。这对于使用 JavaScript 或 Python 等解释型语言的开发者来说是典型的。

能够运行代码片段的工具是**语言解释器**或**快速内存编译器**。这样的解释器从用户那里读取命令，评估它，打印结果，然后回到第一步。因此，它们通常被称为**读取-评估-打印循环**，或简称**REPL**。对于所有解释型编程语言，以及一些编译型语言，都有成熟的 REPL。在 2018 年，Rust 生态系统缺少一个成熟的 REPL。

在这里，IDE 问题和 REPL 问题一起提出，因为它们存在以下共同问题。现代 IDE 的主要功能是在编辑源代码时进行分析，以下目标是：

+   为了突出显示包含无效语法的代码，并在靠近无效代码的弹出窗口中显示编译错误消息

+   为了建议完成标识符，从已声明的标识符中选择

+   显示在编辑器中选定的标识符的概要文档

+   要从标识符的定义跳转到其使用，或反之亦然

+   在调试会话中，评估当前上下文中的表达式，或更改变量的内存内容

这些操作需要非常快速地解析 Rust 代码，这也是 Rust REPL 所需的功能。解决此类问题的尝试是一个名为**Rust 语言服务器**（[`github.com/rust-lang/rls`](https://github.com/rust-lang/rls)）的项目，该项目由 Rust 语言团队开发。另一个尝试是由 Ferrous Systems 公司开发的名为**Rust Analyzer**（[`github.com/rust-analyzer/rust-analyzer`](https://github.com/rust-analyzer/rust-analyzer)）的项目，由几家合作伙伴支持。希望在下一次 Rust 版本发布之前，会有一个快速且强大的 Rust 语言分析器来支持智能程序员的编辑器、源级调试器和 REPL 工具，就像许多其他编程语言一样。

# Crate 成熟度

当一个 crate 达到*版本 1.0*时，它就变得成熟。这个里程碑意味着后续的 1.x 版本将与它兼容。相反，对于 0.x 版本，没有这样的保证，任何版本都可能有一个与上一个版本相当不同的**应用程序编程接口**（**API**）。

拥有一个成熟的版本对于几个原因很重要，以下列出：

+   当您将依赖项升级到 crate 的新版本（以使用该库的新功能）时，您可以保证现有的代码不会损坏——也就是说，它将继续以先前的方式，或者以更好的方式运行。没有这样的保证，您通常需要审查使用该 crate 的所有代码，并修复所有不兼容性。

+   您在知识技能上的投资得到了保留。您无需重新培训自己或您的同事，甚至无需更新您的文档。

+   通常，软件质量会得到提高。如果一个 API 版本长时间保持不变，并且许多人使用它在不同的边缘情况下，未测试的 bug 和现实世界的性能问题可能会出现并被修复。相反，快速变化的版本通常在许多应用场景中充满 bug 且效率低下。

当然，迭代 API 的几个改进步骤有优势，几周内创建的 API 通常设计得很糟糕。尽管仍然有许多 crate 已经以 0.x 版本存在了几年，但稳定它们的时间即将到来。

这是对流行词“稳定性”的重新解释。在 2015 年，它意味着“语言和标准库的稳定性”。现在，成熟的生态系统其余部分必须稳定下来，才能被实际项目所接受。

# 异步编程

2019 年 11 月，在稳定的 Rust 中引入了一项重大创新——发布 1.39 版——它是`async-await`语法，以支持异步编程。

异步编程是一种在许多应用领域非常有用的编程范式，主要在多用户服务器中，因此许多编程语言——如 JavaScript、C#、Go 和 Erlang——都支持在语言中实现它。其他语言，如 C++和 Java，则通过标准库支持异步编程。

大约在 2016 年，在 Rust 中进行异步编程非常困难，因为既没有语言也没有可用的 crate 以简单和稳定的方式支持它。然后，一些支持异步编程的 crate 被开发出来，例如`futures`、`mio`和`tokio`，尽管它们并不容易使用，并且仍然停留在 1.0 版本之前，这意味着它们的 API 不稳定。

在看到仅使用库创建方便的异步编程支持有多困难之后，很明显需要一个语言扩展。

新的语法，类似于 C#的语法，包括新的`async`和`await`语言关键字。这种语法的稳定意味着之前的异步 crate 现在应该被认为是过时的，直到它们迁移到使用新的语法。

新的语法——在[`blog.rust-lang.org/2019/11/07/Async-await-stable.html`](https://blog.rust-lang.org/2019/11/07/Async-await-stable.html)网页上宣布——在[`rust-lang.github.io/async-book/`](https://rust-lang.github.io/async-book/)网页上进行了描述。

对于那些从未感到异步编程必要的人来说，这里有一个快速示例。创建一个新的 Cargo 项目，并添加以下依赖项：

```rs
async-std = "1.5"
futures = "0.3"
```

在该项目的根目录下准备一个名为`file.txt`的文件，其中只包含五个`Hello`字符。使用类 Unix 的命令行，你可以使用以下命令来完成：

```rs
echo -n "Hello" >file.txt
```

将以下内容放入`src/main.rs`文件中：

```rs
use async_std::fs::File;
use async_std::prelude::*;
use futures::executor::block_on;
use futures::try_join;

fn main() {
    block_on(parallel_read_file()).unwrap();
}

async fn parallel_read_file() -> std::io::Result<()> {
    print_file(1).await?;
    println!();
    print_file(2).await?;
    println!();
    print_file(3).await?;
    println!();
    try_join!(print_file(1), print_file(2), print_file(3))?;
    println!();
    Ok(())
}

async fn print_file(instance: u32) -> std::io::Result<()> {
    let mut file = File::open("file.txt").await?;
    let mut byte = [0u8];
    while file.read(&mut byte).await? > 0 {
        print!("{}:{} ", instance, byte[0] as char);
    }
    Ok(())
}
```

如果你运行这个项目，输出并不完全确定。可能的输出如下：

```rs
1:H 1:e 1:l 1:l 1:o 
2:H 2:e 2:l 2:l 2:o 
3:H 3:e 3:l 3:l 3:o 
1:H 2:H 3:H 1:e 2:e 3:e 1:l 1:l 3:l 1:o 2:l 3:l 2:l 3:o 2:o 
```

前三条线是确定的。相反，最后一条线可以稍微打乱一下。

在第一次阅读时，假设它是同步代码，忽略`async`、`await`、`block_on`和`join!`等单词。通过这种简化，流程很容易理解。

`main`函数调用`parallel_read_file`函数。`parallel_read_file`函数的前六行分别三次调用`print_file`函数，参数为`1`、`2`和`3`，每行后面跟着一个`println!`调用。`parallel_read_file`函数的第七行再次三次调用`print_file`函数，使用相同的三个参数。

`print_file`函数使用`File::open`函数调用打开一个文件，然后使用`file.read`函数调用从该文件中一次读取一个字节。读取到的任何字节都会打印出来，前面跟着函数的参数（`instance`）。

因此，我们得到的信息是第一次调用`print_file`打印了`1:H 1:e 1:l 1:l 1:o`。它们是从文件中读取的五个字符，前面跟着数字`1`，作为函数的参数接收。

第四行打印了前三条线的相同内容，混合了字符。首先打印了三个`H`字符，然后是三个`e`字符，然后是三个`l`字符，然后发生了一些奇怪的事情：在所有`l`字符打印完毕之前，打印了一个`o`。

发生的事情是前三条线是通过`print_file`函数的三个连续调用打印的，而最后一条线是通过对同一函数的三个并行调用打印的。在任何并行调用中，一个调用打印的所有字母都是正确的顺序，但其他调用可能会交错它们的输出。

如果你认为这类似于多线程，你离真相不远了。尽管如此，有一个重要的区别。使用线程时，操作系统可以在任何时候中断线程并将控制权传递给另一个线程，这可能导致输出在不受欢迎的点中断。

为了避免这种中断，必须使用关键区域或其他同步机制。相反，在异步编程中，函数永远不会被中断，除非执行特定的异步操作。通常，这样的操作是调用外部服务，例如访问文件系统，这可能导致等待。而不是等待，另一个异步操作被激活。

现在，让我们从代码的开始部分看起，实现异步操作。它使用`async_std`库。它是标准库的异步版本。标准库仍然可用，但其函数是同步的。代码可以在以下片段中看到：

```rs
use async_std::fs::File;
use async_std::prelude::*;
```

要实现异步行为，必须使用此 crate 的函数。特别是，我们将使用`File`数据类型的函数。此外，还使用了尚未稳定的`futures`crate 的一些功能。代码可以在以下片段中看到：

```rs
use futures::executor::block_on;
use futures::try_join;
```

然后，是`main`函数，其主体只包含以下一行：

```rs
    block_on(parallel_read_file()).unwrap();
```

在这里，首先调用了`parallel_read_file`函数。

这是一个异步函数。当你使用正常的函数调用语法调用异步函数时，就像在`parallel_read_file()`表达式中一样，该函数的函数体实际上并没有被执行，就像一个正常和同步的函数那样。相反，这样的调用只是返回一个对象，称为**future**。future 类似于闭包，因为它封装了一个函数和用于调用该函数的参数。返回的 future 中封装的函数是我们调用函数的函数体。

要实际运行封装在`future`中的函数，需要一个特定的函数，称为**执行器**。`block_on`函数是一个执行器。当调用执行器并传递一个`future`给它时，该`future`封装的函数体将被执行，然后该函数返回的值由执行器本身返回。

因此，当调用`block_on`函数时，`parallel_read_file`的函数体将被执行，当它终止时，`block_on`也会终止，并返回`parallel_read_file`返回的相同值。由于这个最后的函数有一个`Result`值类型，应该将其展开。

然后，定义了一个签名如下所示的功能：

```rs
async fn parallel_read_file() -> std::io::Result<()>
```

`async`关键字标记该函数为异步的。它也是可能出错的，因此返回一个`Result`值。

异步函数只能由其他异步函数或执行器调用，例如`block_on`和`try_join`。`main`函数不是异步的，因此在那里我们需要一个执行器。

以下代码片段中添加了函数体的第一行。它是调用`print_file`函数的调用，传递值`1`给它。由于`print_file`函数也是异步的，因此要从异步函数内部调用它，必须使用`.await`子句。这样的函数是可能出错的，因此添加了一个`?`运算符，如下所示：

```rs
    print_file(1).await?;
```

当使用 `.await` 调用一个异步函数时，该函数的主体立即开始执行，但一旦它因为执行一个阻塞函数（如操作系统调用）而交出控制权，另一个就绪的异步函数可能继续执行。然而，控制流不会超出 `.await` 子句，直到被调用函数的主体执行完毕。

函数主体中的第二行是同步函数的调用，因此不需要也不允许 `.await`，如下面的代码片段所示：

```rs
    println!();
```

我们可以确信它是在前一条语句之后运行的，因为那条语句以 `.await` 子句结束。

这种模式重复三次，然后第七行包含一组与相同异步函数并行调用的三个调用，如下面的代码片段所示：

```rs
    try_join!(print_file(1), print_file(2), print_file(3))?;
```

即使 `try_join!` 宏也是一个执行器。它运行由三次 `print_file` 调用生成的所有三个未来。异步编程只使用一个线程，因此实际上首先运行三个未来中的一个。如果它永远不需要等待，它会在其他未来有机会开始之前结束。

相反，由于这个函数将不得不等待，在任何等待时刻上下文都会切换到另一个正在运行的未来，从将其置于等待状态的语句开始。因此，三个未来的执行是交织在一起的。

现在，让我们看看这种被调用函数的定义。其签名如下面的代码片段所示：

```rs
async fn print_file(instance: u32) -> std::io::Result<()> {
```

它是一个异步函数，接收一个整数参数并返回一个空的 `Result` 值。

其主体中的第一行使用异步标准库中的 `File` 数据类型打开一个文件，如下面的代码片段所示：

```rs
    let mut file = File::open("file.txt").await?;
```

因此，`open` 函数也是异步的，它必须跟随 `.await`，如下面的代码片段所示：

```rs
    let mut byte = [0u8];
    while file.read(&mut byte).await? > 0 {
        print!("{}:{} ", instance, byte[0] as char);
    }
```

异步的 `read` 函数用于读取字节以填充 `byte` 缓冲区。此缓冲区长度为 `1`，因此每次只读取一个字节。`read` 函数是可能出错的，如果成功，它返回读取的字节数。这意味着如果读取了一个字节，它返回 `1`，如果文件结束，它返回 `0`。如果调用读取了一个字节，循环继续。

循环的主体是一个同步输出语句。它打印当前文件流实例的标识符和刚刚读取的字节。

因此，步骤序列如下。

首先，启动`print_file(1)` future。当它执行阻塞的`File::open`调用时，这个 future 被挂起，并寻找一个准备就绪的 future。有两个准备就绪的 future：`print_file(2)`和`print_file(3)`。第一个被选中并启动。它也达到了`File::open`调用，因此被挂起，并启动第三个 future。当它达到`File::open`调用时，它被挂起并寻找一个准备就绪的 future。如果没有准备就绪的 future，线程本身将等待第一个准备就绪的 future。

首个完成`File::open`调用的 future 是第一个，它在调用之后立即恢复执行并开始从文件中读取一个字节。即使这个操作也是阻塞的，所以这个 future 被挂起，控制权转移到第二个 future，它开始读取一个字节。

总是有一个准备就绪的 future 队列。当一个 future 需要等待一个操作时，它将控制权交给执行器，执行器将控制权传递给准备就绪队列中的第一个 future。当阻塞操作完成时，等待的 future 被追加到准备就绪队列中，如果没有其他 future 正在运行，它可以获得控制权。

当读取完文件的所有字节后，`print_file`函数结束。当所有三个`print_file`调用都结束时，`try_join!`执行器结束，`parallel_read_file`函数可以继续执行。当它到达其末尾时，`block_on`执行器结束，随之整个程序结束。

由于阻塞操作需要可变的时间量，步骤的顺序是非确定性的。确实，之前看到的示例程序的最后一行输出在不同的运行中可能会有所不同，交换其中的一些部分。

正如我们所见，异步编程类似于多线程编程，但效率更高，可以节省上下文切换时间和内存使用。它主要适用于**输入/输出**（**I/O**）密集型任务，因为只使用一个线程，并且只有当执行 I/O 操作时才会中断控制流。相反，多线程可以在任何核心上分配不同的线程，因此更适合**中央处理器**（**CPU**）密集型操作。

在添加了`async/await`语法扩展之后，还需要开发和稳定使用并支持这种语法的 crate。

# 优化

通常，系统程序员对效率非常感兴趣。在这方面，Rust 以其高效性而闻名，尽管仍然存在一些性能问题，如下所述：

+   完整构建——特别是优化后的发布构建——相当慢，如果启用了链接时间优化，则更是如此。对于大型项目来说，这可能会相当麻烦。目前，Rust 编译器只是一个前端，它生成 **低级虚拟机** (**LLVM**) **中间表示** (**IR**) 代码，并将此类代码传递给 LLVM 机器码生成器。然而，Rust 编译器生成的 LLVM IR 代码量不成比例，因此 LLVM 后端必须花费很长时间来优化它。一个改进的 Rust 编译器会将一个更紧凑的指令序列传递给 LLVM。编译器的重构正在进行中，这可能会导致编译器更快。

+   自 1.37 版本以来，Rust 编译器支持 **性能分析指导优化** (**PGO**)，这可以提高典型处理器工作流程的性能。然而，此功能使用起来相当繁琐。图形前端或 IDE 集成将使其更容易使用。

+   正在进行开发的是向语言添加 **const 泛型** 功能，这在下一节中描述。

+   在 LLVM IR 中，任何指针类型的函数参数都可以用 `noalias` 属性标记，这意味着此指针引用的内存在此函数内部不会改变，除非通过此指针。利用此信息，LLVM 可以生成更快的机器码。此属性类似于 C 语言中的 `restrict` 关键字。然而，在 Rust 中，对于 **每个** 可变引用 (`&mut`)，`noalias` 属性由语言所有权规则保证。因此，可以获得更快的程序，这些程序始终为每个可变引用生成带有 `noalias` 属性的 LLVM IR 代码。这已经在 1.0 到 1.7 版本以及 1.28 和 1.29 版本中实现，尽管由于 LLVM 后端编译器中的错误，生成的代码存在缺陷。因此，直到发布正确的 LLVM 实现之前，`noalias` 优化提示将不会使用。

## const 泛型功能

目前，泛型数据类型只能由类型或生命周期参数化。能够通过常量表达式来参数化泛型数据类型也是有用的。从某种意义上说，此功能已经可用，但仅限于一种泛型类型：数组。你可以有 `[u32; 7]` 类型，这是一个由 `u32` 类型以及常量 `7` 参数化的数组，尽管你不能定义自己的由常量参数化的泛型类型。

此功能已在 C++ 语言中可用，正在夜间构建中进行开发。它将允许在泛型代码中将变量替换为常量，这无疑会提高性能。以下是一个使用 `num` 包作为依赖项的示例程序：

```rs
#![feature(const_generics)]
#![allow(incomplete_features)]

use num::Float;

struct Array2<T: Float, const WIDTH: usize, const HEIGHT: usize> {
    data: [[T; WIDTH]; HEIGHT],
}

impl<T: Float, const WIDTH: usize, const HEIGHT: usize>
Array2<T, WIDTH, HEIGHT> {
    fn new() -> Self {
        Self { data: [[T::zero(); WIDTH]; HEIGHT] }
    }
    fn width(&self) -> usize { WIDTH }
    fn height(&self) -> usize { HEIGHT }
}

fn main() {
    let matrix = Array2::<f64, 4, 3>::new();
    print!("{} {}", matrix.width(), matrix.height());
}
```

此程序仅使用编译器的夜间版本进行编译，创建了一个实现二维浮点数数组的类型。请注意，参数化如下：`T: Float, const WIDTH: usize, const HEIGHT: usize`。第一个参数是数组元素的类型。第二个和第三个参数是数组的大小。

使用常量值而不是变量允许重要的代码优化。

# 嵌入式系统

Rust 自 2009 年 Mozilla 开始赞助它以来一直在开发，有一个具体的目标：创建一个网络浏览器。即使到 2018 年，开发者的核心团队仍然为 Mozilla 基金会工作，其主营业务是构建客户端网络应用程序。此类软件是跨平台的，但专门针对以下要求：

+   **随机存取存储器 (RAM)**: 至少 1 GB

+   **支持的 CPU**：最初仅支持 x86 和 x86_64；后来，也支持 ARM 和 ARM64。

+   **支持的操作系统**：Linux、Windows、macOS

这些要求排除了大多数微控制器，因为 Mozilla 基金会对此类平台不感兴趣，尽管 Rust 的特性似乎与许多具有更多约束要求的嵌入式系统的需求相匹配。因此，多亏了一个全球志愿者团队，2018 年成立了嵌入式工作组，以开发在嵌入式系统上使用 Rust 所需的生态系统——即在裸机或简化版的操作系统上，以及具有严重资源限制的系统。

在这个应用领域的发展相当缓慢，主要针对少数几种架构，但未来前景看好，至少对于 32 位或 64 位架构来说如此，因为任何由 LLVM 后端支持的架构都很容易被 Rust 编译器定位。

列出了以下针对语言的一些特定改进，这些改进简化了 Rust 在嵌入式系统中的使用：

+   标准库中的 `Pin` 泛型类避免了在内存中移动对象。当某些外部设备访问内存位置时，这是必需的。

+   允许条件编译的 `cfg` 和 `cfg_attr` 属性已被扩展。这个特性是必需的，因为尝试为错误平台编译代码可能会产生不可接受的代码膨胀，甚至导致编译错误。

+   `allocator` API 已被做得更具可定制性。

+   `const fn` 的适用性已经扩展。这个结构允许代码库在作为正常算法代码维护的同时，效率等同于硬编码的常量。

# 摘要

在本章中，我们看到了 Rust 生态系统在未来几年中最可能的发展方向——对 IDE 和交互式编程的支持；最受欢迎的 crate 的成熟；对新的异步编程范式及其关键字（`async` 和 `await`）的广泛支持；编译器和生成的机器代码的进一步优化；以及嵌入式系统编程的广泛支持。

我们已经学会了如何编写异步代码，以及定义和使用 const generics 的可能方法（在撰写本文时仍然不稳定）。

我们已经看到，有很多应用领域是 Rust 能够真正大放异彩的。当然，如果你只是想用它来娱乐，那么天空才是极限，但对于实际应用来说，库和工具的生态系统确实可以决定一个编程系统的可行性。现在，终于，高质量库和工具的临界质量即将达到。
