# 第四章：Lint 和 Clippy

到目前为止，我们需要自己检查代码的所有细节。这往往难以控制，因为我们无法检查每一行代码。在本章中，你将了解 Rust 带给我们的 lint，包括默认启用的和你可以自己启用的。

此外，你还将了解一个伟大的工具 Clippy，它将为你提供更多可用的 lint，并帮助你编写更好的代码。在许多情况下，它会对性能陷阱进行 lint。在其他情况下，它们将是潜在的错误或惯用约定。它还将帮助你清理代码。

在本章中，你将学习以下主题：

+   Rust 中的 linting

+   默认 lint

+   使用和配置 Clippy

+   额外的 Clippy lint

# 使用 Rust 编译器 lint

在撰写本文时，Rust 编译器有 70 个 lint。我们不会检查所有 70 个，但我们会查看其中最相关的几个。让我们首先从学习如何配置 lint 开始。我们将以 `unused_imports` 为例。默认情况下，编译器会为此 lint 提醒你。编译将继续，但会在命令行中显示警告，或者在配置了显示 Rust 编译器警告的编辑器中显示。

我们可以改变这种行为，并且我们可以为每个作用域改变它。选项是 `allow`、`warn`、`deny` 和 `forbid` lint。如果我们允许 lint，则不会出现更多警告。如果我们警告，则编译时会出现警告，如果我们拒绝或禁止，如果找到触发 lint 的内容，程序将无法编译。`deny` 和 `forbid` 之间的区别在于前者可以在后续被覆盖，而后者则不能。因此，我们可以有一个拒绝一种行为的模块，但在一个特定的函数中，我们希望允许它。

此配置可以在 crate 级别应用，例如，在 `lib.rs` 或 `main.rs` 文件的顶部放置 `#![deny(unused_imports)]`。它也可以应用于任何作用域，甚至是你可能在函数内部创建的作用域。如果它在 hash 后面有一个感叹号（`!`），它将影响当前作用域；如果没有，它将影响紧邻的作用域。让我们看看 Rust 编译器提供了哪些 lint。

# Lint

在本节中，我们将检查允许默认行为的 lint，你可能会在大多数情况下至少添加一个警告。

# 避免匿名参数

匿名参数已被弃用。这允许你在不要求在 traits 中绑定名称的情况下指定 traits：

```rs
trait MyTrait {
    fn check_this(String);
}
```

这是一个已弃用的遗留功能，可能在未来的版本中被移除，所以你可能应该避免使用这种语法。为了在你的代码库中警告或拒绝这种语法，你需要使用以下语法：`#![warn(anonymous_parameters)]`。

# 避免堆分配的 box 指针

Rust 默认在栈上分配空间，因为它比使用堆快得多。尽管如此，有时，当我们不知道对象的大小在编译时，我们需要使用堆来分配新的结构体。Rust 通过使用`Vec`、`String`和`Box`等类型来明确这一点。最后一个允许我们将任何类型的对象放入堆中，这通常是一个坏主意，但有时这是必需的。

例如，查看以下代码：

```rs
fn main() {
    let mut int = Box::new(5);
    *int += 5;
    println!("int: {}", int);
}
```

这段代码编译得非常完美，它告诉我们整数是`10 (5 + 5)`。这个问题的主要问题是它执行了堆分配，进行了一个需要找到堆中空间的系统调用等。但我们已经知道整数在编译时具有固定的大小，所以我们应该使用栈来完成这个操作。

通过使用`#![warn(box_pointers)]`警告每个`Box`的使用，可以避免这类错误。但请注意：这将警告所有 boxed 类型的用法，所以你可能希望在许多地方明确允许它。

# 避免缺失的实现

我们可能希望许多类型实现一些特性。其中第一个是`Debug`特性。`Debug`特性可能应该由我们所有的类型实现，因为它使得开发者能够打印出关于我们的结构体、枚举等调试信息。此外，它还允许 API 用户通过仅添加一个属性，使用我们的 API 类型在结构体中推导出`Debug`特性。

我们可以通过添加`#![warn(missing_debug_implementations)]`来强制实现这个特性对所有我们的类型。唯一的细节是，这个特性将只检查 API 中暴露的类型。所以，它只适用于`pub`类型。

另一个有趣的特性是`Copy`特性。有时，我们会创建一个包含几个整数的简单结构体，在某些情况下最好是通过复制来实现，正如我们在前面的章节中看到的。问题是如果我们忘记实现它，我们可能会进行过多的引用，使我们的代码变慢。我们可以通过添加这个 lint 来解决：`#![warn(missing_copy_implementations)]`。

然而，这个 lint 有几个限制。它只适用于`pub`类型，就像`Debug`实现 lint 的情况一样，并且它会 lint 所有所有成员都是`Copy`类型的结构体。这意味着如果我们有一个非常大的结构体，我们不想复制它，我们可能需要为该特定结构体允许这个 lint。

# 强制文档

这可以说是最重要的 lint，遗憾的是它默认是`allow`。每当创建一个 API 时，我们必须记录 API 的功能。这将使新开发者更容易使用它。`#![warn(missing_docs)]` lint 将确保至少所有公共 API 都有一些文档。我个人通常在开发期间将其设置为警告，一旦项目进入生产阶段，就将其更改为`deny`甚至`forbid`。

# 指出平凡的转换

有时，我们可能会明确地将一个元素转换为编译器应该自动转换的类型。这通常发生在我们使用特质时，但也可能是因为我们将一个元素的类型更改为新类型，而没有更改转换。为了清理这类行为，我们有`trivial_casts`和`trivial_numeric_casts`代码审查。让我们用一个例子来看看：

```rs
#![warn(trivial_casts, trivial_numeric_casts)]

#[derive(Default, Debug)]
struct MyStruct {
    a: i32,
    b: i32,
}

fn main() {
    let test = MyStruct::default();
    println!("{:?}", (test as MyStruct).a as i32);
}
```

在这种情况下，我们首先将`test`转换为`MyStruct`，但它已经是`MyStruct`了，所以这是多余的，并且使代码的可读性大大降低，从而增加了出错的可能性。然后我们将它的`a`属性转换为`i32`，但它已经是`i32`了，所以再次是冗余信息。第一种情况不常见，但第二种情况如果我们将这个参数用于只接受`i32`的函数，并且我们的结构在之前的实现中包含`i16`，例如，可能会被发现。

在任何情况下，这类铸造都不是好的实践，因为我们可能已经将`a`属性从`i64`更改为`i32`，并且我们会在无声中丢失精度。我们应该使用`i32::from()`，这样如果我们将它更改为`i64`，它将简单地停止编译。这将在我们稍后看到的 Clippy 工具中自动进行代码审查。

无论如何，启用这两个代码审查是个好主意，因为它将帮助我们找到这类错误。`trivial_casts`代码审查会审查非数值类型/特质的转换，而`trivial_numeric_casts`将审查数值转换。

# 代码审查不可安全代码块

在某些情况下，特别是如果我们使用的是极低级别的编程，有时用于高性能计算，我们可能需要进行一些指针算术，甚至**单指令多数据**（**SIMD**）内联，这需要不可安全的作用域。这可能在某些特定的函数或代码片段中是这种情况，但一般来说，我们应该避免不可安全的作用域。

一个经验法则是这样的：如果你不是在处理性能关键代码，不要使用它们。如果你是，请非常小心地使用，并且只在没有其他改进性能的选项的地方使用。这意味着通常内联代码可以封装在一个模块或函数中。

为了确保没有人使用我们希望在显示范围之外使用的不可安全代码，我们可以使用`unsafe_code`代码审查来审查所有不可安全的作用域。让我们用一个例子来看看：

```rs
#![warn(unsafe_code)]

fn main() {
    let test = vec![1, 2, 3];
    println!("{}", unsafe { test.get_unchecked(2) });
}
```

如果你还记得第一章中的*常见性能陷阱*，切片中的`get_unchecked()`函数将获取给定索引处的元素，而不会检查切片的边界，这使得它运行得更快。这也意味着如果索引超出范围，你可能会从内存泄漏到段错误。

在这个例子中，当编译这段代码时，一个警告会告诉我们我们正在使用不可安全代码。如果它对于这个特定的函数是 100%必需的，我们可以允许它，或者我们可以更改代码。一个修复上述问题同时仍然使用不可安全代码的例子可以在这里看到：

```rs
#![deny(unsafe_code)]

fn main() {
    let test = vec![1, 2, 3];
    println!("{}", get_second(&test));
}

#[allow(unsafe_code)]
fn get_second(slice: &[i32]) -> i32 {
    *unsafe { slice.get_unchecked(1) }
}
```

在这个例子中，如果我们将不安全的范围添加到`get_second()`函数外部，crate 将无法编译。无论如何，这个函数是不安全的，因为它不会检查发送给它的切片的任何边界；我们可能应该在函数开始时添加一个`assert!()`，或者至少一个`debug_assert!()`，来检查切片的长度。

# 未使用的代码风格检查

诚实地讲，我们有时会忘记移除不再使用的依赖项，或者忘记`write()`方法返回写入的字节数。这通常不是什么大问题。第一个只会使我们的编译速度变慢，而第二个，在大多数情况下，将不会改变我们的代码。

但由于我们不希望有未使用的依赖项，或者我们不希望忘记我们可能没有将整个缓冲区写入文件，这就是下一个代码风格检查帮助我们的地方。让我们从第一个开始，即`unused_extern_crates`代码风格检查。这个代码风格检查将标记未在我们的代码中使用的外部 crate。这可以用来移除不再使用的依赖项，所以我通常在开始开发时将其配置为`warn`，一旦我的 crate 进入生产或依赖项在每次提交中都没有变化，就将其更改为`forbid`。

你应该了解的第二个代码风格检查是`unused_results`。默认情况下，编译器将警告`Result<T, E>`返回值中未使用的返回值。这是一个重要的细节，因为可能是一个 I/O 操作失败了，例如，你应该相应地采取行动。尽管如此，还有其他情况下 Rust 编译器不会警告，但这可能和之前的一样危险。例如，`Write`和`Read`特质分别返回写入和读取的字节数，你应该可能对此数字有所了解。

这个代码风格检查将确保你始终考虑任何返回值，除了空元组`()`。这有时可能有些烦人，但你可以通过使用下划线绑定显式地丢弃结果，如下所示：

```rs
#![warn(unused_results)]

fn main() {
    let _ = write_hello();
}

fn write_hello() -> usize {
    unimplemented!()
}
```

此外，还有一些代码风格检查可以使你的代码更加易于阅读：`unused_qualifications`和`unused_import_braces`。第一个将检测你为某些元素使用额外限定符的地方：

```rs
#![warn(unused_qualifications)]

#[derive(Debug)]
enum Test {
    A,
    B,
}

fn main() {
    use Test::*;

    println!("{:?}", Test::A);
    println!("{:?}", B);
}
```

以下代码示例将警告我们在第一个`println!()`中不需要使用`Test::`限定符，因为我们已经导入了`Test`枚举中的所有值。第二个`println!()`不会警告我们，因为我们没有指定任何额外的限定符。这将使代码更易于阅读，可能减少错误。

第二个代码风格检查，`unused_import_braces`，将检查我们只使用导入花括号导入一个元素的地方：

```rs
#![warn(unused_import_braces)]

#[derive(Debug)]
enum Test {
    A,
    B,
}

#[derive(Debug)]
enum Test2 {
    C,
    D,
}

fn main() {
    use Test::{A, B};
    use Test2::{C};

    println!("{:?}, {:?}, {:?}", A, B, C);
}
```

尽管 Rust 格式化器会自动移除 `Test2` 导入的 C 变体的括号，如果我们不使用格式化器，这是一个有趣的 lint，会提醒我们不需要这些括号，并且移除它们会使代码更简洁。

# 变体大小差异

正如我们在前面的章节中看到的，枚举的大小将是最大元素的大小加上标签，但是，正如我们讨论的，如果我们有很多小的变体，而其中一个变体的大小更大，这可能会很麻烦：所有变体都将占用最大变体的整个空间。我们看到一个选择是将大变体移动到堆分配。

我们可以使用 `variant_size_differences` lint 来检测具有明显大于其他变体的枚举。它将检查至少有三个倍数大于其他变体的枚举：

```rs
#![warn(variant_size_differences)]

enum Test {
    A(u8),
    B(u32),
}
```

注意，它不适用于联合，并且如果我们有中等大小的变体，即使最大变体和最小变体之间的差异超过三倍，lint 也不会提醒我们。

# Lint 组

Rust 编译器允许我们按组配置一些上述 lint。例如，`unused` 组将包含许多 `unused_` 类型的 lint。`warnings` 组将包含所有被配置为警告的 lint，等等。

Lint 组可以使用与 lint 相同的方式使用，通过指定当编译器捕获到该行为时你希望发生什么：

```rs
#[deny(warnings)]
```

你可以通过运行 `rustc -W help` 来查看其余的内置 lint。它将显示我们讨论过的 lint 以及默认情况下会警告或拒绝的其他 lint。

# Clippy

如果有一个工具能帮助你最大程度地清理你的代码，那就是 Clippy。在撰写本文时，Clippy 提供了 208 个额外的 lint，其中大多数都非常有用，可以避免一些有趣的陷阱，例如我们在第二章“额外的性能提升”中讨论的 `unwrap_or()` 使用，或者避免非惯用代码。当然，我们在这里不会看到所有这些，你可以在 Clippy lint 文档的[`rust-lang-nursery.github.io/rust-clippy/master/`](https://rust-lang-nursery.github.io/rust-clippy/master/)中找到它们的完整列表。

由于其中许多默认情况下会警告甚至拒绝，我们将检查一些默认允许但实际上可以极大地提高你的应用程序代码质量甚至性能的 lint。

# 安装

安装 Clippy 非常简单：你需要通过运行 `rustup toolchain install nightly` 来安装 Rust 夜间版本，然后你可以通过运行 `cargo +nightly install clippy` 来安装 Clippy。

注意，由于 Clippy 需要使用 nightly 编译器来构建，并且它使用编译器内建函数，一些 Rust nightly 编译器的更新可能会使其无法使用。这些问题通常在几天内得到修复，并且会发布一个新的 Clippy 版本，但在此期间，你可以通过向 nightly 工具链添加一个以前的日期来选择以前的 nightly 版本：`rustup toolchain install nightly-YYYY-MM-DD`。

一旦安装了正确的工具链，Clippy 将会完美安装。要使用它，你需要进入你的项目并运行 `cargo clippy` 命令，而不是通常的 `cargo check` 或 `cargo build` 命令。这将运行所有 Clippy 检查并显示结果。

# 配置

即使我们在下一节将检查单个检查，我们现在将看到如何配置整个 Clippy 执行。Clippy 将读取与 `Cargo.toml` 文件同一级别的 `clippy.toml` 文件并根据其内容执行。

一些检查具有配置参数。例如，循环复杂度检查会在函数有超过 25 个分支时提醒你。正如我们在 第一章 中看到的，*常见性能陷阱*，这是不好的做法，因为它会使编译器对代码的优化变得更加困难，从而产生性能较差的代码。

然而，你可以更改创建警告的阈值。25 个分支是一个合理的数量，但根据你的产品，你可能希望不超过 20 个分支，或者能够达到 30 个分支，例如。在 `clippy.toml` 中更改此行为的设置是 `cyclomatic-complexity-threshold`：

```rs
cyclomatic-complexity-threshold = 30
```

例如，当 Clippy 发现文档中缺少适当（`` ` ``）字符来显示它们是代码的结构或枚举名称时，它也会警告你。例如，如果你的软件被命名为 `MyCompanyInc`，Clippy 会认为它是一个 `struct` 或一个 `enum`。对于这种情况也有配置参数。你可以在 Clippy 维基页面上检查所有这些配置：[`rust-lang-nursery.github.io/rust-clippy/master/`](https://rust-lang-nursery.github.io/rust-clippy/master/)。

如果我们想在项目中添加 Clippy 检查，当我们不使用 Clippy 编译时，Rust 会警告我们那些检查是未知的。当然，这些是由 Clippy 定义的，但编译器并不知道这一点。Clippy 默认设置了一个 `cargo-clippy` 功能，当配置检查时，我们可以使用它来消除未知检查的警告：

```rs
#![cfg_attr(feature = "cargo-clippy", forbid(deprecated))]
```

这样，当我们运行 `cargo clippy` 时，检查将被考虑，但在运行 `cargo check` 时则不会。

# 检查

在 Clippy 目前可用的 208 个 lints 中，我们将仅分析那些默认配置为`allow`的一些。其余的可以在 Clippy wiki 上检查[`rust-lang-nursery.github.io/rust-clippy/master/`](https://rust-lang-nursery.github.io/rust-clippy/master/)，但你应该注意这些，因为它们默认不会显示警报。

# 投影

投影数字有时是一项危险的操作。我们可能会丢失精度，丢失符号，截断数字等等。Clippy 为我们提供了一些非常有用的 lints，可以避免这些情况。当然，通常你并不关心这些行为，因为你可能知道它们不会发生，或者它们可能是预期的行为。

尽管如此，我发现即使只激活一次以检查这些 cast 发生的地方并将它们设置为默认允许，这些 lints 也是有用的。

这些 lints 如下：

+   `cast_possible_truncation`

+   `cast_possible_wrap`

+   `cast_precision_loss`

+   `cast_sign_loss`

# 不良实践

Clippy 还提供了可以检测不良编码实践的 lints。例如，你不应该导入枚举变体，因为枚举变体应该始终以实际的枚举为前缀。为了对此实践进行 lint，你可以使用`enum_glob_use` lint。

可能会引发问题的其他代码实践是`From`和`Into`特质的恐慌实现。根据定义，这些特质永远不应该失败，使用`unwrap()`、`expect()`、`panic!()`或`assert!()`函数和宏可能会使函数恐慌。尽管这可能是应用程序中期望的行为，但这是一种不良实践（你应该使用`TryInto`和`TryFrom`特质，或者在稳定编译器开发时创建一个新函数）。

但主要问题是当开发可能导致整个操作系统恐慌的软件，如内核时。你可以通过使用`fallible_impl_from` lint 来检测这些问题。

我们在第一章，“常见性能陷阱”中讨论了迭代器，我们看到，我们有时有有用的函数来包装`filter()`和`map()`。这提高了可读性，并且可以使用`filter_map` lint 来检测这些函数的连接。

有时，我们编写的条件可能不容易理解，有时是因为我们在带有`else`分支的条件中使用否定，或者是因为我们添加了太多的条件，这会搞乱我们的比较。我们有两个 Clippy lint 会指出这些情况：`if_not_else`和`nonminimal_bool`。

第一个将检测条件中的否定，并建议将条件改为正条件，并更改`else`和`if`代码部分。第二个将检查可以简化以去除冗余并清理代码的布尔值。

当只有两个分支且其中一个不需要任何参数时，例如处理`Option`类型时，一些`match`语句也可以得到改进。在这种情况下，将它们改为带有`else`的`if let`表达式会更简洁，这也会减少比较的缩进。这些失败点可以通过使用`single_match_else` lint 来显示。

另外两个有趣的 lint 会检查你可能只是为了使比较或范围包含而向整数添加`1`的地方。让我们看看一个例子：

```rs
    let max = 10;
    for i in 0..max + 1 {
        println!("{}", i);
    }
```

那段代码只加`1`是为了能够打印出`10`。你可以通过在两个范围符号之后使用等号（`..=`）来创建 nightly Rust 的包含范围：

```rs
#![feature(inclusive_range_syntax)]

fn main() {
    let max = 10;
    for i in 0..=max {
        println!("{}", i);
    }
}
```

指出这种错误的 lint 叫做`range_plus_one`，而用于检测诸如`a < b+1`这样的比较，这些比较可以用`a <= b`来替换的 lint 叫做`int_plus_one`。

也有时候，我们可能会更改变量的名称或拼错它，从而破坏我们的代码，即使它看起来可以编译。其他时候，我们可能会创建名称过于相似的变量，最终将它们混淆。这可以通过使用`similar_names` lint 来避免。

另一个坏习惯是将枚举的名称包含在枚举的变体中，或者包含当前模块名称的结构中。由于名称可以有资格，因此不需要重复，这会增加很多文本。这默认会发出警告，但在公共 API 中不会。你可以通过`stutter`和`pub_enum_variant_names` lint 来控制这一点。

最后，就像 Rust 编译器给了我们一个`missing_docs` lint 来指出缺失的公共文档一样，`missing_docs_in_private_items` Clippy lint 也会对私有项做同样的事情。这对于强制整个代码库的文档化来说是非常好的。

# 性能 lint

如果你正在阅读这本书，这两条 lint 可能比 Clippy 默认不警告的 lint 更重要。第一条相当简单：如果你想在多个线程之间共享一个整数，而你不需要将其用作同步变量时，使用`Mutex`是一个非常糟糕的主意。

通常，使用原子类型的事物，如计数器，会快得多。在撰写本文时，只有指针大小的原子和布尔值是稳定的，但其余的也在路上，现在可以在 nightly Rust 中使用。你可以通过`mutex_integer` lint 来发现这个问题。

此外，你可能会被诱惑使用`std::mem::forget()`来启用向 C API 发送数据，或者能够做一些奇怪的内存技巧。这可能是可以的（尽管它可能导致内存泄漏），但有时会阻止运行析构函数。如果你想确保你的`Drop`类型永远不会被遗忘，请使用`mem_forget` lint。

如果你担心无限迭代器可能会挂起你的应用程序，你应该使用 `maybe_infinite_iter` 检查项，它会找到这些迭代器。它不会检测停止条件，因此可能会显示过多的误报。

在开发过程中，我们可能会使用 `print!()` 宏和调试格式添加调试信息。一旦应用程序进入生产环境，避免这些日志留在代码库中的好方法就是使用 `print_stdout` 和 `use_debug` 检查。

# 解包

Rust 允许你解包 `Result`s 和 `Option`s，但代价是如果它们分别是 `Err(_)` 或 `None`，则会引发恐慌。在任何生产代码中都应该避免这样做，可以使用 `expect()` 添加信息消息，或者使用带有 `?` 操作符的错误链，例如。你也可以对它们进行匹配并控制错误。

为了避免这些不必要的恐慌，你可以使用 `result_unwrap_used`、`option_unwrap_used`、`option_map_unwrap_or_else`、`option_map_unwrap_or` 和 `result_map_unwrap_or_else` 检查项。

# 覆盖

在 Rust 中，你可以通过创建另一个具有相同名称的 `let` 绑定来覆盖一个变量。这通常是可以接受的，除非我们可能只想修改一个变量，例如。一般来说，你应该避免这种做法，只在有助于可读性的情况下使用它。

你可以使用 `shadow_unrelated`、`shadow_same` 和 `shadow_reuse` 检查项，并默认警告这种行为，然后在特定情况下允许它。

# 整数溢出

有时，当我们对整数进行操作时，我们没有考虑到溢出、下溢和覆盖。C 语言默认允许这样做，而 Rust 在调试模式下运行时会引发恐慌。然而，在发布模式下，这些整数溢出可能成为一个大问题。

你可以使用 `integer_arithmetic` 检查项，它会建议使用 `wrapping_...()` 或 `saturating_...()` 方法之一，以确保你知道操作的结果。

# 检查项组

Clippy 中有两个检查项组。`clippy` 检查项组将控制默认警告的所有检查项，例如，你可以拒绝所有这些检查项。`clippy_pedantic` 组将作为一个组控制其余的检查项，但将所有这些检查项设置为警告，例如，会导致你的编译结果充满警告，因为存在误报。

要使用它们，你只需将一组检查作为检查项使用：

```rs
#![deny(clippy)]
```

你可以在 Clippy 的维基百科中查看其余的检查项和配置选项：[`rust-lang-nursery.github.io/rust-clippy/master/`](https://rust-lang-nursery.github.io/rust-clippy/master/)。

# 摘要

在本章中，你学习了如何配置 Rust 和 Clippy 工具提供的不同检查项。通过它们，你可以获得更多具体粒度的警告选项，这些选项会影响性能和代码质量。

我们涵盖了默认情况下您看不到的代码检查，这使得您的探索之旅变得更加容易。在第五章，*分析您的 Rust 应用程序*，我们将了解其他工具；在这种情况下，用于分析您的应用程序并找到那些不太容易直接看到的性能瓶颈。
