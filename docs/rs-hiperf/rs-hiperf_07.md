# 内置宏和配置项

现在我们知道了如何提高我们的代码效率，我们可以学习如何使它在多个平台上工作，并确保我们充分利用所有可能的本地优化，同时使代码更快、更容易实现。元编程允许我们通过非常简单的代码片段来完成所有这些，你可能已经了解其中的一些特性。

在本章中，您将学习如何使用以下宏和编译器以及标准库内置的配置项：

+   属性

+   Crate 功能

+   宏

+   Nightly 功能

# 理解属性

Rust 允许我们根据我们调用的属性有条件地编译代码的某些部分。这些属性可以应用于完整的 crate/module，也可以应用于特定的函数、作用域，甚至是结构字段或枚举变体。我们在讨论 Clippy 时看到了一些例子，但这些属性允许我们做更多的事情，我们现在将深入探讨它们。

让我们先看看属性是如何工作的。要应用于整个当前模块/crate 的属性将写成这样：`#![{attribute}]`。应用于紧邻的作用域/函数/字段/变体的属性将写成这样：`#[{attribute}]`。请注意，第一个在井号和属性之间有一个`!`符号。

你可能已经在某些代码中看到过如`#[macro_use]`或`#[derive(Debug)]`之类的属性。第一个将允许使用外部 crate 中的宏，而第二个将推导给定结构或枚举中的`Debug`特性。让我们先检查一下我们可以通过特性推导避免输入什么。

# 特性推导

特性推导有两种类型：内置推导和自定义推导。我们将在第九章“创建您的宏”中讨论第二种，但现在让我们看看推导能帮助我们实现什么。让我们想象以下结构：

```rs
struct MyData {
    field1: String,
    field2: u64,
}
```

建议每个结构实现`Debug`特性，这样，例如，如果我们需要调试代码中某个部分的运行情况，我们可以使用`println!("{:?}", element);`语法。它应该显示字段的值，因此我们可以想象以下内容：

```rs
use std::fmt;

impl fmt::Debug for MyData {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MyData {{ field1: \"{}\", field2: {} }}",
            self.field1, self.field2
        )
    }
}
```

这将打印字段信息。例如，假设我们有以下代码：

```rs
fn main() {
    let data = MyData {
        field1: "This is my string".to_owned(),
        field2: 4402,
    };

    println!("Data: {:?}", data);
}
```

我们将收到以下输出：

```rs
Data: MyData { field1: "This is my string", field2: 4402 } 
```

这很好，因为它使我们能够获取有关我们结构的信息，但它难以维护，并且给我们的代码库添加了大量样板代码。假设我们有一个 20 个字段的结构，我们需要删除 2 个字段，并添加 4 个新字段。这迅速演变成一个混乱的局面。我们需要修改特性实现，可能改变字段的顺序，等等。

这就是`#[derive]`属性发挥作用的地方：它会为我们编写代码，并且如果我们的结构发生变化，它将重新编写代码。而且，更好的是，它不会污染我们的代码库，因为这段代码将在编译时编写。整个`Debug`特性实现可以通过在结构的开始处添加`#[derive(Debug)]`来替换：

```rs
#[derive(Debug)]
struct MyData {
    field1: String,
    field2: u64,
}
```

如果我们再次运行程序，我们会看到没有任何变化。可以派生出多个特性：比较特性（`PartialEq`、`Eq`、`PartialOrd`和`Ord`）、`Copy`、`Clone`、`Hash`、`Default`以及我们看到的`Debug`。让我们看看这些特性各自的作用。我们已经讨论了`Debug`特性，所以让我们从比较特性开始。

前两个可派生的特性是`PartialEq`和`Eq`。两者都使得可以使用`==`和`!=`运算符与结构一起使用，但它们是如何工作的呢？

`PartialEq`旨在描述部分等价关系，这意味着如果*A*部分等于*B*，*B*部分等于*A*，并且如果在这个例子中*B*部分等于*C*，*A*也部分等于*C*，因为这种性质是对称的和传递的。

当为结构或枚举派生时，它只有在结构或枚举的所有成员已经实现了`PartialEq`时才可用，并且如果所有字段都相等，它将考虑两个结构或枚举相等。

`Eq`特性需要额外的条件，并且不能在编译时检查。它要求*A*等于*A*。如果我们谈论具有简单字段的结构，这可能会听起来很奇怪，但在标准库中有一个简单的类型显示了相反的行为。浮点类型（`f32`和`f64`）在它们是**NaN**（**不是一个数字**）时不尊重这一点。两个`NaN`不相等，即使它们都是`NaN`。

要派生`Eq`特性，结构或枚举中的所有字段都必须实现`Eq`。这意味着你将无法为包含浮点数的任何结构或枚举实现`Eq`。这个特性不需要任何方法实现，它只是告诉编译器结构或枚举总是等于自身，而不需要任何额外的代码。

接下来的两个特性`PartialOrd`和`Ord`与`PartialEq`和`Eq`的工作方式类似，但它们增加了比较两个元素以了解它们顺序的能力，因此允许你使用`<`、`<=`、`=>`和`>`运算符与结构或枚举一起使用。两者都需要满足如果*A < B*且*B < C*，则*A < C*（对于`==`和`>`也是如此），并且如果*A > B*，则*A < B*是错误的。`Ord`特性还要求只有一个*A < B*、*A == B*或*A > B*是正确的。

作为额外信息点，`PartialOrd` 特性添加了一个 `partial_cmp()` 函数，而 `Ord` 特性添加了 `cmp()` 函数。两者都返回一个 `Ordering`，但对于第一个函数，它是可选的（`Option<Ordering>`），而对于第二个函数，则是强制的。这是因为部分比较可能对于某个特定值没有定义的顺序；记住浮点数的 `NaN` 情况。

对于只包含 `PartialOrd` 或 `Ord` 字段的结构的函数实现相当简单：定义哪个字段对于排序是最相关的，然后在结构之间比较它们，然后，如果相等，比较下一个相关字段。这可以通过使用 `#[derive(PartialOrd)]` 或 `#[derive(PartialOrd, Ord)]` 来避免。

派生将按从第一个到最后一个的顺序比较字段，所以请确保您将最相关的字段放在前面。在枚举的情况下，它将考虑第一个变体比最新变体*小*。如果您想改变这一点，您可以通过更改字段的顺序或变体，或者自己实现特性来实现。您可能还只想比较结构的一个字段，并认为其余字段无关紧要。在这种情况下，您将需要自己实现特性。

要实现任何这些特性，您只需逐个比较字段。请注意，`Ord` 需要 `Eq`，因此我们需要实现 `PartialEq` 来检查日期、月份和年份，然后派生 `Eq`。您可以按照以下方式检查实现的细节：

```rs
use std::cmp::Ordering;

#[derive(Eq)]
struct DateNotes {
    day: u8,
    month: u8,
    year: i32,
    comment: String,
}

impl PartialEq for DateNotes {
    fn eq(&self, other: &Self) -> bool {
        self.day == other.day && self.month == other.month && self.year == other.year
    }
}

impl Ord for DateNotes {
    fn cmp(&self, other: &Self) -> Ordering {
        match self.year.cmp(&other.year) {
            Ordering::Equal => match self.month.cmp(&other.month) {
                Ordering::Equal => self.day.cmp(&other.day),
                o => o,
            },
            o => o,
        }
    }
}

impl PartialOrd for DateNotes {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}
```

在这个例子中，我们首先检查年份来比较日期。如果年份相同，我们比较月份，如果月份相等，我们比较日期。我们不需要检查与日期关联的评论，因为我们不需要。`PartialOrd` 特性的实现只返回 `Ord` 特性包裹在 `Option::Some` 中的结果。

接下来的两个特性，`Copy` 和 `Clone`，允许在内存中复制结构。这意味着您将能够逐个复制实例的所有内容到另一个实例。`Clone` 特性通过添加 `clone()` 方法来实现这一点，通常它只调用每个字段的 `clone()` 方法。但它可以运行任何任意的代码，您永远不知道复制对象是否会昂贵。这就是为什么使用它需要显式调用 `clone()` 方法的原因。

另一方面，`Copy` 特性使得复制一个元素是隐式的。这意味着，例如，当将变量移动到函数中时，如果它是 `Copy` 变量，您在移动后仍然可以使用它，因为只有它的副本会被移动。我们在第一章，*常见性能陷阱*中看到了这种方法的一些优点和缺点。

然而，你不能为具有复杂不可复制类型的结构实现`Copy`特质，因为 Rust 要求它必须非常便宜，并且它使用编译器内建函数实现。所以，你可以安全地使用`Copy`类型，知道复制它不会很昂贵，但你不能自己实现它。你可以推导它。为结构或枚举推导`Copy`需要该结构或枚举实现`Clone`（如果所有内部元素都实现了`Clone`，你也可以推导它）以及所有内部元素都实现`Copy`。

因此，你可以为以下基本类型结构的结构推导出`Copy`：

```rs
#[derive(Clone, Copy)]
struct MyData {
    field1: u64,
    field2: f64,
    field3: i32,
}
```

但是，你不能为具有复杂不可复制类型的结构推导它：

```rs
#[derive(Clone)]
struct MyData {
    field1: String,
    field2: Vec<u32>,
    field3: i32,
}
```

尽管如此，在大多数情况下，你可以推导出`Clone`，因为大多数标准库类型都实现了它。但请记住，`clone()`方法通常成本较高，不应过度使用。实际上，通常认为如果你直接使用`clone()`方法，你可能在做错事，而且在大多数情况下，其他方法，如`to_owned()`或`into()`，会更有效地完成任务。

`to_owned()`将获取变量的所有者版本，在切片和字符串中这意味着只进行`memcpy()`堆操作。另一方面，`into()`方法将使用专门的转换实现，以便产生最佳输出代码。这两个方法都会改变变量的类型。最后，`clone()`通常是通用的，这意味着它将为每个成员属性调用`clone()`，有时会使其变慢。

现在我们来谈谈`Hash`特质。这个特质允许将给定的结构或枚举用作哈希结构（如`HashMap`）中的键。它使我们能够使用`Hasher`对结构进行哈希处理，以获取包含的信息的哈希值。`Hasher`是一个特质，它接收输入，如字节或数字，一旦你在它上面调用`finish()`，它将返回一个包含哈希值的`u64`。

由于`Hasher`是一个特质，特质本身不提供实现细节，但正如我们在第二章“额外性能增强”中看到的，标准库中提供了一些默认实现：`SipHasher`、`SipHasher13`、`SipHasher24`和`DefaultHasher`。我们已经看到了它们之间的一些区别。

`Hash`特质背后的主要思想是它允许对任何结构进行哈希处理，而不限制`HashMap`键必须是字节或数字。你可以为你自己的结构实现这个特质（如果你想要微调哈希过程），但如果你的目的是能够简单地将你的结构或枚举用作`HashMap`中的键，你只需推导出`Hash`特质，编译器就会为你编写代码。

不仅如此，您可能还希望实现它的 `Eq` 特性，因为对于 `HashMap` 键来说，这是必需的。如果您自己实现它，您需要确保如果 *A = B*，则 *hash(A) = hash(B)*，这可能不是显而易见的。最好的办法是简单地推导两者。让我们用我们之前定义的结构来检查这个示例代码：

```rs
use std::collections::HashMap;

#[derive(Clone, Hash, PartialEq, Eq)]
struct MyData {
    field1: String,
    field2: Vec<u32>,
    field3: i32,
}

fn main() {
    let key1 = MyData {
        field1: "myField".to_owned(),
        field2: vec![0, 1, 2],
        field3: 1898,
    };

    let key2 = key1.clone();

    let key3 = MyData {
        field1: "myField2".to_owned(),
        field2: vec![5, 3, 1],
        field3: 2345,
    };

    let mut map = HashMap::new();
    map.insert(key1, "MyFirst");

    assert!(map.get(&key2).is_some());
    assert!(map.get(&key3).is_none());
}
```

在这里，我们首先在 `MyData` 结构中推导 `Hash`、`PartialEq` 和 `Eq`，然后创建两个相同的键和一个不同的键。我使用了 `clone` 以便于理解，但使用具有相同值的另一个键也会起作用。我们使用第一个键向映射中添加一个值，并检查是否可以无问题地使用键的副本检索元素。然而，如果我们尝试使用不同的键，我们就无法获取值。您还可以检查，如果 `MyData` 结构没有实现 `Eq` 或 `Hash`，您将无法将其用作 `HashMap` 的键。

与之前一样，一个结构要推导 `Hash` 的唯一要求是它的所有成员已经实现了它，而大多数标准库类型都实现了 `Hash`。默认实现将简单地使用给定的 `Hasher` 逐个哈希所有属性，这可能是您手动实现的内容。这种实现的例子可能如下所示：

```rs
use std::hash::{Hash, Hasher};

impl Hash for MyData {
    fn hash<H>(&self, state: &mut H)
    where
        H: Hasher,
    {
        self.field1.hash(state);
        self.field2.hash(state);
        self.field3.hash(state);
    }
}
```

如您所见，这是一段简单的代码，但如果您自己推导它，可以使代码更加整洁且易于维护。尽管如此，自己实现它可以帮助您处理那些没有实现 `Hash` 的字段，或者使用自定义哈希技术，或者在比较结构时忽略某些字段以获得更好的性能（如果忽略这些字段结构比较仍然有效的话）。

最后，Rust 可以直接推导的最后一个特性是 `Default` 特性。这个特性为结构或枚举提供了一个 `default()` 方法，该方法将创建具有默认值的结构。这些默认值是，例如，数字的 `0`，字符串的空字符串，向量的空向量等等。它通常用作未来计算的占位符。

如果您有一个希望具有默认值的结构，您可以实现 `Default` 特性。而且，这样做可能只需要为每个属性提供一个值。如果您不需要特定的默认值（所有零对您来说都很好），您可能更愿意简单地推导 `Default` 特性。让我们用 `MyData` 结构来检查一个示例：

```rs
#[derive(Debug, Default)]
struct MyData {
    field1: String,
    field2: Vec<u32>,
    field3: i32,
}

fn main() {
    let test1 = MyData {
        field1: "sth".to_owned(),
        ..Default::default()
    };
    let test2 = MyData::default();

    println!("test1: {:?}", test1);
    println!("test2: {:?}", test2);
}
```

如您所见，我推导了 `Default` 特性（以及 `Debug` 特性，仅用于打印结构）。这允许您通过仅调用 `MyData::default()` 来创建 `test2` 变量。如果您为变量提供了类型提示，也可以调用 `Default::default()`。

```rs
let test3: MyData = Default::default();
```

如您所见，如果结构体的一些字段实现了 `Default`，您可以使用该特性来完成您不想指定的字段，就像您在 `test1` 变量中看到的那样。只需指定非默认字段，然后在最后一个逗号之后添加几个点（`..`），然后是 `Default::default()`，这样编译器就会使用 `Default` 特性来填充其他字段。您可以使用任何对其他字段通用的函数，并使用此语法。

如您所见，`Default` 特性是一个非常实用的特性，如果您不需要对结构体的任何字段进行特殊处理以设置默认值，那么使用它是一个很好的主意。您可能会避免以下潜在实现：

```rs
impl Default for MyData {
    fn default() -> Self {
        Self {
            field1: Default::default(),
            field2: Default::default(),
            field3: Default::default(),
        }
    }
}
```

如您所见，使用它可以使您的工作变得容易得多。尽管如此，您可以使用此实现来自定义结构体默认实例的任何字段，如果，例如，您希望所有结构体默认将字符串字段设置为 `"This is my data"`，这可能是一个好主意。如果您自己实现它，还可以在您的任何字段没有实现 `Default` 的情况下自定义它，这在使用标准库类型时很少见。

# 铁盒功能

第二个、非常有趣的属性用途是启用铁盒功能。这些功能可能封装了一些某些使用铁盒的人不需要的功能，因此使编译成为可选操作。Rust 编译器将在编译过程中删除任何未使用的代码，但如果没有从开始就编译某些代码部分，这将加快处理速度。

您可以通过在 `Cargo.toml` 文件中使用 `[features]` 部分，来定义铁盒功能。您可以指定一些默认功能，如果未指定任何内容，这些功能将被构建：

```rs
[features]
default = ["add"]
add = []
multiply = ["expensive_dependency"]
```

在此示例中，定义了两个功能，即 `add` 功能和 `multiply` 功能。`add` 功能没有额外的依赖项，但 `multiply` 功能依赖于 `expensive_dependency` 铁盒。默认情况下，仅构建 `add` 功能。如果这是一个二进制铁盒，您可以使用 `cargo` 的 `--features` 命令行选项来指定要构建的功能：

```rs
cargo build --features "multiply"
```

如果您想禁用默认功能，只需使用 `--no-default-features` 命令行选项运行即可。如果您想将具有功能的铁盒作为项目依赖项，您可以在 `Cargo.toml` 文件中声明依赖项时指定要包含哪些功能：

```rs
[dependencies.my_dep]
version = "1.0"
default-features = false
features = ["nice_feat"]
```

`[section.subsection]` 语法仅用于我们不需要在 `dependencies` 部分添加内联对象。在这种情况下，它禁用了默认功能并请求了 `nice_feat` 功能。

但是，这在代码中看起来如何呢？让我们看看。如果我们有一个 `add` 功能，就像我们之前看到的那样，我们可能添加一个属性来仅为此情况启用一个函数或模块：

```rs
#[cfg(feature = "add")]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

這將只在請求 `add` 特性時編譯。我們在使用 `cargo clippy` 時已經看到過類似的語法，因為它會從我們的包中請求 `cargo-clippy` 特性，使我們能夠挑選 lints。

# 配置屬性

最終類型的屬性是 `#[cfg]` 屬性。這些屬性非常強大，使我們能夠根據我們要編譯到的目標編譯代碼的某些部分。例如，我們可能想使用特定的 Windows 函數，並為其他部分提供一個備用版本，或者我們可能希望代碼在小端和大端機器上執行不同的操作。

語法相對簡單。例如，如果你想檢查系統架構，你可以使用 `#[cfg(target_arch = "arm")]`，而不是 ARM，你也可以檢查 `"x86"`、`"x86_64"`、`"mips"`、`"powerpc"`、`"powerpc64"` 或 `"aarch64"`。要僅為 FreeBSD 編譯某個東西，我們可以使用 `#[cfg(target_os = "freebsd")]`。你可以比較 `target_os` 配置屬性與 `"windows"`、`"macos"`、`"ios"`、`"linux"`、`"android"`、`"freebsd"`、`"dragonfly"`、`"bitrig"`、`"openbsd"` 或 `"netbsd"`。

如果你只關心 Windows/Unix 的差異，你可以使用 `#[cfg(target_family = "windows")]` 或 `#[cfg(target_family = "unix")]`，或者甚至直接使用 `#[windows]` 和 `#[unix]`。這可以通過使用 `#[cfg(target_env = "gnu")]`、`"msvc"` 或 `"musl"` 進一步指定。你可以使用 `#[cfg(target_endian = "little")]` 或 `#[cfg(target_endian = "big")]` 檢查系統的端序，並使用 `#[cfg(target_pointer_width = "32")]` 或 `#[cfg(target_pointer_width = "64")]` 依次檢查指針寬度（32 或 64 位）。

也可以檢查更複雜的細節，例如目標是否具有原子整數類型，以及這些原子整數的大小。例如，要檢查目標平台是否具有原子 8 位整數，你將使用 `#[cfg(target_has_atomic = "8")]`。你可以檢查 `8`、`16`、`32`、`64` 和指針寬度整數（使用 `"ptr"`）。你甚至可以通過檢查 `#[cfg(target_vendor = "apple")]` 檢查目標架構的供應商。你可以檢查 `"apple"`、`"pc"` 或 `"unknown"`。

最後，有幾個屬性可以告訴你你是否正在進行測試（使用 `#[test]`）以及是否已啟用调试斷言（使用 `#[debug_assertions]`）。第一個可能在你只想為測試更改特定行為時有用（不推薦；測試應該運行與生產環境相同的代碼），而第二個則允許你在應用程序以调试模式編譯時添加一些调试信息。

你可以通过使用 `#[cfg_attr(a, b)]` 选择性地设置/使用配置项。这将产生与 `#[b]` 相同的效果，但只有在 `a` 为真时才会执行某些操作。如果它是假的，就像什么都没写一样。这在例如你想根据其他属性启用或禁用 lint，或者你想只为某些目标派生 trait 并为其余部分实现它时很有用。

你也可以通过使用 `cfg!()` 宏在逻辑代码内部检查这些配置属性。只需使用与属性相同的语法：

```rs
if cfg!(target_pointer_width = "32") {
    do_something();
}
```

# 宏

Rust 最有用的功能之一是其宏生态系统。你可能已经知道 `println!()` 宏，但还有更多。这些宏允许你以简单的方式编写复杂的样板代码（例如 `println!()` 中的 `stdio` 处理），而不必添加大量的样板代码。让我们来看看最常用的几个。

# 控制台打印

当你需要锁定标准 I/O 接口，然后写入字节到它，最后在每个调用中刷新它时，`print!()` 和 `println!()` 宏允许你通过只向它们提供一个格式化的静态字符串和一系列参数来实现这一点。不仅如此，你还可以使用整个 `std::fmt` 模块来指定数字精度，以调试模式格式化事物，等等。

对于标准错误输出接口或 `stderr`，也存在类似的宏。它们被称为 `eprint!()` 和 `eprintln!()`，允许你以与 `print!()` 和 `println!()` 相同的格式轻松地在 `stderr` 中打印。这四个宏使用来自 `format!()` 宏的语法，我们将在下一节中看到。

# 字符串格式化

创建字符串很简单：你只需调用 `String::new()`，然后使用静态字符串或向其中添加字符。有时，你可能想要更容易地访问字符串的创建方式。例如，如果你想字符串显示为 `Hello {user}!`，即使你可能会创建一个包含 `Hello` 的 `String`，然后追加用户名和感叹号，这并不理想。

这就是 `std::fmt` 模块及其 `format!()` 宏和所有格式化选项派上用场的地方。这些选项适用于控制台打印、字符串格式化，甚至使用 `write!()` 和 `writeln!()` 宏进行缓冲区写入。你可以在标准库文档中找到完整的指南，通过运行 `rustup doc --open` 来查看 `std::fmt` 模块的文档。

# 编译环境

你可以通过使用 `env!("VAR")` 和 `option_env!("VAR")` 宏在编译时检查环境变量。第一个将检索环境变量作为 `&'static str`。如果变量未定义，编译将失败。`option_env!()` 宏通过在环境变量未设置时返回 `Option::None`，在变量设置时返回 `Option::Some(&'static str)` 来避免这种情况：

```rs
const THE_KEY: &str = env!("KEY");
```

# 在编译时加载字节数组和字符串

你可以在编译时加载各种类型的常量。`include_bytes!()` 宏将创建一个包含指定文件内容的字节数组（`u8`）。另一方面，`include_str!()` 宏将获取文件内容作为字符串并创建一个 `&static str`。两者都会在编译时如果文件不存在而使编译失败。

你还可以使用 `include!()` 宏，该宏将在编译时将指定文件的代码包含到当前文件中。如果该文件中的代码不是有效的 Rust 代码，编译将失败：

```rs
const CRATE_CONFIG: &str = include_str!("../Cargo.toml");
```

# 代码路径

有些路径永远不应该被遍历，在我们的代码中，这通常是代码正常工作的条件。如果我们收到不良的输入数据，我们可能希望返回一个错误，但如果我们的库被误用，我们可能更愿意引发 panic。有时，我们还想确保变量在到达函数的逻辑时不可能超出某些界限，以避免安全漏洞，例如。在这些情况下，可以使用 `unreachable!()` 宏，甚至显式的 `panic!()` 宏来帮助我们。

还有一条可能尚未准备好遍历的路径。当我们的 crate 正在实现时，我们可以使用之前在某些示例中看到的 `unimplemented!()` 宏，来指示我们正在编写的代码尚未实现。这将使代码能够编译，但如果执行，它将带有 *尚未实现* 消息的 panic。

# 检查先决条件和后置条件

在测试时，甚至在我们的日常代码中，我们可能希望我们的函数有一些先决条件，或者我们可能想检查一些后置条件。我们使用断言来做这件事。它们有两种变体，调试断言和正常断言。

正常断言总是会进行检查，但它们会减慢你的生产代码，因为它们需要每次运行。调试断言只有在调试模式下编译时才会运行，因此你可以在那时捕获错误，而生产代码将不会出现性能问题。

通常，你应该尽可能使用所有调试断言，只在从用户或其他 crate（如果构建库）接收输出时使用正常断言。

三个宏分别是 `assert!()`、`assert_eq!()` 和 `assert_ne!()`，它们的调试版本分别是 `debug_assert!()`、`debug_assert_eq!()` 和 `debug_assert_ne!()`。第一个宏接受一个返回布尔值的表达式作为第一个参数，可选的第二个参数可以包含一个消息，当第一个参数为假时，这个消息将在 panic 时被打印出来。

另外两个宏接受两个参数，它们之间将进行比较，还有一个可选的注释字符串。如果两个元素不同，`assert_eq!()` 宏将引发 panic，而如果它们相等，`assert_ne!()` 将引发 panic。

# 其他

还有更多宏。我们已经使用了一些，例如`cfg!()`和`vec![]`宏。您还可以使用`compile_error!("message")`宏来引发显式的编译错误，或者使用`file!()`、`line!()`和`column!()`宏来获取当前代码的位置，甚至可以使用`module_path!()`宏来获取当前模块。

如果您想了解更多信息，可以通过运行`rustup doc --open`来打开标准库文档，并查看那里的其他宏。

# 夜间 Rust

在某些情况下，夜间 Rust 甚至可以进一步加快您的代码。如果您不需要与稳定版 Rust 兼容，您可能想检查所有夜间功能。在某些情况下，例如内核开发，使用稳定版 Rust 无法获得所有所需的功能。您可以通过覆盖默认编译器来使用夜间 Rust：

```rs
rustup override add nightly
```

或者，您可以使用带有`+nightly`标志的 cargo。这些方法只有在您使用`rustup`管理您的 Rust 安装时才会生效，如果您有这个选项，那么您可能应该这样做。

要使用夜间功能，您需要在 crate 级别使用`#![feature]`属性。例如，如果您想使用`conservative_impl_trait`功能，您需要将`#![feature(conservative_impl_trait)]`添加到您的`main.rs`或`lib.rs`文件的开始部分。

让我们看看一些最有趣的不稳定功能。请注意，这些功能可能会迅速变化，并且它们在您阅读这本书的时候可能已经发生了变化。始终检查最新的 Rust 不稳定功能列表（[`doc.rust-lang.org/unstable-book/the-unstable-book.html`](https://doc.rust-lang.org/unstable-book/the-unstable-book.html)）以获取最新信息。这里有数十个功能，在这个章节中不可能检查所有这些功能，但在这里您可以找到最相关的一些功能的解释，以便您了解它们能为您做什么，以及您如何使用它们来提高您应用程序的性能。

# 保守特型返回

这个功能使您能够直接从函数中返回一个特型。这意味着在稳定版 Rust 中，如果您想返回一个实现了特型的类型而不指定类型，您需要编写以下内容：

```rs
fn iterate_something() -> Box<Iterator<Item = u32>> {
    unimplemented!()
}
```

这意味着在返回迭代器之前，您需要将所有相关信息移动到堆上（这很容易完成，但使用`Box::new()`会非常昂贵），然后返回它。这不应该必要，因为 Rust 应该在编译时知道您返回的类型，并相应地分配栈，然后只允许您使用特型，因为这是您事先指定的。

好吧，这已经在夜间 Rust 中实现了，但您需要使用`conservative_impl_trait`功能：

```rs
#![feature(conservative_impl_trait)]

fn iterate_something() -> impl Iterator<Item = u32> {
    (0..3).into_iter()
}
```

这允许 Rust 直接使用栈，这将避免昂贵的分配，并使您的代码运行更快。

# 常量函数

`const_fn` 功能允许您将一些函数声明为常量，这样它们就可以在编译时接收常量参数并在那时执行，而不是在运行时执行。这对于构造函数或需要尽快创建对象的常量特别有用。

对于最后一个选项，我们有 `lazy_static!{}` 宏，正如我们将在下一章中看到的，但这个宏在其首次使用时运行所有代码，而不是在编译时。在编译时这样做会使编译时间稍微长一些，但在运行时，它不需要计算任何东西，因为所有东西都已经是一个常量。尽管如此，似乎并不是所有的 `lazy_static!{}` 情况都可以用 `const_fn` 解决。

让我们看看它是什么样子：

```rs
#![feature(const_fn)]

const FIRST_CONST: MyData = MyData::new(23, 275);
const SECOND_CONST: MyData = MyData::new(336, 7);

#[derive(Debug)]
struct MyData {
    field1: u32,
    field2: f32,
}

impl MyData {
    pub const fn new(a: u32, b: u32) -> MyData {
        MyData {
            field1: a / b,
            field2: b as f32 / a as f32,
        }
    }
}

fn main() {
    println!("FIRST_CONST: {:?}", FIRST_CONST);
    println!("SECOND_CONST: {:?}", SECOND_CONST);

    let third = MyData::new(78, 22);
    println!("third: {:?}", third);
}
```

在这种情况下，正如您所看到的，我们创建了两个使用 `MyData::new()` 方法创建的常量。然后在运行时的 `main()` 函数中使用了相同的方法。在常量函数中可以做的事情非常有限。例如，您不能创建绑定，如果您调用另一个函数或宏，它也必须是常量。但您仍然可以执行一些复杂的操作，这些操作不会影响应用程序的性能。正如您所想象的，这是这段代码的输出：

```rs
FIRST_CONST: MyData { field1: 0, field2: 11.956522 }
SECOND_CONST: MyData { field1: 48, field2: 0.020833334 }
third: MyData { field1: 3, field2: 0.2820513 }
```

# 内联汇编和裸函数

这可能是 Rust 中最有趣的夜间功能之一。使用 `#[feature(asm)]`，我们将获得一个新的宏 `asm!()`，我们将在代码中使用它。使用这个宏，如果我们需要进一步的性能优化，我们可以在代码中编写内联汇编以执行细粒度操作。

正确的语法仍在开发中，但它已经允许您在函数中编写任意汇编代码。这对于内核开发来说是一个必须的功能，例如，在这种情况下，只能通过直接 CPU 指令来访问 CPU 功能。确保您彻底测试这段代码，因为它在使用时是不安全的。

此外，`#[feature(naked_functions)]` 允许您将 `#[naked]` 属性添加到函数中。这将删除在函数前后添加的一些样板汇编代码，这样您就可以编写纯汇编代码。很多时候，这对于使用某些 CPU 内置函数是必不可少的。

# 使用更大的整数

`i128_type` 功能为我们提供了 `i128` 和 `u128` 整数，它们的工作方式与 `i64` 和 `u64` 类型相同，但使用 128 位而不是 64 位，这使它们具有更大的容量。它们具有与整数其余部分相同的 API，因此您可以执行相同类型的操作。有时拥有一个更大、全精度的整数是非常好的，在这种情况下，因为它使用了 LLVM 内置函数，所以这个类型几乎与 `u64` 或 `i64` 一样轻量级（在 64 位机器上大约是双倍的处理时间；在 128 位机器上应该差不多）。主文档中给出了一个简单的例子：

```rs
#![feature(i128_type)]

fn main() {
    assert_eq!(1u128 + 1u128, 2u128);
    assert_eq!(u128::min_value(), 0);
    assert_eq!(u128::max_value(),
               340282366920938463463374607431768211455);

    assert_eq!(1i128 - 2i128, -1i128);
    assert_eq!(i128::min_value(),
               -170141183460469231731687303715884105728);
    assert_eq!(i128::max_value(),
               170141183460469231731687303715884105727);
}
```

# 单指令多数据

**单指令多数据**（**SIMD**）CPU 特性已经彻底改变了我们在 CPU 中执行操作的方式。使用处理器特定的特性，我们现在可以同时运行相同的操作。假设我们需要成对地添加四个数字。我们首先可以添加前两个，然后添加后两个，并得到两个结果。SIMD 允许我们同时计算这两个结果，通过同时将加法操作应用于这两对。

然而，这需要汇编，尽管 LLVM 尽可能地使用尽可能多的 SIMD 指令，但对于一些高性能应用来说，有时这还不够。当然，我们可以使用内联汇编，但使用汇编时出错并不罕见，并且您需要为每个目标重新编写它，因此正在开发一个针对 SIMD 的特定前端。

API 仍在开发中，但请查看`simd`功能，以了解它将如何实现。目前看来，似乎将开发一个包含所有内建的独立包。您将能够生成数据组，并支持处理器的每个元素应用同时操作。

# 分配 API

一些特定的项目需要改变默认的堆分配算法的能力。Rust 默认使用 jemalloc，对于允许它的目标。正如我们在前面的章节中看到的，这个分配器的特性之一是，在集合中，它将分配上一次分配的两倍。

您可以通过使用`alloc`、`allocator_api`、`alloc_jemalloc`和`alloc_system`功能来改变这一点。后两个指定了包的全局分配器，在例如内核开发的情况下，必须指定并实现一些函数，以便集合能够工作。其他两个允许进行更定制的分配器操作，甚至给您提供更改每个集合分配器的选项。

# 编译器插件

完成这个列表后，我们将讨论编译器插件。这些插件可以通过在`main.rs`或`lib.rs`文件的顶部添加`#![feature(plugin)]`来使用，就像使用其他夜间功能一样。如果您实际上要创建一个插件，您将需要使用`plugin_registrar`和`rustc_private`功能。

不稳定的特性列表提供了一个有趣的指南来创建插件，这些插件将在第九章“创建您自己的宏”中扩展。您需要使用`libsyntax`包，以及编译器语法的内部结构和编译器本身的内部结构，以便您能够解析**高级源树（AST）**标记，并执行插件所需的操作。

插件允许对语言进行大语法扩展，这可以让您在宏内部运行任意 Rust 代码或生成任何类型的样板代码。我们将在下一章看到一个真实示例，该示例通过大量使用插件来创建出色的 Web 开发体验。

其中一些特性可能短期内不会得到稳定，一些可能会发生很大变化，还有一些甚至可能不会实现，尽管我对您刚才读到的列表表示怀疑。这些变化可能会使您的代码在一夜之间变得过时，因此您必须确保，如果您使用了一些这些特性，您能够维护一个不断变化的生态系统。

# 摘要

在本章中，我们通过学习属性和宏开始了元编程的学习。两者都将帮助您编写更少的代码，并确保您为琐碎的细节获得最佳实现。

我们随后学习了夜间 Rust 版本，以及一些夜间特性如何为我们提供新的语言扩展，这些扩展可以极大地帮助我们提高代码的效率、性能和清晰度。

在下一章中，我们将看到[crates.io](https://crates.io/)上的 crates 如何为生态系统带来新的宏和插件，我们将探讨其中最常用的那些，它们可以提升您应用程序的性能和开发时间。
