# 常见性能陷阱

如果你正在阅读这本书，你很可能关心你的 Rust 代码的性能。众所周知，Rust 可以提供接近 C/C++ 程序的性能，在某些情况下，Rust 甚至可以在基准测试中胜出。然而，主要问题是，有时很难获得这种效率，尤其是如果你来自 C/C++。有些概念不适用，而且那些语言中的一些简单高效的方法在 Rust 中明显更差。

在这本书中，你将学习如何真正利用 Rust，使其在保持其带来的所有好处——安全性、零成本抽象和出色的并发性的同时，发挥最佳性能。你可以从头到尾阅读这本书，你可能会在每一章中学习到新的概念。不过，你也可以直接阅读你感兴趣的章节，因为每一章都包含了完成其内容所需的所有信息，因此它可以作为参考。

在本书的第一部分，我们将从介绍如何提高你的顺序代码性能开始。你将学习如何避免常见的性能陷阱，以及如何修复来自其他语言的直接翻译。然后，你将学习如何从你的代码中获得更好的性能，并最终理解 Rust 中的内存管理。

在本章中，我们将探讨以下内容：

+   使用配置文件配置编译过程

+   翻译陷阱——学习如何通过数组/切片索引和掌握迭代器避免性能陷阱

+   标准库和外部 crate 中的新迭代器适配器，以及以零成本编码任何复杂行为

+   如何利用借用检查器

大多数开始学习 Rust 的人，包括我自己，往往会将其他语言中学到的经验带到 Rust 中。这通常是一件好事，因为它将使你更快地学习这门语言。这种方法的 主要问题是，在其他语言中使用的一些模式在 Rust 中实际上可能是一个权衡。我们将学习最常见的和不太常见的一些模式，以便任何试图在 Rust 中获得更好性能的人都能学到如何做到这一点。

# 向 Rust 编译器询问性能

Rust 有时有一些有趣且不太为人所知的特性，在谈论性能提升时，这些特性确实能带来很大的差异。当涉及到通过小改动实现大改进时，你应该首先理解的是发布模式。Rust 默认以开发模式编译你的软件，这对于快速检查编译错误来说相当不错，但如果你想运行它，它会运行得很慢。这是因为开发模式不会进行任何优化。它将创建与 Rust 代码直接相关的对象（机器）代码，而不会对其进行优化。

Rust 使用了 LLVM 后端，这使得它能够利用其性能优化，而无需自己开发所有这些。它们只需要使用 LLVM 中间表示。这是 Rust 和汇编代码之间的中间语言，LLVM 编译器能够理解。在开发模式下，Rust 或 LLVM 不会执行任何优化；启用它们就像在 cargo 编译时添加 `--release` 标志一样简单。例如，如果你通过在控制台输入 `cargo run` 来运行你的软件，只需使用 `cargo run --release`，它就会进行优化编译并运行得快得多。通常，这种提升是超过一个数量级的。

# 优化

默认情况下，Rust 会在代码中执行第 3 级优化。优化根据其复杂度被分为不同的级别。理论上，高级别的优化可以极大地提高代码的性能，但它们可能存在可能导致程序行为改变的错误。通常，第 1 级优化是完全安全的，而第 2 级优化在 C/C++ 生态系统中是最常用的。第 3 级优化尚未被证明会引起任何问题，但在某些关键情况下，可能最好避免它们。这可以进行配置，但我们应该首先了解 Rust 编译器如何将代码编译成机器指令，以便我们知道不同的选项能完成什么。

Rust 首先会解析你的代码文件。它会获取关键词和不同的符号来在内存中创建代码的表示。这种解析会找到常见的错误，例如缺少分号或无效的关键词。这种代码的内存表示称为 **高中间表示**（**HIR**）。这种代码的表示将会大大简化，移除复杂的流程结构，并将其转换为 **中间中间表示**（**MIR**）。

然后，MIR 表示被用来检查软件的更复杂的流程，并允许进行复杂的变量生命周期检查，以及其他一些改进。然后，它被转换为 LLVM 中间表示，并传递给 LLVM 编译器。当将此代码传递给 LLVM 时，Rust 会添加一些标志，这些标志将修改 LLVM 优化代码的方式。我们已经看到，默认情况下，它传递的其中一个标志是 `-O0` 标志，或 *不优化* 标志，因此它简单地转换为机器代码。然而，在发布模式下编译时，会传递 `-O3`，以便执行第 3 级优化。

这种行为可以在项目的 `Cargo.toml` 文件中配置，并且可以为每个配置文件进行配置。你可以配置如何为测试、开发、文档、基准测试和发布进行编译。你可能希望将开发和文档优化保持在最低限度，因为在这些配置文件中，主要目的是快速编译。在开发配置文件的情况下，你将想要检查一切是否都能正确编译，甚至测试程序的行为，但你可能不会关心性能。在生成文档时，应用程序的性能根本不重要，所以最好的办法就是不要进行优化。

在测试时，所需的优化级别将取决于你想要运行多少次测试以及它们的计算成本有多高。如果运行测试需要非常长的时间，那么编译它们以优化可能是有意义的。此外，在某些可能无法完全确保优化以完全安全方式执行的关键情况下，你可能希望以与优化发布相同的方式优化测试，这样你就可以检查所有单元和集成测试在优化后是否都能正确通过。如果它们没有通过，这可能是编译器故障，你应该向 Rust 编译器团队报告。他们将很高兴提供帮助。

当然，基准测试和发布配置文件应该是优化程度最高的。在基准测试中，你将想要知道代码的真实优化性能，而在发布中，你将希望用户从他们的硬件中获得最佳性能，并且你的软件能够尽可能高效地运行。在这些情况下，你将想要至少优化到 2 级，如果你不是在发送卫星到太空或编程起搏器，你可能会想要将优化进行到 3 级。

# 构建配置

在 `Cargo.toml` 文件中有一个部分可以启用这些配置：配置文件部分。在这个部分中，你会为每个配置文件找到一个子部分。每个子部分都使用 `[profile.{profile}]` 格式声明。例如，对于开发配置文件，它将是 `[profile.dev]`。不同的配置文件配置关键字如下：

+   `dev` 用于开发配置文件，在 `cargo build` 或 `cargo run` 中使用

+   `release` 用于发布配置文件，在 `cargo build --release` 或 `cargo run --release` 中使用

+   `test` 用于测试配置文件，在 `cargo test` 中使用

+   `bench` 用于基准测试配置文件，在 `cargo bench` 中使用

+   `doc` 用于文档配置文件，在 `cargo doc` 中使用

当配置每个配置文件时，你将有很多选项，我们将在这里检查所有这些选项。

# 优化级别

第一个选项是之前提到的优化级别。此配置选项可以通过在相关配置文件部分使用`opt-level`键来设置。默认情况下，优化级别为 3 用于基准测试和发布，其余为 0。例如，要仅在发布配置文件中执行级别`2`的优化，您可以将以下代码添加到您的`Cargo.toml`文件中：

```rs
    [profile.release]
    opt-level = 2
```

# 调试信息

下一个选项是调试信息。这不会直接影响性能，但它是一个有趣的配置项。在这种情况下，您可以决定是否将调试符号信息添加到最终的可执行文件中。如果您正在开发，尤其是如果您正在使用 GDB 之类的调试器，这将非常有用。将调试信息添加到可执行文件将使您能够获取处理器中每个指令的函数名甚至行号。这将为您提供关于代码中发生情况的深入了解。

在任何情况下，调试信息在最终发布的二进制文件中并不那么有用，因为最终发布的二进制文件并不是为了调试而设计的。而且，调试信息通常会增加最终二进制文件的大小。这曾多次成为开发者的担忧，因为 Rust 的二进制文件通常比用 C/C++编写的二进制文件要大得多。这在很大程度上是由于这种配置，以及在大多数情况下是由于 panic 行为，我们稍后会检查。调试符号还会显示有关原始代码的信息，因此在封闭源代码项目中隐藏它可能是有意义的。

为了避免在最终二进制文件中包含额外的调试符号，必须将`debug`选项设置为`false`。这可以为每个配置文件进行设置，默认情况下，只有开发配置文件为`true`。如果您还希望将其用于测试，例如，您可以在`Cargo.toml`文件中添加以下内容：

```rs
    [profile.test]
    debug = true
```

当然，您可以将此与任何其他配置文件选项结合使用：

```rs
    [profile.test]
    debug = true
    opt-level = 1
```

# 链接时间优化

下一个配置选项，对于提高应用程序的性能很有用，是链接时间优化。通常，当程序构建时，一旦所有代码都已优化，它就会被链接到其他库和函数，以提供所需的功能。然而，这并不总是以最有效的方式进行。有时，一个函数会被链接两次，或者一段代码会在许多地方使用，在这种情况下，编译器可能会决定复制一些代码。

该程序将完美运行，但有两个主要缺点——首先，复制代码和链接会使二进制文件更大，这可能是你不想看到的事情，其次，它将降低性能。你可能会问为什么。好吧，由于相同的代码在程序的不同地方被访问，如果它只执行一次，它可能会被添加到处理器的 L1/L2/L3 缓存中。这将使得未来可以重用这些指令，而无需处理器从 RAM 内存（较慢）或甚至从磁盘/SSD（极慢）中获取它们（如果内存已经被交换的话）。

当执行**链接时间优化**，或简称为**LTOs**时，主要优势在于，虽然 Rust 是按文件编译代码的，但 LTOs 将整个几乎最终的表示形式放入一个大的编译单元中，可以对其进行整体优化，从而实现更好的执行路径。

当然，这可以完成，但代价是编译时间会非常长。这些优化非常昂贵，因为它们有时需要改变最终的表现形式，即准备写入二进制的那个形式。不仅如此，这还需要检查大量的执行路径和代码样本以找到相似的块。记住，这是在对象代码上完成的，而不是 Rust 代码，所以编译器不知道库或模块；它只看到指令。

这种代价高昂的优化将提高你软件的性能和二进制文件的大小，但由于代价如此之高（通常需要与编译的其他部分一样多的时间，甚至更多），它默认情况下在所有配置文件中都没有启用。你不应该在除了发布和可能基准测试配置文件之外的地方启用它（你不想每次在函数中做小改动并想要测试它时都等待 LTO）。要更改的配置项是`lto`配置项：

```rs
    [profile.release]
    lto = true
```

有一个相关的配置项，如果为给定配置文件开启了 LTO，则会被忽略。我指的是`codegen`单元。这把代码分成多个更小的代码单元，并分别编译每个单元，从而实现并行编译，这提高了程序编译的速度。这在 LTO 的情况下是如此，但也可以对其他情况进行修改。当然，使用单独的编译单元可以避免一些可以提高代码性能的优化，因此，在开发模式下启用更快的编译可能是有意义的。默认情况下，它将是 16。

这就像更改开发配置文件中的`codegen-units`配置选项一样简单：

```rs
    [profile.dev]
    codegen-units = 32
```

一个示例值可以是你的计算机中的处理器/线程数。但请记住，这将使编译的软件变慢，所以不要在发布配置文件中使用它。无论如何，如果你激活了链接时间优化，它将始终被忽略。

# 调试断言

下一个有趣的配置项是允许移除调试断言的选项。调试断言类似于正常断言，但默认情况下它们仅在开发配置文件中执行。它们通过在`assert!`宏前加上`debug_`前缀来写入代码，例如使用`debug_assert!`或`debug_assert_eq!`。这使您能够在整个代码中填充必须为真且需要处理周期来测试的断言，而不会降低发布应用程序的性能。当然，这意味着这些断言在发布模式下不会运行。这对于测试内部方法很有用，但对于 API 来说可能不是最好的选择，而且在不安全的代码包装器中肯定不是一个好主意。

例如，标准库`Vec`对象中的索引函数有一个断言，每次您通过索引获取向量的元素时都会检查索引是否超出范围。这可以很好地避免缓冲区溢出，但会使获取向量元素的运算变慢，如果索引超出范围，程序将崩溃。我们稍后会讨论这个特定的例子，但总的来说，它显示了这些断言是多么有用——在这种情况下，对于发布模式也是如此。

另一方面，如果您计划创建一个小的内部 API，该 API 将输入介于`0`和`100`之间的数字并对其进行一些计算，但不对公众公开，您只需添加一个`debug_assert!(num <= 100 && num >= 0)`，在测试和调试模式下，如果函数接收到该范围之外的数字，程序将恐慌，但在发布模式下不会运行这个断言。这可能会成为一个潜在的错误向量，但通过彻底的单元测试，测试/开发模式下未获得错误以及在发布模式下接收到错误数字的概率要低得多。当然，再次强调，这不应该用于安全重点区域或可能导致不安全或未定义行为的输入。

默认情况下，如解释所述，这些断言在开发、测试和文档模式下运行。最后一个模式在您有带有调试断言的文档测试时很有用。在任何情况下，都可以通过更改`debug-assertions`配置选项轻松地进行配置。例如：

```rs
    [profile.doc]
    debug-assertions = false
```

# 潘克行为

下一个要检查的配置变量是恐慌行为。默认情况下，Rust 会在恐慌时进行堆栈展开。这意味着如果发生严重错误并且应用程序恐慌，它将调用堆栈中每个变量的每个析构函数。还有一个选项：不调用任何东西，只是简单地终止程序（这是标准 C/C++的行为）。

unwind 的主要优势是，你将能够调用析构函数，因此程序堆栈中变量的任何清理工作都将得到妥善处理。`abort` 行为的主要优势是，它将需要编译更少的代码，因为对于每个潜在的 panic 位置，代码中都会添加一个新的分支，其中运行所有析构函数。它还使代码具有更少的分支，这使得优化更容易，但主要优势是更小的二进制文件。当然，你失去了运行析构函数的能力，因此某些复杂的行为可能无法得到适当的清理，例如，如果你需要在关闭时向日志写入某些内容。

如果你仍然认为在你的用例中，使用 `abort` 行为是一个好主意，你可以通过使用 `panic` 关键字来启用它：

```rs
    [profile.doc]
    panic = 'abort'
```

# 运行时库路径

最后一个配置选项是 `rpath`。此配置项接受一个布尔值，允许你要求 Rust 编译器在可执行文件在运行时查找库时设置加载器路径。尽管如此，大多数时候 Rust 会将 crate 和库静态链接，但你可以要求特定的库以动态方式链接。在这种情况下，该库将在运行时而不是编译时搜索，因此它将使用程序运行所在位置的系统库。

此配置选项要求 cargo 在 `rustc` 编译器调用时添加 `-C rpath`。这将添加到动态库搜索路径中。尽管如此，在大多数情况下，这不应该被需要，如果你不必要的话，应该通过使用 `false` 作为选项值来避免它。如果你在使你的应用程序在多个操作系统上运行时遇到问题，你可能可以尝试它，因为它可能会使可执行文件在新位置查找动态库。

# 翻译问题

当你将 C/C++/Java 思维方式翻译过来，或者直接将项目移植到 Rust 时，你可能会发现自己写的代码与你用母语写的代码相似，但如果你尝试过，你可能已经注意到它的性能不佳，或者至少比旧代码差得多。这种情况在 C/C++ 中尤其如此，因为与 Java 应用程序相比，Java 的性能问题要低得多，Java 应用程序具有 Java 虚拟机和垃圾回收器，内存和计算占用都很大。

但为什么直接翻译会损害性能？在本节中，我们将看到 Rust 的保证有时会创建不必要的样板指令，我们将学习如何通过使用安全和高效的代码来绕过它们。当然，在某些性能关键的情况下，可能需要使用不安全的作用域，但通常情况下并非如此。

# 索引退化

让我们从简单的例子开始。以下 Rust 代码将表现不佳：

```rs
    let arr = ['a', 'b', 'c', 'd', 'e', 'f'];

    for i in 0..arr.len() {
      println!("{}", arr[i]);
    }
```

当然，这会起作用，并且是完全安全的。我们创建一个从`0`到数组长度（在这个例子中是`6`）的索引，但不包括最后一个，所以`i`绑定将取值`0`、`1`、`2`、`3`、`4`和`5`。对于每一个，它将获取数组中该索引处的元素并在新的一行中打印它。然而，这种方法有一个问题。在 C/C++中，等效的代码将简单地向数组中的指针添加元素的大小，以获取下一个元素，但有时这会导致问题。看看这段代码：

```rs
    let arr = ['a', 'b', 'c', 'd', 'e', 'f'];

    for i in 0..arr.len() + 1 {
      println!("{}", arr[i]);
    }
```

在这种情况下，我们迭代到数组长度加一，由于范围是排他的，最后一个索引将是 6。这意味着它将尝试获取数组中的第七个元素，但数组中没有第七个元素。在 C/C++中，这将创建一个缓冲区溢出，并获取内存中的下一个内容。如果这个内存超出了程序的范围，你将得到一个段错误，但如果它是程序的一部分，它将打印出那个位置的内容，导致泄漏。当然，在 Rust 中这是不可能的，因为 Rust 是一种内存安全的语言，所以会发生什么呢？

好吧，答案令人惊讶——它会惊慌程序，撤销栈（调用栈中所有变量的析构函数），并安全地退出程序，而不尝试访问无效内存。根据你的观点，你可能认为“太好了，我将不再有缓冲区溢出”，或者你可能认为“哦，我的天哪，整个服务器都会崩溃以防止缓冲区溢出”。然而，第二种情况可以通过停止惊慌并恢复适当的服务器状态来缓解，这已经在大多数框架中实现，所以这基本上是一个双赢的局面。

但这是真的吗？Rust 是如何知道索引是否越界的呢？在这个简单的例子中，编译器可以知道`arr`变量只有六个元素，所以尝试访问第七个将违反内存约束。但关于这个更复杂的程序：

```rs
    fn print_request(req: Request) {
      for i in 0..req.content_length {
        println!("{}", req.data[i]);
      }
    }
```

在这里，我接收到一个至少包含一个`content_length`属性和一个`data`属性的 HTTP 请求（非常天真地表示）。第一个应该包含数据字段长度的字节数，而第二个将是一个字节数组。假设我们没有那个数据字段中的`len()`函数，并且我们信任`content_length`属性。如果有人发送一个包含比内容实际长度更大的`content_length`的无效请求怎么办？编译器在请求运行时从 TCP 连接中产生之前不会知道这一点，但同样，Rust 必须始终是内存安全的（除非在不可安全的作用域中工作，这在本例中不是情况）。

嗯，发生的事情是索引操作有两个部分。首先，它检查切片的界限，如果索引是正确的，它将返回元素；如果不正确，它将引发恐慌。是的，它对每个索引操作都这样做。所以在这种情况下，如果请求是一个有效的请求，假设有 100 万个字节（1 MB），它将 1 百万次比较索引与向量的长度。这至少是 200 万个额外的指令（每个比较和分支至少）。这比等效的 C/C++代码效率低得多。

# 使用迭代器

然而，有一种方法可以绕过这个问题，达到与 C/C++代码相同的效果：使用迭代器。之前的代码可以转换为以下：

```rs
    let arr = ['a', 'b', 'c', 'd', 'e', 'f'];

    for c in &arr {
      println!("{}", c);
    }
```

这将大致编译成与 C/C++变体相同的机器代码，因为它不会多次检查切片的界限，然后使用相同的指针算术。这在迭代切片时很好，但在直接查找的情况下可能会出现问题。假设我们将收到成千上万的 100 元素切片，我们需要获取每个切片的最后一个元素并打印它。在这种情况下，为了只获取最后一个元素，遍历每个数组中的所有 100 个元素是不明智的，因为这会更有效率，只需检查最后一个元素的界限。有几种方法可以做到这一点。

第一个是最直接的：

```rs
    for arr in array_of_arrays {
      let last_index = arr.len() - 1;
      println!("{}", arr[last_index]);
    }
```

在这个具体案例中，我们想要获取最后一个元素，我们可以这样做：

```rs
    for arr in array_of_arrays {
      if let Some(elt) = arr.iter().rev().next() {
        println!("{}", elt);
      }
    }
```

这将通过调用`rev()`来反转迭代器，然后获取下一个元素（最后一个元素）。如果存在，它将打印它。但是，如果我们需要获取一个不接近切片末尾或开头的数字，最好的方法就是使用`get()`方法：

```rs
    for arr in array_of_arrays {
      if let Some(elt) = arr.get(125) {
        println!("{}", elt);
      }
    }
```

然而，最后一个有双重界限检查。它将首先检查索引是否正确以返回`Some(elt)`或`None`，然后最后一个检查将查看返回的元素是`Some`还是`None`。如果我们确实知道，我是指 100%确定，索引始终在切片内，我们可以使用`get_unchecked()`来获取元素。这是 C/C++索引操作的精确等效，因此它不会进行界限检查，允许更好的性能，但使用它是不安全的。所以，在之前的 HTTP 示例中，攻击者能够获取存储在该索引中的内容，即使它是一个切片之外的内存地址。当然，您需要使用一个不安全的作用域：

```rs
    for arr in array_of_arrays {
      println!("{}", unsafe { arr.get_unchecked(125) });
    }
```

`get_unchecked()`函数将始终返回某些内容或段错误，因此不需要检查它是`Some`还是`None`。记住，在段错误发生时，这不会引发恐慌，并且不会调用析构函数。它只应在没有安全替代方案且切片界限已知的情况下使用。

在大多数情况下，你将想要使用一个迭代器。迭代器允许精确地迭代元素，甚至过滤它们，跳过一些，取最大数量的它们，最后将它们收集到一个集合中。它们甚至可以被扩展或与其他迭代器连接起来，以允许任何类型的解决方案。所有这些都由`std::iter::Iterator`特质管理。你现在已经理解了特质的常用方法，其余的留给你在标准库文档中研究。

正确使用和理解迭代器非常重要，因为它们对于执行真正快速的循环非常有用。迭代器是无成本的抽象，它们的工作方式与索引相同，但不需要边界检查，这使得它们非常适合效率提升。

# 迭代器适配器

让我们从最简单的方法开始。其余方法的基本方法是`next()`方法。这个函数将返回迭代中的下一个元素，或者如果迭代器已经被消耗，则返回`None`。这可以用来手动获取下一个元素，或者创建一个使用`while`的`for`循环，例如：

```rs
let arr = [10u8, 14, 5, 76, 84];
let mut iter = arr.iter();

while let Some(elm) = iter.next() {
    println!("{}", elm);
}
```

这将等同于以下内容：

```rs
let arr = [10u8, 14, 5, 76, 84];

for elm in &arr {
    println!("{}", elm);
}
```

注意在`for`中的数组变量前面的`&`。这是因为基本数组类型没有实现`Iterator`特质，但数组的引用是一个切片，而切片实现了`IntoIterator`特质，这使得它可以作为一个迭代器使用。

你应该了解的下一个两个方法是`skip()`和`take()`方法。这些方法使得获取已知有序迭代器的正确成员变得容易。例如，假设我们想要从一个长度未知的迭代器中取出第三到第十个元素（至少有 10 个元素）。在这种情况下，最好的办法是跳过前两个，然后取出接下来的八个。然后我们将它们收集到一个向量中。请注意，迭代器不会运行，直到你调用`collect()`方法或者在一个循环中使用它。这些就是`next()`方法被执行的时刻：

```rs
let arr = [10u8, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

let collection: Vec<_> = arr.iter().cloned().skip(2).take(8).collect();

for elm in collection {
    println!("{}", elm);
}
```

这将开始遍历数组，并且它将首先克隆每个元素。这是因为默认情况下，迭代器会返回元素的引用，而在`u8`的情况下，最好复制它们而不是引用它们，就像我们在本章末尾将看到的那样。`skip()`方法将调用`next()`两次并丢弃它返回的内容。然后，对于每次`next()`操作，它将返回一个元素。直到它调用`next()`八次，`take()`方法将返回一个元素。然后它将返回`None`。`collect()`方法将创建一个空向量，并将元素推送到它里面，而`next()`方法返回`Some`，然后返回向量。

注意，`collect()`方法需要一个类型提示，因为它可以返回任何类型的集合——实际上，任何实现了`FromIterator`特质的类型。我们只是简单地告诉它它将是一个标准库的`Vec`，然后让编译器推断向量将持有的元素类型。

也有一些函数是前一个函数的泛化，分别是 `skip_while()` 和 `take_while()`。这两个函数分别会在闭包返回 `true` 时跳过或取走元素。让我们看一个例子：

```rs
let arr = [10u8, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

let collection: Vec<_> = arr.iter()
    .cloned()
    .skip_while(|&elm| elm < 25)
    .take_while(|&elm| elm <= 100)
    .collect();

for elm in collection {
    println!("{}", elm);
}
```

在这种情况下，`skip_while()` 方法将运行 `next()` 直到找到一个大于或等于 `25` 的元素。在这种情况下，这是第四个元素（索引 3），数字 `76`。`take_while()` 方法随后调用 `next()` 并返回所有小于或等于 `100` 的元素。当它找到 `143` 时，它返回 `None`。然后 `collect()` 方法将包括所有这些元素，从 `76` 到 `100`（包括），并将它们放入一个向量中，并返回它。请注意，`23` 也会被添加到最终结果中，因为即使它小于 `25`，跳过方法停止跳过后，它将永远不会再次跳过。

为了微调迭代中元素的过滤，还有一些其他非常有趣的方法，比如 `filter()` 方法及其伴随的 `map()` 方法。第一个方法允许你根据闭包过滤迭代器的元素，而第二个方法允许你将每个元素映射到不同的元素。让我们通过使用一个简单的迭代器来探索这一点，该迭代器产生迭代器的奇数元素并将它们收集到一个向量中：

```rs
let arr = [10u8, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

let collection: Vec<_> = arr.iter()
    .enumerate()
    .filter(|&(i, _)| i % 2 != 0)
    .map(|(_, elm)| elm)
    .collect();

for elm in collection {
    println!("{}", elm);
}
```

在这种情况下，我们通过调用 `enumerate()` 来枚举迭代器。这将产生一个元组，包含每次 `next()` 调用的索引和元素。然后，通过检查索引进行过滤。如果索引是奇数，它将在 `next()` 调用中返回；如果不是，它将再次调用 `next()`。然后，它将被映射，因为过滤也会返回元组。`map()` 函数将只取元素，丢弃索引，并返回它。

通过使用有用的 `filter_map()` 函数，可以将过滤和映射函数简化，该函数结合了这两个功能：

```rs
let arr = [10u8, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

let collection: Vec<_> = arr.iter()
    .enumerate()
    .filter_map(|(i, elm)| if i % 2 != 0 { Some(elm) } else { None })
    .collect();

for elm in collection {
    println!("{}", elm);
}
```

`filter_map()` 转换器期望一个闭包，当应该返回元素时返回 `Some(element)`，当应该重试并调用 `next()` 时返回 `None`。这将避免一些额外的代码。在这个具体案例中，你也可以使用 `step_by()` 方法，它只返回每 *n* 个元素中的一个。在这种情况下，使用两步将产生相同的效果。

当尝试使用迭代器进行计算时，我们不必使用 `for` 循环，而是可以使用伟大的 `fold()` 方法。这个方法会在每次调用 `next()` 之间保持一个变量，你可以更新它。这样，你可以在迭代器中求和、乘法，以及执行任何其他操作。例如，让我们求迭代器中所有元素的总和：

```rs
let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

let sum = arr.iter().fold(0u32, |acc, elm| acc + elm);
println!("{}", sum);
```

这将打印 `985`，而不需要循环。当然，这将在底层使用循环实现，但对于程序员来说，这是一个零成本的抽象，有助于简化代码。

# 真实世界的例子

作为现实生活中的例子，这里是用`fold()`方法实现的*VSOP87*算法的变量函数。*VSOP87*算法用于在天空中发现行星和卫星，具有非常好的精度，对于模拟器和望远镜星象仪等非常有用：

```rs
fn calculate_var(t: f64, var: &[(f64, f64, f64)]) -> f64 {
    var.iter()
       .fold(0_f64, |term, &(a, b, c)| term + a * (b + c * t).cos())
}
```

这等同于以下其他代码：

```rs
fn calculate_var(t: f64, var: &[(f64, f64, f64)]) -> f64 {
    let mut term = 0_f64;
    for &(a, b, c) in var {
        term += a * (b + c * t).cos();
    }
    term
}
```

而在 C/C++中，这可能需要一个结构来保存元组。五行代码简化为了一行，同时保持了原生代码。正如我们之前讨论的，这没有额外的成本，并且将被编译成相同的机器代码。

# 专门适配器

在求和或乘法的情况下，有一些专门的方法：`sum()`和`product()`方法。这些方法将执行与`fold()`方法相同的功能，即用于在迭代器中添加所有数字或乘以迭代器中的所有项。我们之前看到的例子可以简化为这个：

```rs
let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

let sum: u32 = arr.iter().sum();
println!("{}", sum);
```

目前需要类型注解，但代码看起来更简单。你还可以以相同的方式使用`product()`函数，它将等同于以下代码：

```rs
let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

let prod = arr.iter().fold(0u32, |acc, elm| acc * elm);
println!("{}", prod);
```

# 适配器之间的交互

还有一些函数可以控制迭代器如何与其他迭代器或自身交互。例如，`cycle()`函数将在迭代器到达末尾后再次从开头开始。这对于使用迭代器创建无限循环非常有用。还有一些函数可以帮助你同时处理多个迭代器。假设你有两个长度相同的切片，并想生成一个具有相同长度的新的向量，但每个元素都是切片中相同索引的元素之和：

```rs
let arr1 = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];
let arr2 = [25u32, 12, 73, 2, 98, 122, 213, 22, 39, 300, 144, 163, 127, 3, 56];

let collection: Vec<_> = arr1.iter()
    .zip(arr2.iter())
    .map(|(elm1, elm2)| elm1 + elm2)
    .collect();
println!("{:?}", collection);
```

在这个例子中，我们使用了`zip()`函数，它会生成一个元组，其中每个元素都是每个迭代器的下一个元素。我们还可以使用`chain()`函数将它们连接起来，该函数将生成一个新的迭代器，一旦第一个迭代器开始产生`None`，它将开始从第二个迭代器产生元素。还有许多其他的迭代函数，但我们现在先不讨论标准库，而是专注于外部 crate。

# Itertools

有一个外部 crate 可以使使用迭代器的工作变得容易得多，并赋予你超级能力。还记得这些迭代器允许你执行在 C 语言中使用索引会执行的操作的想法吗？但是具有完整的内存安全和零成本抽象？它们还使代码更容易理解。在迭代器功能方面，最重要的 crate 是*itertools* crate。这个 crate 提供了一个新的 trait，即`Itertools` trait，它为迭代器提供了许多新的方法和函数，使开发者的生活变得更加容易，同时保持其核心价值——性能，这得益于零成本抽象。你可以通过将它们添加到`Cargo.toml`文件中的`[dependencies]`部分来将它们添加到你的项目中。

让我们探索一些它的迭代器适配器。我们从一个简单的适配器开始，它帮助我们创建给定迭代器的批次或块，即 `batching()` 函数。假设我们想要使用一个迭代器遍历之前的数组，并希望它以三组元素的形式返回元素。这就像使用该方法并创建一个直接调用 `next()` 方法并返回所需元组的闭包一样简单：

```rs
// Remember
extern crate itertools;
use itertools::Itertools;

let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

for tuple in arr.iter().batching(|it| match it.next() {
    None => None,
    Some(x) => {
        match it.next() {
            None => None,
            Some(z) => {
                match it.next() {
                    None => None,
                    Some(y) => Some((x, y, z)),
                }
            }
        }
    }
})
{
    println!("{:?}", tuple);
}
```

这将按顺序以三个元素为一组打印数组：

```rs
(10, 5, 14)
(76, 35, 84)
(23, 100, 94)
(143, 200, 23)
(12, 72, 94)
```

可以通过使用 `chunks()` 函数完成类似的操作。我们可以说，`batching()` 适配器是 `chunks()` 适配器的泛化，因为它为你提供了创建函数内部逻辑的选项。在 `chunks()` 的情况下，它将只接收块中元素的数量作为参数，并返回这些块的切片。

使用 `tuples()` 方法将执行一个非常类似的操作。正如你所见，`batching()` 方法在创建迭代器的批次或块方面是一个完全的泛化。让我们看看之前用 `tuples()` 方法看到的相同示例：

```rs
// Remember
extern crate itertools;
use itertools::Itertools;

let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

for tuple in arr.iter().tuples::<(_, _, _)>() {
    println!("{:?}", tuple);
}
```

代码量大大减少，对吧？在这种情况下，我们需要指定元组中的元素数量，但如果我们在 `for` 循环中使用类型推断，就可以避免这样做：

```rs
// Remember
extern crate itertools;
use itertools::Itertools;

let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];

for (a, b, c) in arr.iter().tuples() {
    println!("({}, {}, {})", a, b, c);
}
```

当然，在这种情况下，我们将进行模式赋值。还有一个有趣的功能允许创建两个迭代器的笛卡尔积。

毫不奇怪，函数名是 `cartesian_product()`。这将创建一个新的迭代器，包含前两个迭代器所有可能的组合：

```rs
// Remember
extern crate itertools;
use itertools::Itertools;

let arr1 = [10u32, 14, 5];
let arr2 = [192u32, 73, 44];

for row in arr1.iter().cartesian_product(arr2.iter()) {
    print!("{:?}, ", row);
}
```

这将打印以下内容：

```rs
(10, 192), (10, 73), (10, 44), (14, 192), (14, 73), (14, 44), (5, 192), (5, 73), (5,44),
```

`Itertools` 特性中还有许多其他方法，我邀请你查看官方文档，因为它非常详细，有很多示例。现在，这些常用方法应该可以帮助你以更高效的方式执行任何需要用切片执行的操作。

# 借用退化

翻译退化不仅发生在迭代过程中。还有一些额外的点，有时你可以看到相同的代码在 Rust 中的性能比 C/C++ 差得多。其中一个点是引用处理。由于借用检查器的限制，当你将变量传递给函数时，你可以对变量做三件事：发送一个引用（借用）、将变量的控制权交给新函数（拥有），或者复制/克隆变量以将其发送到函数。这似乎很容易决定，对吧？如果你不再需要变量，让函数拥有你的变量。如果你需要它，发送引用，如果你需要它且 API 只接受拥有，就克隆它。

嗯，实际上并不那么简单。例如，整数比引用更快地复制，小型结构也是如此。一般来说，如果它的大小小于或等于`usize`，就复制，总是如此。如果它在`usize`和 10 倍大小之间，可能最好复制。如果更大，可能最好引用。如果结构有堆分配（例如`Vec`或`Box`），通常最好传递一个引用。

然而，也有一些情况下，你无法决定变量的去向。例如，在宏中，变量是原样传递的，宏决定如何处理它。例如，`println!`宏通过引用获取所有元素，因为它不需要更多。问题是，如果你试图打印一个整数，例如，会出现瓶颈。这就是罗伯特·格罗斯（Robert Grosse）之前遇到的情况，他写了一篇文章关于这件事。

简而言之，他不得不强制复制整数。他是怎么做到的？嗯，这就像创建一个会返回那个整数的范围一样简单。由于整数实现了`Copy`，整数将被复制到范围中，然后返回，实际上是将它复制到了宏中：

```rs
let my_int = 76_u32;
println!("{}", {my_int});
```

对于正常的打印，这通常不是必要的，但如果你需要快速打印成千上万或数百万个整数，你将无法避免 I/O 接口，但至少可以避免这个瓶颈。

# 圈复杂度

另一个可能的瓶颈是函数的圈复杂度。虽然它与将代码从其他语言翻译过来没有直接关系，但确实，Rust 有时会增加代码的圈复杂度，因为它迫使你检查可选（可空）的结果，一些复杂的迭代器，函数式编程等等。这对于代码安全性来说是个好事情，但有时编译器在优化我们编写的代码时会出现问题。

避免这种情况的唯一方法是将代码分成更小的代码单元，这将有助于编译器逐个优化。实现这一目标的一种方法是通过创建更小的函数，每个函数不超过 20-25 个分支。分支是程序根据一个变量的值运行一个代码或另一个代码的地方。最简单的分支是条件分支，一个`if`。还有很多其他分支，比如循环（特别是当循环包含返回时）或`?`运算符。这将创建两个分支，每个结果选项一个。其中一个将返回函数，而另一个将分配变量。

嵌套循环和条件语句会使这个列表变得更大，分支可以变得越来越复杂，因此你将不得不尝试将这些深层嵌套的条件语句划分到新的函数中。这甚至被认为是一种良好的实践。正如你将在*工具*部分看到的那样，有一些工具可以帮助你找到这些瓶颈。

# 摘要

在本章中，我们学习了如何避免新 Rust 程序员遇到的最常见错误，并了解了 Rust 如何执行某些操作，以便我们可以利用它们。

我们学习了如何配置构建系统以允许精确编译。你现在可以设置优化过程、链接时优化或恐慌行为，以及其他许多事情。

现在，你已经掌握了迭代器，并且能够停止索引切片，从而获得宝贵的计算周期。你还发现了*Itertools*包，现在你可以使用它来对迭代器执行复杂操作。

最后，你学习了一些关于循环复杂度的技巧，并了解了借用或复制如何影响程序的工作方式。

从现在开始，我们将进入更复杂的问题的世界，这些问题有时对新开发者来说可能难以理解。我们将充分利用 Rust 编程语言的全部功能来创建快速且安全的应用程序。
