# 第一章：*第一章*：理解 LLVM

JavaScript 是最受欢迎的编程语言之一。然而，JavaScript 有两个主要缺点：

+   **不可预测的性能**

JavaScript 在 JavaScript 引擎提供的环境和运行时中执行。存在各种 JavaScript 引擎（V8、WebKit 和 Gecko）。它们都是不同构建的，并以不同的方式运行相同的 JavaScript 代码。此外，JavaScript 是动态类型的。这意味着 JavaScript 引擎在执行 JavaScript 代码时应该猜测类型。这些因素导致 JavaScript 执行性能不可预测。针对一种 JavaScript 引擎的优化可能会对其他类型的 JavaScript 引擎产生不希望的影响。这导致性能不可预测。

+   **包大小**

JavaScript 引擎会等待下载整个 JavaScript 文件后再进行解析和执行。JavaScript 文件越大，等待时间越长。这将降低应用程序的性能。捆绑器如 webpack 有助于最小化捆绑大小。但当您的应用程序增长时，捆绑大小会呈指数增长。

有没有一种工具提供原生性能，并且体积要小得多？是的，WebAssembly。

WebAssembly 是 Web 和 Node 开发的未来。WebAssembly 是静态类型和预编译的，因此它比 JavaScript 提供更好的性能。二进制的预编译提供了生成小型二进制捆绑包的选项。WebAssembly 允许 Rust、C 和 C++等语言编译成在 JavaScript 引擎内与 JavaScript 一起运行的二进制文件。所有 WebAssembly 编译器都使用 LLVM 在底层将本地代码转换为 WebAssembly 二进制代码。因此，了解 LLVM 是什么以及它是如何工作的是非常重要的。

在本章中，我们将学习编译器的各种组件及其工作原理。然后，我们将探讨 LLVM 是什么以及它是如何帮助编译型语言的。最后，我们将看到 LLVM 编译器如何编译本地代码。本章将涵盖以下主题：

+   理解编译器

+   探索 LLVM

+   LLVM 的实际应用

# 技术要求

我们将使用**Clang**，这是一个将 C/C++代码编译成本地代码的编译器。

对于 Linux 和 Mac 用户，Clang 应该直接可用。

对于 Windows 用户，可以从以下链接安装 Clang：[`llvm.org/docs/GettingStarted.html?highlight=installing%20clang%20windows#getting-the-source-code-and-building-llvm`](https://llvm.org/docs/GettingStarted.html?highlight=installing%20clang%20windows#getting-the-source-code-and-building-llvm) 以安装 Clang。

您可以在 GitHub 上找到本章中存在的代码文件，链接为[`github.com/PacktPublishing/Practical-WebAssembly`](https://github.com/PacktPublishing/Practical-WebAssembly)

# 理解编译器

编程语言被广泛分为编译型和解释型语言。

在编译世界中，代码首先被编译成目标机器码。将代码转换为二进制的过程称为*编译*。将代码转换为目标机器码的软件程序称为*编译器*。在编译过程中，编译器会对编写的代码运行一系列的检查、通过和验证，并生成一个高效且优化的二进制文件。编译语言的一些例子包括 C、C++和 Rust。

在解释世界中，代码在单次遍历中读取和执行。由于编译是在运行时发生的，因此生成的机器码不如编译后的版本优化。解释语言比编译语言慢得多，但它们提供了动态类型和更小的程序大小。

在这本书中，我们将只关注编译语言。

## 编译语言

编译器是一种将源代码翻译成机器码（或者更抽象地说，将代码从一种编程语言转换到另一种编程语言）的翻译器。编译器很复杂，因为它应该理解源代码所写的语言（其语法、语义和上下文）；它还应该理解目标机器码（其语法、语义和上下文），并应该创建一个表示，将源代码映射到目标机器码。

编译器有以下组件：

+   **前端** – 前端负责处理源语言。

+   **优化器** – 优化器负责优化代码。

+   **后端** – 后端负责处理目标语言。

![ 图 1.1 – 编译器的组件

![ 图 1.1 – 编译器的组件

图 1.1 – 编译器的组件

### 前端

前端专注于处理源语言。前端在接收到代码后对其进行解析。然后检查代码中是否存在任何语法或语法错误。之后，代码被转换（映射）成**中间表示**（**IR**）。可以将 IR 视为表示编译器处理的代码的格式。IR 是编译器版本的你的代码。

### 优化器

编译器的第二个组件是优化器。这是可选的，但正如其名称所示，优化器分析 IR 并将其转换为一个更高效的版本。少数编译器有多个 IR。编译器在每次遍历 IR 时都会高效地优化代码。优化器是 IR 到 IR 的转换器。优化器分析、运行遍历并重写 IR。这里的优化包括移除冗余计算、消除死代码（无法到达的代码）以及各种其他优化选项，这些将在未来的章节中探讨。需要注意的是，优化器不必是语言特定的。由于它们作用于 IR，因此可以作为通用组件构建并用于多种语言。

### 后端

后端专注于生成目标语言。后端接收生成的（优化后的）中间表示（IR）并将其转换为另一种语言（例如机器码）。也有可能链式连接多个后端，将代码转换为其他语言。后端负责从 IR 生成目标机器码。这种机器码是实际在裸机上运行的代码。为了生成高效的机器码，后端应该理解代码执行的架构。

机器码是一组指令，指示机器将某些值存储在寄存器中并对它们进行一些计算。例如，生成的机器码负责在 32 位架构中高效地将 64 位数字存储在空闲寄存器中（以及类似的事情）。后端应该理解目标环境，以便高效地创建一组指令，并正确选择和调度指令以提高应用程序执行的效率。

## 编译器效率

*执行越快，性能越好。*

编译器的效率取决于它如何选择指令、分配寄存器以及在给定架构中调度指令执行。指令集是处理器支持的运算集，这种整体设计被称为**指令集架构**（**ISA**）。ISA 是计算机的抽象模型，通常被称为计算机架构。不同的处理器以不同的实现方式转换 ISA。不同的实现可能在性能上有所不同。ISA 是硬件和软件之间的接口。

如果你正在实现一种新的编程语言，并且希望这种语言能在不同的架构（或更抽象地说，不同的处理器）上运行，那么你应该为这些架构/目标中的每一个构建后端。但是，为每个架构构建这些后端是困难的，并且会花费时间、成本和努力来开始语言创建之旅。

如果我们创建一个通用的 IR 并构建一个编译器，将这个 IR 转换为在各种架构上高效运行的机器码，那会怎么样？让我们称这个编译器为低级虚拟机。现在，你的前端在编译器链中的角色仅仅是把源代码转换为与低级虚拟机（如 LLVM）兼容的 IR。现在，低级虚拟机的一般目的是成为一个通用的可重用组件，将 IR 映射到各种目标的本机代码。但是，低级虚拟机只会理解通用的 IR。这个 IR 被称为**LLVM IR**，编译器被称为**LLVM**。

# 探索 LLVM

LLVM 是 LLVM 项目的一部分。LLVM 项目托管编译器和工具链技术。*LLVM 核心* 是 LLVM 项目的一部分。LLVM 核心负责提供源和目标无关的优化，并为许多 CPU 架构生成代码。这使得语言开发者只需创建一个前端，即可从源语言生成与 LLVM 兼容的 IR 或 LLVM IR。

你知道吗？

LLVM 不是一个缩写。当该项目作为一个研究项目开始时，它代表低级虚拟机（Low-Level Virtual Machine）。但后来，决定使用这个名字而不是缩写。

LLVM 的主要优势如下：

+   LLVM 使用一种类似于 C 的简单低级语言。

+   LLVM 是强类型的。

+   LLVM 具有严格定义的语义。

+   LLVM 具有精确和精确的垃圾回收。

+   LLVM 提供了各种优化，您可以根据需求选择。它有 *激进*、*标量*、*跨过程*、*简单循环* 和 *基于配置文件* 的优化。

+   LLVM 提供了各种编译模型。它们是 *链接时间*、*安装时间*、*运行时* 和 *离线*。

+   LLVM 为各种目标架构生成机器代码。

+   LLVM 提供了 DWARF 调试信息。

    注意

    DWARF 是许多编译器和调试器使用的调试文件格式，用于支持源级调试。DWARF 是架构无关的，适用于任何处理器或操作系统。它使用一种称为 **调试信息条目**（**DIE**）的数据结构来表示每个变量、类型、过程等。

    如果你想了解更多关于 DWARF 的信息，请参阅 [`dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf`](http://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf)。

    重要提示

    LLVM 不是一个单一的项目。它是一系列子项目和其它项目的集合。这些项目被各种语言使用，如 Ruby、Python、Haskell、Rust 和 D，用于编译。

现在我们已经了解了编译器和 LLVM，我们将看到它是如何被使用的。

# LLVM 在行动

在本节中，让我们使用 LLVM 的 Clang 编译器将原生代码编译成 LLVM IR。这将更好地了解 LLVM 的工作原理，并在未来章节中理解编译器如何使用 LLVM 时非常有用。

我们首先创建一个名为 `sum.c` 的 C 文件，并输入以下内容：

```rs
 $ touch sum.c
 // sum.c
 unsigned sum(unsigned a, unsigned b) {
    return a + b;
}
```

`sum.c` 文件包含一个简单的 `sum` 函数，该函数接受两个无符号整数并返回它们的和。LLVM 提供了 Clang LLVM 编译器来编译 C 源代码。为了生成 LLVM IR，请运行以下命令：

```rs
$ clang -S -O3 -emit-llvm sum.c
```

我们向 Clang 编译器提供了 `-S`、`-O3` 和 `-emit-llvm` 选项：

+   `-S` 选项指定编译器只运行预处理和编译步骤。

+   `-O3` 选项指定编译器生成一个经过良好优化的二进制文件。

+   `-emit-llvm` 选项指定编译器在生成机器代码时输出 LLVM IR。

上述代码将打印出以下 LLVM IR：

```rs
define i32 @sum(i32, i32) local_unnamed_addr #0 {
  %3 = add i32 %1, %0
  ret i32 %3
}
```

LLVM IR 的语法在结构上与 C 语言非常接近。`define`关键字定义了函数的开始。旁边是函数的返回类型，`i32`。接下来是函数的名称，`@sum`。

重要提示

注意那里的`@`符号吗？LLVM 使用`@`来标识全局变量和函数。它使用`%`来标识局部变量。

在函数名之后，我们声明输入参数的类型（在这种情况下为`i32`）。`local_unnamed_addr`属性表示地址在模块内不具有重要意义。LLVM IR 中的变量是*不可变的*。也就是说，一旦你定义了它们，就不能更改它们。因此，在`block`内部，我们创建一个新的局部值`%3`，并将其赋值为`add`。`add`是一个操作码，它接受参数的类型，然后是两个参数，`%0`和`%1`。`%0`和`%1`表示第一个和第二个局部变量。最后，我们使用`ret`关键字返回`%3`，后面跟着`type`。

这个 IR 是可以转换的；也就是说，IR 可以从文本表示转换为内存，然后转换为在裸金属上运行的实际位码。此外，从位码，你可以将它们转换回文本表示。

假设你正在编写一种新的语言。这种语言的成功取决于它在各种架构上执行时的灵活性。为各种架构（如 x86、ARM 等）生成优化的字节码需要很长时间，而且并不容易。LLVM 提供了一种简单的方法来实现这一点。不是针对不同的架构，而是创建一个编译器前端，将源代码转换为 LLVM 兼容的 IR。然后，LLVM 将 IR 转换为在任何架构上运行的效率高和优化的字节码。

注意

LLVM 是一个伞形项目。它有如此多的组件，你几乎可以为他们写一套书。涵盖整个 LLVM 以及如何安装和运行它们超出了本书的范围。如果你对学习 LLVM 的各个组件、它们的工作原理以及如何使用它们感兴趣，请查看网站：[`llvm.org`](https://llvm.org)。

# 摘要

在本章中，我们了解了编译型语言是如何工作的，以及 LLVM 是如何帮助编译它们的。我们已经使用 LLVM 编译了一个示例程序，以了解它是如何工作的。在下一章中，我们将探讨 Emscripten，这是一个将 C/C++转换为 WebAssembly 模块的工具。Emscripten 使用 LLVM 后端进行编译。
