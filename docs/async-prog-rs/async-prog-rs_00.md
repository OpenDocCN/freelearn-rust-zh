# 前言

本书中的内容最初是为那些希望从零开始使用 Rust 学习异步编程的程序员编写的一系列较短的书籍。我发现当时我所遇到的材料在挫败感、启发性和困惑感上各占一半，所以我想要做些改变。

那些较短的书籍变得流行起来，所以当我有机会再次写一切，改进我满意的部分，并完全重写其他所有内容，将其整合成一本单一、连贯的书籍时，我不得不这么做。结果就在你面前。

人们开始编程的原因多种多样。科学家开始编程是为了建模问题和进行计算。商业专家创建程序来解决特定问题，这些问题有助于他们的业务。有些人开始编程作为一种爱好或在业余时间。这些程序员共同的特点是他们从上到下学习编程。

大多数情况下，这完全没问题，但在异步编程这一普遍话题，尤其是在 Rust 语言中，从基本原理学习这一主题具有明显的优势，本书旨在提供一种实现这一目标的方法。

**异步编程**是一种编写程序的方式，你将程序划分为可以在特定点停止和恢复的任务。这反过来又允许语言运行时或库驱动和调度这些任务，使它们的进度交错。

异步编程由于其本质，将影响整个程序流程，并且非常具有侵入性。它以对你作为程序员来说并不总是明显的方式重写、重新排序和调度你编写的程序。

大多数编程语言都试图使异步编程变得如此简单，以至于你不必真正了解它是如何工作的，就可以在其中高效工作。

你可以在几乎不了解异步 Rust 是如何工作的同时，相当高效地编写异步 Rust，但 Rust 比大多数其他语言更明确，并向程序员暴露了更多的复杂性。如果你对异步编程有一个深入的理解，以及当你编写异步 Rust 时真正发生了什么，你将更容易处理这种复杂性。

另一个巨大的优势是，从基本原理学习得出的知识可以应用于 Rust 之外，而且它反过来会使在其他语言中学习异步编程变得更加容易。我甚至可以说，这些知识中的大部分在日常编程中也会很有用。至少，对我来说是这样的。

我希望这本书能让你感觉像是加入了我的旅程，我们在每个知识主题上逐步构建知识，并通过创建示例和实验来学习。我不想让这本书感觉像是一位讲师简单地告诉你一切是如何工作的。

本书是为那些天生好奇的人而创作的，这类程序员希望理解他们使用的系统，并喜欢通过创建小实验和大实验来探索和学习。

# 本书面向的对象

本书面向那些有一定编程经验，希望从零开始学习异步编程的开发者，以便他们能够熟练掌握异步 Rust，并能够参与关于该主题的技术讨论。对于那些喜欢编写可以拆解、扩展和实验的工作示例的人来说，本书是完美的。我认为这本书对以下两种角色特别相关：

+   来自具有垃圾收集器、解释器或运行时的高级语言（如 C#、Java、JavaScript、Python、Ruby、Swift 或 Go）的开发者。那些在这些语言中具有丰富异步编程经验，但希望从零开始学习它，以及那些没有异步编程经验的程序员，都应该发现这本书同样有用。

+   在 C 或 C++等语言方面有经验，但对异步编程经验有限的开发者。

# 本书涵盖的内容

*第一章*，*并发与异步编程：详细概述*，提供了关于我们今天使用的异步编程类型的历史简短介绍。我们给出了几个重要的定义，并提供了一个心理模型来解释异步编程真正解决的问题，以及并发与并行之间的区别。我们还讨论了在讨论异步程序流程时选择正确参考框架的重要性，并介绍了关于 CPU、操作系统、硬件、中断和 I/O 的几个重要和基本概念。

*第二章*，*编程语言如何模拟异步程序流程*，将范围从上一章缩小，专注于编程语言处理异步编程的不同方式。它首先给出了几个重要的定义，然后解释了堆栈式和无堆栈协程、操作系统线程、绿色线程、纤程、回调、承诺、未来和 async/await。

*第三章*，*理解操作系统支持的事件队列、系统调用和跨平台抽象*，解释了 epoll、kqueue 和 IOCP 是什么以及它们之间的区别。通过介绍系统调用、FFI 和跨平台抽象，为下一章做准备。

*第四章*，*创建您自己的事件队列*，在这一章中，你将创建自己的事件队列，该队列模仿了*mio*（支撑当前异步生态系统大部分内容的流行 Rust 库）的 API。示例将围绕 epoll 展开，并详细介绍其工作原理。

*第五章*，*创建我们自己的 Fibers*，通过一个示例展示了我们创建自己的堆栈式协程，称为 fibers。它们与 Go 使用的绿色线程相同，展示了目前 Rust 使用 futures 和 async/await 进行抽象的最常见和最受欢迎的替代方案之一。Rust 在达到 1.0 之前就使用了这种抽象，因此它也是 Rust 历史的一部分。本章还将涵盖许多通用编程概念，如堆栈、汇编、**应用程序二进制接口**（**ABIs**）和**指令集架构**（**ISAs**），这些概念在异步编程之外也很有用。

*第六章*，*Rust 中的 Futures*，提供了对 futures、运行时和 Rust 中异步编程的简要介绍和概述。

*第七章*，*协程和 async/await*，是一个你可以编写自己的协程的章节，这些协程是 Rust 中 async/await 创建的协程的简化版本。我们将手动编写几个，并介绍一种新的语法，允许我们将看起来像常规函数的内容程序化地重写为我们手动编写的协程。

*第八章*，*运行时、唤醒器和反应器-执行器模式*，介绍了运行时和运行时设计。通过迭代我们在*第七章*中创建的示例，我们将为我们的协程创建一个运行时，我们将逐步改进它。完成之后，我们还会对我们的运行时进行一些实验，以更好地理解其工作原理。

*第九章*，*协程、自引用结构和 Pinning*，是我们介绍 Rust 中的自引用结构和 Pinning 的章节。通过进一步改进我们的协程，我们将亲身体验为什么我们需要像`Pin`这样的东西，以及它是如何帮助我们解决我们遇到的问题的。

*第十章*，*创建您自己的运行时*，是我们最终将所有部件组合在一起的一章。我们将进一步改进前几章中的相同示例，以便我们可以运行 Rust 的 future，这将使我们能够使用 async/await 和异步 Rust 的全部功能。我们还将进行一些实验，展示异步 Rust 的一些困难以及我们如何最好地解决这些问题。

# 为了充分利用这本书

你应该有一些先前的编程经验，并且最好有一些关于 Rust 的知识。阅读免费的、优秀的入门书籍*《Rust 编程语言》*([`doc.rust-lang.org/book/`](https://doc.rust-lang.org/book/))应该会给你提供足够多的关于 Rust 的知识，以便跟随，因为任何高级主题都会一步一步地解释。

阅读本书的理想方式是将书本和代码编辑器并排打开。您还应该有伴随的仓库可用，以便在遇到任何问题时可以参考。

| **本书涵盖的软件/硬件** | **操作系统要求** |
| --- | --- |
| Rust (版本 1.51 或更高) | Windows, macOS, 或 Linux |

您需要安装 Rust。如果您还没有安装，请按照以下说明进行操作：[`www.rust-lang.org/tools/install`](https://www.rust-lang.org/tools/install)。

一些示例可能需要您在 Windows 上使用**Windows Subsystem for Linux**（**WSL**）。如果您在 Windows 机器上跟随，我建议您现在启用 WSL（[`learn.microsoft.com/en-us/windows/wsl/install`](https://learn.microsoft.com/en-us/windows/wsl/install)），并按照以下安装 Rust 的说明进行安装：[`www.rust-lang.org/tools/install`](https://www.rust-lang.org/tools/install)。

**如果您使用的是本书的数字版，我们建议您自己输入代码或从书本的 GitHub 仓库（下一节中有一个链接）访问代码。这样做将帮助您避免与代码复制和粘贴相关的任何潜在错误。**

伴随的仓库按照以下方式组织：

+   属于特定章节的代码位于该章节的文件夹中（例如，`ch01`）。

+   每个示例都作为一个单独的 crate 组织。

+   示例名称前的字母表示不同示例在书中的呈现顺序。例如，`a-runtime`示例在`b-reactor-executor`示例之前。这样，它们将按时间顺序排列（至少在大多数系统上默认是这样）。

+   一些示例有一个后缀为`-bonus`的版本。这些版本将在书中提到，通常包含一个可能值得检查但不是当前主题重要性的示例的具体变体。

# 下载示例代码文件

您可以从 GitHub 下载本书的示例代码文件：[`github.com/PacktPublishing/Asynchronous-Programming-in-Rust`](https://github.com/PacktPublishing/Asynchronous-Programming-in-Rust)。如果代码有更新，它将在 GitHub 仓库中更新。

我们还有其他来自我们丰富图书和视频目录的代码包，可在[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)找到。查看它们吧！

# 使用的约定

本书使用了多种文本约定。

`文本中的代码`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。以下是一个示例：“因此，我们现在已经创建了自己的异步运行时，它使用了 Rust 的`Futures`、`Waker`、`Context`和`async/await`。”

代码块设置为如下：

```rs
pub trait Future {
    type Output;
    fn poll(&mut self) -> PollState<Self::Output>;
}
```

当我们希望您注意代码块中的特定部分时，相关的行或项目将以粗体显示：

```rs
struct Coroutine0 {
    stack: Stack0,
    state: State0,
}
```

任何命令行输入或输出都应如下编写：

```rs
$ cargo run
```

小贴士或重要注意事项

它看起来像这样。

# 联系我们

我们读者的反馈始终受到欢迎。

**一般反馈**：如果您对本书的任何方面有疑问，请通过 mailto:customercare@packtpub.com 给我们发邮件，并在邮件主题中提及书名。

**勘误**：尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，如果您能向我们报告，我们将不胜感激。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)并填写表格。

**盗版**：如果您在互联网上以任何形式发现我们作品的非法副本，如果您能向我们提供位置地址或网站名称，我们将不胜感激。请通过 mailto:copyright@packt.com 与我们联系，并提供材料的链接。

**如果您有兴趣成为作者**：如果您在某个主题上具有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com)。

# 分享您的想法

一旦您阅读了《Rust 中的异步编程》，我们很乐意听到您的想法！请[点击此处直接进入此书的亚马逊评论页面](https://packt.link/r/1805128132)并分享您的反馈。

您的评论对我们和科技社区非常重要，并将帮助我们确保我们提供高质量的内容。

# 下载本书的免费 PDF 副本

感谢您购买本书！

您喜欢在路上阅读，但又无法携带您的印刷书籍到处走？

您的电子书购买是否与您选择的设备不兼容？

别担心，现在，随着每本 Packt 书籍，您都可以免费获得该书的 DRM 免费 PDF 版本。

在任何地方、任何设备上阅读。直接从您最喜欢的技术书籍中搜索、复制和粘贴代码到您的应用程序中。

优惠远不止于此，您还可以获得独家折扣、时事通讯和每日免费内容的每日电子邮件。

按照以下简单步骤获取优惠：

1.  扫描下面的二维码或访问链接

![](img/B20892_QR_Free_PDF.jpg)

[`packt.link/free-ebook/9781805128137`](https://packt.link/free-ebook/9781805128137)

2. 提交您的购买证明

3. 就这样！我们将直接将您的免费 PDF 和其他优惠发送到您的电子邮件

# 第一部分：异步编程基础

在本部分，您将全面了解并发与异步编程。我们还将探讨编程语言采用的各种技术来模拟异步性，包括最流行的技术，并讨论与每种技术相关的优缺点。最后，我们将解释基于操作系统的事件队列的概念，例如 epoll、kqueue 和 IOCP，详细说明如何使用系统调用来与操作系统交互，并解决在创建跨平台抽象（如 mio）时遇到的挑战。本节包括以下章节：

+   *第一章*, *并发与异步编程：详细概述*

+   *第二章*, *编程语言如何模拟异步程序流程*

+   *第三章**, 理解基于操作系统的事件队列、系统调用和跨平台抽象*
