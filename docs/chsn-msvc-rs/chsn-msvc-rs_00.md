# 前言

本书将介绍使用 Rust 开发微服务。我最近才开始使用 Rust，回溯到 2015 年。那时，1.0 版本发布才几个月，我当时并不认为这个工具会带来一场无声的革命，这场革命将颠覆与系统编程相关的传统，而那时，系统编程是乏味的，根本不是时尚。

也许我有点夸张，但我见证了公司如何停止使用传统工具，并开始用 Rust 重写他们产品或服务的一部分，他们对结果如此满意，以至于一次又一次地这样做。如今，Rust 是区块链倡议的重要组成部分，是 WebAssembly 的旗舰，是开发快速且可靠的微服务的强大工具，这些微服务利用了所有可用的服务器资源。因此，Rust 已经从好奇开发者的爱好工具转变为现代产品的坚实基础。

在本书中，我们将学习如何使用 Rust 创建微服务。我们从对微服务的简要介绍开始，讨论为什么 Rust 是编写它们的良好工具。然后，我们将使用`hyper` crate 创建我们的第一个微服务，并学习如何配置微服务和记录活动。之后，我们将探讨如何使用`serde` crate 支持不同格式的请求和响应。

# 本书面向的读者

这本书是为两类读者设计的——对于微服务新手的经验丰富的 Rust 开发者，以及对于 Rust 新手的先进微服务开发者。我试图涵盖今天 Rust 开发者可用的有用工具和 crate 的生态系统。本书描述了微服务的创建过程，从高级框架到构建低级异步组合器，这些组合器以最小的资源阻塞时间产生响应。本书旨在帮助你找到特定任务的解决方案。

为了能够理解本书涵盖的主题，你需要对 Rust 编程语言有扎实的背景知识（你应该能够使用`cargo`编写和编译应用程序，理解生命周期和借用概念，了解特质的工作原理，以及理解如何使用引用计数器、互斥锁、线程和通道）。如果你对 Rust 不熟悉，请在阅读本书之前花时间理解这些概念。

你还必须知道如何编写一个基于 HTTP 协议的最小后端。你必须理解 REST 是什么，以及如何将其用于应用程序。然而，你不需要理解 HTTP/2 是如何工作的，因为我们将使用提供对特定传输抽象无关的 crate。

# 本书涵盖的内容

第一章，*微服务简介*，介绍了微服务以及如何使用 Rust 创建它们。在这一章中，我们还讨论了使用 Rust 创建微服务的优势。

第二章，*使用 Hyper Crate 开发微服务*，描述了如何使用`hyper` crate 创建微服务，从而允许我们创建一个紧凑的异步 Web 服务器，并能够精确控制传入的请求（方法、路径、查询参数等）。

第三章，*日志记录和配置微服务*，包括有关使用命令行参数、环境变量和配置文件配置微服务的信息。您还将了解如何将日志添加到您的项目中，因为这是微服务在生产中维护最重要的功能。

第四章，*使用 Serde Crate 进行数据序列化和反序列化*，解释了除了常规的 HTTP 请求之外，您的微服务还必须支持特定格式的正式请求和响应，如 JSON 和 CBOR，这对于 API 实现以及在微服务之间组织相互交互非常重要。

第五章，*使用 Futures Crate 理解异步操作*，深入探讨了 Rust 的更深入的异步概念以及如何使用异步原语编写组合器来处理请求并为客户端准备响应。如果没有对这些概念有清晰的理解，您将无法编写有效的微服务来利用服务器所有可用的资源，并且避免阻塞执行异步活动的线程，这些线程需要特殊的执行运行时处理。

第六章，*反应式微服务 – 提高容量和性能*，向您介绍了一种不会立即响应传入请求的反应式微服务，并且在完成请求和响应处理时需要花费时间。您将熟悉 Rust 中的远程过程调用以及如何使用该语言，以便微服务之间可以相互调用。

第七章，*与数据库的可靠集成*，展示了如何使用 Rust 与数据库交互。您将了解提供数据库交互的 crates，包括 MySQL、PostgreSQL、Redis、MongoDB 和 DynamoDB。

第八章，*使用对象关系映射（ORM）与数据库交互*，解释了为了有效地与 SQL 数据库交互并将数据库记录映射到本机 Rust 结构体，您可以使用**对象关系映射**（**ORM**）。本章演示了如何使用需要夜间编译器版本的 diesel crates，以及其能力用于生成与表绑定的绑定。

第九章，*使用框架进行简单的 REST 定义和请求路由*，解释了在某些情况下，你不需要编写严格的异步代码，并且使用简化微服务编写的框架就足够了。在本章中，你将熟悉四个这样的框架——rouille、nickel、rocket 和 gotham。

第十章，*微服务中的后台任务和线程池*，讨论了微服务中的多线程以及如何在需要高 CPU 负载且不能异步执行的情况下使用线程池来执行后台任务。

第十一章，*使用 Actors 和 Actix Crate 处理并发*，介绍了 Actix 框架，该框架使用 actor 模型为你提供易于与 Rust 兼容的抽象。这包括性能平衡、代码可读性和任务分离。

第十二章，*可扩展的微服务架构*，深入解释了如何设计松耦合的微服务，这些微服务不需要了解兄弟微服务，并且使用消息队列和代理来相互交互。我们将编写一个示例，说明如何使用 RabbitMQ 与其他微服务进行交互。

第十三章，*Rust 微服务的测试与调试*，解释了测试和调试在为微服务发布做准备方面是一个关键组成部分。你将学习如何从单元测试到覆盖整个应用程序的集成测试来测试微服务。之后，我们将讨论如何使用调试器和日志功能来调试应用程序。此外，我们还将创建一个使用基于 OpenTrace API 的分布式跟踪的示例——这是一个用于跟踪复杂应用程序活动的现代工具。

第十四章，*微服务优化*，阐述了如何优化微服务并提取最大可能的性能。

第十五章，*将服务器打包到容器中*，解释了当微服务准备发布时，应该关注将微服务打包到容器中，因为至少一些微服务需要额外的数据和环境才能工作，或者只是为了获得比裸二进制文件更快的容器交付的优势。

第十六章，*Rust 微服务的 DevOps - 持续集成与交付*，继续探讨如何构建微服务的主题，并解释如何使用持续集成来自动化产品的构建和交付流程。

第十七章，*使用 AWS Lambda 的边界微服务*，向您介绍了无服务器架构，这是一种编写服务的替代方法。您将熟悉 AWS Lambda，并可以使用 Rust 编写快速函数，作为无服务器应用程序的一部分。此外，我们将使用 Serverless Framework 以完全自动化的方式构建和部署示例应用程序到 AWS 基础设施。

# 要充分利用本书

您至少需要 Rust 的 1.31 版本。使用`rustup`工具安装它：[`rustup.rs/`](https://rustup.rs/)。为了编译某些章节的示例，您还需要安装编译器的夜间版本。您还需要安装 Docker 和 Docker Compose 来运行带有数据库和消息代理的容器，以简化本书中示例微服务的测试。

# 下载示例代码文件

您可以从[www.packt.com](http://www.packt.com)的账户下载本书的示例代码文件。如果您在其他地方购买了此书，您可以访问[www.packt.com/support](http://www.packt.com/support)并注册，以便将文件直接通过电子邮件发送给您。

您可以通过以下步骤下载代码文件：

1.  在[www.packt.com](http://www.packt.com)登录或注册。

1.  选择 SUPPORT 标签。

1.  点击代码下载与勘误。

1.  在搜索框中输入书籍名称，并遵循屏幕上的说明。

文件下载完成后，请确保您使用最新版本的软件解压缩或提取文件夹：

+   Windows 版的 WinRAR/7-Zip

+   Mac 版的 Zipeg/iZip/UnRarX

+   Linux 版的 7-Zip/PeaZip

本书代码包也托管在 GitHub 上，地址为[`github.com/PacktPublishing/Hands-On-Microservices-with-Rust`](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust)。如果代码有更新，它将在现有的 GitHub 仓库中更新。

我们还有其他来自我们丰富的书籍和视频目录的代码包可供选择，请访问 **[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**。查看它们！

# 下载彩色图像

我们还提供了一份包含本书中使用的截图/图表的彩色图像的 PDF 文件。您可以从这里下载：[`www.packtpub.com/sites/default/files/downloads/9781789342758_ColorImages.pdf`](https://www.packtpub.com/sites/default/files/downloads/9781789342758_ColorImages.pdf)。

# 约定使用

本书使用了多种文本约定。

`CodeInText`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。以下是一个示例：“将下载的`WebStorm-10*.dmg`磁盘映像文件作为系统中的另一个磁盘挂载。”

代码块设置如下：

```rs
let conn = Connection::connect("postgres://postgres@localhost:5432", TlsMode::None).unwrap();
```

当我们希望您注意代码块中的特定部分时，相关的行或项目将以粗体显示：

```rs
#[derive(Deserialize, Debug)]
struct User {
 name: String,
 email: String,
}
```

任何命令行输入或输出都应如下所示：

```rs
cargo run -- add user-1 user-1@example.com
cargo run -- add user-2 user-2@example.com
cargo run -- add user-3 user-3@example.com
```

**粗体**: 表示新术语、重要单词或屏幕上看到的单词。例如，菜单或对话框中的单词在文本中会这样显示。例如：“从管理面板中选择系统信息。”

警告或重要提示看起来像这样。

小贴士和技巧看起来像这样。

# 联系我们

欢迎读者反馈。

**一般反馈**: 如果您对本书的任何方面有疑问，请在邮件主题中提及书名，并给我们发送邮件至`customercare@packtpub.com`。

**勘误**: 尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，我们将非常感激您能向我们报告。请访问[www.packt.com/submit-errata](http://www.packt.com/submit-errata)，选择您的书籍，点击勘误提交表单链接，并输入详细信息。

**盗版**: 如果您在互联网上以任何形式遇到我们作品的非法副本，我们将非常感激您能提供位置地址或网站名称。请通过`copyright@packt.com`与我们联系，并提供材料的链接。

**如果您有兴趣成为作者**: 如果您在某个领域有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com/)。

# 评论

请留下评论。一旦您阅读并使用过这本书，为何不在购买它的网站上留下评论呢？潜在读者可以查看并使用您的客观意见来做出购买决定，Packt 公司可以了解您对我们产品的看法，我们的作者也可以看到他们对书籍的反馈。谢谢！

如需更多关于 Packt 的信息，请访问[packt.com](http://www.packt.com/)。
