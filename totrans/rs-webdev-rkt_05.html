<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-63"><em class="italic"><a id="_idTextAnchor063"/>Chapter 4</em>: Building, Igniting, and Launching Rocket</h1>
			<p>Many web applications require some kind of object management that can be reused again and again, be it a connection pool for a database server, a connection to a memory store, an HTTP client to third-party servers, or any other object. Another common feature in a web application is <strong class="bold">middleware</strong>.</p>
			<p>In this chapter, we will discuss two Rocket features (state and fairings), which act as the reusable object management and middleware parts of Rocket. We will also learn how to create and use connections to database servers, which is very important in almost all web applications.</p>
			<p>After completing this chapter, we expect you to be able to use and implement the reusable object management and middleware parts of the Rocket web framework. We also expect you to be able to connect to a database of your own choice.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Managing state</li>
				<li>Working with a database</li>
				<li>Attaching Rocket fairings</li>
			</ul>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Technical requirements</h1>
			<p>Besides the usual requirements of a Rust compiler, a text editor, and an HTTP client, starting from this chapter, we're going to work with a database. The database we're going to use throughout this book is PostgreSQL, and you can download it from <a href="https://www.postgresql.org/">https://www.postgresql.org/</a>, install it from your operating system package manager, or use a third-party server such as <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), Microsoft Azure, or <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>).</p>
			<p>We're going to see how to connect to other <strong class="bold">Relational Database Management Systems</strong> (<strong class="bold">RDBMSs</strong>) such as SQLite, MySQL, or Microsoft SQL Server, and you can adjust the lesson code to make the type suitable to those RDBMSs, but it's easier to follow using PostgreSQL.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04</a>.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>Managing state</h1>
			<p>In a web application, usually, programmers <a id="_idIndexMarker216"/>need to create an object that can be reused during the request/response life cycle. In the Rocket web framework, that object is called a <strong class="bold">state</strong>. A state can be anything such as a database connection pool, an object to store various customer statistics, an object to store a connection to a memory store, a<a id="_idIndexMarker217"/> client to send <strong class="bold">Simple Mail Transfer Protocol</strong> (<strong class="bold">SMTP</strong>) emails, and many more.</p>
			<p>We can tell Rocket to <a id="_idIndexMarker218"/>maintain the state, and this is called a <strong class="bold">managed state</strong>. The process of creating a managed state is quite simple. We need to initialize an object, tell Rocket to manage it, and finally use it in a route. One caveat is that we can manage many states from different types, but Rocket can only manage one instance of a Rust type.</p>
			<p>Let's try it directly. We are going to have a visitor counter state and tell Rocket to manage it and increment the counter for every incoming request. We can reuse the previous application from the previous chapter, copy the program from <strong class="source-inline">Chapter03/15ErrorCatcher</strong> into <strong class="source-inline">Chapter04/01State</strong>, and rename the application in <strong class="source-inline">Cargo.toml</strong> as <strong class="source-inline">chapter4</strong>.</p>
			<p>In <strong class="source-inline">src/main.rs</strong>, define a struct to hold the value of the visitor counter. For the state to work, the requirement is <strong class="source-inline">T: Send + Sync + 'static</strong>:</p>
			<pre class="source-code">use std::sync::atomic::AtomicU64;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">struct VisitorCounter {</pre>
			<pre class="source-code">    visitor: AtomicU64,</pre>
			<pre class="source-code">}</pre>
			<p>We already know that <strong class="source-inline">'static</strong> is a lifetime marker, but what is <strong class="source-inline">Send + Sync</strong>?</p>
			<p>In modern computing, due to its complexity, there are many ways a program can be executed in a way not intended. For example, multithreading makes it hard to know whether a variable value has been changed on another thread or not. Modern CPUs also perform branch prediction and execute multiple instructions at the same time. Sophisticated compilers also rearrange the resulting binary code execution flow to optimize the result. To overcome those problems, some kind of syncing is needed in the Rust language.</p>
			<p>The Rust language has<a id="_idIndexMarker219"/> traits and memory containers to solve syncing problems depending on how programmers intended the application to work. We might want to create an object in the heap and share the reference to that object in multiple other objects. For example, we create object <strong class="source-inline">x</strong>, and we use the reference of x, <strong class="source-inline">&amp;x</strong> in other objects field, <strong class="source-inline">y</strong> and <strong class="source-inline">z</strong>. This creates another problem, as the program can delete <strong class="source-inline">x</strong> in other routines making the program unstable. The solution is to create different containers for different use cases. These include <strong class="source-inline">std::cell::Rc</strong> and <strong class="source-inline">std::box::Box</strong>, among others.</p>
			<p><strong class="source-inline">std::marker::Send</strong> is one of those traits. The <strong class="source-inline">Send</strong> trait is making sure any <strong class="source-inline">T</strong> type is safe to be transferred to another thread. Almost all types in the <strong class="source-inline">std</strong> library are <strong class="source-inline">Send</strong>, with a few exceptions such as <strong class="source-inline">std::rc::Rc</strong> and <strong class="source-inline">std::cell::UnsafeCell</strong>. Rc is a single-threaded reference counted pointer.</p>
			<p>Meanwhile, <strong class="source-inline">std::marker::Sync</strong> is saying the <strong class="source-inline">T</strong> type is safe to be shared across multiple threads. That only holds <strong class="source-inline">true</strong> if the <strong class="source-inline">&amp;T</strong> reference is safe to be sent to another thread. Not all <strong class="source-inline">Send</strong> types are <strong class="source-inline">Sync</strong>. For example, <strong class="source-inline">std::cell::Cell</strong> and <strong class="source-inline">std::cell::RefCell</strong> are <strong class="source-inline">Send</strong> but not <strong class="source-inline">Sync</strong>.</p>
			<p><strong class="source-inline">Both</strong> <strong class="source-inline">Send + Sync</strong> are <strong class="bold">marker traits</strong>; they don't have<a id="_idIndexMarker220"/> a function to be implemented by a type. They are <a id="_idIndexMarker221"/>also <strong class="bold">unsafe traits</strong>, so all types implementing these manually are also unsafe and can lead to undefined behavior. So, how do we implement <strong class="source-inline">Send + Sync</strong> in our type? These<a id="_idIndexMarker222"/> types are also <strong class="bold">automatically-derived traits</strong>, which means that a type in which all members are implementing <strong class="source-inline">Send</strong> automatically becomes a <strong class="source-inline">Send</strong> type. Almost all types in the <strong class="source-inline">std</strong> library are <strong class="source-inline">Send + Sync</strong> apart from the raw pointers, <strong class="source-inline">Rc</strong>, <strong class="source-inline">Cell</strong>, and <strong class="source-inline">RefCell</strong>.</p>
			<p>What is <strong class="source-inline">AtomicU64</strong>? With the regular <strong class="source-inline">u64</strong> type, even though it's <strong class="source-inline">Send + Sync</strong>, there's no synchronization between threads so a data race condition might happen. For example, two threads access the same variable, <strong class="source-inline">x</strong> (which has a value of <strong class="source-inline">64</strong>) at the same time, and they increment the value by one. We expect the result to be <strong class="source-inline">66</strong> (as there are two threads), but because there's no synchronization between threads, the final result is unpredictable. It can be <strong class="source-inline">65</strong> or <strong class="source-inline">66</strong>.</p>
			<p>The types in the <strong class="source-inline">std::sync</strong> module provide a couple of ways to share updates between multiple threads, including the <strong class="source-inline">std::sync::Mutex</strong>, <strong class="source-inline">std::sync::RwLock</strong>, and <strong class="source-inline">std::sync::atomic</strong> types. We can also use other libraries that might provide better speed than a standard library, such as the <strong class="source-inline">parking_lot</strong> crate.</p>
			<p>Now we have<a id="_idIndexMarker223"/> defined <strong class="source-inline">VisitorCounter</strong>, let's initialize it and tell Rocket to manage it as a state. Write the code inside the <strong class="source-inline">rocket()</strong> function as in the following lines:</p>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    <strong class="bold">let visitor_counter = VisitorCounter {</strong></pre>
			<pre class="source-code"><strong class="bold">        visitor: AtomicU64::new(0),</strong></pre>
			<pre class="source-code"><strong class="bold">    };</strong></pre>
			<pre class="source-code">    rocket::build()</pre>
			<pre class="source-code">        <strong class="bold">.manage(visitor_counter)</strong></pre>
			<pre class="source-code">        .mount("/", routes![user, users, favicon])</pre>
			<pre class="source-code">        .register("/", catchers![not_found, forbidden])</pre>
			<pre class="source-code">}</pre>
			<p>After we tell Rocket to manage the state, we can use it inside the route handling functions. In the previous chapter, we learned about dynamic segments that we have to use in <strong class="source-inline">function</strong> arguments. There are other arguments we can use in a route handling function, which we call <strong class="bold">request guards</strong>. They are called <em class="italic">guards</em> because if a request does not pass the <a id="_idIndexMarker224"/>validation inside the guard, the request will be rejected, and an error response will be returned.</p>
			<p>Any type that implements <strong class="source-inline">rocket::request::FromRequest</strong> can be considered a request guard. Incoming requests are then validated against each request guard from left to right and will short circuit and return an error if the request is not valid.</p>
			<p>Suppose we have a route handling function as in the following lines:</p>
			<pre class="source-code">#[get("/&lt;param1&gt;")]</pre>
			<pre class="source-code">fn handler1(param1: u8, <strong class="bold">type1: Guard1, type2: Guard2</strong>) {}</pre>
			<p>The <strong class="source-inline">Guard1</strong> and <strong class="source-inline">Guard2</strong> types are the request guards. The incoming request is then validated against the <strong class="source-inline">Guard1</strong> methods, and if an error occurs, the proper error response will be returned immediately.</p>
			<p>We will learn about and implement request guards throughout the book, but we will just use a request guard without implementing it in this chapter. <strong class="source-inline">FromRequest</strong> is already implemented for <strong class="source-inline">rocket::State&lt;T&gt;</strong>, so we can use it in the route handling function.</p>
			<p>Now that we have<a id="_idIndexMarker225"/> learned why we use <strong class="source-inline">State</strong> in a route handling function, let's use it in our functions. We want to set the visitor counter so each hit to the request should increment the counter:</p>
			<pre class="source-code">use rocket::{Build, Rocket, <strong class="bold">State</strong>};</pre>
			<pre class="source-code">#[get("/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</pre>
			<pre class="source-code">fn user&lt;'a&gt;(<strong class="bold">counter: &amp;State&lt;VisitorCounter&gt;, </strong>uuid: &amp;'a str) -&gt; Option&lt;&amp;'a User&gt; {</pre>
			<pre class="source-code">    <strong class="bold">counter.visitor.fetch_add(1, Ordering::Relaxed);</strong></pre>
			<pre class="source-code"><strong class="bold">    println!("The number of visitor is: {}", counter.</strong></pre>
			<pre class="source-code"><strong class="bold">    visitor.load(Ordering::Relaxed));</strong></pre>
			<pre class="source-code">    USERS.get(uuid)</pre>
			<pre class="source-code">}</pre>
			<p>Why do we add the <strong class="source-inline">'a</strong> lifetime? We are adding a new reference argument, and Rust cannot infer which lifetime the returned <strong class="source-inline">&amp;User</strong> should follow. In this case, we are saying the lifetime of the <strong class="source-inline">User</strong> reference should be as long as <strong class="source-inline">uuid</strong>.</p>
			<p>Inside the function, we use the AtomicU64 <strong class="source-inline">fetch_add()</strong> method to increment the value of the visitor, and we print the value using the AtomicU64 <strong class="source-inline">load()</strong> method.</p>
			<p>Let's add the same for the <strong class="source-inline">users()</strong> function, but since we have the exact same routine with the <strong class="source-inline">user()</strong> function, let's make another function instead:</p>
			<pre class="source-code"><strong class="bold">impl VisitorCounter {</strong></pre>
			<pre class="source-code"><strong class="bold">    fn increment_counter(&amp;self) {</strong></pre>
			<pre class="source-code"><strong class="bold">        self.visitor.fetch_add(1, Ordering::Relaxed);</strong></pre>
			<pre class="source-code"><strong class="bold">        println!(</strong></pre>
			<pre class="source-code"><strong class="bold">            "The number of visitor is: {}",</strong></pre>
			<pre class="source-code"><strong class="bold">            self.visitor.load(Ordering::Relaxed)</strong></pre>
			<pre class="source-code"><strong class="bold">        );</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn user&lt;'a&gt;(counter: &amp;State&lt;VisitorCounter&gt;, uuid: &amp;'a str) -&gt; Option&lt;&amp;'a User&gt; {</pre>
			<pre class="source-code">    <strong class="bold">counter.increment_counter();</strong></pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn users&lt;'a&gt;(</pre>
			<pre class="source-code">    <strong class="bold">counter: &amp;State&lt;VisitorCounter&gt;,</strong></pre>
			<pre class="source-code">    name_grade: NameGrade,</pre>
			<pre class="source-code">    filters: Option&lt;Filters&gt;,</pre>
			<pre class="source-code">) -&gt; Result&lt;NewUser&lt;'a&gt;, Status&gt; {</pre>
			<pre class="source-code">    <strong class="bold">counter.increment_counter();</strong></pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>This example works<a id="_idIndexMarker226"/> fine with the <strong class="source-inline">Atomic</strong> type, but if you ever needed a more complex type to work with, such as <strong class="source-inline">String</strong>, <strong class="source-inline">Vec</strong>, or <strong class="source-inline">Struct</strong>, try using <strong class="source-inline">Mutex</strong> or <strong class="source-inline">RwLock</strong> from either the standard library or a third-party crate such as <strong class="source-inline">parking_lot</strong>.</p>
			<p>Now that we know what <strong class="source-inline">State</strong> is in Rocket, let's expand our application by combining it with a database <a id="_idIndexMarker227"/>server. We will use <strong class="source-inline">State</strong> for storing the connection to the database.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/>Working with a database</h1>
			<p>Currently, in our <a id="_idIndexMarker228"/>application, we are storing user data in a static variable. This is very cumbersome, as it is inflexible and we cannot update the data easily. Most modern applications handling data will use some kind of persistent storage, be it filesystem-backed storage, a document-oriented database, or a traditional RDBMS.</p>
			<p>Rust has many libraries to connect to various databases or database-like storage. There's the <strong class="source-inline">postgres</strong> crate, which works as a PostgreSQL client for Rust. There are also other clients such as <strong class="source-inline">mongodb</strong> and <strong class="source-inline">redis</strong>. For <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) and Query Builder, there's <strong class="source-inline">diesel</strong>, which can be used to connect to various database systems. For connection pool<a id="_idIndexMarker229"/> management, there are the <strong class="source-inline">deadpool</strong> and <strong class="source-inline">r2d2</strong> crates. All crates have their strengths and limitations, such as not having an asynchronous application.</p>
			<p>In this book, we're going to use <strong class="source-inline">sqlx</strong> to connect to an RDBMS. <strong class="source-inline">sqlx</strong> claims to be an SQL toolkit for Rust. It has abstractions for clients to connect to various RDBMSs, it has a connection pool trait, and it can also be used to convert types to queries and query responses to Rust types.</p>
			<p>As mentioned in the <em class="italic">Technical requirements</em> section of this chapter, we're going to use PostgreSQL as our RDBMS, so please prepare the connection information to PostgreSQL.</p>
			<p>After that, follow these steps to convert our application into using a database:</p>
			<ol>
				<li>We will reuse our application again. The first thing we want to do is to install <strong class="source-inline">sqlx-cli</strong> by typing this command in the terminal:<p class="source-code"><strong class="bold">cargo install sqlx-cli</strong></p></li>
			</ol>
			<p><strong class="source-inline">sqlx-cli</strong> is a useful command-line application to create a database, create migrations, and run the migrations. It's not as sophisticated as migration tools in other established frameworks, but it does its job very well.</p>
			<ol>
				<li value="2">Prepare the connection information and set the <strong class="source-inline">DATABASE_URL</strong> environment variable in your terminal. The <strong class="source-inline">DATABASE_URL</strong> format should look as follows, depending on<a id="_idIndexMarker230"/> which RDBMS you are using:<p class="source-code">postgres://username:password@localhost:port/db_name?connect_options</p></li>
			</ol>
			<p>For <strong class="source-inline">connect_options</strong>, it's in query form, and the reference can be found at <a href="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING">https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING</a>. Other DATABASE_URL format for other RDBMS might look like:</p>
			<p class="source-code">mysql://username:password@localhost:port/db_name</p>
			<p>Or <strong class="source-inline">sqlite::memory:</strong> or <strong class="source-inline">sqlite://path/to/file.db?connect_options</strong> or <strong class="source-inline">sqlite:///path/to/file.db?connect_options</strong>. The connect options for SQLite can be found at <a href="https://www.sqlite.org/uri.html">https://www.sqlite.org/uri.html</a>.</p>
			<ol>
				<li value="3">Create a new database using this command:<p class="source-code"><strong class="bold">sqlx database create</strong></p></li>
				<li>We can create a migration named <strong class="source-inline">create_users</strong> using this command:<p class="source-code"><strong class="bold">sqlx migrate add create_users</strong></p></li>
				<li>The <strong class="source-inline">sqlx</strong> CLI will create a new folder named <strong class="source-inline">migrations</strong> inside the root directory of our application, and inside the folder, there will be a file with the <strong class="source-inline">timestamp_migration_name.sql</strong> pattern. In our example, the filename will look like <strong class="source-inline">migrations/20210923055406_create_users.sql</strong>. Inside the file, we can write SQL <a id="_idIndexMarker231"/>queries to create or modify the <strong class="bold">data definition layer</strong> (<strong class="bold">DDL</strong>). In this case, we want to make the content the same as the <strong class="source-inline">User</strong> struct, so let's write the following code into the SQL file:<p class="source-code">CREATE TABLE IF NOT EXISTS users</p><p class="source-code">(</p><p class="source-code">    uuid   UUID PRIMARY KEY,</p><p class="source-code">    name   VARCHAR NOT NULL,</p><p class="source-code">    age    SMALLINT NOT NULL DEFAULT 0,</p><p class="source-code">    grade  SMALLINT NOT NULL DEFAULT 0,</p><p class="source-code">    active BOOL NOT NULL DEFAULT TRUE</p><p class="source-code">);</p><p class="source-code">CREATE INDEX name_active_idx ON users(name, active);</p></li>
			</ol>
			<p>How do we know what the mapping between the database column type and Rust type is? <strong class="source-inline">sqlx</strong> provides its own mapping; we can find the documentation at <a href="https://docs.rs/sqlx">https://docs.rs/sqlx</a>. The crate<a id="_idIndexMarker232"/> has great modules for a supported database. We can search for it in the top search bar; for example, we can find the documentation for PostgreSQL in <a href="https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html">https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html</a>. On that page, we can see there are <strong class="source-inline">types</strong> modules that we can look at.</p>
			<ol>
				<li value="6">After we write the content of the migration file, we can run the migration using the following command:<p class="source-code"><strong class="bold">sqlx migrate run</strong></p></li>
				<li>After the migration, check the generated database table and see whether the table schema is correct or not. Let's insert the data from the previous chapter. Also, feel free to fill the table with sample data of your choice.</li>
				<li>After migration, include the <strong class="source-inline">sqlx</strong> crate in our <strong class="source-inline">Cargo.toml</strong> file. We should also include the <strong class="source-inline">uuid</strong> crate as we're going to use PostgreSQL's <strong class="source-inline">uuid</strong> type. Take a look at the API documentation of the crate if you want to enable another RDBMS:<p class="source-code">sqlx = {version = "0.5.7", features = ["postgres", "uuid", "runtime-tokio-rustls"]}</p><p class="source-code">uuid = "0.8.2"</p></li>
				<li>We can delete <strong class="source-inline">lazy_static</strong> from <strong class="source-inline">Cargo.toml</strong> and remove references of <strong class="source-inline">lazy_static!</strong>, <strong class="source-inline">USERS</strong>, and <strong class="source-inline">HashMap</strong> from the <strong class="source-inline">src/main.rs</strong> file. We don't need those, and we are only going to retrieve the <strong class="source-inline">User</strong> data from the database that we inserted earlier. Use the following <strong class="source-inline">SQL INSERT</strong> syntax to insert the previous user data:<p class="source-code">INSERT INTO public.users</p><p class="source-code">(uuid, name, age, grade, active)</p><p class="source-code">VALUES('3e3dd4ae-3c37-40c6-aa64-7061f284ce28'::uuid, 'John Doe', 18, 1, true);</p></li>
				<li>Modify the <strong class="source-inline">User</strong> struct <a id="_idIndexMarker233"/>to follow the database that we've created:<p class="source-code"><strong class="bold">use sqlx::FromRow;</strong></p><p class="source-code"><strong class="bold">use uuid::Uuid;</strong></p><p class="source-code">...</p><p class="source-code">#[derive(Debug<strong class="bold">, FromRow</strong>)]</p><p class="source-code">struct User {</p><p class="source-code"><strong class="bold">    uuid: Uuid,</strong></p><p class="source-code">    name: String,</p><p class="source-code">    age: <strong class="bold">i16</strong>,</p><p class="source-code">    grade: <strong class="bold">i16</strong>,</p><p class="source-code">    active: bool,</p><p class="source-code">}</p></li>
			</ol>
			<p>When <strong class="source-inline">sqlx</strong> retrieves the result from the database, it will be stored in <strong class="source-inline">sqlx::Database::Row</strong>. This type can then be converted to any type that implements <strong class="source-inline">sqlx::FromRow</strong>. Luckily, we can derive <strong class="source-inline">FromRow</strong> as long as all the members implement <strong class="source-inline">sqlx::Decode</strong>. There are a few exceptions that we can use to override <strong class="source-inline">FromRow</strong>. Here is an example:</p>
			<p class="source-code">#[derive(Debug, FromRow)]</p>
			<p class="source-code"><strong class="bold">#[sqlx(rename_all = "camelCase")]</strong></p>
			<p class="source-code">struct User {</p>
			<p class="source-code">    uuid: Uuid,</p>
			<p class="source-code">    name: String,</p>
			<p class="source-code">    age: i16,</p>
			<p class="source-code">    grade: i16,</p>
			<p class="source-code"><strong class="bold">    #[sqlx(rename = "active")]</strong></p>
			<p class="source-code"><strong class="bold">    present: bool,</strong></p>
			<p class="source-code"><strong class="bold">    #[sqlx(default)]</strong></p>
			<p class="source-code"><strong class="bold">    not_in_database: String,</strong></p>
			<p class="source-code">}</p>
			<p>For <strong class="source-inline">rename_all</strong>, we can use these options: <strong class="source-inline">snake_case</strong>, <strong class="source-inline">lowercase</strong>, <strong class="source-inline">UPPERCASE</strong>, <strong class="source-inline">camelCase</strong>, <strong class="source-inline">PascalCase</strong>, <strong class="source-inline">SCREAMING_SNAKE_CASE</strong>, and <strong class="source-inline">kebab-case</strong>.</p>
			<p><strong class="source-inline">rename</strong> is used when we have different column names and type member names. If a member has no column in the database, and that type has the implementation of the <strong class="source-inline">std::default::Default</strong> trait, we can use the <strong class="source-inline">default</strong> directive.</p>
			<p>Why do we use <strong class="source-inline">i16</strong>? The answer is the PostgreSQL type has no mapping to the Rust <strong class="source-inline">u8</strong> type. We can <a id="_idIndexMarker234"/>either use <strong class="source-inline">i8</strong>, use a bigger <strong class="source-inline">i16</strong> type, or try implementing <strong class="source-inline">Decode</strong> for <strong class="source-inline">u8</strong>. In this case, we choose to use the <strong class="source-inline">i16</strong> type.</p>
			<p>We want the program to read the connection information (<strong class="source-inline">DATABASE_URL</strong>) from the environment variable. In <a href="B16825_02_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Our First Rocket Web Application</em>, we learned how to configure Rocket using standard configuration, but this time, we want to add extra configuration. We can start by adding <strong class="source-inline">serde</strong> to application dependencies in <strong class="source-inline">Cargo.toml</strong>.</p>
			<p><strong class="source-inline">serde</strong> is one of the most used and important libraries in Rust. The name comes from <em class="italic">serialization and deserialization</em>. It is used for anything that involves serialization and deserialization. It can be used to convert Rust type instances to bytes representations and<a id="_idIndexMarker235"/> vice versa, to JSON and vice versa, to YAML, and any other type, as long as they implement the <strong class="source-inline">serde</strong> traits. It can also be used to transcode one type that implements <strong class="source-inline">serde</strong> traits to another type that implements <strong class="source-inline">serde</strong> traits.</p>
			<p>If you<a id="_idIndexMarker236"/> want to look at the <strong class="source-inline">serde</strong> documentation, you can find it on their website at <a href="https://serde.rs">https://serde.rs</a>.</p>
			<p>The <strong class="source-inline">serde</strong> documentation mentions many native or third-party supports for many data formats such as JSON, Bincode, CBOR, YAML, MessagePack, TOML, Pickle, RON, BSON, Avro, JSON5, Postcard, URL query strings, Envy, Envy Store, S-expressions, D-Bus's binary wire format, and FlexBuffers.</p>
			<p>Let's add the following lines into <strong class="source-inline">Cargo.toml</strong> to include <strong class="source-inline">serde</strong> in our application:</p>
			<p class="source-code">[dependencies]</p>
			<p class="source-code">...</p>
			<p class="source-code"><strong class="bold">serde = "1.0.130"</strong></p>
			<ol>
				<li value="11">After that, create a struct that will be used to contain our custom configuration:<p class="source-code">use serde::Deserialize;</p><p class="source-code">...</p><p class="source-code">#[derive(Deserialize)]</p><p class="source-code">struct Config {</p><p class="source-code">    database_url: String,</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">serde</strong> already provides the <strong class="source-inline">Deserialize</strong> macro that can be used in the <strong class="source-inline">derive</strong> attribute. So far, we have used a lot of macros providing libraries that can be used in the <strong class="source-inline">derive</strong> attribute, such as <strong class="source-inline">Debug</strong>, <strong class="source-inline">FromRow</strong>, <strong class="source-inline">Deserialize</strong>. The macro<a id="_idIndexMarker237"/> system is one of the important Rust features.</p>
			<ol>
				<li value="12">Implement the routine to read the configuration and map it into the <strong class="source-inline">rocket()</strong> function:<p class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</p><p class="source-code">    let our_rocket = rocket::build();</p><p class="source-code">    let config: Config = our_rocket</p><p class="source-code">        .figment()</p><p class="source-code">        .extract()</p><p class="source-code">        .expect("Incorrect Rocket.toml </p><p class="source-code">         configuration");</p><p class="source-code">    ...</p><p class="source-code">    our_rocket</p><p class="source-code">        .manage(visitor_counter)</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Now that the application can get the <strong class="source-inline">DATABASE_URL</strong> information from environment variables, it's time to initialize the database connection pool and tell Rocket to manage it. Write<a id="_idIndexMarker238"/> the following lines:<p class="source-code"><strong class="bold">use sqlx::postgres::PgPoolOptions;</strong></p><p class="source-code">...</p><p class="source-code"><strong class="bold">async</strong> fn rocket() -&gt; Rocket&lt;Build&gt; {</p><p class="source-code">    ...</p><p class="source-code">    let config: Config = rocket_frame</p><p class="source-code">        .figment()</p><p class="source-code">        .extract()</p><p class="source-code">        .expect("Incorrect Rocket.toml </p><p class="source-code">        configuration");</p><p class="source-code"><strong class="bold">    let pool = PgPoolOptions::new()</strong></p><p class="source-code"><strong class="bold">        .max_connections(5)</strong></p><p class="source-code"><strong class="bold">        .connect(&amp;config.database_url)</strong></p><p class="source-code"><strong class="bold">        .await</strong></p><p class="source-code"><strong class="bold">        .expect("Failed to connect to database");</strong></p><p class="source-code">    ...</p><p class="source-code">    rocket_frame</p><p class="source-code">        .manage(visitor_counter)</p><p class="source-code">        <strong class="bold">.manage(pool)</strong></p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>We initialize the connection pool using <strong class="source-inline">PgPoolOptions</strong>. Other databases can use their corresponding type, such as <strong class="source-inline">sqlx::mysql::MySqlPoolOptions</strong> or <strong class="source-inline">sqlx::sqlite::SqlitePoolOptions</strong>. The <strong class="source-inline">connect()</strong> method is an <strong class="source-inline">async</strong> method, so we must make <strong class="source-inline">rocket()</strong> async as well to be able to use the result.</p>
			<p>After that, inside the <strong class="source-inline">rocket()</strong> function, we tell Rocket to manage the connection pool.</p>
			<ol>
				<li value="14">Before using the database connection, we used <strong class="source-inline">lazy_static</strong> and created <strong class="source-inline">user</strong> objects as<a id="_idIndexMarker239"/> references to the <strong class="source-inline">USERS</strong> hash map. Now, we will use the data from the database, so we need to use concrete objects instead of references. Remove the ampersand (<strong class="source-inline">&amp;</strong>) from the <strong class="source-inline">Responder</strong> implementation for the <strong class="source-inline">User</strong> and <strong class="source-inline">NewUser</strong> structs:<p class="source-code">impl&lt;'r&gt; Responder&lt;'r, 'r&gt; for <strong class="bold">User</strong> { ... }</p><p class="source-code">struct NewUser(Vec&lt;<strong class="bold">User</strong>&gt;);</p><p class="source-code">impl&lt;'r&gt; Responder&lt;'r, 'r&gt; for <strong class="bold">NewUser</strong> { ... }</p></li>
				<li>Now, it's time to implement the <strong class="source-inline">user()</strong> function to use the database connection pool to query from the database. Modify the <strong class="source-inline">user()</strong> function as follows:<p class="source-code"><strong class="bold">async</strong> fn user(</p><p class="source-code">    counter: &amp;State&lt;VisitorCounter&gt;,</p><p class="source-code">    <strong class="bold">pool: &amp;rocket::State&lt;PgPool&gt;,</strong></p><p class="source-code">    uuid: &amp;str,</p><p class="source-code">) -&gt; Result&lt;User, Status&gt; {</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">let parsed_uuid = Uuid::parse_str(uuid)</strong></p><p class="source-code"><strong class="bold">    .map_err(|_| Status::BadRequest)?;</strong></p><p class="source-code"><strong class="bold">    let user = sqlx::query_as!(</strong></p><p class="source-code"><strong class="bold">        User,</strong></p><p class="source-code"><strong class="bold">        "SELECT * FROM users WHERE uuid = $1",</strong></p><p class="source-code"><strong class="bold">        parsed_uuid</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code"><strong class="bold">    .fetch_one(pool.inner())</strong></p><p class="source-code"><strong class="bold">    .await;</strong></p><p class="source-code"><strong class="bold">    user.map_err(|_| Status::NotFound)</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>We included the connection pool managed state in the function arguments. After that, we parsed the<a id="_idIndexMarker240"/> UUID <strong class="source-inline">&amp;str</strong> parameter into the <strong class="source-inline">Uuid</strong> instance. If there's an error parsing the <strong class="source-inline">uuid</strong> parameter, we change the error to <strong class="source-inline">Status::BadRequest</strong> and return the error.</p>
			<p>We then use the <strong class="source-inline">query_as!</strong> macro to send a query to the database server and convert the result to a <strong class="source-inline">User</strong> instance. There are many <strong class="source-inline">sqlx</strong> macros we can use, such as <strong class="source-inline">query!</strong>, <strong class="source-inline">query_file!</strong>, <strong class="source-inline">query_as_unchecked!</strong>, and <strong class="source-inline">query_file_as!</strong>. You can find the documentation for those macros in the <strong class="source-inline">sqlx</strong> API documentation that we mentioned earlier.</p>
			<p>The format to use this macro is as follows: <strong class="source-inline">query_as!(RustType, "prepared statement", bind parameter1, ...)</strong>. If you don't need to get the result as a Rust type, you can use the <strong class="source-inline">query!</strong> macro instead.</p>
			<p>We then use the <strong class="source-inline">fetch_one()</strong> method. If you want to execute instead of query, for example, to update or delete rows, you can use the <strong class="source-inline">execute()</strong> method. If you want to get all the results, you can use the <strong class="source-inline">fetch_all()</strong> method. You can find other methods to use and their documentation in the <strong class="source-inline">sqlx::query::Query</strong> struct documentation.</p>
			<p>We can either keep the <strong class="source-inline">user()</strong> function return as <strong class="source-inline">Option&lt;User&gt;</strong> and use <strong class="source-inline">user.ok()</strong>, or we change the return to <strong class="source-inline">Status::SomeStatus</strong>. Since we change the return type to either <strong class="source-inline">Ok(user)</strong> or <strong class="source-inline">Err(some_error)</strong>, we can just return the <strong class="source-inline">Ok(user)</strong> variant, but we want to use <strong class="source-inline">map_err(|_| Status::NotFound)</strong> to change the error to a <strong class="source-inline">Status</strong> type.</p>
			<p>You might be thinking, if we send raw SQL queries to the server, is it possible to do a SQL injection attack? Is it possible to mistakenly get any user input and execute <strong class="source-inline">sqlx::query_as::&lt;_, User&gt;("SELECT * FROM users WHERE name = ?").bind</strong><strong class="bold">("Name'; DROP TABLE users"</strong><strong class="source-inline">).fetch_one(pool.inner())</strong>?</p>
			<p>The answer is no. <strong class="source-inline">sqlx</strong> prepared and cached each statement. As the result of using a prepared <a id="_idIndexMarker241"/>statement, it's more secure than a regular SQL query, and the type returned is also what we expect from the RDBMS server.</p>
			<ol>
				<li value="16">Let's also change the <strong class="source-inline">users()</strong> function. Like the <strong class="source-inline">user()</strong> function, we want the function to be <strong class="source-inline">async</strong> and get the connection pool from the Rocket managed state. We also want to remove the lifetime from <strong class="source-inline">NewUser</strong> as we are not referencing <strong class="source-inline">USERS</strong> anymore:<p class="source-code"><strong class="bold">async</strong> fn users(</p><p class="source-code">    counter: &amp;State&lt;VisitorCounter&gt;,</p><p class="source-code">    <strong class="bold">pool: &amp;rocket::State&lt;PgPool&gt;,</strong></p><p class="source-code">    name_grade: NameGrade&lt;'_&gt;,</p><p class="source-code">    filters: Option&lt;Filters&gt;,</p><p class="source-code">) -&gt; Result&lt;NewUser, Status&gt; {…}</p></li>
				<li>After that, we can prepare the prepared statement. We append more conditions to <strong class="source-inline">WHERE</strong> if the client sends the <strong class="source-inline">filters</strong> request. For PostgreSQL, the prepared statement uses <strong class="source-inline">$1</strong>, <strong class="source-inline">$2</strong>, and so on, but for other RDBMSs, you can use <strong class="source-inline">?</strong> for the prepared statement:<p class="source-code">...</p><p class="source-code">let mut query_str = String::from("SELECT * FROM users WHERE name LIKE $1 AND grade = $2");</p><p class="source-code">if filters.is_some() {</p><p class="source-code">    query_str.push_str(" AND age = $3 AND active = </p><p class="source-code">    $4");</p><p class="source-code">}</p></li>
				<li>Next, write the code to<a id="_idIndexMarker242"/> execute the query, but the number of bound parameters may change depending on whether filters exist or not; we use the <strong class="source-inline">query_as</strong> function instead so we can use the <strong class="source-inline">if</strong> branching. We also add <strong class="source-inline">%name%</strong> for the name-bound parameter because we use the <strong class="source-inline">LIKE</strong> operator in the SQL statement. We also have to cast the <strong class="source-inline">u8</strong> type to the <strong class="source-inline">i16</strong> type. And, finally, we use the <strong class="source-inline">fetch_all</strong> method to retrieve all the results. The nice thing with the <strong class="source-inline">query_as!</strong> macro and query as function is they both returned <strong class="source-inline">Vec&lt;T&gt;</strong> or not depending on the <strong class="source-inline">fetch_one</strong> or <strong class="source-inline">fetch_all</strong>:<p class="source-code">...</p><p class="source-code">let mut query = sqlx::query_as::&lt;_, User&gt;(&amp;query_str)</p><p class="source-code">    .bind(format!("%{}%", &amp;name_grade.name))</p><p class="source-code">    .bind(name_grade.grade as i16);</p><p class="source-code">if let Some(fts) = &amp;filters {</p><p class="source-code">    query = query.bind(fts.age as i16).bind(fts.</p><p class="source-code">    active);</p><p class="source-code">}</p><p class="source-code">let unwrapped_users = query.fetch_all(pool.inner()).await;</p><p class="source-code">let users: Vec&lt;User&gt; = unwrapped_users.map_err(|_| Status::InternalServerError)?;</p></li>
				<li>We can return the result as usual:<p class="source-code">...</p><p class="source-code">if users.is_empty() {</p><p class="source-code">    Err(Status::NotFound)</p><p class="source-code">} else {</p><p class="source-code">    Ok(NewUser(users))</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, let's try calling the <strong class="source-inline">user()</strong> and <strong class="source-inline">users()</strong> endpoints again. It should work as it did when we used <strong class="source-inline">HashMap</strong>. Since we <a id="_idIndexMarker243"/>didn't modify the connection options after we wrote <strong class="source-inline">connect()</strong> on the connection pool, the SQL output is written on the terminal:</p>
			<p class="source-code">/* SQLx ping */; rows: 0, elapsed: 944.711µs</p>
			<p class="source-code">SELECT * FROM users …; rows: 1, elapsed: 11.187ms</p>
			<p class="source-code">SELECT</p>
			<p class="source-code">  *</p>
			<p class="source-code">FROM</p>
			<p class="source-code">  users</p>
			<p class="source-code">WHERE</p>
			<p class="source-code">  uuid = $1</p>
			<p>Here is some more of the output:</p>
			<p class="source-code">/* SQLx ping */; rows: 0, elapsed: 524.114µs</p>
			<p class="source-code">SELECT * FROM users …; rows: 1, elapsed: 2.435ms</p>
			<p class="source-code">SELECT</p>
			<p class="source-code">  *</p>
			<p class="source-code">FROM</p>
			<p class="source-code">  users</p>
			<p class="source-code">WHERE</p>
			<p class="source-code">  name LIKE $1</p>
			<p class="source-code">  AND grade = $2</p>
			<p>In this book, we are<a id="_idIndexMarker244"/> not going to use ORM; instead, we are going to use <strong class="source-inline">sqlx</strong> only, as it is enough for the scope of this book. If you want to use ORM in your application, you can use ORM and query builders from <a href="https://github.com/NyxCode/ormx">https://github.com/NyxCode/ormx</a> or <a href="https://www.sea-ql.org/SeaORM/">https://www.sea-ql.org/SeaORM/</a>.</p>
			<p>Now that we have learned about <strong class="source-inline">State</strong> and how to use databases using <strong class="source-inline">State</strong>, it is time to learn about another Rocket middleware capability, attaching fairings.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/>Attaching Rocket fairings</h1>
			<p>In real life, a rocket fairing is a nose cone used to protect the rocket payload. In the Rocket framework, a <a id="_idIndexMarker245"/>fairing is not used to protect the payload but is instead used to hook in to any part of the request life cycle and rewrite the payload. Fairings are analogous to middleware in other web frameworks but with few differences.</p>
			<p>Other framework middleware may be able to inject any arbitrary data. In Rocket, the fairing can be used to modify the request but cannot be used to add information that is not part of the request. For example, we can use fairings to add a new HTTP header in the requests or responses.</p>
			<p>Some web frameworks might be able to terminate and directly respond to incoming requests, but in Rocket, the fairings cannot stop the incoming requests directly; the request must go through the route handling function, and then the route can create the proper response.</p>
			<p>We can create a fairing by implementing <strong class="source-inline">rocket::fairing::Fairing</strong> for a type. Let's first see the signature of the trait:</p>
			<pre class="source-code"> #[crate::async_trait]</pre>
			<pre class="source-code">pub trait Fairing: Send + Sync + Any + 'static {</pre>
			<pre class="source-code">    fn info(&amp;self) -&gt; Info;</pre>
			<pre class="source-code">    async fn on_ignite(&amp;self, rocket: Rocket&lt;Build&gt;) -&gt;</pre>
			<pre class="source-code">    Result { Ok(rocket) }</pre>
			<pre class="source-code">    async fn on_liftoff(&amp;self, _rocket: &amp;Rocket&lt;Orbit&gt;) { }</pre>
			<pre class="source-code">    async fn on_request(&amp;self, _req: &amp;mut Request&lt;'_&gt;, </pre>
			<pre class="source-code">    _data: &amp;mut Data&lt;'_&gt;) {}</pre>
			<pre class="source-code">    async fn on_response&lt;'r&gt;(&amp;self, _req: &amp;'r Request&lt;'_&gt;, </pre>
			<pre class="source-code">    _res: &amp;mut Response&lt;'r&gt;) {}</pre>
			<pre class="source-code">}</pre>
			<p>There are a couple <a id="_idIndexMarker246"/>of types we are not familiar with, such as <strong class="source-inline">Build</strong> and <strong class="source-inline">Orbit</strong>. These types are related to phases in Rocket.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>Rocket phases</h2>
			<p>The types that we want to<a id="_idIndexMarker247"/> discuss are <strong class="source-inline">Build</strong> and <strong class="source-inline">Orbit</strong>, with the full module paths of <strong class="source-inline">rocket::Orbit</strong> and <strong class="source-inline">rocket::Build</strong>. What are these types? The signature for a Rocket instance is <strong class="source-inline">Rocket&lt;P: Phase&gt;</strong>, which means any <strong class="source-inline">P</strong> type that implements <strong class="source-inline">rocket::Phase</strong>.</p>
			<p><strong class="source-inline">Phase</strong> is a <strong class="bold">sealed trait</strong>, which means <a id="_idIndexMarker248"/>no other type outside the crate can implement this trait. We can define a sealed trait as follows: <strong class="source-inline">pub trait SomeTrait: private::Sealed {}</strong>.</p>
			<p>The <strong class="source-inline">Phase</strong> trait is sealed because Rocket authors intended only three phases in the Rocket application: <strong class="source-inline">rocket::Build</strong>, <strong class="source-inline">rocket::Ignite</strong>, and <strong class="source-inline">rocket::Orbit</strong>.</p>
			<p>We initialize a Rocket instance through <strong class="source-inline">rocket::build()</strong>, which uses the <strong class="source-inline">Config::figment()</strong>default, or <strong class="source-inline">rocket::custom&lt;T: Provider&gt;(provider: T)</strong>, which uses the custom configuration provider. In this phase, we can also chain the generated instance with custom configuration using <strong class="source-inline">configure&lt;T: Provider&gt;(self, provider: T)</strong>. We can then add a route using <strong class="source-inline">mount()</strong>, register a catcher using <strong class="source-inline">register()</strong>, manage the states using <strong class="source-inline">manage()</strong>, and attach fairings using <strong class="source-inline">attach()</strong>.</p>
			<p>After that, we can change the Rocket phase to <strong class="source-inline">Ignite</strong> through the <strong class="source-inline">ignite()</strong> method. In this phase, we have a Rocket instance with the final configuration. We can then send the Rocket to the <strong class="source-inline">Orbit</strong> phase through the <strong class="source-inline">launch()</strong> method or return <strong class="source-inline">Rocket&lt;Build&gt;</strong> and use the <strong class="source-inline">#[launch]</strong> attribute. We can also skip the <strong class="source-inline">Ignite</strong> phase and use <strong class="source-inline">launch()</strong> directly after <strong class="source-inline">build()</strong>.</p>
			<p>Let's recall the code that we<a id="_idIndexMarker249"/> have created up to now:</p>
			<pre class="source-code"><strong class="bold">#[launch]</strong></pre>
			<pre class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    let our_rocket = rocket::<strong class="bold">build();</strong></pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    our_rocket</pre>
			<pre class="source-code">        <strong class="bold">.manage(</strong>visitor_counter<strong class="bold">)</strong></pre>
			<pre class="source-code">        <strong class="bold">.manage(</strong>pool<strong class="bold">)</strong></pre>
			<pre class="source-code">        <strong class="bold">.mount(</strong>"/", routes![user, users, favicon]<strong class="bold">)</strong></pre>
			<pre class="source-code">        <strong class="bold">.register(</strong>"/", catchers![not_found, forbidden]<strong class="bold">)</strong></pre>
			<pre class="source-code">}</pre>
			<p>This function generates <strong class="source-inline">Rocket&lt;Build&gt;</strong>, and the <strong class="source-inline">#[launch]</strong> attribute generates the code that uses <strong class="source-inline">launch()</strong>.</p>
			<p>The conclusion for this subsection is that the Rocket phase goes from <strong class="source-inline">Build</strong> to <strong class="source-inline">Ignite</strong> to <strong class="source-inline">Launch</strong>. How are those phases related to fairing? Let's discuss this in the next subsection.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>Fairing callbacks</h2>
			<p>Any type implementing fairings <a id="_idIndexMarker250"/>must implement one mandatory function, <strong class="source-inline">info()</strong>, which returns <strong class="source-inline">rocket::fairing::Info</strong>. The <strong class="source-inline">Info</strong> struct is defined as follows:</p>
			<pre class="source-code">pub struct Info {</pre>
			<pre class="source-code">    pub name: &amp;'static str,</pre>
			<pre class="source-code">    pub kind: Kind,</pre>
			<pre class="source-code">}</pre>
			<p>And, <strong class="source-inline">rocket::fairing::Kind</strong> is defined as just an empty struct, <strong class="source-inline">pub struct Kind(_);</strong>, but <strong class="source-inline">Kind</strong> has the <strong class="bold">associated constants</strong> of <strong class="source-inline">Kind::Ignite</strong>, <strong class="source-inline">Kind::Liftoff</strong>, <strong class="source-inline">Kind::Request</strong>, <strong class="source-inline">Kind::Response</strong>, and <strong class="source-inline">Kind::Singleton</strong>.</p>
			<p>What are associated<a id="_idIndexMarker251"/> constants? In Rust, we can <a id="_idIndexMarker252"/>declare <strong class="bold">associated items</strong>, which are items declared in<a id="_idIndexMarker253"/> traits or defined in implementations. For example, we have this piece of code:</p>
			<pre class="source-code">struct Something {</pre>
			<pre class="source-code">    item: u8</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">impl Something {</pre>
			<pre class="source-code">    fn new() -&gt; Something {</pre>
			<pre class="source-code">        Something {</pre>
			<pre class="source-code">            item: 8,</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We can use the <strong class="source-inline">Something::new()</strong> <strong class="bold">associated function</strong> to<a id="_idIndexMarker254"/> create a new instance of the type. There are also <strong class="bold">associated methods</strong>, just like associated functions <a id="_idIndexMarker255"/>but with <strong class="source-inline">self</strong> as the first parameter. We have already implemented an associated method a couple of times.</p>
			<p>We can also<a id="_idIndexMarker256"/> define an <strong class="bold">associated type</strong> as follows:</p>
			<pre class="source-code">trait SuperTrait {</pre>
			<pre class="source-code">    type Super;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">struct Something;</pre>
			<pre class="source-code">struct Some;</pre>
			<pre class="source-code">impl SuperTrait for Something {</pre>
			<pre class="source-code">    type Super = Some;</pre>
			<pre class="source-code">}</pre>
			<p>And, finally, we can have <a id="_idIndexMarker257"/>an <strong class="bold">associated constant</strong>. Let's take a look at how we can define an associated constant by looking at an example, the simplified source of <strong class="source-inline">rocket::fairing::Kind</strong>:</p>
			<pre class="source-code">pub struct Kind(usize);</pre>
			<pre class="source-code">impl Kind {</pre>
			<pre class="source-code">    pub const Ignite: Kind = Kind(1 &lt;&lt; 0);</pre>
			<pre class="source-code">    pub const Liftoff: Kind = Kind(1 &lt;&lt; 1);</pre>
			<pre class="source-code">    pub const Request: Kind = Kind(1 &lt;&lt; 2);</pre>
			<pre class="source-code">    pub const Response: Kind = Kind(1 &lt;&lt; 3);</pre>
			<pre class="source-code">    pub const Singleton: Kind = Kind(1 &lt;&lt; 4);</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>Let's go back to <strong class="source-inline">Info</strong>. We <a id="_idIndexMarker258"/>can make an <strong class="source-inline">Info</strong> instance as follows:</p>
			<pre class="source-code">Info {</pre>
			<pre class="source-code">    name: "Request Response Tracker",</pre>
			<pre class="source-code">    kind: Kind::Request | Kind::Response,</pre>
			<pre class="source-code">}</pre>
			<p>We are saying the value for <strong class="source-inline">kind</strong> is the result of the <strong class="source-inline">OR</strong> bitwise operation between the<strong class="source-inline"> kind</strong> associated constants. <strong class="source-inline">Kind::Request</strong> is <strong class="source-inline">1&lt;&lt;2</strong>, which means <strong class="source-inline">100</strong> in binary or <strong class="source-inline">4</strong> in decimal. <strong class="source-inline">Kind::Response</strong> is <strong class="source-inline">1&lt;&lt;3</strong>, which means <strong class="source-inline">1000</strong> in binary or <strong class="source-inline">8</strong> in decimal. The result of <strong class="source-inline">0100 | 1000</strong> is <strong class="source-inline">1100</strong> in binary or <strong class="source-inline">12</strong> in decimal. With this knowledge, we can set the value for the <strong class="source-inline">Info</strong> instance, <strong class="source-inline">kind</strong>, from <strong class="source-inline">00000</strong> to <strong class="source-inline">11111</strong>.</p>
			<p>Setting configuration using bitwise is a very common design pattern for packing multiple values into one variable. Some other languages <a id="_idIndexMarker259"/>even make this design pattern into its own type and call it <strong class="bold">bitset</strong>.</p>
			<p>In a type that implements the <strong class="source-inline">Fairing</strong> trait, the mandatory method implementation is <strong class="source-inline">info()</strong>, which returns the <strong class="source-inline">Info</strong> instance. We also have to implement <strong class="source-inline">on_ignite()</strong>, <strong class="source-inline">on_liftoff()</strong>, <strong class="source-inline">on_request()</strong>, and <strong class="source-inline">on_response()</strong> depending on the <strong class="source-inline">kind</strong> instance that we defined. In our case, this means we have to implement <strong class="source-inline">on_request()</strong> and <strong class="source-inline">on_response()</strong>.</p>
			<p>Rocket executes our fairing method on different occasions. If we have <strong class="source-inline">on_ignite()</strong>, it will be executed before launch. This type of fairing is special as <strong class="source-inline">on_ignite()</strong> returns <strong class="source-inline">Result</strong>, and if the returned variant is <strong class="source-inline">Err</strong>, it can abort the launch.</p>
			<p>For <strong class="source-inline">on_liftoff()</strong>, this method will be executed after launch, which means when Rocket is in the <strong class="source-inline">Orbit</strong> phase.</p>
			<p>If we have <strong class="source-inline">on_request()</strong>, it <a id="_idIndexMarker260"/>will be executed after Rocket gets the request but before the request is routed. This method will have access to <strong class="source-inline">Request</strong> and <strong class="source-inline">Data</strong>, which means we can modify these two items.</p>
			<p>And, <strong class="source-inline">on_response()</strong> will be executed when the route handler has created the response but before the response is sent to the HTTP client. This callback has access to the <strong class="source-inline">Request</strong> and <strong class="source-inline">Response</strong> instances.</p>
			<p><strong class="source-inline">Kind::Singleton</strong> is special. We can create multiple instances of fairings of the same type and attach them to Rocket. But, maybe we only want to allow one instance of the <strong class="source-inline">Fairing</strong> implementing type to be added. We can use <strong class="source-inline">Kind::Singleton</strong> and it will make sure only the last attached instance of this type will be added.</p>
			<p>Now that we know more about Rocket phases and <strong class="source-inline">Fairing</strong> callbacks, let's implement the <strong class="source-inline">Fairing</strong> trait in the next subsection.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Implementing and attaching fairings</h2>
			<p>Right now, our <a id="_idIndexMarker261"/>Rocket application manages <strong class="source-inline">VisitorCounter</strong>, but we did not add <strong class="source-inline">State&lt;VisitorCounter&gt;</strong> to the <strong class="source-inline">favicon()</strong> function. We might also want to<a id="_idIndexMarker262"/> add new route handling functions, but adding <strong class="source-inline">State&lt;VisitorCounter&gt;</strong> as an argument parameter for every route handling function is cumbersome.</p>
			<p>We can change <strong class="source-inline">VisitorCounter</strong> from a managed state into a fairing. At the same time, let's imagine that we have another requirement in our application. We want to have a custom header for the request and response for internal logging purposes. We can do it by adding another fairing to change the incoming requests and responses.</p>
			<p>First, let's organize our module usage a little bit. We need to add the fairing-related modules, <strong class="source-inline">rocket::http::Header</strong>, <strong class="source-inline">rocket::Build</strong>, and <strong class="source-inline">rocket::Orbit</strong>, so we can use those for our <strong class="source-inline">VisitorCounter</strong> fairing and another fairing to modify the requests and <a id="_idIndexMarker263"/>responses:</p>
			<pre class="source-code"><strong class="bold">use rocket::fairing::{self, Fairing, Info, Kind};</strong></pre>
			<pre class="source-code">use rocket::fs::{relative, NamedFile};</pre>
			<pre class="source-code">use rocket::http::{ContentType, <strong class="bold">Header</strong>, Status};</pre>
			<pre class="source-code">use rocket::request::{FromParam, Request};</pre>
			<pre class="source-code">use rocket::response::{self, Responder, Response};</pre>
			<pre class="source-code">use rocket::{<strong class="bold">Build</strong>, Data, <strong class="bold">Orbit</strong>, Rocket, <strong class="bold">State</strong>};</pre>
			<p>Add the <strong class="source-inline">Fairing</strong> trait<a id="_idIndexMarker264"/> implementation for <strong class="source-inline">VisitorCounter</strong>. We need to decorate the <strong class="source-inline">impl</strong> with <strong class="source-inline">#[rocket::async_trait]</strong>, since this trait is an <strong class="source-inline">async</strong> trait:</p>
			<pre class="source-code">#[rocket::async_trait]</pre>
			<pre class="source-code">impl Fairing for VisitorCounter {</pre>
			<pre class="source-code">    fn info(&amp;self) -&gt; Info {</pre>
			<pre class="source-code">        Info {</pre>
			<pre class="source-code">            name: "Visitor Counter",</pre>
			<pre class="source-code">            kind: Kind::Ignite | Kind::Liftoff | Kind::</pre>
			<pre class="source-code">            Request,</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We added the <strong class="source-inline">info()</strong> mandatory method, which returned the <strong class="source-inline">Info</strong> instance. Inside the <strong class="source-inline">Info</strong> instance, we only really need <strong class="source-inline">Kind::Request</strong> as we only need to increment the visitor counter for every incoming request. But this time, we also added <strong class="source-inline">Kind::Ignite</strong> and <strong class="source-inline">Kind::Liftoff</strong> because we want to see when the callback is executed.</p>
			<p>Then, we can add the <a id="_idIndexMarker265"/>callbacks inside the <strong class="source-inline">impl Fairing</strong> block:</p>
			<pre class="source-code">async fn on_ignite(&amp;self, rocket: Rocket&lt;Build&gt;) -&gt; fairing::Result {</pre>
			<pre class="source-code">    println!("Setting up visitor counter");</pre>
			<pre class="source-code">    Ok(rocket)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">async fn on_liftoff(&amp;self, _: &amp;Rocket&lt;Orbit&gt;) {</pre>
			<pre class="source-code">    println!("Finish setting up visitor counter");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">async fn on_request(&amp;self, _: &amp;mut Request&lt;'_&gt;, _: &amp;mut Data&lt;'_&gt;) {</pre>
			<pre class="source-code">    self.increment_counter();</pre>
			<pre class="source-code">}</pre>
			<p>What is the return<a id="_idIndexMarker266"/> type on the <strong class="source-inline">on_ignite()</strong> method? <strong class="source-inline">rocket::fairing::Result</strong> is defined as <strong class="source-inline">Result&lt;T = Rocket&lt;Build&gt;, E = Rocket&lt;Build&gt;&gt; = Result&lt;T, E&gt;</strong>. This method is used to control whether the program continues or not. For example, we can check the connection to a third-party server to ensure its readiness. If the third-party server is ready to accept connections, we can return <strong class="source-inline">Ok(rocket)</strong>. But, if the third-party server is not available, we can return <strong class="source-inline">Err(rocket)</strong> to halt the launch of Rocket. Notice that <strong class="source-inline">on_liftoff()</strong>, <strong class="source-inline">on_request()</strong>, and <strong class="source-inline">on_response()</strong> do not have a return type, as <strong class="source-inline">Fairing</strong> is designed to only fail when we build Rocket.</p>
			<p>For <strong class="source-inline">on_liftoff()</strong>, we just want to print something to the application output. For <strong class="source-inline">on_request()</strong>, we undertake the real purpose of this fairing: increase the counter for every request.</p>
			<p>After implementing the <strong class="source-inline">Fairing</strong> trait, we can remove <strong class="source-inline">counter: &amp;State&lt;VisitorCounter&gt;</strong> from the <strong class="source-inline">user()</strong> and <strong class="source-inline">users()</strong> function arguments. We also need to remove <strong class="source-inline">counter.increment_counter();</strong> from the body of those functions.</p>
			<p>After we have modified the <strong class="source-inline">user()</strong> and <strong class="source-inline">users()</strong> functions, we can attach the fairing to the Rocket application. Change <strong class="source-inline">manage(visitor_counter)</strong> to <strong class="source-inline">attach(visitor_counter)</strong> in the Rocket initialization code.</p>
			<p>Time to see the fairing in action! First, take a look at the initialization sequence. You can see <strong class="source-inline">on_ignite()</strong> is<a id="_idIndexMarker267"/> executed in the beginning, and <strong class="source-inline">on_liftoff()</strong> is executed after everything is ready: <a id="_idIndexMarker268"/></p>
			<p class="source-code">&gt; cargo run</p>
			<p class="source-code">...</p>
			<p class="source-code">Setting up visitor counter</p>
			<p class="source-code"><img src="image/011.png" alt=""/> Configured for debug.</p>
			<p class="source-code">...</p>
			<p class="source-code"><img src="image/021.png" alt=""/> Fairings:</p>
			<p class="source-code">   &gt;&gt; Visitor Counter (ignite, liftoff, request)</p>
			<p class="source-code">...</p>
			<p class="source-code">Finish setting up visitor counter</p>
			<p class="source-code"><img src="image/033.png" alt=""/> Rocket has launched from http://127.0.0.1:8000</p>
			<p>After that, try calling our route handling function again to see the counter increase again:</p>
			<p class="source-code">&gt; curl http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28</p>
			<p>And, in the Rocket output, we can see it increase when we use it as a state:</p>
			<p class="source-code">The number of visitor is: 2</p>
			<p>Now, let's implement our second use case, injecting a tracing ID to our requests and responses.</p>
			<p>First, modify <strong class="source-inline">Cargo.toml</strong> to ensure the <strong class="source-inline">uuid</strong> crate can generate a random UUID:</p>
			<pre class="source-code">uuid = {version = "0.8.2", features = ["v4"]}</pre>
			<p>After that, inside <strong class="source-inline">src/main.rs</strong>, we can define the header name we want to inject and a type that works as the fairing:</p>
			<pre class="source-code">const X_TRACE_ID: &amp;str = "X-TRACE-ID";</pre>
			<pre class="source-code">struct XTraceId {}</pre>
			<p>Afterward, we can<a id="_idIndexMarker269"/> implement the <strong class="source-inline">Fairing</strong> trait for <strong class="source-inline">XtraceId</strong>. This time, we<a id="_idIndexMarker270"/> want to have <strong class="source-inline">on_request()</strong> and <strong class="source-inline">on_response()</strong> callbacks:</p>
			<pre class="source-code">#[rocket::async_trait]</pre>
			<pre class="source-code">impl Fairing for XTraceId {</pre>
			<pre class="source-code">    fn info(&amp;self) -&gt; Info {</pre>
			<pre class="source-code">        Info {</pre>
			<pre class="source-code">            name: "X-TRACE-ID Injector",</pre>
			<pre class="source-code">            kind: Kind::Request | Kind::Response,</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Now, write the <strong class="source-inline">on_request()</strong> and <strong class="source-inline">on_response()</strong> implementations inside the <strong class="source-inline">impl Fairing</strong> block:</p>
			<pre class="source-code">async fn on_request(&amp;self, req: &amp;mut Request&lt;'_&gt;, _: &amp;mut Data&lt;'_&gt;) {</pre>
			<pre class="source-code">    let header = Header::new(X_TRACE_ID, </pre>
			<pre class="source-code">    Uuid::new_v4().to_hyphenated().to_string());</pre>
			<pre class="source-code">    req.add_header(header);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">async fn on_response&lt;'r&gt;(&amp;self, req: &amp;'r Request&lt;'_&gt;, res: &amp;mut Response&lt;'r&gt;) {</pre>
			<pre class="source-code">    let header = req.headers().get_one(X_TRACE_ID).</pre>
			<pre class="source-code">    unwrap();</pre>
			<pre class="source-code">    res.set_header(Header::new(X_TRACE_ID, header));</pre>
			<pre class="source-code">}</pre>
			<p>In <strong class="source-inline">on_request()</strong>, we generate a random UUID and inject the resulting string as one of the request headers. In <strong class="source-inline">on_response()</strong>, we inject the response with the same header from the request.</p>
			<p>Don't forget to<a id="_idIndexMarker271"/> initialize and attach this new fairing to the Rocket build and<a id="_idIndexMarker272"/> launch process:</p>
			<pre class="source-code"><strong class="bold">let x_trace_id = XTraceId {};</strong></pre>
			<pre class="source-code">our_rocket</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    .attach(visitor_counter)</pre>
			<pre class="source-code">    <strong class="bold">.attach(x_trace_id)</strong></pre>
			<pre class="source-code">    ...</pre>
			<p>Rerun the application. We should have a new fairing in the application output and <strong class="source-inline">"x-trace-id"</strong> in the HTTP response:</p>
			<p class="source-code">...</p>
			<p class="source-code"><img src="image/022.png" alt=""/> Fairings:</p>
			<p class="source-code">   &gt;&gt; X-TRACE-ID Injector (request, response)</p>
			<p class="source-code">   &gt;&gt; Visitor Counter (ignite, liftoff, request)</p>
			<p class="source-code">...</p>
			<p>Here is another example:</p>
			<p class="source-code">curl -v http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt; x-trace-id: 28c0d523-13cc-4132-ab0a-3bb9ae6153a9</p>
			<p class="source-code">...</p>
			<p>Please note that we can use both <strong class="source-inline">State</strong> and <strong class="source-inline">Fairing</strong> in our application. Only use <strong class="source-inline">Fairing</strong> if we need to call this for every request.</p>
			<p>Previously, we <a id="_idIndexMarker273"/>created a connection pool and told Rocket to manage it using managed state but Rocket already has a way to connect to the database<a id="_idIndexMarker274"/> via its built-in database connection, <strong class="source-inline">rocket_db_pools</strong>, which is a type of fairings. Let's see how we can do it in the next part.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Connecting to a database using rocket_db_pools</h2>
			<p>Rocket provided a <em class="italic">sanctioned</em> way to <a id="_idIndexMarker275"/>connect to some RDBMSs by using <strong class="source-inline">rocket_db_pools</strong>. That crate provides the database driver integration for Rocket. We are going to learn how to use this crate for connecting<a id="_idIndexMarker276"/> to the database. Let's change the connection pool that we made previously from using state into using fairings:</p>
			<ol>
				<li value="1">We don't need <strong class="source-inline">serde</strong>, as <strong class="source-inline">rocket_db_pools</strong> already has its own configuration. Remove <strong class="source-inline">serde</strong> from <strong class="source-inline">Cargo.toml</strong> and add <strong class="source-inline">rocket_db_pools</strong> as a dependency:<p class="source-code">[dependencies]</p><p class="source-code">rocket = "0.5.0-rc.1"</p><p class="source-code"><strong class="bold">rocket_db_pools = {version = "0.5.0-rc.1", features = ["sqlx_postgres"]}</strong></p><p class="source-code">...</p></li>
			</ol>
			<p>You can also use different features such as <strong class="source-inline">sqlx_mysql</strong>, <strong class="source-inline">sqlx_sqlite</strong>, <strong class="source-inline">sqlx_mssql</strong>, <strong class="source-inline">deadpool_postgres</strong>, <strong class="source-inline">deadpool_redis</strong>, or <strong class="source-inline">mongodb</strong>.</p>
			<ol>
				<li value="2">In <strong class="source-inline">Rocket.toml</strong>, remove the line containing the <strong class="source-inline">database_url</strong> configuration and replace it with these lines:<p class="source-code">[debug.databases.main_connection]</p><p class="source-code">url = "postgres://username:password@localhost/rocket"</p></li>
			</ol>
			<p>You can use <strong class="source-inline">default.databases.main_connection</strong> if you like, and you can also change <strong class="source-inline">main_connection</strong> to whatever name you see fit.</p>
			<ol>
				<li value="3">In the Cargo <a id="_idIndexMarker277"/>library project, we can<a id="_idIndexMarker278"/> re-export something in <strong class="source-inline">our_library</strong> using the <strong class="source-inline">pub use something;</strong> syntax, and another library can then use that through <strong class="source-inline">our_library::something</strong>. Remove these <strong class="source-inline">use sqlx...</strong> and <strong class="source-inline">use serde...</strong> lines, as <strong class="source-inline">rocket_db_pools</strong> already re-exported <strong class="source-inline">sqlx</strong> and we don't need <strong class="source-inline">serde</strong> anymore:<p class="source-code">use serde::Deserialize;</p><p class="source-code">...</p><p class="source-code">use sqlx::postgres::{PgPool, PgPoolOptions};</p><p class="source-code">use sqlx::FromRow;</p></li>
				<li>Add the following lines to use <strong class="source-inline">rocket_db_pools</strong>. Notice that we can multiline the <strong class="source-inline">use</strong> declaration in the code:<p class="source-code">use rocket_db_pools::{</p><p class="source-code">    sqlx,</p><p class="source-code">    sqlx::{FromRow, PgPool},</p><p class="source-code">    Connection, Database,</p><p class="source-code">};</p></li>
				<li>Delete the struct <strong class="source-inline">Config</strong> declaration and add the following lines to declare the database connection type:<p class="source-code">#[derive(Database)]</p><p class="source-code">#[database("main_connection")]</p><p class="source-code">struct DBConnection(PgPool);</p></li>
			</ol>
			<p>The database derives an automatically generated <strong class="source-inline">rocket_db_pools::Database</strong> implementation for the <strong class="source-inline">DBConnection</strong> type. Notice that we wrote the connection name <strong class="source-inline">"main_connection"</strong>, just like what we have set in <strong class="source-inline">Rocket.toml</strong>.</p>
			<ol>
				<li value="6">Remove the <a id="_idIndexMarker279"/>config and<a id="_idIndexMarker280"/> connection pool initializations in the <strong class="source-inline">rocket()</strong> function:<p class="source-code">let config: Config = our_rocket</p><p class="source-code">    .figment()</p><p class="source-code">    .extract()</p><p class="source-code">    .expect("Incorrect Rocket.toml configuration");</p><p class="source-code">let pool = PgPoolOptions::new()</p><p class="source-code">    .max_connections(5)</p><p class="source-code">    .connect(&amp;config.database_url)</p><p class="source-code">    .await</p><p class="source-code">    .expect("Failed to connect to database");</p></li>
				<li>Add <strong class="source-inline">DBConnection::init()</strong> inside the <strong class="source-inline">rocket()</strong> function and attach it to Rocket:<p class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</p><p class="source-code">    ...</p><p class="source-code">    rocket::build()</p><p class="source-code">        <strong class="bold">.attach(DBConnection::init())</strong></p><p class="source-code">        .attach(visitor_counter)</p><p class="source-code">        ...</p><p class="source-code">}</p></li>
				<li>Change<a id="_idIndexMarker281"/> the <strong class="source-inline">user()</strong> and <strong class="source-inline">users()</strong> functions to use the <strong class="source-inline">rocket_db_pools::Connection</strong> request<a id="_idIndexMarker282"/> guard:<p class="source-code">async fn user(<strong class="bold">mut db: Connection&lt;DBConnection&gt;,</strong> uuid: &amp;str) -&gt; Result&lt;User, Status&gt; {</p><p class="source-code">    ...</p><p class="source-code">    let user = sqlx::query_as!(User, "SELECT * FROM </p><p class="source-code">    users WHERE uuid = $1", parsed_uuid)</p><p class="source-code">        .fetch_one<strong class="bold">(&amp;mut *db</strong>)</p><p class="source-code">        .await;</p><p class="source-code">    ...</p><p class="source-code">}</p><p class="source-code">...</p><p class="source-code">#[get("/users/&lt;name_grade&gt;?&lt;filters..&gt;")]</p><p class="source-code">async fn users(</p><p class="source-code">    <strong class="bold">mut db: Connection&lt;DBConnection&gt;,</strong></p><p class="source-code">    ...</p><p class="source-code">) -&gt; Result&lt;NewUser, Status&gt; {</p><p class="source-code">    ...</p><p class="source-code">    let unwrapped_users = query.fetch_all<strong class="bold">(&amp;mut </strong></p><p class="source-code"><strong class="bold">    *db</strong>).await;</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>The application should work just like when we managed the connection pool using state, but with minor differences. Here's the output we see:</p>
			<p class="source-code"><img src="image/023.png" alt=""/> Fairings:</p>
			<p class="source-code">   ...</p>
			<p class="source-code">   &gt;&gt; 'main_connection' Database Pool (ignite)</p>
			<p>We can see<a id="_idIndexMarker283"/> there's a new fairing in the <a id="_idIndexMarker284"/>application output but there is no prepared SQL statement in the application output.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>Summary</h1>
			<p>In this chapter, we learned about two Rocket components, <strong class="source-inline">State</strong> and <strong class="source-inline">Fairing</strong>. We can manage state objects and attach fairings upon building rockets, use the <strong class="source-inline">state</strong> objects in route handling functions, and use the <strong class="source-inline">fairing</strong> functions to execute callbacks on the build, after launch, on request, and on response.</p>
			<p>We also created counter states and used them in the route handling functions. We also learned how to use <strong class="source-inline">sqlx</strong>, made a database migration, made a database connection pool state, and used <strong class="source-inline">state</strong> to query the database.</p>
			<p>Afterward, we learned more about the Rocket initialization process and the building, igniting, and launching phases.</p>
			<p>Finally, we changed the counter state into a fairing and created a new fairing to inject a custom HTTP header into the incoming requests and outgoing responses.</p>
			<p>Armed with that knowledge, you can create reusable objects between route handling functions, and create a method that can be executed globally between requests and responses.</p>
			<p>Our <strong class="source-inline">src/main.rs</strong> file is getting bigger and more complicated; we will learn how to manage our Rust code in modules and plan a more complex application in the next chapter.</p>
		</div>
	</body></html>