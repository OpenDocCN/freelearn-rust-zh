<html><head></head><body>
		<div><h1 id="_idParaDest-63"><em class="italic"><a id="_idTextAnchor063"/>Chapter 4</em>: Building, Igniting, and Launching Rocket</h1>
			<p>Many web applications require some kind of object management that can be reused again and again, be it a connection pool for a database server, a connection to a memory store, an HTTP client to third-party servers, or any other object. Another common feature in a web application is <strong class="bold">middleware</strong>.</p>
			<p>In this chapter, we will discuss two Rocket features (state and fairings), which act as the reusable object management and middleware parts of Rocket. We will also learn how to create and use connections to database servers, which is very important in almost all web applications.</p>
			<p>After completing this chapter, we expect you to be able to use and implement the reusable object management and middleware parts of the Rocket web framework. We also expect you to be able to connect to a database of your own choice.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Managing state</li>
				<li>Working with a database</li>
				<li>Attaching Rocket fairings</li>
			</ul>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Technical requirements</h1>
			<p>Besides the usual requirements of a Rust compiler, a text editor, and an HTTP client, starting from this chapter, we're going to work with a database. The database we're going to use throughout this book is PostgreSQL, and you can download it from <a href="https://www.postgresql.org/">https://www.postgresql.org/</a>, install it from your operating system package manager, or use a third-party server such as <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), Microsoft Azure, or <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>).</p>
			<p>We're going to see how to connect to other <strong class="bold">Relational Database Management Systems</strong> (<strong class="bold">RDBMSs</strong>) such as SQLite, MySQL, or Microsoft SQL Server, and you can adjust the lesson code to make the type suitable to those RDBMSs, but it's easier to follow using PostgreSQL.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04</a>.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>Managing state</h1>
			<p>In a web application, usually, programmers <a id="_idIndexMarker216"/>need to create an object that can be reused during the request/response life cycle. In the Rocket web framework, that object is called a <strong class="bold">state</strong>. A state can be anything such as a database connection pool, an object to store various customer statistics, an object to store a connection to a memory store, a<a id="_idIndexMarker217"/> client to send <strong class="bold">Simple Mail Transfer Protocol</strong> (<strong class="bold">SMTP</strong>) emails, and many more.</p>
			<p>We can tell Rocket to <a id="_idIndexMarker218"/>maintain the state, and this is called a <strong class="bold">managed state</strong>. The process of creating a managed state is quite simple. We need to initialize an object, tell Rocket to manage it, and finally use it in a route. One caveat is that we can manage many states from different types, but Rocket can only manage one instance of a Rust type.</p>
			<p>Let's try it directly. We are going to have a visitor counter state and tell Rocket to manage it and increment the counter for every incoming request. We can reuse the previous application from the previous chapter, copy the program from <code>Chapter03/15ErrorCatcher</code> into <code>Chapter04/01State</code>, and rename the application in <code>Cargo.toml</code> as <code>chapter4</code>.</p>
			<p>In <code>src/main.rs</code>, define a struct to hold the value of the visitor counter. For the state to work, the requirement is <code>T: Send + Sync + 'static</code>:</p>
			<pre class="source-code">use std::sync::atomic::AtomicU64;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">struct VisitorCounter {</pre>
			<pre class="source-code">    visitor: AtomicU64,</pre>
			<pre class="source-code">}</pre>
			<p>We already know that <code>'static</code> is a lifetime marker, but what is <code>Send + Sync</code>?</p>
			<p>In modern computing, due to its complexity, there are many ways a program can be executed in a way not intended. For example, multithreading makes it hard to know whether a variable value has been changed on another thread or not. Modern CPUs also perform branch prediction and execute multiple instructions at the same time. Sophisticated compilers also rearrange the resulting binary code execution flow to optimize the result. To overcome those problems, some kind of syncing is needed in the Rust language.</p>
			<p>The Rust language has<a id="_idIndexMarker219"/> traits and memory containers to solve syncing problems depending on how programmers intended the application to work. We might want to create an object in the heap and share the reference to that object in multiple other objects. For example, we create object <code>x</code>, and we use the reference of x, <code>&amp;x</code> in other objects field, <code>y</code> and <code>z</code>. This creates another problem, as the program can delete <code>x</code> in other routines making the program unstable. The solution is to create different containers for different use cases. These include <code>std::cell::Rc</code> and <code>std::box::Box</code>, among others.</p>
			<p><code>std::marker::Send</code> is one of those traits. The <code>Send</code> trait is making sure any <code>T</code> type is safe to be transferred to another thread. Almost all types in the <code>std</code> library are <code>Send</code>, with a few exceptions such as <code>std::rc::Rc</code> and <code>std::cell::UnsafeCell</code>. Rc is a single-threaded reference counted pointer.</p>
			<p>Meanwhile, <code>std::marker::Sync</code> is saying the <code>T</code> type is safe to be shared across multiple threads. That only holds <code>true</code> if the <code>&amp;T</code> reference is safe to be sent to another thread. Not all <code>Send</code> types are <code>Sync</code>. For example, <code>std::cell::Cell</code> and <code>std::cell::RefCell</code> are <code>Send</code> but not <code>Sync</code>.</p>
			<p><code>Both</code> <code>Send + Sync</code> are <code>Send + Sync</code> in our type? These<a id="_idIndexMarker222"/> types are also <code>Send</code> automatically becomes a <code>Send</code> type. Almost all types in the <code>std</code> library are <code>Send + Sync</code> apart from the raw pointers, <code>Rc</code>, <code>Cell</code>, and <code>RefCell</code>.</p>
			<p>What is <code>AtomicU64</code>? With the regular <code>u64</code> type, even though it's <code>Send + Sync</code>, there's no synchronization between threads so a data race condition might happen. For example, two threads access the same variable, <code>x</code> (which has a value of <code>64</code>) at the same time, and they increment the value by one. We expect the result to be <code>66</code> (as there are two threads), but because there's no synchronization between threads, the final result is unpredictable. It can be <code>65</code> or <code>66</code>.</p>
			<p>The types in the <code>std::sync</code> module provide a couple of ways to share updates between multiple threads, including the <code>std::sync::Mutex</code>, <code>std::sync::RwLock</code>, and <code>std::sync::atomic</code> types. We can also use other libraries that might provide better speed than a standard library, such as the <code>parking_lot</code> crate.</p>
			<p>Now we have<a id="_idIndexMarker223"/> defined <code>VisitorCounter</code>, let's initialize it and tell Rocket to manage it as a state. Write the code inside the <code>rocket()</code> function as in the following lines:</p>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    <strong class="bold">let visitor_counter = VisitorCounter {</strong></pre>
			<pre class="source-code"><strong class="bold">        visitor: AtomicU64::new(0),</strong></pre>
			<pre class="source-code"><strong class="bold">    };</strong></pre>
			<pre class="source-code">    rocket::build()</pre>
			<pre class="source-code">        <strong class="bold">.manage(visitor_counter)</strong></pre>
			<pre class="source-code">        .mount("/", routes![user, users, favicon])</pre>
			<pre class="source-code">        .register("/", catchers![not_found, forbidden])</pre>
			<pre class="source-code">}</pre>
			<p>After we tell Rocket to manage the state, we can use it inside the route handling functions. In the previous chapter, we learned about dynamic segments that we have to use in <code>function</code> arguments. There are other arguments we can use in a route handling function, which we call <strong class="bold">request guards</strong>. They are called <em class="italic">guards</em> because if a request does not pass the <a id="_idIndexMarker224"/>validation inside the guard, the request will be rejected, and an error response will be returned.</p>
			<p>Any type that implements <code>rocket::request::FromRequest</code> can be considered a request guard. Incoming requests are then validated against each request guard from left to right and will short circuit and return an error if the request is not valid.</p>
			<p>Suppose we have a route handling function as in the following lines:</p>
			<pre class="source-code">#[get("/&lt;param1&gt;")]</pre>
			<pre class="source-code">fn handler1(param1: u8, <strong class="bold">type1: Guard1, type2: Guard2</strong>) {}</pre>
			<p>The <code>Guard1</code> and <code>Guard2</code> types are the request guards. The incoming request is then validated against the <code>Guard1</code> methods, and if an error occurs, the proper error response will be returned immediately.</p>
			<p>We will learn about and implement request guards throughout the book, but we will just use a request guard without implementing it in this chapter. <code>FromRequest</code> is already implemented for <code>rocket::State&lt;T&gt;</code>, so we can use it in the route handling function.</p>
			<p>Now that we have<a id="_idIndexMarker225"/> learned why we use <code>State</code> in a route handling function, let's use it in our functions. We want to set the visitor counter so each hit to the request should increment the counter:</p>
			<pre class="source-code">use rocket::{Build, Rocket, <strong class="bold">State</strong>};</pre>
			<pre class="source-code">#[get("/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</pre>
			<pre class="source-code">fn user&lt;'a&gt;(<strong class="bold">counter: &amp;State&lt;VisitorCounter&gt;, </strong>uuid: &amp;'a str) -&gt; Option&lt;&amp;'a User&gt; {</pre>
			<pre class="source-code">    <strong class="bold">counter.visitor.fetch_add(1, Ordering::Relaxed);</strong></pre>
			<pre class="source-code"><strong class="bold">    println!("The number of visitor is: {}", counter.</strong></pre>
			<pre class="source-code"><strong class="bold">    visitor.load(Ordering::Relaxed));</strong></pre>
			<pre class="source-code">    USERS.get(uuid)</pre>
			<pre class="source-code">}</pre>
			<p>Why do we add the <code>'a</code> lifetime? We are adding a new reference argument, and Rust cannot infer which lifetime the returned <code>&amp;User</code> should follow. In this case, we are saying the lifetime of the <code>User</code> reference should be as long as <code>uuid</code>.</p>
			<p>Inside the function, we use the AtomicU64 <code>fetch_add()</code> method to increment the value of the visitor, and we print the value using the AtomicU64 <code>load()</code> method.</p>
			<p>Let's add the same for the <code>users()</code> function, but since we have the exact same routine with the <code>user()</code> function, let's make another function instead:</p>
			<pre class="source-code"><strong class="bold">impl VisitorCounter {</strong></pre>
			<pre class="source-code"><strong class="bold">    fn increment_counter(&amp;self) {</strong></pre>
			<pre class="source-code"><strong class="bold">        self.visitor.fetch_add(1, Ordering::Relaxed);</strong></pre>
			<pre class="source-code"><strong class="bold">        println!(</strong></pre>
			<pre class="source-code"><strong class="bold">            "The number of visitor is: {}",</strong></pre>
			<pre class="source-code"><strong class="bold">            self.visitor.load(Ordering::Relaxed)</strong></pre>
			<pre class="source-code"><strong class="bold">        );</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn user&lt;'a&gt;(counter: &amp;State&lt;VisitorCounter&gt;, uuid: &amp;'a str) -&gt; Option&lt;&amp;'a User&gt; {</pre>
			<pre class="source-code">    <strong class="bold">counter.increment_counter();</strong></pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn users&lt;'a&gt;(</pre>
			<pre class="source-code">    <strong class="bold">counter: &amp;State&lt;VisitorCounter&gt;,</strong></pre>
			<pre class="source-code">    name_grade: NameGrade,</pre>
			<pre class="source-code">    filters: Option&lt;Filters&gt;,</pre>
			<pre class="source-code">) -&gt; Result&lt;NewUser&lt;'a&gt;, Status&gt; {</pre>
			<pre class="source-code">    <strong class="bold">counter.increment_counter();</strong></pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>This example works<a id="_idIndexMarker226"/> fine with the <code>Atomic</code> type, but if you ever needed a more complex type to work with, such as <code>String</code>, <code>Vec</code>, or <code>Struct</code>, try using <code>Mutex</code> or <code>RwLock</code> from either the standard library or a third-party crate such as <code>parking_lot</code>.</p>
			<p>Now that we know what <code>State</code> is in Rocket, let's expand our application by combining it with a database <a id="_idIndexMarker227"/>server. We will use <code>State</code> for storing the connection to the database.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/>Working with a database</h1>
			<p>Currently, in our <a id="_idIndexMarker228"/>application, we are storing user data in a static variable. This is very cumbersome, as it is inflexible and we cannot update the data easily. Most modern applications handling data will use some kind of persistent storage, be it filesystem-backed storage, a document-oriented database, or a traditional RDBMS.</p>
			<p>Rust has many libraries to connect to various databases or database-like storage. There's the <code>postgres</code> crate, which works as a PostgreSQL client for Rust. There are also other clients such as <code>mongodb</code> and <code>redis</code>. For <code>diesel</code>, which can be used to connect to various database systems. For connection pool<a id="_idIndexMarker229"/> management, there are the <code>deadpool</code> and <code>r2d2</code> crates. All crates have their strengths and limitations, such as not having an asynchronous application.</p>
			<p>In this book, we're going to use <code>sqlx</code> to connect to an RDBMS. <code>sqlx</code> claims to be an SQL toolkit for Rust. It has abstractions for clients to connect to various RDBMSs, it has a connection pool trait, and it can also be used to convert types to queries and query responses to Rust types.</p>
			<p>As mentioned in the <em class="italic">Technical requirements</em> section of this chapter, we're going to use PostgreSQL as our RDBMS, so please prepare the connection information to PostgreSQL.</p>
			<p>After that, follow these steps to convert our application into using a database:</p>
			<ol>
				<li>We will reuse our application again. The first thing we want to do is to install <code>sqlx-cli</code> by typing this command in the terminal:<pre><strong class="bold">cargo install sqlx-cli</strong></pre></li>
			</ol>
			<p><code>sqlx-cli</code> is a useful command-line application to create a database, create migrations, and run the migrations. It's not as sophisticated as migration tools in other established frameworks, but it does its job very well.</p>
			<ol>
				<li value="2">Prepare the connection information and set the <code>DATABASE_URL</code> environment variable in your terminal. The <code>DATABASE_URL</code> format should look as follows, depending on<a id="_idIndexMarker230"/> which RDBMS you are using:<pre>postgres://username:password@localhost:port/db_name?connect_options</pre></li>
			</ol>
			<p>For <code>connect_options</code>, it's in query form, and the reference can be found at <a href="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING">https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING</a>. Other DATABASE_URL format for other RDBMS might look like:</p>
			<pre>mysql://username:password@localhost:port/db_name</pre>
			<p>Or <code>sqlite::memory:</code> or <code>sqlite://path/to/file.db?connect_options</code> or <code>sqlite:///path/to/file.db?connect_options</code>. The connect options for SQLite can be found at <a href="https://www.sqlite.org/uri.html">https://www.sqlite.org/uri.html</a>.</p>
			<ol>
				<li value="3">Create a new database using this command:<pre><strong class="bold">sqlx database create</strong></pre></li>
				<li>We can create a migration named <code>create_users</code> using this command:<pre><strong class="bold">sqlx migrate add create_users</strong></pre></li>
				<li>The <code>sqlx</code> CLI will create a new folder named <code>migrations</code> inside the root directory of our application, and inside the folder, there will be a file with the <code>timestamp_migration_name.sql</code> pattern. In our example, the filename will look like <code>migrations/20210923055406_create_users.sql</code>. Inside the file, we can write SQL <a id="_idIndexMarker231"/>queries to create or modify the <code>User</code> struct, so let's write the following code into the SQL file:<pre>CREATE TABLE IF NOT EXISTS users
(
    uuid   UUID PRIMARY KEY,
    name   VARCHAR NOT NULL,
    age    SMALLINT NOT NULL DEFAULT 0,
    grade  SMALLINT NOT NULL DEFAULT 0,
    active BOOL NOT NULL DEFAULT TRUE
);
CREATE INDEX name_active_idx ON users(name, active);</pre></li>
			</ol>
			<p>How do we know what the mapping between the database column type and Rust type is? <code>sqlx</code> provides its own mapping; we can find the documentation at <a href="https://docs.rs/sqlx">https://docs.rs/sqlx</a>. The crate<a id="_idIndexMarker232"/> has great modules for a supported database. We can search for it in the top search bar; for example, we can find the documentation for PostgreSQL in <a href="https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html">https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html</a>. On that page, we can see there are <code>types</code> modules that we can look at.</p>
			<ol>
				<li value="6">After we write the content of the migration file, we can run the migration using the following command:<pre><strong class="bold">sqlx migrate run</strong></pre></li>
				<li>After the migration, check the generated database table and see whether the table schema is correct or not. Let's insert the data from the previous chapter. Also, feel free to fill the table with sample data of your choice.</li>
				<li>After migration, include the <code>sqlx</code> crate in our <code>Cargo.toml</code> file. We should also include the <code>uuid</code> crate as we're going to use PostgreSQL's <code>uuid</code> type. Take a look at the API documentation of the crate if you want to enable another RDBMS:<pre>sqlx = {version = "0.5.7", features = ["postgres", "uuid", "runtime-tokio-rustls"]}
uuid = "0.8.2"</pre></li>
				<li>We can delete <code>lazy_static</code> from <code>Cargo.toml</code> and remove references of <code>lazy_static!</code>, <code>USERS</code>, and <code>HashMap</code> from the <code>src/main.rs</code> file. We don't need those, and we are only going to retrieve the <code>User</code> data from the database that we inserted earlier. Use the following <code>SQL INSERT</code> syntax to insert the previous user data:<pre>INSERT INTO public.users
(uuid, name, age, grade, active)
VALUES('3e3dd4ae-3c37-40c6-aa64-7061f284ce28'::uuid, 'John Doe', 18, 1, true);</pre></li>
				<li>Modify the <code>User</code> struct <a id="_idIndexMarker233"/>to follow the database that we've created:<pre><strong class="bold">use sqlx::FromRow;</strong>
<strong class="bold">use uuid::Uuid;</strong>
...
#[derive(Debug<strong class="bold">, FromRow</strong>)]
struct User {
<strong class="bold">    uuid: Uuid,</strong>
    name: String,
    age: <strong class="bold">i16</strong>,
    grade: <strong class="bold">i16</strong>,
    active: bool,
}</pre></li>
			</ol>
			<p>When <code>sqlx</code> retrieves the result from the database, it will be stored in <code>sqlx::Database::Row</code>. This type can then be converted to any type that implements <code>sqlx::FromRow</code>. Luckily, we can derive <code>FromRow</code> as long as all the members implement <code>sqlx::Decode</code>. There are a few exceptions that we can use to override <code>FromRow</code>. Here is an example:</p>
			<pre>#[derive(Debug, FromRow)]
<strong class="bold">#[sqlx(rename_all = "camelCase")]</strong>
struct User {
    uuid: Uuid,
    name: String,
    age: i16,
    grade: i16,
<strong class="bold">    #[sqlx(rename = "active")]</strong>
<strong class="bold">    present: bool,</strong>
<strong class="bold">    #[sqlx(default)]</strong>
<strong class="bold">    not_in_database: String,</strong>
}</pre>
			<p>For <code>rename_all</code>, we can use these options: <code>snake_case</code>, <code>lowercase</code>, <code>UPPERCASE</code>, <code>camelCase</code>, <code>PascalCase</code>, <code>SCREAMING_SNAKE_CASE</code>, and <code>kebab-case</code>.</p>
			<p><code>rename</code> is used when we have different column names and type member names. If a member has no column in the database, and that type has the implementation of the <code>std::default::Default</code> trait, we can use the <code>default</code> directive.</p>
			<p>Why do we use <code>i16</code>? The answer is the PostgreSQL type has no mapping to the Rust <code>u8</code> type. We can <a id="_idIndexMarker234"/>either use <code>i8</code>, use a bigger <code>i16</code> type, or try implementing <code>Decode</code> for <code>u8</code>. In this case, we choose to use the <code>i16</code> type.</p>
			<p>We want the program to read the connection information (<code>DATABASE_URL</code>) from the environment variable. In <a href="B16825_02_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Our First Rocket Web Application</em>, we learned how to configure Rocket using standard configuration, but this time, we want to add extra configuration. We can start by adding <code>serde</code> to application dependencies in <code>Cargo.toml</code>.</p>
			<p><code>serde</code> is one of the most used and important libraries in Rust. The name comes from <em class="italic">serialization and deserialization</em>. It is used for anything that involves serialization and deserialization. It can be used to convert Rust type instances to bytes representations and<a id="_idIndexMarker235"/> vice versa, to JSON and vice versa, to YAML, and any other type, as long as they implement the <code>serde</code> traits. It can also be used to transcode one type that implements <code>serde</code> traits to another type that implements <code>serde</code> traits.</p>
			<p>If you<a id="_idIndexMarker236"/> want to look at the <code>serde</code> documentation, you can find it on their website at <a href="https://serde.rs">https://serde.rs</a>.</p>
			<p>The <code>serde</code> documentation mentions many native or third-party supports for many data formats such as JSON, Bincode, CBOR, YAML, MessagePack, TOML, Pickle, RON, BSON, Avro, JSON5, Postcard, URL query strings, Envy, Envy Store, S-expressions, D-Bus's binary wire format, and FlexBuffers.</p>
			<p>Let's add the following lines into <code>Cargo.toml</code> to include <code>serde</code> in our application:</p>
			<pre>[dependencies]
...
<strong class="bold">serde = "1.0.130"</strong></pre>
			<ol>
				<li value="11">After that, create a struct that will be used to contain our custom configuration:<pre>use serde::Deserialize;
...
#[derive(Deserialize)]
struct Config {
    database_url: String,
}</pre></li>
			</ol>
			<p><code>serde</code> already provides the <code>Deserialize</code> macro that can be used in the <code>derive</code> attribute. So far, we have used a lot of macros providing libraries that can be used in the <code>derive</code> attribute, such as <code>Debug</code>, <code>FromRow</code>, <code>Deserialize</code>. The macro<a id="_idIndexMarker237"/> system is one of the important Rust features.</p>
			<ol>
				<li value="12">Implement the routine to read the configuration and map it into the <code>rocket()</code> function:<pre>fn rocket() -&gt; Rocket&lt;Build&gt; {
    let our_rocket = rocket::build();
    let config: Config = our_rocket
        .figment()
        .extract()
        .expect("Incorrect Rocket.toml 
         configuration");
    ...
    our_rocket
        .manage(visitor_counter)
    ...
}</pre></li>
				<li>Now that the application can get the <code>DATABASE_URL</code> information from environment variables, it's time to initialize the database connection pool and tell Rocket to manage it. Write<a id="_idIndexMarker238"/> the following lines:<pre><strong class="bold">use sqlx::postgres::PgPoolOptions;</strong>
...
<strong class="bold">async</strong> fn rocket() -&gt; Rocket&lt;Build&gt; {
    ...
    let config: Config = rocket_frame
        .figment()
        .extract()
        .expect("Incorrect Rocket.toml 
        configuration");
<strong class="bold">    let pool = PgPoolOptions::new()</strong>
<strong class="bold">        .max_connections(5)</strong>
<strong class="bold">        .connect(&amp;config.database_url)</strong>
<strong class="bold">        .await</strong>
<strong class="bold">        .expect("Failed to connect to database");</strong>
    ...
    rocket_frame
        .manage(visitor_counter)
        <strong class="bold">.manage(pool)</strong>
    ...
}</pre></li>
			</ol>
			<p>We initialize the connection pool using <code>PgPoolOptions</code>. Other databases can use their corresponding type, such as <code>sqlx::mysql::MySqlPoolOptions</code> or <code>sqlx::sqlite::SqlitePoolOptions</code>. The <code>connect()</code> method is an <code>async</code> method, so we must make <code>rocket()</code> async as well to be able to use the result.</p>
			<p>After that, inside the <code>rocket()</code> function, we tell Rocket to manage the connection pool.</p>
			<ol>
				<li value="14">Before using the database connection, we used <code>lazy_static</code> and created <code>user</code> objects as<a id="_idIndexMarker239"/> references to the <code>USERS</code> hash map. Now, we will use the data from the database, so we need to use concrete objects instead of references. Remove the ampersand (<code>&amp;</code>) from the <code>Responder</code> implementation for the <code>User</code> and <code>NewUser</code> structs:<pre>impl&lt;'r&gt; Responder&lt;'r, 'r&gt; for <strong class="bold">User</strong> { ... }
struct NewUser(Vec&lt;<strong class="bold">User</strong>&gt;);
impl&lt;'r&gt; Responder&lt;'r, 'r&gt; for <strong class="bold">NewUser</strong> { ... }</pre></li>
				<li>Now, it's time to implement the <code>user()</code> function to use the database connection pool to query from the database. Modify the <code>user()</code> function as follows:<pre><strong class="bold">async</strong> fn user(
    counter: &amp;State&lt;VisitorCounter&gt;,
    <strong class="bold">pool: &amp;rocket::State&lt;PgPool&gt;,</strong>
    uuid: &amp;str,
) -&gt; Result&lt;User, Status&gt; {
    ...
    <strong class="bold">let parsed_uuid = Uuid::parse_str(uuid)</strong>
<strong class="bold">    .map_err(|_| Status::BadRequest)?;</strong>
<strong class="bold">    let user = sqlx::query_as!(</strong>
<strong class="bold">        User,</strong>
<strong class="bold">        "SELECT * FROM users WHERE uuid = $1",</strong>
<strong class="bold">        parsed_uuid</strong>
<strong class="bold">    )</strong>
<strong class="bold">    .fetch_one(pool.inner())</strong>
<strong class="bold">    .await;</strong>
<strong class="bold">    user.map_err(|_| Status::NotFound)</strong>
}</pre></li>
			</ol>
			<p>We included the connection pool managed state in the function arguments. After that, we parsed the<a id="_idIndexMarker240"/> UUID <code>&amp;str</code> parameter into the <code>Uuid</code> instance. If there's an error parsing the <code>uuid</code> parameter, we change the error to <code>Status::BadRequest</code> and return the error.</p>
			<p>We then use the <code>query_as!</code> macro to send a query to the database server and convert the result to a <code>User</code> instance. There are many <code>sqlx</code> macros we can use, such as <code>query!</code>, <code>query_file!</code>, <code>query_as_unchecked!</code>, and <code>query_file_as!</code>. You can find the documentation for those macros in the <code>sqlx</code> API documentation that we mentioned earlier.</p>
			<p>The format to use this macro is as follows: <code>query_as!(RustType, "prepared statement", bind parameter1, ...)</code>. If you don't need to get the result as a Rust type, you can use the <code>query!</code> macro instead.</p>
			<p>We then use the <code>fetch_one()</code> method. If you want to execute instead of query, for example, to update or delete rows, you can use the <code>execute()</code> method. If you want to get all the results, you can use the <code>fetch_all()</code> method. You can find other methods to use and their documentation in the <code>sqlx::query::Query</code> struct documentation.</p>
			<p>We can either keep the <code>user()</code> function return as <code>Option&lt;User&gt;</code> and use <code>user.ok()</code>, or we change the return to <code>Status::SomeStatus</code>. Since we change the return type to either <code>Ok(user)</code> or <code>Err(some_error)</code>, we can just return the <code>Ok(user)</code> variant, but we want to use <code>map_err(|_| Status::NotFound)</code> to change the error to a <code>Status</code> type.</p>
			<p>You might be thinking, if we send raw SQL queries to the server, is it possible to do a SQL injection attack? Is it possible to mistakenly get any user input and execute <code>sqlx::query_as::&lt;_, User&gt;("SELECT * FROM users WHERE name = ?").bind</code><code>).fetch_one(pool.inner())</code>?</p>
			<p>The answer is no. <code>sqlx</code> prepared and cached each statement. As the result of using a prepared <a id="_idIndexMarker241"/>statement, it's more secure than a regular SQL query, and the type returned is also what we expect from the RDBMS server.</p>
			<ol>
				<li value="16">Let's also change the <code>users()</code> function. Like the <code>user()</code> function, we want the function to be <code>async</code> and get the connection pool from the Rocket managed state. We also want to remove the lifetime from <code>NewUser</code> as we are not referencing <code>USERS</code> anymore:<pre><strong class="bold">async</strong> fn users(
    counter: &amp;State&lt;VisitorCounter&gt;,
    <strong class="bold">pool: &amp;rocket::State&lt;PgPool&gt;,</strong>
    name_grade: NameGrade&lt;'_&gt;,
    filters: Option&lt;Filters&gt;,
) -&gt; Result&lt;NewUser, Status&gt; {…}</pre></li>
				<li>After that, we can prepare the prepared statement. We append more conditions to <code>WHERE</code> if the client sends the <code>filters</code> request. For PostgreSQL, the prepared statement uses <code>$1</code>, <code>$2</code>, and so on, but for other RDBMSs, you can use <code>?</code> for the prepared statement:<pre>...
let mut query_str = String::from("SELECT * FROM users WHERE name LIKE $1 AND grade = $2");
if filters.is_some() {
    query_str.push_str(" AND age = $3 AND active = 
    $4");
}</pre></li>
				<li>Next, write the code to<a id="_idIndexMarker242"/> execute the query, but the number of bound parameters may change depending on whether filters exist or not; we use the <code>query_as</code> function instead so we can use the <code>if</code> branching. We also add <code>%name%</code> for the name-bound parameter because we use the <code>LIKE</code> operator in the SQL statement. We also have to cast the <code>u8</code> type to the <code>i16</code> type. And, finally, we use the <code>fetch_all</code> method to retrieve all the results. The nice thing with the <code>query_as!</code> macro and query as function is they both returned <code>Vec&lt;T&gt;</code> or not depending on the <code>fetch_one</code> or <code>fetch_all</code>:<pre>...
let mut query = sqlx::query_as::&lt;_, User&gt;(&amp;query_str)
    .bind(format!("%{}%", &amp;name_grade.name))
    .bind(name_grade.grade as i16);
if let Some(fts) = &amp;filters {
    query = query.bind(fts.age as i16).bind(fts.
    active);
}
let unwrapped_users = query.fetch_all(pool.inner()).await;
let users: Vec&lt;User&gt; = unwrapped_users.map_err(|_| Status::InternalServerError)?;</pre></li>
				<li>We can return the result as usual:<pre>...
if users.is_empty() {
    Err(Status::NotFound)
} else {
    Ok(NewUser(users))
}</pre></li>
			</ol>
			<p>Now, let's try calling the <code>user()</code> and <code>users()</code> endpoints again. It should work as it did when we used <code>HashMap</code>. Since we <a id="_idIndexMarker243"/>didn't modify the connection options after we wrote <code>connect()</code> on the connection pool, the SQL output is written on the terminal:</p>
			<pre>/* SQLx ping */; rows: 0, elapsed: 944.711µs
SELECT * FROM users …; rows: 1, elapsed: 11.187ms
SELECT
  *
FROM
  users
WHERE
  uuid = $1</pre>
			<p>Here is some more of the output:</p>
			<pre>/* SQLx ping */; rows: 0, elapsed: 524.114µs
SELECT * FROM users …; rows: 1, elapsed: 2.435ms
SELECT
  *
FROM
  users
WHERE
  name LIKE $1
  AND grade = $2</pre>
			<p>In this book, we are<a id="_idIndexMarker244"/> not going to use ORM; instead, we are going to use <code>sqlx</code> only, as it is enough for the scope of this book. If you want to use ORM in your application, you can use ORM and query builders from <a href="https://github.com/NyxCode/ormx">https://github.com/NyxCode/ormx</a> or <a href="https://www.sea-ql.org/SeaORM/">https://www.sea-ql.org/SeaORM/</a>.</p>
			<p>Now that we have learned about <code>State</code> and how to use databases using <code>State</code>, it is time to learn about another Rocket middleware capability, attaching fairings.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/>Attaching Rocket fairings</h1>
			<p>In real life, a rocket fairing is a nose cone used to protect the rocket payload. In the Rocket framework, a <a id="_idIndexMarker245"/>fairing is not used to protect the payload but is instead used to hook in to any part of the request life cycle and rewrite the payload. Fairings are analogous to middleware in other web frameworks but with few differences.</p>
			<p>Other framework middleware may be able to inject any arbitrary data. In Rocket, the fairing can be used to modify the request but cannot be used to add information that is not part of the request. For example, we can use fairings to add a new HTTP header in the requests or responses.</p>
			<p>Some web frameworks might be able to terminate and directly respond to incoming requests, but in Rocket, the fairings cannot stop the incoming requests directly; the request must go through the route handling function, and then the route can create the proper response.</p>
			<p>We can create a fairing by implementing <code>rocket::fairing::Fairing</code> for a type. Let's first see the signature of the trait:</p>
			<pre class="source-code"> #[crate::async_trait]</pre>
			<pre class="source-code">pub trait Fairing: Send + Sync + Any + 'static {</pre>
			<pre class="source-code">    fn info(&amp;self) -&gt; Info;</pre>
			<pre class="source-code">    async fn on_ignite(&amp;self, rocket: Rocket&lt;Build&gt;) -&gt;</pre>
			<pre class="source-code">    Result { Ok(rocket) }</pre>
			<pre class="source-code">    async fn on_liftoff(&amp;self, _rocket: &amp;Rocket&lt;Orbit&gt;) { }</pre>
			<pre class="source-code">    async fn on_request(&amp;self, _req: &amp;mut Request&lt;'_&gt;, </pre>
			<pre class="source-code">    _data: &amp;mut Data&lt;'_&gt;) {}</pre>
			<pre class="source-code">    async fn on_response&lt;'r&gt;(&amp;self, _req: &amp;'r Request&lt;'_&gt;, </pre>
			<pre class="source-code">    _res: &amp;mut Response&lt;'r&gt;) {}</pre>
			<pre class="source-code">}</pre>
			<p>There are a couple <a id="_idIndexMarker246"/>of types we are not familiar with, such as <code>Build</code> and <code>Orbit</code>. These types are related to phases in Rocket.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>Rocket phases</h2>
			<p>The types that we want to<a id="_idIndexMarker247"/> discuss are <code>Build</code> and <code>Orbit</code>, with the full module paths of <code>rocket::Orbit</code> and <code>rocket::Build</code>. What are these types? The signature for a Rocket instance is <code>Rocket&lt;P: Phase&gt;</code>, which means any <code>P</code> type that implements <code>rocket::Phase</code>.</p>
			<p><code>Phase</code> is a <code>pub trait SomeTrait: private::Sealed {}</code>.</p>
			<p>The <code>Phase</code> trait is sealed because Rocket authors intended only three phases in the Rocket application: <code>rocket::Build</code>, <code>rocket::Ignite</code>, and <code>rocket::Orbit</code>.</p>
			<p>We initialize a Rocket instance through <code>rocket::build()</code>, which uses the <code>Config::figment()</code>default, or <code>rocket::custom&lt;T: Provider&gt;(provider: T)</code>, which uses the custom configuration provider. In this phase, we can also chain the generated instance with custom configuration using <code>configure&lt;T: Provider&gt;(self, provider: T)</code>. We can then add a route using <code>mount()</code>, register a catcher using <code>register()</code>, manage the states using <code>manage()</code>, and attach fairings using <code>attach()</code>.</p>
			<p>After that, we can change the Rocket phase to <code>Ignite</code> through the <code>ignite()</code> method. In this phase, we have a Rocket instance with the final configuration. We can then send the Rocket to the <code>Orbit</code> phase through the <code>launch()</code> method or return <code>Rocket&lt;Build&gt;</code> and use the <code>#[launch]</code> attribute. We can also skip the <code>Ignite</code> phase and use <code>launch()</code> directly after <code>build()</code>.</p>
			<p>Let's recall the code that we<a id="_idIndexMarker249"/> have created up to now:</p>
			<pre class="source-code"><strong class="bold">#[launch]</strong></pre>
			<pre class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    let our_rocket = rocket::<strong class="bold">build();</strong></pre>
			<pre class="source-code">    …</pre>
			<pre class="source-code">    our_rocket</pre>
			<pre class="source-code">        <strong class="bold">.manage(</strong>visitor_counter<strong class="bold">)</strong></pre>
			<pre class="source-code">        <strong class="bold">.manage(</strong>pool<strong class="bold">)</strong></pre>
			<pre class="source-code">        <strong class="bold">.mount(</strong>"/", routes![user, users, favicon]<strong class="bold">)</strong></pre>
			<pre class="source-code">        <strong class="bold">.register(</strong>"/", catchers![not_found, forbidden]<strong class="bold">)</strong></pre>
			<pre class="source-code">}</pre>
			<p>This function generates <code>Rocket&lt;Build&gt;</code>, and the <code>#[launch]</code> attribute generates the code that uses <code>launch()</code>.</p>
			<p>The conclusion for this subsection is that the Rocket phase goes from <code>Build</code> to <code>Ignite</code> to <code>Launch</code>. How are those phases related to fairing? Let's discuss this in the next subsection.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>Fairing callbacks</h2>
			<p>Any type implementing fairings <a id="_idIndexMarker250"/>must implement one mandatory function, <code>info()</code>, which returns <code>rocket::fairing::Info</code>. The <code>Info</code> struct is defined as follows:</p>
			<pre class="source-code">pub struct Info {</pre>
			<pre class="source-code">    pub name: &amp;'static str,</pre>
			<pre class="source-code">    pub kind: Kind,</pre>
			<pre class="source-code">}</pre>
			<p>And, <code>rocket::fairing::Kind</code> is defined as just an empty struct, <code>pub struct Kind(_);</code>, but <code>Kind</code> has the <code>Kind::Ignite</code>, <code>Kind::Liftoff</code>, <code>Kind::Request</code>, <code>Kind::Response</code>, and <code>Kind::Singleton</code>.</p>
			<p>What are associated<a id="_idIndexMarker251"/> constants? In Rust, we can <a id="_idIndexMarker252"/>declare <strong class="bold">associated items</strong>, which are items declared in<a id="_idIndexMarker253"/> traits or defined in implementations. For example, we have this piece of code:</p>
			<pre class="source-code">struct Something {</pre>
			<pre class="source-code">    item: u8</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">impl Something {</pre>
			<pre class="source-code">    fn new() -&gt; Something {</pre>
			<pre class="source-code">        Something {</pre>
			<pre class="source-code">            item: 8,</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We can use the <code>Something::new()</code> <code>self</code> as the first parameter. We have already implemented an associated method a couple of times.</p>
			<p>We can also<a id="_idIndexMarker256"/> define an <strong class="bold">associated type</strong> as follows:</p>
			<pre class="source-code">trait SuperTrait {</pre>
			<pre class="source-code">    type Super;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">struct Something;</pre>
			<pre class="source-code">struct Some;</pre>
			<pre class="source-code">impl SuperTrait for Something {</pre>
			<pre class="source-code">    type Super = Some;</pre>
			<pre class="source-code">}</pre>
			<p>And, finally, we can have <a id="_idIndexMarker257"/>an <code>rocket::fairing::Kind</code>:</p>
			<pre class="source-code">pub struct Kind(usize);</pre>
			<pre class="source-code">impl Kind {</pre>
			<pre class="source-code">    pub const Ignite: Kind = Kind(1 &lt;&lt; 0);</pre>
			<pre class="source-code">    pub const Liftoff: Kind = Kind(1 &lt;&lt; 1);</pre>
			<pre class="source-code">    pub const Request: Kind = Kind(1 &lt;&lt; 2);</pre>
			<pre class="source-code">    pub const Response: Kind = Kind(1 &lt;&lt; 3);</pre>
			<pre class="source-code">    pub const Singleton: Kind = Kind(1 &lt;&lt; 4);</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>Let's go back to <code>Info</code>. We <a id="_idIndexMarker258"/>can make an <code>Info</code> instance as follows:</p>
			<pre class="source-code">Info {</pre>
			<pre class="source-code">    name: "Request Response Tracker",</pre>
			<pre class="source-code">    kind: Kind::Request | Kind::Response,</pre>
			<pre class="source-code">}</pre>
			<p>We are saying the value for <code>kind</code> is the result of the <code>OR</code> bitwise operation between the<code> kind</code> associated constants. <code>Kind::Request</code> is <code>1&lt;&lt;2</code>, which means <code>100</code> in binary or <code>4</code> in decimal. <code>Kind::Response</code> is <code>1&lt;&lt;3</code>, which means <code>1000</code> in binary or <code>8</code> in decimal. The result of <code>0100 | 1000</code> is <code>1100</code> in binary or <code>12</code> in decimal. With this knowledge, we can set the value for the <code>Info</code> instance, <code>kind</code>, from <code>00000</code> to <code>11111</code>.</p>
			<p>Setting configuration using bitwise is a very common design pattern for packing multiple values into one variable. Some other languages <a id="_idIndexMarker259"/>even make this design pattern into its own type and call it <strong class="bold">bitset</strong>.</p>
			<p>In a type that implements the <code>Fairing</code> trait, the mandatory method implementation is <code>info()</code>, which returns the <code>Info</code> instance. We also have to implement <code>on_ignite()</code>, <code>on_liftoff()</code>, <code>on_request()</code>, and <code>on_response()</code> depending on the <code>kind</code> instance that we defined. In our case, this means we have to implement <code>on_request()</code> and <code>on_response()</code>.</p>
			<p>Rocket executes our fairing method on different occasions. If we have <code>on_ignite()</code>, it will be executed before launch. This type of fairing is special as <code>on_ignite()</code> returns <code>Result</code>, and if the returned variant is <code>Err</code>, it can abort the launch.</p>
			<p>For <code>on_liftoff()</code>, this method will be executed after launch, which means when Rocket is in the <code>Orbit</code> phase.</p>
			<p>If we have <code>on_request()</code>, it <a id="_idIndexMarker260"/>will be executed after Rocket gets the request but before the request is routed. This method will have access to <code>Request</code> and <code>Data</code>, which means we can modify these two items.</p>
			<p>And, <code>on_response()</code> will be executed when the route handler has created the response but before the response is sent to the HTTP client. This callback has access to the <code>Request</code> and <code>Response</code> instances.</p>
			<p><code>Kind::Singleton</code> is special. We can create multiple instances of fairings of the same type and attach them to Rocket. But, maybe we only want to allow one instance of the <code>Fairing</code> implementing type to be added. We can use <code>Kind::Singleton</code> and it will make sure only the last attached instance of this type will be added.</p>
			<p>Now that we know more about Rocket phases and <code>Fairing</code> callbacks, let's implement the <code>Fairing</code> trait in the next subsection.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Implementing and attaching fairings</h2>
			<p>Right now, our <a id="_idIndexMarker261"/>Rocket application manages <code>VisitorCounter</code>, but we did not add <code>State&lt;VisitorCounter&gt;</code> to the <code>favicon()</code> function. We might also want to<a id="_idIndexMarker262"/> add new route handling functions, but adding <code>State&lt;VisitorCounter&gt;</code> as an argument parameter for every route handling function is cumbersome.</p>
			<p>We can change <code>VisitorCounter</code> from a managed state into a fairing. At the same time, let's imagine that we have another requirement in our application. We want to have a custom header for the request and response for internal logging purposes. We can do it by adding another fairing to change the incoming requests and responses.</p>
			<p>First, let's organize our module usage a little bit. We need to add the fairing-related modules, <code>rocket::http::Header</code>, <code>rocket::Build</code>, and <code>rocket::Orbit</code>, so we can use those for our <code>VisitorCounter</code> fairing and another fairing to modify the requests and <a id="_idIndexMarker263"/>responses:</p>
			<pre class="source-code"><strong class="bold">use rocket::fairing::{self, Fairing, Info, Kind};</strong></pre>
			<pre class="source-code">use rocket::fs::{relative, NamedFile};</pre>
			<pre class="source-code">use rocket::http::{ContentType, <strong class="bold">Header</strong>, Status};</pre>
			<pre class="source-code">use rocket::request::{FromParam, Request};</pre>
			<pre class="source-code">use rocket::response::{self, Responder, Response};</pre>
			<pre class="source-code">use rocket::{<strong class="bold">Build</strong>, Data, <strong class="bold">Orbit</strong>, Rocket, <strong class="bold">State</strong>};</pre>
			<p>Add the <code>Fairing</code> trait<a id="_idIndexMarker264"/> implementation for <code>VisitorCounter</code>. We need to decorate the <code>impl</code> with <code>#[rocket::async_trait]</code>, since this trait is an <code>async</code> trait:</p>
			<pre class="source-code">#[rocket::async_trait]</pre>
			<pre class="source-code">impl Fairing for VisitorCounter {</pre>
			<pre class="source-code">    fn info(&amp;self) -&gt; Info {</pre>
			<pre class="source-code">        Info {</pre>
			<pre class="source-code">            name: "Visitor Counter",</pre>
			<pre class="source-code">            kind: Kind::Ignite | Kind::Liftoff | Kind::</pre>
			<pre class="source-code">            Request,</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We added the <code>info()</code> mandatory method, which returned the <code>Info</code> instance. Inside the <code>Info</code> instance, we only really need <code>Kind::Request</code> as we only need to increment the visitor counter for every incoming request. But this time, we also added <code>Kind::Ignite</code> and <code>Kind::Liftoff</code> because we want to see when the callback is executed.</p>
			<p>Then, we can add the <a id="_idIndexMarker265"/>callbacks inside the <code>impl Fairing</code> block:</p>
			<pre class="source-code">async fn on_ignite(&amp;self, rocket: Rocket&lt;Build&gt;) -&gt; fairing::Result {</pre>
			<pre class="source-code">    println!("Setting up visitor counter");</pre>
			<pre class="source-code">    Ok(rocket)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">async fn on_liftoff(&amp;self, _: &amp;Rocket&lt;Orbit&gt;) {</pre>
			<pre class="source-code">    println!("Finish setting up visitor counter");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">async fn on_request(&amp;self, _: &amp;mut Request&lt;'_&gt;, _: &amp;mut Data&lt;'_&gt;) {</pre>
			<pre class="source-code">    self.increment_counter();</pre>
			<pre class="source-code">}</pre>
			<p>What is the return<a id="_idIndexMarker266"/> type on the <code>on_ignite()</code> method? <code>rocket::fairing::Result</code> is defined as <code>Result&lt;T = Rocket&lt;Build&gt;, E = Rocket&lt;Build&gt;&gt; = Result&lt;T, E&gt;</code>. This method is used to control whether the program continues or not. For example, we can check the connection to a third-party server to ensure its readiness. If the third-party server is ready to accept connections, we can return <code>Ok(rocket)</code>. But, if the third-party server is not available, we can return <code>Err(rocket)</code> to halt the launch of Rocket. Notice that <code>on_liftoff()</code>, <code>on_request()</code>, and <code>on_response()</code> do not have a return type, as <code>Fairing</code> is designed to only fail when we build Rocket.</p>
			<p>For <code>on_liftoff()</code>, we just want to print something to the application output. For <code>on_request()</code>, we undertake the real purpose of this fairing: increase the counter for every request.</p>
			<p>After implementing the <code>Fairing</code> trait, we can remove <code>counter: &amp;State&lt;VisitorCounter&gt;</code> from the <code>user()</code> and <code>users()</code> function arguments. We also need to remove <code>counter.increment_counter();</code> from the body of those functions.</p>
			<p>After we have modified the <code>user()</code> and <code>users()</code> functions, we can attach the fairing to the Rocket application. Change <code>manage(visitor_counter)</code> to <code>attach(visitor_counter)</code> in the Rocket initialization code.</p>
			<p>Time to see the fairing in action! First, take a look at the initialization sequence. You can see <code>on_ignite()</code> is<a id="_idIndexMarker267"/> executed in the beginning, and <code>on_liftoff()</code> is executed after everything is ready: <a id="_idIndexMarker268"/></p>
			<pre>&gt; cargo run
...
Setting up visitor counter
<img src="img/011.png" alt=""/> Configured for debug.
...
<img src="img/021.png" alt=""/> Fairings:
   &gt;&gt; Visitor Counter (ignite, liftoff, request)
...
Finish setting up visitor counter
<img src="img/033.png" alt=""/> Rocket has launched from http://127.0.0.1:8000</pre>
			<p>After that, try calling our route handling function again to see the counter increase again:</p>
			<pre>&gt; curl http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28</pre>
			<p>And, in the Rocket output, we can see it increase when we use it as a state:</p>
			<pre>The number of visitor is: 2</pre>
			<p>Now, let's implement our second use case, injecting a tracing ID to our requests and responses.</p>
			<p>First, modify <code>Cargo.toml</code> to ensure the <code>uuid</code> crate can generate a random UUID:</p>
			<pre class="source-code">uuid = {version = "0.8.2", features = ["v4"]}</pre>
			<p>After that, inside <code>src/main.rs</code>, we can define the header name we want to inject and a type that works as the fairing:</p>
			<pre class="source-code">const X_TRACE_ID: &amp;str = "X-TRACE-ID";</pre>
			<pre class="source-code">struct XTraceId {}</pre>
			<p>Afterward, we can<a id="_idIndexMarker269"/> implement the <code>Fairing</code> trait for <code>XtraceId</code>. This time, we<a id="_idIndexMarker270"/> want to have <code>on_request()</code> and <code>on_response()</code> callbacks:</p>
			<pre class="source-code">#[rocket::async_trait]</pre>
			<pre class="source-code">impl Fairing for XTraceId {</pre>
			<pre class="source-code">    fn info(&amp;self) -&gt; Info {</pre>
			<pre class="source-code">        Info {</pre>
			<pre class="source-code">            name: "X-TRACE-ID Injector",</pre>
			<pre class="source-code">            kind: Kind::Request | Kind::Response,</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Now, write the <code>on_request()</code> and <code>on_response()</code> implementations inside the <code>impl Fairing</code> block:</p>
			<pre class="source-code">async fn on_request(&amp;self, req: &amp;mut Request&lt;'_&gt;, _: &amp;mut Data&lt;'_&gt;) {</pre>
			<pre class="source-code">    let header = Header::new(X_TRACE_ID, </pre>
			<pre class="source-code">    Uuid::new_v4().to_hyphenated().to_string());</pre>
			<pre class="source-code">    req.add_header(header);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">async fn on_response&lt;'r&gt;(&amp;self, req: &amp;'r Request&lt;'_&gt;, res: &amp;mut Response&lt;'r&gt;) {</pre>
			<pre class="source-code">    let header = req.headers().get_one(X_TRACE_ID).</pre>
			<pre class="source-code">    unwrap();</pre>
			<pre class="source-code">    res.set_header(Header::new(X_TRACE_ID, header));</pre>
			<pre class="source-code">}</pre>
			<p>In <code>on_request()</code>, we generate a random UUID and inject the resulting string as one of the request headers. In <code>on_response()</code>, we inject the response with the same header from the request.</p>
			<p>Don't forget to<a id="_idIndexMarker271"/> initialize and attach this new fairing to the Rocket build and<a id="_idIndexMarker272"/> launch process:</p>
			<pre class="source-code"><strong class="bold">let x_trace_id = XTraceId {};</strong></pre>
			<pre class="source-code">our_rocket</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    .attach(visitor_counter)</pre>
			<pre class="source-code">    <strong class="bold">.attach(x_trace_id)</strong></pre>
			<pre class="source-code">    ...</pre>
			<p>Rerun the application. We should have a new fairing in the application output and <code>"x-trace-id"</code> in the HTTP response:</p>
			<pre>...
<img src="img/022.png" alt=""/> Fairings:
   &gt;&gt; X-TRACE-ID Injector (request, response)
   &gt;&gt; Visitor Counter (ignite, liftoff, request)
...</pre>
			<p>Here is another example:</p>
			<pre>curl -v http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28
...
&lt; x-trace-id: 28c0d523-13cc-4132-ab0a-3bb9ae6153a9
...</pre>
			<p>Please note that we can use both <code>State</code> and <code>Fairing</code> in our application. Only use <code>Fairing</code> if we need to call this for every request.</p>
			<p>Previously, we <a id="_idIndexMarker273"/>created a connection pool and told Rocket to manage it using managed state but Rocket already has a way to connect to the database<a id="_idIndexMarker274"/> via its built-in database connection, <code>rocket_db_pools</code>, which is a type of fairings. Let's see how we can do it in the next part.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Connecting to a database using rocket_db_pools</h2>
			<p>Rocket provided a <em class="italic">sanctioned</em> way to <a id="_idIndexMarker275"/>connect to some RDBMSs by using <code>rocket_db_pools</code>. That crate provides the database driver integration for Rocket. We are going to learn how to use this crate for connecting<a id="_idIndexMarker276"/> to the database. Let's change the connection pool that we made previously from using state into using fairings:</p>
			<ol>
				<li value="1">We don't need <code>serde</code>, as <code>rocket_db_pools</code> already has its own configuration. Remove <code>serde</code> from <code>Cargo.toml</code> and add <code>rocket_db_pools</code> as a dependency:<pre>[dependencies]
rocket = "0.5.0-rc.1"
<strong class="bold">rocket_db_pools = {version = "0.5.0-rc.1", features = ["sqlx_postgres"]}</strong>
...</pre></li>
			</ol>
			<p>You can also use different features such as <code>sqlx_mysql</code>, <code>sqlx_sqlite</code>, <code>sqlx_mssql</code>, <code>deadpool_postgres</code>, <code>deadpool_redis</code>, or <code>mongodb</code>.</p>
			<ol>
				<li value="2">In <code>Rocket.toml</code>, remove the line containing the <code>database_url</code> configuration and replace it with these lines:<pre>[debug.databases.main_connection]
url = "postgres://username:password@localhost/rocket"</pre></li>
			</ol>
			<p>You can use <code>default.databases.main_connection</code> if you like, and you can also change <code>main_connection</code> to whatever name you see fit.</p>
			<ol>
				<li value="3">In the Cargo <a id="_idIndexMarker277"/>library project, we can<a id="_idIndexMarker278"/> re-export something in <code>our_library</code> using the <code>pub use something;</code> syntax, and another library can then use that through <code>our_library::something</code>. Remove these <code>use sqlx...</code> and <code>use serde...</code> lines, as <code>rocket_db_pools</code> already re-exported <code>sqlx</code> and we don't need <code>serde</code> anymore:<pre>use serde::Deserialize;
...
use sqlx::postgres::{PgPool, PgPoolOptions};
use sqlx::FromRow;</pre></li>
				<li>Add the following lines to use <code>rocket_db_pools</code>. Notice that we can multiline the <code>use</code> declaration in the code:<pre>use rocket_db_pools::{
    sqlx,
    sqlx::{FromRow, PgPool},
    Connection, Database,
};</pre></li>
				<li>Delete the struct <code>Config</code> declaration and add the following lines to declare the database connection type:<pre>#[derive(Database)]
#[database("main_connection")]
struct DBConnection(PgPool);</pre></li>
			</ol>
			<p>The database derives an automatically generated <code>rocket_db_pools::Database</code> implementation for the <code>DBConnection</code> type. Notice that we wrote the connection name <code>"main_connection"</code>, just like what we have set in <code>Rocket.toml</code>.</p>
			<ol>
				<li value="6">Remove the <a id="_idIndexMarker279"/>config and<a id="_idIndexMarker280"/> connection pool initializations in the <code>rocket()</code> function:<pre>let config: Config = our_rocket
    .figment()
    .extract()
    .expect("Incorrect Rocket.toml configuration");
let pool = PgPoolOptions::new()
    .max_connections(5)
    .connect(&amp;config.database_url)
    .await
    .expect("Failed to connect to database");</pre></li>
				<li>Add <code>DBConnection::init()</code> inside the <code>rocket()</code> function and attach it to Rocket:<pre>async fn rocket() -&gt; Rocket&lt;Build&gt; {
    ...
    rocket::build()
        <strong class="bold">.attach(DBConnection::init())</strong>
        .attach(visitor_counter)
        ...
}</pre></li>
				<li>Change<a id="_idIndexMarker281"/> the <code>user()</code> and <code>users()</code> functions to use the <code>rocket_db_pools::Connection</code> request<a id="_idIndexMarker282"/> guard:<pre>async fn user(<strong class="bold">mut db: Connection&lt;DBConnection&gt;,</strong> uuid: &amp;str) -&gt; Result&lt;User, Status&gt; {
    ...
    let user = sqlx::query_as!(User, "SELECT * FROM 
    users WHERE uuid = $1", parsed_uuid)
        .fetch_one<strong class="bold">(&amp;mut *db</strong>)
        .await;
    ...
}
...
#[get("/users/&lt;name_grade&gt;?&lt;filters..&gt;")]
async fn users(
    <strong class="bold">mut db: Connection&lt;DBConnection&gt;,</strong>
    ...
) -&gt; Result&lt;NewUser, Status&gt; {
    ...
    let unwrapped_users = query.fetch_all<strong class="bold">(&amp;mut </strong>
<strong class="bold">    *db</strong>).await;
    ...
}</pre></li>
			</ol>
			<p>The application should work just like when we managed the connection pool using state, but with minor differences. Here's the output we see:</p>
			<pre><img src="img/023.png" alt=""/> Fairings:
   ...
   &gt;&gt; 'main_connection' Database Pool (ignite)</pre>
			<p>We can see<a id="_idIndexMarker283"/> there's a new fairing in the <a id="_idIndexMarker284"/>application output but there is no prepared SQL statement in the application output.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>Summary</h1>
			<p>In this chapter, we learned about two Rocket components, <code>State</code> and <code>Fairing</code>. We can manage state objects and attach fairings upon building rockets, use the <code>state</code> objects in route handling functions, and use the <code>fairing</code> functions to execute callbacks on the build, after launch, on request, and on response.</p>
			<p>We also created counter states and used them in the route handling functions. We also learned how to use <code>sqlx</code>, made a database migration, made a database connection pool state, and used <code>state</code> to query the database.</p>
			<p>Afterward, we learned more about the Rocket initialization process and the building, igniting, and launching phases.</p>
			<p>Finally, we changed the counter state into a fairing and created a new fairing to inject a custom HTTP header into the incoming requests and outgoing responses.</p>
			<p>Armed with that knowledge, you can create reusable objects between route handling functions, and create a method that can be executed globally between requests and responses.</p>
			<p>Our <code>src/main.rs</code> file is getting bigger and more complicated; we will learn how to manage our Rust code in modules and plan a more complex application in the next chapter.</p>
		</div>
	</body></html>