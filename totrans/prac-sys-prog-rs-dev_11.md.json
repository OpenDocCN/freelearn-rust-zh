["```rs\nrustup --version\nrustc --version \ncargo --version\n```", "```rs\nuse std::thread;\nfn main() {\n    for _ in 1..5 {\n        thread::spawn(|| {\n            println!(\"Hi from thread id {:?}\", \n                thread::current().id());\n        });\n    }\n} \n```", "```rs\nuse std::thread;\nfn main() {\n    let mut child_threads = Vec::new();\n    for _ in 1..5 {\n        let handle = thread::spawn(|| {\n            println!(\"Hi from thread id {:?}\", \n                thread::current().id());\n        });\n        child_threads.push(handle);\n    }\n    for i in child_threads {\n        i.join().unwrap();\n    }\n}\n```", "```rs\nuse std::thread;\nfn main() {\n    let mut child_threads = Vec::new();\n    for i in 1..5 {\n        let builder = thread::Builder::new().name(format!(\n            \"mythread{}\", i));\n        let handle = builder\n            .spawn(|| {\n                println!(\"Hi from thread id {:?}\", thread::\n                    current().name().unwrap());\n            })\n            .unwrap();\n        child_threads.push(handle);\n    }\n\n    for i in child_threads {\n        i.join().unwrap();\n    }\n}\n```", "```rs\nuse std::fs;\nuse std::thread;\nfn copy_file() -> thread::Result<()> {\n    thread::spawn(|| {\n        fs::copy(\"a.txt\", \"b.txt\").expect(\"Error \n            occurred\");\n    })\n    .join()\n}\nfn main() {\n    match copy_file() {\n        Ok(_) => println!(\"Ok. copied\"),\n        Err(_) => println!(\"Error in copying file\"),\n    }\n}\n```", "```rs\nuse std::fs;\nuse std::thread;\nstruct Filenames {\n    source: String,\n    destination: String,\n}\nimpl Drop for Filenames {\n    fn drop(&mut self) {\n        if thread::panicking() {\n            println!(\"dropped due to  panic\");\n        } else {\n            println!(\"dropped without panic\");\n        }\n    }\n}\nfn copy_file(file_struct: Filenames) -> thread::Result<()> {\n    thread::spawn(move || {\n        fs::copy(&file_struct.source, \n            &file_struct.destination).expect(\n            \"Error occurred\");\n    })\n    .join()\n}\nfn main() {\n    let foo = Filenames {\n        source: \"a1.txt\".into(),\n        destination: \"b.txt\".into(),\n    };\n    match copy_file(foo) {\n        Ok(_) => println!(\"Ok. copied\"),\n        Err(_) => println!(\"Error in copying file\"),\n    }\n}\n```", "```rs\ndropped due to  panic\nError in copying file\n```", "```rs\n    use std::sync::mpsc;\n    use std::thread;\n    ```", "```rs\n    let (transmitter1, receiver) = mpsc::channel();\n    ```", "```rs\n    let transmitter2 = mpsc::Sender::clone(&transmitter1);\n    ```", "```rs\n        thread::spawn(move || {\n            let num_vec: Vec<String> = vec![\"One\".into(), \n                \"two\".into(), \"three\".into(), \n                \"four\".into()];\n            for num in num_vec {\n                transmitter1.send(num).unwrap();\n            }\n        });\n    ```", "```rs\n        thread::spawn(move || {\n            let num_vec: Vec<String> =\n                vec![\"Five\".into(), \"Six\".into(), \n                    \"Seven\".into(), \"eight\".into()];\n            for num in num_vec {\n                transmitter2.send(num).unwrap();\n            }\n        });\n    ```", "```rs\n        for received_val in receiver {\n            println!(\"Received from thread: {}\", \n                received_val);\n        }\n    ```", "```rs\n    use std::sync::mpsc;\n    use std::thread;\n    fn main() {\n        let (transmitter1, receiver) = mpsc::channel();\n        let transmitter2 = mpsc::Sender::clone(\n            &transmitter1);\n        thread::spawn(move || {\n            let num_vec: Vec<String> = vec![\"One\".into(), \n                \"two\".into(), \"three\".into(), \n                \"four\".into()];\n            for num in num_vec {\n                transmitter1.send(num).unwrap();\n            }\n        });\n        thread::spawn(move || {\n            let num_vec: Vec<String> =\n                vec![\"Five\".into(), \"Six\".into(), \n                    \"Seven\".into(), \"eight\".into()];\n            for num in num_vec {\n                transmitter2.send(num).unwrap();\n            }\n        });\n        for received_val in receiver {\n            println!(\"Received from thread: {}\", \n                received_val);\n        }\n    }\n    ```", "```rs\n    use std::ffi::OsStr;\n    use std::fs;\n    use std::fs::File;\n    use std::io::{BufRead, BufReader};\n    use std::path::PathBuf;\n    use std::sync::{Arc, Mutex};\n    use std::thread;\n    ```", "```rs\n    #[derive(Debug)]\n    pub struct SrcStats {\n        pub number_of_files: u32,\n        pub loc: u32,\n        pub comments: u32,\n        pub blanks: u32,\n    }\n    ```", "```rs\n      let src_stats = SrcStats {\n            number_of_files: 0,\n            loc: 0,\n            comments: 0,\n            blanks: 0,\n       };\n       let stats_counter = Arc::new(\n           Mutex::new(src_stats));\n    ```", "```rs\n        let mut dir_list = File::open(\n            \"./dirnames.txt\").unwrap();\n        let reader = BufReader::new(&mut dir_list);\n        let dir_lines: Vec<_> = reader.lines().collect();\n    ```", "```rs\n    let mut child_handles = vec![];\n    for dir in dir_lines {\n        let dir = dir.unwrap();\n        let src_stats = Arc::clone(&stats_counter);\n\n        let handle = thread::spawn(move || {\n        // Do processing: A) \n        // Do processing: B)\n        });\n        child_handles.push(handle);\n    }\n```", "```rs\n                let mut dir_entries = vec![PathBuf::\n                    from(dir)];\n                let mut file_entries = vec![];\n                while let Some(entry) = dir_entries.pop() \n                {            \n                    for inner_entry in fs::read_dir(\n                        &entry).unwrap() {\n                        if let Ok(entry) = inner_entry {\n                            if entry.path().is_dir() {\n                                dir_entries.push(\n                                    entry.path());\n                            } else {\n                                if entry.path()\n                                    .extension() \n                                   == Some(OsStr::\n                                       new(\"rs\")) \n                                {\n                                    println!(\"File name \n                                        processed is \n                                        {:?}\",entry);\n\n                                    file_entries.push(\n                                        entry);\n\n                                }\n                            }\n                        }\n                    }\n                }\n    ```", "```rs\n                for file in file_entries {\n                    let file_contents = \n                        fs::read_to_string(\n                        &file.path()).unwrap();\n\n                    let mut stats_pointer = \n                        src_stats.lock().unwrap();\n                    for line in file_contents.lines() {\n                        if line.len() == 0 {\n                            stats_pointer.blanks += 1;\n                        } else if line.starts_with(\"//\") {\n                            stats_pointer.comments += 1;\n                        } else {\n                            stats_pointer.loc += 1;\n                        }\n                    }\n\n                    stats_pointer.number_of_files += 1;\n                }\n    ```", "```rs\n        let mut child_handles = vec![];\n        for dir in dir_lines {\n            let dir = dir.unwrap();\n            let src_stats = Arc::clone(&stats_counter);\n\n            let handle = thread::spawn(move || {\n            // Do processing: step A) \n            // Do processing: step B)\n            });\n               child_handles vector.\n    ```", "```rs\n        for handle in child_handles {\n            handle.join().unwrap();\n        }\n        println!(\n            \"Source stats: {:?}\",\n            stats_counter.lock().unwrap()\n        );\n    ```", "```rs\nuse std::thread;\nuse std::time::Duration;\nfn main() {\n    let duration = Duration::new(1,0);\n    println!(\"Going to sleep\");\n    thread::sleep(duration);\n    println!(\"Woke up\");\n}\n```"]