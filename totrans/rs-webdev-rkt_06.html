<html><head></head><body>
		<div><h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor073"/>Chapter 5</em>: Designing a User-Generated Application</h1>
			<p>We are going to write a Rocket application in order to learn more about the Rocket web framework. In this chapter, we are going to design the application and create an application skeleton. Then, we are going to split the application skeleton into smaller manageable modules.</p>
			<p>After reading this chapter, you will be able to design and create an application skeleton and modularize your own application to your liking.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Designing a user-generated web application</li>
				<li>Planning the user struct</li>
				<li>Creating application routes</li>
				<li>Modularizing a Rocket application</li>
			</ul>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>Technical requirements</h1>
			<p>For this chapter, we have the same technical requirements as the previous chapter. We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database server.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter05">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/>Designing a user-generated web application</h1>
			<p>Up to now, we have gained some fundamental knowledge about the Rocket framework, such as routes, requests, responses, states, and fairings. Let's expand on that knowledge and learn more <a id="_idIndexMarker285"/>about the Rocket framework's other capabilities, such as request guards, cookies systems, forms, uploading, and templating, by creating a full-fledged application.</p>
			<p>The idea for our <a id="_idIndexMarker286"/>application is one that handles various operations for the user, and each user can create and delete user-generated content such as text, photos, or videos.</p>
			<p>We can start by creating requirements for what we want to do. In various development methodologies, there are many forms and names for defining requirements, such as user stories, use cases, software requirements, or software requirement specifications.</p>
			<p>After specifying the requirements, we can usually create an application skeleton. We can then implement the application and test the implementation.</p>
			<p>In our case, because we want to be practical and understand what is going on at the code level, we will specify the requirements and create the application skeleton in the same step.</p>
			<p>Let's start by creating a new application. Then, name the application <code>"our_application"</code> and include the <code>rocket</code> and <code>rocket_db_pools</code> crates in <code>Cargo.toml</code>:</p>
			<pre class="source-code">[package]</pre>
			<pre class="source-code">edition = "2018"</pre>
			<pre class="source-code">name = "our_application"</pre>
			<pre class="source-code">version = "0.1.0"</pre>
			<pre class="source-code">[dependencies]</pre>
			<pre class="source-code">rocket = {path = "../../../rocket/core/lib/", features = ["uuid"]}</pre>
			<pre class="source-code">rocket_db_pools = {path = "../../../rocket/contrib/db_pools/lib/", features =[ "sqlx_postgres"]}</pre>
			<p>Modify the <code>src/main.rs</code> file to remove the <code>main()</code> function and make sure we have the <a id="_idIndexMarker287"/>most basic Rocket application:</p>
			<pre class="source-code">#[macro_use]</pre>
			<pre class="source-code">extern crate rocket;</pre>
			<pre class="source-code">use rocket::{Build, Rocket};</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build()</pre>
			<pre class="source-code">}</pre>
			<p>Let's go to the next step by planning what user data we want to have in our application.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Planning the user struct</h2>
			<p>Let's write the <a id="_idIndexMarker288"/>struct for the user in the application. At the most basic level, we want to have <code>uuid</code> with the <code>Uuid</code> type as a unique identifier, and <code>username</code> with the <code>String</code> type as a human-rememberable identifier. Then, we can add extra columns such as <code>email</code> and <code>description</code> with a <code>String</code> type to store a little bit more information about our user.</p>
			<p>We also want to have <code>password</code> for the user data but having a cleartxt <code>password</code> field is not an option. There are a couple of hashing options, but obviously, we cannot use insecure old hashing functions such as <code>md5</code> or <code>sha1</code>. We can, however, use newer secure hashing encryptions such as <code>bcrypt</code>, <code>scrypt</code>, or <code>argon2</code>. In this book, we will use the <code>argon2id</code> function, as it is <a id="_idIndexMarker289"/>more resistant to <code>String</code> as the <code>password_hash</code> type.</p>
			<p>We also want a <code>status</code> column for our users. The status can be either <code>active</code> or <code>inactive</code>, so we can use the <code>bool</code> type. But, in the future, we might want it to be expandable and have other statuses, such as <code>confirmed</code> if we require the user to include email information and confirm their email before they can use our application. We have to use another type.</p>
			<p>In Rust, we have <code>enum</code>, a type <a id="_idIndexMarker291"/>with many variants. We can either have <a id="_idIndexMarker292"/>an enum with an <strong class="bold">implicit discriminator</strong> or an <strong class="bold">explicit discriminator</strong>.</p>
			<p>An implicit <a id="_idIndexMarker293"/>discriminator enum is an enum in which the member is not given a discriminator; it automatically starts from <code>0</code>, for example, <code>enum Status {Active, Inactive}</code>. Using an implicit discriminator enum means we have to add a new data type in PostgreSQL using the <code>CREATE TYPE</code> SQL statement, for example, <code>CREATE TYPE status AS ENUM ('active', 'inactive');</code>.</p>
			<p>If we use an explicit discriminator enum, that is, an enum in which the member is given a discriminator, we can use the PostgreSQL <code>INTEGER</code> type and map it to <code>rust i32</code>. An explicit discriminator enum looks like the following:</p>
			<pre class="source-code">enum Status {</pre>
			<pre class="source-code">    Inactive = 0,</pre>
			<pre class="source-code">    Active = 1,</pre>
			<pre class="source-code">}</pre>
			<p>Because it's simpler to use an explicit discriminator enum, we will choose this type for the user status column.</p>
			<p>We also want to keep track of when user data is created and when it is updated. The Rust standard library provides <code>std::time</code> for temporal quantification types, but this module is very primitive and not usable for day-to-day operations. There are several attempts to create a good date and time library for Rust, such as the <code>time</code> or <code>chrono</code> crates, and fortunately, <code>sqlx</code> already supports both crates. We chose to use <code>chrono</code> for this book.</p>
			<p>Based on those requirements, let's write the struct definition and the <code>sqlx</code> migration for the <code>User</code> type:</p>
			<ol>
				<li>In <code>Cargo.toml</code>, add the <code>sqlx</code>, <code>chrono</code>, and <code>uuid</code> crates: <pre>sqlx = {version = "0.5.9", features = ["postgres", "uuid", "runtime-tokio-rustls", "chrono"]}
chrono = "0.4"
uuid = {version = "0.8.2", features = ["v4"]}</pre></li>
				<li>In <code>src/main.rs</code>, add <a id="_idIndexMarker294"/>the <code>UserStatus</code> enum and the <code>User</code> struct:<pre>use chrono::{offset::Utc, DateTime};
use rocket_db_pools::sqlx::FromRow;
use uuid::Uuid;
#[derive(sqlx::Type, Debug)]
#[repr(i32)]
enum UserStatus {
    Inactive = 0,
    Active = 1,
}
#[derive(Debug, FromRow)]
struct User {
    uuid: Uuid,
    username: String,
    email: String,
    password_hash: String,
    description: String,
    status: UserStatus,
    created_at: DateTime&lt;Utc&gt;,
    updated_at: DateTime&lt;Utc&gt;,
}</pre></li>
			</ol>
			<p>Notice that we set the <code>UserStatus</code> enum with an explicit discriminator and, in the <code>User</code> struct, we used <code>UserStatus</code> as the status type.</p>
			<ol>
				<li value="3">After that, let's <a id="_idIndexMarker295"/>set the database URL configuration in the <code>Rocket.toml</code> file:<pre>[default]
[default.databases.main_connection]
url = "postgres://username:password@localhost/rocket"</pre></li>
				<li>Afterward, create the database migration using the <code>sqlx migrate add</code> command again, and modify the generated migration file as follows:<pre>CREATE TABLE IF NOT EXISTS users
(
    uuid          UUID PRIMARY KEY,
    username      VARCHAR NOT NULL UNIQUE,
    email         VARCHAR NOT NULL UNIQUE,
    password_hash VARCHAR NOT NULL,
    description   TEXT,
    status        INTEGER NOT NULL DEFAULT 0,
    created_at    TIMESTAMPTZ NOT NULL DEFAULT 
    CURRENT_TIMESTAMP,
    updated_at    TIMESTAMPTZ NOT NULL DEFAULT 
    CURRENT_TIMESTAMP
);</pre></li>
			</ol>
			<p>Notice that we set <code>INTEGER</code>, which corresponds to <code>i32</code> in Rust as a <code>status</code> column type. One more thing to notice is because the <code>UNIQUE</code> constraints in PostgreSQL already automatically create an index for <code>username</code> and <code>email</code>, we don't need to add custom indices for those two columns.</p>
			<p>Don't forget to run the <code>sqlx migrate run</code> command line again to run this migration.</p>
			<ol>
				<li value="5">Let's initialize <a id="_idIndexMarker296"/>the database connection pool fairing by adding these lines in <code>src/main.rs</code>:<pre><strong class="bold">use rocket_db_pools::{sqlx::{FromRow, PgPool}, Database};</strong>
...
<strong class="bold">#[derive(Database)]</strong>
<strong class="bold">#[database("main_connection")]</strong>
<strong class="bold">struct DBConnection(PgPool);</strong>
async fn rocket() -&gt; Rocket&lt;Build&gt; {
    rocket::build<strong class="bold">().attach(DBConnection::init())</strong>
}</pre></li>
			</ol>
			<p>After our <code>User</code> struct is ready, the next thing we can do is write the code skeleton for user-related routes, such as creating or deleting users.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>Creating user routes</h2>
			<p>In the previous application, we dealt primarily with getting user data, but in a real-world application, we also <a id="_idIndexMarker297"/>want other operations such as inserting, updating, and deleting data. We can expand the two functions to <a id="_idIndexMarker298"/>get user data (user and users) into <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) functions. These four basic functions can be considered fundamental operations of persistent data storage.</p>
			<p>In a web application, an architecture style exists to perform operations based on the HTTP method. If we want to get an entity or a collection of entities, we use the <code>HTTP GET</code> method. If we want to create an entity, we use the <code>HTTP POST</code> method. If we want to update an entity, we use the <code>HTTP PUT</code> or <code>PATCH</code> method. And finally, if we want to delete an entity, we use the <code>HTTP DELETE</code> method. Using those HTTP methods to deliver <a id="_idIndexMarker299"/>data uniformly is called <strong class="bold">representational state transfer</strong> (<strong class="bold">REST</strong>), and an application following that constraint is called <strong class="bold">RESTful</strong>.</p>
			<p>Before we create RESTful user <a id="_idIndexMarker300"/>routes for our application, let's think about what <a id="_idIndexMarker301"/>incoming parameters we want to handle and what responses we want to return. In the previous chapters, we have created routes that returned <code>String</code>, but most of the web is composed of HTML.</p>
			<p>For user route responses, we want HTML, so we can use <code>rocket::response::content::RawHtml</code>. We can wrap it in <code>Result</code>, with <code>Status</code> as the error type. Let's make a type alias to avoid writing <code>Result&lt;RawHtml&lt;String&gt;, Status&gt;</code> every time we use it as a route function return type. Add this in <code>src/main.rs</code>:</p>
			<pre class="source-code">type HtmlResponse = Result&lt;RawHtml&lt;String&gt;, Status&gt;;</pre>
			<p>For user route requests, the request payload will be different depending on what the request is. For a function that uses GET to obtain a particular user information, we would need to know the identifier of the user, in our case, it would be <code>uuid</code> in the <code>&amp;str</code> type. We just need the reference (<code>&amp;str</code>) because we are not going to process <code>uuid</code>, so we don't need the <code>String</code> type:</p>
			<pre class="source-code">#[get("/users/&lt;_uuid&gt;", format = "text/html")]</pre>
			<pre class="source-code">async fn get_user(mut _db: Connection&lt;DBConnection&gt;, _uuid: &amp;str) -&gt; HtmlResponse {</pre>
			<pre class="source-code">    todo!("will implement later")</pre>
			<pre class="source-code">}</pre>
			<p>The compiler will emit a warning if we define a variable or pass a parameter but do not use it, so we use an underscore (<code>_</code>) before the variable name in the function argument to suppress the compiler warning for now. We will change the variable to one without an underscore in front of it when we are implementing the function later.</p>
			<p>Just like the <code>unimplemented!</code> macro, the <code>todo!</code> macro is useful for prototyping. The semantic difference is that if we use <code>todo!</code>, we are saying that the code will be implemented, but if we use <code>unimplemented!</code>, we are not making any promises.</p>
			<p>Mount the route and try running the application now and make the HTTP request to this endpoint. You can see how the application will panic, but fortunately, Rocket handles catching the panic in the server using the <code>std::panic::catch_unwind</code> function.</p>
			<p>For the <a id="_idIndexMarker302"/>list of users, we have to think about the scalability of our application. If we have a lot of users, it would not be very efficient if we tried to query all the users. We need to introduce some kind of pagination in our application.</p>
			<p>One of the weaknesses of using <code>Uuid</code> as an entity ID is that we cannot sort and order the entity by its ID. We have to use another ordered field. Fortunately, we have defined the <code>created_at</code> field with <code>TIMESTAMPZ</code>, which has a 1-microsecond resolution and can be ordered.</p>
			<p>But, be aware that if your application is handling high traffic or will be in distributed systems, the microsecond resolution might not be enough. You can calculate the chance of collision of <code>TIMESTAMPZ</code> using a formula to calculate the <em class="italic">birthday paradox</em>. You can solve this problem with a monotonic ID or hardware and a database supporting a nanosecond resolution, but a highly-scalable application is beyond the scope of this book for the Rocket web framework.</p>
			<p>Let's define the <code>Pagination</code> struct for now and then we will implement this struct later. As we want to use <code>Pagination</code> in the list of users and we will use it as a <code>request</code> parameter, we can automatically use <code>#[derive(FromForm)]</code> to make auto-generation for the <code>rocket::form::FromForm</code> implementation. But, we have to create a new type, <code>OurDateTime</code>, because orphan rules mean we cannot implement <code>rocket::form::FromForField</code> for <code>DateTime&lt;Utc&gt;;</code>:</p>
			<pre class="source-code"><strong class="bold">use rocket::form::{self, DataField, FromFormField, ValueField};</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code"><strong class="bold">#[derive(Debug, FromRow)]</strong></pre>
			<pre class="source-code"><strong class="bold">struct OurDateTime(DateTime&lt;Utc&gt;);</strong></pre>
			<pre class="source-code"><strong class="bold">#[rocket::async_trait]</strong></pre>
			<pre class="source-code"><strong class="bold">impl&lt;'r&gt; FromFormField&lt;'r&gt; for OurDateTime {</strong></pre>
			<pre class="source-code"><strong class="bold">    fn from_value(_: ValueField&lt;'r&gt;) -&gt; form::Result&lt;'r, </strong></pre>
			<pre class="source-code"><strong class="bold">    Self&gt; {</strong></pre>
			<pre class="source-code"><strong class="bold">        todo!("will implement later")</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code"><strong class="bold">    async fn from_data(_: DataField&lt;'r, '_&gt;) -&gt; form::</strong></pre>
			<pre class="source-code"><strong class="bold">    Result&lt;'r, Self&gt; {</strong></pre>
			<pre class="source-code"><strong class="bold">        todo!("will implement later")</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code"><strong class="bold">#[derive(FromForm)]</strong></pre>
			<pre class="source-code"><strong class="bold">struct Pagination {</strong></pre>
			<pre class="source-code"><strong class="bold">    cursor: OurDateTime,</strong></pre>
			<pre class="source-code"><strong class="bold">    limit: usize,</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code">#[derive(sqlx::Type, Debug, <strong class="bold">FromFormField</strong>)]</pre>
			<pre class="source-code">#[repr(i32)]</pre>
			<pre class="source-code">enum UserStatus {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[derive(Debug, FromRow, <strong class="bold">FromForm</strong>)]</pre>
			<pre class="source-code">struct User {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    created_at: <strong class="bold">OurDateTime</strong>,</pre>
			<pre class="source-code">    updated_at: <strong class="bold">OurDateTime</strong>,</pre>
			<pre class="source-code">}</pre>
			<p>Now, we <a id="_idIndexMarker303"/>can make an unimplemented function for the list of users:</p>
			<pre class="source-code">#[get("/users?&lt;_pagination&gt;", format = "text/html")]</pre>
			<pre class="source-code">async fn get_users(mut _db: Connection&lt;DBConnection&gt;, _pagination: Option&lt;Pagination&gt;) -&gt; HtmlResponse {</pre>
			<pre class="source-code">    todo!("will implement later")</pre>
			<pre class="source-code">}</pre>
			<p>We need a page to fill in the form for inputting new user data:</p>
			<pre class="source-code">#[get("/users/new", format = "text/html")]</pre>
			<pre class="source-code">async fn new_user(mut _db: Connection&lt;DBConnection&gt;) -&gt; HtmlResponse {</pre>
			<pre class="source-code">    todo!("will implement later")</pre>
			<pre class="source-code">}</pre>
			<p>After that, we can create a function to handle the creation of user data:</p>
			<pre class="source-code">use rocket::form::{self, DataField, <strong class="bold">Form</strong>, FromFormField, ValueField};</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code"><strong class="bold">#[post("/users", format = "text/html", data = "&lt;_user&gt;")]</strong></pre>
			<pre class="source-code"><strong class="bold">async fn create_user(mut _db: Connection&lt;DBConnection&gt;, _user: Form&lt;User&gt;) -&gt; HtmlResponse {</strong></pre>
			<pre class="source-code"><strong class="bold">    todo!("will implement later")</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<p>We need a page to modify existing user data:</p>
			<pre class="source-code">#[get("/users/edit/&lt;_uuid&gt;", format = "text/html")]</pre>
			<pre class="source-code">async fn edit_user(mut _db: Connection&lt;DBConnection&gt;, _uuid: &amp;str) -&gt; HtmlResponse {</pre>
			<pre class="source-code">    todo!("will implement later")</pre>
			<pre class="source-code">}</pre>
			<p>We need <a id="_idIndexMarker304"/>functions to handle updating user data:</p>
			<pre class="source-code">#[put("/users/&lt;_uuid&gt;", format = "text/html", data = "&lt;_user&gt;")]</pre>
			<pre class="source-code">async fn put_user(mut _db: Connection&lt;DBConnection&gt;, _uuid: &amp;str, _user: Form&lt;User&gt;) -&gt; HtmlResponse {</pre>
			<pre class="source-code">    todo!("will implement later")</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[patch("/users/&lt;_uuid&gt;", format = "text/html", data = "&lt;_user&gt;")]</pre>
			<pre class="source-code">async fn patch_user(</pre>
			<pre class="source-code">    mut _db: Connection&lt;DBConnection&gt;,</pre>
			<pre class="source-code">    _uuid: &amp;str,</pre>
			<pre class="source-code">    _user: Form&lt;User&gt;,</pre>
			<pre class="source-code">) -&gt; HtmlResponse {</pre>
			<pre class="source-code">    todo!("will implement later")</pre>
			<pre class="source-code">}</pre>
			<p>What's the difference between <code>PUT</code> and <code>PATCH</code>? Simply put, in REST, a <code>PUT</code> request is used if we want to replace the resource completely, and <code>PATCH</code> is used to update data partially.</p>
			<p>The last <a id="_idIndexMarker305"/>user-related function is a function to execute <code>HTTP DELETE</code>:</p>
			<pre class="source-code">#[delete("/users/&lt;_uuid&gt;", format = "text/html")]</pre>
			<pre class="source-code">async fn delete_user(mut _db: Connection&lt;DBConnection&gt;, _uuid: &amp;str) -&gt; HtmlResponse {</pre>
			<pre class="source-code">    todo!("will implement later")</pre>
			<pre class="source-code">}</pre>
			<p>After creating user-related route handling functions, we can expand our requirements.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>Making user-generated contents</h2>
			<p>An application that only handles user data is not fun, so we will add the capability for our users <a id="_idIndexMarker306"/>to upload and delete posts. Each post can be either a text post, a photo post, or a video post. Let's look at the steps:</p>
			<ol>
				<li value="1">Create the definition for <code>Post</code>:<pre>#[derive(sqlx::Type, Debug, FromFormField)]
#[repr(i32)]
enum PostType {
    Text = 0,
    Photo = 1,
    Video = 2,
}
#[derive(FromForm)]
struct Post {
    uuid: Uuid,
    user_uuid: Uuid,
    post_type: PostType,
    content: String,
    created_at: OurDateTime,
}</pre></li>
			</ol>
			<p>We want to differentiate the type, so we added the <code>post_type</code> column. We also want to make a relationship between the user and posts. As we want the user to <a id="_idIndexMarker307"/>be able to create many posts, we can create a <code>user_uuid</code> field in the struct. The content will be used to store either text content or the file path where we store the uploaded file. We will deal with the data migration on application implementation later.</p>
			<ol>
				<li value="2">The way each post is presented might be different on our HTML, but it will occupy the same part on the web page, so let's make a <code>DisplayPostContent</code> trait and three <code>DisplayPostContent</code> for each newtype:<pre>trait DisplayPostContent {
    fn raw_html() -&gt; String;
}
struct TextPost(Post);
impl DisplayPostContent for TextPost {
    fn raw_html() -&gt; String {
        todo!("will implement later")
    }
}
struct PhotoPost(Post);
impl DisplayPostContent for PhotoPost {
    fn raw_html() -&gt; String {
        todo!("will implement later")
    }
}
struct VideoPost(Post);
impl DisplayPostContent for VideoPost {
    fn raw_html() -&gt; String {
        todo!("will implement later")
    }
}</pre></li>
				<li>Finally, we <a id="_idIndexMarker308"/>can add the routes for handling <code>Post</code>. We can create <code>get_post</code>, <code>get_posts</code>, <code>create_post</code>, and <code>delete_post</code>. We also want these routes to be under a user:<pre>#[get("/users/&lt;_user_uuid&gt;/posts/&lt;_uuid&gt;", format = "text/html")]
async fn get_post(mut _db: Connection&lt;DBConnection&gt;, _user_uuid: &amp;str, _uuid: &amp;str) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[get("/users/&lt;_user_uuid&gt;/posts?&lt;_pagination&gt;", format = "text/html")]
async fn get_posts(
    mut _db: Connection&lt;DBConnection&gt;,
    _user_uuid: &amp;str,
    _pagination: Option&lt;Pagination&gt;,
) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[post("/users/&lt;_user_uuid&gt;/posts", format = "text/html", data = "&lt;_upload&gt;")]
async fn create_post(
    mut _db: Connection&lt;DBConnection&gt;,
    _user_uuid: &amp;str,
    _upload: Form&lt;Post&gt;,
) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[delete("/users/&lt;_user_uuid&gt;/posts/&lt;_uuid&gt;", format = "text/html")]
async fn delete_post(
    mut _db: Connection&lt;DBConnection&gt;,
    _user_uuid: &amp;str,
    _uuid: &amp;str,
) -&gt; HtmlResponse {
    todo!("will implement later")
}</pre></li>
			</ol>
			<p>After <a id="_idIndexMarker309"/>adding post-related types and functions, we can finalize creating the application skeleton in the next subsection.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Finalizing the application</h2>
			<p>Don't forget <a id="_idIndexMarker310"/>to add these routes to the Rocket initialization process:</p>
			<pre class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">   rocket::build().attach(DBConnection::init())<strong class="bold">.mount(</strong></pre>
			<pre class="source-code">        <strong class="bold">"/",</strong></pre>
			<pre class="source-code"><strong class="bold">        routes![</strong></pre>
			<pre class="source-code"><strong class="bold">            get_user,</strong></pre>
			<pre class="source-code"><strong class="bold">            get_users,</strong></pre>
			<pre class="source-code"><strong class="bold">            new_user,</strong></pre>
			<pre class="source-code"><strong class="bold">            create_user,</strong></pre>
			<pre class="source-code"><strong class="bold">            edit_user,</strong></pre>
			<pre class="source-code"><strong class="bold">            put_user,</strong></pre>
			<pre class="source-code"><strong class="bold">            patch_user,</strong></pre>
			<pre class="source-code"><strong class="bold">            delete_user,</strong></pre>
			<pre class="source-code"><strong class="bold">            get_post,</strong></pre>
			<pre class="source-code"><strong class="bold">            get_posts,</strong></pre>
			<pre class="source-code"><strong class="bold">            create_post,</strong></pre>
			<pre class="source-code"><strong class="bold">            delete_post,</strong></pre>
			<pre class="source-code"><strong class="bold">        ],</strong></pre>
			<pre class="source-code"><strong class="bold">    )</strong></pre>
			<pre class="source-code">}</pre>
			<p>We also want to serve the uploaded file through a route:</p>
			<pre class="source-code">use rocket::fs::<strong class="bold">{NamedFile, </strong>TempFile<strong class="bold">}</strong>;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code"><strong class="bold">#[get("/&lt;_filename&gt;")]</strong></pre>
			<pre class="source-code"><strong class="bold">async fn assets(_filename: &amp;str) -&gt; NamedFile {</strong></pre>
			<pre class="source-code"><strong class="bold">    todo!("will implement later")</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build()</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        <strong class="bold">.mount("/assets", routes![assets])</strong></pre>
			<pre class="source-code">}</pre>
			<p>Time to <a id="_idIndexMarker311"/>add our default error handling! Other frameworks usually have a default error handler for HTTP status codes <code>404</code>, <code>422</code>, and <code>500</code>. Let's make a handler for these codes:</p>
			<pre class="source-code"><strong class="bold">use rocket::request::Request;</strong></pre>
			<pre class="source-code"><strong class="bold">...</strong></pre>
			<pre class="source-code"><strong class="bold">#[catch(404)]</strong></pre>
			<pre class="source-code"><strong class="bold">fn not_found(_: &amp;Request) -&gt; RawHtml&lt;String&gt; {</strong></pre>
			<pre class="source-code"><strong class="bold">    todo!("will implement later")</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code"><strong class="bold">#[catch(422)]</strong></pre>
			<pre class="source-code"><strong class="bold">fn unprocessable_entity(_: &amp;Request) -&gt; RawHtml&lt;String&gt; {</strong></pre>
			<pre class="source-code"><strong class="bold">    todo!("will implement later")</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code"><strong class="bold">#[catch(500)]</strong></pre>
			<pre class="source-code"><strong class="bold">fn internal_server_error(_: &amp;Request) -&gt; RawHtml&lt;String&gt; {</strong></pre>
			<pre class="source-code"><strong class="bold">    todo!("will implement later")</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build()</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        <strong class="bold">.register(</strong></pre>
			<pre class="source-code"><strong class="bold">            "/",</strong></pre>
			<pre class="source-code"><strong class="bold">            catchers![not_found, unprocessable_entity, </strong></pre>
			<pre class="source-code"><strong class="bold">            internal_server_error],</strong></pre>
			<pre class="source-code"><strong class="bold">        )</strong></pre>
			<pre class="source-code">}</pre>
			<p>When we <a id="_idIndexMarker312"/>run the application using Cargo's <code>run</code> command, the application should launch correctly. But, when we look at <code>src/main.rs</code>, the file has a lot of functions and type definitions. We will modularize our application in the next section.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/>Modularizing the Rocket application</h1>
			<p>Remember <a id="_idIndexMarker313"/>in <a href="B16825_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Introducing the Rust Language</em>, when we made an application with modules? One of the functions of the application source code is to use it as documentation for the people working on the application. A good readable code can be easily further developed and shared with other people on the team.</p>
			<p>The compiler does not care whether the program is in one file or multiple files; the resulting application binary is the same. However, people working on a single, long file can get confused very easily.</p>
			<p>We are going to split our application source code into smaller files and categorize the files into different modules. Programmers come from various backgrounds and may have their own paradigm on how to split the source code of the application. For example, programmers who are used to writing Java programs may prefer organizing their code based on the logical entities or classes. People who are used to Model-Viev-Controller (MVC) frameworks may prefer putting files in models, views, and controllers folders. People who are used to clean architecture may <a id="_idIndexMarker314"/>try to organize their code into layers. But, at the end of the day, what really matters is that the way you organize your code is accepted by the people you work with, and they can all comfortably and easily use the same source code.</p>
			<p>Rocket does not have specific guidelines on how to organize the code, but there are two things that we can observe to modularize our application. The first one is the <code>Cargo</code> project package layout convention, and the second one is the Rocket parts themselves.</p>
			<p>According to Cargo documentation (<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">https://doc.rust-lang.org/cargo/guide/project-layout.html</a>), the package layout should be as follows:</p>
			<pre class="source-code">┌── Cargo.lock</pre>
			<pre class="source-code">├── Cargo.toml</pre>
			<pre class="source-code">├── src/</pre>
			<pre class="source-code">│   ├── lib.rs</pre>
			<pre class="source-code">│   ├── main.rs</pre>
			<pre class="source-code">│   └── bin/</pre>
			<pre class="source-code">│       ├── named-executable.rs</pre>
			<pre class="source-code">│       ├── another-executable.rs</pre>
			<pre class="source-code">│       └── multi-file-executable/</pre>
			<pre class="source-code">│           ├── main.rs</pre>
			<pre class="source-code">│           └── some_module.rs</pre>
			<pre class="source-code">├── benches/</pre>
			<pre class="source-code">│   ├── large-input.rs</pre>
			<pre class="source-code">│   └── multi-file-bench/</pre>
			<pre class="source-code">│       ├── main.rs</pre>
			<pre class="source-code">│       └── bench_module.rs</pre>
			<pre class="source-code">├── examples/</pre>
			<pre class="source-code">│   ├── simple.rs</pre>
			<pre class="source-code">│   └── multi-file-example/</pre>
			<pre class="source-code">│       ├── main.rs</pre>
			<pre class="source-code">│       └── ex_module.rs</pre>
			<pre class="source-code">└── tests/</pre>
			<pre class="source-code">    ├── some-integration-tests.rs</pre>
			<pre class="source-code">    └── multi-file-test/</pre>
			<pre class="source-code">        ├── main.rs</pre>
			<pre class="source-code">        └── test_module.rs</pre>
			<p>Since we <a id="_idIndexMarker315"/>don't have benchmarks, examples, or tests yet, let's focus on the <code>src</code> folder. We can split the application into an executable in <code>src/main.rs</code> and a library in <code>src/lib.rs</code>. It's very common in an executable project to make a small executable code that only calls the library.</p>
			<p>We already know Rocket has different parts, so it's a good idea to split the Rocket components into <a id="_idIndexMarker316"/>their own module. Let's organize our source code into these files and folders:</p>
			<pre class="source-code">┌── Cargo.lock</pre>
			<pre class="source-code">├── Cargo.toml</pre>
			<pre class="source-code">└── src/</pre>
			<pre class="source-code">    ├── lib.rs</pre>
			<pre class="source-code">    ├── main.rs</pre>
			<pre class="source-code">    ├── catchers</pre>
			<pre class="source-code">    │   └── put catchers modules here</pre>
			<pre class="source-code">    ├── fairings</pre>
			<pre class="source-code">    │   └── put fairings modules here</pre>
			<pre class="source-code">    ├── models</pre>
			<pre class="source-code">    │   └── put requests, responses, and database related modules here</pre>
			<pre class="source-code">    ├── routes</pre>
			<pre class="source-code">    │   └── put route handling functions and modules here</pre>
			<pre class="source-code">    ├── states</pre>
			<pre class="source-code">    │   └── put states modules here</pre>
			<pre class="source-code">    ├── traits</pre>
			<pre class="source-code">    │   └── put our traits here</pre>
			<pre class="source-code">    └── views</pre>
			<pre class="source-code">        └── put our templates here</pre>
			<ol>
				<li value="1">First, edit the <code>Cargo.toml</code> file:<pre>[package]
...
<strong class="bold">[[bin]]</strong>
<strong class="bold">name = "our_application"</strong>
<strong class="bold">path = "src/main.rs"</strong>
<strong class="bold">[lib]</strong>
<strong class="bold">name = "our_application"</strong>
<strong class="bold">path = "src/lib.rs"</strong>
[dependencies]
...</pre></li>
				<li>Create the <code>src/lib.rs</code> file and the following folders: <code>src/catchers</code>, <code>src/fairings</code>, <code>src/models</code>, <code>src/routes</code>, <code>src/states</code>, <code>src/traits</code>, and <code>src/views</code>.</li>
				<li>After <a id="_idIndexMarker317"/>that, create a <code>mod.rs</code> file inside each folder: <code>src/catchers/mod.rs</code>, <code>src/fairings/mod.rs</code>, <code>src/models/mod.rs</code>, <code>src/routes/mod.rs</code>, <code>src/states/mod.rs</code>, <code>src/traits/mod.rs</code>, and <code>src/views/mod.rs</code>.</li>
				<li>Then, edit <code>src/lib.rs</code>:<pre>#[macro_use]
extern crate rocket;
pub mod catchers;
pub mod fairings;
pub mod models;
pub mod routes;
pub mod states;
pub mod traits;</pre></li>
				<li>Write the connection for our database first. Edit <code>src/fairings/mod.rs</code>:<pre>pub mod db;</pre></li>
				<li>Make a new file, <code>src/fairings/db.rs</code>, and write the file just like the connection <a id="_idIndexMarker318"/>we defined earlier in <code>src/main.rs</code>:<pre>use rocket_db_pools::{sqlx::PgPool, Database};
#[derive(Database)]
#[database("main_connection")]
pub struct DBConnection(PgPool);</pre></li>
			</ol>
			<p>Notice that we use only use a smaller number of modules compared to <code>src/main.rs</code>. We also added the <code>pub</code> keyword in order to make the struct accessible from other modules or from <code>src/main.rs</code>.</p>
			<ol>
				<li value="7">Because the trait is going to be used by the structs, we need to define the trait first. In <code>src/traits/mod.rs</code>, copy the trait from <code>src/main.rs</code>:<pre>pub trait DisplayPostContent {
    fn raw_html() -&gt; String;
}</pre></li>
				<li>After that, let's move all of our structs for requests and responses to the <code>src/models</code> folder. Edit <code>src/models/mod.rs</code> as follows:<pre>pub mod our_date_time;
pub mod pagination;
pub mod photo_post;
pub mod post;
pub mod post_type;
pub mod text_post;
pub mod user;
pub mod user_status;
pub mod video_post;</pre></li>
				<li>Then, create <a id="_idIndexMarker319"/>the files and copy the definition from <code>src/main.rs</code> to those files. The first one is <code>src/models/our_date_time.rs</code>:<pre>use chrono::{offset::Utc, DateTime};
use rocket::form::{self, DataField, FromFormField, ValueField};
#[derive(Debug)]
pub struct OurDateTime(DateTime&lt;Utc&gt;);
#[rocket::async_trait]
impl&lt;'r&gt; FromFormField&lt;'r&gt; for OurDateTime {
    fn from_value(_: ValueField&lt;'r&gt;) -&gt; form::
    Result&lt;'r, Self&gt; {
        todo!("will implement later")
    }
    async fn from_data(_: DataField&lt;'r, '_&gt;) -&gt; 
    form::Result&lt;'r, Self&gt; {
        todo!("will implement later")
    }
}</pre></li>
				<li>Next is <code>src/models/pagination.rs</code>:<pre>use super::our_date_time::OurDateTime;
#[derive(FromForm)]
pub struct Pagination {
    pub next: OurDateTime,
    pub limit: usize,
}</pre></li>
			</ol>
			<p>Notice the <code>use</code> declaration uses the <code>super</code> keyword. The Rust module is organized by hierarchy, with a module containing other modules. The <code>super</code> keyword is <a id="_idIndexMarker320"/>used to access the module containing the current module. The <code>super</code> keyword can be chained, for example, <code>use super::super::SomeModule;</code>.</p>
			<ol>
				<li value="11">After that, write <code>src/models/post_type.rs</code>:<pre>use rocket::form::FromFormField;
use rocket_db_pools::sqlx;
#[derive(sqlx::Type, Debug, FromFormField)]
#[repr(i32)]
pub enum PostType {
    Text = 0,
    Photo = 1,
    Video = 2,
}</pre></li>
				<li>Also, write <code>src/models/post.rs</code>:<pre>use super::our_date_time::OurDateTime;
use super::post_type::PostType;
use rocket::form::FromForm;
use uuid::Uuid;
#[derive(FromForm)]
pub struct Post {
    pub uuid: Uuid,
    pub user_uuid: Uuid,
    pub post_type: PostType,
    pub content: String,
    pub created_at: OurDateTime,
}</pre></li>
			</ol>
			<p>And <a id="_idIndexMarker321"/>then, write <code>src/models/user_status.rs</code>:</p>
			<pre>use rocket::form::FromFormField;
use rocket_db_pools::sqlx;
#[derive(sqlx::Type, Debug, FromFormField)]
#[repr(i32)]
pub enum UserStatus {
    Inactive = 0,
    Active = 1,
}</pre>
			<ol>
				<li value="13">Write <code>src/models/user.rs</code>:<pre>use super::our_date_time::OurDateTime;
use super::user_status::UserStatus;
use rocket::form::FromForm;
use rocket_db_pools::sqlx::FromRow;
use uuid::Uuid;
#[derive(Debug, FromRow, FromForm)]
pub struct User {
    pub uuid: Uuid,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub description: Option&lt;String&gt;,
    pub status: UserStatus,
    pub created_at: OurDateTime,
    pub updated_at: OurDateTime,
}</pre></li>
			</ol>
			<p>And then, write <a id="_idIndexMarker322"/>the three <code>post</code> newtypes, <code>src/models/photo_post.rs</code>, <code>src/models/text_post.rs</code>, and <code>src/models/video_post.rs</code>:</p>
			<pre>use super::post::Post;
use crate::traits::DisplayPostContent;
pub struct PhotoPost(Post);
impl DisplayPostContent for PhotoPost {
    fn raw_html() -&gt; String {
        todo!("will implement later")
    }
}
use super::post::Post;
use crate::traits::DisplayPostContent;
pub struct TextPost(Post);
impl DisplayPostContent for TextPost {
    fn raw_html() -&gt; String {
        todo!("will implement later")
    }
}
use super::post::Post;
use crate::traits::DisplayPostContent;
pub struct VideoPost(Post);
impl DisplayPostContent for VideoPost {
    fn raw_html() -&gt; String {
        todo!("will implement later")
    }
}</pre>
			<p>In all three files, we use the <code>crate</code> keyword in the <code>use</code> declaration. We have discussed the <code>super</code> keyword before; the <code>crate</code> keyword is referring to the current library <a id="_idIndexMarker323"/>we are working on, which is the <code>our_application</code> library. In Rust 2015 edition, it's written as a double semicolon (<code>::</code>), but since Rust 2018 edition, <code>::</code> changed to <code>crate</code>. Now, <code>::</code> means the root path of the external crate, for example, <code>::rocket::fs::NamedFile;</code>.</p>
			<p>Besides <code>super</code>, <code>::</code>, and <code>crate</code>, there are a couple more <code>use</code> declaration: <code>self</code> and <code>Self</code>. We can use <code>self</code> to avoid ambiguity when referring to items in code, as shown in this example:</p>
			<pre>use super::haha;
mod a {
    fn haha() {}
    fn other_func() {
        self::haha();
    }
}</pre>
			<p><code>Self</code> is used to refer to an associated type in a trait, as shown in this example:</p>
			<pre>trait A {
  type Any;
  fn any(&amp;self) -&gt; Self::Any;
}
struct B;
impl A for B {
  type Any = usize;
  fn any(&amp;self) -&gt; self::Any {
    100
  }
}</pre>
			<ol>
				<li value="14">Now, let's get <a id="_idIndexMarker324"/>back to the application skeleton. After all the structs, it's time to write routes for the application. Modify <code>src/routes/mod.rs</code>:<pre>use rocket::fs::NamedFile;
use rocket::http::Status;
use rocket::response::content::RawHtml;
pub mod post;
pub mod user;
type HtmlResponse = Result&lt;RawHtml&lt;String&gt;, Status&gt;;
#[get("/&lt;_filename&gt;")]
pub async fn assets(_filename: &amp;str) -&gt; NamedFile {
    todo!("will implement later")
}</pre></li>
			</ol>
			<p>We could put the function handling assets in their own Rust file, but since there's only one function and it's very simple, we can just put the function in the <code>mod.rs</code> file.</p>
			<ol>
				<li value="15">Next, create <a id="_idIndexMarker325"/>and write <code>src/routes/post.rs</code>:<pre>use super::HtmlResponse;
use crate::fairings::db::DBConnection;
use crate::models::{pagination::Pagination, post::Post};
use rocket::form::Form;
use rocket_db_pools::Connection;
#[get("/users/&lt;_user_uuid&gt;/posts/&lt;_uuid&gt;", format = "text/html")]
pub async fn get_post(
    mut _db: Connection&lt;DBConnection&gt;,
    _user_uuid: &amp;str,
    _uuid: &amp;str,
) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[get("/users/&lt;_user_uuid&gt;/posts?&lt;_pagination&gt;", format = "text/html")]
pub async fn get_posts(
    mut _db: Connection&lt;DBConnection&gt;,
    _user_uuid: &amp;str,
    _pagination: Option&lt;Pagination&gt;,
) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[post("/users/&lt;_user_uuid&gt;/posts", format = "text/html", data = "&lt;_upload&gt;")]
pub async fn create_post(
    mut _db: Connection&lt;DBConnection&gt;,
    _user_uuid: &amp;str,
    _upload: Form&lt;Post&gt;,
) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[delete("/users/&lt;_user_uuid&gt;/posts/&lt;_uuid&gt;", format = "text/html")]
pub async fn delete_post(
    mut _db: Connection&lt;DBConnection&gt;,
    _user_uuid: &amp;str,
    _uuid: &amp;str,
) -&gt; HtmlResponse {
    todo!("will implement later")
}</pre></li>
				<li>Create <a id="_idIndexMarker326"/>and write <code>src/routes/user.rs</code>:<pre>use super::HtmlResponse;
use crate::fairings::db::DBConnection;
use crate::models::{pagination::Pagination, user::User};
use rocket::form::Form;
use rocket_db_pools::Connection;
#[get("/users/&lt;_uuid&gt;", format = "text/html")]
pub async fn get_user(mut _db: Connection&lt;DBConnection&gt;, _uuid: &amp;str) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[get("/users?&lt;_pagination&gt;", format = "text/html")]
pub async fn get_users(
    mut _db: Connection&lt;DBConnection&gt;,
    _pagination: Option&lt;Pagination&gt;,
) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[get("/users/new", format = "text/html")]
pub async fn new_user(mut _db: Connection&lt;DBConnection&gt;) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[post("/users", format = "text/html", data = "&lt;_user&gt;")]
pub async fn create_user(mut _db: Connection&lt;DBConnection&gt;, _user: Form&lt;User&gt;) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[get("/users/edit/&lt;_uuid&gt;", format = "text/html")]
pub async fn edit_user(mut _db: Connection&lt;DBConnection&gt;, _uuid: &amp;str) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[put("/users/&lt;_uuid&gt;", format = "text/html", data = "&lt;_user&gt;")]
pub async fn put_user(
    mut _db: Connection&lt;DBConnection&gt;,
    _uuid: &amp;str,
    _user: Form&lt;User&gt;,
) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[patch("/users/&lt;_uuid&gt;", format = "text/html", data = "&lt;_user&gt;")]
pub async fn patch_user(
    mut _db: Connection&lt;DBConnection&gt;,
    _uuid: &amp;str,
    _user: Form&lt;User&gt;,
) -&gt; HtmlResponse {
    todo!("will implement later")
}
#[delete("/users/&lt;_uuid&gt;", format = "text/html")]
pub async fn delete_user(mut _db: Connection&lt;DBConnection&gt;, _uuid: &amp;str) -&gt; HtmlResponse {
    todo!("will implement later")
}</pre></li>
				<li>And, to finalize <a id="_idIndexMarker327"/>the library, add the catchers in <code>src/catchers/mod.rs</code>:<pre>use rocket::request::Request;
use rocket::response::content::RawHtml;
#[catch(404)]
pub fn not_found(_: &amp;Request) -&gt; RawHtml&lt;String&gt; {
    todo!("will implement later")
}
#[catch(422)]
pub fn unprocessable_entity(_: &amp;Request) -&gt; RawHtml&lt;String&gt; {
    todo!("will implement later")
}
#[catch(500)]
pub fn internal_server_error(_: &amp;Request) -&gt; RawHtml&lt;String&gt; {
    todo!("will implement later")
}</pre></li>
				<li>When the <a id="_idIndexMarker328"/>library is ready, we can modify <code>src/main.rs</code> itself:<pre>#[macro_use]
extern crate rocket;
use our_application::catchers;
use our_application::fairings::db::DBConnection;
use our_application::routes::{self, post, user};
use rocket::{Build, Rocket};
use rocket_db_pools::Database;
#[launch]
async fn rocket() -&gt; Rocket&lt;Build&gt; {
    rocket::build()
        .attach(DBConnection::init())
        .mount(
            "/",
            routes![
                user::get_user,
                user::get_users,
                user::new_user,
                user::create_user,
                user::edit_user,
                user::put_user,
                user::patch_user,
                user::delete_user,
                post::get_post,
                post::get_posts,
                post::create_post,
                post::delete_post,
            ],
        )
        .mount("/assets", routes![routes::assets])
        .register(
            "/",
            catchers![
                catchers::not_found,
                catchers::unprocessable_entity,
                catchers::internal_server_error
            ],
        )
}</pre></li>
			</ol>
			<p>Our <code>src/main.rs</code> file has become cleaner.</p>
			<p>Now, if we want <a id="_idIndexMarker329"/>to add more structs or routes, we can easily add new modules in the corresponding folders. We can also add more states or fairings and easily find the file location for those items.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/>Summary</h1>
			<p>In this chapter, we learned how to design an application, create a Rocket application skeleton, and organize the Rust application into smaller manageable modules.</p>
			<p>We also learned about concepts such as CRUD and RESTful applications, Rust <code>enum</code> discriminators, and Rust path qualifiers.</p>
			<p>Hopefully, after reading this chapter, you can apply those concepts to help you organize your code better.</p>
			<p>We will start implementing this application and learn more about Rust and Rocket concepts such as templating, request guards, cookies, and JSON, in the following chapters.</p>
		</div>
	</body></html>