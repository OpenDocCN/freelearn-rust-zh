<html><head></head><body>
        

                            
                    <h1 class="header-title">Functional Control Flow</h1>
                
            
            
                
<p>The control flow is the most basic building block of programming. Early languages had no concept of data structures or functions, only program flow. These control flow structures have evolved over time, from simple branches and loops to the complex value expressions available in Rust.</p>
<p>In this chapter, we will start developing the project that will form the basis of all code examples in this book. The first project's requirements are introduced immediately. Then, we will provide you with actionable steps to transform project requirements into a code outline with tests. Lastly, we will develop code for the full deliverable.</p>
<p>Learning outcomes:</p>
<ul>
<li>Gathering project requirements</li>
<li>Architecting a solution based on project requirements</li>
<li>Using and recognizing expressions in functional style</li>
<li>Testing the solution with integration and unit tests</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>A recent version of Rust is necessary to run the examples provided:</p>
<p><a href="https://www.rust-lang.org/en-US/install.html">https://www.rust-lang.org/en-US/install.html</a></p>
<p>This chapter's code is also available on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST">https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST</a></p>
<p>Specific installation and build instructions are also included in each chapter's <kbd>README.md</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing the program</h1>
                
            
            
                
<p>To design the program, let's look at the various aspects required for the project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gathering project requirements</h1>
                
            
            
                
<p class="mce-root">Consider this situation: Your engineering firm is being considered for a contract to design software to control the elevators for a real estate developer. The contract lists three buildings under development with various heights and non-uniform elevator designs. The elevator designs are being finalized by other subcontractors and will become available shortly after the software contract is awarded.</p>
<p class="mce-root">To submit your proposal, your firm should demonstrate the basic capabilities of your elevator control software. Then, once awarded, you will be expected to integrate these capabilities into the final software, along with modifications that are necessary to accommodate the physical elevator specifications and behaviors.</p>
<p class="mce-root">To win the proposal, your team agrees on several key points on which to outperform competitors. Namely, your elevators should do the following:</p>
<ul>
<li>Take less time moving between floors</li>
<li>Stop at each floor location more precisely</li>
<li>Provide a smoother ride for passengers in transit</li>
</ul>
<p>As a program deliverable to accompany the project proposal, you are expected to provide a simulation of elevator behavior. You are responsible for further details and implementation.</p>
<p>The following questions should be resolved now:</p>
<ul>
<li>What data will the program access and store?</li>
<li>What input will the program expect?</li>
<li>What output should the program produce?</li>
</ul>
<p>After some deliberation, your team agrees on some behaviors:</p>
<ul>
<li>The program should emphasize the elevator's location, velocity, and acceleration. Velocity determines ride duration. Acceleration determines ride comfort. The location, at rest, determines stop precision. These are the key selling points that your company will emphasize, so the demonstration software should mirror the same message.</li>
<li>As input, the program should take a file describing the number of floors and floor height, and finally a list of floor requests for the elevator to process.</li>
<li>The output of the program should be real-time information regarding the elevator's location, velocity, and acceleration. After processing all floor requests, the program should print average and standard deviations for location, velocity, and acceleration.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Architecting a code map from requirements</h1>
                
            
            
                
<p>To outline our code solution, we will use the <kbd>stubs</kbd> method. To use this process, we simply start a code project normally and fill out high-level details as we think of them. Details will be left unimplemented until we finalize the outline. After we are satisfied with the overall program design, then we can start implementing program logic. We will begin the project now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Rust project</h1>
                
            
            
                
<p>To create a new Rust project, we will perform the following steps (alternatively, you can invoke <kbd>cargo new</kbd>):</p>
<ol>
<li>Create a new folder for the Rust project</li>
<li>Create a <kbd>Cargo.toml</kbd> file, which is shown as follows:</li>
</ol>
<pre style="padding-left: 60px">[package]<br/>name = "elevator"<br/>version = "1.0.0"<br/><br/>[dependencies]</pre>
<ol start="3">
<li>Create a <kbd>src/main.rs</kbd> file, as follows:</li>
</ol>
<pre class="p1" style="padding-left: 60px">fn main()<br/>{<br/>   println!("main")<br/>}</pre>
<p>Now, we can build the project with <kbd>cargo build</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing stubs for each program requirement</h1>
                
            
            
                
<p>Program requirements are typically phrased as outcomes. What effects should this program have when you run it? Answering this question with code is often straightforward. Here is a list of steps to methodically transform project requirements into code:</p>
<ol>
<li>List all program requirements</li>
<li>List dependencies or prerequisites for each requirement</li>
<li>Create a dependency graph from the requirements and dependencies lists</li>
<li>Write stubs that implement the dependency graph</li>
</ol>
<p>With practice, these steps can be combined into a single step of writing the stub code. However, if you become overwhelmed during the architecture phase of a project, then it may be helpful to go through these steps explicitly. This is a reliable method to break down complex problems into smaller problems:</p>
<ol>
<li>Firstly, to list all program requirements, from earlier consideration, we know that we need to store real-time data for location, velocity, and acceleration. The program should accept an input file or standard input describing the number of floors, floor height, and a list of floor requests to be processed. The output of the program should be real-time elevator location, velocity, and acceleration, with a summary, upon completion, of all transport requests. The summary should list average and standard deviation for location, velocity, and acceleration.</li>
<li>Secondly, list dependencies or prerequisites for each requirement. The data seems to be atomic with no dependencies or prerequisites. The program flow seems to naturally take the form of a polling loop, updating real-time state information from sensors and issuing motion commands once per loop. There is a time-lagged circular dependency between elevator state and motion commands: motion commands are chosen based on state, and the next loop will realize the time-adjusted effect of those commands.</li>
<li>Thirdly, create a dependency graph from the requirements and dependencies lists with the following:
<ol>
<li>Store the location, velocity, and acceleration state</li>
<li>Store the motor input voltage</li>
<li>Store the input building description and floor requests</li>
<li>Parse the input and store as building description and floor requests</li>
<li>Loop while there are remaining floor requests:
<ol>
<li>Update the location, velocity, and acceleration</li>
<li>If the next floor request in the queue is satisfied, then remove it from the queue</li>
<li>Adjust motor control to process the next floor request</li>
<li>Print real-time statistics</li>
</ol>
</li>
<li>Print the summary</li>
</ol>
</li>
<li>Fourthly, write stubs that implement the dependency graph. We will update <kbd>src/main.rs</kbd> to implement this stub logic. Note that the variables, declared by <kbd>let</kbd> bindings, are stored inside the <kbd>main</kbd> function. The mutable state must be stored inside a function or a data structure. This is shown in the following code block:</li>
</ol>
<pre class="p1" style="padding-left: 60px">pub fn run_simulation()<br/>{<br/><br/>   //1. Store location, velocity, and acceleration state<br/>   let mut location: f64 = 0.0; // meters<br/>   let mut velocity: f64 = 0.0; // meters per second<br/>   let mut acceleration: f64 = 0.0; // meters per second squared<br/>   <br/>   //2. Store motor input voltage<br/>   let mut up_input_voltage: f64 = 0.0;<br/>   let mut down_input_voltage: f64 = 0.0;<br/><br/>   //3. Store input building description and floor requests<br/>   let mut floor_count: u64 = 0;<br/>   let mut floor_height: f64 = 0.0; // meters<br/>   let mut floor_requests: Vec&lt;u64&gt; = Vec::new();<br/><br/>   //4. Parse input and store as building description and floor requests<br/><br/>   //5. Loop while there are remaining floor requests<br/>   while floor_requests.len() &gt; 0<br/>   {<br/>      //5.1. Update location, velocity, and acceleration<br/><br/>      //5.2. If next floor request in queue is satisfied, then remove from queue<br/><br/>      //5.3. Adjust motor control to process next floor request<br/><br/>      //5.4. Print realtime statistics<br/>   }<br/><br/>   //6. Print summary<br/>   println!("summary");<br/>}<br/><br/>fn main()<br/>{<br/>   run_simulation()<br/>}</pre>
<p>Alternatively, we could have written the loop as a separate function. The function would check the condition, and the function would potentially call itself again. When a function calls itself, this is called <strong>recursion</strong>. Recursion is an extremely common and important pattern in functional programming. However, this specific type of recursion, known as <strong>tail recursion</strong>, is not recommended in Rust currently (see RFC #271 (<a href="https://github.com/rust-lang/rfcs/issues/271">https://github.com/rust-lang/rfcs/issues/271</a>)—without this proposed optimization, the tail recursion may unnecessarily use extra stack space and run out of memory).</p>
<p>The recursive loop code would become as follows:</p>
<pre style="padding-left: 30px">fn process_floor_requests(...)<br/>{<br/>   if floor_requests.len() == 0 { return; }<br/><br/>   //5.1 Update location, velocity, and acceleration<br/><br/>   //5.2 If next floor request in queue is satisfied, then remove from queue<br/><br/>   //5.3 Adjust motor control to process next floor request<br/><br/>   //5.4 Print realtime statistics<br/><br/>   //tail recursion<br/>   process_floor_requests(...)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing program logic</h1>
                
            
            
                
<p>Once a stub program has been created, we can proceed to replace stubs with working code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Filling in the blanks</h1>
                
            
            
                
<p>Now that we have code stubs and a map of each feature that needs to be implemented, we can begin writing the code logic. At this point, if you are working on a team, then this would be a good time to divide the work. The architecture phase may be done by one person, or as a team, but it can't be done in parallel. In contrast, the implementation phase can be broken into parts to work on separately.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parsing input and storing as building description and floor requests</h1>
                
            
            
                
<p>To parse input, we first need to decide whether to expect input from <kbd>stdin</kbd> or from a file. We will adopt the convention that if a filename is provided to the program, then we will read from the file; if the file name is <kbd>-</kbd> then read from <kbd>stdin</kbd>, and otherwise read from <kbd>test1.txt</kbd>.</p>
<p>Using the Rust <kbd>std::env</kbd> package and a pattern <kbd>match</kbd> statement, we can accomplish this quite easily. This is shown as follows:</p>
<pre class="p1">let buffer = match env::args().nth(1) {<br/>   Some(ref fp) if *fp == "-".to_string()  =&gt; {<br/>      let mut buffer = String::new();<br/>      io::stdin().read_to_string(&amp;mut buffer)<br/>                 .expect("read_to_string failed");<br/>      buffer<br/>   },<br/>   None =&gt; {<br/>      let fp = "test1.txt";<br/>      let mut buffer = String::new();<br/>      File::open(fp)<br/>         .expect("File::open failed")<br/>         .read_to_string(&amp;mut buffer)<br/>         .expect("read_to_string failed");<br/>         buffer<br/>   },<br/>   Some(fp) =&gt; {<br/>      let mut buffer = String::new();<br/>      File::open(fp)<br/>         .expect("File::open failed")<br/>         .read_to_string(&amp;mut buffer)<br/>         .expect("read_to_string failed");<br/>      buffer<br/>   }<br/>};<br/></pre>
<p>Now, we need to parse the string's input. For each line in the input, we store the parsed value as either a floor count, floor height, or floor request, in that order. Here is the code to implement this:</p>
<pre class="p1">for (li,l) in buffer.lines().enumerate() {<br/>   if li==0 {<br/>      floor_count = l.parse::&lt;u64&gt;().unwrap();<br/>   } else if li==1 {<br/>      floor_height = l.parse::&lt;f64&gt;().unwrap();<br/>   } else {<br/>      floor_requests.push(l.parse::&lt;u64&gt;().unwrap());<br/>   }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating location, velocity, and acceleration</h1>
                
            
            
                
<p>Here, we need to update the program's state to reflect physical changes in the state variables since the previous loop iteration. All of these changes depend on knowledge of how much time has elapsed since the previous iteration, but we don't have that information store. So, let's make some small changes to our code.</p>
<ol>
<li>Store a timestamp of the previous iteration outside of the loop:</li>
</ol>
<pre class="p1" style="padding-left: 60px">let mut prev_loop_time = Instant::now();</pre>
<ol start="2">
<li>Calculate the elapsed time, then overwrite the previous timestamp:</li>
</ol>
<pre class="p1" style="padding-left: 60px">let now = Instant::now();<br/>let dt = now.duration_since(prev_loop_time)<br/>            .as_fractional_secs();<br/>prev_loop_time = now;</pre>
<ol start="3">
<li>To improve accuracy, sleep for a while at the end of the loop (it is difficult to accurately record sub-millisecond measurements):</li>
</ol>
<pre class="p1" style="padding-left: 60px">thread::sleep(time::Duration::from_millis(10));</pre>
<p>Now, we can start to calculate the new location, velocity, and acceleration. The location is calculated as previous location plus velocity over time. Velocity is calculated as previous velocity plus acceleration over time. Acceleration is calculated as <em>F=ma</em> and will be calculated from the motor force and carriage weight. At this point, we realize that carriage weight is not specified in the input file, but after some discussion, the team decides to use a standard carriage weight rather than change the input format.</p>
<p>With a little research, you find that an elevator carriage weighs about 1,200 kg. Similarly, you estimate that a simple DC motor can produce roughly eight newtons of force per volt. The resulting code looks like the following:</p>
<pre class="p1" style="padding-left: 30px">location = location + velocity * dt;<br/>velocity = velocity + acceleration * dt;<br/>acceleration = {<br/>   let F = (up_input_voltage - down_input_voltage) * 8.0;<br/>   let m = 1200000.0;<br/>   //-9.8 is an approximation of acceleration due to gravity<br/>   -9.8 + F/m<br/>};</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">If the next floor request in the queue is satisfied, then remove it from the queue</h1>
                
            
            
                
<p>To complete a floor request, we must be at the destination floor and stopped. We assume that a sufficiently low velocity can be stopped with some sort of brake. This will hold us in place steadily until passengers depart or enter the elevator. The code is as follows:</p>
<pre class="p1" style="padding-left: 30px">let next_floor = floor_requests[0];<br/>if (location - (next_floor as f64)*floor_height).abs() &lt; 0.01<br/>   &amp;&amp; velocity.abs() &lt; 0.01<br/>{<br/>   velocity = 0.0;<br/>   floor_requests.remove(0);<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adjusting motor control to process the next floor request</h1>
                
            
            
                
<p>To adjust motor control, we need to decide how much acceleration we want, and then calculate how much force is required to achieve the target acceleration. According to our objectives, we want shorter travel time, less motion sickness, and accurate stop locations.</p>
<p>The metrics that we should optimize to achieve these objectives are to maximize average velocity, minimize acceleration, and minimize stop location error. All of these objectives compete with one another for precedence, so we will need to compromise between each to achieve good overall performance.</p>
<p>With some research, you find that comfortable acceleration is limited to between 1 and 1.5 meters per second squared. You decide to aim for a maximum of  1 m/s<sup>2</sup>, with a slack of up to 1.5 m/s<sup>2</sup> in exceptional circumstances.</p>
<p>For velocity, you decide that carriage speeds over 5 m/s are unsafe, so you will implement a maximum velocity, otherwise, the velocity should always be maximized to reach the next floor.</p>
<p>For location precision, the calculation of target acceleration versus current velocity versus target destination is essential. Here, you will try to keep the acceleration near 1 m/s<sup>2</sup>, with significant room for additional acceleration. When sufficiently close to the destination, it may be necessary to use a different acceleration target to make smaller motions and velocity adjustments.</p>
<p>To implement this with code, we first calculate the deceleration range. This is defined as the distance from which, at the current velocity, we would need to decelerate at greater than 1 m/s<sup>2</sup> to stop at the destination. Our acceleration buffer provides some room for correction, making this a safe target from which to start decelerating before reaching the next floor. This is shown in the following code:</p>
<pre style="padding-left: 30px">//it will take t seconds to decelerate from velocity v at -1 m/s^2<br/>let t = velocity.abs() / 1.0;<br/><br/>//during which time, the carriage will travel d=t * v/2 meters<br/>//at an average velocity of v/2 before stopping<br/>let d = t * (velocity/2.0);<br/><br/>//l = distance to next floor<br/>let l = (location - (next_floor as f64)*floor_height).abs();<br/></pre>
<p>To calculate the target acceleration, we have three cases to consider:</p>
<ul>
<li>If we are in the deceleration range, then we should slow down</li>
<li>If we are not in the deceleration range and not at maximum velocity, then we should accelerate</li>
<li>If we are outside of the deceleration range but already at maximum velocity, then we should not change velocity:</li>
</ul>
<pre class="p1" style="padding-left: 60px">let target_acceleration = {<br/>   //are we going up?<br/>   let going_up = location &lt; (next_floor as f64)*floor_height;<br/><br/>   //Do not exceed maximum velocity<br/>   if velocity.abs() &gt;= 5.0 {<br/>      //if we are going up and actually going up<br/>      //or we are going down and actually going down<br/>      if (going_up &amp;&amp; velocity&gt;0.0)<br/>      || (!going_up &amp;&amp; velocity&lt;0.0) {<br/>         0.0<br/>      //decelerate if going in wrong direction<br/>      } else if going_up {<br/>         1.0<br/>      } else {<br/>         -1.0<br/>      }<br/><br/>   //if within comfortable deceleration range and moving in right direction, decelerate<br/>   } else if l &lt; d &amp;&amp; going_up==(velocity&gt;0.0) {<br/>      if going_up {<br/>         -1.0<br/>      } else {<br/>         1.0<br/>      }<br/><br/>   //else if not at peak velocity, accelerate<br/>   } else {<br/>      if going_up {<br/>         1.0<br/>      } else {<br/>         -1.0<br/>      }<br/>   }<br/>};</pre>
<p>Finally, using the target acceleration, we can calculate how much voltage we should apply to each motor to achieve the desired acceleration. By inverting the formula previously used to calculate acceleration, we can now calculate our desired voltage from the target acceleration, as follows:</p>
<pre class="p1" style="padding-left: 30px">let gravity_adjusted_acceleration = target_acceleration + 9.8;<br/>let target_force = gravity_adjusted_acceleration * 1200000.0;<br/>let target_voltage = target_force / 8.0;<br/>if target_voltage &gt; 0.0 {<br/>   up_input_voltage = target_voltage;<br/>   down_input_voltage = 0.0;<br/>} else {<br/>   up_input_voltage = 0.0;<br/>   down_input_voltage = target_voltage.abs();<br/>};</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Printing real-time statistics</h1>
                
            
            
                
<p>To print real-time statistics, we will use a console formatting library. This allows us to easily move the cursor around the screen and write clear and easily formattable text. This is depicted as follows:</p>
<ol>
<li>To get started, we should grab some information and a handle to <kbd>stdout</kbd> and store it outside of our loop. This is shown in the following code:</li>
</ol>
<pre class="p1" style="padding-left: 90px">let termsize = termion::terminal_size().ok();<br/>let termwidth = termsize.map(|(w,_)| w-2).expect("termwidth");<br/>let termheight = termsize.map(|(_,h)| h-2).expect("termheight");<br/>let mut _stdout = io::stdout(); //lock once, instead of once per write<br/>let mut stdout = _stdout.lock().into_raw_mode().unwrap();</pre>
<ol start="2">
<li>Inside the loop, let's start by clearing a space to render our output:</li>
</ol>
<pre class="p1" style="padding-left: 60px">print!("{}{}", clear::All, cursor::Goto(1, 1));<br/>for tx in 0..(termwidth-1)<br/>{<br/>   for ty in 0..(termheight-1)<br/>   {<br/>      write!(stdout, "{}", cursor::Goto(tx+1, ty+1));<br/>      write!(stdout, "{}", " ");<br/>   }<br/>}</pre>
<ol start="3">
<li>Then, we can render the elevator shaft and carriage. The elevator shaft will be simple brackets, one for each floor on the left and right. The elevator carriage will be an <kbd>X</kbd> mark placed on the floor closest to the current carriage location. We calculate each floor location by multiplying <kbd>floor_height</kbd> by floor offset from the ground floor. Then, we compare each floor location to the carriage locations to find the closest one. The code is as follows:</li>
</ol>
<pre class="p1" style="padding-left: 60px">print!("{}{}{}", clear::All, cursor::Goto(1, 1), cursor::Hide);<br/>let carriage_floor = (location / floor_height).floor() as u64;<br/>let carriage_floor = cmp::max(carriage_floor, 0);<br/>let carriage_floor = cmp::min(carriage_floor, floor_count-1);<br/>for tx in 0..(termwidth-1)<br/>{<br/>   for ty in 0..(termheight-1)<br/>   {<br/>      write!(stdout, "{}", cursor::Goto(tx+1, ty+1));<br/>      if tx==0 &amp;&amp; (ty as u64)&lt;floor_count {<br/>         write!(stdout, "{}", "[");<br/>      } else if tx==1 &amp;&amp; (ty as u64)==((floor_count-1)-carriage_floor) {<br/>         write!(stdout, "{}", "X");<br/>      } else if tx==2 &amp;&amp; (ty as u64)&lt;floor_count {<br/>         write!(stdout, "{}", "]");<br/>      } else {<br/>         write!(stdout, "{}", " ");<br/>      }<br/>   }<br/>}<br/>stdout.flush().unwrap();</pre>
<ol start="4">
<li>Now, we need to print real-time statistics. In addition to location, velocity, and acceleration, let's also display the nearest floor and motor input voltage, as follows:</li>
</ol>
<pre class="p1" style="padding-left: 60px">write!(stdout, "{}", cursor::Goto(6, 1));<br/>write!(stdout, "Carriage at floor {}", carriage_floor+1);<br/>write!(stdout, "{}", cursor::Goto(6, 2));<br/>write!(stdout, "Location          {}", location);<br/>write!(stdout, "{}", cursor::Goto(6, 3));<br/>write!(stdout, "Velocity          {}", velocity);<br/>write!(stdout, "{}", cursor::Goto(6, 4));<br/>write!(stdout, "Acceleration      {}", acceleration);<br/>write!(stdout, "{}", cursor::Goto(6, 5));<br/>write!(stdout, "Voltage [up-down] {}", up_input_voltage-down_input_voltage);</pre>
<ol start="5">
<li>Here, we find that the Terminal screen is tearing, so let's adjust the output to use a buffer:</li>
</ol>
<pre class="p1" style="padding-left: 30px">let mut terminal_buffer = vec![' ' as u8; (termwidth*termheight) as usize];<br/>for ty in 0..floor_count<br/>{<br/>   terminal_buffer[ (ty*termwidth + 0) as usize ] = '[' as u8;<br/>   terminal_buffer[ (ty*termwidth + 1) as usize ] =<br/>      if   (ty as u64)==((floor_count-1)-carriage_floor) { 'X' as u8 }<br/>      else { ' ' as u8 };<br/>   terminal_buffer[ (ty*termwidth + 2) as usize ] = ']' as u8;<br/>   terminal_buffer[ (ty*termwidth + termwidth-2) as usize ] = '\r' as u8;<br/>   terminal_buffer[ (ty*termwidth + termwidth-1) as usize ] = '\n' as u8;<br/>}<br/>let stats = vec![<br/>   format!("Carriage at floor {}", carriage_floor+1),<br/>   format!("Location          {}", location),<br/>   format!("Velocity          {}", velocity),<br/>   format!("Acceleration      {}", acceleration),<br/>   format!("Voltage [up-down] {}", up_input_voltage-down_input_voltage)<br/>];<br/>for sy in 0..stats.len()<br/>{<br/>   for (sx,sc) in stats[sy].chars().enumerate()<br/>   {<br/>      terminal_buffer[ sy*(termwidth as usize) + 6 + sx ] = sc as u8;<br/>   }<br/>}<br/>write!(stdout, "{}", String::from_utf8(terminal_buffer).unwrap()); </pre>
<p>Now, our screen will clearly display real-time information until the loop ends.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Printing summary</h1>
                
            
            
                
<p>To print our summary, we should include averages and standard deviations for location, velocity, and acceleration. Additionally, it may be interesting to see statistics for motor control, so let's also display voltage statistics. At this point, we realize that the data is not storing enough information to calculate average or standard deviation numbers.</p>
<p>To calculate the average value for a variable, we will need to calculate a sum of each recorded value and record a count of how many data points we recorded. Then, we will calculate the average value by dividing the total value by the record count, giving us our estimation of the average value over time.</p>
<p>To calculate the standard deviation, we will require a full record of each observed value of the variable. Additionally, the average value and record count are required. Then, we will use the following formula to calculate standard deviation:</p>
<div><img class="fm-editor-equation" src="img/3c852df4-1086-4609-bfd9-3bec0b76abb5.png" style="width:7.83em;height:3.33em;"/></div>
<p>To store our data, we need to declare new variables before our loop starts:</p>
<ol>
<li>To store data using new variables, use the following code:</li>
</ol>
<pre class="p1" style="padding-left: 60px">let mut record_location = Vec::new();<br/>let mut record_velocity = Vec::new();<br/>let mut record_acceleration = Vec::new();<br/>let mut record_voltage = Vec::new();</pre>
<ol start="2">
<li>Then, at each iteration, before calculating the new values, we will store each data point:</li>
</ol>
<pre class="p1" style="padding-left: 60px">record_location.push(location);<br/>record_velocity.push(velocity);<br/>record_acceleration.push(acceleration);<br/>record_voltage.push(up_input_voltage-down_input_voltage);</pre>
<ol start="3">
<li>Finally, we calculate the statistics:</li>
</ol>
<pre class="p1" style="padding-left: 60px">let record_location_N = record_location.len();<br/>let record_location_sum: f64 = record_location.iter().sum();<br/>let record_location_avg = record_location_sum / (record_location_N as f64);<br/>let record_location_dev = (<br/>   record_location.clone().into_iter()<br/>   .map(|v| (v - record_location_avg).powi(2))<br/>   .fold(0.0, |a, b| a+b)<br/>   / (record_location_N as f64)<br/>).sqrt();<br/><br/>let record_velocity_N = record_velocity.len();<br/>let record_velocity_sum: f64 = record_velocity.iter().sum();<br/>let record_velocity_avg = record_velocity_sum / (record_velocity_N as f64);<br/>let record_velocity_dev = (<br/>   record_velocity.clone().into_iter()<br/>   .map(|v| (v - record_velocity_avg).powi(2))<br/>   .fold(0.0, |a, b| a+b)<br/>   / (record_velocity_N as f64)<br/>).sqrt();<br/><br/>let record_acceleration_N = record_acceleration.len();<br/>let record_acceleration_sum: f64 = record_acceleration.iter().sum();<br/>let record_acceleration_avg = record_acceleration_sum / (record_acceleration_N as f64);<br/>let record_acceleration_dev = (<br/>   record_acceleration.clone().into_iter()<br/>   .map(|v| (v - record_acceleration_avg).powi(2))<br/>   .fold(0.0, |a, b| a+b)<br/>   / (record_acceleration_N as f64)<br/>).sqrt();<br/><br/>let record_voltage_N = record_voltage.len();<br/>let record_voltage_sum = record_voltage.iter().sum();<br/>let record_voltage_avg = record_voltage_sum / (record_voltage_N as f64);<br/>let record_voltage_dev = (<br/>   record_voltage.clone().into_iter()<br/>   .map(|v| (v - record_voltage_avg).powi(2))<br/>   .fold(0.0, |a, b| a+b)<br/>   / (record_voltage_N as f64)<br/>).sqrt();</pre>
<ol start="4">
<li>Before exiting the program, we must print the statistics:</li>
</ol>
<pre class="p1" style="padding-left: 60px">write!(stdout, "{}{}{}", clear::All, cursor::Goto(1, 1), cursor::Show).unwrap();<br/><br/>write!(stdout, "Average of location                 {:.6}\r\n", record_location_avg);<br/>write!(stdout, "Standard deviation of location      {:.6}\r\n", record_location_dev);<br/>write!(stdout, "\r\n");<br/><br/>write!(stdout, "Average of velocity                 {:.6}\r\n", record_velocity_avg);<br/>write!(stdout, "Standard deviation of velocity      {:.6}\r\n", record_velocity_dev);<br/>write!(stdout, "\r\n");<br/><br/>write!(stdout, "Average of acceleration             {:.6}\r\n", record_acceleration_avg);<br/>write!(stdout, "Standard deviation of acceleration  {:.6}\r\n", record_acceleration_dev);<br/>write!(stdout, "\r\n");<br/><br/>write!(stdout, "Average of voltage                  {:.6}\r\n", record_voltage_avg);<br/>write!(stdout, "Standard deviation of voltage       {:.6}\r\n", record_voltage_dev);<br/>write!(stdout, "\r\n");<br/><br/>stdout.flush().unwrap();</pre>
<p>Now, having assembled the pieces, we have a complete simulation. Running the program on a test input produces a nice graphic and result summary. This should be sufficient to accompany the initial proposal.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Breaking down long segments into components</h1>
                
            
            
                
<p>Once the project is functional, we can begin to look for opportunities to simplify the design and eliminate redundancies. The first step here should be to look for patterns of similar code. Our summary statistics are a very good example of code that should be cleaned up. We have four variables that we track and display statistics for. The calculation of each statistic is identical, yet we repeat the calculation explicitly for each variable. There are also similarities in the output formatting, so let's also clean that up.</p>
<p>To fix redundancy, the first question to ask is whether the code can be rewritten as a function. Here, we do have the opportunity to use this pattern by creating a function that accepts the variable data and prints the summary. This is done as follows:</p>
<ol>
<li>We can write this function, which is shown as follows:</li>
</ol>
<pre class="p1" style="padding-left: 60px">fn variable_summary&lt;W: Write&gt;(stdout: &amp;mut raw::RawTerminal&lt;W&gt;, vname: &amp;str, data: Vec&lt;f64&gt;)<br/>{<br/>   //calculate statistics<br/>   let N = data.len();<br/>   let sum: f64 = data.iter().sum();<br/>   let avg = sum / (N as f64);<br/>   let dev = (<br/>      data.clone().into_iter()<br/>      .map(|v| (v - avg).powi(2))<br/>      .fold(0.0, |a, b| a+b)<br/>      / (N as f64)<br/>   ).sqrt();<br/><br/>   //print formatted output<br/>   write!(stdout, "Average of {:25}{:.6}\r\n", vname, avg);<br/>   write!(stdout, "Standard deviation of {:14}{:.6}\r\n", vname, dev);<br/>   write!(stdout, "\r\n");<br/>}</pre>
<ol start="2">
<li>To call the function, we provide each <kbd>name</kbd> and <kbd>data</kbd> variable:</li>
</ol>
<pre class="p1" style="padding-left: 60px">write!(stdout, "{}{}{}", clear::All, cursor::Goto(1, 1), cursor::Show).unwrap();<br/>variable_summary(&amp;mut stdout, "location", record_location);<br/>variable_summary(&amp;mut stdout, "velocity", record_velocity);<br/>variable_summary(&amp;mut stdout, "acceleration", record_acceleration);<br/>variable_summary(&amp;mut stdout, "voltage", record_voltage);<br/>stdout.flush().unwrap();</pre>
<p>This rewrite improves the program in two significant ways:</p>
<ul>
<li>The statistics calculation is much easier to read and debug</li>
<li>Using the statistics and summary function involves very little redundancy, which reduces the likelihood of accidentally using incorrect variable names or other common errors</li>
</ul>
<p>Short, literate code is robust and prevents mistakes. Long, redundant code is brittle and error-prone.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Searching for abstractions</h1>
                
            
            
                
<p>After writing a code draft, it is a good practice to read through the code again and look for possible improvements.  When reviewing a project, look specifically for ugly code, anti-patterns, and unchecked assumptions. After review, we find the code does not need correcting.</p>
<p>We should, however, point out one functional abstraction that was used that reduced line count significantly, which is the use of iterators. In calculating our variable summaries, we always used iterators to calculate sums and statistics. Some of the operators have not been introduced, so let's look closer:</p>
<pre class="p1" style="padding-left: 30px">let N = data.len();<br/>let sum: f64 = data.iter().sum();<br/>let avg = sum / (N as f64);<br/>let dev = (<br/>   data.clone().into_iter()<br/>   .map(|v| (v - avg).powi(2))<br/>   .fold(0.0, |a, b| a+b)<br/>   / (N as f64)<br/>).sqrt();<br/></pre>
<p>Here, there are two important iterator methods being used—<kbd>map</kbd> and <kbd>fold</kbd>. <kbd>map</kbd> accept a mapping function and return an iterator of the modified values. The <kbd>fold</kbd> method holds an accumulator value (argument 1), and, for each element in the iterator, applies the accumulator function (argument 2), returning the accumulated value as a result. The <kbd>fold</kbd> function consumes the iterator when called.</p>
<p>An iterator is defined by a trait with a <kbd>next</kbd> method, which may return the next item in the sequence. A simple infinite list could be defined as follows:</p>
<pre style="padding-left: 30px">struct Fibonacci<br/>{<br/> curr: u32,<br/> next: u32,<br/>}<br/><br/>impl Iterator for Fibonacci<br/>{<br/>   type Item = u32;<br/>   fn next(&amp;mut self) -&gt; Option&lt;u32&gt;<br/>   {<br/>      let new_next = self.curr + self.next;<br/>      self.curr = self.next;<br/>      self.next = new_next;<br/>      Some(self.curr) //infinite list, never None<br/>   }<br/>}<br/><br/>fn fibonacci() -&gt; Fibonacci<br/>{<br/>   Fibonacci { curr: 1, next: 1 }<br/>}</pre>
<p>These objects define an iterator. The <kbd>map</kbd> function and other stream modifiers simply wrap the input stream inside of another iterator that applies the modifier.</p>
<p>Alternatively, the statistics calculation could have been defined with <kbd>for</kbd> loops. The result would look like the following:</p>
<pre class="p1" style="padding-left: 30px">let N = data.len();<br/>let mut sum = 0.0;<br/>for di in 0..data.len()<br/>{<br/>   sum += data[di];<br/>}<br/>let avg = sum / (N as f64);<br/>let mut dev = 0.0;<br/>for di in 0..data.len()<br/>{<br/>   dev += (data[di] - avg).powi(2);<br/>}<br/>dev = (dev / (N as f64)).sqrt();</pre>
<p>By comparison, we can see that the functional code is a little bit shorter. More importantly, the functional code is declarative. When code only describes requirements, we call that code <strong>declarative</strong>. When code describes machine instructions to satisfy requirements, we call that code <strong>imperative</strong>. The primary benefits of declarative style over imperative style are that declarative style is self-documenting and prevents mistakes by making them more obvious.</p>
<p>For these reasons, when searching for abstractions, we encourage looking at <kbd>for</kbd> loops. In most cases, <kbd>for</kbd> loops can be messy or otherwise undesirable. Iterators and combinators may be a good solution to help improve code quality.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing tests</h1>
                
            
            
                
<p>To run tests from the command line, type <kbd>cargo test</kbd>. We will be doing this a lot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unit testing</h1>
                
            
            
                
<p>Unit testing focuses on testing internal interfaces and components of a program. It is also called <strong>whitebox testing</strong>. To first create unit tests, it is a good idea to look at all of the top-level types, traits, and functions. All top-level identifiers make for good test cases. Depending on the structure of the program, it may also be a good idea to test combinations of these components to cover expected use cases.</p>
<p>We have one utility function, the statistic calculation, which would be a good candidate to write a unit test for. However, this function doesn't return any result. Instead, it immediately prints output to the console. To test this, we should break the function into two components—one that calculates the statistics, and a second function that prints the statistics. This would look as follows:</p>
<pre class="p1" style="padding-left: 30px">fn variable_summary&lt;W: Write&gt;(stdout: &amp;mut raw::RawTerminal&lt;W&gt;, vname: &amp;str, data: Vec&lt;f64&gt;)<br/>{<br/>   let (avg, dev) = variable_summary_stats(data);<br/>   variable_summary_print(stdout, vname, avg, dev);<br/>}<br/><br/>fn variable_summary_stats(data: Vec&lt;f64&gt;) -&gt; (f64, f64)<br/>{<br/>   //calculate statistics<br/>   let N = data.len();<br/>   let sum: f64 = data.iter().sum();<br/>   let avg = sum / (N as f64);<br/>   let dev = (<br/>      data.clone().into_iter()<br/>      .map(|v| (v - avg).powi(2))<br/>      .fold(0.0, |a, b| a+b)<br/>      / (N as f64)<br/>   ).sqrt();<br/>   (avg, dev)<br/>}<br/><br/>fn variable_summary_print&lt;W: Write&gt;(stdout: &amp;mut raw::RawTerminal&lt;W&gt;, vname: &amp;str, avg: f64, dev: f64)<br/>{<br/>   //print formatted output<br/>   write!(stdout, "Average of {:25}{:.6}\r\n", vname, avg);<br/>   write!(stdout, "Standard deviation of {:14}{:.6}\r\n", vname, dev);<br/>   write!(stdout, "\r\n");<br/>}</pre>
<p class="p1">Now that we have isolated the statistics calculation into its own function, we can write unit tests for it much more easily. First, we supply some test data, and then verify each result. Also note that unit tests have access to private functions as long as we add <kbd>use super::*;</kbd> to the test declaration. Here are some unit tests for our statistics calculation:</p>
<pre class="p1" style="padding-left: 30px">#[cfg(test)]<br/>mod tests {<br/>   use super::*;<br/><br/>   #[test]<br/>   fn variable_stats() {<br/>      let test_data = vec![<br/>         (vec![1.0, 2.0, 3.0, 4.0, 5.0], 3.0, 1.41),<br/>         (vec![1.0, 3.0, 5.0, 7.0, 9.0], 5.0, 2.83),<br/>         (vec![1.0, 9.0, 1.0, 9.0, 1.0], 4.2, 3.92),<br/>         (vec![1.0, 0.5, 0.7, 0.9, 0.6], 0.74, 0.19),<br/>         (vec![200.0, 3.0, 24.0, 92.0, 111.0], 86.0, 69.84),<br/>      ];<br/>      for (data, avg, dev) in test_data<br/>      {<br/>         let (ravg, rdev) = variable_summary_stats(data);<br/>         //it is not safe to use direct == operator on floats<br/>         //floats can be *very* close and not equal<br/>         //so instead we check that they are very close in value<br/>         assert!( (avg-ravg).abs() &lt; 0.1 );<br/>         assert!( (dev-rdev).abs() &lt; 0.1 );<br/>      }<br/>   }<br/>}</pre>
<p>Now, if we run <kbd>cargo test</kbd>, the unit tests will run. The result should show one test passing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integration testing</h1>
                
            
            
                
<p>Integration testing focuses on testing external interfaces of a program. It is also called <strong>blackbox testing</strong>. To create integration tests, focus on what the input and output of a program or module should be. Think of the different configurations of options, data, and possible internal interactions to create tests. These tests should then provide good coverage of high-level behavior of the completed program.</p>
<p>To create an integration test, we first need to reconfigure our project as a module that can be imported. Integration tests do not have access to symbols other than what they can reference from <kbd>use</kbd> statements. To accomplish this, we can move the program logic into a <kbd>src/lib.rs</kbd> file and use a simple wrapper for <kbd>src/main.rs</kbd> . After this change, the <kbd>lib.rs</kbd> file should contain all of the code from <kbd>main.rs</kbd>, with the one change of renaming the <kbd>main</kbd> function to <kbd>run_simulation</kbd> and making the function public. The <kbd>main.rs</kbd> wrapper should then look as follows:</p>
<pre class="p1" style="padding-left: 30px">extern crate elevator;<br/><br/>fn main()<br/>{<br/>   elevator::run_simulation();<br/>}</pre>
<p>Now, in order to create an integration test:</p>
<ol>
<li>Create a  <kbd>tests/</kbd> directory</li>
<li>Create an <kbd>integration_tests.rs</kbd> file inside the <kbd>tests/</kbd> directory</li>
<li>Inside the <kbd>integration_tests.rs</kbd> file, create functions for each test case</li>
</ol>
<p>We will create a single test case here to accept a specific elevator request and check that the requests are processed in a reasonable amount of time. The test harness is as follows:</p>
<pre class="p1" style="padding-left: 30px">extern crate elevator;<br/>extern crate timebomb;<br/>use timebomb::timeout_ms;<br/><br/>#[test]<br/>fn test_main() {<br/>   timeout_ms(|| {<br/>      elevator::run_simulation();<br/>   }, 300000);<br/>}</pre>
<p>As input, we will use a <kbd>5</kbd> story building, <kbd>5.67</kbd> meters for each floor, and <kbd>7</kbd> floor requests. The file will be stored as <kbd>test1.txt</kbd> and should have the following structure:</p>
<pre class="p1" style="padding-left: 30px">5<br/>5.67<br/>2<br/>1<br/>4<br/>0<br/>3<br/>1<br/>0</pre>
<p>With these tests in place, we can now confirm that the basic logic is working and that the program as a whole function properly. To run all tests, call <kbd>cargo test</kbd>, or use a specific test case with <kbd>cargo test casename</kbd>.</p>
<p>A sample test run is as follows:</p>
<pre><strong>[ ]   Carriage at floor 1</strong><br/><strong>[ ]   Location          2.203829</strong><br/><strong>[ ]   Velocity          -2.157214</strong><br/><strong>[ ]   Acceleration      1.000000</strong><br/><strong>[X]   Voltage [up-down] 1620000.000000</strong><br/><br/><strong>[ ]   Carriage at floor 3</strong><br/><strong>[ ]   Location          11.344785</strong><br/><strong>[X]   Velocity          0.173572</strong><br/><strong>[ ]   Acceleration      -1.000000</strong><br/><strong>[ ]   Voltage [up-down] 1320000.000000</strong><br/><br/><strong>[ ]   Carriage at floor 4</strong><br/><strong>[X]   Location          19.235710</strong><br/><strong>[ ]   Velocity          2.669347</strong><br/><strong>[ ]   Acceleration      -1.000000</strong><br/><strong>[ ]   Voltage [up-down] 1320000.000000</strong><br/><br/><strong>[ ]   Carriage at floor 1</strong><br/><strong>[ ]   Location          0.133051</strong><br/><strong>[ ]   Velocity          0.160799</strong><br/><strong>[ ]   Acceleration      -1.000000</strong><br/><strong>[X]   Voltage [up-down] 1320000.000000</strong></pre>
<p>Once the simulation completes, the summary and test results are as follows:</p>
<pre><strong>Average of location                 5.017036</strong><br/><strong>Standard deviation of location      8.813507</strong><br/><br/><strong>Average of velocity                 -0.007597</strong><br/><strong>Standard deviation of velocity      2.107692</strong><br/><br/><strong>Average of acceleration             0.000850</strong><br/><strong>Standard deviation of acceleration  0.995623</strong><br/><br/><strong>Average of voltage                  1470109.838195</strong><br/><strong>Standard deviation of voltage       149352.287579</strong><br/><br/><strong>test test_main ... ok</strong><br/><br/><strong>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</strong><br/><br/><strong>running 1 test<br/>test tests::variable_stats ... ok<br/><br/>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we outlined the steps taken to gather project requirements, architect a solution, and then implement the completed deliverable. We focused on how this process can be clarified using functional thinking.</p>
<p>When gathering program requirements, the required data, input, and output should be clarified. When translating requirements into a code plan, creating a dependency graph as an intermediary step can help simplify complex designs. When testing, functions become great units to cover. By comparison, lines and lines of imperative code are almost impossible to test.</p>
<p>We will continue to develop this software project throughout the book. This first simulation deliverable will accompany the project proposal and will hopefully help our firm be selected for the contract. In the next chapter, you will receive feedback from the developers and meet your competitor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the ternary operator?</li>
<li>What is another name for unit tests?</li>
<li>What is another name for integration tests?</li>
<li>What is declarative programming?</li>
<li>What is imperative programming?</li>
<li>What is defined in the iterator trait?</li>
<li>In which direction will fold traverse the iterator sequence?</li>
<li>What is a dependency graph?</li>
<li>What are the two constructors of <kbd>Option</kbd>?</li>
</ol>


            

            
        
    </body></html>