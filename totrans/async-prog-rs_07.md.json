["```rs\nmod http;\nmod future;\n```", "```rs\n[dependencies]\nmio = { version = \"0.8\", features = [\"net\", \"os-poll\"] }\n```", "```rs\npub trait Future {\n    type Output;\n    fn poll(&mut self) -> PollState<Self::Output>;\n}\n```", "```rs\npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```", "```rs\npub enum PollState<T> {\n    Ready(T),\n    NotReady,\n}\n```", "```rs\npub enum Poll<T> {\n    Ready(T),\n    Pending,\n}\n```", "```rs\nuse crate::future::{Future, PollState};\nuse std::io::{ErrorKind, Read, Write};\n```", "```rs\nfn get_req(path: &str) -> String {\n    format!(\n        \"GET {path} HTTP/1.1\\r\\n\\\n             Host: localhost\\r\\n\\\n             Connection: close\\r\\n\\\n             \\r\\n\"\n    )\n}\n```", "```rs\npub struct Http;\nimpl Http {\n    pub fn get(path: &str) -> impl Future<Output = String> {\n        HttpGetFuture::new(path)\n    }\n}\n```", "```rs\nstruct HttpGetFuture {\n    stream: Option<mio::net::TcpStream>,\n    buffer: Vec<u8>,\n    path: String,\n}\n```", "```rs\nimpl HttpGetFuture {\n    fn new(path: &'static str) -> Self {\n        Self {\n            stream: None,\n            buffer: vec![],\n            Path: path.to_string(),\n        }\n    }\n    fn write_request(&mut self) {\n        let stream = std::net::TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n        stream.set_nonblocking(true).unwrap();\n        let mut stream = mio::net::TcpStream::from_std(stream);\n        stream.write_all(get_req(&self.path).as_bytes()).unwrap();\n        self.stream = Some(stream);\n    }\n}\n```", "```rs\nimpl Future for HttpGetFuture {\n    type Output = String;\n    fn poll(&mut self) -> PollState<Self::Output> {\n        if self.stream.is_none() {\n            println!(\"FIRST POLL - START OPERATION\");\n            self.write_request();\n            return PollState::NotReady;\n        }\n        let mut buff = vec![0u8; 4096];\n        loop {\n            match self.stream.as_mut().unwrap().read(&mut buff) {\n                Ok(0) => {\n                    let s = String::from_utf8_lossy(&self.buffer);\n                    break PollState::Ready(s.to_string());\n                }\n                Ok(n) => {\n                    self.buffer.extend(&buff[0..n]);\n                    continue;\n                }\n                Err(e) if e.kind() == ErrorKind::WouldBlock => {\n                    break PollState::NotReady;\n                }\n                Err(e) if e.kind() == ErrorKind::Interrupted => {\n                    continue;\n                }\n                Err(e) => panic!(\"{e:?}\"),\n            }\n        }\n    }\n}\n```", "```rs\nasync fn async_main() {\n    println!(\"Program starting\")\n    let txt = Http::get(\"/1000/HelloWorld\").await;\n    println!(\"{txt}\");\n    let txt2 = Http::(\"500/HelloWorld2\").await;\n    println!(\"{txt2}\");\n}\n```", "```rs\nuse std::time::Instant;\nmod future;\nmod http;\nuse crate::http::Http;\nuse future::{Future, PollState};\n```", "```rs\nstruct Coroutine {\n    state: State,\n}\n```", "```rs\nenum State {\n    Start,\n    Wait1(Box<dyn Future<Output = String>>),\n    Wait2(Box<dyn Future<Output = String>>),\n    Resolved,\n}\n```", "```rs\nimpl Coroutine {\n    fn new() -> Self {\n        Self {\n            state: State::Start,\n        }\n    }\n}\n```", "```rs\nimpl Future for Coroutine {\n    type Output = ();\n    fn poll(&mut self) -> PollState<Self::Output> {\n        loop {\n            match self.state {\n                State::Start => {\n                    println!(\"Program starting\");\n                    let fut = Box::new(Http::get(\"/600/HelloWorld1\"));\n                    self.state = State::Wait1(fut);\n                }\n                State::Wait1(ref mut fut) => match fut.poll() {\n                    PollState::Ready(txt) => {\n                        println!(\"{txt}\");\n                        let fut2 = Box::new(Http::get(\"/400/HelloWorld2\"));\n                        self.state = State::Wait2(fut2);\n                    }\n                    PollState::NotReady => break PollState::NotReady,\n                },\n                State::Wait2(ref mut fut2) => match fut2.poll() {\n                    PollState::Ready(txt2) => {\n                        println!(\"{txt2}\");\n                        self.state = State::Resolved;\n                        break PollState::Ready(());\n                    }\n                    PollState::NotReady => break PollState::NotReady,\n                },\n                State::Resolved => panic!(\"Polled a resolved future\"),\n            }\n        }\n    }\n}\n```", "```rs\nfn async_main() -> impl Future<Output = ()> {\n    Coroutine::new()\n}\n```", "```rs\nfn main() {\n    let mut future = async_main();\n    loop {\n        match future.poll() {\n            PollState::NotReady => {\n                println!(\"Schedule other tasks\");\n            },\n            PollState::Ready(_) => break,\n        }\n        thread::sleep(Duration::from_millis(100));\n    }\n}\n```", "```rs\nProgram starting\nFIRST POLL - START OPERATION\nSchedule other tasks\nSchedule other tasks\nSchedule other tasks\nSchedule other tasks\nSchedule other tasks\nSchedule other tasks\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, 24 Oct 2023 20:39:13 GMT\nHelloWorld1\nFIRST POLL - START OPERATION\nSchedule other tasks\nSchedule other tasks\nSchedule other tasks\nSchedule other tasks\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, 24 Oct 2023 20:39:13 GMT\nHelloWorld2\n```", "```rs\nasync fn async_main() {\n    println!(\"Program starting\")\n    let txt = Http::get(\"/1000/HelloWorld\").await;\n    println!(\"{txt}\");\n    let txt2 = Http::(\"500/HelloWorld2\").await;\n    println!(\"{txt2}\");\n}\n```", "```rs\ncoroutine fn async_main() {\n    println!(\"Program starting\")\n    let txt = Http::get(\"/1000/HelloWorld\").wait;\n    println!(\"{txt}\");\n    let txt2 = Http::(\"500/HelloWorld2\").wait;\n    println!(\"{txt2}\");\n}\n```", "```rs\ncargo install --path .\n```", "```rs\nuse std::time::Instant;\nmod http;\nmod future;\nuse future::*;\nuse crate::http::Http;\nfn get_path(i: usize) -> String {\n    format!(\"/{}/HelloWorld{i}\", i * 1000)\n}\ncoroutine fn async_main() {\n    println!(\"Program starting\");\n    let txt = Http::get(&get_path(0)).wait;\n    println!(\"{txt}\");\n    let txt = Http::get(&get_path(1)).wait;\n    println!(\"{txt}\");\n    let txt = Http::get(&get_path(2)).wait;\n    println!(\"{txt}\");\n    let txt = Http::get(&get_path(3)).wait;\n    println!(\"{txt}\");\n    let txt = Http::get(&get_path(4)).wait;\n    println!(\"{txt}\");\n}\nfn main() {\n    let start = Instant::now();\n    let mut future = async_main();\n    loop {\n        match future.poll() {\n            PollState::NotReady => (),\n            PollState::Ready(_) => break,\n        }\n    }\n    println!(\"\\nELAPSED TIME: {}\", start.elapsed().as_secs_f32());\n}\n```", "```rs\ncorofy ./src/main.rs\n```", "```rs\nenum State0 {\n    Start,\n    Wait1(Box<dyn Future<Output = String>>),\n    Wait2(Box<dyn Future<Output = String>>),\n    Wait3(Box<dyn Future<Output = String>>),\n    Wait4(Box<dyn Future<Output = String>>),\n    Wait5(Box<dyn Future<Output = String>>),\n    Resolved,\n}\n```", "```rs\nProgram starting\nFIRST POLL - START OPERATION\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:05:55 GMT\nHelloWorld0\nFIRST POLL - START OPERATION\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:05:56 GMT\nHelloWorld1\nFIRST POLL - START OPERATION\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:05:58 GMT\nHelloWorld2\nFIRST POLL - START OPERATION\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:06:01 GMT\nHelloWorld3\nFIRST POLL - START OPERATION\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:06:05 GMT\nHelloWorld4\nELAPSED TIME: 10.043025\n```", "```rs\npub fn join_all<F: Future>(futures: Vec<F>) -> JoinAll<F> {\n    let futures = futures.into_iter().map(|f| (false, f)).collect();\n    JoinAll {\n        futures,\n        finished_count: 0,\n    }\n}\n```", "```rs\npub struct JoinAll<F: Future> {\n    futures: Vec<(bool, F)>,\n    finished_count: usize,\n}\n```", "```rs\nimpl<F: Future> Future for JoinAll<F> {\n    type Output = String;\n    fn poll(&mut self) -> PollState<Self::Output> {\n        for (finished, fut) in self.futures.iter_mut() {\n            if *finished {\n                continue;\n            }\n            match fut.poll() {\n                PollState::Ready(_) => {\n                    *finished = true;\n                    self.finished_count += 1;\n                }\n                PollState::NotReady => continue,\n            }\n        }\n        if self.finished_count == self.futures.len() {\n            PollState::Ready(String::new())\n        } else {\n            PollState::NotReady\n        }\n    }\n}\n```", "```rs\nfor (finished, fut) in self.futures.iter_mut()\n```", "```rs\ncoroutine fn request(i: usize) {\n    let path = format!(\"/{}/HelloWorld{i}\", i * 1000);\n    let txt = Http::get(&path).wait;\n    println!(\"{txt}\");\n}\ncoroutine fn async_main() {\n    println!(\"Program starting\");\n    let mut futures = vec![];\n    for i in 0..5 {\n        futures.push(request(i));\n    }\n    future::join_all(futures).wait;\n}\n```", "```rs\nProgram starting\nFIRST POLL - START OPERATION\nFIRST POLL - START OPERATION\nFIRST POLL - START OPERATION\nFIRST POLL - START OPERATION\nFIRST POLL - START OPERATION\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:11:36 GMT\nHelloWorld0\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:11:37 GMT\nHelloWorld1\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:11:38 GMT\nHelloWorld2\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:11:39 GMT\nHelloWorld3\nHTTP/1.1 200 OK\ncontent-length: 11\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Tue, xx xxx xxxx 21:11:40 GMT\nHelloWorld4\nELAPSED TIME: 4.0084987\n```"]