- en: Unsafe Rust and Foreign Function Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的 Rust 和外部函数接口
- en: 'Rust is a language that has two modes: safe mode (the default) and unsafe mode.
    In safe mode, you get all sorts of safety features to protect you from serious
    mistakes, but there are times when you''re required to shake off the safety harness
    provided by the compiler and get that extra level of control. One use case is
    interfacing with other languages, such as C, which can be very unsafe. In this
    chapter, you will get to know what sort of extra work is required when Rust has
    to interact with other languages and how unsafe mode is used to facilitate and
    make this interaction explicit.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种具有两种模式的语言：安全模式（默认模式）和不安全模式。在安全模式下，你将获得各种安全特性来保护你免受严重错误的影响，但有时你需要摆脱编译器提供的安全束缚，获得额外的控制级别。一个用例是与其他语言（如
    C 语言）交互，这可能会非常不安全。在本章中，你将了解当 Rust 需要与其他语言交互时需要做哪些额外的工作，以及如何使用不安全模式来促进并明确这种交互。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the safe and unsafe modes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解安全和不安全模式
- en: Operations that are unsafe in Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 中不安全的操作
- en: Foreign function interface, talking to C, and vice versa
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部函数接口，与 C 语言通信以及反之
- en: Interfacing with Python using PyO3
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PyO3 与 Python 交互
- en: Interfacing with Node.js using Neon
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Neon 与 Node.js 交互
- en: What is safe and unsafe really?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是真正的安全和不安全？
- en: “You are allowed to do this, but you had better know what you are doing.”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “你可以这样做，但你最好知道你在做什么。”
- en: '- *A Rustacean*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '- *Rustacean*'
- en: When we talk about safety in programming languages, it is a property that spans
    different levels. A language can be memory-safe, type-safe, or it can be concurrent-safe.
    Memory safety means that a program doesn't write to a forbidden memory address
    and it doesn't access invalid memory. Type safety means that a program doesn't
    allow you to assign a number to a string variable and that this check happens
    at compile time, while concurrent-safe means that the program does not lead to
    race conditions when multiple threads are executing and modifying a shared state. If
    a language provides all of these levels of safety by itself, then it is said to
    be safe. To put it more generally, a program is deemed safe if, in all possible
    executions of the program and for all possible inputs, it gives correct outputs,
    does not lead to crashes, and does not clobber or corrupt its internal or external
    state. With Rust in safe mode, this is indeed true!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论编程语言中的安全性时，这是一个跨越不同级别的属性。一种语言可以是内存安全的、类型安全的，或者它可以具有并发安全。内存安全意味着程序不会写入禁止的内存地址，也不会访问无效的内存。类型安全意味着程序不允许你将数字赋值给字符串变量，并且这个检查发生在编译时，而并发安全意味着程序在多个线程执行并修改共享状态时不会导致竞争条件。如果一个语言本身提供了所有这些级别的安全性，那么它就被认为是安全的。更普遍地说，如果一个程序在所有可能的执行和所有可能的输入下都能给出正确的输出，不会导致崩溃，并且不会损坏或破坏其内部或外部状态，那么这个程序被认为是安全的。在
    Rust 的安全模式下，这确实是正确的！
- en: 'An unsafe program is one that violates an invariant at runtime or triggers
    an undefined behavior. These unsafe effects may be local to a function, or may
    have propagated later as a global state in the program. Some of them are inflicted
    by programmers themselves, such as logic errors, while some of them are due to
    the side effects of the compiler implementation that''s used, and sometimes from
    the language specification itself. **Invariants** are conditions that must always
    be true during the execution of the program in all code paths. The simplest example
    would be that a pointer pointing to an object on the heap should never be null
    within a certain section of code. If that invariant breaks, code that is dependent
    on that pointer might dereference it and undergo a crash. Languages such as C/C++
    and languages based on them are unsafe because quite a few operations are categorized
    as an undefined behavior in the compiler specification. An undefined behavior
    is an effect of hitting a situation in a program for which the compiler specification
    does not specify what happens at lower levels, and you are free to assume that
    anything can happen. One example of undefined behavior is using an uninitialized
    variable. Consider the following C code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不安全的程序是指在运行时违反了不变性或触发了未定义行为的程序。这些不安全的效果可能仅限于函数内部，也可能在程序中作为全局状态传播开来。其中一些是由程序员自己造成的，例如逻辑错误，而另一些则可能是由于所使用的编译器实现的副作用，有时甚至来自语言规范本身。**不变性**是在程序执行过程中，所有代码路径上必须始终为真的条件。最简单的例子是，指向堆上对象的指针在代码的某个部分内不应为空。如果这个不变性被打破，依赖于该指针的代码可能会取消引用它并发生崩溃。像C/C++这样的语言以及基于它们的语言是不安全的，因为编译器规范中将相当多的操作归类为未定义行为。未定义行为是在程序中遇到编译器规范未指定在较低级别发生什么的情况的效果，你可以自由地假设任何事情都可能发生。未定义行为的一个例子是使用未初始化的变量。考虑以下C代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of this program is not the same with all C compiler implementations
    because using an uninitialized variable is an undefined operation. On some C compilers
    with some optimizations enabled, you may even get the following output:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出在不同的C编译器实现中可能不同，因为使用未初始化的变量是一个未定义的操作。在某些启用了某些优化的C编译器上，你甚至可能会得到以下输出：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Having your code take unpredictable code paths like this is something you don't
    want to see happen in production. Another example of undefined behavior in C is
    writing past the end of an array of size `n`. When the write happens to `n + 1`
    offset in memory, the program may either crash or it may modify a random memory
    location. In the best case scenario, the program would crash immediately and you
    would get to know about this. In the worst case scenario, the program would continue
    running but may later corrupt other parts of the code and give faulty results.
    Undefined behaviors in C exist in the first place to allow compilers to optimize
    code for performance and go with the assumption that a certain corner case never
    happens and to not add error-checking code for these situations, just to avoid
    the overhead associated with error handling. It would be great if undefined behavior
    could be converted to compile time errors, but detecting some of these behaviors
    at compile time sometimes becomes resource intensive, and so not doing so keeps
    the compiler implementation simple.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中看到你的代码采取这种不可预测的代码路径是不希望看到的。C中未定义行为的另一个例子是超出大小为`n`的数组末尾写入。当写入发生到内存中的`n
    + 1`偏移量时，程序可能会崩溃或修改随机的内存位置。在最佳情况下，程序会立即崩溃，你会了解到这一点。在最坏的情况下，程序可能会继续运行，但可能会后来损坏代码的其他部分并给出错误的结果。C中的未定义行为最初存在是为了允许编译器优化代码以获得性能，并假设某些边缘情况永远不会发生，因此不添加错误检查代码来处理这些情况，以避免与错误处理相关的开销。如果可以将未定义行为转换为编译时错误那就太好了，但有时在编译时检测这些行为可能会变得资源密集，因此不这样做可以保持编译器实现简单。
- en: Now, when Rust has to interact with these languages, it knows very little about
    how function calls and how types are represented at lower levels in these languages
    and because undefined behavior can occur at unexpected places, it sidesteps from
    all of these gotchas and instead provides us with a special `unsafe {}` block
    for interacting with things that come from other languages. In unsafe mode, you
    get some extra abilities to do things, which would be considered undefined behavior
    in C/C++. However, with great power comes great responsibility. A a developer
    who uses `unsafe` in their code has to be careful of the operations that are performed
    within the `unsafe` block. With Rust in unsafe mode, the onus is on you. Rust
    places trust in the programmer to keep operations safe. Fortunately, this unsafe
    feature is provided in a very controlled manner and is easily identifiable by
    reading the code, because unsafe code is always annotated with the `unsafe` keyword
    or `unsafe {}` blocks. This is unlike C, where most things are likely to be unsafe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当Rust需要与这些语言交互时，它对这些语言中函数调用和类型在较低级别如何表示了解得非常有限，并且由于未定义行为可能在意想不到的地方发生，它回避了所有这些陷阱，并提供了一个特殊的`unsafe
    {}`块来与来自其他语言的元素交互。在`unsafe`模式下，你获得了一些额外的能力来做一些在C/C++中会被视为未定义行为的事情。然而，权力越大，责任越大。一个在其代码中使用`unsafe`的开发者必须小心在`unsafe`块中执行的操作。在Rust的`unsafe`模式下，责任在你身上。Rust信任程序员保持操作的安全性。幸运的是，这个`unsafe`特性是以非常受控的方式提供的，并且通过阅读代码很容易识别，因为`unsafe`代码总是用`unsafe`关键字或`unsafe
    {}`块进行注释。这与C语言不同，在C语言中，大多数事情都可能是不安全的。
- en: 'Now, it''s important to mention that, while Rust offers to protect you from
    major unsafe situations in programs, there are also cases where Rust can''t save
    you, even if the program you wrote is safe. These are the cases where you have
    logical errors such as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重要的是要提到，虽然Rust提供了保护你免受程序中主要不安全情况的方法，但也有Rust无法救你出来的情况，即使你编写的程序是安全的。这些是存在如下逻辑错误的情况：
- en: A program uses floating-point numbers to represent currency. However, floating-point
    numbers are not precise and lead to rounding errors. This error is somewhat predictable
    (since, given the same input, it always manifests itself in the same way) and
    easy to fix. This is a logic and implementation error, and Rust offers no protection
    for such errors.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个程序使用浮点数来表示货币。然而，浮点数并不精确，会导致舍入误差。这种错误在一定程度上是可以预测的（因为，给定相同的输入，它总是以相同的方式表现出来）并且容易修复。这是一个逻辑和实现错误，Rust对此类错误不提供保护。
- en: A program to control a spacecraft uses primitive numbers as parameters in functions
    to calculate distance metrics. However, a library may be providing an API where
    the distances are interpreted in the metric system, and the user might provide
    numbers in the imperial system, leading to invalid measurements. A similar error
    occurred in 1999, in NASA's Mars Climate Orbiter spacecraft, and caused nearly
    $125 million worth of loss. Rust won't fully protect you from such mistakes, although,
    with the help of type system abstractions such as enums and the newtype pattern,
    we can isolate different units from each other and restrict the API's surface
    to only valid operations, making this error much less likely.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制航天器的程序使用原始数字作为函数中的参数来计算距离度量。然而，一个库可能提供了一个API，其中距离是以公制系统解释的，而用户可能提供英制系统的数字，从而导致无效的测量。1999年，在NASA的火星气候轨道器航天器中就发生了类似的错误，造成了近1250万美元的损失。Rust虽然不能完全保护你免犯此类错误，但借助枚举和newtype模式等类型系统抽象，我们可以将不同的单位彼此隔离，并限制API的表面仅限于有效操作，从而使这种错误的可能性大大降低。
- en: A program writes to shared data from multiple threads without the appropriate
    locking mechanisms. The error manifests itself unpredictably, and finding it can
    be very difficult since it is non-deterministic. In this case, Rust fully protects
    you against data races with its ownership and borrowing rules, which are applicable
    to concurrent code too, but it cannot detect deadlocks for you.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个程序在没有适当的锁定机制的情况下从多个线程写入共享数据。错误以不可预测的方式表现出来，找到它可能非常困难，因为它是非确定性的。在这种情况下，Rust通过其所有权和借用规则完全保护你免受数据竞争的影响，这些规则也适用于并发代码，但它不能为你检测死锁。
- en: A program accesses an object through a pointer, which, in some situations, is
    a null pointer, causing the program to crash. In safe mode, Rust fully protects
    you against null pointers. However, when using unsafe mode, the programmer has
    to make sure that operations with a pointer from other languages are safe.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个程序通过指针访问一个对象，在某些情况下，这个指针是空指针，导致程序崩溃。在安全模式下，Rust完全保护您免受空指针的影响。然而，当使用不安全模式时，程序员必须确保来自其他语言的指针操作是安全的。
- en: 'The unsafe feature of Rust is also needed for situations where the programmer
    knows better than the compiler and has to implement some of the tricky parts in
    their code, where the compile-time ownership rules become too restrictive and
    get in the way. For instance, let''s say there''s a case where you need to convert
    a sequence of bytes into a `String` value and you know that your `Vec<u8>` is
    a valid UTF-8 sequence. In this case, you can directly use the unsafe `String::from_utf_unchecked`
    method instead of the usual safe `String::from_utf8` method to bypass the extra
    overhead in checking for valid UTF-8 in the `from_utf8` method and can gain a
    bit of speedup. Also, when doing low-level embedded system development or any
    program that interfaces with the operating system kernel, you need to switch to
    unsafe mode. However, not everything requires unsafe mode and there are a few
    select operations that the Rust compiler sees as unsafe. They are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的不安全特性在程序员比编译器更了解情况，并且必须在其代码中实现一些复杂部分的情况下也是必需的，在这些情况下，编译时所有权规则变得过于严格，并阻碍了操作。例如，假设有一个需要将字节序列转换为`String`值的情况，并且您知道您的`Vec<u8>`是一个有效的UTF-8序列。在这种情况下，您可以直接使用不安全的`String::from_utf_unchecked`方法，而不是通常的安全`String::from_utf8`方法，以绕过在`from_utf8`方法中检查有效UTF-8的额外开销，并可以略微提高速度。此外，在进行底层嵌入式系统开发或任何与操作系统内核交互的程序时，您需要切换到不安全模式。然而，并非所有内容都需要不安全模式，并且有几个操作是Rust编译器视为不安全的。它们如下：
- en: Updating a mutable static variable
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新可变静态变量
- en: Dereferencing raw pointers, such as `*const T` and `*mut T`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解引用原始指针，例如`*const T`和`*mut T`
- en: Calling an unsafe function
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用不安全函数
- en: Reading values from a union type
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从联合类型中读取值
- en: Invoking a declared function in `extern` blocks – items from other languages
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`extern`块中调用声明的函数——来自其他语言的项
- en: 'Some of the memory-safety guarantees are relaxed in the aforementioned situations,
    but the borrow checker is still active in these operations and all the scoping
    and ownership rules still apply. The Rust reference about unsafety at [https://doc.rust-lang.org/stable/reference/unsafety.html](https://doc.rust-lang.org/stable/reference/unsafety.html)
    distinguishes between what is considered undefined and what is not unsafe. To
    easily distinguish this when you are performing the aforementioned operations,
    Rust requires you to use the `unsafe` keyword. It allows only a handful of places
    to be marked as `unsafe`, such as the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，一些内存安全保证被放宽，但借用检查器在这些操作中仍然活跃，并且所有的作用域和所有权规则仍然适用。Rust关于不安全的文档[https://doc.rust-lang.org/stable/reference/unsafety.html](https://doc.rust-lang.org/stable/reference/unsafety.html)区分了被认为是未定义的和不是不安全的。当您执行上述操作时，为了容易区分，Rust要求您使用`unsafe`关键字。它只允许少数地方被标记为`unsafe`，如下所示：
- en: Functions and methods
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和方法
- en: Unsafe block expressions, such as `unsafe {}`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全块表达式，例如`unsafe {}`
- en: Traits
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性
- en: Implementation blocks
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现块
- en: Unsafe functions and blocks
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全函数和块
- en: 'Let''s look at unsafe functions and blocks, starting with unsafe functions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不安全函数和块，从不安全函数开始：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We defined a `get_value` function that takes in a pointer to an `i32` value,
    which simply returns the pointed value back by dereferencing it. In `main`, we
    are passing `foo` to `get_value`, which is a reference to an `i32` value that `1024`
    cast to `*const i32`. If we try running this, the compiler says the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`get_value`函数，它接受一个指向`i32`值的指针，它通过解引用简单地返回指向的值。在`main`中，我们将`foo`传递给`get_value`，它是`1024`转换为`*const
    i32`的`i32`值的引用。如果我们尝试运行这个程序，编译器会显示以下信息：
- en: '![](img/ac78220b-7cce-4109-bf7e-c1e34a8d421d.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac78220b-7cce-4109-bf7e-c1e34a8d421d.png)'
- en: 'As we already said, we need an `unsafe` function or block to dereference a
    raw pointer. Let''s go with the first suggestion and add `unsafe` before our function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，我们需要一个`unsafe`函数或块来解引用原始指针。让我们按照第一个建议，在我们的函数前添加`unsafe`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s try running this again:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试运行这个程序：
- en: '![](img/28bf6917-59c4-4b83-82b7-b50ddfac96b2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28bf6917-59c4-4b83-82b7-b50ddfac96b2.png)'
- en: 'Interesting! We got rid of the error on our `get_value` function, but now another
    error is shown at the `call` site in `main`. Calling an `unsafe` function requires
    us to wrap it within an `unsafe` block. That''s because unsafe functions, apart
    from Rust''s `unsafe` functions, can also be functions in other languages that
    are declared in `extern` blocks. These might or might not return values that the
    caller expects or a totally malformed value. As such, we need the `unsafe` block
    when calling `unsafe` functions. We modify our code to invoke `get_value` within
    an `unsafe` block like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣！我们消除了`get_value`函数上的错误，但现在在`main`函数的`call`位置显示了另一个错误。调用不安全函数需要我们在其中包裹一个`unsafe`块。这是因为除了Rust的不安全函数之外，不安全函数还可以是声明在`extern`块中的其他语言的函数。这些函数可能或可能不会返回调用者期望的值，或者返回一个完全损坏的值。因此，在调用不安全函数时，我们需要`unsafe`块。我们修改我们的代码，在`unsafe`块中调用`get_value`，如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`unsafe` blocks are expressions, so we remove the semi-colon after `get_value`,
    and instead move it outside the `unsafe` block so that our return value from `get_value`
    gets assigned to `bar`. With that change, our program compiles.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe`块是表达式，所以我们从`get_value`之后移除分号，并将其移到`unsafe`块之外，这样`get_value`的返回值就被分配给了`bar`。有了这个变化，我们的程序就可以编译了。'
- en: 'Unsafe functions behave like regular functions, except that the aforementioned
    operations are allowed in it and that declaring your function as `unsafe` makes
    it non-callable from regular, safe functions. However, we could have written `get_value`
    the other way around:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全函数的行为与普通函数类似，但它在其中允许上述操作，并且将你的函数声明为`unsafe`会使它无法从普通的安全函数中调用。然而，我们也可以将`get_value`写成另一种方式：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This looks similar to before but contains a significant change. We moved the
    `unsafe` keyword from the function signature to an inner `unsafe` block. The function
    now does the same unsafe operation but wraps it inside a function that appears
    just like a regular `safe` function. Now, this function can be called without
    requiring unsafe blocks on the caller side. This technique is often used to provide
    interfaces from libraries that look safe, even though they are doing unsafe operations
    internally. Obviously, if you do this, you should take special care that the `unsafe`
    blocks are correct. There are quite a lot of APIs in the standard library that
    use this paradigm of tucking away operations within `unsafe` blocks while providing
    a safe API on the surface. For example, the `insert` method on the `String` type,
    which inserts a character, `ch`, at a given index, `idx`, is defined like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与之前相似，但有一个显著的变化。我们将`unsafe`关键字从函数签名移动到了一个内部的`unsafe`块中。现在，函数执行相同的非安全操作，但将其封装在一个看起来就像普通的安全函数的函数中。现在，这个函数可以在调用者侧不需要不安全块的情况下被调用。这种技术通常用于提供看起来安全的库接口，尽管它们在内部执行不安全操作。显然，如果你这样做，你应该特别小心确保`unsafe`块是正确的。标准库中有相当多的API使用这种在`unsafe`块中隐藏操作，同时在表面上提供安全API的模式。例如，`String`类型的`insert`方法，它将字符`ch`插入到指定的索引`idx`处，定义如下：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, it does an assertion if the `idx` passed to it lies at the start or the
    end of a UTF-8 encoded code-point sequence. Then, it encodes the `ch` passed to
    it as a sequence of bytes. Finally, it calls an `unsafe` method, `insert_bytes`,
    in an `unsafe` block, passing in `idx` and `bits`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它会检查传递给它的`idx`是否位于UTF-8编码的代码点序列的开始或结束位置。然后，它将传递给它的`ch`编码为一系列字节。最后，它在`unsafe`块中调用一个不安全的方法`insert_bytes`，传递`idx`和`bits`。
- en: There are many such APIs in the standard library that have similar implementations
    where they rely on an unsafe block internally, either to gain speedups or when
    they need mutable access to individual parts of a value because ownership gets
    in the way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有许多类似的API，它们的实现方式相似，它们在内部依赖于不安全块，要么是为了获得速度提升，要么是因为它们需要可变访问值的各个部分，因为所有权阻碍了这种情况。
- en: 'Now, if we call our `get_value` function from our previous snippet, with a
    number as an argument, and cast it to a pointer, you can already guess what''s
    going to happen:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们从之前的代码片段中调用我们的`get_value`函数，并传递一个数字作为参数，然后将其转换为指针，你就可以猜到接下来会发生什么：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running this gives us the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会得到以下输出：
- en: '![](img/869b1b0e-5414-4a28-960a-1cd525392a5b.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/869b1b0e-5414-4a28-960a-1cd525392a5b.png)'
- en: This is an obvious segmentation fault message! The takeaway from this observation
    is that the `unsafe` function, even though appearing safe on the outside, can
    be ignorantly or intentionally misused if the user supplies a malformed value.
    Therefore, if there is the need to expose an unsafe API from your library where
    the safety of your operations is dependent on user-supplied arguments, the author
    should document this clearly to ensure they are not passing an invalid value and
    mark the function with `unsafe` rather than using `unsafe` blocks internally.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个明显的段错误信息！从这个观察结果中可以得出的结论是，即使`unsafe`函数在外观上看起来是安全的，如果用户提供了格式不正确的值，它也可能被无意或故意地误用。因此，如果你需要从你的库中公开一个不安全的API，其中操作的安全性依赖于用户提供的参数，作者应该清楚地记录这一点，以确保他们没有传递无效的值，并且应该用`unsafe`标记函数，而不是在内部使用`unsafe`块。
- en: Safe wrapper functions behind `unsafe` blocks should not really be exposed to
    consumers and instead are to be used mostly to hide implementation details in
    libraries, as is the case with many standard library API implementations. If you're
    not certain that you have managed to create a safe wrapper around the unsafe part,
    you should mark the function as `unsafe`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`unsafe`块后面的安全包装函数实际上不应该暴露给消费者，而应该主要用于在库中隐藏实现细节，就像许多标准库API实现的情况一样。如果你不确定你是否已经成功创建了一个围绕不安全部分的安全包装，你应该将这个函数标记为`unsafe`。
- en: Unsafe traits and implementations
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全特性和实现
- en: Apart from functions, traits can also be marked as unsafe. It isn't obvious
    why we would need unsafe traits. One of the primary motivations for unsafe traits
    existing in the first place is to mark types that cannot be sent to or shared
    between threads. This is achieved via the unsafe `Send` and `Sync` marker traits.
    These types are also auto traits, which means that they are implemented for most
    types in the standard library whenever appropriate. However, they are also explicitly
    opted out for certain types, for instance, the `Rc<T>`. An `Rc<T>` does not have
    an atomic reference counting mechanism and if it were to implement `Sync` and
    later be used in multiple threads, then we might end up with the wrong reference
    counts on the type, which could lead to early frees and dangling pointers. Making
    `Send` and `Sync` unsafe puts the onus on the developer to only implement it,
    that is, if they have proper synchronization in place for their custom types. `Send`
    and `Sync` are marked as `unsafe` because it's incorrect to implement them for
    types that have no clear semantics on how types behave when mutated from multiple
    threads.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数之外，特性也可以被标记为不安全。我们为什么需要不安全特性并不明显。不安全特性最初存在的一个主要动机是标记那些不能发送到或在不同线程之间共享的类型。这是通过不安全的`Send`和`Sync`标记特性实现的。这些类型也是自动特性，这意味着在适当的时候，它们会被实现为标准库中的大多数类型。然而，它们也被明确地排除在某些类型之外，例如`Rc<T>`。`Rc<T>`没有原子引用计数机制，如果它实现了`Sync`并在多个线程中使用，我们可能会得到错误的类型引用计数，这可能导致提前释放和悬挂指针。将`Send`和`Sync`标记为`unsafe`将责任放在了开发者身上，即只有当他们在自定义类型中实现了适当的同步时，才应该实现它。`Send`和`Sync`被标记为`unsafe`是因为为没有明确的语义来描述类型在从多个线程中突变时的行为的类型实现它们是不正确的。
- en: Another motivation for marking traits as unsafe is to encapsulate operations
    that are likely to have an undefined behavior by a family of types. As we've already
    mentioned, traits, by their nature, are used to specify a contract that implementing
    types must hold. Now, let's say your types contain entities from FFI boundaries,
    that is, a field that contains a reference to a C string, and you have many of
    these types. In this case, we can abstract away the behavior of such types by
    using an unsafe trait and then we can have a generic interface that takes types
    that implement this unsafe trait. One such example from Rust's standard library
    is the `Searcher` trait, which is an associated type of the `Pattern` trait,which
    is defined at [https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html](https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html).
    The `Searcher` trait is an unsafe trait that abstracts the notion of searching
    an item from a given byte sequence. One of the implementers of `Searcher` is the
    `CharSearcher` struct. Marking it as `unsafe` removes the burden on the `Pattern`
    trait to check for valid slices on valid UTF-8 byte boundaries and can give you
    some performance gains in string matching.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将特性标记为不安全的另一个动机是通过类型族封装可能具有未定义行为的操作。正如我们之前提到的，特性本质上用于指定实现类型必须遵守的契约。现在，假设你的类型包含来自FFI边界的实体，即包含C字符串引用的字段，并且你有许多这样的类型。在这种情况下，我们可以通过使用不安全特性来抽象这些类型的操作，然后我们可以有一个泛型接口，它接受实现此不安全特性的类型。Rust标准库中的一个这样的例子是`Searcher`特性，它是`Pattern`特性的关联类型，定义在[https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html](https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html)。`Searcher`特性是一个不安全特性，它抽象了从给定字节序列中搜索项的概念。`Searcher`的一个实现者是`CharSearcher`结构体。将其标记为`unsafe`消除了`Pattern`特性在有效UTF-8字节边界上检查有效切片的负担，并且可以在字符串匹配中带来一些性能提升。
- en: 'With the motivation for unsafe traits covered, let''s look at how we can define
    and use unsafe traits. Marking a trait as unsafe doesn''t make your methods unsafe.
    We can have unsafe traits that have safe methods. The opposite is also true; we
    can have a safe trait that can have unsafe methods within it, but that doesn''t
    signify that the trait is unsafe. Unsafe traits are denoted in the same way as
    functions by simply prepending them with the `unsafe` keyword:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了不安全特性的动机之后，让我们看看我们如何定义和使用不安全特性。将特性标记为不安全并不会使你的方法变得不安全。我们可以有不安全特性，它们有安全的方法。反之亦然；我们可以有一个安全的特性，它可以在其中包含不安全的方法，但这并不表示该特性是不安全的。不安全特性与函数的表示方式相同，只需在它们前面加上`unsafe`关键字：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we have all kinds of variations with unsafe traits and
    methods. First, we have two trait declarations: `UnsafeTrait`, which is an unsafe
    trait and `SafeTrait`, which is safe. We also have a unit struct called `MyType`,
    which implements them. As you can see, unsafe traits require the `unsafe` prefix
    to implement `MyType`, letting the implementer know that they have to uphold the
    contracts that are expected by the trait. In the second implementation of the
    `SafeTrait` on `MyType`, we have an unsafe method that we need to call within
    the `unsafe` block, as we can see in the `main` function.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有许多包含不安全特性和方法的变体。首先，我们有两种特性声明：`UnsafeTrait`，这是一个不安全的特性，而`SafeTrait`是安全的。我们还有一个名为`MyType`的单例结构体，它实现了这两个特性。正如你所见，不安全特性需要`unsafe`前缀来实现`MyType`，这样让实现者知道他们必须遵守特性所期望的契约。在`MyType`上的`SafeTrait`的第二种实现中，我们有一个需要在`unsafe`块内调用的不安全方法，正如我们在`main`函数中所见。
- en: In the following sections, we'll be exploring a handful of languages and how
    Rust interoperates with them. All of the related APIs and abstractions that Rust
    provides to communicate safely back and forth between languages is colloquially
    termed the **Foreign Function Interface** (**FFI**). As part of the standard library,
    Rust provides us with built-in FFI abstractions. Wrapper libraries on top of these
    provide seamless cross-language interaction.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨一些语言以及Rust如何与它们交互。Rust提供的相关API和抽象，用于在语言之间安全地双向通信，通常被称为**外部函数接口**（**FFI**）。作为标准库的一部分，Rust为我们提供了内置的FFI抽象。在这些抽象之上构建的包装库提供了无缝的跨语言交互。
- en: Calling C code from Rust
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Rust调用C代码
- en: 'First, we''ll take a look at an example of calling C code from Rust. We''ll
    create a new binary crate from which we''ll call our C function that''s defined
    in a separate C file. Let''s create a new project by running `cargo new c_from_rust`.
    Within the directory, we''ll also add our C source, that is, the `mystrlen.c`
    file, which has the following code inside it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看一个从 Rust 调用 C 代码的例子。我们将创建一个新的二进制包，从该包中我们将调用定义在单独的 C 文件中的我们的 C 函数。让我们通过运行
    `cargo new c_from_rust` 来创建一个新的项目。在目录内，我们还将添加我们的 C 源文件，即 `mystrlen.c` 文件，其内部代码如下：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It contains a simple function, `mystrlen`, which returns the length of a string
    passed to it. We want to invoke `mystrlen` from Rust. To do that, we''ll need
    to compile this C source into a static library. There''s one more example in the
    upcoming section, where we cover linking dynamically to a shared library. We''ll
    use the `cc` crate as a build dependency in our `Cargo.toml` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一个简单的函数，`mystrlen`，该函数返回传递给它的字符串的长度。我们希望从 Rust 中调用 `mystrlen`。为此，我们需要将这个
    C 源文件编译成一个静态库。在下一节中，我们还有一个例子，其中我们将介绍如何动态链接到共享库。我们将在 `Cargo.toml` 文件中将 `cc` 包用作构建依赖项：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `cc` crate does all the heavy lifting of compiling and linking our C source
    file with our binary with correct linker flags. To specify our build commands,
    we need to put a `build.rs` file at the crate root, which has the following contents:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`cc` 包负责编译和链接我们的 C 源文件与我们的二进制文件，并使用正确的链接器标志。为了指定我们的构建命令，我们需要在包根目录下放置一个 `build.rs`
    文件，其内容如下：'
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We created a new `Build` instance and passed the C source filename with the
    static flag set to `true` before giving a name to our static object file to the `compile`
    method. Cargo runs the contents of any `build.rs` file before any project files
    get compiled. Upon running code from `build.rs`, the `cc` crate automatically
    appends the conventional `lib` prefix in C libraries, so our compiled static library
    gets generated at `target/debug/build/c_from_rust-5c739ceca32833c2/out/libmystrlen.a`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的 `Build` 实例，并在给我们的静态对象文件命名之前，将 C 源文件名和静态标志设置为 `true` 传递给 `compile`
    方法。Cargo 在编译任何项目文件之前，都会运行任何 `build.rs` 文件的内容。在运行 `build.rs` 中的代码时，`cc` 包会自动在 C
    库中追加传统的 `lib` 前缀，因此我们的编译后的静态库生成在 `target/debug/build/c_from_rust-5c739ceca32833c2/out/libmystrlen.a`。
- en: 'Now, we also need to tell Rust about the existence of our `mystrlen` function.
    We do this by using `extern` blocks, where we can specify items that come from
    other languages. Our `main.rs` file is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要让 Rust 知道我们的 `mystrlen` 函数的存在。我们通过使用 `extern` 块来实现，这样我们就可以指定来自其他语言的项。我们的
    `main.rs` 文件如下：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have a couple of imports from the `std::os::raw` module that contain types
    that are compatible with primitive C types and have names close to their C counterparts.
    For numeric types, a single letter before the type says whether the type is unsigned.
    For instance, the unsigned integer is defined as `c_uint`. In our `extern` declaration
    of `mystrlen`, we take a `*const c_char` as input, which is equivalent to `char
    *` in C, and return a `c_uint` as output, which maps to `unsigned int` in C. We
    also import the `CString` type from the `std::ffi` module, as we need to pass
    a C-compatible string to our `mystrlen` function. The `std::ffi` module contains
    common utilities and types that make it easy to perform cross language interactions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `std::os::raw` 模块中导入了一些与原始 C 类型兼容的类型，并且它们的名称接近它们的 C 对应类型。对于数值类型，类型前的单个字母表示该类型是否是无符号的。例如，无符号整数定义为
    `c_uint`。在我们的 `extern` 声明 `mystrlen` 中，我们以 `*const c_char` 作为输入，这相当于 C 中的 `char
    *`，并以 `c_uint` 作为输出，这映射到 C 中的 `unsigned int`。我们还从 `std::ffi` 模块中导入了 `CString`
    类型，因为我们需要将一个与 C 兼容的字符串传递给 `mystrlen` 函数。`std::ffi` 模块包含了一些常用的实用工具和类型，使得跨语言交互变得容易。
- en: As you may have noticed, in the `extern` block, we have a string, `"C"`, following
    it. This `"C"` specifies that we want the compiler's code generator to confirm
    to the C ABI (`cdecl`) so that the function-calling convention follows exactly
    as a function call that's done from C. An **Application Binary Interface** *(***ABI**)
    is basically a set of rules and conventions that dictate how types and functions
    are represented and manipulated at the lower levels. The function-calling convention
    is one aspect of an ABI specification. It's quite analogous to what an API means
    for a library consumer. In the context of functions, an API specifies what functions
    you can call from the library, while the ABI specifies the lower-level mechanism
    by which a function is invoked. A calling convention defines things such as whether
    function parameters are stored in registers or on the stack, and whether the caller
    clears the register/stack state or the caller when the function returns, and other
    details. We could have also ignored specifying this, as `"C"` (`cdecl`) is the
    default ABI in Rust for items that are declared in an `extern` block. The `cdecl`
    is a calling convention that's used by most C compilers for function calls. There
    are also other ABIs that Rust supports such as `fastcall`, `cdecl`, `win64`, and
    others, and these need to be put after the `extern` block based on what platform
    you are targeting.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到，在`extern`块中，我们跟随着一个字符串`"C"`。这个`"C"`指定了我们希望编译器的代码生成器符合C ABI（`cdecl`），以便函数调用约定与从C进行的函数调用完全一致。**应用二进制接口**（***ABI**）基本上是一套规则和约定，它规定了在较低级别如何表示和处理类型和函数。函数调用约定是ABI规范的一个方面。它与库消费者对API的含义非常相似。在函数的上下文中，API指定了你可以从库中调用的函数，而ABI指定了调用函数的较低级机制。调用约定定义了诸如函数参数是存储在寄存器中还是堆栈上，以及调用者在函数返回时是否清除寄存器/堆栈状态，以及其他细节。我们也可以忽略指定这一点，因为`"C"`（`cdecl`）是Rust中`extern`块中声明的项目的默认ABI。`cdecl`是一种大多数C编译器用于函数调用的调用约定。Rust还支持其他ABI，如`fastcall`、`cdecl`、`win64`等，并且需要根据目标平台在`extern`块之后指定。
- en: 'In our `main` function, we use a special version of a `CString` string from
    the `std::ffi` module because strings in C are null terminated, while Rust one''s
    aren''t. `CString` does all the checks for us to give us a C-compatible version
    of strings where we don''t have a null `0` byte character in the middle of the
    string and ensures that the ending byte is a `0` byte. The `ffi` module contains
    two major string types:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，我们使用`std::ffi`模块中的一个特殊版本的`CString`字符串，因为C中的字符串是空终止的，而Rust中的字符串不是。`CString`为我们执行所有检查，以提供一个与C兼容的字符串版本，其中字符串中间没有空`0`字节字符，并确保结尾字节是一个`0`字节。`ffi`模块包含两种主要的字符串类型：
- en: '`std::ffi::CStr` represents a borrowed C string that''s analogous to `&str`.
    It can be used to reference a string that has been created in C.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ffi::CStr`表示一个类似于`&str`的借用C字符串。它可以用来引用在C中创建的字符串。'
- en: '`std::ffi::CString` represents an owned string that is compatible with foreign
    C functions. It is often used to pass strings from Rust code to foreign C functions.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ffi::CString`表示一个与外国C函数兼容的所有权字符串。它通常用于将字符串从Rust代码传递到外国C函数。'
- en: Since we want to pass a string from the Rust side to the function we just defined,
    we used the `CString` type here. Following that, we call `mystrlen` in an unsafe
    block, passing in the `c_string` as a pointer. We then print the string length
    to standard output.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望从Rust一侧将字符串传递到我们刚刚定义的函数，所以我们在这里使用了`CString`类型。随后，我们在一个不安全块中调用`mystrlen`，将`c_string`作为指针传递。然后我们将字符串长度打印到标准输出。
- en: 'Now, all we need to do is run `cargo run`. We get the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要运行`cargo run`。我们得到以下输出：
- en: '![](img/69929d3f-ca44-46af-9aeb-28a3582ffaf4.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69929d3f-ca44-46af-9aeb-28a3582ffaf4.png)'
- en: 'The `cc` crate automatically figures out the correct C compiler to call. In
    our case, on Ubuntu, it automatically invokes `gcc` to link our C library. Now,
    there are a couple of improvements to be made here. First, it is awkward that
    we have to be in an `unsafe` block to call the function as we know it''s not unsafe.
    We know our C implementation is sound, at least for this small function. Second,
    we will panic if `CString` creation fails. To solve this, we can create a safe
    wrapper function. In a simplistic form, this just means creating a function that
    calls the external function inside an unsafe block:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`cc` 包会自动确定要调用的正确 C 编译器。在我们的例子中，在 Ubuntu 上，它会自动调用 `gcc` 来链接我们的 C 库。现在，这里有一些需要改进的地方。首先，我们必须在一个
    `unsafe` 块中调用函数，这很尴尬，因为我们知道这并不是不安全的。我们知道我们的 C 实现是可靠的，至少对于这个小的函数来说是这样。其次，如果 `CString`
    创建失败，我们会引发 panic。为了解决这个问题，我们可以创建一个安全的包装器函数。在简单形式下，这意味着创建一个函数，在该函数中调用外部函数，并将其放在
    `unsafe` 块内部：'
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our `safe_mystrlen` function returns an `Option` now, where it returns `None`
    if `CString` creation fails and, following that, calls `mystrlen` wrapped in an
    `unsafe` block, which is returned as `Some`. Calling `safe_mystrlen` feels exactly
    like calling any other Rust function. If possible, it's recommended to make safe
    wrappers around external functions, taking care that all exceptional cases happening
    inside the `unsafe` block are handled properly so that library consumers don't
    use unsafe in their code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `safe_mystrlen` 函数现在返回一个 `Option`，如果 `CString` 创建失败，则返回 `None`，然后调用包裹在 `unsafe`
    块中的 `mystrlen`，并作为 `Some` 返回。调用 `safe_mystrlen` 的感觉就像调用任何其他 Rust 函数一样。如果可能的话，建议围绕外部函数创建安全的包装器，确保在
    `unsafe` 块内部发生的所有异常情况都得到妥善处理，这样库的用户就不会在他们的代码中使用 `unsafe`。
- en: Calling Rust code from C
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 C 调用 Rust 代码
- en: As we stated in the previous section, when Rust libraries expose their functions
    to other languages using the `extern` block, they expose the C ABI (`cdecl`) by
    default. As such, it becomes a very seamless experience of calling Rust code from
    C. To C, they appear just like regular C functions. We'll take a look at an example
    of calling Rust code from a C program. Let's create a cargo project for this by
    running `cargo new rust_from_c --lib`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节所述，当 Rust 库通过 `extern` 块将它们的函数暴露给其他语言时，它们默认暴露 C ABI (`cdecl`)。因此，从 C
    调用 Rust 代码变得非常无缝。我们将通过一个从 C 程序调用 Rust 代码的例子来查看。让我们通过运行 `cargo new rust_from_c
    --lib` 来创建一个 cargo 项目。
- en: 'In our `Cargo.toml` file, we have the following items:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Cargo.toml` 文件中，我们有以下项目：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Under the `[lib]` section, we specified the crate as `cdylib`, which indicates
    that we want a dynamically loadable library to be generated, which is more commonly
    known as a shared object file (`.so`) in Linux. We specified an explicit name
    for our `stringutils` library, and this will be used to create the shared object
    file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[lib]` 部分，我们指定了 crate 为 `cdylib`，这表示我们想要生成一个可动态加载的库，这在 Linux 中更常见地被称为共享对象文件（`.so`）。我们为我们的
    `stringutils` 库指定了一个显式的名称，这将用于创建共享对象文件。
- en: 'Now, let''s move on to our implementation in `lib.rs`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们在 `lib.rs` 中的实现：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have a single function, `compare_str`. We prepend it with the `extern` keyword
    to expose it to C, followed by specifying the `"C"` ABI for the compiler to generate
    code appropriately. We also need to add a `#[no_mangle]` attribute, as Rust adds
    random characters to function names by default to prevent the clashing of names
    of types and functions across modules and crates. This is called name mangling.
    Without this attribute, we won''t be able to call our function by the name `compare_str`.
    Our function lexicographically compares two C strings passed to it and returns
    an enum, `Order`, accordingly, which has three variants: `Gt` (Greater than),
    `Lt` (Less than), and `Eq` (Equal). As you may have noticed, the enum definition
    has a `#[repr(C)]` attribute. Because this enum is being returned to the C side,
    we want it to be represented in the same way as a C enum. The `repr` attribute
    allows us to do that. On the C side, we will get a `uint_32` type as the return
    type of this function as enums variants are represented as 4 bytes in Rust, as
    well as in C. Do note that at the time of writing this book, Rust follows the
    same data layout for enums that have associated data as it does for C enums. However,
    this may change in the future.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个单独的函数，`compare_str`。我们使用`extern`关键字将其暴露给C语言，然后指定编译器为生成适当的代码指定`"C"` ABI。我们还需要添加一个`#[no_mangle]`属性，因为Rust默认情况下会为函数名添加随机字符以防止模块和crate之间类型和函数名称冲突。这被称为名称混淆。如果没有这个属性，我们就无法通过`compare_str`这个名字来调用我们的函数。我们的函数按照字典顺序比较传递给它的两个C字符串，并相应地返回一个枚举，`Order`，它有三个变体：`Gt`（大于）、`Lt`（小于）和`Eq`（等于）。正如你可能已经注意到的，枚举定义有一个`#[repr(C)]`属性。因为这个枚举是要返回到C端的，我们希望它以与C枚举相同的方式表示。`repr`属性允许我们做到这一点。在C端，我们将得到一个`uint_32`类型作为这个函数的返回类型，因为Rust和C中枚举变体都是以4字节表示的。请注意，在撰写这本书的时候，Rust对于具有关联数据的枚举遵循与C枚举相同的数据布局。然而，这可能在将来发生变化。
- en: 'Now, let''s create a file called `main.c` that uses our exposed function from
    Rust:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`main.c`的文件，它使用我们从Rust暴露的函数：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We declared the prototype of our `compare_str` function, just like any normal
    prototype declaration. Following that, we called `compare_str` in `main`, passing
    in our two string values. Do note that if we were passing strings that were allocated
    on the heap, we would need to also free it from the C side. In this case, we are
    passing a C string literal that goes to the data segment of the process, and so
    we don''t need to do any free calls. Now, we''ll create a simple `Makefile` that
    builds our `stringutils` crate and also compiles and links with our `main.c` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像任何正常的原型声明一样声明了`compare_str`函数的原型。随后，我们在`main`中调用了`compare_str`，传递了我们的两个字符串值。请注意，如果我们传递的是在堆上分配的字符串，我们还需要从C端释放它。在这种情况下，我们传递的是一个C字符串字面量，它位于进程的数据段中，所以我们不需要进行任何释放调用。现在，我们将创建一个简单的`Makefile`，它构建我们的`stringutils`
    crate，并编译和链接我们的`main.c`文件：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now run `make` to build our crate and then run `main` by first setting
    our `LD_LIBRARY_PATH` to where our generated `libstringutils.so` resides. Following
    that, we can run `main` like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`make`来构建我们的crate，然后通过首先设置我们的`LD_LIBRARY_PATH`指向我们的生成的`libstringutils.so`所在的位置来运行`main`。之后，我们可以这样运行`main`：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This gives us an output of `1`, which is the value of the `Lt` variant from
    the `Order` enum on the Rust side. The takeaway from this example is that when
    you are invoking a Rust function from C/C++ or any other language that has a supported
    ABI in Rust, we cannot pass Rust-specific data types to the FFI boundary. For
    instance, passing `Option` or `Result` types, that ha've associated data with
    them is meaningless, as C cannot interpret and extract values out of them, as
    it has no way of knowing about that. In such cases, we need to pass primitive
    values as return types from functions to the C side or convert our Rust type to
    some format that C can understand.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个输出`1`，这是Rust端的`Order`枚举中`Lt`变体的值。从这个例子中我们可以得到的启示是，当你从C/C++或其他在Rust中有支持ABI的语言调用Rust函数时，我们不能将Rust特定的数据类型传递到FFI边界。例如，传递带有关联数据的`Option`或`Result`类型是没有意义的，因为C无法解释和从中提取值，因为它没有知道这些数据的方式。在这种情况下，我们需要将原始值作为函数的返回类型传递到C端，或者将我们的Rust类型转换为C可以理解的形式。
- en: Now, consider our previous case of calling C code from Rust. In the manual way,
    we needed to write `extern` declarations for all of our APIs that have been declared
    in header files. It would be great if this could be automated for us. Let's see
    how we can do that next!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑之前从 Rust 调用 C 代码的案例。按照手动方式，我们需要为所有在头文件中声明的 API 编写 `extern` 声明。如果能自动完成这项工作那就太好了。接下来，我们将看看如何实现这一点！
- en: Using external C/C++ libraries from Rust
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中使用外部 C/C++ 库
- en: Given the amount of software written over the last three decades, a lot of system
    software is written in C/C++. It's more likely that you may want to link to an
    existing library written in C/C++ for use in Rust, as rewriting everything in
    Rust (though desirable) is not practical for complex projects. But at the same
    time, writing manual FFI bindings for these libraries is also painful and error-prone.
    Fortunately, there are tools for us to automatically generate bindings to C/C++
    libraries. For this demo, the required code on the Rust side is much simpler than
    the previous example of calling C/C++ code from Rust, as, this time, we'll use
    a neat crate called **bindgen** that automatically generates FFI bindings from
    C/C++ libraries. Bindgen is the recommended tool if someone wants to integrate
    a complex library with lots of APIs. Writing these bindings manually can be very
    error-prone and bindgen helps us by automating this process. We'll use this crate
    to generate bindings for a simple C library, `levenshtein.c`, which can be found
    at [https://github.com/wooorm/levenshtein.c](https://github.com/wooorm/levenshtein.c),
    which is used to find the minimum edit distance between two strings. The edit
    distance is used in a wide variety of applications, such as in fuzzy string matching,
    natural language processing, and in spell checkers. Anyway, let's create our cargo
    project by running `cargo new edit_distance --lib`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到过去三十年中编写的软件数量，大量的系统软件是用 C/C++ 编写的。你可能会想链接到一个用 C/C++ 编写的现有库，用于 Rust 的项目中，尽管在
    Rust 中重写一切（尽管是可取的）对于复杂项目来说并不实际。但与此同时，为这些库编写手动 FFI 绑定也是痛苦且容易出错的。幸运的是，我们有工具可以自动生成
    C/C++ 库的绑定。对于这个演示，Rust 端所需的代码比之前从 Rust 调用 C/C++ 代码的例子要简单得多，因为这次我们将使用一个叫做 **bindgen**
    的整洁的 crate，它可以从 C/C++ 库中自动生成 FFI 绑定。如果你想要集成一个具有大量 API 的复杂库，bindgen 是推荐的工具。手动编写这些绑定可能会非常容易出错，而
    bindgen 通过自动化这个过程来帮助我们。我们将使用这个 crate 为一个简单的 C 库 `levenshtein.c` 生成绑定，该库可以在 [https://github.com/wooorm/levenshtein.c](https://github.com/wooorm/levenshtein.c)
    找到，它用于找到两个字符串之间的最小编辑距离。编辑距离被广泛应用于各种应用中，如模糊字符串匹配、自然语言处理和拼写检查器。无论如何，让我们通过运行 `cargo
    new edit_distance --lib` 来创建我们的 cargo 项目。
- en: 'Before we use bindgen, we need to install a few dependencies as bindgen needs
    them:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 bindgen 之前，我们需要安装一些依赖项，因为 bindgen 需要它们：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, in our `Cargo.toml` file, we''ll add a `build` dependency on `bindgen`
    and the `cc` crate:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的 `Cargo.toml` 文件中，我们将添加对 `bindgen` 和 `cc` crate 的 `build` 依赖项：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `bindgen` crate will be used to generate bindings from the `levenshtein.h`
    header file, while the `cc` crate will be used to compile our library as a shared
    object so that we can use it from Rust. Our library-related files reside in the
    `lib` folder at the crate root.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`bindgen` crate 将用于从 `levenshtein.h` 头文件生成绑定，而 `cc` crate 将用于将我们的库编译为共享对象，以便我们可以从
    Rust 中使用它。我们的库相关文件位于 crate 根目录下的 `lib` 文件夹中。'
- en: 'Next, we''ll create our `build.rs` file, which will be run before any of our
    source files are compiled. It will do two things: first, it will compile `levenshtein.c`
    to a shared object (`.so`) file, and second, it will generate bindings to the
    APIs defined in the `levenshtein.h` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 `build.rs` 文件，该文件将在编译任何源文件之前运行。它将完成两件事：首先，它将编译 `levenshtein.c` 到一个共享对象（`.so`）文件，其次，它将为
    `levenshtein.h` 文件中定义的 API 生成绑定：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we tell Cargo that our library search path is our current
    directory and that the library we are linking against is called `levenshtein`.
    We also tell Cargo to rerun code in `build.rs` if any of our files in our current
    directory change:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们告诉 Cargo 我们的库搜索路径是当前目录，我们正在链接的库名为 `levenshtein`。我们还告诉 Cargo，如果当前目录中的任何文件发生变化，则重新运行
    `build.rs` 中的代码：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following that, we create a compilation pipeline for our library by creating
    a new `Build` instance and provide the appropriate C source file for the `file`
    method. We also set the output directory to `out_dir` and our library name to
    the `compile` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们通过创建一个新的 `Build` 实例来为我们的库创建一个编译管道，并为 `file` 方法提供适当的 C 源文件。我们还设置了输出目录为
    `out_dir`，并将我们的库名称设置为 `compile` 方法：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we create a bindgen `Builder` instance, pass our header file location,
    call `generate()`, and then write it to a `bindings.rs` file before calling `write_to_file`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个bindgen `Builder`实例，传递我们的头文件位置，调用`generate()`，然后在调用`write_to_file`之前将其写入一个`bindings.rs`文件：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, when we run `cargo build`, a `bindings.rs` file will be generated under
    `src/`. As we mentioned previously, it''s good practice for all libraries that
    are exposing FFI bindings to provide a safe wrapper. So, under `src/lib.rs`, we''ll
    create a function named `levenshtein_safe` that wraps the unsafe function from
    `bindings.rs`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行`cargo build`时，一个`bindings.rs`文件将在`src/`下生成。正如我们之前提到的，对于所有暴露FFI绑定的库来说，提供一个安全包装是一个好的实践。因此，在`src/lib.rs`下，我们将创建一个名为`levenshtein_safe`的函数，该函数封装了从`bindings.rs`中的不安全函数：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We import the unsafe function from `bindings.rs`, wrap it within our `levenshtein_safe`
    function, and call our `levenshtein` function in an `unsafe` block, passing C-compatible
    strings. It''s time to test our `levenshtein_safe` function. We''ll create a `basic.rs` file
    in an `examples/` directory in our crate root, which has the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`bindings.rs`导入不安全函数，将其封装在我们的`levenshtein_safe`函数中，并在一个`unsafe`块中调用我们的`levenshtein`函数，传递与C兼容的字符串。现在是测试我们的`levenshtein_safe`函数的时候了。我们将在我们的crate根目录下的`examples/`目录中创建一个`basic.rs`文件，其代码如下：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can run this with `cargo run --example basic` and we should see no assertion
    failures as the value should be `1` from the `levenshtein_safe` call. Now, it's
    a recommended naming convention for these kind of crates to have the suffix `sys` appended
    to them, which only houses FFI bindings. Most crates on `crates.io` follow this
    convention. This was a whirlwind tour on how to use bindgen to automate cross-language
    interaction. If you want similar automation for reverse FFI bindings, such as
    Rust in C, there is also an equivalent project called `cbindgen` at [https://github.com/eqrion/cbindgen](https://github.com/eqrion/cbindgen),
    which can generate C header files for Rust crates. For instance, `Webrender` uses
    this crate to expose its APIs to other languages. Given the legacy of C, it's
    the lingua franca of programming languages and Rust has first-class support for
    it. A lot of other languages also call into C. This implies that your Rust code
    can be called from all other languages that target C. Let's make other languages
    talk to Rust.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cargo run --example basic`来运行它，并且应该看到没有断言失败，因为从`levenshtein_safe`调用中得到的值应该是`1`。现在，对于这类crate，建议在它们后面添加后缀`sys`，这样只包含FFI绑定。`crates.io`上的大多数crate都遵循这个约定。这简要介绍了如何使用bindgen来自动化跨语言交互。如果您想要类似自动化反向FFI绑定，例如Rust在C中，还有一个名为`cbindgen`的等效项目，位于[https://github.com/eqrion/cbindgen](https://github.com/eqrion/cbindgen)，它可以生成Rust
    crate的C头文件。例如，`Webrender`使用这个crate将其API暴露给其他语言。鉴于C的遗产，它是编程语言的通用语言，Rust对其提供了第一级支持。许多其他语言也调用C。这意味着您的Rust代码可以从所有以C为目标的其他语言中调用。让我们让其他语言与Rust通信。
- en: Creating native Python extensions with PyO3
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyO3创建原生Python扩展
- en: In this section, we'll see how Python can also call Rust code. The Python community
    has always been a heavy user of native modules such as numpy, lxml, opencv, and
    so on, and most of them have their underlying implementations in either C or C++.
    Having Rust as an alternative to native C/C++ modules is a major advantage both
    in terms of speed and safety for a lot of Python projects out there. For the demo,
    we'll build a native Python module that's implemented in Rust. We'll be using
    `pyo3`, a popular project that provides Rust bindings for the Python interpreter
    and hides all the low-level details, thus providing a very intuitive API. The
    project is on GitHub at [https://github.com/PyO3/pyo3](https://github.com/PyO3/pyo3).
    It supports both Python 2 and Python 3 versions. `pyo3` is a fast-moving target
    and only works on nightly at the time of writing this book. So, we'll use a specific
    version of `pyo3`, that is, `0.4.1`, along with a specific nightly version of
    the Rust compiler.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到Python也可以调用Rust代码。Python社区一直是诸如numpy、lxml、opencv等原生模块的重量级用户，其中大部分都有其底层实现是在C或C++中。将Rust作为原生C/C++模块的替代品，对于许多Python项目来说，在速度和安全方面都是一个主要优势。对于演示，我们将构建一个在Rust中实现的原生Python模块。我们将使用`pyo3`，这是一个流行的项目，它为Python解释器提供Rust绑定，并隐藏所有底层细节，从而提供了一个非常直观的API。该项目位于GitHub上[https://github.com/PyO3/pyo3](https://github.com/PyO3/pyo3)。它支持Python
    2和Python 3版本。`pyo3`是一个快速发展的目标，在撰写本书时仅在nightly版本上工作。因此，我们将使用`pyo3`的一个特定版本，即`0.4.1`，以及Rust编译器的特定nightly版本。
- en: Let's create a new cargo project by running `cargo new word_suffix --lib`. This
    library crate will expose a Python module called `word_suffix`, which contains
    a single function, `find_words`, which accepts a comma-separated string of words
    and returns all the words in that text that end with a given suffix. Once we build
    our module, we'll be able to import this module like a normal Python module.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `cargo new word_suffix --lib` 来创建一个新的货物项目。这个库包将暴露一个名为 `word_suffix` 的 Python
    模块，其中包含一个名为 `find_words` 的单个函数，该函数接受一个以逗号分隔的单词字符串，并返回所有以给定后缀结尾的单词。一旦我们构建了我们的模块，我们就能像导入普通
    Python 模块一样导入这个模块。
- en: Before we go ahead with the implementation, we'll need to switch to a specific
    nightly Rust toolchain for this project, that is, `rustc 1.30.0-nightly (33b923fd4
    2018-08-18)`. We can override the toolchain to use this specific nightly version
    for this project by running `rustup override set nightly-2018-08-19` in our current
    directory (`word_suffix/`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现之前，我们需要切换到为这个项目特定的 nightly Rust 工具链，即 `rustc 1.30.0-nightly (33b923fd4
    2018-08-18)`。我们可以通过在当前目录（`word_suffix/`）中运行 `rustup override set nightly-2018-08-19`
    来覆盖工具链，以使用这个特定的 nightly 版本。
- en: 'To start things off, we''ll specify our dependencies in our `Cargo.toml` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将在我们的 `Cargo.toml` 文件中指定我们的依赖项：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We added our only dependency here on `pyo3`. As you can see, in the `[lib]`
    section, we specified the `crate-type` as `cdylib`, which means that the generated
    library is similar to a C shared library (`.so` in linux), which Python already
    knows how to call.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了我们的唯一依赖项 `pyo3`。如您所见，在 `[lib]` 部分，我们指定了 `crate-type` 为 `cdylib`，这意味着生成的库类似于
    C 共享库（Linux 中的 `.so`），Python 已经知道如何调用它。
- en: 'Now, let''s start the implementation in our `lib.rs` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的 `lib.rs` 文件中开始实现：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we imported our `pyo3` crate, along with all the Python-related types
    from the `prelude` module. Then, we defined a `word_suffix` function, annotating
    it with the `#[pymodinit]` attribute. This becomes our Python module, which  we
    can import in any `.py` file. This function receives two arguments. The first
    argument is `Python`, a marker type that is required for most Python related operations
    in `pyo3`. This is used to indicate that a particular operation modifies the Python
    interpreter state. The second argument is a `PyModule` instance, which represents
    a Python module object. Through this instance, we then add our `find_words` function,
    wrapped inside the `wrap_function` macro by calling `add_function`. The `wrap_function`
    macro does some manipulation to the provided Rust function to convert it into
    a Python-compatible function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入了我们的 `pyo3` 包，以及来自 `prelude` 模块的 Python 相关类型。然后，我们定义了一个 `word_suffix`
    函数，并使用 `#[pymodinit]` 属性对其进行注释。这成为我们的 Python 模块，我们可以在任何 `.py` 文件中导入它。此函数接收两个参数。第一个参数是
    `Python`，这是一个标记类型，对于 `pyo3` 中的大多数 Python 相关操作都是必需的。这用于指示特定操作会修改 Python 解释器状态。第二个参数是
    `PyModule` 实例，它表示一个 Python 模块对象。通过此实例，我们添加我们的 `find_words` 函数，通过调用 `add_function`
    并在 `wrap_function` 宏中包装它来添加。`wrap_function` 宏对提供的 Rust 函数进行一些操作，将其转换为 Python 兼容的函数。
- en: Next, is our `find_words` function, which is the important piece here. We wrap
    it with a `#[pyfunction]` attribute, which performs conversions on the argument
    and return type of our function so that it's compatible with a Python function.
    Our `find_words` implementation is simple. First, we create a vector, `v`, to
    hold the list of filtered words. Then, we filter our `src` string by splitting
    on `","`, followed by a `filter` and `map` operation. The `split(",")` call returns
    an iterator on which we call the `filter_map` method. This method receives a closure
    as an argument containing the split word `s`. We first remove any white space
    from our `s` by calling `s.trim()`, followed by checking whether it `ends_with`
    our provided `suffix` string. If it does, it converts `trimmed` to an owned `String`
    wrapping in `Some`; otherwise, it returns `None`. We then iterate over all the
    filtered words (if any), push them to our `v`, and return it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的 `find_words` 函数，这是这里的重要部分。我们使用 `#[pyfunction]` 属性将其包装起来，该属性对函数的参数和返回类型进行转换，使其与
    Python 函数兼容。我们的 `find_words` 实现很简单。首先，我们创建一个向量 `v` 来保存过滤后的单词列表。然后，我们通过在 `","`
    上分割 `src` 字符串，然后进行 `filter` 和 `map` 操作来过滤我们的 `src` 字符串。`split(",")` 调用返回一个迭代器，我们对它调用
    `filter_map` 方法。此方法接收一个包含分割单词 `s` 的闭包作为参数。我们首先通过调用 `s.trim()` 从 `s` 中移除任何空白字符，然后检查它是否
    `ends_with` 我们提供的后缀字符串。如果是，它将 `trimmed` 转换为拥有 `String` 的 `Some`；否则，它返回 `None`。然后，我们遍历所有过滤后的单词（如果有），将它们推送到我们的
    `v` 中，并返回它。
- en: 'With that explanation out of the way, it''s time to build our Python module.
    To do that, we have `pyo3-pack`: another tool from the same `pyo3` project that
    automates the whole process of making a native Python module. This tool also has
    the ability to publish the built packages to the **Python Package Index** (**PyPI**).
    Let''s install `pyo3-pack` by running `cargo install pyo3-pack`. Now, we can generate
    the package as a Python wheel (`.whl`), followed by installing the package locally
    using `pyo3-pack develop`. But before we do that, we need to be in a Python virtual
    environment, since the `py3-pack develop` command requires that.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 解释到此为止，现在是时候构建我们的 Python 模块了。为此，我们有 `pyo3-pack`：来自同一 `pyo3` 项目的另一个工具，它自动化了制作本机
    Python 模块的全过程。此工具还具有将构建的包发布到 **Python 包索引**（**PyPI**）的能力。让我们通过运行 `cargo install
    pyo3-pack` 来安装 `pyo3-pack`。现在，我们可以生成一个 Python 轮子（`.whl`）包，然后使用 `pyo3-pack develop`
    在本地安装该包。但在我们这样做之前，我们需要处于一个 Python 虚拟环境中，因为 `py3-pack develop` 命令要求这样做。
- en: 'We can create our virtual environment by running the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码来创建我们的虚拟环境：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are using Python 3.5 here. After that, we need to activate our environment
    by running the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 Python 3.5。之后，我们需要通过运行以下代码来激活我们的环境：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you don''t have `pip` or `virtualenv` installed, you can install them by
    running the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 `pip` 或 `virtualenv`，你可以通过运行以下代码来安装它们：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, we can run `pyo3-pack develop`, which creates the *wheel* files for both
    Python 2 and Python 3 versions and also installs them locally inside our virtual
    environment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `pyo3-pack develop`，它为 Python 2 和 Python 3 版本创建 *wheel* 文件，并在我们的虚拟环境中本地安装它们。
- en: 'Now, we''ll create a simple `main.py` file in our `word_suffix` directory and
    import this module to see if we can use our module:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `word_suffix` 目录下创建一个简单的 `main.py` 文件，并导入此模块以查看我们是否可以使用我们的模块：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running it via `python main.py`, we get the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `python main.py` 运行它，我们得到以下输出：
- en: '![](img/c7e97fad-d750-4b13-8fdf-33e5408ed38a.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7e97fad-d750-4b13-8fdf-33e5408ed38a.png)'
- en: Great! This was a very simple example, though. For complex cases, there are
    lots of details that you need to know about. To explore more about `pyo3`, head
    over to their excellent guide at [https://pyo3.rs](https://pyo3.rs).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这是一个非常简单的例子，尽管如此。对于复杂的情况，你需要了解很多细节。要了解更多关于 `pyo3` 的信息，请访问他们出色的指南 [https://pyo3.rs](https://pyo3.rs)。
- en: Creating native extensions in Rust for Node.js
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中为 Node.js 创建本机扩展
- en: There are times when the performance of JavaScript in the Node.js runtime is
    not enough, so developers reach out to other low-level languages to create native
    Node.js modules. Often, C and C++ are used as the implementation language for
    these native modules. Rust can also be used to create native Node.js modules via
    the the same FFI abstractions that we saw for C and Python. In this section, we'll
    explore a high-level wrapper for these FFI abstractions, called the `neon` project,
    which was created by Dave Herman from Mozilla.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，JavaScript 在 Node.js 运行时的性能不足以满足需求，因此开发者会转向其他底层语言来创建本机 Node.js 模块。通常，C 和
    C++ 被用作这些本机模块的实现语言。Rust 也可以通过与 C 和 Python 相同的 FFI 抽象来创建本机 Node.js 模块。在本节中，我们将探讨这些
    FFI 抽象的高级包装器，即由 Mozilla 的 Dave Herman 创建的 `neon` 项目。
- en: 'The neon project is a set of tools and glue code that makes the life of Node.js
    developers easier, allowing them to write native Node.js modules in Rust and consume
    them seamlessly in their JavaScript code. The project resides at [https://github.com/neon-bindings/neon](https://github.com/neon-bindings/neon).
    It''s partially written in JavaScript: there''s a command-line tool called `neon`
    in the `neon-cli` package, a JavaScript-side support library, and a Rust-side
    support library. Node.js itself has good support for loading native modules, and
    neon uses that same support.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Neon 项目是一套工具和粘合代码，它使 Node.js 开发者的生活变得更轻松，允许他们在 Rust 中编写本机 Node.js 模块，并在他们的 JavaScript
    代码中无缝使用它们。该项目位于 [https://github.com/neon-bindings/neon](https://github.com/neon-bindings/neon)。它部分是用
    JavaScript 编写的：`neon-cli` 包中有一个名为 `neon` 的命令行工具，一个 JavaScript 端支持库，以及一个 Rust 端支持库。Node.js
    本身对加载本机模块有很好的支持，而 neon 就使用了同样的支持。
- en: 'In the following demo, we will be building a native Node.js module in Rust
    as an npm package, exposing a function that can count occurrences of a given word
    in a chunk of text. We will then import this package and test the exposed function
    in a `main.js` file. This demo requires Node.js (version `v11.0.0`) to be installed,
    along with its package manager, `npm` (version `6.4.1`). If you don''t have Node.js
    and `npm` installed, head over to [https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-16-04](https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-16-0)
    to set them up. After you are done installing them, you need to install the `neon-cli`
    tool using `npm` by running the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的演示中，我们将使用Rust作为npm包构建一个本机Node.js模块，并暴露一个可以计算给定单词在文本块中出现的次数的函数。然后我们将导入这个包，并在
    `main.js` 文件中测试暴露的函数。这个演示需要安装Node.js（版本 `v11.0.0`）及其包管理器 `npm`（版本 `6.4.1`）。如果您还没有安装Node.js和
    `npm`，请访问 [https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-16-04](https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-16-0)
    来设置它们。安装完成后，您需要使用 `npm` 通过运行以下命令来安装 `neon-cli` 工具：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we want this tool to be available globally to create new projects from
    anywhere, we pass the `--global` flag. The `neon-cli` tool is used to create a
    Node.js project with skeleton neon support included. Once it is installed, we
    create our project by running `neon new native_counter`, which prompts for basic
    information for the project, as shown in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望这个工具可以在全球范围内使用，以便从任何地方创建新项目，我们传递了 `--global` 标志。`neon-cli` 工具用于创建一个包含骨架neon支持的Node.js项目。一旦安装，我们通过运行
    `neon new native_counter` 来创建我们的项目，这将提示输入项目的基本信息，如下面的截图所示：
- en: '![](img/0be051c4-e78f-465e-98d8-c47c0398e527.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0be051c4-e78f-465e-98d8-c47c0398e527.png)'
- en: 'Here''s the directory structure this command created for us:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此命令为我们创建的目录结构：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The project structure neon created for us is the same npm package structure
    that we get with the usual `lib` directory and `package.json`. In addition to
    the Node.js package structure, it has also created a cargo project for us under
    the `native` directory with some initial code in it. Let''s see what the contents
    of this directory are, starting with `Cargo.toml`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: neon为我们创建的项目结构是与通常的 `lib` 目录和 `package.json` 相同的npm包结构。除了Node.js包结构之外，它还在 `native`
    目录下为我们创建了一个cargo项目，其中包含一些初始代码。让我们看看这个目录的内容，从 `Cargo.toml` 开始：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The prominent thing to note is the `[lib]` section, which specifies the crate
    type as `dylib`, which means we require Rust to create a shared library. There
    is also an autogenerated `build.rs` file at the root level, which does some initial
    build environment configuration by calling `neon_build::setup()` inside it. Next,
    we''ll remove the existing code in our `lib.rs` file and add the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的突出事项是 `[lib]` 部分，它指定了crate类型为 `dylib`，这意味着我们需要Rust来创建共享库。在根目录级别还有一个自动生成的
    `build.rs` 文件，它通过在内部调用 `neon_build::setup()` 来进行一些初始构建环境配置。接下来，我们将从我们的 `lib.rs`
    文件中移除现有代码，并添加以下代码：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we import the `neon` crate, along with the macros and all the items from
    the `prelude` module. Following that, we define a function, `count_words`, which
    takes in a `FunctionContext` instance. This contains information in JavaScript
    regarding the active function that's invoked, such as the argument list, length
    of arguments, the `this` binding, and other details. We expect the caller to pass
    two arguments to our `count_words` function. Firstly, the text, and secondly,
    the word to search for in the text. These values are extracted by calling the
    `argument` method on the `cx` instance and passing in the respective index to
    it. We also use the turbofish operator to ask it to give a value of the `JsString`
    type. On the returned `JsString` instance, we call the `value` method to get a
    Rust `String` value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 `neon` crate，以及宏和 `prelude` 模块中的所有项。随后，我们定义一个函数 `count_words`，它接受一个
    `FunctionContext` 实例。这个实例包含有关被调用的活动函数的信息，例如参数列表、参数长度、`this` 绑定和其他细节。我们期望调用者向我们的
    `count_words` 函数传递两个参数。首先，文本，其次，在文本中搜索的单词。这些值通过在 `cx` 实例上调用 `argument` 方法并传入相应的索引来提取。我们还使用turbofish运算符请求它提供一个
    `JsString` 类型的值。在返回的 `JsString` 实例上，我们调用 `value` 方法来获取Rust `String` 值。
- en: 'After we''re done extracting the arguments, we split our text with white space
    and filter only the chunks that contain the given `word` before calling `count()`
    on the iterator chain to count the number of matched occurrences:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成提取参数之后，我们使用空白字符分割我们的文本，并且只过滤出包含给定`word`的块，在迭代器链上调用`count()`来计算匹配出现的数量：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`count()` returns `usize`. However, we need to cast `usize` to `f64` because
    of the `Into<f64>`  trait bound on our `number` method on `cx`. Once we do that,
    we wrap this expression with a call to `cx.number()`, which creates a JavaScript*-*compatible
    `JsNumber` type. Our `count_words` method returns a `JsResult<JsNumber>` type,
    as accessing the arguments might fail and returning a proper *JavaScript* type
    might also fail. This error variant in the `JsResult` type represents any exception
    that''s thrown from the JavaScript-side.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`返回`usize`。然而，由于`cx`上的`number`方法对`Into<f64>`特质的限制，我们需要将`usize`转换为`f64`。一旦我们这样做，我们就用对`cx.number()`的调用将这个表达式包装起来，这会创建一个JavaScript兼容的`JsNumber`类型。我们的`count_words`方法返回一个`JsResult<JsNumber>`类型，因为访问参数可能会失败，返回适当的*JavaScript*类型也可能失败。`JsResult`类型中的这个错误变体代表从JavaScript端抛出的任何异常。'
- en: Next, we register our `count_words` function with the `register_module!` macro.
    This macro gets a mutable reference to a `ModuleContext` instance, `m`. Using
    this instance, we export our function by calling the `export_function` method,
    passing in the name of the function as string and the actual function type as
    the second parameter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`register_module!`宏将我们的`count_words`函数注册。这个宏获取对`ModuleContext`实例的可变引用，`m`。使用这个实例，我们通过调用`export_function`方法来导出我们的函数，将函数名称作为字符串传递，并将实际函数类型作为第二个参数。
- en: 'Now, here''s our updated `index.js` file''s contents:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是我们的更新后的`index.js`文件的内容：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As `index.js` is the root of an npm package, we require our native module and
    must export the function directly at the root of the module using `module.exports`.
    We can now build our module using the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`index.js`是npm包的根，我们必须在我们的本地模块中导入它，并且必须使用`module.exports`直接在模块的根处导出函数。现在，我们可以使用以下代码构建我们的模块：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once the package has been built, we can test it by creating a simple `main.js`
    file in the `native_counter` directory with the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包构建完成，我们可以在`native_counter`目录中创建一个简单的`main.js`文件来测试它，代码如下：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ll run this file by running the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过运行以下代码来运行这个文件：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This gives us an output of `2`. That concludes our awesome journey on making
    Rust and other languages talk to each other. It turns out that Rust is quite smooth
    at this interaction. There are rough edges in cases where other languages don't
    understand Rust's complex data types, but this is to be expected, as every language
    is different in its implementation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个输出`2`。这就结束了我们让Rust和其他语言相互交流的精彩旅程。结果证明，Rust在这方面的交互非常流畅。在其他语言不理解Rust的复杂数据类型的情况下，存在一些粗糙的边缘，这是可以预料的，因为每种语言在实现上都有所不同。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Rust provides us with convenient FFI abstractions to interface with different
    languages and has first-class support for C, as it exposes the C ABI (`cdecl`)
    for functions marked as `extern`. As such, it's a good candidate for bindings
    for a lot of C/C++ libraries. One of the prominent examples of this is the SpiderMonkey
    JavaScript engine that's implemented in C++, which is used in the Servo project.
    The Servo engine calls into C++ using the bindings that are generated via the
    `bindgen` crate.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Rust为我们提供了方便的FFI抽象，以便与不同的语言进行接口交互，并且对C语言有第一级支持，因为它为标记为`extern`的函数暴露了C ABI（`cdecl`）。因此，它是一个为许多C/C++库创建绑定的好候选者。这一点的突出例子是使用C++实现的SpiderMonkey
    JavaScript引擎，它在Servo项目中使用。Servo引擎通过`bindgen` crate生成的绑定调用C++。
- en: But, when we are interacting with cross-language boundaries, the language constructs
    and data representation that one language has don't need to match with the other
    language. As such, we need to put extra annotations, along with unsafe blocks,
    in Rust code to let the compiler know of our intent. We saw this when we used
    the `#[repr(C)]` attribute. The **Foreign Function Interface** (**FFI**), like
    many other Rust features, is zero-cost, which means that a minimal runtime cost
    is incurred when linking to code from other languages. We took a look at Python
    and Node.js, which have nice wrapper crates for these low-level FFI abstractions.
    For languages that don't have such wrappers, interfacing with other languages
    is always possible by using the bare FFI APIs that Rust's standard library provides.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们跨越语言边界进行交互时，一种语言所具有的语言构造和数据表示并不需要与另一种语言相匹配。因此，我们需要在Rust代码中添加额外的注释，以及不安全块，以便让编译器了解我们的意图。我们在使用`#[repr(C)]`属性时看到了这一点。**外部函数接口**（**FFI**），就像许多其他Rust特性一样，是无成本的，这意味着当链接来自其他语言的代码时，所产生的是最小的运行时成本。我们查看了一下Python和Node.js，它们为这些低级FFI抽象提供了很好的包装库。对于没有此类包装库的语言，可以通过使用Rust标准库提供的裸FFI
    API来实现与其他语言的接口。
- en: The aim up until this chapter was to cover the topics that are core to the language,
    and I hope you are up to speed with most of the core language features. The remaining
    chapters will cover case studies of various Rust frameworks and crates, and will
    be heavily oriented toward applying Rust to practical projects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的目标是涵盖语言的核心主题，我希望你对大多数核心语言特性已经熟悉。接下来的章节将涵盖各种Rust框架和库的案例研究，并将主要面向将Rust应用于实际项目。
