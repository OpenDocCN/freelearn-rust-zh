<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Generics and Polymorphism</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Parameterization, also known as</span> <strong>generics</strong> <span>or</span> <strong>polymorphism</strong><span>, is the third most significant language feature following control flow and data structures. Parameterization addresses the copy-and-paste problem of early languages. This feature permits the</span> <em>don't repeat yourself</em> <span>principle of good program design.</span><br/></p>
<p>In this chapter, we will look at how parameterization can help us design robust programs that evolve with change rather than fight against change. No new project requirements will be introduced. This chapter will be entirely reflective, looking at how the project is currently structured, how can it be improved, and how parameterization can specifically help.</p>
<p>The following are the learning outcomes of this chapter:</p>
<ul>
<li>Understanding generalized algebraic datatypes</li>
<li>Understanding parametric polymorphism</li>
<li>Understanding parametric lifetimes</li>
<li>Understanding parametric traits</li>
<li>Understanding ambiguous method resolution</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>A recent version of Rust is necessary to run the examples provided:</p>
<p><a href="https://www.rust-lang.org/en-US/install.html">https://www.rust-lang.org/en-US/install.html</a></p>
<p>This chapter's code is also available on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST">https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST</a></p>
<p>Specific installation and build instructions are also included in each chapter's <kbd>README.md</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Staying productive during downtime</h1>
                </header>
            
            <article>
                
<p>There will be some time before the client makes a final decision regarding negotiation and potential acceptance of your project proposal. During that time, your management has encouraged you to take this time to review your work and make preparations for integrating the elevator controller into a real elevator.</p>
<p>You do not know much about direct elevator control interfaces, and the client specifically mentioned that there may be multiple subcontractors designing each of the different elevators. Making assumptions at this point may lead to wasted effort so, instead, you decide to reconsider your code and look for opportunities to remove any assumptions.</p>
<p>Parameterization and use of trait interfaces should help achieve this goal of abstraction. During this downtime, you decide to have the team learn about parameterization and consider how it can be applied to improve this project or later projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about generics</h1>
                </header>
            
            <article>
                
<p>Generics are a facility to write code for multiple contexts with different types, and parameterization allows the programmer to write code that makes fewer assumptions about the data structures and code segments involved in the code's definition. For example, a very ambiguous concept would be the concept of addition. When a programmer writes <kbd>a + b</kbd>, what does that mean? In Rust, the <kbd>Add</kbd> trait can be implemented for just about any type. As long as there is an implementation for the <kbd>Add</kbd> trait in scope that is compatible with the types of <kbd>a</kbd> and <kbd>b</kbd>, then this trait will define the operation. In this pattern, we can write generic code that defines a concept in its most abstract terms, allowing for later definitions of data and methods to interface with that code without change.</p>
<p>A major example of completely generic code are built-in container data structures. Vectors and HashMaps must necessarily know the types of the objects they store. However, it would be very limiting if any assumptions were made about the underlying data structure or methods for the stored items. Therefore, parameterization of containers allows the container and its methods to explicitly declare trait bounds that are expected from stored types. All other characteristics of the stored item will be parameterized.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Investigating generics</h1>
                </header>
            
            <article>
                
<p>Generics refers to the practice of parameterizing classes in object-oriented programming languages. Rust does not have an exact equivalent of classes. However, the concept of datatypes paired with a trait is very similar to a class if used in that sense. So, in Rust, generics would refer to the parameterization of datatypes and traits.</p>
<p>Choosing a common example from OOP, let's look at the animal kingdom. In the following code, we will define some animals and actions that they can take. First, let's define two animals:</p>
<pre style="padding-left: 30px">struct Cat<br/>{<br/>   weight: f64,<br/>   speed: f64<br/>}<br/><br/>struct Dog<br/>{<br/>   weight: f64,<br/>   speed: f64<br/>}</pre>
<p>Now, let's define an <kbd>animal trait</kbd> and its implementations. All animals will have the <kbd>max_speed</kbd> method. Here is the code:</p>
<pre style="padding-left: 30px">trait Animal<br/>{<br/>   fn max_speed(&amp;self) -&gt; f64;<br/>}<br/><br/>impl Animal for Cat<br/>{<br/>   fn max_speed(&amp;self) -&gt; f64<br/>   {<br/>      self.speed<br/>   }<br/>}<br/><br/>impl Animal for Dog<br/>{<br/>   fn max_speed(&amp;self) -&gt; f64<br/>   {<br/>      self.speed<br/>   }<br/>}</pre>
<p>Here, we have defined the Rust equivalent of interfaces from OOP. However, we have not parameterized anything, so nothing here should be considered generic. We will add the following code, a trait defining the concept of an animal chasing a toy. First, we will define the concept of a toy. This will follow the same OOP-like pattern as in the preceding code:</p>
<pre style="padding-left: 30px">struct SqueakyToy<br/>{<br/>   weight: f64<br/>}<br/><br/>struct Stick<br/>{<br/>   weight: f64<br/>}<br/><br/>trait Toy<br/>{<br/>   fn weight(&amp;self) -&gt; f64;<br/>}<br/><br/>impl Toy for SqueakyToy<br/>{<br/>   fn weight(&amp;self) -&gt; f64<br/>   {<br/>      self.weight<br/>   }<br/>}<br/><br/>impl Toy for Stick<br/>{<br/>   fn weight(&amp;self) -&gt; f64<br/>   {<br/>      self.weight<br/>   }<br/>}</pre>
<p>Now, we have two traits, each having two possible implementations. Let's define an action for an animal chasing a toy. More than one possible animal has been defined, and more than one possible toy, so we will need to use a generic definition. The struct definition also constrains each parameter with a trait bound, which adds additional information to the <kbd>struct</kbd>; now, we can guarantee that each animal will implement the <kbd>Animal</kbd> trait and similarly, each toy will implement <kbd>Toy</kbd>. We will also define some associated logic that uses the parameterized traits' methods. The code is as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct AnimalChasingToy&lt;A: Animal, T: Toy&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   animal: A,<br/></span><span class="s1">   toy: T<br/></span><span class="s1">}<br/><br/></span><span class="s1">trait AnimalChasesToy&lt;A: Animal, T: Toy&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   fn chase(&amp;self);<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;A: Animal, T: Toy&gt; AnimalChasesToy&lt;A, T&gt; for AnimalChasingToy&lt;A, T&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   fn chase(&amp;self)<br/></span><span class="s1">   {<br/></span><span class="s1">      println!("chase")<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>At this point, we have defined a generic <kbd>struct</kbd> and <kbd>trait</kbd> that accepts types, knowing only some limited information regarding the traits of each object. Multiple traits, or none, can be specified to declare all expected interfaces. Multiple traits or lifetime bounds can be declared with the <kbd>'l + Trait1 + Trait2</kbd> syntax.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Investigating parametric polymorphism</h1>
                </header>
            
            <article>
                
<p>Another common application of parameterization are for functions. For the same reasons that we would want to parameterize data structures or traits, we also should consider parameterization of functions. Parameterizing functions is called <strong>parametric polymorphism</strong>. Polymorphism is Greek for multiple forms or, sometimes in modern usage, it can mean multiple arrows. The word indicates that one function has multiple implementations or multiple ground type signatures.</p>
<p>For a simple example of a parametric function, we can imagine a generic multiply by three function. Here is the implementation:</p>
<pre class="p1"><span class="s1">fn raise_by_three&lt;T: Mul + Copy&gt;(x: T) -&gt; T<br/></span><span class="s1">where T: std::ops::Mul&lt;Output=T&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   x * x * x<br/></span><span class="s1">}</span></pre>
<p>Here, the <kbd>raise_by_three</kbd> function does not know what <kbd>Mul</kbd> does. <kbd>Mul</kbd> is a trait and abstract behavior, which also specifies an associated type, <kbd>Output</kbd>. It is not possible to generically raise <kbd>x.pow(3)</kbd> here because <kbd>x</kbd> may not be a numerical type. At the very least, we do not know whether <kbd>x</kbd> is a floating type or an integral type. So instead, we use the available <kbd>Mul</kbd> trait to multiply <kbd>x</kbd> three times. This may seem like a strange thing to do, but the concept becomes clearer in context.</p>
<p>First, consider the application in regard to floating and integral types. This usage is straightforward but does not seem very useful yet. We already have a working <kbd>raise by three</kbd> expression, as long as we know and have the original floating or integral type. So, why wouldn't we just use the built-in expression? First, let's just compare the two options in code:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">raise_by_three(10);<br/></span><span class="s1">(10 as u64).pow(3);<br/><br/></span><span class="s1">raise_by_three(3.0);<br/></span><span class="s1">(3.0 as f64).powi(3);</span></pre>
<p>The second option seems much more preferable, and it is. However, the second option also assumes we know the full type of <kbd>u64</kbd> or <kbd>f64</kbd> for each argument. Let's look at what happens if we erase some type information:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#[derive(Copy,Clone)]<br/>struct Raiseable&lt;T: Mul + Copy&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   x: T<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;T: Mul + Copy&gt; std::ops::Mul for Raiseable&lt;T&gt;<br/></span><span class="s1">where T: std::ops::Mul&lt;Output=T&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   type Output = Raiseable&lt;T&gt;;<br/></span><span class="s1">   fn mul(self, rhs: Self) -&gt; Self::Output<br/></span><span class="s1">   {<br/></span><span class="s1">      Raiseable { x: self.x * rhs.x }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">let x = Raiseable { x: 10 as u64 };<br/></span><span class="s1">raise_by_three(x);<br/></span><span class="s1">//no method named pow<br/></span><span class="s1">//x.pow(3);<br/></span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">let x = Raiseable { x: 3.0 as f64 };<br/></span><span class="s1">raise_by_three(x);<br/></span><span class="s1">//no method named powi<br/></span><span class="s1">//x.powi(3);</span><span class="s1"> </span></pre>
<p>After we lose access to the underlying types, we are quickly restricted in regard to what operations we can perform. Generic programming is great in the respect that it can reduce work in the long term; however, it also requires very explicit declaration and implementation of all interfaces that are used. Here, you can see that we must declare <kbd>Copy</kbd> as a trait bound, meaning the ability to copy a variable from one memory location to another. Another low-level trait is <kbd>Sized</kbd>, which indicates that a datum has a known constant size at compile time.</p>
<p>If we look at the <kbd>HashMap</kbd> declaration, we can see why this abstraction is often necessary:</p>
<pre style="padding-left: 30px">impl&lt;K: Hash + Eq, V&gt; HashMap&lt;K, V, RandomState&gt;</pre>
<p>Each hash key must implement <kbd>Hash</kbd> and <kbd>Eq</kbd>, meaning it must be hashable and comparable. Other than that, no traits are expected and thus the whole data structure remains very generic.</p>
<p>Just as functions can be parameterized, functions as arguments can also be parameterized. There are two general forms of functions as parameters—closures and function pointers. Function pointers are not permitted to carry state. Closures can carry state but have a variable size which is independent of their declared type. Function pointers can be promoted to closures automatically:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn foo&lt;X&gt;(x: X) -&gt; X<br/></span><span class="s1">{<br/></span><span class="s1">   x<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn bar&lt;X&gt;(f: fn(X) -&gt; X, x: X) -&gt; X<br/></span><span class="s1">{<br/></span><span class="s1">   f(x)<br/></span><span class="s1">}<br/><br/>foo(1);<br/>bar(foo,1);</span></pre>
<p class="mce-root"><span>Closures can also be parameterized in a similar fashion. This case is a bit more common. If you are wondering whether to use a function pointer or a closure, use the closure. Function pointers can always be promoted to closures. Also, this code introduces the <kbd>where</kbd> syntax; <kbd>where</kbd> clauses permit trait bounds to be declared in a more readable form. Here is the code:</span></p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn baz&lt;X,F&gt;(f: F, x: X) -&gt; X<br/></span><span class="s1">where F: Fn(X) -&gt; X<br/></span><span class="s1">{<br/></span><span class="s1">   f(x)<br/></span><span class="s1">}<br/><br/></span><span class="s1">baz(|x| x, 1);<br/></span><span class="s1">baz(foo, 1);</span></pre>
<p>Here, we can see how easy it is to wrap a function pointer into a closure. Closures are a good abstraction and very powerful when used correctly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Investigating generalized algebraic datatypes</h1>
                </header>
            
            <article>
                
<p>Sometimes, it is desirable to have the type system carry more information than normal. If we look at the process of compilation, types occupy a space between the program code and the program executable. The code can take the form of text files before compilation or an abstract syntax tree such as those manipulated by Rust macros. Program executables consist of the resulting combination of all Rust primitives like expressions, functions, datatypes, traits, and so on.</p>
<p>Right in the middle, it is possible to introduce a new concept called <strong>algebraic data types </strong>(<strong>ADTs</strong>). ADTs are technically an extension of Rust primitives, though it is important to note how much extra type information is used for ADTs. This technique involves preserving extra type information into the executable. Extra run time decision-making is a step towards dynamic typing and foregoes optimizations available to static compilation. The result is a somewhat less efficient programming primitive, but also a primitive that can describe concepts that are otherwise difficult to approach.</p>
<p>Let's look at one example—deferred computation. When we describe a relation of different values and expressions, we normally just write this code into the program directly. However, what would we do if we wanted to separate the code step from the execution step? To accomplish this, we start building something called a <strong>domain-specific language</strong>.</p>
<p>For a concrete example, consider that you are building a JIT (dynamically compiled) interpreter for JavaScript. The Mozilla project has several projects dedicated to JS engines built in Rust (<a href="https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/">https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/</a>). This is a real application for which Rust is well-suited. To use an ADT in a JIT compiled interpreter, we want two things:</p>
<ul>
<li>To evaluate ADT expressions directly within the interpreter</li>
<li>To compile ADT expressions if selected for compilation</li>
</ul>
<p>So, any part of our JavaScript expressions can either be interpreted or compiled at any time. If an expression is compiled, then we want all further evaluations to use the compiled version. The key to implementing this cleanly is to put some extra weight on the type system. These heavy type definitions are the essence of the ADT concept. Here is a definition of a very small subset of JavaScript using an ADT:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct JSJIT(u64);<br/><br/></span><span class="s1">enum JSJITorExpr {<br/></span><span class="s1">   Jit { label: Box&lt;JSJIT&gt; },<br/></span><span class="s1">   Expr { expr: Box&lt;JSExpr&gt; }<br/></span><span class="s1">}<br/><br/></span><span class="s1">enum JSExpr {<br/></span><span class="s1">   Integer { value: u64 },<br/></span><span class="s1">   String { value: String },<br/></span><span class="s1">   OperatorAdd { lexpr: Box&lt;JSJITorExpr&gt;, rexpr: Box&lt;JSJITorExpr&gt; },<br/></span><span class="s1">   OperatorMul { lexpr: Box&lt;JSJITorExpr&gt;, rexpr: Box&lt;JSJITorExpr&gt; }<br/></span><span class="s1">}</span></pre>
<p class="mce-root"><span>Here, we can see that each intermediate expression has enough information to be evaluated, but also has enough information to be compiled. We could have easily wrapped the <kbd>Add</kbd> or <kbd>Mul</kbd> operator into closures, but that would disallow JIT optimization. We need to maintain the full representation here in order to permit JIT compilation. Also, note the indirection between each point where the program decides whether to evaluate an expression or to call into compiled code.</span></p>
<p>The next step is to implement an evaluation program for each expression form. We could break this into traits, or define the evaluation as one larger function. To keep the functional style, we will define a single function. To evaluate an expression, we will use a pattern match on the <kbd>JSJITorExpr</kbd> expression. This JIT expression breaks down into either a code address which is run by calling the <kbd>jump</kbd> function or an expression which must be evaluated dynamically. This pattern gives us the best of both worlds, mixing compiled code and interpreted code together. The code is as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn jump(l: JSJIT) -&gt; JSJITorExpr<br/></span><span class="s1">{<br/></span><span class="s1">   //jump to compiled code<br/></span><span class="s1">   //this depends on implementation<br/></span><span class="s1">   //so we will just leave this as a stub<br/></span><span class="s1">   JSJITorExpr::Jit { label: JSJIT(0) }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn eval(e: JSJITorExpr) -&gt; JSJITorExpr<br/></span><span class="s1">{<br/></span><span class="s1">   match e<br/></span><span class="s1">   {<br/></span><span class="s1">      JSJITorExpr::Jit { label: label } =&gt; jump(label),<br/></span><span class="s1">      JSJITorExpr::Expr { expr: expr } =&gt; {<br/></span><span class="s1">         let rawexpr = *expr;<br/></span><span class="s1">         match rawexpr<br/></span><span class="s1">         {<br/></span><span class="s1">            JSExpr::Integer {..} =&gt; JSJITorExpr::Expr { expr: Box::new(rawexpr) },<br/></span><span class="s1">            JSExpr::String {..} =&gt; JSJITorExpr::Expr { expr: Box::new(rawexpr) },<br/></span><span class="s1">            JSExpr::OperatorAdd { lexpr: l, rexpr: r } =&gt; {<br/></span><span class="s1">               let l = eval(*l);<br/></span><span class="s1">               let r = eval(*r);<br/></span><span class="s1">               //call add op codes for possible l,r representations<br/></span><span class="s1">               //should return wrapped value from above<br/></span><span class="s1">               JSJITorExpr::Jit { label: JSJIT(0) }<br/></span><span class="s1">            }<br/></span><span class="s1">            JSExpr::OperatorMul { lexpr: l, rexpr: r } =&gt; {<br/></span><span class="s1">               let l = eval(*l);<br/></span><span class="s1">               let r = eval(*r);<br/></span><span class="s1">               //call mul op codes for possible l,r representations<br/></span><span class="s1">               //should return wrapped value from above<br/></span><span class="s1">               JSJITorExpr::Jit { label: JSJIT(0) }<br/></span><span class="s1">            }<br/></span><span class="s1">         }<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>Another example of the ADT concept is in heterogeneous lists. Heterogeneous lists are not like other generic containers, such as vectors. Rust vectors are homogeneous, meaning all items are required to have the same type. By comparison, a heterogeneous list can have any mix of types of elements. This may sound like a tuple, but tuples have a fixed length and flat type signature. Similarly, heterogeneous lists must have a length and type signature known at compile time, but that knowledge can be achieved incrementally. Heterogeneous lists are permitted to work with partial knowledge of the list type, parameterizing the knowledge that they do not need.</p>
<p>Here is an example implementation of a heterogeneous list:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">pub trait HList: Sized {}<br/><br/></span><span class="s1">pub struct HNil;<br/></span><span class="s1">impl HList for HNil {}<br/></span><span class="s1"><br/>pub struct HCons&lt;H, T&gt; {<br/></span><span class="s1">   pub head: H,<br/></span><span class="s1">   pub tail: T,<br/></span><span class="s1">}<br/></span><span class="s1">impl&lt;H, T: HList&gt; HList for HCons&lt;H, T&gt; {}<br/></span><span class="s1">impl&lt;H, T&gt; HCons&lt;H, T&gt; {<br/></span><span class="s1">   pub fn pop(self) -&gt; (H, T) {<br/></span><span class="s1">      (self.head, self.tail)<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>Notice how this definition intentionally uses a trait to obscure type information, without which, such a definition would be impossible. A declaration of an <kbd>HList</kbd> would look like the following:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let hl = HCons {<br/></span><span class="s1">   head: 2,<br/></span><span class="s1">   tail: HCons {<br/></span><span class="s1">      head: "abcd".to_string(),<br/></span><span class="s1">      tail: HNil<br/></span><span class="s1">   }<br/></span><span class="s1">};<br/><br/></span><span class="s1">let (h1,t1) = hl.pop();<br/></span><span class="s1">let (h2,t2) = t1.pop();<br/></span><span class="s1">//this would fail<br/></span><span class="s1">//HNil has no .pop method<br/></span><span class="s1">//t2.pop();</span></pre>
<p>Rust can be a bit rigid with regards to type checking, at times. However, there are also many workarounds that permit complex behavior that might seem impossible at first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Investigating parametric lifetimes</h1>
                </header>
            
            <article>
                
<p>Lifetimes can get complicated quickly. For example, when a lifetime is used as a parameter, it is called a <strong>parametric lifetime</strong>. To cover the most common problems, we will break down the lifetime concept into four distinct concepts:</p>
<ul>
<li>Lifetimes on ground types</li>
<li>Lifetimes on generic types</li>
<li>Lifetimes on traits</li>
<li>Lifetime subtyping</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining lifetimes on ground types</h1>
                </header>
            
            <article>
                
<p>A ground type is a type with no parameters. Defining lifetimes on ground types is the simplest possible case. All traits, fields, size, and any other information is directly available for group types.</p>
<p>Here is a function declaring a lifetime on a ground type:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn ground_lifetime&lt;'a&gt;(x: &amp;'a u64) -&gt; &amp;'a u64<br/></span><span class="s1">{<br/></span><span class="s1">   x<br/></span><span class="s1">}<br/><br/></span><span class="s1">let x = 3;<br/></span><span class="s1">ground_lifetime(&amp;x);</span></pre>
<p>Declaring lifetimes is often unnecessary. Other times, declaring lifetimes is necessary. The inference rules are complicated and are sometimes extended, so we will ignore that part for now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining lifetimes on generic types</h1>
                </header>
            
            <article>
                
<p>Declaring lifetimes on generic types requires one additional consideration. All generic types that have a specified lifetime must be parameterized as having that lifetime. The parameter declaration must be compatible with how the parameter is used.</p>
<p>Here is an example that will fail:</p>
<pre style="padding-left: 30px"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ref</span></span><span>&lt;</span><span class="hljs-symbol">'a</span><span>, T&gt;(&amp;</span><span class="hljs-symbol">'a</span> <span>T);</span></pre>
<p>The struct definition uses the parameter <kbd>T</kbd> having a lifetime of <kbd>'a</kbd>; however, the parameter <kbd>T</kbd> is not required to have a lifetime compatible with <kbd>'a</kbd>.  The parameter <kbd>T</kbd> must be constrained by its own lifetime. By doing this, the code becomes as follows:</p>
<pre style="padding-left: 30px"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ref</span></span><span>&lt;</span><span class="hljs-symbol">'a</span><span>, T: </span><span class="hljs-symbol">'a</span><span>&gt;(&amp;</span><span class="hljs-symbol">'a</span><span> T);</span></pre>
<p>Now that the parameter <kbd>T</kbd> has an explicit bound compatible with <kbd>'a</kbd>, the code will compile.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining lifetimes on traits</h1>
                </header>
            
            <article>
                
<p>When defining, implementing, and instantiating an object implementing a trait, it is possible that both the object and trait will require a lifetime. Usually, it is possible to infer the lifetime of the trait from the lifetime of the object. When this is not possible, the programmer must declare a lifetime for the trait, which is compatible with all other constraints. The code is as follows:</p>
<pre style="padding-left: 30px"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Red</span></span><span> { }<br/><br/></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ball</span></span><span>&lt;</span><span class="hljs-symbol">'a</span><span>&gt; {<br/>   diameter: &amp;</span><span class="hljs-symbol">'a</span><span> </span><span class="hljs-built_in">i32</span><span>,<br/>}<br/><br/></span><span class="hljs-keyword">impl</span><span>&lt;</span><span class="hljs-symbol">'a</span><span>&gt; Red </span><span class="hljs-keyword">for</span><span> Ball&lt;</span><span class="hljs-symbol">'a</span><span>&gt; { }<br/><br/></span><span>static num: i32 = </span><span class="hljs-number">5</span><span>;<br/></span><span class="hljs-keyword">let</span><span> obj = </span><span class="hljs-built_in">Box</span><span>::new(Ball { diameter: &amp;num }) </span><span class="hljs-keyword">as</span><span> </span><span class="hljs-built_in">Box</span><span>&lt;Red + 'static&gt;;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining lifetime subtyping</h1>
                </header>
            
            <article>
                
<p>It is possible to have a single object that requires a long lifetime for itself but also needs a shorter lifetime for some of its components or methods. This can be accomplished by parameterizing multiple lifetimes. This usually works well unless the lifetimes come into conflict. The following is an example of multiple lifetimes:</p>
<pre class="p1"><span class="s1">struct Context&lt;'s&gt;(&amp;'s mut String);<br/><br/></span><span class="s1">impl&lt;'s&gt; Context&lt;'s&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   fn mutate&lt;'c&gt;(&amp;mut self, cs: &amp;'c mut String) -&gt; &amp;'c mut String</span></pre>
<pre class="p1"><span class="s1"><br/></span><span class="s1">   {<br/></span><span class="s1">      let swap_a = self.0.pop().unwrap();<br/></span><span class="s1">      let swap_b = cs.pop().unwrap();<br/></span><span class="s1">      self.0.push(swap_b);<br/></span><span class="s1">      cs.push(swap_a);<br/></span><span class="s1">      cs<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span>fn main() {<br/><span class="s1">   let mut s = "outside string context abc".to_string();<br/></span><span class="s1">   {<br/></span><span class="s1">      //temporary context<br/></span><span class="s1">      let mut c = Context(&amp;mut s);<br/></span><span class="s1">      {<br/></span><span class="s1">         //further temporary context<br/></span><span class="s1">         let mut s2 = "inside string context def".to_string();<br/></span><span class="s1">         c.mutate(&amp;mut s2);<br/></span><span class="s1">         println!("s2 {}", s2);<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   println!("s {}", s);<br/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Investigating parametric types</h1>
                </header>
            
            <article>
                
<p>At this point, it shouldn't be surprising to learn that all datatype declarations can be parameterized. It should be noted that when declaring parameterized datatypes, the lifetime parameters must be located ahead of the generic parameters. Refer to the following code for this:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">type TFoo&lt;'a, A: 'a&gt; = (&amp;'a A, u64);<br/><br/></span><span class="s1">struct SFoo&lt;'a, A: 'a&gt;(&amp;'a A);<br/><br/></span><span class="s1">struct SBar&lt;'a, A: 'a&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   x: &amp;'a A<br/></span><span class="s1">}<br/><br/></span><span class="s1">enum EFoo&lt;'a, A: 'a&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   X { x: &amp;'a A },<br/></span><span class="s1">   Y { y: &amp;'a A },</span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">}</span></pre>
<p>We have also seen how traits can be parameterized. However, what happens when a datatype and a trait both need parameters for implementation? There is a special syntax for that, involving three parameter lists, and it looks like the following:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct SBaz&lt;'a, 'b, A: 'a, B: 'b&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   a: &amp;'a A,<br/></span><span class="s1">   b: &amp;'b B,<br/></span><span class="s1">}<br/><br/></span><span class="s1">trait TBaz&lt;'a, 'b, A: 'a, B: 'b&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   fn baz(&amp;self);<br/></span><span class="s1">}<br/></span><span class="s1"><br/>impl&lt;'a, 'b, A: 'a, B: 'b&gt;<br/>TBaz&lt;'a, 'b, A, B&gt;<br/>for SBaz&lt;'a, 'b, A, B&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   fn baz(&amp;self){}<br/></span><span class="s1">}</span></pre>
<p>There is one more special case that we should mention, and that is the case of method ambiguity. When multiple traits are implemented for a single type, it is possible for there to be multiple methods with the same name. To access the different methods, it becomes necessary to specify what <kbd>trait</kbd> is intended to be used when called. Here is an example:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">trait Foo {<br/></span><span class="s1">   fn f(&amp;self);<br/></span><span class="s1">}<br/><br/></span><span class="s1">trait Bar {<br/></span><span class="s1">   fn f(&amp;self);<br/></span><span class="s1">}<br/><br/></span><span class="s1">struct Baz;<br/><br/></span><span class="s1">impl Foo for Baz {<br/></span><span class="s1">   fn f(&amp;self) { println!("Baz’s impl of Foo"); }<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl Bar for Baz {<br/></span><span class="s1">   fn f(&amp;self) { println!("Baz’s impl of Bar"); }<br/></span><span class="s1">}</span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">let b = Baz;</span></pre>
<p>To call the method, we must use something called the <strong>universal function call syntax</strong>. There are two forms of the syntax, one short—the other longer. The short form is usually sufficient for resolving all but the most complicated of situations. Here is an example to match the preceding type definitions:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">Foo::f(&amp;b);<br/></span><span class="s1">Bar::f(&amp;b);<br/><br/></span><span class="s1">&lt;Baz as Foo&gt;::f(&amp;b);<br/></span><span class="s1">&lt;Baz as Bar&gt;::f(&amp;b);</span></pre>
<p>There are also several less documented syntax forms (<a href="https://matematikaadit.github.io/posts/rust-turbofish.html">https://matematikaadit.github.io/posts/rust-turbofish.html</a>) syntax forms available for various scenarios where parameters need to be explicitly provided. Rust does not currently have direct type ascription currently, so hints for the compiler are provided as necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying parameterization concepts</h1>
                </header>
            
            <article>
                
<p>We have explored the concepts of generics and parameterization. Let's scan through the project to see if any concepts would be appropriate to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parameterizing data</h1>
                </header>
            
            <article>
                
<p>Parametric data allows us to declare only the minimal amount of semantic information required. Instead of specifying a type, we can specify a generic parameter having a trait. Let's start by looking at <kbd>physics.rs</kbd> type declarations:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#[derive(Clone,Serialize,Deserialize,Debug)]<br/></span><span class="s1">pub enum MotorInput<br/></span><span class="s1">{<br/></span><span class="s1">   Up { voltage: f64 },<br/></span><span class="s1">   Down { voltage: f64 }<br/></span><span class="s1">}<br/><br/>#[derive(Clone,Serialize,Deserialize,Debug)]<br/></span><span class="s1">pub struct ElevatorSpecification<br/></span><span class="s1">{<br/></span><span class="s1">   pub floor_count: u64,<br/></span><span class="s1">   pub floor_height: f64,</span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">   pub carriage_weight: f64<br/></span><span class="s1">}</span><span class="s1"><br/></span><span class="s1">#[derive(Clone,Serialize,Deserialize,Debug)]<br/></span><span class="s1">pub struct ElevatorState</span><span class="s1"><br/></span><span class="s1">{<br/></span><span class="s1">   pub timestamp: f64,<br/></span><span class="s1">   pub location: f64,<br/></span><span class="s1">   pub velocity: f64,<br/></span><span class="s1">   pub acceleration: f64,<br/></span><span class="s1">   pub motor_input: MotorInput<br/></span><span class="s1">}<br/><br/></span><span class="s1">pub type FloorRequests = Vec&lt;u64&gt;;</span></pre>
<p>If we remember, where we used <kbd>physics.rs</kbd> when we designed the new <kbd>MotorInput</kbd> implementation, we should notice a problem. We wanted to abstract <kbd>MotorInput</kbd> behavior behind a trait; however, <kbd>ElevatorState</kbd> specifies a specific implementation. Let's redefine <kbd>ElevatorState</kbd> to use a generic type for <kbd>motor_input</kbd>. The parameter should implement all traits of <kbd>MotorInput</kbd>, and will, therefore, become as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#[derive(Clone,Serialize,Deserialize,Debug)]<br/></span><span class="s1">pub struct ElevatorState&lt;MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug&gt;</span><span class="s1"><br/></span><span class="s1">{<br/></span><span class="s1">   pub timestamp: f64,<br/></span><span class="s1">   pub location: f64,<br/></span><span class="s1">   pub velocity: f64,<br/></span><span class="s1">   pub acceleration: f64,<br/></span><span class="s1">   pub motor_input: MI<br/></span><span class="s1">}</span></pre>
<p>This may look acceptable at first glance, but now the <kbd>MotorInput</kbd> parameter and all traits must be declared along with every mention of any type that wraps <kbd>MotorInput</kbd> or <kbd>ElevatorState</kbd>. We get an explosion of parameters. There must be a better way.</p>
<p>Parameter explosion, in this case, would look like the following, at every type declaration, trait declaration, implementation, function, or expression:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">pub trait MotorController<br/></span><span class="s1">&lt;MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState&lt;MI&gt;);<br/></span><span class="s1">   fn poll(&amp;mut self, est: ElevatorState&lt;MI&gt;, dst: u64) -&gt; MI;</span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">}<br/><br/></span><span class="s1">pub trait DataRecorder</span><span class="s1"><br/></span><span class="s1">&lt;MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug&gt;<br/></span><span class="s1">{<br/></span><span class="s1">   fn init(&amp;mut self, esp: ElevatorSpecification, est: ElevatorState&lt;MI&gt;);<br/></span><span class="s1">   fn poll(&amp;mut self, est: ElevatorState&lt;MI&gt;, dst: u64);<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl MotorController<br/></span><span class="s1">&lt;MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug&gt;<br/></span><span class="s1">for SimpleMotorController<br/></span><span class="s1">&lt;MI: MotorForce + MotorVoltage + Clone, 'a serde::Serialize, 'a serde::Deserialize + Debug&gt;<br/></span><span class="s1">{<br/>   ...<br/></span><span class="s1">} </span></pre>
<p>This is all just for one parameter! Fortunately, there is another solution to this problem. The technique uses something called <strong>trait objects</strong>. A trait object is an object implementing a trait but having no known type at compile time. Trait objects, because they have no concrete type, do not need to be parameterized. The downside of trait objects are that they cannot be sized, and therefore must usually be handled indirectly through a Box or some other sized container. Any attempt to size a trait object will result in a compiler error. Similarly, any trait that has a static method, or is otherwise not object-safe, cannot be used with a trait object.</p>
<p>We can rewrite the <kbd>MotorInput</kbd> and <kbd>ElevatorState</kbd> objects to use trait objects as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#[derive(Clone,Serialize,Deserialize,Debug)]<br/></span><span class="s1">pub enum SimpleMotorInput<br/></span><span class="s1">{<br/></span><span class="s1">   Up { voltage: f64 },<br/></span><span class="s1">   Down { voltage: f64 }<br/></span><span class="s1">}<br/><br/></span><span class="s1">pub trait MotorInput: MotorForce + MotorVoltage<br/></span><span class="s1">{<br/></span><span class="s1">}<br/></span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">impl MotorInput for SimpleMotorInput {}</span><span class="s1"><br/></span><span class="s1">pub struct ElevatorState<br/></span><span class="s1">{<br/></span><span class="s1">   pub timestamp: f64,<br/></span><span class="s1">   pub location: f64,<br/></span><span class="s1">   pub velocity: f64,<br/></span><span class="s1">   pub acceleration: f64,<br/></span><span class="s1">   pub motor_input: Box&lt;MotorInput&gt;<br/></span><span class="s1">}</span></pre>
<p>Here, we declare that a <kbd>MotorInput</kbd> trait has two subtraits specifying the behavior. Our <kbd>ElevatorState</kbd> declaration does not require a parameter; however, the <kbd>MotorInput</kbd> trait object must be wrapped in a <kbd>Box</kbd>. This layer of indirection is required due to the inability of the compiler to size the <kbd>MotorInput</kbd> trait object for compilation. Also, because <kbd>MotorInput</kbd> does not implement <kbd>Sized</kbd>, it cannot use the <kbd>Clone</kbd> or <kbd>serde</kbd> macros. Some of our code needs to be changed to accommodate this, but it is not overwhelming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parameterizing functions and trait objects</h1>
                </header>
            
            <article>
                
<p>In our motor controllers, we make another baseless assumption about the motor. Namely, that a flat force will be generated per voltage input. The suspect code in the motor controllers looks like the following:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let target_voltage = target_force / 8.0;</span></pre>
<p>The assumption may be wrong with respect to the motor being more or less efficient than assumed. Also, the assumption that generated force will be linear with respect to voltage is unlikely. To satisfy the requirements of our motor controller and the physics simulation, we require one function that will consider the physical motor being used and convert the voltage to force. Similarly, we need the inverse function to convert the target force to target voltage. We can write these plainly as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">pub fn force_of_voltage(v: f64) -&gt; f64<br/></span><span class="s1">{<br/></span><span class="s1">   8.0 * v<br/></span><span class="s1">}<br/><br/></span><span class="s1">pub fn voltage_of_force(v: f64) -&gt; f64<br/></span><span class="s1">{<br/></span><span class="s1">   v / 8.0<br/></span><span class="s1">}</span></pre>
<p>This is nice to look at, but it doesn't fit into the goal of abstracting the concept of a physical motor. We should define these functions as methods on an interface. This way, we can use the trait object pattern again to abstract away the type of motor, as well as the type parameter for the motor. The code becomes as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">pub trait Motor<br/></span><span class="s1">{<br/></span><span class="s1">   fn force_of_voltage(&amp;self, v: f64) -&gt; f64;<br/></span><span class="s1">   fn voltage_of_force(&amp;self, v: f64) -&gt; f64;<br/></span><span class="s1">}<br/><br/></span><span class="s1">pub struct SimpleMotor;<br/></span><span class="s1">impl Motor for SimpleMotor<br/></span><span class="s1">{<br/></span><span class="s1">   fn force_of_voltage(&amp;self, v: f64) -&gt; f64<br/></span><span class="s1">   {<br/></span><span class="s1">      8.0 * v<br/></span><span class="s1">   }<br/></span><span class="s1">   fn voltage_of_force(&amp;self, v: f64) -&gt; f64<br/></span><span class="s1">   {<br/></span><span class="s1">      v / 8.0<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>After declaring the <kbd>Motor</kbd> trait and an implementation, we can integrate this definition with the <kbd>ElevatorSpecification</kbd> struct. The result is as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">pub struct ElevatorSpecification<br/></span><span class="s1">{<br/></span><span class="s1">   pub floor_count: u64,<br/></span><span class="s1">   pub floor_height: f64,<br/></span><span class="s1">   pub carriage_weight: f64,<br/></span><span class="s1">   pub motor: Box&lt;Motor&gt;<br/></span><span class="s1">}</span></pre>
<p>Again, we lose the ability to use certain derive macros, but the type signature is much cleaner at least. The usage in the motor controllers now supports multiple motors:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let target_voltage = self.esp.motor.voltage_of_force(target_force);</span></pre>
<p>We can see that there are some potential tradeoffs between different types of parameterization or generic behavior. On one hand, parameters can quickly become overwhelming to keep track of. On the other, side trait objects break many languages with features such as derive macros, anything that is not object-safe, requiring a concrete type, and so on. Choosing the right tool is an important decision that requires weighing the merits of each option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parametric traits and implementations</h1>
                </header>
            
            <article>
                
<p>Now, we have successfully implemented <kbd>Motor</kbd> and <kbd>MotorInput</kbd> as trait objects. However, we sacrificed nice things like <kbd>Clone</kbd>, <kbd>Serialize</kbd>, <kbd>Deserialize</kbd>, and <kbd>Debug</kbd> to accomplish this. Can we reclaim those functionalities?</p>
<p>First, let's try to duplicate the functionality. We will call these bundled traits <kbd>ElevatorStateClone</kbd> and <kbd>ElevatorSpecificationClone</kbd>. The signatures should look something like the following (the trait implementations are available in the <kbd>src/physics.rs</kbd> file):</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">pub trait ElevatorStateClone<br/></span><span class="s1">{</span><span class="s1"><br/></span><span class="s1">   fn clone(&amp;self) -&gt; ElevatorState;<br/></span><span class="s1">   fn dump(&amp;self) -&gt; (f64,f64,f64,f64,f64);<br/></span><span class="s1">   fn load((f64,f64,f64,f64,f64)) -&gt; ElevatorState;<br/></span><span class="s1">}</span><span class="s1"><br/><br/></span><span class="s1">pub trait ElevatorSpecificationClone<br/></span><span class="s1">{<br/></span><span class="s1">   fn clone(&amp;self) -&gt; ElevatorSpecification;<br/></span><span class="s1">   fn dump(&amp;self) -&gt; (u64,f64,f64,u64);<br/></span><span class="s1">   fn load((u64,f64,f64,u64)) -&gt; ElevatorSpecification;<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl ElevatorStateClone for ElevatorState {<br/>   ...<br/>}</span></pre>
<p>These traits provide the bare minimum functionality to get us back to where we were previously with serialization and copy semantics. The major downside is that each definition is quite verbose. Additionally, the serialization turns into a tuple, rather than going directly back and forth between the correct type.</p>
<p>So, what precisely is the problem with trait objects? We know that they must be wrapped in <kbd>Box</kbd> types to circumvent the unknown size. Is this the problem? Here is a program to test this theory:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#[derive(Serialize,Deserialize)]<br/></span><span class="s1">struct Foo<br/></span><span class="s1">{<br/></span><span class="s1">   bar: Box&lt;u64&gt;<br/></span><span class="s1">}</span></pre>
<p>So, <kbd>Box</kbd> types can be serialized. The problem, then, must be with the trait object. Let's try the same thing with a trait object to see what happens:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">trait T {}<br/><br/></span><span class="s1">#[derive(Serialize,Deserialize)]<br/></span><span class="s1">struct S1;<br/></span><span class="s1">impl T for S1 {}<br/><br/></span><span class="s1">#[derive(Serialize,Deserialize)]<br/></span><span class="s1">struct S2;<br/></span><span class="s1">impl T for S2 {}<br/><br/></span><span class="s1">#[derive(Serialize,Deserialize)]<br/></span><span class="s1">struct Container<br/></span><span class="s1">{<br/></span><span class="s1">   field: Box&lt;T&gt;<br/></span><span class="s1">}</span></pre>
<p>When compiling this last snippet, we get the error, <kbd>the trait `serde::Deserialize&lt;'_&gt;` is not implemented for `T`</kbd><span>. </span><span>So, we can see that the individual structs <kbd>S1</kbd> and <kbd>S2</kbd> both implement <kbd>Deserialize</kbd>, but that information is obscured. The</span> trait <span>object <kbd>T</kbd> itself must implement</span> <kbd>Deserialize</kbd><span>.</span></p>
<p>Making the first attempt at serializing the trait object <kbd>T</kbd>, we can follow the instructions for writing custom serialization. The result should be something like the following:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">impl Serialize for Box&lt;T&gt;<br/>{<br/></span><span class="s1">   fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;<br/></span><span class="s1">   where S: Serializer<br/></span><span class="s1">   {<br/></span><span class="s1">      serializer.serialize_unit_struct("S1")<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">struct S1Visitor;<br/></span><span class="s1">impl&lt;'de&gt; Visitor&lt;'de&gt; for S1Visitor {<br/></span><span class="s1">   type Value = Box&lt;T&gt;;<br/><br/></span><span class="s1">   fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result<br/>   {<br/></span><span class="s1">      formatter.write_str("an S1 structure")<br/></span><span class="s1">   }<br/></span><span class="s1">   fn visit_unit&lt;E&gt;(self) -&gt; Result&lt;Self::Value, E&gt;<br/></span><span class="s1">   where E: de::Error</span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">   {<br/></span><span class="s1">      Result::Ok(Box::new(S1))<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;'de&gt; Deserialize&lt;'de&gt; for Box&lt;T&gt; {<br/></span><span class="s1">   fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Box&lt;T&gt;, D::Error&gt;<br/></span><span class="s1">   where D: Deserializer&lt;'de&gt;<br/></span><span class="s1">   {<br/></span><span class="s1">      deserializer.deserialize_unit_struct("S1", S1Visitor)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">let bt: Box&lt;T&gt; = Box::new(S1);<br/></span><span class="s1">let s = serde_json::to_string(&amp;bt).unwrap();<br/></span><span class="s1">let bt: Box&lt;T&gt; = serde_json::from_str(s.as_str()).unwrap();</span></pre>
<p>This is a bit of a mess, but the important parts are that we want to write <kbd>S1</kbd> or <kbd>S2</kbd> to the serializer and check for those tags to deserialize. Essentially, what we are trying to create is a side enum to exist just for the purpose of serialization. Somehow, the serializer needs to know whether <kbd>T</kbd> is an <kbd>S1</kbd> or <kbd>S2</kbd> through the interface, so why not, in turn, provide a method on <kbd>T</kbd> that will return an enum? Enums are also serializable with macros, so we could pass that automatic serialization through to <kbd>T</kbd>. Let's try that, starting with the type and trait definitions, as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">#[derive(Clone,Serialize,Deserialize)]<br/>enum T_Enum<br/></span><span class="s1">{<br/></span><span class="s1">   S1(S1),<br/></span><span class="s1">   S2(S2),<br/></span><span class="s1">}<br/><br/></span><span class="s1">trait T<br/>{<br/></span><span class="s1">   fn as_enum(&amp;self) -&gt; T_Enum;<br/></span><span class="s1">}<br/><br/></span><span class="s1">#[derive(Clone,Serialize,Deserialize)]<br/></span><span class="s1">struct S1;<br/></span><span class="s1">impl T for S1<br/>{<br/></span><span class="s1">   fn as_enum(&amp;self) -&gt; T_Enum<br/></span><span class="s1">   {<br/></span><span class="s1">      T_Enum::S1(self.clone())<br/></span><span class="s1">   }</span></pre>
<pre class="p1" style="padding-left: 30px"><span class="s1"><br/></span><span class="s1">}</span><span class="s1"><br/></span><span class="s1">#[derive(Clone,Serialize,Deserialize)]<br/></span><span class="s1">struct S2;<br/></span><span class="s1">impl T for S2<br/>{<br/></span><span class="s1">   fn as_enum(&amp;self) -&gt; T_Enum<br/></span><span class="s1">   {<br/></span><span class="s1">      T_Enum::S2(self.clone())<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>Here, we can see that there is no issue in permitting a method on a trait object that turns the object into an enum. This relation is natural and provides an escape hatch to convert back and forth between the trait objects and its internal representation. Now, to implement serialization, we just need to wrap and unwrap the enum serializers:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">impl Serialize for Box&lt;T&gt;<br/>{<br/></span><span class="s1">   fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;<br/></span><span class="s1">   where S: Serializer<br/></span><span class="s1">   {<br/></span><span class="s1">      self.as_enum().serialize(serializer)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;'de&gt; Deserialize&lt;'de&gt; for Box&lt;T&gt;<br/>{<br/></span><span class="s1">   fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Box&lt;T&gt;, D::Error&gt;<br/></span><span class="s1">   where D: Deserializer&lt;'de&gt;<br/></span><span class="s1">   {<br/></span><span class="s1">      let result = T_Enum::deserialize(deserializer);<br/></span><span class="s1">      match result<br/></span><span class="s1">      {<br/></span><span class="s1">         Result::Ok(te) =&gt; {<br/></span><span class="s1">            match te {<br/></span><span class="s1">               T_Enum::S1(s1) =&gt; Result::Ok(Box::new(s1.clone())),<br/></span><span class="s1">               T_Enum::S2(s2) =&gt; Result::Ok(Box::new(s2.clone()))<br/></span><span class="s1">            }<br/></span><span class="s1">         }<br/></span><span class="s1">         Result::Err(err) =&gt; Result::Err(err)<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>That wasn't so bad, was it? With this technique, we can hide parameters behind trait objects while still benefiting from the direct access to data and macro-derived traits. There is a little bit of boilerplate here. Luckily though, for each macro, the code is almost identical for whatever type you are using. Remember this one; it could be useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored the basic and deeper concepts of generic and parameterized programming. We learned how to add lifetime, type, and trait parameters to declarations of types, traits, functions, and implementations. We also examined advanced techniques to selectively preserve or obscure type information as desired.</p>
<p>Applying these concepts to the elevator simulation, we observed how parameterization and generics can create fully abstract interfaces. By using trait objects, it is possible to completely separate trait interfaces from any implementation. We also observed the downsides or difficulties of parameterization and generics. Excessive use of parameterization can lead to parameter leaks, potentially requiring all code that interfaces with an interface to also become parameterized itself. On the other hand, we observed the difficulty associated with erasing type information using trait objects. Choosing the right amount of information to preserve is important.</p>
<p>In the next chapter, we will learn about applied project structure with complex requirements. The client will respond to the project proposal and your team will respond to new requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is an algebraic datatype?</li>
<li>What is polymorphism?</li>
<li>What is parametric polymorphism?</li>
<li>What is a ground type?</li>
<li>What is universal function call syntax?</li>
<li>What are the possible type signatures of a trait object?</li>
<li>What are two ways to obscure type information?</li>
<li>How is a subtrait declared?</li>
</ol>


            </article>

            
        </section>
    </body></html>