["```rs\n├── client\n│   ├── Cargo.toml\n│   └── src\n│       └── main.rs\n└── server\n    ├── Cargo.toml\n    └── src\n        └── main.rs\n```", "```rs\n[dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\n```", "```rs\nuse tokio::net::TcpListener;\nuse tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};\n```", "```rs\n#[tokio::main]\nasync fn main() {\n    let addr = \"127.0.0.1:8080\".to_string();\n    let socket = TcpListener::bind(&addr).await.unwrap();\n    println!(\"Listening on: {}\", addr);\n    while let Ok((mut stream, peer)) =\n        socket.accept().await {\n        println!(\"Incoming connection from: {}\",\n                  peer.to_string());\n        tokio::spawn(async move {\n            . . .\n        });\n    }\n}\n```", "```rs\nprintln!(\"thread starting {} starting\", peer.to_string());\nlet (reader, mut writer) = stream.split();\nlet mut buf_reader = BufReader::new(reader);\nlet mut buf = vec![];\nloop {\n    match buf_reader.read_until(b'\\n', &mut buf).await {\n        Ok(n) => {\n            if n == 0 {\n                println!(\"EOF received\");\n                break;\n            }\n            let buf_string = String::from_utf8_lossy(&buf);\n            writer.write_all(buf_string.as_bytes())\n                .await.unwrap();\n            buf.clear();\n        },\n        Err(e) => println!(\"Error receiving message: {}\", e)\n    }\n}\nprintln!(\"thread {} finishing\", peer.to_string());\n```", "```rs\nuse tokio::net::TcpStream;\nuse tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};\nuse std::error::Error;\n```", "```rs\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let mut stream =\n        TcpStream::connect(\"127.0.0.1:8080\").await?;\n    let (reader, mut writer) = stream.split();\n    println!(\"stream starting\");\n    writer.write_all(b\"this is a test\\n\").await?;\n    println!(\"sent data\");\n    let mut buf_reader = BufReader::new(reader);\n    let mut buf = vec![];\n    println!(\"reading data\");\n    let _ = buf_reader.read_until(b'\\n', &mut\n        buf).await.unwrap();\n    let message = String::from_utf8_lossy(&buf);\n    println!(\"{}\", message);\n    Ok(())\n}\n```", "```rs\nstream starting\nsent data\nreading data\nthis is a test\n```", "```rs\nListening on: 127.0.0.1:8080\nIncoming connection from: 127.0.0.1:60545\nthread starting 127.0.0.1:60545 starting\nEOF received\nthread 127.0.0.1:60545 finishing\n```", "```rs\n[dependencies]\nserde = { version = \"1.0.144\", features = [\"derive\"] }\ntokio = { version = \"1\", features = [\"full\"] }\nbincode = \"1.3.3\"\n```", "```rs\n. . .\nuse serde::{Serialize, Deserialize};\nuse bincode;\n```", "```rs\n#[derive(Serialize, Deserialize, Debug)]\nstruct Message {\n    pub ticker: String,\n    pub amount: f32\n}\n```", "```rs\nlet mut stream = TcpStream::connect(\"127.0.0.1:8080\").await?;\nlet (reader, mut writer) = stream.split();\n```", "```rs\nlet message = Message{ticker: String::from(\"BYND\"),\n                      amount: 3.2};\nlet message_bin = bincode::serialize(&message).unwrap();\n```", "```rs\nprintln!(\"stream starting\");\nwriter.write_all(&message_bin).await?;\nwriter.write_all(b\"\\n\").await?;\nprintln!(\"sent data\");\n```", "```rs\nlet mut buf_reader = BufReader::new(reader);\nlet mut buf = vec![];\nprintln!(\"reading data\");\nlet _ = buf_reader.read_until(b'\\n',\n    &mut buf).await.unwrap();\nprintln!(\"{:?}\", bincode::deserialize::<Message>(&buf));\n```", "```rs\nuse serde::{Serialize, Deserialize};\nuse bincode;\n```", "```rs\n#[derive(Serialize, Deserialize, Debug)]\nstruct Message {\n    pub ticker: String,\n    pub amount: f32\n}\n```", "```rs\nlet message =\n    bincode::deserialize::<Message>(&buf).unwrap();\nprintln!(\"{:?}\", message);\nlet message_bin = bincode::serialize(&message).unwrap();\nwriter.write_all(&message_bin).await.unwrap();\nwriter.write_all(b\"\\n\").await.unwrap();\nbuf.clear();\n```", "```rs\nListening on: 127.0.0.1:8080\nIncoming connection from: 127.0.0.1:50973\nthread starting 127.0.0.1:50973 starting\nMessage { ticker: \"BYND\", amount: 3.2 }\nEOF received\nthread 127.0.0.1:50973 finishing\n```", "```rs\nstream starting\nsent data\nreading data\nOk(Message { ticker: \"BYND\", amount: 3.2 })\n```", "```rs\n[dependencies]\ntokio-util = {version = \"0.7.4\", features = [\"full\"] }\nserde = { version = \"1.0.144\", features = [\"derive\"] }\ntokio = { version = \"1\", features = [\"full\"] }\nfutures = \"0.3.24\"\nbincode = \"1.3.3\"\nbytes = \"1.2.1\"\n```", "```rs\nuse tokio::net::TcpStream;\nuse tokio_util::codec::{BytesCodec, Decoder};\n```", "```rs\nimpl Encoder<Bytes> for BytesCodec {\n    . . .\n}\nimpl Encoder<BytesMut> for BytesCodec {\n    . . .\n}\n```", "```rs\nimpl Encoder<Bytes> for BytesCodec {\n    type Error = io::Error;\n    fn encode(&mut self, data: Bytes, buf: &mut BytesMut)\n              -> Result<(), io::Error> {\n        buf.reserve(data.len());\n        buf.put(data);\n        Ok(())\n    }\n}\n```", "```rs\nuse futures::sink::SinkExt;\nuse futures::StreamExt;\nuse bytes::Bytes;\n```", "```rs\nuse serde::{Serialize, Deserialize};\nuse bincode;\nuse std::error::Error;\n#[derive(Serialize, Deserialize, Debug)]\nstruct Message {\n    pub ticker: String,\n    pub amount: f32\n}\n```", "```rs\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    . . .\n    Ok(())\n}\n```", "```rs\nlet stream = TcpStream::connect(\"127.0.0.1:8080\").await?;\nlet mut framed = BytesCodec::new().framed(stream);\n```", "```rs\nlet message = Message{ticker: String::from(\"BYND\"),\n                      amount: 3.2};\nlet message_bin = bincode::serialize(&message).unwrap();\nlet sending_message = Bytes::from(message_bin);\n```", "```rs\nframed.send(sending_message).await.unwrap();\nlet message = framed.next().await.unwrap().unwrap();\nlet message =\n    bincode::deserialize::<Message>(&message).unwrap();\nprintln!(\"{:?}\", message);\n```", "```rs\nuse tokio::net::TcpListener;\nuse tokio_util::codec::{BytesCodec, Decoder};\nuse futures::StreamExt;\nuse futures::sink::SinkExt;\nuse bytes::Bytes;\nuse serde::{Serialize, Deserialize};\nuse bincode;\n```", "```rs\n#[derive(Serialize, Deserialize, Debug)]\nstruct Message {\n    pub ticker: String,\n    pub amount: f32\n}\n```", "```rs\n#[tokio::main]\nasync fn main() {\n    let addr = \"127.0.0.1:8080\".to_string();\n    let listener = TcpListener::bind(&addr).await.unwrap();\n    println!(\"Listening on: {}\", addr);\n    loop {\n        let (socket, _) = listener.accept().await.unwrap();\n        tokio::spawn(async move {\n            . . .\n        });\n    }\n}\n```", "```rs\nlet mut framed = BytesCodec::new().framed(socket);\nlet message = framed.next().await.unwrap();\n    match message {\n        Ok(bytes) => {\n            . . .\n        },\n        Err(err) => println!(\"Socket closed with error:\n                              {:?}\", err),\n    }\nprintln!(\"Socket received FIN packet and closed\n           connection\");\n```", "```rs\nlet message =\n    bincode::deserialize::<Message>(&bytes).unwrap();\nprintln!(\"{:?}\", message);\nlet message_bin = bincode::serialize(&message).unwrap();\nlet sending_message = Bytes::from(message_bin);\nframed.send(sending_message).await.unwrap();\n```", "```rs\nMessage { ticker: \"BYND\", amount: 3.2 }\n```", "```rs\nListening on: 127.0.0.1:8080\nMessage { ticker: \"BYND\", amount: 3.2 }\nSocket received FIN packet and closed connection\n```", "```rs\nuse serde::{Serialize, Deserialize};\n```", "```rs\n#[derive(Serialize, Deserialize, Debug)]\npub struct HttpFrame {\n    pub header: Header,\n    pub body: Body\n}\n```", "```rs\n#[derive(Serialize, Deserialize, Debug)]\npub struct Header {\n    pub method: String,\n    pub uri: String,\n}\n#[derive(Serialize, Deserialize, Debug)]\npub struct Body {\n    pub ticker: String,\n    pub amount: f32,\n}\n```", "```rs\nmod http_frame;\nuse http_frame::{HttpFrame, Header, Body};\n```", "```rs\nlet stream = TcpStream::connect(\"127.0.0.1:8080\").await?;\nlet mut framed = BytesCodec::new().framed(stream);\nlet message = HttpFrame{\n    header: Header{\n        method: \"POST\".to_string(),\n        uri: \"www.freshcutswags.com/stock/purchase\".to_string()\n    },\n    body: Body{\n        ticker: \"BYND\".to_string(),\n        amount: 3.2,\n    }\n};\nlet message_bin = bincode::serialize(&message).unwrap();\nlet sending_message = Bytes::from(message_bin);\nframed.send(sending_message).await.unwrap();\n```", "```rs\nlet message = bincode::deserialize::<HttpFrame>(&bytes).unwrap();\nprintln!(\"{:?}\", message);\nlet message_bin = bincode::serialize(&message).unwrap();\nlet sending_message = Bytes::from(message_bin);\nframed.send(sending_message).await.unwrap();\n```", "```rs\nListening on: 127.0.0.1:8080\nHttpFrame { header: Header {\n                method: \"POST\",\n                uri: \"www.freshcutswags.com/stock/purchase\"\n            },\n            body: Body {\n                ticker: \"BYND\",\n                amount: 3.2\n            }\n        }\nSocket received FIN packet and closed connection\n```", "```rs\nHttpFrame { header: Header {\n                method: \"POST\",\n                uri: \"www.freshcutswags.com/stock/purchase\"\n            },\n            body: Body {\n                ticker: \"BYND\",\n                amount: 3.2\n            }\n        }\n```"]