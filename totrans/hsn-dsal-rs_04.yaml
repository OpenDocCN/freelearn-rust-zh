- en: Lists, Lists, and More Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lists are everywhere: shopping lists, to-do lists, recipes, street numbers
    in western countries... simply everywhere. Their defining characteristic, storing
    things in a linear, defined relationship with each other, helps us keep track
    of stuff and find it again later on. From a data structure perspective, they are
    also essential to almost any program and come in various shapes and forms. While
    some lists are tricky to implement in Rust, the general principles can be found
    here as well, along with some valuable lessons on the borrow checker! After this
    chapter, we want you to know more about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: (Doubly) linked lists and when you should use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array lists, better known as Rust's vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skip lists and, ideally, the New York metro subway system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simple transaction log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a final note, this chapter will build *safe* implementations of various lists,
    even though unsafe versions could be faster and require less code. This decision
    is due to the fact that, when working on regular use cases, unsafe is almost never
    a solution. Check out the links in the *Further reading* section of this chapter
    for unsafe lists.
  prefs: []
  type: TYPE_NORMAL
- en: Linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To keep track of a bunch of items, there is a simple solution: with each entry
    in the list, store a pointer to the next entry. If there is no next item, store
    `null`/`nil`/`None` and so on, and keep a pointer to the first item. This is called
    a **singly linked list**, where each item is connected with a single link to the
    next, as shown in the following diagram—but you already knew that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73e264f8-1621-4095-9d02-fb0a5645e62b.png)'
  prefs: []
  type: TYPE_IMG
- en: What are the real use cases for a linked list though? Doesn't everyone just
    use a dynamic array for everything?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a transaction log, a typical append-only structure. Any new command
    (such as a SQL statement) is simply appended to the existing chain and is eventually
    written to a persistent storage. Thus, the initial requirements are simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Append a command to an existing list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replay every command from the beginning to the end—in that order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, its a queue (or **LIFO**—short for **Last In First Out**) structure.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, a list has to be defined—in Rust, lacking a `null` type, each item is
    chained to the next by an `Option` property. The `Option` instances are enumerations
    that wrap either the value, in this case a heap reference (such as a `Box`, `Rc`,
    and so on), or none—Rust's typed `null` equivalent. Why? Let's find out!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a prototypical implementation to explore a certain aspect is always
    a good idea, especially since the compiler often provides excellent feedback.
    Accordingly, an implementation of an integer list is the first step. How about
    this `struct` for each list element?
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For practical considerations, it needs a way to know where to start and the
    length of the list. Considering the planned `append` operation, a reference to
    the end (tail) would be useful too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That looks great! Does it work though?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, it doesn''t work—and, thinking back to the previous chapters,
    it becomes clear why: the compiler cannot be certain of the data structure''s
    size, since the entire list would have to be nested into the first element. However,
    as we know, the compiler cannot compute and therefore allocate the required amount
    of memory this way—which is why reference types are required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reference types (such as `Box`, `Rc`, and so on) are a good fit, since they
    allocate space on the heap and therefore allow for larger lists. Here''s an updated
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Storing each node item in a `Rc<RefCell<T>>` provides the ability to retrieve
    and replace data as needed (the internal mutability pattern)—crucial when executing
    operations on the list. Another good practice is to alias types, especially if
    there are a lot of generics in play. This makes it easy to replace type implementations
    and provides a more readable definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! This is the base definition of the transaction log, but to use it
    there are many things missing. First of all, the value type has to be `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to that, it is going to be useful to create an empty list, so the
    `impl` block of the list has a single function for now—`new_empty()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Still, there is a lot missing. To recap, the transaction log has two requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Append` entries at the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remove` entries from the front'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the first requirement: appending items to the back of the
    list!'
  prefs: []
  type: TYPE_NORMAL
- en: Adding entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The transaction log can now be created and hold entries, but there is no way
    to add anything to the list. Typically, a list has the ability to add elements
    to either end—as long as there is a pointer to that end. If that was not the case,
    any operation would become computationally expensive, since every item has to
    be looked at to find its successor. With a pointer to the end (tail) of the list,
    this won't be the case for the append operation; however, to access a random index
    on the list, it would require some time to go through everything.
  prefs: []
  type: TYPE_NORMAL
- en: Naming is—especially if English is your second language—often tricky. Operations
    have different names by the language or library used. For example, common names
    for adding items to a list include `push` (can add to the front or back), `push_back`,
    `add`, `insert` (usually comes with a positional parameter), or `append`*.* On
    top of being able to guess method names, some imply completely different processes
    than others! If you design an interface or library, find the most descriptive
    and simple name possible and reuse whenever you can!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the things that a linked list does really well—adding items
    to either end. There are a few critical things that should not be overlooked,
    though:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `Node` object within the method makes for a nicer API and better
    ownership handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge cases such as empty lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incrementing the length is a good idea.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RefCell` is used to retrieve mutable ownership for setting a new successor
    using its `borrow_mut()` function (interior mutability).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once that is thought of, the actual implementation is not too bad. Rust''s
    `Option` type offers a method to retrieve ownership of a value it contains, replacing
    it with `None` (see also the documentations for `Option.take()`—[https://doc.rust-lang.org/std/option/enum.Option.html#method.take](https://doc.rust-lang.org/std/option/enum.Option.html#method.take)
    and `mem::replace()`—[https://doc.rust-lang.org/stable/std/mem/fn.replace.html](https://doc.rust-lang.org/stable/std/mem/fn.replace.html)),
    which conveniently shortens the code required to append a new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, it''s now possible to create a log of any string commands passing
    through. However, there is something important missing here as well: log replay.'
  prefs: []
  type: TYPE_NORMAL
- en: Log replay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically in databases, transaction logs are a resilience measure if something
    bad happens that the database must be restored—or to keep a replica up to date.
    The principle is fairly simple: the log represents a timeline of commands that
    have been executed in this exact order. Thus, to recreate that final state of
    a database, it is necessary to start with the oldest entry and apply every transaction
    that follows in that very order.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have caught how that fits the capabilities of a linked list nicely.
    So, what is missing from the current implementation?
  prefs: []
  type: TYPE_NORMAL
- en: The ability to remove elements starting at the front.
  prefs: []
  type: TYPE_NORMAL
- en: Since the entire data structure resembles a queue, this function is going to
    be called `pop`, as it's the typical name for this kind of operation. Additionally,
    `pop` will consume the item that was returned, making the list a single-use structure.
    This makes sense, to avoid replaying anything twice!
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks a lot more complex than it is: the interior mutability pattern certainly
    adds complexity to the implementation. However, it makes the whole thing safe—thanks
    to `RefCells` checking borrowing rules at runtime. This also leads to the chain
    of functions in the last part—it retrieves the value from within its wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Calling this function in sequence returns the commands in the order they were
    inserted, providing a nice replay feature. For a real-world usage, it's important
    to provide the ability to serialize this state to disk as well, especially since
    this operation consumes the list entirely. Additionally, handling errors gracefully
    (instead of panicking and crashing) is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: After use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever the list needs to be disposed of, Rust calls a `drop()` method that
    is automatically implemented. However, since this is an automated process, each
    member is dropped recursively—which works OK until the level of nested `next`
    pointers exceeds the stack for executing the `drop()` method and crashes the program
    with an unexpected stack overflow message.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, it is a good idea for production usage to also implement the
    `Drop` trait and dispose of the list elements iteratively. By the way, a stack
    overflow also happens while using the derived `Debug` implementation to print
    a `Node`—for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A (transaction) log is a great use case for a linked list: They often grow
    to unexpected sizes, and indexing is not required. While a linked list is often
    a very simple type in other languages, it harbors a surprising amount of challenges
    in Rust. This is mostly due to the borrowing and ownership concepts which require
    a programmer to think about what goes where in great detail. For real-world use
    cases, however, it''s better to use Rust''s standard library linked list (`std::collections::LinkedList`).
    From a performance perspective, finding a particular item in the singly linked
    list requires looking at the entire list in the worst case, resulting in a runtime
    complexity of `O(n)`, with `n` being the number of items in the list (more on
    the topic of runtime complexity in [Chapter 8](6ab96dc6-b8f5-4c03-88a3-f4a345f8cc9b.xhtml),
    *Algorithm Evaluation*).'
  prefs: []
  type: TYPE_NORMAL
- en: Upsides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main benefits of a linked list are the abilities to grow very large in size
    cheaply, always maintain a certain direction, and allow to access items individually.
    What makes this data structure unique?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few points:'
  prefs: []
  type: TYPE_NORMAL
- en: Low overhead allocation per item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item count is only limited by heap memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutation while iterating is possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A direction is strictly enforced—there is no going back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation is fairly simple (even in Rust).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient append, prepend, delete, and insert operations—compared to an array
    (no shifting required).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, the linked list performs well in an environment where limited memory
    does not allow overhead allocation (as dynamic arrays do), or as a basis for an
    exotic lock-free data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The linked list has some obvious shortcomings:'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing is inefficient, since every node has to be looked at.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration in general involves a lot of jumping around on the heap, which takes
    more time and makes the operation hard to cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a list is *very* inefficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point is important, so, commonly, a linked-list implementation will
    have a link back as well, which makes it a doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The transaction log of the previous section is due for an upgrade. The product
    team wants to enable users to be able to examine the log by going through it **forward**
    **and** **backward** to see what each step does. This is bad news for the regular
    linked list, as it's really inefficient to go anywhere other than forward. So,
    how is this rectified?
  prefs: []
  type: TYPE_NORMAL
- en: 'It is rectified using the doubly linked list. The doubly linked list introduces
    the link `back`. While this sounds like a minor change, it allows to work on that
    list backward as well as forward, which significantly improves the ability to
    look up items. By augmenting the previous singly linked list item with a back
    pointer, the doubly linked list is almost created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the singly linked list, the list itself only consists of a head
    and a tail pointer, which makes accessing either end of the list cheap and easy.
    Additionally, the nodes now also feature a pointer back to the preceding node,
    making the list look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30cde807-16c5-4e6a-8009-5967d7449cc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is also the point that makes the doubly linked list tricky in Rust. The
    ownership principle is great if there is a hierarchy of ownership: a customer
    has an address, a text file has several lines of text, and so on. However, a node
    in a doubly linked list doesn''t have clear ownership of either of its neighbors.'
  prefs: []
  type: TYPE_NORMAL
- en: A better transaction log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, the list of requirements got expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: Move forward through the log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move backward through the log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moves don't consume the log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nice fit for the doubly linked list, so the existing transaction log can be
    upgraded! With the pointers to both neighbors of a node, it can solve the problem.
    However, what about moving through the list without removing elements?
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, another concept is required: **iterators**. Rust''s iterators are
    leaning on the functional side of programming and provide a versatile interface
    for integrating with all kinds of other data structures and commands across the
    language. For example, `for` loops will pick up on the iterator and behave as
    expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterators** are pointers to the current item with a method called `next()`
    that produces the next item while moving the pointer forward! This concept is
    applied a lot when using a more functional approach to working with collections:
    by chaining them together and applying a function after invoking `next()`, going
    through a list can be very efficient. Check the *Further reading* section and
    the last chapter of this book for more information!'
  prefs: []
  type: TYPE_NORMAL
- en: The data model is going to look like the singly linked list, so most of the
    operations can be used as they are—they only need to be upgraded to work with
    the back-pointer as well.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at the list without consuming it is an iterator's job (see the info
    box), which—in Rust as well as in most other languages—is a simple implementation
    of an interface or trait. In fact, this is so common that the Rust docs have a
    great article ([https://doc.rust-lang.org/std/iter/index.html#implementing-iterator](https://doc.rust-lang.org/std/iter/index.html#implementing-iterator)),
    which is exactly what's required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are already working with heap references, the iterator can simply
    save an optional reference to a node and it''s easy to move it forward and backward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As the documentation states, a `for` loop uses two traits: `Iterator` and `IntoIterator`.
    Implementing the former is usually a good idea, as it provides access to the powerful
    methods in `Iterator`, such as `map`, `fold`, and so on, and nicely chains together
    with other—compatible—iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This iterator is responsible for moving one direction: forward. How can we
    walk back too?'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, since the requirement was also to go back, the iterator needs to go both
    ways. One easy way is to simply add a function to the structure that is called
    `reverse()`, but that would not integrate well and would require developers to
    read up on this API, and it creates additional work, since the forward/backward
    iterators are separate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust''s standard library offers an interesting concept for this: `DoubleEndedIterator`.
    Implementing this trait will provide the ability to reverse an iterator in a standardized
    way by offering a `next_back()` function to get the previous value—with the doubly
    linked list, this is only a matter of which property gets set to the current item!
    Therefore, both iterators share a large chunk of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, an iterator can be created by calling the `iter()` function
    on the list type, and by calling `iter().rev()`, the iterator will be reversed,
    providing the ability to go back as well as forward.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doubly linked lists are in many cases improved versions (and the default) over
    regular linked lists, thanks to the better flexibility at the cost of a single
    pointer per node and slightly more complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, by keeping the code safe (in Rust terms, so no `unsafe {}` was
    used), the code gets riddled with `RefCells` and `borrow()` to create a data structure
    that the borrow checker is auditing at runtime. Looking at the Rust source code
    for `LinkedList`, this is not the case there (more on that in [Chapter 7](ba6dfa3b-1b5c-4033-a641-da15b9adb390.xhtml),
    *Collections in Rust*). The basic structure is similar, but the operations use
    a bunch of unsafe code underneath—something that requires a good experience writing
    Rust.
  prefs: []
  type: TYPE_NORMAL
- en: '`PhantomData<T>` is a zero-size type that informs the compiler about a range
    of things, such as drop behavior, sizes, and so on, when generics are involved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick preview, here is the Rust standard library''s `LinkedList<T>` definition
    and implementation. It''s a doubly linked list! Additionally, the `push_front_node`
    (`prepend`) function shows the use of an unsafe area to speed up inserts. For
    more information on that, check out the link to the online book *Learning Rust
    With Entirely Too Many Linked Lists* in the *Fu**rther reading* section at the
    end of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Whatever the implementation, there are general upsides and downsides to the
    doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Upsides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a linked list, the principles are the same but slightly different. However,
    the major points of when the list is a good choice are shared with the singly
    linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: Low overhead allocation per item (but more than the singly linked list).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item count is only limited by heap memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutation while iterating is possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation is more complex but still fairly simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserts, deletes, append, and prepend remain efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient reversion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes the doubly linked list a superior version of the two versions of
    linked lists, which is why it's usually the default `LinkedList` type.
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The doubly linked list shares a lot of the downsides of its less complex sibling
    and replaces the "no going back" with "more memory overhead" and "more complex
    implementation". Here''s the list again:'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing is still inefficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes are also allocated on the heap, which requires a lot of jumping around
    too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional pointer has to be stored per node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation is more complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inefficient indexing and iteration is something that a lot of developers wanted
    to get rid of, so they invented a more exotic version of a linked list: the **skip
    list**.'
  prefs: []
  type: TYPE_NORMAL
- en: Skip lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of people love New York—and so do we. It has many qualities that are hard
    to describe; it is a crazy (in a good way), lively city that brings together many
    cultures, backgrounds, ethnicities, activities, and opportunities. New York also
    features a large public transport network, almost like cities in Europe.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does any of this have to do with skip lists? A subway system can be expressed
    as a simple list of stops (expressed in street numbers, a common thing in the
    USA): `14 -> 23 -> 28 -> 33 -> 42 -> 51 -> 59 -> 68` . However, the New York subway
    system has something called **express trains** which reduce the number of stops
    to cover larger distances faster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose someone wants to go from stop 14 to stop 51\. Instead of seeing the
    doors open and close five times, they can go there getting off at the third stop.
    In fact, this is how New Yorkers use the trains 4, 5, and 6 between 14th Street
    (Union Square) and 51st Street. Turned on its side, the subway plan looks roughly
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5ec37c0-2813-4ba9-83ec-91d5403cd129.png)'
  prefs: []
  type: TYPE_IMG
- en: The local service trains stop at every stop along the way, but the express service
    trains skip certain smaller stops only to halt at shared stations where travelers
    can switch between the two. The skipping happens quite literally on some stops
    where trains simply drive through, sometimes confusing tourists and locals alike.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expressed as a data structure, the list is essentially several lists, each
    at a different level. The lowest level contains *all* nodes, where the upper levels
    are their "express services" that can skip a number of nodes to get further ahead
    quicker. This results in a multilayered list, fused together only at certain nodes
    that have a connection on these particular levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/253f5e6f-35ff-49a9-9b48-793e20413e74.png)'
  prefs: []
  type: TYPE_IMG
- en: Ideally, each level has half the number of nodes that the previous level has,
    which means that there needs to be a decision-making algorithm that can work with
    a growing list and still maintain this constraint. If this constraint is not kept,
    search times get worse, and in the worst-case scenario it's a regular linked list
    with a lot of overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'A node''s level is decided using a probabilistic approach: increment the level
    as long as a coin flip comes out on the same side. While this produces the desired
    distribution, that''s only meaningful if the higher-level nodes are evenly distributed.
    There are a few posts on improved versions in the *Further reading* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to that, the skip list has to be ordered to function properly.
    After all, if the elements of the list are in a random order, how would the list
    know what it is skipping? In general, however, a node type for this—basic—skip
    list looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And to chain them together, a list type is also required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What stands out is that the `struct` is very similar to the previous lists.
    Indeed—the relationship is undeniable, since they share almost all the properties.
    However, there are two differences: the `tails` is a `Vec<Link>` and the `max_level`
    is a property of the list.'
  prefs: []
  type: TYPE_NORMAL
- en: The `tails` property being a vector is due to the fact that every level will
    have a tail end, meaning that whenever an append occurs, all tails may need to
    be updated. Additionally, the developer is responsible for providing an appropriate
    `max_level` value, since changing `max_level` would result in constructing a new
    list!
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the previous example, the product team has requested more features!
    Users are confused by the lack of a clear direction in the list, and they are
    annoyed that there is no way to quickly skip the verbose but less-than-interesting
    parts in the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a consequence, the product team wants the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A time associated with the logged transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to quickly jump to an arbitrary time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start iterating from there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't this sound a lot like a skip list?
  prefs: []
  type: TYPE_NORMAL
- en: The best transaction log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To improve the transaction log in the way the product team describes, it's a
    perfect fit for a skip list. How about ordering the commands by a `u32` number—a
    millisecond offset from the initial timestamp. The commands it contains are going
    to be stored as strings associated with the offset.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the list and its nodes need to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to previous implementations (especially since the singly linked list
    is a close relative), there are two major differences in this declaration. Firstly,
    the next pointer is an array, which is due to the node having a different successor
    at every level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, the content was previously named `value`, but to differentiate between
    the timestamp offset and the actual content, `value` has been replaced by `offset`
    and `command`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These nodes form the basis of this—improved—transaction log. As previously,
    with the singly linked list, this is done by creating a type that has a head pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than a simple pointer to the head, the list best stores the length as
    well as the maximum level that elements can have. This user-supplied parameter
    is critical, since if it's chosen too low, searching will approximate the search
    performance of a singly linked list (`O(n)`).
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, choosing a maximum level that is too high will also result in an
    uneven distribution that could see as many vertical (levels down) as horizontal
    iterations (`O(n + h)` ), none of which are good. The Big O notation (`O(n)` and
    so on) will be discussed in [Chapter 8](6ab96dc6-b8f5-4c03-88a3-f4a345f8cc9b.xhtml),
    *Algorithm Evaluation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, this parameter has to be set to somewhat reflect the future size
    of the list and the highest level only contains two or three nodes at most:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `tails` property is a vector pointing to the tail of each level. When adding
    data, this is the primary place to update this transaction log, thanks to the
    append-only nature of our skip list.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having the basic data structures ready, a function to insert data is required.
    As previously stated, a skip list can only work if the values are somehow comparable
    and follow an ascending order. This makes sense: skipping ahead is only useful
    if you know where you are going!'
  prefs: []
  type: TYPE_NORMAL
- en: A very efficient way to create a sorted list is by doing a **sorted insert**
    (sometimes called an **insertion** **sort**). Commonly, this would add some complexity
    to the insert logic to find the correct place for the node. However, since a timestamp
    is naturally ascending and a comparable value, this version of the transaction
    log works without a sophisticated insert, thereby requiring fewer tests and fewer
    headaches when reading it a year down the road.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, this means reusing some code from earlier sections is entirely possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet, there is an important addition: deciding on the level a node should (also)
    be present at. This is what makes the list powerful and is done just before the
    node is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet shows some important details:'
  prefs: []
  type: TYPE_NORMAL
- en: The first node is always present on all levels, which makes search considerably
    easier, since the algorithm only needs to descend. However, this is only possible
    thanks to the append-only approach!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each node's `next` vector has to store succeeding pointers at the level's index,
    which means that the actual length needs to be `highest level + 1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you decide on the level, though? This is a great question, since this
    is the heart of a well-performing skip list.
  prefs: []
  type: TYPE_NORMAL
- en: Leveling up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `search` in a skip list is very much like `search` in a binary search
    tree (the first section in [Chapter 5](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml),
    *Robust Trees*, will get more into those), it has to retain a certain distribution
    of nodes to be effective. The original paper by William Pugh proposes a way to
    create the desired distribution of nodes on a certain level by repeatedly flipping
    a coin (assuming *p = 0.5*).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the proposed algorithm (*William Pugh, Skip Lists: A Probabilistic
    Alternative to Balanced Trees, Figure 5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a simple and understandable implementation, the skip list in
    this chapter will use this as well. However, there are better ways to generate
    the required distribution, and this is left for you to explore further. For this
    task, the first external crate is going to be used: `rand`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`rand` is provided by the Rust project but published in its own repository.
    There certainly are discussions about why this is not part of the default standard
    library; however, it''s not too bad having the choice of crates to import if it
    needs to be replaced by something more lightweight, or if the target platform
    is not supported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This Rust code should do just fine and generate the required level on call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Regarding the algorithm, bear this in mind: a range of levels that come out
    are `[0, max_level]`, including the level. Each time a value is inserted, this
    function is called to acquire the level for the resultant node, so jumps can actually
    make `search` faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Jumping around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The skip list only resembles a binary search tree, but it is able to achieve
    the same runtime complexity (`O(log n)`) without the need for expensive rebalancing.
    This is due to the jumps the skip list allows. Logically, it makes sense: by jumping
    over several nodes, these nodes don''t need to be looked at to find out whether
    those are the values that are being searched for. Fewer nodes means fewer comparisons,
    leading to a reduced runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The jumps are quickly implemented too and can be implemented in a function
    using a few loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These 30 lines of code allow you to search the list quickly within a few steps.
    First, a sensible starting level has to be found by starting at the highest possible
    level, to see which has a valid node that follows it. The following happens in
    this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this level is figured out, the next step is to move vertically toward
    the desired node and move lower, as the potential next node is greater than the
    value we are looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the result of the search is returned as an `Option` that contains the
    command that was issued at the specified time—or `None`. Depending on the semantics
    of failure, it could be a better choice to use a `Result` with the appropriate
    message that informs the user about why there was no result (the list was empty,
    no value has been found, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Thoughts and discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`skip list` is a fascinating data structure, as it is fairly simple to implement
    and combines the benefits of tree-like structures within a list without the need
    for expensive inserts or rebalancing. To visualize the power of this data structure,
    here is a chart that compares the `find()` operation of skip lists and (`std::collections::`)
    `LinkedList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d095723-203b-491d-92c9-4bcffacaa57b.png)'
  prefs: []
  type: TYPE_IMG
- en: The graph output for Skip List find () and Linked List find ()
  prefs: []
  type: TYPE_NORMAL
- en: 'The first chart (higher) shows how the skip list behaves according to an `O(log
    n)` type function, which proves that the implementation works! The second (lower)
    chart shows the linear search in `LinkedList`, with the time required growing
    in `O(n)`. The raw numbers are even more impressive:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Size** | **Skip list [avg ns]** | **Linked list [avg ns]** |'
  prefs: []
  type: TYPE_TB
- en: '| 1,000 | 311 | 825 |'
  prefs: []
  type: TYPE_TB
- en: '| 10,000 | 438 | 17,574 |'
  prefs: []
  type: TYPE_TB
- en: '| 100,000 | 1,190 | 428,259 |'
  prefs: []
  type: TYPE_TB
- en: '| 1,000,000 | 2,609 | 5,440,420 |'
  prefs: []
  type: TYPE_TB
- en: '| 10,000,000 | 3,334 | 45,157,562 |'
  prefs: []
  type: TYPE_TB
- en: These numbers reflect the **nanoseconds** (**ns**) required for a single call
    to the `find()` method averaged over a number of trials. This is truly a great
    data structure for search.
  prefs: []
  type: TYPE_NORMAL
- en: Upsides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a word: `search`. The number of steps required to retrieve a single item
    is linear (it will take as many steps to find an item as there are items in the
    list ), in the *worst case*. Commonly, the time would be at the level of a binary
    search tree!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In more practical terms, this would provide the ability to store large amounts
    of data in a list and quickly find the items that you were looking for. However,
    there is more; here is a list of upsides:'
  prefs: []
  type: TYPE_NORMAL
- en: The item count is only limited by heap memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search is really efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is less complex to implement than many trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yet, there are downsides to this list.
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The memory efficiency of a skip list and its complexity can be an issue. With
    the append-only approach, the list implemented in this book avoids a few complexities
    such as sorted insert (we''ll get there later). Other points include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory efficiency: lots and lots of pointers create overhead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates are expensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probabilistic approach to elevating nodes onto certain levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the type of project, these might be prohibitive issues. However,
    there are other types of lists that might be suitable, one of them being the dynamic
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Arrays** are another common way to store sequences of data. However, they
    lack a fundamental feature of lists: expansion. Arrays are efficient because they
    are a fixed-size container of length *n*, where every element has an equal size.
    Thus, any element can be reached by calculating the address to jump to using the
    simple formula `start_address + n * element_size`, making the entire process really
    fast. Additionally, this is very CPU cache-friendly, since the data is always
    at least one hop away.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of using arrays to emulate list behavior has been around for a long
    time (Java 1.2 included an `ArrayList` class in 1998, but the idea is likely much
    older) and it is still a great way to achieve high performance in lists. Rust''s
    `Vec<T>` uses the same technique. To start off, this is how an array list is built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/880ecd46-5207-45cf-855a-67a55ab1cfe5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Consequently, this Rust implementation will have an array (actually a slice,
    but more on that later) as the main storage facility as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is that, dynamic list sizes can be emulated at the cost of memory
    and potentially excessive overallocation. Consequently, the critical point is
    when the currently allocated size is exceeded and the list needs to grow. The
    question becomes this: how much memory is going to be needed?'
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of too little memory is that reallocation is going to happen
    again quickly—which will remove any performance gains over regular lists. If the
    resizing was too large, a lot of memory would go to waste, and, depending on the
    program's target platform, this might be a huge issue. Thus, the strategy of acquiring
    more memory is essential. Rust's `Vec` follows a smart implementation and allows
    either an exact allocation and an amortized allocation of simply double (or more)
    the size of the current internal array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java''s implementation grows the vector by simply creating a new array with
    the old capacity added to a bit-shifted version (to the right by one) of the old
    capacity. That is, of course, only if that is enough. Typically, that leads to
    adding half of the current capacity or more to the number of possible elements.
    Naturally, all existing elements are (shallow) copied to the new array before
    disposing of the original memory. In code, it looks as follows (from OpenJDK 8,
    class `ArrayList`, lines 237 to 247; new lines added for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code has a fascinating simplicity, and it's used by billions of programs
    worldwide, and the implementation of this book's dynamic array will use the same
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the product team has another feature request. Users liked the going-back-and-forth
    feature a lot, so they want to save a few noteworthy timestamps in a separate
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Often, these kinds of requirements send developers straight to a hash table
    or dictionary type. However, these usually do not retain the order of the items
    that were inserted and, if iteration is a primary concern, they are perhaps not
    the most efficient way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Favorite transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To clean up the product team''s demands, here is a list of the required features:'
  prefs: []
  type: TYPE_NORMAL
- en: Save a transaction's timestamp in a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access the elements quickly by index, in any order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate the items in the order they were saved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dynamic array utilizes an expanding array underneath and works really quickly,
    for accessing indices directly while still supporting iteration—great for saving
    a numbered list of noteworthy timestamps. The direct index access provides a way
    to fetch the stored data without having to go through the entire list, and since
    transaction timestamps are basically `u64` numbers (milliseconds), the data structure
    can be a dynamic array of multiple `u64`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than previous lists, this time, a node only stores data and can therefore
    be a type alias as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Making the node an `Option` type is necessary, since the capacity and actual
    length of the internal slice may differ—which means that an "empty" marker is
    needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Once the node type is declared, it can be used inside the new list's internal
    buffer. This construct is called a **boxed slice** (see the following section)
    and stores nodes in an array-like fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Internal arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are defined as data structures that have a known size at compile time.
    Rust takes this very seriously, and the array constructor will only take constants
    to denominate size in an array. `[0u8; 4]` will work, but `let my_array_size =
    2 * 2; [0u8; my_array_size]` won't.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do you dynamically reallocate a new array then? In Rust, there is also
    something called `slices`, which are views into a sequence data structure, akin
    to an array. These are a great fit when stored inside a `Box` pointer: allocated
    on the heap, it has all the benefits of an array with a dynamic size.'
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, this implementation goes with Java's `ArrayList` growth
    strategy and increases its size by at least 50% each time more capacity is required.
    While this has the unfortunate effect of exponential growth, it has worked for
    Java—a *very* popular language—for decades.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rust implementation is close to its Java pendant; in fact, only the oversized
    variety is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You will quickly see that the `vec![]` macro has been used—"*why is that?*"
    you might ask. Unfortunately, there is no great and safe way outside the `vec![]`
    macro to allocate this boxed slice. This use of the macro, however, allows to
    create an empty vector with the appropriate size and convert it into a boxed slice—a
    slice stored in a `Box`. This slice can afterward clone data from the previous
    slice.
  prefs: []
  type: TYPE_NORMAL
- en: This code works well up to the length of `usize`, which depends on the platform
    the program has been compiled for.
  prefs: []
  type: TYPE_NORMAL
- en: Quick access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Due to the underlying slice, accessing an index is cheap. In fact, it always
    takes the same amount of time, regardless of the index (which makes it different
    to previously discussed lists). A call to the `at()` function will therefore simply
    forward it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, again, the Rust implementation has to deal with sharing borrowed content
    or clone the data structure which might require more memory. Under the hood, a
    `u64` is implicitly cloned.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fulfill all requirements, the `Iterator` trait has to be implemented as
    well. Unlike the doubly linked list, the iterator cannot store a single node and
    go forward or backward from there. It has to store a pointer to the entire list,
    along with the current index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This `struct` makes the implementation already obvious. Move the current pointer
    back and forth as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple and clear iterator: no unpacking, explicit borrowing, and
    so on, just a simple counter that is incremented or decremented as it moves through
    the list.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dynamic array is a very flexible way of using array-like structures as a
    list—and it's surprisingly easy to implement and use. In fact, adding other features
    (`prepend`, insert at a specified position, and so on) is only a matter of a few
    lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Rust, the difference from the other list types is the clearly defined hierarchical
    ownership: the list `struct` owns the internal structure, which in turn owns the
    data in its elements. There are no links among the elements that could create
    ambiguity in who owns what, making the dynamic array a great example for how productive
    Rust code can be.'
  prefs: []
  type: TYPE_NORMAL
- en: Upsides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other than it being only a few lines of code, the dynamic array has quite a
    few upsides:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Speed: arrays/slices make things really fast'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple and fast element access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear ownership structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast append and iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very CPU cache-friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One thing is clear: it''s fast in many cases. When is the dynamic array not
    the best choice, though?'
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, this type of list is also quite memory-inefficient, and its rigid
    structure can be a downside as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Operations other than append will require to shift elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Growth strategy is not memory-efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single large chunk of memory is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size is limited by `usize` type, which differs from platform to platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Growth speed decreases with list size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes this journey into the realm of lists, hopefully in a successful
    manner. Before the next chapter begins, a quick summary highlights all the important
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are everywhere! While this is true, it's a fact that makes everything
    harder. Which list is the right tool for the job? How well will it do at certain
    sizes to add and later find elements? What's the overhead if my payload size is
    really small?
  prefs: []
  type: TYPE_NORMAL
- en: 'These are all questions that programmers are faced with today, and the author
    hopes to provide some guidance on these decisions. To recap: the least complex
    is the singly linked list, upon which the doubly linked list is built. Skip lists
    are in essence multilayered singly linked lists that provide excellent search
    performance at the cost of memory overhead. Last, but not least, there is the
    dynamic array—a type of list that wraps and manages an array for storing data
    just like a list.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing these structures in Rust requires many pointers to the heap, especially
    `Rc` and `RefCells`, which were companions from the beginning to the end of the
    chapter. When you consider the structure of a singly linked list, each item required
    access to the next—but with a predictable size. This fact requires programmers
    to work with references, but how would this work if the list gets passed around
    the program, possibly living on the heap itself? The consequence is to simplify
    things and put them on to the heap from the beginning and use an interior mutable
    `Rc` and `RefCell` construct to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, is the doubly linked list. Other than the forward (next) pointer
    that the singly linked sibling provides, a doubly linked node has to point backward
    as well. Therefore, each item has two pointers in addition to the payload, enabling
    a set of powerful features such as instant list reversal.
  prefs: []
  type: TYPE_NORMAL
- en: Skip lists, on the other hand, have been implemented as singly linked lists
    in this chapter (but certainly can be doubly linked as well). Their main improvement
    is the great ability to search the contained data quickly—just like a binary search
    tree. This means that, almost regardless of the size, the look-up performance
    is vastly better than that of a regular list, both in absolute and relative terms.
    Unfortunately, this comes at the cost of many more pointers per node.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular data structure is probably the dynamic array. Often dubbed
    `Vec<T>` (Rust), `ArrayList` (Java), `List<T>` (C#), or simply `list()` (Python),
    these are wrappers around an array that is allocated and reallocated intelligently
    as required. By doing this, they can accommodate the need for fast element access
    and quick iteration at the cost of a shallow copy on resize, as well as having
    a large chunk of memory available. These are the best choice for storing a limited
    amount of small- to medium-sized items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter is going to delve deeper into less linear data structures:
    trees. These constructs provide interesting capabilities by the way they are built
    and are a great choice for read-heavy undertakings.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is a linked list tricky to implement in Rust?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does Rust's standard library `LinkedList` work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between a doubly linked list and a skip list?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does a dynamic array outperform a skip list for element access?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is a dynamic array a great choice for CPU caching?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is another growth strategy for dynamic arrays?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust takes arrays seriously, so what does the dynamic array use internally?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning Rust With Entirely Too Many Linked Lists* ([http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html](http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `Iterator` trait ([https://doc.rust-lang.org/std/iter/index.html#implementing-iterator](https://doc.rust-lang.org/std/iter/index.html#implementing-iterator))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Skip Lists: Done Right* ([https://doc.rust-lang.org/std/iter/index.html#implementing-iterator](https://doc.rust-lang.org/std/iter/index.html#implementing-iterator))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Skip Lists: A Probabilistic Alternative to Balanced Trees*, William Pugh ([https://www.epaperpress.com/sortsearch/download/skiplist.pdf](https://www.epaperpress.com/sortsearch/download/skiplist.pdf))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
