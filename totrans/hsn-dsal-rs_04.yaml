- en: Lists, Lists, and More Lists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表，列表，还有更多列表
- en: 'Lists are everywhere: shopping lists, to-do lists, recipes, street numbers
    in western countries... simply everywhere. Their defining characteristic, storing
    things in a linear, defined relationship with each other, helps us keep track
    of stuff and find it again later on. From a data structure perspective, they are
    also essential to almost any program and come in various shapes and forms. While
    some lists are tricky to implement in Rust, the general principles can be found
    here as well, along with some valuable lessons on the borrow checker! After this
    chapter, we want you to know more about the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 列表无处不在：购物清单、待办事项清单、食谱、西方国家街道号码……简而言之，无处不在。它们的定义特征，以线性、定义好的关系存储事物，帮助我们跟踪物品并在以后找到它们。从数据结构的角度来看，它们对于几乎任何程序都是必不可少的，并且以各种形状和形式出现。虽然某些列表在Rust中实现起来可能很棘手，但一般原则也可以在这里找到，还有一些关于借用检查器的宝贵经验教训！在本章之后，我们希望你知道更多关于以下内容：
- en: (Doubly) linked lists and when you should use them
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （双链）列表以及何时使用它们
- en: Array lists, better known as Rust's vector
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组列表，也称为Rust的向量
- en: Skip lists and, ideally, the New York metro subway system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳表，以及理想情况下纽约地铁系统
- en: Implementing a simple transaction log
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个简单的交易日志
- en: As a final note, this chapter will build *safe* implementations of various lists,
    even though unsafe versions could be faster and require less code. This decision
    is due to the fact that, when working on regular use cases, unsafe is almost never
    a solution. Check out the links in the *Further reading* section of this chapter
    for unsafe lists.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的注意事项，本章将构建各种列表的安全实现，尽管不安全的版本可能更快且代码更少。这个决定是因为，在处理常规用例时，不安全几乎从未是解决方案。查看本章“进一步阅读”部分的链接，了解不安全列表。
- en: Linked lists
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表
- en: 'To keep track of a bunch of items, there is a simple solution: with each entry
    in the list, store a pointer to the next entry. If there is no next item, store
    `null`/`nil`/`None` and so on, and keep a pointer to the first item. This is called
    a **singly linked list**, where each item is connected with a single link to the
    next, as shown in the following diagram—but you already knew that:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪一堆物品，有一个简单的解决方案：在列表中的每个条目中，存储一个指向下一个条目的指针。如果没有下一个项目，则存储`null`/`nil`/`None`等，并保持对第一个项目的指针。这被称为**单链表**，其中每个项目通过单个链接与下一个项目连接，如下面的图所示——但你已经知道了：
- en: '![](img/73e264f8-1621-4095-9d02-fb0a5645e62b.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73e264f8-1621-4095-9d02-fb0a5645e62b.png)'
- en: What are the real use cases for a linked list though? Doesn't everyone just
    use a dynamic array for everything?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么链表的真实用例是什么？难道每个人不都是用动态数组来处理所有事情吗？
- en: 'Consider a transaction log, a typical append-only structure. Any new command
    (such as a SQL statement) is simply appended to the existing chain and is eventually
    written to a persistent storage. Thus, the initial requirements are simple:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个事务日志，这是一个典型的只追加结构。任何新的命令（如SQL语句）都简单地追加到现有链中，并最终写入持久存储。因此，初始要求很简单：
- en: Append a command to an existing list
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向现有列表中添加命令
- en: Replay every command from the beginning to the end—in that order
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头到尾按顺序重放每个命令
- en: In other words, its a queue (or **LIFO**—short for **Last In First Out**) structure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它是一个队列（或**LIFO**——即**后进先出**）结构。
- en: A transaction log
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务日志
- en: First, a list has to be defined—in Rust, lacking a `null` type, each item is
    chained to the next by an `Option` property. The `Option` instances are enumerations
    that wrap either the value, in this case a heap reference (such as a `Box`, `Rc`,
    and so on), or none—Rust's typed `null` equivalent. Why? Let's find out!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须定义一个列表——在Rust中，由于缺少`null`类型，每个项目通过一个`Option`属性链接到下一个。`Option`实例是封装值（在这种情况下是一个堆引用，如`Box`、`Rc`等）或无值的枚举。为什么？让我们来看看！
- en: Creating a prototypical implementation to explore a certain aspect is always
    a good idea, especially since the compiler often provides excellent feedback.
    Accordingly, an implementation of an integer list is the first step. How about
    this `struct` for each list element?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个典型实现以探索某个方面始终是一个好主意，特别是编译器经常提供出色的反馈。因此，整数列表的实现是第一步。每个列表元素的这个`struct`怎么样？
- en: 'Have a look at the following code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码片段：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For practical considerations, it needs a way to know where to start and the
    length of the list. Considering the planned `append` operation, a reference to
    the end (tail) would be useful too:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际考虑，它需要一个知道从哪里开始以及列表长度的方法。考虑到计划的`append`操作，一个指向末尾（尾部）的引用也会很有用：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That looks great! Does it work though?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒！但它真的工作吗？
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Unfortunately, it doesn''t work—and, thinking back to the previous chapters,
    it becomes clear why: the compiler cannot be certain of the data structure''s
    size, since the entire list would have to be nested into the first element. However,
    as we know, the compiler cannot compute and therefore allocate the required amount
    of memory this way—which is why reference types are required.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它不起作用——回想一下前面的章节，原因变得很清楚：编译器无法确定数据结构的大小，因为整个列表必须嵌套在第一个元素中。然而，正如我们所知，编译器无法以这种方式计算并因此分配所需的内存量——这就是为什么需要引用类型的原因。
- en: 'Reference types (such as `Box`, `Rc`, and so on) are a good fit, since they
    allocate space on the heap and therefore allow for larger lists. Here''s an updated
    version:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型（如`Box`、`Rc`等）非常适合，因为它们在堆上分配空间，因此允许更大的列表。这是一个更新后的版本：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Storing each node item in a `Rc<RefCell<T>>` provides the ability to retrieve
    and replace data as needed (the internal mutability pattern)—crucial when executing
    operations on the list. Another good practice is to alias types, especially if
    there are a lot of generics in play. This makes it easy to replace type implementations
    and provides a more readable definition:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个节点项存储在`Rc<RefCell<T>>`中提供了按需检索和替换数据的能力（内部可变性模式）——在执行列表操作时至关重要。另一个好的做法是别名类型，特别是如果有许多泛型。这使得替换类型实现变得容易，并提供了更易读的定义：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Perfect! This is the base definition of the transaction log, but to use it
    there are many things missing. First of all, the value type has to be `String`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！这是事务日志的基本定义，但为了使用它，还有很多事情要做。首先，值类型必须是`String`：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In addition to that, it is going to be useful to create an empty list, so the
    `impl` block of the list has a single function for now—`new_empty()`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了那个，创建一个空列表将很有用，因此列表的`impl`块目前只有一个函数——`new_empty()`：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Still, there is a lot missing. To recap, the transaction log has two requirements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有很多事情要做。为了总结，事务日志有两个要求：
- en: '`Append` entries at the end'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在末尾添加条目
- en: '`Remove` entries from the front'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从前面删除条目
- en: 'Let''s start with the first requirement: appending items to the back of the
    list!'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个要求开始：向列表的末尾添加项目！
- en: Adding entries
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加条目
- en: The transaction log can now be created and hold entries, but there is no way
    to add anything to the list. Typically, a list has the ability to add elements
    to either end—as long as there is a pointer to that end. If that was not the case,
    any operation would become computationally expensive, since every item has to
    be looked at to find its successor. With a pointer to the end (tail) of the list,
    this won't be the case for the append operation; however, to access a random index
    on the list, it would require some time to go through everything.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 事务日志现在可以创建并保存条目，但无法向列表中添加任何内容。通常，列表具有将元素添加到任一端的能力——只要有一个指向该端点的指针。如果情况不是这样，任何操作都会变得计算成本高昂，因为必须查看每个项目以找到其后续者。有了列表末尾（尾部）的指针，这种情况就不会发生在追加操作中；然而，要访问列表上的随机索引，可能需要花费一些时间来遍历所有内容。
- en: Naming is—especially if English is your second language—often tricky. Operations
    have different names by the language or library used. For example, common names
    for adding items to a list include `push` (can add to the front or back), `push_back`,
    `add`, `insert` (usually comes with a positional parameter), or `append`*.* On
    top of being able to guess method names, some imply completely different processes
    than others! If you design an interface or library, find the most descriptive
    and simple name possible and reuse whenever you can!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命名——尤其是如果你英语是第二语言——通常很棘手。操作在不同的语言或库中有不同的名称。例如，向列表添加项目的常见名称包括`push`（可以添加到前面或后面）、`push_back`、`add`、`insert`（通常带有位置参数）或`append`*.*
    除了能够猜测方法名称外，一些名称暗示了与其他名称完全不同的过程！如果你设计接口或库，找到最描述性和最简单的名称，并在可能的情况下重复使用！
- en: 'This is one of the things that a linked list does really well—adding items
    to either end. There are a few critical things that should not be overlooked,
    though:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是链表做得非常好的事情之一——在任一端添加项目。尽管如此，还有一些关键事项不应被忽视：
- en: Creating the `Node` object within the method makes for a nicer API and better
    ownership handling.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法内创建 `Node` 对象使得 API 更好，并且更好地处理所有权。
- en: Edge cases such as empty lists.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界情况，例如空列表。
- en: Incrementing the length is a good idea.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加长度是一个好主意。
- en: The `RefCell` is used to retrieve mutable ownership for setting a new successor
    using its `borrow_mut()` function (interior mutability).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `RefCell` 的 `borrow_mut()` 函数（内部可变性）来获取可变所有权，以便使用它设置新的后继者。
- en: 'Once that is thought of, the actual implementation is not too bad. Rust''s
    `Option` type offers a method to retrieve ownership of a value it contains, replacing
    it with `None` (see also the documentations for `Option.take()`—[https://doc.rust-lang.org/std/option/enum.Option.html#method.take](https://doc.rust-lang.org/std/option/enum.Option.html#method.take)
    and `mem::replace()`—[https://doc.rust-lang.org/stable/std/mem/fn.replace.html](https://doc.rust-lang.org/stable/std/mem/fn.replace.html)),
    which conveniently shortens the code required to append a new node:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦考虑到这一点，实际的实现并不太糟糕。Rust 的 `Option` 类型提供了一个方法来检索它包含的值的所有权，并用 `None` 替换它（参见 `Option.take()`
    的文档——[https://doc.rust-lang.org/std/option/enum.Option.html#method.take](https://doc.rust-lang.org/std/option/enum.Option.html#method.take)
    和 `mem::replace()`——[https://doc.rust-lang.org/stable/std/mem/fn.replace.html](https://doc.rust-lang.org/stable/std/mem/fn.replace.html)），这方便地缩短了添加新节点所需的代码：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With that, it''s now possible to create a log of any string commands passing
    through. However, there is something important missing here as well: log replay.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，现在可以创建任何字符串命令通过日志。然而，这里也缺少一个重要的东西：日志回放。
- en: Log replay
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志回放
- en: 'Typically in databases, transaction logs are a resilience measure if something
    bad happens that the database must be restored—or to keep a replica up to date.
    The principle is fairly simple: the log represents a timeline of commands that
    have been executed in this exact order. Thus, to recreate that final state of
    a database, it is necessary to start with the oldest entry and apply every transaction
    that follows in that very order.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在数据库中，事务日志是在发生数据库必须恢复的糟糕情况下的一个弹性措施，或者为了保持副本更新。原理相当简单：日志代表了一系列按此顺序执行的命令。因此，为了重新创建数据库的最终状态，必须从最旧的条目开始，并按此顺序应用后续的每个事务。
- en: You may have caught how that fits the capabilities of a linked list nicely.
    So, what is missing from the current implementation?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这很好地符合了链表的功能。那么，当前实现中缺少了什么？
- en: The ability to remove elements starting at the front.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从前面开始删除元素。
- en: Since the entire data structure resembles a queue, this function is going to
    be called `pop`, as it's the typical name for this kind of operation. Additionally,
    `pop` will consume the item that was returned, making the list a single-use structure.
    This makes sense, to avoid replaying anything twice!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个数据结构类似于队列，这个函数将被命名为 `pop`，因为这是此类操作的典型名称。此外，`pop` 将消耗返回的项目，使列表成为单次使用的结构。这很有意义，可以避免重复播放任何内容！
- en: 'This looks a lot more complex than it is: the interior mutability pattern certainly
    adds complexity to the implementation. However, it makes the whole thing safe—thanks
    to `RefCells` checking borrowing rules at runtime. This also leads to the chain
    of functions in the last part—it retrieves the value from within its wrappers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来比实际要复杂得多：内部可变性模式确实增加了实现的复杂性。然而，它使整个实现变得安全——多亏了 `RefCells` 在运行时检查借用规则。这也导致了最后一部分的函数链——它从其包装器中检索值：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Calling this function in sequence returns the commands in the order they were
    inserted, providing a nice replay feature. For a real-world usage, it's important
    to provide the ability to serialize this state to disk as well, especially since
    this operation consumes the list entirely. Additionally, handling errors gracefully
    (instead of panicking and crashing) is recommended.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序调用此函数返回插入的命令顺序，提供了一种很好的回放功能。对于实际应用，提供将此状态序列化到磁盘的能力也很重要，特别是由于此操作完全消耗了列表。此外，优雅地处理错误（而不是恐慌和崩溃）也是推荐的。
- en: After use
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用后
- en: Whenever the list needs to be disposed of, Rust calls a `drop()` method that
    is automatically implemented. However, since this is an automated process, each
    member is dropped recursively—which works OK until the level of nested `next`
    pointers exceeds the stack for executing the `drop()` method and crashes the program
    with an unexpected stack overflow message.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时需要销毁列表，Rust 都会调用一个自动实现的 `drop()` 方法。然而，由于这是一个自动化的过程，每个成员都会递归地被销毁——直到嵌套的
    `next` 指针级别超过执行 `drop()` 方法的栈，导致程序因意外栈溢出信息而崩溃。
- en: As a consequence, it is a good idea for production usage to also implement the
    `Drop` trait and dispose of the list elements iteratively. By the way, a stack
    overflow also happens while using the derived `Debug` implementation to print
    a `Node`—for the same reason.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于生产使用，最好也实现 `Drop` 特性，并迭代地销毁列表元素。顺便说一下，在使用派生的 `Debug` 实现打印 `Node` 时也会发生栈溢出——原因相同。
- en: Wrap up
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'A (transaction) log is a great use case for a linked list: They often grow
    to unexpected sizes, and indexing is not required. While a linked list is often
    a very simple type in other languages, it harbors a surprising amount of challenges
    in Rust. This is mostly due to the borrowing and ownership concepts which require
    a programmer to think about what goes where in great detail. For real-world use
    cases, however, it''s better to use Rust''s standard library linked list (`std::collections::LinkedList`).
    From a performance perspective, finding a particular item in the singly linked
    list requires looking at the entire list in the worst case, resulting in a runtime
    complexity of `O(n)`, with `n` being the number of items in the list (more on
    the topic of runtime complexity in [Chapter 8](6ab96dc6-b8f5-4c03-88a3-f4a345f8cc9b.xhtml),
    *Algorithm Evaluation*).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 日志（事务）是链表的一个很好的用例：它们通常会增长到意外的尺寸，且不需要索引。虽然在其他语言中链表通常是一个非常简单的类型，但在 Rust 中它却隐藏着大量的挑战。这主要归因于借用和所有权概念，这些概念要求程序员详细考虑数据应该放在哪里。然而，对于实际应用场景，最好使用
    Rust 的标准库链表 (`std::collections::LinkedList`)。从性能角度来看，在最坏的情况下，在单链表中查找特定项目需要查看整个列表，导致运行时复杂度为
    `O(n)`，其中 `n` 是列表中的项目数量（关于运行时复杂性的更多内容请参阅第 8 章，*算法评估*）。
- en: Upsides
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: The main benefits of a linked list are the abilities to grow very large in size
    cheaply, always maintain a certain direction, and allow to access items individually.
    What makes this data structure unique?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 链表的主要优点是能够以低廉的成本增长到非常大的尺寸，始终保持一定的方向，并允许单独访问项目。是什么使得这种数据结构独一无二？
- en: 'There are a few points:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个要点：
- en: Low overhead allocation per item.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目的开销分配较低。
- en: Item count is only limited by heap memory.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目数量仅受堆内存限制。
- en: Mutation while iterating is possible.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代时可以进行修改。
- en: A direction is strictly enforced—there is no going back.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方向是严格强制执行的——不能回头。
- en: Implementation is fairly simple (even in Rust).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现相当简单（即使在 Rust 中也是如此）。
- en: Efficient append, prepend, delete, and insert operations—compared to an array
    (no shifting required).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的追加、预追加、删除和插入操作——与数组相比（不需要移动）。
- en: Generally, the linked list performs well in an environment where limited memory
    does not allow overhead allocation (as dynamic arrays do), or as a basis for an
    exotic lock-free data structure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在有限内存不允许开销分配的环境（如动态数组）或作为异构无锁数据结构的基础时，链表表现良好。
- en: Downsides
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'The linked list has some obvious shortcomings:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 链表有一些明显的缺点：
- en: Indexing is inefficient, since every node has to be looked at.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引效率低下，因为必须查看每个节点。
- en: Iteration in general involves a lot of jumping around on the heap, which takes
    more time and makes the operation hard to cache.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代通常涉及在堆上进行大量的跳跃，这需要更多的时间，并使得操作难以缓存。
- en: Reversing a list is *very* inefficient.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转列表非常低效。
- en: The last point is important, so, commonly, a linked-list implementation will
    have a link back as well, which makes it a doubly linked list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点很重要，因此，通常链表实现还会有一个回链，使其成为双向链表。
- en: Doubly linked list
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: The transaction log of the previous section is due for an upgrade. The product
    team wants to enable users to be able to examine the log by going through it **forward**
    **and** **backward** to see what each step does. This is bad news for the regular
    linked list, as it's really inefficient to go anywhere other than forward. So,
    how is this rectified?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的事务日志需要升级。产品团队希望用户能够通过向前和向后查看每个步骤做了什么来检查日志。这对常规链表来说是个坏消息，因为它在除了向前之外的地方效率非常低。那么，这是如何纠正的呢？
- en: 'It is rectified using the doubly linked list. The doubly linked list introduces
    the link `back`. While this sounds like a minor change, it allows to work on that
    list backward as well as forward, which significantly improves the ability to
    look up items. By augmenting the previous singly linked list item with a back
    pointer, the doubly linked list is almost created:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过双向链表来纠正的。双向链表引入了`back`链接。虽然这听起来像是一个微小的变化，但它允许向后以及向前工作在该列表上，这显著提高了查找项的能力。通过在先前的单链表项中增加一个反向指针，几乎就创建了一个双向链表：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similar to the singly linked list, the list itself only consists of a head
    and a tail pointer, which makes accessing either end of the list cheap and easy.
    Additionally, the nodes now also feature a pointer back to the preceding node,
    making the list look like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与单链表类似，列表本身只包含一个头指针和一个尾指针，这使得访问列表的任一端既便宜又容易。此外，节点现在也包含一个指向前一个节点的指针，使得列表看起来像这样：
- en: '![](img/30cde807-16c5-4e6a-8009-5967d7449cc4.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30cde807-16c5-4e6a-8009-5967d7449cc4.png)'
- en: 'This is also the point that makes the doubly linked list tricky in Rust. The
    ownership principle is great if there is a hierarchy of ownership: a customer
    has an address, a text file has several lines of text, and so on. However, a node
    in a doubly linked list doesn''t have clear ownership of either of its neighbors.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是使Rust中的双向链表变得棘手的地方。如果存在所有权的层次结构，所有权原则是很好的：客户有一个地址，文本文件有几行文本，等等。然而，双向链表中的节点对其邻居的任何一方都没有明确的所有权。
- en: A better transaction log
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的事务日志
- en: 'So, the list of requirements got expanded:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需求列表得到了扩展：
- en: Move forward through the log
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向前移动通过日志
- en: Move backward through the log
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后移动通过日志
- en: Moves don't consume the log
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动不会消耗日志
- en: A nice fit for the doubly linked list, so the existing transaction log can be
    upgraded! With the pointers to both neighbors of a node, it can solve the problem.
    However, what about moving through the list without removing elements?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双向链表来说，这是一个很好的匹配，因此现有的事务日志可以进行升级！有了对节点两个邻居的指针，它可以解决这个问题。然而，在不删除元素的情况下移动列表怎么办呢？
- en: 'For that, another concept is required: **iterators**. Rust''s iterators are
    leaning on the functional side of programming and provide a versatile interface
    for integrating with all kinds of other data structures and commands across the
    language. For example, `for` loops will pick up on the iterator and behave as
    expected.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，需要另一个概念：**迭代器**。Rust的迭代器依赖于编程的函数式方面，并为与语言中所有其他数据结构和命令的集成提供了一个灵活的接口。例如，`for`循环将检测迭代器并按预期行为。
- en: '**Iterators** are pointers to the current item with a method called `next()`
    that produces the next item while moving the pointer forward! This concept is
    applied a lot when using a more functional approach to working with collections:
    by chaining them together and applying a function after invoking `next()`, going
    through a list can be very efficient. Check the *Further reading* section and
    the last chapter of this book for more information!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器**是指向当前项的指针，有一个名为`next()`的方法，该方法在移动指针的同时产生下一个项！当使用更函数式的方法处理集合时，这个概念被大量应用：通过将它们链接在一起并在调用`next()`之后应用一个函数，遍历列表可以非常高效。请参阅*进一步阅读*部分和本书的最后一章以获取更多信息！'
- en: The data model is going to look like the singly linked list, so most of the
    operations can be used as they are—they only need to be upgraded to work with
    the back-pointer as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型将看起来像单链表，因此大多数操作都可以直接使用——它们只需要升级以支持反向指针。
- en: Examining the log
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查日志
- en: Looking at the list without consuming it is an iterator's job (see the info
    box), which—in Rust as well as in most other languages—is a simple implementation
    of an interface or trait. In fact, this is so common that the Rust docs have a
    great article ([https://doc.rust-lang.org/std/iter/index.html#implementing-iterator](https://doc.rust-lang.org/std/iter/index.html#implementing-iterator)),
    which is exactly what's required.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 查看列表而不消耗它是迭代器的任务（见信息框），这在Rust以及大多数其他语言中都是一个简单的接口或特性的实现。事实上，这是如此常见，以至于Rust文档有一个非常好的文章([https://doc.rust-lang.org/std/iter/index.html#implementing-iterator](https://doc.rust-lang.org/std/iter/index.html#implementing-iterator))，这正是所需的。
- en: 'Since we are already working with heap references, the iterator can simply
    save an optional reference to a node and it''s easy to move it forward and backward:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在处理堆引用，迭代器可以简单地保存一个可选的节点引用，并且很容易向前和向后移动：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As the documentation states, a `for` loop uses two traits: `Iterator` and `IntoIterator`.
    Implementing the former is usually a good idea, as it provides access to the powerful
    methods in `Iterator`, such as `map`, `fold`, and so on, and nicely chains together
    with other—compatible—iterators:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档所述，`for`循环使用两个特性：`Iterator`和`IntoIterator`。实现前者通常是一个好主意，因为它提供了对`Iterator`中强大方法的访问，如`map`、`fold`等，并且与其他——兼容的——迭代器很好地链接在一起：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This iterator is responsible for moving one direction: forward. How can we
    walk back too?'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代器负责移动一个方向：向前。我们如何走回头路呢？
- en: Reverse
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转
- en: Now, since the requirement was also to go back, the iterator needs to go both
    ways. One easy way is to simply add a function to the structure that is called
    `reverse()`, but that would not integrate well and would require developers to
    read up on this API, and it creates additional work, since the forward/backward
    iterators are separate.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于要求也包括向后移动，迭代器需要双向移动。一种简单的方法是简单地向结构体中添加一个名为`reverse()`的函数，但这不会很好地集成，并且需要开发者阅读这个API，并且它还增加了额外的工作，因为向前/向后迭代器是分开的。
- en: 'Rust''s standard library offers an interesting concept for this: `DoubleEndedIterator`.
    Implementing this trait will provide the ability to reverse an iterator in a standardized
    way by offering a `next_back()` function to get the previous value—with the doubly
    linked list, this is only a matter of which property gets set to the current item!
    Therefore, both iterators share a large chunk of the code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的标准库为此提供了一个有趣的概念：`DoubleEndedIterator`。实现这个特性将提供以标准化的方式反转迭代器的能力，通过提供一个`next_back()`函数来获取前一个值——对于双向链表来说，这只是一个将哪个属性设置为当前项的问题！因此，这两个迭代器共享大量代码：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this in place, an iterator can be created by calling the `iter()` function
    on the list type, and by calling `iter().rev()`, the iterator will be reversed,
    providing the ability to go back as well as forward.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，可以通过在列表类型上调用`iter()`函数来创建迭代器，通过调用`iter().rev()`，迭代器将被反转，提供向前和向后的能力。
- en: Wrap up
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Doubly linked lists are in many cases improved versions (and the default) over
    regular linked lists, thanks to the better flexibility at the cost of a single
    pointer per node and slightly more complex operations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表在很多情况下是普通链表的改进版本（也是默认版本），这得益于每个节点只需一个指针和稍微复杂一些的操作带来的更好的灵活性。
- en: In particular, by keeping the code safe (in Rust terms, so no `unsafe {}` was
    used), the code gets riddled with `RefCells` and `borrow()` to create a data structure
    that the borrow checker is auditing at runtime. Looking at the Rust source code
    for `LinkedList`, this is not the case there (more on that in [Chapter 7](ba6dfa3b-1b5c-4033-a641-da15b9adb390.xhtml),
    *Collections in Rust*). The basic structure is similar, but the operations use
    a bunch of unsafe code underneath—something that requires a good experience writing
    Rust.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是通过保持代码的安全性（在Rust术语中，即没有使用`unsafe {}`），代码中充满了`RefCells`和`borrow()`来创建一个在运行时由借用检查器审计的数据结构。查看Rust的`LinkedList`源代码，情况并非如此（更多内容请参阅[第7章](ba6dfa3b-1b5c-4033-a641-da15b9adb390.xhtml)，*Rust中的集合*)。基本结构是相似的，但操作在底层使用了一堆不安全的代码——这需要良好的Rust编写经验。
- en: '`PhantomData<T>` is a zero-size type that informs the compiler about a range
    of things, such as drop behavior, sizes, and so on, when generics are involved.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhantomData<T>`是一个零大小的类型，当涉及泛型时，它向编译器传达有关一系列事情的信息，例如释放行为、大小等。'
- en: 'As a quick preview, here is the Rust standard library''s `LinkedList<T>` definition
    and implementation. It''s a doubly linked list! Additionally, the `push_front_node`
    (`prepend`) function shows the use of an unsafe area to speed up inserts. For
    more information on that, check out the link to the online book *Learning Rust
    With Entirely Too Many Linked Lists* in the *Fu**rther reading* section at the
    end of the chapter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速预览，这里提供了Rust标准库的`LinkedList<T>`定义和实现。它是一个双链表！此外，`push_front_node`（`prepend`）函数展示了如何使用不安全区域来加速插入。有关更多信息，请查看章节末尾的“进一步阅读”部分中链接到在线书籍《用大量链表学习Rust》：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Whatever the implementation, there are general upsides and downsides to the
    doubly linked list.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 无论实现方式如何，双链表都有其普遍的优缺点。
- en: Upsides
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'As a linked list, the principles are the same but slightly different. However,
    the major points of when the list is a good choice are shared with the singly
    linked list:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为链表，原理相同但略有不同。然而，当列表是一个好选择的主要观点与单链表是共享的：
- en: Low overhead allocation per item (but more than the singly linked list).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目的开销较低（但比单链表多）。
- en: Item count is only limited by heap memory.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目计数仅受堆内存的限制。
- en: Mutation while iterating is possible.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代时的变异是可能的。
- en: Implementation is more complex but still fairly simple.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现起来更复杂，但仍然相当简单。
- en: Inserts, deletes, append, and prepend remain efficient.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入、删除、追加和预追加仍然高效。
- en: Efficient reversion.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的反向。
- en: This makes the doubly linked list a superior version of the two versions of
    linked lists, which is why it's usually the default `LinkedList` type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得双链表成为两种链表版本的优越版本，这也是为什么它通常是默认的`LinkedList`类型。
- en: Downsides
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'The doubly linked list shares a lot of the downsides of its less complex sibling
    and replaces the "no going back" with "more memory overhead" and "more complex
    implementation". Here''s the list again:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 双链表与其较简单的兄弟共享许多缺点，用“无法回头”替换为“更多内存开销”和“更复杂的实现”。以下是列表再次：
- en: Indexing is still inefficient.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引仍然效率低下。
- en: Nodes are also allocated on the heap, which requires a lot of jumping around
    too.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点也分配在堆上，这也需要大量的跳跃。
- en: An additional pointer has to be stored per node.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点必须存储一个额外的指针。
- en: Implementation is more complex.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现更复杂。
- en: 'Inefficient indexing and iteration is something that a lot of developers wanted
    to get rid of, so they invented a more exotic version of a linked list: the **skip
    list**.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不高效的索引和迭代是许多开发者想要摆脱的问题，因此他们发明了一种更奇特的链表版本：跳表。
- en: Skip lists
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳表
- en: A lot of people love New York—and so do we. It has many qualities that are hard
    to describe; it is a crazy (in a good way), lively city that brings together many
    cultures, backgrounds, ethnicities, activities, and opportunities. New York also
    features a large public transport network, almost like cities in Europe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人喜欢纽约——我们也是如此。它有许多难以描述的品质；它是一个疯狂（以好的方式）、充满活力的城市，汇集了许多文化、背景、种族、活动和机会。纽约还拥有庞大的公共交通网络，几乎像欧洲的城市一样。
- en: 'What does any of this have to do with skip lists? A subway system can be expressed
    as a simple list of stops (expressed in street numbers, a common thing in the
    USA): `14 -> 23 -> 28 -> 33 -> 42 -> 51 -> 59 -> 68` . However, the New York subway
    system has something called **express trains** which reduce the number of stops
    to cover larger distances faster.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切与跳表有什么关系？一个地铁系统可以表示为一个简单的站点列表（用街道号码表示，在美国很常见）：`14 -> 23 -> 28 -> 33 -> 42
    -> 51 -> 59 -> 68`。然而，纽约地铁系统有一种称为**快车**的东西，可以减少覆盖更大距离所需的站点数量。
- en: 'Suppose someone wants to go from stop 14 to stop 51\. Instead of seeing the
    doors open and close five times, they can go there getting off at the third stop.
    In fact, this is how New Yorkers use the trains 4, 5, and 6 between 14th Street
    (Union Square) and 51st Street. Turned on its side, the subway plan looks roughly
    like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有人想从第14站去第51站。他们不必看到车门打开和关闭五次，他们可以在第三个站点下车。实际上，这就是纽约人在14街（联合广场）和51街之间乘坐4、5和6号线的方式。将地铁线路图侧放，看起来大致如下：
- en: '![](img/a5ec37c0-2813-4ba9-83ec-91d5403cd129.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5ec37c0-2813-4ba9-83ec-91d5403cd129.png)'
- en: The local service trains stop at every stop along the way, but the express service
    trains skip certain smaller stops only to halt at shared stations where travelers
    can switch between the two. The skipping happens quite literally on some stops
    where trains simply drive through, sometimes confusing tourists and locals alike.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 地铁服务列车在沿途的每个站点都会停靠，但快车服务列车会跳过某些较小的站点，只在旅客可以在这两种服务之间换乘的共享站停靠。在某些站点，这种跳过实际上就是列车直接驶过，有时会同时让游客和当地人感到困惑。
- en: 'Expressed as a data structure, the list is essentially several lists, each
    at a different level. The lowest level contains *all* nodes, where the upper levels
    are their "express services" that can skip a number of nodes to get further ahead
    quicker. This results in a multilayered list, fused together only at certain nodes
    that have a connection on these particular levels:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 用数据结构表达，列表本质上是由几个列表组成的，每个列表位于不同的级别。最低级别包含*所有*节点，而上层级别是它们的“快车服务”，可以跳过一定数量的节点以更快地前进。这导致了一个多层列表，仅在具有这些特定级别连接的某些节点上融合在一起：
- en: '![](img/253f5e6f-35ff-49a9-9b48-793e20413e74.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/253f5e6f-35ff-49a9-9b48-793e20413e74.png)'
- en: Ideally, each level has half the number of nodes that the previous level has,
    which means that there needs to be a decision-making algorithm that can work with
    a growing list and still maintain this constraint. If this constraint is not kept,
    search times get worse, and in the worst-case scenario it's a regular linked list
    with a lot of overhead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每个级别的节点数是上一级别节点数的一半，这意味着需要一个能够处理增长列表并保持此约束的决策算法。如果不保持此约束，搜索时间会变差，在最坏的情况下，它就像一个带有大量开销的常规链表。
- en: 'A node''s level is decided using a probabilistic approach: increment the level
    as long as a coin flip comes out on the same side. While this produces the desired
    distribution, that''s only meaningful if the higher-level nodes are evenly distributed.
    There are a few posts on improved versions in the *Further reading* section.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的级别是通过概率方法决定的：只要硬币翻转结果相同，就增加级别。虽然这产生了期望的分布，但这只有当高级节点均匀分布时才有意义。在*进一步阅读*部分有一些关于改进版本的帖子。
- en: 'In addition to that, the skip list has to be ordered to function properly.
    After all, if the elements of the list are in a random order, how would the list
    know what it is skipping? In general, however, a node type for this—basic—skip
    list looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，跳表必须是有序的才能正常工作。毕竟，如果列表的元素是无序的，列表如何知道它跳过了什么？然而，一般来说，这个——基本——跳表的节点类型看起来是这样的：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And to chain them together, a list type is also required:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将它们连接起来，还需要一种列表类型：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What stands out is that the `struct` is very similar to the previous lists.
    Indeed—the relationship is undeniable, since they share almost all the properties.
    However, there are two differences: the `tails` is a `Vec<Link>` and the `max_level`
    is a property of the list.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最引人注目的是，`struct`与之前的列表非常相似。确实如此——这种关系是无可否认的，因为它们几乎共享所有属性。然而，有两个区别：`tails`是一个`Vec<Link>`，而`max_level`是列表的一个属性。
- en: The `tails` property being a vector is due to the fact that every level will
    have a tail end, meaning that whenever an append occurs, all tails may need to
    be updated. Additionally, the developer is responsible for providing an appropriate
    `max_level` value, since changing `max_level` would result in constructing a new
    list!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`tails`属性是一个向量，是因为每个级别都会有一个尾部，这意味着每当发生追加操作时，所有尾部可能都需要更新。此外，开发者负责提供适当的`max_level`值，因为更改`max_level`会导致构建一个新的列表！'
- en: Going back to the previous example, the product team has requested more features!
    Users are confused by the lack of a clear direction in the list, and they are
    annoyed that there is no way to quickly skip the verbose but less-than-interesting
    parts in the beginning.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回到之前的例子，产品团队要求更多功能！用户对列表中缺乏明确的方向感到困惑，他们很烦恼没有快速跳过开头冗长但不太有趣部分的方法。
- en: 'As a consequence, the product team wants the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，产品团队希望以下内容：
- en: A time associated with the logged transaction
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与已记录的交易相关的时间
- en: To be able to quickly jump to an arbitrary time
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够快速跳转到任意时间
- en: To start iterating from there
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从那里开始迭代
- en: Doesn't this sound a lot like a skip list?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不像是一个跳表吗？
- en: The best transaction log
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳交易日志
- en: To improve the transaction log in the way the product team describes, it's a
    perfect fit for a skip list. How about ordering the commands by a `u32` number—a
    millisecond offset from the initial timestamp. The commands it contains are going
    to be stored as strings associated with the offset.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照产品团队描述的方式改进交易日志，跳表是一个完美的选择。按一个`u32`数字——从初始时间戳开始的毫秒偏移量——对命令进行排序怎么样？它包含的命令将被存储为与偏移量关联的字符串。
- en: Nevertheless, the list and its nodes need to be implemented.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，列表及其节点需要被实现。
- en: Compared to previous implementations (especially since the singly linked list
    is a close relative), there are two major differences in this declaration. Firstly,
    the next pointer is an array, which is due to the node having a different successor
    at every level.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的实现（尤其是单链表是一个紧密的亲戚）相比，这个声明有两个主要差异。首先，下一个指针是一个数组，这是由于节点在每一个级别都有一个不同的后继节点。
- en: 'Secondly, the content was previously named `value`, but to differentiate between
    the timestamp offset and the actual content, `value` has been replaced by `offset`
    and `command`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，内容之前被命名为`value`，但为了区分时间戳偏移和实际内容，`value`已被替换为`offset`和`command`：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These nodes form the basis of this—improved—transaction log. As previously,
    with the singly linked list, this is done by creating a type that has a head pointer.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点构成了这个——改进的——交易日志的基础。与单链表一样，这是通过创建一个具有头指针的类型来完成的。
- en: The list
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Other than a simple pointer to the head, the list best stores the length as
    well as the maximum level that elements can have. This user-supplied parameter
    is critical, since if it's chosen too low, searching will approximate the search
    performance of a singly linked list (`O(n)`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指向头部的简单指针外，列表最好还存储长度以及元素可以拥有的最大级别。这个用户提供的参数至关重要，因为如果它设置得太低，搜索将接近单链表的搜索性能（`O(n)`）。
- en: In contrast, choosing a maximum level that is too high will also result in an
    uneven distribution that could see as many vertical (levels down) as horizontal
    iterations (`O(n + h)` ), none of which are good. The Big O notation (`O(n)` and
    so on) will be discussed in [Chapter 8](6ab96dc6-b8f5-4c03-88a3-f4a345f8cc9b.xhtml),
    *Algorithm Evaluation*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，选择一个过高的最大级别也会导致分布不均，可能会看到与水平迭代（`O(n + h)`）一样多的垂直（向下级别）迭代，这些都不好。大O符号（`O(n)`等）将在[第8章](6ab96dc6-b8f5-4c03-88a3-f4a345f8cc9b.xhtml)
    *算法评估* 中讨论。
- en: 'Consequently, this parameter has to be set to somewhat reflect the future size
    of the list and the highest level only contains two or three nodes at most:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个参数需要设置得稍微反映列表未来的大小，并且最高级别最多只包含两个或三个节点：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `tails` property is a vector pointing to the tail of each level. When adding
    data, this is the primary place to update this transaction log, thanks to the
    append-only nature of our skip list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`tails`属性是一个指向每个级别尾部的向量。当添加数据时，这是更新这个交易日志的主要地方，多亏了我们的跳表只添加性质。'
- en: Adding data
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据
- en: 'Having the basic data structures ready, a function to insert data is required.
    As previously stated, a skip list can only work if the values are somehow comparable
    and follow an ascending order. This makes sense: skipping ahead is only useful
    if you know where you are going!'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数据结构准备就绪后，需要一个插入数据的功能。如前所述，跳表只能在某些值可以比较并按升序排列的情况下工作。这很有意义：跳过前进只有在你知道你要去哪里时才有用！
- en: A very efficient way to create a sorted list is by doing a **sorted insert**
    (sometimes called an **insertion** **sort**). Commonly, this would add some complexity
    to the insert logic to find the correct place for the node. However, since a timestamp
    is naturally ascending and a comparable value, this version of the transaction
    log works without a sophisticated insert, thereby requiring fewer tests and fewer
    headaches when reading it a year down the road.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有序列表的一个非常有效的方法是通过进行**排序插入**（有时称为**插入排序**）。通常，这会给插入逻辑增加一些复杂性，以找到节点正确的位置。然而，由于时间戳是自然升序的，并且是一个可比较的值，这个版本的交易日志无需复杂的插入即可工作，因此需要更少的测试，并且在一年后阅读时更少头痛。
- en: 'In fact, this means reusing some code from earlier sections is entirely possible:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这意味着可以重用早期部分的一些代码：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Yet, there is an important addition: deciding on the level a node should (also)
    be present at. This is what makes the list powerful and is done just before the
    node is created:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个重要的补充：决定一个节点应该（也）存在于哪个级别。这就是使列表强大的原因，并且是在创建节点之前完成的：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This snippet shows some important details:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段显示了某些重要细节：
- en: The first node is always present on all levels, which makes search considerably
    easier, since the algorithm only needs to descend. However, this is only possible
    thanks to the append-only approach!
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个节点始终存在于所有级别上，这使得搜索变得相当容易，因为算法只需要向下移动。然而，这仅得益于只添加不删除的方法！
- en: Each node's `next` vector has to store succeeding pointers at the level's index,
    which means that the actual length needs to be `highest level + 1`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点的`next`向量必须存储该级别索引处的后续指针，这意味着实际的长度需要是`最高级别 + 1`。
- en: How do you decide on the level, though? This is a great question, since this
    is the heart of a well-performing skip list.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你如何决定级别呢？这是一个很好的问题，因为这是高性能跳表的核心。
- en: Leveling up
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级
- en: Since `search` in a skip list is very much like `search` in a binary search
    tree (the first section in [Chapter 5](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml),
    *Robust Trees*, will get more into those), it has to retain a certain distribution
    of nodes to be effective. The original paper by William Pugh proposes a way to
    create the desired distribution of nodes on a certain level by repeatedly flipping
    a coin (assuming *p = 0.5*).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跳表中的`search`操作非常类似于二叉搜索树中的`search`操作（第5章的第一节[84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml]，*健壮树*，将更深入地介绍这一点），它必须保持一定节点的分布才能有效。威廉·普的原始论文提出了一种通过反复抛硬币（假设*p
    = 0.5*）来创建特定级别上所需节点分布的方法。
- en: 'This is the proposed algorithm (*William Pugh, Skip Lists: A Probabilistic
    Alternative to Balanced Trees, Figure 5*):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提出的算法（*威廉·普，跳表：平衡树的概率替代方案，图5*）：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since this is a simple and understandable implementation, the skip list in
    this chapter will use this as well. However, there are better ways to generate
    the required distribution, and this is left for you to explore further. For this
    task, the first external crate is going to be used: `rand`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个简单易懂的实现，本章中的跳表也将使用这种方法。然而，有更好的方法来生成所需的分布，这留给你进一步探索。为此任务，将使用第一个外部crate：`rand`。
- en: '`rand` is provided by the Rust project but published in its own repository.
    There certainly are discussions about why this is not part of the default standard
    library; however, it''s not too bad having the choice of crates to import if it
    needs to be replaced by something more lightweight, or if the target platform
    is not supported.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand`由Rust项目提供，但发布在其自己的仓库中。当然，有关于为什么这不是默认标准库的一部分的讨论；然而，如果需要用更轻量级的东西替换，或者目标平台不受支持，有选择地导入crate还是不错的。'
- en: 'This Rust code should do just fine and generate the required level on call:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Rust代码应该可以很好地工作，并在调用时生成所需的级别：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Regarding the algorithm, bear this in mind: a range of levels that come out
    are `[0, max_level]`, including the level. Each time a value is inserted, this
    function is called to acquire the level for the resultant node, so jumps can actually
    make `search` faster.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 关于算法，请记住：输出的级别范围是`[0, max_level]`，包括级别。每次插入一个值时，都会调用此函数来获取结果节点的级别，因此跳跃实际上可以使`search`更快。
- en: Jumping around
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳跃搜索
- en: 'The skip list only resembles a binary search tree, but it is able to achieve
    the same runtime complexity (`O(log n)`) without the need for expensive rebalancing.
    This is due to the jumps the skip list allows. Logically, it makes sense: by jumping
    over several nodes, these nodes don''t need to be looked at to find out whether
    those are the values that are being searched for. Fewer nodes means fewer comparisons,
    leading to a reduced runtime.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表只类似于二叉搜索树，但它能够在不进行昂贵平衡的情况下实现相同的运行时间复杂度（`O(log n)`）。这是由于跳表允许的跳跃。从逻辑上讲，这是有道理的：通过跳过多个节点，这些节点不需要被检查以确定它们是否是正在搜索的值。节点越少，比较就越少，从而导致运行时间减少。
- en: 'The jumps are quickly implemented too and can be implemented in a function
    using a few loops:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃的实现也很快，可以通过几个循环在一个函数中实现：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These 30 lines of code allow you to search the list quickly within a few steps.
    First, a sensible starting level has to be found by starting at the highest possible
    level, to see which has a valid node that follows it. The following happens in
    this part:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这30行代码允许你在几步之内快速搜索列表。首先，必须从最高可能的级别开始，找到一个合理的起始级别，以查看哪个级别有有效的后续节点。以下是这个部分发生的事情：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once this level is figured out, the next step is to move vertically toward
    the desired node and move lower, as the potential next node is greater than the
    value we are looking for:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了这一级别，下一步就是垂直移动到所需的节点并向下移动，因为潜在的下一个节点的值大于我们正在寻找的值：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, the result of the search is returned as an `Option` that contains the
    command that was issued at the specified time—or `None`. Depending on the semantics
    of failure, it could be a better choice to use a `Result` with the appropriate
    message that informs the user about why there was no result (the list was empty,
    no value has been found, and so on).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，搜索结果以包含在指定时间发出的命令的`Option`返回——或者`None`。根据失败语义，使用带有适当消息的`Result`可能是一个更好的选择，该消息告知用户为什么没有结果（列表为空，未找到值等）。
- en: Thoughts and discussion
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考与讨论
- en: '`skip list` is a fascinating data structure, as it is fairly simple to implement
    and combines the benefits of tree-like structures within a list without the need
    for expensive inserts or rebalancing. To visualize the power of this data structure,
    here is a chart that compares the `find()` operation of skip lists and (`std::collections::`)
    `LinkedList`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip list`是一种迷人的数据结构，因为它实现起来相对简单，并且结合了列表中树状结构的优点，而无需进行昂贵的插入或平衡。为了可视化这种数据结构的强大功能，以下是一个比较跳表和（`std::collections::`）`LinkedList`的`find()`操作的图表：'
- en: '![](img/3d095723-203b-491d-92c9-4bcffacaa57b.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d095723-203b-491d-92c9-4bcffacaa57b.png)'
- en: The graph output for Skip List find () and Linked List find ()
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表查找()和链表查找()的图形输出
- en: 'The first chart (higher) shows how the skip list behaves according to an `O(log
    n)` type function, which proves that the implementation works! The second (lower)
    chart shows the linear search in `LinkedList`, with the time required growing
    in `O(n)`. The raw numbers are even more impressive:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张图（较高的）显示了跳表根据`O(log n)`类型的函数表现，这证明了实现是有效的！第二张图（较低的）显示了`LinkedList`中的线性搜索，所需时间以`O(n)`增长。原始数字甚至更加令人印象深刻：
- en: '| **Size** | **Skip list [avg ns]** | **Linked list [avg ns]** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **跳表 [平均纳秒]** | **链表 [平均纳秒]** |'
- en: '| 1,000 | 311 | 825 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 311 | 825 |'
- en: '| 10,000 | 438 | 17,574 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 10,000 | 438 | 17,574 |'
- en: '| 100,000 | 1,190 | 428,259 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 100,000 | 1,190 | 428,259 |'
- en: '| 1,000,000 | 2,609 | 5,440,420 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 1,000,000 | 2,609 | 5,440,420 |'
- en: '| 10,000,000 | 3,334 | 45,157,562 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 10,000,000 | 3,334 | 45,157,562 |'
- en: These numbers reflect the **nanoseconds** (**ns**) required for a single call
    to the `find()` method averaged over a number of trials. This is truly a great
    data structure for search.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字反映了单个`find()`方法调用所需的**纳秒**（**ns**），这是在多次试验中平均得出的。这确实是一个用于搜索的非常好的数据结构。
- en: Upsides
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'In a word: `search`. The number of steps required to retrieve a single item
    is linear (it will take as many steps to find an item as there are items in the
    list ), in the *worst case*. Commonly, the time would be at the level of a binary
    search tree!'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：`搜索`。检索单个项目所需的步骤数是线性的（找到项目所需的步骤数与列表中的项目数相同），在**最坏的情况下**。通常，时间会达到二叉搜索树的水平！
- en: 'In more practical terms, this would provide the ability to store large amounts
    of data in a list and quickly find the items that you were looking for. However,
    there is more; here is a list of upsides:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在更实际的意义上，这将提供在列表中存储大量数据并快速找到所需项的能力。然而，还有更多；以下是一些优点：
- en: The item count is only limited by heap memory
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目数量仅受堆内存限制
- en: The search is really efficient
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索非常高效
- en: It is less complex to implement than many trees
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比许多树更易于实现
- en: Yet, there are downsides to this list.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个列表也有缺点。
- en: Downsides
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'The memory efficiency of a skip list and its complexity can be an issue. With
    the append-only approach, the list implemented in this book avoids a few complexities
    such as sorted insert (we''ll get there later). Other points include the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表的内存效率和其复杂性可能是一个问题。采用只追加的方法，本书中实现的列表避免了排序插入等一些复杂性（我们稍后会讨论）。其他要点包括以下内容：
- en: 'Memory efficiency: lots and lots of pointers create overhead'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存效率：大量的指针会带来开销
- en: Implementation complexity
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现复杂性
- en: Sorting required
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要排序
- en: Updates are expensive
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新成本高昂
- en: Probabilistic approach to elevating nodes onto certain levels
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将节点提升到某些级别的概率方法
- en: Depending on the type of project, these might be prohibitive issues. However,
    there are other types of lists that might be suitable, one of them being the dynamic
    array.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目的类型，这些问题可能具有威慑力。然而，还有其他类型的列表可能更适合，其中之一就是动态数组。
- en: Dynamic arrays
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态数组
- en: '**Arrays** are another common way to store sequences of data. However, they
    lack a fundamental feature of lists: expansion. Arrays are efficient because they
    are a fixed-size container of length *n*, where every element has an equal size.
    Thus, any element can be reached by calculating the address to jump to using the
    simple formula `start_address + n * element_size`, making the entire process really
    fast. Additionally, this is very CPU cache-friendly, since the data is always
    at least one hop away.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是存储数据序列的另一种常见方式。然而，它们缺少列表的一个基本特性：扩展。数组之所以高效，是因为它们是一个长度为 *n* 的固定大小容器，其中每个元素的大小相等。因此，可以通过计算使用简单公式
    `start_address + n * element_size` 跳转到的地址来访问任何元素，这使得整个过程非常快速。此外，这对CPU缓存非常友好，因为数据始终至少有一个跳跃距离。'
- en: 'The idea of using arrays to emulate list behavior has been around for a long
    time (Java 1.2 included an `ArrayList` class in 1998, but the idea is likely much
    older) and it is still a great way to achieve high performance in lists. Rust''s
    `Vec<T>` uses the same technique. To start off, this is how an array list is built:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组来模拟列表行为的想法已经存在很长时间了（Java 1.2在1998年包含了`ArrayList`类，但这个想法可能更早）并且它仍然是实现列表高性能的绝佳方式。Rust的`Vec<T>`使用了相同的技巧。首先，这是如何构建数组列表的：
- en: '![](img/880ecd46-5207-45cf-855a-67a55ab1cfe5.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/880ecd46-5207-45cf-855a-67a55ab1cfe5.png)'
- en: 'Consequently, this Rust implementation will have an array (actually a slice,
    but more on that later) as the main storage facility as well:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个Rust实现将使用数组（实际上是一个切片，但稍后再谈）作为主要的存储设施：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The idea is that, dynamic list sizes can be emulated at the cost of memory
    and potentially excessive overallocation. Consequently, the critical point is
    when the currently allocated size is exceeded and the list needs to grow. The
    question becomes this: how much memory is going to be needed?'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是，以内存和潜在的过度分配为代价来模拟动态列表大小。因此，关键点是当前分配的大小被超过，列表需要增长时。问题变成了这样：需要多少内存？
- en: The consequence of too little memory is that reallocation is going to happen
    again quickly—which will remove any performance gains over regular lists. If the
    resizing was too large, a lot of memory would go to waste, and, depending on the
    program's target platform, this might be a huge issue. Thus, the strategy of acquiring
    more memory is essential. Rust's `Vec` follows a smart implementation and allows
    either an exact allocation and an amortized allocation of simply double (or more)
    the size of the current internal array.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 内存过少的后果是，重新分配将很快再次发生——这将消除与常规列表相比的任何性能提升。如果调整大小过大，将会浪费很多内存，并且根据程序的目标平台，这可能会成为一个大问题。因此，获取更多内存的策略是至关重要的。Rust的`Vec`采用了一种智能实现，允许精确分配和简单地将当前内部数组的大小加倍（或更多）的摊销分配。
- en: 'Java''s implementation grows the vector by simply creating a new array with
    the old capacity added to a bit-shifted version (to the right by one) of the old
    capacity. That is, of course, only if that is enough. Typically, that leads to
    adding half of the current capacity or more to the number of possible elements.
    Naturally, all existing elements are (shallow) copied to the new array before
    disposing of the original memory. In code, it looks as follows (from OpenJDK 8,
    class `ArrayList`, lines 237 to 247; new lines added for readability):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Java的实现通过简单地创建一个新数组来增长向量，该数组将旧容量加上旧容量的位右移版本（向右一位）相加。当然，只有当这足够时才会这样做。通常，这会导致将当前容量的半数或更多添加到可能元素的数量中。自然地，在丢弃原始内存之前，所有现有元素都会（浅拷贝）到新数组中。在代码中，它看起来如下（来自OpenJDK
    8，`ArrayList`类，第237至247行；新增行以提高可读性）：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code has a fascinating simplicity, and it's used by billions of programs
    worldwide, and the implementation of this book's dynamic array will use the same
    strategy.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码具有迷人的简单性，并被全球数十亿个程序使用，本书动态数组的实现也将采用相同的策略。
- en: Again, the product team has another feature request. Users liked the going-back-and-forth
    feature a lot, so they want to save a few noteworthy timestamps in a separate
    list.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，产品团队又有另一个功能请求。用户非常喜欢来回切换功能，所以他们想在单独的列表中保存一些值得注意的时间戳。
- en: Often, these kinds of requirements send developers straight to a hash table
    or dictionary type. However, these usually do not retain the order of the items
    that were inserted and, if iteration is a primary concern, they are perhaps not
    the most efficient way to do this.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这类需求会直接让开发者转向哈希表或字典类型。然而，这些通常不会保留插入项的顺序，如果迭代是主要关注点，它们可能不是最有效的方法。
- en: Favorite transactions
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 喜爱的交易
- en: 'To clean up the product team''s demands, here is a list of the required features:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理产品团队的需求，以下是一个所需功能的列表：
- en: Save a transaction's timestamp in a list
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中保存交易的时间戳
- en: Access the elements quickly by index, in any order
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过索引快速访问元素，顺序不限
- en: Iterate the items in the order they were saved
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照保存的顺序迭代项目
- en: A dynamic array utilizes an expanding array underneath and works really quickly,
    for accessing indices directly while still supporting iteration—great for saving
    a numbered list of noteworthy timestamps. The direct index access provides a way
    to fetch the stored data without having to go through the entire list, and since
    transaction timestamps are basically `u64` numbers (milliseconds), the data structure
    can be a dynamic array of multiple `u64`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数组利用底层的扩展数组，并且运行得非常快，可以直接访问索引同时支持迭代——非常适合保存一系列值得注意的时间戳。直接索引访问提供了一种方法，可以获取存储的数据而无需遍历整个列表，并且由于事务时间戳基本上是`u64`数字（毫秒），数据结构可以是一个包含多个`u64`的动态数组。
- en: 'Other than previous lists, this time, a node only stores data and can therefore
    be a type alias as well:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前的列表之外，这次，节点只存储数据，因此也可以是一个类型别名：
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Making the node an `Option` type is necessary, since the capacity and actual
    length of the internal slice may differ—which means that an "empty" marker is
    needed:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将节点设置为`Option`类型是必要的，因为内部切片的容量和实际长度可能不同——这意味着需要一个“空”标记：
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once the node type is declared, it can be used inside the new list's internal
    buffer. This construct is called a **boxed slice** (see the following section)
    and stores nodes in an array-like fashion.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了节点类型，它就可以在新的列表内部缓冲区中使用。这种结构被称为**boxed切片**（见下一节），并以类似数组的方式存储节点。
- en: Internal arrays
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部数组
- en: Arrays are defined as data structures that have a known size at compile time.
    Rust takes this very seriously, and the array constructor will only take constants
    to denominate size in an array. `[0u8; 4]` will work, but `let my_array_size =
    2 * 2; [0u8; my_array_size]` won't.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 数组定义为在编译时具有已知大小的数据结构。Rust对此非常认真，数组构造函数只会接受常量来表示数组的大小。`[0u8; 4]`将工作，但`let my_array_size
    = 2 * 2; [0u8; my_array_size]`不会。
- en: 'So, how do you dynamically reallocate a new array then? In Rust, there is also
    something called `slices`, which are views into a sequence data structure, akin
    to an array. These are a great fit when stored inside a `Box` pointer: allocated
    on the heap, it has all the benefits of an array with a dynamic size.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何动态地重新分配一个新的数组呢？在Rust中，还有一种叫做`slices`的东西，它是序列数据结构的一个视图，类似于数组。当存储在`Box`指针中时，它们非常适合：在堆上分配，具有动态大小的数组的所有优点。
- en: As previously mentioned, this implementation goes with Java's `ArrayList` growth
    strategy and increases its size by at least 50% each time more capacity is required.
    While this has the unfortunate effect of exponential growth, it has worked for
    Java—a *very* popular language—for decades.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此实现与Java的`ArrayList`增长策略相同，并且每次需要更多容量时至少增加50%。虽然这有一个不幸的指数增长效应，但它已经为几十年的Java——一种非常流行的语言——工作了。
- en: 'The Rust implementation is close to its Java pendant; in fact, only the oversized
    variety is missing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Rust实现接近其Java对应物；事实上，只是缺少了超大的种类：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will quickly see that the `vec![]` macro has been used—"*why is that?*"
    you might ask. Unfortunately, there is no great and safe way outside the `vec![]`
    macro to allocate this boxed slice. This use of the macro, however, allows to
    create an empty vector with the appropriate size and convert it into a boxed slice—a
    slice stored in a `Box`. This slice can afterward clone data from the previous
    slice.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到使用了`vec![]`宏——“*为什么是那个？*”你可能会问。不幸的是，除了`vec![]`宏之外，没有一种既好又安全的方法来分配这个boxed切片。然而，这个宏的使用允许创建一个具有适当大小的空向量，并将其转换为boxed切片——一个存储在`Box`中的切片。此后，这个切片可以从之前的切片中克隆数据。
- en: This code works well up to the length of `usize`, which depends on the platform
    the program has been compiled for.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在`usize`长度内运行良好，这取决于程序编译的平台。
- en: Quick access
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速访问
- en: 'Due to the underlying slice, accessing an index is cheap. In fact, it always
    takes the same amount of time, regardless of the index (which makes it different
    to previously discussed lists). A call to the `at()` function will therefore simply
    forward it accordingly:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于底层的切片，访问索引的成本很低。实际上，它总是花费相同的时间，无论索引是什么（这使得它与之前讨论的列表不同）。因此，对`at()`函数的调用将简单地相应地转发：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, again, the Rust implementation has to deal with sharing borrowed content
    or clone the data structure which might require more memory. Under the hood, a
    `u64` is implicitly cloned.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Rust实现又必须处理共享借用内容或克隆数据结构，这可能会需要更多的内存。在底层，一个`u64`会被隐式克隆。
- en: 'To fulfill all requirements, the `Iterator` trait has to be implemented as
    well. Unlike the doubly linked list, the iterator cannot store a single node and
    go forward or backward from there. It has to store a pointer to the entire list,
    along with the current index:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足所有要求，`Iterator`特质也必须实现。与双向链表不同，迭代器不能存储单个节点并从那里向前或向后移动。它必须存储指向整个列表的指针，以及当前索引：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This `struct` makes the implementation already obvious. Move the current pointer
    back and forth as needed:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`struct`使得实现已经很明确了。根据需要移动当前指针：
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a simple and clear iterator: no unpacking, explicit borrowing, and
    so on, just a simple counter that is incremented or decremented as it moves through
    the list.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单清晰的迭代器：没有解包、显式借用等，只是一个简单的计数器，在通过列表移动时会递增或递减。
- en: Wrap up
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The dynamic array is a very flexible way of using array-like structures as a
    list—and it's surprisingly easy to implement and use. In fact, adding other features
    (`prepend`, insert at a specified position, and so on) is only a matter of a few
    lines of code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数组是一种非常灵活的方式来使用类似数组的结构作为列表——而且实现和使用都非常简单。实际上，添加其他功能（如`prepend`、在指定位置插入等）只需几行代码。
- en: 'For Rust, the difference from the other list types is the clearly defined hierarchical
    ownership: the list `struct` owns the internal structure, which in turn owns the
    data in its elements. There are no links among the elements that could create
    ambiguity in who owns what, making the dynamic array a great example for how productive
    Rust code can be.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Rust来说，与其他列表类型的不同之处在于清晰定义的层次所有权：列表`struct`拥有内部结构，而内部结构又拥有其元素中的数据。元素之间没有链接，这可能会造成对谁拥有什么的歧义，这使得动态数组成为Rust代码生产力的一个很好的例子。
- en: Upsides
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'Other than it being only a few lines of code, the dynamic array has quite a
    few upsides:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了只有几行代码之外，动态数组还有不少优点：
- en: 'Speed: arrays/slices make things really fast'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度：数组/切片使事情变得非常快
- en: Simple and fast element access
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单且快速访问元素
- en: Clear ownership structures
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的拥有结构
- en: Fast append and iteration
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速追加和迭代
- en: Very CPU cache-friendly
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常CPU缓存友好
- en: 'One thing is clear: it''s fast in many cases. When is the dynamic array not
    the best choice, though?'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一件事很清楚：在许多情况下它都很快。但是，当动态数组不是最佳选择时呢？
- en: Downsides
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'However, this type of list is also quite memory-inefficient, and its rigid
    structure can be a downside as well:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种类型的列表也非常内存低效，而且其刚性的结构也可能是一个缺点：
- en: Operations other than append will require to shift elements
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了追加操作之外，其他操作将需要移动元素
- en: Growth strategy is not memory-efficient
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增长策略不是内存高效的
- en: A single large chunk of memory is required
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个单独的大块内存
- en: Size is limited by `usize` type, which differs from platform to platform
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小受`usize`类型限制，该类型在不同平台上有所不同
- en: Growth speed decreases with list size
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着列表大小的增加，增长速度会降低
- en: This concludes this journey into the realm of lists, hopefully in a successful
    manner. Before the next chapter begins, a quick summary highlights all the important
    parts.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这次对列表领域的探索之旅，希望是以成功的方式结束。在下一章开始之前，快速总结一下所有重要的部分。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Lists are everywhere! While this is true, it's a fact that makes everything
    harder. Which list is the right tool for the job? How well will it do at certain
    sizes to add and later find elements? What's the overhead if my payload size is
    really small?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表无处不在！虽然这是真的，但这是一个让一切变得更难的事实。哪种列表是完成这项工作的正确工具？它在添加和稍后查找元素时表现如何？如果我的有效负载大小真的很小，开销是什么？
- en: 'These are all questions that programmers are faced with today, and the author
    hopes to provide some guidance on these decisions. To recap: the least complex
    is the singly linked list, upon which the doubly linked list is built. Skip lists
    are in essence multilayered singly linked lists that provide excellent search
    performance at the cost of memory overhead. Last, but not least, there is the
    dynamic array—a type of list that wraps and manages an array for storing data
    just like a list.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是程序员今天面临的问题，作者希望对这些决策提供一些指导。回顾一下：最简单的是单链表，双向链表在此基础上构建。跳表本质上是由多层单链表组成，以内存开销为代价提供出色的搜索性能。最后但同样重要的是，还有动态数组——一种列表类型，它像列表一样包装和管理数组以存储数据。
- en: Implementing these structures in Rust requires many pointers to the heap, especially
    `Rc` and `RefCells`, which were companions from the beginning to the end of the
    chapter. When you consider the structure of a singly linked list, each item required
    access to the next—but with a predictable size. This fact requires programmers
    to work with references, but how would this work if the list gets passed around
    the program, possibly living on the heap itself? The consequence is to simplify
    things and put them on to the heap from the beginning and use an interior mutable
    `Rc` and `RefCell` construct to do that.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中实现这些结构需要许多指向堆的指针，特别是 `Rc` 和 `RefCells`，它们从本章的开始到结束都是伴侣。当你考虑单链表的结构时，每个项目都需要访问下一个项目——但具有可预测的大小。这个事实要求程序员使用引用，但如果这个列表在程序中传递，可能本身就在堆上，会如何呢？结果是简化事情并将它们从一开始就放在堆上，并使用内部可变的
    `Rc` 和 `RefCell` 结构来实现这一点。
- en: Similarly, is the doubly linked list. Other than the forward (next) pointer
    that the singly linked sibling provides, a doubly linked node has to point backward
    as well. Therefore, each item has two pointers in addition to the payload, enabling
    a set of powerful features such as instant list reversal.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，双链表也是如此。除了单链表兄弟提供的正向（下一个）指针外，双链表节点还需要指向前方。因此，每个项目除了有效载荷外还有两个指针，这使得一系列强大的功能成为可能，如即时列表反转。
- en: Skip lists, on the other hand, have been implemented as singly linked lists
    in this chapter (but certainly can be doubly linked as well). Their main improvement
    is the great ability to search the contained data quickly—just like a binary search
    tree. This means that, almost regardless of the size, the look-up performance
    is vastly better than that of a regular list, both in absolute and relative terms.
    Unfortunately, this comes at the cost of many more pointers per node.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，跳表在本章中已被实现为单链表（但当然也可以是双链表）。它们的主要改进是快速搜索包含数据的强大能力——就像二叉搜索树一样。这意味着，几乎无论大小如何，查找性能在绝对和相对意义上都远远优于常规列表。不幸的是，这需要每个节点有更多的指针。
- en: The most popular data structure is probably the dynamic array. Often dubbed
    `Vec<T>` (Rust), `ArrayList` (Java), `List<T>` (C#), or simply `list()` (Python),
    these are wrappers around an array that is allocated and reallocated intelligently
    as required. By doing this, they can accommodate the need for fast element access
    and quick iteration at the cost of a shallow copy on resize, as well as having
    a large chunk of memory available. These are the best choice for storing a limited
    amount of small- to medium-sized items.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的数据结构可能是动态数组。通常被称为 `Vec<T>`（Rust）、`ArrayList`（Java）、`List<T>`（C#）或简单地 `list()`（Python），这些是在数组周围包装的智能分配和重新分配的包装器。通过这样做，它们可以满足对快速元素访问和快速迭代的需要，但代价是在调整大小时进行浅拷贝，以及拥有大量可用内存。这些是存储少量小到中等大小项目的最佳选择。
- en: 'The next chapter is going to delve deeper into less linear data structures:
    trees. These constructs provide interesting capabilities by the way they are built
    and are a great choice for read-heavy undertakings.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将深入探讨更非线性的数据结构：树。这些结构通过其构建方式提供了有趣的功能，并且对于读密集型任务来说是一个很好的选择。
- en: Questions
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is a linked list tricky to implement in Rust?
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在 Rust 中实现链表很棘手？
- en: How does Rust's standard library `LinkedList` work?
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 的标准库 `LinkedList` 是如何工作的？
- en: What is the difference between a doubly linked list and a skip list?
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双链表和跳表之间有什么区别？
- en: Does a dynamic array outperform a skip list for element access?
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态数组在元素访问方面是否优于跳表？
- en: How is a dynamic array a great choice for CPU caching?
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态数组为什么是 CPU 缓存的绝佳选择？
- en: What is another growth strategy for dynamic arrays?
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态数组还有哪些增长策略？
- en: Rust takes arrays seriously, so what does the dynamic array use internally?
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 对数组非常重视，那么动态数组在内部使用什么呢？
- en: Further reading
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for more information:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接获取更多信息：
- en: '*Learning Rust With Entirely Too Many Linked Lists* ([http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html](http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html))'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《用过多的链表学习 Rust》* ([http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html](http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html))'
- en: Implementing the `Iterator` trait ([https://doc.rust-lang.org/std/iter/index.html#implementing-iterator](https://doc.rust-lang.org/std/iter/index.html#implementing-iterator))
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `Iterator` 特性 ([https://doc.rust-lang.org/std/iter/index.html#implementing-iterator](https://doc.rust-lang.org/std/iter/index.html#implementing-iterator))
- en: '*Skip Lists: Done Right* ([https://doc.rust-lang.org/std/iter/index.html#implementing-iterator](https://doc.rust-lang.org/std/iter/index.html#implementing-iterator))'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跳表：正确实现* ([https://doc.rust-lang.org/std/iter/index.html#implementing-iterator](https://doc.rust-lang.org/std/iter/index.html#implementing-iterator))'
- en: '*Skip Lists: A Probabilistic Alternative to Balanced Trees*, William Pugh ([https://www.epaperpress.com/sortsearch/download/skiplist.pdf](https://www.epaperpress.com/sortsearch/download/skiplist.pdf))'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跳表：平衡树的概率替代方案*，威廉·普（William Pugh）([https://www.epaperpress.com/sortsearch/download/skiplist.pdf](https://www.epaperpress.com/sortsearch/download/skiplist.pdf))'
