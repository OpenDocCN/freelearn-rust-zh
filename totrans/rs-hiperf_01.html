<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Common Performance Pitfalls</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you are reading this book, you are probably concerned about the performance of your Rust code. It's known that Rust can offer performance close to that of C/C++ programs, and in some cases, Rust can even win those benchmarks. The main issue, though, is that it's sometimes hard to get that efficiency, especially if you are coming from C/C++. Some concepts don't apply, and some simple efficient approaches in those languages are notably worse in Rust.</p>
<p class="mce-root">In this book, you will learn how to really take advantage of Rust to make it perform at its best while maintaining all the benefits it brings—safety, zero-cost abstractions, and great concurrency. The book can be read from start to finish, and you will probably learn new concepts in every chapter. You can go directly to the chapter that interests you, though, as each chapter contains all the required information for its completion, so that it can be used as a reference.</p>
<p class="mce-root">In this first part of the book, we will start with an introduction on how to improve the performance of your sequential code. You will learn how to avoid common performance pitfalls and how to fix direct translations from other languages. You will then learn how to get better performance from your code, and finally understand memory management in Rust.</p>
<p>In this chapter, we will be looking into:</p>
<ul>
<li>Configuration of the compilation process with profiles</li>
<li>Translation pitfalls—learning how to avoid performance pitfalls with array/slice indexing and master iterators</li>
<li>New iterator adaptors, both in the standard library and in external crates, and coding any complex behavior at zero cost</li>
<li>How to use the borrow checker to your advantage</li>
</ul>
<p>Most of the people that start learning Rust, myself included, tend to bring lessons learned in other languages to Rust. This is usually a great thing, as it will enable you to learn the language faster. The main issue with this approach is that some patterns used in other languages can actually be a trade-off in Rust. We will learn about the most common ones and the not-so-common ones, so that anyone trying to get better performance in Rust can learn how to do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asking the Rust compiler about performance</h1>
                </header>
            
            <article>
                
<p>Rust sometimes has interesting and lesser-known features that really make a difference when talking about performance enhancements. When it comes to big improvements with small changes, the first thing that you should understand is the release mode. Rust by default compiles your software in development mode, which is pretty good to check for compiling errors quickly, but if you want to run it, it will run slowly. This is due to the development mode not performing any optimizations. It will create object (machine) code directly related to the Rust code without optimizing it.</p>
<p>Rust makes use of the LLVM backend, which makes it easy to take advantage of its performance optimizations without having to develop all of these by themselves. They will only need to use LLVM intermediate representation. An intermediate language between Rust and assembly code that the LLVM compiler understands. While in development mode, no optimizations get performed by Rust or LLVM; enabling them is as easy as adding the <kbd>--release</kbd> flag to the cargo compilation. So, for example, if you were running your software by typing <kbd>cargo run</kbd> in the console, just by using <kbd>cargo run --release</kbd> it will compile with optimizations and run much, much faster. Usually, the gain is of more than one order of magnitude.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimizations</h1>
                </header>
            
            <article>
                
<p>By default, Rust will perform level 3 optimizations in the code. Optimizations get divided into levels depending on how complex they are. Higher-level optimizations, in theory, improve the performance of the code greatly, but they might have bugs that could change the behavior of the program. Usually, level 1 optimizations are totally safe, and level 2 optimizations are the most-used ones in the C/C++ ecosystem. Level 3 optimizations have not been known to cause any issues, but in some critical situations, it might be better to avoid them. This can be configured, but we should first understand how the Rust compiler compiles the code to machine instructions so that we know what different options accomplish.</p>
<p>Rust first starts with parsing your code files. It will get the keywords and the different symbols to create a representation of the code in memory. This parsing will find common errors such as a missing semicolon or an invalid keyword. This memory representation of the code is called <strong>High Intermediate Representation</strong> (<strong>HIR</strong>). This representation of the code will be greatly simplified, removing complex flow structures and converting it into <strong>Middle Intermediate Representation</strong> (<strong>MIR</strong>).</p>
<p>The MIR representation is then used to check more complex flows of the software, and enables complex variable lifetime checks, along with some other improvements. This is then converted to the LLVM Intermediate Representation and gets passed to the LLVM compiler. When passing this code to LLVM, Rust adds some flags that will modify the way that LLVM optimizes the code. We have already seen that by default one of the flags it passes is the <kbd>-O0</kbd> flag, or <em>do not optimize</em> flag, so it simply translates to machine code. When compiling in release mode, though, a <kbd>-O3</kbd> gets passed so that level 3 optimizations get performed.</p>
<p>This behavior can be configured in the <kbd>Cargo.toml</kbd> file of the project and it can be configured for each profile. You can configure how to compile for tests, development, documentation, benchmarks, and release. You will probably want to keep development and documentation optimizations to a minimum, as in those profiles the main idea is to compile quickly. In the case of the development profile, you will want to check if everything compiles properly, and even test the behavior of the program a little bit, but you probably won't be concerned about the performance. When generating the documentation, the performance of the application doesn't matter at all, so the best idea is to just not optimized.</p>
<p>When testing, the optimization level you need will depend on how many tests you want to run and how computationally expensive they are. If it takes a really long time to run the tests, it may make sense to compile them optimized. Also, in some critical situations in which you might not be 100% sure that optimizations get performed in a completely secure way, you might want to optimize the tests the same way you optimize the release, and that way you can check if all unit and integration tests pass properly even after optimizations. If they don't, this is a compiler malfunction, and you should report it to the Rust compiler team. They will be glad to help.</p>
<p>Of course, benchmarks and release profiles should be the most optimized ones. In benchmarks, you will want to know the real optimized performance of the code, while in the release, you will want your users to get the best out of their hardware and your software to make things run as efficiently as possible. In these cases, you will want to optimize up to level 2 at least, and if you are not sending satellites to space or programming a pacemaker, you will probably want to optimize all the way up to level 3.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Build configuration</h1>
                </header>
            
            <article>
                
<p>There is one section in the <kbd>Cargo.toml</kbd> file that enables these configurations: the profile section. In this section, you will find one subsection for each of the profiles. Each of them gets declared with the <kbd>[profile.{profile}]</kbd> format. So, for example, for the development profile, it would be <kbd>[profile.dev]</kbd>. The different profile configuration keywords are the following:</p>
<ul>
<li><kbd>dev</kbd> for the development profile, used in <kbd>cargo build</kbd> or <kbd>cargo run</kbd></li>
<li><kbd>release</kbd> for the release profile, used in <kbd>cargo build --release</kbd> or <kbd>cargo run --release</kbd></li>
<li><kbd>test</kbd> for the testing profile, used in <kbd>cargo test</kbd></li>
<li><kbd>bench</kbd> for the benchmarking profile, used in <kbd>cargo bench</kbd></li>
<li><kbd>doc</kbd> for the documentation profile, used in <kbd>cargo doc</kbd></li>
</ul>
<p>When configuring each profile, you will have many options, and we will check all of them out here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimization level</h1>
                </header>
            
            <article>
                
<p>The first option is the one mentioned before, the optimization level. This configuration option can be set by using the <kbd>opt-level</kbd> key in the relevant profile section. By default, optimizations will be level 3 for benchmarking and release, and zero for the rest. For example, to only perform level <kbd>2</kbd> optimizations in the release profile, you can add this code to your <kbd>Cargo.toml</kbd> file:</p>
<pre>    [profile.release]<br/>    opt-level = 2</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debug information</h1>
                </header>
            
            <article>
                
<p>The next option is the debug information. This does not directly affect performance, but it's an interesting configuration item. In this case, you can decide if the debug symbol information gets added to the final executable. This is really useful if you are developing, and especially if you are using a debugger such as GDB. Adding debug information to the executable will enable you to get the function names and even the line numbers of each instruction being executed in the processor. This will give you great insight about what is happening in the code.</p>
<p>In any case, debug information is not so useful in final release binaries, as <span>final release binaries</span> are not meant to be used in debugging. And the debug information usually adds a lot of size to the final binary. This has many times been a concern among developers, as the size of Rust binaries is usually much bigger than the ones written in C/C++. This is in part due to this configuration, and in most cases due to the panic behavior, which we will check later. Debug symbols will also show information about the original code, so it might make sense to hide it in closed-source projects.</p>
<p>To avoid extra debug symbols in the final binary, the <kbd>debug</kbd> option must be set to <kbd>false</kbd>. This can be done for each profile, and by default, it's <kbd>true</kbd> only for the development profile. If you'd like to enable it for testing also, for example, you can add this in the <kbd>Cargo.toml</kbd> file:</p>
<pre>    [profile.test]<br/>    debug = true</pre>
<p>You can, of course, combine this with any other profile option:</p>
<pre>    [profile.test]<br/>    debug = true<br/>    opt-level = 1</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Link-time optimizations</h1>
                </header>
            
            <article>
                
<p>The next configuration option, useful for improving the performance of the application, is link-time optimizations. Usually, when a program gets built, once all the code has been optimized, it gets linked to other libraries and functions that provide the required functionality. This, however, does not always happen in the most efficient way. Sometimes, a function gets linked twice, or a piece of code gets used in many places, and in that case, the compiler might decide to duplicate some code.</p>
<p>The program will work perfectly, but this has two main disadvantages—first of all, duplicating code and links will make the binary bigger, which is probably something you don't want, and secondly, it will reduce the performance. You might ask why. Well, since it's the same code being accessed from different places in the program, it might make sense that if it gets executed once, it gets added to the L1/L2/L3 caches in the processor. This will enable the future reuse of these instructions without requiring the processor to get them from the RAM memory (much slower) or even the disk/SSD (extremely slow) if the memory has been swapped.</p>
<p>The main advantage when performing <strong>Link-Time Optimizations</strong>, or <strong>LTOs</strong> in short, is that while Rust compiles the code file by file, LTOs fit the whole, almost final, representation into a big compilation unit that can be optimized in its entirety, enabling better execution paths.</p>
<p>This can be performed, of course, but at a really high compilation time cost. These optimizations are very costly because they sometimes require changing the final representation, the one ready to be written to the binary. Not only that, but this requires checking lots of execution paths and code samples to find similar blocks. And remember, this is done with the object code, not the Rust code, so the compiler doesn't know about libraries or modules; it only sees instructions.</p>
<p>This costly optimization will improve the performance of your software and the size of your binaries, but being so costly (usually taking as much time as the rest of the compilation, or even more), it's not enabled by default in any of the profiles. And you should not enable it on any but release and maybe benchmarking profiles (you don't want to wait for an LTO every time you make a small change in a function and want to test it). The configuration item to change is the <kbd>lto</kbd> configuration item:</p>
<pre>    [profile.release]<br/>    lto = true</pre>
<p>There is a related configuration item, which will be ignored if LTO is turned on for the given profile. I'm talking about the <kbd>codegen</kbd> units. This divides the code into multiple smaller code units and compiles each of them separately, enabling parallel compiling, which improves how fast the program compiles. This is one in the case of LTO, but can be modified for the rest. Of course, using separate compilation units avoids some optimizations that can improve the performance of the code, so it might make sense to enable faster compilation in development mode. It will be 16 by default in development mode.</p>
<p>This is as simple as changing the <kbd>codegen-units</kbd> configuration option in the development profile:</p>
<pre>    [profile.dev]<br/>    codegen-units = 32</pre>
<p class="mce-root">An example value could be the number of processors/threads in your computer. But remember that this will make the compiled software slower, so do not use it in the release profile. It will, in any case, be ignored if you activate the link-time optimizations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debug assertions</h1>
                </header>
            
            <article>
                
<p>The next interesting configuration item is the one that allows debug assertions to be removed. Debug assertions are like normal assertions, but by default they are only executed in the development profile. They are written in the code by prefixing the <kbd>assert!</kbd> macros with <kbd>debug_</kbd>, using for example <kbd>debug_assert!</kbd> or <kbd>debug_assert_eq!</kbd>. This enables you to fill the whole code with assertions that must be true and that take processing cycles to test, while not reducing the performance of a release application. Of course, this means that those assertions won't run in release mode. This is useful for testing internal methods, but is probably not the best for APIs, and certainly not a good idea in unsafe code wrappers.</p>
<p>For example, the indexing function in the standard library <kbd>Vec</kbd> object has an assertion that will check each time you get an element of the vector by index if the index is out of bounds. This is great to avoid buffer overflows, but makes the operation of getting an element of the vector slower, and if the index is out of bounds, the program will panic. We will talk about this particular example later, but in general, it shows how useful these assertions are—in this case for release mode also.</p>
<p>On the other hand, if you plan to create a small internal API that will input numbers between <kbd>0</kbd> and <kbd>100</kbd> and do some calculations with them, but is not exposed to the public, you could simply add a <kbd>debug_assert!(num &lt;= 100 &amp;&amp; num &gt;= 0)</kbd> and, in tests and debug mode, it will panic the program if a number outside that range is received by the function, but it will not run the assertion in release mode. This can be a potential error vector, but with thorough unit testing, the odds of not getting the error in testing/development mode and an incorrect number being received in release mode are much, much lower. Of course, once again, this shouldn't be used for security-focused areas or input that would cause unsafe or undefined behavior.</p>
<p>By default, as explained, these assertions run in development, testing, and documentation modes. This last one is useful if you have documentation tests with debug assertions. This can be configured, in any case, easily, by changing the <kbd>debug-assertions</kbd> configuration option. For example:</p>
<pre>    [profile.doc]<br/>    debug-assertions = false</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Panic behavior</h1>
                </header>
            
            <article>
                
<p>The next configuration variable to check is the panic behavior. By default, Rust will unwind in a panic. This means that it will call each destructor of each variable in the stack if something goes terribly wrong and the application panics. There is another option: not calling anything and simply aborting the program (the standard C/C++ behavior).</p>
<p>The main advantage of the unwind is that you will be able to call the destructors, so any cleanup that should be done for your variables in the stack of the program will be done properly. The main advantage of the <kbd>abort</kbd> behavior is that it will require much less code to be compiled, since for each potential panic location a new branch gets added to the code where all the destructors are run. It also gives the code much fewer branches, which makes it easier to optimize, but the main advantage is smaller binaries. Of course, you lose the ability to run the destructors, so some complex behavior might not be properly cleaned, for example, if you need to write something to a log upon shutdown.</p>
<p>If you still think that in your use case, using the <kbd>abort</kbd> behavior is a good idea, you can enable it by using the <kbd>panic</kbd> keyword:</p>
<pre>    [profile.doc]<br/>    panic = 'abort'</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Runtime library paths</h1>
                </header>
            
            <article>
                
<p>The last configuration option is <kbd>rpath</kbd>. This configuration item accepts a Boolean and allows you to ask the Rust compiler to set loader paths <span>when the executable looks </span>OK for libraries at runtime. Even though, most of the time, Rust will link crates and libraries statically, you can ask a specific library to be linked dynamically. In this case, that library will be searched at runtime, not at compile time, and it will therefore use system libraries installed where the program is running.</p>
<p>This configuration option asks cargo to add <kbd>-C rpath</kbd> to the <kbd>rustc</kbd> compiler invocation. This will add paths to the dynamic library search paths. Nevertheless, this should not be required in most cases, and you should avoid it if it's not necessary by using <kbd>false</kbd> as the option value. If you are having issues making your application run in multiple operating systems, you might try it, since it might make the executable look for dynamic libraries in new places.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Translation issues</h1>
                </header>
            
            <article>
                
<p>When translating your C/C++/Java mindset, or directly porting a project to Rust, you might find yourself writing similar code to what you wrote in your native language, but if you have tried it, you might have noticed that it performs poorly, or at least much worse than your old code. This happens, especially with C/C++, since in the case of Java the performance issue is much lower compared to the high memory and computation footprint of a Java application, with its Java Virtual Machine and its garbage collector.</p>
<p>But why does a direct translation hurt the performance? We will see in this section how Rust's guarantees can sometimes create unnecessary boilerplate instructions, and we will learn how to bypass them by using safe and efficient code. Of course, in some performance-critical situations, unsafe scopes might be needed, but in general, that's not the case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Indexing degradations</h1>
                </header>
            
            <article>
                
<p>Let's start with a simple example. This Rust code will perform poorly:</p>
<pre>    let arr = ['a', 'b', 'c', 'd', 'e', 'f'];<br/><br/>    for i in 0..arr.len() {<br/>      println!("{}", arr[i]);<br/>    }</pre>
<p class="mce-root">This will, of course, work, and it's perfectly safe. We create an index that goes from <kbd>0</kbd> to the length of the array (<kbd>6</kbd> in this case), but exclude the last one, so the <kbd>i</kbd> binding will take the values <kbd>0</kbd>, <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, <kbd>4</kbd>, and <kbd>5</kbd>. For each of them, it will get the element at that index in the array and print it in a new line. There is one problem with this approach though. In C/C++, an equivalent code will simply add the size of the element to the pointer in the array and get the next element, but that sometimes causes issues. Look at this code:</p>
<pre class="mce-root">    let arr = ['a', 'b', 'c', 'd', 'e', 'f'];<br/><br/>    for i in 0..arr.len() + 1 {<br/>      println!("{}", arr[i]);<br/>    }</pre>
<p class="mce-root">In this case, we are iterating until the array length + 1, and since ranges are exclusive, the last index will be 6. This means it will try to get the seventh element in the array, but there is no seventh element. In C/C++, this will create a buffer overflow and will get whatever is next in the memory. In the case that this memory is outside the program, you will get a segmentation fault, but if it's part of the program, it will print whatever was in that position, leading to leaks. Of course, that is not possible in Rust, since Rust is a memory-safe language, so what will happen?</p>
<p class="mce-root">Well, the answer is surprising—it will panic the program, unwind the stack (call all the destructors of all the variables in the stack), and exit the program safely without trying to access invalid memory. Depending on your perspective, you might think <em>great, I will no longer have buffer overflows</em>, or you might think <em>oh my God, the whole server will go down to prevent a buffer overflow</em>. Well, the second can be mitigated by stopping the panic and recovering the proper server state, already implemented in most frameworks, so it's mostly a win-win.</p>
<p class="mce-root">But is it? How does Rust know if the index is out of bounds? In this simple example, the compiler could know that the <kbd>arr</kbd> variable has only six elements, so trying to access the seventh would violate memory constraints. But what about this more complex program:</p>
<pre class="mce-root">    fn print_request(req: Request) {<br/>      for i in 0..req.content_length {<br/>        println!("{}", req.data[i]);<br/>      }<br/>    }</pre>
<p class="mce-root">Here I'm receiving an HTTP request (very naively represented) that has at least one <kbd>content_length</kbd> attribute and one <kbd>data</kbd> attribute. The first should contain the length of the data field, in a number of bytes, while the second will be a vector of bytes. Let's suppose we don't have the <kbd>len()</kbd> function in that data field, and that we trust the <kbd>content_length</kbd> attribute. What if somebody were to send us an invalid request with a bigger <kbd>content_length</kbd> than the actual length of the content? The compiler wouldn't know this in advance because the request originated at runtime from a TCP connection, but again, Rust must always be memory-safe (unless working in an unsafe scope, which is not the case).</p>
<p class="mce-root">Well, what happens is that the index operation has two parts. First, it checks the bounds of the slice, and if the index is fine, it will return the element; if not, it will panic. And yes, it does this for every indexing operation. So in this case, if the request is a valid request with a supposed 1 million bytes (1 MB), it will compare the index to the length of the vector 1 million times. That is at least 2 million extra instructions (the comparison and the branching for each, at least). That becomes much less efficient than the equivalent C/C++ code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using iterators</h1>
                </header>
            
            <article>
                
<p>There is a way around this, though, that gives the same effect as the C/C++ code: using iterators. The previous code can be converted into the following:</p>
<pre>    let arr = ['a', 'b', 'c', 'd', 'e', 'f'];<br/><br/>    for c in &amp;arr {<br/>      println!("{}", c);<br/>    }</pre>
<p class="mce-root">This will compile roughly to the same machine code as the C/C++ variant since it won't check the bounds of the slice more than once, and it will then use the same pointer arithmetic. This is great when iterating through a slice, but in the case of a direct lookup, it can be an issue. Suppose we will receive thousands of 100-element slices, and we are supposed to get the last element of each and print it. In this case, iterating through all 100 elements of each array just to get the last one is a bad idea, as it would be more efficient to bounds check just the last element. There are a couple of ways of doing this.</p>
<p class="mce-root">The first one is straightforward:</p>
<pre class="mce-root">    for arr in array_of_arrays {<br/>      let last_index = arr.len() - 1;<br/>      println!("{}", arr[last_index]);<br/>    }</pre>
<p class="mce-root">In this concrete case, where we want to get the last element, we can do something like this:</p>
<pre class="mce-root">    for arr in array_of_arrays {<br/>      if let Some(elt) = arr.iter().rev().next() {<br/>        println!("{}", elt);<br/>      }<br/>    }</pre>
<p class="mce-root">This will reverse the iterator with the call to <kbd>rev()</kbd> and then get the next element (the last one). If it exists, it will print it. But if we have to get a number that is not close to the end or to the beginning of the slice, the best way is to use the <kbd>get()</kbd> method:</p>
<pre class="mce-root">    for arr in array_of_arrays {<br/>      if let Some(elt) = arr.get(125) {<br/>        println!("{}", elt);<br/>      }<br/>    }</pre>
<p class="mce-root">This last one has a double bound check, though. It will first check if the index is correct to return a <kbd>Some(elt)</kbd> or a <kbd>None</kbd>, and then the last check will see if the returned element is <kbd>Some</kbd> or <kbd>None</kbd>. If we know for sure, and I mean 100% sure, that the index is always inside the slice, we can use <kbd>get_unchecked()</kbd> to get the element. This is an exact equivalent to the C/C++ indexing operation, so it will not do bounds checking, allowing for better performance, but it will be unsafe to use. So in the HTTP example before, an attacker would be able to get what was stored in that index even if it was a memory address outside the slice. You will need to use an unsafe scope, of course:</p>
<pre class="mce-root">    for arr in array_of_arrays {<br/>      println!("{}", unsafe { arr.get_unchecked(125) });<br/>    }</pre>
<p class="mce-root">The <kbd>get_unchecked()</kbd> function will always return something or segfault, so no need to check if it's <kbd>Some</kbd> or <kbd>None</kbd>. Remember also that upon a segfault, this will not panic, and no destructors will be called. It should only be used if a safe alternative would not meet the performance requirements and if the bounds of the slice were previously known.</p>
<p class="mce-root">In most cases, you will want to use an iterator. Iterators allow for precise iteration of elements, even filtering them, skipping some, taking a maximum amount of them, and finally, collecting them into a collection. They can even be extended or joined with other iterators to allow for any kind of solution. Everything gets managed by the <kbd>std::iter::Iterator</kbd> trait. You now understand the most-used methods of the trait, and I leave the rest to you to research in the standard library documentation.</p>
<p class="mce-root">It's important to properly use and understand iterators since they will be very useful for doing really fast loops. Iterators are cost-free abstractions that work the same way as indexing, but will not require bounds checking, making them ideal for efficiency improvements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterator adaptors</h1>
                </header>
            
            <article>
                
<p>Let's start with the most simple method. The basic method for the rest to work is the <kbd>next()</kbd> method. This function will return either the next element in the iteration or a <kbd>None</kbd> if the iterator has been consumed. This can be used to manually get the next element, or to create a for using a <kbd>while</kbd>, for example:</p>
<pre style="padding-left: 30px">let arr = [10u8, 14, 5, 76, 84];<br/>let mut iter = arr.iter();<br/><br/>while let Some(elm) = iter.next() {<br/>    println!("{}", elm);<br/>}</pre>
<p class="mce-root">That would be the same as this:</p>
<pre class="mce-root" style="padding-left: 30px">let arr = [10u8, 14, 5, 76, 84];<br/><br/>for elm in &amp;arr {<br/>    println!("{}", elm);<br/>}</pre>
<div class="mce-root packt_tip packt_infobox">Note the <kbd>&amp;</kbd> before the array variable in the <kbd>for</kbd>. This is because the basic array type does not implement the <kbd>Iterator</kbd> trait, but a reference to the array is a slice, and slices implement the <kbd>IntoIterator</kbd> trait, which makes it usable as an iterator.</div>
<p class="mce-root">The next two methods you should know about are the <kbd>skip()</kbd> and the <kbd>take()</kbd> methods. These make it easy to get only the correct members of a known ordered iterator. For example, let's say we want to take from the third to the tenth element of an iterator with unknown length (at least 10 elements). In this case, the best thing would be to skip the first two and then take the next eight. We then collect them in a vector. Note that the iterator will not run until you call <kbd>collect()</kbd> method or use it in a loop. Those are the moments in which the <kbd>next()</kbd> method gets executed:</p>
<pre class="mce-root" style="padding-left: 30px">let arr = [10u8, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>let collection: Vec&lt;_&gt; = arr.iter().cloned().skip(2).take(8).collect();<br/><br/>for elm in collection {<br/>    println!("{}", elm);<br/>}</pre>
<p class="mce-root">This will start iterating through the array, and it will first clone each element. That's because by default an iterator will yield references to the elements, and in the case of <kbd>u8</kbd> it's better to copy them than to reference them, as we will see at the end of the chapter. The <kbd>skip()</kbd> method will call <kbd>next()</kbd> twice and discard what it returns. Then, for each <kbd>next()</kbd> operation, it will return the element. Until it calls <kbd>next()</kbd> eight times, the <kbd>take()</kbd> method will return the element. It will then return <kbd>None</kbd>. The <kbd>collect()</kbd> method will create an empty vector, and will push elements to it, while the <kbd>next()</kbd> method returns <kbd>Some</kbd>, then returns the vector.</p>
<div class="mce-root packt_infobox">Note that the <kbd>collect()</kbd> method requires a type hint, as it can return any kind of collection—actually, any type that implements the <kbd>FromIterator</kbd> trait. We simply tell it that it will be a standard library <kbd>Vec</kbd>, and we let the compiler infer the type of element the vector will hold.</div>
<p class="mce-root">There are also a couple of functions that are a generalization of the previous ones, <kbd>skip_while()</kbd> and <kbd>take_while()</kbd>. These two will skip or take elements, respectively, while the closure they run returns <kbd>true</kbd>. Let's see an example:</p>
<pre class="mce-root" style="padding-left: 30px">let arr = [10u8, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>let collection: Vec&lt;_&gt; = arr.iter()<br/>    .cloned()<br/>    .skip_while(|&amp;elm| elm &lt; 25)<br/>    .take_while(|&amp;elm| elm &lt;= 100)<br/>    .collect();<br/><br/>for elm in collection {<br/>    println!("{}", elm);<br/>}</pre>
<p class="mce-root">In this case, the <kbd>skip_while()</kbd> method will run <kbd>next()</kbd> until it finds an element bigger than or equal to <kbd>25</kbd>. In this case, this is the fourth element (index 3), number <kbd>76</kbd>. The <kbd>take_while()</kbd> method starts then calling <kbd>next()</kbd> and returning all elements while they are less than or equal to <kbd>100</kbd>. When it finds <kbd>143</kbd>, it returns <kbd>None</kbd>. The <kbd>collect()</kbd> method will then include all those elements, from the <kbd>76</kbd> to the <kbd>100</kbd>, both included in a vector, and return it. Note that the <kbd>23</kbd> is also added to the final result, since even if it's lower than <kbd>25</kbd>, while the skip method stops skipping, it will never skip again.</p>
<p class="mce-root">To fine-tune the filtering of the elements in the iteration, some other very interesting methods are the <kbd>filter()</kbd> method and its companion <kbd>map()</kbd>. The first lets you filter elements of an iterator based on a closure, while the second lets you map each element to a different one. Let's explore this by using a simple iterator that yields the odd elements of an iterator and collects them into a vector:</p>
<pre class="mce-root" style="padding-left: 30px">let arr = [10u8, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>let collection: Vec&lt;_&gt; = arr.iter()<br/>    .enumerate()<br/>    .filter(|&amp;(i, _)| i % 2 != 0)<br/>    .map(|(_, elm)| elm)<br/>    .collect();<br/><br/>for elm in collection {<br/>    println!("{}", elm);<br/>}</pre>
<p class="mce-root">In this case, we enumerate the iterator by calling to <kbd>enumerate()</kbd>. That will yield a tuple with the index and the element for each <kbd>next()</kbd> call. This will then be filtered by checking the index. If the index is odd, it will be returned in the <kbd>next()</kbd> call; if it's not, it will call <kbd>next()</kbd> again. This will then be mapped, as the filter will also return the tuple. The <kbd>map()</kbd> function will take only the element, discard the index, and return it.</p>
<p class="mce-root">The filter and map functions can be reduced by using the helpful <kbd>filter_map()</kbd> function, which combines the two of them:</p>
<pre class="mce-root" style="padding-left: 30px">let arr = [10u8, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>let collection: Vec&lt;_&gt; = arr.iter()<br/>    .enumerate()<br/>    .filter_map(|(i, elm)| if i % 2 != 0 { Some(elm) } else { None })<br/>    .collect();<br/><br/>for elm in collection {<br/>    println!("{}", elm);<br/>}</pre>
<p class="mce-root">The <kbd>filter_map()</kbd> adaptor expects a closure that will return <kbd>Some(element)</kbd> when it should return the element, and <kbd>None</kbd> when it should retry and call <kbd>next()</kbd>. This will avoid some extra code. In this concrete case, you can also use the <kbd>step_by()</kbd> method, which only returns one element every <em>n</em> elements. In this case, using a two-step will have the same effect.</p>
<p class="mce-root">When trying to do calculations with iterators, instead of using a <kbd>for</kbd>, we can use the great <kbd>fold()</kbd> method. This will hold a variable between each call to <kbd>next()</kbd> that you will be able to update. That way, you can sum, multiply, and perform any other operation in the iterator. Let's, for example, perform the sum of all the elements of the iterator:</p>
<pre class="mce-root" style="padding-left: 30px">let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>let sum = arr.iter().fold(0u32, |acc, elm| acc + elm);<br/>println!("{}", sum);</pre>
<p class="mce-root">This will print <kbd>985</kbd>, without needing a loop. Of course, this will be implemented with a loop under the hood, but for the programmer, it's a zero-cost abstraction that helps a lot in terms of simplifying the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Real-life example</h1>
                </header>
            
            <article>
                
<p>As a real-life example, here is the <em>VSOP87</em> algorithm's variable function implemented with a <kbd>fold()</kbd> method. The <em>VSOP87</em> algorithm is used to find planets and moons in the sky with really good accuracy, useful for simulators and telescope star finders, for example:</p>
<pre style="padding-left: 30px">fn calculate_var(t: f64, var: &amp;[(f64, f64, f64)]) -&gt; f64 {<br/>    var.iter()<br/>       .fold(0_f64, |term, &amp;(a, b, c)| term + a * (b + c * t).cos())<br/>}</pre>
<p>This is equivalent to this other code:</p>
<pre style="padding-left: 30px">fn calculate_var(t: f64, var: &amp;[(f64, f64, f64)]) -&gt; f64 {<br/>    let mut term = 0_f64;<br/>    for &amp;(a, b, c) in var {<br/>        term += a * (b + c * t).cos();<br/>    }<br/>    term<br/>}</pre>
<p>And in C/C++, this would probably require a structure to hold the tuple. Five lines reduced to one with the same native code. As we talked about, this has no extra cost and will be compiled to the same machine code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specialized adaptors</h1>
                </header>
            
            <article>
                
<p>In the case of a summation or a multiplication, there are specialized methods: the <kbd>sum()</kbd> and the <kbd>product()</kbd> methods. These methods will do the same as the <kbd>fold()</kbd> method that is used to add all the numbers in an iterator or to multiply all the items of the iterator. The example we saw before can be reduced to this:</p>
<pre style="padding-left: 30px">let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>let sum: u32 = arr.iter().sum();<br/>println!("{}", sum);</pre>
<p class="mce-root">Type annotations are required for now, but the code looks much simpler. You can also use the <kbd>product()</kbd> function in the same way, and it will be equivalent to this code:</p>
<pre class="mce-root" style="padding-left: 30px">let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>let prod = arr.iter().fold(0u32, |acc, elm| acc * elm);<br/>println!("{}", prod);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interaction between adaptors</h1>
                </header>
            
            <article>
                
<p>There are also some functions to control how the iterators interact with other iterators or even themselves. For example, the <kbd>cycle()</kbd> function will make the iterator start again from the beginning once it gets to the end of the iterator. This is useful to create an infinite loop with an iterator. There are also a couple of functions that help you deal with multiple iterators at the same time. Let's suppose that you have two slices of the same length and want to generate a new vector with that same length, but with each element being the sum of the elements with the same index in the slices:</p>
<pre style="padding-left: 30px">let arr1 = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/>let arr2 = [25u32, 12, 73, 2, 98, 122, 213, 22, 39, 300, 144, 163, 127, 3, 56];<br/><br/>let collection: Vec&lt;_&gt; = arr1.iter()<br/>    .zip(arr2.iter())<br/>    .map(|(elm1, elm2)| elm1 + elm2)<br/>    .collect();<br/>println!("{:?}", collection);</pre>
<p class="mce-root">In this case, we have used the <kbd>zip()</kbd> function that will yield a tuple with each element being the next of each iterator. We can also chain them with the <kbd>chain()</kbd> function, which will generate a new iterator that, once the first starts yielding <kbd>None</kbd>, will start yielding elements from the second iterator. There are many more iteration functions, but we will leave the standard library here for now and focus on external crates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Itertools</h1>
                </header>
            
            <article>
                
<p class="mce-root">There is one external crate that can make working with iterators much easier, and gives you superpowers. Remember the idea that these iterators allow you to perform the same operations you would do in C with indexing, but with complete memory safety and zero-cost abstractions? They also make the code much easier to understand. In terms of iterator capabilities, the most important crate is the <em>itertools</em> crate. This crate provides a new trait, the <kbd>Itertools</kbd> trait, which gives iterators many new methods and functions that make the life of the developer much easier, while staying true to its core values of performance thanks to zero-cost abstractions. You can add it to your project by adding it to your <kbd>Cargo.toml</kbd> file in the <kbd>[dependencies]</kbd> section.</p>
<p>Let's explore some of its iterator adapters. We start with a simple one that helps us create batches or chunks of the given iterator, the <kbd>batching()</kbd> function. Let's say that we want to use an iterator over one of the previous arrays and we want to make it return elements in groups of three. It's as simple as using that method and creating a closure that directly calls the <kbd>next()</kbd> method and returns the required tuple:</p>
<pre style="padding-left: 30px">// Remember<br/>extern crate itertools;<br/>use itertools::Itertools;<br/><br/>let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>for tuple in arr.iter().batching(|it| match it.next() {<br/>    None =&gt; None,<br/>    Some(x) =&gt; {<br/>        match it.next() {<br/>            None =&gt; None,<br/>            Some(z) =&gt; {<br/>                match it.next() {<br/>                    None =&gt; None,<br/>                    Some(y) =&gt; Some((x, y, z)),<br/>                }<br/>            }<br/>        }<br/>    }<br/>})<br/>{<br/>    println!("{:?}", tuple);<br/>}</pre>
<p class="mce-root">This will print the array in groups of three elements, in order:</p>
<pre class="CodePACKT CDPAlignLeft CDPAlign"><strong>(10, 5, 14)<br/>(76, 35, 84)<br/>(23, 100, 94)<br/>(143, 200, 23)<br/>(12, 72, 94)</strong></pre>
<p class="mce-root">A similar operation can be accomplished by using the <kbd>chunks()</kbd> function. We can say that the <kbd>batching()</kbd> adaptor is a generalization of the <kbd>chunks()</kbd> adaptor, since it gives you the option to create the internal logic of the function. In the case of <kbd>chunks()</kbd>, it will only receive as a parameter the number of elements in a chunk, and it will return slices to those chunks.</p>
<p class="mce-root">A really similar operation will be performed with the <kbd>tuples()</kbd> method. As you can see, the <kbd>batching()</kbd> method is a complete generalization in terms of how you create batches or chunks of an iterator. Let's see the same example we saw previously using the <kbd>tuples()</kbd> method:</p>
<pre class="mce-root" style="padding-left: 30px">// Remember<br/>extern crate itertools;<br/>use itertools::Itertools;<br/><br/>let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>for tuple in arr.iter().tuples::&lt;(_, _, _)&gt;() {<br/>    println!("{:?}", tuple);<br/>}</pre>
<p class="mce-root">Much less boilerplate code, right? In this case, we are required to specify the number of elements in a tuple, but if we used type inference in the <kbd>for</kbd>, we could avoid it:</p>
<pre class="mce-root" style="padding-left: 30px">// Remember<br/>extern crate itertools;<br/>use itertools::Itertools;<br/><br/>let arr = [10u32, 14, 5, 76, 84, 35, 23, 94, 100, 143, 23, 200, 12, 94, 72];<br/><br/>for (a, b, c) in arr.iter().tuples() {<br/>    println!("({}, {}, {})", a, b, c);<br/>}</pre>
<p class="mce-root">Of course, in this case, we would be pattern-assigning the variables. There is also another interesting function that allows for creating the cartesian product of two iterators.</p>
<p class="mce-root">Unsurprisingly, the name is <kbd>cartesian_product()</kbd>. This will create a new iterator with all possible combinations of the previous two:</p>
<pre class="mce-root" style="padding-left: 30px">// Remember<br/>extern crate itertools;<br/>use itertools::Itertools;<br/><br/>let arr1 = [10u32, 14, 5];<br/>let arr2 = [192u32, 73, 44];<br/><br/>for row in arr1.iter().cartesian_product(arr2.iter()) {<br/>    print!("{:?}, ", row);<br/>}</pre>
<p class="mce-root">This will print the following:</p>
<div class="CDPAlignCenter CDPAlign">
<pre class="CodePACKT"><strong>(10, 192), (10, 73), (10, 44), (14, 192), (14, 73), (14, 44), (5, 192), (5, 73), (5,44),</strong></pre></div>
<p class="mce-root">There are many other methods in the <kbd>Itertools</kbd> trait, and I invite you to check the official documentation, since it's very detailed and has many examples. For now, these common methods should help you do any operation you need to perform with slices in a much more efficient way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Borrowing degradations</h1>
                </header>
            
            <article>
                
<p>Iterations are not the only place where translation degradations occur. There are also a couple of extra points where you can sometimes see that the same code performs much worse in Rust than in C/C++. One of these points is reference handling. Due to borrow checker constraints, you can do three things with variables when passing them to a function: send a reference (borrow), give the new function control of the variable (own), or copy/clone the variable to send it to a function. It seems easy to decide, right? If you do not require the variable anymore, let the function own your variable. If you require it, send the reference, and if you require it and the API only accepts ownership, clone it.</p>
<p>Well, it actually isn't so simple. For example, integers are faster to copy than to reference, and so are small structures. The rule of thumb is, if it's smaller than or equal to <kbd>usize</kbd>, copy, always. If it's somewhere between <kbd>usize</kbd> and 10 times that size, it's probably better to copy. If it's bigger, it's probably better to reference. If the structure has a heap allocation (such as a <kbd>Vec</kbd> or a <kbd>Box</kbd>), it's usually better to send a reference.</p>
<p>There are some cases, though, when you cannot decide what happens to the variable. In a macro, for example, the variable is passed as is, and the macro decides what to do with it. For example, the <kbd>println!</kbd> macro gets all elements by reference, since it does not require more. The problem is that if you are trying to print an integer, for example, a bottleneck appears. That's what happened some time ago to Robert Grosse, and he wrote an article about it.</p>
<p>Long story short, he had to force the copying of the integer. How did he do that? Well, it's as simple as creating a scope that will return that integer. Since integers implement <kbd>Copy</kbd>, the integer will be copied to the scope and then returned, effectively copying it to the macro:</p>
<pre style="padding-left: 30px">let my_int = 76_u32;<br/>println!("{}", {my_int});</pre>
<p>For normal prints, this is not usually necessary, but if you need to quickly print thousands or millions of integers, you will not avoid the I/O interface, but you can at least avoid this bottleneck.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cyclomatic complexity</h1>
                </header>
            
            <article>
                
<p>Another possible bottleneck is the cyclomatic complexity of functions. While not directly related to the translation of code from other languages, it's true that Rust can sometimes increase the cyclomatic complexity of the code, since it forces you to check for optional (nullable) results, some complex iterators, functional programming, and so on. This is great for code security, but sometimes the compiler has issues properly optimizing the code we write.</p>
<p>The only way to avoid this is to separate the code into smaller code units that will help the compiler optimize better unit by unit. One way of doing that is by creating smaller functions, with no more than 20–25 branches each. A branch is a place where, depending on one variable, the program will run one code or another. The simplest branch is conditional, an <kbd>if</kbd>. There are many others, such as loops (especially when the loop contains returns) or the <kbd>?</kbd> operator. This will create two branches, one for each result option. One of them will return the function while the other will assign the variable.</p>
<p>Nested loops and conditionals make this list grow larger, and the branches can be more and more complex, so you will have to try to divide those deeply nested conditionals in new functions. It's even considered a good practice. As you will see in the <em>Tools</em> section, there are tools that will help you find these bottlenecks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to avoid the most common errors new Rust programmers encounter, and we found out how Rust performs some operations so that we could take advantage of them.</p>
<p>We saw how to configure the build system to allow for precise compilation. You can now set up the optimization passes, the link-time optimizations, or the panic behavior, among many other things.</p>
<p>You have now also mastered iterators, and are now able to stop indexing slices, gaining valuable computation cycles. You also found out about the <em>Itertools</em> crate, and you can now use it to perform complex operations with iterators.</p>
<p>Finally, you learned a couple of tricks on cyclomatic complexity, and you learned how borrowing or copying can affect the way the program works.</p>
<p>From now on, we will enter the world of more complex issues, which can sometimes be difficult to understand for new developers. We will embrace the full power of the Rust programming language to create fast and safe applications.</p>


            </article>

            
        </section>
    </body></html>