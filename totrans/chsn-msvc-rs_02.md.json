["```rs\n> cargo new hyper-microservice\n```", "```rs\n[dependencies]\nhyper = \"0.12\"\n```", "```rs\nlet addr = ([127, 0, 0, 1], 8080).into();\n```", "```rs\nlet builder = Server::bind(&addr);\n```", "```rs\nlet server = builder.serve(|| {\n    service_fn_ok(|_| {\n        Response::new(Body::from(\"Almost microservice...\"))\n    })\n});\n```", "```rs\nlet server = server.map_err(drop);\n```", "```rs\nhyper::rt::run(server);\n```", "```rs\nuse hyper::{Body, Response, Server};\nuse hyper::rt::Future;\nuse hyper::service::service_fn_ok;\n```", "```rs\ncargo run\n```", "```rs\ncargo install cargo-watch\n```", "```rs\ncargo watch -x \"run\"\n```", "```rs\nlet server = builder.serve(|| service_fn(microservice_handler));\n```", "```rs\nfn microservice_handler(req: Request<Body>)\n    -> impl Future<Item=Response<Body>, Error=Error>\n{\n    unimplemented!();\n}\n```", "```rs\nuse futures::{future, Future};\nuse hyper::{Body, Error, Method, Request, Response, Server, StatusCode};\nuse hyper::service::service_fn;\n```", "```rs\nextern crate futures;\nextern crate hyper;\n```", "```rs\n[dependencies]\nfutures = \"0.1\"\nhyper = \"0.12\"\n```", "```rs\nfn microservice_handler(req: Request<Body>)\n    -> impl Future<Item=Response<Body>, Error=Error>\n{\n        match (req.method(), req.uri().path()) {\n            (&Method::GET, \"/\") => {\n                future::ok(Response::new(INDEX.into()))\n            },\n            _ => {\n                let response = Response::builder()\n                    .status(StatusCode::NOT_FOUND)\n                    .body(Body::empty())\n                    .unwrap();\n                future::ok(response)\n            },\n        }\n}\n```", "```rs\nconst INDEX: &'static str = r#\"\n <!doctype html>\n <html>\n     <head>\n         <title>Rust Microservice</title>\n     </head>\n     <body>\n         <h3>Rust Microservice</h3>\n     </body>\n </html>\n \"#;\n```", "```rs\ntype UserId = u64;\nstruct UserData;\n```", "```rs\ntype UserDb = Arc<Mutex<Slab<UserData>>>;\n```", "```rs\n[dependencies]\nslab = \"0.4\"\nfutures = \"0.1\"\nhyper = \"0.12\"\n```", "```rs\nuse std::fmt;\nuse std::sync::{Arc, Mutex};\nuse slab::Slab;\nuse futures::{future, Future};\nuse hyper::{Body, Error, Method, Request, Response, Server, StatusCode};\nuse hyper::service::service_fn;\n```", "```rs\nfn microservice_handler(req: Request<Body>, user_db: &UserDb)\n    -> impl Future<Item=Response<Body>, Error=Error>\n```", "```rs\nfn main() {\n     let addr = ([127, 0, 0, 1], 8080).into();\n     let builder = Server::bind(&addr);\n     let user_db = Arc::new(Mutex::new(Slab::new()));\n     let server = builder.serve(move || {\n         let user_db = user_db.clone();\n         service_fn(move |req| microservice_handler(req, &user_db))\n     });\n     let server = server.map_err(drop);\n     hyper::rt::run(server);\n }\n```", "```rs\nfn response_with_code(status_code: StatusCode) -> Response<Body> {\n    Response::builder()\n        .status(status_code)\n        .body(Body::empty())\n        .unwrap()\n}\n```", "```rs\n    let response = {\n        match (req.method(), req.uri().path()) {\n            (&Method::GET, \"/\") => {\n                Response::new(INDEX.into())\n            },\n            (method, path) if path.starts_with(USER_PATH) => {\n                unimplemented!();\n            },\n            _ => {\n                response_with_code(StatusCode::NOT_FOUND)\n            },\n        }\n    };\n    future::ok(response)\n```", "```rs\nconst USER_PATH: &str = \"/user/\";\n```", "```rs\nlet user_id = path.trim_left_matches(USER_PATH)\n        .parse::<UserId>()\n        .ok()\n        .map(|x| x as usize);\n```", "```rs\nlet mut users = user_db.lock().unwrap();\n```", "```rs\nmatch (method, user_id) {\n    // Put other branches here\n    _ => {\n        response_with_code(StatusCode::METHOD_NOT_ALLOWED)\n    },\n}\n```", "```rs\n(&Method::POST, None) => {\n    let id = users.insert(UserData);\n    Response::new(id.to_string().into())\n}\n```", "```rs\n(&Method::POST, Some(_)) => {\n    response_with_code(StatusCode::BAD_REQUEST)\n}\n```", "```rs\n(&Method::GET, Some(id)) => {\n     if let Some(data) = users.get(id) {\n         Response::new(data.to_string().into())\n     } else {\n         response_with_code(StatusCode::NOT_FOUND)\n     }\n }\n```", "```rs\nimpl fmt::Display for UserData {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(\"{}\")\n    }\n}\n```", "```rs\n(&Method::PUT, Some(id)) => {\n    if let Some(user) = users.get_mut(id) {\n        *user = UserData;\n        response_with_code(StatusCode::OK)\n    } else {\n        response_with_code(StatusCode::NOT_FOUND)\n    }\n},\n```", "```rs\n(&Method::DELETE, Some(id)) => {\n    if users.contains(id) {\n        users.remove(id);\n        response_with_code(StatusCode::OK)\n    } else {\n        response_with_code(StatusCode::NOT_FOUND)\n    }\n},\n```", "```rs\n[dependencies]\nslab = \"0.4\"\nfutures = \"0.1\"\nhyper = \"0.12\"\nlazy_static = \"1.0\"\nregex = \"1.0\"\n```", "```rs\nuse lazy_static::lazy_static;\nuse regex::Regex;\n```", "```rs\nlazy_static! {\n    static ref INDEX_PATH: Regex = Regex::new(\"^/(index\\\\.html?)?$\").unwrap();\n    static ref USER_PATH: Regex = Regex::new(\"^/user/((?P<user_id>\\\\d+?)/?)?$\").unwrap();\n    static ref USERS_PATH: Regex = Regex::new(\"^/users/?$\").unwrap();\n}\n```", "```rs\nlet response = {\n    let method = req.method();\n    let path = req.uri().path();\n    let mut users = user_db.lock().unwrap();\n\n    // Put regular expressions here\n};\nfutures::ok()\n```", "```rs\nif INDEX_PATH.is_match(path) {\n    if method == &Method::GET {\n        Response::new(INDEX.into())\n    } else {\n        response_with_code(StatusCode::METHOD_NOT_ALLOWED)\n    }\n```", "```rs\n} else if USERS_PATH.is_match(path) {\n    if method == &Method::GET {\n        let list = users.iter()\n            .map(|(id, _)| id.to_string())\n            .collect::<Vec<String>>()\n            .join(\",\");\n        Response::new(list.into())\n    } else {\n        response_with_code(StatusCode::METHOD_NOT_ALLOWED)\n    }\n```", "```rs\n} else if let Some(cap) = USER_PATH.captures(path) {\n    let user_id = cap.name(\"user_id\").and_then(|m| {\n        m.as_str()\n            .parse::<UserId>()\n            .ok()\n            .map(|x| x as usize)\n    });\n    // Put match expression with (method, user_id) tuple\n```", "```rs\n} else {\n    response_with_code(StatusCode::NOT_FOUND)\n}\n```", "```rs\n$ curl -X POST http://localhost:8080/user/\n0\n$ curl -X POST http://localhost:8080/user/\n1\n$ curl -X POST http://localhost:8080/user/\n2\n$ curl -X DELETE http://localhost:8080/user/1\n$ curl http://localhost:8080/users\n0,2\n```"]