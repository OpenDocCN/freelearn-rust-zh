<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Using Variables and Types" id="aid-LTSU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Using Variables and Types</h1></div></div></div><p>In this chapter, we look at the basic building blocks of a Rust program: variables and their types. We discuss variables of primitive types, whether their type has to be declared or not, and the scope of variables. Immutability, one of the cornerstones of Rust's safety strategy, is also discussed and illustrated.</p><p>We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Comments</li><li class="listitem">Global constants</li><li class="listitem">Values and primitive types</li><li class="listitem">Binding variables to values </li><li class="listitem">Scope of a variable and shadowing</li><li class="listitem">Type checking and conversions</li><li class="listitem">Expressions</li><li class="listitem">The stack and the heap</li></ul></div><p>Our code examples will center on building a text-based game called Monster Attack.</p><div class="section" title="Comments"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Comments</h1></div></div></div><p>Ideally, a program should be self-documenting by using descriptive variable names and easy to read code, but <a id="id48" class="indexterm"/>there are always cases where additional comments about a program's structure or algorithms are needed. Rust follows the C convention and has the following convention for marking comments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Line comments</strong></span> (<code class="literal">//</code>): Everything<a id="id49" class="indexterm"/> on the line after <code class="literal">//</code> is commentary and not compiled</li><li class="listitem"><span class="strong"><strong>Block or multi-line comments</strong></span> (<code class="literal">/* */</code>): Everything between the start <code class="literal">/*</code> and the end <code class="literal">*/</code> is not<a id="id50" class="indexterm"/> compiled</li></ul></div><p>However, the preferred Rust style is to use only line comments even for multiple lines, like the following code:</p><div class="informalexample"><pre class="programlisting">// see Chapter 2/code/comments.rs
fn main() {
<span class="strong"><strong>  // Here starts the execution of the Game.</strong></span>
<span class="strong"><strong>  // We begin with printing a welcome message:</strong></span>
  println!("Welcome to the Game!");
}</pre></div><p>Use the block comments only to comment out code.</p><p>Rust also has a doc comment (<code class="literal">///</code>) that is useful in larger projects that require an official documentation for <a id="id51" class="indexterm"/>customers and developers. Such comments have to appear before an item (like a function) on a separate line to document that item. In these comments, you can use Markdown<a id="id52" class="indexterm"/> formatting syntax; for more information, go to <a class="ulink" href="https://en.wikipedia.org/wiki/Markdown">https://en.wikipedia.org/wiki/Markdown</a>.</p><p>Here is a <code class="literal">doc</code> comment:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/// Start of the Game</strong></span>
fn main() {
}</pre></div><p>We'll see more relevant uses of doc comments in later code snippets. The rustdoc tool can compile these comments into a project's documentation.</p></div></div>
<div class="section" title="Global constants" id="aid-MSDG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Global constants</h1></div></div></div><p>Often, an <a id="id53" class="indexterm"/>application needs a few values that are in fact constants; they do not change in the course of the program. For example: the name of our game, which is "Monster Attack", is a constant, as is the maximum value of health, which is the number 100. We must be able to use them in <code class="literal">main()</code> or any other function in our program, so they are placed at the top of the code file. They live in the global scope of the program. Such constants are declared with the <code class="literal">static</code> keyword as follows:</p><div class="informalexample"><pre class="programlisting">// see Chapter 2/code/constants1.rs
<span class="strong"><strong>static MAX_HEALTH: i32 = 100;</strong></span>
<span class="strong"><strong>static GAME_NAME: &amp;'static str = "Monster Attack";</strong></span>

fn main() {
}</pre></div><p>Names of constants must be in uppercase and underscores can be used to separate words. Their type must also be indicated; <code class="literal">MAX_HEALTH</code> is a 32-bit integer (<code class="literal">i32</code>) and <code class="literal">GAME_NAME</code> is a string (<code class="literal">str</code>). As we will discuss further, the declaration of types for variables is done in exactly the same way although this is often optional when the compiler can infer the type from the code's context.</p><p>Don't worry too much about the <code class="literal">&amp;'static</code> indication for now. Remember that Rust is a low-level language, so many things must be specified in detail. The <code class="literal">&amp;</code> annotation is a reference to something (it contains the memory address of a value); here it contains the reference to the string. However, if we only use <code class="literal">&amp;str</code> and compile, we get an error for that line. Have a look at the following snippet:</p><div class="informalexample"><pre class="programlisting">// warning: incorrect code!
static GAME_NAME: &amp;str = "Monster Attack";</pre></div><p>This will give you the following error:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>2:22 error: missing lifetime specifier [E0106]</strong></span>
</pre></div><p>Here, <code class="literal">2:22</code> means that we have an error on line 2 and position 22, so we must set the line numbering in our editor. We must add the lifetime specifier <code class="literal">'static</code> to the type annotation so that we get <code class="literal">&amp;'static str</code>. The lifetime of an object in Rust is very important<a id="id54" class="indexterm"/> because it says how long the object will live in the program's memory. The Rust compiler adds the code to remove an object when its lifetime is over, freeing the memory that it occupied. The <code class="literal">'static</code> lifetime is the longest possible lifetime; such an object stays alive throughout the entire application, and so it is available to all of its code.</p><p>Even when we add this specifier, the compiler gives us the <code class="literal">warning: static item is never used: `MAX_HEALTH`, #[warn(dead_code)] on by default</code> warning and an analogous warning for <code class="literal">GAME_NAME</code>.</p><p>These warnings do not prevent the compilation, so at this stage, we have an executable. However, the compiler is right. These objects are never used in the program's code; so, in a complete program, you should either use them or throw them out.</p><div class="note" title="Note"><h3 class="title"><a id="tip02"/>Tip</h3><p>It takes a while before an aspiring Rust developer starts to regard the Rust compiler as his or her friend and not an annoying machine that keeps spitting out errors and warnings. As long as you see this message at the end of the compiler output, <code class="literal">error: aborting due to previous errors</code>, no (new) executable is made. But remember, correcting the errors eliminates runtime problems, so this can save you a lot of time that would be otherwise wasted tracking nasty bugs. Often, the error messages are accompanied with helpful notes on how to eliminate the error. Even the warnings can point you to flaws in your code. Rust also warns us when something is declared but not used in the code that follows, such as unused variables, functions, imported modules, and so on. It even warns us if we make a variable mutable (which means that its value can be changed) when it should not be or when code doesn't get executed. The compiler does such a good job that when you reach the stage where all errors and warnings are eliminated, your program will most likely run correctly!</p></div><p>Besides static values, we can also use simple constant values whose value never changes. Constants always have to be typed, for example, <code class="literal">const PI: f32 = 3.14;</code> they are more local in scope than static values.</p><p>The compiler <a id="id55" class="indexterm"/>automatically substitutes the value of the constant everywhere in the code.</p><div class="section" title="Printing with string interpolation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Printing with string interpolation</h2></div></div></div><p>An obvious<a id="id56" class="indexterm"/> way to use variables is to print out their values, as we have done here:</p><div class="informalexample"><pre class="programlisting">// see Chapter 2/code/constants2.rs
static MAX_HEALTH: i32 = 100;
static GAME_NAME: &amp;'static str = "Monster Attack";

fn main() {
<span class="strong"><strong>  const PI: f32 = 3.14;</strong></span>
<span class="strong"><strong>  println!("The Game you are playing is called {}.", GAME_NAME);</strong></span>
  println!("You start with {} health points.", MAX_HEALTH);
}</pre></div><p>This gives the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>The Game you are playing is called Monster Attack.</strong></span>
<span class="strong"><strong>You start with 100 health points.</strong></span>
</pre></div><p>The constant PI exists in the standard library, to use this value insert this statement at the top: use <code class="literal">std::f32::consts;</code> and then use the PI value as follows: <code class="literal">println!("{}", consts::PI);</code>
</p><p>The first argument of <code class="literal">println!</code> is a literal format string that contains a <code class="literal">{}</code> placeholder. The value of the constant or variable after the comma is converted to a string and replaces the {}. There can be more than one placeholder, and they can be numbered in order so that they can be used repeatedly, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">println!("In the Game {0} you start with {1} % health, yes you read it correctly: {1} points!", GAME_NAME, MAX_HEALTH);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>In the Game Monster Attack you start with 100 % health, yes you read it correctly: 100 points!</strong></span>
</pre></div><p>The placeholder can also contain one or more named arguments, as follows:</p><div class="informalexample"><pre class="programlisting">    println!("You have {points} % health", points=70);</pre></div><p>This will give you the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>You have 70 % health</strong></span>
</pre></div><p>Special ways of formatting can be indicated inside <code class="literal">{}</code> after a colon (<code class="literal">:</code>), as follows:</p><div class="informalexample"><pre class="programlisting">println!("MAX_HEALTH is {:x} in hexadecimal", MAX_HEALTH); // 64
println!("MAX_HEALTH is {:b} in binary", MAX_HEALTH);  // 1100100
println!("pi is {:e} in floating point notation", PI); // 3.14e0</pre></div><p>The following<a id="id57" class="indexterm"/> formatting possibilities exist according to the type that must be printed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">o</code> for octal</li><li class="listitem"><code class="literal">x</code> for lower hexadecimal</li><li class="listitem"><code class="literal">X</code> for upper hexadecimal</li><li class="listitem"><code class="literal">p</code> for a pointer</li><li class="listitem"><code class="literal">b</code> for binary</li><li class="listitem"><code class="literal">e</code> for lower exponential notation</li><li class="listitem"><code class="literal">E</code> for upper exponential notation</li><li class="listitem"><code class="literal">?</code> for debugging purposes</li></ul></div><p>The <code class="literal">format!</code> macro has the same parameters and works in the same way as <code class="literal">println!</code>, but it<a id="id58" class="indexterm"/> returns a string instead of printing out.</p><p>Go to <a class="ulink" href="http://doc.rust-lang.org/std/fmt/">http://doc.rust-lang.org/std/fmt/</a> for an overview of all the possibilities.</p></div></div>
<div class="section" title="Values and primitive types" id="aid-NQU21"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Values and primitive types</h1></div></div></div><p>Constants that have been initialized have a value. Values exist in different types: <code class="literal">70</code> is an integer, <code class="literal">3.14</code> is a float, and <code class="literal">Z</code> and <code class="literal">q</code> are of the <code class="literal">char</code> type (they are characters). Characters are unicode values<a id="id59" class="indexterm"/> that take 4 bytes of memory each. <code class="literal">Godzilla</code> is a string of type <code class="literal">&amp;str</code> (which is a Unicode UTF8 by default), <code class="literal">true</code> and <code class="literal">false</code> are of the <code class="literal">bool</code> type; they are Boolean values. Integers<a id="id60" class="indexterm"/> can be written in different formats:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Hexadecimal format with <code class="literal">0x</code> (for example, <code class="literal">0x46</code> for <code class="literal">70</code>)</li><li class="listitem">Octal format with <code class="literal">0o</code>, (for example, <code class="literal">0o106</code> for <code class="literal">70</code>)</li><li class="listitem">Binary format with <code class="literal">0b</code>, (for example, <code class="literal">0b1000110</code>)</li></ul></div><p>Underscores can be used for readability, as in <code class="literal">1_000_000</code>. Sometimes, the compiler will urge you to indicate more explicitly the type of number with a suffix. For example, the number after <code class="literal">u</code> or <code class="literal">i</code> is the number of memory bits used, namely <code class="literal">8</code>, <code class="literal">16</code>, <code class="literal">32</code>, or <code class="literal">64</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">10usize</code> denotes an unsigned integer of machine word size <code class="literal">usize</code>, which can be any of the <code class="literal">u8</code>, <code class="literal">u16</code>, <code class="literal">u32</code>, or <code class="literal">u64</code> types</li><li class="listitem"><code class="literal">10isize</code> denotes a signed integer of machine word size <code class="literal">isize</code>, which can be any of the types among <code class="literal">i8</code>, <code class="literal">i16</code>, <code class="literal">i32</code>, and <code class="literal">i64</code></li><li class="listitem">In the preceding cases, for a 64-bit operating system <code class="literal">usize</code> is in fact <code class="literal">u64</code> and <code class="literal">isize</code> is equivalent to <code class="literal">i64</code></li><li class="listitem"><code class="literal">3.14f32</code> denotes a 32-bit floating point number</li><li class="listitem"><code class="literal">3.14f64</code> denotes a 64-bit floating point number</li></ul></div><p>The numeric types <code class="literal">i32</code> and <code class="literal">f64</code> are the defaults if no suffix is given, but in that case, to differentiate between them, you must end an <code class="literal">f64</code> value with <code class="literal">.0</code>, like this: <code class="literal">let e = 7.0;</code>.</p><p>Indicating a <a id="id61" class="indexterm"/>specific type is only needed when the compiler signals that it cannot infer the type of the variable.</p><p>Rust is like any other C-like language when it comes to the different operators that exist on values and their precedence (go to <a class="ulink" href="http://doc.rust-lang.org/reference.html#binary-operator-expressions">http://doc.rust-lang.org/reference.html#binary-operator-expressions</a> for more information on this). However, note<a id="id62" class="indexterm"/> that Rust does not have increment (<code class="literal">++</code>) or decrement (<code class="literal">--</code>) operators. To compare two values for equality, use <code class="literal">==</code> and to test whether they are different use <code class="literal">!=</code>.</p><p>There is even the empty<a id="id63" class="indexterm"/> value <code class="literal">()</code> of zero size, which is the only value of the so-called unit type <code class="literal">()</code>. This is used to indicate the return value when an expression or a function returns nothing (no value), as is the case for a function that only prints to the console. <code class="literal">()</code> is not the equivalent of a null value in other languages; <code class="literal">()</code> means no value, whereas null is a value.</p><div class="section" title="Consulting Rust documentation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Consulting Rust documentation</h2></div></div></div><p>The quickest way to find <a id="id64" class="indexterm"/>more detailed information about a Rust topic is to browse the documentation <a id="id65" class="indexterm"/>screen of the standard library at <a class="ulink" href="http://doc.rust-lang.org/std/">http://doc.rust-lang.org/std/</a>. On its left-hand side, you can find a listing of all the available crates that you can browse for more details. However, the most useful feature is the search box at the top; you can type in a few letters or a word to get a number of useful references. Have a look at the following screenshot:</p><div class="mediaobject"><img src="../Images/image00174.jpeg" alt="Consulting Rust documentation"/></div><p style="clear:both; height: 1em;"> </p><p>The following is an exercise for you:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Try to change<a id="id66" class="indexterm"/> the value of a constant. This is of course not allowed. What error do you get? Have a look at <code class="literal">Chapter2/exercises/change_constant.rs</code>.</li><li class="listitem">Look up the <code class="literal">println!</code> macro in the documentation.</li><li class="listitem">Read the <code class="literal">fmt</code> specification and write a program that will print the <code class="literal">3.2f32</code> value as <code class="literal">+003.20</code>. Refer to <code class="literal">Chapter2/exercises/formatting.rs</code>.</li></ul></div></div></div>
<div class="section" title="Binding variables to values" id="aid-OPEK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Binding variables to values</h1></div></div></div><p>Storing all <a id="id67" class="indexterm"/>values in constants is not an option. It is not good because constants live as long as the program and therefore be changed, and often we want to<a id="id68" class="indexterm"/> change values. In Rust, we can bind a value to a variable by using a <code class="literal">let</code> binding:</p><div class="informalexample"><pre class="programlisting">// see Chapter 2/code/bindings.rs
fn main() {
<span class="strong"><strong>  let energy = 5; // value 5 is bound to variable energy</strong></span>
}</pre></div><p>Unlike many other languages such as Python or Go, the semicolon (<code class="literal">;</code>) is needed here to end the statement. Otherwise, the compiler will throw the <code class="literal">error: expected one of `.`, `;`, or an operator, found `}`</code> error at us.</p><p>We also want to create bindings only when they are used in the rest of the program, but you needn't worry because the Rust compiler warns us about that:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>values.rs:2:6: 2:7 warning: unused variable: `energy`, #[warn(unused_variables)] on by default</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip03"/>Tip</h3><p>For prototyping purposes, you can suppress the warning by prefixing the variable name with a <code class="literal">_</code> , like in <code class="literal">let _ energy = 5;</code>. In general, <code class="literal">_</code> is used for variables that we don't need.</p></div><p>Note that in the preceding declaration, we didn't need to indicate the type; Rust inferred the type of <code class="literal">energy</code> to be an integer, which the <code class="literal">let</code> binding triggered. If the type is not obvious, the compiler searches in the code context to check from where the variable gets a value or how it is used.</p><p>However, giving type hints like <code class="literal">let energy = 5u16;</code> is also okay; this way you help the compiler a bit by indicating the type of energy, which is a 2-byte unsigned integer in this case.</p><p>We can use the <code class="literal">energy</code> variable by using it in an expression; for example, by assigning it to another variable or by printing it:</p><div class="informalexample"><pre class="programlisting">let copy_energy = energy;
println!("Your energy is {}", energy););</pre></div><p>Here are some other declarations:</p><div class="informalexample"><pre class="programlisting">let level_title = "Level 1";
let dead = false;
let magic_number = 3.14f32;
let empty = ();  // the value of the unit type ()</pre></div><p>The value of <code class="literal">magic_number</code> could also be written as <code class="literal">3.14_f32</code>; the <code class="literal">_</code> separates the digits from the type to improve readability.</p><p>Declarations<a id="id69" class="indexterm"/> can replace previous declarations of the same variable. A<a id="id70" class="indexterm"/> statement like <code class="literal">let energy = "Abundant";</code> would now bind energy to the value <code class="literal">Abundant</code> of string type. The old declaration can no longer be used and its memory is freed.</p><div class="section" title="Mutable and immutable variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Mutable and immutable variables</h2></div></div></div><p>Suppose we get a <a id="id71" class="indexterm"/>boost from swallowing a health pack and our energy rises to value 25. However, if we write <code class="literal">energy = 25;</code>, we get an <code class="literal">error: re-assignment of immutable variable `energy`</code> error. So, what is wrong here?</p><p>Well, Rust applies a<a id="id72" class="indexterm"/> programmer's wisdom here; a lot of bugs come from inadvertent or wrong changes made to variables, so don't let the code change a value unless you have deliberately allowed it!</p><div class="note" title="Note"><h3 class="title"><a id="note02"/>Note</h3><p>Variables are by default <span class="strong"><strong>immutable</strong></span> in Rust, which is very similar to what functional languages do. In pure functional languages, mutability is not even allowed.</p></div><p>If you want a mutable variable because its value can change during code execution, you have to indicate that explicitly with <code class="literal">mut</code>. Have a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">  let mut fuel = 34;
  fuel = 60;</pre></div><p>Simply declaring a variable as <code class="literal">let n;</code> is also not enough. If we do this, we will get <code class="literal">error: unable to infer enough type information about `_`; type annotations required</code>. The compiler needs a value to infer its type.</p><p>We can give the compiler this information by assigning a value to <code class="literal">n</code>, like <code class="literal">n = -2;</code>, but as the message says, we could also indicate its type as follows:</p><div class="informalexample"><pre class="programlisting">  let n: i32;</pre></div><p>Alternatively, you can even use the following:</p><div class="informalexample"><pre class="programlisting">let n: i32 = -2; // n is a binding of type i32 and value -2</pre></div><p>The type (here <code class="literal">i32</code>) follows the variable name after a colon (<code class="literal">:</code>) (as we already showed for global constants), optionally followed by an initialization. In general, the type is indicated like <code class="literal">n: T</code>, where <code class="literal">n</code> is a variable and <code class="literal">T</code> is a type, and it is read as variable <code class="literal">n</code> is of the type <code class="literal">T</code>. So, this is the inverse of what is done in C/C++, Java, or C#, where one would write <code class="literal">T n</code>.</p><p>For primitive types, this can<a id="id73" class="indexterm"/> be done simply with a suffix, like this:</p><div class="informalexample"><pre class="programlisting">let x = 42u8;
let magic_number = 3.14f64;</pre></div><p>Trying to use an uninitialized variable results in the <code class="literal">error: use of possibly uninitialized variable</code> error (try it out). Local variables have to be initialized before they can be used in order to prevent undefined behavior.</p><p>You can experiment with a mutable global constant. What do you have to do to allow it? Why would that be? (For an example code, see <code class="literal">mutable_constant.rs</code>.)</p><p>When the compiler <a id="id74" class="indexterm"/>does not recognize a name in your code, you will get an <code class="literal">unresolved name</code> error. This may probably be just a typo, but it will be caught early on at compilation and not at runtime!</p></div></div>
<div class="section" title="Scope of a variable and shadowing" id="aid-PNV61"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Scope of a variable and shadowing</h1></div></div></div><p>All variables defined in <code class="literal">bindings.rs</code> have local scope delimited by <code class="literal">{ }</code> of the function, which happens to be <code class="literal">main()</code> here, and this applies to any function. After the ending <code class="literal">}</code>, they go out of scope and their memory allocation is freed.</p><p>We can even make<a id="id75" class="indexterm"/> a more limited scope inside a function by defining a code <a id="id76" class="indexterm"/>block that contains all the code within a pair of curly braces (<code class="literal">{ }</code>), as in the following snippet:</p><div class="informalexample"><pre class="programlisting">// see Chapter 2/code/scope.rs
fn main() {
  let outer = 42;
<span class="strong"><strong>  { // start of code block</strong></span>
        let inner = 3.14;
        println!("block variable: {}", inner);
        let outer = 99; // shadows the first outer variable
        println!("block variable outer: {}", outer);
<span class="strong"><strong>  } // end of code block</strong></span>
    println!("outer variable: {}", outer);
  }</pre></div><p>This gives the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>block variable: 3.14</strong></span>
<span class="strong"><strong>block variable outer: 99</strong></span>
<span class="strong"><strong>outer variable: 42</strong></span>
</pre></div><p>A variable defined in the block (like <code class="literal">inner</code>) is only known inside that block. A variable in the block can also have the same name as a variable in an enclosing scope (like <code class="literal">outer</code>), which is replaced (shadowed) by the block variable until the block ends. What do you think will happen when you try to print <code class="literal">inner</code> after the block? Try it out.</p><p>So, why would <a id="id77" class="indexterm"/>you want to use a code block? In the <span class="emphasis"><em>Expressions</em></span> section, we will see that a code block can return a value that can be bound to a variable with let. A code <a id="id78" class="indexterm"/>block can also be empty (<code class="literal">{  }</code>).</p></div>
<div class="section" title="Type checking and conversions" id="aid-QMFO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Type checking and conversions</h1></div></div></div><p>Rust has to know<a id="id79" class="indexterm"/> the type of each variable so that it can check (at compile time) whether they are only used in the manner in which their type permits. This way programs<a id="id80" class="indexterm"/> are type safe and a whole range of bugs can be avoided.</p><p>This also means that<a id="id81" class="indexterm"/> we cannot change the type of a variable during its lifetime because of static typing; for example, the score variable in the following snippet<a id="id82" class="indexterm"/> cannot change from an integer to a string:</p><div class="informalexample"><pre class="programlisting">// see Chapter 2/code/type_errors.rs
// warning: this code does not work!
fn main() {
  let score: i32 = 100;
  score = "YOU WON!"
}</pre></div><p>We get the compiler error, <code class="literal">error: mismatched types: expected `int`, found `&amp;'static str` (expected int, found &amp;-ptr</code>.</p><p>However, we are allowed to write the following code:</p><div class="informalexample"><pre class="programlisting">let score = "YOU WON!";</pre></div><p>Rust lets us redefine variables; each <code class="literal">let</code> binding creates a new variable score that hides the previous one, which is freed from memory. This is actually quite useful because variables are immutable by default.</p><p>Adding strings with <code class="literal">+</code> (like the players in the following code) is not defined in Rust:</p><div class="informalexample"><pre class="programlisting">let player1 = "Rob";
let player2 = "Jane";
let player3 = player1 + player2;</pre></div><p>We then get <code class="literal">error: binary operation `+` cannot be applied to type `&amp;str`</code>.</p><p>In Rust, you can use the <code class="literal">to_string()</code> method to convert the value to a String type like this: <code class="literal">let player3 = player1.to_string() + player2;</code>.</p><p>Otherwise, you could use the <code class="literal">format!</code> macro:</p><div class="informalexample"><pre class="programlisting">    let player3 = format!("{}{}", player1, player2);</pre></div><p>In both the cases, <code class="literal">player3</code> has the value <code class="literal">"RobJane"</code>.</p><p>Let's find out what<a id="id83" class="indexterm"/> happens when you assign a value from a variable of a certain type to another variable of a different type:</p><div class="informalexample"><pre class="programlisting">// see Chapter 2/code/type_conversions.rs
fn main() {
  let points = 10i32;
  let mut saved_points: u32 = 0;
  saved_points = points; // error !
}</pre></div><p>This is again not <a id="id84" class="indexterm"/>allowed; we get the same error (<code class="literal">error: mismatched types: expected `u32`, found `i32` (expected u32, found i32)</code>). To enable maximal type checking, Rust does not permit automatic (or implicit) conversions of one type to another like C++ does; therefore, it avoids a lot of hard-to-find bugs. For<a id="id85" class="indexterm"/> example, the numbers after the decimal point are lost when a <code class="literal">f32</code> value is converted to an <code class="literal">i32</code> value; this could lead to errors when done automatically.</p><p>We can, however, do an explicit conversion (a casting) with the <code class="literal">as</code> keyword:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  saved_points = points as u32;</strong></span>
</pre></div><p>When points contain a negative value, the sign would be lost after conversion. Similarly, when casting from a wider value like a float to an integer, the decimal part is truncated:</p><div class="informalexample"><pre class="programlisting">  let f2 = 3.14;
  saved_points = f2 as u32; // truncation to value 3 occurs here</pre></div><p>In addition, the value must be convertible to the new type as a string cannot be converted to an integer, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">  let mag = "Gandalf";
  saved_points = mag as u32; // error: non-scalar cast:`&amp;str`as`u32`</pre></div><div class="section" title="Aliasing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Aliasing</h2></div></div></div><p>It can be <a id="id86" class="indexterm"/>useful sometimes to give a new, more descriptive or a shorter name to an existing type. This can be done with the <code class="literal">type</code> keyword, as in the following example where we needed a specific (but size-limited) variable for <code class="literal">MagicPower</code>:</p><div class="informalexample"><pre class="programlisting">// see Chapter 2/code/alias.rs
type MagicPower = u16;

fn main() {
  let run: MagicPower= 7800;  
}</pre></div><p>A type name starts with a capital letter, as does each word that is part of the name. What happens when <a id="id87" class="indexterm"/>we change the value <code class="literal">7800</code> to <code class="literal">78000</code>? The compiler detects this with the following warning, <code class="literal">warning: literal out of range for its type</code>.</p></div></div>
<div class="section" title="Expressions" id="aid-RL0A1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Expressions</h1></div></div></div><p>Rust is an <span class="strong"><strong>expression-oriented</strong></span> language, which means that most pieces of code are in fact expressions, that is, they compute a value and return that value (in that sense, values are also expressions). However, expressions<a id="id88" class="indexterm"/> by themselves do not form meaningful code; they must be used in statements.</p><p>The <code class="literal">let</code> bindings like the following are declaration statements; they are not expressions:</p><div class="informalexample"><pre class="programlisting">// see Chapter 2/code/expressions.rs
let a = 2;    // a binds to 2
let b = 5;    // b binds to 5
let n = a + b;   // n binds to 7</pre></div><p>However, <code class="literal">a + b</code> is an expression, and if we omit the semicolon at the end, the resulting value (here <code class="literal">7</code>) is returned. This is often used when a function needs to return its value (see examples in the next chapter). Ending an expression with a semicolon like <code class="literal">a + b;</code> suppresses the value of an expression, thereby throwing away the return value and making it an expression statement that returns the unit value <code class="literal">()</code>. A code is usually a sequence of statements, one on each code line, and Rust has to know when a statement ends; this is why nearly every Rust code line ends with a semicolon.</p><p>What do you think the assignment <code class="literal">m = 42;</code> is? This is not a binding because there is no <code class="literal">let</code>. That should have happened on a previous code line. It is an expression that returns the unit value <code class="literal">()</code>. A compound binding like <code class="literal">let p = q = 3;</code> is not allowed in Rust; it returns the <code class="literal">error: unresolved name q</code> error. However, you can chain <code class="literal">let</code> bindings like this:</p><div class="informalexample"><pre class="programlisting">  let mut n = 0;
  let mut m = 1;
  let t = m; m = n; n  = t;
  println!("{} {} {}", n, m, t); // which prints out 1 0 1</pre></div><p>Here is an exercise for you. Print out the values of a, b, and n after this code snippet and explain the value of <code class="literal">a</code> (for example code, see <code class="literal">compound_let.rs</code>):</p><div class="informalexample"><pre class="programlisting">    let mut a = 5;
    let mut b = 6;
    let n = 7;
    let a = b = n; </pre></div><p>A code block is also an expression, which will return the value of its last expression if we omit the semicolon. For example, in the following code snippet, <code class="literal">n1</code> gets the value <code class="literal">7</code>, but <code class="literal">n2</code> gets no value (or rather the unit value <code class="literal">()</code>) because the return value of the second code block was <a id="id89" class="indexterm"/>suppressed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>let n1 = {</strong></span>
<span class="strong"><strong>    let a = 2;</strong></span>
<span class="strong"><strong>    let b = 5;</strong></span>
<span class="strong"><strong>    a + b   // &lt;-- no semicolon!</strong></span>
<span class="strong"><strong>};</strong></span>
  println!("n1 is: {}", n1);  // prints: n1 is 7

  let n2 = {
    let a = 2;
    let b = 5;
    a + b;
  };
  println!("n2 is: {:?}", n2);  // prints: n2 is ()</pre></div><p>Here, the variables <code class="literal">a</code> and <code class="literal">b</code> are declared in a code block and live only as long as the block itself lives as they are local to the block. Note that the semicolon after the closing brace of the block (<code class="literal">};</code>) is needed. To print the unit value <code class="literal">()</code>, we need {<code class="literal">:?</code>} as the format specifier.</p></div>
<div class="section" title="The stack and the heap"><div class="titlepage" id="aid-SJGS2"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>The stack and the heap</h1></div></div></div><p>Since memory allocation is very important in Rust, we must have a good picture of what is going on. A program's memory is divided into the stack<a id="id90" class="indexterm"/> and heap memory parts; to get more background on these concepts, read the information on the classic web page at <a class="ulink" href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap">https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap</a>. Primitive<a id="id91" class="indexterm"/> values such as numbers (like 32 in the figure), characters, and true/false values are stored on the stack, while the value of more complex objects that could grow in size are stored in the heap memory. Heap values are referenced by a variable on the stack, which contains the memory address of the object on the heap:</p><div class="mediaobject"><img src="../Images/image00175.jpeg" alt="The stack and the heap"/></div><p style="clear:both; height: 1em;"> </p><p>While the stack has a limited size, the size of the heap can grow as and when more space is needed.</p><p>Now, we will run the following program and try to visualize the program's memory:</p><div class="informalexample"><pre class="programlisting">   // see Chapter 2/code/references.rs
  let health = 32;
  let mut game = "Space Invaders";</pre></div><p>Values are stored in memory and so they have memory addresses. The <code class="literal">health</code> variable contains an integer value <code class="literal">32</code> that is stored in the stack at location <code class="literal">0x23fba4</code>, while the variable game contains a string, which is stored in the heap starting at location <code class="literal">0x23fb90</code>. (These were the addresses when I executed the program, but they will be different when you run the program.)</p><p>The variables<a id="id92" class="indexterm"/> to which the values are bound are pointers or references to the values. They point to them; <code class="literal">game</code> is a reference to Space Invaders. The address of a value is given by the <code class="literal">&amp;</code> operator. So, <code class="literal">&amp;health</code> is the address where value <code class="literal">32</code> is stored, and <code class="literal">&amp;game</code> is the address where the Space Invaders' value is stored.</p><p>We can print these addresses by using the format string <code class="literal">{:p}</code> for pointers like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>println!("address of health-value: {:p}", &amp;health); </strong></span>
// prints 0x23fba4
println!("address of game-value: {:p}", &amp;game); // prints 0x23fb90
println!("game-value: {}", game); // prints "Space Invaders"</pre></div><p>Now, we have the following situation in memory (memory addresses will be different at each execution):</p><div class="mediaobject"><img src="../Images/image00176.jpeg" alt="The stack and the heap"/></div><p style="clear:both; height: 1em;"> </p><p>We can make an<a id="id93" class="indexterm"/> alias, which is another reference that points to the same place in memory, like this:</p><div class="informalexample"><pre class="programlisting">let game2 = &amp;game;
println!("{:p}", game2); // prints 0x23fb90</pre></div><p>To get the value that is being referred to rather than the <code class="literal">game2</code> reference itself, dereference it with the asterisk <code class="literal">*</code> operator like this:</p><div class="informalexample"><pre class="programlisting">  println!("{}", *game2); // prints "Space Invaders"</pre></div><p>The <code class="literal">(println! is clever, so println!("{}", game2);</code> line will also print the same value as <code class="literal">println!("game: {}", &amp;game);</code>.</p><p>The preceding code is a bit simplified because Rust will allocate values to the stack that will not change in size as much as it is possible, but this is meant to give you a better idea of what a reference to a value means.</p><p>We know already that a <code class="literal">let</code> binding is immutable, so the value cannot be changed:</p><div class="informalexample"><pre class="programlisting">health = 33; // error: re-assignment of immutable variable `health`.</pre></div><p>If <code class="literal">y</code> is declared with <code class="literal">let y = &amp;health;</code>, then <code class="literal">*y</code> is the value <code class="literal">32</code>. Reference variables can also be given a type like <code class="literal">let x: &amp;i64;</code> and such references can be passed around in code. After this <code class="literal">let</code> binding, <code class="literal">x</code> does not really point yet to a value and it does not contain a memory address. In Rust, there is no way to create a null pointer as you can in other languages; if you try to assign a nil, null, or even a unit value <code class="literal">()</code> to x, this will result in an error. This feature alone saves Rust programmers from countless bugs. Furthermore, trying to use <code class="literal">x</code> in an expression; for example, <code class="literal">println!("{:?}", x);</code> will result in the <code class="literal">error: use of possibly uninitialized variable: `x`error</code> error.</p><p>A mutable reference to an immutable variable is forbidden; otherwise, the immutable variable could be changed through its mutable reference:</p><div class="informalexample"><pre class="programlisting">  let tricks = 10;
  let reftricks = &amp;mut tricks; </pre></div><p>This gives the <code class="literal">error: cannot borrow immutable local variable `tricks` as mutable</code> error.</p><p>A reference to<a id="id94" class="indexterm"/> a mutable score variable can either be immutable or mutable respectively, such as <code class="literal">score2</code> and <code class="literal">score3</code> in the following example:</p><div class="informalexample"><pre class="programlisting">  let mut score = 0;
  let score2 = &amp;score;
  // error: cannot assign to immutable borrowed content *score2
  // *score2 = 5; 

  let mut score = 0;
  let score3 = &amp;mut score;
   *score3 = 5;</pre></div><p>The value of <code class="literal">score</code> can be only changed through a mutable reference such as <code class="literal">score3</code>.</p><p>For reasons that we will see later, you can only make one mutable reference to a mutable variable:</p><div class="informalexample"><pre class="programlisting">let score4 = &amp;mut score;</pre></div><p>This throws the <code class="literal">error: cannot borrow `score` as mutable more than once at a time</code> error.</p><p>Here, we touch the heart of Rust's memory safety system, where borrowing a variable is one of its key concepts. We will explore this in more detail in <a class="link" title="Chapter 6. Pointers and Memory Safety" href="part0056.xhtml#aid-1LCVG2">Chapter 6</a>, <span class="emphasis"><em>Pointers and Memory Safety</em></span>.</p><p>The heap is a much larger memory part than the stack, so it is important that memory locations are freed as soon as they are no longer needed. The Rust compiler sees when a variable ends its lifetime (or in other words, goes out of scope) and inserts a code at compile time to free its memory when the code is executed. This behavior is unique to Rust and is not present in other commonly used languages. Stack values can be boxed, that is, allocated in the heap by creating a <code class="literal">Box</code> around them, as is the case for the value of <code class="literal">x</code> in the following code:</p><div class="informalexample"><pre class="programlisting">let x = Box::new(5i32);</pre></div><p>
<code class="literal">Box</code> is an object that references a value on the heap. We'll also look at this more closely in the <span class="emphasis"><em>Boxes</em></span> section of <a class="link" title="Chapter 6. Pointers and Memory Safety" href="part0056.xhtml#aid-1LCVG2">Chapter 6</a>, <span class="emphasis"><em>Pointers and Memory Safety</em></span>.</p></div>
<div class="section" title="Summary" id="aid-TI1E1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, you learned how to work with variables in Rust and got acquainted with many of the common compiler error messages. We explored types and the default immutability of variables that are the cornerstones of Rust's safety behavior. In the following chapter, we will start writing some useful code by using program logic and functions.</p></div></body></html>