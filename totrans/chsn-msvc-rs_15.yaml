- en: Packing Servers to Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices created with Rust are pretty simple to deploy: it''s sufficient
    to build a binary for your server, upload that binary to your server, and start
    it. But that''s not a flexible approach for real applications. Firstly, your microservice
    may need files, templates, and configuration. On the other hand, you may want
    to use servers with different operating systems. In that case, you would have
    to build a binary for every system. To reduce the amount of issues with deployment,
    modern microservices are packed to containers and use virtualization to launch.
    Virtualization helps to simplify the deployment of a set of microservices. Also,
    it can help to scale a microservice, because to run an extra instance of a microservice
    you should only start another copy of the container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will immerse you in building Docker images with Rust microservices.
    We will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling microservices with Docker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a necessary Rust version in a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing time spent building images with a Rust microservice. After we have
    prepared an image, we will create images for multiple microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a compose file for the Docker Compose utility to bootstrap a set of
    microservices to show how to run a complex project consisting of multiple microservices
    that interact with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a set of microservices and adding a database instance to let those
    microservices store persistent state to a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires a full Docker installation with the Docker Compose utility.
    It doesn't require the Rust compiler, since we will build microservices with Docker
    containers, but it's good to have the nightly Rust compiler if you want to build
    and test any microservices locally or play with configuration parameters without
    patching the `docker-cocmpose.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Docker, follow the instructions for your operating system here:
    [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the Docker Compose utility, look at these docs: [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the examples for this chapter in the `Chapter15` folder of the
    GitHub project: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/).'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image with a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first part of this chapter, we will build a Docker image with the necessary
    version of the Rust compiler and build an image with a compiled microservice.
    We will use a set of microservices from other chapters to show how to join microservices
    created with different frameworks. We will use the *users*, *emails*, and *content*
    microservices from [Chapter 9](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml),  *Simple
    REST Definition and Request Routing with Frameworks*and the *router* microservice
    from [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *In**volving Concurrency
    with Actors and Actix Crate*, and we'll also tune them to be configurable. Also,
    we will add a `dbsync` microservice, which will do all of the necessary migrations
    to a database, because we will use two microservices that use the database with
    the `diesel` crate and there will be a conflict if both microservices try to apply
    migrations for their own schema. That's because we'll use a single database, but
    if you use separate databases (not necessarily different database management applications,
    but only database files) for every microservice, you can use an individual migration
    set for every database. It's time to prepare an image with the nightly Rust compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an image with the Rust compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ready-to-use images on Docker Hub. You can also find an official
    image here: [https://hub.docker.com/_/rust/](https://hub.docker.com/_/rust/).
    But we will create our own image since official images contain a stable compiler
    version only. If it''s enough for you, it''s better to use official images, but
    if you use crates such as `diesel`, which need the nightly version of the Rust
    compiler, you will have to build your own image to build microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Dockerfile` and add the following content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve borrowed this `Dockerfile` from the official Rust Docker image located
    here: [https://github.com/rust-lang-nursery/docker-rust-nightly/blob/master/nightly/Dockerfile](https://github.com/rust-lang-nursery/docker-rust-nightly/blob/master/nightly/Dockerfile).
    This file is a good starting point for good practices when creating images with
    the Rust compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: Our Rust image is based on the `buildpack-deps` image, which contains all of
    the necessary dependencies commonly used by developers. This dependency is indicated
    in the first line with the `FROM` command.
  prefs: []
  type: TYPE_NORMAL
- en: '`buildpack-deps` is an official Docker image based on Ubuntu (a free open-source
    Linux distribution based on Debian). The image includes a lot of headers for libraries
    such as OpenSSL and curl, and packages with all of the necessary certificates,
    and so on. It''s very useful as a build environment for your Docker images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line, which contains the `ENV` command, sets three environment variables
    in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RUSTUP_HOME`: Sets the root folder of the `rustup` utility, which contains
    a configuration and installs toolchains'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CARGO_HOME`: Contains cached files used by the `cargo` utility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATH`: The system environment variable that contains paths to executable binaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We target all utilities to the `/usr/local` folder by setting these environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `rustup` utility here to bootstrap the Rust environment. It's an
    official Rust installation tool that helps you to maintain and keep multiple Rust
    installations up-to-date. In my opinion, using `rustup` is the best way to install
    Rust locally or in a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last `Dockerfile` command, `RUN`, is complex and we will analyze this set
    of commands line by line. The first shell command is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the default shell in Ubuntu is the Bash shell, we can set three useful
    flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-e`: This flag tells the shell to run the next line (command) only if the
    previous one finished successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u`: With this flag, the shell will print an error to `stderr` if the command
    tries to expand a variable that is not set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x`: With this flag, the shell will print every command to `stderr` before
    running it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next three lines download the `rustup-init` binary and set the executable
    flag to the downloaded file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next pair runs the`rustup-init` command with parameters and removes the
    binary after running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following flags were used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-y`: Suppresses any confirmation prompts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-modify-path`: Won''t modify the `PATH` environment variable (we set it
    manually before, for the image)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--default-toolchain`: The type of the default toolchain (we will use `nightly`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The remaining lines set write permissions to the `RUSTUP_HOME` and `CARGO_HOME`
    folders and print the version for all the installed tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can build the `Dockerfile` to get an image that contains the preconfigured
    Rust compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command takes some time to complete, but after it has finished, you will
    have an image that you can use as a base for building images for microservices.
    If you type the `docker images` command, you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we will use the image tagged as `rust:nightly` and create images for microservices
    from it. Let's start by creating an image for the users microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Users microservice image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The users microservice provides users with registration capabilities. This chapter
    contains a modified version of the users microservice from [Chapter 9](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml), 
    *Simple REST Definition and Request Routing with Frameworks*. Since this service
    requires a database and uses the `diesel` crate to interact with it, we need to
    use the `diesel.toml` config in the process of building the image.
  prefs: []
  type: TYPE_NORMAL
- en: .dockerignore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Docker copies all files from the building folder, we have to add the `.dockerignore`
    file that contains the patterns of paths to avoid copying these files. It''s useful,
    for example, to skip the `target` building folder, because it may contain gigabytes
    of data for large projects, but in any case, we don''t need all of them since
    we''ll build a microservice using the image with the Rust compiler. Add the `.dockerignore`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will ignore all Rust''s build artifacts (such as the `target`, `Cargo.lock`,
    and `*.bk` files that are produced by the `rustfmt` tool that we will use later)
    in the next chapter, where we will explore continuous integration tools. We also
    included two patterns: `files`—this folder will be created by this microservice
    to store files if you try to run it locally, and `*.db`—not a necessary pattern
    for SQLite Database, because this version uses PostgreSQL instead of SQLite, but
    useful if you want to support both databases for testing reasons later.'
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now everything is ready to build and pack the microservice to an image. To
    do this, add the `Dockerfile` file to the folder with the microservice and add
    the following lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the image based on the `rust:nightly` images that we created earlier
    in this chapter. We set it using the `FROM` command. The next line creates a new
    crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You might ask why we did that and didn''t use an existing crate. That''s because
    we will reproduce the creation of the crate inside the container to build dependencies
    first, to avoid the lengthy process of rebuilding them, when you would add any
    tiny change to the source code of the microservice. This approach will save you
    a lot of time. Copy `Cargo.toml` to the image and build all of the dependencies
    without the sources of the microservice (since we have not copied them yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next set of commands adds sources and the `diesel.toml` file to the image,
    removes previous build results, and builds the crate again with the new sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, the image contains a binary of a microservice that we can use
    as a starting command for containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, a container doesn''t open a port and you can''t connect to it with
    another container or forward the port of a container to a local port. Since our
    microservice starts at port 8000, we have to expose it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The image is ready to build and run a container. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Building an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have prepared the Dockerfile to build an image that first builds all the
    dependencies for our microservice and then builds all the source code. To start
    this process, you have to use the Docker `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this command, you will see how Docker prepares files to build
    an image and builds all the dependencies, but only for the empty crate without
    the sources of a microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our image needs 12 steps in total to build the microservice. As you can see,
    the building of dependencies takes two and a half minutes. It''s not fast. But
    we don''t need to repeat this step till `Cargo.toml` has changed. The next steps
    copy the source code of the microservices into a container and build them with
    prebuit dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the output, building the microservice takes just 5 seconds.
    It's fast enough and you can rebuild it as many times as you want. Since the image
    has been built, we can start a container with our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The image we built has been stored in Docker and we can see it using the `docker
    images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the microservice from an image, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The container with the microservice instance will start but it won't work since
    we haven't run a container with a database instance. We won't connect containers
    manually, since it's part of the subtleties of Docker usage, and you can read
    about that in Docker's documentation; however, we will learn how to connect containers
    with the Docker Compose tool later in this chapter, in the *Composing a microservice
    set* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also ask: Why is our microservice so big? We will try to reduce it
    later in this chapter. But now we should pack other microservices to images.'
  prefs: []
  type: TYPE_NORMAL
- en: Content microservice image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second microservice we will use is the content microservice that we created
    in [Chapter 9,](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml) *Simple REST Definition
    and Request Routing with Frameworks*. We also prepared this service for use with
    the PostgreSQL database. We borrowed the `dockerignore` file from the previous
    example and adapted the `Dockerfile` file for this microservice. Look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this `Dockerfile` is the same as the `Dockerfile` of the previous
    image, but it has one difference: it doesn''t copy any configuration files. We''ll
    are using the Rocket framework, but we will set all the parameters using the environment
    variables in the Docker Compose file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build this image with the following command to check how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: But it's not necessary to build this image, because we won't start containers
    manually—we will use Docker Compose. Let's pack an email microservice to an image
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Email microservice image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The email microservice doesn''t use the `diesel` crate and we can use the official
    Rust image to build a microservice. Also, the email microservice has templates
    that are used to prepare the contents of emails. We will use the same `.dockerignore`
    file, but will copy `Dockerfile` from the previous example and add some changes
    related to the email microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We created this image from the `rust:1.30.1` image. The stable version of the
    compiler is suitable to compile this simple microservice. We also added a command
    to copy all the templates into the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we can prepare the image with the router microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Router microservice image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you remember, we created the router microservice in [Chapter 11,](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml) *Involving
    Concurrency with Actors and the Actix Crate, *where we explored features of the
    Actix framework. We adapted the router microservice to work with other microservices—we
    added a `Config` and a `State` that share configuration values with handlers.
    Also, the improved router microservice serves assets that are in the static folder.
    We also have to copy this folder to an image. Look at the `Dockerfile` of the
    router microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We also used the official Rust image with the stable compiler. The one difference
    you will notice in comparison with the previous example is copying the `static`
    folder into an image. We use the same `.dockerignore` file as we used for the
    previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: We have built images for all of the microservices, but the last element we need
    to add is a worker that will apply migrations to a database. We will use it with
    Docker Compose later to apply all migrations automatically. Let's create this
    Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: DBSync worker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DBSync worker has only one function—waiting for a connection with the database
    and applying all migrations. We'll also pack this worker to a Docker image to
    use it in a compose file that we will create in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The worker needs the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We need the `diesel` crate with `diesel_migrations` to embed all the migrations
    into the code. It's not necessary, but useful. We need the `config` and `serde`
    crates to configure the worker. The other crates are more common and you can see
    how we used them in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add those dependencies to `Cargo.toml` and import the types that we will use
    in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now let's create code that will wait for a connection to the database and apply
    all embedded migrations.
  prefs: []
  type: TYPE_NORMAL
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we create the main function, we have to embed migrations using the `embed_migrations!`
    macro call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This call creates an `embedded_migrations` module, which contains the `run`
    function, which applies all migrations to a database. But before we use it, let''s
    add the `Config` struct to read the database connection link from a configuration
    file or an environment variable using the `config` crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This struct contains only a single parameter—the optional `String` with a connection
    link to the database. We will set this parameter later with Docker Compose using
    the `DBSYNC_DATABASE` environment variable. We have added the `DBSYNC` prefix
    in the `main` function. Look at the full code of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we initialized `env_logger` to print information to strerr.
    After, we created a generic `Config` instance from the `config` module and merged
    environment variables with the `DBSYNC` prefix. If the config merged successfully,
    we try to convert it to a value of our own `Config` type that we declared before.
    We'll use a config to extract a link of a connection to the database. If the value
    is not provided, we will use the `postgres://localhost/` link.
  prefs: []
  type: TYPE_NORMAL
- en: When a connection link is ready, we use a loop to try to connect to the database.
    We will try to connect to it until it succeeds, because we will use this worker
    with Docker Compose, and despite the fact we will start a container with the database,
    it can be unavailable when a database instance is starting. We use a loop to wait
    for the connection to be ready.
  prefs: []
  type: TYPE_NORMAL
- en: When the connection is ready, we use it to apply embedded migrations with the `run`
    method of the `embedded_migrations` module. After the migrations have been applied,
    we break the loop and stop the worker.
  prefs: []
  type: TYPE_NORMAL
- en: We have all the microservices ready to launch, but their disadvantage is that
    their source code also remains in the image. This is not good if we want to hide
    the implementation details of our microservices. Let's explore a technique that
    hides the sources of microservices using the image building cache.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding microservice source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main drawback of building microservices inside an image is that all of the
    sources and build artifacts will be available for anyone who has access to a Docker
    image. If you want to remove sources and other building artifacts, you can use
    one of two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is to build all sources using a Docker image with the Rust
    compiler, providing access to sources through a linked virtual volume. In Docker,
    you can map any local folder to a volume inside a container using the `-v` argument
    of the `docker run` command. The disadvantage of this approach is that Docker
    uses another ID inside the container that you have in your local session. It can
    create files you can't delete without changing the user ID. Also, this approach
    is harder to maintain. But it's useful if you need the result of compilation only.
    If you plan to run a microservice inside a container, it's better to build everything
    inside an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second approach involves building everything with Docker, but using a building
    cache to get the compilation result and putting it into a newly created container.
    Let''s explore the `Dockerfile` that implements this approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `Dockerfile` of the dbsync microservice and the first part of the
    file was the same as the original with one small improvement—we set that name
    as an image we built in the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use the cached data of the image using the `builder` name.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this section, we start a new empty image from the `buildpack-deps` image
    that was originally used to build the preceding `rust:nightly` image. We copy
    a binary executable file from the builder image using the `COPY` command with
    the `--from` parameter where we set the name of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This command copies the binary to the `/app` folder inside the image and we
    can use it as the entry point of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We also set the `RUST_LOG` environment variable and expose the port. Build this
    image by passing the name of this `Dockerfile` with the `-f` argument of the Docker
    build command and you will get an image with a single binary of the microservice
    inside. In other words, this approach allows us to build a microservice and reuse
    the compiled binary for a new image. You now know enough to pack your microservices
    to an image and now we can explore Docker Compose's ability to start a set of
    microservices and connect all launched containers to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Composing a microservice set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose is an awesome tool for deploying and running a set of microservices
    that can be connected each other. It helps you to define a multi-container application
    with configuration parameters in a human-readable YAML file. You are not limited
    to local deployment only and you can deploy it on a remote server on which the
    Docker daemon is also running.
  prefs: []
  type: TYPE_NORMAL
- en: In this section of the chapter, we will pack all our microservices with a database
    into a single application. You will learn how to set variables for Rust frameworks
    and loggers, how to connect microservices, how to define the order to start containers,
    how to read the logs of a running application, and how to use different configurations
    for testing and production.
  prefs: []
  type: TYPE_NORMAL
- en: Application definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker Compose is a tool that works with the YAML definition of an application.
    A YAML file can contain a declaration of containers, networks, and volumes. We
    will use version `3.6`. Create a `docker-compose.test.yml` file and add the following
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the `services` section, we will add all our microservices. Let's look at
    each container configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Database container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application needs a database instance. Both user and content microservices
    use the PostgreSQL database, and the dbsync worker applies all migrations if necessary.
    Look at these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We use the official PostgreSQL image. If the database fails, it will have to
    be restarted. We set the `restart` policy to `always`, which means the container
    will be restarted if it fails. We also set the user and password with environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Since we created a compose file for testing purposes, we forward a port of the
    container outside to connect to the database using the local client.
  prefs: []
  type: TYPE_NORMAL
- en: A container with an email server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need the SMTP server for our mailer service. We use the `juanluisbaptiste/postfix`
    image with the Postfix mail server. The server also has to be restarted if it
    fails and we set the `restart` policy to `always`. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We also configure the server using the environment variables and set the server
    name, username, password, and a hostname. To test the mail server, we forward
    port `25` of the mail server to a local `2525` port.
  prefs: []
  type: TYPE_NORMAL
- en: DBSync worker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can add the dbsync worker that applies migrations to a database instance.
    We use a local image that will be built with `Dockerfile` from the `./microservices/dbsync`
    folder that we used as a value for the `build` parameter. This worker depends
    on a database container (called `db`) and we set this dependency with the `depends_on`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies don't mean the dependant container will be started when the necessary
    application is ready to work. It only refers to the order in which containers
    are started; the application that your microservice needs might not be ready.
    You have to control the readiness of the application, as we did for dbsync, with
    a loop that tries to connect to a database till it is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we set the `RUST_LOG` variable with the filtering of messages with one
    level less than `debug` and printed messages related to the `dbsync_worker` module
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We also activated backtrace printing by setting the `RUST_BACKTRACE` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The last variable sets a connection link to a database. As you can see, we use
    the `db` name of the host since Docker configures containers to resolve names
    and match the names of other containers, so you don't need to set or remember
    the IP address of the container. You can use the names of containers as host names.
  prefs: []
  type: TYPE_NORMAL
- en: Mails microservice container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The microservice that sends emails to users builds on the image from the `Dockerfile`
    stored in the `./microservices/mails` folder. This microservice depends on the `smtp`
    container, but this microservice doesn''t check that the mail service is ready
    for work. If you want to check that the mail server is ready, add a piece of code
    that will try to connect to the SMTP server before starting any activity. Look
    at the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We also configure a microservice with environment variables and forward port
    `8002` to port `8000` of the container. You  can use port `8002` to check that
    the microservice started and works.
  prefs: []
  type: TYPE_NORMAL
- en: Users microservice container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The users microservice is built from the `Dockerfile` we created before. This
    microservice depends on two other containers—dbsync and mails. First, we need
    to have a table of users in the database to keep user records in; secondly, we
    need to have the ability to send email notifications to a user. We also set the
    address of the socket in the `USERS_ADDRESS` variable and the link for the connection
    in the `USERS_DATABASE` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Also, there is a setting to forward port `8000` of the container to the local
    port, `8001`, which you can use to access the microservice for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Content microservice container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The content microservice is built with the `Dockerfile` file in the `./microservices/content`
    folder. We also created this file earlier in this chapter. Since the content microservice
    is based on the Rocket framework, we can use the environment variables with the `ROCKET`
    prefix to configure the microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This microservice uses the database and depends on the `dbsync` container, which
    in turn depends on the `db` container with a database instance. We open port `8003`
    to access this microservice outside Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Router microservice container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last service we''ll configure before we start the whole application is
    the router microservice. This service depends on the users and content microservices,
    because router proxies request these microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We also configured logging with the `debug` level for the `router_microservice`
    namespace, turned on backtrace printing, set the socket address to bind this microservice
    to, and set paths to the users and content microservices with environment variables
    supported by the configuration. We used container names as host names, since Docker
    Compose configures containers to reach each other by name. We also forwarded port
    `8000` to the same system port. Now we can start the application with all of the
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the application, we will use the Docker Compose tool, which has to be
    installed (you can find useful links in the Technical Requirements section of
    this chapter). If the utility installed successfully, you''ll have the `docker-compose`
    command. Change the directory to a directory called `docker-compose.test.yml`
    and run the `up` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, it will build all the images if necessary and start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When all the containers are started, you will see the logs of all the containers
    in the terminal, prefixed by the name of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the application is started and you can connect to it with the browser using
    this link: `http://localhost:8000`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the application, use the *Ctrl+C* key combination. That will start
    the termination process and you will see it reflected in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If you restart the application, the database will be empty. Why? Because we
    stored the database on a temporary filesystem of the container. If you need persistence,
    you can attach a local folder to the container as a virtual volume. Let's explore
    this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Adding persistent state to the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We created an application that consists of microservices, and that doesn''t
    have a persistent state – the application is empty on every restart. Fixing this
    is simple: map the persistent volume to a folder of the container. Since no one
    microservice of our application keeps the data in files, but the PostgreSQL database
    does, we only need to attach a folder to a database container. Copy `docker-compose.test.yml`
    to `docker-compose.prod.yml` and add the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We attached a volume with the name `database_data` to the `/var/lib/postgresql/data`
    path of the database container. PostgreSQL uses this path by default to store
    database files. To declare a persistent volume, we use the `volume` section with
    the name of the volume. We set the `driver` parameter to `local` to keep the data
    on the local hard drive. Now the data is saved between restarts.
  prefs: []
  type: TYPE_NORMAL
- en: We also removed port forwarding for all of the microservices, excluding the
    router microservice, since all of the microservices are available via the inner
    virtual network of Docker and only the router has to be available outside the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We started the application by attaching the terminal to the output of the containers,
    but that''s inconvenient if you want to deploy an application to a remote server.
    To detach the terminal, use the `-d` parameter when you start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the application with a persistent state, and print something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It also detaches from the Terminal. You might ask: How can I read the logs
    that microservices print using `env_logger` and the `log` crate? Use the following
    command with the name of the service at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This command will print the logs of the `users_1` container, which represents
    the users service of the application. You can use the `grep` command to filter
    unnecessary records in logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the application detached from the terminal, you should use the down command
    to stop the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will stop all containers and finish with the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The application has stopped and now you know how to use the Docker Compose tool
    to run a multi-container application. If you want to learn more about using Docker
    Compose on local and remote machines, read this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to how to build images and run containers with your
    own microservices using Docker. We packed all of the microservices we created
    in [Chapter 9](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml), *Simple REST Definition
    and Request Routing with Frameworks**,* and [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *Involving
    Concurrency with Actors and the Actix Crate*, and learned how to build images
    manually and start a container. We also added the dbsync worker, which applied
    all necessary migrations and prepared a database for use with the users and content
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we considered approaches to hiding the source code of a microservice and
    used the cache of a container to copy a compiled binary to an empty image without
    building artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: In the second half of the chapter, we learned how to run multiple microservices
    with necessary dependencies (such as databases and mail servers) at once. We used
    the Docker Compose tool to describe the configuration of a microservice set with
    a running order and port forwarding. We also learned how to attach volumes to
    services (containers), to store persistent data, and to allow you to restart an
    application without any risk of losing data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to automate building microservices using
    continuous integration tools, helping you deliver the latest release of your product
    faster.
  prefs: []
  type: TYPE_NORMAL
