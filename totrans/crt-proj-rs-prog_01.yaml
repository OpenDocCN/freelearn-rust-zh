- en: 'Rust 2018: Productivity'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: The Rust Standard Library and tooling have improved a lot over the years. Since
    February 2018, the Rust ecosystem has become quite wide and multifaceted. Four
    domain working groups have been created, each covering one of the main application
    areas. These areas were already fairly mature, but this development allowed them
    to improve even further. In the coming years, we will see the introduction of
    other domain working groups as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: It's not an easy task to develop a high-quality and cost-effective application,
    even after learning a language as a developer. To avoid reinventing the (presumably
    low-quality) wheel, you as a developer should use a high-quality framework or
    some high-quality libraries that cover the kind of application you are going to
    develop.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this book is to guide you as a developer to choose the best open
    source Rust libraries available for developing software. This book covers several
    typical domains, each using different libraries. Because some non-standard libraries
    are useful in a number of different domains, it would be quite limiting to present
    them as confined to a single domain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different editions of Rust
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the most important recent improvements made to Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding domain working groups
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the kind of projects that we will cover in this book
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to some useful Rust libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow this book, you will need to have access to a computer on which a recent
    Rust system is installed. Any release since version 1.31 is okay. Some optional
    libraries will be listed for some specific projects later on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Any cited source code and additional examples can (and should) be downloaded
    from the repository: [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different editions of Rust
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On December 6, 2018, a very important version of the Rust language, its compiler,
    and its standard library was released: stable version **1.31**. This version has
    been defined as the **2018 edition**, meaning it is a milestone that will be used
    as a reference for the years to come.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Before this, there was another version, 1.0, which was defined as the **2015
    edition**. This edition was characterized by the word *stability*. Up until version
    1.0, every version of the compiler applied breaking changes to the language or
    to the standard library, forcing the developers to apply sweeping changes to their
    code base. From version 1.0, efforts have been made to ensure that any future
    version of the compiler can correctly compile any code written for version 1.0
    or successive versions. This is called **backward compatibility**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: However, many features were applied to the language and to the standard library before
    the release of the 2018 edition. Many new libraries used these new features, meaning
    that these libraries could not be used by older compilers. For this reason, there
    was a need to tag a specific version of Rust as aimed at being used with newer
    libraries. This was the main reason for the 2018 edition.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Some of the features added to the language are marked as for the 2015 edition,
    while others are marked as for the 2018 edition. The features for the 2015 edition are
    just small improvements, while the features for the 2018 edition are more in-depth
    changes. Developers must mark their crates as for the 2018 edition in order to
    use the features that are specific to the 2018 edition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: In addition, although the 2015 edition marked a stable milestone for the language
    and the standard library, the command-line tools were not actually stabilized;
    they were still quite immature. In the three and a half years from May 2015 to
    December 2018, the main official command-line tools have matured, and the language
    has also been improved to allow more efficient coding. The 2018 edition can be
    characterized by the word *productivity*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows a timeline of the features stabilized in the language,
    the standard library, and the tooling:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '| **2015** | **May**: 2015 edition | **August**: Parallel compilation on multi-core
    CPUs |  |  |  |  |  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| **2016** | **April**: Microsoft C compiler format supported | **May**: Ability
    to capture panics | **September**: Improved compiler error messages | **November**:
    The `?` operator | **December**: The `rustup` command |  |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| **2017** | **February**: Custom derive attributes | **March**: The cargo
    check command | **July**: The `union` keyword | **August**: Associated constants
    | **November**: The `?` operator with Option |  |  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| **2018** | **February**:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The formation of four Domain Working Groups.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rustfmt` program
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **May**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The Rust Programming Language Second Edition.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `impl` Trait language feature.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` can return a Result.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inclusive ranges with `..=`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *i128* and *u128* native types.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved patterns for `match`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **June**:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The SIMD library feature
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dyn` Trait language feature
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **August**: Custom global allocator | **September**:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The `cargo fix` command
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cargo clippy` command
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **October**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Procedural macros
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to the module system and the `use` statement
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw identifiers
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_std` applications'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **December**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The 2018 edition
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-lexical lifetimes
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `const fn` language feature
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new [https://www.rust-lang.org/](https://www.rust-lang.org/) website
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try`, `async`, and `await` are reserved words'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Many improvements have been applied since the 2015 edition. More information
    can be found in the official documentation ([https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html)).
    The most important improvements are listed as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: A new official tutorial book, available free online ([https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)),
    or printed on paper (*The Rust Programming Language* by Steve Klabnik and Carol
    Nichols).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A revamped official website.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The formation of four domain working groups, which are open committees to design
    the future of the ecosystem in four key areas:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: Designing the new asynchronous paradigm around a concept of
    delayed computation, named *future*, as it is already done in other languages,
    such as C++, C#, and JavaScript (with *promises*).'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command-line applications**: Designing some standard libraries to support
    any non-graphical, non-embedded applications.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebAssembly**: Designing tools and libraries to build applications to be
    run inside web browsers.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded software**: Designing tools and libraries to build applications
    to be run on bare-metal systems or on strictly constrained hardware.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We witnessed some good improvements to the language:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-lexical lifetimes; any bindings that are no longer used are considered
    *dead*. For example, now this program is allowed:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, the object bound to the variable `_a` is borrowed by the variable
    `_ref_to_a` in the second statement. Prior to the introduction of non-lexical
    lifetimes, such bindings would last till the end of the scope, and so the last
    statement would have been illegal because it tries to change that object through
    binding `_a` when it is still borrowed to variable `_ref_to_a`. Now, because variable `_ref_to_a`
    is no longer used, its lifetime ceases in the same line it is declared, and so,
    in the last statement, variable `_a` is again free to change its own object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The `Impl Trait` feature, which allows functions to return unspecified types,
    such as **closures**.
  id: totrans-63
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The `i128` and `u128` native types.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other reserved keywords such as `try`, `async`, and `await`.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `?` operator, usable even in the `main` function, because now it can return `Result`.
    The following program is an example of the `main` function returning a `Result`:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It can succeed, by returning the usual empty tuple or fail by returning the
    type you specify. In this case, it was `String`. The following program is an example
    using the `?` operator used in the `main` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This program will print `Found 1` on the standard output stream, meaning that
    the number `19` has been found at position `1`, and it will print `Error: 2` on
    the standard error stream, meaning that the number `20` hasn''t been found, but
    that it should be inserted at position `2`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Procedural macros, which allow a kind of meta-programming, manipulating source
    code to generate Rust code at compile time.
  id: totrans-71
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: More powerful and more ergonomic pattern matching in `match` expressions.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `match` 表达式中实现更强大和更直观的模式匹配。
- en: 'And also some improvements to the standard tooling:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及对标准工具的一些改进：
- en: The `rustup` program, which allows users to easily choose the default compiler
    target or to update the toolchain.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustup` 程序，它允许用户轻松选择默认的编译器目标或更新工具链。'
- en: The `rustfix` program, which converts a 2015 edition project to a 2018 edition project.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustfix` 程序，它将 2015 版本的项目转换为 2018 版本的项目。'
- en: The Clippy program, which checks for non-idiomatic syntax, and suggests changes
    to code for better maintainability.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clippy 程序，它检查非惯用语法，并为提高代码可维护性提出代码更改建议。
- en: Faster compilation speed, in particular, if just a syntax check is required.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的编译速度，特别是如果只需要进行语法检查的话。
- en: The **Rust Language Server** (**RLS**) program, which is currently still unstable,
    but which allows IDEs and programmable editors to spot syntax errors, and to suggest
    allowed operations.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust 语言服务器**（**RLS**）程序，目前仍然不稳定，但它允许 IDE 和可编程编辑器发现语法错误，并提出允许的操作。'
- en: 'Rust is still evolving as a language, like any other programming language.
    The following areas are still left to be improved:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 语言像任何其他编程语言一样仍在不断发展。以下领域仍需改进：
- en: The IDE tools, including a language interpreter (REPL) and a graphical debugger
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE 工具，包括语言解释器（REPL）和图形调试器
- en: Libraries and tools to support bare-metal and real-time software development
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持裸机实时软件开发库和工具
- en: Application-level frameworks and libraries for the main application areas
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要应用程序领域的应用程序级框架和库
- en: This book will focus primarily on the third point on this list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将主要关注列表上的第三点。
- en: The projects
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: When we write a real-world application, the Rust language and its standard library
    are not sufficient. Application frameworks are needed for particular kinds of
    applications, such as GUI apps, web apps, or games.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写现实世界应用程序时，Rust 语言及其标准库是不够的。需要特定类型的应用程序框架，例如 GUI 应用程序、网络应用程序或游戏。
- en: 'Of course, if you use a good-quality and comprehensive library, you can reduce
    the number of lines of code that you need to write. Using a library also offers
    the following two advantages:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你使用高质量和全面的库，你可以减少需要编写的代码行数。使用库还有以下两个优点：
- en: The overall design is improved, particularly if you are using a framework (since
    it imposes an architecture on your app) as it will be created by knowledgeable
    engineers and time-tested by a number of users.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体设计得到改进，尤其是如果您使用框架（因为它强加了一个架构到您的应用程序上），它将由知识渊博的工程师创建，并由众多用户经过时间考验。
- en: The number of bugs will be reduced because it will have undergone more thorough
    testing than that which you are likely to be able to apply.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误数量将减少，因为它们将经过比您可能能够应用的更彻底的测试。
- en: There are actually many Rust libraries, also known as **crates**, but most are
    low-quality or quite narrow in their range of applications. This book will look
    at the best quality and most complete libraries for some typical application areas
    of the Rust language.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有很多 Rust 库，也称为 **crates**，但大多数质量较低或应用范围相当狭窄。本书将探讨 Rust 语言一些典型应用领域的最佳质量和最完整的库。
- en: 'The application areas are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序领域如下：
- en: '**Web apps**: There are various popular technologies, including the following:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 应用程序**：有各种流行的技术，包括以下：'
- en: The REST web service (backend only)
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 网络服务（仅后端）
- en: An event-driven web client (frontend only)
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个事件驱动的网络客户端（仅前端）
- en: A full web app (full-stack)
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的网络应用程序（全栈）
- en: A web game (frontend only)
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅前端的一个网络游戏
- en: '**Games**: When I say *games*, I''m not referring to anything that is entertaining.
    I am referring to a graphical application where a continuous animation is shown,
    as opposed to event-driven graphical applications that do nothing until an event
    occurs, such as the user pressing a key, moving the mouse, or some data arriving
    from a connection. As well as games for the web browser, there are also games
    for desktop and laptop computers, for video game consoles, and for mobile devices.
    However, video game consoles and mobile devices are not yet that well supported
    by Rust, so we will only be looking at games for desktop and laptop computers
    in this book.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏**：当我说“游戏”时，我并不是指任何娱乐性的东西。我指的是一个显示连续动画的图形应用程序，与事件驱动的图形应用程序相反，后者在事件发生之前不做任何事情，例如用户按下键、移动鼠标或从连接中接收到一些数据。除了网页浏览器中的游戏，还有桌面和笔记本电脑游戏、游戏机游戏以及移动设备游戏。然而，游戏机和移动设备目前还没有得到Rust的良好支持，所以本书中我们将只探讨桌面和笔记本电脑游戏。'
- en: '**Language interpreters**: There are two kinds of languages that can be interpreted.
    Both are covered in this book:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言解释器**：有两种可以解释的语言。这两种语言都在本书中进行了介绍：'
- en: '**Text**: Like a programming language, a markup language, or a machine command
    language'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**：类似于编程语言、标记语言或机器命令语言'
- en: '**Binary**: Like the machine language of a computer to be emulated, or the
    intermediate bytecode of a programming language.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制**：类似于要模拟的计算机的机器语言，或编程语言的中间字节码。'
- en: '**C-language-callable libraries**: This is an important use case of Rust: to
    develop a library to be invoked by another application, typically written in a
    higher-level language. Rust cannot assume that other languages can invoke the
    Rust code, but it can assume that they can invoke the C-language code. We will
    look at how to build a library that can be invoked as if it were written in C.
    One particularly challenging case is to build a module for the Linux operating
    system, which notoriously has to be written in C.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C语言可调用的库**：这是Rust的一个重要用例：开发一个可以被其他应用程序调用的库，通常是用高级语言编写的。Rust不能假设其他语言可以调用Rust代码，但它可以假设它们可以调用C语言代码。我们将探讨如何构建一个可以像C语言编写的库一样调用的库。一个特别具有挑战性的案例是构建Linux操作系统的模块，它臭名昭著地必须用C语言编写。'
- en: Most applications read and write data to and from a file, or a communication
    channel, or a database. In the next chapter, we will be looking at various different
    techniques that will be useful for all the other projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都会从文件、通信通道或数据库中读取和写入数据。在下一章中，我们将探讨各种不同的技术，这些技术将对所有其他项目都有用。
- en: Other application areas have not been listed here as they are either not used
    much in Rust, they are still immature, or they are still in a state of flux. The
    libraries available for these immature areas will be completely different in a
    couple of years. These areas include software for micro-controllers, or other
    real-time or low-resource systems, and also software for mobile or wearable systems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他应用领域尚未在此列出，因为它们在Rust中要么使用不多，要么还不够成熟，或者它们仍然处于变动之中。这些不成熟领域的库在几年后将完全不同。这些领域包括微控制器软件、或其他实时或低资源系统软件，以及移动或可穿戴系统软件。
- en: Working through the examples in this book
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本书中通过示例进行实践
- en: To follow the examples in the book, you should download all the examples from the
    online repository: [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
    This repository contains a sub-folder for each chapter of the book and a sub-sub-folder
    for any project in a chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随书中的示例，您应该从在线仓库下载所有示例：[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)。此仓库包含每个章节的子文件夹，以及章节中任何项目的子子文件夹。
- en: For example, to run the `use_rand` project in this chapter, you should go to
    the `Chapter01/use_rand` folder and type `cargo run`. Notice that the most important
    files of any project are `cargo.toml` and `src/main.rs`, so you should always
    take a look at them first.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要运行本章中的`use_rand`项目，您应该前往`Chapter01/use_rand`文件夹，并输入`cargo run`。请注意，任何项目的最重要文件是`cargo.toml`和`src/main.rs`，因此您应该首先查看它们。
- en: Exploring some utility crates
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索一些实用工具包
- en: Before moving on to looking at how to use the most complex crates, let's take
    a look at some basic Rust crates. These are not a part of the standard library,
    but they are useful in many different kinds of projects. They should be known
    by all Rust developers since they are of general applicability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-random number generators – the rand crate
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to generate pseudo-random numbers is needed for several kinds of
    applications, especially for games. The `rand` crate is rather complex, but its
    basic usage is shown in the following example (named `use_rand`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, you create a pseudo-random number generator object. Then, you call several
    methods on this object. Any generator must be **mutable** because any generation
    modifies the state of the generator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The `gen_range` method generates an integer number in a right-open range. The
    `gen` generic method generates a number of the specified type. Sometimes, this
    type can be inferred, like in the last statement, where a Boolean is expected.
    If the generated type is a floating-point number, it is between 0 and 1, with
    1 excluded.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Logging – the log crate
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For any kind of software, in particular for servers, the ability to emit logging
    messages is essential. The logging architecture has two components:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**API**: Defined by the `log` crate'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation**: Defined by several possible crates'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, an example using the popular `env_logger` crate is shown. If you want
    to emit logging messages from a library, you should only add the API crate as
    a dependency, as it is the responsibility of the application to define the logging implementation
    crate.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example (named `use_env_logger`), we are showing an application
    (not a library), and so we need both crates:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a Unix-like console, after having run `cargo build`, execute the following
    command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It will print something like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By typing `RUST_LOG=debug` at the beginning of the command, you defined the
    temporary environment variable `RUST_LOG`, with `debug` as its value. The `debug`
    level is the highest, and hence all logging statements are performed. Instead,
    if you execute the following command, only the first three lines will be printed,
    as the `info` level is not detailed enough to print debug messages:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, if you execute the following command, only the first two lines will
    be printed, as the `warn` level is not detailed enough to print either the `debug`
    or the `info` messages:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you execute one or the other of the following commands, only the first line
    will be printed, as the default logging level is `error`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`RUST_LOG=error ./target/debug/use_env_logger`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./target/debug/use_env_logger`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing static variables at runtime – the lazy_static crate
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's well known that Rust does not allow *mutable static variables in safe code*.
    Immutable static variables are allowed in safe code, but they must be initialized
    by constant expressions, possibly by invoking `const fn` functions. However, the
    compiler must be able to evaluate the initialization expression of any static
    variable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，Rust不允许在安全代码中存在**可变静态变量**。在安全代码中允许存在不可变静态变量，但它们必须由常量表达式初始化，可能通过调用`const
    fn`函数来实现。然而，编译器必须能够评估任何静态变量的初始化表达式。
- en: Sometimes, however, there is a need to initialize a static variable at runtime,
    because the initial value depends on an input, such as a command-line argument
    or a configuration option. In addition, if the initialization of a variable takes
    a long time, instead of initializing it at the start of the program, it may be
    better to initialize it only the first time the variable is used. This technique
    is called **lazy initialization**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，然而，需要在使用时初始化静态变量，因为初始值取决于输入，如命令行参数或配置选项。此外，如果变量的初始化需要很长时间，而不是在程序开始时初始化它，那么可能最好只在变量第一次使用时初始化它。这种技术被称为**延迟初始化**。
- en: 'There is a small crate, named `lazy_static`, that contains only one macro,
    which has the same name as the crate. This can be used to solve the issue mentioned
    previously. Its use is shown in the following project (named `use_lazy_static`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小crate，名为`lazy_static`，它只包含一个与crate同名宏。这可以用来解决之前提到的问题。其使用方法如下（项目名为`use_lazy_static`）：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will print the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下输出：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the `main` function starts first. Then, it tries to access the
    `DICTIONARY` static variable, and that access causes the initialization of variables.
    The initialized value, which is a reference, is then dereferenced and printed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`main`函数首先开始执行。然后，它尝试访问`DICTIONARY`静态变量，这次访问导致变量的初始化。初始化的值，即一个引用，随后被解引用并打印出来。
- en: The last statement, which is identical to the previous one, does not perform the
    initialization again, as you can see by the fact that the `Initialized` text is
    not printed again.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句，与之前的语句相同，不会再次执行初始化，正如您所看到的，`Initialized`文本没有再次打印出来。
- en: Parsing the command line – the structopt crate
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析命令行 – structopt crate
- en: 'The command-line arguments of any program are easily accessible through the
    `std::env::args()` iterator. However, the code that parses these arguments is
    actually rather cumbersome. To get more maintainable code, the `structopt` crate
    can be used, as shown in the following project (named `use_structopt`):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序的命令行参数都很容易通过`std::env::args()`迭代器访问。然而，解析这些参数的代码实际上相当繁琐。为了获得更易于维护的代码，可以使用`structopt`
    crate，如下面的项目所示（项目名为`use_structopt`）：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you execute the `cargo run input1.txt input2.txt -v --result res.xyz` command, you
    should get the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行`cargo run input1.txt input2.txt -v --result res.xyz`命令，你应该得到以下输出：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the filenames `input1.txt` and `input2.txt` have been loaded
    into the `files` field of the structure. The `--result res.xyz` argument caused
    the `result_file` field to be filled, and the `-v` argument caused the `verbose` field
    to be set to `true`, instead of the default `false`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，文件名`input1.txt`和`input2.txt`已经被加载到结构的`files`字段中。`--result res.xyz`参数导致`result_file`字段被填充，而`-v`参数导致`verbose`字段被设置为`true`，而不是默认的`false`。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the new Rust 2018 edition. We learned about the
    kind of projects that are going to be described in this book. We then took a quick
    look at four useful crates which you can apply in your Rust code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了新的Rust 2018版。我们学习了本书将要描述的项目类型。然后，我们快速浏览了四个有用的crate，你可以在你的Rust代码中应用它们。
- en: In the next chapter, we will learn how to store or retrieve data to and from
    a file, a database, or another application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将数据存储或检索到文件、数据库或其他应用程序中。
- en: Questions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is there an official printed book to learn the Rust language?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有官方的Rust语言学习书籍？
- en: How long was the longest primitive Rust integer in 2015, and how long was it
    at the end of 2018?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2015年最长的原始Rust整数有多长，到2018年底又是多长？
- en: Which are the four domain working groups at the end of 2018?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2018年底有哪四个领域工作组？
- en: What is the purpose of the Clippy utility?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Clippy工具的目的何在？
- en: What is the purpose of the `rustfix` utility?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rustfix`工具的目的是什么？'
- en: Write a program that generates 10 pseudo-random `f32` numbers between 100 and
    400.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，生成10个介于100和400之间的伪随机`f32`数字。
- en: Write a program that generates 10 pseudo-random `i32` numbers between 100 and
    400 (without truncating or rounding the numbers generated by the previous exercise).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，生成10个介于100到400之间的伪随机`i32`数字（不截断或四舍五入前一个练习中生成的数字）。
- en: Write a program that creates a static vector containing all squared integers
    between 1 and 200.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，创建一个包含1到200之间所有平方整数的静态向量。
- en: Write a program that emits a warning message and an info message, and then run
    it so that only the warning message appears.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，输出警告信息和信息消息，然后运行它，以便只显示警告信息。
- en: Try to parse a command-line argument that contains a value from 1 to 20, emitting
    an error message if the value is out of range. The short option should be `-l`,
    and the long option should be `--level`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试解析一个包含1到20之间值的命令行参数，如果值超出范围，则输出错误信息。短选项应为`-l`，长选项应为`--level`。
