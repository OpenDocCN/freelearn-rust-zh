- en: 'Rust 2018: Productivity'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 2018：生产力
- en: The Rust Standard Library and tooling have improved a lot over the years. Since
    February 2018, the Rust ecosystem has become quite wide and multifaceted. Four
    domain working groups have been created, each covering one of the main application
    areas. These areas were already fairly mature, but this development allowed them
    to improve even further. In the coming years, we will see the introduction of
    other domain working groups as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 标准库和工具在过去几年中得到了很大的改进。自 2018 年 2 月以来，Rust 生态系统已经变得非常广泛和多样化。已经创建了四个领域工作小组，每个小组覆盖一个主要的应用领域。这些领域已经相当成熟，但这一发展使它们能够进一步改进。在未来几年，我们还将看到其他领域工作小组的引入。
- en: It's not an easy task to develop a high-quality and cost-effective application,
    even after learning a language as a developer. To avoid reinventing the (presumably
    low-quality) wheel, you as a developer should use a high-quality framework or
    some high-quality libraries that cover the kind of application you are going to
    develop.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使作为一个开发者学习了语言，开发一个高质量且成本效益高的应用程序也不是一件容易的事情。为了避免重复造（可能是低质量的）轮子，作为开发者，你应该使用一个高质量的框架或一些高质量的库，这些库涵盖了你要开发的类型的应用程序。
- en: The purpose of this book is to guide you as a developer to choose the best open
    source Rust libraries available for developing software. This book covers several
    typical domains, each using different libraries. Because some non-standard libraries
    are useful in a number of different domains, it would be quite limiting to present
    them as confined to a single domain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是指导你作为开发者选择最适合开发软件的开源 Rust 库。本书涵盖了几个典型领域，每个领域使用不同的库。由于一些非标准库在许多不同领域都有用，如果将它们限制在单一领域，将会非常局限。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Understanding the different editions of Rust
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Rust 的不同版本
- en: Understanding the most important recent improvements made to Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解最近对 Rust 做出的最重要的改进
- en: Understanding domain working groups
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解领域工作小组
- en: Understanding the kind of projects that we will cover in this book
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解本书中将涵盖的项目类型
- en: An introduction to some useful Rust libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些有用的 Rust 库简介
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow this book, you will need to have access to a computer on which a recent
    Rust system is installed. Any release since version 1.31 is okay. Some optional
    libraries will be listed for some specific projects later on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这本书，你需要访问一台安装了最新 Rust 系统的计算机。任何自 1.31 版本以来的版本都是可以的。稍后将为一些特定项目列出一些可选库。
- en: Any cited source code and additional examples can (and should) be downloaded
    from the repository: [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何引用的源代码和附加示例都可以（并且应该）从以下存储库下载：[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
- en: Understanding the different editions of Rust
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Rust 的不同版本
- en: 'On December 6, 2018, a very important version of the Rust language, its compiler,
    and its standard library was released: stable version **1.31**. This version has
    been defined as the **2018 edition**, meaning it is a milestone that will be used
    as a reference for the years to come.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2018 年 12 月 6 日，Rust 语言、其编译器和其标准库的一个非常重要的版本被发布：稳定版本 **1.31**。这个版本被定义为 **2018
    版本**，这意味着它是一个里程碑，将作为未来年份的参考。
- en: Before this, there was another version, 1.0, which was defined as the **2015
    edition**. This edition was characterized by the word *stability*. Up until version
    1.0, every version of the compiler applied breaking changes to the language or
    to the standard library, forcing the developers to apply sweeping changes to their
    code base. From version 1.0, efforts have been made to ensure that any future
    version of the compiler can correctly compile any code written for version 1.0
    or successive versions. This is called **backward compatibility**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，还有一个版本，1.0，被定义为 **2015 版本**。这个版本的特点是 *稳定性*。直到版本 1.0，编译器的每个版本都对语言或标准库进行了破坏性更改，迫使开发者对其代码库进行大规模的更改。从版本
    1.0 开始，已经做出了努力，以确保任何未来的编译器版本都可以正确编译为版本 1.0 或后续版本编写的任何代码。这被称为 **向后兼容性**。
- en: However, many features were applied to the language and to the standard library before
    the release of the 2018 edition. Many new libraries used these new features, meaning
    that these libraries could not be used by older compilers. For this reason, there
    was a need to tag a specific version of Rust as aimed at being used with newer
    libraries. This was the main reason for the 2018 edition.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 2018 版本发布之前，许多功能已经应用于语言和标准库。许多新库使用了这些新功能，这意味着这些库不能由较旧的编译器使用。因此，有必要将 Rust
    的一个特定版本标记为旨在与较新库一起使用。这是 2018 版本的主要原因。
- en: Some of the features added to the language are marked as for the 2015 edition,
    while others are marked as for the 2018 edition. The features for the 2015 edition are
    just small improvements, while the features for the 2018 edition are more in-depth
    changes. Developers must mark their crates as for the 2018 edition in order to
    use the features that are specific to the 2018 edition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到语言的一些功能被标记为 2015 版本，而其他功能被标记为 2018 版本。2015 版本的功能只是小改进，而 2018 版本的功能是更深入的变化。开发者必须将他们的
    crate 标记为 2018 版本，才能使用特定于 2018 版本的功能。
- en: In addition, although the 2015 edition marked a stable milestone for the language
    and the standard library, the command-line tools were not actually stabilized;
    they were still quite immature. In the three and a half years from May 2015 to
    December 2018, the main official command-line tools have matured, and the language
    has also been improved to allow more efficient coding. The 2018 edition can be
    characterized by the word *productivity*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管 2015 版本标志着语言和标准库的稳定里程碑，但命令行工具实际上并没有稳定；它们仍然相当不成熟。从 2015 年 5 月到 2018 年 12
    月的三年半时间里，主要的官方命令行工具已经成熟，语言也得到了改进，以允许更高效的编码。2018 版本可以用“生产力”这个词来描述。
- en: 'The following table shows a timeline of the features stabilized in the language,
    the standard library, and the tooling:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了语言、标准库和工具中稳定的功能的时间线：
- en: '| **2015** | **May**: 2015 edition | **August**: Parallel compilation on multi-core
    CPUs |  |  |  |  |  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **2015** | **五月**: 2015 版本 | **八月**: 多核 CPU 上的并行编译 |  |  |  |  |  |'
- en: '| **2016** | **April**: Microsoft C compiler format supported | **May**: Ability
    to capture panics | **September**: Improved compiler error messages | **November**:
    The `?` operator | **December**: The `rustup` command |  |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **2016** | **四月**: 支持微软 C 编译器格式 | **五月**: 捕获 panic 的能力 | **九月**: 改进的编译器错误信息
    | **十一月**: `?` 操作符 | **十二月**: `rustup` 命令 |  |  |'
- en: '| **2017** | **February**: Custom derive attributes | **March**: The cargo
    check command | **July**: The `union` keyword | **August**: Associated constants
    | **November**: The `?` operator with Option |  |  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **2017** | **二月**: 自定义 derive 属性 | **三月**: cargo check 命令 | **七月**: `union`
    关键字 | **八月**: 关联常量 | **十一月**: 与 Option 一起的 `?` 操作符 |  |  |'
- en: '| **2018** | **February**:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| **2018** | **二月**:'
- en: The formation of four Domain Working Groups.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个领域工作组的形成。
- en: The `rustfmt` program
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustfmt` 程序'
- en: '| **May**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '| **五月**:'
- en: The Rust Programming Language Second Edition.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 编程语言第二版。
- en: The `impl` Trait language feature.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`impl` 特性语言功能。'
- en: '`main` can return a Result.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main` 可以返回一个 Result。'
- en: Inclusive ranges with `..=`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `..=` 的包含范围
- en: The *i128* and *u128* native types.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地类型 *i128* 和 *u128*。
- en: Improved patterns for `match`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match` 的改进模式'
- en: '| **June**:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '| **六月**:'
- en: The SIMD library feature
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SIMD 库功能
- en: The `dyn` Trait language feature
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dyn` 特性语言功能'
- en: '| **August**: Custom global allocator | **September**:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '| **八月**: 自定义全局分配器 | **九月**:'
- en: The `cargo fix` command
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo fix` 命令'
- en: The `cargo clippy` command
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo clippy` 命令'
- en: '| **October**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '| **十月**:'
- en: Procedural macros
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程宏
- en: Changes to the module system and the `use` statement
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块系统和 `use` 语句的更改
- en: Raw identifiers
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始标识符
- en: '`no_std` applications'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_std` 应用程序'
- en: '| **December**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '| **十二月**:'
- en: The 2018 edition
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2018 版本
- en: Non-lexical lifetimes
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非词法生命周期
- en: The `const fn` language feature
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const fn` 语言功能'
- en: The new [https://www.rust-lang.org/](https://www.rust-lang.org/) website
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 [https://www.rust-lang.org/](https://www.rust-lang.org/) 网站
- en: '`try`, `async`, and `await` are reserved words'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`、`async` 和 `await` 是保留字'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Many improvements have been applied since the 2015 edition. More information
    can be found in the official documentation ([https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html)).
    The most important improvements are listed as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自2015年版以来，已经应用了许多改进。更多信息可以在官方文档中找到（[https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html))。以下列出了最重要的改进：
- en: A new official tutorial book, available free online ([https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)),
    or printed on paper (*The Rust Programming Language* by Steve Klabnik and Carol
    Nichols).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一本新的官方教程书籍，免费在线提供（[https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/))，或打印在纸上（由
    Steve Klabnik 和 Carol Nichols 编写的 *Rust 编程语言*）。
- en: A revamped official website.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全新的官方网站。
- en: 'The formation of four domain working groups, which are open committees to design
    the future of the ecosystem in four key areas:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成立了四个领域工作组，这些是开放委员会，旨在设计四个关键领域的生态系统未来：
- en: '**Networking**: Designing the new asynchronous paradigm around a concept of
    delayed computation, named *future*, as it is already done in other languages,
    such as C++, C#, and JavaScript (with *promises*).'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络编程**：围绕延迟计算的概念设计新的异步范式，称为 *future*，就像在其他语言中已经做的那样，例如 C++、C# 和 JavaScript（使用
    *promises*）。'
- en: '**Command-line applications**: Designing some standard libraries to support
    any non-graphical, non-embedded applications.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行应用程序**：设计一些标准库来支持任何非图形、非嵌入式应用程序。'
- en: '**WebAssembly**: Designing tools and libraries to build applications to be
    run inside web browsers.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebAssembly**：设计工具和库来构建可在网页浏览器中运行的应用程序。'
- en: '**Embedded software**: Designing tools and libraries to build applications
    to be run on bare-metal systems or on strictly constrained hardware.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入式软件**：设计工具和库来构建在裸机系统或严格受限的硬件上运行的应用程序。'
- en: 'We witnessed some good improvements to the language:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们见证了语言的一些良好改进：
- en: 'Non-lexical lifetimes; any bindings that are no longer used are considered
    *dead*. For example, now this program is allowed:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非词法生命周期；任何不再使用的绑定都被认为是 *已死亡*。例如，现在这个程序是被允许的：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, the object bound to the variable `_a` is borrowed by the variable
    `_ref_to_a` in the second statement. Prior to the introduction of non-lexical
    lifetimes, such bindings would last till the end of the scope, and so the last
    statement would have been illegal because it tries to change that object through
    binding `_a` when it is still borrowed to variable `_ref_to_a`. Now, because variable `_ref_to_a`
    is no longer used, its lifetime ceases in the same line it is declared, and so,
    in the last statement, variable `_a` is again free to change its own object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，变量 `_a` 绑定的对象在第二个语句中被变量 `_ref_to_a` 借用。在非词法生命周期的引入之前，此类绑定会持续到作用域的末尾，因此最后一个语句将是非法的，因为它试图在
    `_ref_to_a` 仍然借用该对象时通过绑定 `_a` 来更改该对象。现在，因为变量 `_ref_to_a` 不再使用，其生命周期在声明它的同一行结束，因此，在最后一个语句中，变量
    `_a` 再次可以自由地更改其对象。
- en: The `Impl Trait` feature, which allows functions to return unspecified types,
    such as **closures**.
  id: totrans-63
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Impl Trait` 功能，允许函数返回未指定的类型，例如 **闭包**。'
- en: The `i128` and `u128` native types.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i128` 和 `u128` 本地类型。'
- en: Some other reserved keywords such as `try`, `async`, and `await`.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些其他保留关键字，例如 `try`、`async` 和 `await`。
- en: 'The `?` operator, usable even in the `main` function, because now it can return `Result`.
    The following program is an example of the `main` function returning a `Result`:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 操作符，即使在 `main` 函数中也可以使用，因为它现在可以返回 `Result`。以下是一个 `main` 函数返回 `Result` 的程序示例：'
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It can succeed, by returning the usual empty tuple or fail by returning the
    type you specify. In this case, it was `String`. The following program is an example
    using the `?` operator used in the `main` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过返回通常的空元组或通过返回你指定的类型来成功，在这种情况下是 `String`。以下是一个使用 `?` 操作符的示例，该操作符在 `main`
    函数中使用：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This program will print `Found 1` on the standard output stream, meaning that
    the number `19` has been found at position `1`, and it will print `Error: 2` on
    the standard error stream, meaning that the number `20` hasn''t been found, but
    that it should be inserted at position `2`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '这个程序将在标准输出流上打印 `Found 1`，这意味着数字 `19` 在位置 `1` 被找到，并且它将在标准错误流上打印 `Error: 2`，这意味着数字
    `20` 没有被找到，但它应该被插入到位置 `2`。'
- en: Procedural macros, which allow a kind of meta-programming, manipulating source
    code to generate Rust code at compile time.
  id: totrans-71
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程宏，允许一种元编程，在编译时通过操作源代码生成 Rust 代码。
- en: More powerful and more ergonomic pattern matching in `match` expressions.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `match` 表达式中实现更强大和更直观的模式匹配。
- en: 'And also some improvements to the standard tooling:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及对标准工具的一些改进：
- en: The `rustup` program, which allows users to easily choose the default compiler
    target or to update the toolchain.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustup` 程序，它允许用户轻松选择默认的编译器目标或更新工具链。'
- en: The `rustfix` program, which converts a 2015 edition project to a 2018 edition project.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustfix` 程序，它将 2015 版本的项目转换为 2018 版本的项目。'
- en: The Clippy program, which checks for non-idiomatic syntax, and suggests changes
    to code for better maintainability.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clippy 程序，它检查非惯用语法，并为提高代码可维护性提出代码更改建议。
- en: Faster compilation speed, in particular, if just a syntax check is required.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的编译速度，特别是如果只需要进行语法检查的话。
- en: The **Rust Language Server** (**RLS**) program, which is currently still unstable,
    but which allows IDEs and programmable editors to spot syntax errors, and to suggest
    allowed operations.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust 语言服务器**（**RLS**）程序，目前仍然不稳定，但它允许 IDE 和可编程编辑器发现语法错误，并提出允许的操作。'
- en: 'Rust is still evolving as a language, like any other programming language.
    The following areas are still left to be improved:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 语言像任何其他编程语言一样仍在不断发展。以下领域仍需改进：
- en: The IDE tools, including a language interpreter (REPL) and a graphical debugger
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE 工具，包括语言解释器（REPL）和图形调试器
- en: Libraries and tools to support bare-metal and real-time software development
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持裸机实时软件开发库和工具
- en: Application-level frameworks and libraries for the main application areas
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要应用程序领域的应用程序级框架和库
- en: This book will focus primarily on the third point on this list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将主要关注列表上的第三点。
- en: The projects
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: When we write a real-world application, the Rust language and its standard library
    are not sufficient. Application frameworks are needed for particular kinds of
    applications, such as GUI apps, web apps, or games.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写现实世界应用程序时，Rust 语言及其标准库是不够的。需要特定类型的应用程序框架，例如 GUI 应用程序、网络应用程序或游戏。
- en: 'Of course, if you use a good-quality and comprehensive library, you can reduce
    the number of lines of code that you need to write. Using a library also offers
    the following two advantages:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你使用高质量和全面的库，你可以减少需要编写的代码行数。使用库还有以下两个优点：
- en: The overall design is improved, particularly if you are using a framework (since
    it imposes an architecture on your app) as it will be created by knowledgeable
    engineers and time-tested by a number of users.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体设计得到改进，尤其是如果您使用框架（因为它强加了一个架构到您的应用程序上），它将由知识渊博的工程师创建，并由众多用户经过时间考验。
- en: The number of bugs will be reduced because it will have undergone more thorough
    testing than that which you are likely to be able to apply.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误数量将减少，因为它们将经过比您可能能够应用的更彻底的测试。
- en: There are actually many Rust libraries, also known as **crates**, but most are
    low-quality or quite narrow in their range of applications. This book will look
    at the best quality and most complete libraries for some typical application areas
    of the Rust language.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有很多 Rust 库，也称为 **crates**，但大多数质量较低或应用范围相当狭窄。本书将探讨 Rust 语言一些典型应用领域的最佳质量和最完整的库。
- en: 'The application areas are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序领域如下：
- en: '**Web apps**: There are various popular technologies, including the following:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 应用程序**：有各种流行的技术，包括以下：'
- en: The REST web service (backend only)
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 网络服务（仅后端）
- en: An event-driven web client (frontend only)
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个事件驱动的网络客户端（仅前端）
- en: A full web app (full-stack)
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的网络应用程序（全栈）
- en: A web game (frontend only)
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅前端的一个网络游戏
- en: '**Games**: When I say *games*, I''m not referring to anything that is entertaining.
    I am referring to a graphical application where a continuous animation is shown,
    as opposed to event-driven graphical applications that do nothing until an event
    occurs, such as the user pressing a key, moving the mouse, or some data arriving
    from a connection. As well as games for the web browser, there are also games
    for desktop and laptop computers, for video game consoles, and for mobile devices.
    However, video game consoles and mobile devices are not yet that well supported
    by Rust, so we will only be looking at games for desktop and laptop computers
    in this book.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏**：当我说“游戏”时，我并不是指任何娱乐性的东西。我指的是一个显示连续动画的图形应用程序，与事件驱动的图形应用程序相反，后者在事件发生之前不做任何事情，例如用户按下键、移动鼠标或从连接中接收到一些数据。除了网页浏览器中的游戏，还有桌面和笔记本电脑游戏、游戏机游戏以及移动设备游戏。然而，游戏机和移动设备目前还没有得到Rust的良好支持，所以本书中我们将只探讨桌面和笔记本电脑游戏。'
- en: '**Language interpreters**: There are two kinds of languages that can be interpreted.
    Both are covered in this book:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言解释器**：有两种可以解释的语言。这两种语言都在本书中进行了介绍：'
- en: '**Text**: Like a programming language, a markup language, or a machine command
    language'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**：类似于编程语言、标记语言或机器命令语言'
- en: '**Binary**: Like the machine language of a computer to be emulated, or the
    intermediate bytecode of a programming language.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制**：类似于要模拟的计算机的机器语言，或编程语言的中间字节码。'
- en: '**C-language-callable libraries**: This is an important use case of Rust: to
    develop a library to be invoked by another application, typically written in a
    higher-level language. Rust cannot assume that other languages can invoke the
    Rust code, but it can assume that they can invoke the C-language code. We will
    look at how to build a library that can be invoked as if it were written in C.
    One particularly challenging case is to build a module for the Linux operating
    system, which notoriously has to be written in C.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C语言可调用的库**：这是Rust的一个重要用例：开发一个可以被其他应用程序调用的库，通常是用高级语言编写的。Rust不能假设其他语言可以调用Rust代码，但它可以假设它们可以调用C语言代码。我们将探讨如何构建一个可以像C语言编写的库一样调用的库。一个特别具有挑战性的案例是构建Linux操作系统的模块，它臭名昭著地必须用C语言编写。'
- en: Most applications read and write data to and from a file, or a communication
    channel, or a database. In the next chapter, we will be looking at various different
    techniques that will be useful for all the other projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都会从文件、通信通道或数据库中读取和写入数据。在下一章中，我们将探讨各种不同的技术，这些技术将对所有其他项目都有用。
- en: Other application areas have not been listed here as they are either not used
    much in Rust, they are still immature, or they are still in a state of flux. The
    libraries available for these immature areas will be completely different in a
    couple of years. These areas include software for micro-controllers, or other
    real-time or low-resource systems, and also software for mobile or wearable systems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他应用领域尚未在此列出，因为它们在Rust中要么使用不多，要么还不够成熟，或者它们仍然处于变动之中。这些不成熟领域的库在几年后将完全不同。这些领域包括微控制器软件、或其他实时或低资源系统软件，以及移动或可穿戴系统软件。
- en: Working through the examples in this book
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本书中通过示例进行实践
- en: To follow the examples in the book, you should download all the examples from the
    online repository: [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
    This repository contains a sub-folder for each chapter of the book and a sub-sub-folder
    for any project in a chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随书中的示例，您应该从在线仓库下载所有示例：[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)。此仓库包含每个章节的子文件夹，以及章节中任何项目的子子文件夹。
- en: For example, to run the `use_rand` project in this chapter, you should go to
    the `Chapter01/use_rand` folder and type `cargo run`. Notice that the most important
    files of any project are `cargo.toml` and `src/main.rs`, so you should always
    take a look at them first.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要运行本章中的`use_rand`项目，您应该前往`Chapter01/use_rand`文件夹，并输入`cargo run`。请注意，任何项目的最重要文件是`cargo.toml`和`src/main.rs`，因此您应该首先查看它们。
- en: Exploring some utility crates
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索一些实用工具包
- en: Before moving on to looking at how to use the most complex crates, let's take
    a look at some basic Rust crates. These are not a part of the standard library,
    but they are useful in many different kinds of projects. They should be known
    by all Rust developers since they are of general applicability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续查看如何使用最复杂的包之前，让我们先看看一些基本的 Rust 包。这些不是标准库的一部分，但它们在许多不同类型的项目中都很实用。所有 Rust 开发者都应该了解它们，因为它们具有通用适用性。
- en: Pseudo-random number generators – the rand crate
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪随机数生成器 – rand 包
- en: 'The ability to generate pseudo-random numbers is needed for several kinds of
    applications, especially for games. The `rand` crate is rather complex, but its
    basic usage is shown in the following example (named `use_rand`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 生成伪随机数的能力对于多种应用都是必需的，特别是对于游戏。`rand` 包相当复杂，但它的基本用法在以下示例（命名为 `use_rand`）中展示：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, you create a pseudo-random number generator object. Then, you call several
    methods on this object. Any generator must be **mutable** because any generation
    modifies the state of the generator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个伪随机数生成器对象。然后，你在这个对象上调用几个方法。任何生成器都必须是 **可变的**，因为任何生成都会修改生成器的状态。
- en: The `gen_range` method generates an integer number in a right-open range. The
    `gen` generic method generates a number of the specified type. Sometimes, this
    type can be inferred, like in the last statement, where a Boolean is expected.
    If the generated type is a floating-point number, it is between 0 and 1, with
    1 excluded.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen_range` 方法在右开区间内生成一个整数。`gen` 泛型方法生成指定类型的数字。有时，这种类型可以推断出来，就像在最后一个语句中，期望的是一个布尔值。如果生成的类型是浮点数，它在
    0 和 1 之间，但不包括 1。'
- en: Logging – the log crate
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录 – log 包
- en: 'For any kind of software, in particular for servers, the ability to emit logging
    messages is essential. The logging architecture has two components:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何类型的软件，特别是对于服务器，发出日志消息的能力是必不可少的。日志架构有两个组件：
- en: '**API**: Defined by the `log` crate'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：由 `log` 包定义'
- en: '**Implementation**: Defined by several possible crates'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现**：由几个可能的包定义'
- en: Here, an example using the popular `env_logger` crate is shown. If you want
    to emit logging messages from a library, you should only add the API crate as
    a dependency, as it is the responsibility of the application to define the logging implementation
    crate.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，展示了使用流行的 `env_logger` 包的示例。如果你想要从库中发出日志消息，你应该只添加 API 包作为依赖项，因为定义日志实现包是应用程序的责任。
- en: 'In the following example (named `use_env_logger`), we are showing an application
    (not a library), and so we need both crates:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例（命名为 `use_env_logger`）中，我们展示了一个应用程序（而不是库），因此我们需要这两个包：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a Unix-like console, after having run `cargo build`, execute the following
    command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 类似控制台中，在运行 `cargo build` 之后，执行以下命令：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It will print something like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印类似以下内容：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By typing `RUST_LOG=debug` at the beginning of the command, you defined the
    temporary environment variable `RUST_LOG`, with `debug` as its value. The `debug`
    level is the highest, and hence all logging statements are performed. Instead,
    if you execute the following command, only the first three lines will be printed,
    as the `info` level is not detailed enough to print debug messages:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令开始处输入 `RUST_LOG=debug`，你定义了临时环境变量 `RUST_LOG`，其值为 `debug`。`debug` 级别是最高的，因此所有日志语句都会执行。相反，如果你执行以下命令，只有前三条线将被打印，因为
    `info` 级别不够详细，无法打印调试信息：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, if you execute the following command, only the first two lines will
    be printed, as the `warn` level is not detailed enough to print either the `debug`
    or the `info` messages:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你执行以下命令，只有前两行将被打印，因为 `warn` 级别不够详细，无法打印 `debug` 或 `info` 消息：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you execute one or the other of the following commands, only the first line
    will be printed, as the default logging level is `error`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行以下命令之一，只有第一行将被打印，因为默认的日志级别是 `error`：
- en: '`RUST_LOG=error ./target/debug/use_env_logger`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUST_LOG=error ./target/debug/use_env_logger`'
- en: '`./target/debug/use_env_logger`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./target/debug/use_env_logger`'
- en: Initializing static variables at runtime – the lazy_static crate
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时初始化静态变量 – lazy_static 包
- en: It's well known that Rust does not allow *mutable static variables in safe code*.
    Immutable static variables are allowed in safe code, but they must be initialized
    by constant expressions, possibly by invoking `const fn` functions. However, the
    compiler must be able to evaluate the initialization expression of any static
    variable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，Rust不允许在安全代码中存在**可变静态变量**。在安全代码中允许存在不可变静态变量，但它们必须由常量表达式初始化，可能通过调用`const
    fn`函数来实现。然而，编译器必须能够评估任何静态变量的初始化表达式。
- en: Sometimes, however, there is a need to initialize a static variable at runtime,
    because the initial value depends on an input, such as a command-line argument
    or a configuration option. In addition, if the initialization of a variable takes
    a long time, instead of initializing it at the start of the program, it may be
    better to initialize it only the first time the variable is used. This technique
    is called **lazy initialization**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，然而，需要在使用时初始化静态变量，因为初始值取决于输入，如命令行参数或配置选项。此外，如果变量的初始化需要很长时间，而不是在程序开始时初始化它，那么可能最好只在变量第一次使用时初始化它。这种技术被称为**延迟初始化**。
- en: 'There is a small crate, named `lazy_static`, that contains only one macro,
    which has the same name as the crate. This can be used to solve the issue mentioned
    previously. Its use is shown in the following project (named `use_lazy_static`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小crate，名为`lazy_static`，它只包含一个与crate同名宏。这可以用来解决之前提到的问题。其使用方法如下（项目名为`use_lazy_static`）：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will print the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下输出：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the `main` function starts first. Then, it tries to access the
    `DICTIONARY` static variable, and that access causes the initialization of variables.
    The initialized value, which is a reference, is then dereferenced and printed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`main`函数首先开始执行。然后，它尝试访问`DICTIONARY`静态变量，这次访问导致变量的初始化。初始化的值，即一个引用，随后被解引用并打印出来。
- en: The last statement, which is identical to the previous one, does not perform the
    initialization again, as you can see by the fact that the `Initialized` text is
    not printed again.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句，与之前的语句相同，不会再次执行初始化，正如您所看到的，`Initialized`文本没有再次打印出来。
- en: Parsing the command line – the structopt crate
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析命令行 – structopt crate
- en: 'The command-line arguments of any program are easily accessible through the
    `std::env::args()` iterator. However, the code that parses these arguments is
    actually rather cumbersome. To get more maintainable code, the `structopt` crate
    can be used, as shown in the following project (named `use_structopt`):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序的命令行参数都很容易通过`std::env::args()`迭代器访问。然而，解析这些参数的代码实际上相当繁琐。为了获得更易于维护的代码，可以使用`structopt`
    crate，如下面的项目所示（项目名为`use_structopt`）：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you execute the `cargo run input1.txt input2.txt -v --result res.xyz` command, you
    should get the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行`cargo run input1.txt input2.txt -v --result res.xyz`命令，你应该得到以下输出：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the filenames `input1.txt` and `input2.txt` have been loaded
    into the `files` field of the structure. The `--result res.xyz` argument caused
    the `result_file` field to be filled, and the `-v` argument caused the `verbose` field
    to be set to `true`, instead of the default `false`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，文件名`input1.txt`和`input2.txt`已经被加载到结构的`files`字段中。`--result res.xyz`参数导致`result_file`字段被填充，而`-v`参数导致`verbose`字段被设置为`true`，而不是默认的`false`。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the new Rust 2018 edition. We learned about the
    kind of projects that are going to be described in this book. We then took a quick
    look at four useful crates which you can apply in your Rust code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了新的Rust 2018版。我们学习了本书将要描述的项目类型。然后，我们快速浏览了四个有用的crate，你可以在你的Rust代码中应用它们。
- en: In the next chapter, we will learn how to store or retrieve data to and from
    a file, a database, or another application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将数据存储或检索到文件、数据库或其他应用程序中。
- en: Questions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is there an official printed book to learn the Rust language?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有官方的Rust语言学习书籍？
- en: How long was the longest primitive Rust integer in 2015, and how long was it
    at the end of 2018?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2015年最长的原始Rust整数有多长，到2018年底又是多长？
- en: Which are the four domain working groups at the end of 2018?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2018年底有哪四个领域工作组？
- en: What is the purpose of the Clippy utility?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Clippy工具的目的何在？
- en: What is the purpose of the `rustfix` utility?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rustfix`工具的目的是什么？'
- en: Write a program that generates 10 pseudo-random `f32` numbers between 100 and
    400.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，生成10个介于100和400之间的伪随机`f32`数字。
- en: Write a program that generates 10 pseudo-random `i32` numbers between 100 and
    400 (without truncating or rounding the numbers generated by the previous exercise).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，生成10个介于100到400之间的伪随机`i32`数字（不截断或四舍五入前一个练习中生成的数字）。
- en: Write a program that creates a static vector containing all squared integers
    between 1 and 200.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，创建一个包含1到200之间所有平方整数的静态向量。
- en: Write a program that emits a warning message and an info message, and then run
    it so that only the warning message appears.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，输出警告信息和信息消息，然后运行它，以便只显示警告信息。
- en: Try to parse a command-line argument that contains a value from 1 to 20, emitting
    an error message if the value is out of range. The short option should be `-l`,
    and the long option should be `--level`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试解析一个包含1到20之间值的命令行参数，如果值超出范围，则输出错误信息。短选项应为`-l`，长选项应为`--level`。
