- en: 'Rust 2018: Productivity'
  prefs: []
  type: TYPE_NORMAL
- en: The Rust Standard Library and tooling have improved a lot over the years. Since
    February 2018, the Rust ecosystem has become quite wide and multifaceted. Four
    domain working groups have been created, each covering one of the main application
    areas. These areas were already fairly mature, but this development allowed them
    to improve even further. In the coming years, we will see the introduction of
    other domain working groups as well.
  prefs: []
  type: TYPE_NORMAL
- en: It's not an easy task to develop a high-quality and cost-effective application,
    even after learning a language as a developer. To avoid reinventing the (presumably
    low-quality) wheel, you as a developer should use a high-quality framework or
    some high-quality libraries that cover the kind of application you are going to
    develop.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this book is to guide you as a developer to choose the best open
    source Rust libraries available for developing software. This book covers several
    typical domains, each using different libraries. Because some non-standard libraries
    are useful in a number of different domains, it would be quite limiting to present
    them as confined to a single domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different editions of Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the most important recent improvements made to Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding domain working groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the kind of projects that we will cover in this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to some useful Rust libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow this book, you will need to have access to a computer on which a recent
    Rust system is installed. Any release since version 1.31 is okay. Some optional
    libraries will be listed for some specific projects later on.
  prefs: []
  type: TYPE_NORMAL
- en: Any cited source code and additional examples can (and should) be downloaded
    from the repository: [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different editions of Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On December 6, 2018, a very important version of the Rust language, its compiler,
    and its standard library was released: stable version **1.31**. This version has
    been defined as the **2018 edition**, meaning it is a milestone that will be used
    as a reference for the years to come.'
  prefs: []
  type: TYPE_NORMAL
- en: Before this, there was another version, 1.0, which was defined as the **2015
    edition**. This edition was characterized by the word *stability*. Up until version
    1.0, every version of the compiler applied breaking changes to the language or
    to the standard library, forcing the developers to apply sweeping changes to their
    code base. From version 1.0, efforts have been made to ensure that any future
    version of the compiler can correctly compile any code written for version 1.0
    or successive versions. This is called **backward compatibility**.
  prefs: []
  type: TYPE_NORMAL
- en: However, many features were applied to the language and to the standard library before
    the release of the 2018 edition. Many new libraries used these new features, meaning
    that these libraries could not be used by older compilers. For this reason, there
    was a need to tag a specific version of Rust as aimed at being used with newer
    libraries. This was the main reason for the 2018 edition.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the features added to the language are marked as for the 2015 edition,
    while others are marked as for the 2018 edition. The features for the 2015 edition are
    just small improvements, while the features for the 2018 edition are more in-depth
    changes. Developers must mark their crates as for the 2018 edition in order to
    use the features that are specific to the 2018 edition.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, although the 2015 edition marked a stable milestone for the language
    and the standard library, the command-line tools were not actually stabilized;
    they were still quite immature. In the three and a half years from May 2015 to
    December 2018, the main official command-line tools have matured, and the language
    has also been improved to allow more efficient coding. The 2018 edition can be
    characterized by the word *productivity*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows a timeline of the features stabilized in the language,
    the standard library, and the tooling:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **2015** | **May**: 2015 edition | **August**: Parallel compilation on multi-core
    CPUs |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **2016** | **April**: Microsoft C compiler format supported | **May**: Ability
    to capture panics | **September**: Improved compiler error messages | **November**:
    The `?` operator | **December**: The `rustup` command |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **2017** | **February**: Custom derive attributes | **March**: The cargo
    check command | **July**: The `union` keyword | **August**: Associated constants
    | **November**: The `?` operator with Option |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **2018** | **February**:'
  prefs: []
  type: TYPE_NORMAL
- en: The formation of four Domain Working Groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rustfmt` program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **May**:'
  prefs: []
  type: TYPE_NORMAL
- en: The Rust Programming Language Second Edition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `impl` Trait language feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` can return a Result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inclusive ranges with `..=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *i128* and *u128* native types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved patterns for `match`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **June**:'
  prefs: []
  type: TYPE_NORMAL
- en: The SIMD library feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dyn` Trait language feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **August**: Custom global allocator | **September**:'
  prefs: []
  type: TYPE_NORMAL
- en: The `cargo fix` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cargo clippy` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **October**:'
  prefs: []
  type: TYPE_NORMAL
- en: Procedural macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to the module system and the `use` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw identifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_std` applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **December**:'
  prefs: []
  type: TYPE_NORMAL
- en: The 2018 edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-lexical lifetimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `const fn` language feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new [https://www.rust-lang.org/](https://www.rust-lang.org/) website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try`, `async`, and `await` are reserved words'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many improvements have been applied since the 2015 edition. More information
    can be found in the official documentation ([https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html)).
    The most important improvements are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A new official tutorial book, available free online ([https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)),
    or printed on paper (*The Rust Programming Language* by Steve Klabnik and Carol
    Nichols).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A revamped official website.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The formation of four domain working groups, which are open committees to design
    the future of the ecosystem in four key areas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: Designing the new asynchronous paradigm around a concept of
    delayed computation, named *future*, as it is already done in other languages,
    such as C++, C#, and JavaScript (with *promises*).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command-line applications**: Designing some standard libraries to support
    any non-graphical, non-embedded applications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebAssembly**: Designing tools and libraries to build applications to be
    run inside web browsers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded software**: Designing tools and libraries to build applications
    to be run on bare-metal systems or on strictly constrained hardware.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We witnessed some good improvements to the language:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-lexical lifetimes; any bindings that are no longer used are considered
    *dead*. For example, now this program is allowed:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the object bound to the variable `_a` is borrowed by the variable
    `_ref_to_a` in the second statement. Prior to the introduction of non-lexical
    lifetimes, such bindings would last till the end of the scope, and so the last
    statement would have been illegal because it tries to change that object through
    binding `_a` when it is still borrowed to variable `_ref_to_a`. Now, because variable `_ref_to_a`
    is no longer used, its lifetime ceases in the same line it is declared, and so,
    in the last statement, variable `_a` is again free to change its own object.
  prefs: []
  type: TYPE_NORMAL
- en: The `Impl Trait` feature, which allows functions to return unspecified types,
    such as **closures**.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The `i128` and `u128` native types.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other reserved keywords such as `try`, `async`, and `await`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `?` operator, usable even in the `main` function, because now it can return `Result`.
    The following program is an example of the `main` function returning a `Result`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It can succeed, by returning the usual empty tuple or fail by returning the
    type you specify. In this case, it was `String`. The following program is an example
    using the `?` operator used in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will print `Found 1` on the standard output stream, meaning that
    the number `19` has been found at position `1`, and it will print `Error: 2` on
    the standard error stream, meaning that the number `20` hasn''t been found, but
    that it should be inserted at position `2`.'
  prefs: []
  type: TYPE_NORMAL
- en: Procedural macros, which allow a kind of meta-programming, manipulating source
    code to generate Rust code at compile time.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: More powerful and more ergonomic pattern matching in `match` expressions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And also some improvements to the standard tooling:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rustup` program, which allows users to easily choose the default compiler
    target or to update the toolchain.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rustfix` program, which converts a 2015 edition project to a 2018 edition project.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Clippy program, which checks for non-idiomatic syntax, and suggests changes
    to code for better maintainability.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster compilation speed, in particular, if just a syntax check is required.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Rust Language Server** (**RLS**) program, which is currently still unstable,
    but which allows IDEs and programmable editors to spot syntax errors, and to suggest
    allowed operations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rust is still evolving as a language, like any other programming language.
    The following areas are still left to be improved:'
  prefs: []
  type: TYPE_NORMAL
- en: The IDE tools, including a language interpreter (REPL) and a graphical debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries and tools to support bare-metal and real-time software development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application-level frameworks and libraries for the main application areas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book will focus primarily on the third point on this list.
  prefs: []
  type: TYPE_NORMAL
- en: The projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write a real-world application, the Rust language and its standard library
    are not sufficient. Application frameworks are needed for particular kinds of
    applications, such as GUI apps, web apps, or games.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if you use a good-quality and comprehensive library, you can reduce
    the number of lines of code that you need to write. Using a library also offers
    the following two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The overall design is improved, particularly if you are using a framework (since
    it imposes an architecture on your app) as it will be created by knowledgeable
    engineers and time-tested by a number of users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of bugs will be reduced because it will have undergone more thorough
    testing than that which you are likely to be able to apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are actually many Rust libraries, also known as **crates**, but most are
    low-quality or quite narrow in their range of applications. This book will look
    at the best quality and most complete libraries for some typical application areas
    of the Rust language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application areas are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web apps**: There are various popular technologies, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The REST web service (backend only)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An event-driven web client (frontend only)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A full web app (full-stack)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A web game (frontend only)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Games**: When I say *games*, I''m not referring to anything that is entertaining.
    I am referring to a graphical application where a continuous animation is shown,
    as opposed to event-driven graphical applications that do nothing until an event
    occurs, such as the user pressing a key, moving the mouse, or some data arriving
    from a connection. As well as games for the web browser, there are also games
    for desktop and laptop computers, for video game consoles, and for mobile devices.
    However, video game consoles and mobile devices are not yet that well supported
    by Rust, so we will only be looking at games for desktop and laptop computers
    in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language interpreters**: There are two kinds of languages that can be interpreted.
    Both are covered in this book:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text**: Like a programming language, a markup language, or a machine command
    language'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binary**: Like the machine language of a computer to be emulated, or the
    intermediate bytecode of a programming language.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C-language-callable libraries**: This is an important use case of Rust: to
    develop a library to be invoked by another application, typically written in a
    higher-level language. Rust cannot assume that other languages can invoke the
    Rust code, but it can assume that they can invoke the C-language code. We will
    look at how to build a library that can be invoked as if it were written in C.
    One particularly challenging case is to build a module for the Linux operating
    system, which notoriously has to be written in C.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most applications read and write data to and from a file, or a communication
    channel, or a database. In the next chapter, we will be looking at various different
    techniques that will be useful for all the other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Other application areas have not been listed here as they are either not used
    much in Rust, they are still immature, or they are still in a state of flux. The
    libraries available for these immature areas will be completely different in a
    couple of years. These areas include software for micro-controllers, or other
    real-time or low-resource systems, and also software for mobile or wearable systems.
  prefs: []
  type: TYPE_NORMAL
- en: Working through the examples in this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples in the book, you should download all the examples from the
    online repository: [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
    This repository contains a sub-folder for each chapter of the book and a sub-sub-folder
    for any project in a chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to run the `use_rand` project in this chapter, you should go to
    the `Chapter01/use_rand` folder and type `cargo run`. Notice that the most important
    files of any project are `cargo.toml` and `src/main.rs`, so you should always
    take a look at them first.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring some utility crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before moving on to looking at how to use the most complex crates, let's take
    a look at some basic Rust crates. These are not a part of the standard library,
    but they are useful in many different kinds of projects. They should be known
    by all Rust developers since they are of general applicability.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-random number generators – the rand crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to generate pseudo-random numbers is needed for several kinds of
    applications, especially for games. The `rand` crate is rather complex, but its
    basic usage is shown in the following example (named `use_rand`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, you create a pseudo-random number generator object. Then, you call several
    methods on this object. Any generator must be **mutable** because any generation
    modifies the state of the generator.
  prefs: []
  type: TYPE_NORMAL
- en: The `gen_range` method generates an integer number in a right-open range. The
    `gen` generic method generates a number of the specified type. Sometimes, this
    type can be inferred, like in the last statement, where a Boolean is expected.
    If the generated type is a floating-point number, it is between 0 and 1, with
    1 excluded.
  prefs: []
  type: TYPE_NORMAL
- en: Logging – the log crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For any kind of software, in particular for servers, the ability to emit logging
    messages is essential. The logging architecture has two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API**: Defined by the `log` crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation**: Defined by several possible crates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, an example using the popular `env_logger` crate is shown. If you want
    to emit logging messages from a library, you should only add the API crate as
    a dependency, as it is the responsibility of the application to define the logging implementation
    crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example (named `use_env_logger`), we are showing an application
    (not a library), and so we need both crates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In a Unix-like console, after having run `cargo build`, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It will print something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By typing `RUST_LOG=debug` at the beginning of the command, you defined the
    temporary environment variable `RUST_LOG`, with `debug` as its value. The `debug`
    level is the highest, and hence all logging statements are performed. Instead,
    if you execute the following command, only the first three lines will be printed,
    as the `info` level is not detailed enough to print debug messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if you execute the following command, only the first two lines will
    be printed, as the `warn` level is not detailed enough to print either the `debug`
    or the `info` messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute one or the other of the following commands, only the first line
    will be printed, as the default logging level is `error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RUST_LOG=error ./target/debug/use_env_logger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./target/debug/use_env_logger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing static variables at runtime – the lazy_static crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's well known that Rust does not allow *mutable static variables in safe code*.
    Immutable static variables are allowed in safe code, but they must be initialized
    by constant expressions, possibly by invoking `const fn` functions. However, the
    compiler must be able to evaluate the initialization expression of any static
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, there is a need to initialize a static variable at runtime,
    because the initial value depends on an input, such as a command-line argument
    or a configuration option. In addition, if the initialization of a variable takes
    a long time, instead of initializing it at the start of the program, it may be
    better to initialize it only the first time the variable is used. This technique
    is called **lazy initialization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a small crate, named `lazy_static`, that contains only one macro,
    which has the same name as the crate. This can be used to solve the issue mentioned
    previously. Its use is shown in the following project (named `use_lazy_static`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `main` function starts first. Then, it tries to access the
    `DICTIONARY` static variable, and that access causes the initialization of variables.
    The initialized value, which is a reference, is then dereferenced and printed.
  prefs: []
  type: TYPE_NORMAL
- en: The last statement, which is identical to the previous one, does not perform the
    initialization again, as you can see by the fact that the `Initialized` text is
    not printed again.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the command line – the structopt crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command-line arguments of any program are easily accessible through the
    `std::env::args()` iterator. However, the code that parses these arguments is
    actually rather cumbersome. To get more maintainable code, the `structopt` crate
    can be used, as shown in the following project (named `use_structopt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the `cargo run input1.txt input2.txt -v --result res.xyz` command, you
    should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the filenames `input1.txt` and `input2.txt` have been loaded
    into the `files` field of the structure. The `--result res.xyz` argument caused
    the `result_file` field to be filled, and the `-v` argument caused the `verbose` field
    to be set to `true`, instead of the default `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the new Rust 2018 edition. We learned about the
    kind of projects that are going to be described in this book. We then took a quick
    look at four useful crates which you can apply in your Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to store or retrieve data to and from
    a file, a database, or another application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is there an official printed book to learn the Rust language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How long was the longest primitive Rust integer in 2015, and how long was it
    at the end of 2018?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which are the four domain working groups at the end of 2018?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the Clippy utility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `rustfix` utility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that generates 10 pseudo-random `f32` numbers between 100 and
    400.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that generates 10 pseudo-random `i32` numbers between 100 and
    400 (without truncating or rounding the numbers generated by the previous exercise).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that creates a static vector containing all squared integers
    between 1 and 200.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that emits a warning message and an info message, and then run
    it so that only the warning message appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to parse a command-line argument that contains a value from 1 to 20, emitting
    an error message if the value is out of range. The short option should be `-l`,
    and the long option should be `--level`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
