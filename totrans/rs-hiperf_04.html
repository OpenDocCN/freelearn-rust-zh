<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Lints and Clippy</h1>
                </header>
            
            <article>
                
<p class="mce-root">Up until now, we needed to check all the details of the code by ourselves. This can often get out of control, since we cannot be checking each line of code. In this chapter, you will learn about the lints Rust brings us, both the ones enabled by default and the ones you can enable yourself.</p>
<p>Moreover, you will learn about a great tool, Clippy, that will give you many more lints you can use, and that can help you write much better code. In many cases, it will lint about performance pitfalls. In other cases, they will be potential errors or idiomatic conventions. It will also help you clean your code.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Linting in Rust</li>
<li>Default lints</li>
<li>Using and configuring Clippy</li>
<li>Extra Clippy lints</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Rust compiler lints</h1>
                </header>
            
            <article>
                
<p>The Rust compiler, at the time of writing, has 70 lints. We will not check all 70, but we will take a look at the most relevant ones. Let's first start by learning how to configure a lint. We will take <kbd>unused_imports</kbd> as an example. The compiler will warn you for this lint by default. The compilation will continue, but it will show a warning in the command line, or in the editor if it's configured to show Rust compilation warnings.</p>
<p>We can change this behavior, and we can change it for each scope. The options are <kbd>allow</kbd>, <kbd>warn</kbd>, <kbd>deny</kbd>, and <kbd>forbid</kbd> the lint. If we allow the lint, no more warnings will appear. If we warn, compilation warnings will appear, and if we deny or forbid, the program won't compile if it finds something that triggers the lint. The difference between <kbd>deny</kbd> and <kbd>forbid</kbd> is that the former can be overridden down the line, while the latter can't. So we can have a module that denies one behavior, but in one particular function, we want to allow it.</p>
<p>This configuration can be applied at crate level, by putting  <kbd>#![deny(unused_imports)]</kbd>, for example, at the top of the <kbd>lib.rs</kbd> or <kbd>main.rs</kbd> file. It can also be applied to any scope, even scopes you might create inside functions. If it has an exclamation mark (<kbd>!</kbd>) after the hash, it will affect the current scope; if not, it will affect the scope just next to it. Let's see what lints the Rust compiler gives us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lints</h1>
                </header>
            
            <article>
                
<p>In this section, we will check the lints that allow the behavior by default, and that you will probably want to add at least a warning for in most cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding anonymous parameters</h1>
                </header>
            
            <article>
                
<p class="mce-root">Anonymous parameters have been deprecated. This allowed you to specify traits without requiring binding names in traits:</p>
<pre>trait MyTrait {<br/>    fn check_this(String);<br/>}</pre>
<p>This is a deprecated legacy feature that might get removed in future versions, so you should probably avoid using this syntax. In order to warn or deny this syntax in your code base, you will need to use this syntax: <kbd>#![warn(anonymous_parameters)]</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding heap allocated box pointers</h1>
                </header>
            
            <article>
                
<p>Rust allocates space in the stack by default, since it's much faster than using the heap. Nevertheless, sometimes, when we do not know the size of objects at compile time, we need to use the heap to allocate new structures. Rust makes this explicit by using the <kbd>Vec</kbd>, <kbd>String</kbd>, and <kbd>Box</kbd> types, for example. The last one allows us to put in the heap any kind of object, which is usually a bad idea, but sometimes it's a must.</p>
<p>Check out, for example, the following code:</p>
<pre>fn main() {<br/>    let mut int = Box::new(5);<br/>    *int += 5;<br/>    println!("int: {}", int);<br/>}</pre>
<p>This code compiles perfectly, and it tells us that the integer is <kbd>10 (5 + 5)</kbd>. The main issue with this is that it does a heap allocation, doing a system call that needs to find the space in the heap and so on. But we already know that an integer has a fixed size at compile time, so we should be using the stack for this.</p>
<p>These kinds of errors can be avoided by warning every <kbd>Box</kbd> usage using <kbd>#![warn(box_pointers)]</kbd>. But beware: this will warn every usage of a boxed type, so you probably want to allow this in many places explicitly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding missing implementations</h1>
                </header>
            
            <article>
                
<p>There are a couple of traits we probably want many of our types to implement. The first of them is the <kbd>Debug</kbd> trait. The <kbd>Debug</kbd> trait should probably be implemented by all of our types, since it enables a developer to print debug information about our structures, enumerations, and so on. Moreover, it allows a user of our API to derive the <kbd>Debug</kbd> trait in structures using our API types by only adding an attribute.</p>
<p>We can enforce the implementation of this trait for all of our types by adding <kbd>#![warn(missing_debug_implementations)]</kbd>. The only detail is that this trait will only check for types exposed in our API. So, it will only work for <kbd>pub</kbd> types.</p>
<p>Another interesting trait is the <kbd>Copy</kbd> trait. Sometimes, we create a small structure with a couple of integers that would work best if copied in certain cases, as we saw in the previous chapters. The problem is that if we forget about implementing it, we might end up doing excessive referencing, making our code slower. We can solve this by adding this lint: <kbd>#![warn(missing_copy_implementations)]</kbd>.</p>
<p>This lint has a couple of caveats though. It will only work for <kbd>pub</kbd> types, as in the case for the <kbd>Debug</kbd> implementation lint, and it will lint all structures that all of its members are <kbd>Copy</kbd> types. This means that if we have a really big structure that we wouldn't like to copy around, we will need to allow the lint for that particular structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enforcing documentation</h1>
                </header>
            
            <article>
                
<p>This is arguably the most important lint of all, and it's a pity that it's <kbd>allow</kbd> by default. Whenever we create an API, we must document what the API does. This will make it much, much easier for new developers to use it. The <kbd>#![warn(missing_docs)]</kbd> lint will make sure that at least all of your public API has some documentation. I personally usually have this as a warning during the development and change it to <kbd>deny</kbd> or even <kbd>forbid</kbd> once the project enters into production.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pointing out trivial casts</h1>
                </header>
            
            <article>
                
<p>Sometimes, we might explicitly cast an element to a type that the compiler should cast automatically. This sometimes happens when we use traits, but it can also happen because we changed the type of an element to a new type and we didn't change the castings. To clean these kinds of behavior, we have the <kbd>trivial_casts</kbd> and <kbd>trivial_numeric_casts</kbd> lints. Let's see it as an example:</p>
<pre>#![warn(trivial_casts, trivial_numeric_casts)]<br/><br/>#[derive(Default, Debug)]<br/>struct MyStruct {<br/>    a: i32,<br/>    b: i32,<br/>}<br/><br/>fn main() {<br/>    let test = MyStruct::default();<br/>    println!("{:?}", (test as MyStruct).a as i32);<br/>}</pre>
<p>In this case, we first cast <kbd>test</kbd> as a <kbd>MyStruct</kbd>, but it's already a <kbd>MyStruct</kbd>, so this is redundant and makes the code much less readable, and in consequence, more error-prone. Then we cast its <kbd>a</kbd> attribute as an <kbd>i32</kbd>, but it's already an <kbd>i32</kbd>, so once again, redundant information. The first is not common, but the second could be found if we use this parameter for a function that only accepts an <kbd>i32</kbd>, and our structure had <kbd>i16</kbd> in a previous implementation, for example.</p>
<p>In any case, these kinds of castings are not good practice, since it could be that we had changed the <kbd>a</kbd> attribute for an <kbd>i64</kbd>, and we would be silently losing precision. We should use <kbd>i32::from()</kbd> so that if we change it for an <kbd>i64</kbd>, it will simply stop compiling. This gets automatically linted with the Clippy tool we will see later.</p>
<p>It is a good idea to enable these two lints anyway, since it will help us find these kinds of errors. The <kbd>trivial_casts</kbd> lint will lint us for non-numeric type/trait casts, while <kbd>trivial_numeric_casts</kbd> will lint the numeric casts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linting unsafe code blocks</h1>
                </header>
            
            <article>
                
<p>In some situations, especially if we are using extremely low-level programming, sometimes used for high-performance computing, we will need to perform some pointer arithmetics or even <span><strong>Single Instruction, Multiple Data</strong> (</span><strong>SIMD</strong>) intrinsics that will require unsafe scopes. This might be the case in some specific functions or pieces of code, but in general, we should avoid unsafe scopes.</p>
<p>A rule of thumb is this: if you are not working on performance-critical code, do not use them. If you are, use them very carefully and only in places where there is no other option to improve performance. This means that usually intrinsic code can be wrapped in one module or function.</p>
<p>To make sure nobody uses unsafe code outside the scope where we want it to be shown, we can lint all unsafe scopes by using the <kbd>unsafe_code</kbd> lint. Let's see it as an example:</p>
<pre>#![warn(unsafe_code)]<br/><br/>fn main() {<br/>    let test = vec![1, 2, 3];<br/>    println!("{}", unsafe { test.get_unchecked(2) });<br/>}</pre>
<p>If you remember from <a href="ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml" target="_blank">Chapter 1</a>, <em>Common Performance Pitfalls</em>, the <kbd>get_unchecked()</kbd> function in a slice will get the element at the given index without checking the bounds of the slice, making it go faster. This also means that if the index is out of bounds, you could get from a memory leak to a segmentation fault.</p>
<p>In this example, when compiling this piece of code, a warning will tell us that we are using unsafe code. We can allow it for this particular function if it's 100% required, or we can change the code. An example fixing the issue above while still using unsafe code can be seen here:</p>
<pre>#![deny(unsafe_code)]<br/><br/>fn main() {<br/>    let test = vec![1, 2, 3];<br/>    println!("{}", get_second(&amp;test));<br/>}<br/><br/>#[allow(unsafe_code)]<br/>fn get_second(slice: &amp;[i32]) -&gt; i32 {<br/>    *unsafe { slice.get_unchecked(1) }<br/>}</pre>
<p>In this example, the crate won't compile if we add an unsafe scope outside the <kbd>get_second()</kbd> function. In any case, this function is not safe, as it will not check any bounds of the slice being sent to it; we should probably add an <kbd>assert!()</kbd>, or at least a <kbd>debug_assert!()</kbd>, to the length of the slice at the beginning of the function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unused lints</h1>
                </header>
            
            <article>
                
<p>Let's face it, we sometimes forget to remove a dependency we are no longer using, or we forget that the <kbd>write()</kbd> method returns the number of bytes written. This usually is not a big deal. The first will simply make our compilation slower, while the second, in most cases, will simply not change our code.</p>
<p>But since we do not want to have unused dependencies, or we don't want to forget that we might not have written the whole buffer to a file, that's where the next lints come to help us. Let's start with the first one, the <kbd>unused_extern_crates</kbd> lint. This lint will mark the external crates that are not being used in our code. This can be useful to remove dependencies we are no longer using, so I usually configure it to <kbd>warn</kbd> while I'm starting the development and change it to <kbd>forbid</kbd> once my crates go to production or the dependencies are not changing in every commit.</p>
<p>The second lint you should know about is the <kbd>unused_results</kbd> lint. By default, the compiler will warn about unused results for <kbd>Result&lt;T, E&gt;</kbd> return values. That is an important detail because it could be that an I/O operation failed, for example, and you should act accordingly. There are other cases, though, where the Rust compiler won't warn, but that can be almost as dangerous as the previous ones. The <kbd>Write</kbd> and <kbd>Read</kbd> traits, for example, will return the number of bytes written and read, respectively, and you should probably be aware of that number.</p>
<p>This lint will make sure you always take into account any return value, except for the empty tuple <kbd>()</kbd>. This can sometimes be annoying, but you can explicitly discard a result by using the underscore binding, which is shown as follows:</p>
<pre>#![warn(unused_results)]<br/><br/>fn main() {<br/>    let _ = write_hello();<br/>}<br/><br/>fn write_hello() -&gt; usize {<br/>    unimplemented!()<br/>}</pre>
<p>There are also a couple of lints that will make your code much more readable: <kbd>unused_qualifications</kbd> and <kbd>unused_import_braces</kbd>. The first will detect places where you are using extra qualifications for some elements:</p>
<pre>#![warn(unused_qualifications)]<br/><br/>#[derive(Debug)]<br/>enum Test {<br/>    A,<br/>    B,<br/>}<br/><br/>fn main() {<br/>    use Test::*;<br/><br/>    println!("{:?}", Test::A);<br/>    println!("{:?}", B);<br/>}</pre>
<p>This example of code will warn us that in the first <kbd>println!()</kbd> we do not need to use the <kbd>Test::</kbd> qualification, as we are already importing all values inside the <kbd>Test</kbd> enumeration. The second <kbd>println!()</kbd> will not warn us since we are not specifying any extra qualifications. This will make the code more readable, potentially reducing errors.</p>
<p>The second lint, the <kbd>unused_import_braces</kbd> lint, will check for places where we are importing only one element with import braces:</p>
<pre>#![warn(unused_import_braces)]<br/><br/>#[derive(Debug)]<br/>enum Test {<br/>    A,<br/>    B,<br/>}<br/><br/>#[derive(Debug)]<br/>enum Test2 {<br/>    C,<br/>    D,<br/>}<br/><br/>fn main() {<br/>    use Test::{A, B};<br/>    use Test2::{C};<br/><br/>    println!("{:?}, {:?}, {:?}", A, B, C);<br/>}</pre>
<p>Even though the Rust formatter will automatically remove the braces around the C variant of the <kbd>Test2</kbd> import, if we do not use the formatter, this is an interesting lint that will alert that we do not require those braces and that removing them we will make the code cleaner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variant size differences</h1>
                </header>
            
            <article>
                
<p>As we saw in the previous chapters, the size of an enumeration will be the size of the biggest element plus the tag, but, as we discussed, this can be troublesome if we have many small variants and one has a bigger size: all variants will occupy the whole space for the biggest one. We saw that an option would be to move the big variant to a heap allocation.</p>
<p>We can detect enumerations with variants significantly bigger than the rest with the <kbd>variant_size_differences</kbd> lint. It will check for enumerations where a variant is at least three times bigger than the rest:</p>
<pre>#![warn(variant_size_differences)]<br/><br/>enum Test {<br/>    A(u8),<br/>    B(u32),<br/>}</pre>
<div class="mce-root packt_infobox">Note that it will not work for unions and that if we have middle-sized variants, even if the difference between the biggest one and the smallest one is more than three times, the lint will not alert us.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lint groups</h1>
                </header>
            
            <article>
                
<p>The Rust compiler lets us configure some of the aforementioned lints in groups. For example, the <kbd>unused</kbd> group will contain many of the <kbd>unused_</kbd> kind of lints. The <kbd>warnings</kbd> group will contain all the lints that have been configured to warn, and so on.</p>
<p>Lint groups can be used the same way as lints, by specifying what you want to happen when the compiler catches that behavior:</p>
<pre>#[deny(warnings)]</pre>
<p>You can check out the rest of the built-in lints by running <kbd>rustc -W help</kbd>. It will show the ones we have talked about and the other lints that are <kbd>warn</kbd> or <kbd>deny</kbd> by default.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clippy</h1>
                </header>
            
            <article>
                
<p>If there is a tool that will help you sanitize your code the most, it is Clippy. At the time of writing, Clippy provides 208 extra lints, most of them really useful to avoid interesting pitfalls such as the <kbd>unwrap_or()</kbd> usage that we discussed in <a href="da2d0480-3314-408b-9cad-60987754f45d.xhtml" target="_blank">Chapter 2</a>, <span><em>Extra Performance Enhancements</em>,</span> or to avoid non-idiomatic code. Of course, we will not see all of them here, and you will find a comprehensive list of all of them in the Clippy lint documentation at <a href="https://rust-lang-nursery.github.io/rust-clippy/master/">https://rust-lang-nursery.github.io/rust-clippy/master/<span>.</span></a></p>
<p>Since many of them already warn or even deny by default, we will check some of the ones that are allowed by default but that could be really useful to improve the code quality of your application and even its performance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation</h1>
                </header>
            
            <article>
                
<p>Installing Clippy is pretty easy: you will need to install Rust nightly by running <kbd>rustup toolchain install nightly</kbd>, then you can install Clippy by running <kbd>cargo +nightly install clippy</kbd>.</p>
<p>Note that since<span> Clippy </span>requires a nightly compiler to build, and since it uses compiler intrinsics, some Rust nightly compiler updates make it unusable. Those issues are usually fixed in a couple of days and a new <span>Clippy</span> version gets released, but meanwhile, you can select a previous nightly version by appending a previous date to the nightly toolchain: <kbd>rustup toolchain install nightly-YYYY-MM-DD</kbd>.</p>
<p>Once the correct toolchain is installed, Clippy will be installed perfectly. To use it, you will need to go to your project and run <kbd>cargo clippy</kbd> instead of the usual <kbd>cargo check</kbd> or <kbd>cargo build</kbd> commands. This will run all Clippy lints and show you the results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration</h1>
                </header>
            
            <article>
                
<p>Even if we will check individual lints in the next section, we will now see how we can configure the whole Clippy execution. Clippy will read the <kbd>clippy.toml</kbd> file at the same level as the <kbd>Cargo.toml</kbd> file and act accordingly.</p>
<p>Some lints have configuration parameters. For instance, the cyclomatic complexity lint will alert you whenever a function has more than 25 branches. As we saw in <a href="ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml" target="_blank">Chapter 1</a>, <em>Common Performance Pitfalls</em>, this is bad practice, since it will make the optimizations of the code much harder for the compiler, creating less performant code.</p>
<p>However, you can change the threshold that creates the warning. 25 is a fair amount of branches, but depending on your product, you would prefer not to have more than 20 branches or to be able to have up to 30, for example. The setting that changes this behavior in the <kbd>clippy.toml</kbd> is the <kbd>cyclomatic-complexity-threshold</kbd>:</p>
<pre><span class="pl-smi">cyclomatic-complexity-threshold</span> = <span class="pl-c1">30</span></pre>
<p>Clippy will also warn you, for example, when it finds names that could be the name of a structure or enumeration in the documentation without the proper (<kbd>`</kbd>) characters showing that they are code. This can have false positives in cases such as your software being called <kbd>MyCompanyInc</kbd>, for example, where Clippy will think it's a <kbd>struct</kbd> or an <kbd>enum</kbd>. There is a configuration parameter for this case too. You can check all of them in the Clippy wiki at <a href="https://rust-lang-nursery.github.io/rust-clippy/master/">https://rust-lang-nursery.github.io/rust-clippy/master/</a>.</p>
<p>If we want to add Clippy lints to our project, when we compile without Clippy, Rust will warn us that those lints are unknown. Of course, those have been defined by Clippy, but the compiler does not know this. Clippy sets a <kbd>cargo-clippy</kbd> feature by default, and when configuring the lints, we can use it to remove the unknown lints warning:</p>
<pre>#![cfg_attr(feature = "cargo-clippy", forbid(deprecated))]</pre>
<p>This way, when we run <kbd>cargo clippy</kbd>, the lint will be taken into account, but when running <kbd>cargo check</kbd>, it won't.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lints</h1>
                </header>
            
            <article>
                
<p>From those 208 lints currently available in Clippy, we will analyze only some of them that are configured as <kbd>allow</kbd> by default. The rest can be checked at the Clippy wiki at <a href="https://rust-lang-nursery.github.io/rust-clippy/master/">https://rust-lang-nursery.github.io/rust-clippy/master/</a>, but you should take note of these ones, since they will not show an alert by default.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Casting</h1>
                </header>
            
            <article>
                
<p>Casting numbers is sometimes a dangerous operation. We could lose precision, lose sign, truncate numbers, and so on. Clippy gives us some very useful lints that can avoid these situations. Of course, often you do not care about these behaviors since you might know they won't happen or they could be intended behavior.</p>
<p>Nevertheless, I have found these lints useful even if you only activate them on one occasion to check the places where these casts take place and set them to allow by default when usual testing.</p>
<p>The lints are the following:</p>
<ul>
<li><kbd>cast_possible_truncation</kbd></li>
<li><kbd>cast_possible_wrap</kbd></li>
<li><kbd>cast_precision_loss</kbd></li>
<li><kbd>cast_sign_loss</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bad practice</h1>
                </header>
            
            <article>
                
<p>Clippy also gives us lints that will detect bad coding practices. You should, for example, not import enumeration variants, since enumeration variants should always be prefixed with the actual enumeration. To lint against this practice, you can use the <kbd>enum_glob_use</kbd> lint.</p>
<p>Other code practices that might create issues are the panicking <kbd>From</kbd> and <kbd>Into</kbd> trait implementations. By definition, these traits must never fail, and using <kbd>unwrap()</kbd>, <kbd>expect()</kbd>, <kbd>panic!()</kbd>, or <kbd>assert!()</kbd> functions and macros can panic the function. This can be the desired behavior in an application, even though it's bad practice (you should use <kbd>TryInto</kbd> and <kbd>TryFrom</kbd> traits, or create a new function if developing with the stable compiler).</p>
<p>But the main issue is when developing software such as kernels that could cause the whole OS to panic. You can detect these issues by using the <kbd>fallible_impl_from</kbd> lint.</p>
<p>We talked about iterators in <a href="ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml" target="_blank">Chapter 1</a>, <em>Common Performance Pitfalls</em>, and as we saw, we sometimes have useful functions to wrap <kbd>filter()</kbd> and <kbd>map()</kbd>. This improves readability, and concatenations of these functions can be detected by using the <kbd>filter_map</kbd> lint.</p>
<p>Sometimes, we write conditionals that might not be straightforward to understand, sometimes because we do negations in conditions with <kbd>else</kbd> branches or because we add lots of conditions that mess up our comparisons. We have two Clippy lints that will point out these situations: <kbd>if_not_else</kbd> and <kbd>nonminimal_bool</kbd>.</p>
<p>The first will detect a negation in a conditional, and suggest changing the condition to a positive one and changing the <kbd>else</kbd> and the <kbd>if</kbd> code sections. The second will check for Booleans that can be simplified to remove redundancy and clean up the code.</p>
<p>Some <kbd>match</kbd> statements can also be improved when there are only two branches and one of them does not require any parameters, such as when dealing with <kbd>Option</kbd> types. In this case, it's cleaner to change them for an <kbd>if let</kbd> expression with an <kbd>else</kbd> that will also reduce the indenting of the comparison. These points of failure can be shown by using the <kbd>single_match_else</kbd> lint.</p>
<p>Another interesting couple of lints will check for places where you might be adding <kbd>1</kbd> to an integer just to make comparisons or ranges inclusive. Let's see an example:</p>
<pre>    let max = 10;<br/>    for i in 0..max + 1 {<br/>        println!("{}", i);<br/>    }</pre>
<p>That code only adds <kbd>1</kbd> to be able to print the <kbd>10</kbd> too. You can create an inclusive range of nightly Rust by using an equals symbol after the two range periods (<kbd>..=</kbd>):</p>
<pre>#![feature(inclusive_range_syntax)]<br/><br/>fn main() {<br/>    let max = 10;<br/>    for i in 0..=max {<br/>        println!("{}", i);<br/>    }<br/>}</pre>
<p>The lint that will point out this error is called <kbd>range_plus_one</kbd>, while the one that will detect comparisons such as <kbd>a &lt; b+1</kbd>, that can be replaced by <kbd>a &lt;= b</kbd>, is called <kbd>int_plus_one</kbd>.</p>
<p>There are also times where we might change the name of a variable or misspell it and break our code, even if it seems to compile. Other times, we might create variables with too similar names and end up mixing them up. This can be avoided by using the <kbd>similar_names</kbd> lint.</p>
<p>Another bad practice is to include the name of an enumeration in a variant of the enumeration, or a structure containing the name of the current module. Since names can be qualified, repetition is not required and adds a lot of text. This will be warned by default, but not in public APIs. You can control that with the <kbd>stutter</kbd> and the <kbd>pub_enum_variant_names</kbd> lints.</p>
<p>Finally, the same way the Rust compiler gave us a <kbd>missing_docs</kbd> lint that would point out missing public documentation, the <kbd>missing_docs_in_private_items</kbd> Clippy lint will do the same for private items. This is great to enforce documentation of the whole code base.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performance lints</h1>
                </header>
            
            <article>
                
<p>If you are reading this book, these two lints will probably be the ones you will find more important than the ones Clippy does not warn by default. The first is pretty simple: if you want to share an integer between threads, using a <kbd>Mutex</kbd> is a really bad idea if you do not need to use it as a synchronization variable.</p>
<p>Usually, things such as counters will be much faster by using atomic types. Only pointer-sized atomics and booleans are stable at the time of writing, but the rest are also coming and can now be used in nightly Rust. You can spot this issue with the <kbd>mutex_integer</kbd> lint.</p>
<p>Also, you might be tempted to use <kbd>std::mem::forget()</kbd> to enable sending data to C APIs, or to be able to do some strange memory tricks. This can be fine (even though it can lead to memory leaks), but can sometimes prevent running destructors. If you want to make sure that your <kbd>Drop</kbd> types never get forgotten, use the <kbd>mem_forget</kbd> lint.</p>
<p>If you are worried about infinite iterators that could hang your applications, you should use the <kbd>maybe_infinite_iter</kbd> lint, which will find those. It will not detect stopping conditions, so it could show too many false positives.</p>
<p>We might also find ourselves adding debug information when developing by using <kbd>print!()</kbd> macros and debug formatting. Once the application goes into production, a good way to avoid these logs staying in the code base is to use the <kbd>print_stdout</kbd> and <kbd>use_debug</kbd> lints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unwraps</h1>
                </header>
            
            <article>
                
<p>Rust allows you to unwrap <kbd>Result</kbd>s and <kbd>Option</kbd>s, at the cost of panicking if they are <kbd>Err(_)</kbd> or <kbd>None</kbd> respectively. This should be avoided in any production code, and either use <kbd>expect()</kbd> to add an information message or use error chaining with the <kbd>?</kbd> operator, for example. You can also match them and control the error.</p>
<p>To avoid those unnecessary panics, you can use the <kbd>result_unwrap_used</kbd>, <kbd>option_unwrap_used</kbd>, <kbd>option_map_unwrap_or_else</kbd>, <kbd>option_map_unwrap_or</kbd>, and <kbd>result_map_unwrap_or_else</kbd> lints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shadowing</h1>
                </header>
            
            <article>
                
<p>In Rust, you can shadow a variable by creating another <kbd>let</kbd> binding with the same name. This is usually okay, except when we maybe only wanted to mutate a variable, for example. In general, you should avoid this practice and only use it where it helps readability.</p>
<p>You can use the <kbd>shadow_unrelated</kbd>, <kbd>shadow_same</kbd>, and <kbd>shadow_reuse</kbd> lints and warn this behavior by default, then allow it for specific situations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integer overflow</h1>
                </header>
            
            <article>
                
<p>Sometimes, when we do operations with integers, we do not take overflows, underflows, and wrappings into account. C will let you do this by default, while Rust will panic when running in debug mode. In release mode, though, these integer overflows can be a big problem.</p>
<p>You can use the <kbd>integer_arithmetic</kbd> lint that will suggest using one of the <kbd>wrapping_...()</kbd> or <kbd>saturating_...()</kbd> methods of the integer to make sure you know what the outcomes of the operation are.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lint groups</h1>
                </header>
            
            <article>
                
<p>There are two lint groups in Clippy. The <kbd>clippy</kbd> lint group will control all the lints that warn by default, and you can, for example, deny all of them. The <kbd>clippy_pedantic</kbd> group will control the rest of the lints as a group, but making all of them warn, for example, will make your compilation results full of warnings, due to false positives.</p>
<p>To use them, you simply need to use the group of lints as a lint:</p>
<pre>#![deny(clippy)]</pre>
<p>You can check the rest of the lints and configuration options in the Clippy wiki at <a href="https://rust-lang-nursery.github.io/rust-clippy/master/">https://rust-lang-nursery.github.io/rust-clippy/master/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to configure the different lints that Rust and the Clippy tool give us. With them, you can get warnings of much more specific grain options that affect performance and code quality.</p>
<p>We covered the lints that you will not see by default, making your exploration journey much easier. In <a href="f8df2811-838d-40e2-970d-f50b909252f1.xhtml" target="_blank">Chapter 5</a>, <em><span>Profiling Your Rust Application</span></em>, we will learn about other tools; in this case, to profile your application and find performance bottlenecks that are not straightforward to see.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>