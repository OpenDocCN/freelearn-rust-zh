- en: '*Chapter 7*: Sound Effects and Music'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a moment and think of the game Tetris. If you're like me, you're probably
    already humming its theme song, *Korobeiniki*, because that song is so synonymous
    with the game itself. Beyond the appeal of music, sound effects are crucial for
    creating an immersive experience. We play games with more than just the touch
    of a keyboard or joystick and the use of our eyes; we hear Mario jump or Sonic
    catch a ring. While our game may be playable, it's just not a game without some
    sound. To play sound in our game, we'll need to learn how to use the browser's
    Web Audio API for both short and long sounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Web Audio API to the engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing long music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you won't just see RHB run, jump, and dodge obstacles,
    but you'll be able to hear him too after we add sound effects and music to our
    game. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements are largely unchanged from the previous chapters.
    You will need the `sound` assets from the `sound` directory in the assets download
    at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
  prefs: []
  type: TYPE_NORMAL
- en: All sounds are from open sound collections and are used with permission. See
    the `sounds/credits.txt` file for more information. The code for this chapter
    is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_7](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3JUdA2R](https://bit.ly/3JUdA2R)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Web Audio API to the engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be using the browser's Web Audio API to add sound to
    our game. The API is incredibly full-featured, allowing for mixing audio sources
    and special effects, but we're just going to use it to play background music and
    sounds. In fact, the Web Audio API is its own book and, if you're interested,
    you can find one at [https://webaudioapi.com/book/](https://webaudioapi.com/book/).
    While it would be fun to add things such as spatialized audio to our game, we're
    going to focus on just adding some music and sound effects. I encourage you to
    experiment on your own when making your own, more complicated games.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've got an overview of the Web Audio API, we'll create a module to play
    sounds in Rust, load the sounds in the same way as we load our images, and finally,
    add that sound to the engine.
  prefs: []
  type: TYPE_NORMAL
- en: The Web Audio API is a relatively new technology that is meant to replace older
    technology for audio, such as QuickTime and Flash, as well as being a more flexible
    solution than using audio elements. It's supported by all the major browsers,
    with only old versions of Internet Explorer being a potential problem. Given that
    the last release of Internet Explorer was in 2013, with Windows using the Edge
    browser instead, your game is probably okay with sacrificing that market.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Web Audio API may initially look familiar when compared to Canvas. As with
    Canvas, you create a context that then provides an API for playing sounds. At
    that point, the similarity ends. Because the Web Audio API has all the features
    I mentioned earlier, it can be hard to figure out how to do the basic act of playing
    a sound. Unlike Canvas, there''s no `drawImage` equivalent called `playSound`
    or something like that. Instead, you have to get the sound data, create `AudioBufferSourceNode`,
    connect it to a destination, and then finally start it. This enables some really
    impressive effects (such as the ones found at [https://webaudiodemos.appspot.com/](https://webaudiodemos.appspot.com/))
    but means that, for our game, we''ll write the one-time code and forget all about
    it. In JavaScript, the code to load and prepare a sound for playback looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It starts by creating a new `AudioContext`, which is built into the browser
    engine, then fetching a sound file from the server. The `fetch` call eventually
    returns a response, which we'll need to decode. We do this by first getting its
    `arrayBuffer`, which consumes it, and then we use the `audioContext` we created
    at the beginning to decode the buffer into a sound that can be played. Note how
    everything is asynchronous, which will cause us a little trouble in the Rust code
    as we map JavaScript promises to Rust futures. The previous code should only be
    done *once* for any sound resource since loading and decoding the file can take
    significant time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will play a sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Ugh, that's not intuitive, but it's what we have. Fortunately, we can wrap it
    in a few simple functions that we'll be able to remember, and forget all about
    it. It creates the `AudioBufferSourceNode` we need with `createBufferSource`,
    assigns it the array that we decoded into audio data in the previous section,
    connects it to the `audioContext`, and finally, plays the sound with `start`.
    It's important to know that you cannot call `start` on `trackSource` twice, but
    fortunately, the creation of a buffer source is very fast and won't require us
    to cache it.
  prefs: []
  type: TYPE_NORMAL
- en: That's great! We know the eight lines of code to play a sound in JavaScript,
    but how do we get this into our engine?
  prefs: []
  type: TYPE_NORMAL
- en: Playing a sound in Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to create a `sound` module that's very similar to our `browser`
    module, a series of functions that just delegate right to the underlying JavaScript.
    It will be a very bottom-up approach, where we'll create our utility functions
    and then create the final functions that use them. We'll start by focusing on
    the parts we need for a `play_sound` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you want these functions to be very small – it's a *thin* layer
    between Rust and JavaScript – but also to change the interface to better match
    what you want to do. So, eventually, rather than talking about buffer sources
    and contexts, we'll want to call that `play_sound` function we wish existed in
    the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating the module in a file named `sound.rs` living alongside
    the rest of our modules in `src`. Don''t forget to add a reference to it in `src/lib.rs`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the part I always forget. Our first function will create an `AudioContext`
    in a *Rusty* way as opposed to the JavaScript way we already saw, and that''s
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, the Rust version of the code is more verbose than the JavaScript
    version. That''s the price we pay for the positives of Rust. None of this code
    is particularly new; we''re mapping `new AudioContext` to `AudioContext::new`,
    and we''re mapping the `JsResult` error to an `anyhow` result that it might return,
    to be more Rust-friendly. This code doesn''t compile though; take a moment and
    think about why. It''s the infamous feature flags for `web-sys` in `Cargo.toml`
    that we haven''t added `AudioContext` to, so let''s add that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for the `AudioContext` bindings can be found at [https://bit.ly/3tv5PsD](https://bit.ly/3tv5PsD).
    Remember you can search the `web-sys` documentation for any JavaScript object
    to find its corresponding Rust library.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your editor of choice, you may need to restart `rust-analyzer`
    to get correct compiler errors and code actions when adding a new file to the
    project (such as `sound.rs`) and/or adding feature flags to the `Cargo.toml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve set up the `sound` module, created the function to create `AudioContext`,
    and refreshed our memory on the process of adding a new feature to the `web-sys`
    dependency, we can go ahead and add a little more code to play sounds. Let''s
    introduce all the remaining feature flags you''ll need to add to `web-sys` in
    `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The three features, `AudioBuffer`, `AudioBufferSourceNode`, and `AudioDestinationNode`,
    correspond to those same objects in the original JavaScript code. For instance,
    the `let trackSource = audioContext.createBufferSource();` function returned `AudioBufferSourceNode`.
    The `web-sys` authors have chosen to hide a large number of audio features under
    individual flags, so we need to name them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to check the feature flags whenever you can''t use a `web-sys` feature.
    It''s always listed in the documentation with a note such as "This API requires
    the following crate features to be activated: `AudioContext`."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the features ready, we can add the rest of the code without
    worrying about those errors. Back in the `sound` module, the code will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this book, we've typically gone through the code one function at a time,
    but for these two it's not necessary. These functions correspond to the calls
    to `audioContext.createBufferSource` and `trackSource.connect(audioContext.destionation)`
    respectively. We've converted the code from the object-oriented style of JavaScript
    into a slightly more procedural format with the functions taking parameters, in
    part so that we can map errors from the `JsValue` types into proper Rust `Error`
    types via the `anyhow!` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the three functions, we need to play a sound. We can go ahead
    and write the function that plays it right below them, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `play_sound` function accepts `AudioContext` and `AudioBuffer` as parameters,
    then returns the result of the `start` call, with `JsValue` mapped to `Error`.
    We haven''t created an `AudioBuffer` yet anywhere, so don''t worry that you don''t
    know how to as we''ll cross that bridge when we come to it. What we have here
    is a function that is very similar to the original JavaScript for playing a sound,
    but with the additional error handling that comes with Rust, including using the
    `?` operator to make it easier to read, and a little bit of additional work around
    `None` in the `track_source.set_buffer(Some(&buffer));` line, where we need to
    wrap a reference to `AudioBuffer` in `Some` because `track_source` has an optional
    buffer. In JavaScript, this is `null` or `undefined`, but in Rust, we need to
    use the `Option` type. Otherwise, both the JavaScript and Rust versions do the
    same thing to play a sound:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `AudioBufferSource` from `AudioContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `AudioBuffer` on the source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect `AudioBufferSource` to the `AudioContext` destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `start` to play the sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This seems like a lot, but in reality, it's very fast, so there's not much use
    in caching `AudioBufferSource`, especially since you can only call `start` once.
    Now that we can play a sound, it's time to load a sound resource and decode it,
    so that we have an `AudioBuffer` to play. Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To load a sound from the server, we''ll need to translate the following code,
    which you''ve already seen, into Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetching the resource is something we can already do in our `browser` module,
    but we don''t have a handy way to get its `arrayBuffer`, so we''ll need to add
    that. We''ll also need to create a Rust version of `decodeAudioData`. Let''s start
    with the changes we need to add to `browser`, which are modifications to existing
    methods. We''ll want to split the old `fetch_json` function, which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to split it into two functions that first fetch `Result<Response>`,
    then a second that converts it into JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a classic case of *the second person pays for abstraction*, where we
    wrote the code we needed in [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038),
    *Drawing Sprites*, to load JSON, but now we need a version of `fetch` that can
    handle multiple kinds of responses, specifically, sound files that will be accessible
    as an `ArrayBuffer` instead. That code will need `fetch_response` but will convert
    it into a different object. Let''s write that code now, right below `fetch_json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Just as `fetch_json` does, this starts by calling `fetch_response` with the
    passed-in resource. Then, it calls the `array_buffer()` function on that response,
    which will return a promise that resolves to `ArrayBuffer`. Then, we convert from
    a promise to `JsFuture` as usual, in order to use the `await` syntax. Finally,
    we call `dyn_into` to convert the `JsValue` that all `Promise` types return into
    `ArrayBuffer`. I've skipped over it, but at each step, we use `map_err` to convert
    the `JsValue` errors into `Error` types.
  prefs: []
  type: TYPE_NORMAL
- en: The `ArrayBuffer` type is a JavaScript type that isn't available to our code
    yet. It's a core JavaScript type, defined in the ECMAScript standard, and in order
    to use it directly, we need to add the `js-sys` crate. This is somewhat surprising,
    as we are already pulling in `wasm-bindgen` and `web-sys`, which are both dependent
    on JavaScript, so why do we need to pull in yet another crate for `ArrayBuffer`?
    This has to do with how the various crates are arranged. The `web-sys` crate has
    all the web APIs where `js-sys` is limited to code that is in the ECMAScript standard.
    Up to now, we haven't had to use anything in core JavaScript except what was exposed
    by `web-sys`, but this changes with `ArrayBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: In order for this code to compile, you'll need to add `js-sys = "0.3.55"` to
    the list of dependencies in `Cargo.toml`. It is already in `dev-dependencies`,
    so you can just move it from there. You'll also need to add a `use` `js_sys::ArrayBuffer`
    declaration to import the `ArrayBuffer` struct`.`
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The various libraries are likely to change in small ways after the publication
    of this book. If you have any difficulties with these dependencies, check the
    documentation at [https://github.com/rustwasm/wasm-bindgen](https://github.com/rustwasm/wasm-bindgen).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can fetch a sound file and get it as an `ArrayBuffer`, we''re ready
    to write our version of `await audioContext.decodeAudioData(soundBuffer)`. By
    now, you may have noticed that we''re following the same pattern for wrapping
    every JavaScript function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert any function that returns a promise, such as `decode_audio_data`, into
    `JsFuture` so you can use it in asynchronous Rust code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map any errors from `JsValue` into your own error types; in this case, we're
    using `anyhow::Result` but you may want more specific errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `?` operator to propagate errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for feature flags, particularly when using `web_sys` and you just *know*
    a library exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To this, we'll add one more step.
  prefs: []
  type: TYPE_NORMAL
- en: Cast from `JsValue` types to more specific types using the `dyn_into` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following that same pattern, the Rust version of `decodeAudioData` goes in
    the `sound` module, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You'll need to make sure you add `use` declarations for `js_sys::ArrayBuffer`
    and `wasm_bindgen_futures::JsFuture`, and also `wasm_bindgen::JsCast` to bring
    the `dyn_into` function into scope. Once again instead of directly calling the
    method on `AudioContext`, in this case `decodeAudioData`, we've created a function
    that wraps the call. It borrows a reference to `AudioContext` as the first parameter
    and takes the `ArrayBuffer` type as the second parameter. This allows us to encapsulate
    the mapping of errors and casting of results into a function.
  prefs: []
  type: TYPE_NORMAL
- en: This function then delegates to `ctx.decode_audio_data`, passing it `ArrayBuffer`,
    but if that's all it did we wouldn't really need it. It then takes any error from
    `ctx.decode_audio_data` and maps it to `Error` with `anyhow!`; in fact, as you
    can see, it will ultimately do this at every step in the process, pairing that
    with the `?` operator to propagate the error. It takes a promise from `decode_audio_data`
    and creates `JsFuture` from it, then immediately calls `await` to wait for completion,
    corresponding to the `await` call in JavaScript. After handling any errors converting
    the promise to `JsFuture`, we use the `dyn_into` function to cast it to `AudioBuffer`,
    ultimately handling any errors with that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'That function is the most complicated of the wrapper functions, so let''s reiterate
    the steps we did when translating from one line of JavaScript to nine lines of
    Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert any function that returns a promise into `JsFuture` so you can use it
    in asynchronous Rust code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, `decode_audio_data` returned a promise, and we converted it into
    `JsFuture` with `JsFuture::from`, then immediately called `await` on it.
  prefs: []
  type: TYPE_NORMAL
- en: Map any errors from `JsValue` into your own error type; in this case, we're
    using `anyhow::Result`, but you may want more specific errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We did this three times, as every call seemed to return a `JsValue` version
    of the result, adding clarifying language to the error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Cast from `JsValue` types to more specific types using the `dyn_into` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We did this to convert the ultimate result of `decode_audio_data` from `JsValue`
    to `AudioBuffer`, and Rust's compiler could infer the appropriate type from the
    return value of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to use the `?` operator to propagate errors; note how this function
    does that twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the `?` operator twice to make the function easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Check for feature flags, particularly when using `web_sys` and you just *know*
    a library exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AudioBuffer` is feature flagged, but we added that back at the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: This process is a bit more complicated to explain than it is in practice. For
    the most part, you can follow the compiler and use tools such as `rust-analyzer`
    to do things such as automatically add `use` declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got all the utilities, we need to play a sound. It's time to
    add that feature to the `engine` module so our game can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding audio to the engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functions we just created in the `sound` module could be used by the engine
    directly via delegation functions, but we don''t want to make the game worry about
    `AudioContext`, `AudioBuffer`, and things like that. Just like `Renderer`, we''ll
    create an `Audio` struct that encapsulates the details of that implementation.
    We''ll also create a `Sound` struct to convert `AudioBuffer` into a friendlier
    type for the rest of the system. Those will be very small, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These structs are added to the bottom of the `engine` module, but they can really
    be put anywhere in the file. Don't forget to import `AudioContext` and `AudioBuffer`!
    If you're finding yourself getting confused as `engine` and `game` get larger,
    you're welcome to break that up into multiple files with a `mod.rs` file and a
    directory, but to follow along, everything needs to end up in the `engine` module.
    I'm not going to do that because, while it makes the code a bit easier to navigate,
    it makes it harder to explain and follow along with. Breaking it up into smaller
    chunks later is an excellent exercise to make sure you understand the code we're
    writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a struct representing `Audio` holding `AudioContext`, and
    a corresponding `Sound` holding `AudioBuffer`, we can add `impl` to `Audio`, which
    uses the functions we wrote earlier to play a sound. Now, we''ll want to add `impl`
    to the `Audio` struct to play sounds and load them. Let''s start with the load
    implementation, which is probably the hardest, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `impl` will start with two methods, the familiar `new` method that creates
    an `Audio` struct with `AudioContext`. Pay attention to the fact that `new` returns
    a result in this case, because `create_audio_context` can fail. Then, we have
    the `load_sound` method, which also returns a result, this time of the `Sound`
    type, which is only three lines. This is a sign we did something right with the
    way we organized our functions in the `sound` and `browser` modules, as we can
    simply call our `fetch_array_buffer` and `decode_audio_data` functions to get
    `AudioBuffer` and then wrap it in a `Sound` struct. We return a result and propagate
    errors via `?`. If loading a sound was simple, then playing it is easy in this
    method on the `Audio` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For `play_sound`, we really just delegate, passing along `AudioContext` that
    `Audio` holds and `AudioBuffer` from the passed-in sound.
  prefs: []
  type: TYPE_NORMAL
- en: We've written a module to play sounds in the API, added loading sounds to the
    browser, and finally created an audio portion of our game engine. That's enough
    to play a sound effect in the engine; now we need to add it to our game, and here
    it's going to get complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding sound effects to our game is a challenge for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Effects must only occur once:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll be adding a sound effect for jumping (*boing!*) and want to make sure
    that it only happens one time. Fortunately, we have something for that already,
    our state machine! We can use `RedHatBoyContext` to play a sound when something
    happens, something like this (don''t add it yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This leads directly into our second challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Playing audio on transitions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to play the sound at the moment of transition, but most transitions
    won't play a sound. Remember our state machine uses `transition` to transition
    from one event to another, and while we could pass in the audio there it would
    only be used by a small portion of the code in that method. It's a code smell,
    so we won't do that. `RedHatBoyContext` will have to own the audio and the sound.
    This isn't ideal, we'd prefer there to be only one audio in the system, but that's
    not workable with our state machine. That leads to our third problem.
  prefs: []
  type: TYPE_NORMAL
- en: '`AudioContext` and `AudioBuffer` are not `Copy`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to use syntax such as `self.state = self.state.jump();` in the `RedHatBoy`
    implementation and have each state transition consume `RedHatBoyContext`, we needed
    `RedHatBoyContext` to be `Copy`. Unfortunately, `AudioContext` and `AudioBuffer`
    are not `Copy`, which means `Audio` and `Sound` cannot be `Copy` and, therefore,
    if `RedHatBoyContext` is going to hold audio and a sound, it cannot also be a
    copy. This stinks, but we can fix it by refactoring `RedHatBoyContext` and `RedHatBoy`
    to use the `clone` function as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Having `RedHatBoyContext` own an audio means that there will be more than one
    `Audio` object in the system potentially, where the other will play music. This
    is redundant but mostly harmless, so it's the solution we'll go with. It gets
    us moving forward with development, and in the end, the solution works well. When
    in doubt, choose the solution that ships.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we don't store a reference to `Audio` in `RedHatBoyContext`.
    Ultimately, `Game` is static in our engine, and therefore, an `Audio` reference
    must be guaranteed to live as long as `Game` if it's stored as a reference on
    `RedHatBoyContext`.
  prefs: []
  type: TYPE_NORMAL
- en: There are other options, including using the service locator pattern ([https://bit.ly/3A4th2f](https://bit.ly/3A4th2f))
    or passing in the audio into the `update` function as a parameter, but they all
    take longer to get us to our end goal of playing a sound, which is the real goal
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can add a sound effect to the game, we're going to refactor the code
    to hold an `Audio` element. Then we'll play the sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring RedHatBoyContext and RedHatBoy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to prepare `RedHatBoyContext` and `RedHatBoy` to hold audio and
    a song before we actually do it because that will make it easier to add the sound.
    Let''s start by making `RedHatBoyContext` just `clone`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'All we''ve done is removed the `Copy` trait from the `derive` declaration.
    This will cause compiler errors on `RedHatBoyStateMachine` and `RedHatBoyState<S>`,
    which both derive `Copy`, so you''ll need to remove that declaration on those
    structures as well. Once you''ve done that, you''ll see a bunch of errors like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the calls to `self.state.<method>`, where the method takes `self`,
    all fail to compile, because `RedHatBoyStateMachine` doesn''t implement `Copy`
    anymore. The solution, and we''ll do this on every line with this compiler error,
    is to explicitly clone the state when we want to make the change. Here''s the
    `run_right` function with the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here it is with the fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps the most teeth-grindingly offensive instance of this is in the `transition`
    method, where we will get a move because of the `match` statement, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The trouble with this section is that `self` is moved into the `match` statement
    and cannot be returned in the default case. Trying to use `match` and `self` to
    get around the issue causes all of the typestate methods, such as `land_on` and
    `knock_out`, to fail because they need to consume `self`. The *cleanest* fix is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It's gross, I admit, but we are able to keep progressing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: I know what you're thinking – performance! We're cloning on each transition!
    You're absolutely right, but do you know that the performance is adversely impacted?
    The first rule of performance is *measure first*, and until we measure this, we
    don't actually know if the final version of this code is a problem. I spent a
    lot of time trying to avoid this `clone` call because of performance concerns,
    and it turned out not to make much of a difference at all. Make it work, then
    make it fast.
  prefs: []
  type: TYPE_NORMAL
- en: Once you fix that error a few times, you're ready to add the audio and the sound
    to `RedHatBoyContext`, but what sound will we play?
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sound effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the Web Audio API, we can play any sound format that is supported by the
    `audio` HTML element, which includes all the common formats of WAV, MP3, MP4,
    and Ogg. In addition, in 2017, the MP3 license expired, so if you're concerned
    about that, don't be; you can use MP3 files for sounds without worry.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Web Audio API is compatible with so many audio formats, you can use
    sound from all over the internet, provided it's released under the appropriate
    license. The sound effect we'll be using for jumping is available at [https://opengameart.org/content/8-bit-jump-1](https://opengameart.org/content/8-bit-jump-1)
    and is released under the *Creative Commons public domain* license, so we can
    use it without concern. You don't need to download that bundle and browse through
    it, although you can, but the jump sound is already bundled with this book's assets
    at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)
    in the `sounds` directory. The specific file we want is `SFX_Jump_23.mp3`. You'll
    want to copy that file into the `static` directory of your Rust project so that
    it will be available for your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `RedHatBoyContext` is ready to hold the `Audio` struct, and the `SFX_Jump_23.mp3`
    file is available to be loaded, we can start adding that code. Start with adding
    `Audio` and `Sound` to `RedHatBoyContext` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to add `use` declarations for `Audio` and `Sound` to the `red_hat_boy_states`
    module. The code will stop compiling because `RedHatBoyContext` is being initialized
    without `audio` or `jump_sound`, so we''ll need to add that. `RedHatBoyContext`
    is initialized in the `new` method of the `RedHatBoyState<Idle>` implementation
    so we''ll change that method to take `Audio` and `Sound` objects that we''ll pass
    into `RedHatBoyContext` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We could create an `Audio` object here, but then the `new` method would need
    to return `Result<Self>` and I don't think that's appropriate. This will move
    the compiler error, because where we call `RedHatBoyState<Idle>::new` is now wrong.
    That is in `RedHatBoy::new`, which can now also take `Audio` and `Sound` objects
    and pass them through.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to our infamous `initialize` function in our `Game` implementation,
    which fails to compile because it calls `RedHatBoy::new` without `Audio` or `Sound`.
    This is the appropriate place to load a file, both because it is `async` and because
    it returns a result. We''ll create an `Audio` object in `initialize`, load up
    the sound we want, and pass it to the `RedHatBoy::new` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get the app compiling again, but we don''t do anything with `audio`
    or `sound`. Remember that all this work was done because we wanted to make sure
    the sound is only played *once* when we jump, and the way to ensure that is to
    put the playing of the sound in the transition from `Running` to `Jumping`. Transitions
    are done in the various `From` implementations via methods on `RedHatBoyContext`.
    Let''s write a small function called `play_jump_sound` on `RedHatBoyContext`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is written a little differently than the other transition side
    effect functions in this implementation, because `play_sound` returns a result,
    but in order to be consistent with the other transition methods, `play_jump_sound`
    really shouldn''t. Fortunately, failing to play a sound, while annoying, isn''t
    fatal, so we''ll log the error and continue if the sound couldn''t be played.
    The code now compiles, but we need to add the call to `play_jump_sound` to the
    transition. Look for `jump` on `RedHatBoyState<Running>` and modify that transition
    to call `play_jump_sound`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When this compiles, run the game and you'll see, and hear, RHB jump onto a platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Can you hear it?](img/Figure_7.01_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Can you hear it?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If, like most developers I know, you have 20+ browser tabs open right now, you
    may want to close them. It can slow down the browser's sound playback and make
    the sound timing off.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've played one sound effect, consider adding more, for example,
    when RHB crashes into an obstacle, or lands cleanly, or slides. The choices are
    up to you! After you've had a little fun with sound effects, let's add some background
    music.
  prefs: []
  type: TYPE_NORMAL
- en: Playing long music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might think that playing music will mean detecting whether the sound is
    complete and restarting it. This is probably true for the browser''s implementation,
    but fortunately, you don''t have to do it. The Web Audio API already has a flag
    on the `AudioBufferSourceNode` loop that will play the sound on a loop until it
    is explicitly stopped. This will make playing background audio rather simple.
    We can add a flag to the `play_sound` function in the `sound` module for the `loop`
    parameter, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts with the `create_track_source` function, which is actually a refactoring
    of the `play_sound` function. It takes the first three lines of it and extracts
    them into a separate function for readability. After that, we create a `LOOPING`
    enum and use it to check whether we should call `set_loop` on `track_source`.
    You might wonder why we don''t just pass `bool` as the third parameter, and the
    answer is that it is going to be much easier to read the first line of code shown
    here than the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Six months from now, when I don''t know what that Boolean is for, I''ll have
    to look it up, whereas the version with the enum is obvious. By adding this flag,
    our program stops compiling because `Audio` in the engine is still calling `play_sound`
    with two parameters. We can quickly fix that, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add a new method to play background music, which is just playing
    a sound with looping turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'I like how the engine has progressively less flexibility than the `sound` module.
    The `sound` and `browser` modules are wrappers around the browser functionality;
    the engine provides utilities to help you make a game. Now that the engine provides
    a way to play background music, we can actually add it to the game. In the assets,
    there''s a second file in the `sounds` directory, `background_song.mp3`, which
    you can copy into the `static` directory of this project. Once you''ve done that,
    we can load and play the background music in our `Game::initialize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://gamesounds.xyz/](https://gamesounds.xyz/) for royalty-free
    sounds for your games.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we load the second song, `background_song.mp3`, and play it immediately
    with `play_looping_sound`. On most browsers, you won't hear the music until you
    click the canvas to give it focus, so check that if you don't hear anything. One
    thing to note is that, even though that sound is going to go out of scope, the
    browser will happily keep playing it. We've passed along the song to the browser
    and it's in charge now. Nothing changes about the creation of `RedHatBoy` as the
    audio is moved into it, and it will eventually be in charge of playing sound effects
    for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You may want to mute your browser while developing, as each time the browser
    refreshes, the song will restart.
  prefs: []
  type: TYPE_NORMAL
- en: There you have it! A proper game with music and sound effects! Now to add a
    UI, so we can actually click **New Game** on it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you added sounds to your game using the Web Audio API and got
    an overview of the API itself. The Web Audio API is very broad and has a ton of
    features, and I'd encourage you to explore it. Your first challenge is to use
    the `gain` property to change the volume of the music, which is rather loud at
    the moment. The Web Audio API also supports features such as stereo surround sound
    and programmatically generated music. Have some fun and try it out!
  prefs: []
  type: TYPE_NORMAL
- en: You also added a new module to the game, and further extended the game engine
    to support it. We even covered refactoring and made some trade-offs to ensure
    the game would finish without requiring a time-consuming *ideal* design. I encourage
    you to take some time to add more sound effects to the game; you have the skills
    now to make RHB *thud* when he lands or crashes into a rock. Speaking of crashing
    into rocks, you're probably sick of having to hit *refresh* every time you do
    that, so in the next chapter, we'll add a small UI with a wonderful **New Game**
    button.
  prefs: []
  type: TYPE_NORMAL
