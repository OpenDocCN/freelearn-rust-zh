["```rs\ndocker container ls -a\n```", "```rs\nCONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES\n```", "```rs\ndocker image ls\n```", "```rs\nREPOSITORY  TAG  IMAGE ID  CREATED  SIZE\n```", "```rs\nversion: \"3.7\"\nservices:\n  postgres:\n    container_name: 'to-do-postgres'\n    image: 'postgres:11.2'\n    restart: always\n    ports:\n      - '5432:5432'\n    environment:\n      - 'POSTGRES_USER=username'\n      - 'POSTGRES_DB=to_do'\n      - 'POSTGRES_PASSWORD=password'\n```", "```rs\n{\n  \"version\": \"3.7\",\n  \"services\": {\n    \"postgres\": {\n      \"container_name\": \"to-do-postgres\",\n      \"image\": \"postgres:11.2\",\n      \"restart\": \"always\",\n      \"ports\": [\n        \"5432:5432\"\n      ],\n      \"environment\": [\n        \"POSTGRES_USER=username\",\n        \"POSTGRES_DB=to_do\",\n        \"POSTGRES_PASSWORD=password\"\n      ]\n    }\n  }\n}\n```", "```rs\ndocker-compose up\n```", "```rs\nLOG:  listening on IPv4 address \"0.0.0.0\", port 5432\nLOG:  listening on IPv6 address \"::\", port 5432\nLOG:  listening on Unix socket \"/var/run/postgresql/.s.PGSQL.5432\"\nLOG:  database system was shut down at 2022-04-23 17:36:45 UTC\nLOG:  database system is ready to accept connections\n```", "```rs\ndocker container ls -a\n```", "```rs\nCONTAINER ID        IMAGE               COMMAND                  \nc99f3528690f        postgres:11.2       \"docker-entrypoint.s…\"\nCREATED             STATUS                          PORTS\n4 hours ago         Exited (0) About a minute ago        \nNAMES\nto-do-postgres\n```", "```rs\nversion: \"3.7\"\nservices:\n  postgres:\n    container_name: 'to-do-postgres'\n    image: 'postgres:11.2'\n    restart: always\n    ports:\n      - '5432:5432'\n    environment:\n      - 'POSTGRES_USER=username'\n      - 'POSTGRES_DB=to_do'\n      - 'POSTGRES_PASSWORD=password'\n  postgres_two:\n    container_name: 'to-do-postgres_two'\n    image: 'postgres:11.2'\n    restart: always\n    ports:\n      - '5433:5432'\n    environment:\n      - 'POSTGRES_USER=username'\n      - 'POSTGRES_DB=to_do'\n      - 'POSTGRES_PASSWORD=password'\n```", "```rs\ndocker image ls\n```", "```rs\nREPOSITORY          TAG                 IMAGE ID    \npostgres            11.2                3eda284d1840\nCREATED             SIZE\n17 months ago       312MB\n```", "```rs\ndocker-compose up -d\n```", "```rs\nStarting to-do-postgres ... done\n```", "```rs\nSTATUS              PORTS                    NAMES\nUp About a minute   0.0.0.0:5432->5432/tcp   to-do-postgres\n```", "```rs\ndocker logs c99f3528690f\n```", "```rs\ndocker-compose stop\n```", "```rs\ndocker-compose down\n```", "```rs\n#!/bin/bash\ncd ..\ndocker-compose up -d\nuntil pg_isready -h localhost -p 5432 -U username\ndo\n  echo \"Waiting for postgres\"\n  sleep 2;\ndone\necho \"docker is now running\"\ndocker-compose down\n```", "```rs\n❯ sh wait_for_database.sh \n[+] Running 0/0\n ⠋ Network web_app_default  Creating        0.2s\n ⠿ Container to-do-postgres      Started    1.5s\nlocalhost:5432 - no response\nWaiting for postgres\nlocalhost:5432 - no response\nWaiting for postgres\nlocalhost:5432 - accepting connections\ndocker is now running\n[+] Running 1/1\n ⠿ Container to-do-postgres  Removed        1.2s\n ⠿ Network web_app_default   Removed  \n```", "```rs\n    diesel = { version = \"1.4.8\", features = [\"postgres\", \n    ```", "```rs\n                                              \"chrono\", \n    ```", "```rs\n                                              \"r2d2\"] }\n    ```", "```rs\n    dotenv = \"0.15.0\"\n    ```", "```rs\n    chrono = \"0.4.19\"\n    ```", "```rs\n    cargo install diesel_cli --no-default-features \n    ```", "```rs\n        --features postgres\n    ```", "```rs\n    echo DATABASE_URL=postgres://username:password@localhost/to_do \n    ```", "```rs\n        > .env\n    ```", "```rs\nDATABASE_URL=postgres://username:password@localhost/to_do\n```", "```rs\n    diesel setup\n    ```", "```rs\n── migrations\n│   └── 00000000000000_diesel_initial_setup\n│       ├── down.sql\n│       └── up.sql\n```", "```rs\n    diesel migration generate create_to_do_items\n    ```", "```rs\nCreating migrations/2022-04-23-201747_create_to_do_items/up.sql\nCreating migrations/2022-04-23-201747_create_to_do_items/down.sql\n```", "```rs\n├── migrations\n│   ├── 00000000000000_diesel_initial_setup\n│   │   ├── down.sql\n│   │   └── up.sql\n│   └── 2022-04-23-201747_create_to_do_items\n│       ├── down.sql\n│       └── up.sql\n```", "```rs\nCREATE TABLE to_do (\n  id SERIAL PRIMARY KEY,\n  title VARCHAR NOT NULL,\n  status VARCHAR NOT NULL,\n  date timestamp NOT NULL DEFAULT NOW()\n)\n```", "```rs\nDROP TABLE to_do\n```", "```rs\n    diesel migration run\n    ```", "```rs\ndiesel migration redo\n```", "```rs\n    docker exec -it 5fdeda6cfe43 psql -U username to_do\n    ```", "```rs\nto_do=#\n```", "```rs\nSchema |            Name            |   Type   |  Owner \n--------+----------------------------+----------+----------\n public | __diesel_schema_migrations | table    | username\n public | to_do                      | table    | username\n public | to_do_id_seq               | sequence | username\n```", "```rs\n    Table \"public.to_do\"\n    ```", "```rs\n     Column |            Type             | Collation |\n    ```", "```rs\n    --------+-----------------------------+-----------+\n    ```", "```rs\n     id     | integer                     |           |\n    ```", "```rs\n     title  | character varying           |           |\n    ```", "```rs\n     status | character varying           |           |\n    ```", "```rs\n     date   | timestamp without time zone |           |\n    ```", "```rs\n    | Nullable |              Default              | Storage  |\n    ```", "```rs\n    +----------+-----------------------------------+----------+\n    ```", "```rs\n    | not null | nextval('to_do_id_seq'::regclass) | plain    | \n    ```", "```rs\n    | not null |                                   | extended | \n    ```", "```rs\n    | not null || extended | \n    ```", "```rs\n    | not null | now()                             | plain    |            \n    ```", "```rs\n    Indexes:\n    ```", "```rs\n        \"to_do_pkey\" PRIMARY KEY, btree (id)\n    ```", "```rs\n    SELECT * FROM  __diesel_schema_migrations;\n    ```", "```rs\n    version     |           run_on           \n----------------+----------------------------\n 00000000000000 | 2022-04-25 23:10:07.774008\n 20220424171018 | 2022-04-25 23:29:55.167845\n```", "```rs\ndiesel migration revert\n```", "```rs\nRolling back migration 2022-04-24-171018_create_to_do_items\n```", "```rs\n    version     |           run_on \n----------------+----------------------------\n 00000000000000 | 2022-04-25 23:10:07.774008\n```", "```rs\nuse diesel::prelude::*;\nuse diesel::pg::PgConnection;\nuse dotenv::dotenv;\nuse std::env;\npub fn establish_connection() -> PgConnection {\n    dotenv().ok();\n    let database_url = env::var(\"DATABASE_URL\")\n        .expect(\"DATABASE_URL must be set\");\n    PgConnection::establish(&database_url)\n        .unwrap_or_else(\n        |_| panic!(\"Error connecting to {}\", \n        database_url))\n}\n```", "```rs\ntable! {\n    to_do (id) {\n        id -> Int4,\n        title -> Varchar,\n        status -> Varchar,\n        date -> Timestamp,\n    }\n}\n```", "```rs\n#[macro_use] extern crate diesel;\nextern crate dotenv;\nuse actix_web::{App, HttpServer};\nuse actix_service::Service;\nuse actix_cors::Cors;\nmod schema;\nmod database;\nmod views;\nmod to_do;\nmod state;\nmod processes;\nmod json_serialization;\nmod jwt;\n```", "```rs\n├── models\n│   ├── item\n│   │   ├── item.rs\n│   │   ├── mod.rs\n│   │   └── new_item.rs\n│   └── mod.rs\n```", "```rs\nuse crate::schema::to_do;\nuse chrono::{NaiveDateTime, Utc};\n#[derive(Insertable)]\n#[table_name=\"to_do\"]\npub struct NewItem {\n    pub title: String,\n    pub status: String,\n    pub date: NaiveDateTime\n}\nimpl NewItem {\n    pub fn new(title: String) -> NewItem {\n        let now = Utc::now().naive_local();\n        return NewItem{\n            title, \n            status: String::from(\"PENDING\"), \n            date: now\n        }\n    }\n}\n```", "```rs\nuse crate::schema::to_do;\nuse chrono::NaiveDateTime;\n#[derive(Queryable, Identifiable)]\n#[table_name=\"to_do\"]\npub struct Item {\n    pub id: i32,\n    pub title: String,\n    pub status: String,\n    pub date: NaiveDateTime\n}\n```", "```rs\npub mod new_item;\npub mod item;\n```", "```rs\npub mod item;\n```", "```rs\nmod models;\n```", "```rs\nuse crate::diesel;\nuse diesel::prelude::*;\nuse crate::database::establish_connection;\nuse crate::models::item::item::Item;\nuse crate::schema::to_do;\n```", "```rs\npub fn get_state() -> ToDoItems {\n    let connection = establish_connection();\n    let mut array_buffer = Vec::new();\n    let items = to_do::table\n        .order(to_do::columns::id.asc())\n        .load::<Item>(&connection).unwrap();\n    for item in items {\n        let status = \n            TaskStatus::new(&item.status.as_str());\n        let item = to_do_factory(&item.title, status);\n        array_buffer.push(item);\n    }                            \n    return ToDoItems::new(array_buffer)\n}\n```", "```rs\nfn some_function<T: SomeType>(some_input: &T) -> () {\n    . . .\n}\n```", "```rs\nuse crate::state::read_file;\nuse serde_json::value::Value;\nuse serde_json::Map;\n```", "```rs\nuse crate::diesel;\nuse diesel::prelude::*;\nuse actix_web::HttpResponse;\nuse actix_web::HttpRequest;\nuse crate::json_serialization::to_do_items::ToDoItems;\nuse crate::database::establish_connection;\nuse crate::models::item::new_item::NewItem;\nuse crate::models::item::item::Item;\nuse crate::schema::to_do;\n```", "```rs\npub async fn create(req: HttpRequest) -> HttpResponse {\n    let title: String = req.match_info().get(\"title\"\n    ).unwrap().to_string();\n    . . .\n}\n```", "```rs\nlet connection = establish_connection();\nlet items = to_do::table\n    .filter(to_do::columns::title.eq(&title.as_str()))\n    .order(to_do::columns::id.asc())\n    .load::<Item>(&connection)\n    .unwrap();\n```", "```rs\nif items.len() == 0 {\n    let new_post = NewItem::new(title);\n    let _ = \n     diesel::insert_into(to_do::table).values(&new_post)\n     .execute(&connection);\n}\nreturn HttpResponse::Ok().json(ToDoItems::get_state())\n```", "```rs\nuse serde_json::value::Value;\nuse serde_json::Map;\nuse crate::state::read_file;\nuse crate::processes::process_input;\nuse crate::to_do::{to_do_factory, enums::TaskStatus};\n```", "```rs\nuse crate::diesel;\nuse diesel::prelude::*;\nuse actix_web::{web, HttpResponse};\nuse crate::json_serialization::{to_do_item::ToDoItem, \n                                to_do_items::ToDoItems};\nuse crate::jwt::JwToken;\nuse crate::database::establish_connection;\nuse crate::schema::to_do;\n```", "```rs\npub async fn edit(to_do_item: web::Json<ToDoItem>, \n    token: JwToken) -> HttpResponse {\n    let connection = establish_connection();\n    let results = to_do::table.filter(to_do::columns::title\n        .eq(&to_do_item.title));\n\n    let _ = diesel::update(results)\n        .set(to_do::columns::status.eq(\"DONE\"))\n        .execute(&connection);\n    return HttpResponse::Ok().json(ToDoItems::get_state())\n}\n```", "```rs\nuse crate::processes::process_input;\nuse crate::to_do::{to_do_factory, enums::TaskStatus};\nuse serde_json::value::Value;\nuse serde_json::Map;\nuse crate::state::read_file;\n```", "```rs\nuse crate::diesel;\nuse diesel::prelude::*;\nuse actix_web::{web, HttpResponse};\nuse crate::database::establish_connection;\nuse crate::schema::to_do;\nuse crate::json_serialization::{to_do_item::ToDoItem, \n                                to_do_items::ToDoItems};\nuse crate::jwt::JwToken;\nuse crate::models::item::item::Item;\n```", "```rs\npub async fn delete(to_do_item: web::Json<ToDoItem>, \n                    token: JwToken) -> HttpResponse {\n    let connection = establish_connection();\n    let items = to_do::table\n        .filter(to_do::columns::title.eq(\n                &to_do_item.title.as_str()))\n        .order(to_do::columns::id.asc())\n        .load::<Item>(&connection)\n        .unwrap();\n    let _ = diesel::delete(&items[0]).execute(&connection);\n    return HttpResponse::Ok().json(ToDoItems::get_state())\n}\n```", "```rs\nwarning: function is never used: `read_file`\n  --> src/state.rs:17:8\n   |\n17 | pub fn read_file(file_name: &str) -> Map<String, Value> {\n. . .\nwarning: function is never used: `process_pending`\n  --> src/processes.rs:18:4\n   |\n18 | fn process_pending(item: Pending, command: String, \n                        state: &Map<String, Value>) {\n```", "```rs\nuse super::super::traits::get::Get;\nuse super::super::traits::edit::Edit;\nuse super::super::traits::create::Create;\n```", "```rs\nimpl Get for Pending {}\nimpl Edit for Pending {}\nimpl Create for Pending {}\n```", "```rs\nserde_yaml = \"0.8.23\"\n```", "```rs\nuse std::collections::HashMap;\nuse std::env;\nuse serde_yaml;\n```", "```rs\npub struct Config {\n    pub map: HashMap<String, serde_yaml::Value>\n}\n```", "```rs\nimpl Config {\n    pub fn new() -> Config {\n        let args: Vec<String> = env::args().collect();\n        let file_path = &args[args.len() - 1];\n        let file = std::fs::File::open(file_path).unwrap();\n        let map: HashMap<String, serde_yaml::Value> = \n            serde_yaml::\n                 from_reader(file).unwrap();\n        return Config{map}\n    }\n}\n```", "```rs\nmod config;\n```", "```rs\nuse diesel::prelude::*;\nuse diesel::pg::PgConnection;\nuse crate::config::Config;\n```", "```rs\nDB_URL: postgres://username:password@localhost:5433/to_do\n```", "```rs\ncargo run config.yml\n```", "```rs\nlazy_static = \"1.4.0\"\n```", "```rs\nuse actix_web::dev::Payload;\nuse actix_web::error::ErrorServiceUnavailable;\nuse actix_web::{Error, FromRequest, HttpRequest};\nuse futures::future::{Ready, ok, err};\nuse lazy_static::lazy_static;\nuse diesel::{\n   r2d2::{Pool, ConnectionManager, PooledConnection},\n   pg::PgConnection,\n};\nuse crate::config::Config;\n```", "```rs\ntype PgPool = Pool<ConnectionManager<PgConnection>>;\npub struct DbConnection {\n   pub db_connection: PgPool,\n}\n```", "```rs\nlazy_static! {\n    pub static ref DBCONNECTION: DbConnection = {\n        let connection_string = \n            Config::new().map.get(\"DB_URL\").unwrap()\n            .as_str().unwrap().to_string();\n      DbConnection {\n          db_connection: PgPool::builder().max_size(8)\n          .build(ConnectionManager::new(connection_string))\n          .expect(\"failed to create db connection_pool\")\n       }\n   };\n}\n```", "```rs\npub fn establish_connection() -> \n  PooledConnection<ConnectionManager<PgConnection>>{\n    return DBCONNECTION.db_connection.get().unwrap()\n}\n```", "```rs\npub struct DB {\n   pub connection: PooledConnection<ConnectionManager<PgConnection>>\n}\n```", "```rs\nimpl FromRequest for DB {\n  type Error = Error;\n  type Future = Ready<Result<DB, Error>>;\n  fn from_request(_: &HttpRequest, _: &mut Payload) -> \n      Self::Future{\n      match DBCONNECTION.db_connection.get() {\n         Ok(connection) => {\n            return ok(DB{connection})\n         },\n         Err(_) => {\n            return err(ErrorServiceUnavailable(\n            \"could not make connection to database\"))\n         }\n      }\n  }\n}\n```", "```rs\nuse crate::diesel;\nuse diesel::prelude::*;\nuse actix_web::{web, HttpResponse};\nuse crate::json_serialization::{to_do_item::ToDoItem, \n                                to_do_items::ToDoItems};\nuse crate::jwt::JwToken;\nuse crate::schema::to_do;\nuse crate::database::DB;\n```", "```rs\npub async fn edit(to_do_item: web::Json<ToDoItem>, \n    token: JwToken, db: DB) -> HttpResponse {\n    let results = to_do::table.filter(to_do::columns::title\n        .eq(&to_do_item.title));\n\n    let _ = diesel::update(results)\n        .set(to_do::columns::status.eq(\"DONE\"))\n        .execute(&db.connection);\n    return HttpResponse::Ok().json(ToDoItems::get_state())\n}\n```"]