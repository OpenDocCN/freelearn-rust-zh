- en: Getting Ready
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this guide, we're going to learn the basics of working with Rust, a systems-level
    programming language that has been making a name for itself over the last few
    years. Rust is a strict language, designed to make the most common errors impossible
    and less common errors obvious.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指南中，我们将学习与Rust一起工作的基础知识，这是一种在过去的几年中逐渐成名的系统级编程语言。Rust是一种严格的语言，旨在使最常见的错误成为不可能，使不太常见的错误变得明显。
- en: Being a systems-level language means that Rust is guided by the needs of low-level
    programs that don't have a safety net, because they *are *the safety net for higher-level
    programs. Operating system kernels, web browsers, and other critical pieces of
    infrastructure are systems-level applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种系统级语言，Rust受没有安全网的低级程序需求的指导，因为它们*正是*高级程序的安全网。操作系统内核、网络浏览器和其他关键基础设施都是系统级应用。
- en: This is not to say that Rust can only be used for writing critical infrastructure,
    of course. The efficiency and reliability of Rust code can benefit any program.
    It's just that the priorities for higher-level code can be different.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说Rust只能用于编写关键基础设施，当然不是。Rust代码的效率和可靠性可以惠及任何程序。只是高级代码的优先级可能不同。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: The `rustup` tool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rustup`工具'
- en: The `cargo` tool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo`工具'
- en: How to start a new Rust project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何开始一个新的Rust项目
- en: How to compile a Rust project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编译Rust项目
- en: How to locate third-party libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定位第三方库
- en: How to manage dependencies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何管理依赖项
- en: How to keep a Rust installation up-to-date
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何保持Rust安装更新
- en: How to switch between stable and beta Rust
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在稳定版和beta版Rust之间切换
- en: Installing Rust
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Rust
- en: 'Installing Rust on any supported platform is simple. All we need to do is navigate
    to [https://rustup.rs/](https://rustup.rs/). That page will give us a single-step
    procedure to install the command-line Rust compiler. The procedure differs slightly
    depending on the platform, but it''s never difficult. Here we see the `rustup.rs`
    page for Linux:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何支持的平台上安装Rust都非常简单。我们只需导航到[https://rustup.rs/](https://rustup.rs/)。该页面将为我们提供一个步骤的安装命令行Rust编译器的程序。根据平台的不同，程序略有差异，但从不困难。这里我们看到的是Linux的`rustup.rs`页面：
- en: '![](img/a5afd80a-e6dc-4335-ab7b-10aaad3b9236.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5afd80a-e6dc-4335-ab7b-10aaad3b9236.png)'
- en: 'The installer doesn''t just install the Rust compiler, it also installs a tool
    called `rustup` that can be used at any time to upgrade our compiler to the latest
    version. To do this, all we have to do is open up a command-line (or Terminal)
    window, and type: `rustup update`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序不仅安装了Rust编译器，还安装了一个名为`rustup`的工具，我们可以在任何时候使用它来升级我们的编译器到最新版本。为此，我们只需打开一个命令行（或终端）窗口，并输入：`rustup
    update`。
- en: Upgrading the compiler needs to be simple because the Rust project uses a six-week
    rapid release schedule, meaning there's a new version of the compiler every six
    weeks, like clockwork. Each release contains whatever new features have been deemed
    to be stable in the six weeks since the previous release, in addition to the features
    of previous releases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 升级编译器需要简单，因为Rust项目使用六周的快速发布计划，这意味着每六周就会有一个新的编译器版本，就像时钟一样。每个版本都包含自上次发布以来被认为稳定的所有新功能，以及之前版本的功能。
- en: Don't worry, the rapid release of new features doesn't mean that those features
    were slapped together in the six weeks prior to the release. It's common for them
    to have spent years in development and testing prior to that. The release schedule
    just makes sure that, once a feature is deemed to be truly stable, it doesn't
    take long to get into our hands.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，新功能的快速发布并不意味着这些功能在发布前的六周内匆忙拼凑而成。它们在发布前通常已经经过多年的开发和测试。发布计划只是确保一旦一个功能被认为真正稳定，它就能很快进入我们的手中。
- en: If we aren't willing to wait for a feature to be vetted and stabilized, for
    whatever reason, we can also use `rustup` to download, install, and update the
    *beta* or *nightly* releases of the compiler.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不愿意等待一个功能经过审查和稳定，无论出于什么原因，我们也可以使用`rustup`下载、安装和更新编译器的*beta*或*nightly*版本。
- en: 'To download and install the beta compiler, we just need to type this: `rustup
    toolchain install beta`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载和安装beta编译器，我们只需输入这个：`rustup toolchain install beta`。
- en: From that point on, when we use `rustup` to update our compiler, it will make
    sure that we have the newest versions of both the stable and beta compilers. We
    can then make the beta compiler active with `rustup default beta`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，当我们使用`rustup`更新我们的编译器时，它会确保我们拥有稳定和测试版编译器的最新版本。然后我们可以使用`rustup default beta`来激活测试版编译器。
- en: Please note that the beta compiler is not the same thing as the next release
    of the stable compiler. The beta version is where features live before they graduate
    to stable, and features can and do remain in beta for years.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试版编译器与下一个稳定编译器的下一个版本不是同一回事。测试版是功能在毕业到稳定之前存在的地方，功能可以在测试版中保持多年。
- en: The nightly version is at most 24 hours behind the development code repository,
    which means that it might be broken in any number of ways. It's not particularly
    useful unless you're actually participating in the development of Rust itself.
    However, should you want to try it out, `rustup` can install and update it as
    well. You might also find yourself depending on a library that someone else has
    written that depends on features that only exist in the nightly build, in which
    case you'll need to tell `rustup` that you need the nightly build, too.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每晚版本最多落后于开发代码仓库24小时，这意味着它可能以任何方式出现错误。除非你实际上正在参与Rust本身的发展，否则它并不特别有用。然而，如果你想要尝试它，`rustup`也可以安装和更新它。你也可能发现自己依赖于一个依赖于仅在每晚构建中存在的特性的库，在这种情况下，你需要告诉`rustup`你也需要每晚构建。
- en: 'One of the things `rustup` will install is a tool called `cargo`, which we''ll
    be seeing a lot of in this chapter, and using behind the scenes for the rest of
    this book. The `cargo` tool is the frontend to the whole Rust compiler system:
    it is used for creating new Rust project directories containing the initial boilerplate
    code for a program or library, for installing and managing dependencies, and for
    compiling Rust programs, among other things.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustup`将安装的一个工具是名为`cargo`的工具，我们将在本章中看到很多，并在本书的其余部分幕后使用它。`cargo`工具是整个Rust编译系统的前端：它用于创建包含程序或库初始样板代码的新Rust项目目录，用于安装和管理依赖项，以及编译Rust程序等。'
- en: Starting a new project
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始新项目
- en: Okay, so we've installed the compiler. Yay! But how do we use it?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们已经安装了编译器。太好了！但我们如何使用它呢？
- en: The first step is to open up a command-line window, and navigate to the directory
    where we want to store our new project. Then we can create the skeleton of a new
    program with `cargo new foo`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是打开一个命令行窗口，并导航到我们想要存储新项目的目录。然后我们可以使用`cargo new foo`来创建一个新程序的骨架。
- en: When we do this, `cargo` will create a new directory named `foo` and set up
    the skeletal program inside it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，`cargo`将在`foo`目录中创建一个新的目录，并在其中设置骨架程序。
- en: The default is for `cargo` to create the skeleton of an executable program,
    but we can also tell it to set up a new library for us. All that takes is an additional
    command-line argument (`bar` is the name of the new directory that will be created,
    like `foo`): `cargo new --lib bar`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`cargo`会创建一个可执行程序的骨架，但我们可以告诉它为我们设置一个新的库。这只需要一个额外的命令行参数（`bar`是新创建的目录的名称，就像`foo`一样）：`cargo
    new --lib bar`。
- en: When we look inside the newly created `foo` directory, we see a file called
    `Cargo.toml` and a sub-directory called `src`. There may also be a Git version
    control repository, which we will ignore for now.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看新创建的`foo`目录时，我们看到一个名为`Cargo.toml`的文件和一个名为`src`的子目录。可能还会有一个Git版本控制仓库，我们现在可以忽略它。
- en: Project metadata
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目元数据
- en: The `Cargo.toml` file is where metadata about the program is stored. That includes
    the program's name, version number, and authors, but importantly it also has a
    section for dependencies. Editing the content of the `[dependencies]` section
    is how we tell Rust that our code should be linked to external libraries when
    it is compiled, which libraries and versions to use, and where to find them. External
    libraries are collections of source code that were packaged up in order to make
    them easy to use as components of other programs. By finding and linking good
    libraries, we can save the time and effort of writing our whole program ourselves.
    Instead, we can write only the part that nobody else has already done.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo.toml`文件是存储程序元数据的地方。这包括程序名称、版本号和作者，但更重要的是，它还有一个依赖部分。编辑`[dependencies]`部分的内容是告诉Rust在编译我们的代码时应该链接到外部库，以及使用哪些库和版本，以及它们在哪里。外部库是一系列源代码的集合，被打包起来以便作为其他程序组件使用。通过找到并链接好的库，我们可以节省编写整个程序的时间和精力。相反，我们只需编写别人还没有做过的部分。'
- en: By the way, `.toml` files are written in **Tom's Obvious, Minimal Language**
    (**TOML**), a more well-defined and feature-complete version of the old `.ini` format
    that Microsoft popularized but never standardized. TOML is becoming quite popular,
    and is supported and used in a wide variety of languages and applications. You
    can find the language specification at [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`.toml`文件是用**Tom's Obvious, Minimal Language**（**TOML**）编写的，它是旧`.ini`格式的更定义明确和功能更完整的版本，虽然微软推广了它但从未标准化。TOML变得越来越受欢迎，并且在各种语言和应用中被支持和使用。你可以在[https://github.com/toml-lang/toml](https://github.com/toml-lang/toml)找到语言规范。
- en: Dependencies on libraries from crates.io
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自crates.io的库的依赖
- en: If a library that our program depends on is published on [https://crates.io/](https://crates.io/),
    all we have to do to link it is add its linking code to the dependencies section.
    Let's say we want to use **serde **(a tool for turning Rust data into formats
    such as JSON and back) in our program. First, we find its linking code with: `cargo
    search serde`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们程序依赖的库在[https://crates.io/](https://crates.io/)上发布，我们只需将其链接代码添加到依赖部分即可。假设我们想在程序中使用**serde**（一个将Rust数据转换为JSON等格式并反向转换的工具）。首先，我们使用以下命令找到它的链接代码：`cargo
    search serde`。
- en: I originally found out about **serde** by browsing through `crates.io`, an exploration
    that I would encourage you to try as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初是通过浏览`crates.io`了解到**serde**的，这是一个我鼓励你也尝试的探索过程。
- en: 'This will print out a list of matches that looks something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出一个类似以下内容的匹配列表：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first one is the core `serde` library, and the linking code is the part
    of the line before the `#` symbol. All we have to do is copy and paste that into
    the dependencies section of `Cargo.toml`, and Rust will know that it should compile
    and link `serde` when it compiles our `foo` program. So, the dependencies section
    of `Cargo.toml` would look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是核心`serde`库，链接代码是`#`符号之前的部分。我们只需将其复制粘贴到`Cargo.toml`文件的依赖部分，Rust就会知道在编译我们的`foo`程序时应该编译和链接`serde`。因此，`Cargo.toml`的依赖部分将看起来像这样：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Dependencies on Git repositories
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自Git仓库的依赖
- en: 'Depending on a library stored in the Git version control system, either locally
    or remotely, is also easy. The linking code is slightly different, but it looks
    like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于存储在Git版本控制系统中的库，无论是本地还是远程，也很容易。链接代码略有不同，但看起来像这样：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We tell Rust where to find the repository, and it knows how to check it out,
    compile it, and link it with our program. The repository location doesn't have
    to be a URL; it can be any repository location that the `git` command recognizes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉Rust如何找到仓库，它知道如何检出、编译并将它链接到我们的程序。仓库位置不一定是URL；它可以是被`git`命令识别的任何仓库位置。
- en: Dependencies on local libraries
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地库的依赖
- en: 'We can also link against other libraries stored on our own systems, of course.
    To do this, we just have to add an entry such as this to our `Cargo.toml` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以链接到存储在我们自己系统上的其他库。为此，我们只需在我们的`Cargo.toml`文件中添加一个类似这样的条目：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The path can be absolute or relative. If it's relative, it's interpreted as
    being relative to the directory containing our `Cargo.toml` file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 路径可以是绝对路径或相对路径。如果是相对路径，它将被解释为相对于包含我们的`Cargo.toml`文件的目录。
- en: Automatically generated source files
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动生成的源文件
- en: When creating an executable program, `cargo` adds a file called `main.rs` to
    our project as it is created. For a newly created library, it instead adds `lib.rs`. In
    either case, that file is the entry point for the whole project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建可执行程序时，`cargo`会在创建时将一个名为`main.rs`的文件添加到我们的项目中。对于一个新创建的库，它则添加`lib.rs`。在两种情况下，该文件都是整个项目的入口点。
- en: 'Let''s take a look at the boilerplate `main.rs` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模板`main.rs`文件：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Simple enough, right? Cargo's default program is a Rust version of the classic
    `hello world` program, which has been re-implemented countless times by new programmers
    in every conceivable programming language.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 简单到令人难以置信，对吧？Cargo的默认程序是经典`hello world`程序的Rust版本，无数新程序员在几乎每一种可想象的编程语言中都已重新实现了它。
- en: 'If we look at a new library''s `lib.rs` file, things are a little more interesting:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看一个新库的`lib.rs`文件，事情会变得更有趣：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Instead of having a main function, which all executable programs need because
    they need a place to start, the library boilerplate includes a framework for automated
    tests and a single test that confirms that `2 + 2 = 4`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有可执行程序都需要一个主函数以有一个启动点不同，库的模板包括一个自动化测试框架以及一个确认`2 + 2 = 4`的单个测试。
- en: Compiling our project
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译我们的项目
- en: 'The basic command to compile a Rust program is simple: `cargo build.`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编译Rust程序的基本命令很简单：`cargo build`。
- en: We need to be in the directory containing `Cargo.toml` (or any subdirectory
    of that directory) in order to be able to do this, since that's how the `cargo`
    program knows which project to compile. However, we don't need to give it any
    other information, since everything it needs to know is in the metadata file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要位于包含`Cargo.toml`的目录中（或该目录的任何子目录），这样才能做到这一点，因为这是`cargo`程序知道要编译哪个项目的方式。然而，我们不需要提供任何其他信息，因为它所需的所有信息都在元数据文件中。
- en: 'Here, we see the result of building the `chapter02` source code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到构建`chapter02`源代码的结果：
- en: '![](img/93e50d15-c345-4d6e-b2b1-319f3a6921f2.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93e50d15-c345-4d6e-b2b1-319f3a6921f2.png)'
- en: The warnings are expected and do not prevent the compile from succeeding. If
    we look at those warnings carefully, we can see that Rust is a lot more helpful
    with its warnings than many programming languages, giving us hints for improving
    efficiency and such, rather than just talking about language syntax.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些警告是可以预见的，并不会阻止编译成功。如果我们仔细查看这些警告，我们可以看到Rust的警告比许多编程语言都要有帮助，它给我们提供了改进效率等提示，而不是仅仅谈论语言语法。
- en: When we build the program, a `Cargo.lock` file and `target` directory are created.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建程序时，会创建一个`Cargo.lock`文件和`target`目录。
- en: '`Cargo.lock` records the exact versions of dependencies that were used to build
    the project, which makes it much easier to produce repeatable results from different
    compilations of the same program. It''s largely safe to ignore this file, as `cargo` will
    usually take care of anything that needs to be done with it.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo.lock`记录了构建项目时使用的依赖项的确切版本，这使得从不同编译的同一程序中产生可重复的结果变得容易得多。在很大程度上，可以忽略这个文件，因为`cargo`通常会处理与之相关的任何需要做的事情。'
- en: The Rust community recommends that the `Cargo.lock` file should be added to
    your version control system (Git, for example) if your project is a program, but
    not if your project is a library. That's because a program's `Cargo.lock` file
    stores all of the versions that resulted in a successful compile of a complete
    program, where a library's only encompasses part of the picture, and so can lead
    to more confusion than help when distributed to others.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Rust社区建议，如果你的项目是一个程序，应该将`Cargo.lock`文件添加到你的版本控制系统（例如Git）中，但如果你的项目是一个库，则不应这样做。这是因为程序`Cargo.lock`文件存储了导致完整程序成功编译的所有版本，而库只包含部分画面，因此当分发给他人时，可能会比有帮助造成更多的困惑。
- en: The `target` directory contains all of the build artifacts and intermediate
    files resulting from the compilation process, as well as the final program file.
    Storing the intermediate files allows future compiles to process only those files
    that need to be processed, and so speeds up the compilation process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`目录包含所有由编译过程产生的构建工件和中间文件，以及最终的程序文件。存储中间文件允许未来的编译只处理需要处理的文件，从而加快编译过程。'
- en: Our program itself is in the `target/debug/foo` file (or `target\debug\foo.exe` on
    Windows) and we can navigate to it and run it manually if we want to. However,
    `cargo` provides a shortcut: `cargo run`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目本身位于`target/debug/foo`文件中（或在Windows上的`target\debug\foo.exe`），如果我们想手动导航到它并运行它，可以这样做。然而，`cargo`提供了一个快捷方式：`cargo
    run`。
- en: We can use that command from any subdirectory of our project, and it will find
    and run our program for us.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从项目的任何子目录中使用该命令，并且它会为我们找到并运行我们的程序。
- en: Additionally, `cargo run` implies `cargo build`, meaning that if we've changed
    the source code since the last time we ran the program, `cargo run` will recompile
    the program before running it. That means we can just alternate between making
    changes to our code and executing it with `cargo run` to see it in action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`cargo run`隐含着`cargo build`，这意味着如果我们自上次运行程序以来更改了源代码，`cargo run`将在运行程序之前重新编译程序。这意味着我们可以在修改代码和用`cargo
    run`执行它以查看其效果之间交替进行。
- en: Debug and release builds
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和发布构建
- en: You may have noticed that the program was in a directory called `target/debug`.
    What's that about? By default, `cargo` builds our program in debug mode, which
    is what a programmer normally wants.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到程序位于一个名为`target/debug`的目录中。这是怎么回事？默认情况下，`cargo`以调试模式构建我们的程序，这是程序员通常想要的。
- en: That means that the resulting program is instrumented to work with the `rust-gdb`
    debugging program so we can examine what is happening in its internals, and to
    provide useful information in crash dumps and such, as well as skipping the compiler's
    optimization phase. The optimizations are skipped because they rearrange things
    in such a way that it makes debugging information almost incomprehensible.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着生成的程序被配置为与`rust-gdb`调试程序一起工作，这样我们就可以检查其内部发生的情况，并在崩溃转储等情况下提供有用的信息，同时跳过编译器的优化阶段。优化被跳过，因为这些优化以某种方式重新排列事物，使得调试信息几乎无法理解。
- en: However, sometimes a program doesn't have any more bugs (that we know about)
    and we're ready to ship it out to others. To construct our final, optimized version
    of the program, we use `cargo build --release`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时一个程序可能没有更多的错误（我们知道的情况）并且我们准备将其分发给其他人。为了构建程序的最终、优化版本，我们使用`cargo build --release`。
- en: This will construct the release version of the program, and leave it in `target/release/foo`.
    We can copy it from there and package it up for distribution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建程序的发布版本，并将其留在`target/release/foo`中。我们可以从那里复制它，并打包它以进行分发。
- en: Dynamic libraries, software distribution, and Rust
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态库、软件分发和Rust
- en: For the most part, Rust avoids using dynamic libraries. Instead, all of the
    dependencies of a Rust program are linked directly into the executable, and only
    select operating system libraries are dynamically linked. This makes Rust programs
    a little larger than you might expect, but a few megabytes are of no concern in
    the era of gigabytes. In exchange, Rust programs are very portable and immune
    to dynamically linked library version issues.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，Rust避免使用动态库。相反，Rust程序的依赖项都直接链接到可执行文件中，并且只有选择性的操作系统库是动态链接的。这使得Rust程序比预期的要大一些，但在千兆字节的时代，几兆字节并不成问题。作为交换，Rust程序非常便携，并且不受动态链接库版本问题的影响。
- en: That means that, if a Rust program works at all, it's going to work on pretty
    much any computer running roughly the same operating system and architecture it
    was compiled for, with no hassles. You can take your release version of a Rust
    program, zip it up, and email it to someone else with confidence that they will
    have no problem running it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果一个Rust程序能正常工作，它几乎可以在编译时使用的任何运行大致相同操作系统和架构的计算机上运行，没有任何麻烦。你可以将Rust程序的发布版本压缩，然后有信心地将其通过电子邮件发送给其他人，他们不会有任何问题运行它。
- en: This doesn't entirely eliminate external dependencies. If your program is a
    client, the server it connects to needs to be available, for example. However,
    it does greatly simplify the whole packaging and distribution process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有完全消除外部依赖。例如，如果你的程序是一个客户端，它连接的服务器需要可用。然而，它确实大大简化了整个打包和分发过程。
- en: Using crates.io
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用crates.io
- en: We saw `cargo search` earlier, which allowed us a quick and easy way to find
    third-party libraries from the command line, so that we could link them with our
    own program. That's very useful, but sometimes we want a little more information
    than what that provides. It's really most useful when we know exactly which library
    we want and just need a quick reference to the linking code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了`cargo search`，它允许我们从命令行快速轻松地找到第三方库，以便我们可以将它们链接到我们的程序中。这非常有用，但有时我们需要的不仅仅是它提供的信息。当我们确切知道我们想要哪个库，并且只需要快速参考链接代码时，它最有用。
- en: When we *don't* know exactly what we want, it's usually better to use a web
    browser to look around [https://crates.io/](https://crates.io/) and find options.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们**不知道**自己确切想要什么时，通常最好使用网页浏览器浏览[https://crates.io/](https://crates.io/)并寻找选项。
- en: 'When we find an interesting or useful library in the web browser, we get the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在网页浏览器中找到一个有趣或有用的库时，我们会得到以下信息：
- en: The linking code
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接代码
- en: Introductory information
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简介信息
- en: Documentation
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: Popularity statistics
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人气统计
- en: Version history
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本历史
- en: License information
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可信息
- en: A link to the library's web site
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库的网站链接
- en: A link to the source code
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码链接
- en: This richer information is useful for figuring out which library or libraries
    are best suited to our projects. Picking the best libraries for the job saves
    a lot of time in the end, so the web interface to `crates.io` is great.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这更丰富的信息有助于确定哪个库或哪些库最适合我们的项目。选择最适合工作的库最终可以节省大量时间，因此`crates.io`的网页界面非常出色。
- en: The front page of `crates.io` shows new and popular libraries, divided up in
    several ways, and these can be interesting and useful to explore. However, the
    main value is the search box. Using the search box, we can usually find several
    candidates for any library needs we may have.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`crates.io`的前页展示了新的和受欢迎的库，以多种方式划分，这些可以是有趣和有用的探索对象。然而，主要价值在于搜索框。使用搜索框，我们通常可以找到任何可能需要的库的几个候选者。'
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, now we know how to install the Rust compiler, set up a Rust project, find
    and link useful third-party libraries, and compile source code into a usable program.
    We've also taken a basic look at the boilerplate code that `cargo` generates when
    we ask it to set up a new program or library project for us. We've learned about
    the difference between a debugging build and a release build and taken a quick
    look at what's involved in distributing a Rust program to users.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道了如何安装Rust编译器，设置Rust项目，查找和链接有用的第三方库，并将源代码编译成可用的程序。我们还简要了解了`cargo`在为我们设置新程序或库项目时生成的样板代码。我们学习了调试构建和发布构建之间的区别，并快速浏览了将Rust程序分发给用户所涉及的内容。
- en: Coming up in [Chapter 2](ee56cb8a-b053-4673-9a4a-e890ce323f2d.xhtml), *Basics
    of the Rust Language*, we're going to begin looking at the Rust programming language
    itself, rather than the support facilities that surround it. We're going to see
    how the language is structured and some of the most important commands.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ee56cb8a-b053-4673-9a4a-e890ce323f2d.xhtml)“Rust语言基础”中，我们将开始研究Rust编程语言本身，而不是围绕它的支持设施。我们将了解语言的结构和一些最重要的命令。
