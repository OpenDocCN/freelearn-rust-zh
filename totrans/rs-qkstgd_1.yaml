- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this guide, we're going to learn the basics of working with Rust, a systems-level
    programming language that has been making a name for itself over the last few
    years. Rust is a strict language, designed to make the most common errors impossible
    and less common errors obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Being a systems-level language means that Rust is guided by the needs of low-level
    programs that don't have a safety net, because they *are *the safety net for higher-level
    programs. Operating system kernels, web browsers, and other critical pieces of
    infrastructure are systems-level applications.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that Rust can only be used for writing critical infrastructure,
    of course. The efficiency and reliability of Rust code can benefit any program.
    It's just that the priorities for higher-level code can be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The `rustup` tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cargo` tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to start a new Rust project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compile a Rust project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to locate third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to keep a Rust installation up-to-date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to switch between stable and beta Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing Rust on any supported platform is simple. All we need to do is navigate
    to [https://rustup.rs/](https://rustup.rs/). That page will give us a single-step
    procedure to install the command-line Rust compiler. The procedure differs slightly
    depending on the platform, but it''s never difficult. Here we see the `rustup.rs`
    page for Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5afd80a-e6dc-4335-ab7b-10aaad3b9236.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The installer doesn''t just install the Rust compiler, it also installs a tool
    called `rustup` that can be used at any time to upgrade our compiler to the latest
    version. To do this, all we have to do is open up a command-line (or Terminal)
    window, and type: `rustup update`.'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the compiler needs to be simple because the Rust project uses a six-week
    rapid release schedule, meaning there's a new version of the compiler every six
    weeks, like clockwork. Each release contains whatever new features have been deemed
    to be stable in the six weeks since the previous release, in addition to the features
    of previous releases.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry, the rapid release of new features doesn't mean that those features
    were slapped together in the six weeks prior to the release. It's common for them
    to have spent years in development and testing prior to that. The release schedule
    just makes sure that, once a feature is deemed to be truly stable, it doesn't
    take long to get into our hands.
  prefs: []
  type: TYPE_NORMAL
- en: If we aren't willing to wait for a feature to be vetted and stabilized, for
    whatever reason, we can also use `rustup` to download, install, and update the
    *beta* or *nightly* releases of the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download and install the beta compiler, we just need to type this: `rustup
    toolchain install beta`.'
  prefs: []
  type: TYPE_NORMAL
- en: From that point on, when we use `rustup` to update our compiler, it will make
    sure that we have the newest versions of both the stable and beta compilers. We
    can then make the beta compiler active with `rustup default beta`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the beta compiler is not the same thing as the next release
    of the stable compiler. The beta version is where features live before they graduate
    to stable, and features can and do remain in beta for years.
  prefs: []
  type: TYPE_NORMAL
- en: The nightly version is at most 24 hours behind the development code repository,
    which means that it might be broken in any number of ways. It's not particularly
    useful unless you're actually participating in the development of Rust itself.
    However, should you want to try it out, `rustup` can install and update it as
    well. You might also find yourself depending on a library that someone else has
    written that depends on features that only exist in the nightly build, in which
    case you'll need to tell `rustup` that you need the nightly build, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things `rustup` will install is a tool called `cargo`, which we''ll
    be seeing a lot of in this chapter, and using behind the scenes for the rest of
    this book. The `cargo` tool is the frontend to the whole Rust compiler system:
    it is used for creating new Rust project directories containing the initial boilerplate
    code for a program or library, for installing and managing dependencies, and for
    compiling Rust programs, among other things.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, so we've installed the compiler. Yay! But how do we use it?
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to open up a command-line window, and navigate to the directory
    where we want to store our new project. Then we can create the skeleton of a new
    program with `cargo new foo`.
  prefs: []
  type: TYPE_NORMAL
- en: When we do this, `cargo` will create a new directory named `foo` and set up
    the skeletal program inside it.
  prefs: []
  type: TYPE_NORMAL
- en: The default is for `cargo` to create the skeleton of an executable program,
    but we can also tell it to set up a new library for us. All that takes is an additional
    command-line argument (`bar` is the name of the new directory that will be created,
    like `foo`): `cargo new --lib bar`.
  prefs: []
  type: TYPE_NORMAL
- en: When we look inside the newly created `foo` directory, we see a file called
    `Cargo.toml` and a sub-directory called `src`. There may also be a Git version
    control repository, which we will ignore for now.
  prefs: []
  type: TYPE_NORMAL
- en: Project metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Cargo.toml` file is where metadata about the program is stored. That includes
    the program's name, version number, and authors, but importantly it also has a
    section for dependencies. Editing the content of the `[dependencies]` section
    is how we tell Rust that our code should be linked to external libraries when
    it is compiled, which libraries and versions to use, and where to find them. External
    libraries are collections of source code that were packaged up in order to make
    them easy to use as components of other programs. By finding and linking good
    libraries, we can save the time and effort of writing our whole program ourselves.
    Instead, we can write only the part that nobody else has already done.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, `.toml` files are written in **Tom's Obvious, Minimal Language**
    (**TOML**), a more well-defined and feature-complete version of the old `.ini` format
    that Microsoft popularized but never standardized. TOML is becoming quite popular,
    and is supported and used in a wide variety of languages and applications. You
    can find the language specification at [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml).
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies on libraries from crates.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a library that our program depends on is published on [https://crates.io/](https://crates.io/),
    all we have to do to link it is add its linking code to the dependencies section.
    Let's say we want to use **serde **(a tool for turning Rust data into formats
    such as JSON and back) in our program. First, we find its linking code with: `cargo
    search serde`.
  prefs: []
  type: TYPE_NORMAL
- en: I originally found out about **serde** by browsing through `crates.io`, an exploration
    that I would encourage you to try as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will print out a list of matches that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one is the core `serde` library, and the linking code is the part
    of the line before the `#` symbol. All we have to do is copy and paste that into
    the dependencies section of `Cargo.toml`, and Rust will know that it should compile
    and link `serde` when it compiles our `foo` program. So, the dependencies section
    of `Cargo.toml` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Dependencies on Git repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on a library stored in the Git version control system, either locally
    or remotely, is also easy. The linking code is slightly different, but it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We tell Rust where to find the repository, and it knows how to check it out,
    compile it, and link it with our program. The repository location doesn't have
    to be a URL; it can be any repository location that the `git` command recognizes.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies on local libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also link against other libraries stored on our own systems, of course.
    To do this, we just have to add an entry such as this to our `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The path can be absolute or relative. If it's relative, it's interpreted as
    being relative to the directory containing our `Cargo.toml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically generated source files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating an executable program, `cargo` adds a file called `main.rs` to
    our project as it is created. For a newly created library, it instead adds `lib.rs`. In
    either case, that file is the entry point for the whole project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the boilerplate `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Simple enough, right? Cargo's default program is a Rust version of the classic
    `hello world` program, which has been re-implemented countless times by new programmers
    in every conceivable programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at a new library''s `lib.rs` file, things are a little more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Instead of having a main function, which all executable programs need because
    they need a place to start, the library boilerplate includes a framework for automated
    tests and a single test that confirms that `2 + 2 = 4`.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic command to compile a Rust program is simple: `cargo build.`'
  prefs: []
  type: TYPE_NORMAL
- en: We need to be in the directory containing `Cargo.toml` (or any subdirectory
    of that directory) in order to be able to do this, since that's how the `cargo`
    program knows which project to compile. However, we don't need to give it any
    other information, since everything it needs to know is in the metadata file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see the result of building the `chapter02` source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93e50d15-c345-4d6e-b2b1-319f3a6921f2.png)'
  prefs: []
  type: TYPE_IMG
- en: The warnings are expected and do not prevent the compile from succeeding. If
    we look at those warnings carefully, we can see that Rust is a lot more helpful
    with its warnings than many programming languages, giving us hints for improving
    efficiency and such, rather than just talking about language syntax.
  prefs: []
  type: TYPE_NORMAL
- en: When we build the program, a `Cargo.lock` file and `target` directory are created.
  prefs: []
  type: TYPE_NORMAL
- en: '`Cargo.lock` records the exact versions of dependencies that were used to build
    the project, which makes it much easier to produce repeatable results from different
    compilations of the same program. It''s largely safe to ignore this file, as `cargo` will
    usually take care of anything that needs to be done with it.'
  prefs: []
  type: TYPE_NORMAL
- en: The Rust community recommends that the `Cargo.lock` file should be added to
    your version control system (Git, for example) if your project is a program, but
    not if your project is a library. That's because a program's `Cargo.lock` file
    stores all of the versions that resulted in a successful compile of a complete
    program, where a library's only encompasses part of the picture, and so can lead
    to more confusion than help when distributed to others.
  prefs: []
  type: TYPE_NORMAL
- en: The `target` directory contains all of the build artifacts and intermediate
    files resulting from the compilation process, as well as the final program file.
    Storing the intermediate files allows future compiles to process only those files
    that need to be processed, and so speeds up the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: Our program itself is in the `target/debug/foo` file (or `target\debug\foo.exe` on
    Windows) and we can navigate to it and run it manually if we want to. However,
    `cargo` provides a shortcut: `cargo run`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use that command from any subdirectory of our project, and it will find
    and run our program for us.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `cargo run` implies `cargo build`, meaning that if we've changed
    the source code since the last time we ran the program, `cargo run` will recompile
    the program before running it. That means we can just alternate between making
    changes to our code and executing it with `cargo run` to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Debug and release builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that the program was in a directory called `target/debug`.
    What's that about? By default, `cargo` builds our program in debug mode, which
    is what a programmer normally wants.
  prefs: []
  type: TYPE_NORMAL
- en: That means that the resulting program is instrumented to work with the `rust-gdb`
    debugging program so we can examine what is happening in its internals, and to
    provide useful information in crash dumps and such, as well as skipping the compiler's
    optimization phase. The optimizations are skipped because they rearrange things
    in such a way that it makes debugging information almost incomprehensible.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes a program doesn't have any more bugs (that we know about)
    and we're ready to ship it out to others. To construct our final, optimized version
    of the program, we use `cargo build --release`.
  prefs: []
  type: TYPE_NORMAL
- en: This will construct the release version of the program, and leave it in `target/release/foo`.
    We can copy it from there and package it up for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic libraries, software distribution, and Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the most part, Rust avoids using dynamic libraries. Instead, all of the
    dependencies of a Rust program are linked directly into the executable, and only
    select operating system libraries are dynamically linked. This makes Rust programs
    a little larger than you might expect, but a few megabytes are of no concern in
    the era of gigabytes. In exchange, Rust programs are very portable and immune
    to dynamically linked library version issues.
  prefs: []
  type: TYPE_NORMAL
- en: That means that, if a Rust program works at all, it's going to work on pretty
    much any computer running roughly the same operating system and architecture it
    was compiled for, with no hassles. You can take your release version of a Rust
    program, zip it up, and email it to someone else with confidence that they will
    have no problem running it.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't entirely eliminate external dependencies. If your program is a
    client, the server it connects to needs to be available, for example. However,
    it does greatly simplify the whole packaging and distribution process.
  prefs: []
  type: TYPE_NORMAL
- en: Using crates.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw `cargo search` earlier, which allowed us a quick and easy way to find
    third-party libraries from the command line, so that we could link them with our
    own program. That's very useful, but sometimes we want a little more information
    than what that provides. It's really most useful when we know exactly which library
    we want and just need a quick reference to the linking code.
  prefs: []
  type: TYPE_NORMAL
- en: When we *don't* know exactly what we want, it's usually better to use a web
    browser to look around [https://crates.io/](https://crates.io/) and find options.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we find an interesting or useful library in the web browser, we get the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The linking code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introductory information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popularity statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: License information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A link to the library's web site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A link to the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This richer information is useful for figuring out which library or libraries
    are best suited to our projects. Picking the best libraries for the job saves
    a lot of time in the end, so the web interface to `crates.io` is great.
  prefs: []
  type: TYPE_NORMAL
- en: The front page of `crates.io` shows new and popular libraries, divided up in
    several ways, and these can be interesting and useful to explore. However, the
    main value is the search box. Using the search box, we can usually find several
    candidates for any library needs we may have.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now we know how to install the Rust compiler, set up a Rust project, find
    and link useful third-party libraries, and compile source code into a usable program.
    We've also taken a basic look at the boilerplate code that `cargo` generates when
    we ask it to set up a new program or library project for us. We've learned about
    the difference between a debugging build and a release build and taken a quick
    look at what's involved in distributing a Rust program to users.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up in [Chapter 2](ee56cb8a-b053-4673-9a4a-e890ce323f2d.xhtml), *Basics
    of the Rust Language*, we're going to begin looking at the Rust programming language
    itself, rather than the support facilities that surround it. We're going to see
    how the language is structured and some of the most important commands.
  prefs: []
  type: TYPE_NORMAL
