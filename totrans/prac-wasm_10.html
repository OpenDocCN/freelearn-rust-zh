<html><head></head><body>
		<div><h1 id="_idParaDest-81"><em class="italic"><a id="_idTextAnchor090"/>Chapter 7</em>: Integrating Rust with WebAssembly</h1>
			<p>Rust is a system-level programming language. Being a system-level programming language, Rust provides low-level memory management and the ability to represent data efficiently. Thus, it provides complete control to programmers and better performance. </p>
			<p>In addition to this, Rust also provides the following:</p>
			<ul>
				<li><strong class="bold">A friendly compiler</strong> – The Rust compiler is your companion when writing Rust. The compiler corrects you, guides you, and ensures that you write memory-safe code almost always.</li>
				<li><strong class="bold">The ownership model</strong> – The ownership model ensures that we do not need garbage collection. This guarantees thread and memory safety in Rust.</li>
				<li><strong class="bold">Safety, speed, and concurrency</strong> – Rust ensures safety and concurrency and makes you stay away from risks, crashes, and vulnerabilities.</li>
				<li><strong class="bold">A modern language</strong> – Rust provides modern language syntax and the language is built to provide a better developer experience.</li>
			</ul>
			<p>These features (along with thousands of others) ensure Rust is a general-purpose programming language. The highlight of the Rust language is that its compiler and community are always helpful.</p>
			<p>Rust provides first-class support for WebAssembly. Rust's rich toolchain makes it easier to get started with WebAssembly. Rust does not need a runtime, which makes it a perfect candidate for WebAssembly. In this chapter, we will see how to install Rust and explore various ways to convert Rust into a WebAssembly module. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Installing Rust</li>
				<li>Converting Rust into WebAssembly via <code>rustc</code></li>
				<li>Converting Rust into WebAssembly via Cargo</li>
				<li>Installing wasm-bindgen</li>
				<li>Converting Rust into WebAssembly via <a id="_idTextAnchor091"/><code>wasm-bindgen</code></li>
			</ul>
			<p>Now let's hack into the Rust and WebAssembly world.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor092"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor093"/>Installing Rust </h1>
			<p>Rust is a compiled language and its compiler is called the <strong class="bold">Rust compiler</strong> (<strong class="bold">rustc</strong>). Rust also has its own <a id="_idIndexMarker283"/>package manager, called <strong class="bold">Cargo</strong>. Cargo is similar to npm for <a id="_idIndexMarker284"/>Node.js. Cargo downloads package dependencies and builds, compiles, packs, and <a id="_idIndexMarker285"/>uploads the artifacts into crates (Rust's version of packages). </p>
			<p>The Rust language provides an easy way to install and manage Rust via <code>rustu<a id="_idTextAnchor094"/>p</code>. <code>rustup</code> helps to install, update, and remove <code>rustc</code>, Cargo, and <code>rustup</code> itself. It makes it easy to install and manage various versions of Rust. </p>
			<p>Let's install Rust using the <code>rustup</code> tool and see how we can manage Rust versions using <code>rustup</code>.</p>
			<p>In Linux or macOS, use the following command:</p>
			<pre>$ curl https://sh.rustup.rs --sSf | sh</pre>
			<p>The script will download and install the Rust language. Both <code>rustc</code> and Cargo are installed in <code>~/.cargo/bin</code> and delegate any access to the underlying toolchain.</p>
			<p>For Windows, download and install the binaries from here: <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">https://forge.rust-lang.org/infra/other-installation-methods.html</a>. Both <code>rustc</code> and Cargo are installed in the <code>users</code> folder.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">You will require C++ build tools for Visual Studio 2013 or later. You can install them from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>.</p>
			<p>Once the installation is completed successfully, you can check it by running the following command:</p>
			<pre>$ rustc –version
rustc 1.58.1 (db9d1b20b 2022-01-2<a id="_idTextAnchor095"/>0)</pre>
			<p><code>rustup</code> is a toolchain multiplexer. It installs and manages many Rust toolchains and proxies them <a id="_idIndexMarker286"/>through the single set of tools installed at <code>.cargo/bin</code> in the home directory. Once <code>rustup</code> is installed, we can easily manage the <code>rustc</code> and <code>cargo</code> compilers. <code>rustup</code> also makes it easy to switch between nightly, stable, and beta versions of Rust.</p>
			<p>Rust provides WebAssembly compilation support in its stable version. We will also switch to the nightly build to make sure we get all the latest benefits.</p>
			<p>To switch to the nightly version, we have to run the following command:</p>
			<pre>$ rustup default nightly</pre>
			<p>This command will switch the default <code>rustc</code> to the nightly version. The <code>rustc</code> proxy in <code>~/.cargo/bin</code> will run the nightly compiler instead of the stable compiler.</p>
			<p>To update to the latest version of nightly, we can run the following:</p>
			<pre>$ rustup update</pre>
			<p>Once successfully updated, we can check the current version installed by running the following:</p>
			<pre>$ rustc --version
rustc 1.55.0 (c8dfcfe04 2021-09-06)</pre>
			<p>Rust supports WebAssembly as a first-class citizen. Thus, <code>rustc</code> is capable of compiling Rust code into <a id="_idIndexMarker287"/>WebAssembly modules. Let's see how to convert Rust into WebAssembly via <code>rustc</code>.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor096"/>Converting Rust into WebAssembly via rustc</h1>
			<p>Rust uses the LLVM compiler we'll create now to generate machine-native code. <code>rustc</code> uses LLVM's capability <a id="_idIndexMarker288"/>to convert the native <a id="_idIndexMarker289"/>code into a WebAssembly module. We installed Rust in the previous section; let's start converting Rust into a WebAssembly module using <code>rustc</code>.</p>
			<p>We will start with Hello World: </p>
			<ol>
				<li>Let's create a file called <code>hello_world.rs</code>:<pre><strong class="bold">$ touch hello_world.rs</strong></pre></li>
				<li>Spin up your favorite editor and start writing the Rust code:<pre>fn main() {    
println!("Hello World!");
}</pre></li>
			</ol>
			<p>We have defined a <code>main</code> function. Similar to C, <code>main</code> is a special function that marks the entry point to a program after it has been compiled as an executable.</p>
			<p><code>fn</code> is the function keyword in Rust. <code>main()</code> is the function name.</p>
			<p><code>println!</code> is the macro. Macros in Rust allow us to abstract code at a syntactic level. A macro invocation is shorthand for an "expanded" syntactic form. This expansion happens early on in compilation, before any static checking. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Macros are an interesting feature but explaining them is beyond the scope of this book. You can find more <a id="_idIndexMarker290"/>information here: <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">https://doc.rust-lang.org/book/ch19-06-macros.html</a>.</p>
			<ol>
				<li value="3">We pass in the <code>Hello World!</code> string to the <code>println!</code> macro function. We can compile and generate the binary by running the following:<pre><strong class="bold">$ rustc hello.rs</strong></pre></li>
				<li>This will generate a <code>hello</code> binary. We can execute the binary and that will print <code>Hello World!</code>:<pre><strong class="bold">$ ./hello</strong>
<strong class="bold">Hello World!</strong></pre></li>
				<li>Now, compile <a id="_idIndexMarker291"/>Rust into a WebAssembly <a id="_idIndexMarker292"/>module with <code>rustc</code>:<pre><strong class="bold">$ rustc --target wasm32-unknown-emscripten</strong>
<strong class="bold">  hello_world.rs -o hello_world.html</strong></pre></li>
			</ol>
			<p>This will generate the WebAssembly module. </p>
			<ol>
				<li value="6">Let's run the generated code in the browser using the following command:<pre><strong class="bold">$ python -m http.server</strong></pre></li>
			</ol>
			<p>Open your browser and head over to <code>http://localhost:8000</code>. Open the developer console to see <code>Hello World!</code> printed in it.</p>
			<p>To convert Rust into a WebAssembly module, we have used the <code>--target</code> flag. This flag instructs the compiler to compile and build the binary such that it runs on the provided runtime.</p>
			<p>We passed in <code>wasm32-unknown-emscripten</code> as a value to the <code>--target</code> flag.</p>
			<p><code>wasm32</code> indicates that the address space is 32 bits large. <code>unknown</code> tells the compiler that you don't know the system that you are compiling to. <code>emscripten</code> at the end notifies the compiler that you are targeting.</p>
			<p>So, with the <code>wasm32-unknown-emscripten</code> value, the compiler will compile on almost any machine but run only on the Emscripten runtime. Then, we specify the input file that needs to be compiled into the WebAssembly module. Finally, we specify the output with a <code>-o</code> flag.</p>
			<p>It is important to understand what <code>rustc</code> does.</p>
			<div><div><img src="img/Figure_7.1_B14844.jpg" alt="Figure 7.1 – Rust compilation steps&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Rust compilation steps</p>
			<p><code>rustc</code> first parses the input and produces the <strong class="bold">Abstract Syntax Tree</strong> (<strong class="bold">AST</strong>). Once the AST is generated, the <a id="_idIndexMarker293"/>compiler then recursively resolves <a id="_idIndexMarker294"/>the paths, expanding <a id="_idIndexMarker295"/>macros and other references. Once the AST is completely <a id="_idIndexMarker296"/>resolved, it will be converted into the <strong class="bold">High-level Intermediate Representation</strong> (<strong class="bold">HIR</strong>). This intermediate representation is like a desugared variant of AST.</p>
			<p>The HIR is then <a id="_idIndexMarker297"/>analyzed for type checking. After <a id="_idIndexMarker298"/>type checking, the HIR is postprocessed and converted into the <strong class="bold">Middle Intermediate Representation</strong> (<strong class="bold">MIR</strong>). From MIR, the compiler<a id="_idTextAnchor097"/> generates the <strong class="bold">LLVM Intermediate Representation</strong> (<strong class="bold">LLVM IR</strong>). After that, LLVM does the required optimizations on them.</p>
			<p>Now, with LLVM IR, it is easier to convert LLVM IR into WebAssembly modules. This is similar to how Emscripten converts C or C++ code into WebAssembly modules.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Since we are using the <code>wasm32-unknown-emscripten</code> flag here, we need <code>emcc</code> to be available for converting the LLVM IR generated from Rust code into a WebAssembly module.</p>
			<p>We have seen how to use <code>rustc</code> to generate WebAssembly modules. It uses Emscripten behind the scenes to create them. But Rust provides another <a id="_idIndexMarker299"/>abstraction to generate WebAssembly modules, via <a id="_idIndexMarker300"/>Cargo. </p>
			<p>In the next section, we will see how to convert Rust into WebAssembly using Cargo.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor098"/>Converting Rust into WebAssembly via Cargo </h1>
			<p>Cargo makes it easier to create, run, download, compile, test, and run your project. The <code>cargo</code> command <a id="_idIndexMarker301"/>provides a wrapper that <a id="_idIndexMarker302"/>calls the <code>rustc</code> compiler to start the <a id="_idIndexMarker303"/>compilation. In order to create WebAssembly modules using Rust's toolchain, we will be using a different target, <code>wasm32-unknown-unknown</code>.</p>
			<p>The <code>wasm32-unknown-unknown</code> target adds zero runtime and toolchain footprint. <code>wasm32</code> makes the compiler assume that only the <code>wasm32</code> instruction set is present. The first <code>unknown</code> in <code>unknown-unknown</code> indicates the code can compile on any machine and the second indicates the code can run on any machine. </p>
			<p>To see it in action, let's create a new project with Cargo:</p>
			<pre>$ cargo new --lib fib_wasm
Created library `fib_wasm` package</pre>
			<p>A new project called <code>fib_wasm</code> is created. The new option creates a Rust project. The <code>--lib</code> flag informs Cargo to create a new library project rather than the default binary project.</p>
			<p>The binary project will produce the executable binary. The library project will create the library module.</p>
			<p>Spin up your favorite text editor and replace the contents of <code>src/lib.rs</code> with the following:</p>
			<pre>#[no_mangle]
fn add(x: i32, y:i32) -&gt; i32 {    x + y}</pre>
			<p><code>#[no_mangle]</code> is a kind of annotation. This annotation informs the compiler not to mangle the names when generating the library.</p>
			<p>Then, we <a id="_idIndexMarker304"/>define the <code>add</code> function. The <code>add</code> function <a id="_idIndexMarker305"/>takes in two parameters, <code>x</code> and <code>y</code>. We <a id="_idIndexMarker306"/>define their types with <code>i32</code> following the variable and a colon (<code>:</code>). Finally, we define their return type using <code>-&gt; i32</code>.</p>
			<p>The function body has just <code>x + y</code>. Note, in Rust we do not need <code>return</code> keyword and <code>;</code> at the end of the last statement, this shorts to return.</p>
			<p>Cargo also generates <code>Cargo.toml</code>. This file holds all the meta-information about the project, how to compile the Rust code, and their dependencies.</p>
			<p>The <code>Cargo.toml</code> file looks like this:</p>
			<pre>[package]
name = "fib_wasm"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"</pre>
			<p>It defines the package name, version, authors, and edition of Rust we are using.</p>
			<p>Here, we have to instruct the compiler what type of crate we are compiling. We can specify it under the <code>[lib]</code> segment and with the <code>crate-type</code> property.</p>
			<p>Open <code>Cargo.toml</code> and append the <code>crate-type</code> information inside:</p>
			<pre>[package]
name = "fib_wasm"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
[lib]
crate-type = ["cdylib"]</pre>
			<p><code>cdylib</code> here specifies a dynamic system library will be produced. This dynamic system library is used when the library has to be loaded from another language.</p>
			<p>Let's compile Rust into WebAssembly modules:</p>
			<pre>$ cargo build --target wasm32-unknown-unknown</pre>
			<p>This will <a id="_idIndexMarker307"/>invoke <code>rustc</code> with the specified <a id="_idIndexMarker308"/>target. That will generate the WebAssembly <a id="_idIndexMarker309"/>module inside <code>/target/wasm32-unknown-unknown/</code>. Now, in order to run the WebAssembly module on the browser, let's manually create the HTML file and load it using JavaScript.</p>
			<p>Let's create an HTML file:</p>
			<pre>$ touch index.html</pre>
			<p>Add the following content to the file:</p>
			<pre>&lt;script&gt; 
(async () =&gt; {     
const bytes = await fetch("target/wasm32-unknown-
  unknown/debug/fib_wasm.wasm");     
const response = await bytes.arrayBuffer();     
const result = await WebAssembly.instantiate(response, {});
  console.log(result.instance.exports.add(10,3)); 
})();
&lt;/script&gt;</pre>
			<p>We defined the script inside the <code>&lt;script&gt;</code> tag. In HTML, we define JavaScript inside the <code>&lt;script&gt;</code> tag. We have added the <code>async</code> keyword. The <code>async</code> keyword specifies the function is asynchronous.</p>
			<p>First, we fetch the WebAssembly module. The WebAssembly module is generated in the <code>target/wasm32-unknown-unknown/debug/</code> folder with the same name as the package name defined in <code>Cargo.toml</code>.</p>
			<p>The <code>await</code> keyword ensures the execution is awaited until we fetch the entire WebAssembly module.</p>
			<p>We then convert the collected bytes (from the fetch call) using <code>bytes.arrayBuffer()</code>. The <code>response</code> object will now have the WebAssembly module inside <code>ArrayBuffer</code>.</p>
			<p>We then <a id="_idIndexMarker311"/>instantiate the bytes array using <a id="_idIndexMarker312"/>the <code>WebAssembly.instantiate</code> function. The <code>result</code> object contains the entire WebAssembly <a id="_idIndexMarker313"/>module.</p>
			<p>The WebAssembly module <code>result</code> contains the <code>instance</code> property. The instance has the <code>exports</code> property. The <code>exports</code> property holds all the functions exported by the WebAssembly module.</p>
			<p>Since we added <code>#[no_mangle]</code>, the exported function name is not changed. Hence, the <code>exports</code> property has the <code>add</code> function defined in it.</p>
			<p>We have used async-await here to make the syntax more elegant and contextually easier to understand.</p>
			<p>As expected, the preceding code will give an output of <code>13</code>. You can check the output in the browser console.</p>
			<p>Here, the <code>cargo build</code> command invokes <code>rustc</code> and compiles the Rust code into MIR and then into LLVM IR. The generated LLVM IR is then converted into a WebAssembly module. Let's make this function a bit more complicated. We can create a Fibonacci number generator with Rust and run the WebAssembly Module on the browser:</p>
			<ol>
				<li value="1">Open <code>src/lib.rs</code> and replace everything with the following content:<pre>#[no_mangle]
fn fibonacci(num: i32) -&gt; i32 {    
match num {        
0 =&gt; 0,        
1 =&gt; 1,        
_ =&gt; fibonacci(num-1) + fibonacci(num-2),    
}
}</pre></li>
			</ol>
			<p>Build <a id="_idIndexMarker314"/>it using <code>cargo build --target wasm32-unknown-unknown</code>.</p>
			<ol>
				<li value="2">Then, <a id="_idIndexMarker315"/>replace <code>index.html</code> such that <a id="_idIndexMarker316"/>we call the Fibonacci instead of the <code>add</code>:<pre>&lt;script&gt;
 (async () =&gt; {     
const bytes = await fetch("target/wasm32-unknown-
  unknown/debug/fib_wasm.wasm");     
const response = await bytes.arrayBuffer();     
const result = await WebAssembly.instantiate(response,
  {});  
     result.instance.exports.fibonacci(20); 
})();
&lt;/script&gt;</pre></li>
				<li>Now, spin up the HTML server and check the browser's console for the Fibonacci value.</li>
			</ol>
			<p>So far, we have seen simple examples. But how can we pass functions and classes from JavaScript into WebAssembly and the other way around? In order to do more advanced bindings, Rust provides us with <code>wasm-bindgen</code>.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor099"/>Installing wasm-bindgen </h1>
			<p><code>wasm-bindgen</code> is used to <a id="_idIndexMarker317"/>bind entities from Rust into JavaScript and vice versa.</p>
			<p><code>wasm-bindgen</code> makes it more natural to import exported entities from Rust into JavaScript. JavaScript developers will find that <code>wasm-bindgen</code>'s use of WebAssembly is similar to JavaScript.</p>
			<p>This enables the use of richer and easier APIs while converting Rust into a WebAssembly module. <code>wasm-bindgen</code> uses these features and provides a simple API to use. It ensures that there is high-level interaction happening between wasm modules and JavaScript.</p>
			<p><code>wasm-bindgen</code> provides a channel between JavaScript and WebAssembly to communicate something other than numbers, such as objects, strings, and arrays.</p>
			<p>To install <code>wasm-bindgen-cli</code>, use the following <code>cargo</code> command:</p>
			<pre>$ cargo install wasm-bindgen-cli</pre>
			<p>Once successfully installed, let's run the <code>wasm-bindgen</code> CLI:</p>
			<pre>$ wasm-bindgen  --help
Generating JS bindings for a wasm file
Usage:
    wasm-bindgen [options] &lt;input&gt;
    wasm-bindgen -h | --help
    wasm-bindgen -V | --version
Options:
    -h --help                 Show this screen.
    --out-dir DIR             Output directory
    --out-name VAR            Set a custom output filename 
      (Without extension. Defaults to crate name)
    --target TARGET           What type of output to generate, 
      valid
      values are [web, bundler, nodejs, no-modules],
        and the default is [bundler]
    --no-modules-global VAR   Name of the global variable to 
      initialize
    --browser                 Hint that JS should only be 
      compatible with a browser
    --typescript              Output a TypeScript definition 
      file (on by default)
    --no-typescript           Don't emit a *.d.ts file
    --debug                   Include otherwise-extraneous 
      debug checks in output
    --no-demangle             Don't demangle Rust symbol names
    --keep-debug              Keep debug sections in wasm files
    --remove-name-section     Remove the debugging `name` 
      section of the file
    --remove-producers-section   Remove the telemetry 
      `producers` section
    --encode-into MODE        Whether or not to use 
      TextEncoder#encodeInto,
      valid values are [test,z always, never]
    --nodejs                  Deprecated, use `--target nodejs`
    --web                     Deprecated, use `--target web`
    --no-modules              Deprecated, use `--target 
      no-modules`
    -V --version              Print the version number of 
     wasm-bindgen</pre>
			<p>Let's take a look at the various options <code>wasm-bindgen</code> supports.</p>
			<p>To generate the file in a particular directory and with a particular name, the tool has <code>--out-dir</code> and <code>--out-name</code>, respectively. To reduce or optimize the generated WebAssembly module size, <code>wasm-bindgen</code> has the following flags:</p>
			<ul>
				<li><code>--debug</code>: The <code>--debug</code> option includes extra debugging information in the generated WebAssembly module. This will increase the size of the WebAssembly module but it is useful in development.</li>
				<li><code>--keep-debug</code>: This WebAssembly module may or may not have custom sections. These custom sections can be used to hold the debugging information. These <a id="_idIndexMarker318"/>custom sections will be helpful while debugging the application (such as in browser developer tools). This will increase the size of the WebAssembly module. This is useful in development.</li>
				<li><code>--no-demangle</code>: This flag tells <code>wasm-bindgen</code> not to demangle the Rust symbol names. Demangling allows the end user to use the same name that they have defined in the Rust file.</li>
				<li><code>--remove-name-section</code>: This will remove the debugging name section of the file. We will see more about the various sections in a WebAssembly module later. This will decrease the size of the WebAssembly module.</li>
				<li><code>--remove-producers-section</code>: WebAssembly modules can have a producer section. This section will hold information about how the file was produced or who produced the file. By default, producer sections are added to a generated WebAssembly module. With this flag, we can remove it. It saves a few more bytes.</li>
			</ul>
			<p><code>wasm-bindgen</code> provides options to generate the binding file for both Node.js and the browser environment. Let's see those flags:</p>
			<ul>
				<li><code>--nodejs</code>: This generates output that only works for Node.js. No ESModules. </li>
				<li><code>--browser</code>: This generates output that only works for the browser. With ESModules. </li>
				<li><code>--no-modules</code>: This generates output that only works for the browser. No ESModules. Suitable for browsers that don't support ESModules yet.</li>
			</ul>
			<p>The type <a id="_idIndexMarker319"/>definition files (<code>*.d.ts</code>) can be switched off by using the <code>--no-typescript</code> flag.</p>
			<p>Now we have installed <code>wasm-bindgen</code>, let's take it for a spin. </p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor100"/>Converting Rust into WebAssembly via wasm-bindgen</h1>
			<p>Let's start <a id="_idIndexMarker320"/>with a Hello World <a id="_idIndexMarker321"/>example with <code>wasm-bindgen</code>:</p>
			<ol>
				<li value="1">Create a new project with Cargo:<pre><strong class="bold"> $ cargo new --lib hello_world</strong>
<strong class="bold">Created library `hello_world` package</strong></pre></li>
			</ol>
			<p>This will create a new Rust project with all the necessary files. </p>
			<ol>
				<li value="2">Open the project in your favorite editor. Open the <code>Cargo.toml</code> file to add <code>crate-type</code> and add the <code>wasm-bindgen</code> dependency:<pre>[package]
name = "hello_world"
version = "0.1.0"
authors = ["Sendil Kumar"]
edition = "2018"
[lib]
crate-type = ["cdylib"]
[dependencies]
wasm-bindgen = "0.2.38"</pre></li>
				<li>We define the dependency under the <code>[dependencies]</code> table in the <code>toml</code> file. Open the <code>src/lib.rs</code> file and replace the contents with the following:<pre>use wasm_bindgen::prelude::*;
#[wasm_bindgen]
pub fn hello() -&gt; String {
"Hello World".to_string()
}</pre></li>
			</ol>
			<p>We import the <code>wasm_bindgen</code> library using <code>use wasm_bingen::prelude::*</code> and then annotate the function with <code># [wasm_bindgen]</code>. The <code>hello</code> function returns <code>String</code>.</p>
			<p> To generate the WebAssembly module, we will first run the following command:</p>
			<pre>$ cargo build --target=wasm32-unknown-unknown</pre>
			<p>This will <a id="_idIndexMarker322"/>generate the WebAssembly <a id="_idIndexMarker323"/>module. But this module cannot run by itself. WebAssembly only supports passing numbers between the native code and JavaScript. But we are returning a <code>String</code> here.</p>
			<p>In order to pass any value (other than numbers), we need to create a binding JavaScript file. This binding file is nothing more than a translator that translates the <code>String</code> (and other types) into <code>start</code>, <code>length</code>, <code>arrayBuffer</code>.</p>
			<p>In order to generate the binding files, we need to run the <code>wasm-bindgen</code> CLI tool on the generated WebAssembly module:</p>
			<pre>$ wasm-bindgen target/wasm32-unknown-
  unknown/debug/hello_world.wasm --out-dir .</pre>
			<p>We run <code>wasm-bindgen</code> and pass it to the generated <code>target/wasm32-unknown-unknown/debug/hello_world.wasm</code> WebAssembly module. The <code>--out-dir</code> flag tells the <code>wasm-bindgen</code> CLI tool where to save the generated files. Here, we are asking for the files to be generated in the current folder.</p>
			<p>We can see the files that are generated inside the folder:</p>
			<pre>$ ls -lrta
-rw-r--r-- 1 sendilkumar staff 1769 hello_world.js
-rw-r--r-- 1 sendilkumar staff 88 hello_world.d.ts
-rw-r--r-- 1 sendilkumar staff 227 hello_world_bg.d.ts
-rw-r--r-- 1 sendilkumar staff 67132 hello_world_bg.wasm </pre>
			<p>The <code>cargo build</code> command generates the WebAssembly module. The <code>wasm-bindgen</code> CLI <a id="_idIndexMarker324"/>takes this WebAssembly <a id="_idIndexMarker325"/>module as input and generates the necessary bindings. The size of the binding JavaScript file is around 1.8 KB.</p>
			<p>The generated files are as follows:</p>
			<ul>
				<li>The WebAssembly module (<code>hello_world_bg.wasm</code>)</li>
				<li>The JavaScript binding file (<code>hello_world.js</code>)</li>
				<li>The type definition file for the <code>WASM</code> (<code>hello_world.d.ts</code>)</li>
				<li>The type definition file for the JavaScript (<code>hello_world_bg.d.ts</code>)</li>
			</ul>
			<p>The JavaScript binding file is enough for us to load and run the WebAssembly module.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is also a TypeScript file generated.</p>
			<p>Let's now check what the binding file contains:</p>
			<pre>import * as wasm from './hello_world_bg.wasm';</pre>
			<p>The binding file imports the WebAssembly module:</p>
			<pre>const lTextDecoder = typeof TextDecoder === 'undefined' ?
  require('util').TextDecoder : TextDecoder;
let cachedTextDecoder = new lTextDecoder('utf-8');</pre>
			<p>It then defines <code>TextDecoder</code>, to decode the string from the shared <code>ArrayBuffer</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since there are no input arguments available, there is no need for <code>TextEncoder</code> (that is, to encode the string from JavaScript into shared memory). <code>wasm-bindgen</code> will generate only the necessary things inside the binding file.</p>
			<p>Modern browsers have built-in <code>TextDecoder</code> and <code>TextEncoder</code> support. <code>wasm-bindgen</code> checks and uses the decoder if present; otherwise, it loads it using polyfill.</p>
			<p>The shared <a id="_idIndexMarker326"/>memory between <a id="_idIndexMarker327"/>JavaScript and the WebAssembly module need not be initialized every time. We can initialize it once and use it throughout the lifetime of the execution. We have the following two methods to load the memory once and use it throughout the lifetime of the execution:</p>
			<pre>function getUint8Memory() { ... }
function getUint32Memory() { ... }</pre>
			<p>Then, we get a <code>String</code> from Rust to JavaScript. This <code>String</code> is passed via the shared memory. So, we can use the pointer to the offset and the length of the <code>String</code> to retrieve it. The following function is used for retrieving the <code>String</code> from the WebAssembly module:</p>
			<pre>function getStringFromWasm(ptr, len) { ....  }</pre>
			<p>We define the heap at the very end. This is where we will store all the JavaScript variables referenceable from the WebAssembly module. The <code>__wbindgen_object_drop_ref</code> function is used to free up the slot occupied by the JavaScript reference count.</p>
			<p>Finally, we have the <code>hello</code> function:</p>
			<pre>export function hello() {
    const retptr = globalArgumentPtr();
    wasm.hello_world(retptr);
    const mem = getUint32Memory();
    const rustptr = mem[retptr / 4];
    const rustlen = mem[retptr / 4 + 1];
    const realRet = getStringFromWasm(rustptr,
      rustlen).slice();
    wasm.__wbindgen_free(rustptr, rustlen * 1);
    return realRet;
}</pre>
			<p>The <code>hello</code> function is exported. We first get the pointer for the argument. This pointer refers to a location in the shared array buffer. Then, we call the <code>hello</code> function in the WebAssembly module. </p>
			<p>Note that <a id="_idIndexMarker328"/>we are passing in a (pointer to the) argument here. But we have defined the function without any arguments <a id="_idIndexMarker329"/>on the Rust side. We will briefly see how <code>rustc</code> has rewritten the code.</p>
			<p>Then, we get the shared memory. Note that this is a 32-bit array. We get the pointer in which the result is stored and the length of the output string. Note that these are stored successively.</p>
			<p>Finally, we will get the string from <code>rustptr</code> and <code>rustlen</code>. Once we have received the output, we will clear the allocated memory using <code>wasm.__wbindgen_free</code>.</p>
			<p>To understand what happens on the Rust side, let's use the <code>cargo-expand</code> command to expand the macro and see how the code is generated.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Check <a href="https://github.com/dtolnay/cargo-expand">https://github.com/dtolnay/cargo-expand</a> for how to install <code>cargo-expand</code>. It is not mandatory for the course of this book. But cargo-expand will help you understand what <code>wasm-bindgen</code> actually generates.</p>
			<p>Open your terminal, go to the project's base directory, and run the following command:</p>
			<pre>cargo expand --target=wasm32-unknown-unknown &gt; expanded.rs</pre>
			<p>The preceding command will create a file called <code>expanded.rs</code>. If you take a look in the file <a id="_idIndexMarker330"/>generated, you will see <a id="_idIndexMarker331"/>how the simple <code>#[wasm_bindgen]</code> annotation changes the verbose part of exposing the function. The wasm-bindgen adds all the necessary metadata that is required for the compiler to convert Rust code into a WebAssembly module. To load and run the generated files, we can use bundlers such as webpack or Parcel. We will see how these bundlers help in more detail in later chapters. For now, let's see how to run and load the generated files:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The following setup is common and we will refer to it as the "default" webpack setup in future examples. Create a <code>webpack-config.js</code> file to tell webpack how to handle the files.</p>
			<pre>const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
    entry: './index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js',
    },
    plugins: [
        new HtmlWebpackPlugin(),
    ],
    mode: 'development'
};</pre>
			<p>This is a standard webpack configuration file with an <code>HTMLWebpackPlugin</code> plugin. This plugin helps us to generate a default <code>index.html</code> instead of manually creating it. </p>
			<p>Let's add a <code>package.json</code> file to bundle the dependencies for running webpack:</p>
			<pre>{
    "scripts": {
        "build": "webpack",
        "serve": "webpack-dev-server"
    },
    "devDependencies": {
        "html-webpack-plugin": "^3.2.0",
        "webpack": "^4.29.4",
        "webpack-cli": "^3.1.1",
        "webpack-dev-server": "^3.1.0"
    }
}</pre>
			<p>Create <a id="_idIndexMarker332"/>an <code>index.js</code> file to load <a id="_idIndexMarker333"/>the binding JavaScript, which in turn loads the WebAssembly module generated:</p>
			<pre>import("./hello_world").then(module =&gt; {
    console.log(module.hello_world());
});</pre>
			<p>Now, head over to the terminal and install the npm dependencies using the following command:</p>
			<pre>$ npm install</pre>
			<p>Run <code>webpack-dev-server</code>:</p>
			<pre>$ npm run serve</pre>
			<p>Go to the URL <code>http://localhost:8080</code> and open the developer console in the browser to see "Hello World" printed.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor101"/>Summary</h1>
			<p>In this chapter, we saw how to install Rust using <code>rustup</code>. <code>rustup</code> helps us to install, update, remove, and switch different versions of Rust. We saw how <code>rustc</code> works and then converted Rust into WebAssembly using <code>rustc</code>. After that, we explored Cargo, the package manager for Rust. Finally, we installed <code>wasm-bindgen</code> and compiled Rust code into a WebAssembly module using <code>wasm-bindgen</code>.</p>
			<p>In the next chapter, we will explore what <code>wasm-pack</code> is and how it helps to build and pack WebAssembly modules.</p>
		</div>
	</body></html>