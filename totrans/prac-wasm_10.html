<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-81"><em class="italic"><a id="_idTextAnchor090"/>Chapter 7</em>: Integrating Rust with WebAssembly</h1>
			<p>Rust is a system-level programming language. Being a system-level programming language, Rust provides low-level memory management and the ability to represent data efficiently. Thus, it provides complete control to programmers and better performance. </p>
			<p>In addition to this, Rust also provides the following:</p>
			<ul>
				<li><strong class="bold">A friendly compiler</strong> – The Rust compiler is your companion when writing Rust. The compiler corrects you, guides you, and ensures that you write memory-safe code almost always.</li>
				<li><strong class="bold">The ownership model</strong> – The ownership model ensures that we do not need garbage collection. This guarantees thread and memory safety in Rust.</li>
				<li><strong class="bold">Safety, speed, and concurrency</strong> – Rust ensures safety and concurrency and makes you stay away from risks, crashes, and vulnerabilities.</li>
				<li><strong class="bold">A modern language</strong> – Rust provides modern language syntax and the language is built to provide a better developer experience.</li>
			</ul>
			<p>These features (along with thousands of others) ensure Rust is a general-purpose programming language. The highlight of the Rust language is that its compiler and community are always helpful.</p>
			<p>Rust provides first-class support for WebAssembly. Rust's rich toolchain makes it easier to get started with WebAssembly. Rust does not need a runtime, which makes it a perfect candidate for WebAssembly. In this chapter, we will see how to install Rust and explore various ways to convert Rust into a WebAssembly module. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Installing Rust</li>
				<li>Converting Rust into WebAssembly via <strong class="source-inline">rustc</strong></li>
				<li>Converting Rust into WebAssembly via Cargo</li>
				<li>Installing wasm-bindgen</li>
				<li>Converting Rust into WebAssembly via <a id="_idTextAnchor091"/><strong class="source-inline">wasm-bindgen</strong></li>
			</ul>
			<p>Now let's hack into the Rust and WebAssembly world.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor092"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor093"/>Installing Rust </h1>
			<p>Rust is a compiled language and its compiler is called the <strong class="bold">Rust compiler</strong> (<strong class="bold">rustc</strong>). Rust also has its own <a id="_idIndexMarker283"/>package manager, called <strong class="bold">Cargo</strong>. Cargo is similar to npm for <a id="_idIndexMarker284"/>Node.js. Cargo downloads package dependencies and builds, compiles, packs, and <a id="_idIndexMarker285"/>uploads the artifacts into crates (Rust's version of packages). </p>
			<p>The Rust language provides an easy way to install and manage Rust via <strong class="source-inline">rustu<a id="_idTextAnchor094"/>p</strong>. <strong class="source-inline">rustup</strong> helps to install, update, and remove <strong class="source-inline">rustc</strong>, Cargo, and <strong class="source-inline">rustup</strong> itself. It makes it easy to install and manage various versions of Rust. </p>
			<p>Let's install Rust using the <strong class="source-inline">rustup</strong> tool and see how we can manage Rust versions using <strong class="source-inline">rustup</strong>.</p>
			<p>In Linux or macOS, use the following command:</p>
			<p class="source-code">$ curl https://sh.rustup.rs --sSf | sh</p>
			<p>The script will download and install the Rust language. Both <strong class="source-inline">rustc</strong> and Cargo are installed in <strong class="source-inline">~/.cargo/bin</strong> and delegate any access to the underlying toolchain.</p>
			<p>For Windows, download and install the binaries from here: <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">https://forge.rust-lang.org/infra/other-installation-methods.html</a>. Both <strong class="source-inline">rustc</strong> and Cargo are installed in the <strong class="source-inline">users</strong> folder.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">You will require C++ build tools for Visual Studio 2013 or later. You can install them from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>.</p>
			<p>Once the installation is completed successfully, you can check it by running the following command:</p>
			<p class="source-code">$ rustc –version</p>
			<p class="source-code">rustc 1.58.1 (db9d1b20b 2022-01-2<a id="_idTextAnchor095"/>0)</p>
			<p><strong class="source-inline">rustup</strong> is a toolchain multiplexer. It installs and manages many Rust toolchains and proxies them <a id="_idIndexMarker286"/>through the single set of tools installed at <strong class="source-inline">.cargo/bin</strong> in the home directory. Once <strong class="source-inline">rustup</strong> is installed, we can easily manage the <strong class="source-inline">rustc</strong> and <strong class="source-inline">cargo</strong> compilers. <strong class="source-inline">rustup</strong> also makes it easy to switch between nightly, stable, and beta versions of Rust.</p>
			<p>Rust provides WebAssembly compilation support in its stable version. We will also switch to the nightly build to make sure we get all the latest benefits.</p>
			<p>To switch to the nightly version, we have to run the following command:</p>
			<p class="source-code">$ rustup default nightly</p>
			<p>This command will switch the default <strong class="source-inline">rustc</strong> to the nightly version. The <strong class="source-inline">rustc</strong> proxy in <strong class="source-inline">~/.cargo/bin</strong> will run the nightly compiler instead of the stable compiler.</p>
			<p>To update to the latest version of nightly, we can run the following:</p>
			<p class="source-code">$ rustup update</p>
			<p>Once successfully updated, we can check the current version installed by running the following:</p>
			<p class="source-code">$ rustc --version</p>
			<p class="source-code">rustc 1.55.0 (c8dfcfe04 2021-09-06)</p>
			<p>Rust supports WebAssembly as a first-class citizen. Thus, <strong class="source-inline">rustc</strong> is capable of compiling Rust code into <a id="_idIndexMarker287"/>WebAssembly modules. Let's see how to convert Rust into WebAssembly via <strong class="source-inline">rustc</strong>.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor096"/>Converting Rust into WebAssembly via rustc</h1>
			<p>Rust uses the LLVM compiler we'll create now to generate machine-native code. <strong class="source-inline">rustc</strong> uses LLVM's capability <a id="_idIndexMarker288"/>to convert the native <a id="_idIndexMarker289"/>code into a WebAssembly module. We installed Rust in the previous section; let's start converting Rust into a WebAssembly module using <strong class="source-inline">rustc</strong>.</p>
			<p>We will start with Hello World: </p>
			<ol>
				<li>Let's create a file called <strong class="source-inline">hello_world.rs</strong>:<p class="source-code"><strong class="bold">$ touch hello_world.rs</strong></p></li>
				<li>Spin up your favorite editor and start writing the Rust code:<p class="source-code">fn main() {    </p><p class="source-code">println!("Hello World!");</p><p class="source-code">}</p></li>
			</ol>
			<p>We have defined a <strong class="source-inline">main</strong> function. Similar to C, <strong class="source-inline">main</strong> is a special function that marks the entry point to a program after it has been compiled as an executable.</p>
			<p><strong class="source-inline">fn</strong> is the function keyword in Rust. <strong class="source-inline">main()</strong> is the function name.</p>
			<p><strong class="source-inline">println!</strong> is the macro. Macros in Rust allow us to abstract code at a syntactic level. A macro invocation is shorthand for an "expanded" syntactic form. This expansion happens early on in compilation, before any static checking. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Macros are an interesting feature but explaining them is beyond the scope of this book. You can find more <a id="_idIndexMarker290"/>information here: <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">https://doc.rust-lang.org/book/ch19-06-macros.html</a>.</p>
			<ol>
				<li value="3">We pass in the <strong class="source-inline">Hello World!</strong> string to the <strong class="source-inline">println!</strong> macro function. We can compile and generate the binary by running the following:<p class="source-code"><strong class="bold">$ rustc hello.rs</strong></p></li>
				<li>This will generate a <strong class="source-inline">hello</strong> binary. We can execute the binary and that will print <strong class="source-inline">Hello World!</strong>:<p class="source-code"><strong class="bold">$ ./hello</strong></p><p class="source-code"><strong class="bold">Hello World!</strong></p></li>
				<li>Now, compile <a id="_idIndexMarker291"/>Rust into a WebAssembly <a id="_idIndexMarker292"/>module with <strong class="source-inline">rustc</strong>:<p class="source-code"><strong class="bold">$ rustc --target wasm32-unknown-emscripten</strong></p><p class="source-code"><strong class="bold">  hello_world.rs -o hello_world.html</strong></p></li>
			</ol>
			<p>This will generate the WebAssembly module. </p>
			<ol>
				<li value="6">Let's run the generated code in the browser using the following command:<p class="source-code"><strong class="bold">$ python -m http.server</strong></p></li>
			</ol>
			<p>Open your browser and head over to <strong class="source-inline">http://localhost:8000</strong>. Open the developer console to see <strong class="source-inline">Hello World!</strong> printed in it.</p>
			<p>To convert Rust into a WebAssembly module, we have used the <strong class="source-inline">--target</strong> flag. This flag instructs the compiler to compile and build the binary such that it runs on the provided runtime.</p>
			<p>We passed in <strong class="source-inline">wasm32-unknown-emscripten</strong> as a value to the <strong class="source-inline">--target</strong> flag.</p>
			<p><strong class="source-inline">wasm32</strong> indicates that the address space is 32 bits large. <strong class="source-inline">unknown</strong> tells the compiler that you don't know the system that you are compiling to. <strong class="source-inline">emscripten</strong> at the end notifies the compiler that you are targeting.</p>
			<p>So, with the <strong class="source-inline">wasm32-unknown-emscripten</strong> value, the compiler will compile on almost any machine but run only on the Emscripten runtime. Then, we specify the input file that needs to be compiled into the WebAssembly module. Finally, we specify the output with a <strong class="source-inline">-o</strong> flag.</p>
			<p>It is important to understand what <strong class="source-inline">rustc</strong> does.</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_7.1_B14844.jpg" alt="Figure 7.1 – Rust compilation steps&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Rust compilation steps</p>
			<p><strong class="source-inline">rustc</strong> first parses the input and produces the <strong class="bold">Abstract Syntax Tree</strong> (<strong class="bold">AST</strong>). Once the AST is generated, the <a id="_idIndexMarker293"/>compiler then recursively resolves <a id="_idIndexMarker294"/>the paths, expanding <a id="_idIndexMarker295"/>macros and other references. Once the AST is completely <a id="_idIndexMarker296"/>resolved, it will be converted into the <strong class="bold">High-level Intermediate Representation</strong> (<strong class="bold">HIR</strong>). This intermediate representation is like a desugared variant of AST.</p>
			<p>The HIR is then <a id="_idIndexMarker297"/>analyzed for type checking. After <a id="_idIndexMarker298"/>type checking, the HIR is postprocessed and converted into the <strong class="bold">Middle Intermediate Representation</strong> (<strong class="bold">MIR</strong>). From MIR, the compiler<a id="_idTextAnchor097"/> generates the <strong class="bold">LLVM Intermediate Representation</strong> (<strong class="bold">LLVM IR</strong>). After that, LLVM does the required optimizations on them.</p>
			<p>Now, with LLVM IR, it is easier to convert LLVM IR into WebAssembly modules. This is similar to how Emscripten converts C or C++ code into WebAssembly modules.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Since we are using the <strong class="source-inline">wasm32-unknown-emscripten</strong> flag here, we need <strong class="source-inline">emcc</strong> to be available for converting the LLVM IR generated from Rust code into a WebAssembly module.</p>
			<p>We have seen how to use <strong class="source-inline">rustc</strong> to generate WebAssembly modules. It uses Emscripten behind the scenes to create them. But Rust provides another <a id="_idIndexMarker299"/>abstraction to generate WebAssembly modules, via <a id="_idIndexMarker300"/>Cargo. </p>
			<p>In the next section, we will see how to convert Rust into WebAssembly using Cargo.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor098"/>Converting Rust into WebAssembly via Cargo </h1>
			<p>Cargo makes it easier to create, run, download, compile, test, and run your project. The <strong class="source-inline">cargo</strong> command <a id="_idIndexMarker301"/>provides a wrapper that <a id="_idIndexMarker302"/>calls the <strong class="source-inline">rustc</strong> compiler to start the <a id="_idIndexMarker303"/>compilation. In order to create WebAssembly modules using Rust's toolchain, we will be using a different target, <strong class="source-inline">wasm32-unknown-unknown</strong>.</p>
			<p>The <strong class="source-inline">wasm32-unknown-unknown</strong> target adds zero runtime and toolchain footprint. <strong class="source-inline">wasm32</strong> makes the compiler assume that only the <strong class="source-inline">wasm32</strong> instruction set is present. The first <strong class="source-inline">unknown</strong> in <strong class="source-inline">unknown-unknown</strong> indicates the code can compile on any machine and the second indicates the code can run on any machine. </p>
			<p>To see it in action, let's create a new project with Cargo:</p>
			<p class="source-code">$ cargo new --lib fib_wasm</p>
			<p class="source-code">Created library `fib_wasm` package</p>
			<p>A new project called <strong class="source-inline">fib_wasm</strong> is created. The new option creates a Rust project. The <strong class="source-inline">--lib</strong> flag informs Cargo to create a new library project rather than the default binary project.</p>
			<p>The binary project will produce the executable binary. The library project will create the library module.</p>
			<p>Spin up your favorite text editor and replace the contents of <strong class="source-inline">src/lib.rs</strong> with the following:</p>
			<p class="source-code">#[no_mangle]</p>
			<p class="source-code">fn add(x: i32, y:i32) -&gt; i32 {    x + y}</p>
			<p><strong class="source-inline">#[no_mangle]</strong> is a kind of annotation. This annotation informs the compiler not to mangle the names when generating the library.</p>
			<p>Then, we <a id="_idIndexMarker304"/>define the <strong class="source-inline">add</strong> function. The <strong class="source-inline">add</strong> function <a id="_idIndexMarker305"/>takes in two parameters, <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>. We <a id="_idIndexMarker306"/>define their types with <strong class="source-inline">i32</strong> following the variable and a colon (<strong class="source-inline">:</strong>). Finally, we define their return type using <strong class="source-inline">-&gt; i32</strong>.</p>
			<p>The function body has just <strong class="source-inline">x + y</strong>. Note, in Rust we do not need <strong class="source-inline">return</strong> keyword and <strong class="source-inline">;</strong> at the end of the last statement, this shorts to return.</p>
			<p>Cargo also generates <strong class="source-inline">Cargo.toml</strong>. This file holds all the meta-information about the project, how to compile the Rust code, and their dependencies.</p>
			<p>The <strong class="source-inline">Cargo.toml</strong> file looks like this:</p>
			<p class="source-code">[package]</p>
			<p class="source-code">name = "fib_wasm"</p>
			<p class="source-code">version = "0.1.0"</p>
			<p class="source-code">authors = ["Sendil Kumar"]</p>
			<p class="source-code">edition = "2018"</p>
			<p>It defines the package name, version, authors, and edition of Rust we are using.</p>
			<p>Here, we have to instruct the compiler what type of crate we are compiling. We can specify it under the <strong class="source-inline">[lib]</strong> segment and with the <strong class="source-inline">crate-type</strong> property.</p>
			<p>Open <strong class="source-inline">Cargo.toml</strong> and append the <strong class="source-inline">crate-type</strong> information inside:</p>
			<p class="source-code">[package]</p>
			<p class="source-code">name = "fib_wasm"</p>
			<p class="source-code">version = "0.1.0"</p>
			<p class="source-code">authors = ["Sendil Kumar"]</p>
			<p class="source-code">edition = "2018"</p>
			<p class="source-code">[lib]</p>
			<p class="source-code">crate-type = ["cdylib"]</p>
			<p><strong class="source-inline">cdylib</strong> here specifies a dynamic system library will be produced. This dynamic system library is used when the library has to be loaded from another language.</p>
			<p>Let's compile Rust into WebAssembly modules:</p>
			<p class="source-code">$ cargo build --target wasm32-unknown-unknown</p>
			<p>This will <a id="_idIndexMarker307"/>invoke <strong class="source-inline">rustc</strong> with the specified <a id="_idIndexMarker308"/>target. That will generate the WebAssembly <a id="_idIndexMarker309"/>module inside <strong class="source-inline">/target/wasm32-unknown-unknown/</strong>. Now, in order to run the WebAssembly module on the browser, let's manually create the HTML file and load it using JavaScript.</p>
			<p>Let's create an HTML file:</p>
			<p class="source-code">$ touch index.html</p>
			<p>Add the following content to the file:</p>
			<p class="source-code">&lt;script&gt; </p>
			<p class="source-code">(async () =&gt; {     </p>
			<p class="source-code">const bytes = await fetch("target/wasm32-unknown-</p>
			<p class="source-code">  unknown/debug/fib_wasm.wasm");     </p>
			<p class="source-code">const response = await bytes.arrayBuffer();     </p>
			<p class="source-code">const result = await WebAssembly.instantiate(response, {});</p>
			<p class="source-code">  console.log(result.instance.exports.add(10,3)); </p>
			<p class="source-code">})();</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We defined the script inside the <strong class="source-inline">&lt;script&gt;</strong> tag. In HTML, we define JavaScript inside the <strong class="source-inline">&lt;script&gt;</strong> tag. We have added the <strong class="bold">Immediately Invoked Function Execution</strong> (<strong class="bold">IIFE</strong>) block with <a id="_idIndexMarker310"/>the <strong class="source-inline">async</strong> keyword. The <strong class="source-inline">async</strong> keyword specifies the function is asynchronous.</p>
			<p>First, we fetch the WebAssembly module. The WebAssembly module is generated in the <strong class="source-inline">target/wasm32-unknown-unknown/debug/</strong> folder with the same name as the package name defined in <strong class="source-inline">Cargo.toml</strong>.</p>
			<p>The <strong class="source-inline">await</strong> keyword ensures the execution is awaited until we fetch the entire WebAssembly module.</p>
			<p>We then convert the collected bytes (from the fetch call) using <strong class="source-inline">bytes.arrayBuffer()</strong>. The <strong class="source-inline">response</strong> object will now have the WebAssembly module inside <strong class="source-inline">ArrayBuffer</strong>.</p>
			<p>We then <a id="_idIndexMarker311"/>instantiate the bytes array using <a id="_idIndexMarker312"/>the <strong class="source-inline">WebAssembly.instantiate</strong> function. The <strong class="source-inline">result</strong> object contains the entire WebAssembly <a id="_idIndexMarker313"/>module.</p>
			<p>The WebAssembly module <strong class="source-inline">result</strong> contains the <strong class="source-inline">instance</strong> property. The instance has the <strong class="source-inline">exports</strong> property. The <strong class="source-inline">exports</strong> property holds all the functions exported by the WebAssembly module.</p>
			<p>Since we added <strong class="source-inline">#[no_mangle]</strong>, the exported function name is not changed. Hence, the <strong class="source-inline">exports</strong> property has the <strong class="source-inline">add</strong> function defined in it.</p>
			<p>We have used async-await here to make the syntax more elegant and contextually easier to understand.</p>
			<p>As expected, the preceding code will give an output of <strong class="source-inline">13</strong>. You can check the output in the browser console.</p>
			<p>Here, the <strong class="source-inline">cargo build</strong> command invokes <strong class="source-inline">rustc</strong> and compiles the Rust code into MIR and then into LLVM IR. The generated LLVM IR is then converted into a WebAssembly module. Let's make this function a bit more complicated. We can create a Fibonacci number generator with Rust and run the WebAssembly Module on the browser:</p>
			<ol>
				<li value="1">Open <strong class="source-inline">src/lib.rs</strong> and replace everything with the following content:<p class="source-code">#[no_mangle]</p><p class="source-code">fn fibonacci(num: i32) -&gt; i32 {    </p><p class="source-code">match num {        </p><p class="source-code">0 =&gt; 0,        </p><p class="source-code">1 =&gt; 1,        </p><p class="source-code">_ =&gt; fibonacci(num-1) + fibonacci(num-2),    </p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>Build <a id="_idIndexMarker314"/>it using <strong class="source-inline">cargo build --target wasm32-unknown-unknown</strong>.</p>
			<ol>
				<li value="2">Then, <a id="_idIndexMarker315"/>replace <strong class="source-inline">index.html</strong> such that <a id="_idIndexMarker316"/>we call the Fibonacci instead of the <strong class="source-inline">add</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code"> (async () =&gt; {     </p><p class="source-code">const bytes = await fetch("target/wasm32-unknown-</p><p class="source-code">  unknown/debug/fib_wasm.wasm");     </p><p class="source-code">const response = await bytes.arrayBuffer();     </p><p class="source-code">const result = await WebAssembly.instantiate(response,</p><p class="source-code">  {});  </p><p class="source-code">     result.instance.exports.fibonacci(20); </p><p class="source-code">})();</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Now, spin up the HTML server and check the browser's console for the Fibonacci value.</li>
			</ol>
			<p>So far, we have seen simple examples. But how can we pass functions and classes from JavaScript into WebAssembly and the other way around? In order to do more advanced bindings, Rust provides us with <strong class="source-inline">wasm-bindgen</strong>.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor099"/>Installing wasm-bindgen </h1>
			<p><strong class="source-inline">wasm-bindgen</strong> is used to <a id="_idIndexMarker317"/>bind entities from Rust into JavaScript and vice versa.</p>
			<p><strong class="source-inline">wasm-bindgen</strong> makes it more natural to import exported entities from Rust into JavaScript. JavaScript developers will find that <strong class="source-inline">wasm-bindgen</strong>'s use of WebAssembly is similar to JavaScript.</p>
			<p>This enables the use of richer and easier APIs while converting Rust into a WebAssembly module. <strong class="source-inline">wasm-bindgen</strong> uses these features and provides a simple API to use. It ensures that there is high-level interaction happening between wasm modules and JavaScript.</p>
			<p><strong class="source-inline">wasm-bindgen</strong> provides a channel between JavaScript and WebAssembly to communicate something other than numbers, such as objects, strings, and arrays.</p>
			<p>To install <strong class="source-inline">wasm-bindgen-cli</strong>, use the following <strong class="source-inline">cargo</strong> command:</p>
			<p class="source-code">$ cargo install wasm-bindgen-cli</p>
			<p>Once successfully installed, let's run the <strong class="source-inline">wasm-bindgen</strong> CLI:</p>
			<p class="source-code">$ wasm-bindgen  --help</p>
			<p class="source-code">Generating JS bindings for a wasm file</p>
			<p class="source-code">Usage:</p>
			<p class="source-code">    wasm-bindgen [options] &lt;input&gt;</p>
			<p class="source-code">    wasm-bindgen -h | --help</p>
			<p class="source-code">    wasm-bindgen -V | --version</p>
			<p class="source-code">Options:</p>
			<p class="source-code">    -h --help                 Show this screen.</p>
			<p class="source-code">    --out-dir DIR             Output directory</p>
			<p class="source-code">    --out-name VAR            Set a custom output filename </p>
			<p class="source-code">      (Without extension. Defaults to crate name)</p>
			<p class="source-code">    --target TARGET           What type of output to generate, </p>
			<p class="source-code">      valid</p>
			<p class="source-code">      values are [web, bundler, nodejs, no-modules],</p>
			<p class="source-code">        and the default is [bundler]</p>
			<p class="source-code">    --no-modules-global VAR   Name of the global variable to </p>
			<p class="source-code">      initialize</p>
			<p class="source-code">    --browser                 Hint that JS should only be </p>
			<p class="source-code">      compatible with a browser</p>
			<p class="source-code">    --typescript              Output a TypeScript definition </p>
			<p class="source-code">      file (on by default)</p>
			<p class="source-code">    --no-typescript           Don't emit a *.d.ts file</p>
			<p class="source-code">    --debug                   Include otherwise-extraneous </p>
			<p class="source-code">      debug checks in output</p>
			<p class="source-code">    --no-demangle             Don't demangle Rust symbol names</p>
			<p class="source-code">    --keep-debug              Keep debug sections in wasm files</p>
			<p class="source-code">    --remove-name-section     Remove the debugging `name` </p>
			<p class="source-code">      section of the file</p>
			<p class="source-code">    --remove-producers-section   Remove the telemetry </p>
			<p class="source-code">      `producers` section</p>
			<p class="source-code">    --encode-into MODE        Whether or not to use </p>
			<p class="source-code">      TextEncoder#encodeInto,</p>
			<p class="source-code">      valid values are [test,z always, never]</p>
			<p class="source-code">    --nodejs                  Deprecated, use `--target nodejs`</p>
			<p class="source-code">    --web                     Deprecated, use `--target web`</p>
			<p class="source-code">    --no-modules              Deprecated, use `--target </p>
			<p class="source-code">      no-modules`</p>
			<p class="source-code">    -V --version              Print the version number of </p>
			<p class="source-code">     wasm-bindgen</p>
			<p>Let's take a look at the various options <strong class="source-inline">wasm-bindgen</strong> supports.</p>
			<p>To generate the file in a particular directory and with a particular name, the tool has <strong class="source-inline">--out-dir</strong> and <strong class="source-inline">--out-name</strong>, respectively. To reduce or optimize the generated WebAssembly module size, <strong class="source-inline">wasm-bindgen</strong> has the following flags:</p>
			<ul>
				<li><strong class="source-inline">--debug</strong>: The <strong class="source-inline">--debug</strong> option includes extra debugging information in the generated WebAssembly module. This will increase the size of the WebAssembly module but it is useful in development.</li>
				<li><strong class="source-inline">--keep-debug</strong>: This WebAssembly module may or may not have custom sections. These custom sections can be used to hold the debugging information. These <a id="_idIndexMarker318"/>custom sections will be helpful while debugging the application (such as in browser developer tools). This will increase the size of the WebAssembly module. This is useful in development.</li>
				<li><strong class="source-inline">--no-demangle</strong>: This flag tells <strong class="source-inline">wasm-bindgen</strong> not to demangle the Rust symbol names. Demangling allows the end user to use the same name that they have defined in the Rust file.</li>
				<li><strong class="source-inline">--remove-name-section</strong>: This will remove the debugging name section of the file. We will see more about the various sections in a WebAssembly module later. This will decrease the size of the WebAssembly module.</li>
				<li><strong class="source-inline">--remove-producers-section</strong>: WebAssembly modules can have a producer section. This section will hold information about how the file was produced or who produced the file. By default, producer sections are added to a generated WebAssembly module. With this flag, we can remove it. It saves a few more bytes.</li>
			</ul>
			<p><strong class="source-inline">wasm-bindgen</strong> provides options to generate the binding file for both Node.js and the browser environment. Let's see those flags:</p>
			<ul>
				<li><strong class="source-inline">--nodejs</strong>: This generates output that only works for Node.js. No ESModules. </li>
				<li><strong class="source-inline">--browser</strong>: This generates output that only works for the browser. With ESModules. </li>
				<li><strong class="source-inline">--no-modules</strong>: This generates output that only works for the browser. No ESModules. Suitable for browsers that don't support ESModules yet.</li>
			</ul>
			<p>The type <a id="_idIndexMarker319"/>definition files (<strong class="source-inline">*.d.ts</strong>) can be switched off by using the <strong class="source-inline">--no-typescript</strong> flag.</p>
			<p>Now we have installed <strong class="source-inline">wasm-bindgen</strong>, let's take it for a spin. </p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor100"/>Converting Rust into WebAssembly via wasm-bindgen</h1>
			<p>Let's start <a id="_idIndexMarker320"/>with a Hello World <a id="_idIndexMarker321"/>example with <strong class="source-inline">wasm-bindgen</strong>:</p>
			<ol>
				<li value="1">Create a new project with Cargo:<p class="source-code"><strong class="bold"> $ cargo new --lib hello_world</strong></p><p class="source-code"><strong class="bold">Created library `hello_world` package</strong></p></li>
			</ol>
			<p>This will create a new Rust project with all the necessary files. </p>
			<ol>
				<li value="2">Open the project in your favorite editor. Open the <strong class="source-inline">Cargo.toml</strong> file to add <strong class="source-inline">crate-type</strong> and add the <strong class="source-inline">wasm-bindgen</strong> dependency:<p class="source-code">[package]</p><p class="source-code">name = "hello_world"</p><p class="source-code">version = "0.1.0"</p><p class="source-code">authors = ["Sendil Kumar"]</p><p class="source-code">edition = "2018"</p><p class="source-code">[lib]</p><p class="source-code">crate-type = ["cdylib"]</p><p class="source-code">[dependencies]</p><p class="source-code">wasm-bindgen = "0.2.38"</p></li>
				<li>We define the dependency under the <strong class="source-inline">[dependencies]</strong> table in the <strong class="source-inline">toml</strong> file. Open the <strong class="source-inline">src/lib.rs</strong> file and replace the contents with the following:<p class="source-code">use wasm_bindgen::prelude::*;</p><p class="source-code">#[wasm_bindgen]</p><p class="source-code">pub fn hello() -&gt; String {</p><p class="source-code">"Hello World".to_string()</p><p class="source-code">}</p></li>
			</ol>
			<p>We import the <strong class="source-inline">wasm_bindgen</strong> library using <strong class="source-inline">use wasm_bingen::prelude::*</strong> and then annotate the function with <strong class="source-inline"># [wasm_bindgen]</strong>. The <strong class="source-inline">hello</strong> function returns <strong class="source-inline">String</strong>.</p>
			<p> To generate the WebAssembly module, we will first run the following command:</p>
			<p class="source-code">$ cargo build --target=wasm32-unknown-unknown</p>
			<p>This will <a id="_idIndexMarker322"/>generate the WebAssembly <a id="_idIndexMarker323"/>module. But this module cannot run by itself. WebAssembly only supports passing numbers between the native code and JavaScript. But we are returning a <strong class="source-inline">String</strong> here.</p>
			<p>In order to pass any value (other than numbers), we need to create a binding JavaScript file. This binding file is nothing more than a translator that translates the <strong class="source-inline">String</strong> (and other types) into <strong class="source-inline">start</strong>, <strong class="source-inline">length</strong>, <strong class="source-inline">arrayBuffer</strong>.</p>
			<p>In order to generate the binding files, we need to run the <strong class="source-inline">wasm-bindgen</strong> CLI tool on the generated WebAssembly module:</p>
			<p class="source-code">$ wasm-bindgen target/wasm32-unknown-</p>
			<p class="source-code">  unknown/debug/hello_world.wasm --out-dir .</p>
			<p>We run <strong class="source-inline">wasm-bindgen</strong> and pass it to the generated <strong class="source-inline">target/wasm32-unknown-unknown/debug/hello_world.wasm</strong> WebAssembly module. The <strong class="source-inline">--out-dir</strong> flag tells the <strong class="source-inline">wasm-bindgen</strong> CLI tool where to save the generated files. Here, we are asking for the files to be generated in the current folder.</p>
			<p>We can see the files that are generated inside the folder:</p>
			<p class="source-code">$ ls -lrta</p>
			<p class="source-code">-rw-r--r-- 1 sendilkumar staff 1769 hello_world.js</p>
			<p class="source-code">-rw-r--r-- 1 sendilkumar staff 88 hello_world.d.ts</p>
			<p class="source-code">-rw-r--r-- 1 sendilkumar staff 227 hello_world_bg.d.ts</p>
			<p class="source-code">-rw-r--r-- 1 sendilkumar staff 67132 hello_world_bg.wasm </p>
			<p>The <strong class="source-inline">cargo build</strong> command generates the WebAssembly module. The <strong class="source-inline">wasm-bindgen</strong> CLI <a id="_idIndexMarker324"/>takes this WebAssembly <a id="_idIndexMarker325"/>module as input and generates the necessary bindings. The size of the binding JavaScript file is around 1.8 KB.</p>
			<p>The generated files are as follows:</p>
			<ul>
				<li>The WebAssembly module (<strong class="source-inline">hello_world_bg.wasm</strong>)</li>
				<li>The JavaScript binding file (<strong class="source-inline">hello_world.js</strong>)</li>
				<li>The type definition file for the <strong class="source-inline">WASM</strong> (<strong class="source-inline">hello_world.d.ts</strong>)</li>
				<li>The type definition file for the JavaScript (<strong class="source-inline">hello_world_bg.d.ts</strong>)</li>
			</ul>
			<p>The JavaScript binding file is enough for us to load and run the WebAssembly module.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is also a TypeScript file generated.</p>
			<p>Let's now check what the binding file contains:</p>
			<p class="source-code">import * as wasm from './hello_world_bg.wasm';</p>
			<p>The binding file imports the WebAssembly module:</p>
			<p class="source-code">const lTextDecoder = typeof TextDecoder === 'undefined' ?</p>
			<p class="source-code">  require('util').TextDecoder : TextDecoder;</p>
			<p class="source-code">let cachedTextDecoder = new lTextDecoder('utf-8');</p>
			<p>It then defines <strong class="source-inline">TextDecoder</strong>, to decode the string from the shared <strong class="source-inline">ArrayBuffer</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since there are no input arguments available, there is no need for <strong class="source-inline">TextEncoder</strong> (that is, to encode the string from JavaScript into shared memory). <strong class="source-inline">wasm-bindgen</strong> will generate only the necessary things inside the binding file.</p>
			<p>Modern browsers have built-in <strong class="source-inline">TextDecoder</strong> and <strong class="source-inline">TextEncoder</strong> support. <strong class="source-inline">wasm-bindgen</strong> checks and uses the decoder if present; otherwise, it loads it using polyfill.</p>
			<p>The shared <a id="_idIndexMarker326"/>memory between <a id="_idIndexMarker327"/>JavaScript and the WebAssembly module need not be initialized every time. We can initialize it once and use it throughout the lifetime of the execution. We have the following two methods to load the memory once and use it throughout the lifetime of the execution:</p>
			<p class="source-code">function getUint8Memory() { ... }</p>
			<p class="source-code">function getUint32Memory() { ... }</p>
			<p>Then, we get a <strong class="source-inline">String</strong> from Rust to JavaScript. This <strong class="source-inline">String</strong> is passed via the shared memory. So, we can use the pointer to the offset and the length of the <strong class="source-inline">String</strong> to retrieve it. The following function is used for retrieving the <strong class="source-inline">String</strong> from the WebAssembly module:</p>
			<p class="source-code">function getStringFromWasm(ptr, len) { ....  }</p>
			<p>We define the heap at the very end. This is where we will store all the JavaScript variables referenceable from the WebAssembly module. The <strong class="source-inline">__wbindgen_object_drop_ref</strong> function is used to free up the slot occupied by the JavaScript reference count.</p>
			<p>Finally, we have the <strong class="source-inline">hello</strong> function:</p>
			<p class="source-code">export function hello() {</p>
			<p class="source-code">    const retptr = globalArgumentPtr();</p>
			<p class="source-code">    wasm.hello_world(retptr);</p>
			<p class="source-code">    const mem = getUint32Memory();</p>
			<p class="source-code">    const rustptr = mem[retptr / 4];</p>
			<p class="source-code">    const rustlen = mem[retptr / 4 + 1];</p>
			<p class="source-code">    const realRet = getStringFromWasm(rustptr,</p>
			<p class="source-code">      rustlen).slice();</p>
			<p class="source-code">    wasm.__wbindgen_free(rustptr, rustlen * 1);</p>
			<p class="source-code">    return realRet;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">hello</strong> function is exported. We first get the pointer for the argument. This pointer refers to a location in the shared array buffer. Then, we call the <strong class="source-inline">hello</strong> function in the WebAssembly module. </p>
			<p>Note that <a id="_idIndexMarker328"/>we are passing in a (pointer to the) argument here. But we have defined the function without any arguments <a id="_idIndexMarker329"/>on the Rust side. We will briefly see how <strong class="source-inline">rustc</strong> has rewritten the code.</p>
			<p>Then, we get the shared memory. Note that this is a 32-bit array. We get the pointer in which the result is stored and the length of the output string. Note that these are stored successively.</p>
			<p>Finally, we will get the string from <strong class="source-inline">rustptr</strong> and <strong class="source-inline">rustlen</strong>. Once we have received the output, we will clear the allocated memory using <strong class="source-inline">wasm.__wbindgen_free</strong>.</p>
			<p>To understand what happens on the Rust side, let's use the <strong class="source-inline">cargo-expand</strong> command to expand the macro and see how the code is generated.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Check <a href="https://github.com/dtolnay/cargo-expand">https://github.com/dtolnay/cargo-expand</a> for how to install <strong class="source-inline">cargo-expand</strong>. It is not mandatory for the course of this book. But cargo-expand will help you understand what <strong class="source-inline">wasm-bindgen</strong> actually generates.</p>
			<p>Open your terminal, go to the project's base directory, and run the following command:</p>
			<p class="source-code">cargo expand --target=wasm32-unknown-unknown &gt; expanded.rs</p>
			<p>The preceding command will create a file called <strong class="source-inline">expanded.rs</strong>. If you take a look in the file <a id="_idIndexMarker330"/>generated, you will see <a id="_idIndexMarker331"/>how the simple <strong class="source-inline">#[wasm_bindgen]</strong> annotation changes the verbose part of exposing the function. The wasm-bindgen adds all the necessary metadata that is required for the compiler to convert Rust code into a WebAssembly module. To load and run the generated files, we can use bundlers such as webpack or Parcel. We will see how these bundlers help in more detail in later chapters. For now, let's see how to run and load the generated files:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The following setup is common and we will refer to it as the "default" webpack setup in future examples. Create a <strong class="source-inline">webpack-config.js</strong> file to tell webpack how to handle the files.</p>
			<p class="source-code">const path = require('path');</p>
			<p class="source-code">const HtmlWebpackPlugin = require('html-webpack-plugin');</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">    entry: './index.js',</p>
			<p class="source-code">    output: {</p>
			<p class="source-code">        path: path.resolve(__dirname, 'dist'),</p>
			<p class="source-code">        filename: 'bundle.js',</p>
			<p class="source-code">    },</p>
			<p class="source-code">    plugins: [</p>
			<p class="source-code">        new HtmlWebpackPlugin(),</p>
			<p class="source-code">    ],</p>
			<p class="source-code">    mode: 'development'</p>
			<p class="source-code">};</p>
			<p>This is a standard webpack configuration file with an <strong class="source-inline">HTMLWebpackPlugin</strong> plugin. This plugin helps us to generate a default <strong class="source-inline">index.html</strong> instead of manually creating it. </p>
			<p>Let's add a <strong class="source-inline">package.json</strong> file to bundle the dependencies for running webpack:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "scripts": {</p>
			<p class="source-code">        "build": "webpack",</p>
			<p class="source-code">        "serve": "webpack-dev-server"</p>
			<p class="source-code">    },</p>
			<p class="source-code">    "devDependencies": {</p>
			<p class="source-code">        "html-webpack-plugin": "^3.2.0",</p>
			<p class="source-code">        "webpack": "^4.29.4",</p>
			<p class="source-code">        "webpack-cli": "^3.1.1",</p>
			<p class="source-code">        "webpack-dev-server": "^3.1.0"</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Create <a id="_idIndexMarker332"/>an <strong class="source-inline">index.js</strong> file to load <a id="_idIndexMarker333"/>the binding JavaScript, which in turn loads the WebAssembly module generated:</p>
			<p class="source-code">import("./hello_world").then(module =&gt; {</p>
			<p class="source-code">    console.log(module.hello_world());</p>
			<p class="source-code">});</p>
			<p>Now, head over to the terminal and install the npm dependencies using the following command:</p>
			<p class="source-code">$ npm install</p>
			<p>Run <strong class="source-inline">webpack-dev-server</strong>:</p>
			<p class="source-code">$ npm run serve</p>
			<p>Go to the URL <strong class="source-inline">http://localhost:8080</strong> and open the developer console in the browser to see "Hello World" printed.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor101"/>Summary</h1>
			<p>In this chapter, we saw how to install Rust using <strong class="source-inline">rustup</strong>. <strong class="source-inline">rustup</strong> helps us to install, update, remove, and switch different versions of Rust. We saw how <strong class="source-inline">rustc</strong> works and then converted Rust into WebAssembly using <strong class="source-inline">rustc</strong>. After that, we explored Cargo, the package manager for Rust. Finally, we installed <strong class="source-inline">wasm-bindgen</strong> and compiled Rust code into a WebAssembly module using <strong class="source-inline">wasm-bindgen</strong>.</p>
			<p>In the next chapter, we will explore what <strong class="source-inline">wasm-pack</strong> is and how it helps to build and pack WebAssembly modules.</p>
		</div>
	</body></html>