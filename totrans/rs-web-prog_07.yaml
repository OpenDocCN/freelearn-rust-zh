- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Managing User Sessions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户会话
- en: At this point, our app is manipulating data in a proper database through the
    clicking of buttons on the view. However, anyone who comes across our app can
    also edit the data. While our app is not the type of app that would require a
    lot of security, it is an important concept to understand and practice in general
    web development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序通过在视图中点击按钮来操作数据库中的数据。然而，任何遇到我们的应用程序的人都可以编辑数据。虽然我们的应用程序不需要太多的安全性，但了解和实践这一概念在一般Web开发中非常重要。
- en: In this chapter, we will build a system that creates users. This system will
    also manage user sessions by requiring the user to log in before they can alter
    any to-do items through the frontend app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个创建用户的系统。此系统还将通过要求用户在通过前端应用程序修改任何待办事项之前登录来管理用户会话。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating user data models with relationships with other tables with unique constraints
    of certain fields via database migrations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数据库迁移创建具有与其他表相关联的具有某些字段唯一约束的用户数据模型
- en: Authenticating our users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证我们的用户
- en: Managing user sessions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户会话
- en: Cleaning up authentication requirements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理认证要求
- en: Configuring expiration of auth tokens
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置认证令牌的过期时间
- en: Adding authentication into our frontend
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将认证添加到我们的前端
- en: After reading this chapter, you will be able to understand the basics of authenticating
    users on a web server. You will also be able to implement this authentication
    on the server side of our Rust application and store credentials in our React
    application in the frontend. The understanding of the concepts and practices covered
    in this chapter will also enable you to incorporate authentication in phone applications
    using React Native, and on a Rust server and desktop applications by wrapping
    our React application in **Electron**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，您将能够理解在Web服务器上认证用户的基本知识。您还将能够在我们的Rust应用程序的服务器端实现此认证，并在前端React应用程序中存储凭证。对本章涵盖的概念和实践的理解也将使您能够通过React
    Native在手机应用程序中集成认证，并通过将我们的React应用程序包装在**Electron**中在Rust服务器和桌面应用程序中实现。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we build on the code built in the previous chapter. This can
    be found at the following URL: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在前一章构建的代码基础上进行构建。您可以在以下URL找到这些代码：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool)。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07)找到。
- en: Creating our user model
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的用户模型
- en: 'Since we are managing user sessions in our app, we will need to store information
    about our users to check their credentials, before we allow our to-do items to
    be created, deleted, and edited. We will store our user data in a **PostgreSQL**
    database. While this is not essential, we will also link users in the database
    to to-do items. This will give us an understanding of how to alter an existing
    table and create links between tables. To create our user model, we are going
    to have to do the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在应用程序中管理用户会话，我们需要在允许创建、删除和编辑待办事项之前存储有关用户的信息以检查其凭证。我们将把我们的用户数据存储在**PostgreSQL**数据库中。虽然这不是必需的，但我们还将数据库中的用户与待办事项链接起来。这将使我们了解如何修改现有表并在表之间创建链接。为了创建我们的用户模型，我们将必须执行以下操作：
- en: Create a `User` data model.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`User`数据模型。
- en: Create a `NewUser` data model.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`NewUser`数据模型。
- en: Alter the to-do item data model so that we can link it to a user model.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改待办事项数据模型，以便我们可以将其链接到用户模型。
- en: Update the schema file with the new table and altered fields.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模式文件，包含新的表和修改的字段。
- en: Create and run migration scripts on the database.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库上创建和运行迁移脚本。
- en: In the following sections, we’ll look at the preceding steps in detail.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将详细查看前面的步骤。
- en: Creating a User data module
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户数据模块
- en: 'Before we start, we will need to update the dependencies in the `Cargo.toml`
    file with the following dependencies:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要更新`Cargo.toml`文件中的依赖项，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will be using the `bcrypt` crate to hash and check passwords and the `uuid`
    crate to generate unique IDs for our user data models. As we covered in [*Chapter
    6*](B18722_06.xhtml#_idTextAnchor127), *Data Persistence with PostgreSQL*, we
    will need to create two different structs for our user data model.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`bcrypt`包来散列和检查密码，以及使用`uuid`包为我们用户数据模型生成唯一的ID。正如我们在[*第6章*](B18722_06.xhtml#_idTextAnchor127)中讨论的，*使用PostgreSQL进行数据持久化*，我们需要为我们的用户数据模型创建两个不同的结构体。
- en: 'The new user will not have an `id` field because it does not exist in the database
    yet. This ID is created by the database when the new user is inserted into the
    table. We then have another struct that has all the same fields with the `id`
    field we added, since we might need to use this ID when we’re interacting with
    existing users in the database. ID numbers can be useful for referencing other
    tables. They are short and we know that they are unique. We will be using a user
    ID to link the user to the to-do items. These data models can be housed in the
    following file structure in the `src/models.rs` directory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 新用户将没有`id`字段，因为这个字段在数据库中尚不存在。当新用户被插入到表中时，数据库将创建这个ID。然后我们还有一个具有所有相同字段的结构体，包括我们添加的`id`字段，因为我们可能需要在与数据库中现有用户交互时使用这个ID。ID数字可以用于引用其他表。它们很短，我们知道它们是唯一的。我们将使用用户ID将用户与待办事项链接起来。这些数据模型可以放在以下文件结构中，在`src/models.rs`目录下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will define the data model in our `new_user.rs` file. First, we must define
    the imports, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`new_user.rs`文件中定义数据模型。首先，我们必须定义导入，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It must be noted that we have not defined the users in the schema yet. We will
    get around to this after we have finished with all the data models. We will not
    be able to compile our code until we have defined our `users` schema. We will
    also import a unique ID crate because we are going to be creating a unique ID
    when we create a new user, and the `Insertable` trait from the `diesel` crate
    because we are going to be inserting the new user into our database. We then use
    the `hash` function from the `bcrypt` crate to hash the new password that we define
    for our new user. We can also see that we import the `DEFAULT_COST` constant from
    the `bcrypt` crate. The `DEFAULT_COST` is merely a constant that we will pass
    into the `hash` function. We will explore why this is the case in the next section
    when we cover hashing passwords. Now that we have defined our user data model
    module and imported what we need, we can move on to the next section to create
    the `NewUser` struct.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，我们尚未在模式中定义用户。在完成所有数据模型之后，我们将解决这个问题。在定义了我们的`users`模式之前，我们将无法编译我们的代码。我们还将导入一个唯一的ID包，因为我们将在创建新用户时创建一个唯一的ID，以及从`diesel`包中导入的`Insertable`特质，因为我们将在数据库中插入新用户。然后我们使用`bcrypt`包中的`hash`函数来散列我们为新用户定义的新密码。我们还可以看到我们导入了来自`bcrypt`包的`DEFAULT_COST`常量。`DEFAULT_COST`仅仅是一个我们将传递给`hash`函数的常量。我们将在下一节中探讨为什么这是这种情况，当我们介绍散列密码时。现在我们已经定义了用户数据模型模块并导入了我们需要的内容，我们可以继续到下一节创建`NewUser`结构体。
- en: Creating a NewUser data model
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个NewUser数据模型
- en: 'We can define our data model with the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码定义我们的数据模型：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we can see that we allowed our data model to be insertable. However,
    we are not allowing it to be queried. We want to ensure that when a user is retrieved
    from the database, their ID is present. We could move on to defining the general
    data model for users, but this is not secure. We need to ensure that our passwords
    are protected by hashing them. If you remember from [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039),
    *Designing Your Web Application in Rust*, we utilized traits to allow certain
    to-do structs to perform actions. Some structs could create, while others could
    delete based on the traits that they implemented. We are locking down the functionality
    of our `NewUser` struct here by just implementing the `Insertable` trait. However,
    we will enable querying by implementing other traits for the `User` struct, as
    shown in the following figure:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们允许我们的数据模型可插入。然而，我们不允许它被查询。我们想要确保当从数据库中检索用户时，他们的ID是存在的。我们本可以继续定义用户的通用数据模型，但这并不安全。我们需要确保通过加密来保护我们的密码。如果你还记得[第2章](B18722_02.xhtml#_idTextAnchor039)，*在Rust中设计您的Web应用程序*，我们利用特性允许某些待办事项结构执行操作。一些结构可以创建，而其他结构可以根据它们实现的特性进行删除。我们在这里通过仅实现`Insertable`特性来锁定`NewUser`结构的函数。然而，我们将通过为`User`结构实现其他特性来启用查询，如图下所示：
- en: '![Figure 7.1 – Locking down data model structs with traits](img/Figure_7.1_B18722.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 使用特性锁定数据模型结构](img/Figure_7.1_B18722.jpg)'
- en: Figure 7.1 – Locking down data model structs with traits
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 使用特性锁定数据模型结构
- en: Now that we have created the struct that inserts new users into the database,
    we can explore how to store our users’ passwords in the database.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了将新用户插入数据库的结构，我们可以探索如何在数据库中存储我们的用户密码。
- en: You may have wondered why you cannot recover forgotten passwords; you can only
    reset them. This is because the password is *hashed*. Hashing passwords is a common
    practice when it comes to storing them. This is where we use an algorithm to obfuscate
    a password so that it cannot be read. Once this is done, it cannot be reversed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么你不能恢复忘记的密码；你只能重置它们。这是因为密码被*加密*了。加密密码是存储密码时的常见做法。这就是我们使用算法来混淆密码，使其无法被读取的地方。一旦这样做，就无法逆转。
- en: The hashed password is then stored in a database. To check the password, the
    input password is hashed and compared to the hashed password in the database.
    This allows us to see whether the input hashed password matches the hashed password
    stored in the database. This has a couple of advantages. First, it prevents employees
    who have access to your data from knowing your password. If there is a data leak,
    it also prevents the leaked data from directly exposing your password to whoever
    had the data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 加密后的密码随后被存储在数据库中。为了验证密码，输入的密码会被加密并与数据库中存储的加密密码进行比较。这使我们能够查看输入的加密密码是否与数据库中存储的加密密码相匹配。这有几个优点。首先，它防止了有权访问您数据的员工知道您的密码。如果发生数据泄露，它也防止泄露的数据直接将您的密码暴露给拥有数据的人。
- en: Considering a lot of people use the same password for multiple things (even
    though they should not), you can only imagine the damage that may be caused to
    people using your app if you are not hashing passwords and there’s a data breach.
    However, hashing gets more complicated than this. There is a concept called *salting*
    that ensures that when you hash the same password, it does not result in the same
    hash. It does this by adding an extra bit of data to the password before it is
    hashed. This is also where the `DEFAULT_COST` constant that we pass into the `hash`
    function comes in. Let’s say we got hold of the data in the database and we want
    to write code that will guess the passwords we have in the data. If we have enough
    computing power, we could effectively guess the password. Therefore, we can pass
    in a cost parameter. As we increase the cost parameter, the amount of work in
    either CPU time or memory increases exponentially. Increasing the cost factor
    by one will increase the number of operations needed to compute the hash by 10,000
    or even more.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到很多人使用相同的密码进行多项操作（尽管他们不应该这样做），如果你不散列密码并且发生数据泄露，你可以想象这将对使用你应用程序的人造成多大的损害。然而，散列比这更复杂。有一个叫做
    *盐值* 的概念，确保当你散列相同的密码时，不会得到相同的散列结果。它是通过在散列之前向密码中添加额外的数据来实现的。这也是我们传递给 `hash` 函数的
    `DEFAULT_COST` 常量所在的地方。假设我们获得了数据库中的数据，并想编写代码来猜测数据中的密码。如果我们有足够的计算能力，我们实际上可以猜测密码。因此，我们可以传递一个成本参数。随着成本参数的增加，无论是
    CPU 时间还是内存的工作量都会呈指数增长。将成本因子增加一个单位将使计算散列所需的操作数量增加 10,000 或更多。
- en: Explaining password security in more detail is beyond the scope of this book.
    However, it must be stressed that password hashing is always a must when storing
    passwords. Luckily, there is a range of modules in all major languages that enable
    you to hash and check passwords with just a few lines of code. Rust is no different
    here.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 详细解释密码安全性超出了本书的范围。然而，必须强调的是，在存储密码时，密码散列始终是必须的。幸运的是，所有主流语言中都有一系列模块，只需几行代码即可实现密码的散列和检查。Rust
    也不例外。
- en: 'To ensure that we can insert our new users into the database with hashed passwords,
    follow these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们可以将新的用户以散列密码的形式插入到数据库中，请按照以下步骤操作：
- en: 'First, we will have to ensure that the input password is hashed in our `NewUser`
    constructor, which is defined as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须确保在 `NewUser` 构造函数中散列输入密码，它定义如下：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we used the `hash` function from the `bcrypt` crate to hash our password,
    where we also passed in the `DEFAULT_COST` constant. We also created a unique
    ID using the `Uuid` crate and then constructed a new instance of the `NewUser`
    struct with those attributes. In our app, there is no real need for a unique ID.
    However, these can come in handy if you are communicating between multiple servers
    and databases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `bcrypt` 包中的 `hash` 函数来散列我们的密码，其中我们还传递了 `DEFAULT_COST` 常量。我们还使用 `Uuid`
    包创建了一个唯一的 ID，然后使用这些属性构造了一个新的 `NewUser` 结构体实例。在我们的应用程序中，实际上并不需要一个唯一的 ID。然而，这些在多个服务器和数据库之间通信时可能会很有用。
- en: 'Now that we have defined our `NewUser` data model, we can define our general
    user data model in the `user.rs` file with the following code. First, we must
    define the following imports:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的 `NewUser` 数据模型，我们可以在 `user.rs` 文件中使用以下代码定义我们的通用用户数据模型。首先，我们必须定义以下导入：
- en: '[PRE19]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we can see that we are using the `verify` function and that we are also
    allowing the general user data model struct to be queryable and identifiable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们正在使用 `verify` 函数，并且我们还允许通用用户数据模型结构体可查询和可识别。
- en: 'With the imports defined in the previous step, we can build our `User` struct.
    Remember, this is a struct that is going to be loaded from our database when we
    make database queries. Before you read further, this is a good time to try and
    build the `User` struct yourself, as it uses the same table as the `NewUser` struct
    but has an `id` field and is queried instead of inserted. Once you have built
    your `User` struct, it should look like the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步定义的导入之后，我们可以构建我们的 `User` 结构体。记住，这是一个在我们进行数据库查询时将从数据库中加载的结构体。在你继续阅读之前，这是一个尝试自己构建
    `User` 结构体的好时机，因为它使用与 `NewUser` 结构体相同的表，但有一个 `id` 字段，并且是查询而不是插入。一旦你构建了你的 `User`
    结构体，它应该看起来像以下代码：
- en: '[PRE23]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can see that we just added the `id` field and derived the `Queryable` trait
    instead of the `Insertable` trait.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们只是添加了 `id` 字段，并推导了 `Queryable` 特性而不是 `Insertable` 特性。
- en: 'Now that our `User` struct has been defined, we can build a function that verifies
    whether an input password matches the password belonging to the user with the
    following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`User`结构体，我们可以构建一个函数来验证输入的密码是否与用户的密码匹配，以下代码所示：
- en: '[PRE32]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that our models have been defined, we must remember to register them in
    the `models/user/mod.rs` file with the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了模型，我们必须记住在`models/user/mod.rs`文件中使用以下代码注册它们：
- en: '[PRE38]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Furthermore, we can make these modules accessible to the app by adding the
    following line to the `models/mod.rs` file:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们可以通过在`models/mod.rs`文件中添加以下行来使这些模块对应用程序可用：
- en: '[PRE40]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With that, our data models for the users have been defined. However, we still
    need to link them to our to-do items.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经定义了针对用户的数据模型。然而，我们仍然需要将它们与我们的待办事项链接起来。
- en: Altering the to-do item data model
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改待办事项数据模型
- en: 'To link data models to our to-do items, we must alter our to-do data models.
    There are multiple ways in which we can do this. For instance, we can add a `user_id`
    field to the item table that is just the `unique_id` field of the user table.
    When we are creating a new item, we then pass the unique ID of the user into the
    item constructor. This is easy to implement; however, it does have risks. Merely
    passing the unique ID of the user into the item does not enforce that the ID of
    the user is valid and in the database. There is nothing stopping us from inserting
    an ID of a deleted user into the item constructor and thus inserting an orphaned
    item into the database. This will then be hard to extract later, as we have no
    reference to the user ID that the orphaned item is associated with. We can also
    create a new table that references the user’s ID with the item ID, as shown in
    the following figure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据模型链接到我们的待办事项，我们必须修改我们的待办事项数据模型。我们可以通过多种方式来实现这一点。例如，我们可以在项目表中添加一个`user_id`字段，它只是用户表中的`unique_id`字段。当我们创建一个新的项目时，我们就会将用户的唯一ID传递给项目构造函数。这很容易实现；然而，它确实存在风险。仅仅将用户的唯一ID传递给项目并不能强制执行该ID是有效的并且在数据库中。没有任何东西阻止我们将已删除用户的ID插入到项目构造函数中，从而将孤立的项目插入到数据库中。这将使得以后很难提取，因为我们没有关于孤立项目关联的用户ID的引用。我们还可以创建一个新表，该表通过用户ID引用项目ID，如下所示：
- en: '![Figure 7.2 – A separate database table for logging item associations with
    users](img/Figure_7.2_B18722.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 用于记录用户与项目关联的独立数据库表](img/Figure_7.2_B18722.jpg)'
- en: Figure 7.2 – A separate database table for logging item associations with users
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 用于记录用户与项目关联的独立数据库表
- en: 'The advantage of this is that it is easy to decouple the users from the items
    by merely dropping the table. However, it also does not have valid user ID enforcement
    or item ID enforcement when creating a new entry. We will also have to make two
    queries, one to the association table and then another to the item table to get
    the items from the user. As the previous two methods of attaching a user ID column
    to the items table or creating a bridge table holding an item ID and user unique
    ID are easy to implement, we will not explore them; you should be able to implement
    them yourself at this point. In the context of the to-do application, the previous
    two methods would be subpar, as they offer us no benefits yet introduce the risk
    of errors when inserting data into our database. This does not mean that the two
    previous methods should never be used. The data needs for each project are different.
    In our project, we will create a foreign key to link our users to items, as shown
    in the following figure:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，只需删除表就可以轻松地将用户与项目解耦。然而，它也没有在创建新条目时对有效用户ID或项目ID进行强制执行。我们还将不得不进行两次查询，一次是关联表，然后是项目表，以从用户那里获取项目。由于前两种方法（将用户ID列附加到项目表或创建包含项目ID和用户唯一ID的桥梁表）易于实现，我们不会探讨它们；你应该能够在这个阶段自己实现它们。在待办事项应用程序的上下文中，前两种方法将是不够好的，因为它们没有提供任何好处，却在将数据插入我们的数据库时引入了错误的风险。这并不意味着前两种方法永远不会被使用。每个项目的数据需求都是不同的。在我们的项目中，我们将创建一个外键来将我们的用户与项目链接起来，如下所示：
- en: '![Figure 7.3 – Foreign key association between our user and items](img/Figure_7.3_B18722.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 用户与项目之间的外键关联](img/Figure_7.3_B18722.jpg)'
- en: Figure 7.3 – Foreign key association between our user and items
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 用户与项目之间的外键关联
- en: 'This does not allow us to access the items associated with a user with one
    database call, but we are only allowed to insert items that have a reference to
    a legitimate user ID in the database. Foreign keys can also trigger cascade events
    where, if we delete a user, this will automatically delete all existing items
    associated with the user to prevent orphan items from being created. We create
    a foreign key by declaring the link to the table with a macro. In `models/item/item.rs`,
    we can achieve this by initially having the following imports:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这不允许我们通过一个数据库调用访问与用户关联的项目，但我们只能插入具有合法用户 ID 引用的项目。外键也可以触发级联事件，如果在删除用户时，这将自动删除与该用户关联的所有现有项目，以防止创建孤儿项目。我们通过声明与表的链接宏来创建外键。在
    `models/item/item.rs` 中，我们可以通过以下方式实现：
- en: '[PRE42]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can see that we must import the `User` struct, as we will be referencing
    it in the `belongs_to` macro to claim that our `Item` struct belongs to the `User`
    struct, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们必须导入 `User` 结构体，因为我们将在 `belongs_to` 宏中引用它，以声明我们的 `Item` 结构体属于 `User`
    结构体，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we can see that we imported the user data model struct, defined it with
    a `belongs_to` macro, and added a `user_id` field to link the struct. Note that
    the `belongs_to` macro will not be callable if we do not include the `Associations`
    macro.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们导入了用户数据模型结构体，使用 `belongs_to` 宏进行了定义，并添加了一个 `user_id` 字段来链接结构体。请注意，如果我们没有包含
    `Associations` 宏，`belongs_to` 宏将无法调用。
- en: 'One last thing we need to do is add the `user_id` field to the fields and constructor
    in the `models/item/new_item.rs` file. We need to do this so that we can link
    the new to-do item to the user creating the item. This can be achieved by using
    the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是在 `models/item/new_item.rs` 文件中的字段和构造函数中添加 `user_id` 字段。我们需要这样做，以便可以将新的待办事项与创建该项目的用户链接起来。这可以通过以下代码实现：
- en: '[PRE44]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, taking stock of what we have done, all our data model structs have been
    altered, and we are able to use them as and when we need them in the app when
    interacting with the database. However, we have not updated our database, and
    we have not updated the bridge connecting the app to the database. We will do
    this next.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结我们所做的，所有我们的数据模型结构体都已更改，并且我们能够在与数据库交互时，根据需要使用它们在应用程序中。然而，我们尚未更新数据库，也尚未更新连接应用程序和数据库的桥梁。我们将在下一步这样做。
- en: Updating the schema file
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新模式文件
- en: 'To make sure that the mapping from the data model struct to the database is
    up to date, we must update our schema with these changes. This means that we must
    alter the existing schema for the to-do item table and add a user schema to the
    `src/schema.rs` file. This is denoted by the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保数据模型结构体到数据库的映射是最新的，我们必须使用这些更改更新我们的模式。这意味着我们必须更改待办事项项表的现有模式，并在 `src/schema.rs`
    文件中添加用户模式。这由以下代码表示：
- en: '[PRE45]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It must be noted that our fields in the schema file are defined in the same
    order as the Rust data models. This is important because, if we do not do this,
    the fields will be mismatched when we’re connecting to the database. We might
    also realize that our schema is merely just defining the fields and their type;
    it is not covering the relationship between the to-do table and the user table.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，在模式文件中，我们的字段定义的顺序与 Rust 数据模型相同。这一点很重要，因为如果我们不这样做，当我们连接到数据库时，字段将不匹配。我们可能还会意识到，我们的模式仅仅只是定义了字段及其类型；它并没有涵盖待办事项表和用户表之间的关系。
- en: We do not have to worry about this because when we create and run our own migrations,
    this schema file will be updated with the relationship. This leads us to create
    our own migrations to complete this schema file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心这个问题，因为当我们创建和运行自己的迁移时，这个模式文件将随着关系的更新而更新。这导致我们创建自己的迁移来完成这个模式文件。
- en: Creating and running migration scripts on the database
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数据库上创建和运行迁移脚本
- en: 'Running migrations has a similar process to what we covered in [*Chapter 6*](B18722_06.xhtml#_idTextAnchor127),
    *Data Persistence with PostgreSQL*, which covered how to install the Diesel client
    and connect to the database. First, we must run our database with the `docker-compose`
    command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行迁移的过程与我们之前在 [*第 6 章*](B18722_06.xhtml#_idTextAnchor127) 中讨论的类似，即 *使用 PostgreSQL
    进行数据持久化*，该章节介绍了如何安装 Diesel 客户端并连接到数据库。首先，我们必须使用 `docker-compose` 命令运行我们的数据库：
- en: '[PRE46]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will need this running in the background when we run the migration. We can
    then create the migration scripts by running the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行迁移时，我们需要在后台运行这个程序。然后我们可以通过运行以下命令来创建迁移脚本：
- en: '[PRE47]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This creates a directory in the migrations, which includes `create_users` in
    the username of the directory. Inside this directory, we have two blank *SQL*
    files. Here, we will manually write our own SQL scripts for the migrations. Initially,
    you might find this unnecessary, as there are libraries in other languages that
    automatically generate these migrations, but there are some advantages to doing
    this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这在迁移目录中创建了一个目录，目录的名称包含`create_users`。在这个目录内，我们有两个空的*SQL*文件。在这里，我们将手动编写自己的SQL脚本用于迁移。最初，你可能会觉得这没有必要，因为其他语言中有库可以自动生成这些迁移，但这样做有一些优点。
- en: 'irst, it keeps our hand in SQL, which is another handy tool. This enables us
    to think about solutions that utilize SQL in the day-to-day problems that we are
    trying to solve. It also gives us more fine-grained control of how migrations
    flow. For instance, in the migration that we are going to create, we are going
    to have to create the user table and then a base user so that when we alter the
    column in the `to_do` table, we can fill it with the ID of the placeholder user
    row. We carry this out in our `up.sql` file with the following table definition:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它让我们保持对SQL的熟悉，SQL是另一个实用的工具。这使得我们能够在解决日常问题时考虑利用SQL的解决方案。它还让我们能够更细致地控制迁移的流程。例如，在我们将要创建的迁移中，我们需要创建用户表和基础用户，这样当我们修改`to_do`表中的列时，我们可以用占位符用户行的ID来填充它。我们通过以下表定义在我们的`up.sql`文件中执行这一操作：
- en: '[PRE48]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is straightforward. Note that the `email` and `username` fields are unique.
    This is because we do not want users with duplicate usernames and emails. It’s
    good to put the constraint in at this level for several reasons. For instance,
    we could protect against this by doing a database call of the username and email
    and refusing to insert a new user if there is duplication.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。注意，`email`和`username`字段是唯一的。这是因为我们不希望有重复用户名和电子邮件的用户。在这个级别上放置约束有多个原因。例如，我们可以通过数据库调用用户名和电子邮件来防止这种情况，如果存在重复，则拒绝插入新用户。
- en: However, there may be an error in the code, or someone might alter our code
    in the future. A new feature might be introduced that doesn’t have this check,
    such as an edit feature. There might be a migration that alters rows or inserts
    new users. It is usually best practice, if you are writing your own SQL, to ensure
    that you use the `;` symbol to indicate that the operation has finished.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码中可能存在错误，或者有人可能在将来修改我们的代码。可能会引入一个新功能，这个功能没有这个检查，比如编辑功能。可能会有一个迁移修改行或插入新用户。如果你自己编写SQL，通常最好的做法是确保你使用`;`符号来表示操作已经完成。
- en: 'This SQL command is fired, and then the next command is fired afterward. Our
    next command in the `up.sql` file inserts a placeholder user row with the following
    command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个SQL命令被触发，然后紧接着下一个命令被触发。在我们的`up.sql`文件中，下一个命令插入了一个占位符用户行，使用以下命令：
- en: '[PRE49]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that we have created our user, we then alter our `to_do` table. We can
    do this with the following command, in the same file under the previous command
    we just wrote:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用户，然后我们修改`to_do`表。我们可以使用以下命令来完成这个操作，在刚刚写的命令相同的文件下：
- en: '[PRE50]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With that, our `up.sql` migration has been defined. Now, we must define our
    `down.sql` migration. With the down migration, we basically must reverse what
    we did in the up migrations. This means dropping the `user_id` column in the `to_do`
    table and then dropping the user table entirely. This can be done with the following
    SQL code in the `down.sql` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的`up.sql`迁移已经被定义。现在，我们必须定义我们的`down.sql`迁移。在向下迁移中，我们基本上必须撤销向上迁移中做的操作。这意味着在`to_do`表中删除`user_id`列，然后完全删除用户表。这可以通过在`down.sql`文件中的以下SQL代码来完成：
- en: '[PRE51]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We must keep in mind that Docker must be running for the migration to influence
    the database. Once this migration is run, we can see that the following code has
    been added to the `src/schema.rs` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，Docker必须运行，以便迁移能够影响数据库。一旦运行了这个迁移，我们可以看到以下代码已经被添加到了`src/schema.rs`文件中：
- en: '[PRE52]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This enables our Rust data models to make queries concerning the relationship
    between users and to-do items. With this migration finished, we can run our app
    again. However, before we do that, there is just one slight alteration that we
    have to make in the `src/views/to_do/create.rs` file, where the constructor of
    the new item in the `create` view function adds the default user ID with the following
    line of code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的Rust数据模型能够查询用户和待办事项之间的关系。随着这次迁移的完成，我们可以再次运行我们的应用程序。然而，在我们这样做之前，我们只需要在`src/views/to_do/create.rs`文件中进行一个小小的修改，在`create`视图函数中的新项构造函数添加以下行代码：
- en: '[PRE53]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Running our app now will result in the same behavior we described in [*Chapter
    6*](B18722_06.xhtml#_idTextAnchor127), *Data Persistence with PostgreSQL*, in
    that our app is running with the migrations that we have made. However, we also
    need to see whether our constructor for the new user works as we hash the password
    and generate the unique ID.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们的应用程序将导致与我们在[*第6章*](B18722_06.xhtml#_idTextAnchor127)中描述的行为相同，即我们的应用程序正在运行我们已制作的迁移。然而，我们还需要查看我们的新用户构造函数是否正常工作，因为我们正在散列密码并生成唯一的ID。
- en: 'To do this, we need to build a create user endpoint. For this, we must define
    the schema, and then a view that inserts that new user into the database. We can
    create our schema in the `src/json_serialization/new_user.rs` file with the following
    code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要构建一个创建用户端点。为此，我们必须定义模式，然后定义一个视图，将新用户插入到数据库中。我们可以在`src/json_serialization/new_user.rs`文件中使用以下代码创建我们的模式：
- en: '[PRE54]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After this, we can declare the new user schema in our `src/json_serialization/mod.rs`
    file with `pub mod new_user;`. Once our schema has been defined, we can create
    our own user view module with the following file structure:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以在`src/json_serialization/mod.rs`文件中声明新的用户模式`pub mod new_user;`。一旦我们的模式被定义，我们可以创建自己的用户视图模块，其文件结构如下：
- en: '[PRE55]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In our `users/create.rs` file, we need to build a create view function. First,
    import the following crates:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`users/create.rs`文件中，我们需要构建一个创建视图函数。首先，导入以下crate：
- en: '[PRE56]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Since we have been building our views multiple times now, none of these imports
    should be surprising. We import the `diesel` macros and crate to enable us to
    make calls to the database. We then import the `actix_web` traits and structs
    to enable data to flow in and out of the view. We then import our schemas and
    structs to structure the data that we are receiving and processing. Now that we’ve
    imported the correct crates, we must define the `create` view function with the
    following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经多次构建我们的视图，因此这些导入不应该令人惊讶。我们导入`diesel`宏和crate，以便我们能够调用数据库。然后我们导入`actix_web`特性和结构体，以使数据能够流入和流出视图。接着我们导入我们的模式和结构体，以结构化我们接收和处理的数据。现在我们已经导入了正确的crate，我们必须使用以下代码定义`create`视图函数：
- en: '[PRE57]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we can see that we accept JSON data that is loaded into the `NewUserSchema`
    struct. We also establish a database connection from the connection pool with
    the `DB` struct. Inside our `create` view function, we extract the data that we
    need from the `NewUserSchema` struct to create a `NewUser` struct with the following
    code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们接受加载到`NewUserSchema`结构体的JSON数据。我们还使用`DB`结构体从连接池中建立数据库连接。在我们的`create`视图函数内部，我们从`NewUserSchema`结构体中提取所需的数据，使用以下代码创建一个`NewUser`结构体：
- en: '[PRE58]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We must clone the fields to be passed into the `NewUser` constructor because
    strings do not implement the `Copy` trait, meaning we must do this manually. We
    then create our `insert` command for the database and execute it with the following
    code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须克隆要传递给`NewUser`构造函数的字段，因为字符串没有实现`Copy`特性，这意味着我们必须手动完成此操作。然后我们创建数据库的`insert`命令并执行以下代码：
- en: '[PRE59]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This returns a `Result` struct. However, we do not unwrap it directly. There
    could be a conflict. For instance, we could be trying to insert a new user with
    a username or email that is already in the database. However, we do not want this
    to just error out. This is an edge case that we will expect as we have implemented
    the unique username and email constraint ourselves. If there was a legitimate
    error that happens when the view is being executed, we need to know about it.
    Therefore, we must give response codes to the edge cases. Therefore, we match
    the result of the insert and return the appropriate response code with the following
    code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个`Result`结构体。然而，我们并不直接`unwrap`它。可能存在冲突。例如，我们可能正在尝试插入一个已经存在于数据库中的用户名或电子邮件的新用户。然而，我们不想让它仅仅出错。这是一个我们预期作为我们已经实现了唯一的用户名和电子邮件约束的边缘情况。如果在视图执行过程中发生了一个合法的错误，我们需要知道它。因此，我们必须给边缘情况提供响应代码。因此，我们匹配插入的结果，并使用以下代码返回适当的响应代码：
- en: '[PRE60]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we have established a database connection, extracted the fields from the
    JSON body, created a new `NewUser` struct, and then inserted it into the database.
    There is a slight difference here compared to the other views. In the return response,
    we are having to *await* and then *unwrap* it. This is because we are not returning
    a JSON body. Therefore, `HttpResponse::Ok()` is merely a builder struct.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经建立了一个数据库连接，从JSON体中提取了字段，创建了一个新的`NewUser`结构体，然后将其插入到数据库中。与其它视图相比，这里有一个细微的差别。在返回响应中，我们必须先`await`然后`unwrap`它。这是因为我们不返回JSON体。因此，`HttpResponse::Ok()`仅仅是一个构建器结构体。
- en: 'Now that we have built our create view, we need to define our view factory
    in the `views/users/mod.rs` file, like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了创建视图，我们需要在`views/users/mod.rs`文件中定义我们的视图工厂，如下所示：
- en: '[PRE61]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Again, since we have been building views regularly, none of this should come
    as a surprise to you. If it does, it is recommended that you read the *Managing
    views using the Actix Web framework* section in [*Chapter 3*](B18722_03.xhtml#_idTextAnchor059),
    *Handling HTTP Requests*, for clarity. Now, our main views factory in the `views/mod.rs`
    file should look like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于我们一直在定期构建视图，这些内容对你来说不应该感到意外。如果确实如此，建议你阅读[*第3章*](B18722_03.xhtml#_idTextAnchor059)中“使用Actix
    Web框架管理视图”部分，*处理HTTP请求*，以获得清晰度。现在，我们的主视图工厂在`views/mod.rs`文件中应该看起来如下：
- en: '[PRE62]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we have registered our user view, we can run our app and create our
    user with the following Postman call:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注册了我们的用户视图，我们可以运行我们的应用程序，并使用以下Postman调用创建我们的用户：
- en: '![Figure 7.4 – Postman call to our create user endpoint](img/Figure_7.4_B18722.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 向我们的创建用户端点发送邮递员调用](img/Figure_7.4_B18722.jpg)'
- en: Figure 7.4 – Postman call to our create user endpoint
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 向我们的创建用户端点发送邮递员调用
- en: 'With this, we should get a `201` created response. If we call the exact same
    call again, we should get a `409` conflict. With this, we should expect that our
    new user has been created. With the steps covered in the *Connecting to PostgreSQL
    with Diesel* section in [*Chapter 6*](B18722_06.xhtml#_idTextAnchor127), *Data
    Persistence with PostgreSQL*, we can inspect the database in our Docker container,
    which gives us the following printout:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该得到一个`201`创建响应。如果我们再次调用完全相同的调用，我们应该得到一个`409`冲突。因此，我们应该期待我们的新用户已经被创建。根据[*第6章*](B18722_06.xhtml#_idTextAnchor127)中“使用Diesel连接PostgreSQL”部分所涵盖的步骤，*使用PostgreSQL进行数据持久化*，我们可以在我们的Docker容器中检查数据库，以下是我们得到的结果：
- en: '[PRE63]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we can see the initial user that was created in our migration. However,
    we can also see the user we created via our view. Here, we have a hashed password
    and a unique ID. From this, we can see that we should never directly create our
    user; we should only create a user through the constructor function belonging
    to the `NewUser` struct.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到在我们的迁移中创建的初始用户。然而，我们也可以看到我们通过视图创建的用户。这里有一个散列密码和唯一的ID。从这一点我们可以看出，我们永远不应该直接创建我们的用户；我们只应该通过`NewUser`结构体所属的构造函数创建用户。
- en: In the context of our app, we do not really need a unique ID. However, in wider
    situations where multiple servers and databases are used, a unique ID can become
    useful. We also must note that our conflict response on the second one was correct;
    the third replica create user call, did not insert a replica user into the database.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的上下文中，我们实际上并不需要一个唯一的ID。然而，在更广泛的情况下，当使用多个服务器和数据库时，一个唯一的ID可能变得很有用。我们还必须注意，我们第二个冲突响应是正确的；第三个副本创建用户调用，并没有将副本用户插入到数据库中。
- en: With this, our app is running as normal, since there is now a user table with
    user models linked to the to-do items. Thus, we can create other data tables with
    relationships and structure migrations so that they can be seamlessly upgraded
    and downgraded. We have also covered how to verify and create passwords. However,
    we have not actually written any code that checks whether the user is passing
    the right credentials. In the next section, we will work on authenticating users
    and rejecting requests that do not contain the right credentials.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们的应用程序正在正常运行，因为现在有一个用户表，其中包含与待办事项关联的用户模型。因此，我们可以创建其他具有关系和结构迁移的数据表，以便它们可以无缝升级和降级。我们也已经涵盖了如何验证和创建密码。然而，我们实际上并没有编写任何检查用户是否传递正确凭证的代码。在下一节中，我们将致力于验证用户并拒绝不包含正确凭证的请求。
- en: Authenticating our users
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证我们的用户
- en: 'When it comes to authenticating our users, we have built a struct that extracts
    a message from the header of the HTTP request. We are now at the stage where we
    can make real use of this extraction by storing data about the user in the header.
    Right now, there is nothing stopping us from storing the username, ID, and password
    in the header of each HTTP request so that we can authenticate each one. However,
    this is a terrible practice. If someone intercepts the request or gets hold of
    the data stored in the browser to facilitate this, then the account is compromised
    and the hacker can do whatever they want. Instead, we are going to obfuscate the
    data, as shown in the following figure:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到验证我们的用户时，我们已经构建了一个结构，用于从HTTP请求的头部提取消息。我们现在已经到了可以真正利用这种提取，将有关用户的数据存储在头部的时候了。目前，没有任何东西阻止我们在每个HTTP请求的头部存储用户名、ID和密码，以便我们可以验证每一个。然而，这是一个糟糕的做法。如果有人拦截请求或获取存储在浏览器中以方便此操作的数据，那么账户就会受到损害，黑客可以随心所欲地做任何事情。相反，我们将对数据进行混淆，如下面的图所示：
- en: '![Figure 7.5 – Steps for authenticating requests](img/Figure_7.5_B18722.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 验证请求的步骤](img/Figure_7.5_B18722.jpg)'
- en: Figure 7.5 – Steps for authenticating requests
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 验证请求的步骤
- en: 'In *Figure 7**.5*, we can see that we use a secret key to serialize the structured
    data that we have on the user into a token that is in bytes. We then give the
    token to the user to store in the browser. When the user wants to make an authorized
    request, the user must send the token in the header of the request. Our server
    then uses the secret key to deserialize the token back into structured data about
    the user. The algorithms used to do this process are standard hashing algorithms
    that are available to anyone. Therefore, we have a secret key that we define to
    keep the tokens out in the wild safe. For our application to carry out the processes
    laid out in *Figure 7**.5*, we are going to have to rewrite most of our `src/jwt.rs`
    file, including the `JwToken` struct. Before we start, we need to update our `Cargo.toml`
    dependencies with the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图7.5**中，我们可以看到我们使用一个密钥将有关用户的结构化数据序列化为字节形式的令牌。然后我们将令牌给用户，让他们存储在浏览器中。当用户想要发送授权请求时，用户必须在请求的头部发送令牌。然后我们的服务器使用密钥将令牌反序列化为有关用户的结构化数据。这个过程所使用的算法是任何人都可以获得的标准哈希算法。因此，我们有一个定义的密钥，以保持令牌在野外安全。为了我们的应用程序执行图7.5中概述的过程，我们可能需要重写大部分`src/jwt.rs`文件，包括`JwToken`结构体。在我们开始之前，我们需要使用以下代码更新我们的`Cargo.toml`依赖项：
- en: '[PRE64]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can see that we have added the `serde` features to the `chrono` crate and
    added the `jsonwebtoken` crate. To rebuild the `JwToken` struct, we need to import
    the following in the `src/jwt.rs` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经将`serde`功能添加到`chrono`包中，并添加了`jsonwebtoken`包。为了重建`JwToken`结构体，我们需要在`src/jwt.rs`文件中导入以下内容：
- en: '[PRE65]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can see that we import `actix_web` traits and structs to enable the processing
    of the requests and responses. We then import `futures` to enable us to handle
    the interception of the HTTP request before it hits the views. We then import
    `serde` and `jsonwebtoken` to enable the serialization and deserialization of
    data to and from the token. We then import the `chrono` crate because we want
    to log when these tokens are minted. We also need to have the key for the serialization,
    and we get this from the config file, which is why we import the `Config` struct.
    Now that we have imported all the traits and structs that we need, we can write
    our token struct with the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们导入了`actix_web`特性和结构体，以启用请求和响应的处理。然后我们导入`futures`，以便我们能够在HTTP请求击中视图之前拦截它。然后我们导入`serde`和`jsonwebtoken`，以启用数据到和从令牌的序列化和反序列化。然后我们导入`chrono`
    crate，因为我们想记录这些令牌何时被铸造。我们还需要序列化的密钥，我们从这个配置文件中获取它，这就是为什么我们导入`Config`结构体的原因。现在我们已经导入了所有需要的特性和结构体，我们可以用以下代码编写我们的令牌结构体：
- en: '[PRE66]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here, we can see that we have the ID of the user, and we also have the date-time
    of when the token was created. We also decorate our `minted` field with a `serde`
    macro to state how we are going to serialize the `datetime` field. Now that we
    have the data that we need for the token, we can move on to defining the serialization
    functions with the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们有用户的ID，我们还有令牌创建的日期和时间。我们还用`serde`宏装饰我们的`minted`字段，以说明我们将如何序列化`datetime`字段。现在我们已经有了令牌所需的数据，我们可以继续定义序列化函数，以下代码：
- en: '[PRE67]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can explain what each one of the preceding functions does with the following
    bullet points:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下项目符号解释前面每个函数的作用：
- en: '`get_key`: Gets the secret key for the serialization and deserialization from
    the `config.yml` file.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_key`：从`config.yml`文件获取序列化和反序列化的密钥'
- en: '`encode`: Encodes the data from the `JwToken` struct as a token'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encode`：将`JwToken`结构体的数据编码为令牌'
- en: '`new`: Creates a new `JwToken` struct'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`：创建一个新的`JwToken`结构体'
- en: '`from_token`: Creates a `JwToken` struct from a token. If there is a failure
    in the deserialization it returns a `None` as there can be failures in deserialization.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from_token`：从令牌创建一个`JwToken`结构体。如果反序列化失败，它返回`None`，因为反序列化可能会失败。'
- en: 'Once we have built the preceding functions, our `JwToken` struct will be able
    to handle tokens as and when we see fit. We flesh out the `get_key` function with
    the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了前面的函数，我们的`JwToken`结构体将能够根据我们的需要处理令牌。我们用以下代码完善`get_key`函数：
- en: '[PRE68]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here, we can see that we load the key from the config file. Therefore, we need
    to add the key to the `config.yml` file, resulting in our file looking like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们从配置文件中加载密钥。因此，我们需要将密钥添加到`config.yml`文件中，这样我们的文件看起来就像这样：
- en: '[PRE69]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If our server is in production, we should have a better secret key. However,
    for local development, this will work fine. Now that we are extracting the key
    from the config file, we can define our `encode` function with the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务器在生产环境中，我们应该有一个更好的密钥。然而，对于本地开发，这将足够好。现在我们已经从配置文件中提取了密钥，我们可以用以下代码定义我们的`encode`函数：
- en: '[PRE70]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, we can see that we have defined an encoding key using the secret key
    from the config file. We then use this key to encode the data from the `JwToken`
    struct into a token and return it. Now that we can encode our `JwToken` struct,
    we will need to create new `JwToken` structs when we need them, which can be achieved
    by the following `new` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们使用配置文件中的密钥定义了一个编码密钥。然后我们使用这个密钥将`JwToken`结构体的数据编码成令牌并返回它。现在我们能够编码我们的`JwToken`结构体，当我们需要时，我们将需要创建新的`JwToken`结构体，这可以通过以下`new`函数实现：
- en: '[PRE71]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With the constructor, we know when our `JwToken` is minted. This can help us
    manage our user sessions if we want. For instance, if the token’s age exceeds
    a threshold that we deem appropriate, we can force another login.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数，我们知道我们的`JwToken`何时被铸造。如果我们想的话，这可以帮助我们管理用户会话。例如，如果令牌的年龄超过我们认为合适的阈值，我们可以强制进行另一次登录。
- en: 'Now, all we have is the `from_token` function, where we extract the data from
    a token using the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有`from_token`函数，其中我们使用以下代码从令牌中提取数据：
- en: '[PRE72]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here, we define a decoding key and then use it to decode the token. We then
    return `JwToken` using `data.claims`. Now, our `JwToken` struct can be created,
    encoded into a token, and extracted from a token. Now, all we need to do is extract
    it from the header of an HTTP request before the view is loaded, using the following
    outline:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个解码密钥，然后使用它来解码令牌。然后我们使用`data.claims`返回`JwToken`。现在，我们的`JwToken`结构体可以创建、编码成令牌，并从令牌中提取。现在，我们只需要在视图加载之前从HTTP请求的头中提取它，以下是一个概要：
- en: '[PRE73]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We have implemented the `FromRequest` trait multiple times now for the database
    connection and the previous implementation for the `JwToken` struct. Inside the
    `from_request` function, we extract the token from the header with the following
    code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次实现了`FromRequest`特质，用于数据库连接和之前为`JwToken`结构体实现的实现。在`from_request`函数内部，我们使用以下代码从头中提取令牌：
- en: '[PRE74]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If the token is not in the header, we directly return `ErrorUnauthorized`,
    avoiding the call to the view completely. If we manage to extract the token from
    the header, we can process it with the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌不在头中，我们直接返回`ErrorUnauthorized`，完全避免调用视图。如果我们能够从头中提取令牌，我们可以使用以下代码来处理它：
- en: '[PRE75]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here, we convert the raw token extracted from the header to a string. We then
    deserialize the token and load it into the `JwToken` struct. However, if this
    fails due to a fake token being supplied, we return an `ErrorUnauthorized` error.
    Our authentication is now fully working; however, we will not be able to do anything
    because we do not have a valid token, as shown in the following figure:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从头中提取的原始令牌转换为字符串。然后我们反序列化令牌并将其加载到`JwToken`结构体中。然而，如果由于提供了伪造的令牌而失败，我们返回一个`ErrorUnauthorized`错误。现在我们的认证已经完全工作；然而，我们将无法做任何事情，因为我们没有有效的令牌，如下面的图所示：
- en: '![Figure 7.6 – Authentication blocking requests](img/Figure_7.6_B18722.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 认证阻止请求](img/Figure_7.6_B18722.jpg)'
- en: Figure 7.6 – Authentication blocking requests
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 认证阻止请求
- en: In the next section, we will build login API endpoints to enable us to interact
    with our protected endpoints.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将构建登录API端点，以便我们能够与受保护的端点交互。
- en: Managing user sessions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户会话
- en: 'For our users, we are going to have to enable them to log in. This means that
    we must create an endpoint to check their credentials and then generate a JWT
    to be returned to the user in the frontend, via the header in the response. Our
    first step is to define a login schema in the `src/json_serialization/login.rs`
    file with the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用户，我们必须让他们能够登录。这意味着我们必须创建一个端点来验证他们的凭据，然后生成一个JWT并将其通过响应头返回给用户。我们的第一步是在`src/json_serialization/login.rs`文件中定义一个登录模式，以下代码如下：
- en: '[PRE76]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We have to remember to register it in the `src/json_serialization/mod.rs` file
    with the `pub mod login;` line of code. Once we have done this, we can build our
    login endpoint. We can do this by editing the `src/views/auth/login.rs` file we
    created in the *Managing views using the Actix Web framework* section in [*Chapter
    3*](B18722_03.xhtml#_idTextAnchor059), *Handling HTTP Requests*, which declares
    our basic login view. This just returns a string.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住在`src/json_serialization/mod.rs`文件中使用`pub mod login;`代码行来注册它。一旦我们这样做，我们就可以构建我们的登录端点了。我们可以通过编辑我们在[*第3章*](B18722_03.xhtml#_idTextAnchor059)中创建的`src/views/auth/login.rs`文件来实现，该文件位于[*“使用Actix
    Web框架管理视图”*](B18722_03.xhtml#_idTextAnchor059)部分，它声明了我们的基本登录视图。这仅仅返回一个字符串。
- en: 'Now, we can start refactoring this view by defining the required imports, as
    shown in the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始重构这个视图，通过定义所需的导入，如下面的代码所示：
- en: '[PRE77]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'At this stage, we can glance at the imports and get a feel for what we are
    going to do. We are going to extract the username and password from the body.
    We are then going to connect to the database to check the user and password, and
    then use the `JwToken` struct to create the token that will be passed back to
    the user. We can initially lay out the outline of the view with the following
    code in the same file:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以浏览一下导入，了解我们将要做什么。我们将从请求体中提取用户名和密码。然后我们将连接到数据库以检查用户名和密码，接着使用`JwToken`结构体创建一个将被返回给用户的令牌。我们可以在同一文件中使用以下代码来初步布局视图的轮廓：
- en: '[PRE78]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, we can see that we accept the login credentials from the body of the
    incoming request and prepare a database connection from the connection pool for
    the view. We can then extract the details we need from the request body and make
    a database call with the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们从传入请求的正文接受登录凭证，并为视图从连接池中准备一个数据库连接。然后我们可以从请求体中提取所需的详细信息，并使用以下代码进行数据库调用：
- en: '[PRE79]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we must check to see whether we got what we expected from the database
    call with the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须检查我们是否从数据库调用中得到了预期的结果，如下面的代码所示：
- en: '[PRE80]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we have done some early returns. If there are no users, then we return
    a `not found` response code. This is something we will expect from time to time.
    However, if there is more than one user with that username, we need to return
    a different code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经进行了一些初步的返回。如果没有用户，我们将返回一个`not found`响应代码。这是我们时不时都会期待的事情。然而，如果有多个用户使用相同的用户名，我们需要返回一个不同的代码。
- en: Due to the unique constraints shown, something is very wrong. A migration script
    in the future might undo these unique constraints, or the user query might be
    altered by accident. If this happens, we need to know that this has happened right
    away, since corrupted data that goes against our constraints can cause our application
    to behave in unexpected ways that can be hard to troubleshoot.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于显示的独特约束，有些事情非常不对劲。未来的迁移脚本可能会撤销这些唯一约束，或者用户查询可能会意外地被更改。如果发生这种情况，我们需要立即知道这一点，因为违反我们约束的损坏数据可能会导致我们的应用程序以难以调试的意外方式运行。
- en: 'Now that we have checked that the right number of users have been retrieved,
    we can get the one and only user at index zero with confidence and check whether
    their password is passable, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认检索到了正确的用户数量，我们可以有信心地获取索引为零的唯一用户，并检查他们的密码是否可接受，如下所示：
- en: '[PRE81]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, we can see that we used the `verify` function. If the password is a match,
    we then generate a token using the ID and return it to the user in the body. If
    the password is not correct, we return an unauthorized code instead.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们使用了`verify`函数。如果密码匹配，我们就使用ID生成一个token，并将其返回给用户作为正文。如果密码不正确，我们则返回一个未授权代码。
- en: 'In terms of our logout, we are going to take a far more lightweight approach.
    All we must do in our logout view is run two lines of JavaScript code. One is
    to remove the user token from the local storage and then revert the user to the
    main view. HTML can just host JavaScript that gets run as soon as you open it.
    Therefore, we can achieve this by putting the following code in the `src/views/auth/logout.rs`
    file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的注销方面，我们将采取一种更轻量级的方法。在我们的注销视图中，我们只需运行两行JavaScript代码。一行是将用户token从本地存储中移除，然后恢复用户到主视图。HTML可以托管在打开时立即运行的JavaScript。因此，我们可以通过在`src/views/auth/logout.rs`文件中放置以下代码来实现这一点：
- en: '[PRE82]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Since this view is already registered, we can run the app and make the call
    with Postman:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个视图已经注册，我们可以运行应用程序并使用Postman进行调用：
- en: '![Figure 7.7 – Logging into our application using the login endpoint with Postman](img/Figure_7.7_B18722.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.7 – 使用Postman通过登录端点登录我们的应用程序](img/Figure_7.7_B18722.jpg)'
- en: Figure 7.7 – Logging into our application using the login endpoint with Postman
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.7 – 使用Postman通过登录端点登录我们的应用程序
- en: Altering the username will give us a `404-response` code, whereas altering the
    password will give us a `401-response` code. If we have the correct username and
    password, we will get a `200-response` code and there will be a *token* in the
    response of the header, as shown in *Figure 7**.7*. However, if we want to use
    our *token* in the response header, we will get a `token can't be decoded` message.
    In the next section, we are going to clean up our authentication requirements.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 修改用户名将给我们一个`404-response`代码，而修改密码将给我们一个`401-response`代码。如果我们有正确的用户名和密码，我们将得到一个`200-response`代码，并且响应头中会有一个*token*，如图*7**.7*所示。然而，如果我们想在响应头中使用我们的*token*，我们将收到一个`token
    can't be decoded`消息。在下文中，我们将清理我们的认证要求。
- en: Cleaning up authentication requirements
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理认证要求
- en: 'In this section, we are going to clean up our Rust server in terms of authentication
    before we start configuring our frontend to handle these authentication processes.
    To keep the flow of the chapter engaging, we have not regularly carried out “housekeeping.”
    Now, we are going to update our `to_do` views. We can start by updating the `create`
    view with authentication requirements. To do so, the function signature of our
    `create` view in the `src/views/to_do/create.rs` file should look like the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在开始配置前端以处理这些认证过程之前，将清理我们的Rust服务器以实现认证。为了保持章节的连贯性，我们并没有定期进行“维护”。现在，我们将更新我们的`to_do`视图。我们可以从更新带有认证要求的`create`视图开始。为此，`src/views/to_do/create.rs`文件中`create`视图的函数签名应如下所示：
- en: '[PRE83]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We also must update the user ID when creating a new item with the ID from the
    token, using the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新项目时，我们也必须使用来自令牌的ID更新用户ID，代码如下：
- en: '[PRE84]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With our `delete` view, we must ensure that we are deleting a to-do item that
    belongs to the user making the request. If we do not add a filter using the user
    ID, the deletion of the to-do item will be random. This filter can be added in
    our `src/views/to_do/delete.rs` file with the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`delete`视图中，我们必须确保我们正在删除请求用户所属的待办事项。如果我们不使用用户ID添加过滤器，待办事项的删除将是随机的。这个过滤器可以添加到我们的`src/views/to_do/delete.rs`文件中，代码如下：
- en: '[PRE85]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can see that the `filter` functions can merely be chained when making a
    database query. Considering what we have done with our `delete` view, how do you
    think we will upgrade our authentication requirements for our `edit` in the `src/views/to_do/edit.rs`
    file? At this stage, I encourage you to try and update the `edit` view yourself,
    as the approach is like our `delete` view upgrade. Once you have done this, your
    `edit` view should look like the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在执行数据库查询时，`filter`函数可以简单地串联。考虑到我们对`delete`视图所做的工作，你认为我们将在`src/views/to_do/edit.rs`文件中如何升级我们的认证要求？在这个阶段，我鼓励你自己尝试更新`edit`视图，因为方法类似于我们的`delete`视图升级。一旦你完成了这个，你的`edit`视图应该如下所示：
- en: '[PRE86]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now that we have updated our specific views, we can now move on to the `get`
    view, which also has the `get_state` function that is applied to all other views.
    Our `get` view in the `src/views/to_do/get.rs` file now takes the following form:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了特定的视图，现在我们可以继续到`get`视图，它也有应用于所有其他视图的`get_state`函数。`src/views/to_do/get.rs`文件中的`get`视图现在如下所示：
- en: '[PRE87]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, everything in the preceding code should not be a surprise. We can see
    that we pass the user ID into the `ToDoItems::get_state` function. You must remember
    to fill in the user ID everywhere the `ToDoItems::get_state` function is implemented,
    which is all the to-do views. We can then redefine our `ToDoItems::get_state`
    function in the `src/json_serialization/to_do_items.rs` file with the following
    code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前述代码中的所有内容都不应该令人惊讶。我们可以看到，我们将用户ID传递给`ToDoItems::get_state`函数。你必须记住在`ToDoItems::get_state`函数实现的所有地方填写用户ID，这包括所有待办事项视图。然后我们可以在`src/json_serialization/to_do_items.rs`文件中重新定义我们的`ToDoItems::get_state`函数，代码如下：
- en: '[PRE88]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, we can see that we have updated the database connection and the filter
    for the user ID. We have now updated our code to accommodate different users.
    There is one more change that we must make. Because we will be writing frontend
    code in our React application, we will try and keep the React coding as simple
    as possible, as React development is a book itself. To avoid over-complicating
    the frontend development of header extraction and `GET` posts using Axios, we
    will add a `Post` method to our login and return the token using the body. This
    is another good opportunity to try and solve this yourself, as we have covered
    all the concepts needed to pull this off.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经更新了数据库连接和用户ID的过滤器。我们现在已经更新了我们的代码以适应不同的用户。还有一个变化我们必须做出。因为我们将在React应用程序中编写前端代码，我们将尽量使React编码尽可能简单，因为React开发本身就是一本大书。为了避免过度复杂化前端开发中的标题提取和`GET`帖子使用Axios，我们将在登录时添加一个`Post`方法，并通过正文返回令牌。这又是一个尝试自己解决问题的好机会，因为我们已经涵盖了实现这一目标所需的所有概念。
- en: 'If you have attempted to solve this problem yourself, it should look like the
    following. First, we define a response struct in the `src/json_serialization/login_response.rs`
    file with the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试自己解决这个问题，它应该如下所示。首先，我们在`src/json_serialization/login_response.rs`文件中定义一个响应结构体，代码如下：
- en: '[PRE89]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We remember to declare the preceding struct by putting in `pub mod login_response`
    in the `src/json_serialization/mod.rs` file. We now go to our `src/views/auth/login.rs`
    and have the following `return` statement in the `login` function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记得在`src/json_serialization/mod.rs`文件中声明前面的结构体，通过添加`pub mod login_response`。我们现在转到`src/views/auth/login.rs`，在`login`函数中有以下`return`语句：
- en: '[PRE90]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may have noticed that we made a slight change to our unauthorized to the
    following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们对未授权的部分做了一些小的改动：
- en: '**HttpResponse::Unauthorized().finish()**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**HttpResponse::Unauthorized().finish()**'
- en: 'This is because we have switched our `return` type for the view function to
    an `HttpResponse` struct giving us the following function signature:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们将视图函数的`return`类型从`HttpResponse`结构体切换了，从而得到了以下函数签名：
- en: '**(credentials: web::Json<Login>, db: DB) ->** **HttpResponse**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**(credentials: web::Json<Login>, db: DB) ->** **HttpResponse**'
- en: 'We had to make the switch because adding the `json` function to our response
    turns our response from `HttpResponseBuilder` to `HttpResponse`. Once the `json`
    function has been called, `HttpResponseBuilder` cannot be used. Going back to
    the unauthored response builder, we can deduce that the `finish` function converts
    `HttpResponseBuilder` to `HttpResponse`. We can also convert our `HttpResponseBuilder`
    to `HttpResponse` by using `await`, as shown in the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须进行切换，因为将`json`函数添加到我们的响应中，将我们的响应从`HttpResponseBuilder`转换为`HttpResponse`。一旦调用了`json`函数，就不能再使用`HttpResponseBuilder`。回到未授权的响应构建器，我们可以推断出`finish`函数将`HttpResponseBuilder`转换为`HttpResponse`。我们也可以通过使用`await`将我们的`HttpResponseBuilder`转换为`HttpResponse`，如下所示：
- en: '**HttpResponse::Unauthorized().await.unwrap()**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**HttpResponse::Unauthorized().await.unwrap()**'
- en: 'Here, we can see that we return the token in the header and the body. This
    will give us flexibility and ease when writing the frontend code. However, it
    must be stressed that this is not the best practice. We are implementing the approach
    of passing the token back into the body and header to keep the frontend development
    section simple. We can then enable the `POST` method for our login view in our
    `src/views/auth/mod.rs` file with the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们在头部和体中返回了令牌。这将给我们编写前端代码时的灵活性和便捷性。然而，必须强调的是，这并不是最佳实践。我们正在实施将令牌返回到体和头部的做法，以使前端开发部分保持简单。我们可以在`src/views/auth/mod.rs`文件中为我们的登录视图启用`POST`方法，如下所示：
- en: '[PRE91]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We can see that we have merely stacked a `get` function onto the same `login`
    view. Now, `POST` and `GET` are available for our login view. We can now move
    into the next section where we configure our authentication tokens so they can
    expire. We want our tokens to expire to increase our security. If a token is compromised
    and a bad actor gets hold of a token, they will be able to do whatever they want
    for as long as they want without ever having to log in. However, if our tokens
    expire, then the bad actor only has a limited time window before the token expires.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们只是在同一个`login`视图中堆叠了一个`get`函数。现在，`POST`和`GET`都可用于我们的登录视图。我们现在可以进入下一节，配置我们的认证令牌，以便它们可以过期。我们希望令牌过期以提高我们的安全性。如果一个令牌被泄露，恶意行为者获取了令牌，他们可以无限制地做他们想做的事情，而无需登录。然而，如果我们的令牌过期，那么恶意行为者只有有限的时间窗口，在令牌过期之前。
- en: Configuring expiration of auth tokens
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置认证令牌的过期时间
- en: 'If we try and perform an API call on our now protected endpoints with a valid
    token obtained from logging in with the token in the header, we will get an unauthorized
    error. If we insert some `print` statements, we will get the following error when
    failing to decode the token:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用从登录令牌中获取的有效令牌在我们的现在受保护的端点上执行API调用，我们将得到一个未授权错误。如果我们插入一些`print`语句，在解码令牌失败时，我们会得到以下错误：
- en: '[PRE92]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This implies that there is no field called `exp` in our `JwToken` struct. If
    we reference the `jsonwebtoken` documentation at [https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html](https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html),
    we can see that the `encode` instructions never mention `exp`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在我们的`JwToken`结构体中没有名为`exp`的字段。如果我们参考[https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html](https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html)上的`jsonwebtoken`文档，我们可以看到`encode`指令从未提到`exp`：
- en: '[PRE93]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Here, we can see that there is no mention of claims. However, what is happening
    is that when we try and deserialize our token, the `decode` function in the `jsonwebtoken`
    crate is automatically looking for the `exp` field to work out when the token
    is supposed to be expired. We are exploring this because the official documentation
    and slightly confusing error message could leave you wasting hours trying to figure
    out what is going on. With this in mind, we must go back to our `src/jwt.rs` file
    for some more rewriting, but this is the last time, I promise, and it is not an
    entire rewrite. First, we ensure that the following is imported alongside what
    is already in the `src/jwt.rs` file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到没有提及任何声明。然而，实际上当我们尝试反序列化我们的令牌时，`jsonwebtoken` crate中的`decode`函数会自动寻找`exp`字段来确定令牌何时应该过期。我们正在探索这一点，因为官方文档和稍微有些令人困惑的错误信息可能会让你浪费数小时试图弄清楚发生了什么。考虑到这一点，我们必须回到我们的`src/jwt.rs`文件进行一些修改，但这是最后一次，我保证，这并不是一个完整的重写。首先，我们确保以下内容与`src/jwt.rs`文件中已有的内容一起导入：
- en: '[PRE94]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can then make sure our `JwToken` struct is written with the `exp` field
    with the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确保使用以下代码将`exp`字段写入我们的`JwToken`结构：
- en: '[PRE95]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We now must rewrite the `new` constructor method for our `JwToken` struct.
    In the `new` function, we will have to define at what time the newly minted `JwToken`
    struct has expired. This must vary; as a developer, you might want to tweak the
    time taken to timeout. Remember that we must recompile every time we change the
    Rust code; therefore, it makes sense to have the timeout period defined in the
    config file. With the variance of timeout considered, our `new` function takes
    the following form:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须重写我们的`JwToken`结构的`new`构造函数。在`new`函数中，我们必须定义新铸造的`JwToken`结构何时过期。这必须变化；作为一个开发者，你可能想要调整超时所需的时间。记住，每次我们更改Rust代码时都必须重新编译；因此，在配置文件中定义超时周期是有意义的。考虑到超时周期的变化，我们的`new`函数具有以下形式：
- en: '[PRE96]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can see that we define the number of minutes. We then convert our expiration
    as `usize` and then build our `JwToken` struct. Now that we have this, we need
    to be more specific with the type of error that we return, as it could be an error
    in the decoding of the token, or the token could be expired. We handle the different
    types of errors when decoding the token with the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们定义了分钟数。然后我们将过期时间转换为`usize`，然后构建我们的`JwToken`结构。现在我们有了这个，我们需要更具体地返回错误类型，因为这可能是令牌解码错误，或者令牌可能已过期。我们使用以下代码处理解码令牌时的不同类型的错误：
- en: '[PRE97]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here, we can see that we have switched from returning `Option` to `Result`.
    We have switched to `Result` because we are returning the message that can be
    digested and processed in our `from_request` function in the `FromRequest` trait
    implementation. The rest of the code in the `from_request` function is the same.
    Where we make the change is checking the message if there is an error and returning
    a different message to the frontend with the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经从返回`Option`切换到了`Result`。我们切换到`Result`是因为我们在`FromRequest`特质的实现中返回的消息可以被我们的`from_request`函数消化和处理。`from_request`函数中的其余代码保持不变。我们进行更改的地方是检查消息是否存在错误，并使用以下代码向前端返回不同的消息：
- en: '[PRE98]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: With the nuanced error message, our frontend code can handle and adapt, as we
    can be more specific on how we handle the errors in the frontend. Being more specific
    in the frontend can aid the user, prompting them where they went wrong. However,
    when it comes to authentication, make sure you do not give too much away because
    this can also aid bad actors trying to obtain unauthorized access. We now have
    our login and logout endpoints running; we also have token authorization on the
    views that we need. However, this is not very useful if we want a standard user
    to interact with our application, as they are unlikely to use Postman. Therefore,
    we are going to have to incorporate our login/logout endpoints in the frontend
    in the next section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 带有细微的错误信息，我们的前端代码可以处理和适应，因为我们可以在前端更具体地处理错误。在前端更具体地处理错误可以帮助用户，提示他们出错的地方。然而，当涉及到身份验证时，确保不要透露太多，因为这也可能帮助试图获取未经授权访问的恶意行为者。我们现在有我们的登录和注销端点正在运行；我们还有在需要视图上的令牌授权。然而，如果我们想要标准用户与我们的应用程序交互，这并不很有用，因为他们不太可能使用Postman。因此，在下一节中，我们必须将我们的登录/注销端点纳入前端。
- en: Adding authentication into our frontend
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将身份验证添加到我们的前端
- en: 'We incorporate our login functionality. We must start off by building the login
    form in the `src/components/LoginForm.js` file. First, we import the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们集成了我们的登录功能。我们必须从在`src/components/LoginForm.js`文件中构建登录表单开始。首先，我们导入以下内容：
- en: '[PRE99]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The code for the imported CSS is provided in the *Appendix* of this chapter.
    We will not go through it here, as it is a lot of repetitive code. You can also
    download the CSS code from the GitHub repo. With these imports, we can build the
    framework for our login form with the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*附录*中提供了导入的CSS代码。我们在这里不会讲解它，因为它有很多重复的代码。您也可以从GitHub仓库下载CSS代码。有了这些导入，我们可以用以下代码构建我们的登录表单框架：
- en: '[PRE100]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here, we can see that we keep track of `username` and `password` that is constantly
    updating the state. Remember, when the state is updated, we execute the `render`
    function. This is powerful, as we can change whatever we want. For instance, if
    the length of `username` exceeds a certain length, we can change the color of
    the components or remove the button. We will not be making drastic changes ourselves,
    as this is out of the scope of this book. Now that we have defined our framework,
    we can state what our `render` function returns with the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们跟踪`username`和`password`，它们会不断更新状态。记住，当状态更新时，我们执行`render`函数。这很强大，因为我们可以改变我们想要的任何东西。例如，如果`username`的长度超过一定长度，我们可以改变组件的颜色或移除按钮。我们不会自己做出剧烈的改变，因为这超出了本书的范围。现在我们已经定义了我们的框架，我们可以用以下代码来声明我们的`render`函数返回的内容：
- en: '[PRE101]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here, we can see that we have the `username` and `password` fields in the form
    that execute the `handleUsernameChange` and `handlePasswordChange` functions when
    there is a change. When we input `username` and `password`, we need to submit
    these fields to the backend via the `submitLogin` function, which we can define
    here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到表单中有`username`和`password`字段，当有变化时，会执行`handleUsernameChange`和`handlePasswordChange`函数。当我们输入`username`和`password`时，我们需要通过`submitLogin`函数将这些字段提交到后端，我们可以在下面定义这个函数：
- en: '[PRE102]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Here, we can see that we pass the response of the login API call to a function
    that we passed through using props. We will have to define this in the `src/app.js`
    file. If there is an error, we print this out in an alert to tell us what happened.
    Either way, we empty the `username` and `password` fields.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们将登录API调用的响应传递给一个我们通过props传递的函数。我们将在`src/app.js`文件中定义这个函数。如果有错误，我们将在一个alert中打印出来，告诉我们发生了什么。无论如何，我们将清空`username`和`password`字段。
- en: 'Now that we have defined our login form, we will need to show it when we need
    the user to log in. Once the user has logged in, we need to hide the login form.
    Before we can do this, we need to import our login form to the `src/app.js` file
    with the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的登录表单，当我们需要用户登录时，我们将需要显示它。一旦用户登录，我们需要隐藏登录表单。在我们能够做到这一点之前，我们需要用以下代码将我们的登录表单导入到`src/app.js`文件中：
- en: '[PRE103]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We now need to keep track of the login status. To do this, our `App` class’s
    state needs to take the following form:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要跟踪登录状态。为此，我们的`App`类的状态需要以下形式：
- en: '[PRE104]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We are keeping track of our items, but if `login_status` is `false`, we can
    show the login form. Once the user has logged in, we can set `login_status` to
    `true`, and as a result, we can hide the login form. Now that we are logging the
    login status, we can update the `App` class’s `getItems` function:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在跟踪我们的项目，但如果`login_status`是`false`，我们可以显示登录表单。一旦用户登录，我们可以将`login_status`设置为`true`，因此我们可以隐藏登录表单。现在我们已经记录了登录状态，我们可以更新`App`类的`getItems`函数：
- en: '[PRE105]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We can see that we get the token and put it in the header. If there is an error
    with unauthorized code, we execute the `logout` function of the `App` class. Our
    `logout` function takes the form defined here:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们获取了令牌并将其放入头部。如果存在授权代码错误，我们将执行`App`类的`logout`函数。我们的`logout`函数的形式如下：
- en: '[PRE106]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can see that we remove the token from the local storage and set our `login_status`
    to `false`. This `logout` function also needs to be executed if there is an error
    when trying to edit a to-do item, as we must remember that our token can expire
    so it can happen anywhere, and we must prompt another login. This means we must
    pass the `logout` function into the `ToDoItem` component with the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们从本地存储中删除了令牌，并将我们的`login_status`设置为`false`。当尝试编辑待办事项时，如果出现错误，也需要执行这个`logout`函数，因为我们必须记住我们的令牌可能会过期，所以它可能发生在任何地方，我们必须提示另一个登录。这意味着我们必须将`logout`函数通过以下代码传递给`ToDoItem`组件：
- en: '[PRE107]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Once we have passed our `logout` function into the `ToDoItem` component, we
    can update the API call to edit a to-do item in the `src/components/ToDoItem.js`
    file with the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`logout`函数传递给`ToDoItem`组件，我们就可以更新`src/components/ToDoItem.js`文件中编辑待办事项的API调用，以下代码：
- en: '[PRE108]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Here, we can see that we pass the token from local storage to the API call via
    the header. We then execute the `logout` function passed in via the props if we
    get an unauthorized status.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们通过头部传递令牌从本地存储到API调用。如果我们收到未授权的状态，我们就会执行通过props传入的`logout`函数。
- en: 'We now move back to the `src/app.js` file to wrap up the functionality of our
    application. Remember that our application needs to load data when we first access
    it. When our application initially loads, we must consider the token in the local
    storage with the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们回到`src/app.js`文件，总结我们应用程序的功能。记住，我们的应用程序在首次访问时需要加载数据。当我们的应用程序最初加载时，我们必须考虑以下代码中的本地存储中的令牌：
- en: '[PRE109]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now our application will only get the items from the backend when there is
    a token. We must only handle the login before we wrap up our application with
    the `render` function. You have seen how we are handling our token with local
    storage. At this point, you should be able to build the `handleLogin` function
    for the `App` class yourself. If you have attempted coding your own function,
    it should look like the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序只有在有令牌的情况下才会从后端获取项目。我们必须在用`render`函数封装我们的应用程序之前只处理登录。你已经看到了我们如何使用本地存储处理令牌。在这个时候，你应该能够为`App`类构建`handleLogin`函数。如果你尝试编写自己的函数，它应该看起来像以下代码：
- en: '[PRE110]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We are now at the stage of defining the `render` function for the `App` class.
    If our login status is `true`, we can show everything our application has to offer
    with the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于为`App`类定义`render`函数的阶段。如果我们的登录状态是`true`，我们可以使用以下代码显示应用程序提供的一切：
- en: '[PRE111]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'There is not too much new here. However, if our login status is not `true`,
    we can then just display the login form with the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多新内容。然而，如果我们的登录状态不是`true`，我们就可以使用以下代码显示登录表单：
- en: '[PRE112]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'As we can see, we have passed the `handleLogin` function into the `LoginForm`
    component. With this, we are ready to run the application. Our first view looks
    like the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们已经将`handleLogin`函数传递给了`LoginForm`组件。有了这个，我们就准备好运行应用程序了。我们的第一个视图看起来如下：
- en: '![Figure 7.8 – Login and thus the loading view of our application](img/Figure_7.8_B18722.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 应用程序的登录和加载视图](img/Figure_7.8_B18722.jpg)'
- en: Figure 7.8 – Login and thus the loading view of our application
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 应用程序的登录和加载视图
- en: Once we enter the correct credentials, we will be able to access the application
    and interact with the to-do items. Our application is essentially working!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入正确的凭证，我们就能访问应用程序并交互待办事项。我们的应用程序本质上已经可以工作了！
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built user data model structs and tied them to the to-do
    item data models in our migrations. We then got to dive a little deeper into our
    migrations by firing multiple steps in the SQL file to ensure our migration runs
    smoothly. We also explored how to add unique constraints to certain fields.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了用户数据模型结构，并将它们绑定到我们的迁移中的待办事项数据模型。然后我们通过在SQL文件中执行多个步骤来进一步深入我们的迁移，以确保迁移顺利运行。我们还探讨了如何向某些字段添加唯一约束。
- en: Once our data models were defined in the database, we hashed some passwords
    before storing them in our database with the stored user. We then created a JWT
    struct to enable our users to store their JWT in their browsers so that they can
    submit them when making an API call. We then explored how to redirect the URL
    in JavaScript and the HTML storage so that the frontend can work out whether the
    user even has credentials, before it entertains the notion of sending API calls
    to the items.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中定义了我们的数据模型之后，我们在将它们与存储的用户一起存储在数据库之前，对一些密码进行了散列。然后我们创建了一个JWT结构，以便我们的用户可以在他们的浏览器中存储JWT，这样他们就可以在发起API调用时提交它们。然后我们探讨了如何在JavaScript和HTML存储中重定向URL，以便前端可以确定用户是否有凭证，在考虑发送API调用到项目之前。
- en: What we have done here is alter the database with migration so that our app
    can manage data models that handle more complexity. We then utilized frontend
    storage to enable our user to pass credentials. This is directly applicable to
    any other Rust web project you will embark on. Most web apps require some sort
    of authentication.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是通过迁移更改数据库，以便我们的应用程序可以管理处理更多复杂性的数据模型。然后我们利用前端存储来允许用户传递凭证。这对于你将开始的任何其他Rust网络项目都直接适用。大多数网络应用程序都需要某种形式的身份验证。
- en: In the next chapter, we will explore **REST API** practices, where we will standardize
    interfaces, caching, and logging.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨**REST API**实践，我们将标准化接口、缓存和日志。
- en: Questions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the advantages of defining unique constraints in SQL as opposed to
    server-side code?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与服务器端代码相比，在SQL中定义唯一约束有什么优势？
- en: What is the main advantage of a user having a JWT over storing a password?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户拥有JWT而不是存储密码的主要优势是什么？
- en: How does a user store a JWT on the frontend?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户如何在前端存储JWT？
- en: How could a JWT be useful in the view once we have verified that it is passable?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们验证JWT是可用的，JWT在视图中有什么用？
- en: What is the minimal approach to altering data in the frontend and redirecting
    it to another view when a user hits an endpoint?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击端点时，更改前端数据并将其重定向到另一个视图的最小方法是什么？
- en: Why is it useful to have a range of different response codes when logging in
    as a user, as opposed to just denoting that login is successful or unsuccessful?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在用户登录时使用一系列不同的响应代码比仅仅表示登录成功或失败更有用？
- en: Answers
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Adding unique constraints directly on a database ensures that this standard
    is enforced, no matter whether data manipulation is done via migration or a server
    request. This also protects us from corrupting data if a new feature is added
    at another endpoint that forgets to enforce this standard, or if the code is altered
    in later alterations of the endpoints.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接在数据库上添加唯一约束确保了无论数据操作是通过迁移还是服务器请求完成的，这一标准都得到执行。这也保护我们免受在另一个端点添加新功能时忘记执行这一标准或代码在端点的后续更改中更改所造成的数据损坏。
- en: If an attacker manages to obtain a JWT, it does not mean that they have direct
    access to the user’s password. Also, if the tokens get refreshed, then the access
    the attacker has to items has a limited timeframe.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果攻击者设法获取JWT，并不意味着他们可以直接访问用户的密码。此外，如果令牌被刷新，那么攻击者对项目的访问时间有限。
- en: The JWT can be stored in local HTML storage or cookies.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT可以存储在本地HTML存储或cookies中。
- en: We can store multiple data points in the token when hashing it. Therefore, we
    can encrypt the user ID. With this, we can extract the user ID for operations
    related to the to-do item’s creation, deletion, or edit.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在散列令牌时，我们可以在其中存储多个数据点。因此，我们可以加密用户ID。有了这个，我们可以提取用户ID，用于与待办事项创建、删除或编辑相关的操作。
- en: We return an `HttpResponse` struct with HTML/text body that contains a string
    housing a couple of HTML tags. In between these tags are a couple of script tags.
    In between the script tags, we can have each of our JavaScript commands split
    by ;. We can then directly alter the HTML storage and window location.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回一个包含HTML/text主体的`HttpResponse`结构，该主体包含一个包含几个HTML标签的字符串。在这些标签之间是几个脚本标签。在脚本标签之间，我们可以通过分号分割我们的JavaScript命令。然后我们可以直接修改HTML存储和窗口位置。
- en: There could be a range of reasons why data gets corrupted on a database, including
    alterations in the migrations. However, there could be an error that is not the
    fault of the user – for instance, a duplicate username for two different users.
    This is an error where our unique constraints have been violated. We need to know
    this has happened so that we can correct it.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库中数据损坏可能有多种原因，包括迁移中的更改。然而，可能存在一个错误，这不是用户的责任——例如，两个不同用户的重复用户名。这是一个违反了我们的唯一约束的错误。我们需要知道这种情况已经发生，以便我们可以纠正它。
- en: Further reading
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'JWT standard: [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: JWT标准：[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)
- en: Appendix
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: 'The CSS used for the login form:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 登录表单所使用的CSS：
- en: '[PRE113]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
