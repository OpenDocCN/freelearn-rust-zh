- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing User Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, our app is manipulating data in a proper database through the
    clicking of buttons on the view. However, anyone who comes across our app can
    also edit the data. While our app is not the type of app that would require a
    lot of security, it is an important concept to understand and practice in general
    web development.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a system that creates users. This system will
    also manage user sessions by requiring the user to log in before they can alter
    any to-do items through the frontend app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating user data models with relationships with other tables with unique constraints
    of certain fields via database migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating our users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing user sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up authentication requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring expiration of auth tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding authentication into our frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to understand the basics of authenticating
    users on a web server. You will also be able to implement this authentication
    on the server side of our Rust application and store credentials in our React
    application in the frontend. The understanding of the concepts and practices covered
    in this chapter will also enable you to incorporate authentication in phone applications
    using React Native, and on a Rust server and desktop applications by wrapping
    our React application in **Electron**.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we build on the code built in the previous chapter. This can
    be found at the following URL: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter06/building_a_database_connection_pool).'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Creating our user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are managing user sessions in our app, we will need to store information
    about our users to check their credentials, before we allow our to-do items to
    be created, deleted, and edited. We will store our user data in a **PostgreSQL**
    database. While this is not essential, we will also link users in the database
    to to-do items. This will give us an understanding of how to alter an existing
    table and create links between tables. To create our user model, we are going
    to have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `User` data model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `NewUser` data model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alter the to-do item data model so that we can link it to a user model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the schema file with the new table and altered fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and run migration scripts on the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following sections, we’ll look at the preceding steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a User data module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start, we will need to update the dependencies in the `Cargo.toml`
    file with the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will be using the `bcrypt` crate to hash and check passwords and the `uuid`
    crate to generate unique IDs for our user data models. As we covered in [*Chapter
    6*](B18722_06.xhtml#_idTextAnchor127), *Data Persistence with PostgreSQL*, we
    will need to create two different structs for our user data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new user will not have an `id` field because it does not exist in the database
    yet. This ID is created by the database when the new user is inserted into the
    table. We then have another struct that has all the same fields with the `id`
    field we added, since we might need to use this ID when we’re interacting with
    existing users in the database. ID numbers can be useful for referencing other
    tables. They are short and we know that they are unique. We will be using a user
    ID to link the user to the to-do items. These data models can be housed in the
    following file structure in the `src/models.rs` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define the data model in our `new_user.rs` file. First, we must define
    the imports, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It must be noted that we have not defined the users in the schema yet. We will
    get around to this after we have finished with all the data models. We will not
    be able to compile our code until we have defined our `users` schema. We will
    also import a unique ID crate because we are going to be creating a unique ID
    when we create a new user, and the `Insertable` trait from the `diesel` crate
    because we are going to be inserting the new user into our database. We then use
    the `hash` function from the `bcrypt` crate to hash the new password that we define
    for our new user. We can also see that we import the `DEFAULT_COST` constant from
    the `bcrypt` crate. The `DEFAULT_COST` is merely a constant that we will pass
    into the `hash` function. We will explore why this is the case in the next section
    when we cover hashing passwords. Now that we have defined our user data model
    module and imported what we need, we can move on to the next section to create
    the `NewUser` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a NewUser data model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define our data model with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we allowed our data model to be insertable. However,
    we are not allowing it to be queried. We want to ensure that when a user is retrieved
    from the database, their ID is present. We could move on to defining the general
    data model for users, but this is not secure. We need to ensure that our passwords
    are protected by hashing them. If you remember from [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039),
    *Designing Your Web Application in Rust*, we utilized traits to allow certain
    to-do structs to perform actions. Some structs could create, while others could
    delete based on the traits that they implemented. We are locking down the functionality
    of our `NewUser` struct here by just implementing the `Insertable` trait. However,
    we will enable querying by implementing other traits for the `User` struct, as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Locking down data model structs with traits](img/Figure_7.1_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Locking down data model structs with traits
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the struct that inserts new users into the database,
    we can explore how to store our users’ passwords in the database.
  prefs: []
  type: TYPE_NORMAL
- en: You may have wondered why you cannot recover forgotten passwords; you can only
    reset them. This is because the password is *hashed*. Hashing passwords is a common
    practice when it comes to storing them. This is where we use an algorithm to obfuscate
    a password so that it cannot be read. Once this is done, it cannot be reversed.
  prefs: []
  type: TYPE_NORMAL
- en: The hashed password is then stored in a database. To check the password, the
    input password is hashed and compared to the hashed password in the database.
    This allows us to see whether the input hashed password matches the hashed password
    stored in the database. This has a couple of advantages. First, it prevents employees
    who have access to your data from knowing your password. If there is a data leak,
    it also prevents the leaked data from directly exposing your password to whoever
    had the data.
  prefs: []
  type: TYPE_NORMAL
- en: Considering a lot of people use the same password for multiple things (even
    though they should not), you can only imagine the damage that may be caused to
    people using your app if you are not hashing passwords and there’s a data breach.
    However, hashing gets more complicated than this. There is a concept called *salting*
    that ensures that when you hash the same password, it does not result in the same
    hash. It does this by adding an extra bit of data to the password before it is
    hashed. This is also where the `DEFAULT_COST` constant that we pass into the `hash`
    function comes in. Let’s say we got hold of the data in the database and we want
    to write code that will guess the passwords we have in the data. If we have enough
    computing power, we could effectively guess the password. Therefore, we can pass
    in a cost parameter. As we increase the cost parameter, the amount of work in
    either CPU time or memory increases exponentially. Increasing the cost factor
    by one will increase the number of operations needed to compute the hash by 10,000
    or even more.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining password security in more detail is beyond the scope of this book.
    However, it must be stressed that password hashing is always a must when storing
    passwords. Luckily, there is a range of modules in all major languages that enable
    you to hash and check passwords with just a few lines of code. Rust is no different
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that we can insert our new users into the database with hashed passwords,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will have to ensure that the input password is hashed in our `NewUser`
    constructor, which is defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we used the `hash` function from the `bcrypt` crate to hash our password,
    where we also passed in the `DEFAULT_COST` constant. We also created a unique
    ID using the `Uuid` crate and then constructed a new instance of the `NewUser`
    struct with those attributes. In our app, there is no real need for a unique ID.
    However, these can come in handy if you are communicating between multiple servers
    and databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our `NewUser` data model, we can define our general
    user data model in the `user.rs` file with the following code. First, we must
    define the following imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we are using the `verify` function and that we are also
    allowing the general user data model struct to be queryable and identifiable.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the imports defined in the previous step, we can build our `User` struct.
    Remember, this is a struct that is going to be loaded from our database when we
    make database queries. Before you read further, this is a good time to try and
    build the `User` struct yourself, as it uses the same table as the `NewUser` struct
    but has an `id` field and is queried instead of inserted. Once you have built
    your `User` struct, it should look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that we just added the `id` field and derived the `Queryable` trait
    instead of the `Insertable` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our `User` struct has been defined, we can build a function that verifies
    whether an input password matches the password belonging to the user with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that our models have been defined, we must remember to register them in
    the `models/user/mod.rs` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Furthermore, we can make these modules accessible to the app by adding the
    following line to the `models/mod.rs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, our data models for the users have been defined. However, we still
    need to link them to our to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: Altering the to-do item data model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To link data models to our to-do items, we must alter our to-do data models.
    There are multiple ways in which we can do this. For instance, we can add a `user_id`
    field to the item table that is just the `unique_id` field of the user table.
    When we are creating a new item, we then pass the unique ID of the user into the
    item constructor. This is easy to implement; however, it does have risks. Merely
    passing the unique ID of the user into the item does not enforce that the ID of
    the user is valid and in the database. There is nothing stopping us from inserting
    an ID of a deleted user into the item constructor and thus inserting an orphaned
    item into the database. This will then be hard to extract later, as we have no
    reference to the user ID that the orphaned item is associated with. We can also
    create a new table that references the user’s ID with the item ID, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – A separate database table for logging item associations with
    users](img/Figure_7.2_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – A separate database table for logging item associations with users
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of this is that it is easy to decouple the users from the items
    by merely dropping the table. However, it also does not have valid user ID enforcement
    or item ID enforcement when creating a new entry. We will also have to make two
    queries, one to the association table and then another to the item table to get
    the items from the user. As the previous two methods of attaching a user ID column
    to the items table or creating a bridge table holding an item ID and user unique
    ID are easy to implement, we will not explore them; you should be able to implement
    them yourself at this point. In the context of the to-do application, the previous
    two methods would be subpar, as they offer us no benefits yet introduce the risk
    of errors when inserting data into our database. This does not mean that the two
    previous methods should never be used. The data needs for each project are different.
    In our project, we will create a foreign key to link our users to items, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Foreign key association between our user and items](img/Figure_7.3_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Foreign key association between our user and items
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not allow us to access the items associated with a user with one
    database call, but we are only allowed to insert items that have a reference to
    a legitimate user ID in the database. Foreign keys can also trigger cascade events
    where, if we delete a user, this will automatically delete all existing items
    associated with the user to prevent orphan items from being created. We create
    a foreign key by declaring the link to the table with a macro. In `models/item/item.rs`,
    we can achieve this by initially having the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we must import the `User` struct, as we will be referencing
    it in the `belongs_to` macro to claim that our `Item` struct belongs to the `User`
    struct, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we imported the user data model struct, defined it with
    a `belongs_to` macro, and added a `user_id` field to link the struct. Note that
    the `belongs_to` macro will not be callable if we do not include the `Associations`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing we need to do is add the `user_id` field to the fields and constructor
    in the `models/item/new_item.rs` file. We need to do this so that we can link
    the new to-do item to the user creating the item. This can be achieved by using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So, taking stock of what we have done, all our data model structs have been
    altered, and we are able to use them as and when we need them in the app when
    interacting with the database. However, we have not updated our database, and
    we have not updated the bridge connecting the app to the database. We will do
    this next.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the schema file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make sure that the mapping from the data model struct to the database is
    up to date, we must update our schema with these changes. This means that we must
    alter the existing schema for the to-do item table and add a user schema to the
    `src/schema.rs` file. This is denoted by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It must be noted that our fields in the schema file are defined in the same
    order as the Rust data models. This is important because, if we do not do this,
    the fields will be mismatched when we’re connecting to the database. We might
    also realize that our schema is merely just defining the fields and their type;
    it is not covering the relationship between the to-do table and the user table.
  prefs: []
  type: TYPE_NORMAL
- en: We do not have to worry about this because when we create and run our own migrations,
    this schema file will be updated with the relationship. This leads us to create
    our own migrations to complete this schema file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and running migration scripts on the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running migrations has a similar process to what we covered in [*Chapter 6*](B18722_06.xhtml#_idTextAnchor127),
    *Data Persistence with PostgreSQL*, which covered how to install the Diesel client
    and connect to the database. First, we must run our database with the `docker-compose`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need this running in the background when we run the migration. We can
    then create the migration scripts by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This creates a directory in the migrations, which includes `create_users` in
    the username of the directory. Inside this directory, we have two blank *SQL*
    files. Here, we will manually write our own SQL scripts for the migrations. Initially,
    you might find this unnecessary, as there are libraries in other languages that
    automatically generate these migrations, but there are some advantages to doing
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'irst, it keeps our hand in SQL, which is another handy tool. This enables us
    to think about solutions that utilize SQL in the day-to-day problems that we are
    trying to solve. It also gives us more fine-grained control of how migrations
    flow. For instance, in the migration that we are going to create, we are going
    to have to create the user table and then a base user so that when we alter the
    column in the `to_do` table, we can fill it with the ID of the placeholder user
    row. We carry this out in our `up.sql` file with the following table definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is straightforward. Note that the `email` and `username` fields are unique.
    This is because we do not want users with duplicate usernames and emails. It’s
    good to put the constraint in at this level for several reasons. For instance,
    we could protect against this by doing a database call of the username and email
    and refusing to insert a new user if there is duplication.
  prefs: []
  type: TYPE_NORMAL
- en: However, there may be an error in the code, or someone might alter our code
    in the future. A new feature might be introduced that doesn’t have this check,
    such as an edit feature. There might be a migration that alters rows or inserts
    new users. It is usually best practice, if you are writing your own SQL, to ensure
    that you use the `;` symbol to indicate that the operation has finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'This SQL command is fired, and then the next command is fired afterward. Our
    next command in the `up.sql` file inserts a placeholder user row with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created our user, we then alter our `to_do` table. We can
    do this with the following command, in the same file under the previous command
    we just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, our `up.sql` migration has been defined. Now, we must define our
    `down.sql` migration. With the down migration, we basically must reverse what
    we did in the up migrations. This means dropping the `user_id` column in the `to_do`
    table and then dropping the user table entirely. This can be done with the following
    SQL code in the `down.sql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We must keep in mind that Docker must be running for the migration to influence
    the database. Once this migration is run, we can see that the following code has
    been added to the `src/schema.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables our Rust data models to make queries concerning the relationship
    between users and to-do items. With this migration finished, we can run our app
    again. However, before we do that, there is just one slight alteration that we
    have to make in the `src/views/to_do/create.rs` file, where the constructor of
    the new item in the `create` view function adds the default user ID with the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Running our app now will result in the same behavior we described in [*Chapter
    6*](B18722_06.xhtml#_idTextAnchor127), *Data Persistence with PostgreSQL*, in
    that our app is running with the migrations that we have made. However, we also
    need to see whether our constructor for the new user works as we hash the password
    and generate the unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to build a create user endpoint. For this, we must define
    the schema, and then a view that inserts that new user into the database. We can
    create our schema in the `src/json_serialization/new_user.rs` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can declare the new user schema in our `src/json_serialization/mod.rs`
    file with `pub mod new_user;`. Once our schema has been defined, we can create
    our own user view module with the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `users/create.rs` file, we need to build a create view function. First,
    import the following crates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have been building our views multiple times now, none of these imports
    should be surprising. We import the `diesel` macros and crate to enable us to
    make calls to the database. We then import the `actix_web` traits and structs
    to enable data to flow in and out of the view. We then import our schemas and
    structs to structure the data that we are receiving and processing. Now that we’ve
    imported the correct crates, we must define the `create` view function with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we accept JSON data that is loaded into the `NewUserSchema`
    struct. We also establish a database connection from the connection pool with
    the `DB` struct. Inside our `create` view function, we extract the data that we
    need from the `NewUserSchema` struct to create a `NewUser` struct with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We must clone the fields to be passed into the `NewUser` constructor because
    strings do not implement the `Copy` trait, meaning we must do this manually. We
    then create our `insert` command for the database and execute it with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a `Result` struct. However, we do not unwrap it directly. There
    could be a conflict. For instance, we could be trying to insert a new user with
    a username or email that is already in the database. However, we do not want this
    to just error out. This is an edge case that we will expect as we have implemented
    the unique username and email constraint ourselves. If there was a legitimate
    error that happens when the view is being executed, we need to know about it.
    Therefore, we must give response codes to the edge cases. Therefore, we match
    the result of the insert and return the appropriate response code with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have established a database connection, extracted the fields from the
    JSON body, created a new `NewUser` struct, and then inserted it into the database.
    There is a slight difference here compared to the other views. In the return response,
    we are having to *await* and then *unwrap* it. This is because we are not returning
    a JSON body. Therefore, `HttpResponse::Ok()` is merely a builder struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have built our create view, we need to define our view factory
    in the `views/users/mod.rs` file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, since we have been building views regularly, none of this should come
    as a surprise to you. If it does, it is recommended that you read the *Managing
    views using the Actix Web framework* section in [*Chapter 3*](B18722_03.xhtml#_idTextAnchor059),
    *Handling HTTP Requests*, for clarity. Now, our main views factory in the `views/mod.rs`
    file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have registered our user view, we can run our app and create our
    user with the following Postman call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Postman call to our create user endpoint](img/Figure_7.4_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Postman call to our create user endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we should get a `201` created response. If we call the exact same
    call again, we should get a `409` conflict. With this, we should expect that our
    new user has been created. With the steps covered in the *Connecting to PostgreSQL
    with Diesel* section in [*Chapter 6*](B18722_06.xhtml#_idTextAnchor127), *Data
    Persistence with PostgreSQL*, we can inspect the database in our Docker container,
    which gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the initial user that was created in our migration. However,
    we can also see the user we created via our view. Here, we have a hashed password
    and a unique ID. From this, we can see that we should never directly create our
    user; we should only create a user through the constructor function belonging
    to the `NewUser` struct.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of our app, we do not really need a unique ID. However, in wider
    situations where multiple servers and databases are used, a unique ID can become
    useful. We also must note that our conflict response on the second one was correct;
    the third replica create user call, did not insert a replica user into the database.
  prefs: []
  type: TYPE_NORMAL
- en: With this, our app is running as normal, since there is now a user table with
    user models linked to the to-do items. Thus, we can create other data tables with
    relationships and structure migrations so that they can be seamlessly upgraded
    and downgraded. We have also covered how to verify and create passwords. However,
    we have not actually written any code that checks whether the user is passing
    the right credentials. In the next section, we will work on authenticating users
    and rejecting requests that do not contain the right credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating our users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to authenticating our users, we have built a struct that extracts
    a message from the header of the HTTP request. We are now at the stage where we
    can make real use of this extraction by storing data about the user in the header.
    Right now, there is nothing stopping us from storing the username, ID, and password
    in the header of each HTTP request so that we can authenticate each one. However,
    this is a terrible practice. If someone intercepts the request or gets hold of
    the data stored in the browser to facilitate this, then the account is compromised
    and the hacker can do whatever they want. Instead, we are going to obfuscate the
    data, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Steps for authenticating requests](img/Figure_7.5_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Steps for authenticating requests
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 7**.5*, we can see that we use a secret key to serialize the structured
    data that we have on the user into a token that is in bytes. We then give the
    token to the user to store in the browser. When the user wants to make an authorized
    request, the user must send the token in the header of the request. Our server
    then uses the secret key to deserialize the token back into structured data about
    the user. The algorithms used to do this process are standard hashing algorithms
    that are available to anyone. Therefore, we have a secret key that we define to
    keep the tokens out in the wild safe. For our application to carry out the processes
    laid out in *Figure 7**.5*, we are going to have to rewrite most of our `src/jwt.rs`
    file, including the `JwToken` struct. Before we start, we need to update our `Cargo.toml`
    dependencies with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we have added the `serde` features to the `chrono` crate and
    added the `jsonwebtoken` crate. To rebuild the `JwToken` struct, we need to import
    the following in the `src/jwt.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we import `actix_web` traits and structs to enable the processing
    of the requests and responses. We then import `futures` to enable us to handle
    the interception of the HTTP request before it hits the views. We then import
    `serde` and `jsonwebtoken` to enable the serialization and deserialization of
    data to and from the token. We then import the `chrono` crate because we want
    to log when these tokens are minted. We also need to have the key for the serialization,
    and we get this from the config file, which is why we import the `Config` struct.
    Now that we have imported all the traits and structs that we need, we can write
    our token struct with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have the ID of the user, and we also have the date-time
    of when the token was created. We also decorate our `minted` field with a `serde`
    macro to state how we are going to serialize the `datetime` field. Now that we
    have the data that we need for the token, we can move on to defining the serialization
    functions with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can explain what each one of the preceding functions does with the following
    bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_key`: Gets the secret key for the serialization and deserialization from
    the `config.yml` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encode`: Encodes the data from the `JwToken` struct as a token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new`: Creates a new `JwToken` struct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from_token`: Creates a `JwToken` struct from a token. If there is a failure
    in the deserialization it returns a `None` as there can be failures in deserialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have built the preceding functions, our `JwToken` struct will be able
    to handle tokens as and when we see fit. We flesh out the `get_key` function with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we load the key from the config file. Therefore, we need
    to add the key to the `config.yml` file, resulting in our file looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If our server is in production, we should have a better secret key. However,
    for local development, this will work fine. Now that we are extracting the key
    from the config file, we can define our `encode` function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have defined an encoding key using the secret key
    from the config file. We then use this key to encode the data from the `JwToken`
    struct into a token and return it. Now that we can encode our `JwToken` struct,
    we will need to create new `JwToken` structs when we need them, which can be achieved
    by the following `new` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With the constructor, we know when our `JwToken` is minted. This can help us
    manage our user sessions if we want. For instance, if the token’s age exceeds
    a threshold that we deem appropriate, we can force another login.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have is the `from_token` function, where we extract the data from
    a token using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a decoding key and then use it to decode the token. We then
    return `JwToken` using `data.claims`. Now, our `JwToken` struct can be created,
    encoded into a token, and extracted from a token. Now, all we need to do is extract
    it from the header of an HTTP request before the view is loaded, using the following
    outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We have implemented the `FromRequest` trait multiple times now for the database
    connection and the previous implementation for the `JwToken` struct. Inside the
    `from_request` function, we extract the token from the header with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If the token is not in the header, we directly return `ErrorUnauthorized`,
    avoiding the call to the view completely. If we manage to extract the token from
    the header, we can process it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we convert the raw token extracted from the header to a string. We then
    deserialize the token and load it into the `JwToken` struct. However, if this
    fails due to a fake token being supplied, we return an `ErrorUnauthorized` error.
    Our authentication is now fully working; however, we will not be able to do anything
    because we do not have a valid token, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Authentication blocking requests](img/Figure_7.6_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Authentication blocking requests
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build login API endpoints to enable us to interact
    with our protected endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Managing user sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our users, we are going to have to enable them to log in. This means that
    we must create an endpoint to check their credentials and then generate a JWT
    to be returned to the user in the frontend, via the header in the response. Our
    first step is to define a login schema in the `src/json_serialization/login.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We have to remember to register it in the `src/json_serialization/mod.rs` file
    with the `pub mod login;` line of code. Once we have done this, we can build our
    login endpoint. We can do this by editing the `src/views/auth/login.rs` file we
    created in the *Managing views using the Actix Web framework* section in [*Chapter
    3*](B18722_03.xhtml#_idTextAnchor059), *Handling HTTP Requests*, which declares
    our basic login view. This just returns a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start refactoring this view by defining the required imports, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we can glance at the imports and get a feel for what we are
    going to do. We are going to extract the username and password from the body.
    We are then going to connect to the database to check the user and password, and
    then use the `JwToken` struct to create the token that will be passed back to
    the user. We can initially lay out the outline of the view with the following
    code in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we accept the login credentials from the body of the
    incoming request and prepare a database connection from the connection pool for
    the view. We can then extract the details we need from the request body and make
    a database call with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must check to see whether we got what we expected from the database
    call with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have done some early returns. If there are no users, then we return
    a `not found` response code. This is something we will expect from time to time.
    However, if there is more than one user with that username, we need to return
    a different code.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the unique constraints shown, something is very wrong. A migration script
    in the future might undo these unique constraints, or the user query might be
    altered by accident. If this happens, we need to know that this has happened right
    away, since corrupted data that goes against our constraints can cause our application
    to behave in unexpected ways that can be hard to troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have checked that the right number of users have been retrieved,
    we can get the one and only user at index zero with confidence and check whether
    their password is passable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we used the `verify` function. If the password is a match,
    we then generate a token using the ID and return it to the user in the body. If
    the password is not correct, we return an unauthorized code instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of our logout, we are going to take a far more lightweight approach.
    All we must do in our logout view is run two lines of JavaScript code. One is
    to remove the user token from the local storage and then revert the user to the
    main view. HTML can just host JavaScript that gets run as soon as you open it.
    Therefore, we can achieve this by putting the following code in the `src/views/auth/logout.rs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this view is already registered, we can run the app and make the call
    with Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Logging into our application using the login endpoint with Postman](img/Figure_7.7_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Logging into our application using the login endpoint with Postman
  prefs: []
  type: TYPE_NORMAL
- en: Altering the username will give us a `404-response` code, whereas altering the
    password will give us a `401-response` code. If we have the correct username and
    password, we will get a `200-response` code and there will be a *token* in the
    response of the header, as shown in *Figure 7**.7*. However, if we want to use
    our *token* in the response header, we will get a `token can't be decoded` message.
    In the next section, we are going to clean up our authentication requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up authentication requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to clean up our Rust server in terms of authentication
    before we start configuring our frontend to handle these authentication processes.
    To keep the flow of the chapter engaging, we have not regularly carried out “housekeeping.”
    Now, we are going to update our `to_do` views. We can start by updating the `create`
    view with authentication requirements. To do so, the function signature of our
    `create` view in the `src/views/to_do/create.rs` file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We also must update the user ID when creating a new item with the ID from the
    token, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'With our `delete` view, we must ensure that we are deleting a to-do item that
    belongs to the user making the request. If we do not add a filter using the user
    ID, the deletion of the to-do item will be random. This filter can be added in
    our `src/views/to_do/delete.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `filter` functions can merely be chained when making a
    database query. Considering what we have done with our `delete` view, how do you
    think we will upgrade our authentication requirements for our `edit` in the `src/views/to_do/edit.rs`
    file? At this stage, I encourage you to try and update the `edit` view yourself,
    as the approach is like our `delete` view upgrade. Once you have done this, your
    `edit` view should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have updated our specific views, we can now move on to the `get`
    view, which also has the `get_state` function that is applied to all other views.
    Our `get` view in the `src/views/to_do/get.rs` file now takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, everything in the preceding code should not be a surprise. We can see
    that we pass the user ID into the `ToDoItems::get_state` function. You must remember
    to fill in the user ID everywhere the `ToDoItems::get_state` function is implemented,
    which is all the to-do views. We can then redefine our `ToDoItems::get_state`
    function in the `src/json_serialization/to_do_items.rs` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we have updated the database connection and the filter
    for the user ID. We have now updated our code to accommodate different users.
    There is one more change that we must make. Because we will be writing frontend
    code in our React application, we will try and keep the React coding as simple
    as possible, as React development is a book itself. To avoid over-complicating
    the frontend development of header extraction and `GET` posts using Axios, we
    will add a `Post` method to our login and return the token using the body. This
    is another good opportunity to try and solve this yourself, as we have covered
    all the concepts needed to pull this off.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have attempted to solve this problem yourself, it should look like the
    following. First, we define a response struct in the `src/json_serialization/login_response.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We remember to declare the preceding struct by putting in `pub mod login_response`
    in the `src/json_serialization/mod.rs` file. We now go to our `src/views/auth/login.rs`
    and have the following `return` statement in the `login` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we made a slight change to our unauthorized to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse::Unauthorized().finish()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we have switched our `return` type for the view function to
    an `HttpResponse` struct giving us the following function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(credentials: web::Json<Login>, db: DB) ->** **HttpResponse**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We had to make the switch because adding the `json` function to our response
    turns our response from `HttpResponseBuilder` to `HttpResponse`. Once the `json`
    function has been called, `HttpResponseBuilder` cannot be used. Going back to
    the unauthored response builder, we can deduce that the `finish` function converts
    `HttpResponseBuilder` to `HttpResponse`. We can also convert our `HttpResponseBuilder`
    to `HttpResponse` by using `await`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse::Unauthorized().await.unwrap()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that we return the token in the header and the body. This
    will give us flexibility and ease when writing the frontend code. However, it
    must be stressed that this is not the best practice. We are implementing the approach
    of passing the token back into the body and header to keep the frontend development
    section simple. We can then enable the `POST` method for our login view in our
    `src/views/auth/mod.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have merely stacked a `get` function onto the same `login`
    view. Now, `POST` and `GET` are available for our login view. We can now move
    into the next section where we configure our authentication tokens so they can
    expire. We want our tokens to expire to increase our security. If a token is compromised
    and a bad actor gets hold of a token, they will be able to do whatever they want
    for as long as they want without ever having to log in. However, if our tokens
    expire, then the bad actor only has a limited time window before the token expires.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring expiration of auth tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we try and perform an API call on our now protected endpoints with a valid
    token obtained from logging in with the token in the header, we will get an unauthorized
    error. If we insert some `print` statements, we will get the following error when
    failing to decode the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This implies that there is no field called `exp` in our `JwToken` struct. If
    we reference the `jsonwebtoken` documentation at [https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html](https://docs.rs/jsonwebtoken/latest/jsonwebtoken/fn.encode.html),
    we can see that the `encode` instructions never mention `exp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that there is no mention of claims. However, what is happening
    is that when we try and deserialize our token, the `decode` function in the `jsonwebtoken`
    crate is automatically looking for the `exp` field to work out when the token
    is supposed to be expired. We are exploring this because the official documentation
    and slightly confusing error message could leave you wasting hours trying to figure
    out what is going on. With this in mind, we must go back to our `src/jwt.rs` file
    for some more rewriting, but this is the last time, I promise, and it is not an
    entire rewrite. First, we ensure that the following is imported alongside what
    is already in the `src/jwt.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then make sure our `JwToken` struct is written with the `exp` field
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We now must rewrite the `new` constructor method for our `JwToken` struct.
    In the `new` function, we will have to define at what time the newly minted `JwToken`
    struct has expired. This must vary; as a developer, you might want to tweak the
    time taken to timeout. Remember that we must recompile every time we change the
    Rust code; therefore, it makes sense to have the timeout period defined in the
    config file. With the variance of timeout considered, our `new` function takes
    the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we define the number of minutes. We then convert our expiration
    as `usize` and then build our `JwToken` struct. Now that we have this, we need
    to be more specific with the type of error that we return, as it could be an error
    in the decoding of the token, or the token could be expired. We handle the different
    types of errors when decoding the token with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have switched from returning `Option` to `Result`.
    We have switched to `Result` because we are returning the message that can be
    digested and processed in our `from_request` function in the `FromRequest` trait
    implementation. The rest of the code in the `from_request` function is the same.
    Where we make the change is checking the message if there is an error and returning
    a different message to the frontend with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: With the nuanced error message, our frontend code can handle and adapt, as we
    can be more specific on how we handle the errors in the frontend. Being more specific
    in the frontend can aid the user, prompting them where they went wrong. However,
    when it comes to authentication, make sure you do not give too much away because
    this can also aid bad actors trying to obtain unauthorized access. We now have
    our login and logout endpoints running; we also have token authorization on the
    views that we need. However, this is not very useful if we want a standard user
    to interact with our application, as they are unlikely to use Postman. Therefore,
    we are going to have to incorporate our login/logout endpoints in the frontend
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication into our frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We incorporate our login functionality. We must start off by building the login
    form in the `src/components/LoginForm.js` file. First, we import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the imported CSS is provided in the *Appendix* of this chapter.
    We will not go through it here, as it is a lot of repetitive code. You can also
    download the CSS code from the GitHub repo. With these imports, we can build the
    framework for our login form with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we keep track of `username` and `password` that is constantly
    updating the state. Remember, when the state is updated, we execute the `render`
    function. This is powerful, as we can change whatever we want. For instance, if
    the length of `username` exceeds a certain length, we can change the color of
    the components or remove the button. We will not be making drastic changes ourselves,
    as this is out of the scope of this book. Now that we have defined our framework,
    we can state what our `render` function returns with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have the `username` and `password` fields in the form
    that execute the `handleUsernameChange` and `handlePasswordChange` functions when
    there is a change. When we input `username` and `password`, we need to submit
    these fields to the backend via the `submitLogin` function, which we can define
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we pass the response of the login API call to a function
    that we passed through using props. We will have to define this in the `src/app.js`
    file. If there is an error, we print this out in an alert to tell us what happened.
    Either way, we empty the `username` and `password` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our login form, we will need to show it when we need
    the user to log in. Once the user has logged in, we need to hide the login form.
    Before we can do this, we need to import our login form to the `src/app.js` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to keep track of the login status. To do this, our `App` class’s
    state needs to take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We are keeping track of our items, but if `login_status` is `false`, we can
    show the login form. Once the user has logged in, we can set `login_status` to
    `true`, and as a result, we can hide the login form. Now that we are logging the
    login status, we can update the `App` class’s `getItems` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we get the token and put it in the header. If there is an error
    with unauthorized code, we execute the `logout` function of the `App` class. Our
    `logout` function takes the form defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we remove the token from the local storage and set our `login_status`
    to `false`. This `logout` function also needs to be executed if there is an error
    when trying to edit a to-do item, as we must remember that our token can expire
    so it can happen anywhere, and we must prompt another login. This means we must
    pass the `logout` function into the `ToDoItem` component with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have passed our `logout` function into the `ToDoItem` component, we
    can update the API call to edit a to-do item in the `src/components/ToDoItem.js`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we pass the token from local storage to the API call via
    the header. We then execute the `logout` function passed in via the props if we
    get an unauthorized status.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now move back to the `src/app.js` file to wrap up the functionality of our
    application. Remember that our application needs to load data when we first access
    it. When our application initially loads, we must consider the token in the local
    storage with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our application will only get the items from the backend when there is
    a token. We must only handle the login before we wrap up our application with
    the `render` function. You have seen how we are handling our token with local
    storage. At this point, you should be able to build the `handleLogin` function
    for the `App` class yourself. If you have attempted coding your own function,
    it should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now at the stage of defining the `render` function for the `App` class.
    If our login status is `true`, we can show everything our application has to offer
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'There is not too much new here. However, if our login status is not `true`,
    we can then just display the login form with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have passed the `handleLogin` function into the `LoginForm`
    component. With this, we are ready to run the application. Our first view looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Login and thus the loading view of our application](img/Figure_7.8_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Login and thus the loading view of our application
  prefs: []
  type: TYPE_NORMAL
- en: Once we enter the correct credentials, we will be able to access the application
    and interact with the to-do items. Our application is essentially working!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built user data model structs and tied them to the to-do
    item data models in our migrations. We then got to dive a little deeper into our
    migrations by firing multiple steps in the SQL file to ensure our migration runs
    smoothly. We also explored how to add unique constraints to certain fields.
  prefs: []
  type: TYPE_NORMAL
- en: Once our data models were defined in the database, we hashed some passwords
    before storing them in our database with the stored user. We then created a JWT
    struct to enable our users to store their JWT in their browsers so that they can
    submit them when making an API call. We then explored how to redirect the URL
    in JavaScript and the HTML storage so that the frontend can work out whether the
    user even has credentials, before it entertains the notion of sending API calls
    to the items.
  prefs: []
  type: TYPE_NORMAL
- en: What we have done here is alter the database with migration so that our app
    can manage data models that handle more complexity. We then utilized frontend
    storage to enable our user to pass credentials. This is directly applicable to
    any other Rust web project you will embark on. Most web apps require some sort
    of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore **REST API** practices, where we will standardize
    interfaces, caching, and logging.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the advantages of defining unique constraints in SQL as opposed to
    server-side code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main advantage of a user having a JWT over storing a password?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a user store a JWT on the frontend?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How could a JWT be useful in the view once we have verified that it is passable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the minimal approach to altering data in the frontend and redirecting
    it to another view when a user hits an endpoint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it useful to have a range of different response codes when logging in
    as a user, as opposed to just denoting that login is successful or unsuccessful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding unique constraints directly on a database ensures that this standard
    is enforced, no matter whether data manipulation is done via migration or a server
    request. This also protects us from corrupting data if a new feature is added
    at another endpoint that forgets to enforce this standard, or if the code is altered
    in later alterations of the endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an attacker manages to obtain a JWT, it does not mean that they have direct
    access to the user’s password. Also, if the tokens get refreshed, then the access
    the attacker has to items has a limited timeframe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JWT can be stored in local HTML storage or cookies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can store multiple data points in the token when hashing it. Therefore, we
    can encrypt the user ID. With this, we can extract the user ID for operations
    related to the to-do item’s creation, deletion, or edit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return an `HttpResponse` struct with HTML/text body that contains a string
    housing a couple of HTML tags. In between these tags are a couple of script tags.
    In between the script tags, we can have each of our JavaScript commands split
    by ;. We can then directly alter the HTML storage and window location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There could be a range of reasons why data gets corrupted on a database, including
    alterations in the migrations. However, there could be an error that is not the
    fault of the user – for instance, a duplicate username for two different users.
    This is an error where our unique constraints have been violated. We need to know
    this has happened so that we can correct it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JWT standard: [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CSS used for the login form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
