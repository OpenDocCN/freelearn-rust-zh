["```rs\nstruct MyData {\n    field1: String,\n    field2: u64,\n}\n```", "```rs\nuse std::fmt;\n\nimpl fmt::Debug for MyData {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"MyData {{ field1: \\\"{}\\\", field2: {} }}\",\n            self.field1, self.field2\n        )\n    }\n}\n```", "```rs\nfn main() {\n    let data = MyData {\n        field1: \"This is my string\".to_owned(),\n        field2: 4402,\n    };\n\n    println!(\"Data: {:?}\", data);\n}\n```", "```rs\nData: MyData { field1: \"This is my string\", field2: 4402 } \n```", "```rs\n#[derive(Debug)]\nstruct MyData {\n    field1: String,\n    field2: u64,\n}\n```", "```rs\nuse std::cmp::Ordering;\n\n#[derive(Eq)]\nstruct DateNotes {\n    day: u8,\n    month: u8,\n    year: i32,\n    comment: String,\n}\n\nimpl PartialEq for DateNotes {\n    fn eq(&self, other: &Self) -> bool {\n        self.day == other.day && self.month == other.month && self.year == other.year\n    }\n}\n\nimpl Ord for DateNotes {\n    fn cmp(&self, other: &Self) -> Ordering {\n        match self.year.cmp(&other.year) {\n            Ordering::Equal => match self.month.cmp(&other.month) {\n                Ordering::Equal => self.day.cmp(&other.day),\n                o => o,\n            },\n            o => o,\n        }\n    }\n}\n\nimpl PartialOrd for DateNotes {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n```", "```rs\n#[derive(Clone, Copy)]\nstruct MyData {\n    field1: u64,\n    field2: f64,\n    field3: i32,\n}\n```", "```rs\n#[derive(Clone)]\nstruct MyData {\n    field1: String,\n    field2: Vec<u32>,\n    field3: i32,\n}\n```", "```rs\nuse std::collections::HashMap;\n\n#[derive(Clone, Hash, PartialEq, Eq)]\nstruct MyData {\n    field1: String,\n    field2: Vec<u32>,\n    field3: i32,\n}\n\nfn main() {\n    let key1 = MyData {\n        field1: \"myField\".to_owned(),\n        field2: vec![0, 1, 2],\n        field3: 1898,\n    };\n\n    let key2 = key1.clone();\n\n    let key3 = MyData {\n        field1: \"myField2\".to_owned(),\n        field2: vec![5, 3, 1],\n        field3: 2345,\n    };\n\n    let mut map = HashMap::new();\n    map.insert(key1, \"MyFirst\");\n\n    assert!(map.get(&key2).is_some());\n    assert!(map.get(&key3).is_none());\n}\n```", "```rs\nuse std::hash::{Hash, Hasher};\n\nimpl Hash for MyData {\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.field1.hash(state);\n        self.field2.hash(state);\n        self.field3.hash(state);\n    }\n}\n```", "```rs\n#[derive(Debug, Default)]\nstruct MyData {\n    field1: String,\n    field2: Vec<u32>,\n    field3: i32,\n}\n\nfn main() {\n    let test1 = MyData {\n        field1: \"sth\".to_owned(),\n        ..Default::default()\n    };\n    let test2 = MyData::default();\n\n    println!(\"test1: {:?}\", test1);\n    println!(\"test2: {:?}\", test2);\n}\n```", "```rs\nlet test3: MyData = Default::default();\n```", "```rs\nimpl Default for MyData {\n    fn default() -> Self {\n        Self {\n            field1: Default::default(),\n            field2: Default::default(),\n            field3: Default::default(),\n        }\n    }\n}\n```", "```rs\n[features]\ndefault = [\"add\"]\nadd = []\nmultiply = [\"expensive_dependency\"]\n```", "```rs\ncargo build --features \"multiply\"\n```", "```rs\n[dependencies.my_dep]\nversion = \"1.0\"\ndefault-features = false\nfeatures = [\"nice_feat\"]\n```", "```rs\n#[cfg(feature = \"add\")]\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n```", "```rs\nif cfg!(target_pointer_width = \"32\") {\n    do_something();\n}\n```", "```rs\nconst THE_KEY: &str = env!(\"KEY\");\n```", "```rs\nconst CRATE_CONFIG: &str = include_str!(\"../Cargo.toml\");\n```", "```rs\nrustup override add nightly\n```", "```rs\nfn iterate_something() -> Box<Iterator<Item = u32>> {\n    unimplemented!()\n}\n```", "```rs\n#![feature(conservative_impl_trait)]\n\nfn iterate_something() -> impl Iterator<Item = u32> {\n    (0..3).into_iter()\n}\n```", "```rs\n#![feature(const_fn)]\n\nconst FIRST_CONST: MyData = MyData::new(23, 275);\nconst SECOND_CONST: MyData = MyData::new(336, 7);\n\n#[derive(Debug)]\nstruct MyData {\n    field1: u32,\n    field2: f32,\n}\n\nimpl MyData {\n    pub const fn new(a: u32, b: u32) -> MyData {\n        MyData {\n            field1: a / b,\n            field2: b as f32 / a as f32,\n        }\n    }\n}\n\nfn main() {\n    println!(\"FIRST_CONST: {:?}\", FIRST_CONST);\n    println!(\"SECOND_CONST: {:?}\", SECOND_CONST);\n\n    let third = MyData::new(78, 22);\n    println!(\"third: {:?}\", third);\n}\n```", "```rs\nFIRST_CONST: MyData { field1: 0, field2: 11.956522 }\nSECOND_CONST: MyData { field1: 48, field2: 0.020833334 }\nthird: MyData { field1: 3, field2: 0.2820513 }\n```", "```rs\n#![feature(i128_type)]\n\nfn main() {\n    assert_eq!(1u128 + 1u128, 2u128);\n    assert_eq!(u128::min_value(), 0);\n    assert_eq!(u128::max_value(),\n               340282366920938463463374607431768211455);\n\n    assert_eq!(1i128 - 2i128, -1i128);\n    assert_eq!(i128::min_value(),\n               -170141183460469231731687303715884105728);\n    assert_eq!(i128::max_value(),\n               170141183460469231731687303715884105727);\n}\n```"]