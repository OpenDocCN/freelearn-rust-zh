- en: Introduction to Client/Server Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端/服务器网络简介
- en: 'This book is an introduction to writing networking applications in Rust. This
    title begs two questions: why should anyone care about networking? And why would
    anyone want to write networking applications in Rust? We attempt to answer the
    first question in this chapter. We will introduce Rust and network programming
    using Rust in subsequent chapters. Firstly, in this chapter, we will start with
    a bit of history and try to understand how network architecture evolved over the
    last hundred years. In subsequent sections, we will see how modern networks are
    layered and addressed. Afterwards, we will describe common service models used
    in networking. We will end with a summary of networking-related programming interfaces
    that Linux exposes. Note that this book deliberately ignores network programming
    in other operating systems and focuses only on Linux for the sake of simplicity.
    While the Rust compiler is platform-agnostic, there can be cases where some things
    are different in other platforms compared to Linux. We will point out those differences
    as we progress.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是关于如何在 Rust 中编写网络应用程序的入门指南。这个标题引出了两个问题：为什么有人会关心网络？为什么有人想要用 Rust 编写网络应用程序？我们试图在本章中回答第一个问题。在随后的章节中，我们将介绍
    Rust 和使用 Rust 进行网络编程。首先，在本章中，我们将从一点历史开始，试图了解网络架构在过去一百年是如何演变的。在随后的部分，我们将看到现代网络是如何分层和寻址的。之后，我们将描述网络中常用的服务模型。我们将以
    Linux 提供的网络相关编程接口的总结结束。请注意，本书故意忽略了其他操作系统的网络编程，为了简化，只关注 Linux。虽然 Rust 编译器是平台无关的，但在其他平台上可能会有一些与
    Linux 不同的情况。我们将随着进展指出这些差异。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: 'History of networking: why and how networks came into use and how the internet
    evolved'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络的历史：为什么网络被使用以及互联网是如何演变的
- en: 'Layering in networks: how layering and encapsulation works'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络分层：分层和封装是如何工作的
- en: 'Addressing: how networks and individual hosts are uniquely identified on the
    internet'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻址：如何在互联网上唯一标识网络和单个主机
- en: How IP routing works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 路由是如何工作的
- en: How DNS works
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名系统（DNS）是如何工作的
- en: Service models for data delivery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输的服务模型
- en: The network programming interface in Linux
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 中的网络编程接口
- en: A brief history of networks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络简史
- en: The modern internet has revolutionized how we communicate with one another.
    However, it had humble beginnings in the Victorian era. One of the earliest precursors
    to the internet was telegraph networks which were operational as early as 1850\.
    Back then, it used to take 10 days to send a message from Europe to North America
    by sea. Telegraph networks reduced that to 17 hours. By the late 19th century,
    the telegraph was a fully successful communication technology that was used widely
    in the two world wars. Around that time, people started building computers to
    help in cracking enemy codes. Unlike our modern mobile phones and laptops, those
    computing machines were often huge and needed specialized environments to be able
    to operate smoothly. Thus, it was necessary to put those in special locations
    while the operators would sit on a terminal. The terminal needed to be able to
    communicate with the computer over short distances. A number of local area networking
    technologies enabled this, the most prominent one being *Ethernet*. Over time,
    these networks grew and by the 1960s, some of these networks were being connected
    with one another to form a larger network of networks. The **Advanced Research
    Projects Agency Network** (**ARPANET**) was established in 1969 and it became
    the first internetwork that resembles the modern internet. Around 1973, there
    were a number of such internetworks all around the world, each using their own
    protocols and methods for communication. Eventually, the protocols were standardized
    so that the networks could communicate with each other seamlessly. All of these
    networks were later merged to form what is the internet today.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现代互联网彻底改变了我们相互沟通的方式。然而，它的起源可以追溯到维多利亚时代。互联网最早的先驱之一是电报网络，这些网络早在1850年就开始运营。当时，通过海上发送一条从欧洲到北美洲的消息需要10天时间。电报网络将这个时间缩短到了17小时。到19世纪末，电报已经成为一种完全成功的通信技术，在两次世界大战中被广泛使用。在那个时期，人们开始建造计算机来帮助破解敌军密码。与我们的现代移动电话和笔记本电脑不同，这些计算机器通常很大，需要专门的环境才能平稳运行。因此，有必要将这些机器放在特殊的位置，而操作员则坐在终端上。终端需要能够在短距离内与计算机通信。一系列局域网技术实现了这一点，其中最突出的是*以太网*。随着时间的推移，这些网络逐渐发展，到20世纪60年代，一些网络开始相互连接，形成一个更大的网络网络。**高级研究计划署网络**（**ARPANET**）于1969年建立，成为第一个类似于现代互联网的互联网。到1973年左右，世界各地都有许多这样的互联网，每个都使用自己的协议和方法进行通信。最终，这些协议被标准化，以便网络能够无缝地相互通信。所有这些网络后来都被合并，形成了今天的互联网。
- en: 'Since networks evolved in silos all around the world, they were often organized
    according to geographical proximity. A **Local Area Network** (**LAN**) is a collection
    of host machines in small proximity like a building or a small neighborhood. A **Wide
    Area Network** (**WAN**) is one that connects multiple neighborhoods; the global
    internet is at the top of the hierarchy. The next picture shows a map of the ARPANET
    in 1977\. Each node in this map is a computer (a server, in today''s terms). Most
    of these were located in large universities like Stanford or at national laboratories
    like Lawrence Berkeley (source: [https://commons.wikimedia.org/wiki/File:Arpanet_logical_map,_march_1977.png](https://commons.wikimedia.org/wiki/File:Arpanet_logical_map,_march_1977.png)).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络在全球范围内独立发展，它们通常根据地理位置组织。**局域网**（**LAN**）是在小范围内（如一栋楼或一个小社区）的计算机集合。**广域网**（**WAN**）是连接多个社区的网；全球互联网位于这个层次结构的顶端。下一张图展示了1977年的ARPANET地图。这张地图上的每个节点都是一台计算机（按照今天的说法，是一台服务器）。其中大部分位于像斯坦福大学这样的大型大学或像劳伦斯伯克利国家实验室这样的国家实验室（来源：[https://commons.wikimedia.org/wiki/File:Arpanet_logical_map,_march_1977.png](https://commons.wikimedia.org/wiki/File:Arpanet_logical_map,_march_1977.png))）。
- en: In networking, a **Request For Comment** (**RFC**) is a document that describes
    how a proposed system should work. These are the first steps towards standardizing
    a protocol or a system. The term internet was first used in RFC 675, which proposed
    a standard for TCP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，**请求评论**（**RFC**）是一份描述拟议系统应如何工作的文档。这些是标准化协议或系统的第一步。术语“互联网”首次出现在RFC 675中，该文档提出了TCP的标准。
- en: '![](img/00005.gif)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.gif)'
- en: Layering in networks
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络分层
- en: Computer science often focuses on subdividing a problem into smaller, hopefully
    independent components that can be solved in isolation. Once that is done, all
    that is needed is a set of rules on how those components should communicate to
    have a solution to the larger problem. This set of rules, along with a pre-agreed
    data format, is called a **protocol**. A network is composed of a number of layers,
    each of which has a fixed purpose. Thus, each of these layers run one or many
    protocols, forming a stack of protocols. In the early days of networking, different
    people implemented their networks in different ways. When the internet was conceived,
    there was a need to make these networks communicate seamlessly. Since they were
    constructed differently, this turned out to be difficult.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学通常关注将问题细分为更小、希望独立的组件，这些组件可以独立解决。一旦这样做，所需要的只是一套规则，说明这些组件应该如何通信，以便对更大的问题有一个解决方案。这组规则，连同预先同意的数据格式，被称为**协议**。网络由多个层次组成，每个层次都有一个固定的目的。因此，这些层次中的每一个都运行一个或多个协议，形成一个协议栈。在网络的早期，不同的人以不同的方式实现了他们的网络。当互联网被构想出来时，需要使这些网络无缝地通信。由于它们的构建方式不同，这最终变得很困难。
- en: 'There was a clear need to agree on standard protocols and interfaces to make
    the internet work. The first attempt at standardizing networking protocols was
    in 1977, which led to the OSI model. This model has the following layers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 明确需要就标准协议和接口达成一致，以使互联网工作。第一次尝试标准化网络协议是在1977年，这导致了OSI模型。此模型具有以下层次：
- en: '**Physical layer**: It defines how data is transmitted in the physical medium
    in terms of its electrical and physical characteristics. This can either be by
    wire, fiber optic, or a wireless medium.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理层**：它定义了从其电气和物理特性方面如何在物理介质中传输数据。这可以是通过电线、光纤或无线介质。'
- en: '**Data link layer**: It defines how data is transmitted between two nodes connected
    by a physical medium. This layer deals with prioritization between multiple parties
    trying to access the wire simultaneously. Another important function of this layer
    is to include some redundancy in the transmitted bits to minimize errors during
    transmission. This is referred to as coding.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据链路层**：它定义了通过物理介质连接的两个节点之间如何传输数据。此层处理多个试图同时访问线的实体之间的优先级问题。此层的重要功能还包括在传输的位中包含一些冗余，以最小化传输过程中的错误。这被称为编码。'
- en: '**Network layer**: It defines how packets (made up of multiple units of data)
    are transmitted between networks. Thus, this layer needs to define how to identify
    hosts and networks uniquely.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络层**：它定义了由多个数据单元组成的数据包如何在网络之间传输。因此，此层需要定义如何唯一地识别主机和网络。'
- en: '**Transport layer**: It defines mechanisms to reliably deliver variable length
    messages to hosts (in the same or different networks). This layer defines a stream
    of packets that the receiver can then listen to.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层**：它定义了将可变长度的消息可靠地传输到主机（在同一网络或不同网络中）的机制。此层定义了一组数据包流，接收者可以监听这些数据包。'
- en: '**Session layer**: It defines how applications running on hosts should communicate.
    This layer needs to differentiate between applications running on the same host
    and deliver packets to them.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话层**：它定义了在主机上运行的应用程序应该如何通信。此层需要区分同一主机上运行的应用程序并将数据包发送给它们。'
- en: '**Presentation layer**: It defines common formats for data representation so
    that different applications can interlink seamlessly. In some cases, this layer
    also takes care of security.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：它定义了数据表示的通用格式，以便不同的应用程序可以无缝地互连。在某些情况下，此层还负责安全。'
- en: '**Application layer**: It defines how user-centric applications should send
    and receive data. An example is the web browser (a user-centric application) using
    HTTP (an application layer protocol) to talk to a web server.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：它定义了以用户为中心的应用程序应该如何发送和接收数据。一个例子是网络浏览器（一个以用户为中心的应用程序）使用HTTP（一个应用层协议）与网络服务器通信。'
- en: 'The following figure shows a visual representation of this model (source: [https://commons.wikimedia.org/wiki/File:Osi-model-jb.svg](https://commons.wikimedia.org/wiki/File:Osi-model-jb.svg)).
    This also shows two vertical classifications, the host running the network stack
    and the physical media (including the wire and the network device). Each layer
    has its own data unit, the representation of the information it works on, and
    since each layer encapsulates the one below it, the data units encapsulate too.
    A number of bits form a frame, a number of frames form a packet, and so on, to
    the top:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了该模型的视觉表示（来源：[https://commons.wikimedia.org/wiki/File:Osi-model-jb.svg](https://commons.wikimedia.org/wiki/File:Osi-model-jb.svg)）。这也显示了两种垂直分类，运行网络栈的主机和物理媒体（包括电线和网络设备）。每一层都有自己的数据单元，即它所处理信息的表示，并且由于每一层封装了其下的一层，数据单元也进行了封装。若干比特组成一个帧，若干帧组成一个数据包，依此类推，直至顶层：
- en: '![](img/00006.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00006.jpeg)'
- en: The OSI model and its layers
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型及其层
- en: 'While OSI was working on standardizing this model, **Defense Advanced Research
    Projects Agency** (**DARPA**) came up with a full implementation of the much simpler
    TCP/IP model (also known as the **IP** (**Internet Protocol**) suite). This model
    has the following layers, from closest to the physical medium to the farthest:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当OSI致力于标准化这一模型时，**国防高级研究计划局**（**DARPA**）提出了一个完整的、更为简单的TCP/IP模型的实现（也称为**IP**（**互联网协议**）套件）。从最接近物理媒体到最远的顺序，该模型具有以下层：
- en: '**Hardware interface layer**: This is a combination of layers one and two of
    the OSI model. This layer is responsible for managing media access control, handling
    transmission and reception of bits, retransmission, and coding (some texts on
    networking differentiate between the hardware interface layer and the link layer.
    This results in a five layer model instead of four. This hardly matters in practice,
    though.)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件接口层**：这是OSI模型第一层和第二层的组合。这一层负责管理媒体访问控制、处理比特的传输和接收、重传以及编码（一些关于网络技术的文本将硬件接口层和链路层区分开来。这导致了一个五层模型而不是四层模型。但在实践中这几乎无关紧要。）'
- en: '**IP layer**: This layer corresponds to layer three of the OSI stack. Thus,
    this layer is responsible for two major tasks: addressing hosts and networks so
    that they can be uniquely identified and given a source and a destination address,
    and computing the path between those given a bunch of constraints (routing).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP层**：这一层对应OSI模型的第三层。因此，这一层负责两大主要任务：为主机和网络分配地址，以便它们能够被唯一识别并赋予源地址和目标地址，以及在给定一系列约束条件（路由）的情况下计算路径。'
- en: '**Transport layer**: This layer corresponds to layer four of the OSI stack.
    This layer converts raw packets to a stream of packets with some guarantees: in-order
    delivery (for TCP) and randomly ordered delivery (for UDP).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层**：这一层对应OSI模型的第四层。这一层将原始数据包转换为带有某些保证的数据包流：按顺序交付（对于TCP）和随机顺序交付（对于UDP）。'
- en: '**Application layer**: This layer combines layers five to seven of the OSI
    stack and is responsible for identifying the process, data formatting, and interfacing
    with all user level applications.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这一层结合了OSI模型的五到七层，负责识别进程、数据格式化以及与所有用户级应用程序的接口。'
- en: Note that the definition of what a particular layer handles changes as we move
    from one layer to another. The hardware interface layer handles collection of
    bits and bytes transmitted by hosts, the IP layer handles packets (the collection
    of a number of bytes sent by a host in a specific format), the transport layer
    bunches together packets from a given process on a host to another process on
    another host to form a segment (for TCP) or datagram (for UDP), and the application
    layer constructs application specific representations from the underlying stream.
    For each of these layers, the representation of data that they deal with is called
    a **Protocol Data Unit** (**PDU**) for that layer. As a consequence of this layering,
    when a process running on a host wants to send data to another host, the data
    must be broken into individual chunks. As the chunk travels from one layer to
    another, each layer adds a header (sometimes a trailer) to the chunk, forming
    the PDU for that layer. This process is called **encapsulation**. Thus, each layer
    provides a set of services to layers above it, specified in the form of a protocol.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们从一层移动到另一层时，特定层处理的内容的定义会发生变化。硬件接口层处理主机传输的比特和字节，IP层处理数据包（主机以特定格式发送的一组字节），传输层将来自主机上某个进程的数据包聚集到另一个主机上的另一个进程，以形成一个段（对于TCP）或数据报（对于UDP），应用层则从底层流中构建特定应用的表现形式。对于这些每一层，它们处理的数据表示称为该层的**协议数据单元**（**PDU**）。由于这种分层，当一个在主机上运行的过程想要向另一个主机发送数据时，数据必须被分割成单独的块。当块从一个层移动到另一个层时，每个层都会给块添加一个头部（有时是尾部），形成该层的PDU。这个过程被称为**封装**。因此，每一层都为其上层提供一组服务，这些服务以协议的形式指定。
- en: The modern internet exhibits a form of geographical hierarchy. Imagine a number
    of homes which are served by a number of **Internet Service Providers** (**ISPs**).
    Each of these homes is in a LAN (either via Ethernet, or more commonly, Wi-Fi).
    The ISP connects many such LANs in a WAN. Each ISP has one or many WANs that they
    connect to form their own network. These larger networks, spanning cities, which
    are controlled by a single business entity, are called **Administrative Systems**
    (**AS**). Routing between multiple ISPs is often more complex than regular IP
    routing since they have to take into account things like trading agreements and
    so on. This is handled by specialized protocols like the **Border Gateway Protocol**
    (**BGP**).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现代互联网表现出一种地理层次结构。想象一下，许多家庭由许多**互联网服务提供商**（**ISP**）提供服务。这些家庭中的每一个都位于一个局域网（通过以太网，或者更常见的是，通过Wi-Fi）。ISP将许多这样的局域网连接起来形成一个广域网。每个ISP连接一个或多个广域网，以形成他们自己的网络。这些跨越城市、由单一商业实体控制的大型网络被称为**管理系统**（**AS**）。在多个ISP之间的路由通常比常规IP路由更复杂，因为他们必须考虑诸如贸易协议等问题。这由专门的协议如**边界网关协议**（**BGP**）来处理。
- en: As mentioned before, one of the earliest and most successful networking technologies
    is Ethernet. First introduced in 1974, it quickly became the predominant technology
    for LAN and WAN due to its low cost and relative ease of maintenance. Ethernet
    is a shared media protocol where all the hosts must use the same physical medium
    to send and receive frames. Frames are delivered to all hosts, which will check
    if the destination MAC address (these addresses will be described in the next
    section) matches its own address. If it does, the frame is accepted, otherwise,
    it is discarded. Since the physical medium can only carry one signal at any given
    moment, there is a probability that frames might collide in transit. If that does
    occur, the sender can sense the collision by sensing transmission from other hosts
    while it is transmitting its frame. It then aborts the transmission and sends
    a jam signal to let other hosts know of the collision. Then, it waits for an exponentially
    backed off amount of time and retries the transmission. After a fixed number of
    attempts, it gives up if the transmission does not succeed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，最早的、最成功的网络技术之一是以太网。1974年首次推出，由于其低成本和相对易于维护，它迅速成为局域网和广域网的主导技术。以太网是一种共享媒体协议，其中所有主机必须使用相同的物理介质来发送和接收帧。帧被发送到所有主机，这些主机将检查目标MAC地址（这些地址将在下一节中描述）是否与其自己的地址匹配。如果匹配，则接受该帧，否则丢弃。由于物理介质在任何给定时刻只能携带一个信号，因此存在帧在传输过程中发生碰撞的概率。如果发生碰撞，发送者可以通过在传输其帧的同时感知来自其他主机的传输来检测到碰撞。然后，它终止传输并发送一个干扰信号，让其他主机知道发生了碰撞。然后，它等待指数退避的时间量，并重试传输。在固定次数的尝试之后，如果传输没有成功，它将放弃。
- en: This scheme is called **carrier-sense multiple access with collision detection**
    (**CSMA/CD**). One problem with Ethernet is its relatively short range. Depending
    on the physical wiring technology used, the maximum length of an Ethernet segment
    varies between 100 m to 500 m. Thus, multiple segments must be connected to form
    a larger network. The most common way of doing that is using layer two switches
    between two adjacent Ethernet segments. Each port of these switches forms different
    collision domains, reducing the overall probability of collisions. These switches
    can also monitor traffic to learn which MAC addresses are on which ports so that
    eventually, they will send out frames for that MAC address only on that port (referred
    to as a learning switch). In modern homes, Wi-Fi is often the dominant LAN technology
    compared to Ethernet.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案被称为**载波侦听多路访问与碰撞检测**（**CSMA/CD**）。以太网的一个问题是它的相对较短的范围。根据所使用的物理布线技术，以太网段的最大长度在100米到500米之间变化。因此，必须连接多个段来形成一个更大的网络。最常见的方法是在相邻的两个以太网段之间使用第二层交换机。这些交换机的每个端口形成不同的碰撞域，从而降低了整体碰撞的概率。这些交换机还可以监控流量，以了解哪些MAC地址连接到哪个端口，这样最终它们只会在该端口发送针对该MAC地址的帧（称为学习交换机）。在现代家庭中，与以太网相比，Wi-Fi通常是占主导地位的局域网技术。
- en: Addressing in networks
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络寻址
- en: 'We have seen why it is important to identify hosts and networks uniquely to
    be able to deliver packets reliably. Depending on the scale, there are three major
    ways of doing this; we will discuss each of those in this section. The end to
    end process of IP routing will be discussed in the next section. One interesting
    fact to note is that for each of these addressing modes, one or more addresses
    are reserved for special use. Often, these are marked by a known set of bits being
    on or off in a known pattern:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，为了可靠地递送数据包，识别主机和网络是唯一重要的。根据规模，有三种主要的方法来实现这一点；我们将在本节中讨论这些方法中的每一个。IP路由的端到端过程将在下一节中讨论。一个值得注意的有趣事实是，对于这些寻址模式中的每一个，都保留了一个或多个地址用于特殊用途。通常，这些地址通过在已知模式中已知位是开还是关来标记：
- en: '**Ethernet address**: This is also known as a **Media Access Control** (**MAC**)
    address. It is a 48-bit long unique identifier assigned to a network device (usually
    stored on the card) that is used to identify it in a network segment. Usually,
    these are programmed by the network card manufacturer, but all modern OS''s allow
    one to modify it. The standard way of writing Ethernet addresses are in six groups
    of two hexadecimal digits (01-23-45-67-89-ab-cd-ef). Another common way is to
    use a colon to separate the digits (01:23:45:67:89:ab:cd:ef). A few special sequences
    of bits are reserved for addressing special cases: the sender can request that an
    Ethernet frame should be received by all hosts in that segment by setting the
    least significant bit of the first octet to 1; this is called multicasting. If
    that particular bit is set to 0, the frame should be delivered to only one receiver. Today,
    these are used widely with Ethernet and Wi-Fi.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以太网地址**：这也被称为**媒体访问控制**（**MAC**）地址。它是一个48位的唯一标识符，分配给网络设备（通常存储在卡上），用于在子网中识别它。通常，这些地址由网卡制造商编程，但所有现代操作系统都允许用户修改它。以太网地址的标准写法是六组两位十六进制数字（01-23-45-67-89-ab-cd-ef）。另一种常见的方法是使用冒号分隔数字（01:23:45:67:89:ab:cd:ef）。一些特殊的比特序列被保留用于特殊地址：发送者可以请求以太网帧被该段的所有主机接收，通过将第一个八位字节的最不重要位设置为1来实现；这被称为多播。如果该位设置为0，则帧应仅发送给一个接收者。今天，这些在以太网和Wi-Fi中得到了广泛的应用。'
- en: '**IP address**: This is an address assigned to each device in an IP network.
    The original IP address standard (IPv4) defined 32-bit addresses in 1980\. However,
    by 1995, it was obvious that the total number of available addresses on the internet
    is not enough to cover all devices. This led to the development of IPv6, which
    expanded the address space to 128 bits. The standard way of dealing with a group
    of IP addresses is using the CIDR notation, for example, 192.168.100.1/26 (IPv4).
    The decimal number after the slash counts the number of leading 1s in the network
    mask. Thus, in this particular case, there are *2^(32-26) = 64* addresses in the
    network starting from 192.168.100.0 to 192.168.100.63. The **Internet Assigned
    Numbers Authority** (**IANA**) assigns blocks of publicly routable IP addresses
    to organizations. A number of IPv4 and v6 addresses are reserved for various purposes
    like addressing in private networks and so on. In a home network (which will always
    use special private range addresses), these are assigned by the **Dynamic Host
    Configuration Protocol** (**DHCP**) by the Wi-Fi router.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP地址**：这是分配给IP网络中每个设备的地址。最初的IP地址标准（IPv4）在1980年定义了32位的地址。然而，到了1995年，很明显，互联网上可用的地址总数不足以覆盖所有设备。这导致了IPv6的发展，它将地址空间扩展到128位。处理一组IP地址的标准方式是使用CIDR表示法，例如，192.168.100.1/26（IPv4）。斜杠后的十进制数字表示网络掩码中前导1的数量。因此，在这个特定的情况下，从192.168.100.0到192.168.100.63的网络中有*2^(32-26)
    = 64*个地址。**互联网名称与数字地址分配机构**（**IANA**）将公开可路由的IP地址块分配给组织。许多IPv4和v6地址被预留用于各种目的，如私有网络中的寻址等。在家庭网络（将始终使用特殊的私有范围地址）中，这些地址由Wi-Fi路由器通过**动态主机配置协议**（**DHCP**）分配。'
- en: '**Autonomous system number:** This is a 32-bit number used to uniquely identify
    autonomous systems. Like IP addresses, these are assigned and maintained by the
    IANA.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自治系统编号**：这是一个32位的数字，用于唯一标识自治系统。像IP地址一样，这些由**互联网名称与数字地址分配机构**（**IANA**）分配和维护。'
- en: Apart from these, communication between hosts often uses a port number to distinguish
    between processes. When the OS allocates a specific port to a process, it updates
    its database of the mapping between process identifier and port number. Thus,
    when it receives incoming packets on that port, it knows what process to deliver
    those packets to. In case the process has exited by that time, the OS will drop
    the packets and in the case of TCP, initiate closing of the connection. In the
    subsequent sections, we will see how TCP works in practice.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，主机之间的通信通常使用端口号来区分进程。当操作系统为进程分配一个特定的端口时，它会更新其进程标识符和端口号之间的映射数据库。因此，当它在该端口上接收传入的数据包时，它知道要将这些数据包发送给哪个进程。如果到那时进程已经退出，操作系统将丢弃这些数据包，在TCP的情况下，将启动连接的关闭。在随后的章节中，我们将看到TCP在实际中是如何工作的。
- en: A range of port numbers between 0 and 1024 are reserved for common services
    by the OS. Other applications are free to request any port above 1024.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统为0到1024之间的端口范围预留了常见服务。其他应用程序可以请求1024以上的任何端口。
- en: How IP routing works
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP路由工作原理
- en: 'To understand how IP routing works, we must first begin with the structure
    of IPv4 addresses. As described in the last section, these are 32 bits in length.
    They are written in a dotted decimal notation in groups of 4 bytes (for example,
    192.168.122.5). A given number of bits in that network prefix is used to identify
    the network where the packet should be delivered, and the rest of the bits identify
    the particular host. Thus, all hosts in the same network must have the same prefix.
    Conventionally, the prefix is described in the CIDR notation with the starting
    address and the number of bits in the network portion of the address separated
    by a slash (192.168.122.0/30). The number can then be used to find out how many
    addresses are available for hosts in the network (in this case, *2^(32-30) = 4*).
    Given an IP address and a prefix, the network address can be extracted by bitwise-ANDing
    the address with a mask of all 1s in the network portion. Calculating the host
    address is just the reverse; we will need to AND with the network mask''s logical
    negation (the host mask), which has all 0s in the network portion and all 1s in
    the host portion. Given an address and a prefix like 192.168.122.5/27, we will
    compute these as shown in the following figure. Thus, for the given CIDR, the
    network address is 192.168.122.0 and the host address is 0.0.0.5:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解IP路由是如何工作的，我们必须首先从IPv4地址的结构开始。如上一节所述，这些地址长度为32位。它们以每组4字节的点分十进制表示法书写（例如，192.168.122.5）。网络前缀中一定数量的位被用来标识数据包应该被发送到的网络，其余的位标识特定的主机。因此，同一网络中的所有主机必须具有相同的网络前缀。传统上，前缀用CIDR表示法描述，起始地址和地址的网络部分中的位数由一个斜杠分隔（192.168.122.0/30）。这个数字可以用来找出网络中可用于主机的地址数量（在这种情况下，*2^(32-30)
    = 4*）。给定一个IP地址和一个前缀，可以通过与网络部分全1的掩码进行位与操作来提取网络地址。计算主机地址正好相反；我们需要与网络掩码的逻辑否定（主机掩码）进行与操作，该掩码在网络部分全0，在主机部分全1。给定一个地址和一个前缀，如192.168.122.5/27，我们将按以下图示进行计算。因此，对于给定的CIDR，网络地址是192.168.122.0，主机地址是0.0.0.5：
- en: '![](img/00007.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: CIDR to network and host address conversion
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: CIDR到网络和主机地址的转换
- en: As described before, each IP network will have a reserved broadcast address
    that can be used for a host to send a message to all hosts in that network. This
    can be computed by ORing with the host mask. In our example, this comes out to
    be 192.168.122.31\. Note that the network address can not be a valid host address.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个IP网络都将有一个保留的广播地址，该地址可以被主机用来向该网络中的所有主机发送消息。这可以通过与主机掩码进行OR操作来计算。在我们的例子中，结果是192.168.122.31。请注意，网络地址不能是一个有效的主机地址。
- en: 'There are two broad classes of IP address; some blocks of addresses can be
    routed in the public internet, these are called public IP addresses. Some other
    blocks can only be used in private networks that do not directly interface with
    the internet, these are called private addresses. If a router on the internet
    receives a packet that is destined for a private IP address, it will have to drop
    that packet. Other than these two, IP addresses are also classified on various
    parameters: some are reserved for documentation only (192.0.2.0/24), some are
    reserved for point to point communication between two hosts (169.254.0.0/16),
    and so on. The Rust standard library has convenience methods to classify IP addresses
    according to their types.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址大致分为两大类；一些地址块可以在公共互联网中路由，这些被称为公共IP地址。还有一些其他地址块只能用于不直接与互联网接口的私有网络，这些被称为私有地址。如果互联网上的一个路由器收到一个目的地为私有IP地址的数据包，它将不得不丢弃该数据包。除了这两类之外，IP地址还可以根据各种参数进行分类：一些地址仅保留用于文档（192.0.2.0/24），一些地址仅保留用于两个主机之间的点对点通信（169.254.0.0/16），等等。Rust标准库提供了方便的方法来根据IP地址的类型进行分类。
- en: All routers maintain a routing table which maps prefixes to the outgoing interface
    of the router (while a router administrator might decide to store individual addresses
    instead of prefixes, this will quickly lead to a large routing table in a busy
    router). An entry in the table basically says *If a packet needs to go to this
    network, it should be sent on this interface*. The next host that receives the
    packet might be another router or the destination host. How do routers figure
    out this table? Multiple routers run routing protocols between those which compute
    those tables. Some common examples are OSPF, RIP, and BGP. Given these primitives,
    the actual routing mechanism is fairly simple, as shown in the next diagram.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有路由器都维护一个路由表，该表将前缀映射到路由器的输出接口（虽然路由器管理员可能会决定存储单个地址而不是前缀，但这将很快导致繁忙路由器上的路由表变得很大）。表中的条目基本上表示“如果数据包需要到达这个网络，它应该通过这个接口发送”。接收数据包的下一位主机可能是另一个路由器或目标主机。路由器是如何确定这个表的？多个路由器在那些计算这些表的路由器之间运行路由协议。一些常见的例子是OSPF、RIP和BGP。给定这些原语，实际的路由机制相当简单，如图中所示。
- en: 'An interesting aspect of IP is the use of the **Time To Live** (**TTL**) field,
    this is also known as hop limit. The host sends out packets with a fixed value
    of TTL (usually 64). Each router the packet crossed decreases the TTL. When it
    reaches 0, the packet is discarded. This mechanism ensures that packets are not
    stuck in an infinite loop between routers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: IP的一个有趣方面是使用**生存时间**（**TTL**）字段，这也被称为跳数限制。主机以固定的TTL值（通常是64）发送数据包。每个数据包经过的路由器都会减少TTL。当它达到0时，数据包将被丢弃。这种机制确保数据包不会在路由器之间陷入无限循环：
- en: '![](img/00008.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00008.jpeg)'
- en: General routing algorithm
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通用路由算法
- en: '**Internet Control Message Protocol** (**ICMP**) is used to exchange operational
    information between network devices. In the preceding example, one or multiple
    routers might decide to send back an ICMP error if they are configured to do so.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网控制消息协议**（**ICMP**）用于在网络设备之间交换操作信息。在前面的示例中，一个或多个路由器可能会决定发送回ICMP错误，如果它们被配置为这样做的话。'
- en: 'Note that while trying to match the prefix to routes in the routing table,
    multiple routes might match. If that happens, the router must select the most
    specific match and use that for forwarding. Since the most specific routes will
    have the maximum number of leading 1s, and hence the largest prefix, this is called
    the longest prefix match. Say our router has the following routing table, as shown
    in the diagram. **eth1**, **eth2,** and **eth3** are three network interfaces
    attached to our router, each having a different IP address in different networks:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在尝试将前缀与路由表中的路由匹配时，可能会有多个路由匹配。如果发生这种情况，路由器必须选择最具体的匹配项，并使用该匹配项进行转发。由于最具体的路由将具有最多的前导1位，因此具有最大的前缀，这被称为最长前缀匹配。假设我们的路由器具有以下路由表，如图所示。**eth1**、**eth2**和**eth3**是我们路由器上的三个网络接口，每个接口在不同的网络中具有不同的IP地址：
- en: '![](img/00009.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00009.jpeg)'
- en: Longest prefix matching example
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最长前缀匹配示例
- en: At this point, if our device gets a packet that has a destination address set
    to 192.168.1.33, all three prefixes have this address but the last one is the
    largest of the three. So, the packet will go out through **eth3**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果我们的设备收到一个目标地址设置为192.168.1.33的数据包，所有三个前缀都有这个地址，但最后一个是最长的。因此，数据包将通过**eth3**发送出去。
- en: A lot of what we described so far about IPv4 addresses does not change for IPv6,
    except, of course, it has a larger address space of 128 bits. In this case, the
    length of the network mask and the host mask depends on the address type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前关于IPv4地址所描述的许多内容对于IPv6来说并没有改变，当然，IPv6具有更大的128位地址空间。在这种情况下，网络掩码和主机掩码的长度取决于地址类型。
- en: 'One might be wondering, how do routers construct the routing table? As always,
    there are protocols to help with that. Routing protocols are of two major types:
    interior gateway protocols which are used for routing inside an autonomous system,
    and exterior gateway protocols which are used in routing between autonomous systems;
    an example of the latter is BGP. Interior gateway protocols can again be of two
    types, depending on how they look at the whole network. In link state routing,
    each router participating in the protocol maintains a view of the whole network
    topology. In distance vector routing, each router only knows about its one hop
    neighbors. An example of the former is the **Routing Information Protocol** (**RIP**)
    and of the latter is **Open Shortest Path First** (**OSPF**). Details about these
    are beyond the scope of this book. However, we can note that the common theme
    among all the routing protocols is that they work by exchanging information between
    routers. Thus, they have their own packet formats for encapsulating that information.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有人会想知道，路由器是如何构建路由表的？一如既往，有协议来帮助完成这项工作。路由协议主要有两种类型：内部网关协议，用于在自治系统内部进行路由，以及外部网关协议，用于在自治系统之间进行路由；后者的一个例子是
    BGP。内部网关协议又可以分为两种类型，这取决于它们如何看待整个网络。在链路状态路由中，每个参与协议的路由器维护整个网络拓扑的视图。在距离向量路由中，每个路由器只知道其单跳邻居。前者的一个例子是
    **路由信息协议**（**RIP**），后者的一个例子是 **开放最短路径优先**（**OSPF**）。关于这些的详细信息超出了本书的范围。然而，我们可以注意到，所有路由协议的共同主题是它们通过在路由器之间交换信息来工作。因此，它们有自己的数据包格式来封装这些信息。
- en: How DNS works
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS 的工作原理
- en: 'Note that it''s impossible for anyone to remember the IP address of each and
    every service on the internet. Fortunately, there is a protocol for that! The
    **Domain Name Server** (**DNS**) solves this problem by maintaining a map of a
    human readable hierarchical name to the IP address of the service in a distributed
    database. Thus, when a user enters [http://www.google.com](http://www.google.com)
    in their browser and hits the *Enter* key, the first step is to look up the IP
    address of the name *www.google.com* using DNS. The next figure shows the steps
    necessary in such a query. In this discussion, we will use the names **local DNS
    resolver**, **local DNS server,** and **local DNS nameserver **interchangeably:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有人能够记住互联网上每个和每个服务的 IP 地址。幸运的是，有一个协议可以解决这个问题！**域名服务器**（**DNS**）通过在分布式数据库中维护一个人类可读的分层名称到服务
    IP 地址的映射来解决此问题。因此，当用户在浏览器中输入 [http://www.google.com](http://www.google.com) 并按下
    *Enter* 键时，第一步是使用 DNS 查找名称 *www.google.com* 的 IP 地址。下图显示了此类查询所需的步骤。在这次讨论中，我们将
    **本地 DNS 解析器**、**本地 DNS 服务器** 和 **本地 DNS 域名服务器** 互换使用：
- en: '![](img/00010.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00010.jpeg)'
- en: How DNS works
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 的工作原理
- en: 'An application that needs to resolve a name will use a system call like `getaddrinfo`.
    This essentially asks the OS to go ahead and resolve the name. This step is not
    shown in the figure. The next steps are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解析名称的应用程序将使用类似 `getaddrinfo` 的系统调用。这本质上是在请求操作系统去解析该名称。这一步在图中没有显示。接下来的步骤如下：
- en: Typically, each computer in a network will have a local DNS server configured
    in the file `/etc/resolv.conf`. In most cases, this points to the ISP's DNS server.
    This might also point to the home Wi-Fi router's DNS server. In that case, the
    DNS will transparently proxy requests to the ISP's DNS server. The OS will then
    query that server, asking the IP of the given name **www.google.com.**
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，网络中的每一台计算机都会在文件 `/etc/resolv.conf` 中配置一个本地 DNS 服务器。在大多数情况下，这指向 ISP 的 DNS
    服务器。这也可能指向家庭 Wi-Fi 路由器的 DNS 服务器。在这种情况下，DNS 将透明地代理请求到 ISP 的 DNS 服务器。然后操作系统将查询该服务器，询问给定名称
    **www.google.com** 的 IP 地址。
- en: The local DNS server will, in turn, ask the same question to a pre-populated
    list of root name servers. These servers are maintained by ICANN and their addresses
    are well-known. They maintain addresses for the top level domain name servers.
    This means that they know the addresses of namesevers for the `.com` domain.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地 DNS 服务器将反过来向预先填充的根域名服务器列表提出相同的问题。这些服务器由 ICANN 维护，它们的地址是众所周知的。它们维护顶级域名服务器的地址。这意味着它们知道
    `.com` 域名服务器的地址。
- en: In this step, the root name server replies with the addresses of TLD name servers
    for the `.com` domain. These servers maintain a list of addresses for name servers
    in their own domains.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，根域名服务器将回复 `.com` 域名的顶级域名服务器地址。这些服务器维护它们自己域中域名服务器的地址列表。
- en: The local DNS server then contacts one of those and asks the same question.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地DNS服务器随后联系这些服务器之一并询问相同的问题。
- en: The TLD name server replies back with the addresses of servers in the `google.com`
    domain. An admin of the `google.com` domain maintains a bunch of nameservers for
    that domain. Those nameservers have full authority over all records in that domain,
    and each of those records are marked *authoritative* to indicate that.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TLD名称服务器回复`google.com`域中服务器的地址。`google.com`域的管理员为该域维护了一组名称服务器。这些名称服务器对该域中的所有记录拥有完全的权威性，并且每个记录都被标记为*权威性*，以表明这一点。
- en: The local DNS server then asks one of those the same question.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地DNS服务器随后向这些服务器之一提出相同的问题。
- en: (Hopefully) that server does know the address of *www.google.com*. If it does,
    it prepares a response, marks it as authoritative, and sends it back to the local
    DNS server. The answer can also have a time to live associated with it so that
    the local DNS server can cache it for future use and evict it after the given
    time is over. If it does not, name resolution will fail and it will send back
    a special response called NXDOMAIN.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (希望)该服务器知道*www.google.com*的地址。如果它知道，它准备一个响应，将其标记为权威性，并将其发送回本地DNS服务器。答案还可以与一个生存时间相关联，这样本地DNS服务器就可以将其缓存以供将来使用，并在给定时间过后将其删除。如果它不知道，名称解析将失败，并将发送回一个称为NXDOMAIN的特殊响应。
- en: The local DNS server then sends back the same response to the OS, which delivers
    it to the application. The local server marks the response as non-authoritative,
    indicating that it got that answer from somewhere else.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地DNS服务器随后将相同的响应发送回操作系统，操作系统再将它传递给应用程序。本地服务器将此响应标记为非权威性，表示它从别处获得了这个答案。
- en: Interestingly, DNS is like asking a friend for someone's address, who then says
    *I do not know, but I know someone who knows someone who knows someone who might
    know. I can find out for you! *They then go and ask around and return with a reply.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，DNS就像向朋友询问某人的地址，朋友说*我不知道，但我认识一个认识一个认识一个可能知道的人。我可以帮你找到！*然后他们四处询问并带回来一个回复。
- en: DNS packets are often very small since they have a small question and answer
    along with some control information, and since DNS does not need very high reliability
    from the transport layer, this makes it an ideal candidate for using UDP (described
    in the next section). However, most implementations include an option to fall
    back to TCP if the transport is too unreliable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: DNS数据包通常非常小，因为它们包含一个小的疑问和答案以及一些控制信息，并且由于DNS不需要从传输层获得非常高的可靠性，这使得它成为使用UDP（在下节中描述）的理想候选者。然而，大多数实现都包括一个选项，如果传输不可靠，则回退到TCP。
- en: DNS supports multiple record types for various things. The *A* record maps a
    name to an IPv4 address, *AAAA* record maps a name to a IPv6 address, and so on.
    Reverse lookups are supported using *PTR* records.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: DNS支持多种记录类型，用于各种事物。*A*记录将名称映射到IPv4地址，*AAAA*记录将名称映射到IPv6地址，等等。反向查找可以使用*PTR*记录支持。
- en: Common service models
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的服务模型
- en: For two hosts to communicate via a network, they will need to send messages
    to each other. There are two models of exchanging messages, and each has specific
    usecases where they work best. In this section, we will explore these. Note that
    the service models are properties of the protocols and that they set expectations
    around what a consumer should expect from them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了两个主机通过网络进行通信，它们需要互相发送消息。有两种交换消息的模型，每种模型都有其最佳使用场景。在本节中，我们将探讨这些。请注意，服务模型是协议的特性，并且它们设定了消费者对这些协议的期望。
- en: Connection-oriented service
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向连接的服务
- en: 'The service a protocol provides to its consumers is connection oriented when
    each party involved negotiates a virtual connection before sending the actual
    data. During the setup process, a number of parameters about the connection must
    be agreed upon. This is analogous to the older wired telephone systems, where
    a dedicated connection is set up between the two hosts. In modern networks, an
    example is TCP. The PDU for TCP is a segment, which consists of a header and a
    data section. The header has a few fields which are used to transition between
    states of the protocol state machine. The next figure shows what the TCP header
    looks like in practice. Each of the rows in this figure are of 32 bits (thus,
    each row is two octets), and some are divided into multiple segments:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个参与方在发送实际数据之前协商一个虚拟连接时，协议提供给其消费者的服务是面向连接的。在设置过程中，必须就连接的一些参数达成一致。这与较老的固定电话系统类似，其中两个主机之间会建立一个专用连接。在现代网络中，一个例子是TCP。TCP的PDU是一个段，它由一个头部和一个数据部分组成。头部有几个字段，用于在协议状态机的状态之间进行转换。下图显示了TCP头部在实际中的样子。这张图中的每一行都是32位（因此，每一行是两个八位字节），其中一些被分割成多个段：
- en: '![](img/00011.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00011.jpeg)'
- en: TCP header format
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: TCP头部格式
- en: 'We will look at a few of these which are used for manipulating the connection
    between hosts:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看其中一些用于在主机之间操作连接的：
- en: Control bits (flags) are a set of 9 bits that are used for various purposes.
    The flags of interest here are SYN, ACK, FIN, and RST. SYN triggers a synchronization
    of sequence numbers. The ACK flag indicates that the receiver should care about
    the corresponding acknowledgment number. The FIN flag starts the process of tearing
    down a connection. The RST flag resets the connection in case of an error.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制位（标志位）是一组用于各种目的的9位。这里感兴趣的标志位有SYN、ACK、FIN和RST。SYN触发序列号的同步。ACK标志表示接收方应关注相应的确认号。FIN标志开始断开连接的过程。RST标志在出现错误时重置连接。
- en: The sequence number is a 32-bit field which is used to reorder messages at the
    receiver. When the SYN flag is set (which should be the case only for the first
    packet in a connection), the sequence number is the initial sequence number; otherwise,
    it is the sequence number accumulated so far.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列号是一个32位字段，用于在接收方重新排序消息。当SYN标志被设置（这应该只适用于连接中的第一个数据包），序列号是初始序列号；否则，它是到目前为止累积的序列号。
- en: The acknowledgement number is a 32-bit field which is used to enable reliable
    delivery of messages. If the ACK flag is set, this value is the next sequence
    number that the sender is expecting.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认号是一个32位字段，用于启用消息的可靠交付。如果ACK标志被设置，这个值是发送方期望的下一个序列号。
- en: 'Before two hosts running TCP can start exchanging data, they must do a three-way
    handshake to establish a connection. This works like this: the client that wants
    to initiate communication sends a SYN packet to the server. The sequence number
    is set to a random value and the SYN flag is set to 1\. The server responds with
    a packet that has both SYN and ACK set to 1\. This packet has the acknowledgment
    number set to one more than what it got from the client, and the sequence number
    is set to a random number. Finally, the client responds with a packet that has
    the ACK flag set, the sequence number set to the received acknowledgement number
    in the last step, and the acknowledgement number is set to one more than the sequence
    number in the previous step. After this is done successfully, both the client
    and the server have agreed on sequence and acknowledgement numbers. The advantage
    of this model is that is has a reliable connection where both the sender and the
    receiver knows what to expect. The sender can tune the rate of sending data, depending
    on how fast or slow the receiver is or how congested the network is. The disadvantage
    here is the higher connection setup costs. Assuming it takes 100 ms to send a
    packet to a host in another continent, we will need to exchange at least 3 packets
    before we can begin sending data. That amounts to a delay of 300 ms. While this
    might not look like a lot, remember that at any given point, a laptop being used
    for accessing Facebook might have thousands of connections open to servers all
    over the world. The connection oriented service model works fine for a large number
    of use cases, but there are a few cases where the overhead is either significant
    or unnecessary. An example is video streaming. In this case, a few missing packets
    do not cause a huge problem since no one notices a small number of misaligned
    pixels in the video. These applications prefer a connectionless model, as described
    below.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个运行TCP协议的主机开始交换数据之前，它们必须进行三次握手来建立连接。这个过程是这样的：想要发起通信的客户端向服务器发送一个SYN数据包。序列号被设置为随机值，SYN标志被设置为1。服务器响应一个同时设置了SYN和ACK标志的数据包。这个数据包的确认号设置为比从客户端接收到的值多1，序列号被设置为随机数。最后，客户端响应一个设置了ACK标志的数据包，序列号设置为上一步接收到的确认号，确认号设置为上一步序列号加1。成功完成这个过程后，客户端和服务器就同意了序列号和确认号。这种模型的优势在于它有一个可靠的连接，发送方和接收方都知道可以期待什么。发送方可以根据接收方的速度或网络拥堵程度调整发送数据的速率。这里的缺点是连接建立的成本较高。假设向另一个大陆的主机发送一个数据包需要100毫秒，我们至少需要交换3个数据包才能开始发送数据。这相当于300毫秒的延迟。虽然这可能看起来不多，但记住，在任何给定时刻，用于访问Facebook的笔记本电脑可能已经打开了成千上万的连接到世界各地的服务器。面向连接的服务模型对于大量用例来说工作得很好，但也有一些情况，其中开销要么很大，要么是不必要的。一个例子是视频流。在这种情况下，丢失几个数据包不会造成大问题，因为没有人会注意到视频中的少量错位像素。这些应用程序更喜欢无连接模型，如下所述。
- en: Connectionless service
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无连接服务
- en: 'The second case here is a connectionless service. This is used when multiple
    messages bear no relation to one another, and thus these protocols do not need
    any connection negotiation step before sending any data. An example of this is
    UDP, which provides no guarantees of the sequence or reliability of transmitted
    messages (it does, however, have a checksum field to guarantee the correctness
    of the datagram). One should note that the protocol running above UDP is always
    free to implement reliability if that is desired. Interestingly, IP routing is
    also a connectionless service. The UDP header is shown as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是无连接服务。当多个消息之间没有关系时，就会使用这种服务。在发送任何数据之前，这些协议不需要进行任何连接协商步骤。一个例子是UDP，它不提供传输消息的顺序或可靠性保证（然而，它确实有一个校验和字段来保证数据报的正确性）。应该注意的是，运行在UDP之上的协议总是可以自由实现可靠性，如果需要的话。有趣的是，IP路由也是一个无连接服务。UDP头部格式如下所示：
- en: '![](img/00012.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.jpeg)'
- en: UDP header format
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: UDP头部格式
- en: It's easy to see that the header here is far smaller than a TCP header. It also
    lacks a number of fields that TCP uses to manage the connection and tune it according
    to network congestion and so on. Since UDP does not have those fields, it cannot
    provide those guarantees.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出这里的头部比TCP头部小得多。它还缺少TCP用来管理连接并根据网络拥堵等因素调整连接的许多字段。由于UDP没有这些字段，它不能提供这些保证。
- en: The network programming interface in Linux
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux中的网络编程接口
- en: In this section, we will see how Linux (and a lot of other members of the Unix
    family) implement common network patterns, and how a user will interact with those
    while writing networking applications. All discussions in this section will be
    strictly based on a Linux-like OS with the standard C library (glibc). The **Portable
    OS Interface** (**POSIX**) standard includes all of these, making them portable
    to any POSIX compliant OS. All functions and data structures here follow C (and
    C++) coding conventions, but as we will see later, some of these are available
    in Rust as well through libc bindings.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解Linux（以及Unix家族中的许多其他成员）如何实现常见的网络模式，以及用户在编写网络应用程序时如何与这些模式交互。本节的所有讨论都将严格基于具有标准C库（glibc）的类似Linux的操作系统。**可移植操作系统接口**（**POSIX**）标准包括所有这些，使它们可移植到任何符合POSIX的操作系统。这里的所有函数和数据结构都遵循C（和C++）编码约定，但正如我们稍后将看到的，其中一些也通过libc绑定在Rust中可用。
- en: The most important networking primitive that the OS provides is a *socket. *Now,
    what is a socket? A socket is a glorified file descriptor, a unique ID that is
    assigned to each file in a Unix-like OS. This follows from the Unix philosophy
    that everything should be a file; treating the connection between two hosts over
    a network as a file enables the OS to expose it as a file descriptor. The programmer
    is then free to use traditional I/O-related syscalls to write and receive from
    that file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提供的最重要的网络原语是*套接字*。那么，什么是套接字？套接字是一个被美化的文件描述符，是一个在类Unix操作系统中分配给每个文件的唯一ID。这源于Unix哲学，即一切都应该是一个文件；将两个主机之间的网络连接视为一个文件，使得操作系统可以将其作为文件描述符暴露出来。然后程序员可以自由使用传统的I/O相关系统调用来从这个文件写入和接收数据。
- en: Now, obviously, a socket needs to hold some more data than a regular file descriptor.
    For instance, it needs to track the remote IP and port (and also the local IP
    and port). Thus, a socket is a logical abstraction for the connection between
    two hosts, along with all information needed to transfer data between those hosts.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，显然，套接字需要比常规文件描述符持有更多的数据。例如，它需要跟踪远程IP和端口（以及本地IP和端口）。因此，套接字是两个主机之间连接的逻辑抽象，包括在那些主机之间传输数据所需的所有信息。
- en: 'There are two major classes of sockets: UNIX sockets for communicating with
    processes on the same host, and internet sockets for communication over an IP
    network.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种主要的套接字类别：UNIX套接字用于与同一主机上的进程通信，以及互联网套接字用于通过IP网络进行通信。
- en: 'The standard library also provides a few system calls for interacting with
    sockets. Some of those are socket specific and some of them are generic I/O syscalls
    that support writing to file descriptors. Since a socket is basically a file descriptor,
    those can be used to interact with sockets. Some of these are described in the
    next image. Note that not all applications will need to use all of these syscalls.
    A server, for instance, will need to call listen to start listening for incoming
    connections once it has created a socket. It will not need to call connect for
    that same connection:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库还提供了一些系统调用用于与套接字交互。其中一些是针对套接字的特定调用，而另一些是通用的I/O系统调用，支持写入文件描述符。由于套接字基本上是一个文件描述符，因此可以使用这些调用与套接字交互。其中一些将在下一张图中描述。请注意，并非所有应用程序都需要使用所有这些系统调用。例如，一旦创建套接字，服务器将需要调用listen来开始监听传入的连接，它不需要为该连接调用connect：
- en: '![](img/00013.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00013.jpeg)'
- en: Common networking system calls
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 常见网络系统调用
- en: Any Unix-like OS will have detailed documentation for each of these syscalls
    in the manpages. The docs for the socket syscall, for example, can be accessed
    using the command `man socket`. The second argument to the `man` command is the
    section of the manpages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类Unix操作系统都会在man手册页中对这些系统调用提供详细的文档。例如，套接字系统调用的文档可以通过命令`man socket`访问。`man`命令的第二个参数是man手册页的章节。
- en: Let's look at the signatures of these syscalls in more detail. Unless otherwise
    mentioned, all of these return 0 on success or -1 on failure, and set the value
    of errno accordingly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看这些系统调用的签名。除非另有说明，否则所有这些在成功时返回0，在失败时返回-1，并相应地设置errno的值。
- en: '[PRE0]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first parameter for the `socket` syscall tells it what kind of communication `socket` will
    be used. Common types are AF_INET for IPv4, AF_INET6 for IPv6, AF_UNIX for IPC,
    and so on. The second parameter tells it what type of socket should be created,
    common values being SOCK_STREAM for a TCP socket, SOCK_DGRAM for a UDP socket, SOCK_RAW
    for a raw socket which provides direct access to the network hardware at packet
    level, and so on. The last parameter denotes the layer 3 protocol to be used;
    in our case, this is exclusively IP. A complete list of supported protocols is
    available in the file `/etc/protocols`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket`系统调用的第一个参数告诉它将使用哪种类型的通信`socket`。常见的类型有AF_INET用于IPv4，AF_INET6用于IPv6，AF_UNIX用于IPC等。第二个参数告诉它应该创建哪种类型的套接字，常见的值包括SOCK_STREAM用于TCP套接字，SOCK_DGRAM用于UDP套接字，SOCK_RAW用于提供数据包级别的直接网络硬件访问的原始套接字等。最后一个参数表示要使用的第3层协议；在我们的情况下，这仅限于IP。支持的所有协议的完整列表可在文件`/etc/protocols`中找到。'
- en: On success, this returns a new file descriptor that the kernel assigns to the
    socket created.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，此操作返回一个新文件描述符，内核将其分配给创建的套接字。
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first parameter for bind is a file descriptor, generally one returned by
    the socket system call. The second parameter is the address to be assigned to
    the given socket, passed as a pointer to a structure. The third parameter is the
    length of the given address.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`的第一个参数是文件描述符，通常是套接字系统调用返回的。第二个参数是要分配给给定套接字的地址，作为结构指针传递。第三个参数是给定地址的长度。'
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`listen` is a function that takes in the file descriptor for the socket. Note
    that when an application is listening for incoming connections on a socket, it
    might not be able to read from it as fast as packets arrive. To handle cases like
    this, the kernel maintains a queue of packets for each socket. The second parameter
    here is the maximum length of the queue for the given socket. If more clients
    are trying to connect after the given number here, the connection will be closed
    with a connection refused error.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen`是一个函数，它接受套接字的文件描述符。请注意，当应用程序在套接字上监听传入的连接时，它可能无法像数据包到达那样快地从中读取。为了处理这种情况，内核为每个套接字维护一个数据包队列。这里的第二个参数是给定套接字队列的最大长度。如果在此之后有更多客户端尝试连接，连接将被关闭，并显示连接被拒绝的错误。'
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This call is used to accept connections on TCP sockets. It takes a connection
    of the queue for the given socket, creates a new socket, and returns the file
    descriptor for the new socket back to the caller. The second argument is a pointer
    to a socket address `struct` that is filled in with the info of the new socket.
    The third argument is its length.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用用于在TCP套接字上接受连接。它从给定套接字的队列中获取一个连接，创建一个新的套接字，并将新套接字的文件描述符返回给调用者。第二个参数是一个指向套接字地址`struct`的指针，其中填充了新套接字的信息。第三个参数是其长度。
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function connects the socket given by the first argument to the address
    specified in the second argument (the third argument being the length of the address
    `struct`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将第一个参数指定的套接字连接到第二个参数指定的地址（第三个参数是地址`struct`的长度）。
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is used to send data over a socket. The first argument tells it which socket
    to use. The second argument is a pointer to the data to be sent, and the third
    argument is its length. The last argument is bitwise OR of a number of options
    which dictates how packets should be delivered in this connection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于通过套接字发送数据。第一个参数告诉它使用哪个套接字。第二个参数是要发送的数据的指针，第三个参数是其长度。最后一个参数是多个选项的按位或，这些选项决定了在此连接中如何交付数据包。
- en: This system call returns the number of bytes sent on success.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此系统调用在成功时返回发送的字节数。
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This one is the counterpart of send. As usual, the first argument tells it which
    socket to read from. The second argument is a pointer to an allocated space where
    it should write the data it reads, and the third argument is its length. `flags`
    here has the same meaning as in the case of send.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是发送的对应函数。通常，第一个参数告诉它从哪个套接字读取。第二个参数是它应该写入读取数据的分配空间的指针，第三个参数是其长度。这里的`flags`与发送的情况具有相同的意义。
- en: 'This function returns the number of bytes received on success:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在成功时返回接收的字节数：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function shuts down a socket. The first argument tells it which socket
    to shut down. The second argument dictates if any further transmission or reception
    should be allowed before the socket is shut down.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数关闭一个套接字。第一个参数告诉它要关闭哪个套接字。第二个参数指定在关闭套接字之前是否允许任何进一步的传输或接收。
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This system call is used to destroy file descriptors. Consequently, this can
    be used to close and clean up a socket as well, given its file descriptor number.
    While `shutdown` allows the socket to receive pending data and not accept new
    connections, a `close` will drop all existing connections and cleanup resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此系统调用用于销毁文件描述符。因此，在给定其文件描述符编号的情况下，这也可以用来关闭和清理套接字。虽然 `shutdown` 允许套接字接收挂起数据而不接受新连接，但
    `close` 将丢弃所有现有连接并清理资源。
- en: 'Other than the ones noted above, a host will also need to resolve the IP of
    a remote host using DNS. The `getaddrinfo` syscall does that. There are some other
    syscalls that provide various useful information for writing applications: `gethostname`
    returns the host name of the current computer, `setsockopt` sets various control
    options on a socket, and so on.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上面提到的之外，主机还需要使用 DNS 解析远程主机的 IP 地址。`getaddrinfo` 系统调用执行此操作。还有一些其他系统调用为编写应用程序提供了各种有用的信息：`gethostname`
    返回当前计算机的主机名，`setsockopt` 在套接字上设置各种控制选项，等等。
- en: Note that a lot of syscalls described above are blocking, which means they block
    the thread they are invoked in waiting for the given operation to finish. For
    example, the *read* syscall will block on the socket if enough data is not available
    to fill the buffer provided. Often, this is not desirable, especially in modern
    multithreaded environments where a blocking call will not be able to take full
    advantage of the computing power available since the thread will loop around doing
    nothing useful.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上面描述的许多系统调用都是阻塞的，这意味着它们会在等待给定操作完成时阻塞调用线程。例如，*read* 系统调用会在提供的缓冲区不足以填充足够数据时在套接字上阻塞。通常，这并不是所希望的，尤其是在现代的多线程环境中，因为阻塞调用将无法充分利用可用的计算能力，因为线程将循环执行无用的操作。
- en: 'Unix provides some more syscalls that enable asynchronous, non-blocking applications
    using the standard C library. There are two standard ways of doing this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 提供了一些其他系统调用，它们使用标准 C 库实现异步、非阻塞应用程序。有两种标准方法来做这件事：
- en: 'Using the *select* system call: This syscall monitors a list of given sockets
    and lets the caller know if any of those has data to read from. The caller can
    then retrieve those file descriptors using some special macros and read from those.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *select* 系统调用：此系统调用监视给定套接字列表，并通知调用者是否有任何套接字有可读数据。然后，调用者可以使用一些特殊宏检索这些文件描述符并从中读取。
- en: 'Using the *poll* system call: The high-level semantics here is similar to that
    of *select*: it takes in a list of socket file descriptors and a timeout. It monitors
    those asynchronously for the given timeout, and if any of those have some data,
    it lets the caller know. Unlike *select*, which checks for all conditions (readability,
    writability, and error) on all file descriptors, poll only cares about the list
    of file descriptors and conditions it receives. This makes *poll* easier to work
    with and faster than *select*.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *poll* 系统调用：这里的高级语义与 *select* 类似：它接受一个套接字文件描述符列表和一个超时时间。它异步监视这些套接字在给定超时时间内，如果其中任何一个有数据，则通知调用者。与
    *select* 不同，*select* 会检查所有文件描述符上的所有条件（可读性、可写性和错误），而 *poll* 只关心它接收到的文件描述符列表和条件。这使得
    *poll* 更易于使用，并且比 *select* 更快。
- en: In practice, however, select and poll are both very slow for applications which
    might need to monitor a lot of sockets for connections. For such applications,
    either *epoll* or an event-based networking library like libevent or libev might
    be more suitable. The gain in performance comes at the cost of portability; those
    libraries are not available in all systems since they are not part of the standard
    library. The other cost is complexity in writing and maintaining applications
    based on external libraries.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，对于可能需要监视大量套接字连接的应用程序，select 和 poll 都非常慢。对于此类应用程序，*epoll* 或基于事件的网络库（如
    libevent 或 libev）可能更适合。性能的提升是以可移植性为代价的；这些库并非在所有系统中都可用，因为它们不是标准库的一部分。另一个代价是编写和维护基于外部库的应用程序的复杂性。
- en: 'In the following section, we will walk through the state transitions of a TCP
    server and client that is communicating over a network. There are some idealistic
    assumptions here for the sake of simplicity: we assume that there are no intermediate
    errors or delays of any kind, that the server and the client can process data
    at the same rate, and that neither the server nor the client crash while communicating.
    We also assume that the client initiates the connection (**Active open**) and
    closes it down (**Active close**). We do not show all the possible states of the
    state machine since that will be way too cumbersome:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐步讲解通过网络通信的TCP服务器和客户端的状态转换。这里为了简化，做了一些理想化的假设：我们假设没有中间错误或任何类型的延迟，服务器和客户端可以以相同的速率处理数据，并且在通信过程中服务器和客户端都不会崩溃。我们还假设客户端发起连接（**主动打开**）并关闭它（**主动关闭**）。我们没有展示状态机的所有可能状态，因为那将过于繁琐：
- en: '![](img/00014.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: TCP state transition for a server and a client
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: TCP服务器和客户端的状态转换
- en: Both the server and the client start from the **CLOSED** state. Assuming the
    server starts up first, it will first acquire a *socket*, *bind* an address to
    it, and start *listening* on it. The client starts up and calls **connect** to
    the server's address and port. When the server sees the connection, it calls **accept**
    on it. That call returns a new socket from which the server can read data from.
    But before actual data transmission can occur, the server and the client must
    do the three-way handshake. The client initiates that by sending a **SYN**, the
    server reads that, responds with a **SYN + ACK** message, and goes to the **SYN_RCVD**
    state. The client goes to the **SYN_SENT** state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端都从**关闭**状态开始。假设服务器首先启动，它将首先获取一个*套接字*，将地址*绑定*到它上，并开始在其上*监听*。客户端启动并调用**connect**到服务器的地址和端口。当服务器看到连接时，它会在其上调用**accept**。这个调用返回一个新的套接字，服务器可以通过它读取数据。但在实际数据传输发生之前，服务器和客户端必须进行三次握手。客户端通过发送一个**SYN**来启动这个过程，服务器读取该信息，并以一个**SYN
    + ACK**消息响应，进入**SYN_RCVD**状态。客户端进入**SYN_SENT**状态。
- en: When the client gets the **SYN + ACK**, it sends out a final **ACK** and goes
    to the **ESTABLISHED** state. The server goes to **ESTABLISHED** when it gets
    the final **ACK**. The actual connection is established only when both parties
    are in the **ESTABLISHED** state. At this point, both the server and the client
    can **send** and **receive** data. These operations do not cause a state change.
    After some time, the client might want to **close** the connection. For that,
    it sends out a **FIN** packet and goes to the **FIN_WAIT_1** state. The server
    receives that, sends an **ACK**, and goes to the **CLOSE_WAIT** state. When the
    client gets that, it goes to the **FIN_WAIT_2** state. This concludes the first
    round of connection termination. The server then calls **close**, sends out a
    **FIN**, and goes to the **LAST_ACK** state. When the client gets that, it sends
    out an **ACK** and goes to the **TIME_WAIT** state. When the server receives the
    final **ACK**, it goes back to the **CLOSED** state. After this point, all server
    resources for this connection are released. The client, however, waits for a timeout
    before moving on to the **CLOSED** state where it releases all client-side resources.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端收到**SYN + ACK**后，它发送一个最终的**ACK**并进入**建立**状态。服务器在收到最终的**ACK**后进入**建立**状态。只有在双方都处于**建立**状态时，实际的连接才建立。在这个时候，服务器和客户端都可以**发送**和**接收**数据。这些操作不会引起状态变化。过了一段时间后，客户端可能想要**关闭**连接。为此，它发送一个**FIN**数据包并进入**FIN_WAIT_1**状态。服务器收到这个数据包，发送一个**ACK**并进入**CLOSE_WAIT**状态。当客户端收到这个数据包后，它进入**FIN_WAIT_2**状态。这标志着连接终止的第一轮结束。然后服务器调用**close**，发送一个**FIN**并进入**LAST_ACK**状态。当客户端收到这个数据包后，它发送一个**ACK**并进入**TIME_WAIT**状态。当服务器收到最终的**ACK**后，它回到**关闭**状态。从这一点开始，所有与此连接相关的服务器资源都将被释放。然而，客户端在移动到**关闭**状态（在那里它释放所有客户端资源）之前会等待一个超时。
- en: Our assumptions here are pretty basic and idealistic. In the real world, communication
    will often be more complex. For example, the server might want to push data, and
    then it will have to initiate the connection. Packets might be corrupted in transit,
    causing either of the parties to request retransmission, and so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的假设非常基础且理想化。在现实世界中，通信通常会更为复杂。例如，服务器可能想要推送数据，然后它必须发起连接。数据包在传输过程中可能会损坏，导致任一方请求重传，等等。
- en: '**Maximum Segment Lifetime** (**MSL**) is defined to be the maximum time a
    TCP segment can exist in the network. In most modern systems, it is set to 60
    seconds.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大段生存时间**（**MSL**）被定义为TCP段在网络中存在的最大时间。在大多数现代系统中，它被设置为60秒。'
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter started with motivations for writing networking applications in
    the modern world. We also took a look at how networking evolved. We studied common
    networking technologies and ideas, and looked at how they work together; starting
    from simple IP routing and DNS to TCP and UDP. We then studied how Linux (and
    POSIX) in general supports synchronous and asynchronous network programming.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从在现代世界中编写网络应用程序的动机开始。我们还回顾了网络的发展历程。我们研究了常见的网络技术和理念，并探讨了它们是如何协同工作的；从简单的IP路由和DNS到TCP和UDP。然后我们研究了Linux（和POSIX）通常如何支持同步和异步网络编程。
- en: In the next chapter, we will look at Rust and try to understand its benefits
    over existing platforms. Having motivated both networking and Rust, we will move
    on to network programming using Rust.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Rust并尝试理解它相对于现有平台的优势。在激发了对网络和Rust的兴趣之后，我们将继续使用Rust进行网络编程。
