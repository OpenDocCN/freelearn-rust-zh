- en: Fearless Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无畏并发
- en: Concurrency and parallelism are important parts of modern-day programming and
    Rust is perfectly equipped to deal with these challenges. The borrowing and ownership
    model is great for preventing data races (**anomalies**, as they are called in
    the database world) since variables are immutable by default and if mutability
    is required, there cannot be any other reference to the data. This makes any type
    of concurrency safe and less complex in Rust (compared to many other languages).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行是现代编程的重要组成部分，Rust 完美地配备了处理这些挑战的能力。借用和所有权模型对于防止数据竞争（在数据库世界中被称为**异常**）非常有效，因为变量默认是不可变的，如果需要可变性，则不能有其他任何对数据的引用。这使得
    Rust 中的任何类型的并发都更加安全且复杂度更低（与其他许多语言相比）。
- en: In this chapter, we will cover several ways of employing concurrency to solve
    problems and will even look at futures, which are—at the time of writing—not part
    of the language yet. If you are reading this in the future (no pun intended),
    this may be part of the core language already and you can check out the *Asynchronous
    programming with futures* recipe for historical reference.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍几种使用并发来解决问题的方法，甚至还会探讨未来，这些在未来写作时还不是语言的一部分。如果你在将来阅读这篇文章（不是字面意思），这可能已经是核心语言的一部分了，你可以查看
    *使用 futures 进行异步编程* 食谱以供历史参考。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Moving data into new threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据移动到新线程中
- en: Managing multiple threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多个线程
- en: Message passing between threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程间的消息传递
- en: Shared mutable states
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享可变状态
- en: Multiprocessing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多进程
- en: Making sequential code parallel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顺序代码并行化
- en: Concurrent data processing in vectors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量中的并发数据处理
- en: Shared immutable states
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享不可变状态
- en: Actors and asynchronous messages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员 和 异步消息
- en: Async programming with futures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 futures 进行异步编程
- en: Moving data into new threads
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据移动到新线程中
- en: Rust threads operate just like in any other language—in scopes. Any other scope
    (such as closures) can easily borrow the variables from the parent scope since
    it's easy to determine if and when variables are dropped. However, when spawning
    a thread, its lifetime, compared to its parent's lifetime, is impossible to know
    and therefore the reference can become invalid at any time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 线程的工作方式与其他任何语言一样——在作用域中。任何其他作用域（如闭包）都可以轻松地从父作用域借用变量，因为很容易确定变量何时被丢弃。然而，在启动线程时，与父作用域的生命周期相比，其生命周期是无法知道的，因此引用可能在任何时候变得无效。
- en: To tackle this problem, the threaded scope can take ownership of its variables—the
    memory is **moved** into the thread's scope. Let's see how this is done!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，线程作用域可以拥有其变量——内存被**移动**到线程的作用域中。让我们看看这是如何实现的！
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to see how to move memory between threads:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤查看如何在线程之间移动内存：
- en: Use `cargo new simple-threads` to create a new application project and open
    the directory in Visual Studio Code.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new simple-threads` 创建一个新的应用程序项目，并在 Visual Studio Code 中打开该目录。
- en: 'Edit `src/main.rs` and spawn a simple thread that does not move data into its
    scope. Since it''s the simplest form of a thread, let''s print something to the
    command line and wait:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/main.rs` 并启动一个简单的线程，该线程不会将数据移动到其作用域中。由于这是线程的最简单形式，让我们打印一些内容到命令行并等待：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s call the new function from within `fn main()`. Replace the `hello
    world` snippet with the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `fn main()` 中调用新函数。将 `hello world` 碎片替换为以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s run the code to see if it works:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行代码看看它是否工作：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s get some outside data into a thread. Add another function to `src/main.rs`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将一些外部数据移动到线程中。向 `src/main.rs` 中添加另一个函数：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To demonstrate what''s happening under the hood, we have left out the `move`
    keyword for now. Expand the `main` function with the following code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示底层发生的事情，我们目前省略了 `move` 关键字。使用以下代码扩展 `main` 函数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Does it work? Let''s try `cargo run`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是否工作？让我们尝试 `cargo run`：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There we have it: to get any kind of data into a threaded scope, we need to
    transfer ownership by moving the value into the scope using the `move` keyword.
    Let''s follow the compiler''s instructions:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到了：要将任何类型的数据移动到线程作用域中，我们需要通过使用 `move` 关键字将值移动到作用域中来转移所有权。让我们遵循编译器的指示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s try again with `cargo run`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次尝试使用 `cargo run`：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Threads in Rust behave a lot like regular functions: they can take ownership
    and operate on the same syntax as closures (`|| {}` is an empty/`noop` function
    without parameters). Therefore, we have to treat them like we treat functions
    and think of them in terms of ownership and borrowing, or more specifically: lifetimes.
    Passing a reference (the default behavior) into this thread function makes it
    impossible for the compiler to keep track of the validity of the reference, which
    is a problem for code safety. Rust solves this by introducing the `move` keyword.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的线程行为与常规函数非常相似：它们可以拥有所有权，并且可以使用与闭包相同的语法（`|| {}` 是一个不带参数的空/`noop` 函数）。因此，我们必须像对待函数一样对待它们，并从所有权和借用（或更具体地说：生命周期）的角度来考虑。将引用（默认行为）传递到这个线程函数中，使得编译器无法跟踪引用的有效性，这对代码安全是一个问题。Rust
    通过引入 `move` 关键字来解决此问题。
- en: Using the `move` keyword changes the default behavior of borrowing to moving
    the ownership of every variable into the scope. Hence, unless these values implement
    the `Copy` trait (like `i32`), or have a longer lifetime than the thread when
    borrowing (like the `'static` lifetime for `str` literals), they become unavailable
    to the thread's parent scope.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `move` 关键字改变了默认的借用行为，将每个变量的所有权移动到作用域中。因此，除非这些值实现了 `Copy` 特性（如 `i32`），或者借用时具有比线程更长的生命周期（如
    `str` 文本的 `'static' 生命周期），否则它们将无法在线程的父作用域中使用。
- en: Giving back ownership also works just like in a function—via the `return` statement.
    The thread that waits for the other (using `join()`) can then retrieve the return
    value by unwrapping the `join()` result.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有权也像在函数中一样工作——通过 `return` 语句。等待其他线程（使用 `join()`）的线程可以解包 `join()` 的结果来检索返回值。
- en: Threads in Rust are native threads for each operating system and have their
    own local state and execution stack. When they panic, only the thread stops, not
    the entire program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的线程是操作系统的原生线程，每个线程都有自己的局部状态和执行栈。当它们崩溃时，只有线程停止，而不是整个程序。
- en: We've successfully gone through moving data into new threads. Now let's move
    on to the next recipe.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将数据移动到新的线程中。现在让我们继续到下一个菜谱。
- en: Managing multiple threads
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理多个线程
- en: Single threads are great, but in reality, many use cases demand a wealth of
    threads to execute on a large-scale data set in parallel. This has been popularized
    by the map/reduce pattern, published several years ago, and is still a great way
    to process something distinct such as multiple files, rows in a database result,
    and many more in parallel. Whatever the source, as long as the processing is not
    inter-dependent, it can be chunked and **mapped**—both of which Rust can make
    easy and free of data-race conditions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程很棒，但在现实中，许多用例需要大量的线程来并行执行大规模数据集。这已经被几年前发布的 map/reduce 模式所普及，并且仍然是一种处理多个文件、数据库结果中的行等不同事物的并行的好方法。无论来源如何，只要处理不是相互依赖的，就可以将其分块并
    **映射**，这两者 Rust 都可以使其变得简单且无数据竞争条件。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In this recipe, we''ll add some more threads to do map-style data processing.
    Follow these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将添加更多线程来进行映射风格的数据处理。按照以下步骤操作：
- en: Run `cargo new multiple-threads` to create a new application project and open
    the directory in Visual Studio Code.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `cargo new multiple-threads` 来创建一个新的应用程序项目，并在 Visual Studio Code 中打开该目录。
- en: 'In `src/main.rs`, add the following function on top of `main()`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中，在 `main()` 之上添加以下函数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this function, we spawn a thread for each chunk that has been passed in.
    This thread only doubles the number and therefore the function returns `Vec<i32>`
    for each chunk containing the results of this transformation. Now we need to create
    input data and call the function. Let''s extend `main` to do that:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们为每个传入的块启动一个线程。这个线程只将数字加倍，因此函数为每个包含此转换结果的块返回 `Vec<i32>`。现在我们需要创建输入数据并调用该函数。让我们扩展
    `main` 来实现这一点：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With `cargo run` we can now see the results:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo run` 我们现在可以看到结果：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Admittedly, working with multiple threads in Rust is just the same as if we
    were working on single threads since there are no convenient methods for joining
    a list of threads or similar. Instead, we can use the power of Rust's iterators
    to do that in an expressive way. With these functional constructs, the need for
    `for` loops can be replaced by a chain of functions that lazily process collections,
    which makes the code easier to handle and more efficient.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 承认，在Rust中处理多个线程就像我们在处理单线程一样，因为没有方便的方法来连接线程列表或类似的东西。相反，我们可以使用Rust的迭代器的力量以表达的方式做到这一点。有了这些功能结构，我们可以用一系列函数来替换`for`循环，这些函数可以懒惰地处理集合，这使得代码更容易处理且更高效。
- en: After setting up the project in *step 1*, we implement a multithreaded function
    to apply an operation to every chunk. These chunks are simply parts of a vector,
    and an operation—a simple function that doubles the input variable in this example—can
    be done with any type of task. *Step 3* shows how to call the multithreaded `mapping`
    function and how to get results by using the `JoinHandle` in a future/promise
    ([http://dist-prog-book.com/chapter/2/futures.html](http://dist-prog-book.com/chapter/2/futures.html))
    way. *Step 4* then simply shows that it works as intended by outputting the doubled
    chunks as a flat list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成*步骤 1*的项目设置后，我们实现了一个多线程函数，用于对每个块应用一个操作。这些块仅仅是向量的部分，在这个例子中，一个操作——一个简单的将输入变量加倍的功能——可以对任何类型的任务进行。*步骤
    3*展示了如何调用多线程的`mapping`函数，以及如何通过在未来的/承诺([http://dist-prog-book.com/chapter/2/futures.html](http://dist-prog-book.com/chapter/2/futures.html))方式中使用`JoinHandle`来获取结果。*步骤
    4*简单地展示了它按预期工作，通过输出加倍后的块作为扁平列表。
- en: What is also interesting is the number of times we have had to clone data. Since
    passing data into the threads is only possible by moving the values into each
    thread's memory space, cloning is often the only way to work around these sharing
    issues. However, we'll cover a method similar to multiple `Rc` in a later recipe
    (*Shared immutable states*) in this chapter, so let's move on to the next recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的是，我们不得不克隆数据的次数。由于将数据传递到线程中只能通过将值移动到每个线程的内存空间中，因此克隆通常是解决这些共享问题的唯一方法。然而，我们将在本章后面的食谱（*共享不可变状态*）中介绍一个类似多个`Rc`的方法，所以让我们继续下一个食谱。
- en: Using channels to communicate between threads
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通道在线程之间进行通信
- en: Message passing between threads has been an issue in many standard libraries
    and programming languages since many rely on the user to apply locking. This leads
    to deadlocks and is somewhat intimidating for newcomers, which is why many developers
    were excited when Go popularized the concept of channels, something that we can
    also find in Rust. Rust's channels are great for designing a safe, event-driven
    application in just a few lines of code without any explicit locking.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多标准库和编程语言中，线程间的消息传递一直是一个问题，因为许多依赖于用户应用锁定。这导致了死锁，对于新手来说有些令人生畏，这也是为什么许多开发者对Go普及通道概念感到兴奋，我们也可以在Rust中找到这一点。Rust的通道非常适合用几行代码设计一个安全、事件驱动的应用程序，而不需要任何显式的锁定。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create a simple application that visualizes incoming values on the command
    line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的应用程序，该程序在命令行中可视化传入的值：
- en: Run `cargo new channels` to create a new application project and open the directory
    in Visual Studio Code.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`cargo new channels`以创建一个新的应用程序项目，并在Visual Studio Code中打开该目录。
- en: 'First, let''s get the basics out of the way. Open `src/main.rs` and add the
    imports and an `enum` structure to the file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们先处理基础知识。打开`src/main.rs`文件，并添加导入和一个`enum`结构：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, inside the `main` function, we create a channel with the `mpsc::channel()`
    function along with two threads that take care of the sending. Afterward, we are
    going to use two threads to send messages to the main thread with a variable delay.
    Here''s the code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`main`函数内部，我们使用`mpsc::channel()`函数创建了一个通道，以及两个负责发送的线程。之后，我们将使用两个线程以可变延迟向主线程发送消息。以下是代码：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Both of the threads are sending data to the channel, so what''s missing is
    the channel''s receiving end to take care of the input data. The receiver offers
    two functions, `recv()` and `recv_timeout()`, both of which block the calling
    thread until an item is received (or the timeout is reached). We are just going
    to print the character multiplied by the passed-in value:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个线程都在向通道发送数据，所以缺少的是通道的接收端来处理输入数据。接收器提供了两个函数，`recv()`和`recv_timeout()`，这两个函数都会阻塞调用线程，直到接收到一个项目（或达到超时）。我们只是将要打印字符乘以传入的值：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order to use `rand` when we finally run the program, we still need to add
    it to `Cargo.toml` with the following:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在最终运行程序时使用 `rand`，我们仍然需要将其添加到 `Cargo.toml` 中，如下所示：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, let''s see how the program runs—it''s going to run infinitely. To stop
    it, press *Ctrl* + *C*. Run it with `cargo run`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们看看程序是如何运行的——它将无限期地运行。要停止它，请按 *Ctrl* + *C*。用 `cargo run` 运行它：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How does this work? Let's go behind the scenes to understand the code better.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Channels are **multi-producer-single-consumer** data structures, consisting
    of many senders (with a lightweight clone) but only a single receiver. Under the
    hood, the channel does not lock but relies on an `unsafe` data structure that
    allows the detection and management of the state of the stream. The channel handles
    simply sending data across threads well and can be used to create an actor-style
    framework or a reactive map-reduce style data-processing engine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是 **多生产者单消费者** 数据结构，由许多发送者（带有轻量级克隆）组成，但只有一个接收者。在底层，通道不锁定，而是依赖于一个 `unsafe`
    数据结构，该结构允许检测和管理流的状态。通道很好地处理了跨线程发送数据，并且可以用来创建演员风格的框架或反应式 map-reduce 风格的数据处理引擎。
- en: 'This is one example of how Rust does **fearless concurrency**: the data going
    in is owned by the channel until the receiver retrieves it, which is when a new
    owner takes over. The channel also acts as a queue and holds elements until they
    are retrieved. This not only frees the developer from implementing the exchange
    but also adds concurrency for regular queues for free as well.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Rust 如何做到 **无畏并发** 的一个例子：进入的数据由通道拥有，直到接收者检索它，这时新的所有者接管。通道还充当队列，并持有元素直到它们被检索。这不仅使开发者免于实现交换，而且还免费为常规队列添加了并发性。
- en: 'We create the channel in *step 3* of this recipe and pass the senders into
    different threads, which start sending the previously defined (in *step 2*) `enum`
    types for the receiver to print. This printing is done in *step 4* by looping
    over the blocking iterator with a three-second timeout. *Step 5* then shows how
    to add the dependency to `Cargo.toml`, and in *step 6* we see the output: multiple
    full lines with a random number of elements that are either asterisks (`*`) or
    pipes (`|`).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个菜谱的 *第 3 步* 中创建通道，并将发送者传递到不同的线程中，这些线程开始发送之前定义的（在 *第 2 步*）`enum` 类型，以便接收者打印。这种打印是在
    *第 4 步* 通过循环带有三秒超时的阻塞迭代器来完成的。*第 5 步* 展示了如何将依赖项添加到 `Cargo.toml`，而在 *第 6 步* 我们看到了输出：多行，包含随机数量的元素，这些元素可以是星号
    (`*`) 或管道 (`|`)。
- en: We've successfully covered how to use channels to communicate between threads
    effortlessly. Now let's move on to the next recipe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功介绍了如何使用通道在线程之间轻松通信。现在让我们继续下一个菜谱。
- en: Sharing mutable states
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享可变状态
- en: Rust's ownership and borrowing model simplifies immutable data access and transfer
    considerably—but what about shared states? There are many applications that require
    mutable access to a shared resource from multiple threads. Let's see how this
    is done!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的所有权和借用模型大大简化了不可变数据的访问和传输——那么共享状态怎么办？有许多应用程序需要从多个线程对共享资源进行可变访问。让我们看看这是如何完成的！
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何去做...
- en: 'In this recipe, we will create a very simple simulation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个非常简单的模拟：
- en: Run `cargo new black-white` to create a new application project and open the
    directory in Visual Studio Code.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `cargo new black-white` 来创建一个新的应用程序项目，并在 Visual Studio Code 中打开该目录。
- en: 'Open `src/main.rs` to add some code. First, we are going to need some imports
    and an `enum` to make our simulation interesting:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/main.rs` 以添加一些代码。首先，我们需要一些导入和一个 `enum` 来使我们的模拟更有趣：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to show a shared state between two threads, we obviously need a thread
    that works on something. This will be a coloring task, where each thread is only
    adding white to a vector if black was the previous element and vice versa. Thus,
    each thread is required to read and—depending on the output—write into a shared
    vector. Let''s look at the code that does this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了展示两个线程之间的共享状态，显然我们需要一个在某个东西上工作的线程。这将是一个着色任务，其中每个线程只有在黑色是前一个元素时才向向量添加白色，反之亦然。因此，每个线程都需要读取并根据输出写入共享向量。让我们看看执行此操作的代码：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All that remains at this stage is to create multiple threads and hand them
    an `Arc` instance of the data to work on:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们剩下的就是创建多个线程，并将数据的 `Arc` 实例传递给它们来处理：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s run the code with `cargo run`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用 `cargo run` 运行代码：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Rust''s ownership principle is a double-edged sword: on the one hand, it protects
    from unintended consequences and enables compile-time memory management; on the
    other hand, mutable access is significantly more difficult to obtain. While it
    is more complex to manage, shared mutable access can be great for performance.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的所有权原则是一把双刃剑：一方面，它保护免受意外后果的影响，并使编译时内存管理成为可能；另一方面，可变访问的获取要困难得多。虽然管理起来更复杂，但共享可变访问对于性能来说可以非常出色。
- en: '`Arc` stands for **Atomic Reference Counter**. This makes them very similar
    to regular reference counters (`Rc`), with the exception that an `Arc` does its
    job with an *atomic increment*, which is thread-safe. Therefore, they''re the
    only choice for cross-threaded reference counting.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arc`代表**原子引用计数器**。这使得它们与常规引用计数器（`Rc`）非常相似，唯一的区别是`Arc`通过**原子递增**来完成其工作，这是线程安全的。因此，它们是跨线程引用计数的唯一选择。'
- en: In Rust, this is done in a way similar to interior mutability ([https://doc.rust-lang.org/book/ch15-05-interior-mutability.html](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html)),
    but using `Arc` and `Mutex` types (instead of `Rc` and `RefCell`), where `Mutex` owns
    the actual part of the memory it restricts access to (in step 3's snippet, we
    create the `Vec` just like that). As shown in *step 2*, to obtain a mutable reference
    to the value, locking the `Mutex` instance is strictly required and it will only
    be returned after the returned data instance is dropped (for example, when the
    scope ends). Hence, it is important to keep the scope of the `Mutex` as small
    as possible (note the additional `{ ... }` in *step 2*)!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，这是以类似内部可变性的方式进行的（[https://doc.rust-lang.org/book/ch15-05-interior-mutability.html](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html)），但使用`Arc`和`Mutex`类型（而不是`Rc`和`RefCell`），其中`Mutex`拥有它限制访问的实际内存部分（在步骤3的片段中，我们就是这样创建`Vec`的）。正如*步骤2*所示，要获取值的可变引用，必须严格锁定`Mutex`实例，并且只有在返回的数据实例被丢弃（例如，当作用域结束时）之后，它才会返回。因此，保持`Mutex`的作用域尽可能小是很重要的（注意*步骤2*中的附加`{
    ... }`）！
- en: In many use cases, a channel-based approach can achieve the same goal without
    having to deal with `Mutex` and the fear of a deadlock occurring (when several
    `Mutex` locks wait for each other to unlock).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多用例中，基于通道的方法可以达到相同的目标，而无需处理`Mutex`和死锁（当多个`Mutex`锁相互等待解锁）的恐惧。
- en: We've successfully learned how to use channels to share mutable states. Now
    let's move on to the next recipe.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用通道来共享可变状态。现在让我们继续下一个菜谱。
- en: Multiprocessing in Rust
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust中的多进程
- en: Threading is great for in-process concurrency and certainly the preferred method
    of spreading workloads over multiple cores. Whenever other programs need to be
    called, or an independent, heavyweight task is required, sub-processes are the
    way to go. With the recent rise of orchestrator-type applications (Kubernetes,
    Docker Swarm, Mesos, and many others), managing child processes has become a more
    important topic as well. In this recipe, we will communicate with and manage child
    processes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 线程对于进程内并发非常出色，当然也是将工作负载分散到多个核心的首选方法。每当需要调用其他程序，或者需要独立、重量级任务时，子进程就是最佳选择。随着最近编排型应用程序（如Kubernetes、Docker
    Swarm、Mesos等）的兴起，管理子进程也变得更为重要。在这个菜谱中，我们将与子进程进行通信和管理。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create a simple application that searches the filesystem:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个简单的应用程序，用于搜索文件系统：
- en: Create a new project using `cargo new child-processes` and open it in Visual
    Studio Code.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new child-processes`创建一个新的项目，并在Visual Studio Code中打开它。
- en: On Windows, execute `cargo run` (the last step) from a PowerShell window, since
    it contains all the required binaries.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上，从PowerShell窗口中执行`cargo run`（最后一步），因为它包含所有必需的二进制文件。
- en: 'After importing a few (standard library) dependencies, let''s write the basic
    `struct` to hold the result data. Add this on top of the `main` function:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入几个（标准库）依赖项之后，让我们编写基本的`struct`来保存结果数据。在`main`函数顶部添加以下内容：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The function calling the `find` binary (which does the actual searching) translates
    the results into the `struct` from *step 1*. This is what the function looks like:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`find`二进制文件（实际执行搜索）的函数将结果转换为*步骤1*中的`struct`。这个函数看起来是这样的：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Great! Now we know how to call an external binary, pass arguments in, and forward
    any `stdout` output to the Rust program. How about writing into the external program''s
    `stdin`? We''ll add the following function to do that:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！现在我们知道了如何调用外部二进制文件，传递参数，并将任何 `stdout` 输出转发到 Rust 程序。那么，如何写入外部程序的 `stdin`
    呢？我们将添加以下函数来完成这个任务：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To see it in action, we also need to call the functions in the `main()` part
    of the program. Replace the contents of the default `main()` function with the
    following:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看到它的实际效果，我们还需要在程序的 `main()` 部分调用这些函数。用以下内容替换默认的 `main()` 函数的内容：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we should see if it works by issuing `cargo run`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过发出 `cargo run` 来检查它是否工作：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By using Rust's ability to run sub-processes and manipulate their inputs and
    outputs, it's easy to integrate existing applications into the new program's workflow.
    In *step 1*, we do exactly that by using the `find` program with parameters and
    parse the output into our own data structure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Rust 的运行子进程和操作其输入输出的能力，将现有应用程序集成到新程序的流程中变得非常容易。在 *步骤 1* 中，我们正是通过使用带有参数的
    `find` 程序并将输出解析到我们自己的数据结构中来实现这一点。
- en: In *step 3*, we go further and send data into a sub-process and recover the
    same text (using `cat` in an echo-like fashion). You'll notice the parsing of
    a string in each function, which is required as Windows and Linux/macOS use different
    byte sizes to encode their characters (**UTF-16** and **UTF-8** respectively).
    Similarly, the `b"string"` transforms the literal into a byte-literal appropriate
    for the current platform.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们进一步发送数据到子进程，并恢复相同的文本（使用类似 `cat` 的 `echo` 风格）。你会注意到每个函数中都有字符串解析，这是必需的，因为
    Windows 和 Linux/macOS 使用不同的字节大小来编码它们的字符（**UTF-16** 和 **UTF-8** 分别）。同样，`b"string"`
    将字面量转换为适合当前平台的字节数组字面量。
- en: The key ingredient for these operations is **piping**, an operation that is
    available on the command line using a `|` (**pipe**) symbol. We encourage you
    to try out other variants of the `Stdio` struct as well and see where they lead!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的关键成分是 **管道**，这是一个在命令行中使用 `|` （**管道**）符号可用的操作。我们鼓励您也尝试其他 `Stdio` 结构的变体，看看它们能引导您到何处！
- en: We've successfully learned about multiprocessing in Rust. Now let's move on
    to the next recipe.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了 Rust 中的多进程。现在让我们继续下一个配方。
- en: Making sequential code parallel
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将顺序代码并行化
- en: Creating highly concurrent applications from scratch is relatively simple in
    many technologies and languages. However, when multiple developers have to build
    on pre-existing work of some kind (legacy or not), creating these highly concurrent
    applications gets complicated. Thanks to API differences across languages, best
    practices, or technical limitations, existing operations on sequences cannot be
    run in parallel without in-depth analysis. Who would do that if the potential
    benefit is not significant? With Rust's powerful iterators, can we run operations
    in parallel without major code changes? Our answer is yes!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始创建高度并发的应用程序在许多技术和语言中相对简单。然而，当多个开发者必须基于某种预存在的工作（无论是遗留的还是其他类型）进行构建时，创建这些高度并发的应用程序就会变得复杂。多亏了不同语言之间的
    API 差异、最佳实践或技术限制，现有的序列操作不能在没有深入分析的情况下并行运行。如果潜在的好处不显著，谁会去做呢？借助 Rust 的强大迭代器，我们能否在不进行重大代码更改的情况下并行运行操作？我们的答案是肯定的！
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This recipe shows you how to simply make an application run in parallel without
    massive effort using `rayon-rs` in just a few steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何仅通过几个步骤使用 `rayon-rs` 简单地使应用程序并行运行，而不需要大量努力：
- en: Create a new project using `cargo new use-rayon --lib` and open it in Visual
    Studio Code.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new use-rayon --lib` 创建一个新的项目，并在 Visual Studio Code 中打开它。
- en: 'Open `Cargo.toml` to add the required dependencies to the project. We are going
    to build on `rayon` and use the benchmarking abilities of `criterion`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Cargo.toml` 以向项目添加所需的依赖项。我们将基于 `rayon` 并使用 `criterion` 的基准测试功能：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As an example algorithm, we are going to use merge sort, a sophisticated, divide-and-conquer
    algorithm similar to quicksort ([https://www.geeksforgeeks.org/quick-sort-vs-merge-sort/](https://www.geeksforgeeks.org/quick-sort-vs-merge-sort/)).
    Let''s start off with the sequential version by adding the `merge_sort_seq()` function
    to `src/lib.rs`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为示例算法，我们将使用归并排序，这是一种类似于快速排序的复杂、分而治之的算法（[https://www.geeksforgeeks.org/quick-sort-vs-merge-sort/](https://www.geeksforgeeks.org/quick-sort-vs-merge-sort/)）。让我们从添加
    `merge_sort_seq()` 函数到 `src/lib.rs` 的顺序版本开始：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The high-level view of merge sort is simple: split the collection in half until
    it''s impossible to do it again, then merge the halves back *in order*. The splitting
    part is done; what''s missing is the merging part. Insert this snippet into `lib.rs`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归并排序的高级视图很简单：将集合分成两半，直到不能再分，然后按顺序合并这些半部分。分割部分已经完成；缺少的是合并部分。将以下片段插入`lib.rs`：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lastly, we will have to import `rayon`, a crate for creating parallel applications
    with ease, and then add a changed, parallelized version of merge sort:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要导入`rayon`，这是一个用于轻松创建并行应用程序的crate，然后添加一个修改过的、并行化的归并排序版本：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we add a modified version of merge sort:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个修改过的归并排序版本：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Great—but can you spot the change? To make sure both variants deliver the same
    results, let''s add a few tests:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很好——你能找到变化吗？为了确保两个版本都能提供相同的结果，让我们添加一些测试：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run `cargo test` and you should see successful tests:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`cargo test`，你应该看到成功的测试：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, we are really interested in the benchmarks—will it be faster? For
    that, create a `benches` folder containing a `seq_vs_par.rs` file. Open the file
    and add the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们真正感兴趣的是基准测试——它是否会更快？为此，创建一个包含`seq_vs_par.rs`文件的`benches`文件夹。打开文件并添加以下代码：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we run `cargo bench`, we are getting actual numbers to compare parallel
    versus sequential implementations (the change refers to previous runs of the same
    benchmark):'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行`cargo bench`时，我们得到实际的数字来比较并行和顺序实现（变化指的是之前相同基准测试的运行）：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, let's check what all of this means and pull back the curtains on the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查所有这些意味着什么，揭开代码的神秘面纱。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`rayon-rs` ([https://github.com/rayon-rs/rayon](https://github.com/rayon-rs/rayon))
    is a popular data-parallelism crate that only requires a few modifications to
    introduce automatic concurrency into the code. In our example, we are using the
    `rayon::join` operation to create a parallel version of the popular merge sort
    algorithm.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`rayon-rs` ([https://github.com/rayon-rs/rayon](https://github.com/rayon-rs/rayon))
    是一个流行的数据并行crate，它只需要少量修改就可以将自动并发引入代码。在我们的例子中，我们使用`rayon::join`操作来创建流行的归并排序算法的并行版本。'
- en: In *step 1*, we are adding dependencies for benchmarks (`[dev-dependencies]`)
    and to actually build the library (`[dependencies]`). But in *step 2* and *step
    3*, we are implementing a regular merge sort variation. Once we add the `rayon`
    dependency in *step 4*, we can add `rayon::join` in *step 5* to run each branch
    (to sorting of the left and right parts) in its own closure (`|/*no params*/|
    {/* do work */}`, or `|/*no params*/| /*do work*/` for short) in parallel *if
    possible*. The docs on `join` can be found at [https://docs.rs/rayon/1.2.0/rayon/fn.join.html](https://docs.rs/rayon/1.2.0/rayon/fn.join.html),
    go into the details about when it speeds things up.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们添加了基准测试的依赖项（`[dev-dependencies]`）以及实际构建库的依赖项（`[dependencies]`）。但在*步骤
    2*和*步骤 3*中，我们实现了一个常规的归并排序变体。一旦我们在*步骤 4*中添加了`rayon`依赖项，我们就可以在*步骤 5*中添加`rayon::join`来并行运行每个分支（到左右部分的排序），如果可能的话，在每个自己的闭包（`|/*no
    params*/| {/* do work */}`，或简写为`|/*no params*/| /*do work*/`）中并行执行。`join`的文档可以在[https://docs.rs/rayon/1.2.0/rayon/fn.join.html](https://docs.rs/rayon/1.2.0/rayon/fn.join.html)找到，其中详细说明了何时它能加速事情。
- en: In *step 8*, we are creating a benchmark test as required by the criterion.
    The library compiles a file outside the `src/` directory to run within the benchmark
    harness and output numbers (as shown in *step 9*)—and in these numbers, we can
    see a slight but consistent improvement in performance just by adding one line
    of code. Within the benchmark file, we are sorting a copy of the same random vector
    (`thread_local!()` is somewhat akin to `static`) of 100,000 random numbers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 8*中，我们正在创建一个符合criterion要求的基准测试。库在`src/`目录外编译一个文件，在基准测试框架中运行并输出数字（如*步骤 9*所示）——在这些数字中，我们可以看到仅通过添加一行代码就实现了轻微但一致的性能提升。在基准测试文件中，我们正在对相同随机向量（`thread_local!()`类似于`static`）的10万个随机数进行排序。
- en: We've successfully learned how to make sequential code parallel. Now let's move
    on to the next recipe.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何将顺序代码并行化。现在让我们继续到下一个菜谱。
- en: Concurrent data processing in vectors
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量中的并发数据处理
- en: Rust's `Vec` is a great data structure that is used not only for holding data
    but also as a management tool of sorts. In an earlier recipe (*Managing multiple
    threads*) in this chapter, we saw that when we captured the handles of multiple
    threads in `Vec` and then used the `map()` function to join them. This time, we
    are going to focus on concurrently processing regular `Vec` instances without
    additional overhead. In the previous recipe, we saw the power of `rayon-rs` and
    now we are going to use it to parallelize data processing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的 `Vec` 是一个伟大的数据结构，它不仅用于存储数据，还作为某种管理工具。在本章早期的一个配方（*管理多个线程*）中，我们看到了当我们捕获
    `Vec` 中多个线程的句柄，然后使用 `map()` 函数将它们连接起来时的情况。这次，我们将专注于并行处理常规 `Vec` 实例，而不增加额外的开销。在前一个配方中，我们看到了
    `rayon-rs` 的强大功能，现在我们将使用它来并行化数据处理。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s use `rayon-rs` some more in the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，让我们更多地使用 `rayon-rs`：
- en: Create a new project using `cargo new concurrent-processing --lib` and open
    it in Visual Studio Code.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new concurrent-processing --lib` 创建一个新的项目，并在 Visual Studio Code 中打开它。
- en: '2 First, we have to add `rayon` as a dependency by adding a few lines to `Cargo.toml`.
    Additionally, the `rand` crate and criterion for benchmarking will be useful later
    on, so let''s add those as well and configure them appropriately:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须通过在 `Cargo.toml` 中添加几行来添加 `rayon` 作为依赖项。此外，`rand` 包和用于基准测试的 criterion
    将在稍后有用，因此让我们也将它们添加并适当配置：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since we are going to add a significant statistical error measure, that is,
    the sum of squared errors, open `src/lib.rs`. In its sequential incarnation, we
    simply iterate over the predictions and their original value to find out the difference,
    then square it, and sum up the results. Let''s add that to the file:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将添加一个重要的统计误差度量，即平方误差之和，请打开 `src/lib.rs`。在其顺序版本中，我们简单地遍历预测及其原始值以找出差异，然后平方它，并汇总结果。让我们将此添加到文件中：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That seems easily parallelizable, and `rayon` offers us just the tools for
    it. Let''s create almost the same code using concurrency:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这看起来很容易并行化，而 `rayon` 正好为我们提供了所需的工具。让我们使用并发来创建几乎相同的代码：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'While the differences to the sequential code are very subtle, the changes have
    a substantial impact on execution speed! Before we proceed, we should add some
    tests to see the results of actually calling the functions. Let''s start with
    the parallel version first:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然与顺序代码的差异非常微妙，但这些变化对执行速度有重大影响！在我们继续之前，我们应该添加一些测试来查看实际调用函数的结果。让我们先从并行版本开始：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The sequential code should have the same results, so let''s duplicate the test
    for the sequential version of the code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顺序代码应该有相同的结果，因此让我们复制顺序代码版本的测试：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to check that everything works as expected, run `cargo test` in between:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查一切是否按预期工作，请在之间运行 `cargo test`：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As an additional feat of `rayon`, let''s also add some more functions to `src/lib.rs`.
    This time, they are related to counting alphanumeric characters in `str`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 `rayon` 的一个额外功能，让我们也在 `src/lib.rs` 中添加一些更多函数。这次，它们与在 `str` 中计数字母数字字符相关：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let''s see which performs better and let''s add a benchmark. To do that,
    create a `benches/` directory next to `src/` with a `seq_vs_par.rs` file. Add
    the following benchmark and helper functions to see what the speedups are. Let''s
    start with a few helpers that define the basic data the benchmark is processing:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看哪个性能更好，并添加一个基准测试。为此，在 `src/` 旁边创建一个 `benches/` 目录，并添加一个 `seq_vs_par.rs`
    文件。添加以下基准测试和辅助函数以查看速度提升。让我们从定义基准测试处理的基本数据的几个辅助函数开始：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we are going to create the benchmarks themselves:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建基准测试本身：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s create another benchmark:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个基准测试：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With that available, run `cargo bench` and (after a while) check the outputs
    to see the improvements and timings (the changed part refers to the changes from
    the previous run of the same benchmark):'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有此可用，运行 `cargo bench` 并（经过一段时间后）检查输出以查看改进和计时（变化的部分指的是与上次运行相同基准测试的变化）：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Again, `rayon-rs`—a fantastic library—has made roughly a 50% improvement in
    the benchmark performance (parallel versus sequential) by changing **a single
    line of code**.This is significant for many applications but in particular for
    machine learning, where the loss function of an algorithm is required to run hundreds
    or thousands of times during a training cycle. Cutting this time in half would
    immediately have a large impact on productivity.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`rayon-rs`——一个出色的库——通过更改**单行代码**实现了基准性能的大约 50% 的提升（并行与顺序）。这对于许多应用程序来说都是重要的，尤其是在机器学习中，算法的损失函数在训练周期中需要运行数百或数千次。将此时间减半将立即对生产力产生重大影响。
- en: In the first steps after setting everything up (*step 3*, *step 4*, and *step
    5*), we are creating a sequential and parallel implementation of the sum of squared
    errors ([https://hlab.stanford.edu/brian/error_sum_of_squares.html](https://hlab.stanford.edu/brian/error_sum_of_squares.html))
    with the only difference being `par_iter()` versus the `iter()` call including
    some tests. Then we add some—more common—counting functions to our benchmark suite,
    which we'll create and call in *step 7* and *step 8*. Again, the sequential and
    parallel algorithms work on exactly the same dataset every time to avoid any unfortunate incidents.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好一切后的第一步（*步骤 3*、*步骤 4* 和 *步骤 5*），我们正在创建平方误差和的顺序和并行实现（[https://hlab.stanford.edu/brian/error_sum_of_squares.html](https://hlab.stanford.edu/brian/error_sum_of_squares.html)），唯一的区别是
    `par_iter()` 与包括一些测试的 `iter()` 调用。然后我们添加一些——更常见的——计数函数到我们的基准测试套件中，我们将在 *步骤 7*
    和 *步骤 8* 中创建和调用它们。再次强调，顺序和并行算法每次都在完全相同的数据集上工作，以避免任何不幸的事件。
- en: We've successfully learned how to process data concurrently in vectors. Now
    let's move on to the next recipe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何在向量中并发处理数据。现在让我们继续到下一个菜谱。
- en: Shared immutable states
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享不可变状态
- en: Sometimes, when a program operates on multiple threads, the current version
    of settings and many more are available to the threads as a single point of truth.
    Sharing a state between threads is straightforward in Rust—as long as the variable
    is immutable and the types are marked as safe to share. In order to mark types
    as thread-safe, it's important that the implementation makes sure that accessing
    the information can be done without any kind of inconsistency occurring.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当程序在多个线程上运行时，当前版本设置以及更多内容都作为单一的真实点提供给线程。在 Rust 中，在变量不可变且类型被标记为安全共享的情况下，线程之间的状态共享是直接的。为了标记类型为线程安全，实现必须确保访问信息时不会发生任何不一致。
- en: Rust uses two marker traits—`Send` and `Sync`—to manage these options. Let's
    see how.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 使用两个标记特质——`Send` 和 `Sync`——来管理这些选项。让我们看看如何。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In just a few steps, we''ll explore immutable states:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个步骤中，我们将探索不可变状态：
- en: Run `cargo new immutable-states` to create a new application project and open
    the directory in Visual Studio Code.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `cargo new immutable-states` 以创建一个新的应用程序项目，并在 Visual Studio Code 中打开该目录。
- en: 'First, we''ll add the imports and a `noop` function to call to our `src/main.rs`
    file:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加导入和一个 `noop` 函数到我们的 `src/main.rs` 文件中：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s explore how different types can be shared across threads. The `mpsc::channel`
    type provides a great out-of-the-box example of a shared state. Let''s start off
    with a baseline that works as expected:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们探索不同类型如何在线程之间共享。`mpsc::channel` 类型提供了一个很好的现成示例，用于共享状态。让我们从一个按预期工作的基线开始：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To see it working, execute `cargo build`. Any errors with respect to illegal
    state sharing will be found by the compiler:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看其工作情况，请执行 `cargo build`。任何关于非法状态共享的错误都将由编译器找到：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we''ll try the same thing with the receiver. Will it work? Add this to
    the `main` function:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将尝试用接收者做同样的事情。它会工作吗？将以下内容添加到 `main` 函数中：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run `cargo build` to get a more extensive message:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `cargo build` 以获取更详细的消息：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since the receiver is only made for a single thread to fetch data out of the
    channel, it''s to be expected that this cannot be avoided using `Arc`. Similarly,
    it''s impossible to simply wrap `Rc` into `Arc` to make it available across threads.
    Add the following to see the error:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于接收者只为单个线程设计，用于从通道中获取数据，因此预期使用 `Arc` 无法避免这种情况。同样，也不可能简单地将 `Rc` 包装到 `Arc` 中，使其能够在线程之间可用。添加以下内容以查看错误：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`cargo build` reveals the consequences again—an error about how the type is
    unable to be sent across threads:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo build` 再次揭示了后果——关于类型无法在线程之间发送的错误：'
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since this recipe actually failed to build and pointed to an error message in
    the last step, what happened? We learned about `Send` and `Sync`. These marker
    traits and the types of errors will cross your path in the most surprising and
    critical situations. Since they work seamlessly when they are present, we had
    to create a failing example to show you what magic they do and how.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个菜谱实际上在最后一步未能构建，并指向了一个错误信息，发生了什么？我们学习了 `Send` 和 `Sync`。这些标记特性和错误类型将在最令人惊讶和关键的情况下出现在你的路径上。由于它们在存在时无缝工作，我们不得不创建一个失败的示例来向你展示它们所做的事情以及如何做到这一点。
- en: In Rust, marker traits ([https://doc.rust-lang.org/std/marker/index.html](https://doc.rust-lang.org/std/marker/index.html)) signal
    something to the compiler. In the case of concurrency, it's the ability to be
    shared across threads. The `Sync` (shared access from multiple threads) and `Send` (ownership
    can transfer safely from one thread to another) traits are implemented for almost
    all default data structures, but if `unsafe` code is required, then the marker
    traits have to be added manually—which is also `unsafe`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，标记特性([https://doc.rust-lang.org/std/marker/index.html](https://doc.rust-lang.org/std/marker/index.html))向编译器发出信号。在并发的情况下，这是跨线程共享的能力。`Sync`（多线程共享访问）和
    `Send`（所有者可以安全地从一条线程转移到另一条线程）特性几乎为所有默认数据结构实现，但如果需要 `unsafe` 代码，则必须手动添加标记特性——这也是
    `unsafe`。
- en: Hence, most of the data structures will be able to inherit `Send` and `Sync` from
    their properties, which is what happens in *step 2* and *step 3*. Mostly, you'll
    wrap your instance in `Arc` as well for easier handling. However, multiple instances
    of `Arc` require their contained types to implement `Send` and `Sync`. In *step
    4* and *step 6*, we try to get the available types into `Arc`—without implementing
    either `Sync` or `Send`. *Step 5* and *step 7* show the compiler's error messages
    for either try.  If you want to know more and see how to add the `marker` trait
    ([https://doc.rust-lang.org/std/marker/index.html](https://doc.rust-lang.org/std/marker/index.html))
    to custom types, check out the documentation at [https://doc.rust-lang.org/nomicon/send-and-sync.html.](https://doc.rust-lang.org/nomicon/send-and-sync.html)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数数据结构都将能够从其属性中继承 `Send` 和 `Sync`，这就是在 *步骤 2* 和 *步骤 3* 中发生的事情。通常，你还会将实例包裹在
    `Arc` 中以便更容易处理。然而，多个 `Arc` 实例需要其包含的类型实现 `Send` 和 `Sync`。在 *步骤 4* 和 *步骤 6* 中，我们尝试将可用的类型放入
    `Arc` 中——而不实现 `Sync` 或 `Send`。*步骤 5* 和 *步骤 7* 展示了尝试时编译器的错误信息。如果你想了解更多，并了解如何将 `marker`
    特性([https://doc.rust-lang.org/std/marker/index.html](https://doc.rust-lang.org/std/marker/index.html))添加到自定义类型中，请查看[https://doc.rust-lang.org/nomicon/send-and-sync.html](https://doc.rust-lang.org/nomicon/send-and-sync.html)上的文档。
- en: Now that we know more about `Send` and `Sync`, sharing states in concurrent
    programs is less of a mystery. Let's move on to the next recipe.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 `Send` 和 `Sync` 了解更多，并发程序中的状态共享就不再是谜了。让我们继续到下一个菜谱。
- en: Handling asynchronous messages with actors
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用演员处理异步消息
- en: Scalable architectures and asynchronous programming have led to a rise of actors
    and actor-based designs ([https://mattferderer.com/what-is-the-actor-model-and-when-should-you-use-it](https://mattferderer.com/what-is-the-actor-model-and-when-should-you-use-it)),
    facilitated by frameworks such as Akka ([https://akka.io/](https://akka.io/)).
    Regardless of Rust's powerful concurrency features, actors in Rust are still tricky
    to get right and they lack the documentation that many other libraries have. In
    this recipe, we are going to explore the basics of `actix`, Rust's actor framework,
    which was created after the popular Akka.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展架构和异步编程导致了演员和基于演员的设计([https://mattferderer.com/what-is-the-actor-model-and-when-should-you-use-it](https://mattferderer.com/what-is-the-actor-model-and-when-should-you-use-it))的兴起，这些设计得到了
    Akka ([https://akka.io/](https://akka.io/)) 等框架的促进。尽管 Rust 拥有强大的并发功能，但 Rust 中的演员仍然难以正确使用，并且缺乏许多其他库所拥有的文档。在这个菜谱中，我们将探索
    Rust 的演员框架 `actix` 的基础知识，该框架是在流行的 Akka 之后创建的。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Implement an actor-based sensor data reader in just a few steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个步骤即可实现基于演员的传感器数据读取器：
- en: Create a new binary application using `cargo new actors` and open the directory
    in Visual Studio Code.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new actors` 创建一个新的二进制应用程序，并在 Visual Studio Code 中打开该目录。
- en: 'Include the required dependencies in the `Cargo.toml` configuration file:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 配置文件中包含所需的依赖项：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Open `src/main.rs` to add the code before the `main` function. Let''s start
    with the imports:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/main.rs` 以在 `main` 函数之前添加代码。让我们从导入开始：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In order to create an actor system, we''ll have to think about the application''s
    structure. An actor can be thought of as a message receiver with a postbox where
    messages are piled up until they are processed. For simplicity, let''s mock up
    some sensor data mock as messages, each consisting of a `u64` timestamp and a
    `f32` value:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个演员系统，我们必须考虑应用程序的结构。演员可以被视为一个消息接收器，其中有一个邮箱，消息堆积在那里直到被处理。为了简单起见，让我们模拟一些传感器数据作为消息，每个消息由一个`u64`时间戳和一个`f32`值组成：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In a typical system, we would use an I/O loop to read from the sensor(s) in
    scheduled intervals. Since `actix` ([https://github.com/actix/actix/](https://github.com/actix/actix/))
    builds on Tokio ([https://tokio.rs/](https://tokio.rs/)), that can be explored
    outside this recipe. To simulate the fast reading and slow processing steps, we''ll
    implement it as a `for` loop:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个典型系统中，我们会使用I/O循环以预定的时间间隔从传感器（s）中读取。由于`actix`([https://github.com/actix/actix/](https://github.com/actix/actix/))建立在Tokio([https://tokio.rs/](https://tokio.rs/))之上，这部分内容可以在这个菜谱之外探索。为了模拟快速读取和慢速处理步骤，我们将它实现为一个`for`循环：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s take care of implementing the most important part: the actor''s message
    handling. `actix` requires you to implement the `Handler<T>` trait. Add the following
    implementation just before the `main` function:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来处理最重要的部分：演员的消息处理。`actix`要求您实现`Handler<T>`特质。在`main`函数之前添加以下实现：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use `cargo run` to run the program and see how it generates artificial sensor
    data (press *Ctrl + C* if you don''t want to wait for it to finish):'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo run`来运行程序，看看它是如何生成人工传感器数据的（如果您不想等待它完成，请按*Ctrl + C*）：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解。
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The actor model solves the shortcomings of passing data around threads using
    an object-oriented approach. By utilizing an implicit queue for messages to and
    from actors, it can prevent expensive locking and corrupt states. There is extensive
    content on the topic, for example, in Akka's documentation at [https://doc.akka.io/docs/akka/current/guide/actors-intro.html](https://doc.akka.io/docs/akka/current/guide/actors-intro.html).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 演员模型通过面向对象的方法解决了在线程间传递数据的不足。通过利用演员之间消息的隐式队列，它可以防止昂贵的锁定和损坏状态。关于这个主题有大量的内容，例如，在Akka的文档中[https://doc.akka.io/docs/akka/current/guide/actors-intro.html](https://doc.akka.io/docs/akka/current/guide/actors-intro.html)。
- en: After preparing the project in the first two steps, *step 3* shows the implementation
    of the `Message` trait using a macro (`[#derive()]`). With that available, we
    proceed to set up the main *system*—the main loop that runs the actor scheduling
    and message passing behind the scenes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个步骤准备项目之后，*步骤 3*展示了使用宏（`[#derive()]`）实现`Message`特质的代码。有了这个，我们继续设置主*系统*——运行演员调度和幕后消息传递的主循环。
- en: '`actix` uses `Arbiters` to run different actors and tasks. A regular Arbiter
    is basically a single-threaded event loop, helpful for working in a non-concurrent
    setting. `SyncArbiter`, on the other hand, is a multithreaded version that allows
    the use of actors across threads. In our case, we used three threads.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`actix`使用`Arbiters`来运行不同的演员和任务。一个常规的仲裁者基本上是一个单线程的事件循环，有助于在非并发环境中工作。另一方面，`SyncArbiter`是一个多线程版本，允许跨线程使用演员。在我们的例子中，我们使用了三个线程。'
- en: In *step 5*, we see the required minimum implementation of a handler. Using
    `SyncArbiter` does not allow sending messages back via the return value, which
    is why the result is an empty tuple for now. The handler is also specific to the
    message type and the handle function simulates a long-running action by issuing `thread::sleep`—this
    only works because it's the only actor running in that particular thread.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5*中，我们看到了处理器的最小实现要求。使用`SyncArbiter`不允许通过返回值发送消息，这就是为什么结果现在是一个空元组。处理器也针对特定的消息类型，处理函数通过发出`thread::sleep`来模拟长时间运行的操作——这之所以有效，是因为它是唯一在该特定线程中运行的演员。
- en: We have only scraped the surface of what `actix` can do (leaving out the all-powerful
    Tokio tasks and streams). Check out their book ([https://actix.rs/book/actix/](https://actix.rs/book/actix/))
    on the topic and the examples in their GitHub repositories[.](https://tokio.rs)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了`actix`能做什么的表面（省略了全能的Tokio任务和流）。查看他们关于这个主题的书([https://actix.rs/book/actix/](https://actix.rs/book/actix/))以及他们在GitHub存储库中的示例[.](https://tokio.rs)
- en: We've successfully learned how to handle asynchronous messages with actors.
    Now let's move on to the next recipe.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何使用演员处理异步消息。现在让我们继续下一个菜谱。
- en: Asynchronous programming with futures
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 futures 进行异步编程
- en: Using futures is a common technique in JavaScript, TypeScript, C#, and similar
    technologies—made popular by the addition of the `async`/`await` keywords in their
    syntax. In a nutshell, futures (or promises) is a function's guarantee that, at
    some point, the handle will be resolved and the actual value will be returned.
    However, there is no explicit time when this is going to happen—but you can schedule
    entire chains of promises that are resolved after each other. How does this work
    in Rust? Let's find out in this recipe.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript、TypeScript、C# 和类似技术中，使用 futures 是一种常见的技巧——通过在它们的语法中添加 `async`/`await`
    关键字而变得流行。简而言之，futures（或承诺）是一个函数的保证，在某个时刻，句柄将被解决，并将返回实际值。然而，并没有明确的时间表明这将会发生——但你可以安排一系列承诺，这些承诺依次解决。在
    Rust 中这是如何工作的？让我们在这个食谱中找出答案。
- en: At the time of writing, `async`/`await` were under heavy development. Depending
    on when you are reading this book, the examples may have stopped working. In this
    case, we ask you to open an issue in the accompanying repository so we can fix
    the issues. For updates, check the Rust `async` working group's repository at [https://github.com/rustasync/team](https://github.com/rustasync/team).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`async`/`await` 正在经历重大开发。根据你阅读这本书的时间，示例可能已经停止工作。在这种情况下，我们要求你在配套的存储库中打开一个问题，这样我们就可以修复这些问题。有关更新，请查看
    Rust `async` 工作组的存储库 [https://github.com/rustasync/team](https://github.com/rustasync/team)。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In a few steps, we''ll be able to use `async` and `await` in Rust for seamless
    concurrency:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个步骤中，我们将能够在 Rust 中使用 `async` 和 `await` 以实现无缝并发：
- en: Create a new binary application using `cargo new async-await` and open the directory
    in Visual Studio Code.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new async-await` 创建一个新的二进制应用程序，并在 Visual Studio Code 中打开该目录。
- en: 'As usual, when we are integrating a library, we''ll have to add the dependencies
    to `Cargo.toml`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，当我们集成库时，我们必须将依赖项添加到 `Cargo.toml`：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In `src/main.rs`, we have to import the dependencies. Add the following lines
    at the top of the file:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中，我们必须导入依赖项。在文件顶部添加以下行：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The classic example is waiting for a web request to finish. This is notoriously
    difficult to judge since the web resources and/or the network in between is owned
    by someone else and might be down. `surf` ([https://github.com/rustasync/surf](https://github.com/rustasync/surf))
    is `async` by default and therefore requires using the `.await` syntax heavily.
    Let''s declare an `async` function to do the fetching:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经典的例子是等待一个网络请求完成。这通常很难判断，因为网络资源和/或中间的网络可能由其他人拥有，并且可能已经关闭。`surf` ([https://github.com/rustasync/surf](https://github.com/rustasync/surf))
    默认为 `async`，因此需要大量使用 `.await` 语法。让我们声明一个 `async` 函数来进行获取：
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we need an `async main` function in order to call the `response_code()
    async` function:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个 `async main` 函数来调用 `response_code() async` 函数：
- en: '[PRE61]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s see if the code works by running `cargo run` (a `200 OK` is expected):'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行 `cargo run` 来看看代码是否工作（预期结果是 `200 OK`）：
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`async` and `await` have been worked on for a long time in the Rust community.
    Let''s see how this recipe works.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 在 Rust 社区中已经讨论了很长时间。让我们看看这个食谱是如何工作的。'
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Futures (often called promises) are typically fully integrated into the language
    and come with a built-in runtime. In Rust, the team chose a more ambitious approach
    and left the runtime open for the community to implement (for now). Right now
    the two projects Tokio and Romio ([https://github.com/withoutboats/romio](https://github.com/withoutboats/romio))
    and `juliex` ([https://github.com/withoutboats/juliex](https://github.com/withoutboats/juliex))
    have the most sophisticated support for these futures. With the recent addition
    of `async`/`await` in the Rust syntax in the 2018 edition, it's only a matter
    of time until the various implementations mature.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Futures（通常称为承诺）通常完全集成到语言中，并带有内置的运行时。在 Rust 中，团队选择了一种更雄心勃勃的方法，并将运行时留给社区来实现（目前是这样）。目前，两个项目
    Tokio 和 Romio ([https://github.com/withoutboats/romio](https://github.com/withoutboats/romio))
    以及 `juliex` ([https://github.com/withoutboats/juliex](https://github.com/withoutboats/juliex))
    为这些 futures 提供了最复杂的支持。随着 2018 版本中 Rust 语法中 `async`/`await` 的最近添加，各种实现成熟只是时间问题。
- en: After setting up the dependencies in *step 1*, *step 2* shows that we don't
    have to enable the `async` and `await` macros/syntax to use them in the code—this
    was a requirement for a long time. Then, we import the required crates. Coincidentally,
    a new async web library—called `surf`—was built by the Rust async working group
    while we were busy with this book. Since this crate was built fully asynchronous,
    we preferred it over more established crates such as `hyper` ([https://hyper.rs](https://hyper.rs)).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第1步* 中设置好依赖项后，*第2步* 显示我们不需要启用 `async` 和 `await` 宏/语法就可以在代码中使用它们——这曾经是一个长期的要求。然后，我们导入所需的包。巧合的是，当我们在忙于这本书时，Rust
    异步工作组构建了一个新的异步网络库——称为 `surf`。由于这个包是完全异步构建的，我们更倾向于使用它而不是更成熟的包，如 `hyper` ([https://hyper.rs](https://hyper.rs))。
- en: 'In *step 3*, we declare an `async` function, which automatically returns a
    `Future` ([https://doc.rust-lang.org/std/future/trait.Future.html](https://doc.rust-lang.org/std/future/trait.Future.html))
    type and can only be called from within another `async` scope. *Step 4* shows
    the creation of such a scope with the `async` main function. Does it end there?
    No—the `#[runtime::main]` attribute gives it away: a runtime is seamlessly started
    and assigned to execute anything async.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第3步* 中，我们声明了一个 `async` 函数，它自动返回一个 `Future` ([https://doc.rust-lang.org/std/future/trait.Future.html](https://doc.rust-lang.org/std/future/trait.Future.html))
    类型，并且只能在其他 `async` 范围内调用。*第4步* 展示了如何使用 `async main` 函数创建这样的范围。这就结束了吗？不——`#[runtime::main]`
    属性揭示了这一点：运行时无缝启动并分配执行任何异步操作。
- en: While the `runtime` crate ([https://docs.rs/runtime/0.3.0-alpha.7/runtime/](https://docs.rs/runtime/0.3.0-alpha.7/runtime/))
    is agnostic of the actual implementation, the default is a native runtime based
    on `romio` and `juliex` (check your `Cargo.lock` file), but you can also enable
    the much more feature-laden [tokio](https://tokio.rs) runtime to enable streams,
    timers, and so on to use on top of async.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `runtime` 包 ([https://docs.rs/runtime/0.3.0-alpha.7/runtime/](https://docs.rs/runtime/0.3.0-alpha.7/runtime/))
    对实际实现不敏感，但默认情况下是基于 `romio` 和 `juliex` 的本地运行时（检查您的 `Cargo.lock` 文件），但您也可以启用功能更丰富的
    [tokio](https://tokio.rs) 运行时，以启用流、定时器等功能，用于异步操作之上。
- en: Inside the `async` functions, we can make use of the `await` keyword attached
    to a `Future` implementor ([https://doc.rust-lang.org/std/future/trait.Future.html](https://doc.rust-lang.org/std/future/trait.Future.html)),
    such as the `surf` request ([https://github.com/rustasync/surf/blob/master/src/request.rs#L563](https://github.com/rustasync/surf/blob/master/src/request.rs#L563)),
    where the runtime calls `poll()` until a result is available. This can also result
    in an error, which means that we have to handle errors as well, which is generally
    done with the `?` operator. `surf` also provides a generic `Exception` type ([https://docs.rs/surf/1.0.2/surf/type.Exception.html](https://docs.rs/surf/1.0.2/surf/type.Exception.html))
    alias to handle anything that might happen.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `async` 函数内部，我们可以使用附加到 `Future` 实现者的 `await` 关键字 ([https://doc.rust-lang.org/std/future/trait.Future.html](https://doc.rust-lang.org/std/future/trait.Future.html))，例如
    `surf` 请求 ([https://github.com/rustasync/surf/blob/master/src/request.rs#L563](https://github.com/rustasync/surf/blob/master/src/request.rs#L563))，其中运行时会调用
    `poll()` 直到结果可用。这也可能导致错误，这意味着我们必须处理错误，这通常使用 `?` 操作符来完成。`surf` 还提供了一个通用的 `Exception`
    类型 ([https://docs.rs/surf/1.0.2/surf/type.Exception.html](https://docs.rs/surf/1.0.2/surf/type.Exception.html))
    别名来处理可能发生的一切。
- en: While there are some things that could still change in Rust's fast-moving ecosystem,
    using `async`/`await` is finally coming together without requiring highly unstable
    crates. Having that available is a significant boost to Rust's usefulness. Now,
    let's move on to another chapter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Rust 快速发展的生态系统中还有一些事情可能会发生变化，但使用 `async`/`await` 现在终于可以一起使用，而无需高度不稳定的包。拥有这一点对
    Rust 的实用性是一个重大的提升。现在，让我们继续到另一个章节。
