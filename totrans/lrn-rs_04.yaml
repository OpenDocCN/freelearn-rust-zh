- en: Conditions, Recursion, and Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops and conditions within any programming language are a fundamental aspect
    of operation. You may be looping around a list attempting to find when something
    matches, and when a match occurs, branching out to perform some other task; or,
    you may just want to check a value to see whether it meets a condition. In any
    case, Rust allows you to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of loop available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of branching within loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the semicolon (`;`) can be omitted and what it means
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust has essentially three types of loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loop` is the simplest one—it just goes through a block of code again and again
    until one of the loop-breaking keywords is used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while` is like loop, but with a condition—the block of code is looped again
    and again as long as the condition is true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` is different from the above two—it is for iterating through sequences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loops are slightly different from the same construct in C-like languages.
    In C, the `for` loops consist of three things: an initialization, a stopping condition,
    and a stepping instruction. Rust `for` loops are a bit higher-level though: they
    are for iterating through sequences.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple example to start with—a loop that goes from 0 to 10 and
    outputs the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We create a variable `x` that takes an element from the range (`0..10`), one
    by one, and does something with it. In Rust terminology, `0..10` is not only a
    variable but also an **iterator**, as it gives back a value from a series of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is obviously a very simple example. We can also define the iterator to
    work in the opposite direction. In C, you will expect something akin to `for (i
    = 10; i > 0; --i)`. In Rust, we use the `rev()` method to reverse the iterator,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that the range excludes the last number. So, for the previous
    example, the values outputted are `9` to `0`; essentially, the program generates
    the output values from 0 to 10 and then outputs them in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for the `for` loops is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The C# equivalent for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using enumerate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `loop` condition can also be more complex, using multiple conditions and
    variables. For example, the `for` loop can be tracked using `enumerate`. This
    will keep track of how many times the loop has executed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Say we have an array that we need to iterate over to obtain the values. Here,
    the `enumerate` method can be used to obtain the value of the array members. The
    value returned in the condition will be a reference, so a code such as the one
    shown in the following example will fail to execute (`line` is a `&` reference
    whereas an `i32` is expected):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be simply converted back from the reference value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iter().enumerate()` method can equally be used with the `Vec` type (or
    any other type that implements the iterator trait), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the value given at the end will be `49`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The _ parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may be wondering what the `_` parameter is. In Rust, it is often not allowed
    to omit variable bindings even if we don't use them. We can use `_` to signify
    that we know that this place needs a variable binding, but we are never going
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The simple loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple form of the loop is called `loop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code has no loop-ending keywords, such as break; it will output
    `Hello` until the application is terminated manually.
  prefs: []
  type: TYPE_NORMAL
- en: The while condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `while` condition extends the loop with a condition, as you will see in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will output `done = 0` to `done = 31`. The loop terminates
    when `done` equals `32`.
  prefs: []
  type: TYPE_NORMAL
- en: Prematurely terminating a loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the size of the data being iterated over within a loop, the loop
    can be costly on processor time. For example, say the server is receiving data
    from a data-logging application, such as measuring values from a gas chromatograph;
    over the entire scan, it may record roughly half a million data points with an
    associated time position.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we want to add all of the recorded values until the value
    is over 1.5 and once that is reached, we can stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sound easy? There is one thing not mentioned: there is no guarantee that the
    recorded value will ever reach over 1.5, so how can we terminate the loop if the
    value is reached?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this in one of two ways. The first is to use a `while` loop and introduce
    a Boolean to act as the test condition. In the following example, `my_array` represents
    a very small subsection of the data sent to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The result here is `4.4`. This code is perfectly acceptable, if slightly long-winded.
    Rust also allows the use of the `break` and `continue` keywords (if you're familiar
    with C, they work in the same way).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code using `break` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Again, this will give an answer of `4.4`, indicating that the two methods used
    are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: If we replace `break` with `continue` in the preceding code example, we will
    get the same result (`4.4`). The difference between `break` and `continue` is
    that `continue` jumps to the next value in the iteration rather than jumping out,
    so if we had the final value of `my_array` as `1.3`, the output at the end should
    be `5.7`.
  prefs: []
  type: TYPE_NORMAL
- en: When using `break` and `continue`, always keep in mind this difference. While
    it may not crash the code, mistaking `break` and `continue` may lead to results
    that you may not expect or want.
  prefs: []
  type: TYPE_NORMAL
- en: Using loop labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allows us to label our loops. This can be very useful, for example with
    nested loops. These labels act as symbolic names for the loop and as we have a
    name for the loop, we can instruct the application to perform a task on that name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What will this code do?
  prefs: []
  type: TYPE_NORMAL
- en: Here, `x % 2 == 0` (or `y % 2 == 0`) means that if a variable divided by two
    returns no remainder, then the condition is met and it executes the code in the
    braces. When `x % 2 == 0`, or when the value of the loop is an even number, we
    will tell the application to skip to the next iteration of `outer_loop`, which
    is an odd number. However, we will also have an inner loop. Again, when `y % 2`
    is an even value, we will tell the application to skip to the next iteration of
    `inner_loop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the application will output the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While this example may seem very simple, it does allow for a great deal of speed
    when checking data. Let's go back to our previous example of data being sent to
    the web service. Recall that we have two values—the recorded data and some other
    value; for ease, it will be a data point. Each data point is recorded 0.2 seconds
    apart; therefore, every fifth data point is one second.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we want all of the values where the data is greater than 1.5 and
    the associated time of that data point, but only on a time when it's dead on a
    second. As we want the code to be understandable and human-readable, we can use
    a loop label on each loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is not quite correct. Can you spot why? The code compiles
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example is a very good one to demonstrate the correct operator in use.
    The issue is the `if *time_value % 5f32 == 0f32` line. We are taking a float value
    and using the modulus of another float to see whether we end up with 0 as a float.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing any value that is not a `string`, `int`, `long`, or `bool` type to
    another is never a good plan, especially if the value is returned by some form
    of calculation. We can also not simply use `continue` on the time loop, so how
    can we solve this problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, we''re using `_` instead of a named parameter for the enumeration
    of the loop. These values are always an integer; therefore, if we replace `_`
    for a variable name, then we can use `% 5` to perform the calculation and the
    code becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next problem is that the output isn''t correct. The code gives the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The data point is correct, but the time is way out and continually repeats.
    We still need the `continue` statement for the data point step, but the time step
    is incorrect. There are a couple of solutions, but possibly the simplest will
    be to store the data and the time in a new vector and then display that data at
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code gets closer to what is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Yes, we now have the correct data, but the time starts again. We're close, but
    it's not right yet. We aren't continuing the `time_loop` loop and we will also
    need to introduce a `break` statement. To trigger the `break`, we will create
    a new variable called `done`. When `v`, the enumerator for `my_array`, reaches
    the length of the vector (this is the number of elements in the vector), we will
    change this from `false` to `true`. This is then tested outside of the `data_loop`.
    If `done == true`, break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final version of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final output from the code is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final form of loop to consider is known as a **recursive function**. This
    is a function that calls itself until a condition is met. In pseudocode, the function
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An actual implementation of a recursive function would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea of a recursive function is very simple, but we need to consider two
    parts of this code. The first is the `let` line in the `recurse` function and
    what it means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of writing this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is that the semicolon is not being used everywhere. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What is the difference between having and not having a semicolon?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Rust, almost everything is an expression. This means that almost everything
    returns a value. One exception is the variable binding statement `let`. In a `let`
    statement, and many others, the ending semicolon is a mandatory part of the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in expressions, the semicolon has a double role: it throws away a
    return value of the expression in addition to allowing further expressions. So
    if the expression is the last in a block, having a semicolon there means that
    the last value is thrown away, and not having a semicolon there means to return
    the last value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example should make it clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two different uses of the semicolon. Let''s look at the `let y` line
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The code within the braces is processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final line, without the semicolon, is assigned to `y`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentially, this is considered as an inline function that returns the line
    without the semicolon into the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line to consider is for `z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, the code within the braces is evaluated. In this case, the line ends
    with a semicolon, so the result is thrown away and the empty value `()` gets bound
    to `z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it is executed, we will get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the code example, the line within `fn main` calling `recurse` gives the same
    result with or without the semicolon, because the Rust runtime doesn't use `main`'s
    return value for anything.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered the different types of loops that are available
    within Rust, as well as gained an understanding of when to use a semicolon and
    what it means to omit it. We have also considered enumeration and iteration over
    a vector and an array and how to handle the data held within them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will see why Rust is a good choice for server applications:
    memory handling.'
  prefs: []
  type: TYPE_NORMAL
