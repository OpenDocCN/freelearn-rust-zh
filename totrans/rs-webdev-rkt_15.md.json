["```rs\n    use crate::models::our_date_time::OurDateTime;\n    use crate::models::post_type::PostType;\n    use chrono::{offset::Utc, TimeZone};\n    use uuid::Uuid;\n    ```", "```rs\n    #[test]\n    fn test_raw_html() {\n    }\n    ```", "```rs\n    let created_at = OurDateTime(Utc.timestamp_nanos(1431648000000000));\n    let post = Post {\n        uuid: Uuid::new_v4(),\n        user_uuid: Uuid::new_v4(),\n        post_type: PostType::Text,\n        content: String::from(\"hello\"),\n        created_at: created_at,\n    };\n    let text_post = TextPost::new(&post);\n    ```", "```rs\n    assert!(\n        text_post.raw_html() == \n        String::from(\"<p>hel1lo</p>\"),\n        \"String is not equal, {}, {}\",\n        text_post.raw_html(),\n        String::from(\"<p>hello</p>\")\n    );\n    ```", "```rs\n    $ cargo test\n       Compiling our_application v0.1.0 (/workspace/\n       rocketbook/Chapter12/01RustTesting)\n    …\n    running 1 test\n    test models::text_post::test_raw_html ... FAILED\n    failures:\n    ---- models::text_post::test_raw_html stdout ----\n    thread 'models::text_post::test_raw_html' panicked at 'String is not equal, <p>hello</p>, <p>hello</p>', src/models/text_post.rs:33:5\n    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n    failures:\n        models::text_post::test_raw_html\n    test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n    error: test failed, to rerun pass '--lib' \n    ```", "```rs\n    $ cargo test\n       Compiling our_application v0.1.0 (/workspace/\n       rocketbook/Chapter12/01RustTesting)\n    …\n    running 1 test\n    test models::text_post::test_raw_html ... ok\n    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n         Running unittests (target/debug/deps/our_\n         application-43a2db5b02032f30)\n    running 0 tests\n    test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n       Doc-tests our_application\n    running 0 tests\n    test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n    ```", "```rs\n    assert_eq!(text_post.raw_html(), String::from(\"<p>hello</p>\"));\n    assert_ne!(text_post.raw_html(), String::from(\"<img>hello</img>\"));\n    ```", "```rs\n    warning: unused import: `crate::models::our_date_time::OurDateTime`\n     --> src/models/text_post.rs:1:5\n      |\n    1 | use crate::models::our_date_time::OurDateTime;\n      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      |\n      = note: `#[warn(unused_imports)]` on by default\n    ```", "```rs\n    #[cfg(test)]\n    mod tests {\n    }\n    ```", "```rs\n    use crate::models::our_date_time::OurDateTime;\n    use crate::models::post_type::PostType;\n    use chrono::{offset::Utc, TimeZone};\n    use uuid::Uuid;\n    ```", "```rs\n    use super::TextPost;\n    use crate::models::our_date_time::OurDateTime;\n    use crate::models::post::Post;\n    use crate::models::post_type::PostType;\n    use crate::traits::DisplayPostContent;\n    use chrono::{offset::Utc, TimeZone};\n    use uuid::Uuid;\n    ```", "```rs\n    $ cargo test\n    Finished test [unoptimized + debuginfo] target(s) \n        in 0.34s\n         Running unittests (target/debug/deps/our_\n         application-40cf18b02419edd7)\n    running 1 test\n    test models::text_post::tests::test_raw_html ... ok\n    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n         Running unittests (target/debug/deps/our_\n         application-77e614e023a036bf)\n    running 0 tests\n    test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n       Doc-tests our_application\n    running 0 tests\n    test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n    ```", "```rs\n    #[test]\n    fn some_test() {\n        assert_eq!(2, 1 + 1);\n    }\n    ```", "```rs\n    ...\n    Running tests/functional_tests.rs\n    ...\n    ```", "```rs\n    #[rocket::async_test]\n    async fn test_rocket() {\n    }\n    ```", "```rs\nimpl Config {\n    pub fn get_database_url(&self) -> String {\n        self.databases.main_connection.url.clone()\n    }\n}\n```", "```rs\n    use our_application::setup_rocket;\n    use rocket::{Build, Rocket};\n    #[launch]\n    async fn rocket() -> Rocket<Build> {\n        setup_rocket().await\n    }\n    ```", "```rs\n    use our_application;\n    ```", "```rs\nlet rocket = our_application::setup_rocket().await;\n```", "```rs\n    use our_application::Config;\n    use rocket_db_pools::sqlx::PgConnection;\n    use sqlx::postgres::PgPoolOptions;\n    ```", "```rs\nlet config_wrapper = rocket.figment().extract();\nassert!(config_wrapper.is_ok());\nlet config: Config = config_wrapper.unwrap();\nlet db_url = config.get_database_url();\nlet db_wrapper = PgPoolOptions::new()\n    .max_connections(5)\n    .connect(&db_url)\n    .await;\nassert!(db_wrapper.is_ok());\nlet db = db_wrapper.unwrap();\n```", "```rs\n    use our_application::models::user::User;\n    ```", "```rs\n#[rocket::async_trait]\ntrait ModelCleaner {\n    async fn clear_all(connection: &mut PgConnection) \n    -> Result<(), String>;\n}\n#[rocket::async_trait]\nimpl ModelCleaner for User {\n    async fn clear_all(connection: &mut PgConnection) \n    -> Result<(), String> {\n        let _ = sqlx::query(\"TRUNCATE users RESTART \n        IDENTITY CASCADE\")\n            .execute(connection)\n            .await\n            .map_err(|_| String::from(\"error \n            truncating databasse\"))?;\n        Ok(())\n    }\n}\n```", "```rs\n    let pg_connection_wrapper = db.acquire().await;\n    assert!(pg_connection_wrapper.is_ok());\n    let mut pg_connection = pg_connection_wrapper.unwrap();\n    let clear_result_wrapper = User::clear_all(&mut pg_connection).await;\n    assert!(clear_result_wrapper.is_ok());\n    ```", "```rs\n    use rocket::local::asynchronous::Client;\n    ```", "```rs\nlet client_wrapper = Client::tracked(rocket).await;\nassert!(client_wrapper.is_ok());\nlet client = client_wrapper.unwrap();\n```", "```rs\n    [dev-dependencies]\n    scraper = \"0.12.0\"\n    ```", "```rs\n    use rocket::http::Status;\n    ```", "```rs\nlet req = client.get(\"/users\");\nlet resp = req.dispatch().await;\nassert_eq!(resp.status(), Status::Ok);\n```", "```rs\n    use scraper::{Html, Selector}; \n    ```", "```rs\nlet body_wrapper = resp.into_string().await;\nassert!(body_wrapper.is_some());\nlet body = Html::parse_document(&body_wrapper.unwrap());\nlet selector = Selector::parse(r#\"mark.tag\"#).unwrap();\nlet containers = body.select(&selector);\nlet num_of_elements = containers.count();\nassert_eq!(num_of_elements, 0);\n```", "```rs\n    let req = client.get(\"/users/new\");\n    let resp = req.dispatch().await;\n    assert_eq!(resp.status(), Status::Ok);\n    let body_wrapper = resp.into_string().await;\n    assert!(body_wrapper.is_some());\n    let body = Html::parse_document(&body_wrapper.unwrap());\n    let authenticity_token_selector = Selector::parse(r#\"input[name=\"authenticity_token\"]\"#).unwrap();\n    let element_wrapper = body.select(&authenticity_token_selector).next();\n    assert!(element_wrapper.is_some());\n    let element = element_wrapper.unwrap();\n    let value_wrapper = element.value().attr(\"value\");\n    assert!(value_wrapper.is_some());\n    let authenticity_token = value_wrapper.unwrap();\n    ```", "```rs\n    use rocket::http::ContentType;\n    ```", "```rs\n    let username = \"testing123\";\n    let password = \"lkjKLAJ09231478mlasdfkjsdkj\";\n    let req = client.post(\"/users\")\n        .header(ContentType::Form)\n        .body(\n            format!(\"authenticity_token={\n            }&username={}&email={}@{}\n            .com&password={}&password_confirmation={}\n            &description=\",\n        authenticity_token, username, username, username, \n        password, password,\n    ));\n    let resp = req.dispatch().await;\n    assert_eq!(resp.status(), Status::SeeOther);\n    ```", "```rs\n    let req = client.get(\"/users\");\n    let resp = req.dispatch().await;\n    assert_eq!(resp.status(), Status::Ok);\n    let body_wrapper = resp.into_string().await;\n    assert!(body_wrapper.is_some());\n    let body = Html::parse_document(&body_wrapper.unwrap());\n    let selector = Selector::parse(r#\"mark.tag\"#).unwrap();\n    let containers = body.select(&selector);\n    let num_of_elements = containers.count();\n    assert_eq!(num_of_elements, 1);\n    ```", "```rs\n$ cargo test\n...\n     Running tests/functional_tests.rs (target/debug/deps/functional_tests-625b16e4b25b72de)\nrunning 2 tests\ntest some_test ... ok\n...\ntest test_rocket ... ok\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.43s\n```", "```rs\n$ cargo test\n...\n     Running tests/functional_tests.rs (target/\n     debug/deps/functional_tests-625b16e4b25b72de)\nrunning 2 tests\ntest some_test ... ok\n...\ntest test_rocket ... FAILED\nfailures:\n---- test_rocket stdout ----\nthread 'test_rocket' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `1`', tests/functional_tests.rs:115:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nthread 'rocket-worker-test-thread' panicked at 'called `Result::unwrap()` on an `Err` value: Disconnected',\n/workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs:137:28\nfailures:\n    test_rocket\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 2.09s\n```", "```rs\ncsrf_token\n```", "```rs\n    .verify(&new_user.authenticity_token)\n```", "```rs\n    .map_err(|err| {\n```", "```rs\n        log::error!(\"Verify authenticity_token error: {}\", \n```", "```rs\n        err);\n```", "```rs\n        Flash::error(\n```", "```rs\n            Redirect::to(\"/users/new\"),\n```", "```rs\n            \"Something went wrong when creating user\",\n```", "```rs\n        )\n```", "```rs\n    })?;\n```", "```rs\nasync fn from_request(request: &'r Request<'_>) -> Outcome<Self, Self::Error> {\n```", "```rs\n    match request.get_csrf_token() {\n```", "```rs\n        None => Outcome::Failure((Status::Forbidden, ())),\n```", "```rs\n        Some(token) => Outcome::Success(Self(base64::\n```", "```rs\n        encode_config(token, base64::URL_SAFE))),\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\n    rust-gdb -q target/debug/our_application\n    ```", "```rs\n    Reading symbols from target/debug/our_application...\n    Reading symbols from /workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application/Contents/Resources/DWARF/our_application...\n    (gdb)\n    ```", "```rs\n    b /workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs:143\n    ```", "```rs\n    No source file named /workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs.\n    Make breakpoint pending on future shared library load? (y or [n])\n    ```", "```rs\n    (y or [n]) y\n    Breakpoint 1 (/workspace/rocketbook/Chapter12/03RocketTesting/src/lib.rs:143) pending.\n    ```", "```rs\n    (gdb) r\n    ```", "```rs\n    Starting program: /workspace/rocketbook/Chapter12/03RocketTesting/target/debug/our_application \n      [Thread debugging using libthread_db enabled]\n    Using host libthread_db library \n      \"/usr/lib/libthread_db.so.1\".\n      [New Thread 0x7ffff7c71640 (LWP 50269)]\n      ...\n      [New Thread 0x7ffff746d640 (LWP 50273)]\n      Thread 1 \"our_application\" hit Breakpoint 1, our_\n    application::main::{generator#0} () at \n      src/lib.rs:143\n      143         final_rocket\n    ```", "```rs\n    (gdb) p config\n    ```", "```rs\n$1 = our_application::Config {databases: our_application::Databases {main_connection: our_application::MainConnection {url: \"postgres://username:password@localhost/rocket\"}}, jwt_secret: \"+/xbAZJs+e1BA4\ngbv2zPrtkkkOhrYmHUGnJIoaL9Qsk=\"}\n```", "```rs\n    (gdb) quit\n    A debugging session is active.\n            Inferior 1 [process 50265] will be killed.\n    Quit anyway? (y or n) y\n    ```"]