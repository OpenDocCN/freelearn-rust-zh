["```rs\nuse std::thread;\nuse std::sync::{Arc, RwLock};\n\nfn main() {\n    let resource: Arc<RwLock<u16>> = Arc::new(RwLock::new(0));\n\n    let total_readers = 5;\n\n    let mut reader_jhs = Vec::with_capacity(total_readers);\n    for _ in 0..total_readers {\n        let resource = Arc::clone(&resource);\n        reader_jhs.push(thread::spawn(move || {\n            let mut total_lock_success = 0;\n            let mut total_lock_failure = 0;\n            let mut total_zeros = 0;\n            while total_zeros < 100 {\n                match resource.try_read() {\n                    Ok(guard) => {\n                        total_lock_success += 1;\n                        if *guard == 0 {\n                            total_zeros += 1;\n                        }\n                    }\n                    Err(_) => {\n                        total_lock_failure += 1;\n                    }\n                }\n            }\n            (total_lock_failure, total_lock_success)\n        }));\n    }\n\n    {\n        let mut loops = 0;\n        while loops < 100 {\n            let mut guard = resource.write().unwrap();\n            *guard = guard.wrapping_add(1);\n            if *guard == 0 {\n                loops += 1;\n            }\n        }\n    }\n\n    for jh in reader_jhs {\n        println!(\"{:?}\", jh.join().unwrap());\n    }\n}\n```", "```rs\n(0, 100)\n(0, 100)\n(0, 100)\n(0, 100)\n(0, 100)\n```", "```rs\n(0, 100)\n(126143752, 2630308)\n(0, 100)\n(0, 100)\n(126463166, 2736405)\n```", "```rs\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let total_readers = 5;\n    let mut sends = Vec::with_capacity(total_readers);\n\n    let mut reader_jhs = Vec::with_capacity(total_readers);\n    for _ in 0..total_readers {\n        let (snd, rcv) = mpsc::sync_channel(64);\n        sends.push(snd);\n        reader_jhs.push(thread::spawn(move || {\n            let mut total_zeros = 0;\n            let mut seen_values = 0;\n            for v in rcv {\n                seen_values += 1;\n                if v == 0 {\n                    total_zeros += 1;\n                }\n                if total_zeros >= 100 {\n                    break;\n                }\n            }\n            seen_values\n        }));\n    }\n\n    {\n        let mut loops = 0;\n        let mut cur: u16 = 0;\n        while loops < 100 {\n            cur = cur.wrapping_add(1);\n            for snd in &sends {\n                snd.send(cur).expect(\"failed to send\");\n            }\n            if cur == 0 {\n                loops += 1;\n            }\n        }\n    }\n\n    for jh in reader_jhs {\n        println!(\"{:?}\", jh.join().unwrap());\n    }\n}\n```", "```rs\n6553600\n6553600\n6553600\n6553600\n6553600\n```", "```rs\nuse std::thread;\nuse std::sync::{Arc, Condvar, Mutex};\n\nfn main() {\n    let total_readers = 5;\n    let mutcond: Arc<(Mutex<(bool, u16)>, Condvar)> =\n        Arc::new((Mutex::new((false, 0)), Condvar::new()));\n```", "```rs\n    let mut reader_jhs = Vec::with_capacity(total_readers);\n    for _ in 0..total_readers {\n        let mutcond = Arc::clone(&mutcond);\n        reader_jhs.push(thread::spawn(move || {\n            let mut total_zeros = 0;\n            let mut total_wakes = 0;\n            let &(ref mtx, ref cnd) = &*mutcond;\n\n            while total_zeros < 100 {\n                let mut guard = mtx.lock().unwrap();\n                while !guard.0 {\n                    guard = cnd.wait(guard).unwrap();\n                }\n                guard.0 = false;\n\n                total_wakes += 1;\n                if guard.1 == 0 {\n                    total_zeros += 1;\n                }\n            }\n            total_wakes\n        }));\n    }\n```", "```rs\n    let _ = thread::spawn(move || {\n        let &(ref mtx, ref cnd) = &*mutcond;\n        loop {\n            let mut guard = mtx.lock().unwrap();\n            guard.1 = guard.1.wrapping_add(1);\n            guard.0 = true;\n            cnd.notify_all();\n        }\n    });\n```", "```rs\n    for jh in reader_jhs {\n        println!(\"{:?}\", jh.join().unwrap());\n    }\n}\n```", "```rs\n7243473\n6890156\n6018468\n6775609\n6192116\n```", "```rs\nuse std::{thread, time};\nuse std::sync::{Arc, Barrier, Condvar, Mutex};\n\n// NOTE if this were a crate, rather than a stand-alone\n// program, we could and _should_ use the XorShiftRng\n// from the 'rand' crate.\npub struct XorShiftRng {\n    state: u32,\n}\n\nimpl XorShiftRng {\n    fn with_seed(seed: u32) -> XorShiftRng {\n        XorShiftRng { state: seed }\n    }\n\n    fn next_u32(&mut self) -> u32 {\n        self.state ^= self.state << 13;\n        self.state ^= self.state >> 17;\n        self.state ^= self.state << 5;\n        return self.state;\n    }\n}\n```", "```rs\nstruct Resources {\n    lock: Mutex<(bool, bool, bool)>,\n    fuel: Condvar,\n    oxidizer: Condvar,\n    astronauts: Condvar,\n}\n```", "```rs\nfn producer(resources: Arc<Resources>) {\n    let mut rng = XorShiftRng::with_seed(2005);\n    loop {\n        let mut guard = resources.lock.lock().unwrap();\n        (*guard).0 = false;\n        (*guard).1 = false;\n        (*guard).2 = false;\n        match rng.next_u32() % 3 {\n            0 => {\n                (*guard).0 = true;\n                resources.fuel.notify_all()\n            }\n            1 => {\n                (*guard).1 = true;\n                resources.oxidizer.notify_all()\n            }\n            2 => {\n                (*guard).2 = true;\n                resources.astronauts.notify_all()\n            }\n            _ => unreachable!(),\n        }\n    }\n}\n```", "```rs\nfn rocket(name: String, resources: Arc<Resources>, \n          all_go: Arc<Barrier>, lift_off: Arc<Barrier>) {\n    {\n        let mut guard = resources.lock.lock().unwrap();\n        while !(*guard).0 {\n            guard = resources.fuel.wait(guard).unwrap();\n        }\n        (*guard).0 = false;\n        println!(\"{:<6} ACQUIRE FUEL\", name);\n    }\n    {\n        let mut guard = resources.lock.lock().unwrap();\n        while !(*guard).1 {\n            guard = resources.oxidizer.wait(guard).unwrap();\n        }\n        (*guard).1 = false;\n        println!(\"{:<6} ACQUIRE OXIDIZER\", name);\n    }\n    {\n        let mut guard = resources.lock.lock().unwrap();\n        while !(*guard).2 {\n            guard = resources.astronauts.wait(guard).unwrap();\n        }\n        (*guard).2 = false;\n        println!(\"{:<6} ACQUIRE ASTRONAUTS\", name);\n    }\n\n    all_go.wait();\n    lift_off.wait();\n    println!(\"{:<6} LIFT OFF\", name);\n}\n```", "```rs\nfn main() {\n    let all_go = Arc::new(Barrier::new(4));\n    let lift_off = Arc::new(Barrier::new(4));\n    let resources = Arc::new(Resources {\n        lock: Mutex::new((false, false, false)),\n        fuel: Condvar::new(),\n        oxidizer: Condvar::new(),\n        astronauts: Condvar::new(),\n    });\n\n    let mut rockets = Vec::new();\n    for name in &[\"KSC\", \"VAB\", \"WSMR\"] {\n        let all_go = Arc::clone(&all_go);\n        let lift_off = Arc::clone(&lift_off);\n        let resources = Arc::clone(&resources);\n        rockets.push(thread::spawn(move || {\n            rocket(name.to_string(), resources, \n                   all_go, lift_off)\n        }));\n    }\n\n    thread::spawn(move || {\n        producer(resources);\n    });\n\n    all_go.wait();\n    let one_second = time::Duration::from_millis(1_000);\n    println!(\"T-11\");\n    for i in 0..10 {\n        println!(\"{:>4}\", 10 - i);\n        thread::sleep(one_second);\n    }\n    lift_off.wait();\n\n    for jh in rockets {\n        jh.join().unwrap();\n    }\n}\n```", "```rs\nKSC    ACQUIRE FUEL\nWSMR   ACQUIRE FUEL\nWSMR   ACQUIRE OXIDIZER\nVAB    ACQUIRE FUEL\nWSMR   ACQUIRE ASTRONAUTS\nKSC    ACQUIRE OXIDIZER\nKSC    ACQUIRE ASTRONAUTS\nVAB    ACQUIRE OXIDIZER\nVAB    ACQUIRE ASTRONAUTS\nT-11\n  10\n   9\n   8\n   7\n   6\n   5\n   4\n   3\n   2\n   1\nVAB    LIFT OFF\nWSMR   LIFT OFF\nKSC    LIFT OFF\n```", "```rs\nuse std::thread;\nuse std::sync::{Arc, Mutex};\n\n#[derive(Debug)]\nenum Bridge {\n    Empty,\n    Left(u8),\n    Right(u8),\n}\n```", "```rs\nfn main() {\n    let rope = Arc::new(Mutex::new(Bridge::Empty));\n```", "```rs\n    let lhs_rope = Arc::clone(&rope);\n    let lhs = thread::spawn(move || {\n        let rope = lhs_rope;\n        loop {\n            let mut guard = rope.lock().unwrap();\n            match *guard {\n                Bridge::Empty => {\n                    *guard = Bridge::Right(1);\n                }\n                Bridge::Right(i) => {\n                    if i < 5 {\n                        *guard = Bridge::Right(i + 1);\n                    }\n                }\n                Bridge::Left(0) => {\n                    *guard = Bridge::Empty;\n                }\n                Bridge::Left(i) => {\n                    *guard = Bridge::Left(i - 1);\n                }\n            }\n        }\n    });\n```", "```rs\n    let rhs = thread::spawn(move || loop {\n        let mut guard = rope.lock().unwrap();\n        match *guard {\n            Bridge::Empty => {\n                *guard = Bridge::Left(1);\n            }\n            Bridge::Left(i) => {\n                if i < 5 {\n                    *guard = Bridge::Left(i + 1);\n                }\n            }\n            Bridge::Right(0) => {\n                *guard = Bridge::Empty;\n            }\n            Bridge::Right(i) => {\n                *guard = Bridge::Right(i - 1);\n            }\n        }\n    });\n\n    rhs.join().unwrap();\n    lhs.join().unwrap();\n}\n```", "```rs\nuse std::thread;\nuse std::sync::mpsc;\n\nfn writer(chan: mpsc::SyncSender<u32>) -> () {\n    let mut cur: u32 = 0;\n    while let Ok(()) = chan.send(cur) {\n        cur = cur.wrapping_add(1);\n    }\n}\n\nfn reader(read_limit: usize, chan: mpsc::Receiver<u32>) -> () {\n    let mut cur: u32 = 0;\n    while (cur as usize) < read_limit {\n        let num = chan.recv().unwrap();\n        assert_eq!(num, cur);\n        cur = cur.wrapping_add(1);\n    }\n}\n\nfn main() {\n    let capacity = 10;\n    let read_limit = 1_000_000;\n    let (snd, rcv) = mpsc::sync_channel(capacity);\n\n    let reader_jh = thread::spawn(move || {\n        reader(read_limit, rcv);\n    });\n    let _writer_jh = thread::spawn(move || {\n        writer(snd);\n    });\n\n    reader_jh.join().unwrap();\n}\n```", "```rs\nextern crate hopper;\nextern crate tempdir;\n\nuse std::{mem, thread};\n```", "```rs\nfn writer(mut chan: hopper::Sender<u32>) -> () {\n    let mut cur: u32 = 0;\n    while let Ok(()) = chan.send(cur) {\n        cur = cur.wrapping_add(1);\n    }\n}\n```", "```rs\nfn reader(read_limit: usize, \n          mut chan: hopper::Receiver<u32>) -> () {\n    let mut cur: u32 = 0;\n    let mut iter = chan.iter();\n    while (cur as usize) < read_limit {\n        let num = iter.next().unwrap();\n        assert_eq!(num, cur);\n        cur = cur.wrapping_add(1);\n    }\n}\n```", "```rs\npub enum Error {\n    NoSuchDirectory,\n    IoError(Error),\n    NoFlush,\n    Full,\n}\n```", "```rs\nfn main() {\n    let read_limit = 1_000_000;\n    let in_memory_capacity = mem::size_of::<u32>() * 10;\n    let on_disk_capacity = mem::size_of::<u32>() * 100_000;\n\n    let dir = tempdir::TempDir::new(\"queue_root\").unwrap();\n    let (snd, rcv) = hopper::channel_with_explicit_capacity::<u32>(\n        \"example\",\n        dir.path(),\n        in_memory_capacity,\n        on_disk_capacity,\n        1,\n    ).unwrap();\n\n    let reader_jh = thread::spawn(move || {\n        reader(read_limit, rcv);\n    });\n    let _writer_jh = thread::spawn(move || {\n        writer(snd);\n    });\n\n    reader_jh.join().unwrap();\n}\n```", "```rs\nwrite: 99\n\nin-memory-buffer: [90, 91, 92, 93, 94, 95, 96, 97, 98]\ndisk-buffer: [87, 88, 89]\n```", "```rs\nin-memory-buffer: [90, 91, 92, 93, 94, 95, 96, 97, 98]\ndisk-buffer: [87, 88, 89, 99]\n```", "```rs\nin-memory-buffer: [90, 91, 92, 93, 94, 95, 96, 97, 98]\ndisk-buffer: [ [87, 88], [89, 99] ]\n```", "```rs\nuse std::sync::{Condvar, Mutex, MutexGuard};\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::{mem, sync};\n\nunsafe impl<T, S> Send for Queue<T, S> {}\nunsafe impl<T, S> Sync for Queue<T, S> {}\n```", "```rs\npub struct Queue<T, S> {\n    inner: sync::Arc<InnerQueue<T, S>>,\n}\n```", "```rs\nimpl<T, S> Clone for Queue<T, S> {\n    fn clone(&self) -> Queue<T, S> {\n        Queue {\n            inner: sync::Arc::clone(&self.inner),\n        }\n    }\n}\n```", "```rs\nstruct InnerQueue<T, S> {\n    capacity: usize,\n    data: *mut Option<T>,\n    size: AtomicUsize,\n    back_lock: Mutex<BackGuardInner<S>>,\n    front_lock: Mutex<FrontGuardInner>,\n    not_empty: Condvar,\n}\n```", "```rs\n#[derive(Debug, Clone, Copy)]\npub struct FrontGuardInner {\n    offset: isize,\n}\n\n#[derive(Debug)]\npub struct BackGuardInner<S> {\n    offset: isize,\n    pub inner: S,\n}\n```", "```rs\nimpl<T, S> InnerQueue<T, S>\nwhere\n    S: ::std::default::Default,\n{\n    pub fn with_capacity(capacity: usize) -> InnerQueue<T, S> {\n        assert!(capacity > 0);\n        let mut data: Vec<Option<T>> = Vec::with_capacity(capacity);\n        for _ in 0..capacity {\n            data.push(None);\n        }\n        let raw_data = (&mut data).as_mut_ptr();\n        mem::forget(data);\n        InnerQueue {\n            capacity: capacity,\n            data: raw_data,\n            size: AtomicUsize::new(0),\n            back_lock: Mutex::new(BackGuardInner {\n                offset: 0,\n                inner: S::default(),\n            }),\n            front_lock: Mutex::new(FrontGuardInner { offset: 0 }),\n            not_empty: Condvar::new(),\n        }\n    }\n```", "```rs\n    pub fn capacity(&self) -> usize {\n        self.capacity\n    }\n\n    pub fn size(&self) -> usize {\n        self.size.load(Ordering::Relaxed)\n    }\n\n    pub fn lock_back(&self) -> MutexGuard<BackGuardInner<S>> {\n        self.back_lock.lock().expect(\"back lock poisoned\")\n    }\n\n    pub fn lock_front(&self) -> MutexGuard<FrontGuardInner> {\n        self.front_lock.lock().expect(\"front lock poisoned\")\n    }\n```", "```rs\n    pub unsafe fn push_back(\n        &self,\n        elem: T,\n        guard: &mut MutexGuard<BackGuardInner<S>>,\n    ) -> Result<bool, Error<T>> {\n        let mut must_wake_dequeuers = false;\n        if self.size.load(Ordering::Acquire) == self.capacity {\n            return Err(Error::Full(elem));\n        } else {\n            assert!((*self.data.offset((*guard).offset)).is_none());\n            *self.data.offset((*guard).offset) = Some(elem);\n            (*guard).offset += 1;\n            (*guard).offset %= self.capacity as isize;\n            if self.size.fetch_add(1, Ordering::Release) == 0 {\n                must_wake_dequeuers = true;\n            }\n        }\n        Ok(must_wake_dequeuers)\n    }\n```", "```rs\n    pub unsafe fn pop_front(&self) -> T {\n        let mut guard = self.front_lock.lock()\n                            .expect(\"front lock poisoned\");\n        while self.size.load(Ordering::Acquire) == 0 {\n            guard = self.not_empty\n                .wait(guard)\n                .expect(\"oops could not wait pop_front\");\n        }\n        let elem: Option<T> = mem::replace(&mut \n        *self.data.offset((*guard).offset), None);\n        assert!(elem.is_some());\n        *self.data.offset((*guard).offset) = None;\n        (*guard).offset += 1;\n        (*guard).offset %= self.capacity as isize;\n        self.size.fetch_sub(1, Ordering::Release);\n        elem.unwrap()\n    }\n}\n```", "```rs\npub fn push_back(\n    &self,\n    elem: T,\n    mut guard: &mut MutexGuard<BackGuardInner<S>>,\n) -> Result<bool, Error<T>> {\n    unsafe { (*self.inner).push_back(elem, &mut guard) }\n}\n```", "```rs\nfn next_value(&mut self) -> Option<T> {\n    loop {\n        if self.disk_writes_to_read == 0 {\n            match self.mem_buffer.pop_front() {\n                private::Placement::Memory(ev) => {\n                    return Some(ev);\n                }\n                private::Placement::Disk(sz) => {\n                    self.disk_writes_to_read = sz;\n                    continue;\n                }\n            }\n        } else {\n            match self.read_disk_value() {\n                Ok(ev) => return Some(ev),\n                Err(_) => return None,\n            }\n        }\n    }\n}\n```", "```rs\npub enum Placement<T> {\n    Memory(T),\n    Disk(usize),\n}\n```", "```rs\n    fn read_disk_value(&mut self) -> Result<T, super::Error> {\n        loop {\n            match self.fp.read_u32::<BigEndian>() {\n                Ok(payload_size_in_bytes) => {\n                    let mut payload_buf = vec![0; payload_size_in_bytes \n                     as usize];\n                    match self.fp.read_exact(&mut payload_buf[..]) {\n                        Ok(()) => {\n                            let mut dec = \n                            DeflateDecoder::new(&payload_buf[..]);\n                            match deserialize_from(&mut dec) {\n                                Ok(event) => {\n                                    self.disk_writes_to_read -= 1;\n                                    return Ok(event);\n                                }\n                                Err(e) => panic!(\"Failed decoding. \n                                Skipping {:?}\", e),\n                            }\n                        }\n```", "```rs\n        let mut back_guard = self.mem_buffer.lock_back();\n        if (*back_guard).inner.total_disk_writes == 0 {\n            // in-memory mode\n            let placed_event = private::Placement::Memory(event);\n            match self.mem_buffer.push_back(placed_event, &mut \n            back_guard) {\n                Ok(must_wake_receiver) => {\n                    if must_wake_receiver {\n                        let front_guard = self.mem_buffer.lock_front();\n                        self.mem_buffer.notify_not_empty(&front_guard);\n                        drop(front_guard);\n                    }\n                }\n                Err(deque::Error::Full(placed_event)) => {\n                    self.write_to_disk(placed_event.extract().unwrap(), \n                    &mut back_guard)?;\n                    (*back_guard).inner.total_disk_writes += 1;\n                }\n            }\n```", "```rs\npub struct SenderSync {\n    pub sender_fp: Option<BufWriter<fs::File>>,\n    pub bytes_written: usize,\n    pub sender_seq_num: usize,\n    pub total_disk_writes: usize,\n    pub path: PathBuf, // active fp filename\n}\n```", "```rs\n        } else {\n            // disk mode\n            self.write_to_disk(event, &mut back_guard)?;\n            (*back_guard).inner.total_disk_writes += 1;\n            assert!((*back_guard).inner.sender_fp.is_some());\n            if let Some(ref mut fp) = (*back_guard).inner.sender_fp {\n                fp.flush().expect(\"unable to flush\");\n            } else {\n                unreachable!()\n            }\n            if let Ok(must_wake_receiver) = self.mem_buffer.push_back(\n                private::Placement::Disk(\n                    (*back_guard).inner.total_disk_writes\n                ),\n                &mut back_guard,\n            ) {\n                (*back_guard).inner.total_disk_writes = 0;\n                if must_wake_receiver {\n                    let front_guard = self.mem_buffer.lock_front();\n                    self.mem_buffer.notify_not_empty(&front_guard);\n                    drop(front_guard);\n                }\n            }\n        }\n```", "```rs\n    #[test]\n    fn multi_thread_concurrent_snd_and_rcv_round_trip() {\n        fn inner(\n            total_senders: usize,\n            in_memory_bytes: usize,\n            disk_bytes: usize,\n            max_disk_files: usize,\n            vals: Vec<u64>,\n        ) -> TestResult {\n            let sz = mem::size_of::<u64>();\n            if total_senders == 0 || \n               total_senders > 10 || \n               vals.len() == 0 ||\n               (vals.len() < total_senders) || \n               (in_memory_bytes / sz) == 0 ||\n               (disk_bytes / sz) == 0\n            {\n                return TestResult::discard();\n            }\n            TestResult::from_bool(\n              multi_thread_concurrent_snd_and_rcv_round_trip_exp(\n                total_senders,\n                in_memory_bytes,\n                disk_bytes,\n                max_disk_files,\n                vals,\n            ))\n        }\n        QuickCheck::new()\n            .quickcheck(inner as fn(usize, usize, usize, usize, \n             Vec<u64>) -> TestResult);\n    }\n```", "```rs\n    fn multi_thread_concurrent_snd_and_rcv_round_trip_exp(\n        total_senders: usize,\n        in_memory_bytes: usize,\n        disk_bytes: usize,\n        max_disk_files: usize,\n        vals: Vec<u64>,\n    ) -> bool {\n        if let Ok(dir) = tempdir::TempDir::new(\"hopper\") {\n            if let Ok((snd, mut rcv)) = \n              channel_with_explicit_capacity(\n                \"tst\",\n                dir.path(),\n                in_memory_bytes,\n                disk_bytes,\n                max_disk_files,\n            ) {\n```", "```rs\n                let chunk_size = vals.len() / total_senders;\n\n                let mut snd_jh = Vec::new();\n                let snd_vals = vals.clone();\n                for chunk in snd_vals.chunks(chunk_size) {\n                    let mut thr_snd = snd.clone();\n                    let chunk = chunk.to_vec();\n                    snd_jh.push(thread::spawn(move || {\n                        let mut queued = Vec::new();\n                        for mut ev in chunk {\n                            loop {\n                                match thr_snd.send(ev) {\n                                    Err(res) => {\n                                        ev = res.0;\n                                    }\n                                    Ok(()) => {\n                                        break;\n                                    }\n                                }\n                            }\n                            queued.push(ev);\n                        }\n                        let mut attempts = 0;\n                        loop {\n                            if thr_snd.flush().is_ok() {\n                                break;\n                            }\n                            thread::sleep(\n                              ::std::time::Duration::from_millis(100)\n                            );\n                            attempts += 1;\n                            assert!(attempts < 10);\n                        }\n                        queued\n                    }))\n                }\n```", "```rs\n                let expected_total_vals = vals.len();\n                let rcv_jh = thread::spawn(move || {\n                    let mut collected = Vec::new();\n                    let mut rcv_iter = rcv.iter();\n                    while collected.len() < expected_total_vals {\n                        let mut attempts = 0;\n                        loop {\n                            match rcv_iter.next() {\n                                None => {\n                                    attempts += 1;\n                                    assert!(attempts < 10_000);\n                                }\n                                Some(res) => {\n                                    collected.push(res);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    collected\n                });\n\n                let mut snd_vals: Vec<u64> = Vec::new();\n                for jh in snd_jh {\n                    snd_vals.append(&mut jh.join().expect(\"snd join \n                    failed\"));\n                }\n                let mut rcv_vals = rcv_jh.join().expect(\"rcv join \n                failed\");\n\n                rcv_vals.sort();\n                snd_vals.sort();\n\n                assert_eq!(rcv_vals, snd_vals);\n```", "```rs\n    #[test]\n    fn single_sender_single_rcv_round_trip() {\n        // Similar to the multi sender test except now with a single \n        // sender we can guarantee order.\n        fn inner(\n            in_memory_bytes: usize,\n            disk_bytes: usize,\n            max_disk_files: usize,\n            total_vals: usize,\n        ) -> TestResult {\n            let sz = mem::size_of::<u64>();\n            if total_vals == 0 || (in_memory_bytes / sz) == 0 || \n            (disk_bytes / sz) == 0 {\n                return TestResult::discard();\n            }\n            TestResult::from_bool(\n              single_sender_single_rcv_round_trip_exp(\n                in_memory_bytes,\n                disk_bytes,\n                max_disk_files,\n                total_vals,\n            ))\n        }\n        QuickCheck::new().quickcheck(inner as fn(usize, usize, \n                                     usize, usize) -> TestResult);\n    }\n```", "```rs\n    fn single_sender_single_rcv_round_trip_exp(\n        in_memory_bytes: usize,\n        disk_bytes: usize,\n        max_disk_files: usize,\n        total_vals: usize,\n    ) -> bool {\n        if let Ok(dir) = tempdir::TempDir::new(\"hopper\") {\n            if let Ok((mut snd, mut rcv)) = \n            channel_with_explicit_capacity(\n                \"tst\",\n                dir.path(),\n                in_memory_bytes,\n                disk_bytes,\n                max_disk_files,\n            ) {\n                let builder = thread::Builder::new();\n                if let Ok(snd_jh) = builder.spawn(move || {\n                    for i in 0..total_vals {\n                        loop {\n                            if snd.send(i).is_ok() {\n                                break;\n                            }\n                        }\n                    }\n                    let mut attempts = 0;\n                    loop {\n                        if snd.flush().is_ok() {\n                            break;\n                        }\n                        thread::sleep(\n                          ::std::time::Duration::from_millis(100)\n                        );\n                        attempts += 1;\n                        assert!(attempts < 10);\n                    }\n                }) {\n                    let builder = thread::Builder::new();\n                    if let Ok(rcv_jh) = builder.spawn(move || {\n                        let mut rcv_iter = rcv.iter();\n                        let mut cur = 0;\n                        while cur != total_vals {\n                            let mut attempts = 0;\n                            loop {\n                                if let Some(rcvd) = rcv_iter.next() {\n                                    debug_assert_eq!(\n                                        cur, rcvd,\n                                    \"FAILED TO GET ALL IN ORDER: {:?}\",\n                                        rcvd,\n                                    );\n                                    cur += 1;\n                                    break;\n                                } else {\n                                    attempts += 1;\n                                    assert!(attempts < 10_000);\n                                }\n                            }\n                        }\n                    }) {\n                        snd_jh.join().expect(\"snd join failed\");\n                        rcv_jh.join().expect(\"rcv join failed\");\n                    }\n                }\n            }\n        }\n        true\n    }\n```", "```rs\n    #[test]\n    fn explicit_single_sender_single_rcv_round_trip() {\n        let mut loops = 0;\n        loop {\n         assert!(single_sender_single_rcv_round_trip_exp(8, 8, 5, 10));\n            loops += 1;\n            if loops > 2_500 {\n                break;\n            }\n            thread::sleep(::std::time::Duration::from_millis(1));\n        }\n    }\n```", "```rs\nextern crate hopper;\nextern crate rand;\n#[macro_use]\nextern crate serde_derive;\nextern crate bincode;\nextern crate tempdir;\n\nuse bincode::{deserialize_from, Bounded};\nuse self::hopper::channel_with_explicit_capacity;\nuse std::{io, process};\nuse rand::{Rng, SeedableRng, XorShiftRng};\n```", "```rs\n#[derive(Debug, PartialEq, Deserialize)]\nstruct Input { // 22 bytes\n    seed_a: u32, // 4\n    seed_b: u32, // 4\n    seed_c: u32, // 4\n    seed_d: u32, // 4\n    max_in_memory_bytes: u32, // 4\n    max_disk_bytes: u16, // 2\n}\n```", "```rs\nfn main() {\n    let stdin = io::stdin();\n    let mut stdin = stdin.lock();\n    if let Ok(input) = deserialize_from(&mut stdin, Bounded(22)) {\n        let mut input: Input = input;\n        let mut rng: XorShiftRng =\n            SeedableRng::from_seed([input.seed_a, input.seed_b, \n                                    input.seed_c, input.seed_d]);\n\n        input.max_in_memory_bytes = \n          if input.max_in_memory_bytes > 2 << 25 {\n            2 << 25\n        } else {\n            input.max_in_memory_bytes\n        };\n\n        // We need to be absolutely sure we don't run into another \n        // running process. Which, this isn't a guarantee but \n        // it's _pretty_ unlikely to hit jackpot.\n        let prefix = format!(\n            \"hopper-{}-{}-{}\",\n            rng.gen::<u64>(),\n            rng.gen::<u64>(),\n            rng.gen::<u64>()\n        );\n```", "```rs\n        if let Ok(dir) = tempdir::TempDir::new(&prefix) {\n            if let Ok((mut snd, mut rcv)) = \n            channel_with_explicit_capacity(\n                \"afl\",\n                dir.path(),\n                input.max_in_memory_bytes as usize,\n                input.max_disk_bytes as usize,\n            ) {\n```", "```rs\n                let mut writes = 0;\n                let mut rcv_iter = rcv.iter();\n                loop {\n                    match rng.gen_range(0, 102) {\n                        0...50 => {\n                            if writes != 0 {\n                                let _ = rcv_iter.next();\n                            }\n                        }\n                        50...100 => {\n                            snd.send(rng.gen::<u64>());\n                            writes += 1;\n                        }\n                        _ => {\n                            process::exit(0);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```", "```rs\n#[macro_use]\nextern crate criterion;\nextern crate hopper;\nextern crate tempdir;\n\nuse std::{mem, thread};\nuse criterion::{Bencher, Criterion};\nuse hopper::channel_with_explicit_capacity;\nuse std::sync::mpsc::channel;\n```", "```rs\nfn mpsc_tst(input: MpscInput) -> () {\n    let (tx, rx) = channel();\n\n    let chunk_size = input.ith / input.total_senders;\n\n    let mut snd_jh = Vec::new();\n    for _ in 0..input.total_senders {\n        let tx = tx.clone();\n        let builder = thread::Builder::new();\n        if let Ok(handler) = builder.spawn(move || {\n            for i in 0..chunk_size {\n                tx.send(i).unwrap();\n            }\n        }) {\n            snd_jh.push(handler);\n        }\n    }\n\n    let total_senders = snd_jh.len();\n    let builder = thread::Builder::new();\n    match builder.spawn(move || {\n        let mut collected = 0;\n        while collected < (chunk_size * total_senders) {\n            let _ = rx.recv().unwrap();\n            collected += 1;\n        }\n    }) {\n        Ok(rcv_jh) => {\n            for jh in snd_jh {\n                jh.join().expect(\"snd join failed\");\n            }\n            rcv_jh.join().expect(\"rcv join failed\");\n        }\n        _ => {\n            return;\n        }\n    }\n}\n```", "```rs\n#[derive(Debug, Clone, Copy)]\nstruct MpscInput {\n    total_senders: usize,\n    ith: usize,\n}\n```", "```rs\nfn hopper_tst(input: HopperInput) -> () {\n    let sz = mem::size_of::<u64>();\n    let in_memory_bytes = sz * input.in_memory_total;\n    let max_disk_bytes = sz * input.max_disk_total;\n    if let Ok(dir) = tempdir::TempDir::new(\"hopper\") {\n        if let Ok((snd, mut rcv)) = channel_with_explicit_capacity(\n            \"tst\",\n            dir.path(),\n            in_memory_bytes,\n            max_disk_bytes,\n            usize::max_value(),\n        ) {\n            let chunk_size = input.ith / input.total_senders;\n\n            let mut snd_jh = Vec::new();\n            for _ in 0..input.total_senders {\n                let mut thr_snd = snd.clone();\n                let builder = thread::Builder::new();\n                if let Ok(handler) = builder.spawn(move || {\n                    for i in 0..chunk_size {\n                        let _ = thr_snd.send(i);\n                    }\n                }) {\n                    snd_jh.push(handler);\n                }\n            }\n\n            let total_senders = snd_jh.len();\n            let builder = thread::Builder::new();\n            match builder.spawn(move || {\n                let mut collected = 0;\n                let mut rcv_iter = rcv.iter();\n                while collected < (chunk_size * total_senders) {\n                    if rcv_iter.next().is_some() {\n                        collected += 1;\n                    }\n                }\n            }) {\n                Ok(rcv_jh) => {\n                    for jh in snd_jh {\n                        jh.join().expect(\"snd join failed\");\n                    }\n                    rcv_jh.join().expect(\"rcv join failed\");\n                }\n                _ => {\n                    return;\n                }\n            }\n        }\n    }\n}\n```", "```rs\n#[derive(Debug, Clone, Copy)]\nstruct HopperInput {\n    in_memory_total: usize,\n    max_disk_total: usize,\n    total_senders: usize,\n    ith: usize,\n}\n```", "```rs\nfn mpsc_benchmark(c: &mut Criterion) {\n    c.bench_function_over_inputs(\n        \"mpsc_tst\",\n        |b: &mut Bencher, input: &MpscInput| b.iter(|| \n         mpsc_tst(*input)),\n        vec![\n            MpscInput {\n                total_senders: 2 << 1,\n                ith: 2 << 12,\n            },\n        ],\n    );\n}\n```", "```rs\nfn hopper_benchmark(c: &mut Criterion) {\n    c.bench_function_over_inputs(\n        \"hopper_tst\",\n        |b: &mut Bencher, input: &HopperInput| b.iter(|| \n         hopper_tst(*input)),\n        vec![\n            // all in-memory\n            HopperInput {\n                in_memory_total: 2 << 11,\n                max_disk_total: 2 << 14,\n                total_senders: 2 << 1,\n                ith: 2 << 11,\n            },\n            // swap to disk\n            HopperInput {\n                in_memory_total: 2 << 11,\n                max_disk_total: 2 << 14,\n                total_senders: 2 << 1,\n                ith: 2 << 12,\n            },\n        ],\n    );\n}\n```", "```rs\ncriterion_group!{\n    name = benches;\n    config = Criterion::default().without_plots();\n    targets = hopper_benchmark, mpsc_benchmark\n}\ncriterion_main!(benches);\n```"]