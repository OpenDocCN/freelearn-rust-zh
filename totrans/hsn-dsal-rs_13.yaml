- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are traits and how are they different from interfaces?**'
  prefs: []
  type: TYPE_NORMAL
- en: Traits are pieces of functionality shared across components. They can contain
    code as well as associated types, and can be implemented for any type and generics
    independently. Interfaces, on the other hand, describe the public methods a class
    provides, without an implementation and typically with inheritance. Rust only
    has traits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why doesn''t Rust have a garbage collector?**'
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection is required to free up unused heap memory that is generated
    from a running the program. Rust avoids this by providing a static code analysis
    at compile-time that forces the user to think of variable lifetimes. These lifetimes
    are very strictly defined and require a lifetime scope to own or borrow memory
    so that the compiler knows when it's not being used without an explicit statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Name three examples of how lifetimes are created in Rust (explicitly and**'
  prefs: []
  type: TYPE_NORMAL
- en: '**implicitly)!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any three that you can come up with are great, but here are mine: Functions,
    scopes (simply create one using `{}`), and closures (lambda functions).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is immutability for variables important?**'
  prefs: []
  type: TYPE_NORMAL
- en: It guarantees that only read operations take place, thereby avoiding any side
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: '**What does the Sync marker trait do?**'
  prefs: []
  type: TYPE_NORMAL
- en: It marks a structure as safe to access from multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: '**Where can you go to participate in the Rust community?**'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://github.com/rust-lang](https://github.com/rust-lang) (opening
    issues, submitting code, discussions, and so on) or [www.rust-lang.org/community](https://www.rust-lang.org/community),
    where all the current community resources (such as the forum and chats) are kept.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are RFCs preferred over PRs?**'
  prefs: []
  type: TYPE_NORMAL
- en: To contribute changes to the Rust programming language, `cargo`, or `crates.io`,
    the traditional fork-then-change-and-PR (pull request) won't work (especially
    if there are major changes). RFCs are the formal process required for substantial
    changes to either of the three projects and allow the wider community to discuss
    and evaluate the proposed changes, as well as contribute to them. This is the
    Rust community's effort to effectively govern something as fundamental as a programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What does cargo do?**'
  prefs: []
  type: TYPE_NORMAL
- en: Read and write access to repositories, run tests, dependency management (download,
    update, and managing the dependency tree), executing the build process, and providing
    a central interface for additional tooling.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does cargo provide linting support?**'
  prefs: []
  type: TYPE_NORMAL
- en: '`cargo` itself doesn''t, but there are additional tools, such as `clippy` ([https://github.com/rust-lang/rust-clippy](https://github.com/rust-lang/rust-clippy)),
    that work seamlessly with `cargo`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**In which cases is the Cargo.lock file important to publish?**'
  prefs: []
  type: TYPE_NORMAL
- en: For libraries. The file is used by cargo to determine the exact versions of
    the dependency tree. As a consequence, there should not be any version issues
    caused by unintentionally updated dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the requirements to publish to crates.io?**'
  prefs: []
  type: TYPE_NORMAL
- en: Passing tests, no uncommitted files in the repository, a valid account, and
    an available spot on `crates.io`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is Wasm and why should you care?**'
  prefs: []
  type: TYPE_NORMAL
- en: Wasm is a compilation target that can be executed in traditional JavaScript
    environments, such as browsers or the Node runtime. This skips the compilation
    steps required for JavaScript as well as its garbage collection, so Wasm binaries
    are better suited for (near-) real-time applications with a browser UI component.
    They can be simply run in the JavaScript world.
  prefs: []
  type: TYPE_NORMAL
- en: '**How are tests organized in a Rust project?**'
  prefs: []
  type: TYPE_NORMAL
- en: Tests can either be added to each file in a module, annotated by `#[tests]`
    and `#[test]`, as well as `#[bench]`. These can also be placed into their own
    file structure under `test/` in the component's directory. Additionally, Rust
    supports doctests, which are executed when the docstring (`///`) has an example
    section that contains code.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How are Sized types different from other types?**'
  prefs: []
  type: TYPE_NORMAL
- en: Sized means that the size of a type instance is known at runtime, so it doesn't
    contain a growing data type. For example, `str` is typically not a sized type – `String`
    is.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does Clone differ from Copy?**'
  prefs: []
  type: TYPE_NORMAL
- en: Clone is an explicit call to the `clone()` function; copy happens implicitly,
    for example, at assignments. Since Clone is explicitly called, it usually does
    a deep copy on the underlying data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the main drawbacks of immutable data structures?**'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures can have worse absolute performances since they can't
    use the optimizations that regular data structures provide. Additionally, updates
    on the data that's contained is impossible, making it a very inefficient choice
    for constantly changing data.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can applications benefit from immutable data structures?**'
  prefs: []
  type: TYPE_NORMAL
- en: They implicitly keep track of changes and work well across threads without side
    effects or the need for locking.
  prefs: []
  type: TYPE_NORMAL
- en: '**Think about an immutable list that you want to work on—how would you ****distribute
    it across multiple threads?**'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the task, it can be split into *n* chunks, where *n* is the number
    of threads. However, this requires you to create *n* copies of the list—or at
    least a move per each. Alternatively, the list can be made accessible across threads,
    providing only the indices to represent the chunks to work on.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why is a linked list tricky to implement in Rust?**'
  prefs: []
  type: TYPE_NORMAL
- en: Rust's ownership principle makes it hard to implement non-hierarchical structures,
    such as the doubly-linked list. There, it's unclear which node owns which area
    of the memory, since both neighbors hold a reference that can't be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does Rust''s standard library, LinkedList<T>, work?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a doubly-linked list: individual nodes are interlinked, just like the
    implementation in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between a doubly-linked list and a skip list?**'
  prefs: []
  type: TYPE_NORMAL
- en: A skip list has multiple levels where nodes are linked together to achieve a
    tree-like search performance. Therefore, the skip list has to be ordered and stores
    multiple pointers to successors and predecessors. The doubly-linked list has only
    two links (forward and backward), doesn't need to be sorted, and achieves linear
    search performance at best.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does a dynamic array outperform a skip list for element access?**'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, if the skip list doesn't use a dynamic array as a base!
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is a dynamic array a great choice for CPU caching?**'
  prefs: []
  type: TYPE_NORMAL
- en: The data is stored in a large continuous portion of the memory, with the elements
    stored one after the other. Caching always builds on blocks of memory, which is
    why caching several elements that are likely processed after each other makes
    the dynamic array well-suited for that.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is another growth strategy for dynamic arrays?**'
  prefs: []
  type: TYPE_NORMAL
- en: Memory can be doubled, increased by a certain amount each time, or logarithmically
    so that it grows fast in the beginning and slows down later on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rust takes arrays seriously, so what does the dynamic array use internally?**'
  prefs: []
  type: TYPE_NORMAL
- en: It uses a boxed slice.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How does a binary search tree skip several nodes when searching?**'
  prefs: []
  type: TYPE_NORMAL
- en: By following one branch, it skips one subtree every time the decision for one
    branch is made. A subtree can be anything from a single node to all nodes except
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are self-balancing trees?**'
  prefs: []
  type: TYPE_NORMAL
- en: Trees that use some kind of logic to (roughly) equalize the number of nodes
    in each subtree. This ensures that all tree algorithms work at the best possible
    efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is balance in a tree important?**'
  prefs: []
  type: TYPE_NORMAL
- en: If a tree is skewed, any algorithm operating on it will encounter an uneven
    amount of work depending on the subtree it works on. The mismatch is the assumption
    that every branch of the tree leads to the same amount of work (for example, the
    same number of comparisons to make), which is what makes the tree data structure
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is a heap a binary tree?**'
  prefs: []
  type: TYPE_NORMAL
- en: Yes. Each node has two children.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are good use cases for tries?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are mine: A trie set is a very efficient data structure for guaranteeing
    uniqueness, there are sequence prediction methods based on tries, and they can
    do a lossless data compression.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a B-Tree?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A B-Tree is a tree with a defined level that relates to the number of children
    in each node. Thus, it is a self-balancing generalization of all trees: a level
    2 B-Tree is akin to a binary tree, but more children will make the data structure
    more efficient and avoid unnecessary heights.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the fundamental components of a graph?**'
  prefs: []
  type: TYPE_NORMAL
- en: Graphs are nodes that are connected with edges. These nodes typically have a
    value; the value on the edges is referred to as weights. In a general graph, there
    are no directions on the edges, but further constraints can make it directed,
    acyclic, or otherwise limited. Graphs are the superstructure of all lists and
    trees.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What makes a good hash function?**'
  prefs: []
  type: TYPE_NORMAL
- en: It depends on the use case. Cryptography should minimize collisions, message
    digests should maximize hash differences on minor input differences, and bloom
    filters should do the reverse.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you estimate the suitability of a hash function for a particular
    task?**'
  prefs: []
  type: TYPE_NORMAL
- en: By using plots and tests to get a sense of how the output hashes are distributed
    and whether that's what you're looking for. Histograms and scatter plots work
    well to see the distribution of values. Also, search the internet for potential
    breaches or weaknesses and the original paper.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is a checksum hash useful in other ways?**'
  prefs: []
  type: TYPE_NORMAL
- en: They can also be useful to determine whether two texts or files are equal, which
    can be used for finding matches quickly or to check whether the content is the
    content that was transferred or whether the content has been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are two ways to implement a map?**'
  prefs: []
  type: TYPE_NORMAL
- en: Using trees or using hashing.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are buckets?**'
  prefs: []
  type: TYPE_NORMAL
- en: Buckets are the hash values that are mapped onto the underlying data structure.
    Hashes might output `u64`, but `Vec<T>` only has a length of 100\. Therefore,
    multiple hashes share an index in `Vec<T>`, which is called a bucket.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can a set replace a list? **'
  prefs: []
  type: TYPE_NORMAL
- en: Only if uniqueness is a required constraint for the contents.
  prefs: []
  type: TYPE_NORMAL
- en: '**What makes a set useful?**'
  prefs: []
  type: TYPE_NORMAL
- en: Quick and specialized set operations, such as union, intersect, difference,
    and fast "contains" lookups, as well as the ability to guarantee uniqueness with
    better efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Which std::collections data structure is not discussed here?**'
  prefs: []
  type: TYPE_NORMAL
- en: '`BinaryHeap` ([https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html](https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**How does Vec<T> or VecDeque<T> grow, as of 2018?**'
  prefs: []
  type: TYPE_NORMAL
- en: They double (or more) their size when more space is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is LinkedList<T> a good default data structure?**'
  prefs: []
  type: TYPE_NORMAL
- en: No. It doesn't provide index access and is generally slower than `Vec<T>`, thanks
    to the internal memory structure, but provides the same basic features.
  prefs: []
  type: TYPE_NORMAL
- en: '**What hashing implementation does the 2018 HashMap<T> use by default?**'
  prefs: []
  type: TYPE_NORMAL
- en: SipHashing. There are others that are on their way into the standard library,
    such as the `hashbrown` crate ([https://github.com/Amanieu/hashbrown](https://github.com/Amanieu/hashbrown)).
  prefs: []
  type: TYPE_NORMAL
- en: '**What are three benefits of BTreeMap<T> over HashMap<T>?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use any three, but here are some suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: Ordered keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower computational intensity (no hashing required)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No hash function required—good performance regardless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I****s the internal tree of BTreeMap<T> wider or higher?**'
  prefs: []
  type: TYPE_NORMAL
- en: Wider, thanks to a larger number of children (up to *2 * level - 1*) for efficient
    CPU caching.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why estimate runtime complexity over something such as the number of statements?**'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime complexity is more about the projected growth alongside the main input
    parameter. In a way, it *is* counting the number of statements and you would likely
    arrive at the same conclusion. The statements that are being counted are the subset
    that matters most.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does runtime complexity relate to math functions?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In two ways: mathematical functions can be described the same way as functions
    in programming, since they rest on the same fundamental construct; and math functions
    are used to express the runtime complexity itself, in particular the logarithmic
    and exponential functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is the complexity class that is typically provided the best or worst case?**'
  prefs: []
  type: TYPE_NORMAL
- en: The worst case, since this will be the slowest/most inefficient case.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are loops important in estimating complexity?**'
  prefs: []
  type: TYPE_NORMAL
- en: Loops are great constructs that repeatedly execute statements and, depending
    on the growth parameter, will drive the function's runtime complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is O(n log(n)) a better or worse runtime complexity than O(log(n))?**'
  prefs: []
  type: TYPE_NORMAL
- en: '*O(log(n))* is clearly a better runtime complexity. Try replacing the *n* with
    three numbers of your choice and calculate *log(n)* versus *n * log(n)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What are some common known complexity classes?**'
  prefs: []
  type: TYPE_NORMAL
- en: '*O(n)*, *O(log(n)*, *O(n²)*, and *O(2^n)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is information retrieval?**'
  prefs: []
  type: TYPE_NORMAL
- en: All disciplines surrounding storage, search, ranking, tokenization, analysis,
    and a general understanding of an information structure. It's everything that
    a good search engine does well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do modern search engines and databases use simple search algorithms?**'
  prefs: []
  type: TYPE_NORMAL
- en: Yes. Regardless of the abstraction on top of the search index, the storing of
    tokens is often done in a linear, append-only fashion that allows for efficient
    search (binary search) on these segments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why does the linear search have O(n) runtime complexity?**'
  prefs: []
  type: TYPE_NORMAL
- en: In case an element doesn't exist in the sequence, it has to walk over all *n*
    items to be sure.
  prefs: []
  type: TYPE_NORMAL
- en: '**What does jump search do better than linear search?**'
  prefs: []
  type: TYPE_NORMAL
- en: It skips parts of the list since, in an ordered list, certain locations can
    be ruled out based on the sorting. Therefore, it significantly reduces the number
    of elements that are searched for linearly.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is binary search and why is it comparable to a tree?**'
  prefs: []
  type: TYPE_NORMAL
- en: Binary search splits the input sequence in half and only continues on the part
    that has to contain the element. Drawing these parts visually (including those
    that have been skipped) looks just like a binary tree, which is why the two parts
    are effectively branches.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why is sorting an important aspect of programming?**'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a predictable order so that algorithms can make assumptions based
    on the content (for example, for search) will enable it to perform much better.
    Another important aspect is user experience in user interfaces, or to establish
    a semantic link between data points (for example, a time series can now have trends).
  prefs: []
  type: TYPE_NORMAL
- en: '**What makes values bubble up in bubble sort?**'
  prefs: []
  type: TYPE_NORMAL
- en: By repeatedly swapping a pair of elements when going through the sequence, elements
    that belong on the opposite end (or close to it) will have to swap places with
    every other element on the way. Therefore, the large number "bubbles up."
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is shell sort useful?**'
  prefs: []
  type: TYPE_NORMAL
- en: It achieves solid sorting performances, yet it's not as complex as merge sort
    and uses less computational resources. This makes it great in scenarios where
    hardware can be bottlenecked (embedded devices) or other sorting approaches aren't
    available (for example, if the standard library is not supported).
  prefs: []
  type: TYPE_NORMAL
- en: '**Can heap sort outperform bubble sort in its best case?**'
  prefs: []
  type: TYPE_NORMAL
- en: No. Bubble sort's best case is simply iterating the list – *O(n)*. Heap sort,
    on the other hand, always has to build a heap, regardless of the sequence being
    already sorted or not – *O(n log n)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**What do merge sort and quicksort have in common?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The divide-and-conquer approach: both split the sequence into smaller pieces
    so that they can work on those separately.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What are hybrid sorting algorithms?**'
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid sorting algorithms use the strengths of at least two different approaches.
    Timsort, for example, uses insertion sort for smaller sequences (for example,
    under 20 items) but merge sort for larger ones.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is the difference between PRNGs and RNGs?**'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-random number generators (PRNGs) use a process to generate a close-to-random
    sequence of numbers that are as statistically independent as possible. Random
    number generators (RNGs) try to use true randomness (for example, phenomena from
    the physical world that cannot be predicted) to generate random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**What crate provides random number generators in Rust?**'
  prefs: []
  type: TYPE_NORMAL
- en: '`rand` is the most important one.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How can backtracking solve combinatorial problems?**'
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking recursively tries out possible combinations and evaluates their
    validity as soon as possible. This allows you to backtrack the bad solutions and
    save good solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is dynamic programming?**'
  prefs: []
  type: TYPE_NORMAL
- en: A programming technique that saves and uses common intermediate solutions to
    improve the algorithm's runtime complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**How are metaheuristics a problem-agnostic approach to solving hard problems?**'
  prefs: []
  type: TYPE_NORMAL
- en: Metaheuristics use generally applicable strategies to find the best solution.
    These strategies can be inspired by nature (natural selection, animal behavior,
    physical processes) and repeatedly generate and evaluate parameters to improve
    the next solution. If the generation and validation of a problem is supplied by
    the user, the approach can be problem-agnostic and since the strategies take care
    of converging toward the best solution, they can provide a best guess in predictable
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Where is Rust''s implementation of generic algorithms on collections?**'
  prefs: []
  type: TYPE_NORMAL
- en: The slice primitive type.
  prefs: []
  type: TYPE_NORMAL
- en: '**When is linear search better than binary search?**'
  prefs: []
  type: TYPE_NORMAL
- en: If the sequence is short and not sorted—the time it takes to sort it would be
    longer than a simple linear search.
  prefs: []
  type: TYPE_NORMAL
- en: '***Potential job interview question:* What are stable and unstable sorting
    algorithms?**'
  prefs: []
  type: TYPE_NORMAL
- en: Stable sorting algorithms maintain a relative order between equal elements,
    while unstable sorting algorithms don't. This means that if there are sequences
    of the same number, the entire block will show up in the sorted collection exactly
    in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a bad behavior of Quicksort that pattern-defeating Quicksort mitigates?**'
  prefs: []
  type: TYPE_NORMAL
- en: The choice of bad pivots is the most important problem that is mitigated. This
    is done by employing strategies to improve the selection or, if all else fails, use
    heap sort to achieve at least a *O(n log n)* runtime complexity (instead of quicksort's
    *O(n²)*).
  prefs: []
  type: TYPE_NORMAL
