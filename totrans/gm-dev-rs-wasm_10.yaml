- en: '*Chapter 8*: Adding a UI'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：添加UI'
- en: It may appear that we've developed everything we need for a video game, and
    to some extent, we have, except for that annoyance where we need to hit refresh
    every time little **Red Hat Boy** (**RHB**) hits a rock. A real game has buttons
    for a "new game" or "high scores", and in this chapter, we'll be adding that UI.
    To do so may seem trivial, but event-driven UIs that you might be familiar with
    from web development are an odd fit with our game loop. To add a simple button,
    we'll need to make significant changes to our application and even write a little
    HTML.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来我们已经为视频游戏开发了一切所需，从某种程度上说，我们确实如此，除了每次小**红帽男孩**（**RHB**）撞到岩石时需要刷新页面的那个烦恼。一个真正的游戏有“新游戏”或“最高分”的按钮，在本章中，我们将添加这个UI。这样做可能看起来微不足道，但你可能从网络开发中熟悉的基于事件的UI与我们的游戏循环并不匹配。为了添加一个简单的按钮，我们需要对我们的应用程序进行重大更改，甚至需要写一点HTML。
- en: 'In this chapter, you''ll do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将执行以下操作：
- en: Design a new game button
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个新的游戏按钮
- en: Show the button on game over
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏结束时显示按钮
- en: Start a new game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: At the end of the chapter, you'll have the framework in place for a more full-featured
    UI and the skills to make it work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将拥有一个更完整功能的UI框架和使其工作的技能。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You'll need a few more assets, this time from the `ui` directory in the `assets`
    download at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
    The font is Kenny Future Narrow from [https://www.kenney.nl](https://www.kenney.nl).
    The button is from [https://www.gameart2d.com/](https://www.gameart2d.com/). Both
    are CC0-licensed. As before, the final code for this chapter is available on the
    corresponding branch at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一些额外的资源，这次来自[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)中的`assets`下载的`ui`目录。字体是来自[https://www.kenney.nl](https://www.kenney.nl)的Kenny
    Future Narrow。按钮来自[https://www.gameart2d.com/](https://www.gameart2d.com/)。两者都是CC0许可。和之前一样，本章的最终代码可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8)的相应分支上找到。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3DrEeNO](https://bit.ly/3DrEeNO)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3DrEeNO](https://bit.ly/3DrEeNO)
- en: Design a new game button
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个新的游戏按钮
- en: When RHB crashes into a rock, he falls over and… well, let's say he takes a
    nap. Unfortunately, at that point, the player has to refresh the page to start
    a new game. In most games, we'd see a series of buttons for a new game and high
    scores. For now, we'll just put in a new game button that will restart from the
    beginning. This might seem like a simple task, but in fact, we'll have quite a
    bit to do.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当RHB撞到岩石上时，他会倒下，嗯，让我们说他要小睡一会儿。不幸的是，到那时，玩家必须刷新页面才能开始新游戏。在大多数游戏中，我们会看到一系列用于新游戏和最高分的按钮。目前，我们只将添加一个新游戏按钮，它会从头开始重新开始。这看起来可能是一个简单的任务，但实际上，我们还有很多事情要做。
- en: First, we need to decide how we want to implement the button. We really have
    two choices. We can create a button in the engine, which would be a sprite that
    is rendered to the canvas, the same as everything else, or we can use an HTML
    button and position it over the canvas. The first option will look right and won't
    require any traditional web programming, but it will also require us to detect
    mouse clicks and handle a button-click animation. In other words, we'd have to
    implement a button. That's more than we want to implement to get our game working,
    so we're going to use a traditional HTML button and make it *look* like it's a
    game element.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要决定我们想要如何实现按钮。我们实际上有两个选择。我们可以在引擎中创建一个按钮，这将是一个渲染到画布上的精灵，就像其他所有东西一样，或者我们可以使用一个HTML按钮并将其定位在画布上。第一个选项看起来会正确，并且不需要任何传统的网络编程，但它也将要求我们检测鼠标点击和处理按钮点击动画。换句话说，我们可能需要实现一个按钮。这比我们想要实现来让游戏工作要多，所以我们打算使用传统的HTML按钮并使其*看起来*像是一个游戏元素。
- en: So, we're going to write some HTML and CSS, which we can use to make the button
    look like it's a part of the game engine. Then, we'll add the button to the screen
    with Rust and handle the click event. That will be the tough part.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将编写一些HTML和CSS，这样我们就可以让按钮看起来像是游戏引擎的一部分。然后，我们将使用Rust将按钮添加到屏幕上并处理点击事件。这将是难点部分。
- en: Preparing a UI
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备用户界面
- en: Conceptually, our UI will work like a HUD in a FPS or where a button is superimposed
    over the front of a game itself. Imagine that there is a perfectly clear pane
    of glass on top of the game, and the button is a sticker that's stuck to it. This
    means, in the context of a web page, that we need a div that is the same size
    and in the same place as the canvas.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，我们的用户界面将像FPS中的HUD或按钮叠加在游戏本身前面时的工作方式。想象一下，在游戏上方有一个完全透明的玻璃板，按钮就像是一张贴在玻璃上的贴纸。这意味着，在网页的上下文中，我们需要一个与canvas大小和位置相同的div。
- en: Tip
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: This isn't a book on HTML or CSS, so I'm not going to spend much time covering
    it, other than the canvas we've been using throughout. If web development isn't
    your forte, don't worry – a quick scan of [https://learnxinyminutes.com/docs/html/](https://learnxinyminutes.com/docs/html/)
    will cover more than enough. We'll also be using a little bit of CSS in this section,
    and you can get a similar cheat sheet for that syntax at [https://learnxinyminutes.com/docs/css/](https://learnxinyminutes.com/docs/css/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于HTML或CSS的书，所以我不会花太多时间来介绍它，除了我们一直在使用的canvas。如果你不是网页开发的专家，不用担心——快速浏览[https://learnxinyminutes.com/docs/html/](https://learnxinyminutes.com/docs/html/)就能了解足够多的内容。我们也会在这一节中使用一点CSS，你可以在[https://learnxinyminutes.com/docs/css/](https://learnxinyminutes.com/docs/css/)找到类似的速查表。
- en: 'We can start rather quickly by updating `index.html` to have the required div,
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速更新`index.html`以包含所需的div，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that the `ui` div is `position: absolute` so that it doesn''t "push" the
    `canvas` element below it. You can see how this will work by putting a standard
    HTML button in the `div` element, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，`ui` div是`position: absolute`，这样它就不会“推”下面的`canvas`元素。你可以通过将一个标准的HTML按钮放入`div`元素中来看如何实现，如下所示：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will produce a screen that looks like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个看起来如下所示的屏幕：
- en: '![Figure 8.1 – A New Game button!](img/Figure_8.01_B17151.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 新游戏按钮！](img/Figure_8.01_B17151.jpg)'
- en: Figure 8.1 – A New Game button!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 新游戏按钮！
- en: 'It won''t respond very well if you completely shrink the screen horizontally,
    but the game won''t work in that situation, so it should be fine. Now that we
    have a button, we''ll need to make it look like a game element, and for that,
    we''ll need styling. Go ahead and create a file named `styles.css` in the `static`
    directory, and add a link to it in `index.html`, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全水平缩小屏幕，它可能不会响应得很好，但游戏在那个情况下是无法工作的，所以应该没问题。现在我们有了按钮，我们需要让它看起来像是一个游戏元素，为此我们需要添加样式。请创建一个名为`styles.css`的文件在`static`目录下，并在`index.html`中添加对其的链接，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Of course, a link to an empty file doesn''t do much for us. To prove the link
    is working, go ahead and change the `index.html` file slightly, removing the inline
    style on the `ui` div so that it looks like `<div id="ui">`. This will cause the
    button to push the canvas element down, and your game will likely be slightly
    off:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个指向空文件的链接对我们来说并没有什么帮助。为了证明链接是有效的，请修改`index.html`文件，移除`ui` div上的内联样式，使其看起来像`<div
    id="ui">`。这将导致按钮将canvas元素向下推，你的游戏可能会稍微偏离：
- en: '![Figure 8.2 – New Game on top](img/Figure_8.02_B17151.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 新游戏在顶部](img/Figure_8.02_B17151.jpg)'
- en: Figure 8.2 – New Game on top
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 新游戏在顶部
- en: 'Now, in the CSS file, you''ll want to add a style for that div. It''s not really
    important that this style isn''t an inline one, except that this handily checks
    that our CSS file is being loaded. In the CSS file, insert the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在CSS文件中，你将为该div添加一个样式。这个样式不是内联的并不是很重要，除了它能方便地检查我们的CSS文件是否被加载。在CSS文件中，插入以下内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a CSS selector for any elements with the `ui` ID and sets their position
    to `absolute`. If your CSS file is being loaded, then the new game button should
    be over the top of the canvas again. Later, we'll programmatically add that button
    in our game code, but for now, we just want it to show up and look right. We'll
    want to give it a font that looks like a video game, and a background too. Let's
    start with the font. In your assets, you'll see there is a directory called `ui`,
    which contains a file named `kenney_future_narrow-webfont.woff2`. **WOFF** stands
    for **Web Open Font Format** and is a font format that will work in every modern
    browser.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个CSS选择器，用于任何具有`ui` ID的元素，并将它们的定位设置为`absolute`。如果你的CSS文件正在加载，那么新游戏按钮应该再次位于画布的顶部。稍后，我们将在游戏代码中程序化地添加该按钮，但现在我们只想让它显示出来，看起来正确。我们希望给它一个看起来像视频游戏的字体，以及背景。让我们从字体开始。在你的资源中，你会看到一个名为`ui`的目录，其中包含一个名为`kenney_future_narrow-webfont.woff2`的文件。**WOFF**代表**Web开放字体格式**，这是一种在所有现代浏览器中都能工作的字体格式。
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Whenever you''re unsure whether a feature will work with a browser, and sometimes
    when you are sure, check [https://caniuse.com/](https://caniuse.com/) to double-check.
    For WOFF files, you can see the results here: [https://caniuse.com/?search=woff](https://caniuse.com/?search=woff).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你不确定一个功能是否与浏览器兼容，有时即使你确定，也要检查[https://caniuse.com/](https://caniuse.com/)以进行双重确认。对于WOFF文件，你可以在这里看到结果：[https://caniuse.com/?search=woff](https://caniuse.com/?search=woff)。
- en: 'Copy `kenney_future_narrow-webfont.woff2` into the `static` directory in your
    application so that it gets picked up by the build process. Then, you need to
    specify `@font-face` in CSS so that elements can be rendered in it, which looks
    like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将`kenney_future_narrow-webfont.woff2`复制到应用程序的`static`目录中，以便它被构建过程选中。然后，你需要指定CSS中的`@font-face`，以便元素可以在此渲染，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What we''ve done here is load a new font face with the simple name ''`Ken Future`''
    so that we can reference it in other styles, and loaded it via the specified URL.
    Now, we can change all buttons to use that font with this additional CSS:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是加载一个名为`Ken Future`的简单名称的新字体，以便我们可以在其他样式中引用它，并通过指定的URL加载它。现在，我们可以使用这个额外的CSS将所有按钮更改为使用该字体：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you should see the button being rendered with a font that looks more like
    a game, as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能看到按钮以更像是游戏的字体渲染，如下所示：
- en: '![Figure 8.3 – New Game with the Kenney Future Font](img/Figure_8.03_B17151.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 使用Kenney Future字体的新游戏](img/Figure_8.03_B17151.jpg)'
- en: Figure 8.3 – New Game with the Kenney Future Font
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 使用Kenney Future字体的新游戏
- en: The button still looks a lot like an HTML button because of that traditional
    web background. To make it look more like a game button, we'll use a background
    and CSS Sprites to create a pretty button with rounded corners and hover colors.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于那个传统的网络背景，按钮仍然看起来非常像HTML按钮。为了使其看起来更像游戏按钮，我们将使用背景和CSS精灵来创建一个具有圆角和悬停颜色的漂亮按钮。
- en: CSS Sprites
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS精灵
- en: As a game developer, you already know what a sprite is; you haven't forgotten
    [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*,
    already, have you? In the case of **CSS Sprites**, the term as commonly used is
    a bit of a misnomer, as instead of referring to a sprite, it really refers to
    a sprite sheet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏开发者，你已经知道什么是精灵；你没有忘记[*第2章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)，*绘制精灵*，对吧？在**CSS精灵**的情况下，这个术语有点名不副实，因为它实际上并不是指精灵，而是指精灵图。
- en: Conceptually, CSS Sprites work the same way as rendering them with the canvas.
    You slice out a chunk of a larger sprite and only render that portion. We'll just
    do the entire thing in CSS instead of Rust. Since we're using CSS, we can change
    the background when the mouse is over the button and when it is clicked. This
    will make the button look correct, and we won't have to write Rust code to have
    the same effect. Clicking a button is something a browser is very good at, so
    we'll leverage it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，CSS精灵的工作方式与使用canvas渲染它们相同。你从更大的精灵中切出一块，并只渲染那一部分。我们将只使用CSS而不是Rust来完成整个操作。由于我们使用CSS，我们可以改变鼠标悬停在按钮上和点击按钮时的背景。这将使按钮看起来正确，我们不需要编写Rust代码就能达到相同的效果。点击按钮是浏览器非常擅长的事情，所以我们将利用它。
- en: 'We''ll use the `Button.svg` file from the `ui` directory in the downloaded
    assets, so you can copy that file to the `static` directory in your game''s project.
    The SVG file actually contains an entire library of buttons, which looks like
    this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用下载资源中`ui`目录下的`Button.svg`文件，因此你可以将该文件复制到游戏项目的`static`目录中。SVG文件实际上包含了一个完整的按钮库，看起来如下所示：
- en: '![Figure 8.4 – The top of Button.svg](img/Figure_8.04_B17151.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The top of Button.svg
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll want to slice out the wide blue, green, and yellow buttons to be the
    background for the button in various states. We''ll start by using the `background`
    attribute in CSS to set the button''s background to the SVG file. You''ll update
    the style as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The pixel values in `background`, `-72px` and `-60px`, mean taking the background
    and shifting it `72` pixels to the left and `60` pixels upward to line it up with
    the blank blue button. You can get those values in a vector graphics editor such
    as `url` value specifies which file to load. Make those changes, and you'll see
    the button change to have a new background… well, sort of.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The button, but with a cut-off background](img/Figure_8.05_B17151.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – The button, but with a cut-off background
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the background is cut off, so you only get half of it, and
    the button itself still has some of the effects of a default HTML button. We can
    get rid of those effects with a little more CSS to remove the border and resize
    the button to match the background, as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `width` and `height` values were plucked from *Inkscape~ again, and that
    will set the button to be the same size as the button background in the source.
    As with the sprite sheets we used earlier, we need to cut out a slice from the
    original source, so in this case, there is a rectangle starting at `(72, 60)`
    with a width and height of `82x33`. With those changes, the button now looks like
    a game button instead of a web button.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – A New Game button'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B17151.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – A New Game button
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: There are still a few problems. The button now doesn't visually interact with
    the user, so it just looks like a picture when you click it. We can address that
    with CSS pseudo-classes for `#active` and `#hover`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Some browsers, notably Firefox, will render **New Game** on one line instead
    of two.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on pseudo-classes, check the Mozilla documentation here:
    [https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In each pseudo-class, we'll change the background attribute to line up with
    another background. Again, the numbers were pulled out of Inkscape, with a little
    tweaking once they were added to make sure that they lined up. First, we can handle
    the `hover` style, which is when the mouse is over the image.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'That produces a hover button that looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Figure 8.7 – Hover'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B17151.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Hover
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll add the `active` style, which is what the mouse will look like
    when clicked:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That produces a clicked button like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Active](img/Figure_8.8_B17151.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Active
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The final issue is that our button is really small, for a game anyway, and
    is positioned at the upper-left corner. Making the button larger the traditional
    CSS way with width and height is problematic, as shown here when we change the
    width value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – That is not a button](img/Figure_8.09_B17151.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – That is not a button
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the width or height will mean changing the "slice" that we''re taking
    from the sprite sheet, so we don''t want that. What we''ll use instead is the
    CSS `translate` property, with the `scale` function, which looks like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This gives us a nice large button with the right background, but it's not in
    the right spot.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – The button with the left side cut off](img/Figure_8.10_B17151.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – The button with the left side cut off
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the button is large and looks like a game button, we just need to
    put it in the right spot. You can do that by adding `translate` to the `transform`
    property, where `translate` is a fancy way of saying `move`. You can see that
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will get the new game button into, roughly, the center of the screen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – A New Game button!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B17151.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – A New Game button!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Centering a button in a div requires a little more CSS than I want to cover
    in this book. Since we''re positioning things manually, we can go with "good enough"
    for now. If you''re more comfortable with web development, feel free to make it
    truly perfectly centered. If you''re interested in getting the perfect center
    with Flexbox, take a look here: [https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989](https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The new game button now shows up, but it doesn't do anything because our code
    isn't doing anything with `onclick`. It's just a floating button, taunting us
    with its ineffectiveness. Go ahead and remove the `button` element from `index.html`,
    but keep `div` with the `ui` ID. Instead, we'll use Rust to dynamically add and
    remove the button when we need it and actually handle the clicks. For that, we'll
    want to make some additions to our `browser` and `engine` modules, so let's dig
    in.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Showing the button with Rust
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve written HTML to show the button and it looks pretty good, but we''ll
    actually need to show it and hide it on command. This means interacting with the
    browser and using the `browser` module. We haven''t done this in a while, so let''s
    refresh our memory on how we translate from the JavaScript we''d write traditionally
    to the Rust with `web-sys` that we''ll be using. First, we''ll need code to insert
    the button into the `ui` div. There are lots of ways to do this; we''ll use `insertAdjacentHTML`
    so that we can just send a string from our code to the screen. In JavaScript,
    that looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: You can find the docs for this function at [https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML).
    When it comes to looking up browser APIs, the **Mozilla Developer Network** (**MDN**)
    is your friend.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML)找到这个函数的文档。当涉及到查找浏览器API时，**Mozilla开发者网络**（**MDN**）是你的朋友。
- en: 'We spent a lot of time translating this kind of code into Rust in [*Chapter
    2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*, and [*Chapter
    3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063), *Creating a Game Loop*, but
    let''s refresh our memory and appease any monsters who read books out of order.
    Any JavaScript function or method is likely to be found in the `web-sys` crate
    with the name converted from PascalCase to snake_case, and with most of the functions
    returning `Option`. Frequently, you can just try that out, and it will work. Let''s
    create a new function in `browser` and see whether that''s the case, as shown
    here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)“绘制精灵”和[*第3章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)“创建游戏循环”中花费了大量时间将此类代码转换为Rust，但让我们刷新一下记忆，安抚一下那些按顺序阅读书籍的怪物。任何JavaScript函数或方法都可能在`web-sys`包中找到，其名称已从PascalCase转换为snake_case，并且大多数函数返回`Option`。通常，你可以尝试一下，它就会工作。让我们在`browser`中创建一个新的函数，看看是否如此，如下所示：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `draw_ui` function assumes there is a div with the `ui` ID, just as the
    `canvas` function assumes an ID of `canvas`. This means it's not *incredibly*
    generic, but we don't need a more complex solution right now. If we do later,
    we'll write more functions. As always, we don't want to go too far with some idea
    of "perfect" code because we've got a game to finish.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`draw_ui`函数假设存在一个具有`ui` ID的div，就像`canvas`函数假设有一个`canvas` ID一样。这意味着它并不**非常**通用，但我们现在不需要更复杂的解决方案。如果我们以后需要，我们会编写更多的函数。一如既往，我们不希望因为“完美”代码的想法而走得太远，因为我们还有游戏要完成。
- en: 'Once again, the Rust version of the code is much longer, using `and_then` and
    mapping errors to make sure we handle the error cases instead of just crashing
    or halting the program as JavaScript would. This is another case where code is
    aesthetically less pleasing in Rust but, in my opinion, better because it highlights
    the possible causes of an error. The other function we''ll need right away is
    used to hide the `ui` element, which looks like this in JavaScript:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Rust版本的代码要长得多，使用`and_then`和映射错误来确保我们处理错误情况，而不是像JavaScript那样崩溃或停止程序。这是代码在Rust中在美学上不那么吸引人，但在我看来更好的一个案例，因为它突出了错误的可能原因。我们马上需要的另一个函数是用来隐藏`ui`元素，它在JavaScript中的样子如下：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function grabs the first child of the `ui` div and removes it with the
    `removeChild` method. To be completely thorough, we should loop through all the
    `ui` children and make sure they all get removed, but we don''t do that here because
    we already know there''s only one. We also remove the children (and don''t just
    set their visibility to hidden) so that they do not affect the layout, and any
    event listeners are removed. Once again, you''ll want to translate JavaScript
    to Rust. In this case, `firstChild` becomes the `first_child()` method and `removeChild`
    becomes `remove_child`, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数获取`ui` div的第一个子元素，并使用`removeChild`方法将其移除。为了彻底，我们应该遍历所有的`ui`子元素并确保它们都被移除，但我们在这里没有这么做，因为我们已经知道只有一个。我们还移除了子元素（而不仅仅是设置它们的可见性为隐藏），这样它们就不会影响布局，并且移除了任何事件监听器。再次强调，你将需要将JavaScript转换为Rust。在这种情况下，`firstChild`变为`first_child()`方法，`removeChild`变为`remove_child`，如下所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function is a little different than `draw_ui`, in part because `first_child`
    being missing isn't an error; it just means you called `hide_ui` on an empty UI,
    and we don't want that to error. That's why we use the `if let` construct and
    just return an `Ok(())` explicitly if it isn't present. The `ui` div was already
    empty, so it's fine. In addition, there's that weird call to `map(|_removed_child|
    ())`, which we call because `remove_child` returns the `Element` being removed.
    We don't care about it here, so we are, once again, explicitly mapping it to our
    expected value of unit. Finally, of course, we address the error with `anyhow!`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与 `draw_ui` 有点不同，部分原因是因为 `first_child` 缺失不是一个错误；它只是意味着你在一个空的 UI 上调用了 `hide_ui`，而我们不希望它出错。这就是为什么我们使用
    `if let` 构造，并在它不存在时显式地返回 `Ok(())`。`ui` div 已经是空的，所以这没问题。此外，还有那个奇怪的调用 `map(|_removed_child|
    ())`，我们之所以调用它是因为 `remove_child` 返回正在被移除的 `Element`。我们在这里不关心它，所以我们再次显式地将它映射到我们的单元值。最后，当然，我们使用
    `anyhow!` 处理错误。
- en: 'This function reveals some duplication, so let''s go ahead and refactor it
    out in the final version, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数揭示了一些重复，所以让我们在最终版本中继续重构它，如下所示：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we've replaced both of the repetitive `document().and_then` calls with
    calls to `find_ui`, which is a private function that ensures we always get the
    same error when UI isn't found. It streamlines a little bit of code and makes
    it possible to use the `try` operator in `draw_ui`. The `find_ui` function returns
    `Element`, so you need to make sure to import `web_sys::Element`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将两个重复的 `document().and_then` 调用替换为对 `find_ui` 的调用，这是一个私有函数，它确保我们在找不到 UI
    时总是得到相同的错误。这简化了一小部分代码，并使得在 `draw_ui` 中使用 `try` 操作符成为可能。`find_ui` 函数返回 `Element`，所以你需要确保导入
    `web_sys::Element`。
- en: We've got the tools we need to draw the button set up in `browser`. To show
    our button programmatically, we can just call `browser::draw_ui("<button>New Game</button>")`.
    That's great, but we can't actually handle doing anything on the button click
    yet. We have two choices. The first is to create the button with an `onclick`
    handler such as `browser::draw_ui("<button onclick='myfunc'>New Game</button>")`.
    This will require taking a function in our Rust package and exposing it to the
    browser. It would also require some sort of global variable that the function
    could operate on. If `myfunc` is going to operate on the game state, then it needs
    access to the game state. We could use something such as an event queue here,
    and that's a viable approach, but it's not what we'll be doing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `browser` 中设置了绘制按钮所需的工具。要程序化地显示我们的按钮，我们只需调用 `browser::draw_ui("<button>New
    Game</button>")`。这很好，但我们实际上还不能处理按钮点击事件。我们有两种选择。第一种是创建一个带有 `onclick` 处理程序的按钮，例如
    `browser::draw_ui("<button onclick='myfunc'>New Game</button>")`。这将需要将我们的 Rust
    包中的函数暴露给浏览器。它还需要某种类型的全局变量，该函数可以操作它。如果 `myfunc` 要操作游戏状态，那么它需要访问游戏状态。我们可以在事件队列中使用某种方法，这是一个可行的方案，但不是我们将要做的。
- en: 'What we''re going to do instead is set the `onclick` variable in Rust code,
    via the `web-sys` library, to a closure that writes to a channel. Other code can
    listen to this channel and see whether a click event has happened. This code will
    be very similar to the code we wrote in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*, for handling keyboard input. We''ll start with a function
    in the `engine` module that takes `HtmlElement` and returns `UnboundedReceiver`,
    as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的相反是，通过 `web-sys` 库在 Rust 代码中设置 `onclick` 变量，将其设置为写入通道的闭包。其他代码可以监听这个通道，看看是否发生了点击事件。这段代码将与我们在
    [*第 3 章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063) 中编写的代码非常相似，即 *创建游戏循环*，用于处理键盘输入。我们将在
    `engine` 模块中从一个函数开始，该函数接受 `HtmlElement` 并返回 `UnboundedReceiver`，如下所示：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Don''t forget to bring `HtmlElement` into scope with `use web_sys::HtmlElement`.
    This doesn''t do much, and it sure doesn''t seem to have anything to do with a
    click, and it''s not obvious why we need an `UnboundedReceiver`. When we add a
    click handler to the button, we don''t want to have to move anything about the
    game *into* the closure. Using a channel here lets us encapsulate the handling
    of the click and separate it from the reacting to click event. Let''s continue
    by creating the `on_click` handler, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用 `use web_sys::HtmlElement` 将 `HtmlElement` 带入作用域。这并不会做太多，而且看起来似乎与点击事件无关，而且我们也不明显地需要
    `UnboundedReceiver`。当我们给按钮添加点击处理程序时，我们不想移动任何关于游戏的元素到闭包中。在这里使用通道让我们能够封装点击处理并使其与对点击事件的响应分离。让我们继续创建
    `on_click` 处理程序，如下所示：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The changes we've made are to make `click_sender` mutable and then move it into
    the newly created closure called `on_click`. You may remember `closure_wrap` from
    the earlier chapters, which needs to take a heap-allocated closure, in other words
    a `Box`, which, in this case, will be passed a `mouse` event that we're not using
    so we can safely skip it. The casting to `Box<dyn FnMut()>` is necessary to appease
    the compiler and allow this function to be converted into `WasmClosure`. Inside
    that, we call the sender's `start_send` function and pass it a unit. Since we're
    not using any other parameters, we can just have the receiver check for any event.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的更改是将`click_sender`变为可变的，然后将其移动到新创建的闭包`on_click`中。你可能还记得前面章节中的`closure_wrap`，它需要接收一个堆分配的闭包，换句话说是一个`Box`，在这个例子中，它将传递一个我们未使用的`mouse`事件，这样我们就可以安全地跳过它。将类型转换为`Box<dyn
    FnMut()>`是必要的，以平息编译器并允许这个函数转换为`WasmClosure`。在这个内部，我们调用发送者的`start_send`函数并传递一个单位。由于我们没有使用任何其他参数，我们只需让接收者检查任何事件即可。
- en: 'Finally, we''ll need to take this closure and assign it to the `on_click` method
    on `elem` so that the button actually handles it, which looks as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将这个闭包分配给`elem`上的`on_click`方法，以便按钮实际上可以处理它，如下所示：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've added the call to `elem.set_onclick`, which corresponds to `elem.onclick
    =` in JavaScript. Note how we pass `set_onclick` a `Some` variant because `onclick`
    itself can be `null` or `undefined` in JavaScript and, therefore, can be `None`
    in Rust and is an `Option` type. We then pass it `on_click.as_ref().unchecked_ref()`,
    which is the pattern we've used several times to turn `Closure` into a function
    that `web-sys` can use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了对`elem.set_onclick`的调用，这对应于JavaScript中的`elem.onclick =`。注意我们如何将`set_onclick`传递一个`Some`变体，因为`onclick`本身在JavaScript中可以是`null`或`undefined`，因此，在Rust中可以是`None`，它是一个`Option`类型。然后我们传递`on_click.as_ref().unchecked_ref()`，这是我们多次使用来将`Closure`转换为`web-sys`可以使用函数的模式。
- en: Finally, we also make sure to forget the `on_click` handler. Without this, when
    we actually make this callback, the program will crash because `on_click` hasn't
    been properly handed off to JavaScript. We've done this a few times, so I won't
    belabor the point here. Now that we've written all the code, we'll need to show
    a button and handle the response to it, and we need to integrate it into our game.
    Let's figure out how to show the button.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还要确保忘记`on_click`处理程序。如果没有这个处理程序，当我们实际创建这个回调时，程序将会崩溃，因为`on_click`尚未正确地传递给JavaScript。我们这样做了几次，所以在这里我不会过多地强调这一点。现在我们已经编写了所有代码，我们需要显示一个按钮并处理对其的响应，并且我们需要将其集成到我们的游戏中。让我们弄清楚如何显示这个按钮。
- en: Show the button on game over
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束时显示按钮
- en: We can show and hide the button in the `Game` `update` method by checking on
    each frame if the game is over and if the button is present, ensuring that we
    only show or hide it once, and that would probably work, but I think you can sense
    the spaghetti code beginning to form if we do that. In general, it's best to avoid
    too much conditional logic in `update`, as it gets confusing and allows for logic
    bugs. Instead, we can think of every conditional check that looks like `if (state_is_true)`
    as two different states of the system. So, if the new game button is shown, that's
    one game state, and if it isn't, that's another game state. You know what that
    means – it's time for a state machine.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Game`的`update`方法中通过检查每一帧游戏是否结束以及按钮是否存在来显示和隐藏按钮，确保我们只显示或隐藏一次，这可能会工作，但我认为你可以感觉到如果这样做，面条代码开始形成。一般来说，最好在`update`中避免过多的条件逻辑，因为它会变得混乱并允许逻辑错误。相反，我们可以将每个看起来像`if
    (state_is_true)`的条件检查视为系统的两种不同状态。所以，如果新游戏按钮被显示，那就是一种游戏状态，如果它没有被显示，那就是另一种游戏状态。你知道这意味着什么——是时候使用状态机了。
- en: A state machine review
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机回顾
- en: 'In [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing
    Animations with State Machines*, we converted RHB to a state machine in order
    to make it change animations on events easily and, more importantly, correctly.
    For instance, when we wanted RHB to jump, we went from `Running` to `Jumping`
    via a typestate method, only changing the state one time and changing the velocity
    and playing the sound one time. That code is reproduced here for clarity:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093) *使用状态机管理动画*中，我们将RHB转换为状态机，以便在事件上轻松且更重要的是正确地更改动画。例如，当我们想让RHB跳跃时，我们通过类型状态方法从`Running`变为`Jumping`，只改变一次状态，只改变一次速度并播放一次声音。这段代码在此处重现以供清晰理解：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The typestates work great, but they are also noisy if we don''t need that kind
    of functionality. That''s why in that same chapter, we chose to model our game
    itself as a simple `enum`, like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is going to change significantly because we now have a problem that necessitates
    a state machine. When RHB is knocked out, the game is over, and the new game button
    should appear. That''s a side effect that needs to happen once, on a change of
    state, the perfect use case for our state machine. Unfortunately, refactoring
    to a state machine is going to require a not insignificant amount of code because
    our current method for implementing state machines is elegant but a little noisy.
    In addition, there''s actually two state machines at work here, which is not obvious
    at first. The first is the one we see at the beginning, moving from `Loading`
    to `Loaded`, which you can think of as when you don''t have `Walk` and when you
    do. The second is the state machine of `Walk` itself, which moves from `Ready`
    to `Walking` to `GameOver`. You can visualize it like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_8.12_B17151.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Nested state machines
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have two state machines here, one going from `Loading` to
    `Loaded` and the other representing the three game states of `Ready`, `Walking`,
    and `GameOver`. There is a third state machine, not pictured, the famous `RedHatBoyStateMachine`
    that manages the `RedHatBoy` animations. A couple of the states pictured mimic
    the states in `RedHatBoyStateMachine`, where `Idle` is `Ready` and `Walking` is
    `Running`, so there is a temptation to move `RedHatBoyStateMachine` into `WalkTheDogStateMachine`.
    This could work, but remember that `Walk` doesn''t have a "jumping" state and
    so, by doing that, you''ll need to start checking a Boolean, and the modeling
    starts to break down. It''s best to accept the similarity because the game is
    heavily dependent on what RHB is doing, but treat `RedHatBoyStateMachine` as having
    more fine-grained states. What *does* work is turning `Loading` and `Loaded` into
    `Option`. Specifically, we''ll model our game like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code isn''t meant to be written anywhere yet; it''s just here for clarity.
    There''s a big advantage to using `Option` here, and it has to do with the way
    our `update` function works. For clarity, I''m going to reproduce a section of
    our game loop here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The key part here is the `game.update` line, which performs a mutable borrow
    on the `game` object instead of moving it into `update`. This is because once
    `game` is owned by `FnMut`, it can''t be moved out. Trying to actually leads to
    this compiler error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Mutable borrows such as this are tricky because they can make it more challenging
    to navigate the borrow checker as you proceed down the call stack. In this case,
    it becomes a problem if we try to implement another state machine in the same
    manner as `RedHatBoyStateMachine`. In our state machine implementation, each `typestate`
    method consumes the machine and returns a new one. Now, let''s imagine that we
    are modeling the entire game as `enum`, like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In order to make this work with the mutable borrow in `update`, we would have
    to clone the entire game on every state change because the `from` function couldn't
    take ownership of it. In other words, the closure in our `game.update` function
    *lends* `game` to the `update` function. This can't turn around and *give* it
    to the `from` function – it doesn't own it! Doing so requires cloning the entire
    game, potentially on every frame!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Modeling the game as holding an optional `WalkTheDogStateMachine` has two advantages:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: We can call `take` on `Option` to get ownership of the state machine.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type reflects that the state machine isn't available until the game is loaded.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are, naturally, many ways to model our game type, and some of them are
    going to be better than the one we'll choose here. However, before you start trying
    to do a "simpler" version of this type, let me warn you that I tried several different
    variations on this solution and ultimately found using `Option` to be the most
    straightforward choice. Several other implementations either ended with complex
    borrowing or unnecessary cloning. Be wary, but also be brave. You may find a better
    way than I did!
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before we dig into the actual implementation, which is fairly long, let's go
    over the design we're implementing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Before](img/Figure_8.13_B17151.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Before
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: It's pretty simple, but it doesn't do all that we need it to. Now, let's redesign
    the state machine.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – After'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B17151.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – After
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, that's a lot more code, and it doesn't even reflect the details of the
    implementation, or the `From` traits we write to make it easy to convert between
    the `enum` values and structs. Writing some macros to handle state machine boilerplate
    is out of the scope of this book, but it's not a bad idea. You might wonder why
    every state holds its own `Walk` instance when every single state has it, and
    that's because we're going to change `Walk` on the transitions and the individual
    states don't have easy access to the parent `WalkTheDogState` container data.
    However, where possible, we'll move common data out of `Walk` and into `WalkTheDogState`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: This section has a lot of code, and the snippets tend to only show a few lines
    at a time so that it's not too much to process. However, as you're following along,
    you may wish to reorganize the code to be easier to find. For instance, I prefer
    to work top-down in the `game` module, with constants at the top followed by the
    "biggest" `struct`, which is `WalkTheDog` in this case, followed by any code it
    depends on, so that the call stack flows down the page. This is how [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8)
    is organized. You're also welcome to start breaking this up into more files. I
    won't, to make it easier to explain in book form.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Redesigning to a state machine
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a true refactoring, we would make sure the game was in a running state after
    each change, but our changes are going to cause cascading compiler errors, meaning
    we're going to be broken for a while, so this change isn't truly a refactoring
    but more of a redesign. When you make this kind of change, you should absolutely
    get to a compiling state as quickly as possible and stay there as long as possible,
    but while I did that when writing this chapter, I'm not going to put you through
    all the intermediate steps. We'll move forward as if we know in advance that our
    design is going to work because we do this time, but don't try this at home. If
    you're a regular Git user, now is an excellent time to create a branch, just in
    case.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by replacing this code in the `game` module:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''ll replace it with the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will cause compiler errors all over the place. This is the section where
    we'll take the shortcut of letting the compiler be broken temporarily while we
    implement the state machine, if only to make sure this chapter isn't a thousand
    pages long. So, if you're uncomfortable working with a broken code base for a
    long time, that's good – just trust that I was *brilliant* and got this all right
    on the first try. Pretend – it'll be okay.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re psychic and know exactly how this design is going to work out,
    we can go and push ahead, knowing that eventually, everything will come together
    without errors. This first change is exactly what we discussed earlier – `enum
    WalkTheDog` becomes a struct holding its `machine` instance, which is an `optional`
    field. Currently, `WalkTheDogStateMachine` doesn''t exist, so we''ll add that
    next, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we implement a state machine in Rust, we need `enum` as a container for
    states so that `WalkTheDog` doesn''t need to be a generic `struct`. We''ve moved
    the compiler errors down because there is no `WalkTheDogState` and no states defined.
    Let''s do that next:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Right now, the various typestates, `Ready`, `Walking`, and `GameOver`, don''t
    store any data. This will change a little as we go on, but all of the typestates
    have `Walk` so that they can be saved in the common `WalkTheDogState` struct.
    Now that we''ve created the state machine, we need to look at where the old version
    of `WalkTheDog` was used. The first is in the small `impl` block for `WalkTheDog`,
    in the old code where we created `enum`, like so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That''s not going to work, and it''s not compiling, so instead, let''s replace
    it with an empty `WalkTheDog` instance, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This change replaces the old, and not used, `enum` with `machine` set to `None`.
    You can now think of `None` as the `Loading` state, and when a machine is present,
    you are `Loaded`. Speaking of loading, the next logical place to make changes
    is in the `Game` implementation for `WalkTheDog`. Looking at the `initialize`
    function that we''ve been in so many times, you''ll see a compiler error here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `match self` line is not going to work anymore because `self` isn''t `enum`.
    What we need to do instead is match `machine`, and if it''s `None`, then load
    the new machine, and if it''s present, then use `Err` in the same way we do now
    because `initialize` was somehow called twice. We can start by replacing both
    halves of the `match` statement, so the match should start as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Look closely to see that we now match on `self.machine`, and we match against
    `None`. Before we dig into the `None` match arm, let''s quickly change the match
    on `WalkTheDog::Loaded(_)`, as shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This simply changes `WalkTheDog::Loaded` to `Some`, using the same error message.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In order to get clearer error messages, you can `#[derive(Debug)]` on the `WalkTheDog`
    struct. Doing that has cascading effects because everything it depends on also
    has to `#[derive(Debug)]`, so we won't do that here, but it's a good idea, especially
    if you're running into issues here.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that both halves of the match properly match an `Option` type, we need
    to modify `initialization` to return the proper type. At the bottom of the `None`
    branch, you will want to create a state machine like the one shown here, right
    before returning the value:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is very similar to the code before; the construction of `Walk` is unchanged,
    but it's obscured by all the state machine noise. We are binding the `machine`
    variable to `WalkTheDogStateMachine::Ready` with the initialized `WalkTheDogState`
    instance, which, in turn, sets its internal `_state` value to `Ready`, and with
    the state getting to have `Walk`. It's noisy, and after we get this file back
    to compiling, we'll do true refactoring to make that line a little cleaner, but
    put a pin in that for now.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we made it so that `initialize` returns a new `Result<Box<dyn Game>>`
    a while back, so we''ll need to return a new `Game` instance next. So, right after
    adding `machine`, add the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Given that `initialize` takes `self` and doesn't really use it, it's debatable
    whether it should be in the `Game` trait. Creating a separate trait, such as `Initializer`,
    will require a lot of modifications and is an exercise for the reader.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: This takes care of making sure `initialize` returns a game with a machine in
    the right state. We have two more big trait methods, `update` and `draw`, to take
    care of, and `update` is filled with compiler errors, so let's do that next.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Spreading update into the state machine
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `update` function is filled with compiler errors, is the core of the game''s
    behavior, and has an additional challenge. Instinctively, you might think you
    can modify the beginning of the function like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `if let Some(machine) = self.machine` line will eventually fail to compile
    with the error:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, you may try, as I did, to fix this by changing the line to `if let Some(machine)
    = &mut self.machine`. This will work until you try to implement a transition on
    `WalkTheDogState`. Because you have a borrowed machine, you''ll also have a borrowed
    state when you later match on the state, as with the following example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, the `state` value is borrowed, unlike in most other cases where the match
    arms take ownership of the value, and it''s not instantly obvious. It will be
    if we write a transition from `Ready` to `Walking`. In order to write `state._state.run_right()`
    and get to `Walking`, your transition will need to look like this in order to
    compile:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that we are transitioning from `&mut WalkTheDogState<Ready>>` to `WalkTheDogState<Walking>`,
    which is an odd conversion and a hint that this is wrong. What you can''t see
    is that this code won''t compile. Returning the new `WalkTheDogState` with `walk`
    is a move that we cannot do because `state` is borrowed. The `start_running` method
    doesn''t own `state`, so it can''t take ownership of `state.walk` and, therefore,
    can''t return the new instance. The workaround for this is to clone the entire
    `Walk` each time we transition, but there''s no need for that inefficiency. We
    can, instead, take ownership of `machine` all the way back up in the `Game` implementation,
    through the aptly named `take` function. Instead of using a mutable borrow on
    the machine, we''ll call `take`, as shown here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is the same code as earlier, but instead, we call the `take` method on
    `Option<WalkTheDogStateMachine>`. This replaces the state machine in `self` with
    `None` and binds the existing `machine` to the variable in `if let Some(machine)`.
    Now, inside that scope, we have complete ownership of `machine` and can do whatever
    we like to it, before eventually calling `replace` on the state machine in `self`
    to move it back in at the end of this function. It''s a little awkward, but it
    gets around mutable borrows. It *also* introduces a potential error in that when
    control exits the `update` function, `machine` could still be set to `None`, effectively
    halting the game by accident. In order to prevent that from happening, before
    we continue updating this function, we''ll add `assert` just outside the `if let`
    statement, as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Unfortunately, this is a runtime error, not a compile-time one, but it''s going
    to let us know right away whether we mess up the next section. This `assert` may
    be overkill, because we are going to dramatically reduce the amount of code inside
    the `if let` block; in fact, it will be just one line. First, we''ll add a call
    to a non-existent function called `update` on our state machine, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Immediately after `if let Some(machine)`, add the `self.machine.replace(machine.update(keystate))`
    line. All the code below `replace` in the `if let` block is going to become part
    of various `update` functions in the implemented states, so what you''ll want
    to do is either cut and paste that code to some place you can get it, or just
    comment it out. Next, we''ll create `impl` on `WalkTheDogStateMachine` with this
    new `update` method, which will return the new state. An empty version of that
    will look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, you can call that from the the `update` method in `Game`, which looks
    like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `update` method in `WalkTheDogStateMachine` is a little empty, and we should
    probably put some code in it. We could call `match self` in the update, and then
    write the behavior for each state in this `update` function, calling things such
    as `state._state.walk.boy.run_right()`, which would work but it is hideous. Instead,
    we''ll match on `self` and then delegate to the individual `state` types. This
    will result in a pretty redundant `match` statement, as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We saw a variation of this pattern before in `RedHatBoyStateMachine`, where
    we have to match on each variant of `enum` in order to delegate to the state,
    and unfortunately, there''s not a great way around it. Fortunately, it''s small.
    This little `match` statement won''t compile because none of the `typestates`
    types have an `update` method. In fact, there are no implementations for the typestates
    at all. Let''s continue our delegation by creating placeholder implementations
    for all three of them, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It's worth refreshing our memory on how typestates work. A typestate is a structure
    that is generic over a state. So `WalkTheDogState<T>` is the structure, and we
    implement transitions between states by adding methods to implementations of `WalkTheDogState<T>`,
    where `T` is one of the concrete states. These placeholders all just return `self`,
    so `update` isn't doing anything yet. Look closely and you'll notice that `GameOver`
    doesn't take `KeyState` because it won't need it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` method on `WalkTheDogStateMachine` tries to use `into` to convert
    each typestate back into `enum`, but we haven''t written those yet. Recalling
    [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing Animations
    with State Machines*, again, we need to implement `From` to convert back from
    the various states to the `enum` type. These are implemented here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is boilerplate just to get things started, but it demonstrates how each
    of these works. The `update` method on `WalkTheDogStateMachine` uses `match` to
    get the `state` value on each variant. Then, the `update` method is called on
    the various typestates. Each `update` method returns the state it transitions
    into, although right now, they all return `self`. Finally, back in the `update`
    method on `WalkTheDogStateMachine`s, we call `into` to convert the typestate back
    into an `enum` variant.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: You might remember that for `RedHatBoyStateMachine`, we used a transition function
    and an `Event` `enum` to advance the state machine. The new `WalkTheDogStateMachine`
    enum has fewer events, so additional complexity isn't necessary.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to think about what each state should actually do. Previously, every
    one of these states was kind of shoved together in the `Game` `update` method
    – for instance, the following old code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the old system, if the game was `Loaded`, then `boy` could `run_right` if
    you pressed the `ArrowRight` button and could jump if you pressed `Space`. This
    worked fine, but it''s worth noting the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The `run_right` function does nothing if RHB is already running.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jump` and `slide` functions do nothing if RHB isn't running.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We handle this quite well in our `RedHatBoyStateMachine`, and will continue
    to do so, but what this reveals is that once RHB starts moving to the right, we
    don't really care if the player has pushed the `WalkTheDogStateMachine`. When
    the game is `Ready`, we'll check whether the user has hit `ArrowRight` and transition
    the state. Otherwise, we'll just stay in the same state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify `WalkTheDogState<Ready>` to reflect this new reality. The first
    change to the function will be to do that check, as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There's one type and one method that doesn't exist, so this code does not compile
    yet. The transition of `start_running` doesn't exist yet, although we discussed
    writing something like it. We also don't have the `ReadyEndState` type. Let's
    address that second one first.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We used this pattern earlier for any `typestate` method that can return more
    than one state, such as the `update` method on `Jumping` or `Sliding`. We create
    a new `enum` that can represent either of the return states. In the case of the
    `update` method for `WalkTheDogState<Ready>`, the game can either still be `Ready`
    at the end of an update (`ReadyEndState::Continue`) or be done and transitioning
    to `Walking` (`ReadyEndState::Complete`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the `From` trait to convert from `ReadyEndState`
    to `WalkTheDogStateMachine`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is some boilerplate that you've seen before. We have two states for `ReadyEndState`
    because there are two states that the `WalkTheDogState<Ready>` `update` method
    can end in. In order to get from `ReadyEndState` to `WalkTheDogStateMachine`,
    we create a `From` trait and match on both variants of `ReadyEndState` and extract
    their fields from them. Those are both typestates, `WalkTheDogState<Ready>` and
    `WalkTheDogState<Walking>`, respectively, so we use their `into` methods to convert
    them into the `WalkTheDogStateMachine` type. Those traits were already written
    earlier.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `self.start_running` is still not going to work because we haven''t
    written it yet! What happens when the player hits `typestate` method named after
    the transition, which looks like so:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let's refresh our memory on these. Every `state` transition is written as a
    method on the various typestates – in this case, `WalkTheDogState<Ready>`, where
    the source state is `self` and the return value is the destination state. Here,
    we transition from `Ready` to `Walking` by writing a method called `start_running`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual implementation isn''t doing much. We start by calling `self.run_right`,
    which doesn''t exist yet, so we have to write it. After sending RHB running, we
    transition into the `Walking` state by returning a new `WalkTheDogState` instance
    with `_state` of `Walking`. Take a close look at the function signature for `start_running`
    and you''ll notice it takes `mut state`. This means taking exclusive ownership
    over `self`, which we can do because we have complete ownership of everything
    in the state. That is one of the reasons we created `Option<WalkTheDogStateMachine>`
    originally! However, it''s not obvious why we take `mut state` here instead of
    `state`, in part because `run_right` doesn''t exist. When we add our new delegation
    method, that should become clear, so let''s do that right now with the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This function on `WalkTheDogState<Ready>` calls `run_right` on `boy` through
    its walk field. The `run_right` method on `boy` requires a mutable borrow, and
    that's why we require a mutable borrow on the previous delegate. It's also why
    we needed to take `mut state` in the `start_running()` method earlier. You can't
    mutably borrow something that isn't mutable in the first place.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep the code clean, we're doing a little more delegation now than
    we were earlier. This makes our methods smaller and easier to understand, but
    the trade-off is that the behavior will be spread across multiple places. I think
    in the end, this will make our code easier to think about, because we won't have
    to consider too much code at any one time, so the trade-off is worth it. We'll
    have to be careful that we don't lose track of any of our original code as we
    break it up into chunks and spread it around.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Re-implementing draw
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we've removed all the compiler errors in the original `update` method,
    in part by removing a large chunk of its functionality, and we can continue by
    updating the `Walking` state to ensure that it's working, but I believe that's
    a long time without any meaningful feedback from the game. After all, at this
    point, the game doesn't compile and doesn't draw. How do we know anything is working?
    Let's instead take a moment and update the `Game` `draw` method so that we can
    actually get the code to compile again and see how it's working.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The `draw` method will start by taking a page from the `update` method and
    replacing its current implementation with a delegation to `WalkTheDogStateMachine`,
    as shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There are two things that are a little different from the changes we made to
    update. The first is that we only borrow `self.machine` because we don't need
    mutable access. We also still clear the screen at the top of `draw`. That happens
    on every state change, so there's no reason to not just do it then. Besides, it
    will help us debug if we make any mistakes, since the screen will turn white.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue the delegation by adding a `draw` method to `WalkTheDogStateMachine`
    that can extract the state from each case for drawing, as shown here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is virtually identical to the `update` method we wrote earlier, except
    on a borrowed `self` instead of consuming `self`. The rest is just delegations
    to the various states. Unlike update, every state draws in the exact same way,
    so we can fill those in with one method, as shown here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Any state will delegate `draw` to `Walk` because the drawing doesn''t actually
    change based on state. We can finally go ahead and re-implement the `draw` method,
    this time on `Walk`, as shown here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code is not new, but I don't blame you if you forgot it. It's our old `draw`
    code from [*Chapter 6*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139), *Creating
    an Endless Runner*, only with the `walk` variable replaced by `self`. The rest
    is identical.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you'll notice something exciting – the code compiles again! But
    if you look closely at the game, you'll see that it's a little static.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Stand very still….](img/Figure_8.15_B17151.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Stand very still….
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat Boy has stopped animating! He doesn't do his little idle animation because
    we're not calling `update` like we used to; it's almost time to go back to fixing
    the `update` method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring initialize
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we proceed with restoring functionality, you might remember that I said
    the creation of `WalkTheDogStateMachine` was "obscured by all the state machine
    noise." Specifically, it looked like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To create `WalkTheDogStateMachine` required creating its `Ready` variant and
    passing a `WalkTheDog` state with its `_state` variable set to `Ready`. In addition
    to being noisy, it requires you to remember the correct initial state of the state
    machine. That's what constructors are for!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a constructor for `WalkTheDogState<Ready>`, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This makes it easier to create a new typestate of `WalkTheDogState<Ready>`;
    accepting `Walk`, it needs to be valid. Let''s also make it easier to create the
    entire machine, with a smaller constructor:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This constructor creates the entire machine with the right state and passes
    it `Walk`. Now that we''ve made these helper methods, we can make the change to
    the original initialize method, making it a little bit easier to read by using
    the `WalkTheDogStateMachine` constructor:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It's a small change, but makes it both easier to read and safer, too. Doing
    the right thing, creating `WalkTheDogStateMachine` in the `Ready` state is easy
    to do, and creating it in the wrong state is not.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've finished that little digression, we can go back to finishing
    the update method as planned.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Finishing update
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This segment of the *original* `update` function in `Game` reveals what is
    missing from our current code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Immediately after all the checks for button presses, we were updating `boy`.
    Let''s go ahead and add that to our new version of the `update` function in the
    `WalkTheDogState<Ready>` implementation, like so:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There are two changes here, so don't forget to change `update` to accept `mut
    self` now instead of `self`. It's hiding there in the function signature. Also,
    we've added a call to `self.walk.boy.update()` to start updating the boy again.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Do that and you''ll see RHB idling again, ready to start chasing down his invisible
    dog. But if you hit the right arrow, RHB freezes, one frame into his running animation.
    That is not what we want, and intriguingly, there are no errors in the console
    log because no exceptions are being thrown. It''s just that the `Walking` state
    doesn''t do anything in its `update` function. We can restore that code by putting
    back some of the code we earlier commented out/copied/deleted into the `Walking`
    state of the game, as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In `WalkTheDogState<Walking>`, we've modified the `update` method to take a
    `mut self` and then restored most of the old `Game` `update` code. Rather than
    showing the entire method, I've just reproduced the beginning and end of the code
    snippet and elided the middle; you can safely cut and paste all the original code.
    There are a few changes to make the code fit its new location. Where the original
    code would read `walk.boy`, it now reads `self.walk.boy`. I also took the opportunity
    to rename `velocity`, which is a little vague, to `walking_speed` to clarify that
    it refers to how fast RHB walks. The final change we've made is taking out the
    `if keystate.is_pressed("ArrowRight")` code because there's no reason to check
    for that keypress anymore. Lastly, we return `self` because there's not yet any
    way to transition out of `WalkTheDogState<Walking>`. If you do this all correctly,
    you'll find that your code compiles and runs! In fact, as of this moment, all
    of the behavior is restored, including the problem where we have to refresh to
    start a new game. How about we finally add a new game button right now, huh?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Game
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you remember our originally planned behavior, and I don''t blame you if
    you don''t, we wanted to draw a new game button on the screen when RHB crashed
    and fell over. Then, when it''s clicked, we want to start a new game. For that
    to happen, we''ll need to do the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Check whether `RedHatBoyStateMachine` is `KnockedOut`, and if so, transition
    from `Walking` to `GameOver`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On that transition, draw the new game button.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `onclick` handler so that when the button is clicked, we transition back
    to `Ready` with a new `Walk` instance.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the transition to `Ready`, hide the button and restart the game.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All the code we wrote before was to make that change easier. Let''s see whether
    we were right about that:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Transition from `Walking` to `GameOver`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To transition from `Walking` to `GameOver`, we need to return the `GameOver`
    state from the `WalkTheDogState<Walking>` `update` method, but when should we
    do that? We''ll need to see whether the *boy* is knocked out and then make the
    change. We don''t have that capability yet, so we''ll need to create it, and let''s
    work top-down, as we have been this entire chapter. First, we''ll change the `WalkTheDogState<Walking>`
    `update` method to check the non-existing method:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, instead of always returning the `Walking` state, we return `WalkingEndState`,
    which doesn''t exist yet but will mimic the pattern we used in the `update` method
    on on `WalkTheDogState<Ready>`. When the current state is `knocked_out`, we will
    return the `Complete` variant holding an instance of the `WalkTheDogState<GameOver>`
    type. That will be the state returned from the `end_game` transition, which is
    also not written yet. Otherwise, we''ll return `Continue` with the current `WalkTheDogState<Walking>`
    state as its field. That''s two functions that don''t exist yet, `knocked_out`
    and `end_game`, along with a brand-new type. You can create the `WalkingEndState`
    type and its corresponding `From` trait to convert it into `WalkTheDogStateMachine`
    right now by following the same pattern we did for `ReadyEndState`. I won''t reproduce
    that code here. We''ll proceed from there by getting `knocked_out` working, which
    is going to be delegated from `Walk` to `RedHatBoyStateMachine` with some delegations
    in between:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We could pass `WalkTheDogState` to `RedHatBoyStateMachine` here to get the new
    state and follow the OO guideline of "tell, don't ask", but sometimes, you just
    want to check a Boolean. Here, we ask the `Walking` state, which asks `RedHatBoy`
    and finally `RedHatBoyStateMachine` whether it is knocked out. `RedHatBoyStateMachine`
    uses the handy `matches!` macro to check `self` against an `enum` variant, and
    return whether or not they match. Now that we can check whether Red Hat Boy is
    knocked out, we have just one compiler error – `` no method named `end_game` found
    for struct `WalkTheDogState` ``.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to implement the `end_game` transition method, which will represent
    our transition. We can start by implementing the transition to do nothing other
    than move `walk` from `Walking` to `GameOver`, as shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This returns us to a compiled state and means that when RHB crashes and is knocked
    out, the game is in the `GameOver` state. However, it does nothing, so it's time
    for *step 2* – draw the new game button.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Draw the new game button.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Many pages ago, I said: "To show our button programmatically, we can just call
    `browser::draw_ui("<button>New Game</button>")`." But when do we call it? Well,
    we call it now, right before creating the new state:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If you add this one line of code to the transition, you'll see the new game
    button we wrote way back at the beginning when our RHB crashes into a rock. There's
    a warning on this line because we don't handle the result of `draw_ui`, which
    we'll ignore for the moment.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Add the `onclick` handler to the button.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to add the click handler to the button, we need to get a reference
    to the element we just drew. We don''t have that, as the `insert_adjacent_html`
    function doesn''t provide it, so we''ll need to find the button we just added
    to the screen so that we can attach an event handler to it. We''ve used `get_element_by_id`
    twice before on `document`, so it''s probably time to write a wrapper function
    in the `browser` module, as shown here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We've made a slight change to the way we've been finding elements in this function.
    Normally, we want `HtmlElement`, not a generic `Element` type, so in this function,
    we've gone ahead and added a call to `dyn_into` to make the conversion. Therefore,
    this function first gets the document, then gets the element, and finally, converts
    it into the `HtmlElement` type, all while normalizing the errors with `anyhow!`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a way to find the element, we can return to the transition
    in `game`, find the newly added new game button, and then add a click handler
    to it, as shown in the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We've reproduced the entire transition trait here, but there are three changes.
    The first is that we've added `id` to the new game button; naturally, that's `new_game`.
    Then, we find the element in the document in the `and_then` block and use `map`
    to take that element and pass it to the recently created `add_click_handler` function.
    Now, we've got a small problem. We will need `receiver` to get click messages
    when they happen, but the `add_click_handler` function returns `Result` with `UnboundedReceiver`.
    The challenge is that the `end_game` function doesn't return `Result`. In [*Chapter
    9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing, Debugging, and
    Performance*, we'll investigate how to debug this kind of condition, but for now,
    we'll just grit our teeth and add `unwrap`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `receiver` that will get a message whenever the player clicks
    `update` function for the `GameOver` state and when we receive the event transition
    to the `Ready` state. That''s going to mean adding the receiver to the `GameOver`
    struct, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will prompt you to add the `use` declaration for `futures::channel::mpsc::UnboundedReceiver`.
    Now that `GameOver` `struct` has the field, we''ll need to pass it along in the
    transition, as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is the final change to this method, and it's just adding the field to `GameOver`.
    Interestingly it's the first time we've added a field to any of our state structures,
    but it's something you're likely to do more of over time as you extend this game.
    Various states have data that's unique to them, and they belong in the `state`
    struct.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to return to the `WalkTheDogState<GameOver>` implementation and
    its `update` method, which currently just returns the `GameOver` state, leaving
    the game in that state forever. Instead, we''ll want to check whether the new
    game event has happened (because the button was clicked) and then return the `Ready`
    state to start over again. That small bit of code is reproduced here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the `WalkTheDogState<GameOver>` implementation, we check the state to see
    whether the new game button has been pressed, and if it has, we return the `GameOverEndState::Complete`
    variant; otherwise, we return the `GameOverEndState::Continue` variant. This is
    the same pattern we've used in every other update method, and you can go ahead
    and reproduce the `GameOverEndState` enum and its corresponding `From` trait to
    convert the type to a `WalkTheDogStateMachine` enum. That code is not reproduced
    here, but remember that if you get stuck, you can find the sample code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In the `GameOver` implementation, we have the details to check whether `new_game_event`,
    corresponding to the player's click, has happened. Calling `try_next` will return
    `Result` immediately, without blocking, or `Ok` if the channel is still open,
    regardless of whether anything is in it. Remember that we are running at 60 frames
    per second and cannot use the blocking calls. Finally, we use the handy matches!
    macro to check whether the channel was successfully sent a message of `unit`,
    or Ok(Some(())). If the event is there, `true`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: This code doesn't compile because we don't have a transition written from `GameOver`
    to `Ready`, which is what we'll write in the next step.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Restart the game on **New Game**.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Restarting the game will mean doing two things on the `new_game` transition.
    The first is hiding the button or "UI," and the second is recreating `Walk` from
    scratch. The first is actually easier, so we''ll start with that:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is another transition, this time from `GameOver` to `Ready`, with the side
    effect of hiding the UI. It then moves to a new state with the same walk we ended
    with, which is not quite what we want.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – I hit New Game – run, boy, run!](img/Figure_8.16_B17151.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – I hit New Game – run, boy, run!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'The button is hidden but RHB is still knocked out. Moving from `GameOver` to
    `Ready` means creating a new `Walk` instance from the old one, so the game starts
    over. This is a bit of a challenge because we no longer have access to the various
    images and sprite sheets we used to create `Walk` and `RedHatBoy` in the first
    place. What we''ll do is clone those from an existing one, via a constructor function
    on the `Walk` implementation. We won''t call this `clone` because that term means
    an identical copy, whereas this is really a reset. You can see the implementation
    here:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `reset` function consumes `Walk` and returns a new one. It recreates `starting_obstacles`
    the same way they are created in `initialize`, and then recalculates `timeline`.
    Then, it constructs a new `Walk`, moving all the values from `Walk` except `starting_obstacles`
    and `timeline`. This function is not quite right though, as it will reset `Walk`
    but leave `boy` in its `KnockedOut` state. We''ll need a similar `reset` function
    for `boy`, as shown here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Writing `reset` on `RedHatBoy` is a lot easier than it was on `Walk` because
    we created a constructor function, `new`, for `RedHatBoy` a long time ago. We
    should do the same for `Walk`, but that refactoring is up to you. Keep in mind
    that for this to compile, the `audio` and `jump_sound` fields on `RedHatBoyContext`
    need to be public.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a `reset` function for `RedHatBoy`, we can use it in the `Walk`
    `reset` function, like so:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We also need to call this in the original transition from `GameOver` to `Ready`,
    as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If you do all that, you'll find that when you click the new game button, the
    game resets and the player is back at the start. You should be able to hit the
    right arrow key and start walking again. You *should*, but it doesn't work because
    we haven't accounted for one feature of the UI – the focus.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Focus!
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It turns out there's one more thing to do when we click the new game button
    to make the game ready to play again. When the game was started, we set up the
    canvas to have the focus so that it would receive keyboard input. We did this
    with the `tabIndex` field in the original HTML. When the player clicks **New Game**,
    they transfer the focus to the button and then hide the button, which means nothing
    will get the keyboard events we are listening to. You can see this effect by clicking
    **New Game** and then clicking the canvas after the button disappears. If you
    click the canvas, it regains the focus, and you can play the game again.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'We can transfer the focus back to the canvas automatically in the `hide_ui`
    function of the `browser` module. It''s debatable whether it belongs here, since
    you may have cases where you want to hide the UI but not reset the focus, but
    our game doesn''t have that case, so I think we''re safe. This change is here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: After the first call to `map_err` for removing the child, we've added a second
    `and_then` call, which takes `unit` from the earlier `map` call, promptly ignores
    it, and then requests `focus` on `canvas`. The error from the `focus` call doesn't
    return an `anyhow!` type, so the compiler complains, and we fix that with a `map_err`
    call. The `focus` function is a JavaScript function we call through `web-sys`,
    which is documented on the MDN ([https://mzl.la/30YGOMm](https://mzl.la/30YGOMm)).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: With that change, you can click **New Game** and start another try. We did it!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Pre-loading
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might notice that the button visibly loads when it shows up on screen –
    that is to say that the image and font aren''t downloaded to the browser yet,
    so it doesn''t appear instantaneously. This is standard behavior for web browsers.
    In order to make sure that you don''t have to wait for an entire page worth of
    images, fonts, and other assets to load before you see a page, browsers will load
    assets lazily. This is so common that your eyes may not have noticed it when the
    `Button.svg` and the `kenney_future_narrow-webfont.woff2` assets immediately when
    the page is loaded so that when the button appears, it''s instantaneous. Open
    the `index.html` file and make the changes shown here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `link` tag with the `preload` attribute will preload assets before rendering
    the page. You'll want to minimize this behavior generally because you don't want
    the user to have to wait a very long time with a blank screen, and if you were
    to make a very large game with many assets, you should probably use a more flexible
    solution in code with a loading screen. Our game is small right now, so this works
    perfectly well. With this change, the new game button not only appears but is
    snappy.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can look at the end of this chapter in two ways. The first might be to say,
    "All that for a button?", and you would have a point. After all, our UI is only
    one new game button, and while that's true, we actually covered quite a bit. We
    have integrated the DOM into our app via `web-sys` and have, in turn, adjusted
    our game to handle it. By utilizing the DOM, we were able to leverage the browser
    for behavior such as clicks and hovers, without having to detect where within
    the canvas the mouse was and creating clickable areas. You can now create far
    more complex UIs using tools such as CSS Grid and Flexbox, so if you are familiar
    with web development, which you've been doing for this entire book, so you are,
    you'll be able to make quality UIs for your games. If you're looking for some
    place to start, try adding a score to this game. You can increment the score in
    the update, and show it at the end menu, or at the right corner during the game,
    or both! I look forward to seeing it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: With that, we will move on from new feature development to making sure that
    our current features work, and work fast. It's now time to start doing some testing
    and debugging, so we'll dive into that in the next chapter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
