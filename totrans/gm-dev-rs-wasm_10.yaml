- en: '*Chapter 8*: Adding a UI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may appear that we've developed everything we need for a video game, and
    to some extent, we have, except for that annoyance where we need to hit refresh
    every time little **Red Hat Boy** (**RHB**) hits a rock. A real game has buttons
    for a "new game" or "high scores", and in this chapter, we'll be adding that UI.
    To do so may seem trivial, but event-driven UIs that you might be familiar with
    from web development are an odd fit with our game loop. To add a simple button,
    we'll need to make significant changes to our application and even write a little
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Design a new game button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the button on game over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start a new game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the chapter, you'll have the framework in place for a more full-featured
    UI and the skills to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need a few more assets, this time from the `ui` directory in the `assets`
    download at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
    The font is Kenny Future Narrow from [https://www.kenney.nl](https://www.kenney.nl).
    The button is from [https://www.gameart2d.com/](https://www.gameart2d.com/). Both
    are CC0-licensed. As before, the final code for this chapter is available on the
    corresponding branch at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3DrEeNO](https://bit.ly/3DrEeNO)'
  prefs: []
  type: TYPE_NORMAL
- en: Design a new game button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When RHB crashes into a rock, he falls over and… well, let's say he takes a
    nap. Unfortunately, at that point, the player has to refresh the page to start
    a new game. In most games, we'd see a series of buttons for a new game and high
    scores. For now, we'll just put in a new game button that will restart from the
    beginning. This might seem like a simple task, but in fact, we'll have quite a
    bit to do.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to decide how we want to implement the button. We really have
    two choices. We can create a button in the engine, which would be a sprite that
    is rendered to the canvas, the same as everything else, or we can use an HTML
    button and position it over the canvas. The first option will look right and won't
    require any traditional web programming, but it will also require us to detect
    mouse clicks and handle a button-click animation. In other words, we'd have to
    implement a button. That's more than we want to implement to get our game working,
    so we're going to use a traditional HTML button and make it *look* like it's a
    game element.
  prefs: []
  type: TYPE_NORMAL
- en: So, we're going to write some HTML and CSS, which we can use to make the button
    look like it's a part of the game engine. Then, we'll add the button to the screen
    with Rust and handle the click event. That will be the tough part.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conceptually, our UI will work like a HUD in a FPS or where a button is superimposed
    over the front of a game itself. Imagine that there is a perfectly clear pane
    of glass on top of the game, and the button is a sticker that's stuck to it. This
    means, in the context of a web page, that we need a div that is the same size
    and in the same place as the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This isn't a book on HTML or CSS, so I'm not going to spend much time covering
    it, other than the canvas we've been using throughout. If web development isn't
    your forte, don't worry – a quick scan of [https://learnxinyminutes.com/docs/html/](https://learnxinyminutes.com/docs/html/)
    will cover more than enough. We'll also be using a little bit of CSS in this section,
    and you can get a similar cheat sheet for that syntax at [https://learnxinyminutes.com/docs/css/](https://learnxinyminutes.com/docs/css/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start rather quickly by updating `index.html` to have the required div,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `ui` div is `position: absolute` so that it doesn''t "push" the
    `canvas` element below it. You can see how this will work by putting a standard
    HTML button in the `div` element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce a screen that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A New Game button!](img/Figure_8.01_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – A New Game button!
  prefs: []
  type: TYPE_NORMAL
- en: 'It won''t respond very well if you completely shrink the screen horizontally,
    but the game won''t work in that situation, so it should be fine. Now that we
    have a button, we''ll need to make it look like a game element, and for that,
    we''ll need styling. Go ahead and create a file named `styles.css` in the `static`
    directory, and add a link to it in `index.html`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, a link to an empty file doesn''t do much for us. To prove the link
    is working, go ahead and change the `index.html` file slightly, removing the inline
    style on the `ui` div so that it looks like `<div id="ui">`. This will cause the
    button to push the canvas element down, and your game will likely be slightly
    off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – New Game on top](img/Figure_8.02_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – New Game on top
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the CSS file, you''ll want to add a style for that div. It''s not really
    important that this style isn''t an inline one, except that this handily checks
    that our CSS file is being loaded. In the CSS file, insert the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a CSS selector for any elements with the `ui` ID and sets their position
    to `absolute`. If your CSS file is being loaded, then the new game button should
    be over the top of the canvas again. Later, we'll programmatically add that button
    in our game code, but for now, we just want it to show up and look right. We'll
    want to give it a font that looks like a video game, and a background too. Let's
    start with the font. In your assets, you'll see there is a directory called `ui`,
    which contains a file named `kenney_future_narrow-webfont.woff2`. **WOFF** stands
    for **Web Open Font Format** and is a font format that will work in every modern
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you''re unsure whether a feature will work with a browser, and sometimes
    when you are sure, check [https://caniuse.com/](https://caniuse.com/) to double-check.
    For WOFF files, you can see the results here: [https://caniuse.com/?search=woff](https://caniuse.com/?search=woff).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy `kenney_future_narrow-webfont.woff2` into the `static` directory in your
    application so that it gets picked up by the build process. Then, you need to
    specify `@font-face` in CSS so that elements can be rendered in it, which looks
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''ve done here is load a new font face with the simple name ''`Ken Future`''
    so that we can reference it in other styles, and loaded it via the specified URL.
    Now, we can change all buttons to use that font with this additional CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should see the button being rendered with a font that looks more like
    a game, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – New Game with the Kenney Future Font](img/Figure_8.03_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – New Game with the Kenney Future Font
  prefs: []
  type: TYPE_NORMAL
- en: The button still looks a lot like an HTML button because of that traditional
    web background. To make it look more like a game button, we'll use a background
    and CSS Sprites to create a pretty button with rounded corners and hover colors.
  prefs: []
  type: TYPE_NORMAL
- en: CSS Sprites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a game developer, you already know what a sprite is; you haven't forgotten
    [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*,
    already, have you? In the case of **CSS Sprites**, the term as commonly used is
    a bit of a misnomer, as instead of referring to a sprite, it really refers to
    a sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, CSS Sprites work the same way as rendering them with the canvas.
    You slice out a chunk of a larger sprite and only render that portion. We'll just
    do the entire thing in CSS instead of Rust. Since we're using CSS, we can change
    the background when the mouse is over the button and when it is clicked. This
    will make the button look correct, and we won't have to write Rust code to have
    the same effect. Clicking a button is something a browser is very good at, so
    we'll leverage it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the `Button.svg` file from the `ui` directory in the downloaded
    assets, so you can copy that file to the `static` directory in your game''s project.
    The SVG file actually contains an entire library of buttons, which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The top of Button.svg](img/Figure_8.04_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The top of Button.svg
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll want to slice out the wide blue, green, and yellow buttons to be the
    background for the button in various states. We''ll start by using the `background`
    attribute in CSS to set the button''s background to the SVG file. You''ll update
    the style as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The pixel values in `background`, `-72px` and `-60px`, mean taking the background
    and shifting it `72` pixels to the left and `60` pixels upward to line it up with
    the blank blue button. You can get those values in a vector graphics editor such
    as `url` value specifies which file to load. Make those changes, and you'll see
    the button change to have a new background… well, sort of.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The button, but with a cut-off background](img/Figure_8.05_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – The button, but with a cut-off background
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the background is cut off, so you only get half of it, and
    the button itself still has some of the effects of a default HTML button. We can
    get rid of those effects with a little more CSS to remove the border and resize
    the button to match the background, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `width` and `height` values were plucked from *Inkscape~ again, and that
    will set the button to be the same size as the button background in the source.
    As with the sprite sheets we used earlier, we need to cut out a slice from the
    original source, so in this case, there is a rectangle starting at `(72, 60)`
    with a width and height of `82x33`. With those changes, the button now looks like
    a game button instead of a web button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – A New Game button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – A New Game button
  prefs: []
  type: TYPE_NORMAL
- en: There are still a few problems. The button now doesn't visually interact with
    the user, so it just looks like a picture when you click it. We can address that
    with CSS pseudo-classes for `#active` and `#hover`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some browsers, notably Firefox, will render **New Game** on one line instead
    of two.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on pseudo-classes, check the Mozilla documentation here:
    [https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes).'
  prefs: []
  type: TYPE_NORMAL
- en: In each pseudo-class, we'll change the background attribute to line up with
    another background. Again, the numbers were pulled out of Inkscape, with a little
    tweaking once they were added to make sure that they lined up. First, we can handle
    the `hover` style, which is when the mouse is over the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'That produces a hover button that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 8.7 – Hover'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Hover
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll add the `active` style, which is what the mouse will look like
    when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That produces a clicked button like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Active](img/Figure_8.8_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Active
  prefs: []
  type: TYPE_NORMAL
- en: 'The final issue is that our button is really small, for a game anyway, and
    is positioned at the upper-left corner. Making the button larger the traditional
    CSS way with width and height is problematic, as shown here when we change the
    width value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – That is not a button](img/Figure_8.09_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – That is not a button
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the width or height will mean changing the "slice" that we''re taking
    from the sprite sheet, so we don''t want that. What we''ll use instead is the
    CSS `translate` property, with the `scale` function, which looks like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a nice large button with the right background, but it's not in
    the right spot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – The button with the left side cut off](img/Figure_8.10_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – The button with the left side cut off
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the button is large and looks like a game button, we just need to
    put it in the right spot. You can do that by adding `translate` to the `transform`
    property, where `translate` is a fancy way of saying `move`. You can see that
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will get the new game button into, roughly, the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – A New Game button!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – A New Game button!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Centering a button in a div requires a little more CSS than I want to cover
    in this book. Since we''re positioning things manually, we can go with "good enough"
    for now. If you''re more comfortable with web development, feel free to make it
    truly perfectly centered. If you''re interested in getting the perfect center
    with Flexbox, take a look here: [https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989](https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989).'
  prefs: []
  type: TYPE_NORMAL
- en: The new game button now shows up, but it doesn't do anything because our code
    isn't doing anything with `onclick`. It's just a floating button, taunting us
    with its ineffectiveness. Go ahead and remove the `button` element from `index.html`,
    but keep `div` with the `ui` ID. Instead, we'll use Rust to dynamically add and
    remove the button when we need it and actually handle the clicks. For that, we'll
    want to make some additions to our `browser` and `engine` modules, so let's dig
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the button with Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve written HTML to show the button and it looks pretty good, but we''ll
    actually need to show it and hide it on command. This means interacting with the
    browser and using the `browser` module. We haven''t done this in a while, so let''s
    refresh our memory on how we translate from the JavaScript we''d write traditionally
    to the Rust with `web-sys` that we''ll be using. First, we''ll need code to insert
    the button into the `ui` div. There are lots of ways to do this; we''ll use `insertAdjacentHTML`
    so that we can just send a string from our code to the screen. In JavaScript,
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the docs for this function at [https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML).
    When it comes to looking up browser APIs, the **Mozilla Developer Network** (**MDN**)
    is your friend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We spent a lot of time translating this kind of code into Rust in [*Chapter
    2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*, and [*Chapter
    3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063), *Creating a Game Loop*, but
    let''s refresh our memory and appease any monsters who read books out of order.
    Any JavaScript function or method is likely to be found in the `web-sys` crate
    with the name converted from PascalCase to snake_case, and with most of the functions
    returning `Option`. Frequently, you can just try that out, and it will work. Let''s
    create a new function in `browser` and see whether that''s the case, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This `draw_ui` function assumes there is a div with the `ui` ID, just as the
    `canvas` function assumes an ID of `canvas`. This means it's not *incredibly*
    generic, but we don't need a more complex solution right now. If we do later,
    we'll write more functions. As always, we don't want to go too far with some idea
    of "perfect" code because we've got a game to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the Rust version of the code is much longer, using `and_then` and
    mapping errors to make sure we handle the error cases instead of just crashing
    or halting the program as JavaScript would. This is another case where code is
    aesthetically less pleasing in Rust but, in my opinion, better because it highlights
    the possible causes of an error. The other function we''ll need right away is
    used to hide the `ui` element, which looks like this in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This function grabs the first child of the `ui` div and removes it with the
    `removeChild` method. To be completely thorough, we should loop through all the
    `ui` children and make sure they all get removed, but we don''t do that here because
    we already know there''s only one. We also remove the children (and don''t just
    set their visibility to hidden) so that they do not affect the layout, and any
    event listeners are removed. Once again, you''ll want to translate JavaScript
    to Rust. In this case, `firstChild` becomes the `first_child()` method and `removeChild`
    becomes `remove_child`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function is a little different than `draw_ui`, in part because `first_child`
    being missing isn't an error; it just means you called `hide_ui` on an empty UI,
    and we don't want that to error. That's why we use the `if let` construct and
    just return an `Ok(())` explicitly if it isn't present. The `ui` div was already
    empty, so it's fine. In addition, there's that weird call to `map(|_removed_child|
    ())`, which we call because `remove_child` returns the `Element` being removed.
    We don't care about it here, so we are, once again, explicitly mapping it to our
    expected value of unit. Finally, of course, we address the error with `anyhow!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function reveals some duplication, so let''s go ahead and refactor it
    out in the final version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've replaced both of the repetitive `document().and_then` calls with
    calls to `find_ui`, which is a private function that ensures we always get the
    same error when UI isn't found. It streamlines a little bit of code and makes
    it possible to use the `try` operator in `draw_ui`. The `find_ui` function returns
    `Element`, so you need to make sure to import `web_sys::Element`.
  prefs: []
  type: TYPE_NORMAL
- en: We've got the tools we need to draw the button set up in `browser`. To show
    our button programmatically, we can just call `browser::draw_ui("<button>New Game</button>")`.
    That's great, but we can't actually handle doing anything on the button click
    yet. We have two choices. The first is to create the button with an `onclick`
    handler such as `browser::draw_ui("<button onclick='myfunc'>New Game</button>")`.
    This will require taking a function in our Rust package and exposing it to the
    browser. It would also require some sort of global variable that the function
    could operate on. If `myfunc` is going to operate on the game state, then it needs
    access to the game state. We could use something such as an event queue here,
    and that's a viable approach, but it's not what we'll be doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re going to do instead is set the `onclick` variable in Rust code,
    via the `web-sys` library, to a closure that writes to a channel. Other code can
    listen to this channel and see whether a click event has happened. This code will
    be very similar to the code we wrote in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*, for handling keyboard input. We''ll start with a function
    in the `engine` module that takes `HtmlElement` and returns `UnboundedReceiver`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to bring `HtmlElement` into scope with `use web_sys::HtmlElement`.
    This doesn''t do much, and it sure doesn''t seem to have anything to do with a
    click, and it''s not obvious why we need an `UnboundedReceiver`. When we add a
    click handler to the button, we don''t want to have to move anything about the
    game *into* the closure. Using a channel here lets us encapsulate the handling
    of the click and separate it from the reacting to click event. Let''s continue
    by creating the `on_click` handler, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The changes we've made are to make `click_sender` mutable and then move it into
    the newly created closure called `on_click`. You may remember `closure_wrap` from
    the earlier chapters, which needs to take a heap-allocated closure, in other words
    a `Box`, which, in this case, will be passed a `mouse` event that we're not using
    so we can safely skip it. The casting to `Box<dyn FnMut()>` is necessary to appease
    the compiler and allow this function to be converted into `WasmClosure`. Inside
    that, we call the sender's `start_send` function and pass it a unit. Since we're
    not using any other parameters, we can just have the receiver check for any event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll need to take this closure and assign it to the `on_click` method
    on `elem` so that the button actually handles it, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We've added the call to `elem.set_onclick`, which corresponds to `elem.onclick
    =` in JavaScript. Note how we pass `set_onclick` a `Some` variant because `onclick`
    itself can be `null` or `undefined` in JavaScript and, therefore, can be `None`
    in Rust and is an `Option` type. We then pass it `on_click.as_ref().unchecked_ref()`,
    which is the pattern we've used several times to turn `Closure` into a function
    that `web-sys` can use.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also make sure to forget the `on_click` handler. Without this, when
    we actually make this callback, the program will crash because `on_click` hasn't
    been properly handed off to JavaScript. We've done this a few times, so I won't
    belabor the point here. Now that we've written all the code, we'll need to show
    a button and handle the response to it, and we need to integrate it into our game.
    Let's figure out how to show the button.
  prefs: []
  type: TYPE_NORMAL
- en: Show the button on game over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can show and hide the button in the `Game` `update` method by checking on
    each frame if the game is over and if the button is present, ensuring that we
    only show or hide it once, and that would probably work, but I think you can sense
    the spaghetti code beginning to form if we do that. In general, it's best to avoid
    too much conditional logic in `update`, as it gets confusing and allows for logic
    bugs. Instead, we can think of every conditional check that looks like `if (state_is_true)`
    as two different states of the system. So, if the new game button is shown, that's
    one game state, and if it isn't, that's another game state. You know what that
    means – it's time for a state machine.
  prefs: []
  type: TYPE_NORMAL
- en: A state machine review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing
    Animations with State Machines*, we converted RHB to a state machine in order
    to make it change animations on events easily and, more importantly, correctly.
    For instance, when we wanted RHB to jump, we went from `Running` to `Jumping`
    via a typestate method, only changing the state one time and changing the velocity
    and playing the sound one time. That code is reproduced here for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The typestates work great, but they are also noisy if we don''t need that kind
    of functionality. That''s why in that same chapter, we chose to model our game
    itself as a simple `enum`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to change significantly because we now have a problem that necessitates
    a state machine. When RHB is knocked out, the game is over, and the new game button
    should appear. That''s a side effect that needs to happen once, on a change of
    state, the perfect use case for our state machine. Unfortunately, refactoring
    to a state machine is going to require a not insignificant amount of code because
    our current method for implementing state machines is elegant but a little noisy.
    In addition, there''s actually two state machines at work here, which is not obvious
    at first. The first is the one we see at the beginning, moving from `Loading`
    to `Loaded`, which you can think of as when you don''t have `Walk` and when you
    do. The second is the state machine of `Walk` itself, which moves from `Ready`
    to `Walking` to `GameOver`. You can visualize it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_8.12_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Nested state machines
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have two state machines here, one going from `Loading` to
    `Loaded` and the other representing the three game states of `Ready`, `Walking`,
    and `GameOver`. There is a third state machine, not pictured, the famous `RedHatBoyStateMachine`
    that manages the `RedHatBoy` animations. A couple of the states pictured mimic
    the states in `RedHatBoyStateMachine`, where `Idle` is `Ready` and `Walking` is
    `Running`, so there is a temptation to move `RedHatBoyStateMachine` into `WalkTheDogStateMachine`.
    This could work, but remember that `Walk` doesn''t have a "jumping" state and
    so, by doing that, you''ll need to start checking a Boolean, and the modeling
    starts to break down. It''s best to accept the similarity because the game is
    heavily dependent on what RHB is doing, but treat `RedHatBoyStateMachine` as having
    more fine-grained states. What *does* work is turning `Loading` and `Loaded` into
    `Option`. Specifically, we''ll model our game like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This code isn''t meant to be written anywhere yet; it''s just here for clarity.
    There''s a big advantage to using `Option` here, and it has to do with the way
    our `update` function works. For clarity, I''m going to reproduce a section of
    our game loop here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The key part here is the `game.update` line, which performs a mutable borrow
    on the `game` object instead of moving it into `update`. This is because once
    `game` is owned by `FnMut`, it can''t be moved out. Trying to actually leads to
    this compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Mutable borrows such as this are tricky because they can make it more challenging
    to navigate the borrow checker as you proceed down the call stack. In this case,
    it becomes a problem if we try to implement another state machine in the same
    manner as `RedHatBoyStateMachine`. In our state machine implementation, each `typestate`
    method consumes the machine and returns a new one. Now, let''s imagine that we
    are modeling the entire game as `enum`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In order to make this work with the mutable borrow in `update`, we would have
    to clone the entire game on every state change because the `from` function couldn't
    take ownership of it. In other words, the closure in our `game.update` function
    *lends* `game` to the `update` function. This can't turn around and *give* it
    to the `from` function – it doesn't own it! Doing so requires cloning the entire
    game, potentially on every frame!
  prefs: []
  type: TYPE_NORMAL
- en: 'Modeling the game as holding an optional `WalkTheDogStateMachine` has two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: We can call `take` on `Option` to get ownership of the state machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type reflects that the state machine isn't available until the game is loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are, naturally, many ways to model our game type, and some of them are
    going to be better than the one we'll choose here. However, before you start trying
    to do a "simpler" version of this type, let me warn you that I tried several different
    variations on this solution and ultimately found using `Option` to be the most
    straightforward choice. Several other implementations either ended with complex
    borrowing or unnecessary cloning. Be wary, but also be brave. You may find a better
    way than I did!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before we dig into the actual implementation, which is fairly long, let's go
    over the design we're implementing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Before](img/Figure_8.13_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Before
  prefs: []
  type: TYPE_NORMAL
- en: It's pretty simple, but it doesn't do all that we need it to. Now, let's redesign
    the state machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – After'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – After
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, that's a lot more code, and it doesn't even reflect the details of the
    implementation, or the `From` traits we write to make it easy to convert between
    the `enum` values and structs. Writing some macros to handle state machine boilerplate
    is out of the scope of this book, but it's not a bad idea. You might wonder why
    every state holds its own `Walk` instance when every single state has it, and
    that's because we're going to change `Walk` on the transitions and the individual
    states don't have easy access to the parent `WalkTheDogState` container data.
    However, where possible, we'll move common data out of `Walk` and into `WalkTheDogState`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This section has a lot of code, and the snippets tend to only show a few lines
    at a time so that it's not too much to process. However, as you're following along,
    you may wish to reorganize the code to be easier to find. For instance, I prefer
    to work top-down in the `game` module, with constants at the top followed by the
    "biggest" `struct`, which is `WalkTheDog` in this case, followed by any code it
    depends on, so that the call stack flows down the page. This is how [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8)
    is organized. You're also welcome to start breaking this up into more files. I
    won't, to make it easier to explain in book form.
  prefs: []
  type: TYPE_NORMAL
- en: Redesigning to a state machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a true refactoring, we would make sure the game was in a running state after
    each change, but our changes are going to cause cascading compiler errors, meaning
    we're going to be broken for a while, so this change isn't truly a refactoring
    but more of a redesign. When you make this kind of change, you should absolutely
    get to a compiling state as quickly as possible and stay there as long as possible,
    but while I did that when writing this chapter, I'm not going to put you through
    all the intermediate steps. We'll move forward as if we know in advance that our
    design is going to work because we do this time, but don't try this at home. If
    you're a regular Git user, now is an excellent time to create a branch, just in
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by replacing this code in the `game` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will cause compiler errors all over the place. This is the section where
    we'll take the shortcut of letting the compiler be broken temporarily while we
    implement the state machine, if only to make sure this chapter isn't a thousand
    pages long. So, if you're uncomfortable working with a broken code base for a
    long time, that's good – just trust that I was *brilliant* and got this all right
    on the first try. Pretend – it'll be okay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re psychic and know exactly how this design is going to work out,
    we can go and push ahead, knowing that eventually, everything will come together
    without errors. This first change is exactly what we discussed earlier – `enum
    WalkTheDog` becomes a struct holding its `machine` instance, which is an `optional`
    field. Currently, `WalkTheDogStateMachine` doesn''t exist, so we''ll add that
    next, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When we implement a state machine in Rust, we need `enum` as a container for
    states so that `WalkTheDog` doesn''t need to be a generic `struct`. We''ve moved
    the compiler errors down because there is no `WalkTheDogState` and no states defined.
    Let''s do that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, the various typestates, `Ready`, `Walking`, and `GameOver`, don''t
    store any data. This will change a little as we go on, but all of the typestates
    have `Walk` so that they can be saved in the common `WalkTheDogState` struct.
    Now that we''ve created the state machine, we need to look at where the old version
    of `WalkTheDog` was used. The first is in the small `impl` block for `WalkTheDog`,
    in the old code where we created `enum`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s not going to work, and it''s not compiling, so instead, let''s replace
    it with an empty `WalkTheDog` instance, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This change replaces the old, and not used, `enum` with `machine` set to `None`.
    You can now think of `None` as the `Loading` state, and when a machine is present,
    you are `Loaded`. Speaking of loading, the next logical place to make changes
    is in the `Game` implementation for `WalkTheDog`. Looking at the `initialize`
    function that we''ve been in so many times, you''ll see a compiler error here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `match self` line is not going to work anymore because `self` isn''t `enum`.
    What we need to do instead is match `machine`, and if it''s `None`, then load
    the new machine, and if it''s present, then use `Err` in the same way we do now
    because `initialize` was somehow called twice. We can start by replacing both
    halves of the `match` statement, so the match should start as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Look closely to see that we now match on `self.machine`, and we match against
    `None`. Before we dig into the `None` match arm, let''s quickly change the match
    on `WalkTheDog::Loaded(_)`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This simply changes `WalkTheDog::Loaded` to `Some`, using the same error message.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In order to get clearer error messages, you can `#[derive(Debug)]` on the `WalkTheDog`
    struct. Doing that has cascading effects because everything it depends on also
    has to `#[derive(Debug)]`, so we won't do that here, but it's a good idea, especially
    if you're running into issues here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that both halves of the match properly match an `Option` type, we need
    to modify `initialization` to return the proper type. At the bottom of the `None`
    branch, you will want to create a state machine like the one shown here, right
    before returning the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to the code before; the construction of `Walk` is unchanged,
    but it's obscured by all the state machine noise. We are binding the `machine`
    variable to `WalkTheDogStateMachine::Ready` with the initialized `WalkTheDogState`
    instance, which, in turn, sets its internal `_state` value to `Ready`, and with
    the state getting to have `Walk`. It's noisy, and after we get this file back
    to compiling, we'll do true refactoring to make that line a little cleaner, but
    put a pin in that for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we made it so that `initialize` returns a new `Result<Box<dyn Game>>`
    a while back, so we''ll need to return a new `Game` instance next. So, right after
    adding `machine`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Given that `initialize` takes `self` and doesn't really use it, it's debatable
    whether it should be in the `Game` trait. Creating a separate trait, such as `Initializer`,
    will require a lot of modifications and is an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: This takes care of making sure `initialize` returns a game with a machine in
    the right state. We have two more big trait methods, `update` and `draw`, to take
    care of, and `update` is filled with compiler errors, so let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Spreading update into the state machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `update` function is filled with compiler errors, is the core of the game''s
    behavior, and has an additional challenge. Instinctively, you might think you
    can modify the beginning of the function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if let Some(machine) = self.machine` line will eventually fail to compile
    with the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you may try, as I did, to fix this by changing the line to `if let Some(machine)
    = &mut self.machine`. This will work until you try to implement a transition on
    `WalkTheDogState`. Because you have a borrowed machine, you''ll also have a borrowed
    state when you later match on the state, as with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `state` value is borrowed, unlike in most other cases where the match
    arms take ownership of the value, and it''s not instantly obvious. It will be
    if we write a transition from `Ready` to `Walking`. In order to write `state._state.run_right()`
    and get to `Walking`, your transition will need to look like this in order to
    compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are transitioning from `&mut WalkTheDogState<Ready>>` to `WalkTheDogState<Walking>`,
    which is an odd conversion and a hint that this is wrong. What you can''t see
    is that this code won''t compile. Returning the new `WalkTheDogState` with `walk`
    is a move that we cannot do because `state` is borrowed. The `start_running` method
    doesn''t own `state`, so it can''t take ownership of `state.walk` and, therefore,
    can''t return the new instance. The workaround for this is to clone the entire
    `Walk` each time we transition, but there''s no need for that inefficiency. We
    can, instead, take ownership of `machine` all the way back up in the `Game` implementation,
    through the aptly named `take` function. Instead of using a mutable borrow on
    the machine, we''ll call `take`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same code as earlier, but instead, we call the `take` method on
    `Option<WalkTheDogStateMachine>`. This replaces the state machine in `self` with
    `None` and binds the existing `machine` to the variable in `if let Some(machine)`.
    Now, inside that scope, we have complete ownership of `machine` and can do whatever
    we like to it, before eventually calling `replace` on the state machine in `self`
    to move it back in at the end of this function. It''s a little awkward, but it
    gets around mutable borrows. It *also* introduces a potential error in that when
    control exits the `update` function, `machine` could still be set to `None`, effectively
    halting the game by accident. In order to prevent that from happening, before
    we continue updating this function, we''ll add `assert` just outside the `if let`
    statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this is a runtime error, not a compile-time one, but it''s going
    to let us know right away whether we mess up the next section. This `assert` may
    be overkill, because we are going to dramatically reduce the amount of code inside
    the `if let` block; in fact, it will be just one line. First, we''ll add a call
    to a non-existent function called `update` on our state machine, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after `if let Some(machine)`, add the `self.machine.replace(machine.update(keystate))`
    line. All the code below `replace` in the `if let` block is going to become part
    of various `update` functions in the implemented states, so what you''ll want
    to do is either cut and paste that code to some place you can get it, or just
    comment it out. Next, we''ll create `impl` on `WalkTheDogStateMachine` with this
    new `update` method, which will return the new state. An empty version of that
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can call that from the the `update` method in `Game`, which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update` method in `WalkTheDogStateMachine` is a little empty, and we should
    probably put some code in it. We could call `match self` in the update, and then
    write the behavior for each state in this `update` function, calling things such
    as `state._state.walk.boy.run_right()`, which would work but it is hideous. Instead,
    we''ll match on `self` and then delegate to the individual `state` types. This
    will result in a pretty redundant `match` statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw a variation of this pattern before in `RedHatBoyStateMachine`, where
    we have to match on each variant of `enum` in order to delegate to the state,
    and unfortunately, there''s not a great way around it. Fortunately, it''s small.
    This little `match` statement won''t compile because none of the `typestates`
    types have an `update` method. In fact, there are no implementations for the typestates
    at all. Let''s continue our delegation by creating placeholder implementations
    for all three of them, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It's worth refreshing our memory on how typestates work. A typestate is a structure
    that is generic over a state. So `WalkTheDogState<T>` is the structure, and we
    implement transitions between states by adding methods to implementations of `WalkTheDogState<T>`,
    where `T` is one of the concrete states. These placeholders all just return `self`,
    so `update` isn't doing anything yet. Look closely and you'll notice that `GameOver`
    doesn't take `KeyState` because it won't need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` method on `WalkTheDogStateMachine` tries to use `into` to convert
    each typestate back into `enum`, but we haven''t written those yet. Recalling
    [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing Animations
    with State Machines*, again, we need to implement `From` to convert back from
    the various states to the `enum` type. These are implemented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is boilerplate just to get things started, but it demonstrates how each
    of these works. The `update` method on `WalkTheDogStateMachine` uses `match` to
    get the `state` value on each variant. Then, the `update` method is called on
    the various typestates. Each `update` method returns the state it transitions
    into, although right now, they all return `self`. Finally, back in the `update`
    method on `WalkTheDogStateMachine`s, we call `into` to convert the typestate back
    into an `enum` variant.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might remember that for `RedHatBoyStateMachine`, we used a transition function
    and an `Event` `enum` to advance the state machine. The new `WalkTheDogStateMachine`
    enum has fewer events, so additional complexity isn't necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to think about what each state should actually do. Previously, every
    one of these states was kind of shoved together in the `Game` `update` method
    – for instance, the following old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the old system, if the game was `Loaded`, then `boy` could `run_right` if
    you pressed the `ArrowRight` button and could jump if you pressed `Space`. This
    worked fine, but it''s worth noting the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `run_right` function does nothing if RHB is already running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jump` and `slide` functions do nothing if RHB isn't running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We handle this quite well in our `RedHatBoyStateMachine`, and will continue
    to do so, but what this reveals is that once RHB starts moving to the right, we
    don't really care if the player has pushed the `WalkTheDogStateMachine`. When
    the game is `Ready`, we'll check whether the user has hit `ArrowRight` and transition
    the state. Otherwise, we'll just stay in the same state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify `WalkTheDogState<Ready>` to reflect this new reality. The first
    change to the function will be to do that check, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There's one type and one method that doesn't exist, so this code does not compile
    yet. The transition of `start_running` doesn't exist yet, although we discussed
    writing something like it. We also don't have the `ReadyEndState` type. Let's
    address that second one first.
  prefs: []
  type: TYPE_NORMAL
- en: We used this pattern earlier for any `typestate` method that can return more
    than one state, such as the `update` method on `Jumping` or `Sliding`. We create
    a new `enum` that can represent either of the return states. In the case of the
    `update` method for `WalkTheDogState<Ready>`, the game can either still be `Ready`
    at the end of an update (`ReadyEndState::Continue`) or be done and transitioning
    to `Walking` (`ReadyEndState::Complete`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the `From` trait to convert from `ReadyEndState`
    to `WalkTheDogStateMachine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is some boilerplate that you've seen before. We have two states for `ReadyEndState`
    because there are two states that the `WalkTheDogState<Ready>` `update` method
    can end in. In order to get from `ReadyEndState` to `WalkTheDogStateMachine`,
    we create a `From` trait and match on both variants of `ReadyEndState` and extract
    their fields from them. Those are both typestates, `WalkTheDogState<Ready>` and
    `WalkTheDogState<Walking>`, respectively, so we use their `into` methods to convert
    them into the `WalkTheDogStateMachine` type. Those traits were already written
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `self.start_running` is still not going to work because we haven''t
    written it yet! What happens when the player hits `typestate` method named after
    the transition, which looks like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Let's refresh our memory on these. Every `state` transition is written as a
    method on the various typestates – in this case, `WalkTheDogState<Ready>`, where
    the source state is `self` and the return value is the destination state. Here,
    we transition from `Ready` to `Walking` by writing a method called `start_running`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual implementation isn''t doing much. We start by calling `self.run_right`,
    which doesn''t exist yet, so we have to write it. After sending RHB running, we
    transition into the `Walking` state by returning a new `WalkTheDogState` instance
    with `_state` of `Walking`. Take a close look at the function signature for `start_running`
    and you''ll notice it takes `mut state`. This means taking exclusive ownership
    over `self`, which we can do because we have complete ownership of everything
    in the state. That is one of the reasons we created `Option<WalkTheDogStateMachine>`
    originally! However, it''s not obvious why we take `mut state` here instead of
    `state`, in part because `run_right` doesn''t exist. When we add our new delegation
    method, that should become clear, so let''s do that right now with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This function on `WalkTheDogState<Ready>` calls `run_right` on `boy` through
    its walk field. The `run_right` method on `boy` requires a mutable borrow, and
    that's why we require a mutable borrow on the previous delegate. It's also why
    we needed to take `mut state` in the `start_running()` method earlier. You can't
    mutably borrow something that isn't mutable in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep the code clean, we're doing a little more delegation now than
    we were earlier. This makes our methods smaller and easier to understand, but
    the trade-off is that the behavior will be spread across multiple places. I think
    in the end, this will make our code easier to think about, because we won't have
    to consider too much code at any one time, so the trade-off is worth it. We'll
    have to be careful that we don't lose track of any of our original code as we
    break it up into chunks and spread it around.
  prefs: []
  type: TYPE_NORMAL
- en: Re-implementing draw
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we've removed all the compiler errors in the original `update` method,
    in part by removing a large chunk of its functionality, and we can continue by
    updating the `Walking` state to ensure that it's working, but I believe that's
    a long time without any meaningful feedback from the game. After all, at this
    point, the game doesn't compile and doesn't draw. How do we know anything is working?
    Let's instead take a moment and update the `Game` `draw` method so that we can
    actually get the code to compile again and see how it's working.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `draw` method will start by taking a page from the `update` method and
    replacing its current implementation with a delegation to `WalkTheDogStateMachine`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There are two things that are a little different from the changes we made to
    update. The first is that we only borrow `self.machine` because we don't need
    mutable access. We also still clear the screen at the top of `draw`. That happens
    on every state change, so there's no reason to not just do it then. Besides, it
    will help us debug if we make any mistakes, since the screen will turn white.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue the delegation by adding a `draw` method to `WalkTheDogStateMachine`
    that can extract the state from each case for drawing, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This is virtually identical to the `update` method we wrote earlier, except
    on a borrowed `self` instead of consuming `self`. The rest is just delegations
    to the various states. Unlike update, every state draws in the exact same way,
    so we can fill those in with one method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Any state will delegate `draw` to `Walk` because the drawing doesn''t actually
    change based on state. We can finally go ahead and re-implement the `draw` method,
    this time on `Walk`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This code is not new, but I don't blame you if you forgot it. It's our old `draw`
    code from [*Chapter 6*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139), *Creating
    an Endless Runner*, only with the `walk` variable replaced by `self`. The rest
    is identical.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you'll notice something exciting – the code compiles again! But
    if you look closely at the game, you'll see that it's a little static.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Stand very still….](img/Figure_8.15_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Stand very still….
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat Boy has stopped animating! He doesn't do his little idle animation because
    we're not calling `update` like we used to; it's almost time to go back to fixing
    the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring initialize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we proceed with restoring functionality, you might remember that I said
    the creation of `WalkTheDogStateMachine` was "obscured by all the state machine
    noise." Specifically, it looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To create `WalkTheDogStateMachine` required creating its `Ready` variant and
    passing a `WalkTheDog` state with its `_state` variable set to `Ready`. In addition
    to being noisy, it requires you to remember the correct initial state of the state
    machine. That's what constructors are for!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a constructor for `WalkTheDogState<Ready>`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it easier to create a new typestate of `WalkTheDogState<Ready>`;
    accepting `Walk`, it needs to be valid. Let''s also make it easier to create the
    entire machine, with a smaller constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor creates the entire machine with the right state and passes
    it `Walk`. Now that we''ve made these helper methods, we can make the change to
    the original initialize method, making it a little bit easier to read by using
    the `WalkTheDogStateMachine` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: It's a small change, but makes it both easier to read and safer, too. Doing
    the right thing, creating `WalkTheDogStateMachine` in the `Ready` state is easy
    to do, and creating it in the wrong state is not.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've finished that little digression, we can go back to finishing
    the update method as planned.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This segment of the *original* `update` function in `Game` reveals what is
    missing from our current code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after all the checks for button presses, we were updating `boy`.
    Let''s go ahead and add that to our new version of the `update` function in the
    `WalkTheDogState<Ready>` implementation, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: There are two changes here, so don't forget to change `update` to accept `mut
    self` now instead of `self`. It's hiding there in the function signature. Also,
    we've added a call to `self.walk.boy.update()` to start updating the boy again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do that and you''ll see RHB idling again, ready to start chasing down his invisible
    dog. But if you hit the right arrow, RHB freezes, one frame into his running animation.
    That is not what we want, and intriguingly, there are no errors in the console
    log because no exceptions are being thrown. It''s just that the `Walking` state
    doesn''t do anything in its `update` function. We can restore that code by putting
    back some of the code we earlier commented out/copied/deleted into the `Walking`
    state of the game, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In `WalkTheDogState<Walking>`, we've modified the `update` method to take a
    `mut self` and then restored most of the old `Game` `update` code. Rather than
    showing the entire method, I've just reproduced the beginning and end of the code
    snippet and elided the middle; you can safely cut and paste all the original code.
    There are a few changes to make the code fit its new location. Where the original
    code would read `walk.boy`, it now reads `self.walk.boy`. I also took the opportunity
    to rename `velocity`, which is a little vague, to `walking_speed` to clarify that
    it refers to how fast RHB walks. The final change we've made is taking out the
    `if keystate.is_pressed("ArrowRight")` code because there's no reason to check
    for that keypress anymore. Lastly, we return `self` because there's not yet any
    way to transition out of `WalkTheDogState<Walking>`. If you do this all correctly,
    you'll find that your code compiles and runs! In fact, as of this moment, all
    of the behavior is restored, including the problem where we have to refresh to
    start a new game. How about we finally add a new game button right now, huh?
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you remember our originally planned behavior, and I don''t blame you if
    you don''t, we wanted to draw a new game button on the screen when RHB crashed
    and fell over. Then, when it''s clicked, we want to start a new game. For that
    to happen, we''ll need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether `RedHatBoyStateMachine` is `KnockedOut`, and if so, transition
    from `Walking` to `GameOver`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On that transition, draw the new game button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `onclick` handler so that when the button is clicked, we transition back
    to `Ready` with a new `Walk` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the transition to `Ready`, hide the button and restart the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All the code we wrote before was to make that change easier. Let''s see whether
    we were right about that:'
  prefs: []
  type: TYPE_NORMAL
- en: Transition from `Walking` to `GameOver`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To transition from `Walking` to `GameOver`, we need to return the `GameOver`
    state from the `WalkTheDogState<Walking>` `update` method, but when should we
    do that? We''ll need to see whether the *boy* is knocked out and then make the
    change. We don''t have that capability yet, so we''ll need to create it, and let''s
    work top-down, as we have been this entire chapter. First, we''ll change the `WalkTheDogState<Walking>`
    `update` method to check the non-existing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of always returning the `Walking` state, we return `WalkingEndState`,
    which doesn''t exist yet but will mimic the pattern we used in the `update` method
    on on `WalkTheDogState<Ready>`. When the current state is `knocked_out`, we will
    return the `Complete` variant holding an instance of the `WalkTheDogState<GameOver>`
    type. That will be the state returned from the `end_game` transition, which is
    also not written yet. Otherwise, we''ll return `Continue` with the current `WalkTheDogState<Walking>`
    state as its field. That''s two functions that don''t exist yet, `knocked_out`
    and `end_game`, along with a brand-new type. You can create the `WalkingEndState`
    type and its corresponding `From` trait to convert it into `WalkTheDogStateMachine`
    right now by following the same pattern we did for `ReadyEndState`. I won''t reproduce
    that code here. We''ll proceed from there by getting `knocked_out` working, which
    is going to be delegated from `Walk` to `RedHatBoyStateMachine` with some delegations
    in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We could pass `WalkTheDogState` to `RedHatBoyStateMachine` here to get the new
    state and follow the OO guideline of "tell, don't ask", but sometimes, you just
    want to check a Boolean. Here, we ask the `Walking` state, which asks `RedHatBoy`
    and finally `RedHatBoyStateMachine` whether it is knocked out. `RedHatBoyStateMachine`
    uses the handy `matches!` macro to check `self` against an `enum` variant, and
    return whether or not they match. Now that we can check whether Red Hat Boy is
    knocked out, we have just one compiler error – `` no method named `end_game` found
    for struct `WalkTheDogState` ``.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to implement the `end_game` transition method, which will represent
    our transition. We can start by implementing the transition to do nothing other
    than move `walk` from `Walking` to `GameOver`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This returns us to a compiled state and means that when RHB crashes and is knocked
    out, the game is in the `GameOver` state. However, it does nothing, so it's time
    for *step 2* – draw the new game button.
  prefs: []
  type: TYPE_NORMAL
- en: Draw the new game button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Many pages ago, I said: "To show our button programmatically, we can just call
    `browser::draw_ui("<button>New Game</button>")`." But when do we call it? Well,
    we call it now, right before creating the new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If you add this one line of code to the transition, you'll see the new game
    button we wrote way back at the beginning when our RHB crashes into a rock. There's
    a warning on this line because we don't handle the result of `draw_ui`, which
    we'll ignore for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `onclick` handler to the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to add the click handler to the button, we need to get a reference
    to the element we just drew. We don''t have that, as the `insert_adjacent_html`
    function doesn''t provide it, so we''ll need to find the button we just added
    to the screen so that we can attach an event handler to it. We''ve used `get_element_by_id`
    twice before on `document`, so it''s probably time to write a wrapper function
    in the `browser` module, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We've made a slight change to the way we've been finding elements in this function.
    Normally, we want `HtmlElement`, not a generic `Element` type, so in this function,
    we've gone ahead and added a call to `dyn_into` to make the conversion. Therefore,
    this function first gets the document, then gets the element, and finally, converts
    it into the `HtmlElement` type, all while normalizing the errors with `anyhow!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a way to find the element, we can return to the transition
    in `game`, find the newly added new game button, and then add a click handler
    to it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We've reproduced the entire transition trait here, but there are three changes.
    The first is that we've added `id` to the new game button; naturally, that's `new_game`.
    Then, we find the element in the document in the `and_then` block and use `map`
    to take that element and pass it to the recently created `add_click_handler` function.
    Now, we've got a small problem. We will need `receiver` to get click messages
    when they happen, but the `add_click_handler` function returns `Result` with `UnboundedReceiver`.
    The challenge is that the `end_game` function doesn't return `Result`. In [*Chapter
    9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing, Debugging, and
    Performance*, we'll investigate how to debug this kind of condition, but for now,
    we'll just grit our teeth and add `unwrap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `receiver` that will get a message whenever the player clicks
    `update` function for the `GameOver` state and when we receive the event transition
    to the `Ready` state. That''s going to mean adding the receiver to the `GameOver`
    struct, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This will prompt you to add the `use` declaration for `futures::channel::mpsc::UnboundedReceiver`.
    Now that `GameOver` `struct` has the field, we''ll need to pass it along in the
    transition, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This is the final change to this method, and it's just adding the field to `GameOver`.
    Interestingly it's the first time we've added a field to any of our state structures,
    but it's something you're likely to do more of over time as you extend this game.
    Various states have data that's unique to them, and they belong in the `state`
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to return to the `WalkTheDogState<GameOver>` implementation and
    its `update` method, which currently just returns the `GameOver` state, leaving
    the game in that state forever. Instead, we''ll want to check whether the new
    game event has happened (because the button was clicked) and then return the `Ready`
    state to start over again. That small bit of code is reproduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the `WalkTheDogState<GameOver>` implementation, we check the state to see
    whether the new game button has been pressed, and if it has, we return the `GameOverEndState::Complete`
    variant; otherwise, we return the `GameOverEndState::Continue` variant. This is
    the same pattern we've used in every other update method, and you can go ahead
    and reproduce the `GameOverEndState` enum and its corresponding `From` trait to
    convert the type to a `WalkTheDogStateMachine` enum. That code is not reproduced
    here, but remember that if you get stuck, you can find the sample code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8).
  prefs: []
  type: TYPE_NORMAL
- en: In the `GameOver` implementation, we have the details to check whether `new_game_event`,
    corresponding to the player's click, has happened. Calling `try_next` will return
    `Result` immediately, without blocking, or `Ok` if the channel is still open,
    regardless of whether anything is in it. Remember that we are running at 60 frames
    per second and cannot use the blocking calls. Finally, we use the handy matches!
    macro to check whether the channel was successfully sent a message of `unit`,
    or Ok(Some(())). If the event is there, `true`.
  prefs: []
  type: TYPE_NORMAL
- en: This code doesn't compile because we don't have a transition written from `GameOver`
    to `Ready`, which is what we'll write in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Restart the game on **New Game**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Restarting the game will mean doing two things on the `new_game` transition.
    The first is hiding the button or "UI," and the second is recreating `Walk` from
    scratch. The first is actually easier, so we''ll start with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This is another transition, this time from `GameOver` to `Ready`, with the side
    effect of hiding the UI. It then moves to a new state with the same walk we ended
    with, which is not quite what we want.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – I hit New Game – run, boy, run!](img/Figure_8.16_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – I hit New Game – run, boy, run!
  prefs: []
  type: TYPE_NORMAL
- en: 'The button is hidden but RHB is still knocked out. Moving from `GameOver` to
    `Ready` means creating a new `Walk` instance from the old one, so the game starts
    over. This is a bit of a challenge because we no longer have access to the various
    images and sprite sheets we used to create `Walk` and `RedHatBoy` in the first
    place. What we''ll do is clone those from an existing one, via a constructor function
    on the `Walk` implementation. We won''t call this `clone` because that term means
    an identical copy, whereas this is really a reset. You can see the implementation
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reset` function consumes `Walk` and returns a new one. It recreates `starting_obstacles`
    the same way they are created in `initialize`, and then recalculates `timeline`.
    Then, it constructs a new `Walk`, moving all the values from `Walk` except `starting_obstacles`
    and `timeline`. This function is not quite right though, as it will reset `Walk`
    but leave `boy` in its `KnockedOut` state. We''ll need a similar `reset` function
    for `boy`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Writing `reset` on `RedHatBoy` is a lot easier than it was on `Walk` because
    we created a constructor function, `new`, for `RedHatBoy` a long time ago. We
    should do the same for `Walk`, but that refactoring is up to you. Keep in mind
    that for this to compile, the `audio` and `jump_sound` fields on `RedHatBoyContext`
    need to be public.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a `reset` function for `RedHatBoy`, we can use it in the `Walk`
    `reset` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to call this in the original transition from `GameOver` to `Ready`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If you do all that, you'll find that when you click the new game button, the
    game resets and the player is back at the start. You should be able to hit the
    right arrow key and start walking again. You *should*, but it doesn't work because
    we haven't accounted for one feature of the UI – the focus.
  prefs: []
  type: TYPE_NORMAL
- en: Focus!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It turns out there's one more thing to do when we click the new game button
    to make the game ready to play again. When the game was started, we set up the
    canvas to have the focus so that it would receive keyboard input. We did this
    with the `tabIndex` field in the original HTML. When the player clicks **New Game**,
    they transfer the focus to the button and then hide the button, which means nothing
    will get the keyboard events we are listening to. You can see this effect by clicking
    **New Game** and then clicking the canvas after the button disappears. If you
    click the canvas, it regains the focus, and you can play the game again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can transfer the focus back to the canvas automatically in the `hide_ui`
    function of the `browser` module. It''s debatable whether it belongs here, since
    you may have cases where you want to hide the UI but not reset the focus, but
    our game doesn''t have that case, so I think we''re safe. This change is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: After the first call to `map_err` for removing the child, we've added a second
    `and_then` call, which takes `unit` from the earlier `map` call, promptly ignores
    it, and then requests `focus` on `canvas`. The error from the `focus` call doesn't
    return an `anyhow!` type, so the compiler complains, and we fix that with a `map_err`
    call. The `focus` function is a JavaScript function we call through `web-sys`,
    which is documented on the MDN ([https://mzl.la/30YGOMm](https://mzl.la/30YGOMm)).
  prefs: []
  type: TYPE_NORMAL
- en: With that change, you can click **New Game** and start another try. We did it!
  prefs: []
  type: TYPE_NORMAL
- en: Pre-loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might notice that the button visibly loads when it shows up on screen –
    that is to say that the image and font aren''t downloaded to the browser yet,
    so it doesn''t appear instantaneously. This is standard behavior for web browsers.
    In order to make sure that you don''t have to wait for an entire page worth of
    images, fonts, and other assets to load before you see a page, browsers will load
    assets lazily. This is so common that your eyes may not have noticed it when the
    `Button.svg` and the `kenney_future_narrow-webfont.woff2` assets immediately when
    the page is loaded so that when the button appears, it''s instantaneous. Open
    the `index.html` file and make the changes shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `link` tag with the `preload` attribute will preload assets before rendering
    the page. You'll want to minimize this behavior generally because you don't want
    the user to have to wait a very long time with a blank screen, and if you were
    to make a very large game with many assets, you should probably use a more flexible
    solution in code with a loading screen. Our game is small right now, so this works
    perfectly well. With this change, the new game button not only appears but is
    snappy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can look at the end of this chapter in two ways. The first might be to say,
    "All that for a button?", and you would have a point. After all, our UI is only
    one new game button, and while that's true, we actually covered quite a bit. We
    have integrated the DOM into our app via `web-sys` and have, in turn, adjusted
    our game to handle it. By utilizing the DOM, we were able to leverage the browser
    for behavior such as clicks and hovers, without having to detect where within
    the canvas the mouse was and creating clickable areas. You can now create far
    more complex UIs using tools such as CSS Grid and Flexbox, so if you are familiar
    with web development, which you've been doing for this entire book, so you are,
    you'll be able to make quality UIs for your games. If you're looking for some
    place to start, try adding a score to this game. You can increment the score in
    the update, and show it at the end menu, or at the right corner during the game,
    or both! I look forward to seeing it.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we will move on from new feature development to making sure that
    our current features work, and work fast. It's now time to start doing some testing
    and debugging, so we'll dive into that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
