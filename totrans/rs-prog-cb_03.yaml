- en: Managing Projects with Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`cargo` is one of the unique selling points of Rust. It makes a developer''s
    life easy by making the creating, developing, packaging, maintaining, testing,
    and deploying of application code or tools to production considerably more enjoyable. `cargo` is
    designed to be the single go-to tool for working on any type of Rust project across
    multiple stages such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Project creation and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and executing builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency installation and maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing with other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging and publishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Especially in the domain of systems programming, tools such as `cargo` are
    still rare—which is why many large-scale users developed their own versions. As
    a young language, Rust draws from the aspects that other tools got right: the
    versatility and central repository of `npm` (for Node.js), the ease of use of `pip`
    (for Python), and many more. In the end, `cargo` provides many great ways to enhance
    the Rust experience and has been cited as a major influence for developers who
    want to adopt the language.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we cover recipes that enable developers to utilize all of the
    features of `cargo` to create production-grade Rust projects. These fundamental
    recipes serve as building blocks for referencing dependencies, adjusting compiler
    behavior, customizing tools, and many more things that are common in everyday
    Rust development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing large projects with workspaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading to `crates.io` ([https://crates.io](https://crates.io))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dependencies and external crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending `cargo` with sub-commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your project with `cargo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration with `cargo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing large projects with workspaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a single project is easy: run `cargo new my-crate` and it''s done.
    `cargo` creates everything from folder structure to a small source file (or unit
    test) in a breeze. However, what about larger projects consisting of multiple
    smaller crates and an executable? Or just a collection of related libraries? The `cargo` tool''s
    answer to this is called **workspaces**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create your own workspace to manage multiple projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Terminal window (Windows PowerShell or a Terminal on macOS/Linux), change
    to a directory that will hold the workspace by running these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `cargo new` command followed by its name to create a project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are talking about multiple projects, let''s add another library project
    that we can use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `a-project/src/main.rs` to contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add some code to `a-lib/src/lib.rs` that will `stringify` (using the
    `Debug` trait) an incoming variable. Obviously, that also needs some tests to
    show that the function works. Let''s add some tests to compare the outputs of
    number formatting and sequence formatting with `stringify`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add some configuration to the `Cargo.toml` files of each project to
    reference dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`a-project` now makes use of the `a-lib` library, but if we are developing
    these at the same time, the switching back and forth (for example, for testing
    `a-lib` after changes) will soon become cumbersome. This is where workspaces come
    in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `cargo` on both projects at the same time, we have to create `Cargo.toml`
    in `my-workspace`, the parent directory of `a-lib` and `a-project`. It only contains
    two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this file in place, `cargo` can execute commands on both projects simultaneously
    and thereby make handling them easier. Let''s compile `cargo test` and see which
    tests are run, along with their (test) results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As there is only one project that has tests (`a-lib`), it runs those. Let''s
    compile `cargo run` to see the output of running the binary executable project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a simple binary project (*step 2* and *step 4*) together
    with a library project (*step 3* and *step 5*) that depend on each other. We simply
    specify these dependencies in their `Cargo.toml` files in *step 6* and the workspace
    we created in *step 7* helps us to join the projects together. Now, any commands
    are run on the projects that support them.
  prefs: []
  type: TYPE_NORMAL
- en: 'By building this project (with `cargo run`, `cargo test`, or `cargo build`),
    the tool creates a file containing the current dependency tree (called `Cargo.lock`).
    As a workspace, the output directory for the binaries (`target/`) is also located in
    the workspace directory instead of the individual projects'' directories. Let''s
    check the contents of the directories to see what that looks like and where the
    compiled output can be found (emphasis has been added to the code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another aspect of workspaces is its dependency management. `cargo` synchronizes
    the external project dependencies inside the `Cargo.lock` file for every project
    contained within that workspace. As a result, any external crate will have the
    same version across every project whenever possible. When we added the `rand` crate
    as a dependency, it picked the same version for both projects (because of the
    `*` version in `a-lib`). Here''s part of the resulting `Cargo.lock` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo` workspaces are a way to handle larger projects by bundling some operations
    at a higher level while leaving most configurations to the individual crates and
    applications. The configuration is simple and results in predictable behavior
    that lets the user build processes around it (for example, collecting all binaries
    from the workspace''s `target/` directory).'
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting aspect is that `cargo` travels upward to find the most parental
    `Cargo.toml` file before executing a command. Therefore, what seems like the running
    of the tests of a specific project from within its directory results in the running
    of *all*tests of that workspace. Consequently, the commands have to be more specific
    now, for example, by using `cargo test -p a-lib`.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to organize large projects with workspaces. Now,
    let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Uploading to crates.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`crates.io` ([https://crates.io](https://crates.io)) is Rust''s public repository
    for community crates. This links dependencies together, enables discovery, and
    lets users search for packages. For crate maintainers, it offers usage statistics
    and a place to host a `readme` file. `cargo` makes it possible to publish crates
    quickly and easily, as well as to handle updates. Let''s see how.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to publish a crate with minimal functionality.
    If you already have source code to work on (that is, your own project), feel free
    to use it. If not, create a new library project using `cargo new public-crate
    --lib` and open it in VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b58444be-9d0c-4649-acaf-818c87121c82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to [https://crates.io](https://crates.io) and log in to your account (using
    [https://github.com](https://github.com)). Then, go to the Account Settings page
    to create a new token (follow the instructions on the page). Log in on the command
    line using your own token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9708bf28-ce3c-45cf-926c-5883bbb35916.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the steps we need to perform to upload to `crates.io` ([https://crates.io](https://crates.io)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `cargo` logged in and ready to go, follow these steps to publish the library
    to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `src/lib.rs` and add some code. The crate in our recipe is only going to
    publish the infamous bubble sort algorithm!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the moment, `crates.io` only uses names as identifiers, which means that
    you can't use the name `bubble-sort` any longer. However, instead of choosing
    a new name, we ask you not to publish a copy of this crate under a different name
    but focus your efforts on crates that are useful to the community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an implementation from the book *Hands-On Data Structures and Algorithms
    with Rust* ([https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust](https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: //!# use bubble_sort::bubble_sort;
  prefs: []
  type: TYPE_NORMAL
- en: //! let v = vec![2, 2, 10, 1, 5, 4, 3];
  prefs: []
  type: TYPE_NORMAL
- en: //! assert_eq!(bubble_sort(&v), vec![1, 2, 2, 3, 4, 5, 10]);
  prefs: []
  type: TYPE_NORMAL
- en: //![PRE12]
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation also comes with tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, `cargo` makes it possible to customize the landing page on `crates.io`
    using various fields in `Cargo.toml`. The landing page should inform the crate''s
    users about the license (no license means everybody has to get your permission
    to use the code), where to find more information, and maybe even an example. On
    top of that, (quite fancy) badges provide information about the crate''s build
    status, test coverage, and so on. Replace the content of `Cargo.toml` with the
    following snippet (and customize it if you want):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all of the metadata is sorted out, let''s run `cargo package` to see
    whether the package fulfills the formal criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As a friendly reminder, `cargo` makes sure that only committed changes are
    packaged, so the repository and `crates.io` are in sync. Commit the changes (read
    up on Git if you don''t know how: [https://git-scm.com](https://git-scm.com))
    and re-run `cargo package`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with an authorized `cargo`, let''s make our crate public and run `cargo
    publish`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once successful, check out your page at [https://crates.io/crates/bubble-sort](https://crates.io/crates/bubble-sort):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be51839e-e481-488c-b536-9b8fbb9b3e4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publishing crates is a great way to get recognized by the Rust community and
    make whatever you are creating available to a wider audience. For the community
    to be able to quickly adapt your crate, be sure to use appropriate keywords and
    categories, as well as examples and tests to make it clear and easy to use, something
    that we did in *step 1* and *step 2*. `Cargo.toml` provides many more options
    than specified previously, so check out the documentation, [https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata](https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata), to
    find out more.
  prefs: []
  type: TYPE_NORMAL
- en: The most important property in that file is the package name, which uniquely
    identifies the crate. While there have been incidents on name squatting and selling
    names, this is generally frowned upon and the community strives to find a solution
    to that.
  prefs: []
  type: TYPE_NORMAL
- en: Once packaged (*step 3* and *step 4*), `cargo` creates a `target/package` directory, which
    contains everything that will be uploaded to `crates.io`. Inside, there is not
    only the source code but also an additional binary file named `project_name-version.crate`.
    If you don't want to upload everything—for example, leaving out videos or large
    example data—`Cargo.toml` allows for exclusion filters as well. By default, everything
    in the directory is included, but it is good practice to keep the size to a minimum!
  prefs: []
  type: TYPE_NORMAL
- en: Keep your API tokens secret and out of source control. If you are not sure whether
    a token has been compromised, revoke it!
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 5*, we are uploading the new crate. However, `crates.io` does not
    accept just any upload; here are some examples of the errors you might encounter
    (observe the error messages to fix them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These are actually great notifications since these barriers help programmers
    to avoid simple mistakes, reduce spam, and thereby raise quality. If you follow
    those terms, you'll easily see a version of the step 6 page for your own project.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to upload to [https://crates.io](https://crates.io).
    Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Using dependencies and external crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reusing other libraries is a common task in software engineering, which is why
    easy dependency management was built into `cargo` from the start. Third-party
    dependencies (called **crates**) are stored in a registry called `crates.io` ([https://crates.io](https://crates.io)),
    a public platform for users to find and discover crates. Private registries are
    also available, starting with Rust 1.34\. With `Cargo.toml` as a central point
    in this process, let's dive into specifying those dependencies well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how dependency management works in these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to print on the command line, let's create a new binary application
    using `cargo new external-deps` and open it in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Cargo.toml` file to add some dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With these added, we need to add some code to the `src/main.rs` file as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, there is `dev-dependency`, which we can use to create benchmarks with
    the stable Rust compiler. For that, create a new folder on the same level as `src/`
    and add a file, `cooking_with_rust.rs`, there. Open it in VS Code and add the
    following code to run a benchmark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use these dependencies and see how `cargo` integrates them. Let''s
    execute `cargo run` first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It downloaded and compiled various crates (the download part was omitted as
    it is only done once)—but can you spot what''s missing? It''s the `criterion`
    crate that was specified as `dev-dependency`, and it''s only required for development
    (`test/bench/..`) operations. Let''s run `cargo bench` to see benchmark results
    of the crate, including some basic trends provided by `criterion` (output redacted):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By specifying the version and name in `Cargo.toml`, `cargo` can download and
    compile the required crates and link them into the project as needed. In fact,
    `cargo` maintains a cache for both crates on `crates.io` and raw `git` dependencies
    (check the `~/.cargo` directory), where it puts recently used crates. This is
    exactly what we did in the first steps by adding dependencies of mixed origin
    to the crate.
  prefs: []
  type: TYPE_NORMAL
- en: One of these origins is a  `git` repository, but can alternatively take the
    shape of local paths to directories. Additionally, by passing an object (as seen
    in the `regex` crate in *step 1*), we can specify features for a crate (as shown
    in the `serde` dependency in *step 1*) or use an entire section called `dev-dependencies` for
    dependencies that are not shipped in the target output. The result is a dependency
    tree that is serialized in `Cargo.lock`. The use of the `dev-dependency` criterion
    is shown in *step 6*. The remaining steps show how to use external dependencies
    and the various versions downloaded and compiled by `cargo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version specification in `Cargo.toml` is its own mini-language, and it
    will only upgrade with certain restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: A single number specifies the major version (a pattern of `<major>.<minor>.<patch>`
    is mandatory in Rust) but leaves the others open for `cargo` to decide (usually
    the latest version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More accurate versions leave less room for interpretation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` means any available version, with the latest preferred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more characters and symbols to put into the version string, yet these
    will typically suffice. Check out [https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html)
    for more examples. The `cargo upgrade` command will also check for the latest
    versions the specification allows and update them accordingly. If you plan to
    build a crate that is used by others, it's recommended to run `cargo upgrade` every
    once in a while to see it didn't miss any security/patch updates. The Rust project
    even recommends putting the `Cargo.lock` file in source control to avoid unintentionally
    breaking the crate.
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to minimize the number of required crates and to keep them
    as up to date as possible. Your users will want to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With 1.34, Rust also allows private repositories. Read more about this on the
    following blog post: [https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#alternative-cargo-registries](https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#alternative-cargo-registries). We've
    now successfully learned how to use dependencies and external crates. Now, let's
    move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Extending cargo with sub-commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These days, everything is extensible. Whether they are called plugins, extensions,
    add-ons, or sub-commands—everything is about customizing the (developer) experience.
    `cargo` provides a very easy path to achieve this: by using a binary''s name.
    This allows for quickly extending the `cargo` base to include functions that are
    specific to your own use case or way of working. In this recipe, we are going
    to build our own extension.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will stay on the command line and we will use a sample code
    for a simple binary, so open a Terminal/PowerShell (we are using PowerShell features
    on Windows) to run the commands in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extending `cargo` is surprisingly easy. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Rust binary application project with the following command: `cargo
    new cargo-hello`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change into the directory with `cd cargo-hello` and build it using `cargo build`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `target/debug` folder of the current project that is located at your
    `PATH` variable. On Linux and Mac (using bash), it''s simply as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, you can use PowerShell to achieve the same goal with this code
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Within the same window, you should now be able to run `cargo-hello` (`cargo-hello.exe`
    on Windows) from any directory on the computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Additionally, `cargo` can now run `hello` as a sub-command. Try running `cargo
    hello` in any directory on the computer. From here, you will see the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`cargo` picks up any executable starting with `cargo-` that''s available in
    the `PATH` environment variable. Directories listed in there are used to discover
    command-line executables in *nix systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `cargo` to integrate these extensions seamlessly, their names have to meet
    a few conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: These binaries have to be executable on the current platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name starts with `cargo-`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The containing folder is listed in the `PATH` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Linux/macOS, these executables can also be shell scripts—something that's
    very useful for improving the developer workflow. However, these scripts have
    to look just like a binary and therefore have no file ending. Then, instead of
    running several commands, such as `cargo publish`, `git tag`, and `git push`, `cargo
    shipit` can significantly improve speed and consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, any `cargo` sub-command can take command-line arguments that are
    passed after the command, and the working directory is the directory the command
    is run from by default. With that knowledge, we hope that you can now add to `cargo` features!
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to extend cargo with sub-commands. Now, let's
    move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Testing your project with cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in a previous recipe we focused on writing tests, this recipe is about
    *running *them. Tests are an important part of software engineering since it ensures
    that we put ourselves in the user's shoes and double-checked to see whether what
    we created is working. While many other languages require a separate test-runner, `cargo` comes
    with this functionality included!
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how `cargo` helps with this process in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To explore `cargo` testing capabilities, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project on the command line with `cargo new test-commands --lib`
    and open the resulting folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, replace the content in `src/lib.rs` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in other recipes, we can execute all tests with the `cargo test`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate quickly, `cargo` allows us to carry out a specific test as well
    by using `cargo test <test-name>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful way to run tests is without capturing their output. By default,
    the testing harness won''t print anything from inside the tests. Sometimes, it''s
    useful to have some testing output, so let''s use `cargo test -- --nocapture`
    to see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'All tests are run in parallel, which sometimes leads to unexpected results.
    To adjust this behavior, we can use `cargo test -- --test-threads <no-of-threads>`
    to control the number of threads. Let''s compare using four threads and one thread
    to see the difference. We will use the `time` program to show the runtime in seconds
    (this is optional if you don''t have `time`). Let''s start with four:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fast, compared to a single thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can also filter multiple tests as well, such as all tests starting
    with `wait`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's built-in testing library is called `libtest` and it is what's invoked
    by `cargo`. Regardless of the type of project created (binary application or library),
    `libtest` runs the associated test and outputs the result. In this recipe, we
    are examining running the tests of a previously created project—however, these
    steps obviously work for any project with tests.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we created a small library that features four tests, two of which
    print things to the command line just after waiting for a few seconds (five and
    ten seconds). This allows us to show threaded test running and that the test harness
    captures the output by default.
  prefs: []
  type: TYPE_NORMAL
- en: Other than filtering the list of available tests (we do that in *step 4* and
    *step 7*) in the project, `libtest` takes command-line arguments to customize
    the output, logging, threads, and many more things. Find out more by invoking
    `cargo test -- --help`. Note the double dashes (`--`), which tell `cargo` to pass
    any following arguments into `libtest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the options already indicate: all tests are run in parallel unless stated
    otherwise, an option that we change in *step 6* with noticeable results (15 seconds
    with a single thread versus 10 seconds multi-threaded—just like the longest sleep
    time). Use this option to debug race conditions or other runtime behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 5* uses an option to show the standard output, which appears in a different
    order than how we wrote the test functions. This is the result of concurrent execution,
    so combining the options to limit the number of threads with the output capture
    will linearly execute the tests. We conclude the steps by filtering for multiple
    tests in *step 7*.'
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to test our project with `cargo`. Now, let's
    move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration with cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation is an important aspect of today's software engineering. Whether it
    is infrastructure as code or functions as a service, many things are expected
    to automatically work as expected. However, the notion of a central testing and
    deployment infrastructure based on certain rules is much older (called **ALM**—**Application
    Lifecycle Management**) and with modern tools, it is incredibly easy. `cargo`
    was built to support this stateless infrastructure with reasonable defaults and
    an easy interface to customize them.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at how to build Rust applications using
    Microsoft's Azure DevOps platform as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the Azure DevOps repository ([https://azure.microsoft.com/en-us/services/devops/?nav=min](https://azure.microsoft.com/en-us/services/devops/?nav=min))
    is accessible for anyone, it is highly recommended to create a Microsoft account
    and make use of the free tier to reproduce the example. Go to [https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/) and
    follow the instructions to get started.
  prefs: []
  type: TYPE_NORMAL
- en: To have a ready-made project to work on, we are re-using the `bubble-sort` crate
    from the *Uploading to crates.io* recipe earlier in this chapter and uploading
    it to a source code hosting service such as Azure DevOps or GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a browser window and navigate to [https://dev.azure.com](https://dev.azure.com),
    sign in, and find the project you created. Then, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps is an all-in-one solution for project management, so we are pushing
    our source code to the available repository. Follow the repository setup guide
    to do that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pipelines are the continuous integration part of Azure DevOps. They orchestrate
    build agents (machines to run the build on) and provide a visual interface to
    put together a step-by-step build process. Create a new pipeline from an empty
    job template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a59bb95c-6db6-42ee-b3e4-2d2513b95f69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside each pipeline, there are several jobs—several steps that run on the
    same agent, but we only need one. Click on the + symbol on the right of the predefined
    Agent job 1 and search for a build task named `rust`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33bd03de-388b-418e-ac46-0766828371ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since that particular build task is available on the Marketplace (thanks to
    Sylvain Pontoreau: [https://github.com/spontoreau/rust-azure-devops](https://github.com/spontoreau/rust-azure-devops)),
    we have to add it to our project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After *purchasing* (it''s free) the task blueprint, we can add and configure
    it in our pipeline. It''s useful to have a build that runs tests, but CI systems
    are very flexible and you can get very creative. Your screen should now look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b6da739c-d057-4c0f-8309-6eb649c9192b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the first task as it is (no configuration needed) since it is only installing
    the tools using `rustup`. The second task simply runs `cargo test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae7d5606-cbb9-4d1b-a3c8-62d1eea983b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As the last step, queue the build and check its progress. If you followed the
    recipe, it will result in a successful build and you can start using it to check
    pull requests, add badges on `crates.io`, and much more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73371632-2ab6-4bf1-b5ee-6b1a60e760e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure DevOps is a fully integrated solution for project management, issue tracking,
    source code hosting, and building and deploying solutions. Similar offerings are
    GitHub (also owned by Microsoft), GitLab ([https://about.gitlab.com](https://about.gitlab.com)),
    or Atlassian's Bitbucket ([https://bitbucket.org](https://bitbucket.org)). Together
    with CircleCI ([https://circleci.com](https://circleci.com)) or Travis CI ([https://travis-ci.org/](https://travis-ci.org/)),
    these platforms offer powerful tools for teams to make sure that every new deployment
    reliably meets their goals without large management overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic idea is simple: by making the build work on a neutral platform, most
    of the obvious mistakes (missing dependencies or relying on environment specifics)
    can easily be avoided while running the same tests that have to run locally. On
    top of that, running every test might be demanding on large projects, and dedicated
    infrastructure takes care of that.'
  prefs: []
  type: TYPE_NORMAL
- en: Since computers are notoriously picky, the results of running tests are also
    visible and can be used to prohibit certain actions, such as deploying to production
    with failing tests. In a way, a continuous integration system holds the developer
    accountable to their own rules (tests).
  prefs: []
  type: TYPE_NORMAL
- en: '`cargo` support is implicit by being a good citizen in stateless systems. Instead
    of failing if certain conditions are not met, it tries to mitigate late terminations
    and requires little configuration to begin with. Its ability to handle dependencies
    easily and well adds to that and the support for sub-commands makes it a great
    way to build across platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some ideas of what you can do besides running `cargo test`:'
  prefs: []
  type: TYPE_NORMAL
- en: Run benchmarks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept PRs only on successful tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do static code analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure DevOps also supports release pipelines, which should be used for tasks
    such as publishing to `crates.io` (or other package repositories), updating the
    hosted documentation, and more. Read the Azure DevOps documentation ([https://docs.microsoft.com/en-us/azure/devops/?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/?view=azure-devops))
    on how to do that. For anyone who prefers YAML ([https://yaml.org/](https://yaml.org/)) files
    to configure CI pipelines, Azure DevOps supports these as well.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Sylvain Pontoreau's work ([https://twitter.com/bla](https://twitter.com/bla))
    on creating easy-to-use task templates, we can quickly set build, test, or other
    pipelines. Doing it manually can be tricky to get right for every platform and
    maintaining downloads and shell scripts is a hassle for most developers. If you
    are using his work, he is happy to hear about it as well—for example, on Twitter
    ([https://twitter.com/spontoreau](https://twitter.com/spontoreau)).
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to continuously integrate with `cargo`. Now,
    let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`cargo` is versatile—something that we have already established in the previous
    recipes in this chapter. However, we did not touch configuring the tools `cargo`
    uses to compile and run Rust projects. For this, there are multiple ways, as they
    apply to different domains.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore two ways by customizing the build of
    a new project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s how to customize a build:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new binary project using `cargo new custom-build` and open the project
    folder using VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/main.rs` and replace the hello world code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in our binary is now creating an overflow situation that a compiler
    can easily catch. However, the default release build has that feature turned off.
    Run `cargo run --release` to see it in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to change the fact that the compiler verifies overflow errors
    at compile time in release mode (even though overflows can be *useful*, for example,
    in hardware drivers), we have to edit `Cargo.toml` and customize the profile for
    `release` (there are others as well, for example, `dev` and `test`). While we
    are there we can change a few other options for faster builds (important for larger
    projects):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run `cargo run --release` now, the output has changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy—but there is more! Create a `.cargo` directory at the root of
    the project and add a `config` file inside. Since the file (and directory) is
    inside the project, that''s its scope. However, it''s possible to make it valid
    for a larger number of projects by moving the `.cargo` directories up several
    levels. Be aware that the user''s home directory represents *global scope*, which
    means the `cargo` configuration applies to all of the user''s projects. The following
    settings switch the default build target to WASM output ([https://webassembly.org/](https://webassembly.org/))
    and rename the build artifact directory `out` (the default is `target`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s remove the overflow from `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile with `cargo build` and `cargo run` to see what''s happening:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many aspects of a project that can be configured, most of which are
    not needed for smaller programs and libraries (unless it's for special architectures).
    This recipe can only show a few—easy—examples of what's possible, but there is
    more in the `cargo` book about configuration ([https://doc.rust-lang.org/cargo/reference/config.html](https://doc.rust-lang.org/cargo/reference/config.html))
    and the manifest ([https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections](https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections)).
  prefs: []
  type: TYPE_NORMAL
- en: In the first steps, `cargo` is configured to overlook overflow errors by changing
    a flag in the `cargo` configuration. While it might seem a foolish step at first,
    it is sometimes necessary to allow overflows for drivers or other low-level electronics
    to operate.
  prefs: []
  type: TYPE_NORMAL
- en: Many other options customize the developer experience (for example, setting
    the name and email address for new projects, aliases, and many more) or prove
    useful in non-standard settings, for example, when creating device drivers, operating
    systems, or real-time software for specialized hardware. We might use some of
    these later on in [Chapter 9](d229ae85-1922-45fc-ab87-b1de7a533f9b.xhtml), *Systems
    Programming Made Easy*.
  prefs: []
  type: TYPE_NORMAL
- en: However, changing the `build` section (as in `cargo build`) has grave consequences
    as it represents the standard output format for the project. It might seem arbitrary
    to change it to something like WASM, but as a default, it can save many steps
    for the developer to set up the development environment—or to simply make CI build
    scripts less verbose.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, `cargo` is very flexible and easy to configure, but it's tailored
    to each project individually. Check out the manifest and documentation to find
    out how it can make your project (and your life) easier.
  prefs: []
  type: TYPE_NORMAL
