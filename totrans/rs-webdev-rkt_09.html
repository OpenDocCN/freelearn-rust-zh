<html><head></head><body>
		<div><h1 id="_idParaDest-91"><em class="italic"><a id="_idTextAnchor091"/>Chapter 7</em>: Handling Errors in Rust and Rocket</h1>
			<p>In the previous chapter, we learned about creating endpoints and SQL queries to handle the management of the <code>User</code> entity. In this chapter, we are going to learn more about error handling in Rust and Rocket. After learning the concepts in this chapter, you will be able to implement error handling in a Rocket application.</p>
			<p>We are also going to discuss more common ways to handle errors in Rust and Rocket, including signaling unrecoverable errors using the <code>panic!</code> macro and catching the <code>panic!</code> macro, using <code>Option</code>, using <code>Result</code>, creating a custom <code>Error</code> type, and logging the generated error.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Using panic!</li>
				<li>Using Option</li>
				<li>Returning Result</li>
				<li>Creating a custom error type</li>
				<li>Logging errors</li>
			</ul>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Technical requirements</h1>
			<p>For this chapter, we have the same technical requirements as the previous chapter. We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database server.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Using panic!</h1>
			<p>To understand error handling in Rust, we need to begin with the <code>panic!</code> macro. We can use the <code>panic!</code> macro when the application encounters an unrecoverable error and there's no purpose in continuing the application. If the application encounters <code>panic!</code>, the application will emit the backtrace and terminate.</p>
			<p>Let's try using <code>panic!</code> on the program <a id="_idIndexMarker392"/>that we created in the previous chapter. Suppose we want the application to read a secret file before we initialize Rocket. If the application cannot find this secret file, it will not continue.</p>
			<p>Let's get started:</p>
			<ol>
				<li>Add the following line in <code>src/main.rs</code>:<pre>use std::env;</pre></li>
				<li>In the same file in the <code>rocket()</code> function, prepend the following lines:<pre>let secret_file_path = env::current_dir().unwrap().join("secret_file");
if !secret_file_path.exists() {
    panic!("secret does not exists");
}</pre></li>
				<li>Afterward, try executing <code>cargo run</code> without creating an empty file named <code>secret_file</code> inside the working directory. You should see the output as follows:<pre><strong class="bold">thread 'main' panicked at 'secret does not exists', src/main.rs:15:9</strong>
<strong class="bold">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</strong></pre></li>
				<li>Now, try running the application again with <code>RUST_BACKTRACE=1 cargo run</code>. You should see the backtrace output in the terminal similar to the following:<pre><strong class="bold">RUST_BACKTRACE=1 cargo run </strong>
<strong class="bold">    Finished dev [unoptimized + debuginfo] target(s) </strong>
<strong class="bold">    in 0.18s</strong>
<strong class="bold">     Running `target/debug/our_application`</strong>
<strong class="bold">thread 'main' panicked at 'secret does not exists', src/main.rs:15:9</strong>
<strong class="bold">stack backtrace:</strong>
<strong class="bold">...</strong>
<strong class="bold">  14: our_application::main</strong>
<strong class="bold">             at ./src/main.rs:12:36</strong>
<strong class="bold">  15: core::ops::function::FnOnce::call_once</strong>
<strong class="bold">             at /rustc/59eed8a2aac0230a8b5</strong>
<strong class="bold">             3e89d4e99d55912ba6b35/library/core/</strong>
<strong class="bold">             src/ops/function.rs:227:5</strong>
<strong class="bold">note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.</strong></pre></li>
				<li>Sometimes, we don't <a id="_idIndexMarker393"/>want to deallocate after panicking using the <code>panic!</code> macro because we want the application to exit as soon as possible. We can skip deallocating by setting <code>panic = "abort"</code> in <code>Cargo.toml</code> under the profile we are using. Setting that configuration will make our binary smaller and exit faster, and the operating system will need to clean it later. Let's try doing that. Set the following lines in <code>Cargo.toml</code> and run the application again:<pre>[profile.dev]
panic = "abort"</pre></li>
			</ol>
			<p>Now that we know how to use <code>panic!</code>, let's see how we can catch it in the next section.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Catching panic!</h2>
			<p>As well as using <code>panic!</code>, we can also use the <code>todo!</code> and <code>unimplemented!</code> macros in Rust code. Those macros are very useful for prototyping because they will call <code>panic!</code> while also allowing the code to type-check at compile time.</p>
			<p>But, why does <a id="_idIndexMarker394"/>Rocket not shut down when we are calling a route with <code>todo!</code>? If we check the Rocket source code, there's a <code>catch_unwind</code> function in <code>src::panic</code> that can be used to capture a panicking function. Let's see that code in the Rocket source code, <code>core/lib/src/server.rs</code>:</p>
			<pre class="source-code">let fut = std::panic::catch_unwind(move || run())</pre>
			<pre class="source-code">         .map_err(|e| panic_info!(name, e))</pre>
			<pre class="source-code">         .ok()?;</pre>
			<p>Here, <code>run()</code> is a route handling function. Each time we call a route that is panicking, the preceding routine will convert the panic into the result's <code>Err</code> variant. Try removing the <code>secret_file_path</code> routine we added before and running the application. Now, create a user and try going into user posts. For example, create a user with the <code>95a54c16-e830-45c9-ba1d-5242c0e4c18f</code> UUID. Try opening <code>http://127.0.0.1/users/95a54c16-e830-45c9-ba1d-5242c0e4c18f/posts</code>. Since we only put <code>todo!("will implement later")</code> in the function body, the application will panic, but the preceding <code>catch_unwind</code> function will catch the panic and convert it into an error. Please note that <code>catch_unwind</code> will not work if we set <code>panic = "abort"</code> in <code>Cargo.toml</code>.</p>
			<p>In a regular workflow, we don't usually want to use <code>panic!</code>, because panicking interrupts everything, and the program will not be able to continue. If the Rocket framework does not catch <code>panic!</code> and one of the route handling functions is panicking, then that single error will close the application and there will be nothing to handle the other requests. But, what if we want to terminate the Rocket application when we encounter an unrecoverable error? Let's see how we can do it in the next section.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Using shutdown</h2>
			<p>To shut <a id="_idIndexMarker395"/>down smoothly if the application encounters an unrecoverable error in the route handling function, we can use the <code>rocket::Shutdown</code> request guard. Remember, the request guard is a parameter we are supplying to the route handling functions.</p>
			<p>To see the <code>Shutdown</code> request guard in action, let's try implementing it in our application. Using <a id="_idIndexMarker396"/>the previous application, add a new route in <code>src/routes/mod.rs</code> called <code>/shutdown</code>:</p>
			<pre class="source-code">use rocket::Shutdown;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">#[get("/shutdown")]</pre>
			<pre class="source-code">pub async fn shutdown(shutdown: Shutdown) -&gt; &amp;'static str {</pre>
			<pre class="source-code">    // suppose this variable is from function which </pre>
			<pre class="source-code">    // produces irrecoverable error</pre>
			<pre class="source-code">    let result: Result&lt;&amp;str, &amp;str&gt; = Err("err");</pre>
			<pre class="source-code">    if result.is_err() {</pre>
			<pre class="source-code">        shutdown.notify();</pre>
			<pre class="source-code">        return "Shutting down the application.";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return "Not doing anything.";</pre>
			<pre class="source-code">}</pre>
			<p>Try adding the <code>shutdown()</code> function in <code>src/main.rs</code>. After that, rerun the application and send an HTTP request to <code>/shutdown</code> while monitoring the output of the application on the terminal. The application should shut down smoothly.</p>
			<p>In the next two sections, let's see how we can use <code>Option</code> and <code>Result</code> as an alternative way to handle errors.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Using Option</h1>
			<p>In programming, a routine might <a id="_idIndexMarker397"/>produce a correct result or encounter a problem. One classical example is division by zero. Dividing something by zero is mathematically undefined. If the application has a routine to divide something, and the routine encounters zero as input, the application cannot return any number. We want the application to return another type instead of a number. We need a type that can hold multiple variants of data.</p>
			<p>In Rust, we can <a id="_idIndexMarker398"/>define an <code>enum</code> type, a type that can be different variants of data. An <code>enum</code> type might be as follows:</p>
			<pre class="source-code">enum Shapes {</pre>
			<pre class="source-code">    None,</pre>
			<pre class="source-code">    Point(i8),</pre>
			<pre class="source-code">    Line(i8, i8),</pre>
			<pre class="source-code">    Rectangle {</pre>
			<pre class="source-code">        top: (i8, i8),</pre>
			<pre class="source-code">        length: u8,</pre>
			<pre class="source-code">        height: u8,</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">}</pre>
			<p><code>Point</code> and <code>Line</code> are said to have <code>Rectangle</code> is said to have <code>Rectangle</code> can also <a id="_idIndexMarker399"/>be called a <strong class="bold">struct-like enum</strong> variant.</p>
			<p>If all members of <code>enum</code> have no data, we can add a discriminant on the member. Here is an example:</p>
			<pre class="source-code">enum Color {</pre>
			<pre class="source-code">    Red,         // 0</pre>
			<pre class="source-code">    Green = 127, // 127</pre>
			<pre class="source-code">    Blue,        // 128</pre>
			<pre class="source-code">}</pre>
			<p>We can assign <code>enum</code> to a variable, and use the variable in a function as in the following:</p>
			<pre class="source-code">fn do_something(<strong class="bold">color: Color</strong>) -&gt; Shapes {</pre>
			<pre class="source-code">    let rectangle = Shapes::Rectangle {</pre>
			<pre class="source-code">        top: (0, 2),</pre>
			<pre class="source-code">        length: 10,</pre>
			<pre class="source-code">        height: 8,</pre>
			<pre class="source-code">    };</pre>
			<pre class="source-code">    match <strong class="bold">color</strong> {</pre>
			<pre class="source-code">        <strong class="bold">Color::Red</strong> =&gt; Shapes::None,</pre>
			<pre class="source-code">        <strong class="bold">Color::Green</strong> =&gt; Shapes::Point(10),</pre>
			<pre class="source-code">        _ =&gt; rectangle,</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Going back <a id="_idIndexMarker400"/>to error handling, we can use <code>enum</code> to communicate that there's something wrong in our code. Going back to division by zero, here is an example:</p>
			<pre class="source-code">enum Maybe {</pre>
			<pre class="source-code">    WeCannotDoIt,</pre>
			<pre class="source-code">    WeCanDoIt(i8),</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fn check_divisible(input: i8) -&gt; Maybe {</pre>
			<pre class="source-code">    if input == 0 {</pre>
			<pre class="source-code">        return <strong class="bold">Maybe::WeCannotDoIt</strong>;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    <strong class="bold">Maybe::WeCanDoIt(input)</strong></pre>
			<pre class="source-code">}</pre>
			<p>The preceding pattern returning something or not returning something is very common, so Rust has its own enum to show whether we have something or not in the standard library, called <code>std::option::Option</code>:</p>
			<pre class="source-code">pub enum Option&lt;T&gt; {</pre>
			<pre class="source-code">    None,</pre>
			<pre class="source-code">    Some(T),</pre>
			<pre class="source-code">}</pre>
			<p><code>Some(T)</code> is used to <a id="_idIndexMarker401"/>communicate that we have <code>T</code>, and <code>None</code> is obviously used to communicate that we don't have <code>T</code>. We used <code>Option</code> in some of the previous code. For example, we used it in the <code>User</code> struct:</p>
			<pre class="source-code">struct User {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    description: <strong class="bold">Option&lt;String&gt;,</strong></pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>We also used <code>Option</code> as a function parameter or return type:</p>
			<pre class="source-code">find_all(..., <strong class="bold">pagination: Option&lt;Pagination&gt;</strong>) -&gt; (..., <strong class="bold">Option&lt;Pagination&gt;</strong>), ... {}</pre>
			<p>There are many useful things we can use with <code>Option</code>. Suppose we have two variables, <code>we_have_it</code> and <code>we_do_not_have_it</code>:</p>
			<pre class="source-code">let we_have_it: Option&lt;usize&gt; = Some(1);</pre>
			<pre class="source-code">let we_do_not_have_it: Option&lt;usize&gt; = None;</pre>
			<ul>
				<li>One thing we can do is pattern matching and use the content:<pre>match we_have_it {
    <strong class="bold">Some(t)</strong> =&gt; println!("The value = {}", t),
    <strong class="bold">None</strong> =&gt; println!("We don't have it"),
};</pre></li>
				<li>We can process it in a more convenient way if we care about the content of <code>we_have_it</code>:<pre>if let <strong class="bold">Some(t)</strong> = we_have_it {
    println!("The value = {}", t);
}</pre></li>
				<li><code>Option</code> can be compared if the inner type implements <code>std::cmp::Eq</code> and <code>std::cmp::Ord</code>, that is, the inner type can be compared using <code>==</code>, <code>!=</code>, <code>&gt;</code>, and other comparison operators. Notice that we use <code>assert!</code>, a macro used for testing:<pre>assert!(we_have_it != we_do_not_have_it);</pre></li>
				<li>We can check <a id="_idIndexMarker402"/>whether a variable is <code>Some</code> or <code>None</code>:<pre>assert!(we_have_it.<strong class="bold">is_some()</strong>);
assert!(we_do_not_have_it.<strong class="bold">is_none()</strong>);</pre></li>
				<li>We can also get the content by unwrapping <code>Option</code>. But, there's a caveat; unwrapping <code>None</code> will cause panic, so be careful when unwrapping <code>Option</code>. Notice we use <code>assert_eq!</code>, which is a macro used for testing to ensure equality:<pre>assert_eq!(we_have_it.<strong class="bold">unwrap()</strong>, 1);
// assert_eq!(we_do_not_have_it.<strong class="bold">unwrap()</strong>, 1); 
// will panic</pre></li>
				<li>We can also use the <code>expect()</code> method. This method will work the same with <code>unwrap()</code> but we can use a custom message:<pre>assert_eq!(we_have_it.<strong class="bold">expect("Oh no!")</strong>, 1);
// assert_eq!(we_do_not_have_it.<strong class="bold">expect("Oh no!")</strong>, 1); // will panic</pre></li>
				<li>We can unwrap and set the default value so it will not panic if we unwrap <code>None</code>:<pre>assert_eq!(we_have_it.<strong class="bold">unwrap_or(42)</strong>, 1);
assert_eq!(we_do_not_have_it.<strong class="bold">unwrap_or(42)</strong>, 42);</pre></li>
				<li>We can unwrap and set the default value with a closure:<pre>let x = 42;
assert_eq!(we_have_it.<strong class="bold">unwrap_or_else(|| x)</strong>, 1);
assert_eq!(we_do_not_have_it.<strong class="bold">unwrap_or_else(|| x)</strong>, 42);</pre></li>
				<li>We can convert <a id="_idIndexMarker403"/>the value contained to something else using <code>map()</code>, <code>map_or()</code>, or <code>map_or_else()</code>:<pre>assert_eq!(we_have_it.<strong class="bold">map</strong>(|v| format!("The value = {}", v)), Some("The value = 1".to_string()));
assert_eq!(we_do_not_have_it.<strong class="bold">map</strong>(|v| format!("The value = {}", v)), None);
assert_eq!(we_have_it.<strong class="bold">map_or</strong>("Oh no!".to_string(), |v| format!("The value = {}", v)), "The value = 1".to_string());
assert_eq!(we_do_not_have_it.<strong class="bold">map_or</strong>("Oh no!".to_string(), |v| format!("The value = {}", v)), "Oh no!".to_string());
assert_eq!(we_have_it.<strong class="bold">map_or_else</strong>(|| "Oh no!".to_string(), |v| format!("The value = {}", v)), "The value = 1".to_string());
assert_eq!(we_do_not_have_it.<strong class="bold">map_or_else</strong>(|| "Oh no!".to_string(), |v| format!("The value = {}", v)), "Oh no!".to_string());</pre></li>
			</ul>
			<p>There are other important methods, which you can check in the documentation for <code>std::option::Option</code>. Even though we can use <code>Option</code> to handle a situation where there's something or nothing, it does not convey a message of <em class="italic">something went wrong</em>. We can use another type similar to <code>Option</code> in the next part to achieve this.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Returning Result</h1>
			<p>In Rust, we have the <code>std::result::Result</code> enum that works like <code>Option</code>, but instead of <a id="_idIndexMarker404"/>saying <em class="italic">we have it</em> or <em class="italic">we don't have it</em>, the <code>Result</code> type is more about saying <em class="italic">we have it</em> or <em class="italic">we have this error</em>. Just like <code>Option</code>, <code>Result</code> is an <code>enum</code> type of the possible <code>T</code> type or possible <code>E</code> error:</p>
			<pre class="source-code">enum Result&lt;T, E&gt; {</pre>
			<pre class="source-code">   Ok(T),</pre>
			<pre class="source-code">   Err(E),</pre>
			<pre class="source-code">}</pre>
			<p>Going back to the division by zero problem, take a look at the following simple example:</p>
			<pre class="source-code">fn division(a: usize, b: usize) -&gt; Result&lt;f64, String&gt; {</pre>
			<pre class="source-code">    if b == 0 {</pre>
			<pre class="source-code">        return Err(String::from("division by zero"));</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return Ok(a as f64 / b as f64);</pre>
			<pre class="source-code">}</pre>
			<p>We don't want division by <code>0</code>, so we return an error for the preceding function.</p>
			<p>Similar to <code>Option</code>, <code>Result</code> has many convenient features we can use. Suppose we have the <code>we_have_it</code> and <code>we_have_error</code> variables:</p>
			<pre class="source-code">let we_have_it: Result&lt;usize, &amp;'static str&gt; = Ok(1);</pre>
			<pre class="source-code">let we_have_error: Result&lt;usize, &amp;'static str&gt; = Err("Oh no!");</pre>
			<ul>
				<li>We can get the value or the error using pattern matching:<pre>match we_have_it {
    <strong class="bold">Ok(v)</strong> =&gt; println!("The value = {}", v),
    <strong class="bold">Err(e)</strong> =&gt; println!("The error = {}", e),
};</pre></li>
				<li>Or, we can use <code>if let</code> to destructure and get the value or the error:<pre>if let <strong class="bold">Ok(v)</strong> = we_have_it {
    println!("The value = {}", v);
}
if let <strong class="bold">Err(e)</strong> = we_have_error {
    println!("The error = {}", e);
}</pre></li>
				<li>We can compare the <code>Ok</code> variant and the <code>Err</code> variant:<pre>assert!(we_have_it != we_have_error);</pre></li>
				<li>We can <a id="_idIndexMarker405"/>check whether a variable is an <code>Ok</code> variant or an <code>Err</code> variant:<pre>assert!(we_have_it<strong class="bold">.is_ok());</strong>
assert!(we_have_error<strong class="bold">.is_err()</strong>);</pre></li>
				<li>We can convert <code>Result</code> to <code>Option</code>:<pre>assert_eq!(we_have_it.ok(), Some(1));
assert_eq!(we_have_error.ok(), None);
assert_eq!(we_have_it.err(), None);
assert_eq!(we_have_error.err(), Some("Oh no!"));</pre></li>
				<li>Just like <code>Option</code>, we can use <code>unwrap()</code>, <code>unwrap_or()</code>, or <code>unwrap_or_else()</code>:<pre>assert_eq!(we_have_it.<strong class="bold">unwrap()</strong>, 1);
// assert_eq!(we_have_error.<strong class="bold">unwrap()</strong>, 1); 
// panic
assert_eq!(we_have_it.<strong class="bold">expect("Oh no!")</strong>, 1);
// assert_eq!(we_have_error.<strong class="bold">expect("Oh no!")</strong>, 1);
// panic
assert_eq!(we_have_it.<strong class="bold">unwrap_or(0)</strong>, 1);
assert_eq!(we_have_error.<strong class="bold">unwrap_or(0)</strong>, 0);
assert_eq!(we_have_it.<strong class="bold">unwrap_or_else(|_| 0),</strong> 1);
assert_eq!(we_have_error.<strong class="bold">unwrap_or_else(|_| 0)</strong>, 0);</pre></li>
				<li>And, we <a id="_idIndexMarker406"/>can use <code>map()</code>, <code>map_err()</code>, <code>map_or()</code>, or <code>map_or_else()</code>:<pre>assert_eq!(we_have_it.<strong class="bold">map</strong>(|v| format!("The value = {}", v)), Ok("The value = 1".to_string()));
assert_eq!(
    we_have_error.<strong class="bold">map</strong>(|v| format!("The error = {}", 
    v)),
    Err("Oh no!")
);
assert_eq!(we_have_it.<strong class="bold">map_err</strong>(|s| s.len()), Ok(1));
assert_eq!(we_have_error.<strong class="bold">map_err</strong>(|s| s.len()), Err(6));
assert_eq!(we_have_it.<strong class="bold">map_or</strong>("Default value".to_string(), |v| format!("The value = {}", v)), "The value = 1".to_string());
assert_eq!(we_have_error.<strong class="bold">map_or</strong>("Default value".to_string(), |v| format!("The value = {}", v)), "Default value".to_string());
assert_eq!(we_have_it.<strong class="bold">map_or_else</strong>(|_| "Default value".to_string(), |v| format!("The value = {}", v)), "The value = 1".to_string());
assert_eq!(we_have_error.<strong class="bold">map_or_else</strong>(|_| "Default value".to_string(), |v| format!("The value = {}", v)), "Default value".to_string());</pre></li>
			</ul>
			<p>There are other important methods besides those methods in the <code>std::result::Result</code> documentation. Do check them because <code>Option</code> and <code>Result</code> are very important in Rust and Rocket.</p>
			<p>Returning a <a id="_idIndexMarker407"/>string or numbers as an error might be acceptable in some cases, but most likely, we want a real error type with a message and possible backtrace that we can process further. In the next section, we are going to learn about (and use) the <code>Error</code> trait and return the dynamic error type in our application.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Creating a custom error type</h1>
			<p>Rust has a <a id="_idIndexMarker408"/>trait to unify propagating errors by providing the <code>std::error::Error</code> trait. Since the <code>Error</code> trait is defined as <code>pub trait Error: Debug + Display</code>, any type that implements <code>Error</code> should also implement the <code>Debug</code> and <code>Display</code> traits.</p>
			<p>Let's see how we can create a custom error type by creating a new module:</p>
			<ol>
				<li value="1">In <code>src/lib.rs</code>, add the new <code>errors</code> module:<pre>pub mod errors;</pre></li>
				<li>After that, create a new folder, <code>src/errors</code>, and add the <code>src/errors/mod.rs</code> and <code>src/errors/our_error.rs</code> files. In <code>src/errors/mod.rs</code>, add this line:<pre>pub mod our_error;</pre></li>
				<li>In <code>src/errors/our_error.rs</code>, add the custom type for <code>error</code>:<pre>use rocket::http::Status;
use std::error::Error;
use std::fmt;
#[derive(Debug)]
pub struct OurError {
    pub status: Status,
    pub message: String,
    debug: Option&lt;Box&lt;dyn Error&gt;&gt;,
}
impl fmt::Display for OurError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; 
    fmt::Result {
        write!(f, "{}", &amp;self.message)
    }
}</pre></li>
				<li>Then, we can <a id="_idIndexMarker409"/>implement the <code>Error</code> trait for <code>OurError</code>. In <code>src/errors/our_error.rs</code>, add the following lines:<pre>impl Error for OurError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        if self.debug.is_some() {
            self.debug.as_ref().unwrap().source();
        }
        None
    }
}</pre></li>
			</ol>
			<p>Currently, for the <code>User</code> module, we return a <code>Result&lt;..., Box&lt;dyn Error&gt;&gt;</code> dynamic error for each method. This is a common pattern of returning an error by using any type that implements <code>Error</code> and then putting the instance in the heap using <code>Box</code>.</p>
			<p>The problem with this approach is we can only use methods provided by the <code>Error</code> trait, that is, <code>source()</code>. We want to be able to use the <code>OurError</code> status, message, and debug information.</p>
			<ol>
				<li value="5">So, let's add <a id="_idIndexMarker410"/>a couple of builder methods to <code>OurError</code>. In <code>src/errors/our_error.rs</code>, add the following lines:<pre>impl OurError {
    fn new_error_with_status(status: Status, message: 
    String, debug: Option&lt;Box&lt;dyn Error&gt;&gt;) -&gt; Self {
        OurError {
            status,
            message,
            debug,
        }
    }
    pub fn new_bad_request_error(message: String, 
    debug: Option&lt;Box&lt;dyn Error&gt;&gt;) -&gt; Self {
        Self::new_error_with_status(Status::
        BadRequest, message, debug)
    }
    pub fn new_not_found_error(message: String,
    debug: Option&lt;Box&lt;dyn Error&gt;&gt;) -&gt; Self {
        Self::new_error_with_status(Status::NotFound, 
        message, debug)
    }
    pub fn new_internal_server_error(
        message: String,
        debug: Option&lt;Box&lt;dyn Error&gt;&gt;,
    ) -&gt; Self {
        Self::new_error_with_status(Status::
        InternalServerError, message, debug)
    }
}</pre></li>
				<li>If we take <a id="_idIndexMarker411"/>a look at <code>src/models/user.rs</code>, there are three sources of errors: <code>sqlx::Error</code>, <code>uuid::Error</code>, and <code>argon2</code>. Let's create a conversion for <code>sqlx::Error</code> and <code>uuid::Error</code> to <code>OurError</code>. Add the following <code>use</code> directive in <code>src/errors/our_error.rs</code>:<pre>use sqlx::Error as sqlxError;
use uuid::Error as uuidError;</pre></li>
				<li>Inside the same file, <code>src/errors/our_error.rs</code>, add the following lines:<pre>impl OurError {
    ...
    pub fn from_uuid_error(e: uuidError) -&gt; Self {
        OurError::new_bad_request_error(
            String::from("Something went wrong"),
            Some(Box::new(e)))
    }
}</pre></li>
				<li>For <code>sqlx::Error</code>, we want to convert <code>not_found</code> error to HTTP status <code>404</code> and duplicate <a id="_idIndexMarker412"/>index error to an HTTP status 400bad request. Add the following lines to <code>src/errors/our_error.rs</code>:<pre>use std::borrow::Cow;
....
impl OurError {
    ....
    pub fn from_sqlx_error(e: sqlxError) -&gt; Self {
        match e {
            sqlxError::RowNotFound =&gt; {
                OurError::new_not_found_error(
                    String::from("Not found"),
                    Some(Box::new(e)))
            }
            sqlxError::Database(db) =&gt; {
                if db.code().unwrap_or(Cow::
                Borrowed("2300")).starts_with("23") {
                    return OurError::new_bad_
                    request_error(
                        String::from("Cannot create or 
                        update resource"),
                        Some(Box::new(db)),
                    );
                }
                OurError::new_internal_server_error(
                    String::from("Something went 
                    wrong"),
                    Some(Box::new(db)),
                )
            }
            _ =&gt; OurError::new_internal_server_error(
                String::from("Something went wrong"),
                Some(Box::new(e)),
            ),
        }
    }
}</pre></li>
				<li>We need to <a id="_idIndexMarker413"/>do one more thing before we modify our <code>User</code> entity. Some crates in Rust do not compile the <code>std</code> library by default to make the resulting binary smaller and embeddable in IoT (Internet of Things) devices or WebAssembly. For example, the <code>argon2</code> crate does not include the <code>Error</code> trait implementation by default, so we need to enable the <code>std</code> feature. In <code>Cargo.toml</code>, modify the <code>argon2</code> dependencies to enable the <code>std</code> library features:<pre>argon2 = {version = "0.3", features = ["std"]}</pre></li>
				<li>In <code>src/models/user.rs</code>, delete <code>use std::error::Error;</code> and replace it with <code>use crate::errors::our_error::OurError;</code>. Then, we can replace the methods for <code>User</code> to use <code>OurError</code> instead. Here is an example:<pre>pub async fn find(connection: &amp;mut PgConnection, uuid: &amp;str) -&gt; Result&lt;Self, <strong class="bold">OurError</strong>&gt; {
    let parsed_uuid = Uuid::parse_str(
    uuid).map_err(<strong class="bold">OurError::from_uuid_error</strong>)?;
    let query_str = "SELECT * FROM users WHERE uuid = 
    $1";
    Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)
        .bind(parsed_uuid)
        .fetch_one(connection)
        .await
        .map_err(<strong class="bold">OurError::from_sqlx_error</strong>)?)
}</pre></li>
				<li>For the <code>argon2</code> error, we can create a function or method, or convert it manually. For <a id="_idIndexMarker414"/>example, in <code>src/models/user.rs</code>, we can do this:<pre>let password_hash = argon2
    .hash_password(new_user.password.as_bytes(), 
     &amp;salt)
    .map_err(|<strong class="bold">e</strong>| {
        <strong class="bold">OurError::new_internal_server_error(</strong>
<strong class="bold">            String::from("Something went wrong"),</strong>
<strong class="bold">            Some(Box::new(e)),</strong>
<strong class="bold">        )</strong>
    })?;</pre></li>
			</ol>
			<p>Change all the methods to use <code>OurError</code>. Just a reminder: you can find the complete source code for <code>src/models/user.rs</code> in the GitHub repository at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07</a>.</p>
			<ol>
				<li value="12">We will then use the <code>OurError</code> status and message in <code>src/routes/user.rs</code>. Because the <code>Error</code> type already implements the <code>Display</code> trait, we can use <code>e</code> directly inside <code>format!()</code>. Here is an example:<pre>pub async fn get_user(...) -&gt; HtmlResponse {
...
    let user = User::find(connection, 
    uuid).await.map_err(|<strong class="bold">e</strong>| <strong class="bold">e.status</strong>)?;
...
}
...
pub async fn delete_user(...) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {
...
    User::destroy(connection, uuid)
        .await
        .map_err(|e| Flash::error(Redirect::to("/
         users"), format!("&lt;div&gt;<strong class="bold">{}</strong>&lt;/div&gt;", <strong class="bold">e</strong>)))?;
...
}</pre></li>
			</ol>
			<p>You can find the complete source code for <code>src/routes/user.rs</code> in the GitHub repository. Now <a id="_idIndexMarker415"/>that we have implemented errors, it might be a good time to try to implement the catchers that we defined before in <code>src/catchers/mod.rs</code> to show default errors for the user. You can also see the example of the default catchers in the source code.</p>
			<p>In an application, tracking and logging errors are an important part of maintaining the application. Since we implemented the <code>Error</code> trait, we can log the <code>source()</code> of an error in our application. Let's take a look at how to do that in the next section.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Logging errors</h1>
			<p>In Rust, there's a log crate that provides a facade for application logging. The log provides five macros: <code>error!</code>, <code>warn!,</code> <code>info!</code>, <code>debug!</code>, and <code>trace!</code>. An application can then create <a id="_idIndexMarker416"/>a log based on the severity and filter what needs to be logged, also based on the severity. For example, if we filter based on <code>warn</code>, then we only log <code>error!</code> and <code>warn!</code> and ignore the rest. Since the log crate does not implement the logging itself, people often use another crate to do the actual implementation. In the documentation for the log crate, we can find examples of other logging crates that can be used: <code>env_logger</code>, <code>simple_logger,</code> <code>simplelog</code>, <code>pretty_env_logger</code>, <code>stderrlog</code>, <code>flexi_logger</code>, <code>log4rs</code>, <code>fern</code>, <code>syslog</code>, and <code>slog-stdlog</code>.</p>
			<p>Let's implement custom logging in our application. We will use the <code>fern</code> crate for logging and wrap that in <code>async_log</code> to make logging asynchronous:</p>
			<ol>
				<li value="1">First, add these crates in <code>Cargo.toml</code>:<pre>async-log = "2.0.0"
fern = "0.6"
log = "0.4"</pre></li>
				<li>In <code>Rocket.toml</code>, add the config for <code>log_level</code>:<pre>log_level = "normal"</pre></li>
				<li>We can then create the function to initialize a global logger in our application. In <code>src/main.rs</code>, create a new function called <code>setup_logger</code>:<pre>fn setup_logger() {}</pre></li>
				<li>Inside the function, let's initialize the logger:<pre>use log::LevelFilter;
...
let (level, logger) = fern::Dispatch::new()
    .format(move |out, message, record| {
        out.finish(format_args!(
            "[{date}] [{level}][{target}] [{
             message}]",
            date = chrono::Local::now().format("[
            %Y-%m-%d][%H:%M:%S%.3f]"),
            target = record.target(),
            level = record.level(),
            message = message
        ))
    })
    .level(LevelFilter::Info)
    .chain(std::io::stdout())
    .chain(
        fern::log_file("logs/application.log")
            .unwrap_or_else(|_| panic!("Cannot open 
            logs/application.log")),
    )
    .into_log();</pre></li>
			</ol>
			<p>First, we create <a id="_idIndexMarker417"/>a new instance of <code>fern::Dispatch</code>. After that, we configure the output format using the <code>format()</code> method. After setting the output format, we set the log level using the <code>level()</code> method.</p>
			<p>For the logger, we want to not only output the log to the operating system <code>stdout</code>, but we also want to write to a log file. We can do it using the <code>chain()</code> method. To avoid panicking, don't forget to create a <code>logs</code> folder in the application directory.</p>
			<ol>
				<li value="5">After we set up the level and logger, we wrap it inside <code>async_log</code>:<pre>async_log::Logger::wrap(logger, || 0).start(level).unwrap();</pre></li>
				<li>We will log <code>OurError</code> when it's created. Inside <code>src/errors/our_error.rs</code>, add the following lines:<pre>impl OurError {
    fn new_error_with_status(...) ... {
        <strong class="bold">if debug.is_some() {</strong>
<strong class="bold">            log::error!("Error: {:?}", &amp;debug);</strong>
<strong class="bold">        }</strong>
        ...
    }
}</pre></li>
				<li>Add the <code>setup_logger()</code> function to <code>src/main.rs</code>:<pre>async fn rocket() -&gt; Rocket&lt;Build&gt; {
    setup_logger();
...
}</pre></li>
				<li>Now, let's <a id="_idIndexMarker418"/>try to see <code>OurError</code> inside the application log. Try creating users with the same username; the application should emit a duplicate username error in the terminal and <code>logs/application.log</code> similar to the following:<pre>[[2021-11-21][17:50:49.366]] [ERROR][our_application::errors::our_error]
[Error: Some(PgDatabaseError { severity: Error, code: "23505", message:
"duplicate key value violates unique constraint \"users_username_key\""
, detail: Some("Key (username)=(karuna) already exists."), hint: None, p
osition: None, where: None, schema: Some("public"), table: Some("users")
, column: None, data_type: None, constraint: Some("users_username_key"),
file: Some("nbtinsert.c"), line: Some(649), routine: Some("_bt_check_un
ique") })]</pre></li>
			</ol>
			<p>Now that we <a id="_idIndexMarker419"/>have learned how to log errors, we can implement logging functionalities to improve the application. For example, we might want to create server-side analytics, or we can combine the logs with third-party monitoring as a service to improve the operations and create business intelligence.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>Summary</h1>
			<p>In this chapter, we have learned some ways to handle errors in Rust and Rocket applications. We can use <code>panic!</code>, <code>Option</code>, and <code>Result</code> as a way to propagate errors and create handling for the errors.</p>
			<p>We have also learned about creating a custom type that implements the <code>Error</code> trait. The type can store another error, creating an error chain.</p>
			<p>Finally, we learned ways to log errors in our application. We can also use log capability to improve the application itself.</p>
			<p>Our user pages are looking good, but using <code>String</code> all over the place is cumbersome, so in the next chapter, we are going to learn more about templating using CSS, JavaScript, and other assets in our application.</p>
		</div>
	</body></html>