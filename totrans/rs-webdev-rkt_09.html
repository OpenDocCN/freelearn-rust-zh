<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-91"><em class="italic"><a id="_idTextAnchor091"/>Chapter 7</em>: Handling Errors in Rust and Rocket</h1>
			<p>In the previous chapter, we learned about creating endpoints and SQL queries to handle the management of the <strong class="source-inline">User</strong> entity. In this chapter, we are going to learn more about error handling in Rust and Rocket. After learning the concepts in this chapter, you will be able to implement error handling in a Rocket application.</p>
			<p>We are also going to discuss more common ways to handle errors in Rust and Rocket, including signaling unrecoverable errors using the <strong class="source-inline">panic!</strong> macro and catching the <strong class="source-inline">panic!</strong> macro, using <strong class="source-inline">Option</strong>, using <strong class="source-inline">Result</strong>, creating a custom <strong class="source-inline">Error</strong> type, and logging the generated error.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Using panic!</li>
				<li>Using Option</li>
				<li>Returning Result</li>
				<li>Creating a custom error type</li>
				<li>Logging errors</li>
			</ul>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Technical requirements</h1>
			<p>For this chapter, we have the same technical requirements as the previous chapter. We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database server.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Using panic!</h1>
			<p>To understand error handling in Rust, we need to begin with the <strong class="source-inline">panic!</strong> macro. We can use the <strong class="source-inline">panic!</strong> macro when the application encounters an unrecoverable error and there's no purpose in continuing the application. If the application encounters <strong class="source-inline">panic!</strong>, the application will emit the backtrace and terminate.</p>
			<p>Let's try using <strong class="source-inline">panic!</strong> on the program <a id="_idIndexMarker392"/>that we created in the previous chapter. Suppose we want the application to read a secret file before we initialize Rocket. If the application cannot find this secret file, it will not continue.</p>
			<p>Let's get started:</p>
			<ol>
				<li>Add the following line in <strong class="source-inline">src/main.rs</strong>:<p class="source-code">use std::env;</p></li>
				<li>In the same file in the <strong class="source-inline">rocket()</strong> function, prepend the following lines:<p class="source-code">let secret_file_path = env::current_dir().unwrap().join("secret_file");</p><p class="source-code">if !secret_file_path.exists() {</p><p class="source-code">    panic!("secret does not exists");</p><p class="source-code">}</p></li>
				<li>Afterward, try executing <strong class="source-inline">cargo run</strong> without creating an empty file named <strong class="source-inline">secret_file</strong> inside the working directory. You should see the output as follows:<p class="source-code"><strong class="bold">thread 'main' panicked at 'secret does not exists', src/main.rs:15:9</strong></p><p class="source-code"><strong class="bold">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</strong></p></li>
				<li>Now, try running the application again with <strong class="source-inline">RUST_BACKTRACE=1 cargo run</strong>. You should see the backtrace output in the terminal similar to the following:<p class="source-code"><strong class="bold">RUST_BACKTRACE=1 cargo run </strong></p><p class="source-code"><strong class="bold">    Finished dev [unoptimized + debuginfo] target(s) </strong></p><p class="source-code"><strong class="bold">    in 0.18s</strong></p><p class="source-code"><strong class="bold">     Running `target/debug/our_application`</strong></p><p class="source-code"><strong class="bold">thread 'main' panicked at 'secret does not exists', src/main.rs:15:9</strong></p><p class="source-code"><strong class="bold">stack backtrace:</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">  14: our_application::main</strong></p><p class="source-code"><strong class="bold">             at ./src/main.rs:12:36</strong></p><p class="source-code"><strong class="bold">  15: core::ops::function::FnOnce::call_once</strong></p><p class="source-code"><strong class="bold">             at /rustc/59eed8a2aac0230a8b5</strong></p><p class="source-code"><strong class="bold">             3e89d4e99d55912ba6b35/library/core/</strong></p><p class="source-code"><strong class="bold">             src/ops/function.rs:227:5</strong></p><p class="source-code"><strong class="bold">note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.</strong></p></li>
				<li>Sometimes, we don't <a id="_idIndexMarker393"/>want to deallocate after panicking using the <strong class="source-inline">panic!</strong> macro because we want the application to exit as soon as possible. We can skip deallocating by setting <strong class="source-inline">panic = "abort"</strong> in <strong class="source-inline">Cargo.toml</strong> under the profile we are using. Setting that configuration will make our binary smaller and exit faster, and the operating system will need to clean it later. Let's try doing that. Set the following lines in <strong class="source-inline">Cargo.toml</strong> and run the application again:<p class="source-code">[profile.dev]</p><p class="source-code">panic = "abort"</p></li>
			</ol>
			<p>Now that we know how to use <strong class="source-inline">panic!</strong>, let's see how we can catch it in the next section.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Catching panic!</h2>
			<p>As well as using <strong class="source-inline">panic!</strong>, we can also use the <strong class="source-inline">todo!</strong> and <strong class="source-inline">unimplemented!</strong> macros in Rust code. Those macros are very useful for prototyping because they will call <strong class="source-inline">panic!</strong> while also allowing the code to type-check at compile time.</p>
			<p>But, why does <a id="_idIndexMarker394"/>Rocket not shut down when we are calling a route with <strong class="source-inline">todo!</strong>? If we check the Rocket source code, there's a <strong class="source-inline">catch_unwind</strong> function in <strong class="source-inline">src::panic</strong> that can be used to capture a panicking function. Let's see that code in the Rocket source code, <strong class="source-inline">core/lib/src/server.rs</strong>:</p>
			<pre class="source-code">let fut = std::panic::catch_unwind(move || run())</pre>
			<pre class="source-code">         .map_err(|e| panic_info!(name, e))</pre>
			<pre class="source-code">         .ok()?;</pre>
			<p>Here, <strong class="source-inline">run()</strong> is a route handling function. Each time we call a route that is panicking, the preceding routine will convert the panic into the result's <strong class="source-inline">Err</strong> variant. Try removing the <strong class="source-inline">secret_file_path</strong> routine we added before and running the application. Now, create a user and try going into user posts. For example, create a user with the <strong class="source-inline">95a54c16-e830-45c9-ba1d-5242c0e4c18f</strong> UUID. Try opening <strong class="source-inline">http://127.0.0.1/users/95a54c16-e830-45c9-ba1d-5242c0e4c18f/posts</strong>. Since we only put <strong class="source-inline">todo!("will implement later")</strong> in the function body, the application will panic, but the preceding <strong class="source-inline">catch_unwind</strong> function will catch the panic and convert it into an error. Please note that <strong class="source-inline">catch_unwind</strong> will not work if we set <strong class="source-inline">panic = "abort"</strong> in <strong class="source-inline">Cargo.toml</strong>.</p>
			<p>In a regular workflow, we don't usually want to use <strong class="source-inline">panic!</strong>, because panicking interrupts everything, and the program will not be able to continue. If the Rocket framework does not catch <strong class="source-inline">panic!</strong> and one of the route handling functions is panicking, then that single error will close the application and there will be nothing to handle the other requests. But, what if we want to terminate the Rocket application when we encounter an unrecoverable error? Let's see how we can do it in the next section.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Using shutdown</h2>
			<p>To shut <a id="_idIndexMarker395"/>down smoothly if the application encounters an unrecoverable error in the route handling function, we can use the <strong class="source-inline">rocket::Shutdown</strong> request guard. Remember, the request guard is a parameter we are supplying to the route handling functions.</p>
			<p>To see the <strong class="source-inline">Shutdown</strong> request guard in action, let's try implementing it in our application. Using <a id="_idIndexMarker396"/>the previous application, add a new route in <strong class="source-inline">src/routes/mod.rs</strong> called <strong class="source-inline">/shutdown</strong>:</p>
			<pre class="source-code">use rocket::Shutdown;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">#[get("/shutdown")]</pre>
			<pre class="source-code">pub async fn shutdown(shutdown: Shutdown) -&gt; &amp;'static str {</pre>
			<pre class="source-code">    // suppose this variable is from function which </pre>
			<pre class="source-code">    // produces irrecoverable error</pre>
			<pre class="source-code">    let result: Result&lt;&amp;str, &amp;str&gt; = Err("err");</pre>
			<pre class="source-code">    if result.is_err() {</pre>
			<pre class="source-code">        shutdown.notify();</pre>
			<pre class="source-code">        return "Shutting down the application.";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return "Not doing anything.";</pre>
			<pre class="source-code">}</pre>
			<p>Try adding the <strong class="source-inline">shutdown()</strong> function in <strong class="source-inline">src/main.rs</strong>. After that, rerun the application and send an HTTP request to <strong class="source-inline">/shutdown</strong> while monitoring the output of the application on the terminal. The application should shut down smoothly.</p>
			<p>In the next two sections, let's see how we can use <strong class="source-inline">Option</strong> and <strong class="source-inline">Result</strong> as an alternative way to handle errors.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Using Option</h1>
			<p>In programming, a routine might <a id="_idIndexMarker397"/>produce a correct result or encounter a problem. One classical example is division by zero. Dividing something by zero is mathematically undefined. If the application has a routine to divide something, and the routine encounters zero as input, the application cannot return any number. We want the application to return another type instead of a number. We need a type that can hold multiple variants of data.</p>
			<p>In Rust, we can <a id="_idIndexMarker398"/>define an <strong class="source-inline">enum</strong> type, a type that can be different variants of data. An <strong class="source-inline">enum</strong> type might be as follows:</p>
			<pre class="source-code">enum Shapes {</pre>
			<pre class="source-code">    None,</pre>
			<pre class="source-code">    Point(i8),</pre>
			<pre class="source-code">    Line(i8, i8),</pre>
			<pre class="source-code">    Rectangle {</pre>
			<pre class="source-code">        top: (i8, i8),</pre>
			<pre class="source-code">        length: u8,</pre>
			<pre class="source-code">        height: u8,</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">Point</strong> and <strong class="source-inline">Line</strong> are said to have <strong class="bold">unnamed fields</strong>, while <strong class="source-inline">Rectangle</strong> is said to have <strong class="bold">named fields</strong>. <strong class="source-inline">Rectangle</strong> can also <a id="_idIndexMarker399"/>be called a <strong class="bold">struct-like enum</strong> variant.</p>
			<p>If all members of <strong class="source-inline">enum</strong> have no data, we can add a discriminant on the member. Here is an example:</p>
			<pre class="source-code">enum Color {</pre>
			<pre class="source-code">    Red,         // 0</pre>
			<pre class="source-code">    Green = 127, // 127</pre>
			<pre class="source-code">    Blue,        // 128</pre>
			<pre class="source-code">}</pre>
			<p>We can assign <strong class="source-inline">enum</strong> to a variable, and use the variable in a function as in the following:</p>
			<pre class="source-code">fn do_something(<strong class="bold">color: Color</strong>) -&gt; Shapes {</pre>
			<pre class="source-code">    let rectangle = Shapes::Rectangle {</pre>
			<pre class="source-code">        top: (0, 2),</pre>
			<pre class="source-code">        length: 10,</pre>
			<pre class="source-code">        height: 8,</pre>
			<pre class="source-code">    };</pre>
			<pre class="source-code">    match <strong class="bold">color</strong> {</pre>
			<pre class="source-code">        <strong class="bold">Color::Red</strong> =&gt; Shapes::None,</pre>
			<pre class="source-code">        <strong class="bold">Color::Green</strong> =&gt; Shapes::Point(10),</pre>
			<pre class="source-code">        _ =&gt; rectangle,</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Going back <a id="_idIndexMarker400"/>to error handling, we can use <strong class="source-inline">enum</strong> to communicate that there's something wrong in our code. Going back to division by zero, here is an example:</p>
			<pre class="source-code">enum Maybe {</pre>
			<pre class="source-code">    WeCannotDoIt,</pre>
			<pre class="source-code">    WeCanDoIt(i8),</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fn check_divisible(input: i8) -&gt; Maybe {</pre>
			<pre class="source-code">    if input == 0 {</pre>
			<pre class="source-code">        return <strong class="bold">Maybe::WeCannotDoIt</strong>;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    <strong class="bold">Maybe::WeCanDoIt(input)</strong></pre>
			<pre class="source-code">}</pre>
			<p>The preceding pattern returning something or not returning something is very common, so Rust has its own enum to show whether we have something or not in the standard library, called <strong class="source-inline">std::option::Option</strong>:</p>
			<pre class="source-code">pub enum Option&lt;T&gt; {</pre>
			<pre class="source-code">    None,</pre>
			<pre class="source-code">    Some(T),</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">Some(T)</strong> is used to <a id="_idIndexMarker401"/>communicate that we have <strong class="source-inline">T</strong>, and <strong class="source-inline">None</strong> is obviously used to communicate that we don't have <strong class="source-inline">T</strong>. We used <strong class="source-inline">Option</strong> in some of the previous code. For example, we used it in the <strong class="source-inline">User</strong> struct:</p>
			<pre class="source-code">struct User {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    description: <strong class="bold">Option&lt;String&gt;,</strong></pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>We also used <strong class="source-inline">Option</strong> as a function parameter or return type:</p>
			<pre class="source-code">find_all(..., <strong class="bold">pagination: Option&lt;Pagination&gt;</strong>) -&gt; (..., <strong class="bold">Option&lt;Pagination&gt;</strong>), ... {}</pre>
			<p>There are many useful things we can use with <strong class="source-inline">Option</strong>. Suppose we have two variables, <strong class="source-inline">we_have_it</strong> and <strong class="source-inline">we_do_not_have_it</strong>:</p>
			<pre class="source-code">let we_have_it: Option&lt;usize&gt; = Some(1);</pre>
			<pre class="source-code">let we_do_not_have_it: Option&lt;usize&gt; = None;</pre>
			<ul>
				<li>One thing we can do is pattern matching and use the content:<p class="source-code">match we_have_it {</p><p class="source-code">    <strong class="bold">Some(t)</strong> =&gt; println!("The value = {}", t),</p><p class="source-code">    <strong class="bold">None</strong> =&gt; println!("We don't have it"),</p><p class="source-code">};</p></li>
				<li>We can process it in a more convenient way if we care about the content of <strong class="source-inline">we_have_it</strong>:<p class="source-code">if let <strong class="bold">Some(t)</strong> = we_have_it {</p><p class="source-code">    println!("The value = {}", t);</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">Option</strong> can be compared if the inner type implements <strong class="source-inline">std::cmp::Eq</strong> and <strong class="source-inline">std::cmp::Ord</strong>, that is, the inner type can be compared using <strong class="source-inline">==</strong>, <strong class="source-inline">!=</strong>, <strong class="source-inline">&gt;</strong>, and other comparison operators. Notice that we use <strong class="source-inline">assert!</strong>, a macro used for testing:<p class="source-code">assert!(we_have_it != we_do_not_have_it);</p></li>
				<li>We can check <a id="_idIndexMarker402"/>whether a variable is <strong class="source-inline">Some</strong> or <strong class="source-inline">None</strong>:<p class="source-code">assert!(we_have_it.<strong class="bold">is_some()</strong>);</p><p class="source-code">assert!(we_do_not_have_it.<strong class="bold">is_none()</strong>);</p></li>
				<li>We can also get the content by unwrapping <strong class="source-inline">Option</strong>. But, there's a caveat; unwrapping <strong class="source-inline">None</strong> will cause panic, so be careful when unwrapping <strong class="source-inline">Option</strong>. Notice we use <strong class="source-inline">assert_eq!</strong>, which is a macro used for testing to ensure equality:<p class="source-code">assert_eq!(we_have_it.<strong class="bold">unwrap()</strong>, 1);</p><p class="source-code">// assert_eq!(we_do_not_have_it.<strong class="bold">unwrap()</strong>, 1); </p><p class="source-code">// will panic</p></li>
				<li>We can also use the <strong class="source-inline">expect()</strong> method. This method will work the same with <strong class="source-inline">unwrap()</strong> but we can use a custom message:<p class="source-code">assert_eq!(we_have_it.<strong class="bold">expect("Oh no!")</strong>, 1);</p><p class="source-code">// assert_eq!(we_do_not_have_it.<strong class="bold">expect("Oh no!")</strong>, 1); // will panic</p></li>
				<li>We can unwrap and set the default value so it will not panic if we unwrap <strong class="source-inline">None</strong>:<p class="source-code">assert_eq!(we_have_it.<strong class="bold">unwrap_or(42)</strong>, 1);</p><p class="source-code">assert_eq!(we_do_not_have_it.<strong class="bold">unwrap_or(42)</strong>, 42);</p></li>
				<li>We can unwrap and set the default value with a closure:<p class="source-code">let x = 42;</p><p class="source-code">assert_eq!(we_have_it.<strong class="bold">unwrap_or_else(|| x)</strong>, 1);</p><p class="source-code">assert_eq!(we_do_not_have_it.<strong class="bold">unwrap_or_else(|| x)</strong>, 42);</p></li>
				<li>We can convert <a id="_idIndexMarker403"/>the value contained to something else using <strong class="source-inline">map()</strong>, <strong class="source-inline">map_or()</strong>, or <strong class="source-inline">map_or_else()</strong>:<p class="source-code">assert_eq!(we_have_it.<strong class="bold">map</strong>(|v| format!("The value = {}", v)), Some("The value = 1".to_string()));</p><p class="source-code">assert_eq!(we_do_not_have_it.<strong class="bold">map</strong>(|v| format!("The value = {}", v)), None);</p><p class="source-code">assert_eq!(we_have_it.<strong class="bold">map_or</strong>("Oh no!".to_string(), |v| format!("The value = {}", v)), "The value = 1".to_string());</p><p class="source-code">assert_eq!(we_do_not_have_it.<strong class="bold">map_or</strong>("Oh no!".to_string(), |v| format!("The value = {}", v)), "Oh no!".to_string());</p><p class="source-code">assert_eq!(we_have_it.<strong class="bold">map_or_else</strong>(|| "Oh no!".to_string(), |v| format!("The value = {}", v)), "The value = 1".to_string());</p><p class="source-code">assert_eq!(we_do_not_have_it.<strong class="bold">map_or_else</strong>(|| "Oh no!".to_string(), |v| format!("The value = {}", v)), "Oh no!".to_string());</p></li>
			</ul>
			<p>There are other important methods, which you can check in the documentation for <strong class="source-inline">std::option::Option</strong>. Even though we can use <strong class="source-inline">Option</strong> to handle a situation where there's something or nothing, it does not convey a message of <em class="italic">something went wrong</em>. We can use another type similar to <strong class="source-inline">Option</strong> in the next part to achieve this.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Returning Result</h1>
			<p>In Rust, we have the <strong class="source-inline">std::result::Result</strong> enum that works like <strong class="source-inline">Option</strong>, but instead of <a id="_idIndexMarker404"/>saying <em class="italic">we have it</em> or <em class="italic">we don't have it</em>, the <strong class="source-inline">Result</strong> type is more about saying <em class="italic">we have it</em> or <em class="italic">we have this error</em>. Just like <strong class="source-inline">Option</strong>, <strong class="source-inline">Result</strong> is an <strong class="source-inline">enum</strong> type of the possible <strong class="source-inline">T</strong> type or possible <strong class="source-inline">E</strong> error:</p>
			<pre class="source-code">enum Result&lt;T, E&gt; {</pre>
			<pre class="source-code">   Ok(T),</pre>
			<pre class="source-code">   Err(E),</pre>
			<pre class="source-code">}</pre>
			<p>Going back to the division by zero problem, take a look at the following simple example:</p>
			<pre class="source-code">fn division(a: usize, b: usize) -&gt; Result&lt;f64, String&gt; {</pre>
			<pre class="source-code">    if b == 0 {</pre>
			<pre class="source-code">        return Err(String::from("division by zero"));</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return Ok(a as f64 / b as f64);</pre>
			<pre class="source-code">}</pre>
			<p>We don't want division by <strong class="source-inline">0</strong>, so we return an error for the preceding function.</p>
			<p>Similar to <strong class="source-inline">Option</strong>, <strong class="source-inline">Result</strong> has many convenient features we can use. Suppose we have the <strong class="source-inline">we_have_it</strong> and <strong class="source-inline">we_have_error</strong> variables:</p>
			<pre class="source-code">let we_have_it: Result&lt;usize, &amp;'static str&gt; = Ok(1);</pre>
			<pre class="source-code">let we_have_error: Result&lt;usize, &amp;'static str&gt; = Err("Oh no!");</pre>
			<ul>
				<li>We can get the value or the error using pattern matching:<p class="source-code">match we_have_it {</p><p class="source-code">    <strong class="bold">Ok(v)</strong> =&gt; println!("The value = {}", v),</p><p class="source-code">    <strong class="bold">Err(e)</strong> =&gt; println!("The error = {}", e),</p><p class="source-code">};</p></li>
				<li>Or, we can use <strong class="source-inline">if let</strong> to destructure and get the value or the error:<p class="source-code">if let <strong class="bold">Ok(v)</strong> = we_have_it {</p><p class="source-code">    println!("The value = {}", v);</p><p class="source-code">}</p><p class="source-code">if let <strong class="bold">Err(e)</strong> = we_have_error {</p><p class="source-code">    println!("The error = {}", e);</p><p class="source-code">}</p></li>
				<li>We can compare the <strong class="source-inline">Ok</strong> variant and the <strong class="source-inline">Err</strong> variant:<p class="source-code">assert!(we_have_it != we_have_error);</p></li>
				<li>We can <a id="_idIndexMarker405"/>check whether a variable is an <strong class="source-inline">Ok</strong> variant or an <strong class="source-inline">Err</strong> variant:<p class="source-code">assert!(we_have_it<strong class="bold">.is_ok());</strong></p><p class="source-code">assert!(we_have_error<strong class="bold">.is_err()</strong>);</p></li>
				<li>We can convert <strong class="source-inline">Result</strong> to <strong class="source-inline">Option</strong>:<p class="source-code">assert_eq!(we_have_it.ok(), Some(1));</p><p class="source-code">assert_eq!(we_have_error.ok(), None);</p><p class="source-code">assert_eq!(we_have_it.err(), None);</p><p class="source-code">assert_eq!(we_have_error.err(), Some("Oh no!"));</p></li>
				<li>Just like <strong class="source-inline">Option</strong>, we can use <strong class="source-inline">unwrap()</strong>, <strong class="source-inline">unwrap_or()</strong>, or <strong class="source-inline">unwrap_or_else()</strong>:<p class="source-code">assert_eq!(we_have_it.<strong class="bold">unwrap()</strong>, 1);</p><p class="source-code">// assert_eq!(we_have_error.<strong class="bold">unwrap()</strong>, 1); </p><p class="source-code">// panic</p><p class="source-code">assert_eq!(we_have_it.<strong class="bold">expect("Oh no!")</strong>, 1);</p><p class="source-code">// assert_eq!(we_have_error.<strong class="bold">expect("Oh no!")</strong>, 1);</p><p class="source-code">// panic</p><p class="source-code">assert_eq!(we_have_it.<strong class="bold">unwrap_or(0)</strong>, 1);</p><p class="source-code">assert_eq!(we_have_error.<strong class="bold">unwrap_or(0)</strong>, 0);</p><p class="source-code">assert_eq!(we_have_it.<strong class="bold">unwrap_or_else(|_| 0),</strong> 1);</p><p class="source-code">assert_eq!(we_have_error.<strong class="bold">unwrap_or_else(|_| 0)</strong>, 0);</p></li>
				<li>And, we <a id="_idIndexMarker406"/>can use <strong class="source-inline">map()</strong>, <strong class="source-inline">map_err()</strong>, <strong class="source-inline">map_or()</strong>, or <strong class="source-inline">map_or_else()</strong>:<p class="source-code">assert_eq!(we_have_it.<strong class="bold">map</strong>(|v| format!("The value = {}", v)), Ok("The value = 1".to_string()));</p><p class="source-code">assert_eq!(</p><p class="source-code">    we_have_error.<strong class="bold">map</strong>(|v| format!("The error = {}", </p><p class="source-code">    v)),</p><p class="source-code">    Err("Oh no!")</p><p class="source-code">);</p><p class="source-code">assert_eq!(we_have_it.<strong class="bold">map_err</strong>(|s| s.len()), Ok(1));</p><p class="source-code">assert_eq!(we_have_error.<strong class="bold">map_err</strong>(|s| s.len()), Err(6));</p><p class="source-code">assert_eq!(we_have_it.<strong class="bold">map_or</strong>("Default value".to_string(), |v| format!("The value = {}", v)), "The value = 1".to_string());</p><p class="source-code">assert_eq!(we_have_error.<strong class="bold">map_or</strong>("Default value".to_string(), |v| format!("The value = {}", v)), "Default value".to_string());</p><p class="source-code">assert_eq!(we_have_it.<strong class="bold">map_or_else</strong>(|_| "Default value".to_string(), |v| format!("The value = {}", v)), "The value = 1".to_string());</p><p class="source-code">assert_eq!(we_have_error.<strong class="bold">map_or_else</strong>(|_| "Default value".to_string(), |v| format!("The value = {}", v)), "Default value".to_string());</p></li>
			</ul>
			<p>There are other important methods besides those methods in the <strong class="source-inline">std::result::Result</strong> documentation. Do check them because <strong class="source-inline">Option</strong> and <strong class="source-inline">Result</strong> are very important in Rust and Rocket.</p>
			<p>Returning a <a id="_idIndexMarker407"/>string or numbers as an error might be acceptable in some cases, but most likely, we want a real error type with a message and possible backtrace that we can process further. In the next section, we are going to learn about (and use) the <strong class="source-inline">Error</strong> trait and return the dynamic error type in our application.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Creating a custom error type</h1>
			<p>Rust has a <a id="_idIndexMarker408"/>trait to unify propagating errors by providing the <strong class="source-inline">std::error::Error</strong> trait. Since the <strong class="source-inline">Error</strong> trait is defined as <strong class="source-inline">pub trait Error: Debug + Display</strong>, any type that implements <strong class="source-inline">Error</strong> should also implement the <strong class="source-inline">Debug</strong> and <strong class="source-inline">Display</strong> traits.</p>
			<p>Let's see how we can create a custom error type by creating a new module:</p>
			<ol>
				<li value="1">In <strong class="source-inline">src/lib.rs</strong>, add the new <strong class="source-inline">errors</strong> module:<p class="source-code">pub mod errors;</p></li>
				<li>After that, create a new folder, <strong class="source-inline">src/errors</strong>, and add the <strong class="source-inline">src/errors/mod.rs</strong> and <strong class="source-inline">src/errors/our_error.rs</strong> files. In <strong class="source-inline">src/errors/mod.rs</strong>, add this line:<p class="source-code">pub mod our_error;</p></li>
				<li>In <strong class="source-inline">src/errors/our_error.rs</strong>, add the custom type for <strong class="source-inline">error</strong>:<p class="source-code">use rocket::http::Status;</p><p class="source-code">use std::error::Error;</p><p class="source-code">use std::fmt;</p><p class="source-code">#[derive(Debug)]</p><p class="source-code">pub struct OurError {</p><p class="source-code">    pub status: Status,</p><p class="source-code">    pub message: String,</p><p class="source-code">    debug: Option&lt;Box&lt;dyn Error&gt;&gt;,</p><p class="source-code">}</p><p class="source-code">impl fmt::Display for OurError {</p><p class="source-code">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; </p><p class="source-code">    fmt::Result {</p><p class="source-code">        write!(f, "{}", &amp;self.message)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Then, we can <a id="_idIndexMarker409"/>implement the <strong class="source-inline">Error</strong> trait for <strong class="source-inline">OurError</strong>. In <strong class="source-inline">src/errors/our_error.rs</strong>, add the following lines:<p class="source-code">impl Error for OurError {</p><p class="source-code">    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {</p><p class="source-code">        if self.debug.is_some() {</p><p class="source-code">            self.debug.as_ref().unwrap().source();</p><p class="source-code">        }</p><p class="source-code">        None</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Currently, for the <strong class="source-inline">User</strong> module, we return a <strong class="source-inline">Result&lt;..., Box&lt;dyn Error&gt;&gt;</strong> dynamic error for each method. This is a common pattern of returning an error by using any type that implements <strong class="source-inline">Error</strong> and then putting the instance in the heap using <strong class="source-inline">Box</strong>.</p>
			<p>The problem with this approach is we can only use methods provided by the <strong class="source-inline">Error</strong> trait, that is, <strong class="source-inline">source()</strong>. We want to be able to use the <strong class="source-inline">OurError</strong> status, message, and debug information.</p>
			<ol>
				<li value="5">So, let's add <a id="_idIndexMarker410"/>a couple of builder methods to <strong class="source-inline">OurError</strong>. In <strong class="source-inline">src/errors/our_error.rs</strong>, add the following lines:<p class="source-code">impl OurError {</p><p class="source-code">    fn new_error_with_status(status: Status, message: </p><p class="source-code">    String, debug: Option&lt;Box&lt;dyn Error&gt;&gt;) -&gt; Self {</p><p class="source-code">        OurError {</p><p class="source-code">            status,</p><p class="source-code">            message,</p><p class="source-code">            debug,</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    pub fn new_bad_request_error(message: String, </p><p class="source-code">    debug: Option&lt;Box&lt;dyn Error&gt;&gt;) -&gt; Self {</p><p class="source-code">        Self::new_error_with_status(Status::</p><p class="source-code">        BadRequest, message, debug)</p><p class="source-code">    }</p><p class="source-code">    pub fn new_not_found_error(message: String,</p><p class="source-code">    debug: Option&lt;Box&lt;dyn Error&gt;&gt;) -&gt; Self {</p><p class="source-code">        Self::new_error_with_status(Status::NotFound, </p><p class="source-code">        message, debug)</p><p class="source-code">    }</p><p class="source-code">    pub fn new_internal_server_error(</p><p class="source-code">        message: String,</p><p class="source-code">        debug: Option&lt;Box&lt;dyn Error&gt;&gt;,</p><p class="source-code">    ) -&gt; Self {</p><p class="source-code">        Self::new_error_with_status(Status::</p><p class="source-code">        InternalServerError, message, debug)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>If we take <a id="_idIndexMarker411"/>a look at <strong class="source-inline">src/models/user.rs</strong>, there are three sources of errors: <strong class="source-inline">sqlx::Error</strong>, <strong class="source-inline">uuid::Error</strong>, and <strong class="source-inline">argon2</strong>. Let's create a conversion for <strong class="source-inline">sqlx::Error</strong> and <strong class="source-inline">uuid::Error</strong> to <strong class="source-inline">OurError</strong>. Add the following <strong class="source-inline">use</strong> directive in <strong class="source-inline">src/errors/our_error.rs</strong>:<p class="source-code">use sqlx::Error as sqlxError;</p><p class="source-code">use uuid::Error as uuidError;</p></li>
				<li>Inside the same file, <strong class="source-inline">src/errors/our_error.rs</strong>, add the following lines:<p class="source-code">impl OurError {</p><p class="source-code">    ...</p><p class="source-code">    pub fn from_uuid_error(e: uuidError) -&gt; Self {</p><p class="source-code">        OurError::new_bad_request_error(</p><p class="source-code">            String::from("Something went wrong"),</p><p class="source-code">            Some(Box::new(e)))</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>For <strong class="source-inline">sqlx::Error</strong>, we want to convert <strong class="source-inline">not_found</strong> error to HTTP status <strong class="source-inline">404</strong> and duplicate <a id="_idIndexMarker412"/>index error to an HTTP status 400bad request. Add the following lines to <strong class="source-inline">src/errors/our_error.rs</strong>:<p class="source-code">use std::borrow::Cow;</p><p class="source-code">....</p><p class="source-code">impl OurError {</p><p class="source-code">    ....</p><p class="source-code">    pub fn from_sqlx_error(e: sqlxError) -&gt; Self {</p><p class="source-code">        match e {</p><p class="source-code">            sqlxError::RowNotFound =&gt; {</p><p class="source-code">                OurError::new_not_found_error(</p><p class="source-code">                    String::from("Not found"),</p><p class="source-code">                    Some(Box::new(e)))</p><p class="source-code">            }</p><p class="source-code">            sqlxError::Database(db) =&gt; {</p><p class="source-code">                if db.code().unwrap_or(Cow::</p><p class="source-code">                Borrowed("2300")).starts_with("23") {</p><p class="source-code">                    return OurError::new_bad_</p><p class="source-code">                    request_error(</p><p class="source-code">                        String::from("Cannot create or </p><p class="source-code">                        update resource"),</p><p class="source-code">                        Some(Box::new(db)),</p><p class="source-code">                    );</p><p class="source-code">                }</p><p class="source-code">                OurError::new_internal_server_error(</p><p class="source-code">                    String::from("Something went </p><p class="source-code">                    wrong"),</p><p class="source-code">                    Some(Box::new(db)),</p><p class="source-code">                )</p><p class="source-code">            }</p><p class="source-code">            _ =&gt; OurError::new_internal_server_error(</p><p class="source-code">                String::from("Something went wrong"),</p><p class="source-code">                Some(Box::new(e)),</p><p class="source-code">            ),</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We need to <a id="_idIndexMarker413"/>do one more thing before we modify our <strong class="source-inline">User</strong> entity. Some crates in Rust do not compile the <strong class="source-inline">std</strong> library by default to make the resulting binary smaller and embeddable in IoT (Internet of Things) devices or WebAssembly. For example, the <strong class="source-inline">argon2</strong> crate does not include the <strong class="source-inline">Error</strong> trait implementation by default, so we need to enable the <strong class="source-inline">std</strong> feature. In <strong class="source-inline">Cargo.toml</strong>, modify the <strong class="source-inline">argon2</strong> dependencies to enable the <strong class="source-inline">std</strong> library features:<p class="source-code">argon2 = {version = "0.3", features = ["std"]}</p></li>
				<li>In <strong class="source-inline">src/models/user.rs</strong>, delete <strong class="source-inline">use std::error::Error;</strong> and replace it with <strong class="source-inline">use crate::errors::our_error::OurError;</strong>. Then, we can replace the methods for <strong class="source-inline">User</strong> to use <strong class="source-inline">OurError</strong> instead. Here is an example:<p class="source-code">pub async fn find(connection: &amp;mut PgConnection, uuid: &amp;str) -&gt; Result&lt;Self, <strong class="bold">OurError</strong>&gt; {</p><p class="source-code">    let parsed_uuid = Uuid::parse_str(</p><p class="source-code">    uuid).map_err(<strong class="bold">OurError::from_uuid_error</strong>)?;</p><p class="source-code">    let query_str = "SELECT * FROM users WHERE uuid = </p><p class="source-code">    $1";</p><p class="source-code">    Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)</p><p class="source-code">        .bind(parsed_uuid)</p><p class="source-code">        .fetch_one(connection)</p><p class="source-code">        .await</p><p class="source-code">        .map_err(<strong class="bold">OurError::from_sqlx_error</strong>)?)</p><p class="source-code">}</p></li>
				<li>For the <strong class="source-inline">argon2</strong> error, we can create a function or method, or convert it manually. For <a id="_idIndexMarker414"/>example, in <strong class="source-inline">src/models/user.rs</strong>, we can do this:<p class="source-code">let password_hash = argon2</p><p class="source-code">    .hash_password(new_user.password.as_bytes(), </p><p class="source-code">     &amp;salt)</p><p class="source-code">    .map_err(|<strong class="bold">e</strong>| {</p><p class="source-code">        <strong class="bold">OurError::new_internal_server_error(</strong></p><p class="source-code"><strong class="bold">            String::from("Something went wrong"),</strong></p><p class="source-code"><strong class="bold">            Some(Box::new(e)),</strong></p><p class="source-code"><strong class="bold">        )</strong></p><p class="source-code">    })?;</p></li>
			</ol>
			<p>Change all the methods to use <strong class="source-inline">OurError</strong>. Just a reminder: you can find the complete source code for <strong class="source-inline">src/models/user.rs</strong> in the GitHub repository at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07</a>.</p>
			<ol>
				<li value="12">We will then use the <strong class="source-inline">OurError</strong> status and message in <strong class="source-inline">src/routes/user.rs</strong>. Because the <strong class="source-inline">Error</strong> type already implements the <strong class="source-inline">Display</strong> trait, we can use <strong class="source-inline">e</strong> directly inside <strong class="source-inline">format!()</strong>. Here is an example:<p class="source-code">pub async fn get_user(...) -&gt; HtmlResponse {</p><p class="source-code">...</p><p class="source-code">    let user = User::find(connection, </p><p class="source-code">    uuid).await.map_err(|<strong class="bold">e</strong>| <strong class="bold">e.status</strong>)?;</p><p class="source-code">...</p><p class="source-code">}</p><p class="source-code">...</p><p class="source-code">pub async fn delete_user(...) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {</p><p class="source-code">...</p><p class="source-code">    User::destroy(connection, uuid)</p><p class="source-code">        .await</p><p class="source-code">        .map_err(|e| Flash::error(Redirect::to("/</p><p class="source-code">         users"), format!("&lt;div&gt;<strong class="bold">{}</strong>&lt;/div&gt;", <strong class="bold">e</strong>)))?;</p><p class="source-code">...</p><p class="source-code">}</p></li>
			</ol>
			<p>You can find the complete source code for <strong class="source-inline">src/routes/user.rs</strong> in the GitHub repository. Now <a id="_idIndexMarker415"/>that we have implemented errors, it might be a good time to try to implement the catchers that we defined before in <strong class="source-inline">src/catchers/mod.rs</strong> to show default errors for the user. You can also see the example of the default catchers in the source code.</p>
			<p>In an application, tracking and logging errors are an important part of maintaining the application. Since we implemented the <strong class="source-inline">Error</strong> trait, we can log the <strong class="source-inline">source()</strong> of an error in our application. Let's take a look at how to do that in the next section.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Logging errors</h1>
			<p>In Rust, there's a log crate that provides a facade for application logging. The log provides five macros: <strong class="source-inline">error!</strong>, <strong class="source-inline">warn!,</strong> <strong class="source-inline">info!</strong>, <strong class="source-inline">debug!</strong>, and <strong class="source-inline">trace!</strong>. An application can then create <a id="_idIndexMarker416"/>a log based on the severity and filter what needs to be logged, also based on the severity. For example, if we filter based on <strong class="source-inline">warn</strong>, then we only log <strong class="source-inline">error!</strong> and <strong class="source-inline">warn!</strong> and ignore the rest. Since the log crate does not implement the logging itself, people often use another crate to do the actual implementation. In the documentation for the log crate, we can find examples of other logging crates that can be used: <strong class="source-inline">env_logger</strong>, <strong class="source-inline">simple_logger,</strong> <strong class="source-inline">simplelog</strong>, <strong class="source-inline">pretty_env_logger</strong>, <strong class="source-inline">stderrlog</strong>, <strong class="source-inline">flexi_logger</strong>, <strong class="source-inline">log4rs</strong>, <strong class="source-inline">fern</strong>, <strong class="source-inline">syslog</strong>, and <strong class="source-inline">slog-stdlog</strong>.</p>
			<p>Let's implement custom logging in our application. We will use the <strong class="source-inline">fern</strong> crate for logging and wrap that in <strong class="source-inline">async_log</strong> to make logging asynchronous:</p>
			<ol>
				<li value="1">First, add these crates in <strong class="source-inline">Cargo.toml</strong>:<p class="source-code">async-log = "2.0.0"</p><p class="source-code">fern = "0.6"</p><p class="source-code">log = "0.4"</p></li>
				<li>In <strong class="source-inline">Rocket.toml</strong>, add the config for <strong class="source-inline">log_level</strong>:<p class="source-code">log_level = "normal"</p></li>
				<li>We can then create the function to initialize a global logger in our application. In <strong class="source-inline">src/main.rs</strong>, create a new function called <strong class="source-inline">setup_logger</strong>:<p class="source-code">fn setup_logger() {}</p></li>
				<li>Inside the function, let's initialize the logger:<p class="source-code">use log::LevelFilter;</p><p class="source-code">...</p><p class="source-code">let (level, logger) = fern::Dispatch::new()</p><p class="source-code">    .format(move |out, message, record| {</p><p class="source-code">        out.finish(format_args!(</p><p class="source-code">            "[{date}] [{level}][{target}] [{</p><p class="source-code">             message}]",</p><p class="source-code">            date = chrono::Local::now().format("[</p><p class="source-code">            %Y-%m-%d][%H:%M:%S%.3f]"),</p><p class="source-code">            target = record.target(),</p><p class="source-code">            level = record.level(),</p><p class="source-code">            message = message</p><p class="source-code">        ))</p><p class="source-code">    })</p><p class="source-code">    .level(LevelFilter::Info)</p><p class="source-code">    .chain(std::io::stdout())</p><p class="source-code">    .chain(</p><p class="source-code">        fern::log_file("logs/application.log")</p><p class="source-code">            .unwrap_or_else(|_| panic!("Cannot open </p><p class="source-code">            logs/application.log")),</p><p class="source-code">    )</p><p class="source-code">    .into_log();</p></li>
			</ol>
			<p>First, we create <a id="_idIndexMarker417"/>a new instance of <strong class="source-inline">fern::Dispatch</strong>. After that, we configure the output format using the <strong class="source-inline">format()</strong> method. After setting the output format, we set the log level using the <strong class="source-inline">level()</strong> method.</p>
			<p>For the logger, we want to not only output the log to the operating system <strong class="source-inline">stdout</strong>, but we also want to write to a log file. We can do it using the <strong class="source-inline">chain()</strong> method. To avoid panicking, don't forget to create a <strong class="source-inline">logs</strong> folder in the application directory.</p>
			<ol>
				<li value="5">After we set up the level and logger, we wrap it inside <strong class="source-inline">async_log</strong>:<p class="source-code">async_log::Logger::wrap(logger, || 0).start(level).unwrap();</p></li>
				<li>We will log <strong class="source-inline">OurError</strong> when it's created. Inside <strong class="source-inline">src/errors/our_error.rs</strong>, add the following lines:<p class="source-code">impl OurError {</p><p class="source-code">    fn new_error_with_status(...) ... {</p><p class="source-code">        <strong class="bold">if debug.is_some() {</strong></p><p class="source-code"><strong class="bold">            log::error!("Error: {:?}", &amp;debug);</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">        ...</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add the <strong class="source-inline">setup_logger()</strong> function to <strong class="source-inline">src/main.rs</strong>:<p class="source-code">async fn rocket() -&gt; Rocket&lt;Build&gt; {</p><p class="source-code">    setup_logger();</p><p class="source-code">...</p><p class="source-code">}</p></li>
				<li>Now, let's <a id="_idIndexMarker418"/>try to see <strong class="source-inline">OurError</strong> inside the application log. Try creating users with the same username; the application should emit a duplicate username error in the terminal and <strong class="source-inline">logs/application.log</strong> similar to the following:<p class="source-code">[[2021-11-21][17:50:49.366]] [ERROR][our_application::errors::our_error]</p><p class="source-code">[Error: Some(PgDatabaseError { severity: Error, code: "23505", message:</p><p class="source-code">"duplicate key value violates unique constraint \"users_username_key\""</p><p class="source-code">, detail: Some("Key (username)=(karuna) already exists."), hint: None, p</p><p class="source-code">osition: None, where: None, schema: Some("public"), table: Some("users")</p><p class="source-code">, column: None, data_type: None, constraint: Some("users_username_key"),</p><p class="source-code">file: Some("nbtinsert.c"), line: Some(649), routine: Some("_bt_check_un</p><p class="source-code">ique") })]</p></li>
			</ol>
			<p>Now that we <a id="_idIndexMarker419"/>have learned how to log errors, we can implement logging functionalities to improve the application. For example, we might want to create server-side analytics, or we can combine the logs with third-party monitoring as a service to improve the operations and create business intelligence.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>Summary</h1>
			<p>In this chapter, we have learned some ways to handle errors in Rust and Rocket applications. We can use <strong class="source-inline">panic!</strong>, <strong class="source-inline">Option</strong>, and <strong class="source-inline">Result</strong> as a way to propagate errors and create handling for the errors.</p>
			<p>We have also learned about creating a custom type that implements the <strong class="source-inline">Error</strong> trait. The type can store another error, creating an error chain.</p>
			<p>Finally, we learned ways to log errors in our application. We can also use log capability to improve the application itself.</p>
			<p>Our user pages are looking good, but using <strong class="source-inline">String</strong> all over the place is cumbersome, so in the next chapter, we are going to learn more about templating using CSS, JavaScript, and other assets in our application.</p>
		</div>
	</body></html>