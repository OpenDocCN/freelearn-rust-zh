- en: Integrating Rust with Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Rust 与其他语言集成
- en: In today's application landscape, integration is key. Whether you are slowly
    modernizing a legacy service or starting from scratch with using a new language,
    programs rarely run in isolation nowadays. Rust is still an exotic technology
    for many companies and—unfortunately—is usually not considered in the typical
    SDK. This is why Rust made a point of *playing nicely with others*, which is why
    the community can (and will) supply a large number of drivers, service integrations,
    and so on, by wrapping other (native) libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的应用程序领域，集成是关键。无论您是缓慢地现代化旧服务还是从头开始使用新语言，现在的程序很少是独立运行的。对于许多公司来说，Rust 仍然是一种异类技术——不幸的是，它通常不被考虑在典型的
    SDK 中。这就是为什么 Rust 强调了与其他技术的良好协作，这也是为什么社区可以（并将）通过包装其他（本地）库来提供大量的驱动程序、服务集成等。
- en: As developers, we rarely have the luxury of starting completely from scratch
    (greenfield projects), so in this chapter, we will cover the various ways the
    Rust language integrates with other languages and technologies. We'll focus on
    the most popular and useful integrations at the time of writing, but these fundamentals
    should provide a basis for greater interoperability as well since many languages
    provide an interface for native binaries (such as .NET ([https://docs.microsoft.com/en-us/cpp/dotnet/calling-native-functions-from-managed-code?view=vs-2019](https://docs.microsoft.com/en-us/cpp/dotnet/calling-native-functions-from-managed-code?view=vs-2019)) or
    Java's JNI ([https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html#wp9502](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html#wp9502))).
    With that knowledge, adding Rust to enhance your web application should be just
    as easy as creating a sensor driver wrapper for the manufacturer's code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们很少有机会从头开始（绿色项目），因此在本章中，我们将介绍 Rust 语言与其他语言和技术集成的各种方式。我们将重点关注撰写时的最流行和最有用的集成，但这些基础知识也应该为更大的互操作性提供基础，因为许多语言都提供了用于本地二进制的接口（例如
    .NET ([https://docs.microsoft.com/en-us/cpp/dotnet/calling-native-functions-from-managed-code?view=vs-2019](https://docs.microsoft.com/en-us/cpp/dotnet/calling-native-functions-from-managed-code?view=vs-2019)）或
    Java 的 JNI ([https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html#wp9502](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html#wp9502)））。有了这些知识，添加
    Rust 来增强您的 Web 应用程序应该和创建制造商代码的传感器驱动程序包装一样简单。
- en: 'We believe that good integration is important for the success of a language.
    In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，良好的集成对于语言的成功至关重要。在本章中，我们将介绍以下食谱：
- en: Including legacy C code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含旧 C 代码
- en: Calling into Rust from Node.js using FFI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 FFI 从 Node.js 调用 Rust
- en: Running Rust in the browser
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中运行 Rust
- en: Using Rust and Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rust 和 Python
- en: Generating bindings for legacy applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为旧应用生成绑定
- en: Including legacy C code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含旧 C 代码
- en: C is still among the most popular programming languages ([https://www.tiobe.com/tiobe-index/](https://www.tiobe.com/tiobe-index/))
    thanks to its versatility, speed, and simplicity. Due to this, many applications—legacy
    or not—are developed using C, with all of its upsides and downsides. Rust shares
    a domain with C—systems programming, which is why more and more companies replace
    their C code with Rust thanks to its safety and appeal as a modern programming
    language. However, changes are not always made in one big bang ([https://www.linkedin.com/pulse/big-bang-vs-iterative-dilemma-martijn-endenburg/](https://www.linkedin.com/pulse/big-bang-vs-iterative-dilemma-martijn-endenburg/));
    it's usually a much more gradual (iterative) approach that includes swapping out
    components and replacing parts of an application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其多功能性、速度和简单性，C 仍然是最受欢迎的编程语言之一 ([https://www.tiobe.com/tiobe-index/](https://www.tiobe.com/tiobe-index/))。因此，许多应用程序——无论是旧应用还是新应用——都是使用
    C 开发的，既有其优点也有其缺点。Rust 与 C 共享一个领域——系统编程，这就是为什么越来越多的公司用 Rust 替换其 C 代码，因为 Rust 作为一种现代编程语言具有安全性和吸引力。然而，变化并不总是以一次性的大爆炸（[https://www.linkedin.com/pulse/big-bang-vs-iterative-dilemma-martijn-endenburg/](https://www.linkedin.com/pulse/big-bang-vs-iterative-dilemma-martijn-endenburg/)）形式发生；通常是一个更加渐进的（迭代）方法，包括替换组件和替换应用程序的部分。
- en: Here, we use the C code as an analogy because it's popular and well known. However,
    these techniques apply to any (natively) compiled technology, such as Go, C++,
    or even Fortran. So let's get to it!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 C 代码作为类比，因为它流行且广为人知。然而，这些技术适用于任何（本地）编译的技术，例如 Go、C++，甚至是 Fortran。所以，让我们开始吧！
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we are not only building Rust but also C. For this, we need
    a C compiler toolchain—`gcc` ([https://gcc.gnu.org/](https://gcc.gnu.org/)) and `make`:
    [https://www.gnu.org/software/make/manual/make.html](https://www.gnu.org/software/make/manual/make.html),
    which is a rule-based scripting engine for executing the build.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们不仅构建Rust，还构建C。为此，我们需要一个C编译器工具链——`gcc` ([https://gcc.gnu.org/](https://gcc.gnu.org/))
    和 `make`：[https://www.gnu.org/software/make/manual/make.html](https://www.gnu.org/software/make/manual/make.html)，这是一个基于规则的脚本引擎，用于执行构建。
- en: 'Check whether the tools are installed by opening a Terminal window (note that
    the versions should be similar—at least the major release—to avoid any unexpected
    differences):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 检查工具是否已安装，方法是在终端窗口中打开（注意版本应该相似——至少是主要版本——以避免任何意外差异）：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If these commands are not available on your machine, check how to install them
    on your operating system. In any **Linux/Unix** environment (including the WSL—the
    **Windows Subsystem for Linux**: [https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)),
    they can require the installation of `gcc` and `make` via the default package
    repositories. On some distributions (for example, Ubuntu), bundles such as `build_essentials` ([https://packages.ubuntu.com/xenial/build-essential](https://packages.ubuntu.com/xenial/build-essential))
    provide these tools as well.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些命令在你的机器上不可用，请检查如何在你的操作系统上安装它们。在任何**Linux/Unix**环境中（包括WSL——Windows子系统对于Linux：[https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)），它们可能需要通过默认的软件仓库安装`gcc`和`make`。在某些发行版中（例如Ubuntu），如`build_essential`（[https://packages.ubuntu.com/xenial/build-essential](https://packages.ubuntu.com/xenial/build-essential)）这样的捆绑包也提供了这些工具。
- en: On macOS, check out Homebrew, which provides a similar experience and provides `gcc` as
    well as `make`: [https://brew.sh/](https://brew.sh/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，检查Homebrew，它提供类似的经验并提供`gcc`以及`make`：[https://brew.sh/](https://brew.sh/)。
- en: Windows users have a choice between the WSL (and then following the Linux instructions)
    or using Cygwin ([https://www.cygwin.com](https://www.cygwin.com)) to find `gcc-core`
    and `make` there. We recommended adding these tools (by default, `C:\cygwin64\bin`)
    to the `PATH` variable on Windows ([https://www.java.com/en/download/help/path.xml](https://www.java.com/en/download/help/path.xml)),
    so a regular (PowerShell) Terminal can access Cygwin's executables.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户可以选择使用WSL（然后遵循Linux说明）或使用Cygwin ([https://www.cygwin.com](https://www.cygwin.com))来找到`gcc-core`和`make`。我们建议将这些工具（默认为`C:\cygwin64\bin`）添加到Windows的`PATH`变量中（[https://www.java.com/en/download/help/path.xml](https://www.java.com/en/download/help/path.xml)），这样常规的（PowerShell）终端就可以访问Cygwin的可执行文件。
- en: 'Once ready, use the same shell to create a `legacy-c-code` directory and, inside,
    run `cargo new rust-digest --lib` and create a directory named `C` alongside it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪后，使用相同的shell创建一个`legacy-c-code`目录，并在其中运行`cargo new rust-digest --lib`，并在旁边创建一个名为`C`的目录：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the `C` directory, create an `src` folder to mirror the Rust project.
    Open the entire `legacy-c-code` in Visual Studio Code or your Rust development
    environment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`C`目录内，创建一个`src`文件夹以反映Rust项目。在Visual Studio Code或你的Rust开发环境中打开整个`legacy-c-code`。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to be able to include legacy code in your project:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作，以便能够在你的项目中包含旧代码：
- en: 'Let''s implement the Rust library first. Open `rust-digest/Cargo.toml` to adjust
    the configuration to output a dynamic library (`*.so` or `*.dll`):'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先实现Rust库。打开`rust-digest/Cargo.toml`来调整配置以输出动态库（`*.so`或`*.dll`）：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another thing to add is the dependencies. Here, we are using types from `libc`
    and a cryptography library called `ring`, so let''s add those dependencies:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要添加的是依赖项。在这里，我们使用`libc`中的类型和一个名为`ring`的加密库，所以让我们添加这些依赖项：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we can take care of the code itself. Let''s open `rust-digest/src/lib.rs`
    and replace the default code with the following snippet. This snippet creates
    an interface from the outside world that accepts a string (a mutable character
    pointer) and returns a string digest of the input:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以处理代码本身。让我们打开`rust-digest/src/lib.rs`并替换默认代码为以下片段。这个片段创建了一个从外部世界接受字符串（一个可变字符指针）并返回输入字符串摘要的接口：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should be a full Rust library now. Let''s run `cargo build` inside `rust-digest` to
    check the output:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该是一个完整的Rust库了。让我们在`rust-digest`中运行`cargo build`来检查输出：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There should be a `libdigest.so` library (or `digest.dll` on Windows):'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该有一个`libdigest.so`库（或在Windows上是`digest.dll`）：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, let''s do a release build as well. Run `cargo build --release` in `rust-digest`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们也应该进行一次发布构建。在 `rust-digest` 目录下运行 `cargo build --release`：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To implement the `C` part of the project, create and open `C/src/main.c` to
    add the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现项目的 `C` 部分，创建并打开 `C/src/main.c` 以添加以下代码：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`make` is the traditional (and simplest) tool to build `C` code. `make` runs
    a file called `Makefile` to adhere to the rules that it defines. Create and open `C/Makefile` and
    add the following:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make` 是构建 `C` 代码的传统（也是最简单）的工具。`make` 通过运行一个名为 `Makefile` 的文件来遵循它定义的规则。创建并打开
    `C/Makefile` 并添加以下内容：'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If everything is in place, we should be able to switch to the `C` directory
    and run `make all` there:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切就绪，我们应该能够切换到 `C` 目录并运行 `make all`：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Afterward, there is a `C/target` directory, which contains two files: `main.o` and `main` (`main.exe` on
    Windows).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，会有一个 `C/target` 目录，其中包含两个文件：`main.o` 和 `main`（Windows 上的 `main.exe`）。
- en: 'To be able to run the executable (the `.o` file is just the object file; not
    for running), we also need to tell it where our dynamic library is located. For
    that, the `LD_LIBRARY_PATH` environment variable is typically used. Open `bash` and
    run the following command inside the `legacy-c-code` directory to—temporarily—overwrite
    the variable with the appropriate path:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够运行可执行文件（`.o` 文件只是目标文件；不能运行），我们还需要告诉它我们的动态库所在的位置。为此，通常使用 `LD_LIBRARY_PATH`
    环境变量。在 `bash` 中打开并运行以下命令，在 `legacy-c-code` 目录内临时覆盖变量为适当的路径：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now it''s time to finally run the C program and check whether everything worked
    out. Switch to the `C/target` directory and run the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候最终运行 C 程序并检查是否一切正常了。切换到 `C/target` 目录并运行以下命令：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With that done, let's take a look behind the scenes to understand how it was
    done.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，让我们看看背后的情况，了解它是如何完成的。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Replacing legacy C code with Rust is a step-by-step process that is often done
    in order to improve developer productivity, safety, and potential innovation.
    This has been done in countless applications (for example, in Microsoft's public
    cloud offering, Azure: [https://azure.microsoft.com/en-gb/](https://azure.microsoft.com/en-gb/))
    and requires two technologies to work together flawlessly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 用 Rust 替换旧 C 代码是一个逐步的过程，通常是为了提高开发者的生产力、安全性和潜在的创新。这已经在无数的应用程序中完成（例如，在微软的公共云服务
    Azure 中：[https://azure.microsoft.com/en-gb/](https://azure.microsoft.com/en-gb/))，并且需要两种技术无缝协作。
- en: 'Thanks to Rust''s LLVM-based compiler, the compilation outputs native code
    (for example, ELF on Linux: [https://en.wikipedia.org/wiki/Executable_and_Linkable_Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)),
    which makes it accessible—in particular—for C/C++. In this recipe, we are taking
    a look at how to link those two outputs together into a single program using a
    dynamic library built in Rust.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了基于 LLVM 编译器的 Rust 编译器，编译输出的是原生代码（例如，Linux 上的 ELF：[https://zh.wikipedia.org/wiki/Executable_and_Linkable_Format](https://zh.wikipedia.org/wiki/Executable_and_Linkable_Format)），这使得它对
    C/C++ 来说特别易于访问。在这个菜谱中，我们将探讨如何使用 Rust 中构建的动态库将这两个输出链接成一个单独的程序。
- en: 'The prerequisites for creating a dynamic library (`*.so`/`*.dll`) in Rust are
    surprisingly simple: *step 1* shows the required changes to `Cargo.toml` for `rustc` to
    output the required format. There are other formats, so if you are looking for
    something specific, check out the nomicon ([https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries](https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries)) and docs
    at [https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries](https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中创建动态库（`*.so`/`*.dll`）的先决条件出奇地简单：*步骤 1* 展示了 `Cargo.toml` 中对 `rustc` 输出所需格式的必要更改。还有其他格式，所以如果你在寻找特定内容，请查看
    nomicon ([https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries](https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries))
    和文档 [https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries](https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries)。
- en: '*Step 3* shows the code to create an SHA256 ([https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/](https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/)) digest
    of an incoming string, but only after it calls a simple callback function, `pre_digest()`, to
    showcase the bi-directional bindings. There are a few things of note here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 3* 展示了创建传入字符串的 SHA256 ([https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/](https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/))
    摘要的代码，但只有在它调用了一个简单的回调函数 `pre_digest()` 来展示双向绑定之后。这里有几个需要注意的地方：'
- en: Importing a function from a linked library is done using an `extern "C" {}` declaration
    (the `"C"` isn't actually necessary). After declaring a construct like that, it
    can be used just like any other function.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从链接的库中导入函数是通过使用 `extern "C" {}` 声明来完成的（`"C"` 实际上并不必要）。在声明了这样的结构之后，它可以像任何其他函数一样使用。
- en: 'In order to export a function compatible with the ELF format, the `#[no_mangle]` attribute
    is required since the compiler runs a name-mangling scheme that changes the function
    name. Since compilers don''t have a common scheme, `no_mangle` makes sure it stays
    just as it is. To learn more about name mangling, check out this link: [https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了导出与 ELF 格式兼容的函数，需要 `#[no_mangle]` 属性，因为编译器运行一个名称混淆方案，会更改函数名称。由于编译器没有通用的方案，`no_mangle`
    确保它保持原样。要了解更多关于名称混淆的信息，请查看这个链接：[https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code)。
- en: The use of `unsafe` inside the `digest` function is required for a few reasons.
    First, calling an external function is always unsafe (`pre_digest()`). Second,
    the conversion from a `char` pointer to `CStr` is unsafe, requiring the scope
    as well.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `digest` 函数内部使用 `unsafe` 是出于几个原因。首先，调用外部函数始终是不安全的（`pre_digest()`）。其次，从 `char`
    指针到 `CStr` 的转换是不安全的，需要作用域。
- en: '**Note:** `ring` ([https://github.com/briansmith/ring](https://github.com/briansmith/ring)) is
    a pure Rust implementation of several cryptography algorithms, so there are no OpenSSL
    ([https://www.openssl.org/](https://www.openssl.org/)) or LibreSSL ([https://www.libressl.org](https://www.libressl.org)) requirements.
    Since both of those libraries are built on the respective native libraries, they
    always present a headache to even experienced Rust developers. Being pure Rust, `ring` avoids
    any of their linking/compilation issues, however.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** `ring` ([https://github.com/briansmith/ring](https://github.com/briansmith/ring))
    是几个加密算法的纯 Rust 实现，因此没有 OpenSSL ([https://www.openssl.org/](https://www.openssl.org/))
    或 LibreSSL ([https://www.libressl.org](https://www.libressl.org)) 的要求。由于这两个库都是基于各自的本地库构建的，它们总是给即使是经验丰富的
    Rust 开发者带来头疼。然而，作为纯 Rust 实现，`ring` 避免了任何链接/编译问题。'
- en: From *steps **4* to* 6*, we are building the Rust library just as we used to,
    but instead of a `.rlib` file, a `.so` or `.dll` file is the result of this process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *步骤 4* 到 *步骤 6*，我们正在像以前一样构建 Rust 库，但结果是一个 `.so` 或 `.dll` 文件，而不是 `.rlib` 文件。
- en: '*Step 7* shows the `C` code required to import and call a dynamically linked
    function. `C` keeps this admirably simple with an `extern` declaration for the
    interface, which enables you to call the function just like that. The callback
    is also implemented and exported using the `extern` declaration and it simply
    prints out that it was called.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 7* 展示了导入和调用动态链接函数所需的 `C` 代码。`C` 使用接口的 `extern` 声明来保持这一点的简单性，这使得你可以直接调用该函数。回调也是通过
    `extern` 声明实现的，并且简单地打印出它已被调用。'
- en: Rust's build system really shines when we get to *step 8*, where the rules for
    `Makefile` are created. Making rules is simple, but it leaves a lot of room for
    complexity, as many C developers know. In our recipe, however, we want to keep
    it easy to understand. Each rule consists of a target (for example, `all`) and
    its dependencies (for example, `target/main`), as well as a body of bash commands
    to run (for example, `@mkdir -p $@`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的构建系统在到达 *第 8 步* 时真正大放异彩，在这一步中创建了 `Makefile` 的规则。创建规则很简单，但正如许多 C 语言开发者所知，它留下了很多复杂性的空间。然而，在我们的配方中，我们希望让它易于理解。每个规则都包含一个目标（例如，`all`）及其依赖项（例如，`target/main`），以及要运行的
    bash 命令体（例如，`@mkdir -p $@`）。
- en: These dependencies can be files (such as `target/main.o` or `target/main`) or
    other rules. If they are files, check when they were modified last and, if there
    was a change, that they run the rule and its dependencies. The resulting dependency
    tree gets resolved automatically. As fascinating as this highly useful, 30-year-old
    tool may be, there are books written that are devoted to how it works. It is certainly
    a deep dive into history, and Linux conventions. Check out a short tutorial here: [http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)[ or
    go straight to the make manual (](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)[https://www.gnu.org/software/make/manual/make.html](https://www.gnu.org/software/make/manual/make.html)[).](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项可以是文件（例如 `target/main.o` 或 `target/main`）或其他规则。如果是文件，检查它们最后修改的时间，如果有变化，它们将运行规则及其依赖项。生成的依赖项树会自动解析。尽管这个高度有用、已有
    30 年历史的工具可能非常吸引人，但仍有书籍专门讲述它是如何工作的。这当然是一次深入历史和 Linux 传统的探索。在这里查看一个简短的教程：[http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)
    [或者直接查看 make 手册 (](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)[https://www.gnu.org/software/make/manual/make.html](https://www.gnu.org/software/make/manual/make.html)[)。](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)
- en: '*Step 9* compiles the `C` code into an executable and links it to `libdigest.so`,
    which `rustc` created. We are also pointing the linker to the right path in the `LDFLAGS` variable
    in `Makefile`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 9* 将 `C` 代码编译成可执行文件，并将其链接到 `libdigest.so`，这是 `rustc` 创建的。我们还在 `Makefile`
    中的 `LDFLAGS` 变量中指定了正确的链接路径。'
- en: 'Only in *step 10* will it become apparent how a static library is different
    from a dynamic library. The latter has to be available at runtime because it isn''t
    baked into the executable and relies on other mechanisms to be found. One such
    mechanism is the `LD_LIBRARY_PATH` environment variable, which points to directories
    with `libXXXX.so` files for the program to find its dependencies (by name). For
    this recipe, we are **replacing** the original value with wherever your `rust-digest/target/release` directory
    is located (`$(pwd)` outputs the current directory); however, this is only for
    the current Terminal session, so whenever you close and reopen the window, the
    setting will be gone. If the path is improperly set or the directory/file is missing,
    executing `main` will give you something along the lines of the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在 *步骤 10* 中，才会明显看出静态库与动态库的不同。后者必须在运行时可用，因为它没有嵌入到可执行文件中，并且依赖于其他机制来查找。其中一种机制是
    `LD_LIBRARY_PATH` 环境变量，它指向包含 `libXXXX.so` 文件的目录，以便程序通过名称查找其依赖项。对于这个菜谱，我们正在**替换**原始值，使其指向你的
    `rust-digest/target/release` 目录所在位置（`$(pwd)` 输出当前目录）；然而，这仅适用于当前的终端会话，所以每次你关闭并重新打开窗口时，设置都会消失。如果路径设置不正确或目录/文件缺失，执行
    `main` 将会得到类似以下的内容：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Step 11* shows the correct output since the `pre_digest` function was called
    and we were able to create the correct SHA256 digest for `"Hello World"` (without
    the `"`).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 11* 展示了正确的输出，因为已经调用了 `pre_digest` 函数，并且我们能够为 `"Hello World"`（不带引号）创建正确的
    SHA256 摘要。'
- en: Now that we know a little more about integrating Rust into a C-type application,
    we can move on to the next recipe.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对将 Rust 集成到 C 类型应用程序中有了更多了解，我们可以继续到下一个菜谱。
- en: Calling into Rust from Node.js using FFI
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FFI 从 Node.js 调用 Rust
- en: JavaScript is a language that excels in its flat learning curve and flexibility,
    which leads to impressive adoption rates in various areas outside of the original
    browser animation. Node.js ([https://nodejs.org/en/](https://nodejs.org/en/))
    is a runtime based on Google's V8 JavaScript engine, which allows JavaScript code
    to run directly on the operating system (without the browser), including access
    to various low-level APIs in order to enable IoT-type applications and web services,
    or even to create and display virtual/augmented reality environments ([https://github.com/microsoft/HoloJS](https://github.com/microsoft/HoloJS)).
    All of this is possible because the Node runtime provides access to native libraries
    on the host operating system. Let's see how we create a Rust library to call from
    JavaScript into this.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种学习曲线平缓且灵活的语言，这导致了在原始浏览器动画之外的各种领域的令人印象深刻的采用率。Node.js ([https://nodejs.org/en/](https://nodejs.org/en/))
    是基于Google的V8 JavaScript引擎的运行时，它允许JavaScript代码在操作系统（无需浏览器）上直接运行，包括访问各种低级API，以启用物联网类型的应用程序和Web服务，甚至创建和显示虚拟/增强现实环境
    ([https://github.com/microsoft/HoloJS](https://github.com/microsoft/HoloJS))。所有这一切都是因为Node运行时提供了对宿主操作系统的本地库的访问。让我们看看我们如何创建一个Rust库，以便从JavaScript中调用它。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Since we are working with Node.js, please install `npm` and the Node.js runtime,
    as explained on their official website: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    Once ready, you should be able to run these commands from a Terminal (PowerShell
    or bash):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用Node.js，请按照官方网站上的说明安装`npm`和Node.js运行时：[https://nodejs.org/en/download/](https://nodejs.org/en/download/)。一旦准备就绪，您应该能够从终端（PowerShell或bash）运行以下命令：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The actual versions may be higher at the time of reading. The node dependency
    we are using also requires C/C++ tools, as well as having Python 2 installed.
    Follow the instructions for your OS on GitHub: [https://github.com/nodejs/node-gyp#installation](https://github.com/nodejs/node-gyp#installation).
    Then, let''s set up a folder structure similar to the previous recipe:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实际版本可能更高。我们使用的node依赖项还需要C/C++工具，以及安装Python 2。按照GitHub上您操作系统的说明：[https://github.com/nodejs/node-gyp#installation](https://github.com/nodejs/node-gyp#installation)。然后，让我们设置一个类似于上一个菜谱的文件夹结构：
- en: Create a `node-js-rust` folder.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`node-js-rust`文件夹。
- en: Create a sub-folder called `node`, change into it, and run `npm init` to generate `package.json`—basically,
    Node's `Cargo.toml`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`node`的子文件夹，进入它，并运行`npm init`以生成`package.json`——基本上是Node的`Cargo.toml`。
- en: Inside the `node` folder, add a directory called `src`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`node`文件夹内，添加一个名为`src`的目录。
- en: At the same level as the `node` folder, create a new Rust project called `cargo
    new rust-digest --lib` (or reuse the one from the previous recipe).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`node`文件夹的同一级别创建一个新的Rust项目，命名为`cargo new rust-digest --lib`（或重用上一个菜谱中的项目）。
- en: 'At the end, you should have a directory setup like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该有一个如下设置的目录结构：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open the entire directory in Visual Studio Code to work on the code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开整个目录以进行代码编写。
- en: How to do it ...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s repeat a few steps from the SHA256 library from the previous recipe:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一个菜谱中的SHA256库重复几个步骤：
- en: 'First, let''s take care of the Rust part. Open `rust-digest/Cargo.toml` to
    add `ring`, a dependency for the hashing part, as well as the `crate-type` configuration
    for cross-compilation:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们处理Rust部分。打开`rust-digest/Cargo.toml`以添加`ring`，这是用于哈希部分的依赖项，以及用于交叉编译的`crate-type`配置：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s look at the Rust code. Just as in other recipes in this chapter,
    we are creating a fast way to generate an SHA digest via Rust to be used from
    Node.js:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看Rust代码。就像本章中的其他菜谱一样，我们正在创建一种通过Rust快速生成SHA摘要的方法，以便在Node.js中使用：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`cargo build` now creates a native library. You can find the library in `target/debug`
    inside the Rust project directory:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo build`现在创建了一个本地库。您可以在Rust项目目录中的`target/debug`下找到这个库：'
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the JavaScript part calls into the Rust binary, there are a few declarations
    to be made in order to make the function known. We finish off the code by printing
    out the result of a call to the Rust library. Add this to `node/src/index.js`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果JavaScript部分调用了Rust二进制文件，需要做出一些声明以便使函数被识别。我们通过打印出对Rust库的调用结果来完成代码。将以下内容添加到`node/src/index.js`中：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `require` statement already hints toward a dependency, so let''s integrate
    this as well. Open `node/package.json` to add the following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`require`语句已经暗示了依赖关系，所以让我们也将其整合。打开`node/package.json`以添加以下内容：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With everything in place, we can now issue an `npm install` command from within
    the `node` directory:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备就绪后，我们现在可以从`node`目录中运行`npm install`命令：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the dependencies have been installed, the `node` application is ready
    to run. Issue `node src/index.js` to execute the JavaScript file:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖项安装完成后，`node`应用程序就准备好运行了。运行`node src/index.js`来执行JavaScript文件：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Having done the work, let's take a look at why and how it all comes together.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完成工作后，让我们看看为什么以及它是如何结合在一起的。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Node.js, as a native runtime environment for JavaScript, provides easy-to-access
    native libraries that can be built with Rust. In order to do that, the `node-ffi` ([https://github.com/node-ffi/node-ffi](https://github.com/node-ffi/node-ffi)) package is
    required to dynamically find and load the desired libraries. First, however, we
    start with the Rust code and project: *steps* *1* to *3* show how to build a native
    dynamic library, which we discussed earlier in this chapter, in the *Including
    legacy C code* recipe, in the *How it works...* section.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js，作为JavaScript的本地运行环境，提供了易于访问的本地库，这些库可以使用Rust构建。为了做到这一点，需要`node-ffi`([https://github.com/node-ffi/node-ffi](https://github.com/node-ffi/node-ffi))包来动态查找和加载所需的库。然而，首先，我们从Rust代码和项目开始：*步骤*
    *1* 到 *3* 展示如何构建一个本地动态库，这是我们之前在本章的*包含遗留C代码*配方中，在*它是如何工作的...*部分讨论过的。
- en: In *step 4*, we create the JavaScript code. Thanks to the dynamic nature of
    JavaScript, defining the function signature can be done using strings and objects
    and the actual invocation looks just like a regular function that can be imported
    from a module. The FFI library also takes away the data type conversion, and the
    call across technology boundaries is seamless. Another important note is that,
    with `node-ffi` ([https://github.com/node-ffi/node-ffi](https://github.com/node-ffi/node-ffi)),
    the actual module path is required, which makes handling the different artifacts
    a lot easier (compared to using environment variables in C/C++ interop).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4* 中，我们创建JavaScript代码。得益于JavaScript的动态特性，可以使用字符串和对象来定义函数签名，实际的调用看起来就像一个可以从模块中导入的常规函数。FFI库还消除了数据类型转换，跨技术边界的调用是无缝的。另一个重要的注意事项是，使用`node-ffi`([https://github.com/node-ffi/node-ffi](https://github.com/node-ffi/node-ffi))时，需要实际的模块路径，这使得处理不同的工件变得容易得多（与在C/C++互操作中使用环境变量相比）。
- en: In *step 5* and *step 6*, we take care of adding and installing the required
    dependencies for Node.js using the famous `npm` package manager ([https://www.npmjs.com/](https://www.npmjs.com/)),
    with `node-ffi` ([https://github.com/node-ffi/node-ffi](https://github.com/node-ffi/node-ffi))
    requiring some compiler tools to work properly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5* 和 *步骤 6* 中，我们使用著名的`npm`包管理器([https://www.npmjs.com/](https://www.npmjs.com/))添加和安装Node.js所需的依赖项，其中`node-ffi`([https://github.com/node-ffi/node-ffi](https://github.com/node-ffi/node-ffi))需要一些编译工具才能正常工作。
- en: The last step shows how the program executes and creates the same hash as other
    recipes in this chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步展示了程序是如何执行并创建与本章其他配方中相同的哈希值的。
- en: We've learned how to call into Rust from Node.js using FFI, so now let's move
    on to the next recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用FFI从Node.js调用Rust，现在让我们继续到下一个配方。
- en: Running Rust in the browser
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中运行Rust
- en: Running Rust in the browser may seem like a similar task to using Rust binaries
    with Node.js. However, the modern browser environment is exceedingly more difficult.
    Sandboxing limits access to local resources (which is a good thing!) and browsers
    provide a small number of scripting languages to run within the website. While
    the most successful language is JavaScript, it comes with many drawbacks in the
    area of animation, caused by the scripting nature of the technology. On top of
    that, there is garbage collection, a type system with many flaws, and the lack
    of a coherent programming paradigm—all of which manifests itself in unpredictable
    and poor performance for real-time applications such as games.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行Rust可能看起来与使用Node.js的Rust二进制文件类似。然而，现代浏览器环境要复杂得多。沙箱限制了本地资源的访问（这是好事！），浏览器提供少量脚本语言在网站内运行。虽然最成功的语言是JavaScript，但它由于技术的脚本性质，在动画方面存在许多缺点。除此之外，还有垃圾回收、存在许多缺陷的类型系统以及缺乏一致的编程范式——所有这些都导致了实时应用程序（如游戏）不可预测和性能不佳。
- en: However, these issues are being resolved. A technology called WebAssembly has
    been introduced to be able to distribute binaries (as an assembler language for
    the web) that can be run in a specialized execution environment—just like JavaScript.
    In fact, JavaScript is able to seamlessly interact with these binaries, akin to
    native libraries in a Node.js application, which speeds things up considerably.
    Thanks to Rust's LLVM base, it can compile to WebAssembly, and, with its memory
    management, it's a great choice for running these real-time applications. While
    this technology is still in its infancy, let's see how this works!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些问题正在得到解决。一种名为WebAssembly的技术被引入，以便能够分发二进制文件（作为网络汇编语言），这些二进制文件可以在一个专门的执行环境中运行——就像JavaScript一样。事实上，JavaScript能够无缝地与这些二进制文件交互，类似于Node.js应用程序中的本地库，这大大加快了速度。得益于Rust的LLVM基础，它可以编译成WebAssembly，并且，凭借其内存管理，它对于运行这些实时应用是一个很好的选择。尽管这项技术仍处于起步阶段，但让我们看看它是如何工作的！
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this project, we are setting up a directory called `browser-rust`, containing
    a `web` directory and a `cargo` library project called `rust-digest` (`cargo new
    rust-digest --lib`). For the compilation, we need an additional compilation target, `wasm23-unknown-unknown`,
    which can be installed via `rustup`. Issue the following command in a Terminal
    to install the target:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们正在设置一个名为`browser-rust`的目录，其中包含一个`web`目录和一个名为`rust-digest`的`cargo`库项目（`cargo
    new rust-digest --lib`）。对于编译，我们需要一个额外的编译目标`wasm23-unknown-unknown`，可以通过`rustup`安装。在终端中运行以下命令来安装目标：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Use `cargo` to install a tool called `wasm-bindgen-cli` (`cargo install wasm-bindgen-cli`),
    and check whether it works by invoking `wasm-bindgen` in your current console
    window.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo`安装一个名为`wasm-bindgen-cli`的工具（`cargo install wasm-bindgen-cli`），并在当前控制台窗口中调用`wasm-bindgen`来检查它是否工作。
- en: 'Inside the `web` directory, we create a file named `index.html`, which will
    host and show our Rust output. In order to be able to render the index file, a
    web server is also required. Here are a few options:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web`目录内，我们创建一个名为`index.html`的文件，该文件将托管并展示我们的Rust输出。为了能够渲染索引文件，还需要一个网络服务器。以下是一些选项：
- en: 'Python (3.x)''s standard library comes with an `http.server` module, which
    can be called like this: `python3 -m http.server 8080`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python（3.x）的标准库包含一个`http.server`模块，可以像这样调用：`python3 -m http.server 8080`。
- en: Fans of JavaScript and Node.js can use `http-server` ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)),
    installable via `npm` ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript和Node.js的爱好者可以使用`http-server`（[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)），通过`npm`（[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)）安装。
- en: 'Recent versions of Ruby come with a web server as well: `ruby -run -ehttpd
    . -p8080`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby的最新版本也自带了一个网络服务器：`ruby -run -ehttpd . -p8080`。
- en: 'On Windows, you can use IIS Express ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)),
    also via the command line: `C:\> "C:\Program Files (x86)\IIS Express\iisexpress.exe"
    /path:C:\Rust-Cookbook\Chapter07\browser-rust\web /port:8080`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上，您可以使用IIS Express（[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)），也可以通过命令行：`C:\>
    "C:\Program Files (x86)\IIS Express\iisexpress.exe" /path:C:\Rust-Cookbook\Chapter07\browser-rust\web
    /port:8080`。
- en: 'Any web server that serves static files will do, and it should be able to provide
    the files appropriately. You should end up with a directory structure like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 任何提供静态文件的网络服务器都可以，并且它应该能够适当地提供文件。您最终应该得到如下目录结构：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Your project should now be set up and ready to go. Let's see how we can get
    Rust to run in the browser.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目现在应该已经设置好并准备就绪。让我们看看如何让Rust在浏览器中运行。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here''s how to write low-latency web applications in just a few steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何仅用几个步骤编写低延迟网络应用的步骤：
- en: 'Let''s start by implementing the Rust part. We''ll again create a hashing library,
    so we start by creating the API basics. Open `rust-digest/src/lib.rs` and insert
    the following above the tests:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现Rust部分开始。我们再次创建一个哈希库，因此我们首先创建API的基本功能。打开`rust-digest/src/lib.rs`，在测试上方插入以下内容：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s bind the `hex_digest()` function to a public API that we can call from
    outside the module. This enables us to invoke the code using WASM types and even
    autogenerate most of these bindings. Add some of those just below the preceding
    code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`hex_digest()`函数绑定到一个公开的API，我们可以从模块外部调用它。这使得我们可以使用WASM类型调用代码，甚至可以自动生成大部分这些绑定。在上述代码下方添加一些内容：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It''s sometimes handy to have a callback once the module is instantiated, so
    let''s add one of those as well:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候，在模块实例化后有一个回调会很有用，所以让我们也添加一个：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have used two imports that require additional dependencies: `wasm-bindgen`
    and `sha2` (as a web-compatible version of `ring::digest`). Additionally, we are
    pretending to be a native library for external linking, so the library type and
    name should be adjusted. Modify `rust-digest/Cargo.toml` to include these changes:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了两个需要额外依赖的导入：`wasm-bindgen`和`sha2`（作为`ring::digest`的Web兼容版本）。此外，我们假装是一个用于外部链接的本地库，因此库的类型和名称应该进行调整。修改`rust-digest/Cargo.toml`以包含这些更改：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s compile the library and check the output. Run `cargo build --target
    wasm32-unknown-unknown`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编译库并检查输出。运行`cargo build --target wasm32-unknown-unknown`：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The resulting `digest.wasm` file is what we want to include in our web application
    using JavaScript. While this can be done directly ([https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API](https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API)),
    the data type conversion can be quite cumbersome. This is why there is a CLI tool
    to help out. Run `wasm-bindgen target/wasm32-unknown-unknown/debug/digest.wasm
    --out-dir ../web/ --web` from within `browser-rust/rust-digest` to generate the
    necessary JavaScript bindings for web browsers:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的`digest.wasm`文件是我们想在Web应用程序中使用JavaScript包含的文件。虽然可以直接这样做([https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API](https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API))，但数据类型转换可能会相当繁琐。这就是为什么有一个CLI工具来帮助。在`browser-rust/rust-digest`目录下运行`wasm-bindgen
    target/wasm32-unknown-unknown/debug/digest.wasm --out-dir ../web/ --web`以生成Web浏览器所需的必要JavaScript绑定：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These bindings need to be included in our `web/index.html` file (which is empty
    at the moment):'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些绑定需要包含在我们的`web/index.html`文件中（目前是空的）：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Save and exit the `index.html` file and start the web server you prepared earlier
    inside the web directory:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并退出`index.html`文件，然后在网站目录内启动你之前准备好的网络服务器：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Access `http://localhost:8080` in your browser (be sure to allow the server
    through the firewall) and check whether your output matches the following:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中访问`http://localhost:8080`（确保允许服务器通过防火墙）并检查你的输出是否与以下内容匹配：
- en: '![](img/ad8dc81b-b4e0-4a4d-b33b-8341643e2498.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad8dc81b-b4e0-4a4d-b33b-8341643e2498.png)'
- en: Having done the work, let's take a look at why and how it all comes together.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完成工作后，让我们看看为什么以及如何将所有这些内容结合起来。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Modern browsers provide a JavaScript engine alongside a web assembly virtual
    machine ([https://webassembly.org/](https://webassembly.org/)). With this capability,
    web applications can run binary code that is safely executed inside its own runtime
    environment with easy access from the outside. The main benefits include the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器提供了一个JavaScript引擎和Web汇编虚拟机([https://webassembly.org/](https://webassembly.org/))。有了这个功能，Web应用程序可以运行二进制代码，这些代码在其自己的运行时环境中安全执行，并且可以从外部轻松访问。主要好处包括以下内容：
- en: A smaller-sized application, thanks to binary compilation
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于二进制编译，应用程序体积更小
- en: Faster end-to-end execution times (no compilation step)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的端到端执行时间（没有编译步骤）
- en: No garbage collection—the WASM virtual machine is a stack machine
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有垃圾回收——WASM虚拟机是一个栈机器
- en: On top of that, WASM can be converted into a text-based format for visual inspection
    and manual optimization. Rust is one of the few languages to even compile to these
    formats (text and binary), and it's largely thanks to LLVM and Rust's approach
    to memory management.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，WASM可以被转换成基于文本的格式，以便进行视觉检查和手动优化。Rust是少数几种甚至可以编译成这些格式（文本和二进制）的语言之一，这主要归功于LLVM和Rust对内存管理的方法。
- en: In *steps 1*, *2*, and *3*, we create the Rust module to do the work. Notice
    the `#[wasm_bindgen]` attributes over the `extern` functions, which allow the
    macro preprocessor to fetch the input and output types of the function and generate
    bindings from this interface definition. There is also a special ([https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html](https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html))
    `#[wasm_bindgen(start)]` macro on top of one of the functions, which designates
    the initializer function to run whenever the module is instantiated. Both this
    function and `digest_attach()` feature a `Result` return type, which allows the
    `?` operator and rusty error handling in general.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*、*步骤 2*和*步骤 3*中，我们创建Rust模块来完成这项工作。注意`extern`函数上方的`#[wasm_bindgen]`属性，它允许宏预处理器获取函数的输入和输出类型，并从该接口定义生成绑定。还有一个特殊的`#[wasm_bindgen(start)]`宏位于其中一个函数上方，它指定初始化函数在模块实例化时运行。这两个函数和`digest_attach()`都返回`Result`类型，这允许使用`?`运算符和通用的rust错误处理。
- en: '`digest_attach()` is special (compared to `digest()`) since it directly accesses
    the DOM ([https://www.w3.org/TR/WD-DOM/introduction.html](https://www.w3.org/TR/WD-DOM/introduction.html)) from
    the WASM module, which is provided by the `web_sys` crate. All of these macros
    and functions are imported in the `wasm_bindgen::prelude::*` statement.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`digest_attach()`是特殊的（与`digest()`相比），因为它直接从WASM模块访问DOM([https://www.w3.org/TR/WD-DOM/introduction.html](https://www.w3.org/TR/WD-DOM/introduction.html))，这是由`web_sys`包提供的。所有这些宏和函数都在`wasm_bindgen::prelude::*`语句中导入。'
- en: '*Step 4* adjusts `Cargo.toml` accordingly to provide everything in order for
    the compilation to work. Note that any errors here that work on a different target
    (for example, the default target) hint toward an incompatible crate for WASM.
    Only in *step 5* do we execute the compilation for the wasm32 target, which produces
    a WASM binary file. *Step 6* runs the binding generator using the `wasm-bindgen`
    CLI, which produces a few files for easier integration. In this case, they are
    the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 4*相应地调整`Cargo.toml`，以确保编译工作顺利进行。注意，这里出现的任何错误（例如，针对不同的目标，例如默认目标）都表明crate与WASM不兼容。只有在*步骤
    5*中，我们才执行针对wasm32目标的编译，这将生成WASM二进制文件。*步骤 6*使用`wasm-bindgen` CLI运行绑定生成器，这将生成一些文件以简化集成。在这种情况下，它们是以下文件：'
- en: '`digest_bg.d.ts`: TypeScript ([https://www.typescriptlang.org/](https://www.typescriptlang.org/))
    definitions for the exported WASM functions'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digest_bg.d.ts`: 导出WASM函数的TypeScript([https://www.typescriptlang.org/](https://www.typescriptlang.org/))定义'
- en: '`digest_bg.wasm`: The WASM file itself'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digest_bg.wasm`: WASM文件本身'
- en: '`digest.d.ts`: TypeScript definitions for the integration file'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digest.d.ts`: 集成文件的TypeScript定义'
- en: '`digest.js`: The JavaScript implementation for loading and converting the exported
    WASM functions into regular JavaScript calls'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digest.js`: 加载和将导出的WASM函数转换为常规JavaScript调用的JavaScript实现'
- en: The tool includes more options and examples ([https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html](https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html)) for
    other integrations so, check out the documentation for specifics ([https://rustwasm.github.io/docs/wasm-bindgen/](https://rustwasm.github.io/docs/wasm-bindgen/)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 工具包括更多选项和示例([https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html](https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html))，用于其他集成，因此，请查看文档以获取详细信息([https://rustwasm.github.io/docs/wasm-bindgen/](https://rustwasm.github.io/docs/wasm-bindgen/))。
- en: Not every crate can be compiled to `wasm32-unknown-unknown`, especially if they
    are using hardware access or operating system features. Some crates implement
    compatibility layers that are often specified as `cargo` features.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是每个crate都可以编译为`wasm32-unknown-unknown`，特别是如果它们使用硬件访问或操作系统功能的话。一些crate实现了兼容层，通常指定为`cargo`功能。
- en: '*Step 7* shows how to include the generated WASM bindings into a regular HTML
    page. Outside of the ES6 syntax ([http://es6-features.org/#Constants](http://es6-features.org/#Constants))
    (which may be unfamiliar to some), the Rust code is neatly wrapped in JavaScript
    functions, so no additional conversion is needed. For those interested in how
    this works, check out the `digest.js` file, which is quite readable but shows
    the complexity involved in transforming the data. That''s it—the last step only
    shows how to serve the files and that the hosting actually works.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 7 步*展示了如何将生成的 WASM 绑定包含到常规 HTML 页面中。在 ES6 语法（[http://es6-features.org/#Constants](http://es6-features.org/#Constants)）（可能对一些人来说不熟悉）之外，Rust
    代码被整洁地封装在 JavaScript 函数中，因此不需要额外的转换。对于那些对它是如何工作的感兴趣的人，可以查看 `digest.js` 文件，该文件相当易于阅读，但展示了转换数据所涉及到的复杂性。就是这样——最后一步仅展示了如何提供文件，并且托管实际上是可以工作的。'
- en: Now that we have learned how to run Rust in the browser, let's move on to the
    next recipe!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在浏览器中运行 Rust，让我们继续学习下一道食谱！
- en: Using Rust and Python
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 和 Python
- en: Python has become a staple language for many applications, from the web to data
    science. However, Python itself is an interpreted language and is famously quite
    slow—which is why it integrates well with much faster C code. Many well-liked
    libraries are implemented in C/C++ and Cython ([https://cython.org/](https://cython.org/)) in
    order to achieve the required performance (for example, `numpy`, `pandas`, `keras`,
    and PyTorch are largely native code). Since Rust produces native binaries as well,
    let's look at how we can write Rust modules for Python.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Python 已经成为许多应用的标配语言，从网络到数据科学。然而，Python 本身是一种解释型语言，并且以其相当慢而闻名——这就是为什么它与更快 的
    C 代码集成得很好的原因。许多受欢迎的库都是用 C/C++ 和 Cython ([https://cython.org/](https://cython.org/))
    实现的，以实现所需性能（例如，`numpy`、`pandas`、`keras` 和 PyTorch 主要为原生代码）。由于 Rust 也能生成原生二进制文件，让我们看看如何为
    Python 编写 Rust 模块。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will work on creating an SHA256 digest again and will use the same folder
    structure as we have in every recipe in this chapter. Create a `python-rust` directory and
    initialize a new Rust project there using `cargo new rust-digest --lib`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次创建 SHA256 摘要，并使用本章中每个食谱中相同的文件夹结构。创建一个 `python-rust` 目录，并使用 `cargo new rust-digest
    --lib` 在其中初始化一个新的 Rust 项目。
- en: 'For the Python part of the project, install Python (3.6/3.7) by following the
    instructions on the website. Then, create the following folder structure and files
    (empty is OK for now) inside `python-rust/python`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目的 Python 部分，按照网站上的说明安装 Python（3.6/3.7）。然后，在 `python-rust/python` 内创建以下文件夹结构和文件（目前为空即可）：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Open the entire `python-rust` folder in VS Code and you are ready to go.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开整个 `python-rust` 文件夹，你就可以开始了。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Python is a great language to integrate with—find out why in just a few steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种非常适合集成的优秀语言——只需几个步骤就能了解其中的原因：
- en: 'Open `rust-digest/src/lib.rs` to start off with the Rust code. Let''s add the
    required `use` statements for FFI and `ring` and declare a `digest()` function
    to be exported. Note that this function is the same as in most other recipes in
    this chapter:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `rust-digest/src/lib.rs` 以开始编写 Rust 代码。让我们添加所需的 `use` 语句以支持 FFI 和 `ring`，并声明一个要导出的
    `digest()` 函数。请注意，此函数与本章中大多数其他食谱中的函数相同：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since we are using `ring` and a third-party dependency to create the hash, let''s
    declare them (and the library type) in `rust-digest/Cargo.toml`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用 `ring` 和第三方依赖项来创建哈希，因此让我们在 `rust-digest/Cargo.toml` 中声明它们（以及库类型）：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s build the library to obtain `libdigest.so` (or `digest.dll` or
    `libdigest.dylib`). Run `cargo build` inside `rust-digest`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建库以获得 `libdigest.so`（或 `digest.dll` 或 `libdigest.dylib`）。在 `rust-digest`
    中运行 `cargo build`：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In order to load this library in Python, we need to write some code as well.
    Open `python/src/digest.py` and add the following content:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在 Python 中加载此库，我们需要编写一些代码。打开 `python/src/digest.py` 并添加以下内容：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'While this file can be run by invoking `python3 digest.py`, it''s not what
    a larger project will look like. Python''s setuptools ([https://setuptools.readthedocs.io/en/latest/](https://setuptools.readthedocs.io/en/latest/)) provide
    a better-structured approach to create and even install runnable scripts for the
    current OS. The common point of entry is the `setup.py` script, which declares
    metadata along with dependencies and entry points. Create `python/setup.py` with
    the following content:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然可以通过调用 `python3 digest.py` 来运行此文件，但这并不是大型项目的样子。Python 的 setuptools ([https://setuptools.readthedocs.io/en/latest/](https://setuptools.readthedocs.io/en/latest/))
    提供了一种更好的结构化方法来创建甚至为当前操作系统安装可运行的脚本。常见的入口点是 `setup.py` 脚本，它声明了元数据以及依赖项和入口点。使用以下内容创建
    `python/setup.py`：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The file continues to input the declared variables into the `setup()` method,
    which generates the required metadata:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 文件继续将声明的变量输入到 `setup()` 方法中，该方法生成所需的元数据：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Steps 6*, *7*, and *8* are for Linux/macOS only (or WSL). Windows users, please
    continue with *step 9*. Python''s standalone modules are called eggs, so let''s
    make one and run `python3 setup.py bdist_egg`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*步骤 6*、*步骤 7* 和 *步骤 8* 仅适用于 Linux/macOS（或 WSL）。Windows 用户，请继续进行 *步骤 9*。Python
    的独立模块被称为 eggs，因此让我们创建一个并运行 `python3 setup.py bdist_egg`：'
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This creates a `.egg` file in `python/dist`, which is built to run the `main()`
    function from the preceding script when invoked. On Mac/Linux, you have to run
    `chmod +x python/dist/digest-0.1.0-py3.7.egg` to be able to run it. Let''s see
    what happens when we run it right away:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这在 `python/dist` 中创建了一个 `.egg` 文件，它被构建为在调用时运行前面脚本中的 `main()` 函数。在 Mac/Linux
    上，您必须运行 `chmod +x python/dist/digest-0.1.0-py3.7.egg` 才能运行它。让我们看看立即运行它会发生什么：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Right, the library is only dynamically linked! We have to point our binary
    to the library or move the library where it can find it. On Mac/Linux, this can
    be accomplished by setting the `LD_LIBRARY_PATH` environment variable to wherever
    the Rust build output is located. The result is a Python program that calls into
    the compiled Rust code for an `SHA256` digest of a string:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对了，这个库仅是动态链接的！我们必须将我们的二进制文件指向库或将其移动到库可以找到它的位置。在 Mac/Linux 上，可以通过设置 `LD_LIBRARY_PATH`
    环境变量到 Rust 构建输出所在的位置来实现。结果是调用编译后的 Rust 代码以获取字符串的 `SHA256` 摘要的 Python 程序：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For Windows users, the execution is a little bit simpler. First, make the library
    available to Python and then run the script directly. Run the following from within
    the `python` directory to use Rust from within Python to generate the `SHA256`
    digest:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，执行过程要简单一些。首先，使库对 Python 可用，然后直接运行脚本。在 `python` 目录中运行以下命令，以在 Python
    中使用 Rust 生成 `SHA256` 摘要：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's look at how and why this works.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何以及为什么这样工作的。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Enhancing Python''s capabilities with Rust is a great way to get the best of
    both worlds: Python is famously easy to learn and use; Rust is fast and safe (and
    does not fail at runtime as easily).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rust 来增强 Python 的功能是获得两者最佳结合的好方法：Python 以易于学习和使用而闻名；Rust 快速且安全（并且不容易在运行时失败）。
- en: 'In *steps 1* to *3*, we again create a dynamic native library that creates
    an `SHA256` hash out of a provided string argument. The required changes in `Cargo.toml`
    and `lib.rs` are the same as if we were to create a library for C/C++ inter-op:
    `#[no_mangle]`. The *Including legacy C code* recipe earlier in this chapter describes
    the inner workings in more detail, so be sure to read the *How it works...* section
    there as well.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 到 *步骤 3* 中，我们再次创建了一个动态本地库，该库从提供的字符串参数创建 `SHA256` 哈希。在 `Cargo.toml`
    和 `lib.rs` 中的所需更改与创建用于 C/C++ 互操作性的库相同：`#[no_mangle]`。本章前面关于 *包含旧版 C 代码* 的配方详细描述了内部工作原理，因此请务必阅读那里的
    *它是如何工作的...* 部分。
- en: The `cdylib` library type describes a dynamic library for C, and other types
    are available for different purposes. Check out the nomicon ([https://doc.rust-lang.org/nomicon/ffi.html](https://doc.rust-lang.org/nomicon/ffi.html)) and docs
    ([https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries](https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries)) for
    more details.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdylib` 库类型描述了 C 的动态库，其他类型适用于不同的目的。查看 nomicon ([https://doc.rust-lang.org/nomicon/ffi.html](https://doc.rust-lang.org/nomicon/ffi.html))
    和文档 ([https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries](https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries))
    以获取更多详细信息。'
- en: Our Python code uses the `ctypes` ([https://docs.python.org/3/library/ctypes.html](https://docs.python.org/3/library/ctypes.html))
    part of the standard library to load the Rust module. In *step 4*, we show that
    Python's dynamic invocation capabilities seamlessly instantiate and integrate
    the type. However, the data types need to be interpreted accordingly, which is
    why the return type is set as a character pointer and the input is of the bytes
    type to achieve the same result as the other recipes in this chapter. Since platforms
    and programming languages use their own ways of encoding bytes to strings (UTF-8,
    UTF-16, ...), we have to pass a bytes literal (which translates to a `char*` in
    C) into the function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Python代码使用标准库中的`ctypes` ([https://docs.python.org/3/library/ctypes.html](https://docs.python.org/3/library/ctypes.html))部分来加载Rust模块。在*步骤4*中，我们展示了Python的动态调用能力可以无缝实例化和集成该类型。然而，数据类型需要相应地解释，这就是为什么返回类型被设置为字符指针，输入为字节类型，以实现与其他章节中其他菜谱相同的结果。由于平台和编程语言使用它们自己的方式将字节编码为字符串（UTF-8、UTF-16等），我们必须将一个字节字面量（在C中转换为`char*`）传递给函数。
- en: In *steps 5* and *6*, we use Python's setuptools to create a `.egg` file, which
    is a distribution format for Python modules. In this particular case, we even
    create an eggsecutable ([https://setuptools.readthedocs.io/en/latest/setuptools.html#eggsecutable-scripts](https://setuptools.readthedocs.io/en/latest/setuptools.html#eggsecutable-scripts)),
    which makes it possible to run the function by executing the `.egg` file. As shown
    in *step 7*, simply running it is not enough, since we also need to make the library
    known to the execution environment. In *step 8*, we are doing that and checking
    the result (more on `LD_LIBRARY_PATH` in the *How to do it...* section of the
    *Including legacy C code* recipe earlier in this chapter).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*和*步骤6*中，我们使用Python的setuptools创建一个`.egg`文件，这是Python模块的发行格式。在这种情况下，我们甚至创建了一个eggsecutable
    ([https://setuptools.readthedocs.io/en/latest/setuptools.html#eggsecutable-scripts](https://setuptools.readthedocs.io/en/latest/setuptools.html#eggsecutable-scripts))，这使得通过执行`.egg`文件来运行函数成为可能。如*步骤7*所示，仅仅运行它是不够的，因为我们还需要让库对执行环境可见。在*步骤8*中，我们正在做这件事并检查结果（关于`LD_LIBRARY_PATH`的更多内容请参阅本章早期*包含遗留C代码*菜谱的*如何做...*部分）。
- en: In *step 9*, we run the script on Windows. Windows uses a different mechanism
    to load dynamic libraries, so the `LD_LIBRARY_PATH` method does not work. On top
    of that, Python eggsecutables are only available on Linux/macOS, and setuptools
    provides great mechanisms for deployment right away, but not for local development
    (without further installations/complexities). This is why, on Windows, we are
    executing the script directly—which is the reason for `if __name__ == "__main__"`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，我们在Windows上运行脚本。Windows使用不同的机制来加载动态库，因此`LD_LIBRARY_PATH`方法不起作用。此外，Python
    eggsecutables仅在Linux/macOS上可用，setuptools提供了即时的部署机制，但不适用于本地开发（无需进一步安装/复杂性）。这就是为什么在Windows上，我们直接执行脚本——这也是`if
    __name__ == "__main__"`的原因。
- en: Now that we have learned how to successfully run Rust from within Python, let's
    move on to the next recipe.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在Python中成功运行Rust，让我们继续下一个菜谱。
- en: Generating bindings for legacy applications
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为遗留应用程序生成绑定
- en: As we saw in the first recipe, Rust's interop capabilities with other native
    languages require specific structures to be present on either side to declare
    the memory layout properly. This task is easy to automate using `rust-bindgen`.
    Let's see how this makes integrating with native code easier.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一个菜谱中看到的，Rust与其他本地语言之间的互操作性需要在一侧或两侧存在特定的结构来正确声明内存布局。使用`rust-bindgen`可以轻松自动化这项任务。让我们看看这如何使与本地代码的集成变得更加容易。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Just like the first recipe in this chapter, *Including legacy C code*, this
    recipe has the following prerequisites:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章的第一个菜谱*包含遗留的C代码*一样，这个菜谱有以下先决条件：
- en: '`gcc` ([https://gcc.gnu.org/](https://gcc.gnu.org/)) (includes `ar` and `cc`)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcc` ([https://gcc.gnu.org/](https://gcc.gnu.org/))（包括`ar`和`cc`）'
- en: '`git` ([https://git-scm.com/](https://git-scm.com/)) (command-line or UI tools
    are fine)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git` ([https://git-scm.com/](https://git-scm.com/))（命令行或UI工具均可）'
- en: '`llvm` ([https://releases.llvm.org/2.7/docs/UsingLibraries.html](https://releases.llvm.org/2.7/docs/UsingLibraries.html))
    (library and header files for the LLVM compiler project)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm` ([https://releases.llvm.org/2.7/docs/UsingLibraries.html](https://releases.llvm.org/2.7/docs/UsingLibraries.html))（LLVM编译器项目的库和头文件）'
- en: '`libclang` ([https://clang.llvm.org/doxygen/group__CINDEX.html](https://clang.llvm.org/doxygen/group__CINDEX.html))
    (library and header files for the CLang compiler)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libclang` ([https://clang.llvm.org/doxygen/group__CINDEX.html](https://clang.llvm.org/doxygen/group__CINDEX.html))（CLang编译器的库和头文件）'
- en: The tools are available in any Linux/Unix environment (on Windows, you can use
    the WSL ([https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)))
    and might require additional installs. Check your distribution's package repositories
    for the packages in the list.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具在任何 Linux/Unix 环境中都可用（在 Windows 上，您可以使用 WSL ([https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)))，可能需要额外的安装。检查您的发行版的软件包仓库以获取列表中的软件包。
- en: On macOS, check out Homebrew, which is a package manager for Mac: [https://brew.sh/](https://brew.sh/).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，检查 Homebrew，这是一个 Mac 的包管理器：[https://brew.sh/](https://brew.sh/)。
- en: Windows users best use the WSL and follow the Linux instructions, or install MinGW
    ([http://www.mingw.org/](http://www.mingw.org/)), in an effort to provide GNU
    Linux tools for Windows.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户最好使用 WSL 并遵循 Linux 指令，或者安装 MinGW ([http://www.mingw.org/](http://www.mingw.org/))，以努力为
    Windows 提供 GNU Linux 工具。
- en: 'Check whether the tools are properly installed by opening a Terminal window
    and issuing the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开终端窗口并发出以下命令来检查工具是否正确安装：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The versions should be similar (at least the major release) to avoid any unexpected
    differences.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 版本应该相似（至少是主要版本），以避免任何意外的差异。
- en: Once ready, use the same shell to create a `bindgen` directory, and inside it
    run `cargo new rust-tinyexpr` and clone the TinyExpr GitHub repository ([https://github.com/codeplea/tinyexpr](https://github.com/codeplea/tinyexpr))
    using `git clone https://github.com/codeplea/tinyexpr`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备就绪，使用相同的 shell 创建一个 `bindgen` 目录，并在其中运行 `cargo new rust-tinyexpr` 并使用 `git
    clone https://github.com/codeplea/tinyexpr` 克隆 TinyExpr GitHub 仓库 ([https://github.com/codeplea/tinyexpr](https://github.com/codeplea/tinyexpr))。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create some bindings in just a few steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在几个步骤中创建一些绑定：
- en: 'Open `rust-tinyexpr/Cargo.toml` and add the appropriate build dependencies:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `rust-tinyexpr/Cargo.toml` 并添加适当的构建依赖项：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a new `rust-tinyexpr/build.rs` file and add the following content to
    create a custom build of the C library:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `rust-tinyexpr/build.rs` 文件，并添加以下内容以创建 C 库的定制构建：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now for the actual Rust code. Open `rust-tinyexpr/src/main.rs` and add some
    code to include the file generated by `rust-bindgen` (which is called from `build.rs`):'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是实际的 Rust 代码。打开 `rust-tinyexpr/src/main.rs` 并添加一些代码以包含由 `rust-bindgen` 生成的文件（该文件由
    `build.rs` 调用）：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we run `cargo build` now (inside `rust-tinyexpr`), we will see the following
    result:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在 `rust-tinyexpr` 内运行 `cargo build`，我们将看到以下结果：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This is a linker error—the linker could not find the library! This is because
    we never actually created it. Change into the `tinyexpr` directory and run these
    commands to create a static library from the source code on Linux/macOS:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个链接错误——链接器找不到库！这是因为我们实际上从未创建过它。切换到 `tinyexpr` 目录并运行以下命令在 Linux/macOS 上从源代码创建一个静态库：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With Windows, the process is a little bit different:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，过程略有不同：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Going back into the `rust-tinyexpr` directory, we can run `cargo build` again:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `rust-tinyexpr` 目录，我们可以再次运行 `cargo build`：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As a bonus, `bindgen` also generates tests, so we can run `cargo test` to make
    sure the binary layout is validated. Then, let''s parse an expression using the
    TinyExpr C library from Rust:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为额外的好处，`bindgen` 还会生成测试，因此我们可以运行 `cargo test` 来确保二进制布局得到验证。然后，让我们使用 Rust 的
    TinyExpr C 库解析一个表达式：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let's see how we achieved this result.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何得到这个结果的。
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`bindgen` is an amazing tool that generates Rust code from C/C++ headers *on
    the fly*. In *step 1* and* 2*, we added the dependency and used the `bindgen` API
    to load the header and generate and output a file called `bindings.rs` in the
    temporary `build` directory. The `OUT_DIR` variable is only available from within
    `cargo`''s build environment and leads to a directory containing several build
    artifacts.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`bindgen` 是一个惊人的工具，它可以从 C/C++ 头文件中实时生成 Rust 代码。在 *步骤 1* 和 *步骤 2* 中，我们添加了依赖项并使用
    `bindgen` API 加载头文件，生成并输出一个名为 `bindings.rs` 的文件到临时的 `build` 目录。`OUT_DIR` 变量仅在
    `cargo` 的构建环境中可用，并指向包含多个构建工件目录。'
- en: Additionally, the linker needs to know about the library that has been created
    so it can link to it. This is done by printing out the required parameters to
    standard with a special syntax. In this case, we pass the library's name (`link-lib`)
    and the directory it should check (`link-search`) to the `rustc` linker. `cargo`
    can do much more with these outputs. Check the docs ([https://doc.rust-lang.org/cargo/reference/build-scripts.html](https://doc.rust-lang.org/cargo/reference/build-scripts.html)) for
    more information.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，链接器需要知道已创建的库，以便可以将其链接。这是通过以特殊语法将所需参数打印到标准输出中完成的。在这种情况下，我们将库的名称（`link-lib`）和它应该检查的目录（`link-search`）传递给
    `rustc` 链接器。`cargo` 可以使用这些输出做更多的事情。有关更多信息，请查看文档 ([https://doc.rust-lang.org/cargo/reference/build-scripts.html](https://doc.rust-lang.org/cargo/reference/build-scripts.html))。
- en: Microsoft's `msvc` compiler introduced a breaking change by removing the standard
    `printf` functions in favor of more secure variations. In order to minimize the
    complexity of cross-platform compilation, a simple compiler switch was introduced
    in *step 4* to bring back the `printf` legacy.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的 `msvc` 编译器通过移除标准 `printf` 函数，以更安全的变体取而代之，引入了一个破坏性的变化。为了最小化跨平台编译的复杂性，在 *步骤
    4* 中引入了一个简单的编译器切换，以恢复 `printf` 旧版本。
- en: '*Step 3* creates the Rust code to call the linked functions (while discarding
    several warnings about naming) by including the file. While `bindgen` takes away
    the generation of the interface, it''s still necessary to use C-compatible types
    for passing parameters. This is why we have to create the pointer when we call
    the function.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 3* 通过包含文件创建 Rust 代码来调用链接的函数（同时忽略关于命名的几个警告）。虽然 `bindgen` 去除了接口的生成，但仍然需要使用与
    C 兼容的类型来传递参数。这就是为什么在调用函数时我们必须创建指针的原因。'
- en: If we compiled the Rust code right after this step, we would end up with a huge
    error message, as shown in *step 4*. To remedy this, we create the static library
    from the C code in *step 5*, using a few compiler flags for `cc` (the `gcc` C
    compiler), such as `-fPIC` (which stands for *position independent code*), which
    creates consistent positions within the file, so it's usable as a library. The
    output of the `cc` call is an object file, which is then *archived* in a static
    library using the `ar` tool.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这一步之后立即编译 Rust 代码，我们最终会得到一个巨大的错误信息，如 *步骤 4* 所示。为了解决这个问题，我们在 *步骤 5* 中从 C
    代码创建静态库，使用一些 `cc`（`gcc` C 编译器）的编译器标志，例如 `-fPIC`（代表 *位置无关代码*），它会在文件中创建一致的位置，因此可以作为库使用。`cc`
    调用的输出是一个目标文件，然后使用 `ar` 工具将其存档到静态库中。
- en: If the library is properly available, we can use `cargo build` and `cargo run`—as
    shown in the last two steps—to execute the code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库正确可用，我们可以使用 `cargo build` 和 `cargo run`——如最后两步所示——来执行代码。
- en: Now that we know how to integrate Rust with other languages, let's move on to
    another chapter to deep dive into a different topic.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何将 Rust 与其他语言集成，让我们继续进入下一章，深入探讨另一个主题。
