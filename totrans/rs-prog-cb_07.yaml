- en: Integrating Rust with Other Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's application landscape, integration is key. Whether you are slowly
    modernizing a legacy service or starting from scratch with using a new language,
    programs rarely run in isolation nowadays. Rust is still an exotic technology
    for many companies and—unfortunately—is usually not considered in the typical
    SDK. This is why Rust made a point of *playing nicely with others*, which is why
    the community can (and will) supply a large number of drivers, service integrations,
    and so on, by wrapping other (native) libraries.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we rarely have the luxury of starting completely from scratch
    (greenfield projects), so in this chapter, we will cover the various ways the
    Rust language integrates with other languages and technologies. We'll focus on
    the most popular and useful integrations at the time of writing, but these fundamentals
    should provide a basis for greater interoperability as well since many languages
    provide an interface for native binaries (such as .NET ([https://docs.microsoft.com/en-us/cpp/dotnet/calling-native-functions-from-managed-code?view=vs-2019](https://docs.microsoft.com/en-us/cpp/dotnet/calling-native-functions-from-managed-code?view=vs-2019)) or
    Java's JNI ([https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html#wp9502](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html#wp9502))).
    With that knowledge, adding Rust to enhance your web application should be just
    as easy as creating a sensor driver wrapper for the manufacturer's code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We believe that good integration is important for the success of a language.
    In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Including legacy C code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling into Rust from Node.js using FFI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Rust in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Rust and Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating bindings for legacy applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including legacy C code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C is still among the most popular programming languages ([https://www.tiobe.com/tiobe-index/](https://www.tiobe.com/tiobe-index/))
    thanks to its versatility, speed, and simplicity. Due to this, many applications—legacy
    or not—are developed using C, with all of its upsides and downsides. Rust shares
    a domain with C—systems programming, which is why more and more companies replace
    their C code with Rust thanks to its safety and appeal as a modern programming
    language. However, changes are not always made in one big bang ([https://www.linkedin.com/pulse/big-bang-vs-iterative-dilemma-martijn-endenburg/](https://www.linkedin.com/pulse/big-bang-vs-iterative-dilemma-martijn-endenburg/));
    it's usually a much more gradual (iterative) approach that includes swapping out
    components and replacing parts of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use the C code as an analogy because it's popular and well known. However,
    these techniques apply to any (natively) compiled technology, such as Go, C++,
    or even Fortran. So let's get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are not only building Rust but also C. For this, we need
    a C compiler toolchain—`gcc` ([https://gcc.gnu.org/](https://gcc.gnu.org/)) and `make`:
    [https://www.gnu.org/software/make/manual/make.html](https://www.gnu.org/software/make/manual/make.html),
    which is a rule-based scripting engine for executing the build.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether the tools are installed by opening a Terminal window (note that
    the versions should be similar—at least the major release—to avoid any unexpected
    differences):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If these commands are not available on your machine, check how to install them
    on your operating system. In any **Linux/Unix** environment (including the WSL—the
    **Windows Subsystem for Linux**: [https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)),
    they can require the installation of `gcc` and `make` via the default package
    repositories. On some distributions (for example, Ubuntu), bundles such as `build_essentials` ([https://packages.ubuntu.com/xenial/build-essential](https://packages.ubuntu.com/xenial/build-essential))
    provide these tools as well.'
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, check out Homebrew, which provides a similar experience and provides `gcc` as
    well as `make`: [https://brew.sh/](https://brew.sh/).
  prefs: []
  type: TYPE_NORMAL
- en: Windows users have a choice between the WSL (and then following the Linux instructions)
    or using Cygwin ([https://www.cygwin.com](https://www.cygwin.com)) to find `gcc-core`
    and `make` there. We recommended adding these tools (by default, `C:\cygwin64\bin`)
    to the `PATH` variable on Windows ([https://www.java.com/en/download/help/path.xml](https://www.java.com/en/download/help/path.xml)),
    so a regular (PowerShell) Terminal can access Cygwin's executables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once ready, use the same shell to create a `legacy-c-code` directory and, inside,
    run `cargo new rust-digest --lib` and create a directory named `C` alongside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `C` directory, create an `src` folder to mirror the Rust project.
    Open the entire `legacy-c-code` in Visual Studio Code or your Rust development
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to be able to include legacy code in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the Rust library first. Open `rust-digest/Cargo.toml` to adjust
    the configuration to output a dynamic library (`*.so` or `*.dll`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another thing to add is the dependencies. Here, we are using types from `libc`
    and a cryptography library called `ring`, so let''s add those dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can take care of the code itself. Let''s open `rust-digest/src/lib.rs`
    and replace the default code with the following snippet. This snippet creates
    an interface from the outside world that accepts a string (a mutable character
    pointer) and returns a string digest of the input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be a full Rust library now. Let''s run `cargo build` inside `rust-digest` to
    check the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be a `libdigest.so` library (or `digest.dll` on Windows):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, let''s do a release build as well. Run `cargo build --release` in `rust-digest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `C` part of the project, create and open `C/src/main.c` to
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`make` is the traditional (and simplest) tool to build `C` code. `make` runs
    a file called `Makefile` to adhere to the rules that it defines. Create and open `C/Makefile` and
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is in place, we should be able to switch to the `C` directory
    and run `make all` there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Afterward, there is a `C/target` directory, which contains two files: `main.o` and `main` (`main.exe` on
    Windows).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the executable (the `.o` file is just the object file; not
    for running), we also need to tell it where our dynamic library is located. For
    that, the `LD_LIBRARY_PATH` environment variable is typically used. Open `bash` and
    run the following command inside the `legacy-c-code` directory to—temporarily—overwrite
    the variable with the appropriate path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to finally run the C program and check whether everything worked
    out. Switch to the `C/target` directory and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With that done, let's take a look behind the scenes to understand how it was
    done.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replacing legacy C code with Rust is a step-by-step process that is often done
    in order to improve developer productivity, safety, and potential innovation.
    This has been done in countless applications (for example, in Microsoft's public
    cloud offering, Azure: [https://azure.microsoft.com/en-gb/](https://azure.microsoft.com/en-gb/))
    and requires two technologies to work together flawlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to Rust''s LLVM-based compiler, the compilation outputs native code
    (for example, ELF on Linux: [https://en.wikipedia.org/wiki/Executable_and_Linkable_Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)),
    which makes it accessible—in particular—for C/C++. In this recipe, we are taking
    a look at how to link those two outputs together into a single program using a
    dynamic library built in Rust.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The prerequisites for creating a dynamic library (`*.so`/`*.dll`) in Rust are
    surprisingly simple: *step 1* shows the required changes to `Cargo.toml` for `rustc` to
    output the required format. There are other formats, so if you are looking for
    something specific, check out the nomicon ([https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries](https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries)) and docs
    at [https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries](https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* shows the code to create an SHA256 ([https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/](https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/)) digest
    of an incoming string, but only after it calls a simple callback function, `pre_digest()`, to
    showcase the bi-directional bindings. There are a few things of note here:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing a function from a linked library is done using an `extern "C" {}` declaration
    (the `"C"` isn't actually necessary). After declaring a construct like that, it
    can be used just like any other function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to export a function compatible with the ELF format, the `#[no_mangle]` attribute
    is required since the compiler runs a name-mangling scheme that changes the function
    name. Since compilers don''t have a common scheme, `no_mangle` makes sure it stays
    just as it is. To learn more about name mangling, check out this link: [https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `unsafe` inside the `digest` function is required for a few reasons.
    First, calling an external function is always unsafe (`pre_digest()`). Second,
    the conversion from a `char` pointer to `CStr` is unsafe, requiring the scope
    as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note:** `ring` ([https://github.com/briansmith/ring](https://github.com/briansmith/ring)) is
    a pure Rust implementation of several cryptography algorithms, so there are no OpenSSL
    ([https://www.openssl.org/](https://www.openssl.org/)) or LibreSSL ([https://www.libressl.org](https://www.libressl.org)) requirements.
    Since both of those libraries are built on the respective native libraries, they
    always present a headache to even experienced Rust developers. Being pure Rust, `ring` avoids
    any of their linking/compilation issues, however.'
  prefs: []
  type: TYPE_NORMAL
- en: From *steps **4* to* 6*, we are building the Rust library just as we used to,
    but instead of a `.rlib` file, a `.so` or `.dll` file is the result of this process.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 7* shows the `C` code required to import and call a dynamically linked
    function. `C` keeps this admirably simple with an `extern` declaration for the
    interface, which enables you to call the function just like that. The callback
    is also implemented and exported using the `extern` declaration and it simply
    prints out that it was called.'
  prefs: []
  type: TYPE_NORMAL
- en: Rust's build system really shines when we get to *step 8*, where the rules for
    `Makefile` are created. Making rules is simple, but it leaves a lot of room for
    complexity, as many C developers know. In our recipe, however, we want to keep
    it easy to understand. Each rule consists of a target (for example, `all`) and
    its dependencies (for example, `target/main`), as well as a body of bash commands
    to run (for example, `@mkdir -p $@`).
  prefs: []
  type: TYPE_NORMAL
- en: These dependencies can be files (such as `target/main.o` or `target/main`) or
    other rules. If they are files, check when they were modified last and, if there
    was a change, that they run the rule and its dependencies. The resulting dependency
    tree gets resolved automatically. As fascinating as this highly useful, 30-year-old
    tool may be, there are books written that are devoted to how it works. It is certainly
    a deep dive into history, and Linux conventions. Check out a short tutorial here: [http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)[ or
    go straight to the make manual (](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)[https://www.gnu.org/software/make/manual/make.html](https://www.gnu.org/software/make/manual/make.html)[).](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/)
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 9* compiles the `C` code into an executable and links it to `libdigest.so`,
    which `rustc` created. We are also pointing the linker to the right path in the `LDFLAGS` variable
    in `Makefile`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only in *step 10* will it become apparent how a static library is different
    from a dynamic library. The latter has to be available at runtime because it isn''t
    baked into the executable and relies on other mechanisms to be found. One such
    mechanism is the `LD_LIBRARY_PATH` environment variable, which points to directories
    with `libXXXX.so` files for the program to find its dependencies (by name). For
    this recipe, we are **replacing** the original value with wherever your `rust-digest/target/release` directory
    is located (`$(pwd)` outputs the current directory); however, this is only for
    the current Terminal session, so whenever you close and reopen the window, the
    setting will be gone. If the path is improperly set or the directory/file is missing,
    executing `main` will give you something along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Step 11* shows the correct output since the `pre_digest` function was called
    and we were able to create the correct SHA256 digest for `"Hello World"` (without
    the `"`).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know a little more about integrating Rust into a C-type application,
    we can move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Calling into Rust from Node.js using FFI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a language that excels in its flat learning curve and flexibility,
    which leads to impressive adoption rates in various areas outside of the original
    browser animation. Node.js ([https://nodejs.org/en/](https://nodejs.org/en/))
    is a runtime based on Google's V8 JavaScript engine, which allows JavaScript code
    to run directly on the operating system (without the browser), including access
    to various low-level APIs in order to enable IoT-type applications and web services,
    or even to create and display virtual/augmented reality environments ([https://github.com/microsoft/HoloJS](https://github.com/microsoft/HoloJS)).
    All of this is possible because the Node runtime provides access to native libraries
    on the host operating system. Let's see how we create a Rust library to call from
    JavaScript into this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are working with Node.js, please install `npm` and the Node.js runtime,
    as explained on their official website: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    Once ready, you should be able to run these commands from a Terminal (PowerShell
    or bash):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual versions may be higher at the time of reading. The node dependency
    we are using also requires C/C++ tools, as well as having Python 2 installed.
    Follow the instructions for your OS on GitHub: [https://github.com/nodejs/node-gyp#installation](https://github.com/nodejs/node-gyp#installation).
    Then, let''s set up a folder structure similar to the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `node-js-rust` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a sub-folder called `node`, change into it, and run `npm init` to generate `package.json`—basically,
    Node's `Cargo.toml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `node` folder, add a directory called `src`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the same level as the `node` folder, create a new Rust project called `cargo
    new rust-digest --lib` (or reuse the one from the previous recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end, you should have a directory setup like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Open the entire directory in Visual Studio Code to work on the code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it ...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s repeat a few steps from the SHA256 library from the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take care of the Rust part. Open `rust-digest/Cargo.toml` to
    add `ring`, a dependency for the hashing part, as well as the `crate-type` configuration
    for cross-compilation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the Rust code. Just as in other recipes in this chapter,
    we are creating a fast way to generate an SHA digest via Rust to be used from
    Node.js:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo build` now creates a native library. You can find the library in `target/debug`
    inside the Rust project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the JavaScript part calls into the Rust binary, there are a few declarations
    to be made in order to make the function known. We finish off the code by printing
    out the result of a call to the Rust library. Add this to `node/src/index.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `require` statement already hints toward a dependency, so let''s integrate
    this as well. Open `node/package.json` to add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, we can now issue an `npm install` command from within
    the `node` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After the dependencies have been installed, the `node` application is ready
    to run. Issue `node src/index.js` to execute the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Having done the work, let's take a look at why and how it all comes together.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js, as a native runtime environment for JavaScript, provides easy-to-access
    native libraries that can be built with Rust. In order to do that, the `node-ffi` ([https://github.com/node-ffi/node-ffi](https://github.com/node-ffi/node-ffi)) package is
    required to dynamically find and load the desired libraries. First, however, we
    start with the Rust code and project: *steps* *1* to *3* show how to build a native
    dynamic library, which we discussed earlier in this chapter, in the *Including
    legacy C code* recipe, in the *How it works...* section.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we create the JavaScript code. Thanks to the dynamic nature of
    JavaScript, defining the function signature can be done using strings and objects
    and the actual invocation looks just like a regular function that can be imported
    from a module. The FFI library also takes away the data type conversion, and the
    call across technology boundaries is seamless. Another important note is that,
    with `node-ffi` ([https://github.com/node-ffi/node-ffi](https://github.com/node-ffi/node-ffi)),
    the actual module path is required, which makes handling the different artifacts
    a lot easier (compared to using environment variables in C/C++ interop).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* and *step 6*, we take care of adding and installing the required
    dependencies for Node.js using the famous `npm` package manager ([https://www.npmjs.com/](https://www.npmjs.com/)),
    with `node-ffi` ([https://github.com/node-ffi/node-ffi](https://github.com/node-ffi/node-ffi))
    requiring some compiler tools to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: The last step shows how the program executes and creates the same hash as other
    recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned how to call into Rust from Node.js using FFI, so now let's move
    on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Running Rust in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running Rust in the browser may seem like a similar task to using Rust binaries
    with Node.js. However, the modern browser environment is exceedingly more difficult.
    Sandboxing limits access to local resources (which is a good thing!) and browsers
    provide a small number of scripting languages to run within the website. While
    the most successful language is JavaScript, it comes with many drawbacks in the
    area of animation, caused by the scripting nature of the technology. On top of
    that, there is garbage collection, a type system with many flaws, and the lack
    of a coherent programming paradigm—all of which manifests itself in unpredictable
    and poor performance for real-time applications such as games.
  prefs: []
  type: TYPE_NORMAL
- en: However, these issues are being resolved. A technology called WebAssembly has
    been introduced to be able to distribute binaries (as an assembler language for
    the web) that can be run in a specialized execution environment—just like JavaScript.
    In fact, JavaScript is able to seamlessly interact with these binaries, akin to
    native libraries in a Node.js application, which speeds things up considerably.
    Thanks to Rust's LLVM base, it can compile to WebAssembly, and, with its memory
    management, it's a great choice for running these real-time applications. While
    this technology is still in its infancy, let's see how this works!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, we are setting up a directory called `browser-rust`, containing
    a `web` directory and a `cargo` library project called `rust-digest` (`cargo new
    rust-digest --lib`). For the compilation, we need an additional compilation target, `wasm23-unknown-unknown`,
    which can be installed via `rustup`. Issue the following command in a Terminal
    to install the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Use `cargo` to install a tool called `wasm-bindgen-cli` (`cargo install wasm-bindgen-cli`),
    and check whether it works by invoking `wasm-bindgen` in your current console
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `web` directory, we create a file named `index.html`, which will
    host and show our Rust output. In order to be able to render the index file, a
    web server is also required. Here are a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python (3.x)''s standard library comes with an `http.server` module, which
    can be called like this: `python3 -m http.server 8080`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fans of JavaScript and Node.js can use `http-server` ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)),
    installable via `npm` ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recent versions of Ruby come with a web server as well: `ruby -run -ehttpd
    . -p8080`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Windows, you can use IIS Express ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)),
    also via the command line: `C:\> "C:\Program Files (x86)\IIS Express\iisexpress.exe"
    /path:C:\Rust-Cookbook\Chapter07\browser-rust\web /port:8080`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any web server that serves static files will do, and it should be able to provide
    the files appropriately. You should end up with a directory structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Your project should now be set up and ready to go. Let's see how we can get
    Rust to run in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s how to write low-latency web applications in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the Rust part. We''ll again create a hashing library,
    so we start by creating the API basics. Open `rust-digest/src/lib.rs` and insert
    the following above the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s bind the `hex_digest()` function to a public API that we can call from
    outside the module. This enables us to invoke the code using WASM types and even
    autogenerate most of these bindings. Add some of those just below the preceding
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s sometimes handy to have a callback once the module is instantiated, so
    let''s add one of those as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used two imports that require additional dependencies: `wasm-bindgen`
    and `sha2` (as a web-compatible version of `ring::digest`). Additionally, we are
    pretending to be a native library for external linking, so the library type and
    name should be adjusted. Modify `rust-digest/Cargo.toml` to include these changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile the library and check the output. Run `cargo build --target
    wasm32-unknown-unknown`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting `digest.wasm` file is what we want to include in our web application
    using JavaScript. While this can be done directly ([https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API](https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API)),
    the data type conversion can be quite cumbersome. This is why there is a CLI tool
    to help out. Run `wasm-bindgen target/wasm32-unknown-unknown/debug/digest.wasm
    --out-dir ../web/ --web` from within `browser-rust/rust-digest` to generate the
    necessary JavaScript bindings for web browsers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'These bindings need to be included in our `web/index.html` file (which is empty
    at the moment):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and exit the `index.html` file and start the web server you prepared earlier
    inside the web directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Access `http://localhost:8080` in your browser (be sure to allow the server
    through the firewall) and check whether your output matches the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad8dc81b-b4e0-4a4d-b33b-8341643e2498.png)'
  prefs: []
  type: TYPE_IMG
- en: Having done the work, let's take a look at why and how it all comes together.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern browsers provide a JavaScript engine alongside a web assembly virtual
    machine ([https://webassembly.org/](https://webassembly.org/)). With this capability,
    web applications can run binary code that is safely executed inside its own runtime
    environment with easy access from the outside. The main benefits include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A smaller-sized application, thanks to binary compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster end-to-end execution times (no compilation step)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No garbage collection—the WASM virtual machine is a stack machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On top of that, WASM can be converted into a text-based format for visual inspection
    and manual optimization. Rust is one of the few languages to even compile to these
    formats (text and binary), and it's largely thanks to LLVM and Rust's approach
    to memory management.
  prefs: []
  type: TYPE_NORMAL
- en: In *steps 1*, *2*, and *3*, we create the Rust module to do the work. Notice
    the `#[wasm_bindgen]` attributes over the `extern` functions, which allow the
    macro preprocessor to fetch the input and output types of the function and generate
    bindings from this interface definition. There is also a special ([https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html](https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html))
    `#[wasm_bindgen(start)]` macro on top of one of the functions, which designates
    the initializer function to run whenever the module is instantiated. Both this
    function and `digest_attach()` feature a `Result` return type, which allows the
    `?` operator and rusty error handling in general.
  prefs: []
  type: TYPE_NORMAL
- en: '`digest_attach()` is special (compared to `digest()`) since it directly accesses
    the DOM ([https://www.w3.org/TR/WD-DOM/introduction.html](https://www.w3.org/TR/WD-DOM/introduction.html)) from
    the WASM module, which is provided by the `web_sys` crate. All of these macros
    and functions are imported in the `wasm_bindgen::prelude::*` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* adjusts `Cargo.toml` accordingly to provide everything in order for
    the compilation to work. Note that any errors here that work on a different target
    (for example, the default target) hint toward an incompatible crate for WASM.
    Only in *step 5* do we execute the compilation for the wasm32 target, which produces
    a WASM binary file. *Step 6* runs the binding generator using the `wasm-bindgen`
    CLI, which produces a few files for easier integration. In this case, they are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`digest_bg.d.ts`: TypeScript ([https://www.typescriptlang.org/](https://www.typescriptlang.org/))
    definitions for the exported WASM functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digest_bg.wasm`: The WASM file itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digest.d.ts`: TypeScript definitions for the integration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digest.js`: The JavaScript implementation for loading and converting the exported
    WASM functions into regular JavaScript calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool includes more options and examples ([https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html](https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html)) for
    other integrations so, check out the documentation for specifics ([https://rustwasm.github.io/docs/wasm-bindgen/](https://rustwasm.github.io/docs/wasm-bindgen/)).
  prefs: []
  type: TYPE_NORMAL
- en: Not every crate can be compiled to `wasm32-unknown-unknown`, especially if they
    are using hardware access or operating system features. Some crates implement
    compatibility layers that are often specified as `cargo` features.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 7* shows how to include the generated WASM bindings into a regular HTML
    page. Outside of the ES6 syntax ([http://es6-features.org/#Constants](http://es6-features.org/#Constants))
    (which may be unfamiliar to some), the Rust code is neatly wrapped in JavaScript
    functions, so no additional conversion is needed. For those interested in how
    this works, check out the `digest.js` file, which is quite readable but shows
    the complexity involved in transforming the data. That''s it—the last step only
    shows how to serve the files and that the hosting actually works.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to run Rust in the browser, let's move on to the
    next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Using Rust and Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has become a staple language for many applications, from the web to data
    science. However, Python itself is an interpreted language and is famously quite
    slow—which is why it integrates well with much faster C code. Many well-liked
    libraries are implemented in C/C++ and Cython ([https://cython.org/](https://cython.org/)) in
    order to achieve the required performance (for example, `numpy`, `pandas`, `keras`,
    and PyTorch are largely native code). Since Rust produces native binaries as well,
    let's look at how we can write Rust modules for Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will work on creating an SHA256 digest again and will use the same folder
    structure as we have in every recipe in this chapter. Create a `python-rust` directory and
    initialize a new Rust project there using `cargo new rust-digest --lib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Python part of the project, install Python (3.6/3.7) by following the
    instructions on the website. Then, create the following folder structure and files
    (empty is OK for now) inside `python-rust/python`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Open the entire `python-rust` folder in VS Code and you are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is a great language to integrate with—find out why in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `rust-digest/src/lib.rs` to start off with the Rust code. Let''s add the
    required `use` statements for FFI and `ring` and declare a `digest()` function
    to be exported. Note that this function is the same as in most other recipes in
    this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are using `ring` and a third-party dependency to create the hash, let''s
    declare them (and the library type) in `rust-digest/Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s build the library to obtain `libdigest.so` (or `digest.dll` or
    `libdigest.dylib`). Run `cargo build` inside `rust-digest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to load this library in Python, we need to write some code as well.
    Open `python/src/digest.py` and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'While this file can be run by invoking `python3 digest.py`, it''s not what
    a larger project will look like. Python''s setuptools ([https://setuptools.readthedocs.io/en/latest/](https://setuptools.readthedocs.io/en/latest/)) provide
    a better-structured approach to create and even install runnable scripts for the
    current OS. The common point of entry is the `setup.py` script, which declares
    metadata along with dependencies and entry points. Create `python/setup.py` with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The file continues to input the declared variables into the `setup()` method,
    which generates the required metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Steps 6*, *7*, and *8* are for Linux/macOS only (or WSL). Windows users, please
    continue with *step 9*. Python''s standalone modules are called eggs, so let''s
    make one and run `python3 setup.py bdist_egg`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a `.egg` file in `python/dist`, which is built to run the `main()`
    function from the preceding script when invoked. On Mac/Linux, you have to run
    `chmod +x python/dist/digest-0.1.0-py3.7.egg` to be able to run it. Let''s see
    what happens when we run it right away:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Right, the library is only dynamically linked! We have to point our binary
    to the library or move the library where it can find it. On Mac/Linux, this can
    be accomplished by setting the `LD_LIBRARY_PATH` environment variable to wherever
    the Rust build output is located. The result is a Python program that calls into
    the compiled Rust code for an `SHA256` digest of a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows users, the execution is a little bit simpler. First, make the library
    available to Python and then run the script directly. Run the following from within
    the `python` directory to use Rust from within Python to generate the `SHA256`
    digest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at how and why this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enhancing Python''s capabilities with Rust is a great way to get the best of
    both worlds: Python is famously easy to learn and use; Rust is fast and safe (and
    does not fail at runtime as easily).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *steps 1* to *3*, we again create a dynamic native library that creates
    an `SHA256` hash out of a provided string argument. The required changes in `Cargo.toml`
    and `lib.rs` are the same as if we were to create a library for C/C++ inter-op:
    `#[no_mangle]`. The *Including legacy C code* recipe earlier in this chapter describes
    the inner workings in more detail, so be sure to read the *How it works...* section
    there as well.'
  prefs: []
  type: TYPE_NORMAL
- en: The `cdylib` library type describes a dynamic library for C, and other types
    are available for different purposes. Check out the nomicon ([https://doc.rust-lang.org/nomicon/ffi.html](https://doc.rust-lang.org/nomicon/ffi.html)) and docs
    ([https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries](https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries)) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Our Python code uses the `ctypes` ([https://docs.python.org/3/library/ctypes.html](https://docs.python.org/3/library/ctypes.html))
    part of the standard library to load the Rust module. In *step 4*, we show that
    Python's dynamic invocation capabilities seamlessly instantiate and integrate
    the type. However, the data types need to be interpreted accordingly, which is
    why the return type is set as a character pointer and the input is of the bytes
    type to achieve the same result as the other recipes in this chapter. Since platforms
    and programming languages use their own ways of encoding bytes to strings (UTF-8,
    UTF-16, ...), we have to pass a bytes literal (which translates to a `char*` in
    C) into the function.
  prefs: []
  type: TYPE_NORMAL
- en: In *steps 5* and *6*, we use Python's setuptools to create a `.egg` file, which
    is a distribution format for Python modules. In this particular case, we even
    create an eggsecutable ([https://setuptools.readthedocs.io/en/latest/setuptools.html#eggsecutable-scripts](https://setuptools.readthedocs.io/en/latest/setuptools.html#eggsecutable-scripts)),
    which makes it possible to run the function by executing the `.egg` file. As shown
    in *step 7*, simply running it is not enough, since we also need to make the library
    known to the execution environment. In *step 8*, we are doing that and checking
    the result (more on `LD_LIBRARY_PATH` in the *How to do it...* section of the
    *Including legacy C code* recipe earlier in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9*, we run the script on Windows. Windows uses a different mechanism
    to load dynamic libraries, so the `LD_LIBRARY_PATH` method does not work. On top
    of that, Python eggsecutables are only available on Linux/macOS, and setuptools
    provides great mechanisms for deployment right away, but not for local development
    (without further installations/complexities). This is why, on Windows, we are
    executing the script directly—which is the reason for `if __name__ == "__main__"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to successfully run Rust from within Python, let's
    move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Generating bindings for legacy applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the first recipe, Rust's interop capabilities with other native
    languages require specific structures to be present on either side to declare
    the memory layout properly. This task is easy to automate using `rust-bindgen`.
    Let's see how this makes integrating with native code easier.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the first recipe in this chapter, *Including legacy C code*, this
    recipe has the following prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gcc` ([https://gcc.gnu.org/](https://gcc.gnu.org/)) (includes `ar` and `cc`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git` ([https://git-scm.com/](https://git-scm.com/)) (command-line or UI tools
    are fine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`llvm` ([https://releases.llvm.org/2.7/docs/UsingLibraries.html](https://releases.llvm.org/2.7/docs/UsingLibraries.html))
    (library and header files for the LLVM compiler project)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libclang` ([https://clang.llvm.org/doxygen/group__CINDEX.html](https://clang.llvm.org/doxygen/group__CINDEX.html))
    (library and header files for the CLang compiler)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tools are available in any Linux/Unix environment (on Windows, you can use
    the WSL ([https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)))
    and might require additional installs. Check your distribution's package repositories
    for the packages in the list.
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, check out Homebrew, which is a package manager for Mac: [https://brew.sh/](https://brew.sh/).
  prefs: []
  type: TYPE_NORMAL
- en: Windows users best use the WSL and follow the Linux instructions, or install MinGW
    ([http://www.mingw.org/](http://www.mingw.org/)), in an effort to provide GNU
    Linux tools for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether the tools are properly installed by opening a Terminal window
    and issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The versions should be similar (at least the major release) to avoid any unexpected
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: Once ready, use the same shell to create a `bindgen` directory, and inside it
    run `cargo new rust-tinyexpr` and clone the TinyExpr GitHub repository ([https://github.com/codeplea/tinyexpr](https://github.com/codeplea/tinyexpr))
    using `git clone https://github.com/codeplea/tinyexpr`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create some bindings in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `rust-tinyexpr/Cargo.toml` and add the appropriate build dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `rust-tinyexpr/build.rs` file and add the following content to
    create a custom build of the C library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the actual Rust code. Open `rust-tinyexpr/src/main.rs` and add some
    code to include the file generated by `rust-bindgen` (which is called from `build.rs`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run `cargo build` now (inside `rust-tinyexpr`), we will see the following
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a linker error—the linker could not find the library! This is because
    we never actually created it. Change into the `tinyexpr` directory and run these
    commands to create a static library from the source code on Linux/macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With Windows, the process is a little bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back into the `rust-tinyexpr` directory, we can run `cargo build` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As a bonus, `bindgen` also generates tests, so we can run `cargo test` to make
    sure the binary layout is validated. Then, let''s parse an expression using the
    TinyExpr C library from Rust:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how we achieved this result.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`bindgen` is an amazing tool that generates Rust code from C/C++ headers *on
    the fly*. In *step 1* and* 2*, we added the dependency and used the `bindgen` API
    to load the header and generate and output a file called `bindings.rs` in the
    temporary `build` directory. The `OUT_DIR` variable is only available from within
    `cargo`''s build environment and leads to a directory containing several build
    artifacts.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the linker needs to know about the library that has been created
    so it can link to it. This is done by printing out the required parameters to
    standard with a special syntax. In this case, we pass the library's name (`link-lib`)
    and the directory it should check (`link-search`) to the `rustc` linker. `cargo`
    can do much more with these outputs. Check the docs ([https://doc.rust-lang.org/cargo/reference/build-scripts.html](https://doc.rust-lang.org/cargo/reference/build-scripts.html)) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft's `msvc` compiler introduced a breaking change by removing the standard
    `printf` functions in favor of more secure variations. In order to minimize the
    complexity of cross-platform compilation, a simple compiler switch was introduced
    in *step 4* to bring back the `printf` legacy.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* creates the Rust code to call the linked functions (while discarding
    several warnings about naming) by including the file. While `bindgen` takes away
    the generation of the interface, it''s still necessary to use C-compatible types
    for passing parameters. This is why we have to create the pointer when we call
    the function.'
  prefs: []
  type: TYPE_NORMAL
- en: If we compiled the Rust code right after this step, we would end up with a huge
    error message, as shown in *step 4*. To remedy this, we create the static library
    from the C code in *step 5*, using a few compiler flags for `cc` (the `gcc` C
    compiler), such as `-fPIC` (which stands for *position independent code*), which
    creates consistent positions within the file, so it's usable as a library. The
    output of the `cc` call is an object file, which is then *archived* in a static
    library using the `ar` tool.
  prefs: []
  type: TYPE_NORMAL
- en: If the library is properly available, we can use `cargo build` and `cargo run`—as
    shown in the last two steps—to execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to integrate Rust with other languages, let's move on to
    another chapter to deep dive into a different topic.
  prefs: []
  type: TYPE_NORMAL
