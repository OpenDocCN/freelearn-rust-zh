["```rs\nuse actix_web::{App, HttpServer, HttpResponse};\nuse actix_service::Service;\nuse futures::future::{ok, Either};\nuse actix_cors::Cors;\n```", "```rs\n.wrap_fn(|req, srv|{\n    let passed: bool;\n    if req.path().contains(\"/v1/\") {\n        passed = false;\n    } else {\n        passed = true;\n    }\n. . .\n```", "```rs\nlet future = srv.call(req);\nasync {\n    let result = fut.await?;\n    Ok(result)\n}\n```", "```rs\n    let end_result;\n    if passed == true {\n        end_result = Either::Left(srv.call(req))\n    }\n    else {\n        let resp = HttpResponse::NotImplemented().body(\n            \"v1 API is no longer supported\"\n            );\n        end_result = Either::Right(\n            ok(req.into_response(resp)\n                  .map_into_boxed_body())\n        )\n    }\n    async move {\n        let result = end_result.await?;\n        Ok(result)\n    }\n}).configure(views::views_factory).wrap(cors);\n```", "```rs\nlet outcome = \"test\".to_owned();\nHttpServer::new(|| {\n    . . .\n    let app = App::new()\n        .wrap_fn(|req, srv|{\n            println!(\"{}\", outcome);\n            . . .\n        }\n    . . .\n```", "```rs\nconst OUTCOME: &str = \"test\";\nHttpServer::new(|| {\n    . . .\n    let app = App::new()\n        .wrap_fn(|req, srv|{\n            println!(\"{}\", outcome);\n            . . .\n        }\n    . . .\n```", "```rs\n[package]\nname = \"web_app\"\nversion = \"0.1.0\"\nedition = \"2021\"\nbuild = \"build.rs\"\n[build-dependencies]\nserde_yaml = \"0.8.23\"\nserde = { version = \"1.0.136\", features = [\"derive\"] }\n```", "```rs\nuse std::fs::File;\nuse std::io::Write;\nuse std::collections::HashMap;\nuse serde_yaml;\nfn main() {\n  let file =\n      std::fs::File::open(\"./build_config.yml\").unwrap();\n  let map: HashMap<String, serde_yaml::Value> =\n      serde_yaml::from_reader(file).unwrap();\n  let version =\n      map.get(\"ALLOWED_VERSION\").unwrap().as_str()\n          .unwrap();\n  let mut f =\n      File::create(\"./src/output_data.txt\").unwrap();\n  write!(f, \"{}\", version).unwrap();\n}\n```", "```rs\nALLOWED_VERSION: v1\n```", "```rs\nconst ALLOWED_VERSION: &'static str = include_str!(\n    \"./output_data.txt\");\nHttpServer::new(|| {\n. . .\n```", "```rs\nHttpServer::new(|| {\n. . .\nlet app = App::new()\n.wrap_fn(|req, srv|{\n    let passed: bool;\n    if *&req.path().contains(&format!(\"/{}/\",\n                             ALLOWED_VERSION)) {\n        passed = true;\n    } else {\n        passed = false;\n    }\n```", "```rs\n. . .\nlet end_result = match passed {\n    true => {\n        Either::Left(srv.call(req))\n    },\n    false => {\n        let resp = HttpResponse::NotImplemented()\n            .body(format!(\"only {} API is supported\",\n                ALLOWED_VERSION));\n        Either::Right(\n            ok(req.into_response(resp).map_into_boxed_body())\n        )\n    }\n};\n. . .\n```", "```rs\n    version: \"3.7\"\n    ```", "```rs\n    services:\n    ```", "```rs\n      postgres:\n    ```", "```rs\n        container_name: 'to-do-postgres'\n    ```", "```rs\n        image: 'postgres:11.2'\n    ```", "```rs\n        restart: always\n    ```", "```rs\n        ports:\n    ```", "```rs\n          - '5433:5432'\n    ```", "```rs\n        environment:\n    ```", "```rs\n          - 'POSTGRES_USER=username'\n    ```", "```rs\n          - 'POSTGRES_DB=to_do'\n    ```", "```rs\n          - 'POSTGRES_PASSWORD=password'\n    ```", "```rs\n      redis:\n    ```", "```rs\n          container_name: 'to-do-redis'\n    ```", "```rs\n          image: 'redis:5.0.5'\n    ```", "```rs\n          ports:\n    ```", "```rs\n            - '6379:6379'\n    ```", "```rs\n    [dependencies]\n    ```", "```rs\n    . . .\n    ```", "```rs\n    redis = \"0.21.5\"\n    ```", "```rs\n    DB_URL: postgres://username:password@localhost:5433/to_do\n    ```", "```rs\n    SECRET_KEY: secret\n    ```", "```rs\n    EXPIRE_MINUTES: 120\n    ```", "```rs\n    REDIS_URL: redis://127.0.0.1/\n    ```", "```rs\n    use serde::{Deserialize, Serialize};\n    ```", "```rs\n    use crate::config::Config;\n    ```", "```rs\n    #[derive(Serialize, Deserialize, Debug)]\n    ```", "```rs\n    pub struct Counter {\n    ```", "```rs\n        pub count: i32\n    ```", "```rs\n    }\n    ```", "```rs\n    impl Counter {\n    ```", "```rs\n        fn get_redis_url() -> String {\n    ```", "```rs\n            . . .\n    ```", "```rs\n        }\n    ```", "```rs\n        pub fn save(self) {\n    ```", "```rs\n            . . .\n    ```", "```rs\n        }\n    ```", "```rs\n        pub fn load() -> Counter {\n    ```", "```rs\n            . . .\n    ```", "```rs\n        }\n    ```", "```rs\n    }\n    ```", "```rs\n    fn get_redis_url() -> String {\n    ```", "```rs\n        let config = Config::new();\n    ```", "```rs\n        config.map.get(\"REDIS_URL\")\n    ```", "```rs\n                  .unwrap().as_str()\n    ```", "```rs\n                  .unwrap().to_owned()\n    ```", "```rs\n    }\n    ```", "```rs\n    pub fn save(self) -> Result<(), redis::RedisError> {\n    ```", "```rs\n        let serialized = serde_yaml::to_vec(&self).unwrap();\n    ```", "```rs\n        let client = match redis::Client::open(\n    ```", "```rs\n                         Counter::get_redis_url()) {\n    ```", "```rs\n            Ok(client) => client,\n    ```", "```rs\n            Err(error) => return Err(error)\n    ```", "```rs\n        };\n    ```", "```rs\n        let mut con = match client.get_connection() {\n    ```", "```rs\n            Ok(con) => con,\n    ```", "```rs\n            Err(error) => return Err(error)\n    ```", "```rs\n        };\n    ```", "```rs\n        match redis::cmd(\"SET\").arg(\"COUNTER\")\n    ```", "```rs\n                               .arg(serialized)\n    ```", "```rs\n                               .query::<Vec<u8>>(&mut con) {\n    ```", "```rs\n            Ok(_) => Ok(()),\n    ```", "```rs\n            Err(error) => Err(error)\n    ```", "```rs\n        }\n    ```", "```rs\n    }\n    ```", "```rs\n    pub fn load() -> Result<Counter, redis::RedisError> {\n    ```", "```rs\n        let client = match redis::Client::open(\n    ```", "```rs\n                         Counter::get_redis_url()){\n    ```", "```rs\n            Ok(client) => client,\n    ```", "```rs\n            Err(error) => return Err(error)\n    ```", "```rs\n        };\n    ```", "```rs\n        let mut con = match client.get_connection() {\n    ```", "```rs\n            Ok(con) => con,\n    ```", "```rs\n            Err(error) => return Err(error)\n    ```", "```rs\n        };\n    ```", "```rs\n        let byte_data: Vec<u8> = match redis::cmd(\"GET\")\n    ```", "```rs\n                                     .arg(\"COUNTER\")\n    ```", "```rs\n                                     .query(&mut con) {\n    ```", "```rs\n            Ok(data) => data,\n    ```", "```rs\n            Err(error) => return Err(error)\n    ```", "```rs\n        };\n    ```", "```rs\n        Ok(serde_yaml::from_slice(&byte_data).unwrap())\n    ```", "```rs\n    }\n    ```", "```rs\n    . . .\n    ```", "```rs\n    mod counter;\n    ```", "```rs\n    . . .\n    ```", "```rs\n    #[actix_web::main]\n    ```", "```rs\n    async fn main() -> std::io::Result<()> {\n    ```", "```rs\n        . . .\n    ```", "```rs\n        let site_counter = counter::Counter{count: 0};\n    ```", "```rs\n        site_counter.save();\n    ```", "```rs\n        HttpServer::new(|| {\n    ```", "```rs\n            . . .\n    ```", "```rs\n            let app = App::new()\n    ```", "```rs\n                .wrap_fn(|req, srv|{\n    ```", "```rs\n                    let passed: bool;\n    ```", "```rs\n                    let mut site_counter = counter::\n    ```", "```rs\n                                           Counter::load()\n    ```", "```rs\n                                           .unwrap();\n    ```", "```rs\n                    site_counter.count += 1;\n    ```", "```rs\n                    println!(\"{:?}\", &site_counter);\n    ```", "```rs\n                    site_counter.save();\n    ```", "```rs\n                    . . .\n    ```", "```rs\nCounter { count: 1 }\nCounter { count: 2 }\nCounter { count: 3 }\nCounter { count: 4 }\n```", "```rs\n[dependencies]\n. . .\nenv_logger = \"0.9.0\"\n```", "```rs\nuse actix_web::{. . ., middleware::Logger};\n```", "```rs\n. . .\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    . . .\n    env_logger::init_from_env(env_logger::Env::new()\n                              .default_filter_or(\"info\"));\n. . .\n```", "```rs\n. . .\n        async move {\n            let result = end_result.await?;\n            Ok(result)\n        }\n}).configure(views::views_factory).wrap(cors)\n    .wrap(Logger::new(\"%a %{User-Agent}i %r %s %D\"));\nreturn app\n. . .\n```", "```rs\n[2022-05-25T17:22:32Z INFO  actix_server::builder] Starting 8 workers\n[2022-05-25T17:22:32Z INFO  actix_server::server] Actix runtime found; starting in Actix runtime\n```", "```rs\n[2022-05-25T17:14:56Z INFO  actix_web::middleware::logger]\n127.0.0.1 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)\nAppleWebKit/537.36 (KHTML, like Gecko)\nChrome/101.0.4951.64 Safari/537.36\nGET /v1/item/get HTTP/1.1 401 9.466000\n```", "```rs\nGET /v1/item/get HTTP/1.1 401 9.466000\nOPTIONS /v1/auth/login HTTP/1.1 200 0.254000\nPOST /v1/auth/login HTTP/1.1 200 1405.585000\nOPTIONS /v1/item/get HTTP/1.1 200 0.082000\nGET /v1/item/get HTTP/1.1 200 15.470000\n```", "```rs\nOPTIONS /v1/item/get HTTP/1.1 200 0.251000\nOPTIONS /v1/item/get HTTP/1.1 200 0.367000\nGET /v1/item/get HTTP/1.1 200 88.317000\nGET /v1/item/get HTTP/1.1 200 9.523000\n```", "```rs\ngetItems() {\n  . . .\n  if (difference <= 120) {\n      . . .\n  }\n  else {\n      axios.get(\"http://127.0.0.1:8000/v1/item/get\",\n          {headers: {\"token\": localStorage\n                      .getItem(\"token\")}}).then(response => {\n              . . .\n              })\n          }).catch(error => {\n          if (error.response.status === 401) {\n              this.logout();\n          }\n      });\n  }\n}\n```", "```rs\nlet cachedData = Date.parse(localStorage\n                            .getItem(\"item-cache-date\"));\nlet now = new Date();\nlet difference = Math.round((now - cachedData) / (1000));\n```", "```rs\nlet pendingItems =\n    JSON.parse(localStorage.getItem(\"item-cache-data-pending\"));\nlet doneItems =\n    JSON.parse(localStorage.getItem(\"item-cache-data-\n                                     done\"));\nlet pendingItemsCount = pendingItems.length;\nlet doneItemsCount = doneItems.length;\nthis.setState({\n  \"pending_items\": this.processItemValues(pendingItems),\n  \"done_items\": this.processItemValues(doneItems),\n  \"pending_items_count\": pendingItemsCount,\n  \"done_items_count\": doneItemsCount\n})\n```", "```rs\nlet pending_items = response.data[\"pending_items\"]\nlet done_items = response.data[\"done_items\"]\nlocalStorage.setItem(\"item-cache-date\", new Date());\nlocalStorage.setItem(\"item-cache-data-pending\",\n                      JSON.stringify(pending_items));\nlocalStorage.setItem(\"item-cache-data-done\",\n                      JSON.stringify(done_items));\nthis.setState({\n  \"pending_items\": this.processItemValues(pending_items),\n  \"done_items\": this.processItemValues(done_items),\n  \"pending_items_count\":\n      response.data[\"pending_item_count\"],\n  \"done_items_count\": response.data[\"done_item_count\"]\n})\n```", "```rs\nhandleReturnedState = (response) => {\n  let pending_items = response.data[\"pending_items\"]\n  let done_items = response.data[\"done_items\"]\n  localStorage.setItem(\"item-cache-date\", new Date());\n  localStorage.setItem(\"item-cache-data-pending\",\n                        JSON.stringify(pending_items));\n  localStorage.setItem(\"item-cache-data-done\",\n                        JSON.stringify(done_items));\n  this.setState({\n     \"pending_items\":this.processItemValues(pending_items),\n     \"done_items\": this.processItemValues(done_items),\n     \"pending_items_count\":response\n         .data[\"pending_item_count\"],\n      \"done_items_count\": response.data[\"done_item_count\"]\n  })\n}\n```", "```rs\npub async fn logout() -> HttpResponse {\n    HttpResponse::Ok()\n        .content_type(\"text/html; charset=utf-8\")\n        .body(. . .)\n}\n```", "```rs\n\"<html>\\\n<script>\\\n    localStorage.removeItem('user-token'); \\\n    localStorage.removeItem('item-cache-date'); \\\n    localStorage.removeItem('item-cache-data-pending'); \\\n    localStorage.removeItem('item-cache-data-done'); \\\n    window.location.replace(\n        document.location.origin);\\\n</script>\\\n</html>\"\n```"]