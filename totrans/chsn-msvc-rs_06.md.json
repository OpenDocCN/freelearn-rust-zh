["```rs\n{\"jsonrpc\": \"2.0\", \"method\": \"substring\", \"params\": [2, 6, \\\"string\\\"], \"id\": 1}\n```", "```rs\n{\"jsonrpc\": \"2.0\", \"result\": \"ring\", \"id\": 1}\n```", "```rs\nfailure = \"0.1\"\nJSON-RPC = { git = \"https://github.com/apoelstra/rust-JSON-RPC\" }\njsonrpc-http-server = { git = \"https://github.com/paritytech/JSON-RPC\" }\nlog = \"0.4\"\nenv_logger = \"0.6\"\nserde = \"1.0\"\nserde_derive = \"1.0\"\n```", "```rs\nuse failure::Error;\nuse JSON-RPC::client::Client;\nuse JSON-RPC::error::Error as ClientError;\nuse JSON-RPC_http_server::ServerBuilder;\nuse JSON-RPC_http_server::JSON-RPC_core::{IoHandler, Error as ServerError, Value};\nuse log::{debug, error, trace};\nuse serde::Deserialize;\nuse std::env;\nuse std::fmt;\nuse std::net::SocketAddr;\nuse std::sync::Mutex;\nuse std::sync::mpsc::{channel, Sender};\nuse std::thread;\n```", "```rs\nconst START_ROLL_CALL: &str = \"start_roll_call\";\nconst MARK_ITSELF: &str = \"mark_itself\";\n```", "```rs\nstruct Remote {\n    client: Client,\n}\n```", "```rs\nimpl Remote {\n    fn new(addr: SocketAddr) -> Self {\n        let url = format!(\"http://{}\", addr);\n        let client = Client::new(url, None, None);\n        Self {\n            client\n        }\n    }\n}\n```", "```rs\nfn call_method<T>(&self, meth: &str, args: &[Value]) -> Result<T, ClientError>\nwhere\n    T: for <'de> Deserialize<'de>,\n{\n    let request = self.client.build_request(meth, args);\n    self.client.send_request(&request).and_then(|res| res.into_result::<T>())\n}\n```", "```rs\nfn start_roll_call(&self) -> Result<bool, ClientError> {\n    self.call_method(START_ROLL_CALL, &[])\n}\n```", "```rs\nfn mark_itself(&self) -> Result<bool, ClientError> {\n    self.call_method(\"mark_itself\", &[])\n}\n```", "```rs\nenum Action {\n    StartRollCall,\n    MarkItself,\n}\n```", "```rs\nfn spawn_worker() -> Result<Sender<Action>, Error> {\n    let (tx, rx) = channel();\n    let next: SocketAddr = env::var(\"NEXT\")?.parse()?;\n    thread::spawn(move || {\n        let remote = Remote::new(next);\n        let mut in_roll_call = false;\n        for action in rx.iter() {\n            match action {\n                Action::StartRollCall => {\n                    if !in_roll_call {\n                        if remote.start_roll_call().is_ok() {\n                            debug!(\"ON\");\n                            in_roll_call = true;\n                        }\n                    } else {\n                        if remote.mark_itself().is_ok() {\n                            debug!(\"OFF\");\n                            in_roll_call = false;\n                        }\n                    }\n                }\n                Action::MarkItself => {\n                    if in_roll_call {\n                        if remote.mark_itself().is_ok() {\n                            debug!(\"OFF\");\n                            in_roll_call = false;\n                        }\n                    } else {\n                        debug!(\"SKIP\");\n                    }\n                }\n            }\n        }\n    });\n    Ok(tx)\n}\n```", "```rs\nfn main() -> Result<(), Error> {\n    env_logger::init();\n    let tx = spawn_worker()?;\n    let addr: SocketAddr = env::var(\"ADDRESS\")?.parse()?;\n    let mut io = IoHandler::default();\n    let sender = Mutex::new(tx.clone());\n    io.add_method(START_ROLL_CALL, move |_| {\n        trace!(\"START_ROLL_CALL\");\n        let tx = sender\n            .lock()\n            .map_err(to_internal)?;\n        tx.send(Action::StartRollCall)\n            .map_err(to_internal)\n            .map(|_| Value::Bool(true))\n    });\n    let sender = Mutex::new(tx.clone());\n    io.add_method(MARK_ITSELF, move |_| {\n        trace!(\"MARK_ITSELF\");\n        let tx = sender\n            .lock()\n            .map_err(to_internal)?;\n        tx.send(Action::MarkItself)\n            .map_err(to_internal)\n            .map(|_| Value::Bool(true))\n    });\n    let server = ServerBuilder::new(io).start_http(&addr)?;\n    Ok(server.wait())\n}\n```", "```rs\nfn to_internal<E: fmt::Display>(err: E) -> ServerError {\n    error!(\"Error: {}\", err);\n    ServerError::internal_error()\n}\n```", "```rs\nRUST_LOG=JSON-RPC_ring=trace ADDRESS=127.0.0.1:4444 NEXT=127.0.0.1:5555 target/debug/JSON-RPC-ring\nRUST_LOG=JSON-RPC_ring=trace ADDRESS=127.0.0.1:5555 NEXT=127.0.0.1:6666 target/debug/JSON-RPC-ring\nRUST_LOG=JSON-RPC_ring=trace ADDRESS=127.0.0.1:6666 NEXT=127.0.0.1:4444 target/debug/JSON-RPC-ring\n```", "```rs\ncurl -H \"Content-Type: application/json\" --data-binary '{\"JSON-RPC\":\"2.0\",\"id\":\"curl\",\"method\":\"start_roll_call\",\"params\":[]}' http://127.0.0.1:4444\n```", "```rs\n[2019-01-14T10:45:29Z TRACE JSON-RPC_ring] START_ROLL_CALL\n[2019-01-14T10:45:29Z DEBUG JSON-RPC_ring] ON\n[2019-01-14T10:45:29Z TRACE JSON-RPC_ring] START_ROLL_CALL\n[2019-01-14T10:45:29Z DEBUG JSON-RPC_ring] OFF\n[2019-01-14T10:45:29Z TRACE JSON-RPC_ring] MARK_ITSELF\n[2019-01-14T10:45:29Z DEBUG JSON-RPC_ring] SKIP\n```", "```rs\n[2019-01-14T10:45:29Z TRACE JSON-RPC_ring] START_ROLL_CALL\n[2019-01-14T10:45:29Z DEBUG JSON-RPC_ring] ON\n[2019-01-14T10:45:29Z TRACE JSON-RPC_ring] MARK_ITSELF\n[2019-01-14T10:45:29Z DEBUG JSON-RPC_ring] OFF\n```", "```rs\n[2019-01-14T10:45:29Z TRACE JSON-RPC_ring] START_ROLL_CALL\n[2019-01-14T10:45:29Z DEBUG JSON-RPC_ring] ON\n[2019-01-14T10:45:29Z TRACE JSON-RPC_ring] MARK_ITSELF\n[2019-01-14T10:45:29Z DEBUG JSON-RPC_ring] OFF\n```", "```rs\n[package]\nname = \"grpc-ring\"\nversion = \"0.1.0\"\nauthors = [\"your email\"]\nedition = \"2018\"\n```", "```rs\n[dependencies]\nenv_logger = \"0.6\"\nfailure = \"0.1\"\ngrpc = { git = \"https://github.com/stepancheg/grpc-rust\" }\nlog = \"0.4\"\nprotobuf = \"2.2\"\n```", "```rs\n[build-dependencies]\nprotoc-rust-grpc = { git = \"https://github.com/stepancheg/grpc-rust\" }\n```", "```rs\n[[bin]]\nname = \"grpc-ring\"\npath = \"src/server.rs\"\ntest = false\n```", "```rs\n[[bin]]\nname = \"grpc-ring-client\"\npath = \"src/client.rs\"\ntest = false\n```", "```rs\nsyntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"rust.microservices.ring\";\noption java_outer_classname = \"RingProto\";\noption objc_class_prefix = \"RING\";\n\npackage ringproto;\n\nmessage Empty { }\n\nservice Ring {\n  rpc StartRollCall (Empty) returns (Empty);\n  rpc MarkItself (Empty) returns (Empty);\n}\n```", "```rs\nextern crate protoc_rust_grpc;\n\nfn main() {\n    protoc_rust_grpc::run(protoc_rust_grpc::Args {\n        out_dir: \"src\",\n        includes: &[],\n        input: &[\"ring.proto\"],\n        rust_protobuf: true,\n        ..Default::default()\n    }).expect(\"protoc-rust-grpc\");\n}\n```", "```rs\nmod ring;\nmod ring_grpc;\n```", "```rs\nuse crate::ring::Empty;\nuse crate::ring_grpc::{Ring, RingClient};\nuse grpc::{ClientConf, ClientStubExt, Error as GrpcError, RequestOptions};\nuse std::net::SocketAddr;\n```", "```rs\npub struct Remote {\n    client: RingClient,\n}\n```", "```rs\nimpl Remote {\n    pub fn new(addr: SocketAddr) -> Result<Self, GrpcError> {\n        let host = addr.ip().to_string();\n        let port = addr.port();\n        let conf = ClientConf::default();\n        let client = RingClient::new_plain(&host, port, conf)?;\n        Ok(Self {\n            client\n        })\n    }\n}\n```", "```rs\npub fn start_roll_call(&self) -> Result<Empty, GrpcError> {\n    self.client.start_roll_call(RequestOptions::new(), Empty::new())\n        .wait()\n        .map(|(_, value, _)| value)\n}\n```", "```rs\npub fn mark_itself(&self) -> Result<Empty, GrpcError> {\n    self.client.mark_itself(RequestOptions::new(), Empty::new())\n        .wait()\n        .map(|(_, value, _)| value)\n}\n```", "```rs\nuse failure::Error;\nuse grpc_ring::Remote;\nuse std::env;\n```", "```rs\nfn main() -> Result<(), Error> {\n    let next = env::var(\"NEXT\")?.parse()?;\n    let remote = Remote::new(next)?;\n    remote.start_roll_call()?;\n    Ok(())\n}\n```", "```rs\nmod ring;\nmod ring_grpc;\n```", "```rs\nuse crate::ring::Empty;\nuse crate::ring_grpc::{Ring, RingServer};\nuse failure::Error;\nuse grpc::{Error as GrpcError, ServerBuilder, SingleResponse, RequestOptions};\nuse grpc_ring::Remote;\nuse log::{debug, trace};\nuse std::env;\nuse std::net::SocketAddr;\nuse std::sync::Mutex;\nuse std::sync::mpsc::{channel, Receiver, Sender};\n```", "```rs\nstruct RingImpl {\n    sender: Mutex<Sender<Action>>,\n}\n```", "```rs\nimpl RingImpl {\n    fn new(sender: Sender<Action>) -> Self {\n        Self {\n            sender: Mutex::new(sender),\n        }\n    }\n}\n```", "```rs\nfn send_action(&self, action: Action) -> SingleResponse<Empty> {\n    let tx = try_or_response!(self.sender.lock());\n    try_or_response!(tx.send(action));\n    let result = Empty::new();\n    SingleResponse::completed(result)\n}\n```", "```rs\nmacro_rules! try_or_response {\n    ($x:expr) => {{\n        match $x {\n            Ok(value) => {\n                value\n            }\n            Err(err) => {\n                let error = GrpcError::Panic(err.to_string());\n                return SingleResponse::err(error);\n            }\n        }\n    }};\n}\n```", "```rs\nimpl Ring for RingImpl {\n    fn start_roll_call(&self, _: RequestOptions, _: Empty) -> SingleResponse<Empty> {\n        trace!(\"START_ROLL_CALL\");\n        self.send_action(Action::StartRollCall)\n    }\n\n    fn mark_itself(&self, _: RequestOptions, _: Empty) -> SingleResponse<Empty> {\n        trace!(\"MARK_ITSELF\");\n        self.send_action(Action::MarkItself)\n    }\n}\n```", "```rs\nfn main() -> Result<(), Error> {\n    env_logger::init();\n    let (tx, rx) = channel();\n    let addr: SocketAddr = env::var(\"ADDRESS\")?.parse()?;\n    let mut server = ServerBuilder::new_plain();\n    server.http.set_addr(addr)?;\n    let ring = RingImpl::new(tx);\n    server.add_service(RingServer::new_service_def(ring));\n    server.http.set_cpu_pool_threads(4);\n    let _server = server.build()?;\n\n    worker_loop(rx)\n}\n```", "```rs\nfn worker_loop(receiver: Receiver<Action>) -> Result<(), Error> {\n    let next = env::var(\"NEXT\")?.parse()?;\n    let remote = Remote::new(next)?;\n    let mut in_roll_call = false;\n    for action in receiver.iter() {\n        match action { /* Action variants here */ }\n    }\n    Ok(())\n}\n```", "```rs\nRUST_LOG=grpc_ring=trace ADDRESS=127.0.0.1:4444 NEXT=127.0.0.1:5555 target/debug/grpc-ring\nRUST_LOG=grpc_ring=trace ADDRESS=127.0.0.1:5555 NEXT=127.0.0.1:6666 target/debug/grpc-ring\nRUST_LOG=grpc_ring=trace ADDRESS=127.0.0.1:6666 NEXT=127.0.0.1:4444 target/debug/grpc-ring\n```", "```rs\nNEXT=127.0.0.1:4444 target/debug/grpc-ring-client\n```"]