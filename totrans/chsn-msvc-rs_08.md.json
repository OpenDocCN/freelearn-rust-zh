["```rs\n[dependencies]\nclap = \"2.32\"\ndiesel = { version = \"^1.1.0\", features = [\"sqlite\", \"r2d2\"] }\nfailure = \"0.1\"\nr2d2 = \"0.8\"\nserde = \"1.0\"\nserde_derive = \"1.0\"\nuuid = { version = \"0.5\", features = [\"serde\", \"v4\"] }\n```", "```rs\ncargo install diesel_cli\n```", "```rs\ncargo install diesel_cli --no-default-features --features \"sqlite\"\n```", "```rs\ndiesel setup\n```", "```rs\ndiesel migration generate <name>\n```", "```rs\nmigrations/\n└── 2018-11-22-192300_create_tables/\n    ├── up.sql\n    └── down.sql\n```", "```rs\nCREATE TABLE users (\n   id TEXT PRIMARY KEY NOT NULL,\n   name TEXT NOT NULL,\n   email TEXT NOT NULL\n );\n```", "```rs\nDROP TABLE users;\n```", "```rs\nDATABASE_URL=test.db diesel migration run\n```", "```rs\ntable! {\n    users (id) {\n        id -> Text,\n        name -> Text,\n        email -> Text,\n    }\n}\n```", "```rs\n# For documentation on how to configure this file,\n# see diesel.rs/guides/configuring-diesel-cli\n[print_schema]\nfile = \"src/schema.rs\"\n```", "```rs\nuse serde_derive::Serialize;\nuse super::schema::users;\n\n#[derive(Debug, Serialize, Queryable)]\npub struct User {\n    pub id: String,\n    pub name: String,\n    pub email: String,\n}\n\n#[derive(Insertable)]\n#[table_name = \"users\"]\npub struct NewUser<'a> {\n    pub id: &'a str,\n    pub name: &'a str,\n    pub email: &'a str,\n}\n```", "```rs\nextern crate clap;\n#[macro_use]\nextern crate diesel;\nextern crate failure;\nextern crate serde_derive;\n\nuse clap::{\n    crate_authors, crate_description, crate_name, crate_version,\n    App, AppSettings, Arg, SubCommand,\n};\nuse diesel::prelude::*;\nuse diesel::r2d2::ConnectionManager;\nuse failure::Error;\n\npub mod models;\npub mod schema;\n```", "```rs\nlet matches = App::new(crate_name!())\n    .version(crate_version!())\n    .author(crate_authors!())\n    .about(crate_description!())\n    .setting(AppSettings::SubcommandRequired)\n    .arg(\n        Arg::with_name(\"database\")\n        .short(\"d\")\n        .long(\"db\")\n        .value_name(\"FILE\")\n        .help(\"Sets a file name of a database\")\n        .takes_value(true),\n        )\n    .subcommand(SubCommand::with_name(CMD_ADD).about(\"add user to the table\")\n                .arg(Arg::with_name(\"NAME\")\n                     .help(\"Sets the name of a user\")\n                     .required(true)\n                     .index(1))\n                .arg(Arg::with_name(\"EMAIL\")\n                     .help(\"Sets the email of a user\")\n                     .required(true)\n                     .index(2)))\n    .subcommand(SubCommand::with_name(CMD_LIST).about(\"prints a list with users\"))\n    .get_matches();\n```", "```rs\nlet path = matches.value_of(\"database\")\n     .unwrap_or(\"test.db\");\n let manager = ConnectionManager::<SqliteConnection>::new(path);\n let pool = r2d2::Pool::new(manager)?;\n```", "```rs\nuse self::schema::users::dsl::*;\n```", "```rs\n(CMD_ADD, Some(matches)) => {\n    let conn = pool.get()?;\n    let name = matches.value_of(\"NAME\").unwrap();\n    let email = matches.value_of(\"EMAIL\").unwrap();\n    let uuid = format!(\"{}\", uuid::Uuid::new_v4());\n    let new_user = models::NewUser {\n        id: &uuid,\n        name: &name,\n        email: &email,\n    };\n    diesel::insert_into(schema::users::table)\n        .values(&new_user)\n        .execute(&conn)?;\n}\n```", "```rs\npub use super::columns::id;\npub use super::columns::name;\npub use super::columns::email;\npub use super::table as users;\n```", "```rs\n(CMD_LIST, _) => {\n    use self::schema::users::dsl::*;\n    let conn = pool.get()?;\n    let mut items = users\n        .load::<models::User>(&conn)?;\n    for user in items {\n        println!(\"{:?}\", user);\n    }\n}\n```", "```rs\nlet mut items = users\n    .filter(email.like(\"%@example.com\"))\n    .limit(10)\n    .load::<models::User>(&conn)?;\n```", "```rs\ncargo run -- add user1 user1@example.com\ncargo run -- add user2 user2@example.com\ncargo run -- add userx userx@xample.com\n```", "```rs\ncargo run -- list\nUser { id: \"a9ec3bae-c8c6-4580-97e1-db8f988f10f8\", name: \"user1\", email: \"user1@example.com\" }\nUser { id: \"7f710d18-aea5-46f9-913c-b60d4e4529c9\", name: \"user2\", email: \"user2@example.com\" }\n```", "```rs\ncargo new --lib chat\ncd chat\ndiesel setup\ndiesel migration generate create_users\ndiesel migration generate create_channels\ndiesel migration generate create_memberships\ndiesel migration generate create_messages\n```", "```rs\n00000000000000_diesel_initial_setup\n2019-01-06-192329_create_users\n2019-01-06-192333_create_channels\n2019-01-06-192338_create_memberships\n2019-01-06-192344_create_messages\n```", "```rs\nCREATE OR REPLACE FUNCTION diesel_manage_updated_at(_tbl regclass) RETURNS VOID AS $$\nBEGIN\n    EXECUTE format('CREATE TRIGGER set_updated_at BEFORE UPDATE ON %s\n                    FOR EACH ROW EXECUTE PROCEDURE diesel_set_updated_at()', _tbl);\nEND;\n$$ LANGUAGE plpgsql;\n```", "```rs\nCREATE OR REPLACE FUNCTION diesel_set_updated_at() RETURNS trigger AS $$\nBEGIN\n    IF (\n        NEW IS DISTINCT FROM OLD AND\n        NEW.updated_at IS NOT DISTINCT FROM OLD.updated_at\n    ) THEN\n        NEW.updated_at := current_timestamp;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n```", "```rs\nDROP FUNCTION IF EXISTS diesel_manage_updated_at(_tbl regclass);\nDROP FUNCTION IF EXISTS diesel_set_updated_at();\n```", "```rs\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email TEXT NOT NULL UNIQUE\n);\n```", "```rs\nDROP TABLE users;\n```", "```rs\nCREATE TABLE channels (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER NOT NULL REFERENCES users,\n  title TEXT NOT NULL,\n  is_public BOOL NOT NULL,\n  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nSELECT diesel_manage_updated_at('channels');\n```", "```rs\nDROP TABLE channels;\n```", "```rs\nCREATE TABLE memberships (\n  id SERIAL PRIMARY KEY,\n  channel_id INTEGER NOT NULL REFERENCES channels,\n  user_id INTEGER NOT NULL REFERENCES users\n);\n```", "```rs\nDROP TABLE memberships;\n```", "```rs\nCREATE TABLE messages (\n  id SERIAL PRIMARY KEY,\n  timestamp TIMESTAMP NOT NULL,\n  channel_id INTEGER NOT NULL REFERENCES channels,\n  user_id INTEGER NOT NULL REFERENCES users,\n  text TEXT NOT NULL\n);\n```", "```rs\nDROP TABLE messages;\n```", "```rs\ntable! {\n    users (id) {\n        id -> Int4,\n        email -> Text,\n    }\n}\n```", "```rs\ncargo rustc -- -Z unstable-options --pretty=expanded\n```", "```rs\ntable! {\n    channels (id) {\n        id -> Int4,\n        user_id -> Int4,\n        title -> Text,\n        is_public -> Bool,\n        created_at -> Timestamp,\n        updated_at -> Timestamp,\n    }\n}\n```", "```rs\ntable! {\n    memberships (id) {\n        id -> Int4,\n        channel_id -> Int4,\n        user_id -> Int4,\n    }\n}\n```", "```rs\ntable! {\n    messages (id) {\n        id -> Int4,\n        timestamp -> Timestamp,\n        channel_id -> Int4,\n        user_id -> Int4,\n        text -> Text,\n    }\n}\n```", "```rs\njoinable!(channels -> users (user_id));\njoinable!(memberships -> channels (channel_id));\njoinable!(memberships -> users (user_id));\njoinable!(messages -> channels (channel_id));\njoinable!(messages -> users (user_id));\n```", "```rs\nallow_tables_to_appear_in_same_query!(\n    channels,\n    memberships,\n    messages,\n    users,\n);\n```", "```rs\nuse chrono::NaiveDateTime;\nuse crate::schema::{users, channels, memberships, messages};\n```", "```rs\npub type Id = i32;\n```", "```rs\n#[derive(Debug, Identifiable, Queryable, Serialize, Deserialize)]\n#[table_name = \"users\"]\npub struct User {\n    pub id: Id,\n    pub email: String,\n}\n```", "```rs\n#[derive(Debug, Identifiable, Queryable, Associations, Serialize, Deserialize)]\n#[belongs_to(User)]\n#[table_name = \"channels\"]\npub struct Channel {\n    pub id: Id,\n    pub user_id: Id,\n    pub title: String,\n    pub is_public: bool,\n    pub created_at: NaiveDateTime,\n    pub updated_at: NaiveDateTime,\n}\n```", "```rs\n#[derive(Debug, Identifiable, Queryable, Associations, Serialize, Deserialize)]\n#[belongs_to(Channel)]\n#[belongs_to(User)]\n#[table_name = \"memberships\"]\npub struct Membership {\n    pub id: Id,\n    pub channel_id: Id,\n    pub user_id: Id,\n}\n```", "```rs\nlet memberships = Membership::belonging_to(&user)\n    .load::<Membership>(&conn);\n```", "```rs\n#[derive(Debug, Identifiable, Queryable, Associations, Serialize, Deserialize)]\n#[belongs_to(Channel)]\n#[belongs_to(User)]\n#[table_name = \"messages\"]\npub struct Message {\n    pub id: Id,\n    pub timestamp: NaiveDateTime,\n    pub channel_id: Id,\n    pub user_id: Id,\n    pub text: String,\n}\n```", "```rs\n#[macro_use]\nextern crate diesel;\n\nmod models;\nmod schema;\n```", "```rs\nuse diesel::{Connection, ExpressionMethods, OptionalExtension, PgConnection, QueryDsl, RunQueryDsl, insert_into};\nuse chrono::Utc;\nuse failure::{Error, format_err};\nuse self::models::{Channel, Id, Membership, Message, User};\nuse self::schema::{channels, memberships, messages, users};\nuse std::env;\n```", "```rs\npub struct Api {\n    conn: PgConnection,\n}\n```", "```rs\nimpl Api {\n    pub fn connect() -> Result<Self, Error> {\n        let database_url = env::var(\"DATABASE_URL\")\n            .unwrap_or(\"postgres://postgres@localhost:5432\".to_string());\n        let conn = PgConnection::establish(&database_url)?;\n        Ok(Self { conn })\n    }\n}\n```", "```rs\npub fn register_user(&self, email: &str) -> Result<User, Error> {\n    insert_into(users::table)\n        .values((\n                users::email.eq(email),\n                ))\n        .returning((\n                users::id,\n                users::email\n                ))\n        .get_result(&self.conn)\n        .map_err(Error::from)\n}\n```", "```rs\npub fn create_channel(&self, user_id: Id, title: &str, is_public: bool)\n    -> Result<Channel, Error>\n{\n    self.conn.transaction::<_, _, _>(|| {\n        let channel: Channel = insert_into(channels::table)\n            .values((\n                    channels::user_id.eq(user_id),\n                    channels::title.eq(title),\n                    channels::is_public.eq(is_public),\n                    ))\n            .returning((\n                    channels::id,\n                    channels::user_id,\n                    channels::title,\n                    channels::is_public,\n                    channels::created_at,\n                    channels::updated_at,\n                    ))\n            .get_result(&self.conn)\n            .map_err(Error::from)?;\n        self.add_member(channel.id, user_id)?;\n        Ok(channel)\n    })\n}\n```", "```rs\npub fn publish_channel(&self, channel_id: Id) -> Result<(), Error> {\n    let channel = channels::table\n        .filter(channels::id.eq(channel_id))\n        .select((\n                channels::id,\n                channels::user_id,\n                channels::title,\n                channels::is_public,\n                channels::created_at,\n                channels::updated_at,\n                ))\n        .first::<Channel>(&self.conn)\n        .optional()\n        .map_err(Error::from)?;\n    if let Some(channel) = channel {\n        diesel::update(&channel)\n            .set(channels::is_public.eq(true))\n            .execute(&self.conn)?;\n        Ok(())\n    } else {\n        Err(format_err!(\"channel not found\"))\n    }\n}\n```", "```rs\npub fn add_member(&self, channel_id: Id, user_id: Id)\n    -> Result<Membership, Error>\n{\n    insert_into(memberships::table)\n        .values((\n                memberships::channel_id.eq(channel_id),\n                memberships::user_id.eq(user_id),\n                ))\n        .returning((\n                memberships::id,\n                memberships::channel_id,\n                memberships::user_id,\n                ))\n        .get_result(&self.conn)\n        .map_err(Error::from)\n}\n```", "```rs\npub fn add_message(&self, channel_id: Id, user_id: Id, text: &str)\n    -> Result<Message, Error>\n{\n    let timestamp = Utc::now().naive_utc();\n    insert_into(messages::table)\n        .values((\n                messages::timestamp.eq(timestamp),\n                messages::channel_id.eq(channel_id),\n                messages::user_id.eq(user_id),\n                messages::text.eq(text),\n                ))\n        .returning((\n                messages::id,\n                messages::timestamp,\n                messages::channel_id,\n                messages::user_id,\n                messages::text,\n                ))\n        .get_result(&self.conn)\n        .map_err(Error::from)\n}\n```", "```rs\npub fn delete_message(&self, message_id: Id) -> Result<(), Error> {\n    diesel::delete(messages::table)\n        .filter(messages::id.eq(message_id))\n        .execute(&self.conn)?;\n    Ok(())\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::Api;\n\n    #[test]\n    fn create_users() {\n        let api = Api::connect().unwrap();\n        let user_1 = api.register_user(\"user_1@example.com\").unwrap();\n        let user_2 = api.register_user(\"user_2@example.com\").unwrap();\n        let channel = api.create_channel(user_1.id, \"My Channel\", false).unwrap();\n        api.publish_channel(channel.id).unwrap();\n        api.add_member(channel.id, user_2.id).unwrap();\n        let message = api.add_message(channel.id, user_1.id, \"Welcome!\").unwrap();\n        api.add_message(channel.id, user_2.id, \"Hi!\").unwrap();\n        api.delete_message(message.id).unwrap();\n    }\n}\n```", "```rs\nDATABASE_URL=postgres://postgres@localhost:5432 diesel migration run && cargo test\n```", "```rs\npostgres=# select * from messages;\n id | timestamp | channel_id | user_id | text \n----+----------------------------+------------+---------+------\n 2 | 2019-01-08 18:30:48.465001 | 1 | 2 | Hi!\n(1 row)\n```"]