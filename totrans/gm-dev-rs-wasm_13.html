<html><head></head><body>
		<div><h1 id="_idParaDest-151"><em class="italic"><a id="_idTextAnchor226"/>Chapter 10</em>: Continuous Deployment</h1>
			<p>The traditional way to publish a game is to create a main copy of the build and ship it off to manufacturing. This was frequently referred to as <strong class="bold">going gold</strong> inside and outside of the gaming industry, and it still is if you're making a AAA game that's being shipped to consoles and sold in stores. The process is time-consuming and extremely expensive; fortunately, we don't have to do it! Walk the Dog is a web-based game that we need to ship to a website. Since we're deploying to the web, we can use all the best practices of the web, including continuous deployment, where we'll deploy a build whenever we want directly from source control.</p>
			<p>In this chapter, we'll cover the following topics:</p>
			<ul>
				<li>Creating a <strong class="bold">Continuous Integration</strong>/<strong class="bold">Continuous Delivery</strong> (<strong class="bold">CI</strong>/<strong class="bold">CD</strong>) pipeline</li>
				<li>Deploying test and production builds</li>
			</ul>
			<p>When this chapter is complete, you'll be able to ship your game to the web! How else will you become rich and famous?</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor227"/>Technical requirements</h1>
			<p>In addition to a GitHub account, you'll need a Netlify account. Both of these have significant free tiers, so if cost becomes a problem, then congratulations! Your game took off! You'll also need to be familiar with Git. You don't need to be an expert, but you'll need to be able to create repositories and push them to GitHub. If Git is completely new to you, then the GitHub <em class="italic">Getting Started</em> guide is a good place to start: <a href="https://docs.github.com/en/get-started">https://docs.github.com/en/get-started</a>. The sample code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_10">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_10</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3DsfDsA">https://bit.ly/3DsfDsA</a></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor228"/>Creating a CI/CD pipeline</h1>
			<p>When you <a id="_idIndexMarker888"/>run <code>npm run build</code> locally, a release build is put inside the <code>dist</code> directory. Theoretically, you could take that directory and copy it to a server somewhere to deploy your application. This will work provided that the server knows about the <code>wasm</code> <code>MIME</code> type, but copying to a directory manually is a very old-fashioned way of deploying software. Nowadays, we automate the build and deploy on a server, along with additional code that's been checked into source control. It's significantly more complicated than the old-fashioned way, so why is it better?</p>
			<p>The practice of automating the build this way is often referred to as CD and its definition is pretty big. Take a look at the following quote from <a href="https://continuousdelivery.com">https://continuousdelivery.com</a>:</p>
			<p class="author-quote">Continuous Delivery is the ability to get changes of all types—including new features, configuration changes, bug fixes, and experiments—into production, or into the hands of users, safely and quickly in a sustainable way.</p>
			<p>You might read this and think that yes, copying from your machine's <code>dist</code> directory onto a server is exactly that, but it isn't. A few issues can happen when deploying manually. We've listed a few of them here:</p>
			<ul>
				<li>The documentation could be wrong or lacking, meaning only one person knows how to deploy.</li>
				<li>The deployed code might not be the same as the code in source control.</li>
				<li>Deployments might only work based on a local configuration, such as the version of <code>rustc</code> that exists on an individual's machine.</li>
			</ul>
			<p>There are many more reasons why you don't simply want to run <code>npm run build</code> locally and then copy/paste to a server. But when a team is small, it's very tempting to say, "I'll worry about it later." Instead of listening to that little voice, let's try to think about the qualities of a deployment that are safe and quick, as the definition says. We can start with the opposite of some of the preceding bullet points. If those are reasons why a manual deployment does not qualify as CD, then a process that does qualify would be able to do the following:</p>
			<ul>
				<li>Automate the process so that it is repeatable by everybody on the team.</li>
				<li>Always deploy from source control.</li>
				<li>Declare the configuration in source control, so it's never incorrect.</li>
			</ul>
			<p>There's a lot more to a proper CD process than the preceding list. In fact, a "perfect" CD is often more of a goal to be reached than an end state that you hit. Since we're a one-person band, we won't be hitting every single bullet point from the <em class="italic">Continuous Delivery</em> book (<a href="https://amzn.to/32bf9bt">https://amzn.to/32bf9bt</a>), but we will be making a <code>main</code>, it will deploy to a production site. For this, we'll use two technologies: GitHub Actions and Netlify.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">CI refers to the practice of frequently merging code into the primary branch (<code>main</code> in Git parlance) and <a id="_idIndexMarker890"/>running all the tests to ensure the code still works. CI/CD is a shorthand for combining the practices of integration and delivery, although it's a bit redundant since CD includes CI.</p>
			<p>GitHub Actions is a relatively new technology from GitHub. It is used for running tasks when branches are pushed to GitHub. It's well suited for running CI/CD because it's built right into the source control that we're already using and has a pretty good free tier. If you decide to use a different tool, such as Travis CI or GitLab CI/CD, you can use this implementation to guide how you would use those other tools. At this point, the similarities outnumber the differences.</p>
			<p>After running CI on GitHub Actions, we'll deploy to Netlify. You might be wondering why we're using Netlify if our stated goal is to reduce the number of new technologies, and that's because, while we can deploy directly to GitHub Pages, that won't support creating test builds. In my opinion, an important part of a good CD process is the ability to create production-like builds that can be experimented on and tried out. Netlify will provide that out of the box. If your team has grown from beyond one person, you'll be able to try out the game as part of the process of reviewing code in a PR. Also, Netlify is set up to work with Wasm out of the box, so that's handy.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In GitHub parlance, a PR is a branch that you wish to merge into the <code>main</code> branch. You create a PR and ask for a review. This branch can run other checks before being allowed to be merged into the <code>main</code> branch. Other tools, such as GitLab, call these <strong class="bold">merge requests</strong> (<strong class="bold">MRs</strong>). I tend<a id="_idIndexMarker891"/> to stick to the term PR because it's what I'm used to.</p>
			<p>Our pipeline will be fairly simple. On every push to a PR branch, we'll check out the code, build and run the tests, then push to Netlify. If the build is a branch build, you'll get a temporary URL to test out that build. If the push is to <code>main</code>, then it will deploy a release build. In the future, you might want a little more rigor around production deployments, such as tagging releases with release notes, but this should be fine to get us started.</p>
			<p>The first step is to make sure the build machine is using the same version of Rust that we're using locally. The <code>rustup</code> tool allows you to install multiple versions of the Rust compiler along with multiple toolchains, and you'll want to make sure that everybody on the team and along with CI is <a id="_idIndexMarker892"/>using the same version of Rust. Fortunately, <code>rustup</code> provides several different ways of doing this. We'll use the <code>toolchain</code> file, which is a file that specifies the toolchain for the current project. In addition to ensuring any machine that builds this crate will use the same version of Rust, it also documents the version of Rust used for development. Every Rust project should have one.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">At the time of writing this chapter, I discovered that I had made a mistake in the first draft of <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>. I hadn't documented the Rust version being used or ensured that the <code>wasm32-unknown-unknown</code> toolchain was installed. These are the exact kinds of errors that come up when you try to set up a CI build, because you've forgotten all of those early assumptions, and it's also one of the reasons why it's important to have a CI build. Sadly, you can always forget documentation, but the build machine can't lie. This is why I frequently set up CI at the beginning of a project.</p>
			<p>The <code>toolchain</code> file is named <code>rust-toolchain.toml</code> and is kept at the root directory of the crate. We can create one that looks like this:</p>
			<pre>[toolchain]
channel = "1.57.0"
targets = ["wasm32-unknown-unknown"]</pre>
			<p>The preceding toolchain says we'll use version <code>1.57.0</code> of the Rust compiler and the <code>wasm32-unknown-unknown</code> target, so we can be sure we'll be able to compile to WebAssembly. Now that we've ensured the version of Rust we're using, we can start setting up a <a id="_idIndexMarker893"/>CI/CD pipeline in GitHub Actions. You're welcome to try newer versions, but this has been tested using <code>1.57.0</code>.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor229"/>GitHub Actions </h2>
			<p>Like many <a id="_idIndexMarker894"/>other CI/CD tools, GitHub Actions is defined by <a id="_idIndexMarker895"/>the configuration files in your source repository. When you create the first configuration file, called a <em class="italic">workflow</em> in Actions, it will get picked up by GitHub, which will then start a <em class="italic">runner</em>. You can see the output in the <strong class="bold">Actions</strong> tab of a GitHub repository. The following screenshot shows what the tab looked like for me while writing this chapter:</p>
			<div><div><img alt="Figure 10.1 – A green build" src="img/Figure_10.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – A green build</p>
			<p>This is an example workflow being run on GitHub, where I have updated the version of the deployment to use the LTS version of Node.js. It's a little unfortunate that you have to go to the <strong class="bold">Actions</strong> tab to see the result of your <em class="italic">workflows</em>, but I suppose marketing won out. It's also a little confusing to hear the terms <em class="italic">workflow</em> and <em class="italic">pipeline</em> thrown around. A <em class="italic">workflow</em> is a specific GitHub Actions term referring to a series of steps run on its infrastructure via the configuration we'll build next. A <em class="italic">pipeline</em> is a CD term referring to a series of steps that are needed to deploy software. So, I can have a pipeline made up of one or more workflows if I'm running it on GitHub Actions and using their terminology. This pipeline will be made up of one workflow, so you can use them interchangeably.</p>
			<p>To begin building our pipeline, we'll need to ensure we have a GitHub repository for Walk the Dog. You probably already have one, but if you don't, you have two options to choose from:</p>
			<ul>
				<li>Create a new repository from your existing code.</li>
				<li>Fork the example code.</li>
			</ul>
			<p>You can do either, although it would be a shame if the code you've been writing all along didn't exist in a repository somewhere. If you do fork from my repository, then make sure you fork from the <a href="B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203"><em class="italic">Chapter 9</em></a><em class="italic">, Testing, Debugging, and Performance</em> sample code at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9</a>. Otherwise, all the work will be done for you. In either case, from now<a id="_idIndexMarker896"/> on, I'll assume you have your code in a repository <a id="_idIndexMarker897"/>on GitHub.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If, at any point, you find yourself confused, you can cross-check the GitHub Actions documentation at <a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions</a>. We'll try to keep the workflow simple, so you won't need to be an Actions expert.</p>
			<p>We can start setting up a workflow with a kind of "Hello World" for GitHub Actions. The workflow will simply check the code, and it should turn green almost immediately after pushing. Create a file, named <code>.github/workflows/build.yml</code>, and add the following YAML to it:</p>
			<pre>on: [push]
name: build
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2</pre>
			<p><strong class="bold">YAML</strong> (<strong class="bold">Yet Another Markup Language</strong>) is the markup language of many CI/CD pipelines. If you've<a id="_idIndexMarker898"/> never seen it before, note that it is whitespace sensitive. This means that, sometimes, if you copy/paste it from one file to another or from a book into code, it might not be syntactically correct. Here, I'm using two spaces per tab, which is the standard format, and YAML does not allow tab characters.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">YAML is mostly self-explanatory, and it's also not the important takeaway from this chapter. So, if there's some YAML syntax that confuses you, it's probably not worth worrying about. But just in case, there is a pretty good YAML cheat sheet at <a href="https://quickref.me/yaml">https://quickref.me/yaml</a>.</p>
			<p>For the most part, you<a id="_idIndexMarker899"/> can read YAML as a list of key-value pairs. This<a id="_idIndexMarker900"/> workflow starts with the <code>on</code> key, which will run this workflow on every <code>push</code> event. It's an array, so you can set up workflows for multiple events, but we won't be doing that. The next key, <code>name</code>, gives the workflow a name. Then, we add the <code>jobs</code> key, which will only have one job. In our case, it is <code>build</code>. We specify that our job runs on <code>ubuntu-latest</code> with the <code>runs-on</code> key. Then, finally, we define its list of steps. This job currently only has one step, <code>uses: actions/checkout@v2</code>, and that's worth explaining in more depth. Each step can either be a shell command or—you guessed it—an <em class="italic">action</em>. You can create your own actions, but most actions are created by the GitHub community; they can be found in the GitHub Actions marketplace.</p>
			<p>You might be able to guess that <code>actions/checkout@v2</code> checks the code, and you'd be right. But you're probably wondering where that comes from and how you were supposed to know about it. That's where the Actions marketplace comes in, which can be found at <a href="https://github.com/marketplace?type=actions">https://github.com/marketplace?type=actions</a>:</p>
			<div><div><img alt="Figure 10.2 – The Actions marketplace" src="img/Figure_10.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – The Actions marketplace</p>
			<p>Your <a id="_idIndexMarker901"/>workflow is<a id="_idIndexMarker902"/> made up of a series of steps run in order, most of which are found on the GitHub marketplace. Don't let the name "marketplace" fool you; actions don't cost money. They are open source projects and free as in beer. Let's dig into the first action we'll be using (<a href="https://github.com/marketplace/actions/checkout">https://github.com/marketplace/actions/checkout</a>):</p>
			<div><div><img alt="Figure 10.3 – Checkout&#13;&#10;" src="img/Figure_10.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Checkout</p>
			<p>The <a id="_idIndexMarker903"/>checkout <a id="_idIndexMarker904"/>action can be found in almost every single workflow since it's pretty hard to do anything without checking out the code first. If you browse this page, you'll see there's full-featured documentation for the action, along with a big green button that says <strong class="bold">Use latest version</strong>. If you click on that button, a small snippet is presented to you, showing you how to integrate the action into your workflow:</p>
			<div><div><img alt="Figure 10.4 – Copy and paste me!&#13;&#10;" src="img/Figure_10.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Copy and paste me!</p>
			<p>These actions are the building blocks of workflows. Setting up a CI/CD pipeline in GitHub Actions means searching through the marketplace, adding actions to your workflow, and reading the docs. This<a id="_idIndexMarker905"/> is significantly easier than the tangle of Bash scripts that I used in the past, although<a id="_idIndexMarker906"/> don't worry, you can call trusty Bash scripts, too.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I want to emphasize that this isn't meant to be taken as an endorsement of GitHub Actions over any other CI/CD solution. Nowadays, there are so many great tools for this kind of work that it's hard to recommend one tool over another. I've used Travis CI and GitLab CI/CD quite a bit over the years, and they are also great. That said, GitHub Actions is also pretty great.</p>
			<p>If you commit this change and push it to a branch (do <em class="italic">not</em> use <code>main</code> for now) inside your repository, you can check the <strong class="bold">Actions</strong> tab to see the workflow running successfully, as shown in the following screenshot:</p>
			<div><div><img alt="Figure 10.5 – Checking out the code" src="img/Figure_10.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Checking out the code</p>
			<p>We have checked out the code, and now we need to build it on the GitHub <em class="italic">runner</em>. A runner is just a fancy name for a machine. To build Rust on your local machine, you need the <code>rustup</code> program with an installed compiler and toolchain. We could run a series of shell scripts; however, instead, we will look to see whether any Rust actions exist in the marketplace. I won't hold you in suspense—there's an entire library of Rust-related actions to be found at <a href="https://actions-rs.github.io/">https://actions-rs.github.io/</a>. It's a great collection, and it will make it <a id="_idIndexMarker907"/>easier<a id="_idIndexMarker908"/> to create our build. We'll add steps to do the following:</p>
			<ul>
				<li>Install a toolchain (<a href="https://actions-rs.github.io/#toolchain">https://actions-rs.github.io/#toolchain</a>).</li>
				<li>Install wasm-pack (<a href="https://actions-rs.github.io/#install">https://actions-rs.github.io/#install</a>).</li>
				<li>Run Clippy (<a href="https://actions-rs.github.io/#clippy-check">https://actions-rs.github.io/#clippy-check</a>).</li>
			</ul>
			<p>The preceding links will take you to the official documentation for each of the actions, all of which have been created and maintained by Nikita Kuznetsov (<a href="https://svartalf.info/">https://svartalf.info/</a>). Since each action is specified in YAML, it can use any keys it likes. Potentially, this means a lot of flags and configurations to document, but we'll stick to the straightforward flag.</p>
			<p>So, what are we waiting for? Let's add the step required to install a toolchain, as shown here:</p>
			<pre>steps:
  - uses: actions/checkout@v2
  <strong class="bold">- uses: actions-rs/toolchain@v1</strong>
     <strong class="bold">with:</strong>
       <strong class="bold">toolchain: 1.57.0</strong>
       <strong class="bold">target: wasm32-unknown-unknown</strong>
       <strong class="bold">override: true</strong>
       <strong class="bold">components: clippy</strong></pre>
			<p>I've left the checkout step in the sample for reference, but the code we've added starts with <code>- uses: actions-rs/toolchain@v1</code>. The <code>-</code> character is important—that's YAML syntax for an entry in a sequence. So, step 1 is the first <code>- uses: actions/checkout@v2</code> line. Step 2 begins with <code>uses: actions-rs/toolchain@v1</code>, which is the name of the action we are using. Note that the next line, <code>with:</code>, does not have a dash in front of it. That's because it's part of the same step, which is a YAML hash with the <code>uses:</code> and <code>hash:</code> keys. Those fields must line up because YAML is whitespace sensitive. If you're still confused by YAML, I recommend you do not think <a id="_idIndexMarker909"/>about it too much; it's really just a plain text markup<a id="_idIndexMarker910"/> format that works in the way it looks.</p>
			<p>In turn, the <code>with</code> key is set to another map with the keys of <code>toolchain</code>, <code>target</code>, <code>override</code>, and <code>components</code>. They set the <code>toolchain</code> (1.57.0) and <code>target</code> (wasm32-unknown-unknown) values, and make sure they install the <code>clippy</code> component. Finally, the <code>override: true</code> flag ensures that this version of Rust is the one in this directory.</p>
			<p>With this step, you've added the toolchain you need. However, if you try to run a build in the workflow, it will still fail because you haven't installed <code>wasm-pack</code> onto the build machine. You can add that step next, as follows:</p>
			<pre>- uses: actions-rs/install@v0.1
   with:
     crate: wasm-pack
     version: 0.9.1
     use-tool-cache: true</pre>
			<p>You're probably starting to see the pattern. A new step is started with the <code>-</code> character, and it <code>uses</code> an action. In this case, it is <code>actions-rs/install@v0.1</code>. It's parameters are the <code>wasm-pack</code> crate, and version 0.9.1. However, we also specify the important <code>use-tool-cache</code>, which will ensure that if that version of <code>wasm-pack</code> can use a pre-built binary, it will do so. This shaves several minutes off of your build, so use it whenever possible.</p>
			<p>So, we're ready to build WebAssembly, but there's one more thing to do before we start worrying about building Wasm, and that's running Clippy. When we ran it in <a href="B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203"><em class="italic">Chapter 9</em></a>, <em class="italic">Testing, Debugging, and Performance</em>, we did it once manually, but it's important to get this kind of linting into the build so that you catch those kinds of errors early. Typically, I install this kind of check even on my solo projects, because I forget to run it locally. We<a id="_idIndexMarker911"/> can add <a id="_idIndexMarker912"/>that step like this:</p>
			<pre>- name: Annotate commit with clippy warnings
   uses: actions-rs/clippy-check@v1
     with:
       token: ${{ secrets.GITHUB_TOKEN }}</pre>
			<p>In this case, I've left the <code>name</code> field, which was taken straight from the <a href="https://actions-rs.github.io/#clippy-check">https://actions-rs.github.io/#clippy-check</a> documentation. This is because that name will show up on the GitHub Actions UI when it runs, and I might forget what <code>clippy-check</code> is. The only parameter it needs is the <code>token</code> field, which is set to the magic <code>${{ secrets.GITHUB_TOKEN }}</code> field. That field will expand to your actual GitHub API token, which is automatically generated on each workflow run by GitHub Actions. That token is necessary because this action can actually annotate the commit with any warnings that were generated by Clippy, so it needs to be able to write to the repository. The following screenshot shows an example of this where I intentionally introduced a Clippy error:</p>
			<div><div><img alt="Figure 10.6 – A Clippy error in GitHub Actions" src="img/Figure_10.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – A Clippy error in GitHub Actions</p>
			<p>This error<a id="_idIndexMarker913"/> also <a id="_idIndexMarker914"/>shows up in the commit itself:</p>
			<div><div><img alt="Figure 10.7 – A Clippy error in the commit&#13;&#10;" src="img/Figure_10.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – A Clippy error in the commit</p>
			<p>This functionality is awesome, but don't introduce Clippy errors to show it off unless you're writing a book; otherwise, it's not safe. Now that we've checked the Rust code for idiomatic errors, it's time to build and run tests. Since this is a Wasm project, for that step, we're<a id="_idIndexMarker915"/><a id="_idTextAnchor230"/> going <a id="_idIndexMarker916"/>to need Node.js.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor231"/>Node.js and webpack</h2>
			<p>The <code>actions-rs</code> family <a id="_idIndexMarker917"/>of<a id="_idIndexMarker918"/> actions<a id="_idIndexMarker919"/> is for<a id="_idIndexMarker920"/> Rust code, hence the addition of <code>-rs</code> at the end of <code>actions</code>. So, we're going to need to look elsewhere to install Node.js. Fortunately, installing Node is so common that it's one of the default actions provided by GitHub. We can add another step to set up Node, as shown here:</p>
			<pre>- uses: actions/setup-node@v2
   with:
     node-version: '16.13.0'</pre>
			<p>Any of the actions provided by GitHub can be found in the <code>actions</code> repository, and this one is called <code>setup-node</code>. In this case, we only need one parameter, <code>node-version</code>, which I've set to the <code>setup-node</code> step. They look like the following:</p>
			<pre>- run: npm install
- run: npm test
- run: npm run build</pre>
			<p>Notice how none of these steps have a <code>uses</code> key—they just call <code>run</code>, which runs the command as<a id="_idIndexMarker921"/> written<a id="_idIndexMarker922"/> in the shell. Since <code>Node.js</code> is installed, you can safely assume <code>npm</code> is available, and install, test, and run the build as three more steps in your workflow. This is a great time to commit your workflow and give it a try.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Before committing and pushing your code, it can be helpful to run it through a YAML syntax validator. This won't ensure that it's valid for GitHub Actions, but it will at least ensure that it's valid YAML syntax and prevent wasted time pushing simple errors in indentation. <a href="https://onlineyamltools.com/validate-yaml">https://onlineyamltools.com/validate-yaml</a> is an example of a simple online one, and Visual Studio Code has a plugin for it at <a href="https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml">https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml</a>.</p>
			<p>This build might actually fail at <code>-run: npm test</code>, with the following error highlighted: </p>
			<pre>Error: Must specify at least one of `--node`, `--chrome`, `--firefox`, or `--safari`</pre>
			<p>In <a href="B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203"><em class="italic">Chapter 9</em></a>, <em class="italic">Testing, Debugging, and Performance</em>, we ran our browser-based tests with the <code>wasm-pack test --headless --chrome</code> command. The build script <a id="_idIndexMarker923"/>runs <code>npm test</code>, which corresponds to the test script in <a id="_idIndexMarker924"/>the <code>package.json</code> file that was created for us in <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>. If that filename doesn't sound familiar, that's because we haven't spent any time in it. Open it up, and you'll see the test entry, which should look like this:</p>
			<pre>{
  ...
  "scripts": {
    "build": "rimraf dist pkg &amp;&amp; webpack",
    "start": "rimraf dist pkg &amp;&amp; webpack-dev-server --open 
       -d --host 0.0.0.0",
    <strong class="bold">"test": "cargo test &amp;&amp; wasm-pack test --headless"</strong>
  },
...
} </pre>
			<p>In the<a id="_idIndexMarker925"/> preceding <a id="_idIndexMarker926"/>highlighted code, you can see that it runs <code>cargo test</code> and then <code>wasm-pack test --headless</code>, but without specifying a browser. There's our build error! You can fix that by adding <code>--chrome</code> to the list of parameters passed to <code>wasm-pack test</code> and pushing that up to GitHub.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It's possible that this code has been fixed in newer versions of the project skeleton, so you do not see this error. If that's the case, you're already finished—congratulations! It's still useful to understand what tasks are being run under the hood of <code>npm test</code>.</p>
			<p>At this point, you should have a build that takes about 4 minutes, which is a little longer than I'd like for a<a id="_idIndexMarker927"/> small project, but we'll leave optimizing the build to the<a id="_idIndexMarker928"/> DevOps team. You've completed the CI step of this section, and no<a id="_idTextAnchor232"/>w you can move on to the CD part.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor233"/>Deploying test and production builds</h1>
			<p>For<a id="_idIndexMarker929"/> deployments, we'll <a id="_idIndexMarker930"/>use Netlify, which is a cloud computing company that specializes in <code>main</code>, it will perform the production build. Production is defined loosely here, as we won't go in great depth into tasks such as getting a custom domain for your app or monitoring for errors, but it's the version of the app that will be publicly available.</p>
			<p>In order to deploy from GitHub to Netlify, we'll have to do some wiring so that GitHub has access to push to your Netlify account, and we have a site to push to. So, we're going to use the Netlify CLI to set up a site and prepare it for GitHub pushes. We're not going to use the built-in Netlify-GitHub connection that Netlify provides because it doesn't work with repositories unless you are an administrator on them. In this case, it's also more applicable if you are using other Git providers since the Netlify CLI will work with any of them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There's an argument to be made that we're not practicing CD here because we won't have our machine completely configured in a tool such as Ansible or Terraform. The Netlify configuration isn't disposable, so it's not CD or DevOps. That's true, but this is not a book about how to configure Netlify in code, so we're not going to concern ourselves with that here. We had to draw a line somewhere.</p>
			<p>The first step is to install the CLI itself, which can be installed with <code>npm install netlify-cli --save</code> running at the root directory. This will install <code>netlify-cli</code> locally, which is in the <code>node_modules</code> directory of this project, so it won't pollute your local environment. The <code>--save</code> flag automatically adds <code>netlify-cli</code> to the list of dependencies in <code>package.json</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you have trouble running the Netlify CLI, make sure you're using version <code>16.13.0</code> of Node.js or higher. There were issues with the earlier versions.</p>
			<p>After installing the Netlify CLI, you'll need to call <code>npm exec netlify login</code> to log in to your Netlify account. At the time of writing, <code>npm exec</code> is the way to ensure you're using the local copy of the <code>netlify</code> command, but you could also use <code>npx</code> or directly call the copy in <code>node_modules\.bin</code>. This will probably change again in the future, so it pays to Google it. The important part is that you probably don't want to install a global <a id="_idIndexMarker931"/>version of the <code>netlify</code> command unless you know what you're <a id="_idIndexMarker932"/>doing.</p>
			<p>When you call <code>npm exec netlify login</code>, it will take you through the web browser to complete the login process. Then, you'll want to call <code>npm exec netlify init -- --manual</code>. The addition of <code>--</code> in the middle is important so that <code>--manual</code> is passed through to the <code>netlify</code> command and not to <code>npm exec</code>. You will want to choose <code>rust-games-webassembly</code>. Your build command is <code>npm run build</code>, and the directory to deploy is <code>dist</code>. You can accept the default settings until the instructions say <strong class="bold">Give this Netlify SSH public key access to your repository</strong>. Then, you'll want to copy the provided key and add it to GitHub under your repository's <strong class="bold">Settings</strong> | <strong class="bold">Deploy keys</strong> page, as shown in the following screenshot:</p>
			<div><div><img alt="Figure 10.8 – Deploying keys&#13;&#10;" src="img/Figure_10.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – Deploying keys</p>
			<p>You can <a id="_idIndexMarker933"/>accept<a id="_idIndexMarker934"/> the default settings, but do not configure the <code>webhook</code> setting that is provided. While you can do this, I want to make sure we only push a test build if the build passes, so we'll add this to GitHub Actions instead. That also keeps more of the behavior inside source control. This is because we'll explicitly push to Netlify in a workflow step, whereas configuring through the GitHub GUI means there will be more settings we might forget about if we ever move the repository.</p>
			<p>When the command is complete, you should see a message that reads <strong class="bold">Success! Netlify CI/CD Configured!</strong>. It will tell you that branches will be automatically deployed when you push to them. Since we didn't set up the webhook, this is incorrect, and there's a little more still to do.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Of course, the CLI might have changed its interface since this book was published. The important takeaway is you want to create the site in Netlify, and do not want to set up a webhook because we'll be using GitHub Actions instead. If the choices have changed, you can look at the official Netlify documentation at <a href="https://docs.netlify.com/cli/get-started/">https://docs.netlify.com/cli/get-started/</a>.</p>
			<p>To add the step<a id="_idIndexMarker935"/> to <a id="_idIndexMarker936"/>deploy to Netlify, we're going to need to add a step to the workflow. That step is as follows:</p>
			<pre>- name: Deploy to Netlify
  uses: nwtgck/actions-netlify@v1.2
  with:
    publish-dir: './dist'
    production-branch: main
    github-token: ${{ secrets.GITHUB_TOKEN }}
    deploy-message: "Deploy from GitHub Actions"
    enable-pull-request-comment: true
    enable-commit-comment: true
    overwrites-pull-request-comment: true
  env:
    NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
    NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
  timeout-minutes: 1</pre>
			<p>We're using the action at <code>nwtgck/actions-netlify@v1.2</code> because it has the cool feature of commenting on the commit that does a deployment. There are other actions that use Netlify, and you could also just use the <code>runs</code> command after installing the CLI if you so choose. There are many options, and all of this should be considered as an example of one way to set up this workflow and not the actual way to set it up.</p>
			<p>The first few flags are somewhat self-explanatory. The build directory is <code>dist</code> so that's what we'll publish. The production branch is <code>main</code>, and we need <code>github-token</code> again so that the action can annotate the commits. The next three flags will enable a PR comment, telling you where the app was deployed to. Put that same comment on the comment, and then overwrite <code>pull-request-comment</code> if you deploy the same branch more than once. We've set all of these to true.</p>
			<p>The two <code>env</code> fields are probably the most confusing, as they specify a <code>NETLIFY_AUTH_TOKEN</code> token and the <code>NETLIFY_SITE_ID</code>  site ID that you don't have yet. The site ID is the easier of the two to find, and you can get it through the GUI or the CLI. To <a id="_idIndexMarker937"/>get it from the CLI, run <code>npm exec netlify status</code> in <a id="_idIndexMarker938"/>Command Prompt. You should get an output that looks like this:</p>
			<pre>$ npm exec netlify status
 ──────────────────────┐
 Current Netlify User  │
 ──────────────────────┘
Name:  You
Email: you@gmail.com
Teams:
                                    Your team: Collaborator
────────────────────┐
 Netlify Site Info  │
────────────────────┘
Current site: site-name
Admin URL: https://app.netlify.com/sites/site-name
Site URL: https://site-name.netlify.app
<strong class="bold">Site Id:  SITE_ID</strong></pre>
			<p>The last line displays your <code>NETLIFY_SITE_ID</code> site ID. You can then take that site ID and add it to the <code>Secrets</code> section of your GitHub repository, which is located in the <code>NETLIFY_SITE_ID</code>:</p>
			<div><div><img alt="Figure 10.9 – Setting the site ID in GitHub" src="img/Figure_10.09_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – Setting the site ID in GitHub</p>
			<p>Also, you'll need <a id="_idIndexMarker939"/>a <a id="_idIndexMarker940"/>personal access token to access the deployment. That's tricky to find in the Netlify UI, but it's there under <strong class="bold">User settings</strong>, which you can find by clicking on your user icon in the upper-right corner of the screen: </p>
			<div><div><img alt="Figure 10.10 – User settings&#13;&#10;" src="img/Figure_10.10_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – User settings</p>
			<p>Then, choose <strong class="bold">Applications</strong>, not <strong class="bold">Security</strong>, and you'll see the <strong class="bold">Personal access tokens</strong> section, as<a id="_idIndexMarker941"/> shown<a id="_idIndexMarker942"/> in the following screenshot:</p>
			<div><div><img alt="Figure 10.11 – The personal access token" src="img/Figure_10.11_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – The personal access token</p>
			<p>You can see the <code>Netlify Deploy</code> or something similar. Copy that token and add it to the secrets in GitHub, this time, named <code>NETLIFY_AUTH_TOKEN</code>:</p>
			<div><div><img alt="Figure 10.12 – Showing two secrets&#13;&#10;" src="img/Figure_10.12_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12 – Showing two secrets</p>
			<p>Once you've added<a id="_idIndexMarker943"/> those<a id="_idIndexMarker944"/> two keys, you can commit the changes to the workflow, push them up, and you will get an email from the GitHub Actions bot telling you that your app was deployed to a test URL. It's also commented to the commit, which you can see in the following screenshot:</p>
			<div><div><img alt="Figure 10.13 – Deployed to test&#13;&#10;" src="img/Figure_10.13_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.13 – Deployed to test</p>
			<p>Alternatively, you can go to the sample repository where you can see the comment at <a href="https://bit.ly/3DR1dS5">https://bit.ly/3DR1dS5</a>. The deploy link in the commit message won't work anymore because it's a test URL, but it did work at one time. That leaves us with one other thing to test. So far, we've been pushing to a branch—at least, you should have been if you paid attention—but if we deploy to the <code>main</code> branch, we will get a production deploy. You can get your code over to <code>main</code> however you like, merge locally, and push or create a PR. In any case, you <a id="_idIndexMarker945"/>just need to push a branch to <code>main</code> and you should get a<a id="_idIndexMarker946"/> production deployment.</p>
			<p>I know I did—you can play Walk the Dog at <a href="https://rust-games-webassembly.netlify.app/">https://rust-games-webassembly.netlify.app/</a>. We shipped!</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor235"/>Summary</h1>
			<p>Did I mention we shipped? In this chapter, we built a small but functional CI/CD pipeline for the Walk the Dog game. We learned how to create a GitHub Actions workflow and took a tour of how to find actions in the marketplace. Additionally, we started creating both test and production deployments in Netlify. We even get emails when it's done! You could extend this process to do things such as only making the test build on a PR or adding integration tests, and you could use this as a model for other CI/CD pipelines on different systems. This chapter was short, but vital since games must actually ship.</p>
			<p>Of course, while the game might be shipped, it's never finished. In the next chapter, we'll discuss some challenges that you can take on to make your version of Walk the Dog superior to the book version. I'm excited to see what you'll do!</p>
		</div>
	</body></html>