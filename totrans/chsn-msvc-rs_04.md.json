["```rs\n[dependencies]\nfutures = \"0.1\"\nhyper = \"0.12\"\nrand = \"0.5\"\nserde = \"1.0\"\nserde_derive = \"1.0\"\nserde_json = \"1.0\"\n```", "```rs\nextern crate futures;\nextern crate hyper;\nextern crate rand;\n#[macro_use]\nextern crate serde_derive;\nextern crate serde_json;\n```", "```rs\n#[derive(Serialize)]\nstruct RngResponse {\n    value: f64,\n}\n```", "```rs\n{ \"value\": 0.123456 }\n```", "```rs\n#[derive(Deserialize)]\nenum RngRequest {\n    Uniform {\n        range: Range<i32>,\n    },\n    Normal {\n        mean: f64,\n        std_dev: f64,\n    },\n    Bernoulli {\n        p: f64,\n    },\n}\n```", "```rs\nRngRequest::Uniform {\n        range: 1..10,\n}\n```", "```rs\n{ \"Uniform\": { \"range\": { \"start\": 1, \"end\": 10 } } }\n```", "```rs\n{ \"distribution\": \"uniform\", \"parameters\": { \"start\": 1, \"end\": 10 } } }\n```", "```rs\n#[derive(Deserialize)]\n#[serde(tag = \"distribution\", content = \"parameters\", rename_all = \"lowercase\")]\nenum RngRequest {\n    Uniform {\n        #[serde(flatten)]\n        range: Range<i32>,\n    },\n    Normal {\n        mean: f64,\n        std_dev: f64,\n    },\n    Bernoulli {\n        p: f64,\n    },\n}\n```", "```rs\nwarning: variable `stdDev` should have a snake case name such as `std_dev`\n```", "```rs\n#[derive(Serialize, Deserialize)]\nenum RpcRequest {\n    Request { id: u32, method: String, params: Vec<Value> },\n    Notification { id: u32, method: String, params: Vec<Value> },\n}\n```", "```rs\n{ \"Request\": { \"id\": 1, \"method\": \"get_user\", \"params\": [123] } }\n```", "```rs\n{ \"id\": 1, \"method\": \"get_user\", \"params\": [123] }\n```", "```rs\n#[serde(tag = \"distribution\", content = \"parameters\", rename_all = \"lowercase\")]\n```", "```rs\n#[derive(Deserialize)]\nstruct Response {\n    id: u32,\n    result: serde_json::Value,\n}\n```", "```rs\nlet u: User = serde_json::from_value(&response)?;\n```", "```rs\n(&Method::POST, \"/random\") => {\n    let body = req.into_body().concat2()\n        .map(|chunks| {\n            let res = serde_json::from_slice::<RngRequest>(chunks.as_ref())\n                .map(handle_request)\n                .and_then(|resp| serde_json::to_string(&resp));\n            match res {\n                Ok(body) => {\n                    Response::new(body.into())\n                },\n                Err(err) => {\n                    Response::builder()\n                        .status(StatusCode::UNPROCESSABLE_ENTITY)\n                        .body(err.to_string().into())\n                        .unwrap()\n                },\n            }\n        });\n    Box::new(body)\n}\n```", "```rs\nfn handle_request(request: RngRequest) -> RngResponse {\n    let mut rng = rand::thread_rng();\n    let value = {\n        match request {\n            RngRequest::Uniform { range } => {\n                rng.sample(Uniform::from(range)) as f64\n            },\n            RngRequest::Normal { mean, std_dev } => {\n                rng.sample(Normal::new(mean, std_dev)) as f64\n            },\n            RngRequest::Bernoulli { p } => {\n                rng.sample(Bernoulli::new(p)) as i8 as f64\n            },\n        }\n    };\n    RngResponse { value }\n}\n```", "```rs\n#[derive(Clone, PartialEq, Eq)]\npub struct Color {\n    pub red: u8,\n    pub green: u8,\n    pub blue: u8,\n}\n```", "```rs\npub const WHITE: Color = Color { red: 0xFF, green: 0xFF, blue: 0xFF };\npub const BLACK: Color = Color { red: 0x00, green: 0x00, blue: 0x00 };\n```", "```rs\nimpl fmt::Display for Color {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            &WHITE => f.write_str(\"white\"),\n            &BLACK => f.write_str(\"black\"),\n            color => {\n                write!(f, \"#{:02X}{:02X}{:02X}\", color.red, color.green, color.blue)\n            },\n        }\n    }\n}\n```", "```rs\nimpl Serialize for Color {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_str(&self.to_string())\n    }\n}\n```", "```rs\nuse std::fmt;\nuse std::str::FromStr;\nuse std::num::ParseIntError;\nuse serde::{de::{self, Visitor}, Deserialize, Deserializer, Serialize, Serializer};\n```", "```rs\nimpl FromStr for Color {\n    type Err = ColorError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"white\" => Ok(WHITE.to_owned()),\n            \"black\" => Ok(BLACK.to_owned()),\n            s if s.starts_with(\"#\") && s.len() == 7 => {\n                let red = u8::from_str_radix(&s[1..3], 16)?;\n                let green = u8::from_str_radix(&s[3..5], 16)?;\n                let blue = u8::from_str_radix(&s[5..7], 16)?;\n                Ok(Color { red, green, blue })\n            },\n            other => {\n                Err(ColorError::InvalidValue { value: other.to_owned() })\n            },\n        }\n    }\n}\n```", "```rs\nstruct ColorVisitor;\n\nimpl<'de> Visitor<'de> for ColorVisitor {\n    type Value = Color;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a color value expected\")\n    }\n\n    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E> where E: de::Error {\n        value.parse::<Color>().map_err(|err| de::Error::custom(err.to_string()))\n    }\n\n    fn visit_string<E>(self, value: String) -> Result<Self::Value, E> where E: de::Error {\n        self.visit_str(value.as_ref())\n    }\n}\n```", "```rs\n#[derive(Debug, Fail)]\npub enum ColorError {\n    #[fail(display = \"parse color's component error: {}\", _0)]\n    InvalidComponent(#[cause] ParseIntError),\n    #[fail(display = \"invalid value: {}\", value)]\n    InvalidValue {\n        value: String,\n    },\n}\n```", "```rs\nimpl From<ParseIntError> for ColorError {\n    fn from(err: ParseIntError) -> Self {\n        ColorError::InvalidComponent(err)\n    }\n}\n```", "```rs\nfailure = \"0.1\"\nfutures = \"0.1\"\nhyper = \"0.12\"\nrand = \"0.5\"\nserde = \"1.0\"\nserde_derive = \"1.0\"\nserde_json = \"1.0\"\nbase64 = \"0.9\"\nbase64-serde = \"0.3\"\n```", "```rs\n#[macro_use]\nextern crate failure;\nextern crate futures;\nextern crate hyper;\nextern crate rand;\nextern crate serde;\n#[macro_use]\nextern crate serde_derive;\nextern crate serde_json;\nextern crate base64;\n#[macro_use]\nextern crate base64_serde;\n\nmod color;\n\nuse std::ops::Range;\nuse std::cmp::{max, min};\nuse futures::{future, Future, Stream};\nuse hyper::{Body, Error, Method, Request, Response, Server, StatusCode};\nuse hyper::service::service_fn;\nuse rand::Rng;\nuse rand::distributions::{Bernoulli, Normal, Uniform};\nuse base64::STANDARD;\nuse color::Color;\n```", "```rs\n#[derive(Deserialize)]\n#[serde(tag = \"distribution\", content = \"parameters\", rename_all = \"lowercase\")]\nenum RngRequest {\n    Uniform {\n        #[serde(flatten)]\n        range: Range<i32>,\n    },\n    Normal {\n        mean: f64,\n        std_dev: f64,\n    },\n    Bernoulli {\n        p: f64,\n    },\n    Shuffle {\n        #[serde(with = \"Base64Standard\")]\n        data: Vec<u8>,\n    },\n    Color {\n        from: Color,\n        to: Color,\n    },\n}\n```", "```rs\nbase64_serde_type!(Base64Standard, STANDARD);\n```", "```rs\n#[derive(Serialize)]\n#[serde(rename_all = \"lowercase\")]\nenum RngResponse {\n    Value(f64),\n    #[serde(with = \"Base64Standard\")]\n    Bytes(Vec<u8>),\n    Color(Color),\n}\n```", "```rs\nfn handle_request(request: RngRequest) -> RngResponse {\n    let mut rng = rand::thread_rng();\n    match request {\n        RngRequest::Uniform { range } => {\n            let value = rng.sample(Uniform::from(range)) as f64;\n            RngResponse::Value(value)\n        },\n        RngRequest::Normal { mean, std_dev } => {\n            let value = rng.sample(Normal::new(mean, std_dev)) as f64;\n            RngResponse::Value(value)\n        },\n        RngRequest::Bernoulli { p } => {\n            let value = rng.sample(Bernoulli::new(p)) as i8 as f64;\n            RngResponse::Value(value)\n        },\n        RngRequest::Shuffle { mut data } => {\n            rng.shuffle(&mut data);\n            RngResponse::Bytes(data)\n        },\n        RngRequest::Color { from, to } => {\n            let red = rng.sample(color_range(from.red, to.red));\n            let green = rng.sample(color_range(from.green, to.green));\n            let blue = rng.sample(color_range(from.blue, to.blue));\n            RngResponse::Color(Color { red, green, blue})\n        },\n    }\n}\n```", "```rs\nfn color_range(from: u8, to: u8) -> Uniform<u8> {\n    let (from, to) = (min(from, to), max(from, to));\n    Uniform::new_inclusive(from, to)\n}\n```", "```rs\n$ curl --header \"Content-Type: application/json\" --request POST \\\n --data '{\"distribution\": \"uniform\", \"parameters\": {\"start\": -100, \"end\": 100}}' \\\n http://localhost:8080/random\n```", "```rs\n$ curl --header \"Content-Type: application/json\" --request POST \\\n --data '{\"distribution\": \"shuffle\", \"parameters\": { \"data\": \"MTIzNDU2Nzg5MA==\" } }' \\\n http://localhost:8080/random\n```", "```rs\n$ curl --header \"Content-Type: application/json\" --request POST \\\n --data '{\"distribution\": \"color\", \"parameters\": { \"from\": \"black\", \"to\": \"#EC670F\" } }' \\\n http://localhost:8080/random\n```", "```rs\n$ curl --header \"Content-Type: application/json\" --request POST \\\n --data '{\"distribution\": \"gamma\", \"parameters\": { \"shape\": 2.0, \"scale\": 5.0 } }' \\\n http://localhost:8080/random\n```", "```rs\nqueryst = \"2.0\"\n serde_cbor = \"0.8\"\n```", "```rs\nextern crate queryst;\nextern crate serde_cbor;\n```", "```rs\nfn serialize(format: &str, resp: &RngResponse) -> Result<Vec<u8>, Error> {\n    match format {\n        \"json\" => {\n            Ok(serde_json::to_vec(resp)?)\n        },\n        \"cbor\" => {\n            Ok(serde_cbor::to_vec(resp)?)\n        },\n        _ => {\n            Err(format_err!(\"unsupported format {}\", format))\n        },\n    }\n}\n```", "```rs\n(&Method::POST, \"/random\") => {\n    let format = {\n        let uri = req.uri().query().unwrap_or(\"\");\n        let query = queryst::parse(uri).unwrap_or(Value::Null);\n        query[\"format\"].as_str().unwrap_or(\"json\").to_string()\n    };\n    let body = req.into_body().concat2()\n        .map(move |chunks| {\n            let res = serde_json::from_slice::<RngRequest>(chunks.as_ref())\n                .map(handle_request)\n                .map_err(Error::from)\n                .and_then(move |resp| serialize(&format, &resp));\n            match res {\n                Ok(body) => {\n                    Response::new(body.into())\n                },\n                Err(err) => {\n                    Response::builder()\n                        .status(StatusCode::UNPROCESSABLE_ENTITY)\n                        .body(err.to_string().into())\n                        .unwrap()\n                },\n            }\n        });\n    Box::new(body)\n},\n```", "```rs\n$ curl --header \"Content-Type: application/json\" --request POST \\\n --data '{\"distribution\": \"uniform\", \"parameters\": {\"start\": -100, \"end\": 100}}' \\\n \"http://localhost:8080/random?format=json\"\n```", "```rs\n$ curl --header \"Content-Type: application/json\" --request POST \\\n --data '{\"distribution\": \"uniform\", \"parameters\": {\"start\": -100, \"end\": 100}}' \\\n \"http://localhost:8080/random?format=cbor\"\n```", "```rs\nWarning: Binary output can mess up your terminal. Use \"--output -\" to tell \nWarning: curl to output it to your terminal anyway, or consider \"--output \nWarning: <FILE>\" to save to a file.\n```", "```rs\n$ curl --header \"Content-Type: application/json\" --request POST \\\n --data '{\"distribution\": \"uniform\", \"parameters\": {\"start\": -100, \"end\": 100}}' \\\n \"http://localhost:8080/random?format=xml\"\n```", "```rs\nlet mut deserializer = serde_json::Deserializer::from_reader(reader);\nlet mut serializer = serde_cbor::Serializer::pretty(writer);\nserde_transcode::transcode(&mut deserializer, &mut serializer).unwrap();\n```"]