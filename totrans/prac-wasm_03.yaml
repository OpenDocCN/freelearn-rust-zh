- en: '*Chapter 2*: Understanding Emscripten'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about **Emscripten**, which is a toolchain to
    convert C/C++ code into a WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Emscripten consists of two components:'
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten compiler frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emscripten SDK** (**emsdk**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Clang** compiler frontend compiles C/C++ code into **LLVM intermediate
    representation** (**LLVM IR**) and then uses the LLVM backend to convert the LLVM
    IR into native code. The Clang compiler is fast, uses little memory, and is compatible
    with **GNU Compiler Collection** (**GCC**). Emscripten is similar to Clang; the
    former produces a *wasm* binary while the latter produces a *native* binary. The
    **Emscripten compiler frontend** (**emcc**) is the compiler frontend that converts
    C/C++ into LLVM IR (both binary and human-readable form) and into the WebAssembly
    binary or *asm.js*, such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Emscripten compiler frontend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B14844.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Emscripten compiler frontend
  prefs: []
  type: TYPE_NORMAL
- en: '**emsdk** helps manage and maintain the Emscripten toolchain components and
    set up the runtime/terminal environment to run emcc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to install Emscripten. Then, we will use
    Emscripten to generate asm.js, a WebAssembly module that runs on Node.js and the
    browser. After that, we will explore the emsdk tool. Finally, we will explore
    various optimizations provided by Emscripten. We will cover the following topics
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Emscripten using emsdk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating asm.js using Emscripten
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Hello World with Emscripten in Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Hello World with Emscripten in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other options in emsdk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding various levels of optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did You Know?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: asm.js is a subset of JavaScript that is optimized to run at near-native performance
    in the browser. The asm.js spec was not accepted by all browser vendors. asm.js
    has evolved into WebAssembly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be showing how to set up Emscripten in this chapter, for which you
    will require the following installed on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: Python >= 3.7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js > 12.18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: emsdk comes prebundled with a compatible Node.js version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly)
  prefs: []
  type: TYPE_NORMAL
- en: Installing Emscripten using emsdk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: emsdk provides an easy way to install, manage, and switch versions of the Emscripten
    toolchain. emsdk takes care of setting up the environment, tools, and SDK required
    for compiling C/C++ to LLVM IR and then to JavaScript in the form of asm.js or
    the WebAssembly binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Emscripten and start hacking:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the emsdk repo and go into the `emsdk` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To install emsdk on the machine, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For *nix users, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows users, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command might take a while to run; it will build and set up the
    entire toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will activate the latest emsdk. The activation updates the local shell
    with the necessary environment references and makes the latest SDK active for
    the user in the current shell. It writes the path and other necessary information
    for the Emscripten toolchain to work under the user''s home directory in a file
    called `.emscripten`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the installed emsdk, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For *nix users, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows users, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to make sure the configurations and paths are activated by running
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For *nix users, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows users, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Congrats, the Emscripten toolchain is installed! Updating the toolchain with
    emsdk is as easy as installing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For *nix users, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows users, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'emsdk sets up the following paths inside the Emscripten configuration file.
    The Emscripten configuration file (`.emscripten`) is in the home folder. It consists
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LLVM_ROOT` – specifies the path of the LLVM Clang compiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NODE_JS` – specifies the path of Node.js'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BINARYEN_ROOT` – specifies the optimizer for the Emscripten compiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMSCRIPTEN_ROOT` – specifies the path of the Emscripten compiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can check whether the installation of emcc was successful by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have finished installing the Emscripten compiler, let's go ahead
    and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Generating asm.js using Emscripten
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Emscripten to port C/C++ programs into asm.js or the WebAssembly
    binary and then run them inside the JavaScript engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages such as Lua and Python have a C/C++ runtime. With Emscripten,
    we can port the runtime as a WebAssembly module and execute them inside the JavaScript
    engine. This makes it easy to run Lua/Python code on the JavaScript engine. Thus,
    Emscripten and WebAssembly allow the running of native code in the JavaScript
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a `sum.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Consider `extern "C"` as something like an *export* mechanism. All the functions
    inside are available as an exported function without any changes to their name.
    Then, we define the normal `sum` function that takes in two numbers and returns
    a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate the asm.js like JavaScript code from `sum.cpp`, use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are running emcc for the first time, it might take a few seconds to complete.
    Subsequent runs will be faster.
  prefs: []
  type: TYPE_NORMAL
- en: We pass in the `-O1` option to the emcc compiler, instructing the compiler to
    produce less-optimized code (we will see more options to optimize later in this
    chapter). Next, we pass the file to be converted, that is, `sum.cpp`. Then, with
    the `-o` flag, we provide the desired name for the output, which is `sum.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we send in more information to the emcc compiler using the `-s` flag.
    The `-s` flag takes in a key and value as their arguments. The emcc compiler generates
    the WebAssembly module by default. `WASM=0` instructs the compiler to generate
    asm.js like JavaScript instead of WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we specify the exported functions using the `EXPORTED_FUNCTIONS` option.
    The `EXPORTED_FUNCTIONS` option takes an array of arguments. In order to export
    the `sum` function, we specify `_sum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will generate the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`|0` specifies the type as a number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `sum.html` in a browser and open the developer console. In order to
    call the exported function, we will run the following expression in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`ccall` is the way to call the exported function from C/C++ code via JavaScript.
    The function takes in the name of the function, the type of the return value,
    types of arguments, and then the input arguments as an array. This will invoke
    the `sum` function to produce the result. We will see more about `ccall` and `cwrap`
    in later chapters. But for now, consider `ccall` a way to call the C function.'
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about the Emscripten source at [https://github.com/emscripten-core/emscripten](https://github.com/emscripten-core/emscripten).
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how to generate asm.js files using emscripten. Let us use
    emscripten to create a WebAssembly Module to run on Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Running Hello World with Emscripten in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to convert C/C++ code into the WebAssembly
    binary via Emscripten and run it along with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If the terminal errors out with *emcc command not found*, your terminal environment
    might have been reset. To set up the environment, run the following command from
    inside the `emsdk` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '**source ./emsdk_env.sh**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow the tradition of Brian Kernighan, by writing "Hello, world" with
    a slight twist. Let''s do a "Hello, Web":'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `hello_web.c` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Launch your favorite editor and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is a simple C program with a `main` function. The `main` function is the
    entry point during the runtime. When this code is compiled and executed using
    Clang (`clang sum.c && ./a.out`), "Hello, Web!" is printed. Now, instead of Clang
    (or any other compiler), let's compile the code with emcc.
  prefs: []
  type: TYPE_NORMAL
- en: 'We enter the following command to compile the code with emcc:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once completed, the following files are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a.out.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a.out.wasm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generated JavaScript file is huge. It has more than 2,000 lines and is 109
    KB in size. We will learn how to optimize the file size later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the generated JavaScript file using Node and that will print out
    "Hello, Web!":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations! You just ran your first WebAssembly binary!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Binary size matters in the world of browsers. It won't matter if your algorithm
    runs in nanoseconds if you have a huge chunk of code. The browser waits till it
    receives all the necessary information before it starts to parse and compile.
    So, it is mandatory to check the file size. *Closure Compiler* helps to minimize
    the byte code size further. Closure Compiler not only reduces the code size but
    also tries to make the code more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated JavaScript file contains its own runtime and configuration needed
    for the JavaScript engine to execute the WebAssembly module inside the JavaScript
    engine. The generated JavaScript file creates a JavaScript module and initializes
    code for both browsers and Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: In Node.js, the generated JavaScript file creates a module by reading the file
    from the local filesystem. It gets the arguments passed to the node command and
    sets them up in the module created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In browsers, the generated JavaScript file creates a module by framing a request
    and fetches it as bytes from a URL. The browser fetches the WebAssembly binary
    from the hosted server or location and then instantiates the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generated JavaScript file also creates a stack, memory, import, and export
    sections. We will deep dive into those sections later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: This generated JavaScript file is called a *binding file*. The main function
    of the binding file is to create or set an environment that enables executing
    a WebAssembly module inside the JavaScript engine. The binding file acts as a
    translator between JavaScript and WebAssembly. All the values are passed in and
    out via this binding file.
  prefs: []
  type: TYPE_NORMAL
- en: When the JavaScript file is executed via node, it does the following.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript engine first loads the module and then sets up the constants
    and various functions that are required for WebAssembly to execute. Then, the
    module checks where the code is being executed, whether the module is inside the
    browser or in the `Node` environment. Based on that, it fetches the file. Since
    we are running the WebAssembly Module via the node here, it fetches the file from
    the local filesystem. Then, the module is checked for any arguments provided for
    the call. If not, the JavaScript engine will check whether there are any unhandled/uncaught
    exceptions. The JavaScript engine then maps the `print out`/`print err` function
    to the console. The JavaScript engine checks whether the module loaded has all
    the required access and global variables and imports are available for execution.
  prefs: []
  type: TYPE_NORMAL
- en: The module goes on to initialize the stack and other required constants as well
    as the decoder and encoder for decoding and encoding the buffer, respectively.
    The encoder is responsible for translating the JavaScript values into WebAssembly-understandable
    values. The decoder is responsible for translating the WebAssembly values into
    JavaScript-understandable values.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js runtime then checks the availability of the file and then initializes
    the file. The module is checked for all the WebAssembly-related function availability.
    Once everything is initialized and the module contains all the functions required,
    we will call the `run` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `run` function instantiates the WebAssembly binary. In this case, since
    we have defined the `main` function in C, the binding file calls the `main` function
    straight away when instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binding file contains the `ccall` function. The `ccall` function is an
    interface to the underlying function defined in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ccall` function accepts the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ident` – The function to call; it is the function identifier defined in C.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returnType` – The return type of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argTypes` – The argument types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args` – The arguments that are passed along with the function call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opts` – Any other options that are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JavaScript module exports the `cwrap` function in addition to `ccall`.
    `cwrap` is a wrapper function around the `ccall` function. While `ccall` is a
    function invocation, `cwrap` provides a function that invokes `ccall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The WebAssembly file generated consists of binary opcode to instruct the runtime
    to print "Hello, Web!". The WebAssembly file starts with `00 61 73 6d 01 00 00
    00`.
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about WebAssembly specifications at [https://webassembly.github.io/spec/](https://webassembly.github.io/spec/).
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how to generate a WebAssembly module to run on Node.js.
    Let us use emscripten to create a WebAssembly Module to run in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Running Hello World with Emscripten in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to convert C/C++ code into the WebAssembly
    binary via Emscripten and run it in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If the terminal says that the `emcc` command is not found, it is highly likely
    that you have missed setting up the environment variables. To set up the environment
    variables, run the following command from inside the `emsdk` folder: `source ./emsdk_env.sh`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same code example used in the *Generating asm.js using Emscripten*
    section . Now, instead of just running emcc, let''s pass the `-o` option and instruct
    emcc to generate the `.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once completed, the following files are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`helloweb.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helloweb.wasm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helloweb.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the Node example, the generated JavaScript file is huge. We will
    learn how to optimize the file size later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `-o` option ensures all the files generated have the name `helloweb`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to run the generated HTML file in the browser, we will need a web server.
    The web server serves the HTML file over the HTTP protocol. Explaining web servers
    and how they work is beyond the scope of this book; refer to [https://en.wikipedia.org/wiki/Web_server](https://en.wikipedia.org/wiki/Web_server)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides an easy way to run the web server. In order to run the web
    server using Python, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://localhost:<port number>` to see WebAssembly in action in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Browser running WebAssembly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B14844.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Browser running WebAssembly
  prefs: []
  type: TYPE_NORMAL
- en: When the JavaScript file is executed via the browser, it prints out `run` function.
    The `run` function instantiates the WebAssembly binary. In this case, since we
    have defined the `main` function in C, the binding file calls the `main` function
    straight away when instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten also provides `emrun` to run HTML files. Check out [https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html](https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about deploying Emscripten-compiled pages at [https://emscripten.org/docs/compiling/Deploying-Pages.html](https://emscripten.org/docs/compiling/Deploying-Pages.html).
  prefs: []
  type: TYPE_NORMAL
- en: We have used Emscripten to generate the WebAssembly module. Let's go ahead and
    explore what else the emsdk can do.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other options in emsdk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: emsdk is a single-stop shop for installing, maintaining, and managing all the
    tools and toolchains required for using Emscripten. emsdk makes it easier to bootstrap
    the environment, upgrade to the latest versions, switch to various versions, change
    or configure various tools, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The `emsdk` command is available inside the `emsdk` folder. Go to the `emsdk`
    folder and run the `emsdk` command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For all the commands in this chapter, for *nix systems, use `./emsdk`, and for
    Windows, use `emsdk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the various options available in the `emsdk` command, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'An `emsdk` command takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `emsdk` command consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<option>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be one of the following: list, update, update-tags, install, uninstall,
    or activate.'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Tool/SDK>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This refers to libraries and it includes Emscripten and LLVM. `SDK` refers to
    emsdk itself.
  prefs: []
  type: TYPE_NORMAL
- en: '`--<flags>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This refers to various configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Let us explore each of the options and flags that emsdk command supports.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the tools and SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we show how to list the tools and SDK that are available with emsdk.
    Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`emsdk list` lists all tool packages and SDKs that are available. This list
    of tools and SDKs includes the last few versions of LLVM, Clang, Emscripten, and
    Binaryen. They even have Node versions 8 and 12 and Python 3.7\. emsdk maintains
    and manages `emsdk`. This means that we need to know the information about the
    current version that we are using and how to update it. The `emsdk list` command
    also provides more detail on the SDK components along with a list of those compiled
    from the sources.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the tools and SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: emsdk provides an option to install, update, and uninstall the tools and SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to install the tools, SDK, or emsdk itself, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the latest version of the SDK, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`latest` refers to the latest version of emsdk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install multiple tools with the `emsdk install` command, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify multiple options for the `install` command. You can pass
    in options to the `install` command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The various `options` available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of cores to build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type of build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activation of tools and SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninstallation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of cores to build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The initial setup will take a long time to build and install the required tools
    and SDK. Based on your requirements, you can control the number of cores that
    you need for building and installing the required tools and SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Type of build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You instruct `emsdk` on what type of build is to be used to make LLVM perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`type` accepts the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: Debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type is used for debugging.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It generates Symbol files.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The end build will not produce optimized, fast code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type will generate optimized, fast code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MinSizeRel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type is the same as Release.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This type will minimize the size and maximize the speed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This uses optimization options such as `-O1` (minimize size) and `-O2` (maximize
    speed).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: RelWithDebInfo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type is the same as Release.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This type will also generate Symbol files. That will help in debugging.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Activation of the tools and SDK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the tools and SDK are installed, we can activate different versions to
    use them. The `activate` command generates the necessary configuration files mapping
    the path, with the built executables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the tools and SDK, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `activate` command accepts a few options; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--embedded` – This option makes sure all the built files, configuration, cache,
    and temporary files are located inside the directory in which the emsdk command
    is located.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not specified, this command will move the configuration file to the user's
    home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`--build=<type>` – Similar to the type of build that LLVM supports. For example,
    Debug, Release, MinSizeRel, RelWithDebInfo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninstallation of the tools and SDK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To uninstall the tools and SDK, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Find out more about the tools at [https://emscripten.org/docs/tools_reference/index.html](https://emscripten.org/docs/tools_reference/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: We have explored how emsdk helps us to manage tools and SDKs; let's go ahead
    and explore various optimizations provided by Emscripten.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding various levels of optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C/C++ programs are compiled and converted into native code via Clang or the
    GCC compiler. Clang or the GCC compiler converts the C/C++ program based on the
    target. Target here refers to the end machine where the code is executed. emcc
    has the Clang compiler built in. The emcc compiler is responsible for converting
    the C or C++ source code into LLVM byte code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how to improve the optimization and code size of
    the generated WebAssembly binary code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the efficiency and generated code size, the Emscripten compiler
    has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closure Compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lets talk about optimizations first.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of the compiler is to reduce the cost of compilation, that is, the
    compile time. With the `-O` optimization flag, the compiler tries to improve the
    code size and/or the performance at the expense of the compile time. In terms
    of compiler optimizations, code size and performance are mutually exclusive. The
    faster the compile time, the lower the optimization. To specify the optimization,
    we use the `-O<0/1/2/3/s/z>` flag. Each of the options includes various assertions,
    code size optimizations, and code performance optimizations, along with others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the various optimizations available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-O0` – This is the default option and a perfect starter to experiment. This
    option means "no optimizations." This optimization level compiles the fastest
    and generates the most debuggable code. This is a basic optimization level. This
    option tries to inline functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-O1` – This option adds simple optimizations and tries to generate a minimum
    code size. This option removes runtime assertions in the generated code and builds
    slower than the `-O0` option. This option also tries to simplify the loops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-O2` – This option adds further optimizations than `-O1`. It is slower than
    `-O1` but generates code that is more optimized than the `-O1` option. This option
    optimizes the code based on JavaScript optimization and removes code that is not
    part of JavaScript modules. This option removes the inline functions and the `vectorize-loop`
    option is set. This option adds a moderate level of optimization. This option
    also adds dead code elimination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vectorization will instruct the processor to do the operation in chunks rather
    than doing it one by one.
  prefs: []
  type: TYPE_NORMAL
- en: '`-O3` – This option adds more options, takes more time to compile, and generates
    more optimized code than the `-O2` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This option produces optimal production-ready code. This option is like `-O2`,
    except that it enables optimizations that take longer to perform or that may generate
    larger code (in an attempt to make the program run faster).
  prefs: []
  type: TYPE_NORMAL
- en: '`-Os` – This option is similar to `-O2`. It adds extra optimizations and reduces
    the code size. Reducing the code size in turn decreases the performance. This
    option generates smaller code than `-O2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Oz` – This option is similar to `-Os` but reduces the code size even further.
    This option takes more compile time to generate the binary code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now explore the various optimization options provided by Emscripten:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a C file called `optimization_check`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, open your favorite editor and add the following code. The following is
    a simple C file with a `main` function and a couple of other functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then compile this into WebAssembly code using emcc:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, check the sizes of the file generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that the WebAssembly file generated is about 13 KB and it took a
    total of 0.514 seconds to compile. That is a fast compilation but the code size
    is huge.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of compilers, the faster the compilation, the bigger the code size
    and the slower the execution speed will be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s optimize it further using the `-O1` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the sizes of the file generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The WebAssembly file generated is about 3.4 KB (3.8 times less than the `-O0`
    version) and it took almost the same time, around 0.519 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s optimize it further using the `-O2` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the sizes of the file generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The WebAssembly file generated is about 2 KB (~6.5 times less than `-O0`) and
    it took around 0.62 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s optimize it further using the `-O3` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Find out more about the `--profiling` flag at [https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling](https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the sizes of the file generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The WebAssembly file generated is the same size as `-02` but the generated JavaScript
    file is 3 KB less, and it took around 1.117 seconds to compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s optimize it further using the `-Os` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the sizes of the file generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The WebAssembly file generated is about 1.7 KB (~7.5 times less than `-O0`)
    and it took almost 2.655 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s optimize it further using the `-Oz` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the sizes of the file generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The WebAssembly file generated is about 1.7 KB (~7.5 times less than `-O0`)
    and it took around 1.123 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll see an alternative means provided by the Emscripten compiler for
    improving the efficiency and reducing the generated code size: Closure Compiler'
  prefs: []
  type: TYPE_NORMAL
- en: Closure Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Closure Compiler is a tool for compiling JavaScript to better JavaScript. It
    parses, analyzes, removes dead code, rewrites, and minimizes JavaScript. Further
    optimizations on the generated binding JavaScript file and WebAssembly module
    are done using Closure Compiler. With Closure Compiler, we can do better optimizations
    on Emscripten code. To optimize the WebAssembly module and JavaScript further,
    we can use `--closure <optimization type>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `optimization` type has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--closure 0` – This option adds no Closure Compiler optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--closure 1` – This option reduces the generated JavaScript code size. This
    option does not optimize the asm.js and WebAssembly binary. This adds an additional
    compilation step that increases the compilation time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--closure 2` – This option optimizes JavaScript, asm.js, and not the WebAssembly
    binary and reduces the code size of the file drastically for asm.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the `–closure 1` option to optimize the WebAssembly binary along
    with the`–O3/s` Emscripten optimization options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The file sizes generated are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with `emcc –O3`, we pass `–closure 1` to further optimize the generated
    files. Closure Compiler reduces the size of the JavaScript file by 50% when compared
    to the `emcc -O3` option and it took 2.681 seconds to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s list the files in the current folder to check the generated files and
    their size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Along with `emcc –Os`, we pass `–closure 1` to further optimize the generated
    binary. Closure Compiler reduces the `.wasm` file a little bit more with the `emcc
    -Os` option, and it took 2.778 seconds to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When optimizing for size, try to use both `-O3` or `-Os` along with `--closure
    1` to optimize both JavaScript and the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Check out more various options and flags at [https://emscripten.org/docs/tools_reference/emcc.html](https://emscripten.org/docs/tools_reference/emcc.html)
    [https://clang.llvm.org/docs/CommandGuide/clang.html](https://clang.llvm.org/docs/CommandGuide/clang.html).
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about various available optimization options at [https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017](https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017).
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about Closure Compiler at [https://developers.google.com/closure/compiler](https://developers.google.com/closure/compiler).
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about optimizing large code bases with Emscripten at [https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases](https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to install and use Emscripten to compile C/C++
    into a WebAssembly module. We also explored the emsdk tool and various levels
    of optimizations when generating the WebAssembly module. In the next chapter,
    we will explore the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
