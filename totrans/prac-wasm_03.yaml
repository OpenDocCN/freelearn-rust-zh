- en: '*Chapter 2*: Understanding Emscripten'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：理解Emscripten'
- en: In this chapter, we will learn about **Emscripten**, which is a toolchain to
    convert C/C++ code into a WebAssembly module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解**Emscripten**，这是一个将C/C++代码转换为WebAssembly模块的工具链。
- en: 'Emscripten consists of two components:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten由两个组件组成：
- en: Emscripten compiler frontend
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emscripten编译器前端
- en: '**Emscripten SDK** (**emsdk**)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Emscripten SDK**（**emsdk**）'
- en: The **Clang** compiler frontend compiles C/C++ code into **LLVM intermediate
    representation** (**LLVM IR**) and then uses the LLVM backend to convert the LLVM
    IR into native code. The Clang compiler is fast, uses little memory, and is compatible
    with **GNU Compiler Collection** (**GCC**). Emscripten is similar to Clang; the
    former produces a *wasm* binary while the latter produces a *native* binary. The
    **Emscripten compiler frontend** (**emcc**) is the compiler frontend that converts
    C/C++ into LLVM IR (both binary and human-readable form) and into the WebAssembly
    binary or *asm.js*, such as JavaScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clang**编译器前端将C/C++代码编译成**LLVM中间表示**（**LLVM IR**），然后使用LLVM后端将LLVM IR转换为本地代码。Clang编译器速度快，内存使用少，与**GNU编译器集合**（**GCC**）兼容。Emscripten与Clang类似；前者生成*wasm*二进制文件，而后者生成*本地*二进制文件。**Emscripten编译器前端**（**emcc**）是将C/C++转换为LLVM
    IR（二进制和可读形式）以及WebAssembly二进制文件或*asm.js*（如JavaScript）的编译器前端。'
- en: '![Figure 2.1 – Emscripten compiler frontend'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – Emscripten编译器前端'
- en: '](img/Figure_2.1_B14844.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.1_B14844.jpg](img/Figure_2.1_B14844.jpg)'
- en: Figure 2.1 – Emscripten compiler frontend
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.1 – Emscripten编译器前端
- en: '**emsdk** helps manage and maintain the Emscripten toolchain components and
    set up the runtime/terminal environment to run emcc.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**emsdk**帮助管理和维护Emscripten工具链组件，并设置运行时/终端环境以运行emcc。'
- en: 'In this chapter, we will learn how to install Emscripten. Then, we will use
    Emscripten to generate asm.js, a WebAssembly module that runs on Node.js and the
    browser. After that, we will explore the emsdk tool. Finally, we will explore
    various optimizations provided by Emscripten. We will cover the following topics
    in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何安装Emscripten。然后，我们将使用Emscripten生成asm.js，这是一个在Node.js和浏览器上运行的WebAssembly模块。之后，我们将探索emsdk工具。最后，我们将探索Emscripten提供的各种优化。本章将涵盖以下主题：
- en: Installing Emscripten using emsdk
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用emsdk安装Emscripten
- en: Generating asm.js using Emscripten
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Emscripten生成asm.js
- en: Running Hello World with Emscripten in Node.js
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js中使用Emscripten运行Hello World
- en: Running Hello World with Emscripten in the browser
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中使用Emscripten运行Hello World
- en: Exploring other options in emsdk
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索emsdk中的其他选项
- en: Understanding various levels of optimizations
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解各种优化级别
- en: Did You Know?
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: asm.js is a subset of JavaScript that is optimized to run at near-native performance
    in the browser. The asm.js spec was not accepted by all browser vendors. asm.js
    has evolved into WebAssembly.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: asm.js是JavaScript的一个子集，经过优化，在浏览器中可以接近本地性能运行。asm.js规范并未被所有浏览器厂商接受。asm.js已演变成WebAssembly。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be showing how to set up Emscripten in this chapter, for which you
    will require the following installed on your system:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示如何设置Emscripten，您需要在系统上安装以下内容：
- en: Python >= 3.7
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python >= 3.7
- en: Node.js > 12.18
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js > 12.18
- en: Note
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: emsdk comes prebundled with a compatible Node.js version.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: emsdk预装了兼容的Node.js版本。
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中提供的代码文件，链接为[https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly)
- en: Installing Emscripten using emsdk
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用emsdk安装Emscripten
- en: emsdk provides an easy way to install, manage, and switch versions of the Emscripten
    toolchain. emsdk takes care of setting up the environment, tools, and SDK required
    for compiling C/C++ to LLVM IR and then to JavaScript in the form of asm.js or
    the WebAssembly binary.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: emsdk提供了一种简单的方式来安装、管理和切换Emscripten工具链的版本。emsdk负责设置环境、工具和SDK，以便将C/C++编译成LLVM
    IR，然后以asm.js或WebAssembly二进制文件的形式转换为JavaScript。
- en: 'Let''s install Emscripten and start hacking:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Emscripten并开始编写代码：
- en: 'Clone the emsdk repo and go into the `emsdk` folder:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆emsdk仓库并进入`emsdk`文件夹：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install emsdk on the machine, run the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在机器上安装emsdk，请运行以下命令：
- en: 'For *nix users, use the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*nix用户，请使用以下命令：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For Windows users, use the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，请使用以下命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding command might take a while to run; it will build and set up the
    entire toolchain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令可能需要一段时间运行；它将构建和设置整个工具链。
- en: 'Next, we will activate the latest emsdk. The activation updates the local shell
    with the necessary environment references and makes the latest SDK active for
    the user in the current shell. It writes the path and other necessary information
    for the Emscripten toolchain to work under the user''s home directory in a file
    called `.emscripten`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将激活最新的 emsdk。激活更新了本地 shell 中的必要环境引用，并使最新的 SDK 在当前 shell 中对用户生效。它将 Emscripten
    工具链的路径和其他必要信息写入用户主目录下的名为 `.emscripten` 的文件中：
- en: 'To activate the installed emsdk, run the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要激活已安装的 emsdk，请运行以下命令：
- en: 'For *nix users, use the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *nix 用户，请使用以下命令：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For Windows users, use the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，请使用以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now it is time to make sure the configurations and paths are activated by running
    the following:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候运行以下命令来确保配置和路径被激活，以确保配置和路径被激活：
- en: 'For *nix users, use the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *nix 用户，请使用以下命令：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For Windows users, use the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，请使用以下命令：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Congrats, the Emscripten toolchain is installed! Updating the toolchain with
    emsdk is as easy as installing it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，Emscripten 工具链已安装！使用 emsdk 更新工具链与安装一样简单。
- en: 'To update, run the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新，请运行以下命令：
- en: 'For *nix users, use the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *nix 用户，请使用以下命令：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For Windows users, use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，请使用以下命令：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'emsdk sets up the following paths inside the Emscripten configuration file.
    The Emscripten configuration file (`.emscripten`) is in the home folder. It consists
    of the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: emsdk 在 Emscripten 配置文件中设置以下路径。Emscripten 配置文件（`.emscripten`）位于主文件夹中。它由以下内容组成：
- en: '`LLVM_ROOT` – specifies the path of the LLVM Clang compiler'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM_ROOT` – 指定 LLVM Clang 编译器的路径'
- en: '`NODE_JS` – specifies the path of Node.js'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NODE_JS` – 指定 Node.js 的路径'
- en: '`BINARYEN_ROOT` – specifies the optimizer for the Emscripten compiler'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BINARYEN_ROOT` – 指定 Emscripten 编译器的优化器'
- en: '`EMSCRIPTEN_ROOT` – specifies the path of the Emscripten compiler'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMSCRIPTEN_ROOT` – 指定 Emscripten 编译器的路径'
- en: 'We can check whether the installation of emcc was successful by using the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查 emcc 的安装是否成功：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have finished installing the Emscripten compiler, let's go ahead
    and use it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 Emscripten 编译器的安装，让我们继续使用它。
- en: Generating asm.js using Emscripten
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Emscripten 生成 asm.js
- en: We will use Emscripten to port C/C++ programs into asm.js or the WebAssembly
    binary and then run them inside the JavaScript engine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Emscripten 将 C/C++ 程序移植到 asm.js 或 WebAssembly 二进制文件，然后在 JavaScript 引擎中运行它们。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Programming languages such as Lua and Python have a C/C++ runtime. With Emscripten,
    we can port the runtime as a WebAssembly module and execute them inside the JavaScript
    engine. This makes it easy to run Lua/Python code on the JavaScript engine. Thus,
    Emscripten and WebAssembly allow the running of native code in the JavaScript
    engine.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Lua 和 Python 等编程语言具有 C/C++ 运行时。使用 Emscripten，我们可以将运行时作为 WebAssembly 模块进行移植，并在
    JavaScript 引擎中执行它们。这使得在 JavaScript 引擎上运行 Lua/Python 代码变得容易。因此，Emscripten 和 WebAssembly
    允许在 JavaScript 引擎中运行原生代码。
- en: 'First, let''s create a `sum.cpp` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 `sum.cpp` 文件：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Consider `extern "C"` as something like an *export* mechanism. All the functions
    inside are available as an exported function without any changes to their name.
    Then, we define the normal `sum` function that takes in two numbers and returns
    a number.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `extern "C"` 视为一个类似于 *导出* 的机制。所有这些函数都作为导出函数可用，无需更改其名称。然后，我们定义一个普通的 `sum` 函数，它接受两个数字并返回一个数字。
- en: 'In order to generate the asm.js like JavaScript code from `sum.cpp`, use the
    following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 `sum.cpp` 生成类似于 JavaScript 的 asm.js 代码，请使用以下命令：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are running emcc for the first time, it might take a few seconds to complete.
    Subsequent runs will be faster.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是第一次运行 emcc，可能需要几秒钟才能完成。后续运行将更快。
- en: We pass in the `-O1` option to the emcc compiler, instructing the compiler to
    produce less-optimized code (we will see more options to optimize later in this
    chapter). Next, we pass the file to be converted, that is, `sum.cpp`. Then, with
    the `-o` flag, we provide the desired name for the output, which is `sum.html`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `-O1` 选项传递给 emcc 编译器，指示编译器生成较少优化的代码（我们将在本章后面看到更多优化选项）。接下来，我们传递要转换的文件，即 `sum.cpp`。然后，使用
    `-o` 标志，我们提供所需的输出名称，即 `sum.html`。
- en: Finally, we send in more information to the emcc compiler using the `-s` flag.
    The `-s` flag takes in a key and value as their arguments. The emcc compiler generates
    the WebAssembly module by default. `WASM=0` instructs the compiler to generate
    asm.js like JavaScript instead of WebAssembly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `-s` 标志向 emcc 编译器发送更多信息。`-s` 标志接受键和值作为它们的参数。emcc 编译器默认生成 WebAssembly
    模块。`WASM=0` 指示编译器生成类似 JavaScript 的 asm.js 而不是 WebAssembly。
- en: Then, we specify the exported functions using the `EXPORTED_FUNCTIONS` option.
    The `EXPORTED_FUNCTIONS` option takes an array of arguments. In order to export
    the `sum` function, we specify `_sum`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `EXPORTED_FUNCTIONS` 选项指定导出的函数。`EXPORTED_FUNCTIONS` 选项接受一个参数数组。为了导出
    `sum` 函数，我们指定 `_sum`。
- en: 'This will generate the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下代码：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`|0` specifies the type as a number.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`|0` 指定类型为数字。'
- en: 'Now open `sum.html` in a browser and open the developer console. In order to
    call the exported function, we will run the following expression in the console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开 `sum.html` 并打开开发者控制台。为了调用导出的函数，我们将在控制台中运行以下表达式：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`ccall` is the way to call the exported function from C/C++ code via JavaScript.
    The function takes in the name of the function, the type of the return value,
    types of arguments, and then the input arguments as an array. This will invoke
    the `sum` function to produce the result. We will see more about `ccall` and `cwrap`
    in later chapters. But for now, consider `ccall` a way to call the C function.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ccall` 是通过 JavaScript 从 C/C++ 代码中调用导出函数的方式。该函数接受函数名称、返回值类型、参数类型以及作为数组的输入参数。这将调用
    `sum` 函数以产生结果。我们将在后面的章节中看到更多关于 `ccall` 和 `cwrap` 的内容。但就现在而言，将 `ccall` 视为调用 C 函数的方式。'
- en: Find out more about the Emscripten source at [https://github.com/emscripten-core/emscripten](https://github.com/emscripten-core/emscripten).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://github.com/emscripten-core/emscripten](https://github.com/emscripten-core/emscripten)
    了解更多关于 Emscripten 源代码的信息。
- en: So far, we have seen how to generate asm.js files using emscripten. Let us use
    emscripten to create a WebAssembly Module to run on Node.js.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用 emscripten 生成 asm.js 文件。让我们使用 emscripten 创建一个在 Node.js 上运行的
    WebAssembly 模块。
- en: Running Hello World with Emscripten in Node.js
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Node.js 中使用 Emscripten 运行 Hello World
- en: In this section, we will see how to convert C/C++ code into the WebAssembly
    binary via Emscripten and run it along with Node.js.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何通过 Emscripten 将 C/C++ 代码转换为 WebAssembly 二进制文件，并与其在 Node.js 中一起运行。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If the terminal errors out with *emcc command not found*, your terminal environment
    might have been reset. To set up the environment, run the following command from
    inside the `emsdk` folder:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果终端出现 *emcc 命令未找到* 的错误，您的终端环境可能已被重置。要设置环境，请在 `emsdk` 文件夹内运行以下命令：
- en: '**source ./emsdk_env.sh**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**source ./emsdk_env.sh**'
- en: 'Let''s follow the tradition of Brian Kernighan, by writing "Hello, world" with
    a slight twist. Let''s do a "Hello, Web":'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们遵循布莱恩·科尼汉的传统，用一点小小的变化来编写 "Hello, world"。让我们来做 "Hello, Web":'
- en: 'First, we create a `hello_web.c` file:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `hello_web.c` 文件：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Launch your favorite editor and add the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您喜欢的编辑器并添加以下代码：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is a simple C program with a `main` function. The `main` function is the
    entry point during the runtime. When this code is compiled and executed using
    Clang (`clang sum.c && ./a.out`), "Hello, Web!" is printed. Now, instead of Clang
    (or any other compiler), let's compile the code with emcc.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 C 程序，包含一个 `main` 函数。`main` 函数是运行时的入口点。当此代码使用 Clang (`clang sum.c &&
    ./a.out`) 编译和执行时，将打印 "Hello, Web!"。现在，我们不再使用 Clang（或任何其他编译器），而是用 emcc 编译代码。
- en: 'We enter the following command to compile the code with emcc:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们输入以下命令使用 emcc 编译代码：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once completed, the following files are generated:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将生成以下文件：
- en: '`a.out.js`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.out.js`'
- en: '`a.out.wasm`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.out.wasm`'
- en: The generated JavaScript file is huge. It has more than 2,000 lines and is 109
    KB in size. We will learn how to optimize the file size later in this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 JavaScript 文件非常大。它有超过 2,000 行，大小为 109 KB。我们将在本章后面学习如何优化文件大小。
- en: 'Let''s run the generated JavaScript file using Node and that will print out
    "Hello, Web!":'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 Node 运行生成的 JavaScript 文件，这将打印出 "Hello, Web!"：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Congratulations! You just ran your first WebAssembly binary!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚运行了您的第一个 WebAssembly 二进制文件！
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Binary size matters in the world of browsers. It won't matter if your algorithm
    runs in nanoseconds if you have a huge chunk of code. The browser waits till it
    receives all the necessary information before it starts to parse and compile.
    So, it is mandatory to check the file size. *Closure Compiler* helps to minimize
    the byte code size further. Closure Compiler not only reduces the code size but
    also tries to make the code more efficient.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器世界中，二进制大小很重要。即使你的算法以纳秒级运行，如果你有一大块代码，那也无济于事。浏览器会等待收到所有必要的信息后才开始解析和编译。因此，检查文件大小是强制性的。*Closure
    Compiler*可以帮助进一步最小化字节码的大小。Closure Compiler不仅减少了代码大小，还试图使代码更加高效。
- en: 'The generated JavaScript file contains its own runtime and configuration needed
    for the JavaScript engine to execute the WebAssembly module inside the JavaScript
    engine. The generated JavaScript file creates a JavaScript module and initializes
    code for both browsers and Node.js:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的JavaScript文件包含其自己的运行时和配置，这些配置是JavaScript引擎在JavaScript引擎内部执行WebAssembly模块所需的。生成的JavaScript文件创建了一个JavaScript模块，并为浏览器和Node.js初始化了代码：
- en: In Node.js, the generated JavaScript file creates a module by reading the file
    from the local filesystem. It gets the arguments passed to the node command and
    sets them up in the module created.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js中，生成的JavaScript文件通过从本地文件系统读取文件来创建一个模块。它获取传递给node命令的参数，并在创建的模块中设置它们。
- en: In browsers, the generated JavaScript file creates a module by framing a request
    and fetches it as bytes from a URL. The browser fetches the WebAssembly binary
    from the hosted server or location and then instantiates the module.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中，生成的JavaScript文件通过发送请求并从URL获取字节来创建一个模块。浏览器从托管服务器或位置获取WebAssembly二进制文件，然后实例化该模块。
- en: The generated JavaScript file also creates a stack, memory, import, and export
    sections. We will deep dive into those sections later in this book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的JavaScript文件还创建了栈、内存、导入和导出部分。我们将在本书的后续章节中深入探讨这些部分。
- en: This generated JavaScript file is called a *binding file*. The main function
    of the binding file is to create or set an environment that enables executing
    a WebAssembly module inside the JavaScript engine. The binding file acts as a
    translator between JavaScript and WebAssembly. All the values are passed in and
    out via this binding file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成的JavaScript文件被称为*绑定文件*。绑定文件的主要功能是创建或设置一个环境，使得可以在JavaScript引擎内部执行WebAssembly模块。绑定文件充当JavaScript和WebAssembly之间的翻译器。所有值都通过这个绑定文件传入和传出。
- en: When the JavaScript file is executed via node, it does the following.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过node执行JavaScript文件时，它会做以下事情。
- en: The JavaScript engine first loads the module and then sets up the constants
    and various functions that are required for WebAssembly to execute. Then, the
    module checks where the code is being executed, whether the module is inside the
    browser or in the `Node` environment. Based on that, it fetches the file. Since
    we are running the WebAssembly Module via the node here, it fetches the file from
    the local filesystem. Then, the module is checked for any arguments provided for
    the call. If not, the JavaScript engine will check whether there are any unhandled/uncaught
    exceptions. The JavaScript engine then maps the `print out`/`print err` function
    to the console. The JavaScript engine checks whether the module loaded has all
    the required access and global variables and imports are available for execution.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎首先加载模块，然后设置WebAssembly执行所需的常量和各种函数。然后，模块检查代码正在何处执行，模块是在浏览器内部还是在`Node`环境中。基于这一点，它获取文件。由于我们在这里通过node运行WebAssembly模块，它从本地文件系统获取文件。然后，模块会检查是否提供了任何调用参数。如果没有，JavaScript引擎将检查是否有任何未处理/未捕获的异常。然后，JavaScript引擎将`print
    out`/`print err`函数映射到控制台。JavaScript引擎检查加载的模块是否具有所有必需的访问权限和全局变量以及导入，以便执行。
- en: The module goes on to initialize the stack and other required constants as well
    as the decoder and encoder for decoding and encoding the buffer, respectively.
    The encoder is responsible for translating the JavaScript values into WebAssembly-understandable
    values. The decoder is responsible for translating the WebAssembly values into
    JavaScript-understandable values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 模块继续初始化栈和其他所需的常量，以及解码器和编码器，分别用于解码和编码缓冲区。编码器负责将JavaScript值转换为WebAssembly可理解的价值。解码器负责将WebAssembly值转换为JavaScript可理解的价值。
- en: The Node.js runtime then checks the availability of the file and then initializes
    the file. The module is checked for all the WebAssembly-related function availability.
    Once everything is initialized and the module contains all the functions required,
    we will call the `run` function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 运行时会检查文件的可访问性，然后初始化文件。模块会检查所有与 WebAssembly 相关的函数可用性。一旦一切初始化完成，并且模块包含所有所需的函数，我们将调用
    `run` 函数。
- en: The `run` function instantiates the WebAssembly binary. In this case, since
    we have defined the `main` function in C, the binding file calls the `main` function
    straight away when instantiated.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 函数实例化 WebAssembly 二进制文件。在这种情况下，由于我们在 C 中定义了 `main` 函数，绑定文件在实例化时会直接调用
    `main` 函数。'
- en: 'The binding file contains the `ccall` function. The `ccall` function is an
    interface to the underlying function defined in C:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定文件包含 `ccall` 函数。`ccall` 函数是访问 C 中定义的底层函数的接口：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `ccall` function accepts the following arguments:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ccall` 函数接受以下参数：'
- en: '`ident` – The function to call; it is the function identifier defined in C.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ident` – 调用的函数；它是C语言中定义的函数标识符。'
- en: '`returnType` – The return type of the function.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returnType` – 函数的返回类型。'
- en: '`argTypes` – The argument types.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argTypes` – 参数类型。'
- en: '`args` – The arguments that are passed along with the function call.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args` – 随函数调用一起传递的参数。'
- en: '`opts` – Any other options that are required.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opts` – 所需的任何其他选项。'
- en: 'The JavaScript module exports the `cwrap` function in addition to `ccall`.
    `cwrap` is a wrapper function around the `ccall` function. While `ccall` is a
    function invocation, `cwrap` provides a function that invokes `ccall`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 模块除了 `ccall` 外还导出 `cwrap` 函数。`cwrap` 是 `ccall` 函数的包装函数。虽然 `ccall`
    是函数调用，但 `cwrap` 提供了一个调用 `ccall` 的函数：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The WebAssembly file generated consists of binary opcode to instruct the runtime
    to print "Hello, Web!". The WebAssembly file starts with `00 61 73 6d 01 00 00
    00`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 WebAssembly 文件包含用于指导运行时打印 "Hello, Web!" 的二进制操作码。WebAssembly 文件以 `00 61 73
    6d 01 00 00 00` 开头。
- en: Find out more about WebAssembly specifications at [https://webassembly.github.io/spec/](https://webassembly.github.io/spec/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://webassembly.github.io/spec/](https://webassembly.github.io/spec/)
    了解更多关于 WebAssembly 规范的信息。
- en: So far, we have seen how to generate a WebAssembly module to run on Node.js.
    Let us use emscripten to create a WebAssembly Module to run in the browser.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何生成在 Node.js 上运行的 WebAssembly 模块。让我们使用 emscripten 创建一个在浏览器中运行的
    WebAssembly 模块。
- en: Running Hello World with Emscripten in the browser
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Emscripten 在浏览器中运行 Hello World
- en: In this section, we will see how to convert C/C++ code into the WebAssembly
    binary via Emscripten and run it in the browser.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何通过 Emscripten 将 C/C++ 代码转换为 WebAssembly 二进制文件并在浏览器中运行。
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If the terminal says that the `emcc` command is not found, it is highly likely
    that you have missed setting up the environment variables. To set up the environment
    variables, run the following command from inside the `emsdk` folder: `source ./emsdk_env.sh`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果终端显示 `emcc` 命令未找到，那么很可能你遗漏了设置环境变量。要设置环境变量，请在 `emsdk` 文件夹内运行以下命令：`source ./emsdk_env.sh`
- en: 'Let''s use the same code example used in the *Generating asm.js using Emscripten*
    section . Now, instead of just running emcc, let''s pass the `-o` option and instruct
    emcc to generate the `.html` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在 *使用 Emscripten 生成 asm.js* 部分中使用的相同代码示例。现在，我们不仅运行 emcc，还传递 `-o` 选项并指示
    emcc 生成 `.html` 文件：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once completed, the following files are generated:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将生成以下文件：
- en: '`helloweb.js`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helloweb.js`'
- en: '`helloweb.wasm`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helloweb.wasm`'
- en: '`helloweb.html`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helloweb.html`'
- en: Similar to the Node example, the generated JavaScript file is huge. We will
    learn how to optimize the file size later in this chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Node.js 示例类似，生成的 JavaScript 文件非常大。我们将在本章后面学习如何优化文件大小。
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `-o` option ensures all the files generated have the name `helloweb`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o` 选项确保所有生成的文件都命名为 `helloweb`。'
- en: In order to run the generated HTML file in the browser, we will need a web server.
    The web server serves the HTML file over the HTTP protocol. Explaining web servers
    and how they work is beyond the scope of this book; refer to [https://en.wikipedia.org/wiki/Web_server](https://en.wikipedia.org/wiki/Web_server)
    for more details.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在浏览器中运行生成的 HTML 文件，我们需要一个网络服务器。网络服务器通过 HTTP 协议提供 HTML 文件。解释网络服务器及其工作原理超出了本书的范围；有关更多详细信息，请参阅
    [https://en.wikipedia.org/wiki/Web_server](https://en.wikipedia.org/wiki/Web_server)。
- en: 'Python provides an easy way to run the web server. In order to run the web
    server using Python, run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一种简单的方式来运行网络服务器。为了使用 Python 运行网络服务器，请运行以下命令：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Open `http://localhost:<port number>` to see WebAssembly in action in the browser.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `http://localhost:<端口号>` 来在浏览器中查看 WebAssembly 的实际运行情况。
- en: '![Figure 2.2 – Browser running WebAssembly'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 浏览器运行 WebAssembly'
- en: '](img/Figure_2.2_B14844.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.2_B14844.jpg)'
- en: Figure 2.2 – Browser running WebAssembly
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 浏览器运行 WebAssembly
- en: When the JavaScript file is executed via the browser, it prints out `run` function.
    The `run` function instantiates the WebAssembly binary. In this case, since we
    have defined the `main` function in C, the binding file calls the `main` function
    straight away when instantiated.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 文件通过浏览器执行时，它会打印出 `run` 函数。`run` 函数实例化了 WebAssembly 二进制文件。在这种情况下，由于我们在
    C 中定义了 `main` 函数，绑定文件在实例化时会直接调用 `main` 函数。
- en: Emscripten also provides `emrun` to run HTML files. Check out [https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html](https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html)
    for more information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 还提供了 `emrun` 来运行 HTML 文件。更多信息请查看 [https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html](https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html)。
- en: Find out more about deploying Emscripten-compiled pages at [https://emscripten.org/docs/compiling/Deploying-Pages.html](https://emscripten.org/docs/compiling/Deploying-Pages.html).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何在 [https://emscripten.org/docs/compiling/Deploying-Pages.html](https://emscripten.org/docs/compiling/Deploying-Pages.html)
    上部署 Emscripten 编译的页面。
- en: We have used Emscripten to generate the WebAssembly module. Let's go ahead and
    explore what else the emsdk can do.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 Emscripten 生成 WebAssembly 模块。让我们继续探索 emsdk 还能做什么。
- en: Exploring other options in emsdk
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 emsdk 中的其他选项
- en: emsdk is a single-stop shop for installing, maintaining, and managing all the
    tools and toolchains required for using Emscripten. emsdk makes it easier to bootstrap
    the environment, upgrade to the latest versions, switch to various versions, change
    or configure various tools, and so on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: emsdk 是一个一站式商店，用于安装、维护和管理使用 Emscripten 所需的所有工具和工具链。emsdk 使启动环境、升级到最新版本、切换到各种版本、更改或配置各种工具等变得更加容易。
- en: The `emsdk` command is available inside the `emsdk` folder. Go to the `emsdk`
    folder and run the `emsdk` command.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`emsdk` 命令在 `emsdk` 文件夹内可用。转到 `emsdk` 文件夹并运行 `emsdk` 命令。'
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For all the commands in this chapter, for *nix systems, use `./emsdk`, and for
    Windows, use `emsdk`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的所有命令，对于 *nix 系统，使用 `./emsdk`，对于 Windows，使用 `emsdk`。
- en: 'To find the various options available in the `emsdk` command, run the following
    command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找 `emsdk` 命令中可用的各种选项，请运行以下命令：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'An `emsdk` command takes the following format:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `emsdk` 命令采用以下格式：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `emsdk` command consists of the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`emsdk` 命令由以下部分组成：'
- en: '`<option>`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<选项>`'
- en: 'This can be one of the following: list, update, update-tags, install, uninstall,
    or activate.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是以下之一：list、update、update-tags、install、uninstall 或 activate。
- en: '`<Tool/SDK>`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<工具/SDK>`'
- en: This refers to libraries and it includes Emscripten and LLVM. `SDK` refers to
    emsdk itself.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这指的是库，它包括 Emscripten 和 LLVM。`SDK` 指的是 emsdk 本身。
- en: '`--<flags>`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--<标志>`'
- en: This refers to various configuration options.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这指的是各种配置选项。
- en: Let us explore each of the options and flags that emsdk command supports.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 emsdk 命令支持的每个选项和标志。
- en: Listing the tools and SDK
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出工具和 SDK
- en: 'Here, we show how to list the tools and SDK that are available with emsdk.
    Run the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了如何列出 emsdk 可用的工具和 SDK。运行以下命令：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`emsdk list` lists all tool packages and SDKs that are available. This list
    of tools and SDKs includes the last few versions of LLVM, Clang, Emscripten, and
    Binaryen. They even have Node versions 8 and 12 and Python 3.7\. emsdk maintains
    and manages `emsdk`. This means that we need to know the information about the
    current version that we are using and how to update it. The `emsdk list` command
    also provides more detail on the SDK components along with a list of those compiled
    from the sources.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`emsdk list` 列出所有可用的工具包和 SDK。这个工具和 SDK 列表包括 LLVM、Clang、Emscripten 和 Binaryen
    的最新几个版本。它们甚至有 Node 版本 8 和 12 以及 Python 3.7。emsdk 维护和管理 `emsdk`。这意味着我们需要了解我们正在使用的当前版本的信息以及如何更新它。`emsdk
    list` 命令还提供了关于 SDK 组件的更多详细信息，以及从源编译的列表。'
- en: Managing the tools and SDK
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理工具和 SDK
- en: emsdk provides an option to install, update, and uninstall the tools and SDK.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: emsdk 提供了安装、更新和卸载工具和 SDK 的选项。
- en: 'In order to install the tools, SDK, or emsdk itself, use the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装工具、SDK 或 emsdk 本身，请使用以下命令：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To install the latest version of the SDK, you can run the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 SDK 的最新版本，可以运行以下命令：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`latest` refers to the latest version of emsdk.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`latest` 指的是 emsdk 的最新版本。'
- en: 'To install multiple tools with the `emsdk install` command, use the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`emsdk install`命令安装多个工具，请使用以下命令：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can also specify multiple options for the `install` command. You can pass
    in options to the `install` command like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以为`install`命令指定多个选项。您可以通过以下方式向`install`命令传递选项：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The various `options` available are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的各种 `options` 如下所示：
- en: Number of cores to build
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建所需的核数
- en: Type of build
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建类型
- en: Activation of tools and SDK
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具和SDK的激活
- en: Uninstallation
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卸载
- en: Number of cores to build
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建所需的核数
- en: 'The initial setup will take a long time to build and install the required tools
    and SDK. Based on your requirements, you can control the number of cores that
    you need for building and installing the required tools and SDK:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 初始设置将花费较长时间构建和安装所需的工具和SDK。根据您的需求，您可以控制构建和安装所需工具和SDK所需的核数：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Type of build
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建类型
- en: 'You instruct `emsdk` on what type of build is to be used to make LLVM perform:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您指导`emsdk`使用哪种构建类型来使LLVM执行：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`type` accepts the following options:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 接受以下选项：'
- en: Debug
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: This type is used for debugging.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此类型用于调试。
- en: It generates Symbol files.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它生成符号文件。
- en: The end build will not produce optimized, fast code.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终构建将不会生成优化、快速代码。
- en: Release
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布版
- en: This type will generate optimized, fast code.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此类型将生成优化、快速代码。
- en: MinSizeRel
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MinSizeRel
- en: This type is the same as Release.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此类型与发布版相同。
- en: This type will minimize the size and maximize the speed.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此类型将最小化大小并最大化速度。
- en: This uses optimization options such as `-O1` (minimize size) and `-O2` (maximize
    speed).
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使用了优化选项，例如 `-O1`（最小化大小）和 `-O2`（最大化速度）。
- en: RelWithDebInfo
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RelWithDebInfo
- en: This type is the same as Release.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此类型与发布版相同。
- en: This type will also generate Symbol files. That will help in debugging.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此类型还将生成符号文件。这将有助于调试。
- en: Activation of the tools and SDK
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具和SDK的激活
- en: After the tools and SDK are installed, we can activate different versions to
    use them. The `activate` command generates the necessary configuration files mapping
    the path, with the built executables.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具和SDK安装后，我们可以激活不同的版本来使用它们。`activate` 命令会生成必要的配置文件，映射路径，并带有构建的可执行文件。
- en: 'To activate the tools and SDK, run the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活工具和SDK，请运行以下命令：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `activate` command accepts a few options; they are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`activate` 命令接受一些选项；如下所示：'
- en: '`--embedded` – This option makes sure all the built files, configuration, cache,
    and temporary files are located inside the directory in which the emsdk command
    is located.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--embedded` – 此选项确保所有构建的文件、配置、缓存和临时文件都位于emsdk命令所在的目录内。'
- en: If not specified, this command will move the configuration file to the user's
    home directory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定，此命令将配置文件移动到用户的主目录。
- en: '`--build=<type>` – Similar to the type of build that LLVM supports. For example,
    Debug, Release, MinSizeRel, RelWithDebInfo.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build=<type>` – 与LLVM支持的构建类型相似。例如，调试、发布、MinSizeRel、RelWithDebInfo。'
- en: Uninstallation of the tools and SDK
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具和SDK的卸载
- en: 'To uninstall the tools and SDK, we can run the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载工具和SDK，我们可以运行以下命令：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Find out more about the tools at [https://emscripten.org/docs/tools_reference/index.html](https://emscripten.org/docs/tools_reference/index.html).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://emscripten.org/docs/tools_reference/index.html](https://emscripten.org/docs/tools_reference/index.html)了解更多关于工具的信息。
- en: We have explored how emsdk helps us to manage tools and SDKs; let's go ahead
    and explore various optimizations provided by Emscripten.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了emscripten如何帮助我们管理工具和SDK；让我们继续探索Emscripten提供的各种优化。
- en: Understanding various levels of optimizations
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解各种优化级别
- en: C/C++ programs are compiled and converted into native code via Clang or the
    GCC compiler. Clang or the GCC compiler converts the C/C++ program based on the
    target. Target here refers to the end machine where the code is executed. emcc
    has the Clang compiler built in. The emcc compiler is responsible for converting
    the C or C++ source code into LLVM byte code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++程序通过Clang或GCC编译器编译并转换为本地代码。Clang或GCC编译器根据目标转换C/C++程序。这里的“目标”是指代码执行的最后机器。emcc内置了Clang编译器。emcc编译器负责将C或C++源代码转换为LLVM字节码。
- en: In this section, we will see how to improve the optimization and code size of
    the generated WebAssembly binary code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何提高生成的WebAssembly二进制代码的优化和代码大小。
- en: 'To improve the efficiency and generated code size, the Emscripten compiler
    has the following options:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率和生成的代码大小，Emscripten编译器有以下选项：
- en: Optimizations
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化
- en: Closure Compiler
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Closure Compiler
- en: Lets talk about optimizations first.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们谈谈优化。
- en: Optimizations
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: The goal of the compiler is to reduce the cost of compilation, that is, the
    compile time. With the `-O` optimization flag, the compiler tries to improve the
    code size and/or the performance at the expense of the compile time. In terms
    of compiler optimizations, code size and performance are mutually exclusive. The
    faster the compile time, the lower the optimization. To specify the optimization,
    we use the `-O<0/1/2/3/s/z>` flag. Each of the options includes various assertions,
    code size optimizations, and code performance optimizations, along with others.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的目标是减少编译成本，即编译时间。使用 `-O` 优化标志，编译器试图在编译时间上做出牺牲，以改善代码大小和/或性能。在编译器优化方面，代码大小和性能是互斥的。编译时间越快，优化级别越低。要指定优化，我们使用
    `-O<0/1/2/3/s/z>` 标志。每个选项都包括各种断言、代码大小优化和代码性能优化，以及其他优化。
- en: 'The following are the various optimizations available:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用的各种优化：
- en: '`-O0` – This is the default option and a perfect starter to experiment. This
    option means "no optimizations." This optimization level compiles the fastest
    and generates the most debuggable code. This is a basic optimization level. This
    option tries to inline functions.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O0` – 这是默认选项，是一个完美的实验起点。这个选项意味着“没有优化”。这个优化级别编译速度最快，生成的代码最易于调试。这是一个基本的优化级别。此选项尝试内联函数。'
- en: '`-O1` – This option adds simple optimizations and tries to generate a minimum
    code size. This option removes runtime assertions in the generated code and builds
    slower than the `-O0` option. This option also tries to simplify the loops.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O1` – 这个选项添加了简单的优化，并尝试生成最小的代码大小。此选项在生成的代码中移除了运行时断言，并且构建速度比 `-O0` 选项慢。此选项还尝试简化循环。'
- en: '`-O2` – This option adds further optimizations than `-O1`. It is slower than
    `-O1` but generates code that is more optimized than the `-O1` option. This option
    optimizes the code based on JavaScript optimization and removes code that is not
    part of JavaScript modules. This option removes the inline functions and the `vectorize-loop`
    option is set. This option adds a moderate level of optimization. This option
    also adds dead code elimination.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O2` – 这个选项比 `-O1` 添加了更多的优化。它比 `-O1` 慢，但生成的代码比 `-O1` 选项更优化。此选项基于 JavaScript
    优化进行代码优化，并移除不属于 JavaScript 模块的代码。此选项移除了内联函数，并将 `vectorize-loop` 选项设置为开启。此选项添加了适度的优化级别。此选项还添加了死代码消除。'
- en: Vectorization will instruct the processor to do the operation in chunks rather
    than doing it one by one.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化将指示处理器以块的形式执行操作，而不是逐个执行。
- en: '`-O3` – This option adds more options, takes more time to compile, and generates
    more optimized code than the `-O2` option.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O3` – 这个选项添加了更多选项，编译时间更长，生成的代码比 `-O2` 选项更优化。'
- en: This option produces optimal production-ready code. This option is like `-O2`,
    except that it enables optimizations that take longer to perform or that may generate
    larger code (in an attempt to make the program run faster).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项生成最优的生产就绪代码。这个选项类似于 `-O2`，但开启了需要更长时间执行或可能生成更大代码的优化（试图使程序运行更快）。
- en: '`-Os` – This option is similar to `-O2`. It adds extra optimizations and reduces
    the code size. Reducing the code size in turn decreases the performance. This
    option generates smaller code than `-O2`.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Os` – 这个选项与 `-O2` 类似。它添加了额外的优化并减少了代码大小。减少代码大小反过来会降低性能。此选项生成的代码比 `-O2` 更小。'
- en: '`-Oz` – This option is similar to `-Os` but reduces the code size even further.
    This option takes more compile time to generate the binary code.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Oz` – 这个选项类似于 `-Os`，但进一步减少了代码大小。此选项生成二进制代码需要更多的编译时间。'
- en: 'We will now explore the various optimization options provided by Emscripten:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探索 Emscripten 提供的各种优化选项：
- en: 'First, we create a C file called `optimization_check`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `optimization_check` 的 C 文件：
- en: '[PRE33]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, open your favorite editor and add the following code. The following is
    a simple C file with a `main` function and a couple of other functions:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开你最喜欢的编辑器并添加以下代码。以下是一个简单的 C 文件，包含一个 `main` 函数和其他几个函数：
- en: '[PRE34]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then compile this into WebAssembly code using emcc:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 emcc 将其编译成 WebAssembly 代码：
- en: '[PRE35]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, check the sizes of the file generated:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，检查生成的文件大小：
- en: '[PRE36]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can see that the WebAssembly file generated is about 13 KB and it took a
    total of 0.514 seconds to compile. That is a fast compilation but the code size
    is huge.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到生成的 WebAssembly 文件大约有 13 KB，总共花费了 0.514 秒来编译。这是一个快速的编译，但代码大小很大。
- en: In the world of compilers, the faster the compilation, the bigger the code size
    and the slower the execution speed will be.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器的世界中，编译速度越快，代码大小越大，执行速度越慢。
- en: 'Now, let''s optimize it further using the `-O1` option:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `-O1` 选项进一步优化它：
- en: '[PRE37]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Check the sizes of the file generated:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的文件大小：
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The WebAssembly file generated is about 3.4 KB (3.8 times less than the `-O0`
    version) and it took almost the same time, around 0.519 seconds.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 WebAssembly 文件大约是 3.4 KB（比 `-O0` 版本少 3.8 倍），并且花费了几乎相同的时间，大约 0.519 秒。
- en: 'Now, let''s optimize it further using the `-O2` option:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `-O2` 选项进一步优化它：
- en: '[PRE39]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Check the sizes of the file generated:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的文件大小：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The WebAssembly file generated is about 2 KB (~6.5 times less than `-O0`) and
    it took around 0.62 seconds.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 WebAssembly 文件大约是 2 KB（比 `-O0` 少约 6.5 倍），花费了大约 0.62 秒。
- en: 'Now, let''s optimize it further using the `-O3` option:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `-O3` 选项进一步优化它：
- en: '[PRE41]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Find out more about the `--profiling` flag at [https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling](https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling](https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling)
    了解更多关于 `--profiling` 标志的信息。
- en: 'Check the sizes of the file generated:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的文件大小：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The WebAssembly file generated is the same size as `-02` but the generated JavaScript
    file is 3 KB less, and it took around 1.117 seconds to compile.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 WebAssembly 文件与 `-02` 的大小相同，但生成的 JavaScript 文件少 3 KB，编译时间大约为 1.117 秒。
- en: 'Now, let''s optimize it further using the `-Os` option:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `-Os` 选项进一步优化它：
- en: '[PRE43]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Check the sizes of the file generated:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的文件大小：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The WebAssembly file generated is about 1.7 KB (~7.5 times less than `-O0`)
    and it took almost 2.655 seconds.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 WebAssembly 文件大约是 1.7 KB（比 `-O0` 少约 7.5 倍），花费了大约 2.655 秒。
- en: 'Now, let''s optimize it further using the `-Oz` option:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `-Oz` 选项进一步优化它：
- en: '[PRE45]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Check the sizes of the file generated:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的文件大小：
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The WebAssembly file generated is about 1.7 KB (~7.5 times less than `-O0`)
    and it took around 1.123 seconds.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 WebAssembly 文件大约是 1.7 KB（比 `-O0` 少约 7.5 倍），花费了大约 1.123 秒。
- en: 'Next, we''ll see an alternative means provided by the Emscripten compiler for
    improving the efficiency and reducing the generated code size: Closure Compiler'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到 Emscripten 编译器提供的另一种提高效率和减少生成代码大小的手段：Closure Compiler
- en: Closure Compiler
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Closure Compiler
- en: Closure Compiler is a tool for compiling JavaScript to better JavaScript. It
    parses, analyzes, removes dead code, rewrites, and minimizes JavaScript. Further
    optimizations on the generated binding JavaScript file and WebAssembly module
    are done using Closure Compiler. With Closure Compiler, we can do better optimizations
    on Emscripten code. To optimize the WebAssembly module and JavaScript further,
    we can use `--closure <optimization type>`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Closure Compiler 是一个将 JavaScript 编译成更优 JavaScript 的工具。它解析、分析、删除死代码、重写和最小化 JavaScript。对生成的绑定
    JavaScript 文件和 WebAssembly 模块进行的进一步优化使用 Closure Compiler 完成。使用 Closure Compiler，我们可以对
    Emscripten 代码进行更好的优化。为了进一步优化 WebAssembly 模块和 JavaScript，我们可以使用 `--closure <优化类型>`。
- en: 'The `optimization` type has the following options:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`优化` 类型有以下选项：'
- en: '`--closure 0` – This option adds no Closure Compiler optimizations.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--closure 0` – 此选项不添加任何 Closure Compiler 优化。'
- en: '`--closure 1` – This option reduces the generated JavaScript code size. This
    option does not optimize the asm.js and WebAssembly binary. This adds an additional
    compilation step that increases the compilation time.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--closure 1` – 此选项减少生成的 JavaScript 代码大小。此选项不优化 asm.js 和 WebAssembly 二进制文件。此选项添加了一个额外的编译步骤，增加了编译时间。'
- en: '`--closure 2` – This option optimizes JavaScript, asm.js, and not the WebAssembly
    binary and reduces the code size of the file drastically for asm.js.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--closure 2` – 此选项优化 JavaScript、asm.js，但不优化 WebAssembly 二进制文件，并且显著减少了文件的代码大小。'
- en: 'We will use the `–closure 1` option to optimize the WebAssembly binary along
    with the`–O3/s` Emscripten optimization options:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `–closure 1` 选项来优化 WebAssembly 二进制文件，同时使用 `–O3/s` Emscripten 优化选项：
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The file sizes generated are as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件大小如下：
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Along with `emcc –O3`, we pass `–closure 1` to further optimize the generated
    files. Closure Compiler reduces the size of the JavaScript file by 50% when compared
    to the `emcc -O3` option and it took 2.681 seconds to compile:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `emcc –O3`，我们还传递 `–closure 1` 以进一步优化生成的文件。与 `emcc -O3` 选项相比，Closure Compiler
    将 JavaScript 文件的大小减少了 50%，编译时间为 2.681 秒：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s list the files in the current folder to check the generated files and
    their size:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出当前文件夹中的文件，以检查生成的文件及其大小：
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Along with `emcc –Os`, we pass `–closure 1` to further optimize the generated
    binary. Closure Compiler reduces the `.wasm` file a little bit more with the `emcc
    -Os` option, and it took 2.778 seconds to compile.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`emcc –Os`之外，我们还会传递`–closure 1`来进一步优化生成的二进制文件。使用`emcc -Os`选项，Closure Compiler可以进一步减少`.wasm`文件的大小，编译耗时2.778秒。
- en: Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When optimizing for size, try to use both `-O3` or `-Os` along with `--closure
    1` to optimize both JavaScript and the WebAssembly module.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化大小的时候，尝试同时使用`-O3`或`-Os`以及`--closure 1`来优化JavaScript和WebAssembly模块。
- en: Check out more various options and flags at [https://emscripten.org/docs/tools_reference/emcc.html](https://emscripten.org/docs/tools_reference/emcc.html)
    [https://clang.llvm.org/docs/CommandGuide/clang.html](https://clang.llvm.org/docs/CommandGuide/clang.html).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://emscripten.org/docs/tools_reference/emcc.html](https://emscripten.org/docs/tools_reference/emcc.html)
    [https://clang.llvm.org/docs/CommandGuide/clang.html](https://clang.llvm.org/docs/CommandGuide/clang.html)查看更多选项和标志。
- en: Find out more about various available optimization options at [https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017](https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017](https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017)了解更多关于各种可用的优化选项。
- en: Learn more about Closure Compiler at [https://developers.google.com/closure/compiler](https://developers.google.com/closure/compiler).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developers.google.com/closure/compiler](https://developers.google.com/closure/compiler)了解更多关于Closure
    Compiler的信息。
- en: Find out more about optimizing large code bases with Emscripten at [https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases](https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases](https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases)了解更多关于使用Emscripten优化大型代码库的信息。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to install and use Emscripten to compile C/C++
    into a WebAssembly module. We also explored the emsdk tool and various levels
    of optimizations when generating the WebAssembly module. In the next chapter,
    we will explore the WebAssembly module.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何安装和使用Emscripten将C/C++编译成WebAssembly模块。我们还探讨了emsdk工具以及生成WebAssembly模块时的各种优化级别。在下一章中，我们将探索WebAssembly模块。
