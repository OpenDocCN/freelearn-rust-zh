["```rs\nfutures = \"0.1.18\"\nhyper = \"0.11.21\"\n```", "```rs\n1   extern crate futures;\n2   extern crate hyper;\n3   \n4   use futures::future::Future;\n5   use hyper::header::{ContentLength, ContentType};\n6   use hyper::server::{const_service, service_fn, Http, Request, Response, Service};\n7   use std::net::SocketAddr;\n8   \n9   const MESSAGE: &str = \"Hello World!\";\n10  \n11  fn main() {\n12    // [::1] is the loopback address for IPv6, 3000 is a port\n13    let addr = \"[::1]:3000\".parse().expect(\"Failed to parse address\");\n14    run_with_service_function(&addr).expect(\"Failed to run web server\");\n15  }\n```", "```rs\n17  fn run_with_service_function(addr: &SocketAddr) -> Result<(), \n     hyper::Error> {\n18    // Hyper is based on Services, which are construct that\n19    // handle how to respond to requests.\n20    // const_service and service_fn are convenience functions\n21    // that build a service out of a closure\n22    let hello_world = const_service(service_fn(|_| {\n23      println!(\"Got a connection!\");\n24      // Return a Response with a body of type hyper::Body\n25      Ok(Response::::new()\n26        // Add header specifying content type as plain text\n27        .with_header(ContentType::plaintext())\n28        // Add header specifying the length of the message in \n          bytes\n29        .with_header(ContentLength(MESSAGE.len() as u64))\n30        // Add body with our message\n31        .with_body(MESSAGE))\n32    }));\n33  \n34    let server = Http::new().bind(addr, hello_world)?;\n35    server.run()\n36  }\n```", "```rs\n38  // The following function does the same, but uses an explicitely \n    created\n39  // struct HelloWorld that implements the Service trait\n40  fn run_with_service_struct(addr: &SocketAddr) -> Result<(), \n     hyper::Error> {\n41    let server = Http::new().bind(addr, || Ok(HelloWorld))?;\n42    server.run()\n43  }\n44  \n45  struct HelloWorld;\n46  impl Service for HelloWorld {\n47    // Implementing a server requires specifying all involved \n      types\n48    type Request = Request;\n49    type Response = Response;\n50    type Error = hyper::Error;\n51    // The future that wraps your eventual Response\n52    type Future = Box<Future>;\n53  \n54    fn call(&self, _: Request) -> Self::Future {\n55      // In contrast to service_fn, we need to explicitely return \n        a future\n56      Box::new(futures::future::ok(\n57        Response::new()\n58          .with_header(ContentType::plaintext())\n59          .with_header(ContentLength(MESSAGE.len() as u64))\n60          .with_body(MESSAGE),\n61      ))\n62    }\n63  }\n```", "```rs\npub trait Service where\n    <Self::Future as Future>::Item == Self::Response,\n    <Self::Future as Future>::Error == Self::Error, {\n    type Request;\n    type Response;\n    type Error;\n    type Future: Future;\n    fn call(&self, req: Self::Request) -> Self::Future;\n}\n```", "```rs\nstruct HelloWorld;\nimpl Service for HelloWorld {\n    type Request = Request;\n    type Response = Response;\n    type Error = hyper::Error;\n    type Future = Box<Future<Item = Self::Response, Error = \n    Self::Error>>;\n\n    fn call(&self, _: Request) -> Self::Future {\n        Box::new(futures::future::ok(\n            Response::new()\n                .with_header(ContentType::plaintext())\n                .with_header(ContentLength(MESSAGE.len() as u64))\n                .with_body(MESSAGE),\n        ))\n    }\n}\n```", "```rs\nInvoke-WebRequest -UseBasicParsing <Your URL> -Method <Your method in CAPSLOCK> -Body <Your message as a string>\n```", "```rs\nInvoke-WebRequest -UseBasicParsing http://localhost:3000/echo -Method POST -Body \"Hello there, my echoing friend\"\n```", "```rs\ncurl -X <Your method> --data <Your message> -g <Your URL>\n```", "```rs\ncurl -X POST --data \"Hello there my echoing friend\" -g \"http://[::1]:3000/echo\"\n```", "```rs\nfutures = \"0.1.18\"\nhyper = \"0.11.21\"\n```", "```rs\n1   extern crate hyper;\n2\n3   use hyper::{Method, StatusCode};\n4   use hyper::server::{const_service, service_fn, Http, Request, \n    Response};\n5   use hyper::header::{ContentLength, ContentType};\n6   use std::net::SocketAddr;\n7\n8   fn main() {\n9     let addr = \"[::1]:3000\".parse().expect(\"Failed to parse \n      address\");\n10    run_echo_server(&addr).expect(\"Failed to run web server\");\n11  }\n12\n13  fn run_echo_server(addr: &SocketAddr) -> Result<(),  \n    hyper::Error> {\n14    let echo_service = const_service(service_fn(|req: Request| {\n15      // An easy way to implement routing is\n16      // to simply match the request's path\n17      match (req.method(), req.path()) {\n18        (&Method::Get, \"/\") => handle_root(),\n19        (&Method::Post, \"/echo\") => handle_echo(req),\n20        _ => handle_not_found(),\n21      }\n22    }));\n23\n24    let server = Http::new().bind(addr, echo_service)?;\n25    server.run()\n26  }\n```", "```rs\n28  type ResponseResult = Result<Response, hyper::Error>;\n29  fn handle_root() -> ResponseResult {\n30    const MSG: &str = \"Try doing a POST at /echo\";\n31    Ok(Response::new()\n32      .with_header(ContentType::plaintext())\n33      .with_header(ContentLength(MSG.len() as u64))\n34      .with_body(MSG))\n35  }\n36\n37  fn handle_echo(req: Request) -> ResponseResult {\n38    // The echoing is implemented by setting the response's\n39    // body to the request's body\n40    Ok(Response::new().with_body(req.body()))\n41  }\n42\n43  fn handle_not_found() -> ResponseResult {\n44    // Return a 404 for every unsupported route\n45    Ok(Response::new().with_status(StatusCode::NotFound))\n46  }\n```", "```rs\n|req: Request| {\n    match (req.method(), req.path()) {\n        (&Method::Get, \"/\") => handle_root(),\n        (&Method::Post, \"/echo\") => handle_echo(req),\n        _ => handle_not_found(),\n    }\n}\n```", "```rs\nfutures = \"0.1.18\"\nhyper = \"0.11.21\"\n```", "```rs\n<!doctype html>\n<html>\n\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\">\n    <title>Home</title>\n</head>\n\n<body>\n    <h1>Home</h1>\n    <p>Welcome. You can access other files on this web server  \n    aswell! Available links:</p>\n    <ul>\n        <li>\n            <a href=\"/foo.html\">Foo!</a>\n        </li>\n        <li>\n            <a href=\"/bar.html\">Bar!</a>\n        </li>\n    </ul>\n</body>\n\n</html>\n```", "```rs\n<!doctype html>\n<html>\n\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\">\n    <title>Foo</title>\n</head>\n\n<body>\n    <p>Foo!</p>\n</body>\n\n</html>\n```", "```rs\n<!doctype html>\n<html>\n\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\">\n    <title>Bar</title>\n</head>\n\n<body>\n    <p>Bar!</p>\n</body>\n\n</html>\n```", "```rs\n<!doctype html>\n<html>\n\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\">\n    <title>Page Not Found</title>\n</head>\n\n<body>\n    <h1>Page Not Found</h1>\n    <p>We're sorry, we couldn't find the page you requested.</p>\n    <p>Maybe it was renamed or moved?</p>\n    <p>Try searching at the\n        <a href=\"/index.html\">start page</a>\n    </p>\n</body>\n\n</html>\n```", "```rs\n<!doctype html>\n<html>\n\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\">\n    <title>Error 405 (Method Not Allowed)</title>\n</head>\n\n<body>\n    <h1>Error 405</h1>\n    <p>The method used is not allowed for this URL</p>\n</body>\n\n</html>\n```", "```rs\n1   extern crate futures;\n2   extern crate hyper;\n3\n4   use hyper::{Method, StatusCode};\n5   use hyper::server::{const_service, service_fn, Http, Request,  \n    Response};\n6   use hyper::header::{ContentLength, ContentType};\n7   use hyper::mime;\n8   use futures::Future;\n9   use futures::sync::oneshot;\n10  use std::net::SocketAddr;\n11  use std::thread;\n12  use std::fs::File;\n13  use std::io::{self, copy};\n14\n15  fn main() {\n16    let addr = \"[::1]:3000\".parse().expect(\"Failed to parse \n      address\");\n17    run_file_server(&addr).expect(\"Failed to run web server\");\n18  }\n19\n20  fn run_file_server(addr: &SocketAddr) -> Result<(), \n    hyper::Error> {\n21    let file_service = const_service(service_fn(|req: Request| {\n22      // Setting up our routes\n23      match (req.method(), req.path()) {\n24        (&Method::Get, \"/\") => handle_root(),\n25        (&Method::Get, path) => handle_get_file(path),\n26        _ => handle_invalid_method(),\n27      }\n28    }));\n29\n30    let server = Http::new().bind(addr, file_service)?;\n31    server.run()\n32  }\n```", "```rs\n34  // Because we don't want the entire server to block when serving \n     a file,\n35  // we are going to return a response wrapped in a future\n36  type ResponseFuture = Box<Future>;\n37  fn handle_root() -> ResponseFuture {\n38    // Send the landing page\n39    send_file_or_404(\"index.html\")\n40  }\n41\n42  fn handle_get_file(file: &str) -> ResponseFuture {\n43    // Send whatever page was requested or fall back to a 404 page\n44    send_file_or_404(file)\n45  }\n46\n47  fn handle_invalid_method() -> ResponseFuture {\n48    // Send a page telling the user that the method he used is not   \n      supported\n49    let response_future = send_file_or_404(\"invalid_method.html\")\n50      // Set the correct status code\n51      .and_then(|response| \n        Ok(response.with_status(StatusCode::MethodNotAllowed)));\n52    Box::new(response_future)\n53  }\n```", "```rs\n55  // Send a future containing a response with the requested file  \n    or a 404 page\n56  fn send_file_or_404(path: &str) -> ResponseFuture {\n57    // Sanitize the input to prevent unwanted data access\n58    let path = sanitize_path(path);\n59\n60    let response_future = try_to_send_file(&path)\n61      // try_to_send_file returns a future of Result<Response, \n        io::Error>\n62      // turn it into a future of a future of Response with an \n        error of hyper::Error\n63      .and_then(|response_result| response_result.map_err(|error| \n         error.into()))\n64      // If something went wrong, send the 404 page instead\n65      .or_else(|_| send_404());\n66    Box::new(response_future)\n67  }\n68\n69  // Return a requested file in a future of Result<Response, \n    io::Error>\n70  // to indicate whether it exists or not\n71  type ResponseResultFuture = Box<Future, Error = hyper::Error>>;\n72  fn try_to_send_file(file: &str) -> ResponseResultFuture {\n73    // Prepend \"files/\" to the file\n74    let path = path_on_disk(file);\n75    // Load the file in a separate thread into memory.\n76    // As soon as it's done, send it back through a channel\n77    let (tx, rx) = oneshot::channel();\n78    thread::spawn(move || {\n79      let mut file = match File::open(&path) {\n80        Ok(file) => file,\n81        Err(err) => {\n82          println!(\"Failed to find file: {}\", path);\n83          // Send error through channel\n84          tx.send(Err(err)).expect(\"Send error on file not \n            found\");\n85          return;\n86        }\n87      };\n88\n89      // buf is our in-memory representation of the file\n90      let mut buf: Vec = Vec::new();\n91      match copy(&mut file, &mut buf) {\n92        Ok(_) => {\n93          println!(\"Sending file: {}\", path);\n94          // Detect the content type by checking the file \n            extension\n95          // or fall back to plaintext\n96          let content_type = \n            get_content_type(&path).unwrap_or_else\n            (ContentType::plaintext);\n97          let res = Response::new()\n98            .with_header(ContentLength(buf.len() as u64))\n99            .with_header(content_type)\n100           .with_body(buf);\n101         // Send file through channel\n102         tx.send(Ok(res))\n103           .expect(\"Send error on successful file read\");\n104       }\n105       Err(err) => {\n106         // Send error through channel\n107         tx.send(Err(err)).expect(\"Send error on error reading \n            file\");\n108       }\n109     };\n110   });\n111   // Convert all encountered errors to hyper::Error\n112   Box::new(rx.map_err(|error|  \n      io::Error::new(io::ErrorKind::Other, \n      error).into()))\n113 }\n114\n115 fn send_404() -> ResponseFuture {\n116   // Try to send our 404 page\n117   let response_future = \n      try_to_send_file(\"not_found.html\").and_then(|response_result|   \n      {\n118     Ok(response_result.unwrap_or_else(|_| {\n119       // If the 404 page doesn't exist, sent fallback text  \n          instead\n120       const ERROR_MSG: &str = \"Failed to find \\\"File not found\\\" \n          page. How ironic\\n\";\n121       Response::new()\n122         .with_status(StatusCode::NotFound)\n123         .with_header(ContentLength(ERROR_MSG.len() as u64))\n124         .with_body(ERROR_MSG)\n125     }))\n126   });\n127   Box::new(response_future)\n128 }\n```", "```rs\n130  fn sanitize_path(path: &str) -> String {\n131    // Normalize the separators for the next steps\n132    path.replace(\"\\\\\", \"/\")\n133      // Prevent the user from going up the filesystem\n134      .replace(\"../\", \"\")\n135      // If the path comes straigh from the router,\n136      // it will begin with a slash\n137      .trim_left_matches(|c| c == '/')\n138      // Remove slashes at the end as we only serve files\n139      .trim_right_matches(|c| c == '/')\n140      .to_string()\n141  }\n142\n143  fn path_on_disk(path_to_file: &str) -> String {\n144    \"files/\".to_string() + path_to_file\n145  }\n146\n147  fn get_content_type(file: &str) -> Option {\n148    // Check the file extension and return the respective MIME type\n149   let pos = file.rfind('.')? + 1;\n150   let mime_type = match &file[pos..] {\n151     \"txt\" => mime::TEXT_PLAIN_UTF_8,\n152     \"html\" => mime::TEXT_HTML_UTF_8,\n153     \"css\" => mime::TEXT_CSS,\n154     // This list can be extended for all types your server \n        should support\n155     _ => return None,\n156   };\n157   Some(ContentType(mime_type))\n158 }\n```", "```rs\ntype ResponseFuture = Box<Future<Item = Response, Error = hyper::Error>>;\n```", "```rs\nfn send_file_or_404(path: &str) -> ResponseFuture {\n    let path = sanitize_path(path);\n\n    let response_future = try_to_send_file(&path)\n        .and_then(|response_result| response_result.map_err(|error| \n         error.into()))\n        .or_else(|_| send_404());\n    Box::new(response_future)\n}\n```", "```rs\n\"files/\".to_string() + path_to_file\n```", "```rs\nfn get_content_type(file: &str) -> Option<ContentType> {\n    let pos = file.rfind('.')? + 1;\n    let mime_type = match &file[pos..] {\n        \"txt\" => mime::TEXT_PLAIN_UTF_8,\n        \"html\" => mime::TEXT_HTML_UTF_8,\n        \"css\" => mime::TEXT_CSS,\n        _ => return None,\n    };\n    Some(ContentType(mime_type))\n}\n```", "```rs\nreqwest = \"0.8.5\"\nserde = \"1.0.30\"\nserde_derive = \"1.0.30\"\n```", "```rs\n1   extern crate reqwest;\n2   #[macro_use]\n3   extern crate serde_derive;\n4   \n5   use std::fmt;\n6   \n7   #[derive(Serialize, Deserialize, Debug)]\n8   // The JSON returned by the web service that hands posts out\n9   // it written in camelCase, so we need to tell serde about that\n10  #[serde(rename_all = \"camelCase\")]\n11  struct Post {\n12    user_id: u32,\n13    id: u32,\n14    title: String,\n15    body: String,\n16  }\n17  \n18  #[derive(Serialize, Deserialize, Debug)]\n19  #[serde(rename_all = \"camelCase\")]\n20  struct NewPost {\n21    user_id: u32,\n22    title: String,\n23    body: String,\n24  }\n25  \n26  #[derive(Serialize, Deserialize, Debug)]\n27  #[serde(rename_all = \"camelCase\")]\n28  // The following struct could be rewritten with a builder\n29  struct UpdatedPost {\n30    #[serde(skip_serializing_if = \"Option::is_none\")]\n31    user_id: Option,\n32    #[serde(skip_serializing_if = \"Option::is_none\")]\n33    title: Option,\n34    #[serde(skip_serializing_if = \"Option::is_none\")]\n35    body: Option,\n36  }\n37  \n38  struct PostCrud {\n39    client: reqwest::Client,\n40    endpoint: String,\n41  }\n42  \n43  impl fmt::Display for Post {\n44    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n45      write!(\n46        f,\n47        \"User ID: {}\\nID: {}\\nTitle: {}\\nBody: {}\\n\",\n48        self.user_id, self.id, self.title, self.body\n49      )\n50    }\n51  }\n```", "```rs\n53  impl PostCrud {\n54    fn new() -> Self {\n55      PostCrud {\n56        // Build an HTTP client. It's reusable!\n57        client: reqwest::Client::new(),\n58        // This is a link to a fake REST API service\n59        endpoint: \n          \"https://jsonplaceholder.typicode.com/posts\".to_string(),\n60      }\n61    }\n62  \n63    fn create(&self, post: &NewPost) -> Result<Post, \n      reqwest::Error> {\n64      let response = \n        self.client.post(&self.endpoint).json(post).send()?.json()?;\n65      Ok(response)\n66    }\n67  \n68    fn read(&self, id: u32) -> Result<Post, reqwest::Error> {\n69      let url = format!(\"{}/{}\", self.endpoint, id);\n70      let response = self.client.get(&url).send()?.json()?;\n71      Ok(response)\n72    }\n73  \n74    fn update(&self, id: u32, post: &UpdatedPost) -> Result<Post, \n      reqwest::Error> {\n75      let url = format!(\"{}/{}\", self.endpoint, id);\n76      let response = \n        self.client.patch(&url).json(post).send()?.json()?;\n77      Ok(response)\n78    }\n79  \n80    fn delete(&self, id: u32) -> Result<(), reqwest::Error> {\n81      let url = format!(\"{}/{}\", self.endpoint, id);\n82      self.client.delete(&url).send()?;\n83      Ok(())\n84    }\n85  }\n```", "```rs\n87  fn main() {\n88    let post_crud = PostCrud::new();\n89    let post = post_crud.read(1).expect(\"Failed to read post\");\n90    println!(\"Read a post:\\n{}\", post);\n91  \n92    let new_post = NewPost {\n93      user_id: 2,\n94      title: \"Hello World!\".to_string(),\n95      body: \"This is a new post, sent to a fake JSON API \n        server.\\n\".to_string(),\n96    };\n97    let post = post_crud.create(&new_post).expect(\"Failed to  \n      create post\");\n98    println!(\"Created a post:\\n{}\", post);\n99  \n100   let updated_post = UpdatedPost {\n101     user_id: None,\n102     title: Some(\"New title\".to_string()),\n103     body: None,\n104   };\n105   let post = post_crud\n106     .update(4, &updated_post)\n107     .expect(\"Failed to update post\");\n108   println!(\"Updated a post:\\n{}\", post);\n109 \n110   post_crud.delete(51).expect(\"Failed to delete post\");\n111 }\n```", "```rs\n#[serde(skip_serializing_if = \"Option::is_none\")]\n```"]