["```rs\n// Thread A\n\nNode get(List list) {\n    if (list.head != NULL) {\n        return list.head\n    }\n}\n\n// Thread B\nlist.head = NULL\n```", "```rs\n// thread_basics.rs\n\nuse std::thread;\n\nfn main() {\n    thread::spawn(|| {\n        println!(\"Thread!\");\n        \"Much concurrent, such wow!\".to_string()\n    });\n    print!(\"Hello \");\n}\n```", "```rs\n$ rustc thread_basics.rs\n$ ./thread_basics\nHello\n```", "```rs\nlet child = thread::spawn(|| {\n    print!(\"Thread!\");\n    String::from(\"Much concurrent, such wow!\")\n});\n```", "```rs\nlet value = child.join().expect(\"Failed joining child thread\");\n```", "```rs\n// thread_basics_join.rs\n\nuse std::thread;\n\nfn main() {\n    let child = thread::spawn(|| {\n        println!(\"Thread!\");\n        String::from(\"Much concurrent, such wow!\")\n    });\n\n    print!(\"Hello \");\n    let value = child.join().expect(\"Failed joining child thread\");\n    println!(\"{}\", value);\n}\n```", "```rs\n$ ./thread_basics_join\nHello Thread!\nMuch concurrent, such wow!\n```", "```rs\n// customize_threads.rs\n\nuse std::thread::Builder;\n\nfn main() {\n    let my_thread = Builder::new().name(\"Worker Thread\".to_string())\n                                  .stack_size(1024 * 4);\n    let handle = my_thread.spawn(|| {\n        panic!(\"Oops!\");\n    });\n    let child_status = handle.unwrap().join();\n    println!(\"Child status: {}\", child_status);\n}\n```", "```rs\n$ ./customize_threads \nthread 'Worker Thread' panicked at 'Oops!', customize_threads.rs:9:9\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\nChild status: Err(Any)\n```", "```rs\n// thread_read.rs\n\nuse std::thread;\n\nfn main() {\n    let nums = vec![0, 1, 2, 3, 4];\n    for n in 0..5 {\n        thread::spawn(|| {\n            println!(\"{}\", nums[n]);\n        });\n    }\n}\n```", "```rs\n// thread_moves.rs\n\nuse std::thread;\n\nfn main() {\n    let my_str = String::from(\"Damn you borrow checker!\");\n    let _ = thread::spawn(move || {\n        println!(\"In thread: {}\", my_str);\n    });\n    println!(\"In main: {}\", my_str);\n}\n```", "```rs\n// thread_rc.rs\n\nuse std::thread;\nuse std::rc::Rc;\n\nfn main() {\n    let nums = Rc::new(vec![0, 1, 2, 3, 4]);\n    let mut childs = vec![];\n    for n in 0..5 {\n        let ns = nums.clone();\n        let c = thread::spawn(|| {\n            println!(\"{}\", ns[n]);\n        });\n        childs.push(c);\n    }\n\n    for c in childs {\n        c.join().unwrap();\n    }\n}\n```", "```rs\n// thread_arc.rs\n\nuse std::thread;\nuse std::sync::Arc;\n\nfn main() {\n    let nums = Arc::new(vec![0, 1, 2, 3, 4]);\n    let mut childs = vec![];\n    for n in 0..5 {\n        let ns = Arc::clone(&nums);\n        let c = thread::spawn(move || {\n            println!(\"{}\", ns[n]);\n        });\n\n        childs.push(c);\n    }\n\n    for c in childs {\n        c.join().unwrap();\n    }\n} \n```", "```rs\n$ rustc thread_arc.rs\n$./thread_arc\n0\n2\n1\n3\n4\n```", "```rs\n// thread_mut.rs\n\nuse std::thread;\nuse std::sync::Arc;\n\nfn main() {\n    let mut nums = Arc::new(vec![]);\n    for n in 0..5 {\n        let mut ns = nums.clone();\n        thread::spawn(move || {\n            nums.push(n);\n        });\n    }\n}\n```", "```rs\n// mutex_basics.rs\n\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let m = Mutex::new(0);\n    let c = thread::spawn(move || {\n        {\n            *m.lock().unwrap() += 1;\n        }\n        let updated = *m.lock().unwrap();\n        updated\n    });\n    let updated = c.join().unwrap();\n    println!(\"{:?}\", updated);\n}\n```", "```rs\n// arc_mutex.rs\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let vec = Arc::new(Mutex::new(vec![]));\n    let mut childs = vec![];\n    for i in 0..5 {\n        let mut v = vec.clone();\n        let t = thread::spawn(move || {\n            let mut v = v.lock().unwrap(); \n            v.push(i);\n        });\n        childs.push(t);\n    }\n\n    for c in childs {\n        c.join().unwrap();\n    }\n\n    println!(\"{:?}\", vec);\n}\n```", "```rs\n$ rustc arc_mutex.rs\n$ ./arc_mutex Mutex { data: [0,1,2,3,4] }\n```", "```rs\n// thread_rwlock.rs\n\nuse std::sync::RwLock;\nuse std::thread;\n\nfn main() {\n    let m = RwLock::new(5);\n    let c = thread::spawn(move || {\n        {\n            *m.write().unwrap() += 1;\n        }\n        let updated = *m.read().unwrap();\n        updated\n    });\n    let updated = c.join().unwrap();\n    println!(\"{:?}\", updated);\n}\n```", "```rs\n// async_channels.rs\n\nuse std::thread;\nuse std::sync::mpsc::channel;\n\nfn main() {\n    let (tx, rx) = channel();\n    let join_handle = thread::spawn(move || {\n        while let Ok(n) = rx.recv() {\n            println!(\"Received {}\", n);\n        }\n    });\n\n    for i in 0..10 {\n        tx.send(i).unwrap();\n    }\n\n    join_handle.join().unwrap();\n}\n```", "```rs\n    let join_handle = thread::spawn(move || {\n        // Keep receiving in a loop, until tx is dropped!\n        while let Ok(n) = rx.recv() { // Note: `recv()` always blocks\n            println!(\"Received {}\", n);\n        }\n    });\n```", "```rs\n// sync_channels.rs\n\nuse std::thread; \nuse std::sync::mpsc; \n\nfn main() { \n    let (tx, rx) = mpsc::sync_channel(1);\n    let tx_clone = tx.clone();\n\n    let _ = tx.send(0);\n\n    thread::spawn(move || { \n        let _ = tx.send(1);\n    }); \n\n    thread::spawn(move || {\n        let _ = tx_clone.send(2);\n    }); \n\n    println!(\"Received {} via the channel\", rx.recv().unwrap());\n    println!(\"Received {} via the channel\", rx.recv().unwrap());\n    println!(\"Received {} via the channel\", rx.recv().unwrap());\n    println!(\"Received {:?} via the channel\", rx.recv());\n}\n\n```", "```rs\nfn spawn<F, T>(f: F) -> JoinHandle<T>\n    where F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send + 'static\n```", "```rs\npub unsafe auto trait Send { }\n```", "```rs\npub unsafe auto trait Sync { }\n```", "```rs\n# actor_demo/Cargo.toml\n\n[dependencies]\nactix = \"0.7.9\"\nfutures = \"0.1.25\"\ntokio = \"0.1.15\"\n```", "```rs\n// actor_demo/src/main.rs\n\nuse actix::prelude::*;\nuse tokio::timer::Delay;\nuse std::time::Duration;\nuse std::time::Instant;\nuse futures::future::Future;\nuse futures::future;\n\nstruct Add(u32, u32);\n\nimpl Message for Add {\n    type Result = Result<u32, ()>;\n}\n\nstruct Adder;\n\nimpl Actor for Adder {\n    type Context = SyncContext<Self>;\n}\n\nimpl Handler<Add> for Adder {\n    type Result = Result<u32, ()>;\n\n    fn handle(&mut self, msg: Add, _: &mut Self::Context) -> Self::Result {\n        let sum = msg.0 + msg.0;\n        println!(\"Computed: {} + {} = {}\",msg.0, msg.1, sum);\n        Ok(msg.0 + msg.1)\n    }\n}\n\nfn main() {\n    System::run(|| {\n        let addr = SyncArbiter::start(3, || Adder);\n        for n in 5..10 {\n            addr.do_send(Add(n, n+1));\n        }\n\n        tokio::spawn(futures::lazy(|| {\n            Delay::new(Instant::now() + Duration::from_secs(1)).then(|_| {\n                System::current().stop();\n                future::ok::<(),()>(())\n            })\n        }));\n    });\n}\n```", "```rs\n$ cargo run\nRunning `target/debug/actor_demo`\nComputed: 5 + 6 = 10\nComputed: 6 + 7 = 12\nComputed: 7 + 8 = 14\nComputed: 8 + 9 = 16\nComputed: 9 + 10 = 18\n```"]