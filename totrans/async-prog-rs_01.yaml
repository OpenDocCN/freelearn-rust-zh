- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: 'Concurrency and Asynchronous Programming: a Detailed Overview'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与异步编程：详细概述
- en: Asynchronous programming is one of those topics many programmers find confusing.
    You come to the point when you think you’ve got it, only to later realize that
    the rabbit hole is much deeper than you thought. If you participate in discussions,
    listen to enough talks, and read about the topic on the internet, you’ll probably
    also come across statements that seem to contradict each other. At least, this
    describes how I felt when I first was introduced to the subject.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是许多程序员觉得令人困惑的话题之一。当你认为自己已经掌握了它时，你可能会后来意识到这个兔子洞比你想象的要深得多。如果你参与讨论，听了足够的讲座，并在互联网上阅读有关这个主题的内容，你可能会遇到似乎相互矛盾的说法。至少，这描述了我第一次接触这个主题时的感受。
- en: The cause of this confusion is often a lack of context, or authors assuming
    a specific context without explicitly stating so, combined with terms surrounding
    concurrency and asynchronous programming that are rather poorly defined.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混淆的原因通常是缺乏上下文，或者作者在没有明确说明的情况下假设了特定的上下文，再加上围绕并发和异步编程的术语定义得相当糟糕。
- en: 'In this chapter, we’ll be covering a lot of ground, and we’ll divide the content
    into the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖很多内容，并将内容分为以下主要主题：
- en: Async history
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程历史
- en: Concurrency and parallelism
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发与并行
- en: The operating system and the CPU
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统与CPU
- en: Interrupts, firmware, and I/O
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断、固件和I/O
- en: This chapter is general in nature. It doesn’t specifically focus on **Rust**,
    or any specific programming language for that matter, but it’s the kind of background
    information we need to go through so we know that everyone is on the same page
    going forward. The upside is that this will be useful no matter what programming
    language you use. In my eyes, that fact also makes this one of the most interesting
    chapters in this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容较为通用。它并不特别关注**Rust**，或者任何特定的编程语言，但这是我们需要的背景信息，以便我们知道每个人在前进的道路上都在同一页面上。好处是，这将对任何编程语言都很有用。在我看来，这也使得这一章成为本书中最有趣的一章之一。
- en: There’s not a lot of code in this chapter, so we’re off to a soft start. It’s
    a good time to make a cup of tea, relax, and get comfortable, as we’re about start
    this journey together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码不多，所以我们从轻松的开始。这是一个泡一杯茶、放松并让自己舒适的时候，因为我们将一起开始这段旅程。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All examples will be written in Rust, and you have two alternatives for running
    the examples:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例都将使用Rust编写，并且你有两种运行示例的替代方案：
- en: Write and run the examples we’ll write on the Rust playground
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rust playground上编写和运行我们将编写的示例
- en: Install Rust on your machine and run the examples locally (recommended)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的机器上安装Rust并本地运行示例（推荐）
- en: The ideal way to read this chapter is to clone the accompanying repository ([https://github.com/PacktPublishing/Asynchronous-Programming-in-Rust/tree/main/ch01/a-assembly-dereference](https://github.com/PacktPublishing/Asynchronous-Programming-in-Rust/tree/main/ch01/a-assembly-dereference))
    and open the `ch01` folder and keep it open while you read the book. There, you’ll
    find all the examples we write in this chapter and even some extra information
    that you might find interesting as well. You can of course also go back to the
    repository later if you don’t have that accessible right now.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章的理想方式是克隆随附的仓库([https://github.com/PacktPublishing/Asynchronous-Programming-in-Rust/tree/main/ch01/a-assembly-dereference](https://github.com/PacktPublishing/Asynchronous-Programming-in-Rust/tree/main/ch01/a-assembly-dereference))，打开`ch01`文件夹，并在阅读本书时保持打开状态。在那里，你可以找到本章中我们编写的所有示例，甚至还有一些你可能觉得有趣的信息。当然，如果你现在无法访问，你当然也可以稍后回到仓库。
- en: An evolutionary journey of multitasking
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多任务处理的进化之旅
- en: In the beginning, computers had one CPU that executed a set of instructions
    written by a programmer one by one. No **operating system** (**OS**), no scheduling,
    no threads, no multitasking. This was how computers worked for a long time. We’re
    talking back when a program was assembled in a deck of punched cards, and you
    got in big trouble if you were so unfortunate that you dropped the deck onto the
    floor.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初，计算机只有一个CPU，它会逐个执行程序员编写的指令集。没有**操作系统**（**OS**），没有调度，没有线程，没有多任务处理。这就是计算机长时间以来的工作方式。我们说的是当程序在穿孔卡片堆栈上汇编的时候，如果你不幸将卡片堆叠掉到地上，那可就麻烦了。
- en: There were operating systems being researched very early and when personal computing
    started to grow in the 80s, operating systems such as DOS were the standard on
    most consumer PCs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代个人计算开始增长时，操作系统如DOS在大多数消费级PC上成为标准。
- en: These operating systems usually yielded control of the entire CPU to the program
    currently executing, and it was up to the programmer to make things work and implement
    any kind of multitasking for their program. This worked fine, but as interactive
    UIs using a mouse and windowed operating systems became the norm, this model simply
    couldn’t work anymore.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作系统通常将整个CPU的控制权交给当前正在执行的程序，程序员需要确保程序正常运行并实现任何类型的多任务处理。这没问题，但随着使用鼠标和窗口式操作系统的交互式用户界面成为常态，这种模式已经无法再继续下去了。
- en: Non-preemptive multitasking
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非抢占式多任务处理
- en: '**Non-preemptive multitasking** was the first method used to be able to keep
    a UI interactive (and running background processes).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**非抢占式多任务处理**是第一个能够保持用户界面交互性（并运行后台进程）的方法。'
- en: This kind of multitasking put the responsibility of letting the OS run other
    tasks, such as responding to input from the mouse or running a background task,
    in the hands of the programmer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多任务处理将操作系统运行其他任务（如响应用户鼠标输入或运行后台任务）的责任交给了程序员。
- en: Typically, the programmer *yielded* control to the OS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序员会将控制权“让出”给操作系统。
- en: Besides offloading a huge responsibility to every programmer writing a program
    for your platform, this method was naturally error-prone. A small mistake in a
    program’s code could halt or crash the entire system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将巨大的责任转嫁给为你的平台编写程序的每个程序员之外，这种方法自然容易出错。程序代码中的一个小错误可能导致整个系统停止或崩溃。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Another popular term for what we call non-preemptive multitasking is **cooperative
    multitasking**. Windows 3.1 used cooperative multitasking and required programmers
    to yield control to the OS by using specific system calls. One badly-behaving
    application could thereby halt the entire system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的非抢占式多任务处理的另一个流行术语是**协作式多任务处理**。Windows 3.1使用了协作式多任务处理，并要求程序员通过使用特定的系统调用来将控制权让给操作系统。一个表现不佳的应用程序可能会因此使整个系统停止。
- en: Preemptive multitasking
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抢占式多任务处理
- en: While non-preemptive multitasking sounded like a good idea, it turned out to
    create serious problems as well. Letting every program and programmer out there
    be responsible for having a responsive UI in an operating system can ultimately
    lead to a bad user experience, since every bug out there could halt the entire
    system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非抢占式多任务处理听起来是个好主意，但它实际上也带来了严重的问题。让每个程序和程序员负责在操作系统中拥有响应式的用户界面，最终可能导致糟糕的用户体验，因为任何一个错误都可能导致整个系统停止。
- en: The solution was to place the responsibility of scheduling the CPU resources
    between the programs that requested it (including the OS itself) in the hands
    of the OS. The OS can stop the execution of a process, do something else, and
    switch back.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将调度CPU资源之间程序的责任（包括操作系统本身）交给了操作系统。操作系统可以停止一个进程的执行，做其他事情，然后再切换回来。
- en: On such a system, if you write and run a program with a graphical user interface
    on a single-core machine, the OS will stop your program to update the mouse position
    before it switches back to your program to continue. This happens so frequently
    that we don’t usually observe any difference whether the CPU has a lot of work
    or is idle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的系统中，如果你在一台单核机器上编写并运行一个具有图形用户界面的程序，操作系统会在切换回你的程序继续之前停止你的程序以更新鼠标位置。这种情况发生的频率很高，以至于我们通常无法观察到CPU是否有很多工作或空闲。
- en: The OS is responsible for scheduling tasks and does this by switching contexts
    on the CPU. This process can happen many times each second, not only to keep the
    UI responsive but also to give some time to other background tasks and IO events.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统负责调度任务，这是通过在CPU上切换上下文来实现的。这个过程可以每秒发生多次，不仅为了保持用户界面的响应性，还为了给其他后台任务和I/O事件留出时间。
- en: This is now the prevailing way to design an operating system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在已经成为设计操作系统的主流方式。
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Later in this book, we’ll write our own green threads and cover a lot of basic
    knowledge about context switching, threads, stacks, and scheduling that will give
    you more insight into this topic, so stay tuned.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将编写自己的绿色线程，并涵盖许多关于上下文切换、线程、堆栈和调度等基础知识，这将使你对这个主题有更深入的了解，所以请保持关注。
- en: Hyper-threading
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超线程技术
- en: As CPUs evolved and added more functionality such as several **arithmetic logic
    units** (**ALUs**) and additional logic units, the CPU manufacturers realized
    that the entire CPU wasn't fully utilized. For example, when an operation only
    required some parts of the CPU, an instruction could be run on the ALU simultaneously.
    This became the start of **hyper-threading**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着CPU的发展，增加了更多功能，例如几个**算术逻辑单元**（**ALUs**）和额外的逻辑单元，CPU制造商意识到整个CPU并没有得到充分利用。例如，当一个操作只需要CPU的部分功能时，可以在ALU上同时运行一条指令。这成为了**超线程**的起点。
- en: Your computer today, for example, may have 6 cores and 12 logical cores.. This
    is exactly where hyper-threading comes in. It “simulates” two cores on the same
    core by using unused parts of the CPU to drive progress on thread *2* and simultaneously
    running the code on thread *1*. It does this by using a number of smart tricks
    (such as the one with the ALU).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你今天的电脑可能有6个核心和12个逻辑核心。这正是超线程发挥作用的地方。它通过使用CPU的未使用部分来驱动线程*2*的进度，并同时运行线程*1*上的代码，从而“模拟”同一核心上的两个核心。它是通过使用一些智能技巧（例如与ALU相关的技巧）来做到这一点的。
- en: Now, using hyper-threading, we could actually offload some work on one thread
    while keeping the UI interactive by responding to events in the second thread
    even though we only had one CPU core, thereby utilizing our hardware better.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过使用超线程，我们实际上可以在一个线程上卸载一些工作，同时通过在第二个线程中响应事件来保持用户界面交互性，即使我们只有一个CPU核心，从而更好地利用我们的硬件。
- en: You might wonder about the performance of hyper-threading
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对超线程的性能感到好奇
- en: It turns out that hyper-threading has been continuously improved since the 90s.
    Since you’re not actually running two CPUs, there will be some operations that
    need to wait for each other to finish. The performance gain of hyper-threading
    compared to multitasking in a single core seems to be somewhere close to 30% but
    it largely depends on the workload.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，自90年代以来，超线程技术一直在不断改进。由于你实际上并没有运行两个CPU，因此将会有一些操作需要等待彼此完成。与单核中的多任务处理相比，超线程的性能提升似乎接近30%，但这在很大程度上取决于工作负载。
- en: Multicore processors
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多核处理器
- en: As most know, the clock frequency of processors has been flat for a long time.
    Processors get faster by improving **caches**, **branch prediction**, and **speculative
    execution**, and by working on the **processing pipelines** of the processors,
    but the gains seem to be diminishing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如大多数人所知，处理器的时钟频率已经很长时间没有提升了。处理器通过改进**缓存**、**分支预测**和**推测执行**，以及通过优化处理器的**处理流水线**来变快，但收益似乎正在减少。
- en: On the other hand, new processors are so small that they allow us to have many
    on the same chip. Now, most CPUs have many cores and most often, each core will
    also have the ability to perform hyper-threading.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，新的处理器非常小，这使我们能够在同一芯片上拥有许多处理器。现在，大多数CPU都有多个核心，而且通常每个核心也都有执行超线程的能力。
- en: Do you really write synchronous code?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你真的编写了同步代码吗？
- en: Like many things, this depends on your perspective. From the perspective of
    your process and the code you write, everything will normally happen in the order
    you write it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多事情一样，这取决于你的视角。从你的进程和编写的代码的角度来看，一切通常都会按照你编写的顺序发生。
- en: From the operating system’s perspective, it might or might not interrupt your
    code, pause it, and run some other code in the meantime before resuming your process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作系统的角度来看，它可能会或可能不会中断你的代码，暂停它，并在恢复你的进程之前在同时运行一些其他代码。
- en: From the perspective of the CPU, it will mostly execute instructions one at
    a time.* It doesn’t care who wrote the code, though, so when a **hardware interrupt**
    happens, it will immediately stop and give control to an interrupt handler. This
    is how the CPU handles concurrency.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从CPU的角度来看，它通常会一次执行一条指令。*尽管它不在乎谁编写了代码，但当发生硬件中断时，它会立即停止并将控制权交给中断处理程序。这就是CPU处理并发的方式。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*However, modern CPUs can also do a lot of things in parallel. Most CPUs are
    pipelined, meaning that the next instruction is loaded while the current one is
    executing. It might have a branch predictor that tries to figure out what instructions
    to load next.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*然而，现代CPU也可以并行执行很多事情。大多数CPU都是流水线化的，这意味着在当前指令执行的同时，会加载下一条指令。它可能有一个分支预测器，试图确定接下来要加载哪些指令。'
- en: The processor can also reorder instructions by using **out-of-order execution**
    if it believes it makes things faster this way without ‘asking’ or ‘telling’ the
    programmer or the OS, so you might not have any guarantee that A happens before
    B.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理器认为通过使用**乱序执行**可以使事情更快，而不需要“询问”或“告诉”程序员或操作系统，那么您可能无法保证 A 发生在 B 之前。
- en: The CPU offloads some work to separate ‘coprocessors’ such as the FPU for floating-point
    calculations, leaving the main CPU ready to do other tasks et cetera.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 将一些工作卸载到单独的“协处理器”上，例如用于浮点计算的 FPU，这样主 CPU 就可以准备执行其他任务等等。
- en: As a high-level overview, it’s OK to model the CPU as operating in a synchronous
    manner, but for now, let’s just make a mental note that this is a model with some
    caveats that become especially important when talking about parallelism, synchronization
    primitives (such as mutexes and atomics), and the security of computers and operating
    systems.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次概述来看，将 CPU 模拟为以同步方式运行是可以的，但在此，我们只需在脑海中记下这是一个存在一些限制条件的模型，这些限制条件在讨论并行性、同步原语（如互斥锁和原子操作）以及计算机和操作系统的安全性时尤为重要。
- en: Concurrency versus parallelism
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与并行性
- en: Right off the bat, we’ll dive into this subject by defining what **concurrency**
    is. Since it is quite easy to confuse *concurrent* with *parallel*, we will try
    to make a clear distinction between the two from the get-go.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将立即深入探讨这个主题，首先定义**并发**是什么。由于很容易将*并发*与*并行*混淆，我们将从一开始就尝试在这两者之间做出明确的区分。
- en: Important
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Concurrency is about *dealing* with a lot of things at the same time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是关于*处理*很多事情。
- en: Parallelism is about *doing* a lot of things at the same time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并行性是关于*同时做*很多事情。
- en: 'We call the concept of progressing multiple tasks at the same time *multitasking*.
    There are two ways to multitask. One is by *progressing* tasks concurrently, but
    not at the same time. Another is to progress tasks at the exact same time in parallel.
    *Figure 1**.1* depicts the difference between the two scenarios:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将同时推进多个任务的概念称为*多任务处理*。有两种多任务处理的方式。一种是通过*并发*推进任务，但不是同时进行。另一种是在并行中同时推进任务。*图
    1.1*展示了这两种场景之间的区别：
- en: '![Figure 1.1 – Multitasking two tasks](img/B20892_Figure_01.1.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 同时处理两个任务](img/B20892_Figure_01.1.jpg)'
- en: Figure 1.1 – Multitasking two tasks
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 同时处理两个任务
- en: 'First, we need to agree on some definitions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要就一些定义达成一致：
- en: '**Resource**: This is something we need to be able to progress a task. Our
    resources are limited. This could be CPU time or memory.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：这是我们能够推进任务所需要的东西。我们的资源是有限的。这可能是 CPU 时间或内存。'
- en: '**Task**: This is a set of operations that requires some kind of resource to
    progress. A task must consist of several sub-operations.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：这是一组需要某种资源来推进的操作。一个任务必须由几个子操作组成。'
- en: '**Parallel**: This is something happening independently at the *exact* same
    time.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行**：这是在*确切*同一时间独立发生的事情。'
- en: '**Concurrent**: These are tasks that are *in progress* at the same time, but
    not necessarily progressing simultaneously.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**：这些是在同一时间进行中的任务，但不一定是同时进行的。'
- en: This is an important distinction. If two tasks are running concurrently, but
    are not running in parallel, they must be able to stop and resume their progress.
    We say that a task is *interruptible* if it allows for this kind of concurrency.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的区分。如果两个任务并发运行，但不是并行运行，它们必须能够停止并恢复其进度。我们说一个任务是*可中断的*，如果它允许这种类型的并发。
- en: The mental model I use
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我使用的心理模型
- en: I firmly believe the main reason we find parallel and concurrent programming
    hard to differentiate stems from how we model events in our everyday life. We
    tend to define these terms loosely, so our intuition is often wrong.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我坚信，我们觉得并行和并发编程难以区分的主要原因，源于我们如何模拟日常生活中的事件。我们往往对这些术语定义得比较宽松，因此我们的直觉往往是不正确的。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It doesn’t help that *concurrent* is defined in the dictionary as *operating
    or occurring at the same time*, which doesn’t really help us much when trying
    to describe how it differs from *parallel*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 并没有帮助的是，*并发*在词典中被定义为*同时进行或发生*，这并没有真正帮助我们描述它与*并行*的区别。
- en: For me, this first clicked when I started to understand why we want to make
    a distinction between parallel and concurrent in the first place!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，当我开始理解为什么我们最初想要区分并行和并发时，这第一个想法就产生了！
- en: The *why* has everything to do with resource utilization and efficiency.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么*与资源利用和效率息息相关。'
- en: '*Efficiency is the (often measurable) ability to avoid wasting materials, energy,
    effort, money, and time in doing something or in producing a* *desired result.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*效率*是（通常可以衡量的）避免在做事或产生*期望结果*时浪费材料、能源、努力、金钱和时间的能力。'
- en: '*Parallelism* is increasing the resources we use to solve a task. It has nothing
    to do with *efficiency*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行性*是增加我们用来解决任务的资源。它与*效率*无关。'
- en: '*Concurrency* has everything to do with efficiency and resource utilization.
    Concurrency can never make *one single task go faster*. It can only help us utilize
    our resources better and thereby *finish a set of* *tasks faster*.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发性*与效率和资源利用密切相关。并发性永远不能让*单个任务更快地完成*。它只能帮助我们更好地利用资源，从而*更快地完成一系列*任务。'
- en: Let’s draw some parallels to process economics
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们通过流程经济学来类比一下
- en: In businesses that manufacture goods, we often talk about **LEAN** processes.
    This is pretty easy to compare with why programmers care so much about what we
    can achieve if we handle tasks concurrently.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在制造商品的企业中，我们经常谈论**精益**流程。这很容易与程序员为什么如此关心如果我们并发处理任务我们能实现什么进行比较。
- en: Let’s pretend we’re running a bar. We only serve Guinness beer and nothing else,
    but we serve our Guinness to perfection. Yes, I know, it’s a little niche, but
    bear with me.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们经营一家酒吧。我们只提供健力士啤酒，没有其他选择，但我们把健力士啤酒做得尽善尽美。是的，我知道，这有点小众，但请耐心听我说。
- en: 'You are the manager of this bar, and your goal is to run it as efficiently
    as possible. Now, you can think of each bartender as a *CPU core*, and each order
    as a *task*. To manage this bar, you need to know the steps to serve a perfect
    Guinness:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你是这个酒吧的经理，你的目标是尽可能高效地经营它。现在，你可以把每个酒保想象成一个*CPU核心*，每个订单想象成一个*任务*。为了管理这个酒吧，你需要知道如何服务一杯完美的健力士啤酒的步骤：
- en: Pour the Guinness draught into a glass tilted at 45 degrees until it’s 3-quarters
    full (15 seconds).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将健力士啤酒倒入倾斜45度的玻璃杯中，直到杯子的3/4满（15秒）。
- en: Allow the surge to settle for 100 seconds.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让激增持续100秒。
- en: Fill the glass completely to the top (5 seconds).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玻璃杯完全倒满（5秒）。
- en: Serve.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上菜。
- en: Since there is only one thing to order in the bar, customers only need to signal
    using their fingers how many they want to order, so we assume taking new orders
    is instantaneous. To keep things simple, the same goes for payment. In choosing
    how to run this bar, you have a few alternatives.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于酒吧里只有一种东西可以点，顾客只需要用手指表示他们想要点多少，所以我们假设接收新订单是瞬时的。为了简化问题，支付也是如此。在经营这家酒吧时，你有几种选择。
- en: Alternative 1 – Fully synchronous task execution with one bartender
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项1 – 与一名酒保完全同步的任务执行
- en: You start out with only one bartender (CPU). The bartender takes one order,
    finishes it, and progresses to the next. The line is out the door and going two
    blocks down the street – great! One month later, you’re almost out of business
    and you wonder why.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始时只有一名酒保（CPU）。酒保接收一个订单，完成它，然后继续下一个。队伍已经走出门口，沿着街道走了两块街区——太棒了！一个月后，你几乎要破产了，你不知道为什么。
- en: Well, even though your bartender is very fast at taking new orders, they can
    only serve 30 customers an hour. Remember, they’re waiting for 100 seconds while
    the beer settles and they’re practically just standing there, and they only use
    20 seconds to actually fill the glass. Only after one order is completely finished
    can they progress to the next customer and take their order.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，即使你的酒保在接收新订单方面非常快，他们每小时也只能服务30名顾客。记住，他们在啤酒沉淀时要等待100秒，他们实际上只是在站着，他们只用了20秒来真正倒满玻璃杯。只有当一项订单完全完成后，他们才能继续服务下一位顾客并接收他们的订单。
- en: The result is bad revenue, angry customers, and high costs. That’s not going
    to work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是收入不佳，顾客愤怒，成本高昂。这是不可行的。
- en: Alternative 2 – Parallel and synchronous task execution
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项2 – 并行和同步任务执行
- en: So, you hire 12 bartenders, and you calculate that you can serve about 360 customers
    an hour. The line is barely going out the door now, and revenue is looking great.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你雇佣了12名酒保，你计算你可以每小时服务大约360名顾客。现在队伍几乎要走出门口了，收入看起来很可观。
- en: One month goes by and again, you’re almost out of business. How can that be?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个月过去了，你几乎要破产了。这怎么可能呢？
- en: It turns out that having 12 bartenders is pretty expensive. Even though revenue
    is high, the costs are even higher. Throwing more resources at the problem doesn’t
    really make the bar more efficient.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，拥有12名酒保相当昂贵。尽管收入很高，但成本更高。向问题投入更多资源并不能真正使酒吧更有效率。
- en: Alternative 3 – Asynchronous task execution with one bartender
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项3 – 使用一个酒保的异步任务执行
- en: So, we’re back to square one. Let’s think this through and find a smarter way
    of working instead of throwing more resources at the problem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们又回到了起点。让我们仔细思考，找到一种更聪明的工作方式，而不是简单地投入更多资源。
- en: You ask your bartender whether they can start taking new orders while the beer
    settles so that they’re never just standing and waiting while there are customers
    to serve. The opening night comes and...
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您询问您的酒保是否可以在啤酒沉淀时开始接受新订单，这样他们就不会在有顾客需要服务时只是站立等待。开业之夜到来了...
- en: Wow! On a busy night where the bartender works non-stop for a few hours, you
    calculate that they now only use just over 20 seconds on an order. You’ve basically
    eliminated all the waiting. Your theoretical throughput is now 240 beers per hour.
    If you add one more bartender, you’ll have higher throughput than you did while
    having 12 bartenders.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！在一个忙碌的夜晚，酒保连续工作几个小时，您计算得出他们现在处理一个订单只需要超过20秒。您基本上消除了所有等待时间。您的理论吞吐量现在是每小时240杯啤酒。如果您再增加一个酒保，您的吞吐量将超过拥有12个酒保时的吞吐量。
- en: However, you realize that you didn’t actually accomplish 240 beers an hour,
    since orders come somewhat erratically and not evenly spaced over time. Sometimes,
    the bartender is busy with a new order, preventing them from topping up and serving
    beers that are finished almost immediately. In real life, the throughput is only
    180 beers an hour.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您意识到您实际上并没有达到每小时240杯啤酒的产量，因为订单的到达有些不规则，并且不是均匀分布的。有时，酒保忙于新订单，阻止他们补充和为几乎立即完成的啤酒服务。在现实生活中，吞吐量只有每小时180杯。
- en: Still, two bartenders could serve 360 beers an hour this way, the same amount
    that you served while employing 12 bartenders.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，两个酒保以这种方式每小时可以服务360杯啤酒，这与您雇佣12个酒保时的服务量相同。
- en: This is good, but you ask yourself whether you can do even better.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但您会问自己是否还能做得更好。
- en: Alternative 4 – Parallel and asynchronous task execution with two bartenders
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项4 – 使用两个酒保的并行和异步任务执行
- en: 'What if you hire two bartenders, and ask them to do just what we described
    in Alternative 3, but with one change: you allow them to steal each other’s tasks,
    so *bartender 1* can start pouring and set the beer down to settle, and *bartender
    2* can top it up and serve it if *bartender 1* is busy pouring a new order at
    that time? This way, it is only rarely that both bartenders are busy at the same
    time as one of the beers-in-progress becomes ready to get topped up and served.
    Almost all orders are finished and served in the shortest amount of time possible,
    letting customers leave the bar with their beer faster and giving space to customers
    who want to make a new order.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您雇佣两个酒保，并要求他们只做我们在选项3中描述的事情，但有一个变化：您允许他们互相偷取任务，这样**酒保1**就可以开始倒酒并将啤酒放下让其沉淀，而**酒保2**可以在**酒保1**忙于倒新订单时补充啤酒并服务。这样，两个酒保同时忙碌的情况很少发生，因为其中一杯正在进行的啤酒已经准备好补充并服务。几乎所有的订单都以可能的最短时间完成并服务，让顾客更快地离开酒吧，为想要下新订单的顾客腾出空间。
- en: Now, this way, you can increase throughput even further. You still won’t reach
    the theoretical maximum, but you’ll get very close. On the opening night, you
    realize that the bartenders now process 230 orders an hour each, giving a total
    throughput of 460 beers an hour.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这样，您可以进一步提高吞吐量。您仍然无法达到理论上的最大值，但您会非常接近。在开业之夜，您意识到酒保现在每小时处理230个订单，总吞吐量为每小时460杯啤酒。
- en: Revenue looks good, customers are happy, costs are kept at a minimum, and you’re
    one happy manager of the weirdest bar on earth (an extremely efficient bar, though).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 收入看起来不错，顾客很满意，成本保持在最低，您是地球上最奇怪的酒吧（尽管是一个效率极高的酒吧）的快乐的经理。
- en: The key takeaway
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点
- en: Concurrency is about working smarter. Parallelism is a way of throwing more
    resources at the problem.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是关于更聪明地工作。并行是一种向问题投入更多资源的方式。
- en: Concurrency and its relation to I/O
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发及其与I/O的关系
- en: As you might understand from what I’ve written so far, writing async code mostly
    makes sense when you need to be smart to make optimal use of your resources.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从我所写的内容中理解的那样，编写异步代码主要在您需要聪明地充分利用资源时才有意义。
- en: Now, if you write a program that is working hard to solve a problem, there is
    often no help in concurrency. This is where parallelism comes into play, since
    it gives you a way to throw more resources at the problem if you can split it
    into parts that you can work on in parallel.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你编写一个努力解决问题的程序，通常在并发方面没有帮助。这就是并行性发挥作用的地方，因为它给你提供了一个方法，如果你可以将问题分解成可以并行工作的部分，你可以向问题投入更多的资源。
- en: 'Consider the following two different use cases for concurrency:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个不同的并发用例：
- en: When performing I/O and you need to wait for some external event to occur
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当执行I/O并且你需要等待某些外部事件发生时
- en: When you need to divide your attention and prevent one task from waiting too
    long
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要分散你的注意力，防止一个任务等待太长时间
- en: 'The first is the classic I/O example: you have to wait for a network call,
    a database query, or something else to happen before you can progress a task.
    However, you have many tasks to do so instead of waiting, you continue to work
    elsewhere and either check in regularly to see whether the task is ready to progress,
    or make sure you are notified when that task is ready to progress.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个经典的I/O示例：你必须等待网络调用、数据库查询或其他事情发生，然后你才能继续任务。然而，你有许多任务要做，所以你不必等待，你可以继续在其他地方工作，或者定期检查任务是否准备好继续，或者确保你在任务准备好继续时得到通知。
- en: The second is an example that is often the case when having a UI. Let’s pretend
    you only have one core. How do you prevent the whole UI from becoming unresponsive
    while performing other CPU-intensive tasks?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子是在有UI时经常发生的情况。让我们假设你只有一个核心。在执行其他CPU密集型任务时，你如何防止整个UI变得无响应？
- en: Well, you can stop whatever task you’re doing every 16 ms, run the *update UI*
    task, and then resume whatever you were doing afterward. This way, you will have
    to stop/resume your task 60 times a second, but you will also have a fully responsive
    UI that has a roughly 60 Hz refresh rate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可以每16毫秒停止你正在做的任何任务，运行*更新UI*任务，然后继续你之后正在做的事情。这样，你将每秒需要停止/恢复你的任务60次，但你也会有一个响应速度大约为60赫兹的完全响应式UI。
- en: What about threads provided by the operating system?
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统提供的线程怎么样？
- en: We’ll cover threads a bit more when we talk about strategies for handling I/O
    later in this book, but I’ll mention them here as well. One challenge when using
    OS threads to understand concurrency is that they appear to be mapped to cores.
    That’s not necessarily a correct mental model to use, even though most operating
    systems will try to map one thread to one core up to the number of threads equal
    to the number of cores.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到处理I/O的策略时，我们将在本书的后面部分更详细地介绍线程，但我也将在这里提及它们。使用操作系统线程理解并发的一个挑战是，它们似乎被映射到核心上。这不一定是一个正确的心理模型来使用，尽管大多数操作系统都会尝试将一个线程映射到一个核心上，直到线程数量等于核心数量。
- en: Once we create more threads than there are cores, the OS will switch between
    our threads and progress each of them concurrently using its scheduler to give
    each thread some time to run. You also must consider the fact that your program
    is not the only one running on the system. Other programs might spawn several
    threads as well, which means there will be many more threads than there are cores
    on the CPU.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建的线程数量超过了核心数量，操作系统将在这我们的线程之间切换，并使用其调度器并发地处理每个线程，以给每个线程一些运行的时间。你也必须考虑这样一个事实，你的程序并不是系统中唯一运行的程序。其他程序也可能创建多个线程，这意味着CPU上的线程数量将远多于核心数量。
- en: Therefore, threads can be a means to perform tasks in parallel, but they can
    also be a means to achieve concurrency.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，线程可以是并行执行任务的手段，但它们也可以是实现并发的手段。
- en: This brings me to the last part about concurrency. It needs to be defined in
    some sort of reference frame.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想到了关于并发的最后一部分。它需要在某种参考系中定义。
- en: Choosing the right reference frame
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的参考系
- en: When you write code that is perfectly synchronous from your perspective, stop
    for a second and consider how that looks from the operating system perspective.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写的代码从你的角度来看是完美同步的，停顿一下，考虑一下从操作系统的角度来看这会是什么样子。
- en: The operating system might not run your code from start to end at all. It might
    stop and resume your process many times. The CPU might get interrupted and handle
    some inputs while you think it’s only focused on your task.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统可能根本不会从头到尾运行你的代码。它可能会多次停止和恢复你的进程。CPU可能会被中断并处理一些输入，而你认为它只专注于你的任务。
- en: 'So, synchronous execution is only an illusion. But from the perspective of
    you as a programmer, it’s not, and that is the important takeaway:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，同步执行只是一个错觉。但从程序员的角度来看，它不是，这是重要的启示：
- en: '*When we talk about concurrency without providing any other context, we are
    using you as a programmer and your code (your process) as the reference frame.
    If you start pondering concurrency without keeping this in the back of your head,
    it will get confusing* *very fast.*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我们谈论并发而不提供任何其他上下文时，我们是以程序员和你的代码（你的进程）作为参考框架。如果你开始思考并发而不将这一点放在心中，它会很快变得混乱。*'
- en: The reason I’m spending so much time on this is that once you realize the importance
    of having the same definitions and the same reference frame, you’ll start to see
    that some of the things you hear and learn that might seem contradictory really
    are not. You’ll just have to consider the reference frame first.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以花这么多时间在这上面，是因为一旦你意识到拥有相同定义和相同参考框架的重要性，你就会开始发现，你所听到和学到的一些看似矛盾的事情实际上并不是。你只需首先考虑参考框架即可。
- en: Asynchronous versus concurrent
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步与并发
- en: So, you might wonder why we’re spending all this time talking about multitasking,
    concurrency, and parallelism, when the book is about asynchronous programming.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能想知道，当这本书是关于异步编程时，我们为什么花这么多时间谈论多任务处理、并发和并行性。
- en: The main reason for this is that all these concepts are closely related to each
    other, and can even have the same (or overlapping) meanings, depending on the
    context they’re used in.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因在于，所有这些概念彼此之间都紧密相关，甚至可以根据它们被使用的上下文具有相同（或重叠）的含义。
- en: In an effort to make the definitions as distinct as possible, we’ll define these
    terms more narrowly than you’d normally see. However, just be aware that we can’t
    please everyone and we do this for our own sake of making the subject easier to
    understand. On the other hand, if you fancy heated internet debates, this is a
    good place to start. Just claim someone else’s definition of concurrent is 100
    % wrong or that yours is 100 % correct, and off you go.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使定义尽可能清晰，我们将比通常更狭窄地定义这些术语。然而，请记住，我们无法取悦每个人，我们这样做是为了使主题更容易理解。另一方面，如果你喜欢热烈的互联网辩论，这是一个很好的开始。只需声称某个人的并发定义是100%错误的，或者你的定义是100%正确的，然后你就可以开始了。
- en: '*For the sake of this book, we’ll stick to this definition: asynchronous programming
    is the way a programming language or library abstracts over concurrent operations,
    and how we as users of a language or library use that abstraction to execute*
    *tasks concurrently.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了本书的目的，我们将坚持这个定义：异步编程是编程语言或库对并发操作进行抽象的方式，以及我们作为语言或库的用户如何使用这种抽象来并发执行任务。*'
- en: The operating system already has an existing abstraction that covers this, called
    **threads**. Using OS threads to handle asynchrony is often referred to **as multithreaded
    programming**. To avoid confusion, we’ll not refer to using OS threads directly
    as asynchronous programming, even though it solves the same problem.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统已经有一个现有的抽象，称为**线程**。使用操作系统线程来处理异步操作通常被称为**多线程编程**。为了避免混淆，我们不会直接将使用操作系统线程称为异步编程，即使它解决了相同的问题。
- en: Given that asynchronous programming is now scoped to be about abstractions over
    concurrent or parallel operations in a language or library, it’s also easier to
    understand that it’s just as relevant on embedded systems without an operating
    system as it is for programs that target a complex system with an advanced operating
    system. The definition itself does not imply any specific implementation even
    though we’ll look at a few popular ones throughout this book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异步编程现在被定义为在语言或库中对并发或并行操作进行抽象，因此也更容易理解，它在没有操作系统的嵌入式系统上与针对具有高级操作系统的复杂系统的程序一样相关。定义本身并不暗示任何特定的实现，尽管我们将在本书中探讨一些流行的实现方式。
- en: If this still sounds complicated, I understand. Just sitting and reflecting
    on concurrency is difficult, but if we try to keep these thoughts in the back
    of our heads when we work with async code I promise it will get less and less
    confusing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这仍然听起来很复杂，我理解。只是坐着反思并发是困难的，但如果我们试图在处理异步代码时将这些想法放在心中，我保证它会越来越不令人困惑。
- en: The role of the operating system
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统的作用
- en: The operating system (OS) stands in the center of everything we do as programmers
    (well, unless you’re writing an operating system or working in the embedded realm),
    so there is no way for us to discuss any kind of fundamentals in programming without
    talking about operating systems in a bit of detail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（OS）是我们作为程序员所做的一切的中心（好吧，除非你在编写操作系统或工作在嵌入式领域），因此我们无法在不稍微详细地讨论操作系统的情况下讨论任何编程基础。
- en: Concurrency from the operating system’s perspective
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从操作系统的角度来看的并发
- en: This ties into what I talked about earlier when I said that concurrency needs
    to be talked about within a reference frame, and I explained that the OS might
    stop and start your process at any time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我在之前提到的话题相关，当时我说并发需要在参考框架内讨论，并解释了操作系统可能会随时停止和启动你的进程。
- en: What we call synchronous code is, in most cases, code that appears synchronous
    to us as programmers. Neither the OS nor the CPU lives in a fully synchronous
    world.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的同步代码，在大多数情况下，是对于我们程序员来说看起来是同步的代码。操作系统和CPU都不生活在完全同步的世界中。
- en: Operating systems use preemptive multitasking and as long as the operating system
    you’re running is preemptively scheduling processes, you won’t have a guarantee
    that your code runs instruction by instruction without interruption.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统使用抢占式多任务处理，只要你在运行的操作系统是抢占式调度进程，你就无法保证你的代码会一条指令一条指令地无中断地运行。
- en: The operating system will make sure that all important processes get some time
    from the CPU to make progress.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统将确保所有重要进程都能从CPU获得一些时间以取得进展。
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is not as simple when we’re talking about modern machines with 4, 6, 8,
    or 12 physical cores, since you might actually execute code on one of the CPUs
    uninterrupted if the system is under very little load. The important part here
    is that you can’t know for sure and there is no guarantee that your code will
    be left to run uninterrupted.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论具有4、6、8或12个物理核心的现代机器时，这并不简单，因为如果系统负载非常小，你实际上可能会在一个CPU上不间断地执行代码。这里的关键部分是，你无法确定，也没有保证你的代码会被允许不间断地运行。
- en: Teaming up with the operating system
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与操作系统合作
- en: When you make a web request, you’re not asking the CPU or the network card to
    do something for you – you’re asking the operating system to talk to the network
    card for you.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发起一个网络请求时，你并不是要求CPU或网卡为你做些什么——你是在要求操作系统代表你与网卡通信。
- en: There is no way for you as a programmer to make your system optimally efficient
    without playing to the strengths of the operating system. You basically don’t
    have access to the hardware directly. *You must remember that the operating system
    is an abstraction over* *the hardware.*
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你无法在不利用操作系统的优势的情况下使你的系统达到最优效率。你基本上无法直接访问硬件。*你必须记住，操作系统是对硬件的抽象*。
- en: However, this also means that to understand everything from the ground up, you’ll
    also need to know how your operating system handles these tasks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着，为了从底层理解一切，你还需要了解你的操作系统如何处理这些任务。
- en: To be able to work with the operating system, you’ll need to know how you can
    communicate with it, and that’s exactly what we’re going to go through next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够与操作系统一起工作，你需要知道你如何与之通信，这正是我们接下来将要探讨的。
- en: Communicating with the operating system
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与操作系统通信
- en: Communication with an operating system happens through what we call a **system
    call** (**syscall**). We need to know how to make system calls and understand
    why it’s so important for us when we want to cooperate and communicate with the
    operating system. We also need to understand how the basic abstractions we use
    every day use system calls behind the scenes. We’ll have a detailed walkthrough
    in [*Chapter 3*](B20892_03.xhtml#_idTextAnchor063), so we’ll keep this brief for
    now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作系统的通信是通过我们所说的**系统调用**（**syscall**）发生的。我们需要知道如何进行系统调用，并理解当我们想要与操作系统合作和通信时，为什么这对我们来说如此重要。我们还需要了解我们每天使用的这些基本抽象是如何在幕后使用系统调用的。我们将在[*第3章*](B20892_03.xhtml#_idTextAnchor063)中进行详细说明，所以现在我们将简要介绍。
- en: A system call uses a public API that the operating system provides so that programs
    we write in ‘userland’ can communicate with the OS.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用使用操作系统提供的公共API，以便我们编写的“用户空间”程序可以与操作系统通信。
- en: Most of the time, these calls are abstracted away for us as programmers by the
    language or the runtime we use.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，这些调用被我们使用的语言或运行时抽象化。
- en: Now, a syscall is an example of something that is unique to the kernel you’re
    communicating with, but the **UNIX** family of kernels has many similarities.
    UNIX systems expose this through **libc**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，系统调用是与你所通信的内核独特的东西的例子，但 **UNIX** 系列内核有很多相似之处。UNIX 系统通过 **libc** 暴露这些相似之处。
- en: Windows, on the other hand, uses its own API, often referred to as **WinAPI**,
    and it can operate radically differently from how the UNIX-based systems operate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Windows 使用它自己的 API，通常被称为 **WinAPI**，并且它可以与基于 UNIX 的系统操作截然不同。
- en: Most often, though, there is a way to achieve the same things. In terms of functionality,
    you might not notice a big difference but as we’ll see later, and especially when
    we dig into how **epoll**, **kqueue**, and **IOCP** work, they can differ a lot
    in how this functionality is implemented.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数情况下，都有一种方法可以达到相同的效果。从功能的角度来看，你可能不会注意到太大的差异，但正如我们稍后将会看到的，尤其是在我们深入研究 **epoll**、**kqueue**
    和 **IOCP** 的工作原理时，它们在实现这一功能方面可能会有很大的不同。
- en: However, a syscall is not the only way we interact with our operating system,
    as we’ll see in the following section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，系统调用并不是我们与操作系统交互的唯一方式，正如我们将在下一节中看到的。
- en: The CPU and the operating system
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU 和操作系统
- en: '*Does the CPU cooperate with the* *operating system?*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*CPU 与操作系统合作吗？*'
- en: If you had asked me this question when I first thought I understood how programs
    work, I would most likely have answered *no*. We run programs on the CPU and we
    can do whatever we want if we know how to do it. Now, first of all, I wouldn’t
    have thought this through, but unless you learn how CPUs and operating systems
    work together, it’s not easy to know for sure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在我认为自己最初理解了程序是如何工作时问我这个问题，我可能会很可能回答 *不*。我们在 CPU 上运行程序，如果我们知道如何做，我们可以做任何我们想做的事情。现在，首先，我可能不会这样思考，但除非你了解
    CPU 和操作系统是如何一起工作的，否则很难确定。
- en: 'What started to make me think I was very wrong was a segment of code that looked
    like what you’re about to see. If you think inline assembly in Rust looks foreign
    and confusing, don’t worry just yet. We’ll go through a proper introduction to
    inline assembly a little later in this book. I’ll make sure to go through each
    of the following lines until you get more comfortable with the syntax:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我开始怀疑自己非常错误的是一段看起来像你即将看到的代码。如果你认为 Rust 中的内联汇编看起来陌生且令人困惑，请不要担心，稍后我们会在本书中详细介绍内联汇编。我会确保逐行解释以下内容，直到你对语法更加熟悉：
- en: 'Repository reference: ch01/ac-assembly-dereference/src/main.rs'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库引用：ch01/ac-assembly-dereference/src/main.rs
- en: '[PRE0]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What you’ve just looked at is a dereference function written in assembly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到的是一个用汇编编写的解引用函数。
- en: The `mov {0}, [{1}]` line needs some explanation. `{0}` and `{1}` are templates
    that tell the compiler that we’re referring to the registers that `out(reg)` and
    `in(reg)` represent. The number is just an index, so if we had more inputs or
    outputs they would be numbered `{2}`, `{3}`, and so on. Since we only specify
    `reg` and not a specific register, we let the compiler choose what registers it
    wants to use.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov {0}, [{1}]` 这一行需要一些解释。`{0}` 和 `{1}` 是模板，告诉编译器我们正在引用由 `out(reg)` 和 `in(reg)`
    表示的寄存器。数字只是一个索引，所以如果我们有更多的输入或输出，它们将是 `{2}`、`{3}` 等等。由于我们只指定了 `reg` 而没有指定特定的寄存器，我们就让编译器选择它想要使用的寄存器。'
- en: The `mov` instruction instructs the CPU to take the first 8 bytes (if we’re
    on a 64-bit machine) it gets when reading the memory location that `{1}` points
    to and place that in the register represented by `{0}`. The `[]` brackets will
    instruct the CPU to treat the data in that register as a memory address, and instead
    of simply copying the memory address itself to `{0}`, it will fetch what’s at
    that memory location and move it over.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov` 指令指示 CPU 从 `{1}` 所指向的内存位置读取前 8 个字节（如果我们是在 64 位机器上），并将其放置在由 `{0}` 表示的寄存器中。`[]`
    方括号将指示 CPU 将该寄存器中的数据视为内存地址，而不是简单地复制内存地址本身到 `{0}`，它将获取该内存位置的内容并将其移动过来。'
- en: '*Anyway, we’re just writing instructions to the CPU here. No standard library,
    no syscall; just raw instructions. There is no way the OS is involved in that
    dereference* *function, right?*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*无论如何，我们在这里只是向 CPU 写入指令。没有标准库，没有系统调用；只有原始指令。操作系统不可能参与那个解引用* *函数，对吧？*'
- en: 'If you run this program, you get what you’d expect:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你会得到你预期的结果：
- en: '[PRE1]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if you keep the `dereference` function but replace the `main` function
    with a function that creates a pointer to the `99999999999999` address, which
    we know is invalid, we get this function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你保留`解引用`函数，但用创建指向`99999999999999`地址的指针的函数替换`main`函数，我们知道这个地址是无效的，我们得到以下函数：
- en: '[PRE2]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, if we run that we get the following results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行它，我们会得到以下结果。
- en: 'This is the result on Linux:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Linux上的结果：
- en: '[PRE3]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the result on Windows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Windows上的结果：
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We get a segmentation fault. Not surprising, really, but as you also might notice,
    the error we get is different on different platforms. Surely, the OS is involved
    somehow. Let’s take a look at what’s really happening here.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了段错误。这并不奇怪，实际上，你可能也注意到了，我们在不同平台上得到的错误是不同的。当然，操作系统在这里起到了某种作用。让我们看看这里真正发生了什么。
- en: Down the rabbit hole
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掉进兔子洞
- en: It turns out that there is a great deal of cooperation between the OS and the
    CPU, but maybe not in the way you would naively think.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，操作系统和CPU之间有很大的合作，但可能不是你天真地认为的那种方式。
- en: Many modern CPUs provide some basic infrastructure that operating systems use.
    This infrastructure gives us the security and stability we expect. Actually, most
    advanced CPUs provide a lot more options than operating systems such as Linux,
    BSD, and Windows actually use.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代CPU为操作系统提供了一些基本的基础设施。这个基础设施为我们提供了我们期望的安全性和稳定性。实际上，大多数先进的CPU提供的选项比Linux、BSD和Windows等操作系统实际使用的选项要多得多。
- en: 'There are two in particular that I want to address here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特别想在这里讨论：
- en: How the CPU prevents us from accessing memory we’re not supposed to access
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU如何阻止我们访问不应该访问的内存
- en: How the CPU handles asynchronous events such as I/O
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU如何处理异步事件，如I/O
- en: We’ll cover the first one here and the second in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论第一个，第二个将在下一节中讨论。
- en: How does the CPU prevent us from accessing memory we’re not supposed to access?
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU是如何阻止我们访问不应该访问的内存的？
- en: 'As I mentioned, modern CPU architectures define some basic concepts by design.
    Some examples of this are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，现代CPU架构通过设计定义了一些基本概念。以下是一些例子：
- en: Virtual memory
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟内存
- en: Page table
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页表
- en: Page fault
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面错误
- en: Exceptions
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: Privilege level
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限级别
- en: Exactly how this works will differ depending on the specific CPU, so we’ll treat
    them in general terms here.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 具体如何工作将取决于特定的CPU，所以我们在这里以一般术语来处理。
- en: Most modern CPUs have a **memory management unit** (**MMU**). This part of the
    CPU is often etched on the same dye, even. The MMU’s job is to translate the virtual
    address we use in our programs to a physical address.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代CPU都有一个**内存管理单元**（**MMU**）。这个CPU的部分通常甚至是在同一层上蚀刻的。MMU的职责是将我们在程序中使用的虚拟地址转换为物理地址。
- en: When the OS starts a process (such as our program), it sets up a page table
    for our process and makes sure a special register on the CPU points to this page
    table.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统启动一个进程（比如我们的程序）时，它会为我们的进程设置一个页表，并确保CPU上的一个特殊寄存器指向这个页表。
- en: Now, when we try to dereference `t_ptr` in the preceding code, the address is
    at some point sent for translation to the MMU, which looks it up in the page table
    to translate it to a physical address in the memory where it can fetch the data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试在前面代码中解引用`t_ptr`时，地址会在某个时刻发送给MMU进行转换，MMU会在页表中查找它，将其转换为内存中的物理地址，以便从中获取数据。
- en: In the first case, it will point to a memory address on our stack that holds
    the value `100`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，它将指向我们的栈上的一个内存地址，该地址持有值`100`。
- en: When we pass in `99999999999999` and ask it to fetch what’s stored at that address
    (which is what dereferencing does), it looks for the translation in the page table
    but can’t find it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传入`99999999999999`并要求它获取该地址存储的内容（这就是解引用所做的），它会查找页表中的转换，但找不到。
- en: The CPU then treats this as a page fault.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: CPU随后将其视为页面错误。
- en: At boot, the OS provided the CPU with an **interrupt descriptor table**. This
    table has a predefined format where the OS provides handlers for the predefined
    conditions the CPU can encounter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，操作系统向CPU提供了一个**中断描述符表**。这个表有一个预定义的格式，其中操作系统为CPU可能遇到预定义条件提供了处理程序。
- en: Since the OS provided a pointer to a function that handles *page fault*, the
    CPU jumps to that function when we try to dereference `99999999999999` and thereby
    hands over control to the operating system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统提供了一个处理*页面错误*的函数指针，当我们尝试解引用`99999999999999`时，CPU会跳转到该函数，并将控制权交给操作系统。
- en: The OS then prints a nice message for us, letting us know that we encountered
    what it calls a **segmentation fault**. This message will therefore vary depending
    on the OS you run the code on.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，操作系统会为我们打印一条友好的消息，让我们知道我们遇到了它所说的**段错误**。因此，这条消息将根据你在其上运行代码的操作系统而有所不同。
- en: But can’t we just change the page table in the CPU?
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但我们能否只是更改CPU中的页表？
- en: 'Now, this is where the *privilege level* comes in. Most modern operating systems
    operate with two *ring levels*: *ring 0*, the kernel space, and *ring 3*, the
    user space.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这就是*权限级别*发挥作用的地方。大多数现代操作系统以两个*ring级别*运行：*ring 0*，内核空间，和*ring 3*，用户空间。
- en: '![Figure 1.2 – Privilege rings](img/B20892_Figure_01.2.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 权限环](img/B20892_Figure_01.2.jpg)'
- en: Figure 1.2 – Privilege rings
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 权限环
- en: Most CPUs have a concept of more rings than what most modern operating systems
    use. This has historical reasons, which is also why *ring 0* and *ring 3* are
    used (and not 1 and 2).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数CPU的概念比大多数现代操作系统使用的还要多。这有历史原因，这也是为什么使用*ring 0*和*ring 3*（而不是1和2）的原因。
- en: Every entry in the page table has additional information about it. Amongst that
    information is the information about which ring it belongs to. This information
    is set up when your OS boots up.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 页表中的每个条目都有关于它的附加信息。其中信息包括它属于哪个环的信息。这些信息是在你的操作系统启动时设置的。
- en: Code executed in *ring 0* has almost unrestricted access to external devices
    and memory, and is free to change registers that provide security at the hardware
    level.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在*ring 0*中执行的代码几乎可以无限制地访问外部设备和内存，并且可以自由更改提供硬件级别安全性的寄存器。
- en: The code you write in *ring 3* will typically have extremely restricted access
    to I/O and certain CPU registers (and instructions). Trying to issue an instruction
    or setting a register from *ring 3* to change the page table will be prevented
    by the CPU. The CPU will then treat this as an exception and jump to the handler
    for that exception provided by the OS.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你在*ring 3*中编写的代码通常对I/O和某些CPU寄存器（以及指令）的访问权限非常有限。试图从*ring 3*发出指令或设置寄存器以更改页表将被CPU阻止。然后CPU会将此视为异常，并跳转到操作系统提供的异常处理程序。
- en: This is also the reason why you have no other choice than to cooperate with
    the OS and handle I/O tasks through syscalls. The system wouldn’t be very secure
    if this wasn’t the case.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么你除了与操作系统合作并通过系统调用处理I/O任务外别无选择的原因。如果不是这样，系统将不会非常安全。
- en: 'So, to sum it up: yes, the CPU and the OS cooperate a great deal. Most modern
    desktop CPUs are built with an OS in mind, so they provide the hooks and infrastructure
    that the OS latches onto upon bootup. When the OS spawns a process, it also sets
    its privilege level, making sure that normal processes stay within the borders
    it defines to maintain stability and security.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下：是的，CPU和操作系统之间有很多合作。大多数现代桌面CPU都是考虑到操作系统而设计的，因此它们提供了操作系统在启动时可以抓取的钩子和基础设施。当操作系统创建一个进程时，它也会设置其权限级别，确保普通进程保持在它定义的边界内，以维护稳定性和安全性。
- en: Interrupts, firmware, and I/O
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断、固件和I/O
- en: We’re nearing the end of the general CS subjects in this book, and we’ll start
    to dig our way out of the rabbit hole soon.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束这本书中的一般计算机科学主题，我们很快就会开始从兔子洞中走出来。
- en: This part tries to tie things together and look at how the whole computer works
    as a system to handle I/O and concurrency.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分试图将事物联系起来，并查看整个计算机作为一个系统来处理I/O和并发。
- en: Let’s get to it!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: A simplified overview
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化的概述
- en: 'Let’s look at some of the steps where we imagine that we read from a network
    card:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些步骤，在这些步骤中，我们想象我们从网络卡中读取：
- en: '![](img/B20892_Figure_01.3.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 页表](img/B20892_Figure_01.3.jpg)'
- en: Remember that we’re simplifying a lot here. This is a rather complex operation
    but we’ll focus on the parts that are of most interest to us and skip a few steps
    along the way.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在这里简化了很多。这是一个相当复杂的操作，但我们将关注对我们最有兴趣的部分，并跳过一些步骤。
- en: Step 1 – Our code
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 我们的代码
- en: We register a socket. This happens by issuing a *syscall* to the OS. Depending
    on the OS, we either get a *file descriptor* (macOS/Linux) or a *socket* (Windows).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册一个套接字。这是通过向操作系统发出*系统调用*来完成的。根据操作系统，我们可能得到一个*文件描述符*（macOS/Linux）或一个*套接字*（Windows）。
- en: The next step is that we register our interest in `Read` events on that socket.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是我们注册对那个套接字的`Read`事件的兴趣。
- en: Step 2 – Registering events with the OS
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 在操作系统中注册事件
- en: 'This is handled in one of three ways:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过三种方式之一来处理：
- en: We tell the operating system that we’re interested in `Read` events but we want
    to wait for it to happen by `yielding` control over our thread to the OS. The
    OS then suspends our thread by storing the register state and switches to some
    other thread
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们告诉操作系统我们感兴趣的是`Read`事件，但我们想通过`yielding`对线程的控制权给操作系统来等待它发生。然后操作系统通过存储寄存器状态并切换到其他线程来挂起我们的线程。
- en: '*From our perspective, this will be blocking our thread until we have data*
    *to read.*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*从我们的角度来看，这将阻塞我们的线程，直到我们有数据* *可以读取。*'
- en: We tell the operating system that we’re interested in `Read` events but we just
    want a handle to a task that we can `poll` to check whether the event is ready
    or not.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们告诉操作系统我们感兴趣的是`Read`事件，但我们只想获取一个可以`poll`的任务句柄来检查事件是否已准备好。
- en: '*The OS will not suspend our thread, so this will not block* *our code.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作系统不会挂起我们的线程，所以这不会阻塞* *我们的代码。*'
- en: We tell the operating system that we are probably going to be interested in
    many events, but we want to subscribe to one event queue. When we `poll` this
    queue, it will block our thread until one or more events occur.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们告诉操作系统我们可能对许多事件感兴趣，但我们只想订阅一个事件队列。当我们`poll`这个队列时，它将阻塞我们的线程，直到一个或多个事件发生。
- en: '*This will block our thread while we wait for events* *to occur.*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*这将阻塞我们的线程，直到事件* *发生。*'
- en: Chapters 3 and 4 will go into detail about the third method, as it’s the most
    used method for modern async frameworks to handle concurrency.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章和第4章将详细介绍第三种方法，因为它是现代异步框架处理并发最常用的方法。
- en: Step 3 – The network card
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 网络卡
- en: We’re skipping some steps here, but I don’t think they’re vital to our understanding.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里跳过了某些步骤，但我不认为它们对我们理解至关重要。
- en: On the network card, there is a small microcontroller running specialized firmware.
    We can imagine that this microcontroller is polling in a busy loop, checking whether
    any data is incoming.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络卡上，有一个运行专用固件的微型控制器。我们可以想象这个微型控制器正在忙循环中轮询，检查是否有数据传入。
- en: The exact way the network card handles its internals is a little different from
    what I suggest here, and will most likely vary from vendor to vendor. The important
    part is that there is a very simple but specialized CPU running on the network
    card doing work to check whether there are incoming events.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 网络卡处理其内部的方式与我这里建议的略有不同，并且可能因供应商而异。重要的是，有一个非常简单但专门的CPU在网络卡上运行，以检查是否有传入的事件。
- en: Once the firmware registers incoming data, it issues a *hardware interrupt*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦固件注册了传入的数据，它就会发出*硬件中断*。
- en: Step 4 – Hardware interrupt
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 硬件中断
- en: A modern CPU has a set of **interrupt request line** (**IRQs**) for it to handle
    events that occur from external devices. A CPU has a fixed set of interrupt lines.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU有一组**中断请求线**（**IRQs**）来处理来自外部设备发生的事件。CPU有一组固定的中断线。
- en: A hardware interrupt is an electrical signal that can occur at any time. The
    CPU immediately *interrupts* its normal workflow to handle the interrupt by saving
    the state of its registers and looking up the interrupt handler. The interrupt
    handlers are defined in the **interrupt descriptor** **table** (**IDT**).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件中断是一个可以在任何时候发生的电信号。CPU立即*中断*其正常工作流程，通过保存其寄存器的状态并查找中断处理程序来处理中断。中断处理程序定义在**中断描述符**
    **表**（**IDT**）中。
- en: Step 5 – Interrupt handler
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步 – 中断处理程序
- en: The IDT is a table where the OS (or a driver) registers handlers for different
    interrupts that may occur. Each entry points to a handler function for a specific
    interrupt. The handler function for a network card would typically be registered
    and handled by a *driver* for that card.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: IDT是一个表，其中操作系统（或驱动程序）为可能发生的不同中断注册了处理程序。每个条目都指向特定中断的处理程序函数。网络卡的处理程序通常由该卡的*驱动程序*注册和处理。
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The IDT is not stored on the CPU as it might seem in *Figure 1**.3*. It’s located
    in a fixed and known location in the main memory. The CPU only holds a pointer
    to the table in one of its registers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: IDT并没有存储在CPU上，正如*图1**.3*所示。它位于主内存中的一个固定且已知的位置。CPU只在其一个寄存器中保存指向表的指针。
- en: Step 6 – Writing the data
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步 – 写入数据
- en: This is a step that might vary a lot depending on the CPU and the firmware on
    the network card. If the network card and the CPU support **direct memory access**
    (**DMA**), which should be the standard on all modern systems today, the network
    card will write data directly to a set of buffers that the OS already has set
    up in the main memory.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤可能会因CPU和网络卡的固件而大不相同。如果网络卡和CPU支持**直接内存访问**（**DMA**），这在今天所有现代系统中应该是标准配置，那么网络卡将直接将数据写入操作系统已在主内存中设置的一组缓冲区。
- en: In such a system, the *firmware* on the network card might issue an *interrupt*
    when the data is *written* to memory. DMA is very efficient, since the CPU is
    only notified when the data is already in memory. On older systems, the CPU needed
    to devote resources to handle the data transfer from the network card.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的系统中，网络卡的**固件**可能会在数据写入内存时发出**中断**。DMA非常高效，因为只有在数据已经在内存中时，CPU才会被通知。在较旧的系统中，CPU需要分配资源来处理从网络卡的数据传输。
- en: '*The* **direct memory access controller** *(* **DMAC***) is added to the diagram
    since in such a system, it would control the* *access to memory. It’s not part
    of the CPU as indicated in the previous diagram. We’re deep enough in the rabbit
    hole now, and exactly where the different parts of a system are is not really
    important to us right now, so let’s* *move on.*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接内存访问控制器**（**DMAC**）被添加到图中，因为在这样的系统中，它将控制对内存的访问。它不是CPU的一部分，如前一个图所示。我们现在已经足够深入到这个兔子洞中，而现在系统不同部分的精确位置对我们来说并不真正重要，所以让我们继续前进。'
- en: Step 7 – The driver
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤7 – 驱动程序
- en: The *driver* would normally handle the communication between the OS and the
    network card. At some point, the buffers are filled and the network card issues
    an interrupt. The CPU then jumps to the handler of that interrupt. The interrupt
    handler for this exact type of interrupt is registered by the driver, so it’s
    actually the driver that handles this event and, in turn, informs the kernel that
    the data is ready to be read.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序通常会处理操作系统和网络卡之间的通信。在某个时刻，缓冲区被填满，网络卡发出中断。然后CPU跳转到该中断的处理程序。对于这种特定类型的中断，处理程序是由驱动程序注册的，因此实际上是驱动程序处理这个事件，并反过来通知内核数据已准备好读取。
- en: Step 8 – Reading the data
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤8 – 读取数据
- en: 'Depending on whether we chose method 1, 2, or 3, the OS will do as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们选择的方法1、2或3，操作系统将按以下方式操作：
- en: Wake our thread
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唤醒我们的线程
- en: Return **Ready** on the next poll
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一次轮询时返回**Ready**
- en: Wake the thread and return a `Read` event for the handler we registered
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唤醒线程并为我们注册的处理程序返回一个`Read`事件
- en: Interrupts
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断
- en: 'As you know by now, there are two kinds of interrupts:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，有两种类型的中断：
- en: Hardware interrupts
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件中断
- en: Software interrupts
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件中断
- en: They are very different in nature.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在本质上非常不同。
- en: Hardware interrupts
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件中断
- en: Hardware interrupts are created by sending an electrical signal through an IRQ.
    These hardware lines signal the CPU directly.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件中断是通过发送一个通过IRQ的电信号来创建的。这些硬件线路直接向CPU发出信号。
- en: Software interrupts
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件中断
- en: These are interrupts issued from software instead of hardware. As in the case
    of a hardware interrupt, the CPU jumps to the IDT and runs the handler for the
    specified interrupt.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是来自软件而非硬件的中断。就像硬件中断的情况一样，CPU会跳转到中断描述符表（IDT）并运行指定中断的处理程序。
- en: Firmware
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固件
- en: Firmware doesn’t get much attention from most of us; however, it’s a crucial
    part of the world we live in. It runs on all kinds of hardware and has all kinds
    of strange and peculiar ways to make the computers we program on work.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 固件并没有得到我们大多数人的太多关注；然而，它是我们生活在这个世界中的关键部分。它运行在各种硬件上，并且有各种奇怪和独特的方式使我们所编程的计算机工作。
- en: Now, the firmware needs a microcontroller to be able to work. Even the CPU has
    firmware that makes it work. That means there are many more small ‘CPUs’ on our
    system than the cores we program against.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，固件需要一个微控制器才能工作。甚至CPU也有使其工作的固件。这意味着在我们的系统中，比我们编程的核心还要多出许多小的‘CPU’。
- en: Why is this important? Well, you remember that concurrency is all about efficiency,
    right? Since we have many CPUs/microcontrollers already doing work for us on our
    system, one of our concerns is to not replicate or duplicate that work when we
    write code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么很重要呢？好吧，你还记得并发都是关于效率的，对吧？由于我们已经在系统中有很多CPU/微控制器为我们做工作，我们关心的一点是在编写代码时不要重复或复制这些工作。
- en: If a network card has firmware that continually checks whether new data has
    arrived, it’s pretty wasteful if we duplicate that by letting our CPU continually
    check whether new data arrives as well. It’s much better if we either check once
    in a while, or even better, get notified when data has arrived.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网卡有固件不断检查是否有新数据到达，如果我们让我们的CPU也不断检查是否有新数据到达，那么这将是相当浪费的。如果我们偶尔检查一次，或者更好，当数据到达时得到通知，那就好多了。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered a lot of ground, so good job on doing all that legwork.
    We learned a little bit about how CPUs and operating systems have evolved from
    a historical perspective and the difference between non-preemptive and preemptive
    multitasking. We discussed the difference between concurrency and parallelism,
    talked about the role of the operating system, and learned that system calls are
    the primary way for us to interact with the host operating system. You’ve also
    seen how the CPU and the operating system cooperate through an infrastructure
    designed as part of the CPU.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章覆盖了大量的内容，所以做得很好，完成了所有这些前期工作。我们从历史的角度了解了一些关于CPU和操作系统如何演变的情况，以及非抢占式和抢占式多任务处理之间的区别。我们讨论了并发和并行之间的区别，讨论了操作系统的角色，并了解到系统调用是我们与宿主操作系统交互的主要方式。你也看到了CPU和操作系统如何通过作为CPU一部分设计的底层设施进行合作。
- en: Lastly, we went through a diagram on what happens when you issue a network call.
    You know there are at least three different ways for us to deal with the fact
    that the I/O call takes some time to execute, and we have to decide which way
    we want to handle that waiting time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过一个图表了解了当你发起网络调用时会发生什么。你知道至少有三种不同的方式来处理I/O调用需要一些时间来执行的事实，我们必须决定我们想要处理那种等待时间的方式。
- en: This covers most of the general background information we need so that we have
    the same definitions and overview before we go on. We’ll go into more detail as
    we progress through the book, and the first topic that we’ll cover in the next
    chapter is how programming languages model asynchronous program flow by looking
    into threads, coroutines and futures.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们需要的大部分一般性背景信息，这样我们才能在继续之前拥有相同的定义和概述。随着我们在书中不断前进，我们将更详细地探讨，下一章我们将讨论的第一个主题是编程语言如何通过研究线程、协程和未来来模拟异步程序流程。
