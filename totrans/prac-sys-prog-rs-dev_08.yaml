- en: '*Chapter 6*: Working with Files and Directories in Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：在 Rust 中处理文件和目录'
- en: In the previous chapter, we looked at the details of how Rust uses memory, a
    key system resource.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Rust 使用内存的细节，内存是关键的系统资源。
- en: In this chapter, we will look at how Rust interacts with another important class
    of system resources – **files** and **directories**. The Rust Standard Library
    offers a rich set of abstractions that enable platform-independent file and directory
    operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Rust 如何与另一类重要的系统资源——**文件**和**目录**——交互。Rust 标准库提供了一套丰富的抽象，使得平台无关的文件和目录操作成为可能。
- en: For this chapter, we will review the basics of how files are managed by Unix/Linux,
    and master the key APIs that the Rust Standard Library provides to deal with *files*,
    *paths*, *links*, and *directories*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将回顾 Unix/Linux 管理文件的基本知识，并掌握 Rust 标准库提供的用于处理**文件**、**路径**、**链接**和**目录**的关键
    API。
- en: Using the Rust Standard Library, we will implement a shell command, `rstat`,
    that counts the total number of lines of Rust code in a directory (and its subfolders),
    and provides a few additional source code metrics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rust 标准库，我们将实现一个 shell 命令 `rstat`，该命令计算目录（及其子目录）中 Rust 代码的总行数，并提供一些额外的源代码度量指标。
- en: 'We will cover the topics in the following order:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下顺序介绍主题：
- en: Understanding Linux system calls for file operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux 文件操作的系统调用
- en: Doing file I/O in Rust
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中进行文件 I/O 操作
- en: Learning directory and path operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习目录和路径操作
- en: Setting hard links, symbolic links, and performing queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置硬链接、符号链接和执行查询
- en: Writing a shell command in Rust (project)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中编写 shell 命令（项目）
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Verify that `rustc`, and `cargo` have been installed correctly with the following
    command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证 `rustc` 和 `cargo` 是否已正确安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的 Git 仓库可以在 [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06)
    找到。
- en: Understanding Linux system calls for file operations
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Linux 文件操作的系统调用
- en: In this section, we will look at the terminology and basic mechanisms associated
    with managing file system resources at the operating system level. We will use
    Linux/Unix as an example, but similar concepts apply to other operating systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨与操作系统级别管理文件系统资源相关的术语和基本机制。我们将以 Linux/Unix 为例，但类似的概念也适用于其他操作系统。
- en: So, what do you think a file is?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你认为文件是什么？
- en: A **file** is just a set of bytes. A **byte** represents a unit of information—it
    can be a number, text, video, audio, image, or any other such digital content.
    The bytes are organized in a *linear array* called a **byte stream**. There is
    no other expectation in terms of the structure or contents of a file, as far as
    the operating system is concerned. It is the *user application* that does the
    interpretation of the file and its contents.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**只是一组字节。**字节**代表信息的一个单位——它可以是一个数字、文本、视频、音频、图像或其他类似的数字内容。字节组织在一个称为**字节流**的**线性数组**中。从操作系统的角度来看，文件的结构或内容没有其他期望。对文件的解释及其内容是由**用户应用程序**来完成的。'
- en: A **user application** is a program that is not a part of the operating system
    kernel. An example of a user application is an image viewer that interprets the
    bytes of data as an image. Since files are resources that are managed by the operating
    system, any user programs that we write must know how to interact with the operating
    system through system calls. A file can be read from, written to, or executed.
    An example of a file that can be executed is the binary executable (object) file,
    generated by software build systems such as **Make** or **Cargo**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户应用程序**是一个不属于操作系统内核的程序。一个用户应用程序的例子是图像查看器，它将数据字节解释为图像。由于文件是由操作系统管理的资源，因此我们编写的任何用户程序都必须知道如何通过系统调用来与操作系统交互。文件可以被读取、写入或执行。一个可以执行的文件示例是由
    **Make** 或 **Cargo** 等软件构建系统生成的二进制可执行（对象）文件。'
- en: 'Another aspect that is unique to Linux/Unix is the philosophy that *everything
    is a file*. Here, *everything* refers to system resources. There can be many types
    of files on Linux/Unix:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Linux/Unix独有的另一个方面是“一切皆文件”的哲学。在这里，“一切”指的是系统资源。Linux/Unix上可以存在许多类型的文件：
- en: '**Regular files**, which we use to store text or binary data'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常规文件**，我们用它来存储文本或二进制数据'
- en: '**Directories**, which contain listings of names and references to other files'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**，包含名称列表和其他文件的引用'
- en: '**Block device files**, for example, a hard disk, a tape drive, USB cameras'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块设备文件**，例如硬盘、磁带驱动器、USB摄像头'
- en: '**Character device files**, for example, a terminal, a keyboard, a printer,
    a sound card'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符设备文件**，例如终端、键盘、打印机、声卡'
- en: '**Named pipes**, an in-memory inter-process communication mechanism'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名管道**，一种内存中的进程间通信机制'
- en: '**Unix domain sockets**, also a form of inter-process communication'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix域套接字**，也是一种进程间通信的形式'
- en: '**Links**, such as hard links and symbolic links'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**，如硬链接和符号链接'
- en: In this chapter, we will focus on files, directories, and links. However, the
    universality of the Unix I/O model means that the same set of system calls used
    to open, read, write, and close regular files can also be used on any other types
    of files such as **device files**. This is achieved in Linux/Unix by standardizing
    the system calls, which are then implemented by various filesystems and device
    drivers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注文件、目录和链接。然而，Unix I/O模型的通用性意味着用于打开、读取、写入和关闭常规文件的同一系列系统调用也可以用于任何其他类型的文件，如**设备文件**。在Linux/Unix中，这是通过标准化系统调用实现的，然后由各种文件系统和设备驱动程序实现。
- en: Linux/Unix also provides a unified `/mnt/cdrom`, which becomes the location
    to access the root of the filesystem. The root directory of a "filesystem" can
    be accessed at the mount point.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Linux/Unix还提供了一个统一的`/mnt/cdrom`，它成为访问文件系统根目录的位置。文件系统的根目录可以在挂载点访问。
- en: The **mount namespace** of a process is the set of all mounted filesystems it
    sees. A process that makes system calls for file operations operates on the set
    of files and directories that it sees as a part of its mount namespace.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的**挂载命名空间**是它看到的所有挂载文件系统的集合。执行文件操作的系统调用进程在它视为其挂载命名空间一部分的文件和目录集合上操作。
- en: 'The Unix/Linux system calls (**Application Programming Interface - API**) model
    for file operations hinges on four operations: **open**, **read**, **write**,
    and **close**, all of which work with the concept of **file descriptors**. What
    is a file descriptor?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Unix/Linux系统调用（**应用程序编程接口 - API**）模型中的文件操作依赖于四个操作：**打开**、**读取**、**写入**和**关闭**，所有这些操作都与**文件描述符**的概念相关。什么是文件描述符？
- en: A file descriptor is a handle to a file. Opening a file returns a file descriptor,
    and other operations such as reading, writing, and closing use the file descriptor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是文件的句柄。打开一个文件会返回一个文件描述符，而读取、写入和关闭等操作则使用文件描述符。
- en: More about file descriptors
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于文件描述符的信息
- en: File operations such as read and write are performed by processes. A process
    performs these operations by invoking system calls on the kernel. As soon as a
    file is opened by a process, the kernel records it in a *file table*, where each
    entry contains details of the open file including the **file descriptor** (**fd**)
    and **file position**. Each Linux process has a limit on the number of files it
    can open.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 读写等文件操作由进程执行。进程通过在内核上调用系统调用来执行这些操作。一旦进程打开一个文件，内核就会在**文件表**中记录它，其中每个条目都包含打开文件的详细信息，包括**文件描述符**（**fd**）和**文件位置**。每个Linux进程对其可以打开的文件数量都有一个限制。
- en: 'To the kernel, all open files are referred to by file descriptors. When a process
    opens an existing file or creates a new file, the kernel returns a file descriptor
    to the process. By default, when a process is started from a shell, three file
    descriptors are automatically created: `open: 0 – standard input (stdin)`, `1-
    standard output(stdout)`, and `2-standard error(stderr)`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '对于内核来说，所有打开的文件都通过文件描述符来引用。当进程打开一个现有文件或创建一个新文件时，内核会返回一个文件描述符给进程。默认情况下，当进程从shell启动时，会自动创建三个文件描述符：`open:
    0 – 标准输入(stdin)`、`1- 标准输出(stdout)`和`2- 标准错误(stderr)`。'
- en: The kernel maintains a table of all open file descriptors. If the process opens
    or creates a file, the kernel allocates the next free file descriptor from the
    pool of free file descriptors. When a file is closed, the file descriptor is released
    back to the pool and is available for re-allotment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 内核维护一个所有打开文件描述符的表。如果进程打开或创建一个文件，内核从空闲文件描述符池中分配下一个空闲的文件描述符。当文件关闭时，文件描述符被释放回池中，并可用于重新分配。
- en: 'Let''s now look at the common *system calls* associated with file operations,
    which the operating system exposes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下与文件操作相关的常见 *系统调用*，操作系统将这些调用暴露出来：
- en: '`open()`: This system call opens an existing file. It can also create a new
    file if the file does not exist. It accepts a pathname, the mode in which the
    file is to be opened, and flags. It returns a file descriptor that can be used
    in subsequent system calls to access the file:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open()`: 这个系统调用打开一个现有文件。如果文件不存在，它还可以创建一个新文件。它接受一个路径名、文件打开的模式和标志。它返回一个文件描述符，可以在后续的系统调用中使用该文件描述符来访问文件：'
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`read()`: This system call accepts three arguments: a *file descriptor*, the
    *number of bytes* to be read, and the *memory address of the buffer* into which
    the data read is to be placed. It returns the number of bytes read. `-1` is returned
    in the event of an error when reading the file.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read()`: 这个系统调用接受三个参数：一个 *文件描述符*、要读取的 *字节数* 以及数据读取后要放置的 *缓冲区内存地址*。它返回读取的字节数。在读取文件时发生错误时返回
    `-1`。'
- en: '`write()`: This system call is similar to `read()`, in that it also takes three
    parameters – a *file descriptor*, a *buffer pointer* from which to read the data,
    and the *number of bytes* to read from the buffer. Note that successful completion
    of the `write()` system call does not guarantee that the bytes have been written
    to disk immediately, as the kernel performs buffering of I/O to disk for performance
    and efficiency reasons.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write()`: 这个系统调用与 `read()` 类似，因为它也接受三个参数——一个 *文件描述符*、一个从其中读取数据的 *缓冲区指针* 以及从缓冲区中读取的
    *字节数*。请注意，`write()` 系统调用的成功完成并不保证字节立即写入磁盘，因为内核为了性能和效率原因对磁盘的 I/O 进行了缓冲。'
- en: '`close()`: This system call accepts a *file descriptor* and releases it. If
    a `close()` call is not explicitly invoked for a file, all open files are closed
    when the process terminates. But it is good practice to release file descriptors
    (when no longer needed) for reuse by the kernel.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close()`: 这个系统调用接受一个 *文件描述符* 并释放它。如果对一个文件没有显式调用 `close()`，那么当进程结束时，所有打开的文件都会被关闭。但是，为了重用内核，在不再需要时释放文件描述符（文件描述符）是一个好的做法。'
- en: '`lseek()`: For each open file, the kernel keeps track of a file offset, which
    represents the location in the file at which the next read or write operation
    will happen. The system call `lseek()` allows you to reposition the file offset
    to any location in the file. The `lseek()` system call accepts three arguments
    – the file descriptor, an offset, and a reference position. The reference position
    can take three values – *start of file*, *current cursor position*, or *end of
    file*. The offset specifies the number of bytes relative to the reference position
    that the file offset should be pointed to, for the next `read()` or `write()`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lseek()`: 对于每个打开的文件，内核跟踪一个文件偏移量，它表示下一次读取或写入操作将在文件中的位置。`lseek()` 系统调用允许你将文件偏移量重新定位到文件中的任何位置。`lseek()`
    系统调用接受三个参数——文件描述符、偏移量和参考位置。参考位置可以取三个值——*文件开头*、*当前光标位置*或*文件结尾*。偏移量指定相对于参考位置的字节数，文件偏移量应指向该位置，以便进行下一次
    `read()` 或 `write()` 操作。'
- en: This concludes the overview of terminologies and key concepts of how operating
    systems manage files as system resources. We have seen the main system calls (`syscalls`)
    in Linux for working with files. We will not be directly using these `syscalls`
    in this book. But we will work with these `syscalls` indirectly, through the Rust
    Standard Library modules. The Rust Standard Library provides higher-level *wrappers*
    to make it easier to work with these `syscalls`. These *wrappers* also allow Rust
    programs to work without necessarily understanding all the differences in `syscalls`
    across different operating systems. However, gaining basic knowledge of how operating
    systems manage files gives us a glimpse into what goes on under the hood when
    we use the Rust Standard Library for file and directory operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对操作系统如何管理文件作为系统资源术语和关键概念的概述。我们已经看到了 Linux 中用于处理文件的 主要系统调用（`syscalls`）。在这本书中，我们不会直接使用这些
    `syscalls`。但我们将通过 Rust 标准库模块间接地使用这些 `syscalls`。Rust 标准库提供了更高层次的 *包装器*，以便更容易地使用这些
    `syscalls`。这些 *包装器* 还允许 Rust 程序在没有必要了解不同操作系统之间 `syscalls` 的所有差异的情况下工作。然而，了解操作系统如何管理文件，可以让我们窥见当我们使用
    Rust 标准库进行文件和目录操作时，底层发生了什么。
- en: In the next section, we will cover how to do file I/O in Rust.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何在 Rust 中进行文件输入/输出操作。
- en: Doing file I/O in Rust
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中进行文件 I/O 操作
- en: In this section, we will look at the Rust method calls that let us work with
    files in Rust programs. The Rust Standard Library spares the programmer from having
    to work with system calls directly and provides a set of wrapper methods exposing
    APIs for common file operations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Rust 方法调用，这些调用使我们能够在 Rust 程序中处理文件。Rust 标准库让程序员免于直接处理系统调用，并提供了一组包装方法，这些方法公开了常见文件操作的
    API。
- en: 'The primary module in the Rust Standard Library for working with files is `std::fs`.
    The official documentation for `std::fs` can be found here: [https://doc.rust-lang.org/std/fs/index.html](https://doc.rust-lang.org/std/fs/index.html).
    This documentation provides the set of methods, structs, enums, and traits that
    collectively provide features for working with files. It helps to study the structure
    of the `std::fs` module to gain a deeper understanding. However, for those starting
    out with exploring system programming in Rust, it is more useful to begin with
    a mental model of what kinds of things a programmer would like to do with files,
    and map it back to the Rust Standard Library. This is what we will do in this
    section. The common lifecycle operations for a file are shown in *Figure 6.1*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 标准库中用于处理文件的主要模块是 `std::fs`。`std::fs` 的官方文档可以在这里找到：[https://doc.rust-lang.org/std/fs/index.html](https://doc.rust-lang.org/std/fs/index.html)。该文档提供了一组方法、结构体、枚举和特质，这些方法共同提供了处理文件的功能。研究
    `std::fs` 模块的结构有助于加深理解。然而，对于刚开始探索 Rust 系统编程的人来说，从程序员希望对文件执行的操作的心理模型开始，并将其映射回 Rust
    标准库，可能更有用。这就是本节我们将要做的事情。文件的常见生命周期操作在 *图 6.1* 中展示。
- en: '![Figure 6.1 – Common file life cycle operations](img/Figure_6.1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 常见的文件生命周期操作](img/Figure_6.1.jpg)'
- en: Figure 6.1 – Common file life cycle operations
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 常见的文件生命周期操作
- en: 'The common things programmers like to do with files include creating a file,
    opening and closing files, reading and writing files, accessing metadata about
    files, and setting file permissions. These are shown in *Figure 6.1*. Descriptions
    of how to perform each of these file operations using the Rust Standard Library
    are provided here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员喜欢对文件执行的一些常见操作包括创建文件、打开和关闭文件、读取和写入文件、访问文件的元数据以及设置文件权限。这些操作在 *图 6.1* 中展示。这里提供了如何使用
    Rust 标准库执行每个文件操作的描述：  '
- en: '`std::fs` module is `File::create()`, which allows you to create a new file
    and write to it. Custom permissions for the file to be created can be specified
    using the `std::fs::OpenOptions` struct. An example of a *create* operation using
    the `std::fs` module is shown in the code snippet here:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs` 模块中的 `File::create()` 允许你创建一个新文件并向其写入。可以使用 `std::fs::OpenOptions`
    结构指定要创建的文件的自定义权限。下面是一个使用 `std::fs` 模块进行 *创建* 操作的代码片段示例：'
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`std::fs::File::open()`. This opens a file in *read-only* mode by default.
    The `std::fs::OpenOptions` struct can be used to set *custom permissions* to create
    the file. Two methods to open a file are shown below. The first function returns
    a `Result` type, which we are just handling using `.expect()`, which panics with
    a message if the file is not found. The second function uses `OpenOptions` to
    set additional permissions on the file to be opened. In the example shown, we
    are opening a file for the *write* operation, and also are asking for the file
    to be created if not present already:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs::File::open()`。默认情况下，它以*只读*模式打开文件。可以使用`std::fs::OpenOptions`结构来设置创建文件的*自定义权限*。以下展示了两种打开文件的方法。第一个函数返回一个`Result`类型，我们只是使用`.expect()`来处理它，如果文件未找到，则抛出带有消息的异常。第二个函数使用`OpenOptions`为要打开的文件设置额外的权限。在示例中，我们正在打开一个文件进行*写*操作，并且要求如果文件尚未存在则创建该文件：'
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`std::fs::copy()` function can be used to copy the contents of one file to
    another, overwriting the latter. An example is shown here:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs::copy()`函数可用于将一个文件的内容复制到另一个文件，并覆盖后者。以下是一个示例：'
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`std::fs::rename()` function can be used for this purpose. If the *to* file
    exists, it is replaced. One thing to note is that there can be more than one filesystem
    mounted (at various points) within the *mount namespace* of a process, as seen
    in the previous section. The `rename` method in Rust will work only if both the
    *from* and *to* file paths are in the same filesystem. An example of usage of
    the `rename()` function is shown here:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs::rename()`函数可用于此目的。如果*目标*文件已存在，则将其替换。需要注意的是，在进程的*挂载命名空间*中可以挂载多个文件系统（在各个位置），如前节所示。Rust中的`rename`方法只有在*源*和*目标*文件路径位于同一文件系统中时才会工作。以下是一个`rename()`函数用法的示例：'
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`std::fs` module, there are two functions available: `fs::read()` and `fs::read_to_string()`.
    The former reads the contents of a file into a `bytes vector`. It pre-allocates
    a buffer based on file size (when available). The latter reads the contents of
    a file directly into a string. Examples are shown here:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs`模块中提供了两个函数：`fs::read()`和`fs::read_to_string()`。前者将文件内容读取到一个`bytes`向量中。它根据文件大小（如果可用）预分配一个缓冲区。后者直接将文件内容读取到字符串中。以下是一些示例：'
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`std::fs`, the `fs::write()` function accepts a *filename* and a *byte slice*,
    and writes the *byte slice* as the contents of the file. An example is shown here:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs`模块中的`fs::write()`函数接受一个*文件名*和一个*字节切片*，并将*字节切片*作为文件的内容写入。以下是一个示例：'
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`std::fs` module. The functions `is_dir()`, `is_file()`, and `is_symlink()`
    respectively check whether a file is a *regular file*, *directory*, or a *symlink*.
    The `modified()`, `created()`, `accessed()` , `len()`, and `metadata()` functions
    are used to retrieve file metadata information. The `permissions()` function is
    used to retrieve a list of permissions on the file.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fs`模块。函数`is_dir()`、`is_file()`和`is_symlink()`分别检查一个文件是否是*常规文件*、*目录*或*符号链接*。`modified()`、`created()`、`accessed()`、`len()`和`metadata()`函数用于检索文件元数据信息。`permissions()`函数用于检索文件上的权限列表。'
- en: 'A few examples of the usage of query operations are shown here:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面展示了查询操作的几个示例：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`set_permissions()`. An example is shown here, where, after setting the file
    permission to read-only, the write operation to the file fails:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_permissions()`。以下是一个示例，其中在将文件权限设置为只读后，对文件的写操作失败：'
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`close()` method in the Rust Standard Library to close files.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust标准库中的`close()`方法用于关闭文件。
- en: In this section, we saw the key function calls from the Rust Standard Library
    that can be used to perform *file manipulation* and *query* operations. In the
    next section, we will take a look at how the Rust Standard Library can be used
    for *directory* and *path* operations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了Rust标准库中用于执行*文件操作*和*查询*操作的关键函数调用。在下一节中，我们将探讨如何使用Rust标准库进行*目录*和*路径*操作。
- en: Learning directory and path operations
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习目录和路径操作
- en: The kernel in Linux (and other Unix variants) maintains a single directory tree
    structure visible to a process, which is hierarchical and contains all files in
    that namespace. This hierarchical organization contains both individual files,
    directories, and links (for example, a symbolic link).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Linux（以及其他Unix变体）的内核维护一个对进程可见的单个目录树结构，它是分层的，包含该命名空间中的所有文件。这种分层组织包含单个文件、目录和链接（例如，符号链接）。
- en: In the previous section, we looked at *files* and file operations in Rust. In
    this section, we will take a closer look at *directory* and *path* operations.
    In the next section, we will cover *links*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'A *directory* is a special file that contains a list of filenames with references
    (`/` represents the root directory, and `/home` and `/etc` will link to `/` as
    the *parent* directory. (Note that in some operating systems, such as Microsoft
    Windows variants, each disk device has its own hierarchy of files, and there is
    not a single unified namespace.) Each directory contains at least two entries
    – a *dot entry* pointing to itself and a *dot-dot* directory, which is a link
    to its parent directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Common directory and path operations](img/Figure_6.2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Common directory and path operations
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In the Rust Standard Library, the `std::fs` module contains methods to work
    with directories, and the `std::path` module contains methods to work with *paths*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as in the previous section, we will look at the common programming tasks
    involving *directory* and *path* manipulations. These are shown in *Figure 6.2*
    and detailed here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fs` module. The `std::fs::read_dir()` function can be used to iterate
    through and retrieve the entries in a directory. From the directory entry thus
    retrieved, the metadata details of the directory entry can be obtained with the
    functions `path()`, `metadata()`, `file_name()`, and `file_type()`. Examples of
    how to do this are shown here:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we'll look at how to construct directory trees programmatically.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`std::fs` module. The Rust `std::fs:DirBuilder` struct provides methods to
    recursively construct a directory structure. An example of creating a directory
    structure recursively is shown here:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that there are two other functions also available to create directories.
    `create_dir()` and `create_dir_all()` in `std::fs` can be used for this purpose.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Likewise, the functions `remove_dir()` and `remove_dir_all()` in the `std::fs`
    module can be used to delete directories.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll look at how to construct path strings dynamically.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`/usr/bob/a.txt`, `usr` and `bob` represent directories, while `a.txt` represents
    a file. The Rust Standard Library provides facilities to construct a path string
    (representing the full path to a file or a directory) programmatically. This is
    available in `std::path::PathBuf`. An example of how to construct a path dynamically
    is shown here:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the code shown, a new variable of type `PathBuf` is constructed, and the
    various path components are dynamically added to create a fully qualified path.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this subsection on directory and path operations with the Rust
    Standard Library.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how to use the Rust Standard Library to read through
    directory entries, get their metadata, construct a directory structure programmatically,
    get path components, and build a path string dynamically.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to work with *links* and *queries*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Setting hard links, symbolic links, and performing queries
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw earlier that a directory is treated in a file system similarly to a
    regular file. But it has a different file type, and it contains a list of filenames
    with their inodes. `ls –li` command shows the inode number corresponding to a
    file, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_6.3.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Inode numbers visible in the file listing
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Since a directory contains a listing that maps *filenames* with *inode numbers*,
    there can be multiple filenames that map to the same inode number. Such multiple
    names are called `ln` shell command. Not all non-UNIX filesystems support such
    hard links.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Within a file system, there can be many *links* to the same file. All of them
    are essentially the same, as they point to the same file. Most files have a *link
    count* of 1 (meaning there is a single directory entry for that file), but a file
    can have a *link count* > 1 ( for example, if there are two links pointing to
    the same *inode* entry, there will be two directory entries for that file, and
    the *link count* will be 2). The kernel maintains this *link count*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: A *hard link* has a limitation in that they can refer only to files within the
    same file system because inode numbers are unique only within a file system. There
    is another type of link called a `ln –s` command. Since a symbolic link refers
    to a filename instead of an inode number, it can refer to a file in another filesystem.
    Also, unlike hard links, symbolic links can be created in directories.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following points, we will see the methods in the Rust Standard Library
    that can be used to create and query hard links and symbolic links (symlinks):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fs` module has a function, `fs::hard_link`, that can be used to create
    a new hard link on the file system. An example is shown here:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`symlink` using the Rust Standard Library vary by platform. On Unix/Linux,
    the `std::os::unix::fs::symlink` method can be used. On windows, there are two
    APIs – `os::windows::fs::symlink_file` to create a *symbolic link* to a file,
    or `os::windows::fs::symlink_dir` to create a `symlink` to a directory. An example
    of creating a `symlink` on Unix-like platforms is shown here:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `fs::read_link` function can be used to read a symbolic link as shown in
    the code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: With this, we conclude the subsection on working with links in the Rust Standard
    Library. We have so far seen how to work with files, directories, paths, and links
    in Rust. In the next section, we will build a small shell command that demonstrates
    the practical use of the Rust Standard Library for file and directory operations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Writing a shell command in Rust (project)
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use our knowledge of the Rust Standard Library on file
    and directory operations that we learned in previous sections to implement a shell
    command.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: What will the shell command do?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The shell command will be called **rstat**, short for **Rust source statistics**.
    Given a directory as an argument, it will generate a *file count* of Rust source
    files, and source code metrics such as the *number of blanks*, *comments*, and
    *actual lines of code* within the directory structure.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该shell命令将被命名为**rstat**，即**Rust源统计**。给定一个目录作为参数，它将生成Rust源文件的*文件计数*，以及目录结构内的源代码度量，如*空白数*、*注释*和*实际代码行数*。
- en: 'Here is what you will type:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你将输入的内容：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is an example of the result you will see from this shell command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从这个shell命令中看到的结果示例：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This section is structured as four sub-sections. In the first sub-section, we
    will see an overview of the code structure and a summary of steps to build this
    shell command. Then, in three different subsections, we will review the code for
    the three source files corresponding to error handling, source metric computation,
    and the main program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节分为四个子节。在第一个子节中，我们将概述代码结构并总结构建此shell命令的步骤。然后，在三个不同的子节中，我们将回顾与错误处理、源度量计算和主程序对应的三个源文件的代码。
- en: Code overview
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码概述
- en: In this subsection, we will look at how the code is structured for the shell
    command. We will also review a summary of the steps to build the shell command.
    Let's get started.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本子节中，我们将探讨shell命令的代码结构。我们还将回顾构建shell命令的步骤摘要。让我们开始吧。
- en: 'The code structure is shown in *Figure 6.4*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码结构如图*6.4*所示：
- en: '![Figure 6.4 – Shell command code structure](img/Figure_6.4.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – Shell命令代码结构](img/Figure_6.4.jpg)'
- en: Figure 6.4 – Shell command code structure
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – Shell命令代码结构
- en: 'Here is a summary of the steps to build the shell command. The source code
    snippets are shown later in this section:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是构建shell命令的步骤摘要。源代码片段将在本节后面展示：
- en: 'Create project: Create a new project with the following command and change
    directory into the `rstat` directory:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目：使用以下命令创建一个新项目，并将目录更改为`rstat`目录：
- en: '[PRE17]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create source files: Create three files under the `src` folder – `main.rs`,
    `srcstats.rs`, and `errors.rs`.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建源文件：在`src`文件夹下创建三个文件 – `main.rs`、`srcstats.rs`和`errors.rs`。
- en: 'Define custom error handling: In `errors.rs`, create a struct, `StatsError`,
    to represent our custom error type. This will be used to unify error handling
    in our project and to send messages back to the user. Implement the following
    four traits on `struct StatsError` : `fmt::Display, From<&str>`, `From<io::Error>`,
    and `From<std::num::TryFromIntError>`.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义自定义错误处理：在`errors.rs`中，创建一个结构体`StatsError`来表示我们的自定义错误类型。这将用于统一我们项目中的错误处理并向用户发送消息。在`struct
    StatsError`上实现以下四个特质：`fmt::Display`、`From<&str>`、`From<io::Error>`和`From<std::num::TryFromIntError>`。
- en: 'Define logic for computing source stats: In `srcstats.rs`, create a struct,
    `SrcStats`, to define the source metrics to be computed. Define two functions:
    `get_src_stats_for_file()` (which accepts a filename as an argument and computes
    the source metrics for that file) and `get_summary_src_stats()` (which takes a
    directory name as an argument and computes source metrics for all files in that
    directory root).'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义计算源统计的逻辑：在`srcstats.rs`中，创建一个结构体`SrcStats`来定义要计算的源度量。定义两个函数：`get_src_stats_for_file()`（接受一个文件名作为参数并计算该文件的源度量）和`get_summary_src_stats()`（接受一个目录名称作为参数并计算该目录根下所有文件的源度量）。
- en: 'Write the main() function to accept command-line parameters:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`main()`函数以接受命令行参数：
- en: In `main.rs`, define a `Opt` struct to define command-line parameters and flags
    for the shell command. Write the `main()` function, which accepts a source directory
    name from the command line and invokes the `get_summary_src_stats()` method in
    the `srcstats` module. Ensure to include `Cargo.toml` under dependencies.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`main.rs`中，定义一个`Opt`结构来定义shell命令的命令行参数和标志。编写`main()`函数，该函数从命令行接受源目录名称并调用`srcstats`模块中的`get_summary_src_stats()`方法。确保在依赖项中包含`Cargo.toml`。
- en: 'Build the tool with the following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建工具：
- en: '[PRE18]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the shell command with the following command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行shell命令：
- en: '[PRE19]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'LD_LIBRARY_PATH can be set as shown here (equivalent commands can be used for
    Windows):'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以像下面这样设置LD_LIBRARY_PATH（对于Windows可以使用等效命令）：
- en: '[PRE20]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: View the consolidated source stats printed to the terminal and confirm the metrics
    generated.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看打印到终端的汇总源统计并确认生成的度量。
- en: Let's now look at the code snippets for the steps listed previously. We will
    start by defining custom error handling.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看之前列出的步骤的代码片段。我们将首先定义自定义错误处理。
- en: Error handling
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'While executing our shell command, several things can go wrong. The source
    folder specified may be invalid. The permissions may be insufficient to view the
    directory entries. There can be other types of I/O errors such as those listed
    here: [https://doc.rust-lang.org/std/io/enum.ErrorKind.html](https://doc.rust-lang.org/std/io/enum.ErrorKind.html).
    In order for us to give a meaningful message back to the user, we will create
    a custom error type. We will also write conversion methods that will automatically
    convert different types of I/O errors into our custom error type by implementing
    various `From` traits. All this code is stored in the `errors.rs` file. Let''s
    review the code snippets from this file in two parts:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 covers the definition of the custom error type and `Display` trait implementation.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 2 covers the various `From` trait implementations for our custom error
    type.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 1 of the `errors.rs` code is shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: src/errors.rs (part-1)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here the `StatsError` struct is defined with a field `message` that will be
    used to store the error message, which will get propagated to the user in case
    of errors. We have also implemented the `Display` trait to enable the error message
    to get printed to the console.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see part 2 of the `errors.rs` file. Here, we implement the various
    `From` trait implementations, as shown here. Code annotations are numbered, and
    are described after the code listing:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: src/errors.rs (part-2)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The source code annotations (shown with numbers) are detailed here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Helps to construct a `StatsError` from a string
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Converts `IO:Error` to `StatsError`
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Used to check for errors while converting `usize` into `u32`
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we reviewed the code for the `errors.js` file. In the next
    section, we will see the code for the computation of source code metrics.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Source metric computation
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at the code for the `srcstats.rs` file. The code
    snippets for this file are shown in the following order in separate parts:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1*: Module imports'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2:* Definition of the `SrcStats` struct'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3*: Definition of the `get_summary_src_stats()` function'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 4:* Definition of the `get_src_stats_for_file()` function'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at *part 1*. The module imports are shown here. The descriptions
    corresponding to code annotation numbers are shown after the code listing:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part-1)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The descriptions for the numbered code annotations are listed here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '`TryFrom` is used to capture any errors in converting `usize` to `u32`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OsStr` is used to check for files with the `.rs` extension.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::fs` is the main module in the Rust Standard Library for file and directory
    operations.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirEntry` is a struct used by Rust Standard Library to denote individual directory
    entries.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path` and `PathBuf` are used to store path names. `&Path` is similar to `&str`
    and `PathBuf` is similar to `String`. One is a reference and another is an owned
    object.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any errors in reading files or computations are converted to the custom error
    type `StatsError`. This is imported in this line.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now look at *part 2*. The definition of the struct to store computed
    metrics is covered here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The struct `SrcStats` contains the following source metrics, which will be
    generated by our shell command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The number of Rust source files
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A count of lines of code (excluding comments and blanks)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of blank lines
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of comment lines (single-line comments that begin with `//`; note
    that we are not considering multi-line comments in the scope of this tool)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Rust data structure to hold the computed source file metrics is shown next:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part-2)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s look at *part 3*, which is the main function that computes summary statistics.
    As this code is a bit long, we will look at this in three parts:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Part 3a of the code snippet shows variable initialization.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 3b of the code snippet shows the main code that recursively retrieves the
    Rust source files within a directory.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In part 3c, we iterate through the list of Rust files and invoke the `get_src_stats_for_file()`
    method to compute source metrics for each file. The results are consolidated.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3a of the `get_summary_src_stats()` method is shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part 3a)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Part 3a shows the initialization of variables representing the various metrics
    that will be computed by the shell command – `total_loc`, `total_comments`, and
    `total_blanks`. Two more variables, `dir_entries` and `file_entries`, are initialized
    as `vector` data types, which will be used for intermediate computations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3b of the `get_summary_src_stats()` method is shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part-3b)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In part 3b of the code, we are iterating through the entries within the specified
    folder and segregating the entries of the type *directory* from the entries of
    the type *file*, and storing them in separate `vector` variables.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3c of the `get_summary_src_stats()` method is shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part 3c)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will now look at *part 4*, which is the code to compute source metrics for
    an individual Rust source file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part-4)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In part 4, the code for the `get_src_stats_for_file()` function is shown. This
    function reads the source file line by line and determines whether the line corresponds
    to a regular line of code, or blanks, or comments. Based on this classification,
    the respective counters are incremented. The final result is returned as the `SrcStats`
    struct from the function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the code listing for the `srcstats` module. In this subsection,
    we reviewed the code for computing source code metrics. In the next section, we
    will review the code for the last part of the code listing, which is the `main()`
    function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The main() function
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, we will now look at the final part of the code, which is
    the `main()` function that represents the entry point into the binary. It performs
    four tasks:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Accepts user inputs from the command line.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invokes the appropriate method to compute the source code metrics.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Displays the result to the user.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the event of errors, a suitable error message is displayed to the user.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code listing for the `main()` function is shown in two parts:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 shows the structure of the command-line interface for the shell command.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 2 shows the code to invoke calls for the computation of source metrics
    and to display the results to the user.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 1* of `main.rs` is shown here. We will use the `structopt` crate to define
    the structure of the command line inputs to be accepted from the user.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the `Cargo.toml` file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code listing for *part 1* is shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: src/main.rs (part-1)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In part 1 of the code shown, a data structure, `Opt`, is defined, which contains
    two fields – `in_dir`, representing the path to the input folder (for which source
    metrics are to be computed), and a field, `mode`. The value for `mode` in our
    example is `src`, which indicates that we want to compute source code metrics.
    In the future, additional modes can be added (such as the `object` mode to compute
    object file metrics such as the size of the executable and library object files).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'In *part 2* of this code, we read the source folder from user''s command-line
    argument, and invoke the `get_summary_src_stats()` method from the `srcstats`
    module, which we reviewed in the previous subsection. The metrics returned by
    this method are then shown to user in the terminal. *Part 2* of the code listing
    is shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: src/main.rs
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` function code is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Part 2 shows the `main()` function, which is the entry point into our shell
    command. The function accepts and parses command-line parameters, and invokes
    the `get_summary_src_stats()` function, passing the *source folder* specified
    by the user as a function parameter. The results, containing consolidated source
    code metrics, are printed to the console.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the tool with the following commands:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`<source-folder>` is the location of the Rust project or source files and `-m`
    is the command-line flag to be specified. It will be `src`, to indicate that we
    want source code metrics.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the stats for the current project, you can do so with the
    following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note the dot (`.`) in the command, which indicates we want to run the command
    for the current project folder.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: You will see the source code metrics displayed on the terminal.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you can extend this shell command to generate metrics on the
    binary files generated for a Rust project. To invoke this option, allow the user
    to specify the `–m` flag as `bin`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the section on developing a shell command, which demonstrated
    file and directory operations in Rust.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the basics of file management at the operating
    system level, and the main system calls to work with files. We then learned how
    to use the Rust Standard Library to open and close a file, read and write to a
    file, query file metadata, and work with links. After file operations, we learned
    how to do directory and path operations in Rust. In the third section, we saw
    how to create hard links and soft (symbolic) links using Rust, and how to query
    `symlinks`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We then developed a shell command that computed source code metrics for Rust
    source files within a directory tree. This project illustrated how to perform
    various file and directory operations in Rust using a practical example, and reinforced
    the concepts of the Rust Standard Library for file I/O operations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the topic of I/O, in the next chapter, we will learn the basics
    of terminal I/O and the features Rust provides to work with pseudo terminals.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
