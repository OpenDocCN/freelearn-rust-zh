- en: '*Chapter 6*: Working with Files and Directories in Rust'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at the details of how Rust uses memory, a
    key system resource.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how Rust interacts with another important class
    of system resources – **files** and **directories**. The Rust Standard Library
    offers a rich set of abstractions that enable platform-independent file and directory
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will review the basics of how files are managed by Unix/Linux,
    and master the key APIs that the Rust Standard Library provides to deal with *files*,
    *paths*, *links*, and *directories*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Rust Standard Library, we will implement a shell command, `rstat`,
    that counts the total number of lines of Rust code in a directory (and its subfolders),
    and provides a few additional source code metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the topics in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux system calls for file operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing file I/O in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning directory and path operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting hard links, symbolic links, and performing queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a shell command in Rust (project)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify that `rustc`, and `cargo` have been installed correctly with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux system calls for file operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the terminology and basic mechanisms associated
    with managing file system resources at the operating system level. We will use
    Linux/Unix as an example, but similar concepts apply to other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: So, what do you think a file is?
  prefs: []
  type: TYPE_NORMAL
- en: A **file** is just a set of bytes. A **byte** represents a unit of information—it
    can be a number, text, video, audio, image, or any other such digital content.
    The bytes are organized in a *linear array* called a **byte stream**. There is
    no other expectation in terms of the structure or contents of a file, as far as
    the operating system is concerned. It is the *user application* that does the
    interpretation of the file and its contents.
  prefs: []
  type: TYPE_NORMAL
- en: A **user application** is a program that is not a part of the operating system
    kernel. An example of a user application is an image viewer that interprets the
    bytes of data as an image. Since files are resources that are managed by the operating
    system, any user programs that we write must know how to interact with the operating
    system through system calls. A file can be read from, written to, or executed.
    An example of a file that can be executed is the binary executable (object) file,
    generated by software build systems such as **Make** or **Cargo**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect that is unique to Linux/Unix is the philosophy that *everything
    is a file*. Here, *everything* refers to system resources. There can be many types
    of files on Linux/Unix:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular files**, which we use to store text or binary data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directories**, which contain listings of names and references to other files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block device files**, for example, a hard disk, a tape drive, USB cameras'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Character device files**, for example, a terminal, a keyboard, a printer,
    a sound card'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Named pipes**, an in-memory inter-process communication mechanism'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unix domain sockets**, also a form of inter-process communication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Links**, such as hard links and symbolic links'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will focus on files, directories, and links. However, the
    universality of the Unix I/O model means that the same set of system calls used
    to open, read, write, and close regular files can also be used on any other types
    of files such as **device files**. This is achieved in Linux/Unix by standardizing
    the system calls, which are then implemented by various filesystems and device
    drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Linux/Unix also provides a unified `/mnt/cdrom`, which becomes the location
    to access the root of the filesystem. The root directory of a "filesystem" can
    be accessed at the mount point.
  prefs: []
  type: TYPE_NORMAL
- en: The **mount namespace** of a process is the set of all mounted filesystems it
    sees. A process that makes system calls for file operations operates on the set
    of files and directories that it sees as a part of its mount namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unix/Linux system calls (**Application Programming Interface - API**) model
    for file operations hinges on four operations: **open**, **read**, **write**,
    and **close**, all of which work with the concept of **file descriptors**. What
    is a file descriptor?'
  prefs: []
  type: TYPE_NORMAL
- en: A file descriptor is a handle to a file. Opening a file returns a file descriptor,
    and other operations such as reading, writing, and closing use the file descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: More about file descriptors
  prefs: []
  type: TYPE_NORMAL
- en: File operations such as read and write are performed by processes. A process
    performs these operations by invoking system calls on the kernel. As soon as a
    file is opened by a process, the kernel records it in a *file table*, where each
    entry contains details of the open file including the **file descriptor** (**fd**)
    and **file position**. Each Linux process has a limit on the number of files it
    can open.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the kernel, all open files are referred to by file descriptors. When a process
    opens an existing file or creates a new file, the kernel returns a file descriptor
    to the process. By default, when a process is started from a shell, three file
    descriptors are automatically created: `open: 0 – standard input (stdin)`, `1-
    standard output(stdout)`, and `2-standard error(stderr)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel maintains a table of all open file descriptors. If the process opens
    or creates a file, the kernel allocates the next free file descriptor from the
    pool of free file descriptors. When a file is closed, the file descriptor is released
    back to the pool and is available for re-allotment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the common *system calls* associated with file operations,
    which the operating system exposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`open()`: This system call opens an existing file. It can also create a new
    file if the file does not exist. It accepts a pathname, the mode in which the
    file is to be opened, and flags. It returns a file descriptor that can be used
    in subsequent system calls to access the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`read()`: This system call accepts three arguments: a *file descriptor*, the
    *number of bytes* to be read, and the *memory address of the buffer* into which
    the data read is to be placed. It returns the number of bytes read. `-1` is returned
    in the event of an error when reading the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write()`: This system call is similar to `read()`, in that it also takes three
    parameters – a *file descriptor*, a *buffer pointer* from which to read the data,
    and the *number of bytes* to read from the buffer. Note that successful completion
    of the `write()` system call does not guarantee that the bytes have been written
    to disk immediately, as the kernel performs buffering of I/O to disk for performance
    and efficiency reasons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close()`: This system call accepts a *file descriptor* and releases it. If
    a `close()` call is not explicitly invoked for a file, all open files are closed
    when the process terminates. But it is good practice to release file descriptors
    (when no longer needed) for reuse by the kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lseek()`: For each open file, the kernel keeps track of a file offset, which
    represents the location in the file at which the next read or write operation
    will happen. The system call `lseek()` allows you to reposition the file offset
    to any location in the file. The `lseek()` system call accepts three arguments
    – the file descriptor, an offset, and a reference position. The reference position
    can take three values – *start of file*, *current cursor position*, or *end of
    file*. The offset specifies the number of bytes relative to the reference position
    that the file offset should be pointed to, for the next `read()` or `write()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes the overview of terminologies and key concepts of how operating
    systems manage files as system resources. We have seen the main system calls (`syscalls`)
    in Linux for working with files. We will not be directly using these `syscalls`
    in this book. But we will work with these `syscalls` indirectly, through the Rust
    Standard Library modules. The Rust Standard Library provides higher-level *wrappers*
    to make it easier to work with these `syscalls`. These *wrappers* also allow Rust
    programs to work without necessarily understanding all the differences in `syscalls`
    across different operating systems. However, gaining basic knowledge of how operating
    systems manage files gives us a glimpse into what goes on under the hood when
    we use the Rust Standard Library for file and directory operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover how to do file I/O in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Doing file I/O in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the Rust method calls that let us work with
    files in Rust programs. The Rust Standard Library spares the programmer from having
    to work with system calls directly and provides a set of wrapper methods exposing
    APIs for common file operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary module in the Rust Standard Library for working with files is `std::fs`.
    The official documentation for `std::fs` can be found here: [https://doc.rust-lang.org/std/fs/index.html](https://doc.rust-lang.org/std/fs/index.html).
    This documentation provides the set of methods, structs, enums, and traits that
    collectively provide features for working with files. It helps to study the structure
    of the `std::fs` module to gain a deeper understanding. However, for those starting
    out with exploring system programming in Rust, it is more useful to begin with
    a mental model of what kinds of things a programmer would like to do with files,
    and map it back to the Rust Standard Library. This is what we will do in this
    section. The common lifecycle operations for a file are shown in *Figure 6.1*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Common file life cycle operations](img/Figure_6.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Common file life cycle operations
  prefs: []
  type: TYPE_NORMAL
- en: 'The common things programmers like to do with files include creating a file,
    opening and closing files, reading and writing files, accessing metadata about
    files, and setting file permissions. These are shown in *Figure 6.1*. Descriptions
    of how to perform each of these file operations using the Rust Standard Library
    are provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fs` module is `File::create()`, which allows you to create a new file
    and write to it. Custom permissions for the file to be created can be specified
    using the `std::fs::OpenOptions` struct. An example of a *create* operation using
    the `std::fs` module is shown in the code snippet here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::fs::File::open()`. This opens a file in *read-only* mode by default.
    The `std::fs::OpenOptions` struct can be used to set *custom permissions* to create
    the file. Two methods to open a file are shown below. The first function returns
    a `Result` type, which we are just handling using `.expect()`, which panics with
    a message if the file is not found. The second function uses `OpenOptions` to
    set additional permissions on the file to be opened. In the example shown, we
    are opening a file for the *write* operation, and also are asking for the file
    to be created if not present already:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::fs::copy()` function can be used to copy the contents of one file to
    another, overwriting the latter. An example is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::fs::rename()` function can be used for this purpose. If the *to* file
    exists, it is replaced. One thing to note is that there can be more than one filesystem
    mounted (at various points) within the *mount namespace* of a process, as seen
    in the previous section. The `rename` method in Rust will work only if both the
    *from* and *to* file paths are in the same filesystem. An example of usage of
    the `rename()` function is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::fs` module, there are two functions available: `fs::read()` and `fs::read_to_string()`.
    The former reads the contents of a file into a `bytes vector`. It pre-allocates
    a buffer based on file size (when available). The latter reads the contents of
    a file directly into a string. Examples are shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::fs`, the `fs::write()` function accepts a *filename* and a *byte slice*,
    and writes the *byte slice* as the contents of the file. An example is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::fs` module. The functions `is_dir()`, `is_file()`, and `is_symlink()`
    respectively check whether a file is a *regular file*, *directory*, or a *symlink*.
    The `modified()`, `created()`, `accessed()` , `len()`, and `metadata()` functions
    are used to retrieve file metadata information. The `permissions()` function is
    used to retrieve a list of permissions on the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few examples of the usage of query operations are shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`set_permissions()`. An example is shown here, where, after setting the file
    permission to read-only, the write operation to the file fails:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`close()` method in the Rust Standard Library to close files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we saw the key function calls from the Rust Standard Library
    that can be used to perform *file manipulation* and *query* operations. In the
    next section, we will take a look at how the Rust Standard Library can be used
    for *directory* and *path* operations.
  prefs: []
  type: TYPE_NORMAL
- en: Learning directory and path operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel in Linux (and other Unix variants) maintains a single directory tree
    structure visible to a process, which is hierarchical and contains all files in
    that namespace. This hierarchical organization contains both individual files,
    directories, and links (for example, a symbolic link).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we looked at *files* and file operations in Rust. In
    this section, we will take a closer look at *directory* and *path* operations.
    In the next section, we will cover *links*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *directory* is a special file that contains a list of filenames with references
    (`/` represents the root directory, and `/home` and `/etc` will link to `/` as
    the *parent* directory. (Note that in some operating systems, such as Microsoft
    Windows variants, each disk device has its own hierarchy of files, and there is
    not a single unified namespace.) Each directory contains at least two entries
    – a *dot entry* pointing to itself and a *dot-dot* directory, which is a link
    to its parent directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Common directory and path operations](img/Figure_6.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Common directory and path operations
  prefs: []
  type: TYPE_NORMAL
- en: In the Rust Standard Library, the `std::fs` module contains methods to work
    with directories, and the `std::path` module contains methods to work with *paths*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as in the previous section, we will look at the common programming tasks
    involving *directory* and *path* manipulations. These are shown in *Figure 6.2*
    and detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fs` module. The `std::fs::read_dir()` function can be used to iterate
    through and retrieve the entries in a directory. From the directory entry thus
    retrieved, the metadata details of the directory entry can be obtained with the
    functions `path()`, `metadata()`, `file_name()`, and `file_type()`. Examples of
    how to do this are shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we'll look at how to construct directory trees programmatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`std::fs` module. The Rust `std::fs:DirBuilder` struct provides methods to
    recursively construct a directory structure. An example of creating a directory
    structure recursively is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that there are two other functions also available to create directories.
    `create_dir()` and `create_dir_all()` in `std::fs` can be used for this purpose.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Likewise, the functions `remove_dir()` and `remove_dir_all()` in the `std::fs`
    module can be used to delete directories.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll look at how to construct path strings dynamically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`/usr/bob/a.txt`, `usr` and `bob` represent directories, while `a.txt` represents
    a file. The Rust Standard Library provides facilities to construct a path string
    (representing the full path to a file or a directory) programmatically. This is
    available in `std::path::PathBuf`. An example of how to construct a path dynamically
    is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the code shown, a new variable of type `PathBuf` is constructed, and the
    various path components are dynamically added to create a fully qualified path.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this subsection on directory and path operations with the Rust
    Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how to use the Rust Standard Library to read through
    directory entries, get their metadata, construct a directory structure programmatically,
    get path components, and build a path string dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to work with *links* and *queries*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting hard links, symbolic links, and performing queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw earlier that a directory is treated in a file system similarly to a
    regular file. But it has a different file type, and it contains a list of filenames
    with their inodes. `ls –li` command shows the inode number corresponding to a
    file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_6.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Inode numbers visible in the file listing
  prefs: []
  type: TYPE_NORMAL
- en: Since a directory contains a listing that maps *filenames* with *inode numbers*,
    there can be multiple filenames that map to the same inode number. Such multiple
    names are called `ln` shell command. Not all non-UNIX filesystems support such
    hard links.
  prefs: []
  type: TYPE_NORMAL
- en: Within a file system, there can be many *links* to the same file. All of them
    are essentially the same, as they point to the same file. Most files have a *link
    count* of 1 (meaning there is a single directory entry for that file), but a file
    can have a *link count* > 1 ( for example, if there are two links pointing to
    the same *inode* entry, there will be two directory entries for that file, and
    the *link count* will be 2). The kernel maintains this *link count*.
  prefs: []
  type: TYPE_NORMAL
- en: A *hard link* has a limitation in that they can refer only to files within the
    same file system because inode numbers are unique only within a file system. There
    is another type of link called a `ln –s` command. Since a symbolic link refers
    to a filename instead of an inode number, it can refer to a file in another filesystem.
    Also, unlike hard links, symbolic links can be created in directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following points, we will see the methods in the Rust Standard Library
    that can be used to create and query hard links and symbolic links (symlinks):'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fs` module has a function, `fs::hard_link`, that can be used to create
    a new hard link on the file system. An example is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`symlink` using the Rust Standard Library vary by platform. On Unix/Linux,
    the `std::os::unix::fs::symlink` method can be used. On windows, there are two
    APIs – `os::windows::fs::symlink_file` to create a *symbolic link* to a file,
    or `os::windows::fs::symlink_dir` to create a `symlink` to a directory. An example
    of creating a `symlink` on Unix-like platforms is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `fs::read_link` function can be used to read a symbolic link as shown in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we conclude the subsection on working with links in the Rust Standard
    Library. We have so far seen how to work with files, directories, paths, and links
    in Rust. In the next section, we will build a small shell command that demonstrates
    the practical use of the Rust Standard Library for file and directory operations.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a shell command in Rust (project)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use our knowledge of the Rust Standard Library on file
    and directory operations that we learned in previous sections to implement a shell
    command.
  prefs: []
  type: TYPE_NORMAL
- en: What will the shell command do?
  prefs: []
  type: TYPE_NORMAL
- en: The shell command will be called **rstat**, short for **Rust source statistics**.
    Given a directory as an argument, it will generate a *file count* of Rust source
    files, and source code metrics such as the *number of blanks*, *comments*, and
    *actual lines of code* within the directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what you will type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the result you will see from this shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This section is structured as four sub-sections. In the first sub-section, we
    will see an overview of the code structure and a summary of steps to build this
    shell command. Then, in three different subsections, we will review the code for
    the three source files corresponding to error handling, source metric computation,
    and the main program.
  prefs: []
  type: TYPE_NORMAL
- en: Code overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will look at how the code is structured for the shell
    command. We will also review a summary of the steps to build the shell command.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code structure is shown in *Figure 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Shell command code structure](img/Figure_6.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Shell command code structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary of the steps to build the shell command. The source code
    snippets are shown later in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create project: Create a new project with the following command and change
    directory into the `rstat` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create source files: Create three files under the `src` folder – `main.rs`,
    `srcstats.rs`, and `errors.rs`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define custom error handling: In `errors.rs`, create a struct, `StatsError`,
    to represent our custom error type. This will be used to unify error handling
    in our project and to send messages back to the user. Implement the following
    four traits on `struct StatsError` : `fmt::Display, From<&str>`, `From<io::Error>`,
    and `From<std::num::TryFromIntError>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define logic for computing source stats: In `srcstats.rs`, create a struct,
    `SrcStats`, to define the source metrics to be computed. Define two functions:
    `get_src_stats_for_file()` (which accepts a filename as an argument and computes
    the source metrics for that file) and `get_summary_src_stats()` (which takes a
    directory name as an argument and computes source metrics for all files in that
    directory root).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the main() function to accept command-line parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `main.rs`, define a `Opt` struct to define command-line parameters and flags
    for the shell command. Write the `main()` function, which accepts a source directory
    name from the command line and invokes the `get_summary_src_stats()` method in
    the `srcstats` module. Ensure to include `Cargo.toml` under dependencies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build the tool with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the shell command with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'LD_LIBRARY_PATH can be set as shown here (equivalent commands can be used for
    Windows):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: View the consolidated source stats printed to the terminal and confirm the metrics
    generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now look at the code snippets for the steps listed previously. We will
    start by defining custom error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While executing our shell command, several things can go wrong. The source
    folder specified may be invalid. The permissions may be insufficient to view the
    directory entries. There can be other types of I/O errors such as those listed
    here: [https://doc.rust-lang.org/std/io/enum.ErrorKind.html](https://doc.rust-lang.org/std/io/enum.ErrorKind.html).
    In order for us to give a meaningful message back to the user, we will create
    a custom error type. We will also write conversion methods that will automatically
    convert different types of I/O errors into our custom error type by implementing
    various `From` traits. All this code is stored in the `errors.rs` file. Let''s
    review the code snippets from this file in two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 covers the definition of the custom error type and `Display` trait implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 2 covers the various `From` trait implementations for our custom error
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 1 of the `errors.rs` code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/errors.rs (part-1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here the `StatsError` struct is defined with a field `message` that will be
    used to store the error message, which will get propagated to the user in case
    of errors. We have also implemented the `Display` trait to enable the error message
    to get printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see part 2 of the `errors.rs` file. Here, we implement the various
    `From` trait implementations, as shown here. Code annotations are numbered, and
    are described after the code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: src/errors.rs (part-2)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The source code annotations (shown with numbers) are detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Helps to construct a `StatsError` from a string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Converts `IO:Error` to `StatsError`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Used to check for errors while converting `usize` into `u32`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we reviewed the code for the `errors.js` file. In the next
    section, we will see the code for the computation of source code metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Source metric computation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at the code for the `srcstats.rs` file. The code
    snippets for this file are shown in the following order in separate parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1*: Module imports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2:* Definition of the `SrcStats` struct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3*: Definition of the `get_summary_src_stats()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 4:* Definition of the `get_src_stats_for_file()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at *part 1*. The module imports are shown here. The descriptions
    corresponding to code annotation numbers are shown after the code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part-1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The descriptions for the numbered code annotations are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TryFrom` is used to capture any errors in converting `usize` to `u32`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OsStr` is used to check for files with the `.rs` extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::fs` is the main module in the Rust Standard Library for file and directory
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirEntry` is a struct used by Rust Standard Library to denote individual directory
    entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path` and `PathBuf` are used to store path names. `&Path` is similar to `&str`
    and `PathBuf` is similar to `String`. One is a reference and another is an owned
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any errors in reading files or computations are converted to the custom error
    type `StatsError`. This is imported in this line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now look at *part 2*. The definition of the struct to store computed
    metrics is covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The struct `SrcStats` contains the following source metrics, which will be
    generated by our shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of Rust source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A count of lines of code (excluding comments and blanks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of blank lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of comment lines (single-line comments that begin with `//`; note
    that we are not considering multi-line comments in the scope of this tool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Rust data structure to hold the computed source file metrics is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part-2)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at *part 3*, which is the main function that computes summary statistics.
    As this code is a bit long, we will look at this in three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Part 3a of the code snippet shows variable initialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 3b of the code snippet shows the main code that recursively retrieves the
    Rust source files within a directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In part 3c, we iterate through the list of Rust files and invoke the `get_src_stats_for_file()`
    method to compute source metrics for each file. The results are consolidated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3a of the `get_summary_src_stats()` method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part 3a)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Part 3a shows the initialization of variables representing the various metrics
    that will be computed by the shell command – `total_loc`, `total_comments`, and
    `total_blanks`. Two more variables, `dir_entries` and `file_entries`, are initialized
    as `vector` data types, which will be used for intermediate computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3b of the `get_summary_src_stats()` method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part-3b)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In part 3b of the code, we are iterating through the entries within the specified
    folder and segregating the entries of the type *directory* from the entries of
    the type *file*, and storing them in separate `vector` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3c of the `get_summary_src_stats()` method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part 3c)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now look at *part 4*, which is the code to compute source metrics for
    an individual Rust source file:'
  prefs: []
  type: TYPE_NORMAL
- en: src/srcstats.rs (part-4)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In part 4, the code for the `get_src_stats_for_file()` function is shown. This
    function reads the source file line by line and determines whether the line corresponds
    to a regular line of code, or blanks, or comments. Based on this classification,
    the respective counters are incremented. The final result is returned as the `SrcStats`
    struct from the function.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the code listing for the `srcstats` module. In this subsection,
    we reviewed the code for computing source code metrics. In the next section, we
    will review the code for the last part of the code listing, which is the `main()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The main() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, we will now look at the final part of the code, which is
    the `main()` function that represents the entry point into the binary. It performs
    four tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepts user inputs from the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invokes the appropriate method to compute the source code metrics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Displays the result to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the event of errors, a suitable error message is displayed to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code listing for the `main()` function is shown in two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 shows the structure of the command-line interface for the shell command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 2 shows the code to invoke calls for the computation of source metrics
    and to display the results to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 1* of `main.rs` is shown here. We will use the `structopt` crate to define
    the structure of the command line inputs to be accepted from the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The code listing for *part 1* is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/main.rs (part-1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In part 1 of the code shown, a data structure, `Opt`, is defined, which contains
    two fields – `in_dir`, representing the path to the input folder (for which source
    metrics are to be computed), and a field, `mode`. The value for `mode` in our
    example is `src`, which indicates that we want to compute source code metrics.
    In the future, additional modes can be added (such as the `object` mode to compute
    object file metrics such as the size of the executable and library object files).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *part 2* of this code, we read the source folder from user''s command-line
    argument, and invoke the `get_summary_src_stats()` method from the `srcstats`
    module, which we reviewed in the previous subsection. The metrics returned by
    this method are then shown to user in the terminal. *Part 2* of the code listing
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/main.rs
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` function code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Part 2 shows the `main()` function, which is the entry point into our shell
    command. The function accepts and parses command-line parameters, and invokes
    the `get_summary_src_stats()` function, passing the *source folder* specified
    by the user as a function parameter. The results, containing consolidated source
    code metrics, are printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the tool with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`<source-folder>` is the location of the Rust project or source files and `-m`
    is the command-line flag to be specified. It will be `src`, to indicate that we
    want source code metrics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the stats for the current project, you can do so with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note the dot (`.`) in the command, which indicates we want to run the command
    for the current project folder.
  prefs: []
  type: TYPE_NORMAL
- en: You will see the source code metrics displayed on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you can extend this shell command to generate metrics on the
    binary files generated for a Rust project. To invoke this option, allow the user
    to specify the `–m` flag as `bin`.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the section on developing a shell command, which demonstrated
    file and directory operations in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the basics of file management at the operating
    system level, and the main system calls to work with files. We then learned how
    to use the Rust Standard Library to open and close a file, read and write to a
    file, query file metadata, and work with links. After file operations, we learned
    how to do directory and path operations in Rust. In the third section, we saw
    how to create hard links and soft (symbolic) links using Rust, and how to query
    `symlinks`.
  prefs: []
  type: TYPE_NORMAL
- en: We then developed a shell command that computed source code metrics for Rust
    source files within a directory tree. This project illustrated how to perform
    various file and directory operations in Rust using a practical example, and reinforced
    the concepts of the Rust Standard Library for file I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the topic of I/O, in the next chapter, we will learn the basics
    of terminal I/O and the features Rust provides to work with pseudo terminals.
  prefs: []
  type: TYPE_NORMAL
