<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Talking HTTP in the Internet</h1>
                
            
            <article>
                
<p class="calibre2">The single most important application-layer protocol that has changed our lives heavily has to be the HTTP. It forms the backbone of the World Wide Web (WWW). In this chapter, we will look at how Rust makes writing fast HTTP servers easier. We will also look at writing clients to communicate with these servers over a network.</p>
<p class="calibre2">We will cover the following topics in this chapter:</p>
<ul class="calibre7">
<li class="calibre8">A short introduction to Hyper, one of the most widely used crates for writing HTTP servers</li>
<li class="calibre8">We will study Rocket, a new crate that has become widely popular owing to its simpler interface</li>
<li class="calibre8">We will move on to reqwest, an HTTP client library</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing Hyper</h1>
                
            
            <article>
                
<p class="calibre2">Hyper is arguably the most stable and well-known of Rust-based HTTP frameworks. It has two distinct components, one for writing HTTP servers and one for writing clients. Recently, the server component was moved to a new async programming model based on tokio and futures. As a result, it is well-suited for high-traffic workloads. However, like a lot of other libraries in the ecosystem, Hyper has not hit Version 1.0 yet, so one should expect breaking API changes.</p>
<p class="calibre2">We will start with writing a small HTTP server in Hyper. Like always, we will need to set up our project using Cargo.</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin hyper-server</strong></pre>
<p class="calibre2">Let us now add dependencies that will include <kbd class="calibre11">hyper</kbd> and <kbd class="calibre11">futures</kbd>. The <kbd class="calibre11">Cargo.toml</kbd> file will look as follows:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "hyper-server"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>hyper = "0.11.7"<br class="title-page-name"/>futures = "0.1.17"</pre>
<p class="calibre2">Our main file is pretty simple. In the real world, HTTP servers often talk to a backend, and all that can take a while to complete. Thus, it is common for replies to be a bit delayed. We will simulate that using a function that sleeps for 200 ms each time it is called, and then returns a fixed string.</p>
<pre class="calibre17">// ch6/hyper-server/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate hyper;<br class="title-page-name"/>extern crate futures;<br class="title-page-name"/><br class="title-page-name"/>use std::{ thread, time };<br class="title-page-name"/>use futures::future::FutureResult;<br class="title-page-name"/>use hyper::{Get, StatusCode};<br class="title-page-name"/>use hyper::header::ContentLength;<br class="title-page-name"/>use hyper::server::{Http, Service, Request, Response};<br class="title-page-name"/><br class="title-page-name"/>// Simulate CPU intensive work by sleeping for 200 ms<br class="title-page-name"/>fn heavy_work() -&gt; String {<br class="title-page-name"/>    let duration = time::Duration::from_millis(200);<br class="title-page-name"/>    thread::sleep(duration);<br class="title-page-name"/>    "done".to_string()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[derive(Clone, Copy)]<br class="title-page-name"/>struct Echo;<br class="title-page-name"/><br class="title-page-name"/>impl Service for Echo {<br class="title-page-name"/>    type Request = Request;<br class="title-page-name"/>    type Response = Response;<br class="title-page-name"/>    type Error = hyper::Error;<br class="title-page-name"/>    type Future = FutureResult&lt;Response, hyper::Error&gt;;<br class="title-page-name"/><br class="title-page-name"/>    // This method handles actually processing requests<br class="title-page-name"/>    // We only handle GET requests on /data and ignore everything else<br class="title-page-name"/>    // returning a HTTP 404<br class="title-page-name"/>    fn call(&amp;self, req: Request) -&gt; Self::Future {<br class="title-page-name"/>        futures::future::ok(match (req.method(), req.path()) {<br class="title-page-name"/>        (&amp;Get, "/data") =&gt; {<br class="title-page-name"/>        let b = heavy_work().into_bytes();<br class="title-page-name"/>        Response::new()<br class="title-page-name"/>        .with_header(ContentLength(b.len() as u64))<br class="title-page-name"/>        .with_body(b)<br class="title-page-name"/>}<br class="title-page-name"/>        _ =&gt; Response::new().with_status(StatusCode::NotFound),})<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let addr = "0.0.0.0:3000".parse().unwrap();<br class="title-page-name"/>    let server = Http::new().bind(&amp;addr, || Ok(Echo)).unwrap();<br class="title-page-name"/>    server.run().unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">As Hyper heavily relies on <kbd class="calibre11">tokio</kbd> to do asynchronous handling of requests, an HTTP server in Hyper needs to implement a built-in trait called <kbd class="calibre11">Service</kbd> from <kbd class="calibre11">tokio</kbd>. This is essentially a function that maps a <kbd class="calibre11">Request</kbd> to a <kbd class="calibre11">Response</kbd> via an implementation of the <kbd class="calibre11">call</kbd> method. This method returns the result as a <kbd class="calibre11">Future</kbd>, indicating eventual completion of the given task. In that implementation, we match the method and path of the incoming request. If the method is <kbd class="calibre11">GET</kbd> and the path is <kbd class="calibre11">/data</kbd>, we call <kbd class="calibre11">heavy_work</kbd> and get the result. We then compose a response by setting the <kbd class="calibre11">Content-Length</kbd> header to the size of the string we are returning and the body of the response. In our <kbd class="calibre11">main</kbd> function, we construct our server by binding it to a known port. At the end, we call <kbd class="calibre11">run</kbd> on it to start the server.</p>
<p class="calibre2">Interacting with the server is easy with <kbd class="calibre11">curl</kbd>; a session should look like this:</p>
<pre class="calibre17"><strong class="calibre1">$ curl http://127.0.0.1:3000/data</strong><br class="title-page-name"/>done$</pre>
<p class="calibre2">Let us benchmark our server. For this, we will install ApacheBench (<a href="https://httpd.apache.org/docs/trunk/programs/ab.html" class="calibre10">https://httpd.apache.org/docs/trunk/programs/ab.html</a>). We will run 1,000 total requests from 100 clients in parallel by passing some command-line parameters to ApacheBench. This will take a while to complete, and we are waiting 200 ms before returning each response. So, for 1,000 requests, we will wait for at least 200 seconds. On one run, the output looks like this:</p>
<pre class="calibre17"><strong class="calibre1">$ ab -n 1000 -c 100 http://127.0.0.1:3000/data</strong><br class="title-page-name"/>Benchmarking 127.0.0.1 (be patient)<br class="title-page-name"/>Completed 100 requests<br class="title-page-name"/>Completed 200 requests<br class="title-page-name"/>Completed 300 requests<br class="title-page-name"/>Completed 400 requests<br class="title-page-name"/>Completed 500 requests<br class="title-page-name"/>Completed 600 requests<br class="title-page-name"/>Completed 700 requests<br class="title-page-name"/>Completed 800 requests<br class="title-page-name"/>Completed 900 requests<br class="title-page-name"/>Completed 1000 requests<br class="title-page-name"/>Finished 1000 requests<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>Server Software:<br class="title-page-name"/>Server Hostname: 127.0.0.1<br class="title-page-name"/>Server Port: 3000<br class="title-page-name"/><br class="title-page-name"/>Document Path: /data<br class="title-page-name"/>Document Length: 4 bytes<br class="title-page-name"/><br class="title-page-name"/>Concurrency Level: 100<br class="title-page-name"/>Time taken for tests: 203.442 seconds<br class="title-page-name"/>Complete requests: 1000<br class="title-page-name"/>Failed requests: 0<br class="title-page-name"/>Total transferred: 79000 bytes<br class="title-page-name"/>HTML transferred: 4000 bytes<br class="title-page-name"/>Requests per second: 4.92 [#/sec] (mean)<br class="title-page-name"/>Time per request: 20344.234 [ms] (mean)<br class="title-page-name"/>Time per request: 103.442 [ms] (mean, across all concurrent requests)<br class="title-page-name"/>Transfer rate: 0.38 [Kbytes/sec] received<br class="title-page-name"/><br class="title-page-name"/>Connection Times (ms)<br class="title-page-name"/>min mean[+/-sd] median max<br class="title-page-name"/>Connect: 0 2 0.7 2 3<br class="title-page-name"/>Processing: 5309 20123 8061.9 20396 33029<br class="title-page-name"/>Waiting: 203 12923 5518.0 14220 20417<br class="title-page-name"/>Total: 5311 20124 8061.9 20397 33029<br class="title-page-name"/><br class="title-page-name"/>Percentage of the requests served within a certain time (ms)<br class="title-page-name"/>  50% 20397<br class="title-page-name"/>  66% 25808<br class="title-page-name"/>  75% 26490<br class="title-page-name"/>  80% 27263<br class="title-page-name"/>  90% 28373<br class="title-page-name"/>  95% 28568<br class="title-page-name"/>  98% 33029<br class="title-page-name"/>  99% 33029<br class="title-page-name"/> 100% 33029 (longest request)</pre>
<p class="calibre2">Notice that, across all requests, the server takes around 103.4 ms to reply back. This matches our expectation of 100 ms with the extra time being spent on other things. Also, our server is processing 4.92 requests per second, which is way too low for a reasonable server. This is all because our server is single-threaded, and only one thread serves all clients. This server also ignores the fact that multiple CPU cores are available on the host.</p>
<p class="calibre2">Let us go ahead and write a server that largely does the same thing, the difference being that this one uses multi-threading heavily and uses all CPU cores. Cargo setup should be as follows:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin hyper-server-faster</strong></pre>
<p class="calibre2">We will need to add some more crates as dependencies, and our <kbd class="calibre11">Cargo.toml</kbd> should be as follows:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "hyper-server-faster"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>hyper = "0.11.7"<br class="title-page-name"/>futures = "0.1.17"<br class="title-page-name"/>net2 = "0.2.31"<br class="title-page-name"/>tokio-core = "0.1.10"<br class="title-page-name"/>num_cpus = "1.0"</pre>
<p class="calibre2">We have a number of extra things here. <kbd class="calibre11">tokio-core</kbd> will be used to run an event loop (as we did in mio, in <a href="part0046.html#1BRPS0-e803f047c8b7448c90887daa96419287" class="calibre10">Chapter 3</a>, <em class="calibre16">TCP and UDP Using Rust</em>), <kbd class="calibre11">net2</kbd> will be used for some advanced socket configuration, and <kbd class="calibre11">num_cpus</kbd> will be used to figure out the number of CPU cores on the machine. Having set those up, our main file is pretty simple:</p>
<pre class="calibre17">// ch6/hyper-server-faster/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate hyper;<br class="title-page-name"/>extern crate net2;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/>extern crate num_cpus;<br class="title-page-name"/><br class="title-page-name"/>use futures::Stream;<br class="title-page-name"/>use net2::unix::UnixTcpBuilderExt;<br class="title-page-name"/>use tokio_core::reactor::Core;<br class="title-page-name"/>use tokio_core::net::TcpListener;<br class="title-page-name"/>use std::{thread, time};<br class="title-page-name"/>use std::net::SocketAddr;<br class="title-page-name"/>use std::sync::Arc;<br class="title-page-name"/>use futures::future::FutureResult;<br class="title-page-name"/>use hyper::{Get, StatusCode};<br class="title-page-name"/>use hyper::header::ContentLength;<br class="title-page-name"/>use hyper::server::{Http, Service, Request, Response};<br class="title-page-name"/><br class="title-page-name"/>// Same method like last example<br class="title-page-name"/>fn heavy_work() -&gt; String {<br class="title-page-name"/>    let duration = time::Duration::from_millis(200);<br class="title-page-name"/>    thread::sleep(duration);<br class="title-page-name"/>    "done".to_string()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[derive(Clone, Copy)]<br class="title-page-name"/>struct Echo;<br class="title-page-name"/><br class="title-page-name"/>impl Service for Echo {<br class="title-page-name"/>    type Request = Request;<br class="title-page-name"/>    type Response = Response;<br class="title-page-name"/>    type Error = hyper::Error;<br class="title-page-name"/>    type Future = FutureResult&lt;Response, hyper::Error&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn call(&amp;self, req: Request) -&gt; Self::Future {<br class="title-page-name"/>        futures::future::ok(match (req.method(), req.path()) {<br class="title-page-name"/>            (&amp;Get, "/data") =&gt; {<br class="title-page-name"/>                let b = heavy_work().into_bytes();<br class="title-page-name"/>                Response::new()<br class="title-page-name"/>                    .with_header(ContentLength(b.len() as u64))<br class="title-page-name"/>                    .with_body(b)<br class="title-page-name"/>            }<br class="title-page-name"/>            _ =&gt; Response::new().with_status(StatusCode::NotFound),<br class="title-page-name"/>        })<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// One server instance<br class="title-page-name"/>fn serve(addr: &amp;SocketAddr, protocol: &amp;Http) {<br class="title-page-name"/>    let mut core = Core::new().unwrap();<br class="title-page-name"/>    let handle = core.handle();<br class="title-page-name"/>    let listener = net2::TcpBuilder::new_v4()<br class="title-page-name"/>        .unwrap()<br class="title-page-name"/>        .reuse_port(true)<br class="title-page-name"/>        .unwrap()<br class="title-page-name"/>        .bind(addr)<br class="title-page-name"/>        .unwrap()<br class="title-page-name"/>        .listen(128)<br class="title-page-name"/>        .unwrap();<br class="title-page-name"/>    let listener = TcpListener::from_listener(listener, addr,<br class="title-page-name"/>    &amp;handle).unwrap();<br class="title-page-name"/>    core.run(listener.incoming().for_each(|(socket, addr)| {<br class="title-page-name"/>        protocol.bind_connection(&amp;handle, socket, addr, Echo);<br class="title-page-name"/>        Ok(())<br class="title-page-name"/>    })).unwrap();<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Starts num number of serving threads<br class="title-page-name"/>fn start_server(num: usize, addr: &amp;str) {<br class="title-page-name"/>    let addr = addr.parse().unwrap();<br class="title-page-name"/><br class="title-page-name"/>    let protocol = Arc::new(Http::new());<br class="title-page-name"/>    {<br class="title-page-name"/>        for _ in 0..num - 1 {<br class="title-page-name"/>            let protocol = Arc::clone(&amp;protocol);<br class="title-page-name"/>            thread::spawn(move || serve(&amp;addr, &amp;protocol));<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    serve(&amp;addr, &amp;protocol);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    start_server(num_cpus::get(), "0.0.0.0:3000");<br class="title-page-name"/>}</pre>
<p class="calibre2">Functionally, this server is exactly the same as the last one. Architecturally, they are very different. Our implementation of <kbd class="calibre11">Service</kbd> is the same. What changed majorly is that we split starting the server into two functions; the serve function creates a new event loop (and a handle to it). We create our listener using <kbd class="calibre11">net2</kbd> so that we can set a bunch of options on it using the <kbd class="calibre11">TcpBuilder</kbd> pattern. Specifically, we set <kbd class="calibre11">SO_REUSEPORT</kbd> on the socket so that under high loads the OS can distribute connections to all threads fairly. We also set a backlog of 128 for the listening socket. We then loop over incoming connections on the listener and, for each, we run our service implementation. Our <kbd class="calibre11">start_server</kbd> method takes in an integer that corresponds to the number of cores on the host and an address as a string. We then start a loop and run the serve method in new threads. In this case, our <kbd class="calibre11">Http</kbd> instance will be passed to multiple threads. Thus, we need to wrap it in an <strong class="calibre1">Automatically Reference Counting</strong> (<strong class="calibre1">ARC</strong>) pointer because that guarantees thread safety of the underlying type. Finally, we call <kbd class="calibre11">start_server</kbd> in our <kbd class="calibre11">main</kbd> function, using <kbd class="calibre11">num_cpus::get</kbd> to get the number of cores on the machine.</p>
<p class="calibre2">Benchmarking this in the same way as last time shows these results:</p>
<pre class="calibre17"><strong class="calibre1">$ ab -n 1000 -c 100 http://127.0.0.1:3000/data</strong><br class="title-page-name"/>Benchmarking 127.0.0.1 (be patient)<br class="title-page-name"/>Completed 100 requests<br class="title-page-name"/>Completed 200 requests<br class="title-page-name"/>Completed 300 requests<br class="title-page-name"/>Completed 400 requests<br class="title-page-name"/>Completed 500 requests<br class="title-page-name"/>Completed 600 requests<br class="title-page-name"/>Completed 700 requests<br class="title-page-name"/>Completed 800 requests<br class="title-page-name"/>Completed 900 requests<br class="title-page-name"/>Completed 1000 requests<br class="title-page-name"/>Finished 1000 requests<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>Server Software:<br class="title-page-name"/>Server Hostname: 127.0.0.1<br class="title-page-name"/>Server Port: 3000<br class="title-page-name"/><br class="title-page-name"/>Document Path: /data<br class="title-page-name"/>Document Length: 4 bytes<br class="title-page-name"/><br class="title-page-name"/>Concurrency Level: 100<br class="title-page-name"/>Time taken for tests: 102.724 seconds<br class="title-page-name"/>Complete requests: 1000<br class="title-page-name"/>Failed requests: 0<br class="title-page-name"/>Total transferred: 79000 bytes<br class="title-page-name"/>HTML transferred: 4000 bytes<br class="title-page-name"/>Requests per second: 9.73 [#/sec] (mean)<br class="title-page-name"/>Time per request: 10272.445 [ms] (mean)<br class="title-page-name"/>Time per request: 102.724 [ms] (mean, across all concurrent requests)<br class="title-page-name"/>Transfer rate: 0.75 [Kbytes/sec] received<br class="title-page-name"/><br class="title-page-name"/>Connection Times (ms)<br class="title-page-name"/>              min mean[+/-sd] median max<br class="title-page-name"/>Connect: 0 2 1.0 2 6<br class="title-page-name"/>Processing: 304 10036 1852.8 10508 10826<br class="title-page-name"/>Waiting: 106 5482 2989.3 5458 10316<br class="title-page-name"/>Total: 305 10038 1852.7 10510 10828<br class="title-page-name"/><br class="title-page-name"/>Percentage of the requests served within a certain time (ms)<br class="title-page-name"/>  50% 10510<br class="title-page-name"/>  66% 10569<br class="title-page-name"/>  75% 10685<br class="title-page-name"/>  80% 10686<br class="title-page-name"/>  90% 10756<br class="title-page-name"/>  95% 10828<br class="title-page-name"/>  98% 10828<br class="title-page-name"/>  99% 10828<br class="title-page-name"/> 100% 10828 (longest request)</pre>
<p class="calibre2">This server's throughput is around double the last one, primarily because it uses threading better. Requests still take just over 100 ms to process, as expected. Note that the actual time taken by this will depend on the hardware and conditions of the machine running this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing Rocket</h1>
                
            
            <article>
                
<p class="calibre2">Perhaps the most widely known web framework for Rust is Rocket. It started as a one-man project and gradually evolved into a simple, elegant, and fast framework over the last year or so. Rocket focuses a lot on simplicity, something that a lot of Flask users will appreciate. Like Flask uses python decorators to declare routes, Rocket uses custom attributes to the same effect. Unfortunately, this means that Rocket has to make heavy use of nightly-only features. Thus, as of now, Rocket applications can only be built using nightly Rust. However, as more and more things are stabilized (moved to stable Rust), this restriction will eventually go away.</p>
<p class="calibre2">Let us start with a basic example of Rocket, beginning with setting up the project:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin rocket-simple</strong></pre>
<p class="calibre2">Our Cargo setup needs to add Rocket components as dependencies, and should look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "rocket-simple"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>rocket = "0.3.6"<br class="title-page-name"/>rocket_codegen = "0.3.6"</pre>
<p class="calibre2">Let us look at the main file. As we will see, Rocket needs a bit of boilerplate setup:</p>
<pre class="calibre17">// ch6/rocket-simple/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(plugin)]<br class="title-page-name"/>#![plugin(rocket_codegen)]<br class="title-page-name"/><br class="title-page-name"/>extern crate rocket;<br class="title-page-name"/><br class="title-page-name"/>#[get("/")]<br class="title-page-name"/>fn blast_off() -&gt; &amp;'static str {<br class="title-page-name"/>    "Hello, Rocket!"<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    rocket::ignite().mount("/", routes![blast_off]).launch();<br class="title-page-name"/>}</pre>
<p class="calibre2">The function called <kbd class="calibre11">blast_off</kbd> defines a route, a mapping between an incoming request and an output. In this case, a <strong class="calibre1">GET</strong> request to the <kbd class="calibre11">/</kbd> route should return a static string. In our main function, we initialize Rocket, add our routes, and call <kbd class="calibre11">launch</kbd>. Run it using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/rocket-simple`<br class="title-page-name"/>Configured for development.<br class="title-page-name"/>    =&gt; address: localhost<br class="title-page-name"/>    =&gt; port: 8000<br class="title-page-name"/>    =&gt; log: normal<br class="title-page-name"/>    =&gt; workers: 16<br class="title-page-name"/>    =&gt; secret key: generated<br class="title-page-name"/>    =&gt; limits: forms = 32KiB<br class="title-page-name"/>    =&gt; tls: disabled<br class="title-page-name"/>Mounting '/':<br class="title-page-name"/>    =&gt; GET /<br class="title-page-name"/>Rocket has launched from http://localhost:8000</pre>
<p class="calibre2">In another terminal, if we use curl to hit that endpoint, this is what we should see:</p>
<pre class="calibre17"><strong class="calibre1">$ curl http://localhost:8000</strong><br class="title-page-name"/>Hello, Rocket!$</pre>
<div class="packt_tip">Experienced Python users will find Rocket similar to the framework called Flask.</div>
<p class="calibre2">Let us now look at a more complex example: writing an API server using Rocket. Our application is a blog server that has the following endpoints:</p>
<table class="calibre33">
<tbody class="calibre34">
<tr class="calibre35">
<td class="calibre36">
<div class="cdpaligncenter"><strong class="calibre1">Endpoint</strong></div>
</td>
<td class="calibre36">
<div class="cdpaligncenter"><strong class="calibre1">Method</strong></div>
</td>
<td class="calibre36">
<div class="cdpaligncenter"><strong class="calibre1">Purpose</strong></div>
</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">/posts</kbd></td>
<td class="calibre36"><kbd class="calibre37">GET</kbd></td>
<td class="calibre36">Get all posts</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">/posts/&lt;id&gt;</kbd></td>
<td class="calibre36"><kbd class="calibre37">GET</kbd></td>
<td class="calibre36">Get the post with the given ID</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">/posts</kbd></td>
<td class="calibre36"><kbd class="calibre37">POST</kbd></td>
<td class="calibre36">Add a new post</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">/posts/&lt;id&gt;</kbd></td>
<td class="calibre36"><kbd class="calibre37">PATCH</kbd></td>
<td class="calibre36">Edit a post</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">/posts/&lt;id&gt;</kbd></td>
<td class="calibre36"><kbd class="calibre37">DELETE</kbd></td>
<td class="calibre36">Delete the post with the given ID</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">For this example, we will use SQLite Version 3 as our database. A real application should use a more scalable database, such as PostgresSQL or MySQL. We will use the diesel crate as our <strong class="calibre1">Object-Relational Mapping</strong> (<strong class="calibre1">ORM</strong>) tool, and r2d2 for connection-pooling to the database. The first step for this is to install the diesel CLI to work with database schema migrations. This can be installed using Cargo.</p>
<pre class="calibre17"><strong class="calibre1">$ cargo install diesel_cli --no-default-features --features sqlite</strong></pre>
<div class="packt_infobox">SQLite Version 3 must be installed on the host's system for this to work. For more information, visit the following link:<br class="calibre22"/>
<a href="https://www.sqlite.org/download.html" class="calibre38">https://www.sqlite.org/download.html</a> </div>
<p class="calibre2">Now we can set up our database using diesel CLI. It will read our migration scripts and create the whole schema. As SQLite is a file-based database, it will also create an empty <kbd class="calibre11">db</kbd> file, if one does not exist already.</p>
<pre class="calibre17"><strong class="calibre1">$ DATABASE_URL=db.sql diesel migration run</strong></pre>
<p class="calibre2">Remember that the last command must be run from the directory that has the migrations directory, otherwise it will fail to find the migrations. We will use Cargo to set up the project:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin rocket-blog</strong></pre>
<p class="calibre2">We will then add a number of dependencies here; <kbd class="calibre11">Cargo.toml</kbd> should look like the following code snippet:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/>name = "rocket-blog"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>rocket = "0.3.5"<br class="title-page-name"/>rocket_codegen = "0.3.5"<br class="title-page-name"/>rocket_contrib = "0.3.5"<br class="title-page-name"/>diesel = { version = "0.16.0", features = ["sqlite"] }<br class="title-page-name"/>diesel_codegen = { version = "0.16.0", features = ["sqlite"] }<br class="title-page-name"/>dotenv = "0.10.1"<br class="title-page-name"/>serde = "1.0.21"<br class="title-page-name"/>serde_json = "1.0.6"<br class="title-page-name"/>serde_derive = "1.0.21"<br class="title-page-name"/>lazy_static = "0.2.11"<br class="title-page-name"/>r2d2 = "0.7.4"<br class="title-page-name"/>r2d2-diesel = "0.16.0"</pre>
<p class="calibre2">This app is a bit more complex than our previous example. This is composed of multiple modules, each doing a specific thing. Here is how the <kbd class="calibre11">src</kbd> directory looks:</p>
<pre class="calibre17"><strong class="calibre1">$ tree src/</strong><br class="title-page-name"/>src/<br class="title-page-name"/>├── db.rs<br class="title-page-name"/>├── error.rs<br class="title-page-name"/>├── main.rs<br class="title-page-name"/>├── models.rs<br class="title-page-name"/>├── post.rs<br class="title-page-name"/>└── schema.rs</pre>
<p class="calibre2">The first step in running this is to set up connection to the database. We will use r2d2 for database pooling; all the <kbd class="calibre11">db</kbd> setup-related operations will be in <kbd class="calibre11">db.rs</kbd>. This will look like the following code snippet:</p>
<pre class="calibre17">// ch6/rocket-blog/src/db.rs<br class="title-page-name"/><br class="title-page-name"/>use dotenv::dotenv;<br class="title-page-name"/>use std::env;<br class="title-page-name"/>use diesel::sqlite::SqliteConnection;<br class="title-page-name"/>use r2d2;<br class="title-page-name"/>use r2d2_diesel::ConnectionManager;<br class="title-page-name"/>use rocket::request::{Outcome, FromRequest};<br class="title-page-name"/>use rocket::Outcome::{Success, Failure};<br class="title-page-name"/>use rocket::Request;<br class="title-page-name"/>use rocket::http::Status;<br class="title-page-name"/><br class="title-page-name"/>// Statically initialize our DB pool<br class="title-page-name"/>lazy_static! {<br class="title-page-name"/>    pub static ref DB_POOL:<br class="title-page-name"/>    r2d2::Pool&lt;ConnectionManager&lt;SqliteConnection&gt;&gt; = {<br class="title-page-name"/>        dotenv().ok();<br class="title-page-name"/><br class="title-page-name"/>        let database_url = env::var("DATABASE_URL").<br class="title-page-name"/>        expect("DATABASE_URL must be set");<br class="title-page-name"/>        let config = r2d2::Config::builder()<br class="title-page-name"/>            .pool_size(32)<br class="title-page-name"/>            .build();<br class="title-page-name"/>        let manager = ConnectionManager::<br class="title-page-name"/>        &lt;SqliteConnection&gt;::new(database_url);<br class="title-page-name"/>        r2d2::Pool::new(config, manager).expect("Failed to create<br class="title-page-name"/>        pool.")<br class="title-page-name"/>    };<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>pub struct DB(r2d2::PooledConnection&lt;ConnectionManager&lt;SqliteConnection&gt;&gt;);<br class="title-page-name"/><br class="title-page-name"/>// Make sure DB pointers deref nicely <br class="title-page-name"/>impl Deref for DB {<br class="title-page-name"/>    type Target = SqliteConnection;<br class="title-page-name"/><br class="title-page-name"/>    fn deref(&amp;self) -&gt; &amp;Self::Target {<br class="title-page-name"/>        &amp;self.0<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl&lt;'a, 'r&gt; FromRequest&lt;'a, 'r&gt; for DB {<br class="title-page-name"/>    type Error = r2d2::GetTimeout;<br class="title-page-name"/>    fn from_request(_: &amp;'a Request&lt;'r&gt;) -&gt; Outcome&lt;Self, Self::Error&gt; {<br class="title-page-name"/>        match DB_POOL.get() {<br class="title-page-name"/>            Ok(conn) =&gt; Success(DB(conn)),<br class="title-page-name"/>            Err(e) =&gt; Failure((Status::InternalServerError, e)),<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Our <kbd class="calibre11">DB</kbd> struct has an instance of the database pool and returns that on calling the function called <kbd class="calibre11">conn</kbd>. <kbd class="calibre11">FromRequest</kbd>. This is a request guard trait from Rocket that makes sure that particular requests can be fulfilled by the handler that matched. In our case, we use it to make sure a new connection is available in the pool, and we return an HTTP 500 error if that is not the case. Now this trait will be used for all incoming requests throughout the life of the program. Thus, for this to work correctly, the reference to the database pool must live throughout the program and not the local scope. We use the <kbd class="calibre11">lazy_static!</kbd> crate to make sure the constant <kbd class="calibre11">DB_POOL</kbd> is initialized only once and lives throughout the life of the program. In the macro, we set up <kbd class="calibre11">dotenv</kbd>, which will be used later to parse the database location and also the connection pool with a size of 32 connections. We also implement the <kbd class="calibre11">Deref</kbd> trait for our database wrapper so that <kbd class="calibre11">&amp;*DB</kbd> is transparently translated to a <kbd class="calibre11">&amp;SqliteConnection</kbd>.</p>
<p class="calibre2">The next step is to set up the database schema in code. Luckily, <kbd class="calibre11">diesel</kbd> makes that very easy, as it can read the database schema and generate Rust code to represent that accordingly. The generated Rust code is put in a module corresponding to the name of the file it is in (in this case, the module will be called <kbd class="calibre11">schema</kbd>). We use the <kbd class="calibre11">dotenv</kbd> crate to pass this information to a <kbd class="calibre11">diesel</kbd> macro. This is done in the file <kbd class="calibre11">schema.rs</kbd>:</p>
<pre class="calibre17">// ch6/rocket-blog/src/schema.rs<br class="title-page-name"/><br class="title-page-name"/>infer_schema!("dotenv:DATABASE_URL");</pre>
<p class="calibre2">Note that once the new macro system is functional, this call will use the <kbd class="calibre11">dotenv!</kbd> macro. We can then use the generated schema to build our models. This is done in <kbd class="calibre11">models.rs</kbd>. This file will look like the following code snippet:</p>
<pre class="calibre17">// ch6/rocket-blog/src/models.rs<br class="title-page-name"/><br class="title-page-name"/>use super::schema::posts;<br class="title-page-name"/>use rocket::{Request, Data};<br class="title-page-name"/>use rocket::data::{self, FromData};<br class="title-page-name"/>use rocket::http::Status;<br class="title-page-name"/>use rocket::Outcome::*;<br class="title-page-name"/>use serde_json;<br class="title-page-name"/><br class="title-page-name"/>// Represents a blog post in the database<br class="title-page-name"/>#[derive(Queryable)]<br class="title-page-name"/>#[derive(Serialize,Deserialize)]<br class="title-page-name"/>pub struct Post {<br class="title-page-name"/>    pub id: i32,<br class="title-page-name"/>    pub title: String,<br class="title-page-name"/>    pub body: String,<br class="title-page-name"/>    pub pinned: bool,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Represents a blog post as incoming request data<br class="title-page-name"/>#[derive(Insertable, Deserialize, AsChangeset)]<br class="title-page-name"/>#[table_name="posts"]<br class="title-page-name"/>pub struct PostData {<br class="title-page-name"/>    pub title: String,<br class="title-page-name"/>    pub body: String,<br class="title-page-name"/>    pub pinned: bool,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// This enables using PostData from incoming request data<br class="title-page-name"/>impl FromData for PostData {<br class="title-page-name"/>    type Error = String;<br class="title-page-name"/><br class="title-page-name"/>    #[allow(unused_variables)]<br class="title-page-name"/>    fn from_data(req: &amp;Request, data: Data) -&gt; data::Outcome&lt;Self,<br class="title-page-name"/>    String&gt; {<br class="title-page-name"/>        let reader = data.open();<br class="title-page-name"/>        match serde_json::from_reader(reader).map(|val| val) {<br class="title-page-name"/>            Ok(value) =&gt; Success(value),<br class="title-page-name"/>            Err(e) =&gt; Failure((Status::BadRequest, e.to_string())),<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We have two major structures here: the <kbd class="calibre11">Post</kbd> structure represents a blog post in the database, and the <kbd class="calibre11">PostData</kbd> structure represents a blog post as seen in an incoming create request. As a <kbd class="calibre11">PostData</kbd> has not been saved in the database yet, it does not have an ID. Diesel necessitates that all types that can be queried should implement the <kbd class="calibre11">Queryable</kbd> trait, which is done automatically using <kbd class="calibre11">#[derive(Queryable)]</kbd>. We also enable serialization and deserialization using serde, as this will be passed as JSON to the API. In contrast, the <kbd class="calibre11">PostData</kbd> struct does not derive <kbd class="calibre11">Queryable</kbd>; it derives some other traits. The <kbd class="calibre11">Insertable</kbd> trait indicates that this struct can be used to insert a row of data in a table (with the specified table name). Because we will only need to deserialize this struct from an incoming request, we only implement <kbd class="calibre11">Deserialize</kbd> on it. Lastly, the <kbd class="calibre11">AsChangeSet</kbd> trait enables this struct to be used to update records in the database.</p>
<p class="calibre2">The <kbd class="calibre11">FromData</kbd> trait is from Rocket, which is used to validate incoming data, making sure it parses into JSON correctly. This is in relation to a feature called data guards. When Rocket finds a suitable handler for an incoming request, it calls the data guard of the data type specified in the request handler on the incoming data. The route is actually invoked only if the data guard succeeds. These guards are implemented using the <kbd class="calibre11">FromData</kbd> trait. In our case, the implementation tries to parse the input as a JSON (using SerDe). In the success case, we return the JSON for further processing, or we return a <kbd class="calibre11">Status::BadRequest</kbd>, which sends back an HTTP 400 error.</p>
<p class="calibre2">The only database-related thing required now is the model. This will define a number of convenience methods that can be used to manipulate records using diesel. The file <kbd class="calibre11">post.rs</kbd> hosts these, and it looks like the following code snippet:</p>
<pre class="calibre17">// ch6/rocket-blog/src/post.rs<br class="title-page-name"/><br class="title-page-name"/>use diesel::result::Error;<br class="title-page-name"/>use diesel;<br class="title-page-name"/>use diesel::sqlite::SqliteConnection;<br class="title-page-name"/>use models::*;<br class="title-page-name"/>use diesel::prelude::*;<br class="title-page-name"/>use schema::posts;<br class="title-page-name"/><br class="title-page-name"/>// Returns post with given id<br class="title-page-name"/>pub fn get_post(conn: &amp;SqliteConnection, id: i32) -&gt; Result&lt;Post, Error&gt; {<br class="title-page-name"/>    posts::table<br class="title-page-name"/>        .find(id)<br class="title-page-name"/>        .first::&lt;Post&gt;(conn)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Returns all posts<br class="title-page-name"/>pub fn get_posts(conn: &amp;SqliteConnection) -&gt; Result&lt;Vec&lt;Post&gt;, Error&gt; {<br class="title-page-name"/>    posts::table<br class="title-page-name"/>        .load::&lt;Post&gt;(conn)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Creates a post with the given PostData, assigns a ID<br class="title-page-name"/>pub fn create_post(conn: &amp;SqliteConnection, post: PostData) -&gt; bool {<br class="title-page-name"/>    diesel::insert(&amp;post)<br class="title-page-name"/>        .into(posts::table).execute(conn).is_ok()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Deletes a post with the given ID<br class="title-page-name"/>pub fn delete_post(conn: &amp;SqliteConnection, id: i32) -&gt; Result&lt;usize, Error&gt; {<br class="title-page-name"/>    diesel::delete(posts::table.find(id))<br class="title-page-name"/>        .execute(conn)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Updates a post with the given ID and PostData<br class="title-page-name"/>pub fn update_post(conn: &amp;SqliteConnection, id: i32, updated_post: PostData) -&gt; bool {<br class="title-page-name"/>    diesel::update(posts::table<br class="title-page-name"/>        .find(id))<br class="title-page-name"/>        .set(&amp;updated_post).execute(conn).is_ok()<br class="title-page-name"/>}</pre>
<p class="calibre2">The function names are very self-explanatory. We make abundant use of a number of diesel APIs that help us to interact with the database without writing SQL directly. All of these functions take in a reference to the database connection. The <kbd class="calibre11">get_post</kbd> function takes in an additional post ID that it uses on the posts table to look up posts using the <kbd class="calibre11">find</kbd> method, and then returns the first result as an instance of <kbd class="calibre11">Post</kbd>. The <kbd class="calibre11">get_posts</kbd> function is similar, except it returns all records in the posts table as a vector of <kbd class="calibre11">Post</kbd> instances. <kbd class="calibre11">create_post</kbd> takes in a reference to <kbd class="calibre11">PostData</kbd> and inserts that record into the database. This function returns a <kbd class="calibre11">bool</kbd> indicating success or failure. <kbd class="calibre11">delete_post</kbd> takes in a post ID and tries to delete it in the database. <kbd class="calibre11">update_post</kbd> again takes in a reference to <kbd class="calibre11">PostData</kbd> and a post ID. It then tries to replace the post with the given ID with the new <kbd class="calibre11">PostData</kbd>.</p>
<p class="calibre2">Let us move on to defining errors for our API. This will be located in the file called <kbd class="calibre11">error.rs</kbd>. As will see here, the errors will need to implement a number of traits to be used seamlessly in Rocket and Diesel.</p>
<pre class="calibre17">// ch6/rocket-blog/src/error.rs<br class="title-page-name"/><br class="title-page-name"/>use std::error::Error;<br class="title-page-name"/>use std::convert::From;<br class="title-page-name"/>use std::fmt;<br class="title-page-name"/>use diesel::result::Error as DieselError;<br class="title-page-name"/>use rocket::http::Status;<br class="title-page-name"/>use rocket::response::{Response, Responder};<br class="title-page-name"/>use rocket::Request;<br class="title-page-name"/><br class="title-page-name"/>#[derive(Debug)]<br class="title-page-name"/>pub enum ApiError {<br class="title-page-name"/>    NotFound,<br class="title-page-name"/>    InternalServerError,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl fmt::Display for ApiError {<br class="title-page-name"/>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br class="title-page-name"/>        match *self {<br class="title-page-name"/>            ApiError::NotFound =&gt; f.write_str("NotFound"),<br class="title-page-name"/>            ApiError::InternalServerError =&gt; f.write_str("InternalServerError"),<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Translates a database error to an API error<br class="title-page-name"/>impl From&lt;DieselError&gt; for ApiError {<br class="title-page-name"/>    fn from(e: DieselError) -&gt; Self {<br class="title-page-name"/>        match e {<br class="title-page-name"/>            DieselError::NotFound =&gt; ApiError::NotFound,<br class="title-page-name"/>            _ =&gt; ApiError::InternalServerError,<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Error for ApiError {<br class="title-page-name"/>    fn description(&amp;self) -&gt; &amp;str {<br class="title-page-name"/>        match *self {<br class="title-page-name"/>            ApiError::NotFound =&gt; "Record not found",<br class="title-page-name"/>            ApiError::InternalServerError =&gt; "Internal server error",<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// This enables sending back an API error from a route<br class="title-page-name"/>impl&lt;'r&gt; Responder&lt;'r&gt; for ApiError {<br class="title-page-name"/>    fn respond_to(self, _request: &amp;Request) -&gt; Result&lt;Response&lt;'r&gt;, Status&gt; {<br class="title-page-name"/>        match self {<br class="title-page-name"/>            ApiError::NotFound =&gt; Err(Status::NotFound),<br class="title-page-name"/>            _ =&gt; Err(Status::InternalServerError),<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Our error is an <kbd class="calibre11">enum</kbd> called <kbd class="calibre11">ApiError</kbd>; for simplicity's sake, we will only return an object-not-found error and a catch-all internal server error. As we have seen in previous chapters, to declare an error in Rust, we will need to implement <kbd class="calibre11">fmt::Display</kbd> and <kbd class="calibre11">std::error::Error</kbd> on that type. We also implement <kbd class="calibre11">From&lt;DieselError&gt;</kbd> for our type so that a failure in the database lookup can be reported appropriately. The final trait we need to implement is <kbd class="calibre11">Responder</kbd> from Rocket, which enables us to use this as the return type of a request handler.</p>
<p class="calibre2">Having done all the groundwork, the last part of the system is our main file that will run when invoked with Cargo. It should look like the following code snippet:</p>
<pre class="calibre17">// ch6/rocket-blog/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(plugin)]<br class="title-page-name"/>#![plugin(rocket_codegen)]<br class="title-page-name"/>extern crate rocket;<br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate diesel;<br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate diesel_codegen;<br class="title-page-name"/>extern crate dotenv;<br class="title-page-name"/>extern crate serde_json;<br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate lazy_static;<br class="title-page-name"/>extern crate rocket_contrib;<br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate serde_derive;<br class="title-page-name"/>extern crate r2d2;<br class="title-page-name"/>extern crate r2d2_diesel;<br class="title-page-name"/><br class="title-page-name"/>mod schema;<br class="title-page-name"/>mod db;<br class="title-page-name"/>mod post;<br class="title-page-name"/>mod models;<br class="title-page-name"/>mod error;<br class="title-page-name"/><br class="title-page-name"/>use db::DB;<br class="title-page-name"/>use post::{get_posts, get_post, create_post, delete_post, update_post};<br class="title-page-name"/>use models::*;<br class="title-page-name"/>use rocket_contrib::Json;<br class="title-page-name"/>use rocket::response::status::{Created, NoContent};<br class="title-page-name"/>use rocket::Rocket;<br class="title-page-name"/>use error::ApiError;<br class="title-page-name"/><br class="title-page-name"/>#[get("/posts", format = "application/json")]<br class="title-page-name"/>fn posts_get(db: DB) -&gt; Result&lt;Json&lt;Vec&lt;Post&gt;&gt;, ApiError&gt; {<br class="title-page-name"/>    let posts = get_posts(&amp;db)?;<br class="title-page-name"/>    Ok(Json(posts))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[get("/posts/&lt;id&gt;", format = "application/json")]<br class="title-page-name"/>fn post_get(db: DB, id: i32) -&gt; Result&lt;Json&lt;Post&gt;, ApiError&gt; {<br class="title-page-name"/>    let post = get_post(&amp;db, id)?;<br class="title-page-name"/>    Ok(Json(post))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[post("/posts", format = "application/json", data = "&lt;post&gt;")]<br class="title-page-name"/>fn post_create(db: DB, post: PostData) -&gt; Result&lt;Created&lt;String&gt;, ApiError&gt; {<br class="title-page-name"/>    let post = create_post(&amp;db, post);<br class="title-page-name"/>    let url = format!("/post/{}", post);<br class="title-page-name"/>    Ok(Created(url, Some("Done".to_string())))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[patch("/posts/&lt;id&gt;", format = "application/json", data = "&lt;post&gt;")]<br class="title-page-name"/>fn post_edit(db: DB, id: i32, post: PostData) -&gt; Result&lt;Json&lt;bool&gt;, ApiError&gt; {<br class="title-page-name"/>    let post = update_post(&amp;db, id, post);<br class="title-page-name"/>    Ok(Json(post))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[delete("/posts/&lt;id&gt;")]<br class="title-page-name"/>fn post_delete(db: DB, id: i32) -&gt; Result&lt;NoContent, ApiError&gt; {<br class="title-page-name"/>    delete_post(&amp;db, id)?;<br class="title-page-name"/>    Ok(NoContent)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Helper method to setup a rocket instance<br class="title-page-name"/>fn rocket() -&gt; Rocket {<br class="title-page-name"/>    rocket::ignite().mount("/", routes![post_create, posts_get, post_delete, post_edit, post_get])<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>        rocket().launch();<br class="title-page-name"/>}</pre>
<p class="calibre2">The most important things here are the route handlers. These are just regular functions with special attributes that determine the path, the format, and the arguments. Also, notice the use of instances of <kbd class="calibre11">DB</kbd> as request guards in the handlers. We have a helper function called <kbd class="calibre11">rocket</kbd> that sets up everything, and the <kbd class="calibre11">main</kbd> function just calls the <kbd class="calibre11">ignite</kbd> method to start the server. When <kbd class="calibre11">rocket</kbd> sees an incoming request, this is how a response is generated:</p>
<ol class="calibre13">
<li value="1" class="calibre8">It goes over the list of all handlers and finds one that matches the HTTP method, type, and format. If one is found, it ensures that the handler's parameters can be derived from the data in the request using <kbd class="calibre11">FormData</kbd>. This process continues till a handler works or all handlers have been exhausted. In the latter case, a 404 error is returned.</li>
</ol>
<p class="calibre2"> </p>
<ol start="2" class="calibre13">
<li value="2" class="calibre8">The handler function then receives a copy of the data parsed into the given data type. After it has done processing, it must use the <kbd class="calibre11">Responder</kbd> implementation to convert the output to a valid return type.</li>
<li value="3" class="calibre8">Finally, <kbd class="calibre11">Rocket</kbd> sends back the response to the client.</li>
</ol>
<p class="calibre2">Having set up everything, running the server is very easy:</p>
<pre class="calibre17"><strong class="calibre1">$ DATABASE_URL=db.sql cargo run</strong></pre>
<p class="calibre2">You can use <kbd class="calibre11">curl</kbd> to interact with the server, as shown in the following code snippet. We use <kbd class="calibre11">jq</kbd> for formatting the JSON nicely by piping curl's output to <kbd class="calibre11">jq</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">$ curl -X POST -H "Content-Type: application/json" -d '{"title": "Hello Rust!", "body": "Rust is awesome!!", "pinned": true}' http://localhost:8000/posts</strong><br class="title-page-name"/>Done<br class="title-page-name"/><strong class="calibre1">$ curl http://localhost:8000/posts | jq</strong><br class="title-page-name"/>  % Total % Received % Xferd Average Speed Time Time Time Current<br class="title-page-name"/>                                 Dload Upload Total Spent Left Speed<br class="title-page-name"/>100 130 100 130 0 0 130 0 0:00:01 --:--:-- 0:00:01 8125<br class="title-page-name"/>[<br class="title-page-name"/>  {<br class="title-page-name"/>    "id": 1,<br class="title-page-name"/>    "title": "test",<br class="title-page-name"/>    "body": "test body",<br class="title-page-name"/>    "pinned": true<br class="title-page-name"/>  },<br class="title-page-name"/>  {<br class="title-page-name"/>    "id": 2,<br class="title-page-name"/>    "title": "Hello Rust!",<br class="title-page-name"/>    "body": "Rust is awesome!!",<br class="title-page-name"/>    "pinned": true<br class="title-page-name"/>  }<br class="title-page-name"/>]</pre>
<p class="calibre2">For comparison, here is how a load testing session looks:</p>
<pre class="calibre17"><strong class="calibre1">$ ab -n 10000 -c 100 http://localhost:8000/posts</strong><br class="title-page-name"/>Benchmarking localhost (be patient)<br class="title-page-name"/>Completed 1000 requests<br class="title-page-name"/>Completed 2000 requests<br class="title-page-name"/>Completed 3000 requests<br class="title-page-name"/>Completed 4000 requests<br class="title-page-name"/>Completed 5000 requests<br class="title-page-name"/>Completed 6000 requests<br class="title-page-name"/>Completed 7000 requests<br class="title-page-name"/>Completed 8000 requests<br class="title-page-name"/>Completed 9000 requests<br class="title-page-name"/>Completed 10000 requests<br class="title-page-name"/>Finished 10000 requests<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>Server Software: Rocket<br class="title-page-name"/>Server Hostname: localhost<br class="title-page-name"/>Server Port: 8000<br class="title-page-name"/><br class="title-page-name"/>Document Path: /posts<br class="title-page-name"/>Document Length: 130 bytes<br class="title-page-name"/><br class="title-page-name"/>Concurrency Level: 100<br class="title-page-name"/>Time taken for tests: 2.110 seconds<br class="title-page-name"/>Complete requests: 10000<br class="title-page-name"/>Failed requests: 0<br class="title-page-name"/>Total transferred: 2740000 bytes<br class="title-page-name"/>HTML transferred: 1300000 bytes<br class="title-page-name"/>Requests per second: 4740.00 [#/sec] (mean)<br class="title-page-name"/>Time per request: 21.097 [ms] (mean)<br class="title-page-name"/>Time per request: 0.211 [ms] (mean, across all concurrent requests)<br class="title-page-name"/>Transfer rate: 1268.32 [Kbytes/sec] received<br class="title-page-name"/><br class="title-page-name"/>Connection Times (ms)<br class="title-page-name"/>              min mean[+/-sd] median max<br class="title-page-name"/>Connect: 0 0 0.4 0 4<br class="title-page-name"/>Processing: 3 21 20.3 19 229<br class="title-page-name"/>Waiting: 2 20 19.8 18 228<br class="title-page-name"/>Total: 7 21 20.3 19 229<br class="title-page-name"/><br class="title-page-name"/>Percentage of the requests served within a certain time (ms)<br class="title-page-name"/>  50% 19<br class="title-page-name"/>  66% 19<br class="title-page-name"/>  75% 20<br class="title-page-name"/>  80% 20<br class="title-page-name"/>  90% 21<br class="title-page-name"/>  95% 22<br class="title-page-name"/>  98% 26<br class="title-page-name"/>  99% 214<br class="title-page-name"/> 100% 229 (longest request)</pre>
<p class="calibre2">Now, to be fair to our earlier servers, we had a delay of 100 ms there. In this case, each request takes around 21 ms on average. So, hypothetically, if each request took 100 ms, we would have one fifth of the throughput. That comes up to be around 950 requests per second—way faster than our earlier servers!</p>
<p class="calibre2">Now, obviously, an HTTP server cannot be all about REST endpoints. It must be able to serve static and dynamic content as well. For that, Rocket has a bunch of features to be able to generate HTML. Let us look at an example, which is a simple web page that takes in a name as a URL parameter and outputs that. The page also counts the total number of visits and displays that as well. The Cargo setup for this project is simple: we just run the following command:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin rocket-templates</strong></pre>
<p class="calibre2">This time, we will just need Rocket in our <kbd class="calibre11">Cargo.toml</kbd> file:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/>name = "rocket-templates"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>rocket = "0.3.5"<br class="title-page-name"/>rocket_codegen = "0.3.5"<br class="title-page-name"/><br class="title-page-name"/>[dependencies.rocket_contrib]<br class="title-page-name"/>version = "*"<br class="title-page-name"/>default-features = false<br class="title-page-name"/>features = ["tera_templates"]</pre>
<p class="calibre2">Our web page will be generated from a template. We will use a templating engine called Tera, which is inspired by Jinja2 and is written in Rust. Rocket supports templates in a different crate called <kbd class="calibre11">rocket_contrib</kbd>, which we will pull in with required features. Our template is pretty simple and should look like this:</p>
<pre class="calibre17">// ch6/rocket-templates/templates/webpage.html.tera<br class="title-page-name"/><br class="title-page-name"/>&lt;!DOCTYPE html&gt;<br class="title-page-name"/>&lt;html&gt;<br class="title-page-name"/>  &lt;head&gt;<br class="title-page-name"/>    &lt;meta charset="utf-8" /&gt;<br class="title-page-name"/>    &lt;title&gt;Rocket template demo&lt;/title&gt;<br class="title-page-name"/>  &lt;/head&gt;<br class="title-page-name"/>  &lt;body&gt;<br class="title-page-name"/>    &lt;h1&gt;Hi {{name}}, you are visitor number {{ visitor_number }}&lt;/h1&gt;<br class="title-page-name"/>  &lt;/body&gt;<br class="title-page-name"/>&lt;/html&gt;</pre>
<p class="calibre2">Note that the template has to be in a directory called <kbd class="calibre11">templates</kbd> in the project root, otherwise <kbd class="calibre11">Rocket</kbd> will not be able to find it. In this case, the template is pretty simple. It needs to be a complete HTML page, as we intend to display it in a browser. We use two temporary variables, <kbd class="calibre11">name</kbd> and <kbd class="calibre11">visitor_number</kbd>, that will be replaced during execution. Our main file will look like the following code snippet:</p>
<pre class="calibre17">// ch6/rocket-templates/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(plugin)]<br class="title-page-name"/>#![plugin(rocket_codegen)]<br class="title-page-name"/><br class="title-page-name"/>extern crate rocket_contrib;<br class="title-page-name"/>extern crate rocket;<br class="title-page-name"/><br class="title-page-name"/>use rocket_contrib::Template;<br class="title-page-name"/>use rocket::{Rocket, State};<br class="title-page-name"/>use std::collections::HashMap;<br class="title-page-name"/>use std::sync::atomic::{AtomicUsize, Ordering};<br class="title-page-name"/><br class="title-page-name"/>struct VisitorCounter {<br class="title-page-name"/>    visitor_number: AtomicUsize,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[get("/webpage/&lt;name&gt;")]<br class="title-page-name"/>fn webpage(name: String, visitor: State&lt;VisitorCounter&gt;) -&gt; Template {<br class="title-page-name"/>    let mut context = HashMap::new();<br class="title-page-name"/>    context.insert("name", name);<br class="title-page-name"/>    let current = visitor.visitor_number.fetch_add(1, Ordering::SeqCst);<br class="title-page-name"/>    context.insert("visitor_number", current.to_string());<br class="title-page-name"/>    Template::render("webpage", &amp;context)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn rocket() -&gt; Rocket {<br class="title-page-name"/>    rocket::ignite()<br class="title-page-name"/>        .manage(VisitorCounter { visitor_number: AtomicUsize::new(1) })<br class="title-page-name"/>        .mount("/", routes![webpage])<br class="title-page-name"/>        .attach(Template::fairing())<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    rocket().launch();<br class="title-page-name"/>}</pre>
<p class="calibre2">Our setup is pretty much the same as last time; the only difference being, we have used the template fairing, which is like a middleware in Rocket. To use this, we needed to call <kbd class="calibre11">attach(Template::fairing())</kbd> on the rocket instance. Another difference is the use of managed state, which we use to manage our counter automatically. This is achieved by calling <kbd class="calibre11">manage</kbd> on the instance and passing an initial state for the managed object. Our counter is a struct, having only one element that holds the current count. Now our counter will be shared between multiple threads, all running rocket instances. To make the counter thread safe, we have used the primitive <kbd class="calibre11">AtomicUsize</kbd>, which guarantees thread safety. In our route, we match on the <kbd class="calibre11">GET</kbd> verb and we take in a name as a URL parameter. To render our template, we will need to build a context and populate it. Whenever an incoming request matches this route, we can insert the name in our context. We then call <kbd class="calibre11">fetch_add</kbd> on the underlying counter. This method increments the counter and returns the previous value, which we store in the context against a key called <kbd class="calibre11">visitor_number</kbd>. Once done, we can render our template, which is returned to the client. Note the use of <kbd class="calibre11">Ordering::SeqCst</kbd> in <kbd class="calibre11">fetch_add</kbd>, which guarantees a sequentially consistent view of the counter across all competing threads. Also note that the names of the keys in the context have to match the temporary variables used in the template, otherwise rendering will fail.</p>
<p class="calibre2">Running this is easy; we just need to use <kbd class="calibre11">cargo run</kbd>. This is what we see on the CLI:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/rocket-templates`<br class="title-page-name"/>Configured for development.<br class="title-page-name"/>    =&gt; address: localhost<br class="title-page-name"/>    =&gt; port: 8000<br class="title-page-name"/>    =&gt; log: normal<br class="title-page-name"/>    =&gt; workers: 16<br class="title-page-name"/>    =&gt; secret key: generated<br class="title-page-name"/>    =&gt; limits: forms = 32KiB<br class="title-page-name"/>    =&gt; tls: disabled<br class="title-page-name"/>Mounting '/':<br class="title-page-name"/>    =&gt; GET /webpage/&lt;name&gt;<br class="title-page-name"/>Rocket has launched from http://localhost:8000</pre>
<p class="calibre2">We can then use a web browser to access the page to see something like the following screenshot:</p>
<div class="cdpaligncenter"><img src="../images/00015.jpeg" class="calibre39"/></div>
<p class="calibre2">Notice that the counter resets when the <kbd class="calibre11">Rocket</kbd> instance is restarted. A real-world application may decide to persist such a metric in a database so that it is not lost between restarts. This also works with <kbd class="calibre11">curl</kbd>, which just dumps the raw HTML in the console:</p>
<pre class="calibre17"><strong class="calibre1">$ curl http://localhost:8000/webpage/foo</strong><br class="title-page-name"/>&lt;!DOCTYPE html&gt;<br class="title-page-name"/>&lt;html&gt;<br class="title-page-name"/>  &lt;head&gt;<br class="title-page-name"/>    &lt;meta charset="utf-8" /&gt;<br class="title-page-name"/>    &lt;title&gt;Rocket template demo&lt;/title&gt;<br class="title-page-name"/>  &lt;/head&gt;<br class="title-page-name"/>  &lt;body&gt;<br class="title-page-name"/>    &lt;h1&gt;Hi foo, you are visitor number 2&lt;/h1&gt;<br class="title-page-name"/>  &lt;/body&gt;<br class="title-page-name"/>&lt;/html&gt;</pre>
<p class="calibre2">The last experiment with this piece of code is performance analysis. As always, we will fire up apache bench and point it to the endpoint. This is what one run shows:</p>
<pre class="calibre17"><strong class="calibre1">$ ab -n 10000 -c 100 http://localhost:8000/webpage/foobar</strong><br class="title-page-name"/>Benchmarking localhost (be patient)<br class="title-page-name"/>Completed 1000 requests<br class="title-page-name"/>Completed 2000 requests<br class="title-page-name"/>Completed 3000 requests<br class="title-page-name"/>Completed 4000 requests<br class="title-page-name"/>Completed 5000 requests<br class="title-page-name"/>Completed 6000 requests<br class="title-page-name"/>Completed 7000 requests<br class="title-page-name"/>Completed 8000 requests<br class="title-page-name"/>Completed 9000 requests<br class="title-page-name"/>Completed 10000 requests<br class="title-page-name"/>Finished 10000 requests<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>Server Software: Rocket<br class="title-page-name"/>Server Hostname: localhost<br class="title-page-name"/>Server Port: 8000<br class="title-page-name"/><br class="title-page-name"/>Document Path: /webpage/foobar<br class="title-page-name"/>Document Length: 191 bytes<br class="title-page-name"/><br class="title-page-name"/>Concurrency Level: 100<br class="title-page-name"/>Time taken for tests: 2.305 seconds<br class="title-page-name"/>Complete requests: 10000<br class="title-page-name"/>Failed requests: 0<br class="title-page-name"/>Total transferred: 3430000 bytes<br class="title-page-name"/>HTML transferred: 1910000 bytes<br class="title-page-name"/>Requests per second: 4337.53 [#/sec] (mean)<br class="title-page-name"/>Time per request: 23.055 [ms] (mean)<br class="title-page-name"/>Time per request: 0.231 [ms] (mean, across all concurrent requests)<br class="title-page-name"/>Transfer rate: 1452.90 [Kbytes/sec] received<br class="title-page-name"/><br class="title-page-name"/>Connection Times (ms)<br class="title-page-name"/>              min mean[+/-sd] median max<br class="title-page-name"/>Connect: 0 0 2.8 0 200<br class="title-page-name"/>Processing: 3 23 18.6 21 215<br class="title-page-name"/>Waiting: 3 22 18.0 20 214<br class="title-page-name"/>Total: 7 23 18.8 21 215<br class="title-page-name"/><br class="title-page-name"/>Percentage of the requests served within a certain time (ms)<br class="title-page-name"/>  50% 21<br class="title-page-name"/>  66% 21<br class="title-page-name"/>  75% 22<br class="title-page-name"/>  80% 22<br class="title-page-name"/>  90% 24<br class="title-page-name"/>  95% 25<br class="title-page-name"/>  98% 28<br class="title-page-name"/>  99% 202<br class="title-page-name"/> 100% 215 (longest request)</pre>
<p class="calibre2">Performance in this case is comparable to last time, as measured in requests per second. This one is slightly slower, as it has to increment the counter and render the template each time. This is also reflected in mean time per request, which increased by 2 ms.</p>
<p class="calibre2">Rocket has a ton of other features, from cookies to streaming data. It also supports SSL out of the box by reading a special config file that can be placed in the root directory of the application. However, those advanced features are outside the scope of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing reqwest</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have only talked about writing servers and used <kbd class="calibre11">curl</kbd> to access those. Sometimes, programmatically accessing a server becomes a necessity. In this section, we will discuss the <kbd class="calibre11">reqwest</kbd> crate and look at how to use it; this borrows heavily from the requests library in Python. Thus, it is very easy to set up and use, starting first with the project setup:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin reqwest-example</strong></pre>
<p class="calibre2">The next step for our demo is to include our dependencies. Our Cargo config should look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "reqwest-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>reqwest = "0.8.1"<br class="title-page-name"/>serde_json = "1.0.6"<br class="title-page-name"/>serde = "1.0.21"<br class="title-page-name"/>serde_derive = "1.0.21"</pre>
<p class="calibre2">Here, we will use Serde to serialize and deserialize our data to JSON. Very conveniently, we will use the <kbd class="calibre11">Rocket</kbd> server we wrote in the last section. Our main file will look like this:</p>
<pre class="calibre17">// ch6/reqwest-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate serde_json;<br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate serde_derive;<br class="title-page-name"/>extern crate reqwest;<br class="title-page-name"/><br class="title-page-name"/>#[derive(Debug,Serialize, Deserialize)]<br class="title-page-name"/>struct Post {<br class="title-page-name"/>    title: String,<br class="title-page-name"/>    body: String,<br class="title-page-name"/>    pinned: bool,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let url = "http://localhost:8000/posts";<br class="title-page-name"/>    let post: Post = Post {title: "Testing this".to_string(), body: "Try to write something".to_string(), pinned: true};<br class="title-page-name"/>    let client = reqwest::Client::new();<br class="title-page-name"/><br class="title-page-name"/>    // Creates a new blog post using the synchronous client<br class="title-page-name"/>    let res = client.post(url)<br class="title-page-name"/>            .json(&amp;post)<br class="title-page-name"/>            .send()<br class="title-page-name"/>            .unwrap();<br class="title-page-name"/>    println!("Got back: {}", res.status());<br class="title-page-name"/><br class="title-page-name"/>    // Retrieves all blog posts using the synchronous client<br class="title-page-name"/>    let mut posts = client.get(url).send().unwrap();<br class="title-page-name"/>    let json: Vec&lt;Post&gt; = posts.json().unwrap();<br class="title-page-name"/>    for post in json {<br class="title-page-name"/>        println!("{:?}", post);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We start with a struct to represent our blog post, which is exactly the same as the one in the last section. In our <kbd class="calibre11">main</kbd> function, we create an instance of our client and, using the builder pattern, pass on our post as a JSON to it. Finally, we call <kbd class="calibre11">send</kbd> on it and print out the return status. Make sure to change the <kbd class="calibre11">url</kbd> to point to the location where <kbd class="calibre11">Rocket</kbd> is running. We then issue a <kbd class="calibre11">GET</kbd> request on the same endpoint. We deserialize the response to a list of <kbd class="calibre11">Post</kbd> objects and print those out in a loop. Internally, reqwest uses SerDe to serialize and deserialize to/from JSON, making the API very user-friendly.</p>
<p class="calibre2">Here is an example session running the preceding code. In our server, we already had two existing entries and, in our code, we added one more. Then, we got back all three, which are printed here. Take a look at the following code snippet:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling reqwest-example v0.1.0 (file:///src/ch6/reqwest-example)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 1.94 secs<br class="title-page-name"/>     Running `target/debug/reqwest-example`<br class="title-page-name"/>Got back: 201 Created<br class="title-page-name"/>Post { title: "test", body: "test body", pinned: true }<br class="title-page-name"/>Post { title: "Hello Rust!", body: "Rust is awesome!!", pinned: true }<br class="title-page-name"/>Post { title: "Testing this", body: "Try to write something", pinned: true }</pre>
<p class="calibre2">Recently, <kbd class="calibre11">reqwest</kbd> added asynchronous programming support using tokio. All those APIs are located in <kbd class="calibre11">reqwest::unstable</kbd> and, as the name suggests, those are not stable yet. Let's look at using the asynchronous client for the same purpose. In this case, we will use the futures and tokio crates, thus we will need to include those in our cargo manifest, which will look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "reqwest-async"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>serde_json = "1.0.6"<br class="title-page-name"/>serde = "1.0.21"<br class="title-page-name"/>serde_derive = "1.0.21"<br class="title-page-name"/>futures = "0.1.17"<br class="title-page-name"/>tokio-core = "0.1.10"<br class="title-page-name"/><br class="title-page-name"/>[dependencies.reqwest]<br class="title-page-name"/>version = "0.8.1"<br class="title-page-name"/>features = ["unstable"]</pre>
<p class="calibre2">We will need to activate the feature called unstable in reqwest. Our main file will look like the following code snippet:</p>
<pre class="calibre17">// ch6/reqwest-async/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate serde_json;<br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate serde_derive;<br class="title-page-name"/>extern crate reqwest;<br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/><br class="title-page-name"/>use futures::Future;<br class="title-page-name"/>use tokio_core::reactor::Core;<br class="title-page-name"/>use reqwest::unstable::async::{Client, Decoder};<br class="title-page-name"/>use std::mem;<br class="title-page-name"/>use std::io::{self, Cursor};<br class="title-page-name"/>use futures::Stream;<br class="title-page-name"/><br class="title-page-name"/>#[derive(Debug, Serialize, Deserialize)]<br class="title-page-name"/>struct Post {<br class="title-page-name"/>    title: String,<br class="title-page-name"/>    body: String,<br class="title-page-name"/>    pinned: bool,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut core = Core::new().expect("Could not create core");<br class="title-page-name"/>    let url = "http://localhost:8000/posts";<br class="title-page-name"/>    let post: Post = Post {<br class="title-page-name"/>        title: "Testing this".to_string(),<br class="title-page-name"/>        body: "Try to write something".to_string(),<br class="title-page-name"/>        pinned: true,<br class="title-page-name"/>    };<br class="title-page-name"/>    let client = Client::new(&amp;core.handle());<br class="title-page-name"/><br class="title-page-name"/>    // Creates a new post using the async client<br class="title-page-name"/>    let res = client.post(url).json(&amp;post).send().and_then(|res| {<br class="title-page-name"/>        println!("{}", res.status());<br class="title-page-name"/>        Ok(())<br class="title-page-name"/>    });<br class="title-page-name"/>    core.run(res).unwrap();<br class="title-page-name"/><br class="title-page-name"/>    // Gets all current blog posts using the async client<br class="title-page-name"/>    let posts = client<br class="title-page-name"/>        .get(url)<br class="title-page-name"/>        .send()<br class="title-page-name"/>        .and_then(|mut res| {<br class="title-page-name"/>            println!("{}", res.status());<br class="title-page-name"/>            let body = mem::replace(res.body_mut(), Decoder::empty());<br class="title-page-name"/>            body.concat2().map_err(Into::into)<br class="title-page-name"/>        })<br class="title-page-name"/>        .and_then(|body| {<br class="title-page-name"/>            let mut body = Cursor::new(body);<br class="title-page-name"/>            let mut writer: Vec&lt;u8&gt; = vec![];<br class="title-page-name"/>            io::copy(&amp;mut body, &amp;mut writer).unwrap();<br class="title-page-name"/>            let posts: Vec&lt;Post&gt; = serde_json::from_str(std::str::from_utf8(&amp;writer).unwrap())<br class="title-page-name"/>                .unwrap();<br class="title-page-name"/>            for post in posts {<br class="title-page-name"/>                println!("{:?}", post);<br class="title-page-name"/>            }<br class="title-page-name"/>            Ok(())<br class="title-page-name"/>        });<br class="title-page-name"/>    core.run(posts).unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">Admittedly, this is way more convoluted than the previous version! Some scaffolding for the <kbd class="calibre11">Post</kbd> struct is the same, and we pull in all the extra libraries we need. In our <kbd class="calibre11">main</kbd> function, we create a tokio core and then an asynchronous client based on that core. We chain the <kbd class="calibre11">json</kbd> and <kbd class="calibre11">send</kbd> methods like last time. Things diverge from there; for the asynchronous client, the <kbd class="calibre11">send</kbd> call returns a future. Once that future has resolved, the <kbd class="calibre11">and_then</kbd> call executes another future based on the first one. In here, we print out the status that we got back and resolve the future by returning an <kbd class="calibre11">Ok(())</kbd>. Finally, we run our future on the core.</p>
<p class="calibre2">Getting data back from the endpoint is a bit more involved, because we have to deal with returned data as well. Here, we chain calls to <kbd class="calibre11">get</kbd> and <kbd class="calibre11">send</kbd>. We then chain another future that collects the response body. The second future is then chained to another one that consumes that body and copies it over to a <kbd class="calibre11">Vec&lt;u8&gt;</kbd> named <kbd class="calibre11">writer</kbd>. We then convert the vector to a <kbd class="calibre11">str</kbd> using <kbd class="calibre11">std::str::from_utf8</kbd>. The <kbd class="calibre11">str</kbd> is then passed to <kbd class="calibre11">serde_json::from_str</kbd>, which tries to deserialize it into a vector of <kbd class="calibre11">Post</kbd> objects that we can then print out by iterating over those. At the end, we resolve the chain of futures by returning an <kbd class="calibre11">Ok(())</kbd>. On running, this behaves exactly like the last one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we covered a number of crates that help with dealing with HTTP-based REST endpoints in Rust, using Hyper and Rocket. We also looked at programmatically accessing these endpoints, using request, which is largely based on Hyper. These crates are at various stages of development. As we saw, Rocket can only run on nightly, because it uses a bunch of features that are not stable yet. We also glossed over tokio, which powers both Hyper and Rocket.</p>
<p class="calibre2">Now, tokio, being the defacto asynchronous programming library in Rust, deserves all the attention it can get. So, we will discuss the tokio stack in detail in the next chapter.</p>


            </article>

            
        </section>
    </body></html>