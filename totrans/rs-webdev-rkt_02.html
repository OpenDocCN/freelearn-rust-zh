<html><head></head><body>
		<div><h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Introducing the Rust Language</h1>
			<p>Almost every programmer has heard about the <strong class="bold">Rust</strong> programming language or even tried or used it. Saying "the Rust programming language" every time is a little bit cumbersome, so let's just call it Rust, or the Rust language from this point forward.</p>
			<p>In this chapter, we will talk a little bit about Rust to help you if you are new to this language or as a refresher if you have tried it already. This chapter might also help seasoned Rust language programmers a bit. Later in the chapter, we will learn how to install the Rust toolchain and create a simple program to introduce the features of the Rust language. We will then use third-party libraries to enhance one of our programs, and finally, we will see how we can get help for the Rust language and its libraries.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>An overview of the Rust language</li>
				<li>Installing the Rust compiler and toolchain</li>
				<li>Writing Hello World</li>
				<li>Exploring Rust crates and Cargo</li>
				<li>Exploring other tools and where to get help</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>To follow the content of this book, you will need a computer running a Unix-like operating system such as Linux, macOS, or Windows with Windows Subsystem for Linux (WSLv1 or WSLv2) installed. Don't worry about the Rust compiler and toolchain; we will install it in this chapter if you don't have it installed already.</p>
			<p> The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter01">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter01</a>.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>An overview of the Rust language</h1>
			<p>To build web applications using the <strong class="bold">Rocket</strong> framework, we must first learn a bit about the Rust language <a id="_idIndexMarker000"/>since Rocket is built using that language. According to <a href="https://www.rust-lang.org">https://www.rust-lang.org</a>, the <a id="_idIndexMarker001"/>Rust language is "<em class="italic">a language empowering everyone to build reliable and efficient software</em>." It began as a personal project for a programmer named Graydon Hoare, an employee at Mozilla, around 2006. The Mozilla Foundation saw the potential of the language for their product; they started sponsoring the project in 2009 before announcing it to the public in 2010.</p>
			<p>Since its inception, the focus of Rust has always been on performance and safety. Building a web browser is not an easy job; an unsafe language can have very fast performance, but programmers working with system languages without adequate safety measures in place can make a lot of mistakes, such as missing pointer references. Rust was designed as a system language and learned many mistakes from older languages. In older languages, you can easily shoot yourself in the foot with a null pointer, and nothing in the language prevents you from compiling such mistakes. In contrast, in the Rust language, you cannot write a code that resulted in null pointer because it will be detected during compile time, and you must fix the implementation to make it compile.</p>
			<p>A lot of the Rust language design is borrowed from the functional programming paradigm, as well as from the object-oriented programming paradigm. For example, it has elements of a functional language such as closures and iterators. You can easily make a pure function and use the function as a parameter in another function; there are syntaxes to easily make closures and data types such as <code>Option</code> or <code>Result</code>.</p>
			<p>On the other hand, there <a id="_idIndexMarker002"/>are no class definitions, but you can easily define a data type, for example, a <strong class="bold">struct</strong>. After defining that data type, you can create a block to implement its methods.</p>
			<p>Even though there is no inheritance, you can easily group objects by using <code>MakeSound</code> trait. Then, you can determine what methods should be in that trait by writing the method signatures. If you define a data type, for example, a struct named <code>Cow</code>, you can tell the compiler that it implements a <code>MakeSound</code> trait. Because you say the <code>Cow</code> struct implements the <code>MakeSound</code> trait, you have to implement the methods defined in the trait for the <code>Cow</code> struct. Sounds like an object-oriented language, right?</p>
			<p>The Rust language went through several iterations before a stable version was released (Rust 1.0) on May 15, 2015. Some of the early language design was scrapped before releasing the stable release. At one point, Rust had a class feature but this was scrapped before the stable release because Rust design was changed to have data and behavior separation. You write data (for example, in the form of a <code>struct</code> or <code>enum</code> type), and then you write a behavior (for example, <code>impl</code>) separately. To categorize those <code>impl</code> in the same group, we can make a <strong class="bold">trait</strong>. So, all the functionality you would want from an object-oriented language can be had thanks to that design. Also, Rust used to <a id="_idIndexMarker004"/>have garbage collection, but it was then scrapped because another design pattern was used. When objects get out of scope, such as exiting a function, they are deallocated automatically. This type of automatic memory management made garbage collection unnecessary.</p>
			<p>After the first stable release, people added more functionalities to make Rust more ergonomic and usable. One of the biggest changes was <strong class="bold">async/await</strong>, which was released in version 1.39. This feature is very useful for developing applications that handle I/O, and web application programming handles a lot of I/O. Web applications have to handle database and network connections, reading from files, and so on. People agree that async/await was one of the most needed features to make the language suitable for web programming, because in async/await, the program doesn't need to make a new thread, but it's also not blocking like a conventional function.</p>
			<p>Another important feature is <code>const fn</code>, a function that will be evaluated at compile-time instead of runtime.</p>
			<p>In recent years, many large companies have started to build a talent pool of Rust developers, which highlights its significance in business.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Why use the Rust language?</h2>
			<p>So, why should we <a id="_idIndexMarker005"/>use the Rust language for web application development? Aren't existing established languages good enough for web development? Here are a few reasons why people would want to use the Rust language for creating web applications:</p>
			<ul>
				<li>Safety</li>
				<li>No garbage collection</li>
				<li>Speed</li>
				<li>Multithreading and asynchronous programming</li>
				<li>Statically typed</li>
			</ul>
			<h3>Safety</h3>
			<p>Although writing <a id="_idIndexMarker006"/>applications using a system programming language is advantageous because it's powerful (a programmer can access the fundamental building block of a program such as allocating computer memory to store important data and then deallocating that memory as soon as it is not in use), it's very easy to make mistakes.</p>
			<p>There's nothing in a traditional system language to prevent a program from storing data in memory, creating a pointer to that data, deallocating the data stored in memory, and trying to access the data again through that pointer. The data is already gone but the pointer is still pointing to that part of the memory.</p>
			<p>Seasoned programmers might easily spot such mistakes in a simple program. Some companies force their programmers to use a static analysis tool to check the code for such mistakes. But, as programming techniques become more sophisticated, the complexity of the application grows, and these kinds of bugs can still be found in many applications. High-profile bugs and hacks found in recent years, such as <em class="italic">Heartbleed</em>, can be prevented if we use a memory-safe language.</p>
			<p>Rust is a memory-safe language because it has certain rules regarding how a programmer can write their code. For example, when the code is compiled, it checks the lifetime of a variable, and the compiler will show an error if another variable still tries to access the already out-of-scope data. Ralf Jung, a postdoctoral researcher, already made the first formal verification in 2020 that the Rust language is indeed a safe language. Built-in data types, such as <code>Option</code> or <code>Result</code>, handle null-like behavior in a safe manner.</p>
			<h3>No garbage collection</h3>
			<p>Many programmers create and use different techniques for memory management due to safety <a id="_idIndexMarker007"/>problems. One of these techniques is garbage collection. The idea is simple: memory management is done automatically during runtime so that a programmer doesn't have to think about memory management. A programmer just needs to create a variable, and when the variable is not used anymore, the runtime will automatically remove it from memory.</p>
			<p>Garbage collection is an interesting and important part of computing. There are many techniques such as reference counting and tracing. Java, for example, even has several third-party garbage collectors besides the official garbage collector.</p>
			<p>The problem with this language design choice is that garbage collection usually takes significant computing resources. For example, a part of the memory is still not usable for a while because <a id="_idIndexMarker008"/>the garbage collector has not recycled that memory yet. Or, even worse, the garbage collector is not able to remove used memory from the heap, so it will accumulate, and most of the computer memory will become <a id="_idIndexMarker009"/>unusable, or what we usually call a <strong class="bold">memory leak</strong>. In the <strong class="bold">stop-the-world</strong> garbage collection mechanism, the whole program execution is paused to allow the garbage collector to recycle the memory, after which the program execution is resumed. As such, some people find it hard to develop real-time applications with this kind of language.</p>
			<p>Rust takes a different approach called <strong class="bold">resource acquisition is initialization</strong> (<strong class="bold">RAII</strong>), which means <a id="_idIndexMarker010"/>an object is deallocated automatically as soon as it's out of scope. For example, if you write a function, an object created in the function will be deallocated as soon as the function exits. But obviously, this makes Rust very different compared to programming languages that deallocate memory manually or programming languages with garbage collection.</p>
			<h3>Speed</h3>
			<p>If you are used to doing web development with an interpreted language or a language with garbage <a id="_idIndexMarker011"/>collection, you might say that we don't need to worry about computing performance as web development is I/O bound; in other words, the bottleneck is when the application accesses the database, disk, or another network, as they are slower than a CPU or memory.</p>
			<p>The adage might be primarily true but it all depends on application usage. If your application processes a lot of JSON, the processing is CPU-bound, which means it is limited by the speed of your CPU and not the speed of disk access or the speed of network connection. If you care about the security of your application, you might need to work with hashing and encryption, which are CPU-bound. If you are writing a backend application for an online streaming service, you want the application to work as optimally as possible. If you are writing an application serving millions of users, you want the application to be very optimized and return the response as fast as possible.</p>
			<p>The Rust language is a compiled language, so the compiler will convert the program into machine code, which a computer processor can execute. A compiled language usually runs faster <a id="_idIndexMarker012"/>than an interpreted language because, in an interpreted language, there is an overhead when the runtime binary interprets the program into native machine code. In modern interpreters, the speed gap is reduced by using modern techniques such as a <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>) compiler to speed up the program <a id="_idIndexMarker013"/>execution, but in dynamic languages such as Ruby, it's still slower than using a compiled language.</p>
			<h3>Multithreading and asynchronous programming</h3>
			<p>In traditional programming, synchronous programming means the application has to wait until <a id="_idIndexMarker014"/>CPU has processed a task. In a web application, the server waits until an HTTP request is processed and responded to; only then does it go on to handle another HTTP request. This is not a problem if the application just directly creates responses such as simple text. It becomes a problem when the web application has to take some time to do the processing; it has to wait for the database server to respond, it has to wait until the file is fully written on the server, and it has to wait until the API call to the third-party API service is done successfully.</p>
			<p>One way to overcome the problem of waiting is multithreading. A single process can create multiple threads that <a id="_idIndexMarker015"/>share some resources. The Rust language has been designed to make it easy to create safe multithreaded applications. It's designed with multiple containers such as <code>Arc</code> to make it easy to pass data between threads.</p>
			<p>The problem with multithreading is that spawning a thread means allocating significant CPU, memory, and <a id="_idIndexMarker016"/>OS resources, or what is colloquially known as being <em class="italic">expensive</em>. The solution is to use a different technique called <strong class="bold">asynchronous programming</strong>, where a single thread is reused by different tasks without waiting for the first task to finish. People can easily write an async program in Rust because it's been incorporated into the language since November 7, 2019.</p>
			<h3>Statically-typed</h3>
			<p>In programming <a id="_idIndexMarker017"/>languages, a dynamically-typed language is <a id="_idIndexMarker018"/>one where a variable type is checked at runtime, while a statically-typed language checks the data type at compile time.</p>
			<p>Dynamic typing means it's easier to write code, but it's also easier to make mistakes. Usually, a programmer has to write more unit tests in dynamically-typed languages to compensate for not checking the type at compile time. A dynamically-typed language is also considered more expensive because every time a function is called, the routine has to check the passed parameters. As a result, it's difficult to optimize a dynamically-typed language.</p>
			<p>Rust, on the other hand, is statically-typed, so it's very hard to make mistakes such as passing a string as a number. The compiler can optimize the resulting machine code and reduce programming bugs significantly before the application is released.</p>
			<p>Now that we have provided an overview of the Rust language and its strengths compared to other languages, let's learn how to install the Rust compiler toolchain, which will be used to compile Rust programs. We'll be using this toolchain throughout this book.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Installing the Rust compiler toolchain</h1>
			<p>Let's start by installing the Rust compiler toolchain. Rust has three official channels: <em class="italic">stable</em>, <em class="italic">beta</em>, and <em class="italic">nightly</em>. The Rust language uses Git as its version control system. People add new <a id="_idIndexMarker019"/>features and bug fixes to the master branch. Every night, the source code from the master branch is compiled and released to the nightly channel. After six weeks, the code will be branched off to the beta branch, compiled, and released to the beta channel. People will then run various tests in the beta release, most often in their CI (Continuous Integration) installation. If a bug is found, the fix will be committed to the master branch and then backported to the beta branch. Six weeks after the first beta branch-off, the stable release will be created from the beta branch.</p>
			<p>We will use the compiler from the stable channel throughout the book, but if you feel adventurous, you can use the other channels as well. There's no guarantee the program we're going to create will compile if you use another channel though because people add new features and there might be regression introduced in the new version.</p>
			<p>There are several ways to install the Rust toolchain in your system, such as bootstrapping and <a id="_idIndexMarker020"/>compiling it from scratch or using your OS package manager. But, the recommended way to install the Rust toolchain in your system is by using <code>rustup</code>.</p>
			<p>The definition <a id="_idIndexMarker021"/>on its website (<a href="https://rustup.rs">https://rustup.rs</a>) is very simple: "<em class="italic">rustup is an installer for the systems programming language Rust</em>." Now, let's try following these instructions to install <code>rustup</code>.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Installing rustup on the Linux OS or macOS</h2>
			<p>These instructions <a id="_idIndexMarker022"/>apply if you are using <a id="_idIndexMarker023"/>a Debian 10 Linux distribution, but <a id="_idIndexMarker024"/>if you are already using another Linux distribution, we're <a id="_idIndexMarker025"/>going to assume you are already proficient with the Linux OS and can adapt these instructions suitable to your Linux distribution:</p>
			<ol>
				<li>Open your terminal of choice.</li>
				<li>Make sure you have cURL installed by typing this command:<pre><strong class="bold">curl</strong></pre></li>
				<li>If cURL is not installed, let's install it:<pre><strong class="bold">apt install curl</strong></pre></li>
			</ol>
			<p>If you are using macOS, you will most likely already have cURL installed.</p>
			<ol>
				<li value="4">After that, follow the instructions on <a href="https://rustup.rs">https://rustup.rs</a>:<pre><strong class="bold">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</strong></pre></li>
				<li>It will then show a greeting and information, which you can customize; for now, we're just going to use the default setup:<pre><strong class="bold">...</strong>
<strong class="bold">1) Proceed with installation (default)</strong>
<strong class="bold">2) Customize installation</strong>
<strong class="bold">3) Cancel installation</strong>
<strong class="bold">&gt;</strong></pre></li>
				<li>Type <code>1</code> to use the default installation.</li>
				<li>After that, reload your terminal or type this in the current terminal:<pre><strong class="bold">source $HOME/.cargo/env</strong></pre></li>
				<li>You can confirm whether the installation was successful or not by typing <code>rustup</code> in the Terminal and you should see the usage instruction for rustup.</li>
				<li>Now, let's install <a id="_idIndexMarker026"/>the stable <a id="_idIndexMarker027"/>Rust toolchain. Type <a id="_idIndexMarker028"/>the following <a id="_idIndexMarker029"/>in the terminal:<pre><strong class="bold">rustup toolchain install stable</strong></pre></li>
				<li>After the toolchain has been installed into your OS, let's confirm whether we can run the Rust compiler. Type <code>rustc</code> in the terminal and you should see the instructions on how to use it.</li>
			</ol>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Installing a different toolchain and components</h2>
			<p>Right now, we <a id="_idIndexMarker030"/>have the stable toolchain installed, but there are two other default channels that we can install: <em class="italic">nightly</em> and <em class="italic">beta</em>.</p>
			<p>Sometimes, you might want to use a different toolchain for various reasons. Maybe you want to try a new feature, or maybe you want to test regression in your application against an upcoming version of Rust. You can simply install it by using <code>rustup</code>:</p>
			<pre>rustup toolchain install nightly</pre>
			<p>Each toolchain has components, some of which are required by the toolchain, such as <code>rustc</code>, which is the Rust compiler. Other components are not installed by default, for example, <code>clippy</code>, which provides more checks not provided by the <code>rustc</code> compiler and gives code style suggestions as well. To install it is also very easy; you can use <code>rustup component add &lt;component&gt;</code> as shown in this example:</p>
			<pre>rustup default stable
rustup component add clippy</pre>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Updating the toolchain, rustup, and components</h2>
			<p>The Rust toolchain has <a id="_idIndexMarker031"/>a regular release schedule of around <a id="_idIndexMarker032"/>every three months (six weeks plus six weeks), but <a id="_idIndexMarker033"/>sometimes there's an emergency release for a major bug fix or a fix for a security problem. As a result, you sometimes need to update your toolchain. Updating is very easy. This command will also update the components installed in the toolchain:</p>
			<pre>rustup update</pre>
			<p>Besides the toolchain, <code>rustup</code> itself might also be updated. You can update it by typing the following:</p>
			<pre>rustup self update</pre>
			<p>Now that we have the Rust compiler toolchain installed in our system, let's write our first Rust program!</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Writing Hello World!</h1>
			<p>In this section, we are going to write a very basic program, <em class="italic">Hello World!</em>. After we successfully compile <a id="_idIndexMarker034"/>that, we are going to write a more complex program to see the basic capabilities of the Rust language. Let's do it by following these instructions:</p>
			<ol>
				<li value="1">Let's create a new folder, for example, <code>01HelloWorld</code>.</li>
				<li>Create a new file inside the folder and give it the name <code>main.rs</code>.</li>
				<li>Let's write our first code in Rust:<pre>fn main() { 
    println!("Hello World!");
}</pre></li>
				<li>After that, save your file, and in the same folder, open your terminal, and compile the code using the <code>rustc</code> command:<pre><strong class="bold">rustc main.rs</strong></pre></li>
				<li>You can see <a id="_idIndexMarker035"/>there's a file inside the folder called <code>main</code>; run that file from your terminal:<pre><strong class="bold">./main</strong></pre></li>
				<li>Congratulations! You just wrote your first <code>Hello World</code> program in the Rust language. </li>
			</ol>
			<p>Next, we're going to step up our Rust language game; we will showcase basic Rust applications with control flow, modules, and other functionalities.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Writing a more complex program</h2>
			<p>Of course, after making the <code>Hello World</code> program, we should try to write a more complex <a id="_idIndexMarker036"/>program to see what we can do with the language. We want to make a program that captures what the user inputted, encrypts it with the selected algorithm, and returns the output to the terminal:</p>
			<ol>
				<li value="1">Let's make a new folder, for example, <code>02ComplexProgram</code>. After that, create the <code>main.rs</code> file again and add the <code>main</code> function again:<pre>fn main() {}</pre></li>
				<li>Then, use the <code>std::io</code> module and write the part of the program to tell the user to input the string they want to encrypt:<pre>use std::io;
fn main() {
    println!("Input the string you want to encrypt:");
    let mut user_input = String::new();
    io::stdin()
        .read_line(&amp;mut user_input)
        .expect("Cannot read input");
    println!("Your encrypted string: {}", user_input);
}</pre></li>
			</ol>
			<p>Let's explore what we have written line by line:</p>
			<ol>
				<li value="1">The first line, <code>use std::io;</code>, is telling our program that we are going to use the <code>std::io</code> module in our program. <code>std</code> should be included by default on a program unless we specifically say not to use it.</li>
				<li>The <code>let...</code> line is a variable declaration. When we define a variable in Rust, the variable is immutable by default, so we must add the <code>mut</code> keyword to make it mutable. <code>user_input</code> is the variable name, and the right hand of this <a id="_idIndexMarker037"/>statement is initializing a new empty <code>String</code> instance. Notice how we initialize the variable directly. Rust allows the separation of declaration and initialization, but that form is not idiomatic, as a programmer might try to use an uninitialized variable and Rust disallows the use of uninitialized variables. As a result, the code will not compile.</li>
				<li>The next piece of code, that is, the <code>stdin()</code> function, initializes the <code>std::io::Stdin</code> struct. It reads the input from the terminal and puts it in the <code>user_input</code> variable. Notice that the signature for <code>read_line() </code>accepts <code>&amp;mut String</code>. We have to explicitly tell the compiler we are passing a mutable reference because of the Rust borrow checker, which we will discuss later in <a href="B16825_09_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 9</em></a><em class="italic">,</em> <em class="italic">Displaying User's Post</em>. The <code>read_line()</code> output is <code>std::result::Result</code>, an enum with two variants, <code>Ok(T)</code> and <code>Err(E)</code>. One of the <code>Result</code> methods is <code>expect()</code>, which returns a generic type <code>T</code>, or if it's an <code>Err</code> variant, then it will cause panic with a generic error <code>E</code> combined with the passed message.</li>
				<li>Two Rust enums (<code>std::result::Result</code> and <code>std::option::Option</code>) are very ubiquitous and important in the Rust language, so by default, we can use them in the program without specifying <code>use</code>.</li>
			</ol>
			<p>Next, we want to be able to encrypt the input, but right now, we don't know what encryption <a id="_idIndexMarker038"/>we want to use. The first thing we want to do is make a <strong class="bold">trait</strong>, a particular code in the Rust language that tells the compiler what functionality a type can have:</p>
			<ol>
				<li value="1">There are two ways to create a module: create <code>module_name.rs</code> or create a folder with <code>module_name</code> and add a <code>mod.rs</code> file inside that folder. Let's create a folder named <code>encryptor</code> and create a new file named <code>mod.rs</code>. Since we want to add a type and implementation later, let's use the second way. Let's write this in <code>mod.rs</code>:<pre>pub trait Encryptable {
    fn encrypt(&amp;self) -&gt; String;
}</pre></li>
				<li>By default, a type or trait is private, but we want to use it in <code>main.rs</code> and implement the encryptor on a different file, so we should denote the trait as public by adding the <code>pub</code> keyword.</li>
				<li>That trait has one function, <code>encrypt()</code>, which has self-reference as a parameter and returns <code>String</code>.</li>
				<li>Now, we should define this new module in <code>main.rs</code>. Put this line before the <code>fn</code> main block:<pre>pub mod encryptor;</pre></li>
				<li>Then, let's make a simple type that implements the <code>Encryptable</code> trait. Remember the Caesar cipher, where the cipher substitutes a letter with another letter? Let's implement the simplest one called <code>ROT13</code>, where it converts <code>'a'</code> to <code>'n'</code> and <code>'n'</code> to <code>'a'</code>, <code>'b'</code> to <code>'o'</code> and <code>'o'</code> to <code>'b'</code>, and so on. Write the following in the <code>mod.rs</code> file:<pre>pub mod rot13;</pre></li>
				<li>Let's make another file named <code>rot13.rs</code> inside the <code>encryptor</code> folder.</li>
				<li>We want to define a simple struct that only has one piece of data, a string, and tell the compiler that the struct is implementing the <code>Encryptable</code> trait. Put this code inside the <code>rot13.rs</code> file:<pre>pub struct Rot13(pub String);
impl super::Encryptable for Rot13 {}</pre></li>
			</ol>
			<p>You might <a id="_idIndexMarker039"/>notice we put <code>pub</code> in everything from the module declaration, to the trait declaration, struct declaration, and field declaration.</p>
			<ol>
				<li value="8">Next, let's try compiling our program:<pre><strong class="bold">&gt; rustc main.rs </strong>
<strong class="bold">error[E0046]: not all trait items implemented, missing: `encrypt`</strong>
<strong class="bold"> --&gt; encryptor/rot13.rs:3:1</strong>
<strong class="bold">  |</strong>
<strong class="bold">3 | impl super::Encryptable for Rot13 {}</strong>
<strong class="bold">  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing </strong>
<strong class="bold">  `encrypt` in implementation</strong>
<strong class="bold">  | </strong>
<strong class="bold"> ::: encryptor/mod.rs:6:5</strong>
<strong class="bold">  |</strong>
<strong class="bold">6 |     fn encrypt(&amp;self) -&gt; String;</strong>
<strong class="bold">  |     ----------------------------------------------</strong>
<strong class="bold">  ------ `encrypt` from trait</strong>
<strong class="bold">error: aborting due to previous error</strong>
<strong class="bold">For more information about this error, try `rustc --explain E0046`.</strong></pre></li>
			</ol>
			<p>What is going on here? Clearly, the compiler found an error in our code. One of Rust's <a id="_idIndexMarker040"/>strengths is helpful compiler messages. You can see the line where the error occurs, the reason why our code is wrong, and sometimes, it even suggests the fix for our code. We know that we have to implement the <code>super::Encryptable</code> trait for the <code>Rot13</code> type.</p>
			<p>If you want to see more information, run the command shown in the preceding error, <code>rustc --explain E0046</code>, and the compiler will show more information about that particular error.</p>
			<ol>
				<li value="9">We now can continue implementing our <code>Rot13</code> encryption. First, let's put the signature from the trait into our implementation:<pre>impl super::Encryptable for Rot13 {
    fn encrypt(&amp;self) -&gt; String {
    }
}</pre></li>
			</ol>
			<p>The strategy for this encryption is to iterate each character in the string and add 13 to the char value if it has a character before <code>'n'</code> or <code>'N'</code>, and remove 13 if it has <code>'n'</code> or <code>'N'</code> or characters after it. The Rust language handles Unicode strings by default, so the program should have a restriction to operate only on the Latin alphabet.</p>
			<ol>
				<li value="10">On our first iteration, we want to allocate a new string, get the original <code>String</code> length, start from the zeroeth index, apply a transformation, push to a new string, and repeat until the end:<pre>fn encrypt(&amp;self) -&gt; String {
    let mut new_string = String::new();
    let len = self.0.len();
    for i in 0..len {
        if (self.0[i] &gt;= 'a' &amp;&amp; self.0[i] &lt; 'n') || 
        (self.0[i] &gt;= 'A' &amp;&amp; self.0[i] &lt; 'N') {
            new_string.push((self.0[i] as u8 + 13) as 
            char);
        } else if (self.0[i] &gt;= 'n' &amp;&amp; self.0[i] &lt; 
        'z') || (self.0[i] &gt;= 'N' &amp;&amp; self.0[i] &lt; 'Z') 
        {
            new_string.push((self.0[i] as u8 - 13) as 
            char);
        } else {
            new_string.push(self.0[i]);
        }
    } 
    new_string
}</pre></li>
				<li>Let's try <a id="_idIndexMarker041"/>compiling that program. You will quickly find it is not working, with all errors being <code>`String` cannot be indexed by `usize`</code>. Remember that Rust handles Unicode by default? Indexing a string will create all sorts of complications, as Unicode characters have different sizes: some are 1 byte but others can be 2, 3, or 4 bytes. With regard to index, what exactly are we saying? Is index means the byte position in a <code>String</code>, grapheme, or Unicode scalar values?</li>
			</ol>
			<p>In the Rust language, we have primitive types such as <code>u8</code>, <code>char</code>, <code>fn</code>, <code>str</code>, and many more. In addition to those primitive types, Rust also defines a lot of modules in the standard library, such as <code>string</code>, <code>io</code>, <code>os</code>, <code>fmt</code>, and <code>thread</code>. These modules contain many building blocks for programming. For example, the <code>std::string::String</code> struct deals with <code>String</code>. Important programming concepts such as comparison and iteration are also defined in these modules, for <a id="_idIndexMarker042"/>example, <code>std::cmp::Eq</code> to compare an instance of a type with another instance. The Rust language also has <code>std::iter::Iterator</code> to make a type iterable. Fortunately, for <code>String</code>, we already have a method to do iteration.</p>
			<ol>
				<li value="12">Let's modify our code a little bit:<pre>fn encrypt(&amp;self) -&gt; String {
    let mut new_string = String::new();
    for ch in self.0.chars() {
        if (ch &gt;= 'a' &amp;&amp; ch &lt; 'n') || (ch &gt;= 'A' &amp;&amp;
        ch &lt; 'N') {
            new_string.push((ch as u8 + 13) as char);
        } else if (ch &gt;= 'n' &amp;&amp; ch &lt; 'z') || (ch &gt;= 
        'N' &amp;&amp; ch &lt; 'Z') {
            new_string.push((ch as u8 - 13) as char);
        } else {
            new_string.push(ch);
        }
    }
    new_string
}</pre></li>
				<li>There are two ways of returning; the first one is using the <code>return</code> keyword such as <code>return new_string;</code>, or we can write just the variable without a semicolon in the last line of a function. You will see that it's more common to use the second form.</li>
				<li>The preceding code works just fine, but we can make it more idiomatic. First, let's process the iterator without the <code>for</code> loop. Let's remove the new string initialization and use the <code>map()</code> method instead. Any type implementing <code>std::iter::Iterator</code> will have a <code>map()</code> method that accepts a closure as the <a id="_idIndexMarker043"/>parameter and returns <code>std::iter::Map</code>. We can then use the <code>collect()</code> method to collect the result of the closure into its own <code>String</code>:<pre>fn encrypt(&amp;self) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
    self.0
        .chars()
        .map(|ch| {
            if (ch &gt;= 'a' &amp;&amp; ch &lt; 'n') || (ch &gt;= 'A' 
            &amp;&amp; ch &lt; 'N') {
                (ch as u8 + 13) as char
            } else if (ch &gt;= 'n' &amp;&amp; ch &lt; 'z') || (
            ch &gt;= 'N' &amp;&amp; ch &lt; 'Z') {
                (ch as u8 - 13) as char
            } else {
                ch
            }
        })
        .collect()
}</pre></li>
			</ol>
			<p>The <code>map()</code> method accepts a closure in the form of <code>|x|...</code>. We then use the captured individual items that we get from <code>chars()</code> and process them.</p>
			<p>If you look at the closure, you'll see we don't use the <code>return</code> keyword either. If we don't put the semicolon in a branch and it's the last item, it will be considered as a <code>return</code> value.</p>
			<p>Using the <code>if</code> block is <a id="_idIndexMarker044"/>good, but we can also make it more idiomatic. One of the Rust language's strengths is the powerful <code>match</code> control flow.</p>
			<ol>
				<li value="15">Let's change the code again:<pre>fn encrypt(&amp;self) -&gt; String {
    self.0
        .chars()
        .map(|ch| match ch {
            'a'..='m' | 'A'..='M' =&gt; (ch as u8 + 13) 
            as char,
            'n'..='z' | 'N'..='Z' =&gt; (ch as u8 - 13) 
            as char,
            _ =&gt; ch,
        })
        .collect()
}</pre></li>
			</ol>
			<p>That looks a lot cleaner. The pipe (<code>|</code>) operator is a separator to match items in an arm. The Rust matcher is exhaustive, which means that the compiler will check whether all possible values of the matcher are included in the matcher or not. In this case, it means all characters in Unicode. Try removing the last arm and compiling it to see what happens if you don't include an item in a collection.</p>
			<p>You can define a <a id="_idIndexMarker045"/>range by using <code>..</code> or <code>..=</code>. The former means we are excluding the last element, and the latter means we are including the last element.</p>
			<ol>
				<li value="16">Now that we have implemented our simple encryptor, let's use it in our main application:<pre>fn main() {
    ...
    io::stdin()
    .read_line(&amp;mut user_input)
    .expect("Cannot read input");
    println!(
        "Your encrypted string: {}",
        encryptor::rot13::Rot13(user_input).encrypt()
    );
}</pre></li>
			</ol>
			<p>Right now, when we try to compile it, the compiler will show an error. Basically, the compiler is saying you cannot use a trait function if the trait is not in the scope, and the help from the compiler is showing what we need to do.</p>
			<ol>
				<li value="17">Put the following line above the <code>main()</code> function and the compiler should produce a binary without any error:<pre>use encryptor::Encryptable;</pre></li>
				<li>Let's try running the executable:<pre><strong class="bold">&gt; ./main</strong>
<strong class="bold">Input the string you want to encrypt:</strong>
<strong class="bold">asdf123</strong>
<strong class="bold">Your encrypted string: nfqs123</strong>
<strong class="bold">&gt; ./main</strong>
<strong class="bold">Input the string you want to encrypt:</strong>
<strong class="bold">nfqs123</strong>
<strong class="bold">Your encrypted string: asdf123</strong></pre></li>
			</ol>
			<p>We have finished <a id="_idIndexMarker046"/>our program and we improved it with real-world encryption. In the next section, we're going to learn how to search for and use third-party libraries and incorporate them into our application.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Packages and Cargo</h1>
			<p>Now that we know how to create a simple program in Rust, let's explore <strong class="bold">Cargo</strong>, the Rust package <a id="_idIndexMarker047"/>manager. Cargo is a <strong class="bold">command-line application</strong> that manages your <a id="_idIndexMarker048"/>application dependencies and compiles your code.</p>
			<p>Rust has a <a id="_idIndexMarker049"/>community package registry at <a href="https://crates.io">https://crates.io</a>. You can use that website to search for a library that you can use in your application. Don't forget to check the license of the library or application that you want to use. If you register on that website, you can use Cargo to publicly distribute your library or binary.</p>
			<p>How do we install Cargo into our system? The good news is Cargo is already installed if you install the Rust toolchain in the stable channel using <code>rustup</code>.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Cargo package layout</h2>
			<p>Let's try using Cargo in our <a id="_idIndexMarker050"/>application. First, let's copy the application that we wrote earlier:</p>
			<pre>cp -r 02ComplexProgram  03Packages
cd 03Packages
cargo init . --name our_package</pre>
			<p>Since we already have an existing application, we can initialize our existing application with <code>cargo init</code>. Notice we add the <code>--name</code> option because we are prefixing our folder name with a number, and a Rust package name cannot start with a number.</p>
			<p>If we are creating a new application, we can use the <code>cargo new package_name</code> command. To create a library-only package instead of a binary package, you can pass the <code>--lib</code> option to <code>cargo new</code>.</p>
			<p>You will see two new files, <code>Cargo.toml</code> and <code>Cargo.lock</code>, inside the folder. The <code>.toml</code> file is a file format commonly used as a configuration file. The <code>lock</code> file is generated automatically by Cargo, and we don't usually change the content manually. It's also common to add <code>Cargo.lock</code> to your source code versioning application ignore list, such as <code>.gitignore</code>, for example.</p>
			<p>Let's check the content of the <code>Cargo.toml</code> file:</p>
			<pre class="source-code">[package]</pre>
			<pre class="source-code">name = "our_package"</pre>
			<pre class="source-code">version = "0.1.0"</pre>
			<pre class="source-code">edition = "2021"</pre>
			<pre class="source-code"># See more keys and their definitions at</pre>
			<pre class="source-code">https://doc.rust-lang.org/cargo/reference/manifest.html</pre>
			<pre class="source-code">[dependencies]</pre>
			<pre class="source-code">[[bin]]</pre>
			<pre class="source-code">name = "our_package"</pre>
			<pre class="source-code">path = "main.rs"</pre>
			<p>As you can see, we can define basic things for our application such as <code>name</code> and <code>version</code>. We can also add important information such as authors, homepage, repository, and much more. We can also add dependencies that we want to use in the Cargo application.</p>
			<p>One thing that stands out is the edition configuration. The Rust edition is an optional marker to group <a id="_idIndexMarker051"/>various Rust language releases that have the same compatibility. When Rust 1.0 was released, the compiler did not have the capability to know the <code>async</code> and <code>await</code> keywords. After <code>async</code> and <code>await</code> were added, it created all sorts of problems with older compilers. The solution to that problem was to introduce Rust editions. Three editions have been defined: 2015, 2018, and 2021.</p>
			<p>Right now, the Rust compiler can compile our package perfectly fine, but it is not very idiomatic because a Cargo project has conventions on file and folder names and structures. Let's change the files and directory structure a little bit:</p>
			<ol>
				<li value="1">A package is expected to reside in the <code>src</code> directory. Let's change the <code>Cargo.toml</code> file <code>[[bin]]</code> path from <code>"main.rs"</code> to <code>"src/main.rs"</code>.</li>
				<li>Create the <code>src</code> directory inside our application folder. Then, move the <code>main.rs</code> file and the <code>encryptor</code> folder to the <code>src</code> folder.</li>
				<li>Add these lines to <code>Cargo.toml</code> after <code>[[bin]]</code>:<pre>[lib]
name = "our_package"
path = "src/lib.rs"</pre></li>
				<li>Let's create the <code>src/lib.rs</code> file and move this line from <code>src/main.rs</code> to <code>src/lib.rs</code>:<pre>pub mod encryptor;</pre></li>
				<li>We can then simplify using both the <code>rot13</code> and <code>Encryptable</code> modules in our <code>main.rs</code> file:<pre>use our_package::encryptor::{rot13, Encryptable};
use std::io;
fn main() {
    ...
    println!(
        "Your encrypted string: {}",
        rot13::Rot13(user_input).encrypt()
    );
}</pre></li>
				<li>We can check whether <a id="_idIndexMarker052"/>there's an error that prevents the code from being compiled by typing <code>cargo check</code> in the command line. It should produce something like this:<pre><strong class="bold">&gt; cargo check</strong>
<strong class="bold">    Checking our_package v0.1.0 </strong>
    <strong class="bold">(/Users/karuna/Chapter01/03Packages)</strong>
<strong class="bold">    Finished dev [unoptimized + debuginfo] target(s) </strong>
    <strong class="bold">in 1.01s</strong></pre></li>
				<li>After that, we can build the binary using the <code>cargo build</code> command. Since we didn't specify any option in our command, the default binary should be unoptimized and contain debugging symbols. The default location for the generated binary is in the <code>target</code> folder at the root of the workspace:<pre><strong class="bold">$ cargo build</strong>
<strong class="bold">   Compiling our_package v0.1.0 </strong>
   <strong class="bold">(/Users/karuna/Chapter01/03Packages)</strong>
<strong class="bold">    Finished dev [unoptimized + debuginfo] target(s) </strong>
    <strong class="bold">in 5.09s</strong></pre></li>
			</ol>
			<p>You can then run the binary in the <code>target</code> folder as follows:</p>
			<pre><strong class="bold">./target/debug/our_package</strong></pre>
			<p><code>debug</code> is enabled <a id="_idIndexMarker053"/>by the default dev profile, and <code>our_package</code> is the name that we specify in <code>Cargo.toml</code>.</p>
			<p>If you want to create a release binary, you can specify the <code>--release</code> option, <code>cargo build --release</code>. You can find the release binary in <code>./target/release/our_package</code>. </p>
			<p>You can also type <code>cargo run</code>, which will compile and run the application for you.</p>
			<p>Now that we have arranged our application structure, let's add real-world encryption to our application by using a third-party crate.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Using third-party crates</h2>
			<p>Before we <a id="_idIndexMarker054"/>implement another encryptor using a third-party module, let's modify our application a little bit. Copy the previous <code>03Packages</code> folder to the new folder, <code>04Crates</code>, and use the folder for the following steps: </p>
			<ol>
				<li value="1">We will rename our Encryptor trait as a Cipher trait and modify the functions. The reason is that we only need to think about the output of the type, not the encrypt process itself:<ul><li>Let's change the content of <code>src/lib.rs</code> to <code>pub mod cipher;</code>.</li><li>After that, rename the <code>encryptor</code> folder as <code>cipher</code>.</li><li>Then, modify the Encryptable trait into the following:<pre>pub trait Cipher {
    fn original_string(&amp;self) -&gt; String;
    fn encrypted_string(&amp;self) -&gt; String;
}</pre></li></ul></li>
			</ol>
			<p>The reality is we only need functions to show the original string and the encrypted <a id="_idIndexMarker055"/>string. We don't need to expose the encryption in the type itself.</p>
			<ol>
				<li value="2">After that, let's also change <code>src/cipher/rot13.rs</code> to use the renamed trait:<pre>impl super::Cipher for Rot13 {
    fn original_string(&amp;self) -&gt; String {
        String::from(&amp;self.0)
    }
    fn encrypted_string(&amp;self) -&gt; String {
        self.0
            .chars()
            .map(|ch| match ch {
                'a'..='m' | 'A'..='M' =&gt; (ch as u8 + 
                13) as char,
                'n'..='z' | 'N'..='Z' =&gt; (ch as u8 – 
                13) as char,
                _ =&gt; ch,
            })
            .collect()
    }
}</pre></li>
				<li>Let's also modify <code>main.rs</code> to use the new trait and function:<pre>use our_package::cipher::{rot13, Cipher};
…
fn main() {
    …
    println!(
        "Your encrypted string: {}",
        rot13::Rot13(user_input).encrypted_string()
    );
}</pre></li>
			</ol>
			<p>The next step is to determine what encryption and library we want to use for our new type. We can go to <a href="https://crates.io">https://crates.io</a> and search for an available crate. After searching for a real-world encryption algorithm on the website, we found <a href="https://crates.io/crates/rsa">https://crates.io/crates/rsa</a>. We found that the RSA algorithm is a secure algorithm, the crate has <a id="_idIndexMarker056"/>good documentation and has been <a id="_idIndexMarker057"/>audited by security researchers, the license is compatible with what we need, and there's a huge number of downloads. Aside from checking the source code of this library, all indications show that this is a good crate to use. Luckily, there's an install section on the right side of that page. Besides the <code>rsa</code> crate, we are also going to use the <code>rand</code> crate, since the RSA algorithm requires a random number generator. Since the generated encryption is in bytes, we must encode it somehow to <code>string</code>. One of the common ways is to use <code>base64</code>.</p>
			<ol>
				<li value="4">Add these lines in our <code>Cargo.toml</code> file, under the <code>[dependencies]</code> section:<pre>rsa = "0.5.0"
rand = "0.8.4"
base64 = "0.13.0"</pre></li>
				<li>The next step should be adding a new module and typing using the <code>rsa</code> crate. But, for this type, we want to modify it a little bit. First, we want to create an <strong class="bold">associated function</strong>, which might be called a constructor in other languages. We want to then encrypt the <a id="_idIndexMarker058"/>input string in this function and store the encrypted string in a field. There's a saying that all data not in processing should be encrypted by default, but the fact is that we as programmers rarely do this.</li>
			</ol>
			<p>Since RSA encryption is dealing with byte manipulation, there's a possibility of errors, so the return <a id="_idIndexMarker059"/>value of the associated function should be wrapped in the <code>Result</code> type. There's no compiler rule, but if a function cannot fail, the return should be straightforward. Regardless of whether or not a function can produce a result, the <code>return</code> value should be <code>Option</code>, but if a function can produce an error, it's better to use <code>Result</code>.</p>
			<p>The <code>encrypted_string()</code> method should return the stored encrypted string, and the <code>original_string()</code> method should decrypt the stored string and return the plain text.</p>
			<p>In <code>src/cipher/mod.rs</code>, change the code to the following:</p>
			<pre>pub trait Cipher {
    fn original_string(&amp;self) -&gt; Result&lt;String, 
    Box&lt;dyn Error&gt;&gt;;
    fn encrypted_string(&amp;self) -&gt; Result&lt;String, 
    Box&lt;dyn Error&gt;&gt;;
}</pre>
			<ol>
				<li value="6">Since we changed the definition of the trait, we have to change the code in <code>src/cipher/rot13.rs</code> as well. Change the code to the following:<pre><strong class="bold">use std::error::Error;</strong>
pub struct Rot13(pub String);
impl super::<strong class="bold">Cipher</strong> for Rot13 {
    <strong class="bold">fn original_string(&amp;self) -&gt; Result&lt;String, </strong>
    <strong class="bold">Box&lt;dyn Error&gt;&gt; {</strong>
<strong class="bold">        Ok(String::from(&amp;self.0))</strong>
<strong class="bold">    }</strong>
<strong class="bold">    fn encrypted_string(&amp;self) -&gt; Result&lt;String, </strong>
    <strong class="bold">Box&lt;dyn Error&gt;&gt; {</strong>
<strong class="bold">        Ok(self</strong>
<strong class="bold">            .0</strong>
<strong class="bold">            ...</strong>
<strong class="bold">            .collect())</strong>
<strong class="bold">    }</strong>
}</pre></li>
				<li>Let's add the following line in the <code>src/cipher/mod.rs</code> file:<pre>pub mod rsa;</pre></li>
				<li>After that, create <code>rsa.rs</code> inside the <code>cipher</code> folder and create the <code>Rsa</code> struct inside it. Notice that <a id="_idIndexMarker060"/>we use <code>Rsa</code> instead of <code>RSA</code> as the type name. The convention is to use <code>CamelCase</code> for type:<pre>use std::error::Error;
pub struct Rsa {
    data: String,
}
impl Rsa {
    pub fn new(input: String) -&gt; Result&lt;Self, Box&lt;
    dyn Error&gt;&gt; {
        unimplemented!();
    }
}
impl super::Cipher for Rsa {
    fn original_string(&amp;self) -&gt; Result&lt;String, ()&gt; {
       unimplemented!();
    }
    fn encrypted_string(&amp;self) -&gt; Result&lt;String, ()&gt; {
        Ok(String::from(&amp;self.data))
    }
}</pre></li>
			</ol>
			<p>There are a couple <a id="_idIndexMarker061"/>of things we can observe. The first one is the <code>data</code> field does not have the <code>pub</code> keyword since we want to make it private. You can see that we have two <code>impl</code> blocks: one is for defining the methods of the <code>Rsa</code> type itself, and the other is for implementing the <code>Cipher</code> trait.</p>
			<p>Also, the <code>new()</code> function does not have <code>self</code>, <code>mut self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first parameter. Consider it as a static method in other languages. This method is returning <code>Result</code>, which is either <code>Ok(Self)</code> or <code>Box&lt;dyn Error&gt;</code>. The <code>Self</code> instance is the instance of the <code>Rsa</code> struct, but we'll discuss <code>Box&lt;dyn Error&gt;</code> later when we talk about error handling in <a href="B16825_07_ePub.xhtml#_idTextAnchor091"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling Errors in Rust and Rocket</em>. Right now, we haven't implemented this method, hence <a id="_idIndexMarker062"/>the usage of the <code>unimplemented!()</code> macro. Macros in Rust look like a function but with an extra bang (!).</p>
			<ol>
				<li value="9">Now, let's implement the associated function. Modify <code>src/cipher/rsa.rs</code>:<pre>use rand::rngs::OsRng;
use rsa::{PaddingScheme, PublicKey, RsaPrivateKey};
use std::error::Error;
const KEY_SIZE: usize = 2048;
pub struct Rsa {
    data: String,
    private_key: RsaPrivateKey,
}
impl Rsa {
     pub fn new(input: String) -&gt; Result&lt;Self, Box&lt;
    dyn Error&gt;&gt; {
        let mut rng = OsRng;
        let private_key = RsaPrivateKey::new(&amp;mut rng, 
        KEY_SIZE)?;
        let public_key = private_key.to_public_key();
        let input_bytes = input.as_bytes();
        let encrypted_data =
            public_key.encrypt(&amp;mut rng, PaddingScheme
            ::new_pkcs1v15_encrypt(), input_bytes)?;
        let encoded_data = 
        base64::encode(encrypted_data);
        Ok(Self {
            data: encoded_data,
            private_key,
        })
    }
}</pre></li>
			</ol>
			<p>The first thing we do is declare the various types we are going to use. After that, we define a constant to denote what size key we are going to use.</p>
			<p>If you understand the RSA algorithm, you already know that it's an asymmetric algorithm, meaning we have two keys: a public key and a private key. We use the public key <a id="_idIndexMarker063"/>to encrypt data and use the private key to decrypt the data. We can generate and give the public key to the other party, but we don't want to give the private key to the other party. That means we must store the private key inside the struct as well.</p>
			<p>The <code>new()</code> implementation is pretty straightforward. The first thing we do is declare a random number generator, <code>rng</code>. We then generate the RSA private key. But, pay attention to the question mark operator (<code>?</code>) on the initialization of the private key. If a function returns <code>Result</code>, we can quickly return the error generated by calling any method or function inside it by using (<code>?</code>) after that function.</p>
			<p>Then, we generate the RSA public key from a private key, encode the input string as bytes, and encrypt the data. Since encrypting the data might have resulted in an error, we use the question mark operator again. We then encode the encrypted bytes as a <code>base64</code> string and initialize <code>Self</code>, which means the <code>Rsa</code> struct itself.</p>
			<ol>
				<li value="10">Now, let's implement the <code>original_string()</code> method. We should do the opposite <a id="_idIndexMarker064"/>of what we do when we create the struct:<pre>fn original_string(&amp;self) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
    let decoded_data = base64::decode(&amp;self.data)?;
    let decrypted_data = self
        .private_key
        .decrypt(PaddingScheme::
        new_pkcs1v15_encrypt(), &amp;decoded_data)?;
    Ok(String::from_utf8(decrypted_data)?)
}</pre></li>
			</ol>
			<p>First, we decode the <code>base64</code> encoded string in the <code>data</code> field. Then, we decrypt the decoded bytes and convert them back to a string.</p>
			<ol>
				<li value="11">Now that we have finished our <code>Rsa</code> type, let's use it in our <code>main.rs</code> file:<pre>fn main() {
    ...
    println!(
        "Your encrypted string: {}",
        rot13::Rot13(user_input).encrypted_
        string().unwrap()
    );
    println!("Input the string you want to encrypt:");
    let mut user_input = String::new();
    io::stdin()
        .read_line(&amp;mut user_input)
        .expect("Cannot read input");
    let encrypted_input = rsa::Rsa::new(
    user_input).expect("");
    let encrypted_string = encrypted_input.encrypted_
    string().expect("");
    println!("Your encrypted string: {}", 
    encrypted_string);
    let decrypted_string = encrypted_input
    .original_string().expect("");
    println!("Your original string: {}", 
    decrypted_string);
}</pre></li>
			</ol>
			<p>Some of you <a id="_idIndexMarker065"/>might wonder why we redeclared the <code>user_input</code> variable. The simple explanation is that Rust already moved the resource to the new <code>Rot13</code> type, and Rust does not allow the reuse of the moved value. You can try commenting on the second variable declaration and <a id="_idIndexMarker066"/>compile the application to see the explanation. We will discuss the Rust borrow checker and moving in more detail in <a href="B16825_09_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 9</em></a><em class="italic">, Displaying Users' Post</em>.</p>
			<p>Now, try running the program by typing <code>cargo run</code>:</p>
			<pre><strong class="bold">$ cargo run</strong>
<strong class="bold">   Compiling cfg-if v1.0.0</strong>
<strong class="bold">   Compiling subtle v2.4.1</strong>
<strong class="bold">   Compiling const-oid v0.6.0</strong>
<strong class="bold">   Compiling ppv-lite86 v0.2.10</strong>
<strong class="bold">   ...</strong>
<strong class="bold">   Compiling our_package v0.1.0 </strong>
   <strong class="bold">(/Users/karuna//Chapter01/04Crates)</strong>
<strong class="bold">    Finished dev [unoptimized + debuginfo] target(s) </strong>
    <strong class="bold">in 3.17s</strong>
<strong class="bold">     Running `target/debug/our_package`</strong>
<strong class="bold">Input the string you want to encrypt:</strong>
<strong class="bold">first</strong>
<strong class="bold">Your encrypted string: svefg</strong>
<strong class="bold">Input the string you want to encrypt:</strong>
<strong class="bold">second</strong>
<strong class="bold">Your encrypted string: lhhb9RvG9zI75U2VC3FxvfUujw0cVqqZFgPXhNixQTF7RoVBEJh2inn7sEefDB7eNlQcf09lD2nULfgc2mK55ZE+UUcYzbMDu45oTaPiDPog4L6FRVpbQR27bkOj9Bq1KS+QAvRtxtTbTa1L5/OigZbqBc2QOm2yHLCimMPeZKhLBtK2whhtzIDM8l5AYTBg+rA688ZfB7ZI4FSRm4/h22kNzSPo1DECI04ZBprAq4hWHxEKRwtn5TkRLhClGFLSYKkY7Ajjr3EOf4QfkUvFFhZ0qRDndPI5c9RecavofVLxECrYfv5ygYRmW3B1cJn4vcBhVKfQF0JQ+vs+FuTUpw==</strong>
<strong class="bold">Your original string: second</strong></pre>
			<p>You will see that Cargo automatically downloaded the dependencies and builds them one by one. Also, you might notice that encrypting using the <code>Rsa</code> type took a while. Isn't Rust supposed to be a fast system language? The RSA algorithm itself is a slow algorithm, but that's not the real cause of the slowness. Because we are <a id="_idIndexMarker067"/>running the program in a development profile, the Rust compiler generates an application binary with all the debugging information and does not optimize the resulting binary. On the other hand, if you build the application using the <code>--release</code> flag, the compiler generates an optimized application binary and strips the debugging symbols. The resulting binary compiled with the release flag should execute faster than the debug binary. Try doing it yourself so you'll remember how to build a release binary.</p>
			<p>In this section, we have learned about Cargo and third-party packages, so next, let's find out where to find help and documentation for the tools that we have used.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Tools and getting help</h1>
			<p>Now that we have created a pretty simple application, you might be wondering what tools we can use for development, and how to find out more about Rust and get help.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Tools</h2>
			<p>Besides Cargo, there <a id="_idIndexMarker068"/>are a couple more tools we can use for Rust application development:</p>
			<ul>
				<li><strong class="bold">rustfmt</strong></li>
			</ul>
			<p>This program is for formatting your source code so it follows the Rust style guide. You can <a id="_idIndexMarker069"/>install it by using <code>rustup</code> (<code>rustup component add rustfmt</code>). Then, you can integrate it with your favorite text editor <a id="_idIndexMarker070"/>or use it from the command line. You can read more about <code>rustfmt</code> at <a href="https://github.com/rust-lang/rustfmt">https://github.com/rust-lang/rustfmt</a>.</p>
			<ul>
				<li><strong class="bold">clippy</strong></li>
			</ul>
			<p>Does the name <a id="_idIndexMarker071"/>remind you of something? <code>clippy</code> is useful for linting your Cargo application <a id="_idIndexMarker072"/>using various lint rules. Right now, there are more than 450 lint rules you can use. You can install it using this command: <code>rustup component add clippy</code>. Afterward, you can use it in the Cargo application by running <code>cargo clippy</code>. Can you try it in the Cargo application <a id="_idIndexMarker073"/>that we wrote earlier? You can read more about <code>clippy</code> at <a href="https://github.com/rust-lang/rust-clippy">https://github.com/rust-lang/rust-clippy</a>.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Text editor</h2>
			<p>Most likely, the text editor of your choice already supports the Rust language, or at least syntax highlighting Rust. You can install the Rust language server if you want to add important functionalities <a id="_idIndexMarker074"/>such as go to definition, go to implementation, symbol search, and code completion. Most popular text editors already support the language server, so you can just install an extension or other integration method to your text editor:</p>
			<ul>
				<li><strong class="bold">The Rust language server</strong></li>
			</ul>
			<p>You can install it <a id="_idIndexMarker075"/>using the <code>rustup</code> command: <code>rustup component add rls rust-analysis rust-src</code>. Then, you can integrate it into your text editor. For example, if you are using <code>rls</code>.</p>
			<p>You can <a id="_idIndexMarker076"/>read more about it at <a href="https://github.com/rust-lang/rls">https://github.com/rust-lang/rls</a>.</p>
			<ul>
				<li><strong class="bold">Rust analyzer</strong></li>
			</ul>
			<p>This application is <a id="_idIndexMarker077"/>poised to be the Rust language server 2.0. It's still considered to be in alpha as of the writing of this book, but in my experience, this application works well with regular updates. You can find the executable for <a id="_idIndexMarker078"/>this one at <a href="https://github.com/rust-analyzer/rust-analyzer/releases">https://github.com/rust-analyzer/rust-analyzer/releases</a>, and then configure your editor language server to use this application. You can read more about it at <a href="https://rust-analyzer.github.io">https://rust-analyzer.github.io</a>. </p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Getting help and documentation</h2>
			<p>There are a few important documents that you might want to read to find help or references:</p>
			<ul>
				<li><strong class="bold">The Rust programming language book</strong>: This is the book that you want to read if you want <a id="_idIndexMarker079"/>to understand more about the Rust programming language. You can find it online at <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>.</li>
				<li><strong class="bold">Rust by Example</strong>: This documentation is a collection of small examples that show the <a id="_idIndexMarker080"/>concepts of the Rust language and its standard library's capabilities. You can read it online at <a href="https://doc.rust-lang.org/rust-by-example/index.html">https://doc.rust-lang.org/rust-by-example/index.html</a>.</li>
				<li><strong class="bold">Standard library documentation</strong>: As a programmer, you will refer to this standard library <a id="_idIndexMarker081"/>documentation. You can read more about standard libraries, their modules, the function signatures, what standard libraries' functions do, read the examples, and more. Find it at <a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a>.</li>
				<li><code>Cargo.toml</code> <a id="_idIndexMarker082"/>manifest format, you can read more about it at <a href="https://doc.rust-lang.org/cargo/index.html">https://doc.rust-lang.org/cargo/index.html</a>.</li>
				<li><strong class="bold">Rust style guidelines</strong>: The Rust language, like other programming languages, has style <a id="_idIndexMarker083"/>guidelines. These guidelines tell a programmer what the convention for naming is, about whitespaces, how to use constants, and other idiomatic conventions for a Rust program. Read more about it at <a href="https://doc.rust-lang.org/1.0.0/style/">https://doc.rust-lang.org/1.0.0/style/</a>.</li>
				<li><code>rsa</code> crate that we used earlier. To find <a id="_idIndexMarker084"/>documentation for that library, you can go to <a href="https://crates.io">https://crates.io</a> and search for the crate's page, then go to the right pane and go to the documentation section. Or, you can go to <a href="https://docs.rs">https://docs.rs</a> and search for the crate name and find the documentation for it.</li>
				<li><code>rustup</code> (<code>rustup component add rust-docs</code>). Then, you can open documentation in your browser while offline using the <code>rustup doc</code> command. If you want to open standard library documentation offline, you can type <code>rustup doc --std</code>. There are other documents you can open; try and see what they are by using <code>rustup doc --help</code>.</li>
				<li><strong class="bold">The Rust user forum</strong>: If you want to get help or help other Rust programmers, you can find it all <a id="_idIndexMarker085"/>over the internet. There's a dedicated forum to discuss Rust-related topics at <a href="https://users.rust-lang.org/">https://users.rust-lang.org/</a>.</li>
			</ul>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Summary</h1>
			<p>In this chapter, we had a brief overview of the Rust language. We learned about the Rust toolchain and how to install it as well as the tools required for Rust development. After that, we created two simple programs, used Cargo, and imported third-party modules to improve our program. Now that you can write a small program in the Rust language, explore! Try creating more programs or experimenting with the language. You can try <em class="italic">Rust by Example</em> to see what features we can use in our programs. In subsequent chapters, we will learn more about Rocket, a web framework written in the Rust language.</p>
		</div>
	</body></html>