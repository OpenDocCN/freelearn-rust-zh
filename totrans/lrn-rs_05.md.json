["```rs\nint values and the single float32 type:\n```", "```rs\n    fn main() \n    { \n        let a = 10; \n        let b = 20; \n        let pi = 3.14f32; \n    } \n```", "```rs\n    fn main() \n    { \n        let i = 32; \n    } \n```", "```rs\n    fn second() \n    { \n        let a = 32; \n        let b = 12; \n    } \n    fn main() \n    { \n        let d = 100; \n    } \n```", "```rs\n    fn second() \n    { \n        let a = 32; \n        let b = 12; \n    } \n    fn main() \n    { \n        let d = 100; \n        second(); \n    } \n```", "```rs\n    fn main() \n    { \n        let f = 42; \n        let my_ids: Vec<i64> = Vec::with_capacity(5); \n    } \n```", "```rs\n    fn main() \n    { \n        let a = 32; \n        let b = &a; \n    } \n```", "```rs\n    fn second(i: &i32) \n    { \n        let c = 42; \n        println!(\"{}\", *i); \n    } \n\n    fn main()  \n    { \n        let a = 32; \n        let b = &a; \n        second(b); \n    } \n\n```", "```rs\n    struct MyRectangle \n    { \n        x: i32, \n        y: i32, \n        length: i32, \n        breadth: i32, \n    } \n\n    fn allocate_rect() \n    { \n        let x: Box<MyRectangle> = Box::new (MyRectangle {x: 5, y: 5, length: 25, breadth:15}); \n    } \n```", "```rs\nfn swap_around() \n{ \n    let my_rect: Box<MyRectangle> = Box::new(MyRectangle{x:5, y:5, length:25, breadth:15}); \n    let dup_rect = my_rect; // dup_rect is now the owner \n    println!(\"{}\", dup_rect.x); \n    println!(\"{}\", my_rect.x); // won't work - use of moved value \n} \n```", "```rs\n    void myFunction() \n    { \n        int *memblock = malloc(sizeof(int)); \n        *memblock = 256; \n        printf(\"%d\\n\", *memblock); \n        free(memblock); \n    } \n```", "```rs\n    fn myMemory() \n    { \n        let memblock: Box<i64> = Box::new(256); \n        println!(\"{}\", memblock); \n    } \n```", "```rs\n   // 05/rc-1/src/main.rs \n   use std::rc::Rc; \n\n    fn main() \n    { \n        let memblock: Rc<i64> = Rc::new(256); \n        // allocate space on the heap and assign \n        secondMethod(memblock.clone()); \n        // clone a new reference counted pointer and pass it on to the method \n        println!(\"{}\", memblock); \n        // output the value \n    } // free memory here \n\n    fn secondMethod(memblock: Rc<i64>) \n    { \n        println!(\"In secondMethod and memblock is {}\", memblock); \n        let secMemblock: Rc<i64> = memblock.clone(); \n        // yet another reference counted pointer to memblock \n    } \n    // secMemblock goes out of scope, but the memory is not deallocated \n```", "```rs\nlet x = 2; \nlet y =  \n    { \n        let x_squared = x * x; \n        let x_cube = x_squared * x; \n        x_cube + x_squared + x \n    }; \n```", "```rs\n    // 05/refs-1/src/main.rs\n    fn main() { \n        let x = 2; \n        let y: &i32; \n        { \n            let x_squared = x * x; \n            let x_cube = x_squared * x; \n            y = &(x_cube + x_squared + x); \n            // this value goes away after this line \n        }; \n        println!(\"Y = {}\", *y); \n    } \n```", "```rs\n    // 05/threads-1/src/main.rs\n    use std::thread; \n    use std::rc::Rc; \n\n    struct MyCounter \n    { \n        count: i32 \n    } \n\n    fn wont_work() \n    { \n        let mut counter = Rc::new(MyCounter {count: 0}); \n        thread::spawn(move || // new thread  \n        { \n            counter.count += 1; \n        }); \n        println!(\"{}\", counter.count); \n    } \n```", "```rs\n    // 05/threads-2/src/main.rs\n    use std::thread; \n    use std::sync::{Arc, Mutex}; \n\n    struct MyCounter \n    { \n        count: i32 \n    } \n\n    fn wont_work() \n    { \n        let counter = Arc::new(Mutex::new(MyCounter {count: 0})); \n        let another_counter = counter.clone(); \n        thread::spawn(move || // new thread  \n        { \n            let mut counter = another_counter.lock().expect(\"Locking of cloned counter failed\"); \n            counter.count += 1; \n        }); \n        println!(\"{}\", counter.lock().unwrap().count); \n    } \n```"]