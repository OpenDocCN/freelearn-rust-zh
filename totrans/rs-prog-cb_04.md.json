["```rs\nuse std::thread;\nuse std::time::Duration;\n\nfn start_no_shared_data_thread() -> thread::JoinHandle<()> {\n    thread::spawn(|| {\n        // since we are not using a parent scope variable in here\n        // no move is required\n        println!(\"Waiting for three seconds.\");\n        thread::sleep(Duration::from_secs(3)); \n        println!(\"Done\")\n    })\n}\n```", "```rs\n    let no_move_thread = start_no_shared_data_thread();\n\n    for _ in 0..10 {\n        print!(\":\");\n    }\n\n    println!(\"Waiting for the thread to finish ... {:?}\", \n    no_move_thread.join());\n```", "```rs\n$ cargo run\n Compiling simple-threads v0.1.0 (Rust-Cookbook/Chapter05/simple-\n threads)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.35s\n     Running `target/debug/simple-threads`\n::::::::::Waiting for three seconds.\nDone\nWaiting for the thread to finish ... Ok(())\n```", "```rs\nfn start_shared_data_thread(a_number: i32, a_vec: Vec<i32>) -> thread::JoinHandle<Vec<i32>> {\n    // thread::spawn(move || {\n    thread::spawn(|| {\n        print!(\" a_vec ---> [\");\n        for i in a_vec.iter() {\n            print!(\" {} \", i);\n        }\n        println!(\"]\");\n        println!(\" A number from inside the thread: {}\", a_number);\n        a_vec // let's return ownership\n    })\n}\n```", "```rs\n    let a_number = 42;\n    let a_vec = vec![1,2,3,4,5];\n\n    let move_thread = start_shared_data_thread(a_number, a_vec);\n\n    println!(\"We can still use a Copy-enabled type: {}\", a_number); \n    println!(\"Waiting for the thread to finish ... {:?}\", \n    move_thread.join());\n```", "```rs\n$ cargo run\nCompiling simple-threads v0.1.0 (Rust-Cookbook/Chapter04/simple-threads)\nerror[E0373]: closure may outlive the current function, but it borrows `a_number`, which is owned by the current function\n  --> src/main.rs:22:20\n   |\n22 | thread::spawn(|| {\n   |               ^^ may outlive borrowed value `a_number`\n...\n29 |    println!(\" A number from inside the thread: {}\", a_number);\n   |                                                     -------- `a_number` is borrowed here\n   |\nnote: function requires argument type to outlive `'static`\n  --> src/main.rs:22:6\n   |\n23 | /     thread::spawn(|| {\n24 | |        print!(\" a_vec ---> [\");\n25 | |        for i in a_vec.iter() {\n...  |\n30 | |        a_vec // let's return ownership\n31 | |     })\n   | |______^\nhelp: to force the closure to take ownership of `a_number` (and any other referenced variables), use the `move` keyword\n   |\n23 | thread::spawn(move || {\n   |               ^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0373`.\nerror: Could not compile `simple-threads`.\n\nTo learn more, run the command again with --verbose.\n```", "```rs\n///\n/// Starts a thread moving the function's input parameters\n/// \nfn start_shared_data_thread(a_number: i32, a_vec: Vec<i32>) -> thread::JoinHandle<Vec<i32>> {\n    thread::spawn(move || {\n    // thread::spawn(|| {\n        print!(\" a_vec ---> [\");\n        for i in a_vec.iter() {\n            print!(\" {} \", i);\n        }\n        println!(\"]\");\n        println!(\" A number from inside the thread: {}\", a_number);\n        a_vec // let's return ownership\n    })\n}\n```", "```rs\n$ cargo run\n   Compiling simple-threads v0.1.0 (Rust-Cookbook/Chapter04/simple-\n   threads)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.38s\n     Running `target/debug/simple-threads`\n::::::::::Waiting for three seconds.\nDone\nWaiting for the thread to finish ... Ok(())\nWe can still use a Copy-enabled type: 42\n   a_vec ---> [ 1 2 3 4 5 ]\n   A number from inside the thread: 42\nWaiting for the thread to finish ... Ok([1, 2, 3, 4, 5])\n```", "```rs\nuse std::thread;\n\n///\n/// Doubles each element in the provided chunks in parallel and returns the results.\n/// \nfn parallel_map(data: Vec<Vec<i32>>) -> Vec<thread::JoinHandle<Vec<i32>>> {\n    data.into_iter()\n        .map(|chunk| thread::spawn(move ||\n         chunk.into_iter().map(|c| \n         c * 2).collect()))\n        .collect()\n}\n```", "```rs\nfn main() {\n\n    // Prepare chunked data\n    let data = vec![vec![1, 2, 3], vec![4, 4, 5], vec![6, 7, 7]];\n\n    // work on the data in parallel\n    let results: Vec<i32> = parallel_map(data.clone())\n        .into_iter() // an owned iterator over the results\n        .flat_map(|thread| thread.join().unwrap()) // join each \n         thread\n        .collect(); // collect the results into a Vec\n\n    // flatten the original data structure\n    let data: Vec<i32> = data.into_iter().flat_map(|e| e)\n     .collect();\n\n    // print the results\n    println!(\"{:?} -> {:?}\", data, results);\n}\n```", "```rs\n$ cargo run\n   Compiling multiple-threads v0.1.0 (Rust-\n    Cookbook/Chapter04/multiple-threads)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.45s\n     Running `target/debug/multiple-threads`\n    [1, 2, 3, 4, 4, 5, 6, 7, 7] -> [2, 4, 6, 8, 8, 10, 12, 14, 14]\n```", "```rs\nuse std::sync::mpsc::{Sender, Receiver};\nuse std::sync::mpsc;\nuse std::thread;\n\nuse rand::prelude::*;\nuse std::time::Duration;\n\nenum ChartValue {\n    Star(usize),\n    Pipe(usize)\n}\n```", "```rs\nfn main() {\n    let (tx, rx): (Sender<ChartValue>, Receiver<ChartValue>) = \n     mpsc::channel();\n\n    let pipe_sender = tx.clone();\n\n    thread::spawn(move || {\n        loop {\n            pipe_sender.send(ChartValue::Pipe(random::<usize>() % \n             80)).unwrap();\n            thread::sleep(Duration::from_millis(random::<u64>() % \n             800));\n        }\n    });\n\n    let star_sender = tx.clone();\n    thread::spawn(move || {\n        loop {\n            star_sender.send(ChartValue::Star(random::<usize>() % \n             80)).unwrap();\n            thread::sleep(Duration::from_millis(random::<u64>() % \n             800));\n        }\n    });\n```", "```rs\n    while let Ok(val) = rx.recv_timeout(Duration::from_secs(3)) {\n\n        println!(\"{}\", match val {\n            ChartValue::Pipe(v) => \"|\".repeat(v + 1),\n            ChartValue::Star(v) => \"*\".repeat(v + 1)\n        });\n    }\n}\n```", "```rs\n[dependencies]\nrand = \"^0.5\"\n```", "```rs\n$ cargo run\n   Compiling channels v0.1.0 (Rust-Cookbook/Chapter04/channels)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.38s\n     Running `target/debug/channels`\n||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n****************************\n|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||\n*********************************************************\n||||||||||||||||||||||||||||\n************************************************************\n*****************************\n||||||||||||||||\n***********\n||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n*******************************\n|||||||||||||||||||||||||||||||||||||||||\n*************************************************************\n|||||||||||||||||||||||||||||||||||||||||||||||\n*******************************\n************************************************************************\n*******************\n******************************************************\n|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n||||||||||||||||||||||||||||||||\n************************************************\n*\n||||||||||||||||||||||||||||||||||||||||\n***********************************************\n||||||\n*************************\n|||||||||||||||||||\n|||||||||||||||||||||||||||||||||||\n^C⏎ \n```", "```rs\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\n///\n/// A simple enum with only two variations: black and white\n/// \n#[derive(Debug)]\nenum Shade {\n    Black,\n    White,\n}\n```", "```rs\nfn new_painter_thread(data: Arc<Mutex<Vec<Shade>>>) -> thread::JoinHandle<()> {\n    thread::spawn(move || loop {\n        {\n            // create a scope to release the mutex as quickly as    \n            // possible\n            let mut d = data.lock().unwrap();\n            if d.len() > 0 {\n                match d[d.len() - 1] {\n                    Shade::Black => d.push(Shade::White),\n                    Shade::White => d.push(Shade::Black),\n                }\n            } else {\n                d.push(Shade::Black)\n            }\n            if d.len() > 5 {\n                break;\n            }\n        }\n        // slow things down a little\n        thread::sleep(Duration::from_secs(1));\n    })\n}\n```", "```rs\nfn main() {\n    let data = Arc::new(Mutex::new(vec![]));\n    let threads: Vec<thread::JoinHandle<()>> =\n        (0..2)\n        .map(|_| new_painter_thread(data.clone()))\n        .collect();\n\n    let _: Vec<()> = threads\n        .into_iter()\n        .map(|t| t.join().unwrap())\n        .collect();\n\n    println!(\"Result: {:?}\", data);\n}\n```", "```rs\n$ cargo run\n   Compiling black-white v0.1.0 (Rust-Cookbook/Chapter04/black-\n   white)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.35s\n     Running `target/debug/black-white`\n     Result: Mutex { data: [Black, White, Black, White, Black, \n    White, Black] }\n```", "```rs\nuse std::io::Write;\nuse std::process::{Command, Stdio};\n\n#[derive(Debug)]\nstruct SearchResult {\n    query: String,\n    results: Vec<String>,\n}\n```", "```rs\nfn search_file(name: String) -> SearchResult {\n    let ps_child = Command::new(\"find\")\n        .args(&[\".\", \"-iname\", &format!(\"{}\", name)])\n        .stdout(Stdio::piped())\n        .output()\n        .expect(\"Could not spawn process\");\n\n    let results = String::from_utf8_lossy(&ps_child.stdout);\n    let result_rows: Vec<String> = results\n        .split(\"\\n\")\n        .map(|e| e.to_string())\n        .filter(|s| s.len() > 1)\n        .collect();\n\n    SearchResult {\n        query: name,\n        results: result_rows,\n    }\n}\n```", "```rs\nfn process_roundtrip() -> String {\n    let mut cat_child = Command::new(\"cat\")\n        .stdin(Stdio::piped())\n        .stdout(Stdio::piped())\n        .spawn()\n        .expect(\"Could not spawn process\");\n\n    let stdin = cat_child.stdin.as_mut().expect(\"Could \n     not attach to stdin\");\n\n    stdin\n        .write_all(b\"datadatadata\")\n        .expect(\"Could not write to child process\");\n    String::from_utf8(\n        cat_child\n            .wait_with_output()\n            .expect(\"Something went wrong\")\n            .stdout\n            .as_slice()\n            .iter()\n            .cloned()\n            .collect(),\n    )\n    .unwrap()\n}\n```", "```rs\nfn main() {\n    println!(\"Reading from /bin/cat > {:?}\", process_roundtrip());\n    println!(\n        \"Using 'find' to search for '*.rs': {:?}\",\n        search_file(\"*.rs\".to_owned())\n    )\n}\n```", "```rs\n$ cargo run\n   Compiling child-processes v0.1.0 (Rust-Cookbook/Chapter04/child-\n    processes)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.59s\n    Running `target/debug/child-processes`\n    Reading from /bin/cat > \"datadatadata\"\n    Using 'find' to search for '*.rs': SearchResult { query: \"\n    *.rs\", results: [\"./src/main.rs\"] }\n```", "```rs\n# replace the default [dependencies] section...\n[dependencies]\nrayon = \"1.0.3\"\n\n[dev-dependencies]\ncriterion = \"0.2.11\"\nrand = \"^0.5\"\n\n[[bench]]\nname = \"seq_vs_par\"\nharness = false\n```", "```rs\n///\n/// Regular, sequential merge sort implementation\n/// \npub fn merge_sort_seq<T: PartialOrd + Clone + Default>(collection: &[T]) -> Vec<T> {\n    if collection.len() > 1 {\n        let (l, r) = collection.split_at(collection.len() / 2);\n        let (sorted_l, sorted_r) = (merge_sort_seq(l), \n         merge_sort_seq(r));\n        sorted_merge(sorted_l, sorted_r)\n    } else {\n        collection.to_vec()\n    }\n}\n```", "```rs\n///\n/// Merges two collections into one. \n/// \nfn sorted_merge<T: Default + Clone + PartialOrd>(sorted_l: Vec<T>, sorted_r: Vec<T>) -> Vec<T> {\n    let mut result: Vec<T> = vec![Default::default(); sorted_l.len() \n     + sorted_r.len()];\n\n    let (mut i, mut j) = (0, 0);\n    let mut k = 0;\n    while i < sorted_l.len() && j < sorted_r.len() {\n        if sorted_l[i] <= sorted_r[j] {\n            result[k] = sorted_l[i].clone();\n            i += 1;\n        } else {\n            result[k] = sorted_r[j].clone();\n            j += 1;\n        }\n        k += 1;\n    }\n    while i < sorted_l.len() {\n        result[k] = sorted_l[i].clone();\n        k += 1;\n        i += 1;\n    }\n\n    while j < sorted_r.len() {\n        result[k] = sorted_r[j].clone();\n        k += 1;\n        j += 1;\n    }\n    result\n}\n```", "```rs\nuse rayon;\n```", "```rs\n///\n/// Merge sort implementation using parallelism.\n/// \npub fn merge_sort_par<T>(collection: &[T]) -> Vec<T>\nwhere\n    T: PartialOrd + Clone + Default + Send + Sync,\n{\n    if collection.len() > 1 {\n        let (l, r) = collection.split_at(collection.len() / 2);\n        let (sorted_l, sorted_r) = rayon::join(|| merge_sort_par(l), \n        || merge_sort_par(r));\n        sorted_merge(sorted_l, sorted_r)\n    } else {\n        collection.to_vec()\n    }\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_merge_sort_seq() {\n        assert_eq!(merge_sort_seq(&vec![9, 8, 7, 6]), vec![6, 7, 8, \n         9]);\n        assert_eq!(merge_sort_seq(&vec![6, 8, 7, 9]), vec![6, 7, 8, \n         9]);\n        assert_eq!(merge_sort_seq(&vec![2, 1, 1, 1, 1]), vec![1, 1, \n         1, 1, 2]);\n    }\n\n    #[test]\n    fn test_merge_sort_par() {\n        assert_eq!(merge_sort_par(&vec![9, 8, 7, 6]), vec![6, 7, 8, \n         9]);\n        assert_eq!(merge_sort_par(&vec![6, 8, 7, 9]), vec![6, 7, 8, \n         9]);\n        assert_eq!(merge_sort_par(&vec![2, 1, 1, 1, 1]), vec![1, 1, \n         1, 1, 2]);\n    }\n}\n```", "```rs\n$ cargo test\n   Compiling use-rayon v0.1.0 (Rust-Cookbook/Chapter04/use-rayon)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.67s\n     Running target/debug/deps/use_rayon-1fb58536866a2b92\n\nrunning 2 tests\ntest tests::test_merge_sort_seq ... ok\ntest tests::test_merge_sort_par ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests use-rayon\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n#[macro_use]\nextern crate criterion;\nuse criterion::black_box;\nuse criterion::Criterion;\nuse rand::prelude::*;\nuse std::cell::RefCell;\nuse use_rayon::{merge_sort_par, merge_sort_seq};\n\nfn random_number_vec(size: usize) -> Vec<i64> {\n    let mut v: Vec<i64> = (0..size as i64).collect();\n    let mut rng = thread_rng();\n    rng.shuffle(&mut v);\n    v\n}\n\nthread_local!(static ITEMS: RefCell<Vec<i64>> = RefCell::new(random_number_vec(100_000)));\n\nfn bench_seq(c: &mut Criterion) {\n    c.bench_function(\"10k merge sort (sequential)\", |b| {\n        ITEMS.with(|item| b.iter(||         \n        black_box(merge_sort_seq(&item.borrow()))));\n    });\n}\n\nfn bench_par(c: &mut Criterion) {\n    c.bench_function(\"10k merge sort (parallel)\", |b| {\n        ITEMS.with(|item| b.iter(|| \n        black_box(merge_sort_par(&item.borrow()))));\n    });\n}\ncriterion_group!(benches, bench_seq, bench_par);\n\ncriterion_main!(benches);\n```", "```rs\n$ cargo bench\n   Compiling use-rayon v0.1.0 (Rust-Cookbook/Chapter04/use-rayon)\n    Finished release [optimized] target(s) in 1.84s\n     Running target/release/deps/use_rayon-eb085695289744ef\n\nrunning 2 tests\ntest tests::test_merge_sort_par ... ignored\ntest tests::test_merge_sort_seq ... ignored\n\ntest result: ok. 0 passed; 0 failed; 2 ignored; 0 measured; 0 filtered out\n\nRunning target/release/deps/seq_vs_par-6383ba0d412acb2b\nGnuplot not found, disabling plotting\n10k merge sort (sequential) \n                        time: [13.815 ms 13.860 ms 13.906 ms]\n                        change: [-6.7401% -5.1611% -3.6593%] (p = \n                         0.00 < 0.05)\n                        Performance has improved.\nFound 5 outliers among 100 measurements (5.00%)\n  3 (3.00%) high mild\n  2 (2.00%) high severe\n\n10k merge sort (parallel) \n                        time: [10.037 ms 10.067 ms 10.096 ms]\n                        change: [-15.322% -13.276% -11.510%] (p = \n                        0.00 < 0.05)\n                        Performance has improved.\nFound 6 outliers among 100 measurements (6.00%)\n  1 (1.00%) low severe\n  1 (1.00%) high mild\n  4 (4.00%) high severe\n\nGnuplot not found, disabling plotting\n```", "```rs\n[dependencies]\nrayon = \"1.0.3\"\n\n[dev-dependencies]\ncriterion = \"0.2.11\"\nrand = \"^0.5\"\n\n[[bench]]\nname = \"seq_vs_par\"\nharness = false\n```", "```rs\npub fn ssqe_sequential(y: &[f32], y_predicted: &[f32]) -> Option<f32> {\n    if y.len() == y_predicted.len() {\n        let y_iter = y.iter();\n        let y_pred_iter = y_predicted.iter();\n\n        Some(\n            y_iter\n                .zip(y_pred_iter)\n                .map(|(y, y_pred)| (y - y_pred).powi(2))\n                .sum()\n        ) \n    } else {\n        None\n    }\n}\n```", "```rs\nuse rayon::prelude::*;\n\npub fn ssqe(y: &[f32], y_predicted: &[f32]) -> Option<f32> {\n    if y.len() == y_predicted.len() {\n        let y_iter = y.par_iter();\n        let y_pred_iter = y_predicted.par_iter();\n\n        Some(\n            y_iter\n                .zip(y_pred_iter)\n                .map(|(y, y_pred)| (y - y_pred).powi(2))\n                .reduce(|| 0.0, |a, b| a + b),\n        ) // or sum()\n    } else {\n        None\n    }\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sum_of_sq_errors() {\n        assert_eq!(\n            ssqe(&[1.0, 1.0, 1.0, 1.0], &[2.0, 2.0, 2.0, 2.0]),\n            Some(4.0)\n        );\n        assert_eq!(\n            ssqe(&[-1.0, -1.0, -1.0, -1.0], &[-2.0, -2.0, -2.0, \n             -2.0]),\n            Some(4.0)\n        );\n        assert_eq!(\n            ssqe(&[-1.0, -1.0, -1.0, -1.0], &[2.0, 2.0, 2.0, 2.0]),\n            Some(36.0)\n        );\n        assert_eq!(\n            ssqe(&[1.0, 1.0, 1.0, 1.0], &[2.0, 2.0, 2.0, 2.0]),\n            Some(4.0)\n        );\n        assert_eq!(\n            ssqe(&[1.0, 1.0, 1.0, 1.0], &[2.0, 2.0, 2.0, 2.0]),\n            Some(4.0)\n        );\n    }\n```", "```rs\n    #[test]\n    fn test_sum_of_sq_errors_seq() {\n        assert_eq!(\n            ssqe_sequential(&[1.0, 1.0, 1.0, 1.0], &[2.0, 2.0, 2.0, \n             2.0]),\n            Some(4.0)\n        );\n        assert_eq!(\n            ssqe_sequential(&[-1.0, -1.0, -1.0, -1.0], &[-2.0,\n             -2.0, -2.0, -2.0]),\n            Some(4.0)\n        );\n        assert_eq!(\n            ssqe_sequential(&[-1.0, -1.0, -1.0, -1.0], &[2.0, 2.0, \n             2.0, 2.0]),\n            Some(36.0)\n        );\n        assert_eq!(\n            ssqe_sequential(&[1.0, 1.0, 1.0, 1.0], &[2.0, 2.0, 2.0, \n             2.0]),\n            Some(4.0)\n        );\n        assert_eq!(\n            ssqe_sequential(&[1.0, 1.0, 1.0, 1.0], &[2.0, 2.0, 2.0, \n             2.0]),\n            Some(4.0)\n        );\n    }\n}\n```", "```rs\n$ cargo test\n   Compiling concurrent-processing v0.1.0 (Rust-\n    Cookbook/Chapter04/concurrent-processing)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.84s\n     Running target/debug/deps/concurrent_processing-\n      250eef41459fd2af\n\nrunning 2 tests\ntest tests::test_sum_of_sq_errors_seq ... ok\ntest tests::test_sum_of_sq_errors ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests concurrent-processing\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\npub fn seq_count_alpha_nums(corpus: &str) -> usize {\n    corpus.chars().filter(|c| c.is_alphanumeric()).count()\n}\n\npub fn par_count_alpha_nums(corpus: &str) -> usize {\n    corpus.par_chars().filter(|c| c.is_alphanumeric()).count()\n}\n```", "```rs\n#[macro_use]\nextern crate criterion;\nuse concurrent_processing::{ssqe, ssqe_sequential, seq_count_alpha_nums, par_count_alpha_nums};\nuse criterion::{black_box, Criterion};\nuse std::cell::RefCell;\nuse rand::prelude::*;\n\nconst SEQ_LEN: usize = 1_000_000;\nthread_local!(static ITEMS: RefCell<(Vec<f32>, Vec<f32>)> = {\n    let y_values: (Vec<f32>, Vec<f32>) = (0..SEQ_LEN).map(|_| \n     (random::<f32>(), random::<f32>()) )\n    .unzip();\n    RefCell::new(y_values)\n});\n\nconst MAX_CHARS: usize = 100_000;\nthread_local!(static CHARS: RefCell<String> = {\n    let items: String = (0..MAX_CHARS).map(|_| random::<char>\n     ()).collect();\n    RefCell::new(items)\n});\n```", "```rs\nfn bench_count_seq(c: &mut Criterion) {\n    c.bench_function(\"Counting in sequence\", |b| {\n        CHARS.with(|item| b.iter(|| \n         black_box(seq_count_alpha_nums(&item.borrow()))))\n    });\n}\n\nfn bench_count_par(c: &mut Criterion) {\n    c.bench_function(\"Counting in parallel\", |b| {\n        CHARS.with(|item| b.iter(|| \n         black_box(par_count_alpha_nums(&item.borrow()))))\n    });\n}\n```", "```rs\nfn bench_seq(c: &mut Criterion) {\n    c.bench_function(\"Sequential vector operation\", |b| {\n        ITEMS.with(|y_values| {\n            let y_borrowed = y_values.borrow();\n            b.iter(|| black_box(ssqe_sequential(&y_borrowed.0, \n             &y_borrowed.1)))\n        })\n    });\n}\n\nfn bench_par(c: &mut Criterion) {\n    c.bench_function(\"Parallel vector operation\", |b| {\n        ITEMS.with(|y_values| {\n            let y_borrowed = y_values.borrow();\n            b.iter(|| black_box(ssqe(&y_borrowed.0, \n            &y_borrowed.1)))\n        })\n    });\n}\n\ncriterion_group!(benches, bench_seq, bench_par,bench_count_par, bench_count_seq);\n\ncriterion_main!(benches);\n```", "```rs\n$ cargo bench\n   Compiling concurrent-processing v0.1.0 (Rust-\n    Cookbook/Chapter04/concurrent-processing)\n    Finished release [optimized] target(s) in 2.37s\n     Running target/release/deps/concurrent_processing-\n      eedf0fd3b1e51fe0\n\nrunning 2 tests\ntest tests::test_sum_of_sq_errors ... ignored\ntest tests::test_sum_of_sq_errors_seq ... ignored\n\ntest result: ok. 0 passed; 0 failed; 2 ignored; 0 measured; 0 filtered out\n\nRunning target/release/deps/seq_vs_par-ddd71082d4bd9dd6\nGnuplot not found, disabling plotting\nSequential vector operation \n                        time: [1.0631 ms 1.0681 ms 1.0756 ms]\n                        change: [-4.8191% -3.4333% -2.3243%] (p = \n                        0.00 < 0.05)\n                        Performance has improved.\nFound 4 outliers among 100 measurements (4.00%)\n  2 (2.00%) high mild\n  2 (2.00%) high severe\n\nParallel vector operation \n                        time: [408.93 us 417.14 us 425.82 us]\n                        change: [-9.5623% -6.0044% -2.2126%] (p = \n                        0.00 < 0.05)\n                        Performance has improved.\nFound 15 outliers among 100 measurements (15.00%)\n  2 (2.00%) low mild\n  7 (7.00%) high mild\n  6 (6.00%) high severe\n\nCounting in parallel time: [552.01 us 564.97 us 580.51 us] \n                        change: [+2.3072% +6.9101% +11.580%] (p = \n                        0.00 < 0.05)\n                        Performance has regressed.\nFound 4 outliers among 100 measurements (4.00%)\n  3 (3.00%) high mild\n  1 (1.00%) high severe\n\nCounting in sequence time: [992.84 us 1.0137 ms 1.0396 ms] \n                        change: [+9.3014% +12.494% +15.338%] (p = \n                        0.00 < 0.05)\n                        Performance has regressed.\nFound 4 outliers among 100 measurements (4.00%)\n  4 (4.00%) high mild\n\nGnuplot not found, disabling plotting\n```", "```rs\nuse std::thread;\nuse std::rc::Rc;\nuse std::sync::Arc;\nuse std::sync::mpsc::channel;\n\nfn noop<T>(_: T) {}\n```", "```rs\nfn main() {\n    let (sender, receiver) = channel::<usize>();\n\n    thread::spawn(move || {\n        let thread_local_read_only_clone = sender.clone();\n        noop(thread_local_read_only_clone);\n    });\n}\n```", "```rs\n$ cargo build\n   Compiling immutable-states v0.1.0 (Rust-Cookbook/Chapter04\n   /immutable-states)\nwarning: unused import: `std::rc::Rc`\n --> src/main.rs:2:5\n  |\n2 | use std::rc::Rc;\n  | ^^^^^^^^^^^\n  |\n  = note: #[warn(unused_imports)] on by default\n\nwarning: unused import: `std::sync::Arc`\n --> src/main.rs:3:5\n  |\n3 | use std::sync::Arc;\n  | ^^^^^^^^^^^^^^\n\nwarning: unused variable: `receiver`\n  --> src/main.rs:10:18\n   |\n10 | let (sender, receiver) = channel::<usize>();\n   | ^^^^^^^^ help: consider prefixing with an underscore: `_receiver`\n   |\n   = note: #[warn(unused_variables)] on by default\n\n    Finished dev [unoptimized + debuginfo] target(s) in 0.58s\n```", "```rs\n    let c = Arc::new(receiver);\n    thread::spawn(move || {\n        noop(c.clone());\n    });\n```", "```rs\n$ cargo build\n   Compiling immutable-states v0.1.0 (Rust-Cookbook/Chapter04\n    /immutable-states)\nwarning: unused import: `std::rc::Rc`\n --> src/main.rs:2:5\n  |\n2 | use std::rc::Rc;\n  | ^^^^^^^^^^^\n  |\n  = note: #[warn(unused_imports)] on by default\n\nerror[E0277]: `std::sync::mpsc::Receiver<usize>` cannot be shared between threads safely\n  --> src/main.rs:26:5\n   |\n26 | thread::spawn(move || {\n   | ^^^^^^^^^^^^^ `std::sync::mpsc::Receiver<usize>` cannot be shared between threads safely\n   |\n   = help: the trait `std::marker::Sync` is not implemented for `std::sync::mpsc::Receiver<usize>`\n   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc<std::sync::mpsc::Receiver<usize>>`\n   = note: required because it appears within the type `[closure@src/main.rs:26:19: 28:6 c:std::sync::Arc<std::sync::mpsc::Receiver<usize>>]`\n   = note: required by `std::thread::spawn`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: Could not compile `immutable-states`.\n\nTo learn more, run the command again with --verbose.\n```", "```rs\n   let b = Arc::new(Rc::new(vec![]));\n    thread::spawn(move || {\n        let thread_local_read_only_clone = b.clone();\n        noop(thread_local_read_only_clone);\n    });\n```", "```rs\n$ cargo build\n   Compiling immutable-states v0.1.0 (Rust-Cookbook/Chapter04\n   /immutable-states)\nerror[E0277]: `std::rc::Rc<std::vec::Vec<_>>` cannot be sent between threads safely\n  --> src/main.rs:19:5\n   |\n19 | thread::spawn(move || {\n   | ^^^^^^^^^^^^^ `std::rc::Rc<std::vec::Vec<_>>` cannot be sent between threads safely\n   |\n   = help: the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::vec::Vec<_>>`\n   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc<std::rc::Rc<std::vec::Vec<_>>>`\n   = note: required because it appears within the type `[closure@src/main.rs:19:19: 22:6 b:std::sync::Arc<std::rc::Rc<std::vec::Vec<_>>>]`\n   = note: required by `std::thread::spawn`\n\nerror[E0277]: `std::rc::Rc<std::vec::Vec<_>>` cannot be shared between threads safely\n  --> src/main.rs:19:5\n   |\n19 | thread::spawn(move || {\n   | ^^^^^^^^^^^^^ `std::rc::Rc<std::vec::Vec<_>>` cannot be shared between threads safely\n   |\n   = help: the trait `std::marker::Sync` is not implemented for `std::rc::Rc<std::vec::Vec<_>>`\n   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc<std::rc::Rc<std::vec::Vec<_>>>`\n   = note: required because it appears within the type `[closure@src/main.rs:19:19: 22:6 b:std::sync::Arc<std::rc::Rc<std::vec::Vec<_>>>]`\n   = note: required by `std::thread::spawn`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: Could not compile `immutable-states`.\n\nTo learn more, run the command again with --verbose. \n```", "```rs\n[package]\nname = \"actors\"\nversion = \"0.1.0\"\nauthors = [\"Claus Matzinger <claus.matzinger+kb@gmail.com>\"]\nedition = \"2018\"\n\n[dependencies]\nactix = \"^0.8\"\nrand = \"0.5\"\n```", "```rs\nuse actix::prelude::*;\nuse std::thread;\nuse std::time::Duration;\nuse rand::prelude::*;\n```", "```rs\n///\n/// A mock sensor function\n/// \nfn read_sensordata() -> f32 {\n     random::<f32>() * 10.0\n}\n\n#[derive(Debug, Message)]\nstruct Sensordata(pub u64, pub f32);\n```", "```rs\nfn main() -> std::io::Result<()> {\n    System::run(|| {\n        println!(\">> Press Ctrl-C to stop the program\");\n        // start multi threaded actor host (arbiter) with 2 threads\n        let sender = SyncArbiter::start(N_THREADS, || \n        DBWriter);\n\n        // send messages to the actor \n        for n in 0..10_000 {\n            let my_timestamp = n as u64;\n            let data = read_sensordata();\n            sender.do_send(Sensordata(my_timestamp, data));\n        }\n    })\n}\n```", "```rs\nstruct DBWriter;\n\nimpl Actor for DBWriter {\n    type Context = SyncContext<Self>;\n}\n\nimpl Handler<Sensordata> for DBWriter {\n    type Result = ();\n\n    fn handle(&mut self, msg: Sensordata, _: &mut Self::Context) -> \n     Self::Result {\n\n        // send stuff somewhere and handle the results\n        println!(\" {:?}\", msg);\n        thread::sleep(Duration::from_millis(300));\n    }\n}\n```", "```rs\n$ cargo run\n   Compiling actors v0.1.0 (Rust-Cookbook/Chapter04/actors)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.05s\n     Running `target/debug/actors`\n>> Press Ctrl-C to stop the program\n  Sensordata(0, 2.2577233)\n  Sensordata(1, 4.039347)\n  Sensordata(2, 8.981095)\n  Sensordata(3, 1.1506838)\n  Sensordata(4, 7.5091066)\n  Sensordata(5, 2.5614727)\n  Sensordata(6, 3.6907816)\n  Sensordata(7, 7.907603)\n  ^C⏎    \n```", "```rs\n[package]\nname = \"async-await\"\nversion = \"0.1.0\"\nauthors = [\"Claus Matzinger <claus.matzinger+kb@gmail.com>\"]\nedition = \"2018\"\n\n[dependencies]\nruntime = \"0.3.0-alpha.6\"\nsurf = \"1.0\"\n```", "```rs\nuse surf::Exception;\nuse surf::http::StatusCode;\n```", "```rs\nasync fn response_code(url: &str) -> Result<StatusCode, Exception> {\n    let res = surf::get(url).await?;\n    Ok(res.status())\n}\n```", "```rs\n#[runtime::main]\nasync fn main() -> Result<(), Exception> {\n    let url = \"https://www.rust-lang.org\";\n    let status = response_code(url).await?;\n    println!(\"{} responded with HTTP {}\", url, status);\n    Ok(())\n}\n```", "```rs\n$ cargo +nightly run\n Compiling async-await v0.1.0 (Rust-Cookbook/Chapter04/async-await)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.81s\n     Running `target/debug/async-await`\n     https://www.rust-lang.org responded with HTTP 200 OK\n```"]