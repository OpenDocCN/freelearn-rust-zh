- en: Making Decisions by Pattern Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already saw Rust's `if` expressions, but those make decisions based on data
    values. Rust is a very type-conscious language, and so it's very important to
    be able to make decisions based on data types as well. Rust's `match` and `if
    let` expressions let us do that, comparing complex data types and allowing us
    to extract data values for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to use pattern matching in the context of variable assignment using
    the `let` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take what we've learned about pattern matching and apply it to decision making
    with the `if let` expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `match` expression to choose exactly one of many possible patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use don't care values in pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how borrowing interacts with pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to match complex, nested data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable assignment with pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen many times how to assign a variable in Rust: we do something like
    `let x = y;`, which tells Rust to create a new variable named `x` and move or
    copy the value stored in `y` into it, as appropriate to the data type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, that''s actually just a simplified case of what Rust is really doing,
    which is matching a pattern to a value and extracting data values from that matched
    pattern to store in the target variables, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Okay, what just happened? First of all, we have a structure definition. We've
    seen those before, and the only new thing here is that we're using the `String`
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: '`String` has an interesting relationship with `str`. When we''re using `str`,
    we almost always actually use a borrow such as `&str` or `&''static str`, rather
    than plain `str`. That''s because plain `str` doesn''t have a fixed size in the
    stack, which makes a lot of the things we''d want to do impossible to compile.
    So, we use `&str` instead, which does have a fixed size. *But*, using a reference
    as a contained value in a data structure also opens the door to all sorts of lifetime-based
    restrictions, so we don''t really want to use `pub name: &str` here. Fortunately,
    we can use `String` instead.`String` can masquerade as an `&str` when we need
    it to, but it''s not actually a borrow, so the ownership is straightforward. It
    is, however, slightly less efficient to use, so the general rule is to use `String`
    when it solves a problem and use `&str` the rest of the time.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, we create a new data value with the `DemoStruct` type, with its
    three contained values. We've seen that before, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'What on Earth are we doing in the last line of the example? `DemoStruct{ id:
    x, name: y, probability: z }` is a pattern. We''re telling Rust that we expect
    the assigned value to be a `DemoStruct`, and that its contained values should
    in turn be matched with the `x`, `y`, and `z` sub-patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: When we use a variable name as a pattern, it matches any value and that value
    is assigned to that name, which is what is happening here. It's also what's happening
    with a simple `let x = 5`. So, `x`, `y`, and `z` end up being new variables containing
    the values that were previously stored in `source.id`, `source.name`, and `source.probability`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We didn''t have to use variable names for the sub-patterns, though. We could,
    for example, have tried this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we do that, however, the compiler will report an error. The error is not
    because `31` is an invalid pattern. It's a perfectly good pattern and even happens
    to match the value we would actually find. The compiler will refuse to compile
    it, though, because it doesn't match all of the possibilities for the source value,
    and Rust doesn't allow `let` statements that might fail just because a variable's
    value got changed. Imagine of all the trouble that it could cause!
  prefs: []
  type: TYPE_NORMAL
- en: The Rust compiler refers to being able to handle all of the possibilities when
    pattern matching as **covering**.
  prefs: []
  type: TYPE_NORMAL
- en: For patterns that might or might not match the input value, we can use `if let`
    expressions instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using if let expressions to test whether a pattern matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using pattern matching to unpack values into multiple variables can be useful,
    but using pattern matching to make decisions is where this functionality really
    shines, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've defined two more variables containing `DemoStruct` values, and then
    used pattern matching to pull them back apart and assign their contained values
    to individual variables. This time, though, we did it in an `if let` expression
    instead of a `let` expression. That makes a world of difference, because now the
    pattern doesn't have to cover the whole domain of possible input values. If the
    pattern matches, the `if let` expression runs the code in its block. If the pattern
    doesn't match, then the `if let` expression doesn't run the code. It's conditional.
  prefs: []
  type: TYPE_NORMAL
- en: Since the pattern doesn't have to cover the domain, it means we can use `63`
    as a pattern to match against the `id` value, and there's nothing wrong with that.
    The same principle applies to more complex patterns or any pattern that only matches
    a subset of the values that might be represented by the data type it's matched
    against.
  prefs: []
  type: TYPE_NORMAL
- en: We can combine `if let` with normal `if` and `else` expressions, to create more
    complex decision-making structures, in a couple of ways.
  prefs: []
  type: TYPE_NORMAL
- en: First, we can put an `if let` expression inside the block of an `if`, `else
    if`, or `else` expression, and vice versa. That comes naturally, since there's
    nothing unusual about those block expressions—no special restrictions are placed
    on them just because they're inside a conditional expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we can combine `if let` or `else if let` into the same chain of options
    as `if`, `else if`, and `else`. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The chain has to start with an `if` or `if let` expression (whichever one we
    need), and can then have any number of `else if` or `else if let`, and finally
    an `else if` expression we need one.
  prefs: []
  type: TYPE_NORMAL
- en: We're still just pulling data values out of our structures with the pattern
    matching, though. We can do more when the pattern is matched against other kinds
    of data type. An important one is the `Result` data type we've talked about previously.
    Remember that `Result` can be either `Ok` or `Err`, and either way it contains
    a value, either a result value or an error value of some sort. We saw before how
    to use the `?` or assorted functions to deal with `Result`, but we can also handle
    it with pattern matching, and that's often going to be the way we'll choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here''s a function that constructs a `DemoStruct` value for us, but it
    only does it if the `id` value we ask for is even (the remainder when divided
    by two is zero). This function gives us a `Result` containing the created `DemoStruct`
    value or an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then call that function, we can use pattern matching to figure out if
    it succeeded or failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're calling `might_fail` twice, once with an odd number as the parameter
    value, and once with an even one. Both times, we use pattern matching to check
    whether the result is `Ok` and assign the contained value to a variable called
    `x` if it is.
  prefs: []
  type: TYPE_NORMAL
- en: '`Ok` is not a data structure and neither is `Err`. We''ll learn more about
    what they are in the next chapter. The point for now is that pattern matching
    gives us a simple way to check whether `Result` represents a success or a failure,
    and to handle one or both cases easily.'
  prefs: []
  type: TYPE_NORMAL
- en: Using match to choose one of several patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have noticed in our previous example that we did not handle the case
    where the function returned an error value. In part, that''s because handling
    that situation with `if let` is a little bit awkward. We could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But that runs the function twice when it doesn''t have to, so it''s inefficient.
    We could fix that by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's better, but variables are for storing information and we don't really
    need the `result` value anymore once we've checked for the success or failure
    of the function, so there's no reason to keep storing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a `match` expression for situations like this, for the best results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A `match` expression matches a single value (in this case, the result of calling
    `might_fail(39)`) against multiple patterns, until it finds a pattern that successfully
    matches the value, then runs the code block associated with that particular pattern.
    The patterns are matched from top to bottom so, normally, we put the most specific
    patterns first and the most generic patterns last.
  prefs: []
  type: TYPE_NORMAL
- en: Individual patterns in a `match` expression don't have to cover all of the possibilities
    for the value, but all of them together need to. If `Result` had three possibilities
    instead of two (
  prefs: []
  type: TYPE_NORMAL
- en: '`Ok`, `Err`, and a hypothetical `Dunno`, for example), then our previous match
    expression would not compile, because we hadn''t told it what to do in the case
    of `Dunno`.'
  prefs: []
  type: TYPE_NORMAL
- en: That's a difference from a series of `if let` and `el`
  prefs: []
  type: TYPE_NORMAL
- en: '`se if let`, which are free to ignore as many possibilities as they want. If
    we use `match`, the compiler will tell us if we''ve missed a possibility, so we
    should always use `match` when we intend to handle all of the options. On the
    other hand, `if let` is for cherry-picking one or a few special cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Using don't care in patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the trick that variable''s names have of matching any value in a
    pattern would be useful, but we don''t actually need the information that would
    be stored in the variable. For example, we might not care about the error value
    when matching `Result`, just the fact that there was an error. In that situation,
    we can use an `_` symbol to indicate *I don''t care what this value is*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the reason why `_` by itself can not be used as a variable name: it
    has a special meaning of its own. We can match `_` against any data value of any
    data type, even multiple times in the same expression, and the matched values
    will simply be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: Matching a value to `_` does not even move or copy the value. When we tell the
    compiler that we don't care about a value, it believes us. However, there's an
    intermediate level between a full variable and a *don't care.* If we start a variable
    name with an `_` but continue on after that with a valid variable name, the named
    variable isn't a *don't car*e but it *is* exempt from some compiler warnings.
  prefs: []
  type: TYPE_NORMAL
- en: For example, normally, the compiler would warn us if we received a value into
    a variable but then did nothing with it. Putting an `_` at the start of the variable
    name means the compiler will not complain about that. Where `_` by itself means
    *I don't care about this value*, starting a variable name with `_` means *it's
    okay if I don't use this value.*
  prefs: []
  type: TYPE_NORMAL
- en: A common use for that is when we are designing for the future. We might anticipate
    that a function parameter or structure member will be useful in the future, so
    we put it in now, but don't use it yet. If we prefix the name with `_`, the compiler
    won't yell at us about it. Then, when the time comes to actually use it, we remove
    the `_` so we benefit from all of the compiler's checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we used `_` to match against the error value, meaning
    we don''t care what the error value actually is, as long as it''s an error. However,
    `_` can match *anything*, which means we can also do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, the last pattern in our `match` is an `_`, which matches anything while
    capturing no data at all. This is very much like putting `else` at the end of
    an `if` chain. Any match expression containing an `_` pattern automatically covers
    the entire space of possible values, too, which means that, as long as there *is*
    a reasonable fallback action to take when none of the more precise patterns match,
    Rust won't complain to us that we're not covering all of the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if we put a plain `_` pattern anywhere but at the bottom of the
    `match` expression, Rust will warn us. This is a good thing, because any patterns
    under it will never, ever get a chance to match.
  prefs: []
  type: TYPE_NORMAL
- en: Moving and borrowing in pattern matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we match a pattern that contains variables, the matching data values are
    moved into the variables (unless their data type has the `Copy` trait). For example,
    this will cause the compiler to report an error, even though at first glance it
    seems reasonable, especially for people who are used to other programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that, after the `if let`, `source5.name` does not (or at least
    might not) contain a value anymore, because that value was moved to the `x` variable.
    The compiler can't be sure that the final `println!` command will always be valid,
    which is a problem because it happens whether the `if let` block gets run or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we borrow the value in `if let`, instead of moving it? That way, future
    uses of the value would still be valid. The answer is yes, but there''s a problem
    we need to get a handle on. We can try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But what we find is that the compiler complains that it expected `String` in
    the pattern, and found a reference instead. That's because using an `&` in the
    pattern this way doesn't mean we want to borrow the value; it means we expect
    the value to *already be a borrow* in the source data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell Rust that we want to borrow a value that is matched by a variable in
    a pattern, we need to use a new keyword: `ref`. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At last, the compiler is happy, and so are we. The value in `source5.name` is
    not a borrow, but when we match `source5` to our pattern, we borrow it into the
    `x` variable, which means it is *not* moved out of `source5`, and the final `println!`
    will always work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ref` keyword and the `&` symbol are closely related. These two lines of
    code do exactly the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between them is syntactic: we apply the `ref` keyword to the
    variable where the borrow *will be stored*, while we apply the `&` symbol to the
    variable where the value to be borrowed *is already stored*. We choose which one
    to use based on which end of the borrow we''re writing, and we don''t need both.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, using both creates a borrow *of a borrow* of the original value, which
    is not usually what we want. The Rust compiler can automatically dereference any
    number of layers of borrowing in order to find the value it needs for a function
    parameter, so something like this works fine without causing any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The compiler sees that the `borrow_demostruct` function wants a borrow of `DemoStruct`,
    and that the value we're trying to send it is a borrow of a borrow of a `DemoStruct`,
    so it dereferences that value once and passes that to the function parameter.
    Everything works.
  prefs: []
  type: TYPE_NORMAL
- en: '*What does a borrow of a borrow* means? Well, first of all, we had a `DemoStruct`
    value. Then, we borrowed it, giving us an `&DemoStruct` value. Then, we borrowed
    *that* value, giving us an `&&DemoStruct` value.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the computer had to put in a little more effort than was necessary
    to achieve the same result. Multiple levels of borrowing should only be used when
    they solve a problem, because using them when we don't need them is just wasteful.
  prefs: []
  type: TYPE_NORMAL
- en: Also, `&&DemoStruct` is not actually the same data type as `&DemoStruct`, despite
    the fact that the Rust compiler can figure out how to treat the former as the
    latter when it's used as a function parameter. Sometimes, that matters.
  prefs: []
  type: TYPE_NORMAL
- en: Matching tuples and other more complex patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matching simple patterns is very useful, but there's more that we can do. Patterns
    can be more complex, consisting of representations of several layers of nested
    data structures and other data types. Patterns can assign to a variable name while
    still looking deeper into the structure to make sure the contained information
    matches what we want. Or patterns can be simplified, checking only a few parts
    of the data structure and ignoring the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Nested patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use pattern matching to pull a value out of a complex data structure.
    As long as the pattern matches the data value, it doesn''t matter how complex
    the pattern and value are. If we want to match a tuple of tuples and extract one
    particular value from one of the inner tuples, we can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This pattern matches any tuple of three elements, where the second element is
    a nested tuple of four elements, and stores the second element of that nested
    tuple in the `x` variable, then prints out the value of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: We could have been even more specific, and replaced some of those `_` with more
    detailed sub-patterns to match. That would have given us a pattern that paid more
    attention to the first and/or last elements out the outer tuple, or the other
    elements of the inner tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same technique to dig into other data types, too; it''s not
    limited to tuples. For example, earlier we used pattern matching to check whether
    a function had succeeded or failed to run properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In that code, we just match the success value to the `x` variable, but what
    if we wanted to handle things differently depending on the details of the success
    value? We can do that by making the contained value match a more detailed sub-pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a pattern that matches when the function returns a success *and*
    the success values is a `DemoStruct` with the proper ID, a second pattern that
    matches when the function return a success and the success value is a `DemoStruct`
    no matter what the ID is, and a third pattern that matches any error the function
    might return.
  prefs: []
  type: TYPE_NORMAL
- en: The first pattern matches the expected case. If it doesn't match, the second
    pattern matches, allowing us to deal with an unexpected result that is still technically
    reported as a success. If neither of those patterns match, the third one handles
    explicit errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile this example, it works fine, but the compiler warns us that the
    `name:` in the first pattern and the `id:` and `name:` in the second pattern are
    redundant. That''s because, when we are initializing a data structure or data
    structure pattern in Rust, we can leave out the destination name if it''s the
    same as the source name. In other words, the second pattern could have been written
    like `Ok(DemoStruct {ref id, ref name, probability: _})` and Rust still would
    have understood it, because `id` and `name` are the names of two of the structure''s
    contained variables. The redundancy warning is just telling us that we wrote more
    than we needed to.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing a matched value and comparing it to a pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, we either use a variable name to match part of a data value, or we
    use a structural pattern to check that it's the right "shape" and use variable
    names inside that structural pattern to match and extract the parts of it we're
    interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do both at the same time, though, by using the `@` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, here we have a pattern that matches a 3-tuple that has `1` as its first
    item, a 2-tuple as its second item, and anything as its third item, and stores
    the second item (which it has confirmed is a 2-tuple) in a variable called `x`.
    The variable name to store into came before the `@`, and the pattern to check
    the match against came after.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring most of a data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some data structures contains a great many data values, and it would be inconvenient
    to have to go through and list each one of them in each pattern we want to match
    against. Fortunately, Rust has a shorthand syntax that means *everything else
    is a don't care.*
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we can include `..` at the end of the pattern, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That has the same effect as listing out all of the structure's contained variables,
    *except* the ones we've explicitly described in the pattern, and matching each
    one to an `_`.
  prefs: []
  type: TYPE_NORMAL
- en: Gotchas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some seemingly reasonable things we might try to do with pattern matching
    that don't work as we might expect. We're going to take a look at those, and work
    out what they're actually doing and why Rust works that way.
  prefs: []
  type: TYPE_NORMAL
- en: Not all values can be matched against a literal pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all of our examples so far, when we matched `DemoStruct` in a pattern, we
    matched `probability` to a variable or to `_`. That's because `probability` is
    a floating point number, which means that two values that are functionally identical
    might not compare as exactly equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to use a floating-point literal in a pattern (in Rust 1.29), we see
    a warning like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d802e4d9-ae92-440e-be76-4bd0f24fff56.png)'
  prefs: []
  type: TYPE_IMG
- en: It's just a warning but, as the warning says, it's going to become an error
    as Rust evolves. We should treat it as an error, regardless, because the pattern
    will likely not work properly even though it (currently) compiles.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for that, in this case, is that floating point numbers are approximate.
    They have to fit into a finite number of bits, so they have to be rounded sometimes.
    That can result in numbers that should be identical in a purely mathematical sense
    being different because their representations differ in the least significant
    bits. The least significant bits usually make such a tiny difference that rounding
    errors don't much matter, but they can throw off an equality comparison.
  prefs: []
  type: TYPE_NORMAL
- en: The upshot is that if we try to use a literal in a pattern that isn't safe to
    use, Rust will warn us or give us an error. As usual, Rust isn't willing to let
    a potential problem go unremarked.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to do something like this, we can use match guards to work around
    the limitation. We're about to learn about them, so keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Patterns assign values to variable names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we use a variable name in a pattern, it matches any value and the matched
    value is stored in the variable. That means that if we were to try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We do not get a pattern that compares the `source6.id` value to the value of
    `x` (five in this case), we don't get what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we get an error saying that the pattern is irrefutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26141fa5-0377-47e6-b6f0-27d06a006fe6.png)'
  prefs: []
  type: TYPE_IMG
- en: Irrefutable means the pattern will never fail to match, which is a problem in
    an `if let` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try a similar pattern that it is refutable, but still uses the `x` variable,
    the program compiles, but the pattern matches when we didn''t want it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these situations arise because of a rule we already talked about: variable
    names used in patterns match any value, and store the matched value into a new
    variable with the given name. If we think about it, that implies that if there''s
    already a variable with that name, its current value doesn''t matter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That doesn''t mean we''re entirely out of luck, though. We can use an extension
    of the `match` syntax to involve existing variables in the decision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing here is applying a **match guard** to the pattern. We do that
    by putting the `if` keyword after the pattern, but before the `=>`, and following
    it up with a Boolean expression. This lets us add non-pattern matching criteria
    to a match branch. In this case, we're saying that if the pattern matches and the
    ID (stored in `y`) matches the value stored in `x`, we should run that block of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: There has been talk of creating a similar feature for `if let`, but mostly people
    just use nested `if` expressions or `match`.
  prefs: []
  type: TYPE_NORMAL
- en: When we use a match guard, we need to be especially careful that our pattern
    doesn't shadow any variable names we want to use in the guard. That's why, in
    this example, we matched the `id` of `DemoStruct` to a variable named `y` instead
    of `x`. We needed to keep `x` around so our match guard could use it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve seen how to use pattern patching to enhance our ability
    to make decisions and assign variables. In particular, we''ve learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to assign *part* of a data value to a variable by matching the whole value
    to a pattern that matches the part we're interested in to a variable name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `if let` and `else if let` to decide whether a particular branch
    of an `if` chain should run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `match` to check a single value against multiple patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `_` as a *don't care* in patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between a pattern that matches a borrowed value and a pattern
    that borrows a matched value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to match patterns for complex, nested data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surprises that can arise when we use pattern matching, and how to deal with
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll be seeing more pattern matching in the next chapter, when we look at enumerations,
    traits, and trait objects.
  prefs: []
  type: TYPE_NORMAL
