["```rs\nstruct PointU32 \n{\n    x: u32,\n    y: u32\n}\n\nstruct PointF32\n{\n    x: f32,\n    y: f32\n}\n\nstruct PointI32\n{\n    x: i32,\n    y: i32\n}\n```", "```rs\nstruct Point<T>\n{\n    x: T,\n    y: T\n}\n```", "```rs\nfn foo_u32(x: u32) -> u32\n{\n    x*x\n}\n\nfn foo_f32(x: f32) -> f32\n{\n    x*x\n}\n\nfn foo_i32(x: i32) -> i32\n{\n    x*x\n}\n```", "```rs\nfn foo<T>(x: T) -> T\nwhere T: std::ops::Mul<Output=T> + Copy\n{\n    x*x\n}\n```", "```rs\nfn bar<F,T>(f: F, x: T) -> T\nwhere F: Fn(T) -> T\n{\n    f(x)\n}\n```", "```rs\n(0..10).map(|x| x*x);\n```", "```rs\n(0..10).map(|x| {\n    fn f(y: u32) -> u32 {\n        y*y\n    }\n    let z = f(x+1) * f(x+2);\n    z*z\n}\n```", "```rs\nfn f<T>(g: T, x: u32) -> u32\nwhere T: Fn(u32) -> u32\n{\n    g(x+1) * g(x+2)\n}\n\nfn main()\n{\n   f(|x|{ x*x }, 2);\n}\n```", "```rs\n(0..10).map(|x| x*x)\n       .inspect(|x|{ println!(\"value {}\", *x) })\n       .filter(|x| *x<3)\n       .filter_map(|x| Some(x))\n       .fold(0, |x,y| x+y);\n\n```", "```rs\nlet x = {\n    fn f(x: u32) -> u32 {\n        x * x\n    }\n    let y = f(5);\n    y * 3\n};\n```", "```rs\nlet x;\nif true {\n    x = 1;\n} else {\n    x = 2;\n}\n```", "```rs\nlet x = if true { 1 } else { 2 };\n```", "```rs\nstruct MyStruct\n{\n    a: u32,\n    b: f32,\n    c: String\n}\n\nfn main()\n{\n    MyStruct {\n        a: 1,\n        b: 1.0,\n        c: \"\".to_string()\n    };\n\n    (1, 1.0, \"\".to_string());\n}\n```", "```rs\nenum Term\n{\n    TermVal { value: String },\n    TermVar { symbol: String },\n    TermApp { f: Box<Term>, x: Box<Term> },\n    TermAbs { arg: String, body: Box<Term> }\n}\n\nfn main()\n{\n    let mut t = Term::TermVar {\n        symbol: \"\".to_string()\n    };\n    match t {\n        Term::TermVal { value: v1 } => v1,\n        Term::TermVar { symbol: v1 } => v1,\n        Term::TermApp { f: ref v1, x: ref v2 } =>\n            \"TermApp(?,?)\".to_string(),\n        Term::TermAbs { arg: ref mut v1, body: ref mut v2 } =>  \n            \"TermAbs(?,?)\".to_string()\n    };\n}\n```", "```rs\nfn scoped() {\n    vec![1, 2, 3];\n}\n```", "```rs\nfn scoped2() -> Vec<u32>\n{\n    vec![1, 2, 3]\n}\n```", "```rs\nfn scoped3()\n{\n    let v1 = vec![1, 2, 3];\n    let v2 = v1;\n    //it is now illegal to reference v1\n    //ownership has been transferred to v2\n}\n```", "```rs\nfn scoped4()\n{\n    vec![1, 2, 3].clone();\n    \"\".to_string().clone();\n}\n```", "```rs\nfn scoped5()\n{\n   fn foo(v1: &Vec<u32>)\n   {\n       for v in v1\n       {\n           println!(\"{}\", v);\n       }\n   }\n\n   let v1 = vec![1, 2, 3];\n   foo(&v1);\n\n   //v1 is still valid\n   //ownership has been returned\n   v1;\n}\n```", "```rs\nuse std::thread;\n\nfn thread1()\n{\n   let v = vec![1, 2, 3];\n\n   let handle = thread::spawn(move || {\n      println!(\"Here's a vector: {:?}\", v);\n   });\n\n   handle.join().ok();\n}\n\n```", "```rs\nuse std::sync::{Mutex, Arc};\nuse std::thread;\n\nfn thread2()\n{\n\n   let counter = Arc::new(Mutex::new(0));\n   let mut handles = vec![];\n\n   for _ in 0..10 {\n      let counter = Arc::clone(&counter);\n      let handle = thread::spawn(move || {\n         let mut num = counter.lock().unwrap();\n         *num += 1;\n      });\n      handles.push(handle);\n   }\n\n   for handle in handles {\n      handle.join().unwrap();\n   }\n\n   println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```", "```rs\nuse std::thread;\nuse std::sync::mpsc::channel;\n\nfn thread3() {\n\n    let (sender, receiver) = channel();\n    let handle = thread::spawn(move ||{\n\n        //do work\n        let v = vec![1, 2, 3];\n        sender.send(v).unwrap();\n\n    });\n\n    handle.join().ok();\n    receiver.recv().unwrap();\n}\n```", "```rs\n//alias\ntype Name = String;\n\n//newtype\nstruct NewName(String);\n```", "```rs\nstruct Data1\n{\n    a: i32,\n    b: f64,\n    c: String\n}\n\nstruct Data2\n{\n    a: u32,\n    b: String,\n    c: f64\n}\n```", "```rs\n//alias to tuples\ntype Tuple1 = (i32, f64, String);\ntype Tuple2 = (u32, String, f64);\n\n//named tuples\nstruct New1(i32, f64, String);\nstruct New2(u32, String, f64);\n```", "```rs\nuse std::ops::Mul;\n\nstruct Point\n{\n    x: i32,\n    y: i32\n}\n\nimpl Mul for Point\n{\n    type Output = Point;\n    fn mul(self, other: Point) -> Point\n    {\n        Point\n        {\n            x: self.x * other.x,\n            y: self.y * other.y\n        }\n    }\n}\n```", "```rs\nuse std::collections::HashMap;\n\ntype CustomHashMap = HashMap<i32,u32>;\n```", "```rs\nenum BTree<T>\n{\n    Branch { val:T, left:Box<BTree<T>>, right:Box<BTree<T>> },\n    Leaf { val: T }\n}\n```", "```rs\nenum Term\n{\n    TermVal { value: String },\n    TermVar { symbol: String },\n    TermApp { f: Box<Term>, x: Box<Term> },\n    TermAbs { arg: String, body: Box<Term> }\n}\n```", "```rs\ntrait Data1Trait\n{\n    //constructors\n    fn new(a: i32, b: f64, c: String) -> Self;\n\n    //methods\n    fn get_a(&self) -> i32;\n    fn get_b(&self) -> f64;\n    fn get_c(&self) -> String;\n}\n```", "```rs\ntrait BehaviorOfShow\n{\n    fn show(&self) -> String;\n}\n```", "```rs\nstruct MyObject\n{\n    a: u32,\n    b: f32,\n    c: String\n}\n\ntrait MyObjectTrait\n{\n    fn new(a: u32, b: f32, c: String) -> Self;\n    fn get_a(&self) -> u32;\n    fn get_b(&self) -> f32;\n    fn get_c(&self) -> String;\n}\n\nimpl MyObjectTrait for MyObject\n{\n    fn new(a: u32, b: f32, c: String) -> Self\n    {\n        MyObject { a:a, b:b, c:c }\n    }\n\n    fn get_a(&self) -> u32\n    {\n        self.a\n    }\n\n    fn get_b(&self) -> f32\n    {\n        self.b\n    }\n\n    fn get_c(&self) -> String\n    {\n        self.c.clone()\n    }\n}\n```", "```rs\ntrait MyObjectApply\n{\n    fn apply<F,R>(&self, f:F) -> R\n    where F: Fn(u32,f32,String) -> R;\n}\n\nimpl MyObjectApply for MyObject\n{\n    fn apply<F,R>(&self, f:F) -> R\n    where F: Fn(u32,f32,String) -> R\n    {\n        f(self.a, self.b, self.c.clone())\n    }\n}\n```", "```rs\n[package]\nname = \"fp_rust\"\nversion = \"0.0.1\"\n\n```", "```rs\nmod inner_module\n{\n    fn f1()\n    {\n        println!(\"inner module function\");\n    }\n}\n\n```", "```rs\nextern crate package;\nuse package::inner_module::f1;\n```", "```rs\n//trait definitions\n\n//data structure and trait implementations\n\n//functions\n\n//main\n```", "```rs\nfn pure_function1(x: u32) -> u32\n{\n    x * x\n}\n\nfn impure_function(x: u32) -> u32\n{\n    println!(\"x = {}\", x);\n    x * x\n}\n```", "```rs\nlet immutable_v1 = 1;\n//immutable_v1 = 2; //invalid\n\nlet mut mutable_v2 = 1;\nmutable_v2 = 2;\n```", "```rs\nlet fsin = |x: f64| x.sin();\nlet fabs = |x: f64| x.abs();\n\n//feed output of one into the other\nlet transform = |x: f64| fabs(fsin(x));\n```", "```rs\nfn filter<P>(self, predicate: P) -> Filter<Self, P>\nwhere P: FnMut(&Self::Item) -> bool\n{ ... }\n```", "```rs\nlet mut c = 0;\nfor _ in vec!['a', 'b', 'c'].into_iter()\n   .map(|letter| {\n      c += 1; (letter, c)\n   }){};\n```", "```rs\ntrait Monad<A> {\n    fn return_(t: A) -> Self;\n    //:: A -> Monad<A>\n\n    fn bind<MB,B>(m: Self, f: Fn(A) -> MB) -> MB\n    where MB: Monad<B>;\n    //:: Monad<A> -> (A -> Monad<B>) -> Monad<B>\n}\n```", "```rs\nfn not_curried(p1: u32, p2: u32) -> u32\n{\n    p1 + p2\n}\n\nfn main()\n{\n   //and calling it\n   not_curried(1, 2);\n}\n```", "```rs\nfn curried(p1: u32) -> Box<Fn(u32) -> u32>\n{\n    Box::new(move |p2: u32| {\n        p1 + p2\n    })\n}\n\nfn main()\n{\n   //and calling it\n   curried(1)(2);\n}\n```", "```rs\nlet x = { println!(\"side effect\"); 1 + 2 };\n\nlet y = ||{ println!(\"side effect\"); 1 + 2 };\n```", "```rs\n#[macro_use] extern crate cached;\n#[macro_use] extern crate lazy_static;\n\ncached! {\n    FIB;\n    fn fib(n: u64) -> u64 = {\n        if n==0 || n==1 { return n }\n        fib(n-1) + fib(n-2)\n    }\n}\n\nfn main()\n{\n   fib(30);\n}\n```", "```rs\nvec![\"this is a macro\", 1, 2];\n```", "```rs\nmacro_rules! my_vec_macro\n{\n    ( $( $x:expr ),* ) =>\n    {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    }\n}\n```", "```rs\n//this\nmy_vec_macro!(1, 2, 3);\n\n//is the same as this\n{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n```", "```rs\nmacro_rules! my_macro_branch\n{\n    (1 $e:expr) => (println!(\"mode 1: {}\", $e));\n    (2 $e:expr) => (println!(\"mode 2: {}\", $e));\n}\n\nfn main()\n{\n    my_macro_branch!(1 \"abc\");\n    my_macro_branch!(2 \"def\");\n}\n\n```", "```rs\nenum DSLTerm {\n    TVar { symbol: String },\n    TAbs { param: String, body: Box<DSLTerm> },\n    TApp { f: Box<DSLTerm>, x: Box<DSLTerm> }\n}\n\nmacro_rules! dsl\n{\n    ( ( $($e:tt)* ) ) => (dsl!( $($e)* ));\n    ( $e:ident ) => (DSLTerm::TVar {\n        symbol: stringify!($e).to_string()\n    });\n    ( fn $p:ident . $b:tt ) => (DSLTerm::TAbs {\n        param: stringify!($p).to_string(),\n        body: Box::new(dsl!($b))\n    });\n    ( $f:tt $x:tt ) => (DSLTerm::TApp {\n        f: Box::new(dsl!($f)),\n        x: Box::new(dsl!($x))\n    });\n} \n```", "```rs\n#![crate_type = \"proc-macro\"]\nextern crate proc_macro;\nextern crate syn;\n#[macro_use]\nextern crate quote;\nuse proc_macro::TokenStream;\n#[proc_macro_derive(TypeName)]\n\npub fn type_name(input: TokenStream) -> TokenStream\n{\n    // Parse token stream into input AST\n    let ast = syn::parse(input).unwrap();\n    // Generate output AST\n    impl_typename(&ast).into()\n}\n\nfn impl_typename(ast: &syn::DeriveInput) -> quote::Tokens\n{\n    let name = &ast.ident;\n    quote!\n    {\n        impl TypeName for #name\n        {\n            fn typename() -> String\n            {\n                stringify!(#name).to_string()\n            }\n        }\n    }\n}\n```", "```rs\n#[macro_use]\nextern crate metaderive;\n\npub trait TypeName\n{\n    fn typename() -> String;\n}\n\n#[derive(TypeName)]\nstruct MyStructA\n{\n    a: u32,\n    b: f32\n}\n```"]