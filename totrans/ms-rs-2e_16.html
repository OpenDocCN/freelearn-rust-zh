<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building Desktop Applications with Rust</h1>
                </header>
            
            <article>
                
<p>If your software only supports a terminal or command-line-based interface, your target audience is likely limited to only people who know how to use the command line. Providing a <strong>Graphical User Interface</strong> (<strong>GUI</strong>) for your software widens your target audience and gives users a friendly and intuitive interface so that they can use the software effortlessly. For building GUIs, most languages provide frameworks that consist of several native libraries that are composed together and can access the graphics and the I/O interfaces of the platform. This enables developers to easily build GUIs for their applications without worrying about the low-level details.</p>
<p>There are quite a few popular GUI frameworks targeting desktop platforms such as Qt, GTK+, and ImGUI, which are available for mainstream languages. At the time of writing this book, Rust doesn't have a mature ecosystem of GUI frameworks, but fortunately we have the convenient FFI mechanism through which it can piggyback onto the native GUI frameworks provided by languages such as C/C++. In this chapter, we'll go through one such crate that provides native bindings to the GTK+ framework for doing GUI development and build our own<em> </em>news reading desktop app.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to GUI development</li>
<li>GTK+ framework and the <kbd>gtk</kbd> crate</li>
<li>Building a hacker news desktop app in Rust</li>
<li>Other emerging frameworks</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to GUI development</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"In programming, the hard part isn't about solving problems, but deciding what problems to solve."</div>
<p class="CDPAlignRight CDPAlign"><span>– <em>Paul Graham</em></span></p>
<p>The advent of GUI-based software started with GUI operating systems. The first GUI operating system was the Alto Executive, which ran on the Xerox Alto computer that was developed in 1973. Since then, many operating systems followed suit and came with their own GUI-based interface. Today, the most famous GUI-based operating systems are macOS, Windows, and Linux-based distributions such as Ubuntu and KDE. With users interacting with the OS via a visual point and click interface, demand for GUI-based applications increased and a lot of software started shipping with GUIs to provide users with a visual way of interacting with their software, similar to how they do with their OS. But the early days of GUI development were a lot of manual work and due to hardware constraints, different applications had specialized implementations and performance characteristics in their GUIs. Eventually, GUI frameworks started to proliferate, which provided developers with a common baseline and an abstraction layer from all the low-level details of the underlying OS, while also being cross-platform.</p>
<p>Before we build our app, it is important for us to have a brief idea about the general design guidelines that are followed in integrating a GUI or a frontend to an application. We'll be focusing our discussion from a Linux OS perspective, but there are similarities in the ideas on other platforms, too. A typical GUI application architecture is usually split into two components: the frontend and the backend. The frontend is the GUI thread or the main thread that the user interacts with. It is composed of interactive visual units called <strong>widgets</strong> that are contained in a parent container window. An example of a widget is a button that you click to perform a task, or a list view that can display multiple items in sequence. The GUI thread is mainly concerned with presenting visual information to the user and is also responsible for propagating any event that occurs when the user interacts with the widgets.</p>
<p>The backend is a separate thread and contains event handlers or event emitters for propagating state changes, and is mainly used for performing compute heavy tasks. Processing inputs from the GUI layer is often offloaded to background threads as performing compute heavy tasks on the main thread blocks the user from interacting with the application frontend, which is not a good user experience. Also, for maintainability and separation of concerns, it is often desirable that we keep the frontend and the backend separate.</p>
<p>Building a GUI-based application without a dedicated framework can be a very cumbersome process, as without them we might need to handle a lot of details in our application code. GUI frameworks abstract all the details for the developer, such as drawing the widgets and the windows to the video memory or GPU's frame buffer, reading events from input devices, re-drawing and refreshing windows, and much more. With that said, let's look at one such framework called the Gimp toolkit or GTK+, which is a very mature and cross-platform solution for building scalable GUI applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GTK+ framework</h1>
                </header>
            
            <article>
                
<p>GTK+ (hereafter gtk) is a cross-platform GUI framework that was created in C. Being cross-platform, applications that are developed using gtk can run on all major platforms, such as Windows, Linux, or MacOS<em>.</em> The gtk project was originally created to develop GIMP, image manipulation software for Linux, and was later open sourced. gtk is also used by many other software projects, such as the Gnome desktop environment on many Linux distributions, which uses it for building its utility software. Architecture-wise, gtk is composed of several libraries that work together to handle various details that are needed to render and facilitate interaction with windows and widgets by the user in the application. Some of these components are as follows:</p>
<ul>
<li class="c2"><strong><span class="c4">GLib</span></strong>: This is<span class="c0"> the basic core library and provides several data structures, wrappers for portability, and interfaces for runtime functionality such as the event loop, thread support, dynamic loading, and an object system. Glib itself is composed of components such as <strong>GObject</strong>, which provides an object model, and <strong>GIO</strong>, which provides high-level abstractions for I/O<strong>.</strong></span></li>
<li class="c2"><strong><span class="c4">Pango</span></strong><span class="c4">: Pango is a library that provides</span> <span class="c0">text rendering and internationalization capabilities.</span></li>
<li class="c2"><strong>Cairo</strong>:<span class="c0"> This is a 2D graphics library that takes care of drawing things on-screen and, tries to be as consistent across multiple devices, and handles details such as hardware acceleration.</span></li>
<li class="c2"><strong><span class="c4">ATK</span></strong><span class="c0">: ATK is the accessibility toolkit library that takes care of providing accessibility to input devices such as screen readers, magnifiers, and alternative input devices.</span></li>
</ul>
<p>gtk also has an interface builder called <strong>Glade</strong>, which generates a gtk source code skeleton for rapid application development.</p>
<p>gtk uses the object-oriented model for representing widgets and windows. It leverages the GObject library to provide this abstraction. To use the gtk framework from Rust, we have the gtk-rs project, which contains many crates that follow the same naming convention as libraries that exist in gtk and provides native C bindings to these libraries. Among all the crates that the gtk-rs project contains, we'll be using the <kbd>gtk</kbd> crate to build our app.</p>
<p>The <kbd>gtk</kbd> crate provides the window and widget system for building GUIs and tries to model the same API as the native C library, though there are differences as Rust does not have an object-oriented type system. Widgets in the <kbd>gtk</kbd> crate are smart pointer types. To allow for flexibility when using the API, you can have many mutable references, similar to the one provided by interior mutability in Rust. Any non-trivial widget in <kbd>gtk</kbd> inherits from some base widget type. Rust supports this inheritance in widgets via the <kbd>IsA&lt;T&gt;</kbd> trait. For instance, the <kbd>gtk::Label</kbd> widget has an <kbd>impl</kbd> of <kbd>impl IsA&lt;Widget&gt; for Label</kbd>. Also, most widgets in <kbd>gtk</kbd> share functionality with each other—the <kbd>gtk</kbd> crate implements this with the idea of extension traits, such as the <kbd>WidgetExt</kbd> trait, for all widget types. Most widgets such as <kbd>gtk::Button</kbd> and <kbd>gtk::ScrollableWindow</kbd> implement the <kbd>WidgetExt</kbd> trait. A widget can also be downcast or upcast to other widgets in its hierarchy using the <kbd>Cast</kbd> trait. With that brief introduction aside, let's get into writing a desktop app in Rust.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a hacker news app using gtk-rs</h1>
                </header>
            
            <article>
                
<p>We'll use the <kbd>gtk</kbd> crate to build a simple hacker news app that fetches the top 10 trending stories from the <a href="https://news.ycombinator.com/">https://news.ycombinator.com/</a> website. Hacker News <span>is a website focusing on digital technologies and tech news from around the world.</span> To start with, we have created a basic wireframe model of our app:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/49b70584-a277-4793-8126-dc4419548ec4.png" style="width:25.08em;height:18.50em;"/></p>
<p class="mce-root"/>
<p>At the very top, we have the app header bar, which has a <span class="packt_screen">Refresh</span> button on the left that can update our stories on demand. A story is a news entry that's posted by users on the Hacker News website. The header bar also contains the app title at the center and the usual window controls on the right. Below that, we have our main scrollable window where our stories will be rendered vertically as a story widget. The story widget is made up of two widgets: a widget for displaying the story's name and its score, and another for rendering a link to the story that can be clicked on in the user's default browser. Pretty simple!</p>
<div class="packt_infobox"><strong>Note</strong>: As we are using the <kbd>gtk</kbd> crate, which binds to native C libraries, we need to install the developmental C libraries for the gtk framework. For Ubuntu and Debian platforms, we can install these dependencies by running the following:</div>
<pre><strong>sudo apt-get install libgtk-3-dev</strong></pre>
<p>Please refer to the gtk-rs documentation page at <a href="http://gtk-rs.org/docs/requirements.html">http://gtk-rs.org/docs/requirements.html</a> for information on setting gtk up on other platforms.</p>
<p>To start things off, we'll create a new cargo project by running <kbd>cargo new hews</kbd>. We have creatively named our app <strong>Hews</strong>, which is short for <strong>H</strong> in hacker + <strong>ews</strong> from news.</p>
<p>The following are the dependencies that we'll need in our <kbd>Cargo.toml</kbd> file:</p>
<pre># hews/Cargo.toml<br/><br/>[dependencies]<br/>gtk = { version = "0.3.0", features = ["v3_18"] }<br/>reqwest = "0.9.5"<br/>serde_json = "1.0.33"<br/>serde_derive = "1.0.82"<br/>serde = "1.0.82"</pre>
<p>We are using a bunch of crates here:</p>
<ul>
<li><kbd>gtk</kbd>: This is used to build the GUI of the app. We use the bindings for gtk version <kbd>3.18</kbd> here.</li>
<li><kbd>reqwest</kbd><span>: This is used for fetching stories from the Hacker News API. <kbd>reqwest</kbd> is a high-level wrapper over the</span> <kbd>hyper</kbd> <span>crate. We are using the <kbd>reqwest</kbd> synchronous API for simplicity.</span></li>
<li><kbd>serde_json</kbd><span>: This is used for seamlessly converting the fetched JSON response from the network to a strongly typed</span> <kbd>Story</kbd> <span><span>struct.</span></span></li>
<li><kbd>serde</kbd><span>,</span> <kbd>serde_derive</kbd><span>: These provide traits and implementations for automatically deriving serialization code for built-in Rust types. By using the </span><kbd>Serialize</kbd><span> and </span><kbd>Deserialize</kbd> <span>traits from</span> <kbd>serde_derive</kbd><span>, we can serialize and deserialize any native Rust type into a given format. </span><kbd>serde_json</kbd> <span>relies on the same functionality to convert a</span> <kbd>serde_json::Value</kbd> <span>type into a Rust type.</span></li>
</ul>
<p>To show news articles in our app, we'll fetch them by making HTTP requests to the official hacker news API, which is documented at <a href="https://github.com/HackerNews/API">https://github.com/HackerNews/API</a>. We have divided our app into two modules. First, we have the <kbd>app</kbd> module, which contains all the UI-related functionality for rendering the app on-screen and handling UI state updates from the user. Second, we have the <kbd>hackernews</kbd> module, which provides APIs for fetching stories from the network. It runs in a separate thread so not block the GUI thread when network requests happen, which is a blocking I/O operation. From the hacker news API, a story is an item containing a news title and a link to the news, along with other properties such as how popular the story is and a list of comments on the story.</p>
<div class="packt_infobox">To make this example simpler and easier to follow, our app does not have proper error handling and includes many <kbd>unwrap()</kbd> calls, which is a bad practice from an error handling perspective. After you are done exploring the demo, you are encouraged to integrate a better error handling strategy in the app. With that said, let's go through the code step by step.</div>
<p>First, we'll look at the entry point of our app in <kbd>main.rs</kbd>:</p>
<pre>// hews/src/main.rs<br/><br/>mod app;<br/>mod hackernews;<br/>use app::App;<br/><br/>fn main() {<br/>    let (app, rx) = App::new();<br/>    app.launch(rx);<br/>}</pre>
<p>In our <kbd>main</kbd> function, we call <kbd>App::new()</kbd>, which returns an <kbd>App</kbd> instance, along with <kbd>rx</kbd>, which is a <kbd>mpsc::Receiver</kbd>. To keep our GUI decoupled from network requests, all state updates in hews are handled asynchronously via channels. The <kbd>App</kbd> instance internally invokes <kbd>mpsc::channel()</kbd>, giving back <kbd>tx</kbd> and <kbd>rx</kbd>. It stores the <kbd>tx</kbd> with it and also passes it to the network thread, allowing it to notify the UI of any new story. Following the <kbd>new</kbd> method call, we invoke <kbd>launch</kbd> on <kbd>app</kbd>, passing in the <kbd>rx</kbd>, which is used to listen for events from the network thread in the GUI thread.</p>
<p>Next, let's go through our <kbd>app</kbd> module in the <kbd>app.rs</kbd> module, which handles most of the orchestration needed to render our app on-screen.</p>
<div class="packt_infobox">If you want to find out more about the widget explanation that follows, look for gtk-rs's excellent documentation at <a href="https://gtk-rs.org/docs/gtk/">https://gtk-rs.org/docs/gtk/</a>, where you can search for any widget and explore more about its properties.</div>
<p>First, we have our <kbd>App</kbd> struct, which is the entry point for all things GUI:</p>
<pre>// hews/src/app.rs<br/><br/>pub struct App {<br/>    window: Window,<br/>    header: Header,<br/>    stories: gtk::Box,<br/>    spinner: Spinner,<br/>    tx: Sender&lt;Msg&gt;,<br/>}</pre>
<p>This struct contains a bunch of fields:</p>
<ul>
<li><kbd>window</kbd>: This contains the base <kbd>gtk::Window</kbd> widget. Every gtk application starts with a window to which we can add child widgets in different layouts to design our GUI.</li>
<li><kbd>header</kbd>: This is a struct that's defined by us and wraps a <kbd>gtk::HeaderBar</kbd> widget, which acts as the title bar for our app window.</li>
<li><kbd>stories</kbd>: This is a container <kbd>gtk::Box</kbd> widget that will store our stories vertically.</li>
<li><kbd>spinner</kbd>: This is a <kbd>gtk::Spinner</kbd> widget that provides a visual cue for loading stories.</li>
<li><kbd>tx</kbd>: This is an mpsc <kbd>Sender</kbd> to send events from the GUI to the network thread. The messages are of type <kbd>Msg</kbd>, which is an enum:</li>
</ul>
<pre style="padding-left: 60px">pub enum Msg {<br/>            NewStory(Story),<br/>            Loading,<br/>            Loaded,<br/>            Refresh,<br/>        }</pre>
<p>Our app starts with the initial state as <kbd>Loading</kbd> when the <kbd>fetch_posts</kbd> method is called from the <kbd>hackernews</kbd> module. We'll see that later. <kbd>NewStory</kbd> is the state that occurs when a new story is fetched. <kbd>Loaded</kbd> is the state that occurs when all of the stories are loaded and <kbd>Refresh</kbd> is sent when the user wants to reload the stories.</p>
<p>Let's move on to the methods on the <kbd>App</kbd> struct. Here's our <kbd>new</kbd> method:</p>
<pre>impl App {<br/>    pub fn new() -&gt; (App, Receiver&lt;Msg&gt;) {<br/>        if gtk::init().is_err() {<br/>            println!("Failed to init hews window");<br/>            process::exit(1);<br/>        }</pre>
<p>The <kbd>new</kbd> method first starts the gtk event loop using <kbd>gtk::init()</kbd>. If that fails, we exit, printing a message to the console:</p>
<pre>        let (tx, rx) = channel();<br/>        let window = gtk::Window::new(gtk::WindowType::Toplevel);<br/>        let sw = ScrolledWindow::new(None, None);<br/>        let stories = gtk::Box::new(gtk::Orientation::Vertical, 20);<br/>        let spinner = gtk::Spinner::new();<br/>        let header = Header::new(stories.clone(), tx.clone());</pre>
<p>Then, we create our <kbd>tx</kbd> and <kbd>rx</kbd> channel endpoints for communicating between the network thread and the GUI thread. Next, we create our <kbd>window</kbd>, which is a <kbd>TopLevel</kbd> window. Now, multiple stories might not fit into our app window if the window is resized, so we need a scrollable window here. For that, we will create a <kbd>ScrolledWindow</kbd> instance as <kbd>sw</kbd>. However, a gtk <kbd>ScrolledWindow</kbd> accepts only a single child within it and we need to store multiple stories, which is a problem. Fortunately, we can use the <kbd>gtk::Box</kbd> type, which is a generic container widget that's used to lay out and organize child widgets. Here, we create a <kbd>gtk::Box</kbd> instance as <kbd>stories</kbd> with the <kbd>Orientation::Vertical</kbd> orientation so that each of our stories renders vertically on top of each other. We also want to show a spinner at the top of our scroll widget when the stories are being loaded, so we will create a <kbd>gtk::Spinner</kbd> widget and add it to <kbd>stories</kbd> to render it at the very top. We will also create our <kbd>Header</kbd> bar and pass a reference to <kbd>stories</kbd> as well as <kbd>tx</kbd>. Our header contains the refresh button and has a click handler, which needs the <kbd>stories</kbd> container to clear items within it, allowing us to load new stories:</p>
<pre>        stories.pack_start(&amp;spinner, false, false, 2);<br/>        sw.add(&amp;stories);<br/>        window.add(&amp;sw);<br/>        window.set_default_size(600, 350);<br/>        window.set_titlebar(&amp;header.header);</pre>
<p>Next, we start composing our widgets. First, we add the <kbd>spinner</kbd> to <kbd>stories</kbd>. Then, we add the <kbd>stories</kbd> container widget to our scroll widget, <kbd>sw</kbd>, which is then added to our parent <kbd>window</kbd>. We also set the <kbd>window</kbd> size with <kbd>set_default_size</kbd>. We then set its title bar with <kbd>set_titlebar</kbd>, passing in our <kbd>header</kbd>. Following that, we attach a signal handler to our window:</p>
<pre>        window.connect_delete_event(move |_, _| {<br/>            main_quit();<br/>            Inhibit(false)<br/>        });</pre>
<p>This will quit the app if we call <kbd>main_quit()</kbd>. The <kbd>Inhibit(false)</kbd> return type does not stop the signal from propagating to the default handler for <kbd>delete_event</kbd>. All widgets have a default signal handler. The signal handlers on the widgets in the gtk crate follow the naming convention of <kbd>connect_&lt;event&gt;</kbd> and take in a closure with the widget as their first parameter and the event object.</p>
<p>Next, let's look at the <kbd>launch</kbd> method on <kbd>App</kbd>, which is called in <kbd>main.rs</kbd>:</p>
<pre>    pub fn launch(&amp;self, rx: Receiver&lt;Msg&gt;) {<br/>        self.window.show_all();<br/>        let client = Arc::new(reqwest::Client::new());<br/>        self.fetch_posts(client.clone());<br/>        self.run_event_loop(rx, client);<br/>    }</pre>
<p>First, we enable the <kbd>window</kbd> widget, along with its child widgets. We make them visible by calling the <kbd>show_all</kbd> method as widgets in gtk are invisible by default. Next, we create our HTTP <kbd>Client</kbd> and wrap it in an <kbd>Arc</kbd> as we want to share it with our network thread. We then call <kbd>fetch_posts</kbd>, passing our client. Following that, we run our event loop by calling <kbd>run_event_loop</kbd>, passing in <kbd>rx</kbd>. The <kbd>fetch_posts</kbd> method is defined like so:</p>
<pre>    fn fetch_posts(&amp;self, client: Arc&lt;Client&gt;) {<br/>        self.spinner.start();<br/>        self.tx.send(Msg::Loading).unwrap();<br/>        let tx_clone = self.tx.clone();<br/>        top_stories(client, 10, &amp;tx_clone);<br/>    }</pre>
<p>It starts our spinner animation by calling its <kbd>start</kbd> method, and sends the <kbd>Loading</kbd> message as the initial state. It then calls the <kbd>top_stories</kbd> function from the <kbd>hackernews</kbd> module, passing <kbd>10</kbd> as the number of stories to fetch and a <kbd>Sender</kbd> to notify the GUI thread of new stories.</p>
<p>After calling <kbd>fetch_posts</kbd>, we call the <kbd>run_event_loop</kbd> method on <kbd>App</kbd>, which is defined like so:</p>
<pre>    fn run_event_loop(&amp;self, rx: Receiver&lt;Msg&gt;, client: Arc&lt;Client&gt;) {<br/>        let container = self.stories.clone();<br/>        let spinner = self.spinner.clone();<br/>        let header = self.header.clone();<br/>        let tx_clone = self.tx.clone();<br/><br/>        gtk::timeout_add(100, move || {<br/>            match rx.try_recv() {<br/>                Ok(Msg::NewStory(s)) =&gt; App::render_story(s, &amp;container),<br/>                Ok(Msg::Loading) =&gt; header.disable_refresh(),<br/>                Ok(Msg::Loaded) =&gt; {<br/>                    spinner.stop();<br/>                    header.enable_refresh();<br/>                }<br/>                Ok(Msg::Refresh) =&gt; {<br/>                    spinner.start();<br/>                    spinner.show();<br/>                    (&amp;tx_clone).send(Msg::Loading).unwrap();<br/>                    top_stories(client.clone(), 10, &amp;tx_clone);<br/>                }<br/>                Err(_) =&gt; {}<br/>            }<br/>            gtk::Continue(true)<br/>        });<br/><br/>        gtk::main();<br/>    }</pre>
<p>First, we get references to a bunch of objects that we'll use. Following that, we call <kbd>gtk::timeout_add</kbd>, which runs the given closure every 100 milliseconds. Within the closure, we poll on <kbd>rx</kbd> in a non-blocking way using <kbd>try_recv()</kbd> for events from the network or GUI thread. When we get a <kbd>NewStory</kbd> message, we call <kbd>render_story</kbd>. When we receive a <kbd>Loading</kbd> message, we disable the refresh button. In the case of the <kbd>Loaded</kbd> message, we stop our spinner and enable the refresh button so that the user can reload stories again. Finally, in the case of receiving a <kbd>Refresh</kbd> message, we start the spinner again and send the <kbd>Loading</kbd> message to the GUI thread itself, followed by calling the <kbd>top_stories</kbd> method.</p>
<p>Our <kbd>render_story</kbd> method is defined as follows:</p>
<pre>    fn render_story(s: Story, stories: &amp;gtk::Box) {<br/>        let title_with_score = format!("{} ({})", s.title, s.score);<br/>        let label = gtk::Label::new(&amp;*title_with_score);<br/>        let story_url = s.url.unwrap_or("N/A".to_string());<br/>        let link_label = gtk::Label::new(&amp;*story_url);<br/>        let label_markup = format!("&lt;a href=\"{}\"&gt;{}&lt;/a&gt;", story_url, story_url);<br/>        link_label.set_markup(&amp;label_markup);<br/>        stories.pack_start(&amp;label, false, false, 2);<br/>        stories.pack_start(&amp;link_label, false, false, 2);<br/>        stories.show_all();<br/>    }</pre>
<p>The <kbd>render_story</kbd> method gets the <kbd>Story</kbd> instance as <kbd>s</kbd> and the <kbd>stories</kbd> container widget as arguments before creating two labels: <kbd>title_with_score</kbd>, which holds the story title along with its score, and <kbd>link_label</kbd>, which holds the link to the story. For the <kbd>link_label</kbd>, we will add a custom markup that contains an <kbd>&lt;a&gt;</kbd> tag with the URL. Finally, we put both these labels onto our <kbd>stories</kbd> container and call <kbd>show_all</kbd> at the end to make those labels visible on the screen.</p>
<p>Our <kbd>Header</kbd> struct and its methods, which we mentioned previously, are part of the <kbd>App</kbd> struct and are as follows:</p>
<pre class="mce-root">// hews/src/app.rs<br/><br/>#[derive(Clone)]<br/>pub struct Header {<br/>    pub header: HeaderBar,<br/>    pub refresh_btn: Button<br/>}<br/><br/>impl Header {<br/>    pub fn new(story_container: gtk::Box, tx: Sender&lt;Msg&gt;) -&gt; Header {<br/>        let header = HeaderBar::new();<br/>        let refresh_btn = gtk::Button::new_with_label("Refresh");<br/>        refresh_btn.set_sensitive(false);<br/>        header.pack_start(&amp;refresh_btn);<br/>        header.set_title("Hews - popular stories from hacker news");<br/>        header.set_show_close_button(true);<br/><br/>        refresh_btn.connect_clicked(move |_| {<br/>            for i in story_container.get_children().iter().skip(1) {<br/>                story_container.remove(i);<br/>            }<br/>            tx.send(Msg::Refresh).unwrap();<br/>        });<br/><br/>        Header {<br/>            header,<br/>            refresh_btn<br/>        }<br/>    }<br/><br/>    fn disable_refresh(&amp;self) {<br/>        self.refresh_btn.set_label("Loading");<br/>        self.refresh_btn.set_sensitive(false);<br/>    }<br/><br/>    fn enable_refresh(&amp;self) {<br/>        self.refresh_btn.set_label("Refresh");<br/>        self.refresh_btn.set_sensitive(true);<br/>    }<br/>}</pre>
<p>This struct contains the following fields:</p>
<ul>
<li><kbd>header</kbd>: A gtk <kbd>HeaderBar</kbd>, which is like a horizontal gtk <kbd>Box</kbd> that's suitable for title bars for a window</li>
<li><kbd>refresh_btn</kbd>: A gtk <kbd>Button</kbd> that is used to reload stories on demand</li>
</ul>
<p><kbd>Header</kbd> also has three methods:</p>
<ul>
<li><kbd>new</kbd>: This creates a new <kbd>Header</kbd> instance. Within the new method, we create a new gtk <kbd>HeaderBar</kbd>, set its close button to show, and add a title. Then, we create a Refresh button and attach a click handler to it using the <kbd>connect_clicked</kbd> method, which takes in a closure. Within this closure, we iterate over all of the children of the scrolled window container, which are passed to this method as <kbd>story_container</kbd>. However, we skip the first one because the first widget is a <kbd>Spinner</kbd> and we want to keep it across multiple reloads to show its progress.</li>
<li><kbd>disable_refresh</kbd>: This disables the refresh button, setting its sensitivity to <kbd>false</kbd>.</li>
<li><kbd>enable_refresh</kbd>: This enables the refresh button, setting its sensitivity to <kbd>true</kbd>.</li>
</ul>
<p>Next, let's go through our <kbd>hackernews</kbd> module, which does all the heavy lifting of getting the stories as json from the API endpoint and parsing it as a <kbd>Story</kbd> instance using <kbd>serde_json</kbd>. Here's the first piece of content of <kbd>hackernews.rs</kbd>:</p>
<pre>// hews/src/hackernews.rs<br/><br/>use crate::app::Msg;<br/>use serde_json::Value;<br/>use std::sync::mpsc::Sender;<br/>use std::thread;<br/>use serde_derive::Deserialize;<br/><br/>const HN_BASE_URL: &amp;str = "https://hacker-news.firebaseio.com/v0/";<br/><br/>#[derive(Deserialize, Debug)]<br/>pub struct Story {<br/>    pub by: String,<br/>    pub id: u32,<br/>    pub score: u64,<br/>    pub time: u64,<br/>    pub title: String,<br/>    #[serde(rename = "type")]<br/>    pub _type: String,<br/>    pub url: Option&lt;String&gt;,<br/>    pub kids: Option&lt;Value&gt;,<br/>    pub descendents: Option&lt;u64&gt;,<br/>}</pre>
<p>First, we have a declaration of the base URL endpoint, <kbd>HN_BASE_URL</kbd>, for the hackernews API that's hosted on firebase. Firebase is a real-time database from Google. Then, we have the <kbd>Story</kbd> struct declaration, annotated with the <kbd>Deserialize</kbd> and <kbd>Debug</kbd> traits. The <kbd>Deserialize</kbd> trait comes from the <kbd>serde_derive</kbd> crate, which provides a derive macro to convert any value into a native Rust type. We need it because want to be able to parse the incoming json reply from the network as a <kbd>Story</kbd> struct.</p>
<p>The <kbd>Story</kbd> struct contains the same fields as the ones that are found in the json reply from the stories endpoint. For more information on the json structure, refer to <a href="https://github.com/HackerNews/API#items">https://github.com/HackerNews/API#items</a>. Also, among all our fields in the <kbd>Story</kbd> struct, we have one field named <kbd>type</kbd>. However, <kbd>type</kbd> is also a keyword in Rust for declaring type aliases and it's invalid for <kbd>type</kbd> to be a field of a struct, so we will name it <kbd>_type</kbd> instead. However, this wouldn't parse as our json reply as a field named <kbd>type</kbd>. To solve this conflict, <kbd>serde</kbd> provides us with a field-level attribute to allow us to parse values, even in the case of such conflicts when using the <kbd>#[serde(rename = "type")]</kbd> attribute on the field. The value of <kbd>rename</kbd> should match whatever the value is in the incoming json response's field name. Next, let's look at the set of methods that are provided by this module:</p>
<pre>// hews/src/hackernews.rs<br/><br/>fn fetch_stories_parsed(client: &amp;Client) -&gt; Result&lt;Value, reqwest::Error&gt; {<br/>    let stories_url = format!("{}topstories.json", HN_BASE_URL);<br/>    let body = client.get(&amp;stories_url).send()?.text()?;<br/>    let story_ids: Value = serde_json::from_str(&amp;body).unwrap();<br/>    Ok(story_ids)<br/>}<br/><br/>pub fn top_stories(client: Arc&lt;Client&gt;, count: usize, tx: &amp;Sender&lt;Msg&gt;) {<br/>    let tx_clone = tx.clone();<br/>    thread::spawn(move || {<br/>        let story_ids = fetch_stories_parsed(&amp;client).unwrap();<br/>        let filtered: Vec&lt;&amp;Value&gt; = story_ids.as_array()<br/>                                             .unwrap()<br/>                                             .iter()<br/>                                             .take(count)<br/>                                             .collect();<br/><br/>        let loaded = !filtered.is_empty();<br/><br/>        for id in filtered {<br/>            let id = id.as_u64().unwrap();<br/>            let story_url = format!("{}item/{}.json", HN_BASE_URL, id);<br/>            let story = client.get(&amp;story_url)<br/>                              .send()<br/>                              .unwrap()<br/>                              .text()<br/>                              .unwrap();<br/>            let story: Story = serde_json::from_str(&amp;story).unwrap();<br/>            tx_clone.send(Msg::NewStory(story)).unwrap();<br/>        }<br/><br/>        if loaded {<br/>            tx_clone.send(Msg::Loaded).unwrap();<br/>        }<br/>    });<br/>}</pre>
<p>Our only public function that's been exposed by this module is <kbd>top_stories</kbd>. This function takes a reference to <kbd>Client</kbd>, which comes from the <kbd>reqwest</kbd> crate, then a <kbd>count</kbd> parameter specifying how many stories to retrieve, and a <kbd>Sender</kbd> instance <kbd>tx</kbd>, which can send messages of type <kbd>Msg</kbd>, an enum. <kbd>tx</kbd> is used to communicate to the GUI thread about the state of our network request. Initially, the GUI starts in the <kbd>Msg::Loading</kbd> state, which keeps the refresh button disabled.</p>
<p>Within this function, we first clone our copy of the <kbd>tx</kbd> sender and then spawn a thread where we'll use this <kbd>tx</kbd>. We spawn a thread so not to block the UI thread when the network request is in progress. Within the closure, we call <kbd>fetch_stories_parsed()</kbd>. In this method, we first construct our <kbd>/top_stories.json</kbd> endpoint by concatenating it with <kbd>HN_BASE_URL</kbd> using the <kbd>format!</kbd> macro. We then make a request to the constructed endpoint to get a list of all stories. We call the <kbd>text()</kbd> method to convert the response into a json string. The returned json response is a list of story IDs, each of which can be used to make another set of requests, which gives us detailed information on the story as another json object. We then parse this response using <kbd>serde_json::from_str(&amp;body)</kbd>. This gives us a <kbd>Value</kbd> enum value, which is a parsed json array containing a list of story IDs.</p>
<p>So, once we have the story IDs stored in <kbd>story_ids</kbd>, we explicitly convert it into an array by calling <kbd>as_array()</kbd> and then we <kbd>iter()</kbd> on it and limit the stories we want by calling <kbd>take(count)</kbd>, followed by calling <kbd>collect()</kbd> on it, which gives us back a <kbd>Vec&lt;Story&gt;</kbd>:</p>
<pre>        let story_ids = fetch_stories_parsed(&amp;client).unwrap();<br/>        let filtered: Vec&lt;&amp;Value&gt; = story_ids.as_array()<br/>                                             .unwrap()<br/>                                             .iter()<br/>                                             .take(count)<br/>                                             .collect();</pre>
<p>Next, we check whether our filtered story ID is empty. If it is, we set the <kbd>loaded</kbd> variable to <kbd>false</kbd>:</p>
<pre>       let loaded = !filtered.is_empty();</pre>
<p>The <kbd>loaded</kbd> boolean value is used to send a notification to the main GUI thread if any of our story was loaded. Next, if the <kbd>filtered</kbd> list is not empty, we iterate over our <kbd>filtered</kbd> stories and construct a <kbd>story_url</kbd> :</p>
<pre>        for id in filtered {<br/>            let id = id.as_u64().unwrap();<br/>            let story_url = format!("{}item/{}.json", HN_BASE_URL, id);<br/>            let story = client.get(&amp;story_url)<br/>                              .send()<br/>                              .unwrap()<br/>                              .text()<br/>                              .unwrap();<br/>            let story: Story = serde_json::from_str(&amp;story).unwrap();<br/>            tx_clone.send(Msg::NewStory(story)).unwrap();<br/>        }</pre>
<p>We make get requests for each constructed <kbd>story_url </kbd> from the story <kbd>id</kbd>, take the json response, and parse it as a <kbd>Story</kbd> struct using the <kbd>serde_json::from_str</kbd> function. Following that, we send the story by wrapping it in <kbd>Msg::NewStory(story)</kbd> to the GUI thread using <kbd>tx_clone</kbd>.</p>
<p>Once we have sent all the stories, we send a <kbd>Msg::Loaded</kbd> message to the GUI thread, which enables the refresh button so that the user can reload the stories again.</p>
<p>All right! It's time for us to read popular news stories on our app. After running <kbd>cargo run</kbd>, we can see our stories being pulled and rendered in the window:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/226a3f3d-1e2b-4998-9308-607251bb4cf4.png" style="width:38.50em;height:45.50em;"/></p>
<p>Upon clicking the link of any for the stories, hews will open in your default browser. That's about it. We've made our GUI application in Rust using very few lines of code. Now, it's time for you to explore and experiment with the app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercise</h1>
                </header>
            
            <article>
                
<p>Our app works great, but there are lots of ways we can improve it. If you are feeling ambitious, you can take a look at the following challenges:</p>
<ul>
<li>Improve error handling in the app and handle cases where the network is slow by adding retry mechanisms.</li>
<li>Customize the number of stories that get loaded by placing an input field widget on the header bar, and parse and pass that number to the network thread.</li>
<li>Add a button to each story to view comments. When the user clicks on the comments button, the app should open a scrollable widget on the right and populate the comments in that story, one by one.</li>
<li>Widgets can be styled using CSS. Try adding colors to the story container, depending on the popularity of posts, using the <kbd>gtk::StyleProvider</kbd> APIs.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other emerging GUI frameworks</h1>
                </header>
            
            <article>
                
<p>As we have already seen, the APIs exposed by the <kbd>gtk</kbd> crate can be a bit uncomfortable to write complex GUIs with. Fortunately, we have a wrapper crate called <kbd>relm</kbd>. The relm crate is inspired by the <em>Elm</em> language's architecture of <kbd>Model-View-Update</kbd>, which provides a simplistic approach for building reactive GUIs. Apart from relm, there are many other standalone GUI toolkits and crates in the works by the Rust community. One of the new and promising ones is <kbd>Azul</kbd>, which can be found at <a href="https://azul.rs/">https://azul.rs/</a>. It is a functional GUI framework that supports async I/O, along with features such as two-way data binding, which allows you to build reactive widgets and employs the principle of composition for building widgets, as opposed to the object-oriented model, which we explored in the gtk framework when building hews. As the rendering backend, Azul uses the performant Webrender rendering engine that's used in Servo from Mozilla.</p>
<p>Other notable mentions are <kbd>conrod</kbd> from the Piston Developers organization at <a href="https://github.com/PistonDevelopers/conrod">https://github.com/PistonDevelopers/conrod</a>, and <kbd>imgui-rs</kbd> at <a href="https://github.com/Gekkio/imgui-rs">https://github.com/Gekkio/imgui-rs</a>, which is a bindings library for the popular immediate mode ImGUI framework in C++.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>That was a very brief tour of GUI development with Rust. This chapter gave us a glimpse into the current experience of developing GUI applications. At the time of writing, the experience isn't all that great, but there are emerging frameworks, such as Azul, that aim to take this experience to the next level.</p>
<p>The next chapter will be about finding and fixing bugs in your program using debuggers.</p>


            </article>

            
        </section>
    </body></html>