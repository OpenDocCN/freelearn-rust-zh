["```rs\nname,radius,distance_from_sun,gravity\nMercury,0.38,0.47,0.38\nVenus,0.95,0.73,0.9\nEarth,1,1,1\nMars,0.53,1.67,0.38\nJupiter,11.21,5.46,2.53\nSaturn,9.45,10.12,1.07\nUranus,4.01,20.11,0.89\nNeptune,3.88,30.33,1.14\n```", "```rs\n csv = \"1.0.0-beta.5\"\n```", "```rs\n1    extern crate csv;\n2 \n3    use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom,\n  Write};\n4    use std::fs::OpenOptions;\n5 \n6    fn main() {\n7      let file = OpenOptions::new()\n8        .read(true)\n9        .write(true)\n10       .create(true)\n11       .open(\"solar_system_compared_to_earth.csv\")\n12       .expect(\"failed to create csv file\");\n13 \n14     let buf_writer = BufWriter::new(&file);\n15     write_records(buf_writer).expect(\"Failed to write csv\");\n16 \n17     let mut buf_reader = BufReader::new(&file);\n18     buf_reader\n19       .seek(SeekFrom::Start(0))\n20       .expect(\"Failed to jump to the beginning of the csv\");\n21     read_records(buf_reader).expect(\"Failed to read csv\");\n22   }\n23 \n24   fn write_records<W>(writer: W) -> csv::Result<()>\n25   where\n26   W: Write,\n27   {\n28     let mut wtr = csv::Writer::from_writer(writer);\n29 \n30     // The header is just a normal record\n31     wtr.write_record(&[\"name\", \"radius\", \"distance_from_sun\", \n32     \"gravity\"])?;\n33 \n34     wtr.write_record(&[\"Mercury\", \"0.38\", \"0.47\", \"0.38\"])?;\n35     wtr.write_record(&[\"Venus\", \"0.95\", \"0.73\", \"0.9\"])?;\n36     wtr.write_record(&[\"Earth\", \"1\", \"1\", \"1\"])?;\n37     wtr.write_record(&[\"Mars\", \"0.53\", \"1.67\", \"0.38\"])?;\n38     wtr.write_record(&[\"Jupiter\", \"11.21\", \"5.46\", \"2.53\"])?;\n39     wtr.write_record(&[\"Saturn\", \"9.45\", \"10.12\", \"1.07\"])?;\n40     wtr.write_record(&[\"Uranus\", \"4.01\", \"20.11\", \"0.89\"])?;\n41     wtr.write_record(&[\"Neptune\", \"3.88\", \"30.33\", \"1.14\"])?;\n42     wtr.flush()?;\n43     Ok(())\n44   }\n45 \n46   fn read_records<R>(reader: R) -> csv::Result<()>\n47   where\n48   R: Read,\n49   {\n50     let mut rdr = csv::Reader::from_reader(reader);\n51     println!(\"Comparing planets in the solar system with the \n52     earth\");\n53     println!(\"where a value of '1' means 'equal to earth'\");\n54     for result in rdr.records() {\n55       println!(\"-------\");\n56       let record = result?;\n57       if let Some(name) = record.get(0) {\n58         println!(\"Name: {}\", name);\n59       }\n60       if let Some(radius) = record.get(1) {\n61         println!(\"Radius: {}\", radius);\n62       }\n63       if let Some(distance) = record.get(2) {\n64         println!(\"Distance from sun: {}\", distance);\n65       }\n66       if let Some(gravity) = record.get(3) {\n67         println!(\"Surface gravity: {}\", gravity);\n68       }\n69     }\n70     Ok(())\n71   }\n```", "```rs\n.terminator(csv::Terminator::CRLF)\n```", "```rs\nserde = \"1.0.24\"\nserde_derive = \"1.0.24\"\n```", "```rs\ncsv = \"1.0.0-beta.5\"\n\n```", "```rs\n1    extern crate csv;\n2    extern crate serde;\n3    #[macro_use]\n4    extern crate serde_derive;\n5 \n6    use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, \n     Write};\n7    use std::fs::OpenOptions;\n8 \n9    #[derive(Serialize, Deserialize)]\n10   struct Planet {\n11     name: String,\n12     radius: f32,\n13     distance_from_sun: f32,\n14     gravity: f32,\n15   }\n16 \n17   fn main() {\n18     let file = OpenOptions::new()\n19       .read(true)\n20       .write(true)\n21       .create(true)\n22       .open(\"solar_system_compared_to_earth.csv\")\n23       .expect(\"failed to create csv file\");\n24 \n25     let buf_writer = BufWriter::new(&file);\n26     write_records(buf_writer).expect(\"Failed to write csv\");\n27 \n28     let mut buf_reader = BufReader::new(&file);\n29     buf_reader\n30       .seek(SeekFrom::Start(0))\n31       .expect(\"Failed to jump to the beginning of the csv\");\n32     read_records(buf_reader).expect(\"Failed to read csv\");\n33   }\n34 \n35   fn write_records<W>(writer: W) -> csv::Result<()>\n36   where\n37   W: Write,\n38  {\n39     let mut wtr = csv::Writer::from_writer(writer);\n40 \n41     // No need to specify a header; Serde creates it for us\n42     wtr.serialize(Planet {\n43       name: \"Mercury\".to_string(),\n44       radius: 0.38,\n45       distance_from_sun: 0.47,\n46       gravity: 0.38,\n47     })?;\n48     wtr.serialize(Planet {\n49       name: \"Venus\".to_string(),\n50       radius: 0.95,\n51       distance_from_sun: 0.73,\n52       gravity: 0.9,\n53     })?;\n54     wtr.serialize(Planet {\n55       name: \"Earth\".to_string(),\n56       radius: 1.0,\n57       distance_from_sun: 1.0,\n58       gravity: 1.0,\n59     })?;\n60     wtr.serialize(Planet {\n61       name: \"Mars\".to_string(),\n62       radius: 0.53,\n63       distance_from_sun: 1.67,\n64       gravity: 0.38,\n65     })?;\n66     wtr.serialize(Planet {\n67       name: \"Jupiter\".to_string(),\n68       radius: 11.21,\n69       distance_from_sun: 5.46,\n70       gravity: 2.53,\n71     })?;\n72     wtr.serialize(Planet {\n73       name: \"Saturn\".to_string(),\n74       radius: 9.45,\n75       distance_from_sun: 10.12,\n76       gravity: 1.07,\n77    })?;\n78    wtr.serialize(Planet {\n79      name: \"Uranus\".to_string(),\n80      radius: 4.01,\n81      distance_from_sun: 20.11,\n82      gravity: 0.89,\n83    })?;\n84    wtr.serialize(Planet {\n85      name: \"Neptune\".to_string(),\n86      radius: 3.88,\n87      distance_from_sun: 30.33,\n88      gravity: 1.14,\n89    })?;\n90    wtr.flush()?;\n91    Ok(())\n92  }\n93 \n94  fn read_records<R>(reader: R) -> csv::Result<()>\n95  where\n96  R: Read,\n97  {\n98    let mut rdr = csv::Reader::from_reader(reader);\n99    println!(\"Comparing planets in the solar system with the \n   earth\");\n100   println!(\"where a value of '1' means 'equal to earth'\");\n101   for result in rdr.deserialize() {\n102     println!(\"-------\");\n103     let planet: Planet = result?;\n104     println!(\"Name: {}\", planet.name);\n105     println!(\"Radius: {}\", planet.radius);\n106     println!(\"Distance from sun: {}\", planet.distance_from_sun);\n107     println!(\"Surface gravity: {}\", planet.gravity);\n108   }\n109   Ok(())\n110 }\n```", "```rs\n#[derive(Serialize, Deserialize)]\nstruct Foo {\n    bar: i32,\n    #[serde(default)]\n    baz: i32,\n}\n```", "```rs\n#[derive(Serialize, Deserialize)]\n#[serde(rename_all = \"PascalCase\")]\nstruct Stats {\n    number_of_clicks: i32,\n    total_time_played: i32,\n}\n```", "```rs\nmessage = \"Hello World\"\n```", "```rs\nmessages: [\"Hello\", \"World\", \"out\", \"there\"]\n```", "```rs\n[smileys]\nhappy = \":)\"\nsad = \":(\"\n```", "```rs\nsmileys = { happy = \":)\", sad = \":(\" }\n```", "```rs\n[servers]\n  [servers.production]\n  ip = \"192.168.0.1\"\n  [servers.beta]\n  ip = \"192.169.0.2\"\n  [servers.testing]\n  ip = \"192.169.0.3\"\n```", "```rs\n[dependencies]\nrocket_contrib = 0.3.3\n```", "```rs\n[dependencies]\n[dependencies.rocket_contrib]\nversion = \"0.3.3\"\ndefault-features = false\nfeatures = [\"json\"]\n```", "```rs\n# some comment\n```", "```rs\ntoml = \"0.4.5\"\n```", "```rs\nserde = \"1.0.24\"\nserde_derive = \"1.0.24\"\n```", "```rs\n1    #[macro_use]\n2    extern crate serde_derive;\n3    extern crate toml;\n4\n5    use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, \n     Write};\n6    use std::fs::OpenOptions;\n```", "```rs\n8    #[derive(Serialize, Deserialize)]\n9    struct Preferences {\n10     person: Person,\n11     language: Language,\n12     privacy: Privacy,\n13   }\n14 \n15   #[derive(Serialize, Deserialize)]\n16   struct Person {\n17     name: String,\n18     email: String,\n19   }\n20 \n21   #[derive(Serialize, Deserialize)]\n22   struct Language {\n23     display: String,\n24     autocorrect: Option<Vec<String>>,\n25   }\n26 \n27   #[derive(Serialize, Deserialize)]\n28   struct Privacy {\n29     share_anonymous_statistics: bool,\n30     public_name: bool,\n31     public_email: bool,\n32   }\n```", "```rs\n34   fn main() {\n35     let file = OpenOptions::new()\n36      .read(true)\n37      .write(true)\n38      .create(true)\n39      .open(\"preferences.toml\")\n40      .expect(\"failed to create TOML file\");\n41 \n42     let buf_writer = BufWriter::new(&file);\n43     write_toml(buf_writer).expect(\"Failed to write TOML\");\n44 \n45     let mut buf_reader = BufReader::new(&file);\n46     buf_reader\n47       .seek(SeekFrom::Start(0))\n48       .expect(\"Failed to jump to the beginning of the TOML \n         file\");\n49     read_toml(buf_reader).expect(\"Failed to read TOML\");\n50   }\n```", "```rs\n52   type SerializeResult<T> = Result<T, toml::ser::Error>;\n53   fn write_toml<W>(mut writer: W) -> SerializeResult<()>\n54   where\n55   W: Write,\n56   {\n57     let preferences = Preferences {\n58       person: Person {\n59         name: \"Jan Nils Ferner\".to_string(),\n60         email: \"jn_ferner@hotmail.de\".to_string(),\n61       },\n62       language: Language {\n63         display: \"en-GB\".to_string(),\n64         autocorrect: Some(vec![\n65           \"en-GB\".to_string(),\n66           \"en-US\".to_string(),\n67           \"de-CH\".to_string(),\n68         ]),\n69       },\n70       privacy: Privacy {\n71         share_anonymous_statistics: false,\n72         public_name: true,\n73         public_email: true,\n74       },\n75     };\n76 \n77     let toml = toml::to_string(&preferences)?;\n78     writer\n79       .write_all(toml.as_bytes())\n80       .expect(\"Failed to write file\");\n81     Ok(())\n82   }\n```", "```rs\n84   type DeserializeResult<T> = Result<T, toml::de::Error>;\n85   fn read_toml<R>(mut reader: R) -> DeserializeResult<()>\n86   where\n87   R: Read,\n88   {\n89     let mut toml = String::new();\n90     reader\n91       .read_to_string(&mut toml)\n92       .expect(\"Failed to read TOML\");\n93     let preferences: Preferences = toml::from_str(&toml)?;\n94 \n95     println!(\"Personal data:\");\n96     let person = &preferences.person;\n97     println!(\" Name: {}\", person.name);\n98     println!(\" Email: {}\", person.email);\n99 \n100     println!(\"\\nLanguage preferences:\");\n101     let language = &preferences.language;\n102     println!(\" Display language: {}\", language.display);\n103     println!(\" Autocorrect priority: {:?}\", \n        language.autocorrect);\n104 \n105 \n106     println!(\"\\nPrivacy settings:\");\n107     let privacy = &preferences.privacy;\n108     println!(\n109       \" Share anonymous usage statistics: {}\",\n110         privacy.share_anonymous_statistics\n111     );\n112     println!(\" Display name publically: {}\", \n        privacy.public_name);\n113     println!(\" Display email publically: {}\", \n        privacy.public_email);\n114 \n115     Ok(())\n116  }\n```", "```rs\n{\n  name: \"John\",\n  age: 23,\n  pets: [\n    {\n      name: \"Sparky\",\n      species: \"Dog\",\n      age: 2\n    },\n    {\n      name: \"Speedy\",\n      species: \"Turtle\",\n      age: 47,\n      colour: \"Green\"\n    },\n    {\n      name: \"Meows\",\n      species: \"Cat\",\n      colour: \"Orange\"\n    }\n  ]\n}\n```", "```rs\nserde_json = \"1.0.8\"\n```", "```rs\nserde = \"1.0.24\"\nserde_derive = \"1.0.24\"\n```", "```rs\n1    extern crate serde;\n2    extern crate serde_json;\n3\n4    #[macro_use]\n5    extern crate serde_derive;\n6\n7    use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, \n     Write};\n8    use std::fs::OpenOptions;\n```", "```rs\n10   #[derive(Serialize, Deserialize)]\n11   struct PetOwner {\n12     name: String,\n13     age: u8,\n14     pets: Vec<Pet>,\n15   }\n16 \n17   #[derive(Serialize, Deserialize)]\n18   struct Pet {\n19     name: String,\n20     species: AllowedSpecies,\n21     // It is usual for many JSON keys to be optional\n22     age: Option<u8>,\n23     colour: Option<String>,\n24   }\n25 \n26   #[derive(Debug, Serialize, Deserialize)]\n27   enum AllowedSpecies {\n28     Dog,\n29     Turtle,\n30     Cat,\n31   }\n```", "```rs\n33   fn main() {\n34     let file = OpenOptions::new()\n35       .read(true)\n36       .write(true)\n37       .create(true)\n38       .open(\"pet_owner.json\")\n39       .expect(\"failed to create JSON file\");\n40 \n41     let buf_writer = BufWriter::new(&file);\n42     write_json(buf_writer).expect(\"Failed to write JSON\");\n43 \n44     let mut buf_reader = BufReader::new(&file);\n45     buf_reader\n46       .seek(SeekFrom::Start(0))\n47       .expect(\"Failed to jump to the beginning of the JSON \n          file\");\n48     read_json(buf_reader).expect(\"Failed to read JSON\");\n49   }\n```", "```rs\n52   fn write_json<W>(mut writer: W) -> serde_json::Result<()>\n53   where\n54   W: Write,\n55   {\n56     let pet_owner = PetOwner {\n57       name: \"John\".to_string(),\n58       age: 23,\n59       pets: vec![\n60         Pet {\n61           name: \"Waldo\".to_string(),\n62           species: AllowedSpecies::Dog,\n63           age: Some(2),\n64           colour: None,\n65         },\n66         Pet {\n67           name: \"Speedy\".to_string(),\n68           species: AllowedSpecies::Turtle,\n69           age: Some(47),\n70           colour: Some(\"Green\".to_string()),\n71         },\n72         Pet {\n73           name: \"Meows\".to_string(),\n74           species: AllowedSpecies::Cat,\n75           age: None,\n76           colour: Some(\"Orange\".to_string()),\n77         },\n78       ],\n79     };\n80 \n81     let json = serde_json::to_string(&pet_owner)?;\n82     writer\n83      .write_all(json.as_bytes())\n84      .expect(\"Failed to write file\");\n85     Ok(())\n86   }\n```", "```rs\n88   fn read_json<R>(mut reader: R) -> serde_json::Result<()>\n89   where\n90   R: Read,\n91   {\n92     let mut json = String::new();\n93     reader\n94       .read_to_string(&mut json)\n95       .expect(\"Failed to read TOML\");\n96     let pet_owner: PetOwner = serde_json::from_str(&json)?;\n97 \n98     println!(\"Pet owner profile:\");\n99     println!(\" Name: {}\", pet_owner.name);\n100    println!(\" Age: {}\", pet_owner.age);\n101 \n102    println!(\"\\nPets:\");\n103    for pet in pet_owner.pets {\n104      println!(\" Name: {}\", pet.name);\n105      println!(\" Species: {:?}\", pet.species);\n106      if let Some(age) = pet.age {\n107        println!(\" Age: {}\", age);\n108      }\n109      if let Some(colour) = pet.colour {\n110        println!(\" Colour: {}\", colour);\n111      }\n112      println!();\n113    }\n114    Ok(())\n115  }\n```", "```rs\nserde_json = \"1.0.8\"\n\n```", "```rs\n1    #[macro_use] \n2    extern crate serde_json;\n3 \n4    use std::io::{self, BufRead};\n5    use std::collections::HashMap;\n6 \n7    fn main() {\n8      // A HashMap is the same as a JSON without any schema\n9      let mut key_value_map = HashMap::new();\n10     let stdin = io::stdin();\n11     println!(\"Enter a key and a value\");\n12     for input in stdin.lock().lines() {\n13       let input = input.expect(\"Failed to read line\");\n14       let key_value: Vec<_> = input.split_whitespace().collect();\n15       let key = key_value[0].to_string();\n16       let value = key_value[1].to_string();\n17 \n18       println!(\"Saving key-value pair: {} -> {}\", key, value);\n19       // The json! macro lets us convert a value into its JSON \n            representation\n20       key_value_map.insert(key, json!(value));\n21       println!(\n22         \"Enter another pair or stop by pressing '{}'\",\n23          END_OF_TRANSMISSION\n24       );\n25     }\n26     // to_string_pretty returns a JSON with nicely readable \n          whitespace\n27     let json =\n28     serde_json::to_string_pretty(&key_value_map).expect(\"Failed \n       to convert HashMap into JSON\");\n29     println!(\"Your input has been made into the following \n       JSON:\");\n30     println!(\"{}\", json);\n31   }\n32 \n33   #[cfg(target_os = \"windows\")]\n34   const END_OF_TRANSMISSION: &str = \"Ctrl Z\";\n35 \n36   #[cfg(not(target_os = \"windows\"))]\n37   const END_OF_TRANSMISSION: &str = \"Ctrl D\";\n```", "```rs\nname abraham\nage 49\nfav_colour red\nhello world\n(press 'Ctrl Z' on Windows or 'Ctrl D' on Unix)\n```"]