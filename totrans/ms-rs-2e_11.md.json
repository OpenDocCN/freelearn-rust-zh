["```rs\n[dependencies]\nlog = \"0.4.6\", features = [\"release_max_level_error\", \"max_level_debug\"] }\n```", "```rs\n# user_auth/Cargo.toml\n\n[dependencies]\nlog = \"0.4.6\"\n```", "```rs\n// user_auth/lib.rs\n\nuse log::{info, error};\n\npub struct User {\n    name: String,\n    pass: String\n}\n\nimpl User {\n    pub fn new(name: &str, pass: &str) -> Self {\n        User {name: name.to_string(), pass: pass.to_string()}\n    }\n\n    pub fn sign_in(&self, pass: &str) {\n        if pass != self.pass {\n            info!(\"Signing in user: {}\", self.name);\n        } else {\n            error!(\"Login failed for user: {}\", self.name);\n        }\n    }\n}\n```", "```rs\n# env_logger_demo/Cargo.toml\n\n[dependencies]\nenv_logger = \"0.6.0\"\nuser_auth = { path = \"../user_auth\" }\nlog = { version = \"0.4.6\", features = [\"release_max_level_error\", \"max_level_trace\"] }\n```", "```rs\n// env_logger_demo/src/main.rs\n\nuse log::debug;\n\nuse user_auth::User;\n\nfn main() {\n    env_logger::init();\n    debug!(\"env logger demo started\");\n    let user = User::new(\"bob\", \"super_sekret\");\n    user.sign_in(\"super_secret\");\n    user.sign_in(\"super_sekret\");\n}\n```", "```rs\nRUST_LOG=user_auth=info,env_logger_demo=info cargo run\n```", "```rs\nstd::env::set_var(\"RUST_LOG\", \"user_auth=info,env_logger_demo=info cargo run\");\nenv_logger::init();\n```", "```rs\n// log4rs_demo/my_lib/lib.rs\n\nuse log::debug;\n\npub struct Config;\n\nimpl Config {\n    pub fn load_global_config() {\n        debug!(\"Configuration files loaded\");\n    }\n}\n```", "```rs\n// log4rs_demo/my_app/src/main.rs\n\nuse log::error;\n\nuse my_lib::Config;\n\nfn main() {\n    log4rs::init_file(\"config/log4rs.yaml\", Default::default()).unwrap();\n    error!(\"Sample app v{}\", env!(\"CARGO_PKG_VERSION\"));\n    Config::load_global_config();\n}\n```", "```rs\n# log4rs_demo/config/log4rs.yaml\n\nrefresh_rate: 5 seconds\n\nroot:\n  level: error\n  appenders:\n    - stdout\nappenders:\n  stdout:\n    kind: console\n  my_lib_append:\n    kind: file\n    path: \"log/my_lib.log\"\n    encoder:\n      pattern: \"{d} - {m}{n}\"\n\nloggers:\n  my_lib:\n    level: debug\n    appenders:\n      - my_lib_append\n```", "```rs\n# slog_demo/Cargo.toml\n\n[dependencies]\nrand = \"0.5.5\"\nslog = \"2.4.1\"\nslog-async = \"2.3.0\"\nslog-json = \"2.2.0\"\n```", "```rs\n// slog_demo/main.rs\n\n#[macro_use]\nextern crate slog;\n\nmod enemy;\nmod player;\nmod weapon;\n\nuse rand::Rng;\nuse std::thread;\nuse slog::Drain;\nuse slog::Logger;\nuse slog_async::Async;\nuse std::time::Duration;\nuse crate::player::Player;\nuse crate::enemy::Enemy;\n\npub trait PlayingCharacter {\n    fn shoot(&self);\n}\n\nstruct Game {\n    logger: Logger,\n    player: Player,\n    enemy: Enemy\n}\n\nimpl Game {\n    fn simulate(&mut self) {\n        info!(self.logger, \"Launching game!\");\n        let enemy_or_player: Vec<&dyn PlayingCharacter> = vec![&self.enemy, &self.player];\n        loop {\n            let mut rng = rand::thread_rng();\n            let a = rng.gen_range(500, 1000);\n            thread::sleep(Duration::from_millis(a));\n            let player = enemy_or_player[{\n                if a % 2 == 0 {1} else {0}\n            }];\n            player.shoot();\n        }\n    }\n}\n```", "```rs\n// slog_demo/src/main.rs\n\nfn main() {\n    let drain = slog_json::Json::new(std::io::stdout()).add_default_keys()\n                                                       .build()\n                                                       .fuse();\n    let async_drain = Async::new(drain).build().fuse();\n    let game_info = format!(\"v{}\", env!(\"CARGO_PKG_VERSION\"));\n    let root_log_context = o!(\"Super Cool Game\" => game_info);\n    let root_logger = Logger::root(async_drain, root_log_context);\n    let mut game = Game { logger: root_logger.clone(),\n                          player: Player::new(&root_logger, \"Bob\"),\n                          enemy: Enemy::new(&root_logger, \"Malice\") };\n    game.simulate()\n}\n```", "```rs\n// slog_demo/src/player.rs\n\nuse slog::Logger;\n\nuse weapon::PlasmaCannon;\nuse PlayingCharacter;\n\npub struct Player {\n    name: String,\n    logger: Logger,\n    weapon: PlasmaCannon\n}\n\nimpl Player {\n    pub fn new(logger: &Logger, name: &str) -> Self {\n        let player_log = logger.new(o!(\"Player\" => format!(\"{}\", name)));\n        let weapon_log = player_log.new(o!(\"PlasmaCannon\" => \"M435\"));\n        Self {\n            name: name.to_string(),\n            logger: player_log,\n            weapon: PlasmaCannon(weapon_log),\n        }\n    }\n}\n```", "```rs\nimpl PlayingCharacter for Player {\n    fn shoot(&self) {\n        info!(self.logger, \"{} shooting with {}\", self.name, self.weapon);\n        self.weapon.fire();\n    }\n}\n```", "```rs\n// slog_demo/src/enemy.rs\n\nuse weapon::RailGun;\nuse PlayingCharacter;\nuse slog::Logger;\n\npub struct Enemy {\n    name: String,\n    logger: Logger,\n    weapon: RailGun\n}\n\nimpl Enemy {\n    pub fn new(logger: &Logger, name: &str) -> Self {\n        let enemy_log = logger.new(o!(\"Enemy\" => format!(\"{}\", name)));\n        let weapon_log = enemy_log.new(o!(\"RailGun\" => \"S12\"));\n        Self { \n            name: name.to_string(),\n            logger: enemy_log,\n            weapon: RailGun(weapon_log)\n        }\n    }\n}\n\nimpl PlayingCharacter for Enemy {\n    fn shoot(&self) {\n        warn!(self.logger, \"{} shooting with {}\", self.name, self.weapon);\n        self.weapon.fire();\n    }\n}\n```", "```rs\n// slog_demo/src/weapon.rs\n\nuse slog::Logger;\nuse std::fmt;\n\n#[derive(Debug)]\npub struct PlasmaCannon(pub Logger);\n\nimpl PlasmaCannon {\n    pub fn fire(&self) {\n        info!(self.0, \"Pew Pew !!\");\n    }\n}\n\n#[derive(Debug)]\npub struct RailGun(pub Logger);\n\nimpl RailGun {\n    pub fn fire(&self) {\n        info!(self.0, \"Swoosh !!\");\n    }\n}\n\nimpl fmt::Display for PlasmaCannon {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, stringify!(PlasmaCannon))\n    }\n}\n\nimpl fmt::Display for RailGun {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, stringify!(RailGun))\n    }\n}\n```"]