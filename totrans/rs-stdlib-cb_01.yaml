- en: Learning the Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the format! macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a default implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the constructor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelism through simple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying with regexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from stdin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepting a variable number of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some code snippets and patterns of thought that prove time and again
    to be the bread and butter of a certain programming language. We will start this
    book by looking at a handful of such techniques in Rust. They are so quintessential
    for elegant and flexible code that you will use at least some of them in just
    about any project you tackle.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapters will then build on this foundation and work hand in hand with
    Rust's zero costs abstractions, which are as powerful as the ones in higher-level
    languages. We are also going to look at the intricate inner aspects of the standard
    library and implement our own similar constructs with the help of fearless concurrency
    and careful use of `unsafe` blocks, which enable us to work at the same low level
    that some system languages, such as C, operate at.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String manipulation is typically a bit less straightforward in system programming
    languages than in scripting languages, and Rust is no exception. There are multiple
    ways to do it, all managing the involved resources differently.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will assume for the rest of the book that you have an editor open, the newest
    Rust compiler ready, and a command line available. As of the time of writing,
    the newest version is `1.24.1`. Because of Rust's strong guarantees about backward
    compatibility, you can rest assured that all of the recipes shown (with the exception
    of [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml), *Using Experimental
    Nightly Features*) are always going to work the same way. You can download the
    newest compiler with its command-line tools at [https://www.rustup.rs](https://www.rustup.rs).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Rust project to work on during this chapter with `cargo new chapter-one`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the newly created `chapter-one` folder. For the rest of this chapter,
    we will assume that your command line is currently in this directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `src` folder, create a new folder called `bin`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the generated `lib.rs` file, as we are not creating a library
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `concat.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin concat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all functions, we start by allocating memory for a string of variable length.
  prefs: []
  type: TYPE_NORMAL
- en: We do this by creating a string slice (`&str`) and applying the `to_string`
    function on it [8, 18 and 28].
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way to concatenate strings in Rust, as shown in the `by_moving` function,
    is by taking said allocated memory and **moving** it, together with an additional
    string slice, into a new variable [12]. This has a couple of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It's very straightforward and clear to look at, as it follows the common programming
    convention of concatenating with the `+` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses only immutable data. Remember to always try to write code in a style
    that creates as little stateful behavior as possible, as it results in more robust
    and reusable code bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reuses the memory allocated by `hello` [8], which makes it very performant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As such, this way of concatenating should be preferred whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why would we even list other ways to concatenate strings? Well, I''m glad
    you asked, dear reader. Although elegant, this approach comes with two downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hello` is no longer usable after line [12], as it was moved. This means you
    can no longer read it in any way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes you may actually prefer mutable data in order to use state in small,
    contained environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two remaining functions address one concern each.
  prefs: []
  type: TYPE_NORMAL
- en: '`by_cloning`[17] looks nearly identical to the first function, but it clones
    the allocated string [22] into a temporary object, allocating new memory in the
    process, which it then moves, leaving the original `hello` untouched and still
    accessible. Of course, this comes at the price of redundant memory allocations
    at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: '`by_mutating`[27] is the stateful way of solving our problem. It performs the
    involved memory management in-place, which means that the performance should be
    the same as in `by_moving`. In the end, it leaves `hello` mutable, ready for further
    changes. You may notice that this function doesn''t look as elegant as the others,
    as it doesn''t use the `+` operator. This is intentional, as Rust tries to push
    you through its design towards moving data in order to create new variables without
    mutating existing ones. As mentioned before, you should only do this if you really
    need mutable data or want to introduce state in a very small and manageable context.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the format! macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an additional way to combine strings, which can also be used to combine
    them with other data types, such as numbers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `format.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following code and run it with `cargo run --bin format`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `format!` macro combines strings by accepting a format string filled with
    formatting parameters (example, `{}`, `{0}`, or `{foo}`) and a list of arguments,
    which are then inserted into the *placeholders*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to show this on the example in line [16]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the preceding line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"My favourite number is {}"` is the format string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{}` is the formatting parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`42` is the argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As demonstrated, `format!` works not only with strings, but also with numbers.
    In fact, it works with all `structs` that implement the `Display` trait. This
    means that, by providing such an implementation by yourself, you can easily make
    your own data structures printable however you want.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `format!` replaces one parameter after another. If you want to override
    this behavior, you can use positional parameters like `{0}` [21]. With the knowledge
    that the positions are zero-indexed, the behavior here is pretty straightforward, `{0}`
    gets replaced by the first argument, `{1}` gets replaced by the second, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'At times, this can become a bit unwieldy when using a lot of parameters. For
    this purpose, you can use named arguments [26], just like in Python. Keep in mind
    that all of your unnamed arguments have to be placed before your named ones. For
    example, the following is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can combine positional parameters with normal ones, but it''s probably
    not a good idea, as it can quite easily become confusing to look at. The behavior,
    in this case, is as follows—imagine that `format!` internally uses a counter to
    determine which argument is the next to be placed. This counter is increased whenever
    `format!` encounters a `{}` *without* a position in it. This rule results in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also a ton of extra formatting options if you want to display your
    data in different formats. `{:?}` prints the implementation of the `Debug` trait
    for the respective argument, often resulting in a more verbose output. `{:.*}`
    lets you specify the decimal precision of floating point numbers via the argument,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For a complete list, visit [https://doc.rust-lang.org/std/fmt/](https://doc.rust-lang.org/std/fmt/).
  prefs: []
  type: TYPE_NORMAL
- en: All of the information in this recipe applies to `println!` and `print!` as
    well, as it is essentially the same macro. The only difference is that `println!`
    doesn't return its processed string but instead, well, prints it!
  prefs: []
  type: TYPE_NORMAL
- en: Providing a default implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when dealing with structures that represent configurations, you don't
    care about certain values and just want to silently assign them a standard value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `default.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin default`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nearly every type in Rust has a `Default` implementation. When you define your
    own `struct` that only contains elements that already have a `Default`, you have
    the option to derive from `Default` as well [42]. In the case of enums or complex
    structs, you can easily write your own implementation of `Default` instead [55],
    as there''s only one method you have to provide. After this, the `struct` returned
    by `Default::default()` is implicitly inferrable as yours, if you tell the compiler
    what your type actually is. This is why in line [3] we have to write `foo: i32`,
    or else Rust wouldn''t know what type the default object actually should become.'
  prefs: []
  type: TYPE_NORMAL
- en: If you only want to specify some elements and leave the others at the default,
    you can use the syntax in line [29]. Keep in mind that you can configure and skip
    as many values as you want, as shown in lines [33 to 37].
  prefs: []
  type: TYPE_NORMAL
- en: Using the constructor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have asked yourself how to idiomatically initialize complex structs
    in Rust, considering it doesn't have constructors. The answer is simple, there
    is a constructor, it's just a convention rather than a rule. Rust's standard library
    uses this pattern very often, so we need to understand it if we want to use the
    std effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to talk about how a **user** interacts with a `struct`.
    When we say *user* in this context, we don't mean the end user that clicks on
    the GUI of the app you're writing. We're referring to the programmer that instantiates
    and manipulates the `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `constructor.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin constructor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a `struct` provides a method called `new` that returns `Self`, the user of
    the `struct` will not configure or depend upon the members of the `struct`, as
    they are considered to be in an internal *hidden* state.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if you see a `struct` that has a `new` function, always use
    it to create the structure.
  prefs: []
  type: TYPE_NORMAL
- en: This has the nice effect of enabling you to change as many members of the struct
    as you want without the user noticing anything, as they are not supposed to look
    at them anyway.
  prefs: []
  type: TYPE_NORMAL
- en: The other reason to use this pattern is to guide the user to the correct way
    of instantiating a `struct`. If one has nothing but a big list of members that
    have to be filled with values, one might feel a bit lost. If one, however, has
    a method with only a few self-documenting parameters, it feels way more inviting.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that for our example we really didn't need a `length`
    member and could have just calculated a length whenever we print. We use this
    pattern anyway, to illustrate the point of its usefulness in hiding implementations.
    Another good use for it is when the members of a `struct` themselves have their
    own constructors and one needs to *cascade* the constructor calls. This happens,
    for example, when we have a `Vec` as a member, as we will see later in the book,
    in the, *Using a vector* section in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, your structs might need more than one way to initialize themselves.
    When this happens, try to still provide a `new()` method as your default way of
    construction and name the other options according to how they differ from the
    default. A good example of this is again vector, which not only provides a `Vec::new()`
    constructor but also a `Vec::with_capacity(10)`, which initializes it with enough
    space for `10` items. More on that again in the Using a vector section in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When accepting a kind of string (either `&str`, that is, a borrowed string
    slice, or `String`, that is, an owned string) with plans to store it in your `struct`,
    like we do in our example, also considering a `Cow`. No, not the big milk animal
    friends. A `Cow` in Rust is a *Clone On Write* wrapper around a type, which means
    that it will try to borrow a type for as long as possible and only make an owned
    clone of the data when absolutely necessary, which happens at the first mutation.
    The practical effect of this is that, if we rewrote our `NameLength` struct in
    the following way, it would not care whether the called passed a `&str` or a `String`
    to it, and would instead try to work in the most efficient way possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to read more about `Cow`, check out this easy-to-understand blog
    post by Joe Wilm: [https://jwilm.io/blog/from-str-to-cow/](https://jwilm.io/blog/from-str-to-cow/).'
  prefs: []
  type: TYPE_NORMAL
- en: The `Into` trait used in the `Cow` code is going to be explained in the Converting
    types into each other section in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using a vector* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Converting types into each other* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need something between the customization of the constructor and
    the implicitness of the default implementation. Enter the builder pattern, another
    technique frequently used by the Rust standard library, as it allows a caller
    to fluidly chain together configurations that they care about and lets them ignore
    details that they don't care about.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `builder.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add all of the following code and run it with `cargo run --bin builder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the configurable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the builder itself. It is used to configure and create a `Burger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whew, that's a lot of code! Let's start by breaking it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first part, we illustrate how to use this pattern to effortlessly configure
    a complex object. We do this by relying on sensible standard values and only specifying
    what we really care about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code reads pretty nicely, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: In our version of the builder pattern, we return the object wrapped in a `Result`
    in order to tell the world that there are certain invalid configurations and that
    our builder might not always be able to produce a valid product. Because of this,
    we have to check the validity of our burger before accessing it[7, 10 and 13].
  prefs: []
  type: TYPE_NORMAL
- en: 'Our invalid configuration is `vegetarian(true)` and `bacon(true)`. Unfortunately,
    our restaurant doesn''t serve vegetarian bacon yet! When you start the program,
    you will see that the following line will print an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we omit the final `build` step, we can reuse the builder in order to build
    as many objects as we want. [25 to 32]
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we implemented all of this. The first thing after the `main` function
    is the definition of our `Burger` struct. No surprises here, it's just plain old
    data. The `print` method is just here to provide us with some nice output during
    runtime. You can ignore it if you want.
  prefs: []
  type: TYPE_NORMAL
- en: The real logic is in the `BurgerBuilder`[64]. It should have one member for
    every value you want to configure. As we want to configure every aspect of our
    burger, we will have the exact same members as `Burger`. In the constructor [74],
    we can specify some default values. We then create one method for every configuration.
    In the end, in `build()` [109], we first perform some error checking. If the configuration
    is OK, we return a `Burger` made out of all of our members [121]. Otherwise, we
    return an error [119].
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want your object to be constructable without a builder, you could also
    provide `Burger` with a `Default` implementation. `BurgerBuilder::new()` could
    then just return `Default::default()`.
  prefs: []
  type: TYPE_NORMAL
- en: In `build()`, if your configuration can inherently not be invalid, you can,
    of course, return the object directly without wrapping it in a `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism through simple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every year, parallelism and concurrency become more important as processors
    tend to have more and more physical cores. In most languages, writing parallel
    code is tricky. Very tricky. Not so in Rust, as it has been designed around the
    principle of *fearless concurrency* since the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `parallelism.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following code and run it with `cargo run --bin parallelism`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create a new thread by calling `thread::spawn`, which will then begin
    executing the provided lambda. This will return a `JoinHandle`, which you can
    use to, well, join the thread. Joining a thread means waiting for the thread to
    finish its work. If you don't join a thread, you have no guarantee of it actually
    ever finishing. This might be valid though when setting up threads to do tasks
    that never complete, such as listening for incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you cannot predetermine the order in which your threads will
    complete any work. In our example, it is impossible to foretell whether *Hello
    from a new thread!* or *Hello from the main thread!* is going to be printed first,
    although most of the time it will probably be the main thread, as the operating
    system needs to put some effort into spawning a new thread. This is the reason
    why small algorithms can be faster when not executed in parallel. Sometimes, the
    overhead of letting the OS spawn and manage new threads is just not worth it.
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated by line [49], joining a thread will return a `Result` that contains
    the value your lambda returned.
  prefs: []
  type: TYPE_NORMAL
- en: Threads can also be given names. Depending on your OS, in case of a crash, the
    name of the responsible thread will be displayed. In line [37], we call our new
    summation threads *calculation*. If one of them were to crash, we would be able
    to quickly identify the issue. Try it out for yourself, insert a call to `panic!();`
    at the beginning of `sum_bucket` in order to intentionally crash the program and
    run it. If your OS supports named threads, you will now be told that your thread
    *calculation* panicked with an *explicit panic*.
  prefs: []
  type: TYPE_NORMAL
- en: '`parallel_sum` is a function that takes a slice of integers and adds them together
    in parallel on four threads. If you have limited experience in working with parallel
    algorithms, this function will be hard to grasp at first. I invite you to copy
    it by hand into your text editor and play around with it in order to get a grasp
    on it. If you still feel a bit lost, don''t worry, we will revisit parallelism
    again later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adapting algorithms to run in parallel normally comes at the risk of data races.
    A data race is defined as the behavior in a system where the output is dependent
    on the random timing of external events. In our case, having a data race would
    mean that multiple threads try to access and modify a resource at the same time.
    Normally, programmers have to analyze their usage of resources and use external
    tools in order to catch all of the data races. In contrast, Rust''s compiler is
    smart enough to catch data races at compile time and stops if it finds one. This
    is the reason why we had to call `.to_vec()` in line [35]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will cover vectors in a later recipe (the *Using a vector* section in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*), so
    if you're curious about what is happening here, feel free to jump to [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections* and
    come back again. The essence of it is that we're copying the data into `bucket`.
    If we instead passed a reference into `sum_bucket` in our new thread, we would
    have a problem, the memory referenced by `range` is only guaranteed to live inside
    of `parallel_sum`, but the threads we spawn are allowed to outlive their parent
    threads. This would mean that in theory, if we didn't `join` the threads at the
    right time, `sum_bucket` might get unlucky and get called late enough for `range`
    to be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: This would then be a data race, as the outcome of our function would depend
    on the uncontrollable sequence in which our operating system decides to launch
    the threads.
  prefs: []
  type: TYPE_NORMAL
- en: But don't just take my word for it, try it yourself. Simply replace the aforementioned
    line with `let bucket = &range[count..count + bucket_size];` and try to compile
    it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're experienced with parallelism, you might have noticed how suboptimal
    our algorithm here is. This is intentional, as the elegant and efficient way of
    writing `parallel_sum` would require using techniques we have not discussed yet.
    We will revisit this algorithm in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism
    and Rayon*, and rewrite it in a professional manner. In that chapter, we will
    also learn how to concurrently modify resources using locks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Access resources in parallel with RwLocks*, recipe in  [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism
    and Rayon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in the preface, the Rust core team left some functionality intentionally
    out of the standard and put it into its own external crate. Generating pseudo-random
    numbers is one such functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to rand's crates.io page ([https://crates.io/crates/rand](https://crates.io/crates/rand))
    to check for the newest version and use that one instead
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `rand.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin rand`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can use `rand`, you have to tell Rust that you''re using the `crate`
    by writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After that, `rand` will provide a random generator. We can access it by either
    calling `rand::random();` [6] or by accessing it directly with `rand::thread_rng();`
    [22].
  prefs: []
  type: TYPE_NORMAL
- en: If we go the first route, the generator will need to be told what type to generate.
    You can either explicitly state the type in the method call [6] or annotate the
    type of the resulting variable [8]. Both are equal and result in the exact same
    thing. Which one you use is up to you. In this book, we will use the first convention.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in lines [29 and 33], you need neither if the type is unambiguous
    in the called context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated value will be between its type''s `MIN` and `MAX` constants.
    In the case of `i32`, this would be `std::i32::MIN` and `std::i32::MAX`, or, in
    concrete numbers, -2147483648 and 2147483647\. You can verify these numbers easily
    by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these are very big numbers. For most purposes, you will probably
    want to define custom limits. You can go the second route discussed earlier and
    use `rand::Rng` for that[22]. It has a `gen` method, which is actually implicitly
    called by `rand::random()`, but also a `gen_range()` that accepts a minimum and
    maximum value. Keep in mind that this range is non-inclusive, which means that
    the maximum value can never be reached. This is why in line [29], `rng.gen_range(0,
    10)` will only generate the numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9, without
    the 10.
  prefs: []
  type: TYPE_NORMAL
- en: All of the described ways of generating random values use **uniform distribution**,
    which means that every number in the range has the same chance of being generated.
    In some contexts, it makes sense to use other distributions. You can specify a
    generator's distribution during its creation[40]. As of the time of publication,
    the rand crate supports the ChaCha and ISAAC distributions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to randomly populate an entire `struct`, you use the `rand_derive`
    helper crate in order to derive it from **Rand**. You can then generate your own
    `struct`, just as you would generate any other type.
  prefs: []
  type: TYPE_NORMAL
- en: Querying with regexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When parsing simple data formats, it is often easier to write regular expressions
    (or *regex* for short) than use a parser. Rust has pretty decent support for this
    through its `regex` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to really understand this chapter, you should be familiar with regexes.
    There are countless free online resources for this, like regexone ([https://www.regexone.com/](https://www.regexone.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will not conform to clippy, as we kept the regexes intentionally
    *too* simple because we want to keep the focus of the recipe on the code, not
    the regex. Some of the examples shown could have been rewritten to use `.contains()`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to regex's crates.io page ([https://crates.io/crates/regex](https://crates.io/crates/regex))
    to check for the newest version and use that one instead
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `regex.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin regex`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can construct a regex object by calling `Regex::new()` with a valid regex
    string[7]. Most of the time, you will want to pass a *raw string* in the form
    of `r"..."`. Raw means that all symbols in the string are taken at literal value
    without being escaped. This is important because of the backslash (`\`) character
    that is used in regex to represent a couple of important concepts, such as digits(`\d`)
    or whitespace (`\s`). However, Rust already uses the backslash to escape special
    *non-printable* symbols, such as the newline (`\n`) or the tab (`\t`)[23]. If
    we wanted to use a backslash in a normal string, we would have to escape it by
    repeating it ( `\\`). Or the regex on line [14] would have to be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Worse yet, if we wanted to match for the backslash itself, we would have to
    escape it as well because of regex. With normal strings, we would have to quadruple-escape
    it! ( `\\\\`)
  prefs: []
  type: TYPE_NORMAL
- en: We can save ourselves the headache of missing readability and confusion by using
    raw strings and write our regex normally. In fact, it is considered good style
    to use raw strings in *every* regex, even when it doesn't have any backslashes
    [33]. This is a help for your future self if you notice down the line that you
    actually would like to use a feature that requires a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: We can iterate over the results of our regex [18]. The object we get on every
    match is a collection of our capture groups. Keep in mind that the zeroeth index
    is always the entire capture [19]. The first index is then the string from our
    first capture group, the second index is the string of the second capture group,
    and so on. [20]. Unfortunately, we do not get a compile-time check on our index,
    so if we accessed `&cap[4]`, our program would compile but then crash during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'When replacing, we follow the same concept: `$0` is the entire match, `$1`
    the result of the first capture group, and so on. To make our life easier, we
    can give the capture groups names by starting them with `?P<somename>`[29] and
    then use this name when replacing [31].'
  prefs: []
  type: TYPE_NORMAL
- en: There are many flags that you can specify, in the form of `(?flag)`, for fine-tuning,
    such as `i`, which makes the match case insensitive [33], or `x`, which ignores
    whitespace in the regex string. If you want to read up on them, visit their documentation
    ([https://doc.rust-lang.org/regex/regex/index.html](https://doc.rust-lang.org/regex/regex/index.html)).
    Most of the time though, you can get the same result by using the `RegexBuilder`
    that is also in the regex crate [36]. Both of the `rust_regex` objects we generate
    in lines [33] and [36] are equivalent. While the second version is definitely
    more verbose, it is also way easier to understand at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The regexes work by compiling their strings into the equivalent Rust code on
    creation. For performance reasons, you are advised to reuse your regexes instead
    of creating them anew every time you use them. A good way of doing this is by
    using the `lazy_static` crate, which we will look at later in the book, in the
    Creating lazy static objects section in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to overdo it with regexes. As they say, "When all you have is
    a hammer, everything looks like a nail." If you parse complicated data, regexes
    can quickly become an unbelievably complex mess. When you notice that your regex
    has become too big to understand at first glance, try to rewrite it as a parser.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating lazy static objects* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    **Advanced Data Structures**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sooner or later, you'll want to interact with the user in some way or another.
    The most basic way to do this is by letting the user pass parameters while calling
    the application through the command line.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `cli_params.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin cli_params some_option
    some_other_option`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling `env::args()` returns an iterator over the provided parameters[6]. By
    convention, the first command-line parameter on most operating systems is the
    path to the executable itself [12].
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access specific parameters in two ways: keep them as an iterator [11]
    or `collect` them into a collection such as `Vec`[23]. Don''t worry, we are going
    to talk about them in detail in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*. For now, it''s enough for you to know that:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an iterator forces you to check at compile time whether the element
    exists, for example, an `if let` binding [12]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a vector checks the validity at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we could have executed lines [26] and [29] without checking
    for their validity first in [25] and [28]. Try it yourself, add the `&args[3];`
    line at the end of the program and run it.
  prefs: []
  type: TYPE_NORMAL
- en: We check the length anyways because it is considered good style to check whether
    the expected parameters were provided. With the iterator way of accessing parameters,
    you don't have to worry about forgetting to check, as it forces you to do it.
    On the other hand, by using a vector, you can check for the parameters once at
    the beginning of the program and not worry about them afterward.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are building a serious command-line utility in the style of *nix tools,
    you will have to parse a lot of different parameters. Instead of reinventing the
    wheel, you should take a look at third-party libraries, such as clap ([https://crates.io/crates/clap](https://crates.io/crates/clap)).
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the Twelve-Factor App ([https://12factor.net/](https://12factor.net/)),
    you should store your configuration in the environment ([https://12factor.net/config](https://12factor.net/config)).
    This means that you should pass values that could change between deployments,
    such as ports, domains, or database handles, as environment variables. Many programs
    also use environment variables to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `env_vars.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin env_vars`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `env::vars()`, we can access an iterator over all the `env var` that were
    set for the current process at the time of execution [6]. This list is pretty
    huge though, as you'll see when running the code, and for the most part, irrelevant
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: It's more practical to access a single `env var` with `env::var()` [26], which
    returns an `Err` if the requested var is either not present or doesn't contain
    valid Unicode. We can see this in action in line [21], where we try to print a
    variable that we just deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because your `env::var` returns a `Result`, you can easily set up default values
    for them by using `unwrap_or_default`. One real-life example of this, involving
    the address of a running instance of the popular Redis ([https://redis.io/](https://redis.io/))
    key-value storage, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that creating an `env var` with `env::set_var()` [13] and deleting
    it with `env::remove_var()` [19] both only change the `env var` for our current
    process. This means that the created `env var` are not going to be readable by
    other programs. It also means that if we accidentally remove an important `env
    var`, the rest of the operating system is not going to care, as it can still access
    it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this recipe, I wrote about storing your configuration in
    the environment. The industry standard way to do this is by creating a file called
    `.env` that contains said config in the form of key-value-pairs, and loading it
    into the process at some point during the build. One easy way to do this in Rust
    is by using the dotenv ([https://crates.io/crates/dotenv](https://crates.io/crates/dotenv))
    third-party crate.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from stdin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to create an interactive application, it's easy to prototype your
    functionality with the command line. For CLI programs, this will be all the interaction
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `stdin.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin stdin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to read from the standard console input, `stdin`, we first need to
    obtain a handle to it. We do this by calling `io::stdin()` [29]. Imagine the returned
    object as a reference to a global `stdin` object. This global buffer is managed
    by a `Mutex`, which means that only one thread can access it at a time (more on
    that later in the book, in the Parallelly accessing resources with Mutexes section
    in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism and Rayon*).
    We get this access by locking (using `lock()`) the buffer, which returns a new
    handle [31]. After we have done this, we can call the `lines` method on it, which
    returns an iterator over the lines the user will write [31 and 52]. More on iterators
    in the *Accessing collections as Iterators* section in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can iterate over as many submitted lines as we want until some kind
    of break condition is reached, otherwise the iteration would go on forever. In
    our example, we break the number-checking loop as soon as a valid number has been
    entered [56].
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re not particularly picky about our input and just want the next line,
    we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: We can continue using the infinite iterator provided by `lines()`, but simply
    call next on it in order to just take the first one. This comes with an additional
    error check as, generally speaking, we cannot guarantee that there is a next element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use `read_line` in order to populate an existing buffer [43]. This doesn't
    require that we `lock` the handler first, as it is done implicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although they both result in the same end effect, you should choose the first
    option. It is more idiomatic as it uses iterators instead of a mutable state,
    which makes it more maintainable and readable.
  prefs: []
  type: TYPE_NORMAL
- en: On a side note, we are using `print!` instead of `println!` in some places in
    this recipe for aesthetic reasons [22]. If you prefer the look of newlines before
    user input, you can refrain from using them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is written with the assumption that you want to use stdin for live
    interaction over the `cli`. If you plan on instead piping some data into it (for
    example, `cat foo.txt | stdin.rs` on *nix), you can stop treating the iterator
    returned by `lines()` as infinite and retrieve the individual lines, not unlike
    how you retrieved the individual parameters in the last recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There are various calls to `trim()` in our recipe [35, 45 and 55]. This method
    removes leading and trailing whitespace in order to enhance the user-friendliness
    of our program. We are going to look at it in detail in the *Using a string* section
    in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Interacting with environment variables* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using a string* and *Accessing collections as iterators recipe* in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parallelly accessing resources with Mutexes* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepting a variable number of arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, when you want to operate on a dataset, you will design a function
    that takes a collection. In some cases, however, it is nice to have functions
    that just accept an unbound amount of parameters, like JavaScript's *rest parameters*.
    This concept is called **variadic functions** and is not supported by Rust. However,
    we can implement it ourselves by defining a recursive macro.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in this recipe might be small, but it will look like gibberish if you're
    not familiar with macros. If you have not yet learned about macros or need a refresh,
    I recommend that you take a quick look at the relevant chapter in the official
    Rust book ([https://doc.rust-lang.org/stable/book/first-edition/macros.html](https://doc.rust-lang.org/stable/book/first-edition/macros.html)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `variadic.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin variadic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with our intention: we want to create a macro called multiply
    that accepts an undefined amount of parameters and multiplies them all together.
    In macros, this is done via recursion. We begin every recursive definition with
    the **edge case**, that is, the parameters where the recursion should stop. Most
    of the time, this is where a function call stops making sense. In our case, this
    is the single parameter. Think about it, what should `multiply!(3)` return? It
    doesn''t make sense to multiply it with anything, since we have no other parameter
    to multiply it with. Our best reaction is to simply return the parameter unmodified.'
  prefs: []
  type: TYPE_NORMAL
- en: Our other condition is a match against more than one parameter, a `$head` and
    a comma-separated list of parameters inside of a `$tail`. Here, we just define
    the return value as the `$head` multiplied with the multiplication of the `$tail`.
    This will call `multiply!` with the `$tail` and without the `$head`, which means
    that on every call we process one parameter less until we finally reach our edge
    case, one single parameter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keep in mind that you should use this technique sparingly. Most of the time,
    it is clearer to just accept and operate on a slice instead. However, it makes
    sense to use this in combination with other macros and higher kinds of concepts
    where the analogy of *a graspable list of things* breaks down. Finding a good
    example for this is difficult since they tend to be extremely specific. You can
    find one of them at the end of the book though.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Composing functions* recipe in [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
