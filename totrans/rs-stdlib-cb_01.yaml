- en: Learning the Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基础知识
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Concatenating strings
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接
- en: Using the format! macro
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 format! 宏
- en: Providing a default implementation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供默认实现
- en: Using the constructor pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造器模式
- en: Using the builder pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构建器模式
- en: Parallelism through simple threads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过简单线程实现并行
- en: Generating random numbers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Querying with regexes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式查询
- en: Accessing the command line
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问命令行
- en: Interacting with environment variables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与环境变量交互
- en: Reading from stdin
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 stdin 读取
- en: Accepting a variable number of arguments
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受可变数量的参数
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: There are some code snippets and patterns of thought that prove time and again
    to be the bread and butter of a certain programming language. We will start this
    book by looking at a handful of such techniques in Rust. They are so quintessential
    for elegant and flexible code that you will use at least some of them in just
    about any project you tackle.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有些代码片段和思维模式一次又一次地证明是某种编程语言的基础。我们将从查看 Rust 中的一些此类技术开始这本书。它们对于编写优雅和灵活的代码至关重要，你几乎会在你处理的任何项目中使用其中的一些。
- en: The next chapters will then build on this foundation and work hand in hand with
    Rust's zero costs abstractions, which are as powerful as the ones in higher-level
    languages. We are also going to look at the intricate inner aspects of the standard
    library and implement our own similar constructs with the help of fearless concurrency
    and careful use of `unsafe` blocks, which enable us to work at the same low level
    that some system languages, such as C, operate at.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将在此基础上构建，并与 Rust 的零成本抽象协同工作，这些抽象与高级语言中的抽象一样强大。我们还将探讨标准库的复杂内部方面，并在无畏并发和谨慎使用
    `unsafe` 块的帮助下实现我们自己的类似结构，这使我们能够以与某些系统语言（如 C 语言）相同的低级别工作。
- en: Concatenating strings
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串连接
- en: String manipulation is typically a bit less straightforward in system programming
    languages than in scripting languages, and Rust is no exception. There are multiple
    ways to do it, all managing the involved resources differently.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程语言中，字符串操作通常比在脚本语言中要复杂一些，Rust 也不例外。有多种方法可以实现，所有这些方法都以不同的方式管理涉及的资源。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will assume for the rest of the book that you have an editor open, the newest
    Rust compiler ready, and a command line available. As of the time of writing,
    the newest version is `1.24.1`. Because of Rust's strong guarantees about backward
    compatibility, you can rest assured that all of the recipes shown (with the exception
    of [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml), *Using Experimental
    Nightly Features*) are always going to work the same way. You can download the
    newest compiler with its command-line tools at [https://www.rustup.rs](https://www.rustup.rs).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设在本书的其余部分，你已打开编辑器，准备就绪的最新 Rust 编译器，以及可用的命令行。截至写作时，最新版本是 `1.24.1`。由于 Rust
    对向后兼容性的强大保证，你可以放心，所有展示的食谱（除第 10 章 [使用实验性夜间功能](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml)外）都将始终以相同的方式工作。你可以通过
    [https://www.rustup.rs](https://www.rustup.rs) 下载最新的编译器和其命令行工具。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a Rust project to work on during this chapter with `cargo new chapter-one`
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new chapter-one` 创建一个 Rust 项目以在本章中工作
- en: Navigate to the newly created `chapter-one` folder. For the rest of this chapter,
    we will assume that your command line is currently in this directory
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的 `chapter-one` 文件夹。在本章的其余部分，我们将假设你的命令行当前位于此目录下
- en: Inside the `src` folder, create a new folder called `bin`
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹内，创建一个名为 `bin` 的新文件夹
- en: Delete the generated `lib.rs` file, as we are not creating a library
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的 `lib.rs` 文件，因为我们没有创建库
- en: In the `src/bin` folder, create a file called `concat.rs`
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中，创建一个名为 `concat.rs` 的文件
- en: 'Add the following code and run it with `cargo run --bin concat`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin concat` 运行它：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In all functions, we start by allocating memory for a string of variable length.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有函数中，我们首先为可变长度的字符串分配内存。
- en: We do this by creating a string slice (`&str`) and applying the `to_string`
    function on it [8, 18 and 28].
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个字符串切片 (`&str`) 并对其应用 `to_string` 函数来实现这一点 [8, 18 和 28]。
- en: 'The first way to concatenate strings in Rust, as shown in the `by_moving` function,
    is by taking said allocated memory and **moving** it, together with an additional
    string slice, into a new variable [12]. This has a couple of advantages:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中连接字符串的第一种方法，如 `by_moving` 函数所示，是通过将分配的内存以及一个额外的字符串切片**移动**到一个新的变量 [12]
    中。这有几个优点：
- en: It's very straightforward and clear to look at, as it follows the common programming
    convention of concatenating with the `+` operator
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它非常直接且清晰，因为它遵循常见的编程约定，即使用 `+` 操作符进行连接
- en: It uses only immutable data. Remember to always try to write code in a style
    that creates as little stateful behavior as possible, as it results in more robust
    and reusable code bases
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只使用不可变数据。请记住，始终尝试编写尽可能少的状态行为代码，因为它会导致更健壮和可重用的代码库
- en: It reuses the memory allocated by `hello` [8], which makes it very performant
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它重用了 `hello` 分配的内存 [8]，这使得它非常高效
- en: As such, this way of concatenating should be preferred whenever possible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在可能的情况下，应该优先选择这种方式进行连接。
- en: 'So, why would we even list other ways to concatenate strings? Well, I''m glad
    you asked, dear reader. Although elegant, this approach comes with two downsides:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们还要列出其他连接字符串的方法呢？好吧，我很高兴你问了，亲爱的读者。虽然这种方法很优雅，但它有两个缺点：
- en: '`hello` is no longer usable after line [12], as it was moved. This means you
    can no longer read it in any way'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [12] 行之后，`hello` 就不再可用，因为它已经被移动。这意味着你不能再以任何方式读取它
- en: Sometimes you may actually prefer mutable data in order to use state in small,
    contained environments
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，你可能实际上更喜欢可变数据，以便在小型、封闭的环境中使用状态
- en: The two remaining functions address one concern each.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个函数分别解决一个关注点。
- en: '`by_cloning`[17] looks nearly identical to the first function, but it clones
    the allocated string [22] into a temporary object, allocating new memory in the
    process, which it then moves, leaving the original `hello` untouched and still
    accessible. Of course, this comes at the price of redundant memory allocations
    at runtime.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`by_cloning`[17] 几乎与第一个函数相同，但它将分配的字符串 [22] 克隆到一个临时对象中，在这个过程中分配新的内存，然后将其移动，这样原始的
    `hello` 就不会被修改，仍然可访问。当然，这会带来运行时冗余内存分配的代价。'
- en: '`by_mutating`[27] is the stateful way of solving our problem. It performs the
    involved memory management in-place, which means that the performance should be
    the same as in `by_moving`. In the end, it leaves `hello` mutable, ready for further
    changes. You may notice that this function doesn''t look as elegant as the others,
    as it doesn''t use the `+` operator. This is intentional, as Rust tries to push
    you through its design towards moving data in order to create new variables without
    mutating existing ones. As mentioned before, you should only do this if you really
    need mutable data or want to introduce state in a very small and manageable context.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`by_mutating`[27] 是解决我们问题的有状态方法。它就地执行涉及的内存管理，这意味着性能应该与 `by_moving` 相同。最后，它将
    `hello` 设置为可变，以便进行进一步更改。你可能注意到这个函数看起来不像其他函数那么优雅，因为它没有使用 `+` 操作符。这是故意的，因为 Rust
    尝试通过其设计推动你通过移动数据来创建新变量，而不是修改现有变量。如前所述，你只有在真正需要可变数据或想在非常小且可管理的环境中引入状态时才应该这样做。'
- en: Using the format! macro
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用格式化宏
- en: There is an additional way to combine strings, which can also be used to combine
    them with other data types, such as numbers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种组合字符串的方法，也可以用来与其他数据类型（如数字）组合。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the `src/bin` folder, create a file called `format.rs`
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中，创建一个名为 `format.rs` 的文件
- en: Add the following code and run it with `cargo run --bin format`
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin format` 运行它
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `format!` macro combines strings by accepting a format string filled with
    formatting parameters (example, `{}`, `{0}`, or `{foo}`) and a list of arguments,
    which are then inserted into the *placeholders*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`format!` 宏通过接受一个填充有格式化参数（例如，`{}`、`{0}` 或 `{foo}`）的格式字符串和一组参数来组合字符串，然后这些参数被插入到**占位符**中。'
- en: 'We are now going to show this on the example in line [16]:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在第 [16] 行的示例中展示这一点：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s break down the preceding line of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下前面的代码行：
- en: '`"My favourite number is {}"` is the format string'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"My favourite number is {}"` 是格式字符串'
- en: '`{}` is the formatting parameter'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}` 是格式化参数'
- en: '`42` is the argument'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`42` 是参数'
- en: As demonstrated, `format!` works not only with strings, but also with numbers.
    In fact, it works with all `structs` that implement the `Display` trait. This
    means that, by providing such an implementation by yourself, you can easily make
    your own data structures printable however you want.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`format!`不仅与字符串一起工作，还与数字一起工作。实际上，它与实现`Display`特质的任何`struct`一起工作。这意味着，通过你自己提供这样的实现，你可以轻松地使你的数据结构以任何你想要的方式可打印。
- en: By default, `format!` replaces one parameter after another. If you want to override
    this behavior, you can use positional parameters like `{0}` [21]. With the knowledge
    that the positions are zero-indexed, the behavior here is pretty straightforward, `{0}`
    gets replaced by the first argument, `{1}` gets replaced by the second, and so
    on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`format!`会依次替换一个参数。如果你想覆盖这种行为，你可以使用位置参数，如`{0}`[21]。了解位置是从零开始的，这里的操作非常直接，`{0}`被第一个参数替换，`{1}`被第二个参数替换，以此类推。
- en: 'At times, this can become a bit unwieldy when using a lot of parameters. For
    this purpose, you can use named arguments [26], just like in Python. Keep in mind
    that all of your unnamed arguments have to be placed before your named ones. For
    example, the following is invalid:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当使用大量参数时，这可能会变得有些难以控制。为此，你可以使用命名参数[26]，就像在Python中一样。记住，你所有的未命名参数都必须放在你的命名参数之前。例如，以下是不合法的：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It should be rewritten as:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应该重写为：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can combine positional parameters with normal ones, but it''s probably
    not a good idea, as it can quite easily become confusing to look at. The behavior,
    in this case, is as follows—imagine that `format!` internally uses a counter to
    determine which argument is the next to be placed. This counter is increased whenever
    `format!` encounters a `{}` *without* a position in it. This rule results in the
    following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将位置参数与普通参数结合使用，但这可能不是一个好主意，因为它很容易变得难以理解。在这种情况下，行为如下——想象一下`format!`在内部使用一个计数器来确定下一个要放置的参数。每当`format!`遇到一个没有位置的`{}`时，这个计数器就会增加。这个规则导致以下结果：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are also a ton of extra formatting options if you want to display your
    data in different formats. `{:?}` prints the implementation of the `Debug` trait
    for the respective argument, often resulting in a more verbose output. `{:.*}`
    lets you specify the decimal precision of floating point numbers via the argument,
    like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以不同的格式显示你的数据，还有很多额外的格式化选项。`{:?}`打印出相应参数的`Debug`特质的实现，通常会产生更冗长的输出。`{:.*}`允许你通过参数指定浮点数的十进制精度，如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For a complete list, visit [https://doc.rust-lang.org/std/fmt/](https://doc.rust-lang.org/std/fmt/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整列表，请访问[https://doc.rust-lang.org/std/fmt/](https://doc.rust-lang.org/std/fmt/)。
- en: All of the information in this recipe applies to `println!` and `print!` as
    well, as it is essentially the same macro. The only difference is that `println!`
    doesn't return its processed string but instead, well, prints it!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的所有信息都适用于`println!`和`print!`，因为它们本质上是一个宏。唯一的区别是`println!`不返回其处理后的字符串，而是直接打印出来！
- en: Providing a default implementation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供默认实现
- en: Often, when dealing with structures that represent configurations, you don't
    care about certain values and just want to silently assign them a standard value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当处理表示配置的结构时，你不需要关心某些值，只想默默地给它们分配一个标准值。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the `src/bin` folder, create a file called `default.rs`
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`default.rs`的文件
- en: 'Add the following code and run it with `cargo run --bin default`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用`cargo run --bin default`运行它：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Nearly every type in Rust has a `Default` implementation. When you define your
    own `struct` that only contains elements that already have a `Default`, you have
    the option to derive from `Default` as well [42]. In the case of enums or complex
    structs, you can easily write your own implementation of `Default` instead [55],
    as there''s only one method you have to provide. After this, the `struct` returned
    by `Default::default()` is implicitly inferrable as yours, if you tell the compiler
    what your type actually is. This is why in line [3] we have to write `foo: i32`,
    or else Rust wouldn''t know what type the default object actually should become.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '几乎Rust中的每个类型都有一个`Default`实现。当你定义自己的`struct`，且它只包含已经具有`Default`的元素时，你可以选择从`Default`派生[42]。在枚举或复杂结构体的情况下，你可以轻松地编写自己的`Default`实现[55]，因为只需提供一个方法。之后，`Default::default()`返回的`struct`会隐式推断为你的类型，前提是你告诉编译器你的类型实际是什么。这就是为什么在行[3]中我们必须写`foo:
    i32`，否则Rust不知道默认对象实际上应该变成什么类型。'
- en: If you only want to specify some elements and leave the others at the default,
    you can use the syntax in line [29]. Keep in mind that you can configure and skip
    as many values as you want, as shown in lines [33 to 37].
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想指定一些元素并让其他元素保持默认值，你可以使用行[29]中的语法。记住，你可以配置和跳过你想要的任意多个值，如行[33到37]所示。
- en: Using the constructor pattern
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造函数模式
- en: You may have asked yourself how to idiomatically initialize complex structs
    in Rust, considering it doesn't have constructors. The answer is simple, there
    is a constructor, it's just a convention rather than a rule. Rust's standard library
    uses this pattern very often, so we need to understand it if we want to use the
    std effectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经问过自己如何在Rust中惯用方式初始化复杂结构体，考虑到它没有构造函数。答案是简单的，有一个构造函数，它只是一种约定而不是规则。Rust的标准库经常使用这种模式，所以如果我们想有效地使用std，我们需要理解它。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we are going to talk about how a **user** interacts with a `struct`.
    When we say *user* in this context, we don't mean the end user that clicks on
    the GUI of the app you're writing. We're referring to the programmer that instantiates
    and manipulates the `struct`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论用户如何与`struct`交互。当我们在这个上下文中说“用户”时，我们不是指点击你编写应用程序GUI的最终用户。我们指的是实例化和操作`struct`的程序员。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the `src/bin` folder, create a file called `constructor.rs`
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`constructor.rs`的文件
- en: 'Add the following code and run it with `cargo run --bin constructor`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用`cargo run --bin constructor`运行它：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If a `struct` provides a method called `new` that returns `Self`, the user of
    the `struct` will not configure or depend upon the members of the `struct`, as
    they are considered to be in an internal *hidden* state.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`struct`提供了一个返回`Self`的`new`方法，那么`struct`的使用者将不会配置或依赖于`struct`的成员，因为它们被认为是处于内部*隐藏*状态。
- en: In other words, if you see a `struct` that has a `new` function, always use
    it to create the structure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果你看到一个具有`new`函数的`struct`，总是使用它来创建结构体。
- en: This has the nice effect of enabling you to change as many members of the struct
    as you want without the user noticing anything, as they are not supposed to look
    at them anyway.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个很好的效果，就是允许你更改结构体的任意多个成员，而用户不会注意到任何变化，因为他们本来就不应该查看它们。
- en: The other reason to use this pattern is to guide the user to the correct way
    of instantiating a `struct`. If one has nothing but a big list of members that
    have to be filled with values, one might feel a bit lost. If one, however, has
    a method with only a few self-documenting parameters, it feels way more inviting.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式的另一个原因是引导用户以正确的方式实例化`struct`。如果有一个只有一大堆成员需要填充值的列表，用户可能会感到有些迷茫。然而，如果有一个只有几个自文档化参数的方法，感觉会更有吸引力。
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might have noticed that for our example we really didn't need a `length`
    member and could have just calculated a length whenever we print. We use this
    pattern anyway, to illustrate the point of its usefulness in hiding implementations.
    Another good use for it is when the members of a `struct` themselves have their
    own constructors and one needs to *cascade* the constructor calls. This happens,
    for example, when we have a `Vec` as a member, as we will see later in the book,
    in the, *Using a vector* section in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，对于我们的示例，我们实际上并不需要一个`length`成员，我们可以在打印时随时计算长度。我们仍然使用这种模式，以说明它在隐藏实现方面的有用性。它的另一个很好的用途是，当`struct`的成员本身有自己的构造函数，并且需要*级联*构造函数调用时。例如，当我们有一个`Vec`作为成员时，就像我们将在本书后面的*使用向量*部分中看到的那样，在[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*处理集合*部分。
- en: Sometimes, your structs might need more than one way to initialize themselves.
    When this happens, try to still provide a `new()` method as your default way of
    construction and name the other options according to how they differ from the
    default. A good example of this is again vector, which not only provides a `Vec::new()`
    constructor but also a `Vec::with_capacity(10)`, which initializes it with enough
    space for `10` items. More on that again in the Using a vector section in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的结构体可能需要多种初始化方式。当这种情况发生时，请尝试仍然提供一个`new()`方法作为你的默认构造方式，并将其他选项根据它们与默认方式的差异进行命名。一个很好的例子又是向量，它不仅提供了一个`Vec::new()`构造函数，还提供了一个`Vec::with_capacity(10)`，它为`10`个元素初始化了足够的空间。更多关于这一点的内容，请参阅[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*处理集合*部分。
- en: 'When accepting a kind of string (either `&str`, that is, a borrowed string
    slice, or `String`, that is, an owned string) with plans to store it in your `struct`,
    like we do in our example, also considering a `Cow`. No, not the big milk animal
    friends. A `Cow` in Rust is a *Clone On Write* wrapper around a type, which means
    that it will try to borrow a type for as long as possible and only make an owned
    clone of the data when absolutely necessary, which happens at the first mutation.
    The practical effect of this is that, if we rewrote our `NameLength` struct in
    the following way, it would not care whether the called passed a `&str` or a `String`
    to it, and would instead try to work in the most efficient way possible:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当接受一种字符串类型（无论是`&str`，即借用字符串切片，还是`String`，即拥有字符串）并计划将其存储在你的`struct`中，就像我们在示例中所做的那样，同时考虑一个`Cow`。不，不是那些大牛奶动物朋友。在Rust中，`Cow`是一个围绕类型的*写时复制*包装器，这意味着它将尽可能尝试借用类型，只有在绝对必要时才会创建数据的拥有副本，这发生在第一次变异时。这种实际效果是，如果我们以以下方式重写我们的`NameLength`结构体，它将不会关心调用者传递给它的是`&str`还是`String`，而会尝试以最有效的方式工作：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you want to read more about `Cow`, check out this easy-to-understand blog
    post by Joe Wilm: [https://jwilm.io/blog/from-str-to-cow/](https://jwilm.io/blog/from-str-to-cow/).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`Cow`的信息，请查看Joe Wilm的这篇易于理解的博客文章：[https://jwilm.io/blog/from-str-to-cow/](https://jwilm.io/blog/from-str-to-cow/)。
- en: The `Into` trait used in the `Cow` code is going to be explained in the Converting
    types into each other section in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cow`代码中使用的`Into`特质将在[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*部分的*将类型转换为彼此*部分中进行解释。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using a vector* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用向量*配方在[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*处理集合*'
- en: '*Converting types into each other* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将类型转换为彼此*配方在[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*'
- en: Using the builder pattern
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构建器模式
- en: Sometimes you need something between the customization of the constructor and
    the implicitness of the default implementation. Enter the builder pattern, another
    technique frequently used by the Rust standard library, as it allows a caller
    to fluidly chain together configurations that they care about and lets them ignore
    details that they don't care about.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要介于构造函数的定制和默认实现的隐式性之间的某种东西。构建器模式就出现了，这是Rust标准库中经常使用的一种技术，因为它允许调用者流畅地连接他们关心的配置，并让他们忽略他们不关心的细节。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In the `src/bin` folder, create a file called `builder.rs`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`builder.rs`的文件
- en: 'Add all of the following code and run it with `cargo run --bin builder`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下所有代码并使用 `cargo run --bin builder` 运行它：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the configurable object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可配置的对象：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And this is the builder itself. It is used to configure and create a `Burger`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是构建器本身。它用于配置和创建一个 `Burger`：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Whew, that's a lot of code! Let's start by breaking it up.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这是一大堆代码！让我们先把它拆分开来。
- en: 'In the first part, we illustrate how to use this pattern to effortlessly configure
    a complex object. We do this by relying on sensible standard values and only specifying
    what we really care about:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们展示了如何使用这种模式轻松地配置一个复杂的对象。我们通过依赖合理的标准值，只指定我们真正关心的内容来实现这一点：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code reads pretty nicely, doesn't it?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码读起来相当清晰，不是吗？
- en: In our version of the builder pattern, we return the object wrapped in a `Result`
    in order to tell the world that there are certain invalid configurations and that
    our builder might not always be able to produce a valid product. Because of this,
    we have to check the validity of our burger before accessing it[7, 10 and 13].
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构建器模式版本中，我们返回一个包裹在 `Result` 中的对象，以便告诉世界存在某些无效配置，并且我们的构建器可能无法始终生成有效的产品。正因为如此，我们必须在访问它之前检查汉堡的有效性[7,
    10 和 13]。
- en: 'Our invalid configuration is `vegetarian(true)` and `bacon(true)`. Unfortunately,
    our restaurant doesn''t serve vegetarian bacon yet! When you start the program,
    you will see that the following line will print an error:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的无效配置是 `vegetarian(true)` 和 `bacon(true)`。不幸的是，我们的餐厅还没有提供素食培根！当你启动程序时，你会看到以下行会打印出一个错误：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we omit the final `build` step, we can reuse the builder in order to build
    as many objects as we want. [25 to 32]
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略最后的 `build` 步骤，我们可以重复使用构建器来构建我们想要的任意数量的对象。[25 到 32]
- en: Let's see how we implemented all of this. The first thing after the `main` function
    is the definition of our `Burger` struct. No surprises here, it's just plain old
    data. The `print` method is just here to provide us with some nice output during
    runtime. You can ignore it if you want.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何实现所有这些的。在 `main` 函数之后的第一件事是我们 `Burger` 结构体的定义。这里没有惊喜，它只是普通的老数据。`print`
    方法只是在这里提供一些在运行时的一些漂亮的输出。如果你想的话可以忽略它。
- en: The real logic is in the `BurgerBuilder`[64]. It should have one member for
    every value you want to configure. As we want to configure every aspect of our
    burger, we will have the exact same members as `Burger`. In the constructor [74],
    we can specify some default values. We then create one method for every configuration.
    In the end, in `build()` [109], we first perform some error checking. If the configuration
    is OK, we return a `Burger` made out of all of our members [121]. Otherwise, we
    return an error [119].
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的逻辑在 `BurgerBuilder`[64] 中。它应该为每个你想要配置的值有一个成员。由于我们想要配置汉堡的每个方面，我们将有与 `Burger`
    完全相同的成员。在构造函数 [74] 中，我们可以指定一些默认值。然后我们为每个配置创建一个方法。最后，在 `build()` [109] 中，我们首先执行一些错误检查。如果配置是正确的，我们返回由所有成员组成的
    `Burger`[121]。否则，我们返回一个错误[119]。
- en: There's more...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you want your object to be constructable without a builder, you could also
    provide `Burger` with a `Default` implementation. `BurgerBuilder::new()` could
    then just return `Default::default()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的对象可以在没有构建器的情况下构建，你也可以为 `Burger` 提供一个 `Default` 实现。`BurgerBuilder::new()`
    然后可以简单地返回 `Default::default()`。
- en: In `build()`, if your configuration can inherently not be invalid, you can,
    of course, return the object directly without wrapping it in a `Result`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `build()` 中，如果你的配置本质上不能是无效的，你当然可以直接返回对象，而无需将其包裹在 `Result` 中。
- en: Parallelism through simple threads
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过简单线程实现并行
- en: Every year, parallelism and concurrency become more important as processors
    tend to have more and more physical cores. In most languages, writing parallel
    code is tricky. Very tricky. Not so in Rust, as it has been designed around the
    principle of *fearless concurrency* since the beginning.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每年，随着处理器物理核心数量的不断增加，并行性和并发性变得越来越重要。在大多数语言中，编写并行代码是棘手的。非常棘手。但在 Rust 中不是这样，因为它从一开始就被设计为围绕
    *无惧并发* 原则。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the `src/bin` folder, create a file called `parallelism.rs`
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中，创建一个名为 `parallelism.rs` 的文件
- en: Add the following code and run it with `cargo run --bin parallelism`
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并使用 `cargo run --bin parallelism` 运行它
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can create a new thread by calling `thread::spawn`, which will then begin
    executing the provided lambda. This will return a `JoinHandle`, which you can
    use to, well, join the thread. Joining a thread means waiting for the thread to
    finish its work. If you don't join a thread, you have no guarantee of it actually
    ever finishing. This might be valid though when setting up threads to do tasks
    that never complete, such as listening for incoming connections.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`thread::spawn`来创建一个新的线程，然后它将开始执行提供的lambda表达式。这将返回一个`JoinHandle`，你可以用它来，嗯，连接线程。连接一个线程意味着等待线程完成其工作。如果你不连接一个线程，你无法保证它实际上会完成。然而，当设置线程来执行永远不会完成的任务时，比如监听传入的连接，这可能是有效的。
- en: Keep in mind that you cannot predetermine the order in which your threads will
    complete any work. In our example, it is impossible to foretell whether *Hello
    from a new thread!* or *Hello from the main thread!* is going to be printed first,
    although most of the time it will probably be the main thread, as the operating
    system needs to put some effort into spawning a new thread. This is the reason
    why small algorithms can be faster when not executed in parallel. Sometimes, the
    overhead of letting the OS spawn and manage new threads is just not worth it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你不能预知你的线程完成任何工作的顺序。在我们的例子中，无法预测是*来自新线程的问候！*还是*来自主线程的问候！*将被首先打印出来，尽管大多数时候可能是主线程，因为操作系统需要付出一些努力来创建一个新的线程。这就是为什么小型算法在不并行执行时可能会更快。有时，让操作系统创建和管理新线程的开销可能根本不值得。
- en: As demonstrated by line [49], joining a thread will return a `Result` that contains
    the value your lambda returned.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如行[49]所示，连接一个线程将返回一个包含你的lambda返回值的`Result`。
- en: Threads can also be given names. Depending on your OS, in case of a crash, the
    name of the responsible thread will be displayed. In line [37], we call our new
    summation threads *calculation*. If one of them were to crash, we would be able
    to quickly identify the issue. Try it out for yourself, insert a call to `panic!();`
    at the beginning of `sum_bucket` in order to intentionally crash the program and
    run it. If your OS supports named threads, you will now be told that your thread
    *calculation* panicked with an *explicit panic*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 线程也可以被赋予名称。根据你的操作系统，在崩溃的情况下，将显示负责线程的名称。在行[37]中，我们将我们的新求和线程命名为*calculation*。如果其中任何一个崩溃，我们就能快速识别问题。自己试试，在`sum_bucket`的开始处插入对`panic!();`的调用，以故意崩溃程序并运行它。如果你的操作系统支持命名线程，你现在将被告知你的线程*calculation*因为*显式恐慌*而崩溃。
- en: '`parallel_sum` is a function that takes a slice of integers and adds them together
    in parallel on four threads. If you have limited experience in working with parallel
    algorithms, this function will be hard to grasp at first. I invite you to copy
    it by hand into your text editor and play around with it in order to get a grasp
    on it. If you still feel a bit lost, don''t worry, we will revisit parallelism
    again later.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel_sum`是一个函数，它接受一个整数切片并在四个线程上并行地将它们相加。如果你在处理并行算法方面经验有限，这个函数一开始可能很难理解。我邀请你手动将其复制到你的文本编辑器中，并对其进行操作，以便掌握它。如果你仍然感到有些迷茫，不要担心，我们稍后会再次讨论并行性。'
- en: 'Adapting algorithms to run in parallel normally comes at the risk of data races.
    A data race is defined as the behavior in a system where the output is dependent
    on the random timing of external events. In our case, having a data race would
    mean that multiple threads try to access and modify a resource at the same time.
    Normally, programmers have to analyze their usage of resources and use external
    tools in order to catch all of the data races. In contrast, Rust''s compiler is
    smart enough to catch data races at compile time and stops if it finds one. This
    is the reason why we had to call `.to_vec()` in line [35]:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将算法调整为并行运行通常伴随着数据竞争的风险。数据竞争被定义为系统中的行为，其输出依赖于外部事件的随机时间。在我们的例子中，存在数据竞争意味着多个线程试图同时访问和修改一个资源。通常，程序员必须分析他们资源的用法并使用外部工具来捕捉所有的数据竞争。相比之下，Rust的编译器足够智能，可以在编译时捕捉到数据竞争，并在发现一个时停止。这就是为什么我们不得不在行[35]中调用`.to_vec()`的原因：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will cover vectors in a later recipe (the *Using a vector* section in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*), so
    if you're curious about what is happening here, feel free to jump to [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections* and
    come back again. The essence of it is that we're copying the data into `bucket`.
    If we instead passed a reference into `sum_bucket` in our new thread, we would
    have a problem, the memory referenced by `range` is only guaranteed to live inside
    of `parallel_sum`, but the threads we spawn are allowed to outlive their parent
    threads. This would mean that in theory, if we didn't `join` the threads at the
    right time, `sum_bucket` might get unlucky and get called late enough for `range`
    to be invalid.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的配方中介绍向量（第 2 章[Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*与集合一起工作*中的*使用向量*部分），所以如果你对此感兴趣，请随时跳转到第
    2 章[Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*与集合一起工作*，然后再回来。其本质是我们将数据复制到
    `bucket` 中。如果我们在新线程中将引用传递给 `sum_bucket`，我们就会遇到问题，`range` 引用的内存只保证在 `parallel_sum`
    内部存在，但我们的线程允许比父线程存活更久。这意味着理论上，如果我们没有在正确的时间 `join` 线程，`sum_bucket` 可能会不幸地太晚被调用，以至于
    `range` 已经无效。
- en: This would then be a data race, as the outcome of our function would depend
    on the uncontrollable sequence in which our operating system decides to launch
    the threads.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就会产生数据竞争，因为我们的函数的结果将取决于操作系统决定启动线程的不可控序列。
- en: But don't just take my word for it, try it yourself. Simply replace the aforementioned
    line with `let bucket = &range[count..count + bucket_size];` and try to compile
    it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要只听我的话，自己试试。只需将上述行替换为 `let bucket = &range[count..count + bucket_size];` 并尝试编译它。
- en: There's more...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you're experienced with parallelism, you might have noticed how suboptimal
    our algorithm here is. This is intentional, as the elegant and efficient way of
    writing `parallel_sum` would require using techniques we have not discussed yet.
    We will revisit this algorithm in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism
    and Rayon*, and rewrite it in a professional manner. In that chapter, we will
    also learn how to concurrently modify resources using locks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉并行处理，你可能已经注意到我们这里的算法不是很优化。这是故意的，因为编写 `parallel_sum` 的优雅和高效方式需要使用我们尚未讨论的技术。我们将在第
    7 章[Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)，*并行性和 Rayon*中重新审视这个算法，并以专业的方式重写它。在第
    7 章，我们还将学习如何使用锁并发修改资源。
- en: See also
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Access resources in parallel with RwLocks*, recipe in  [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism
    and Rayon*'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 RwLocks 并行访问资源*，请参考第 7 章[Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)中的配方，*并行性和
    Rayon*'
- en: Generating random numbers
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数
- en: As described in the preface, the Rust core team left some functionality intentionally
    out of the standard and put it into its own external crate. Generating pseudo-random
    numbers is one such functionality.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前言所述，Rust 核心团队有意将一些功能从标准库中移除，并将其放入自己的外部crate中。生成伪随机数就是这样一种功能。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open the `Cargo.toml` file that was generated earlier for you
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的 `Cargo.toml` 文件
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下添加以下行：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you want, you can go to rand's crates.io page ([https://crates.io/crates/rand](https://crates.io/crates/rand))
    to check for the newest version and use that one instead
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想，你可以访问 rand 的 crates.io 页面([https://crates.io/crates/rand](https://crates.io/crates/rand))来检查最新版本，并使用那个版本。
- en: In the `bin` folder, create a file called `rand.rs`
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `rand.rs` 的文件
- en: 'Add the following code and run it with `cargo run --bin rand`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用 `cargo run --bin rand` 运行它：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before you can use `rand`, you have to tell Rust that you''re using the `crate`
    by writing:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够使用 `rand` 之前，你必须告诉 Rust 你正在使用 `crate`，方法是编写：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After that, `rand` will provide a random generator. We can access it by either
    calling `rand::random();` [6] or by accessing it directly with `rand::thread_rng();`
    [22].
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`rand` 将提供随机数生成器。我们可以通过调用 `rand::random();` [6] 或直接使用 `rand::thread_rng();`
    [22] 来访问它。
- en: If we go the first route, the generator will need to be told what type to generate.
    You can either explicitly state the type in the method call [6] or annotate the
    type of the resulting variable [8]. Both are equal and result in the exact same
    thing. Which one you use is up to you. In this book, we will use the first convention.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择第一条路线，生成器需要被告知要生成哪种类型。你可以在方法调用中明确指定类型[6]或者注释结果的变量类型[8]。两者都是等效的，并且会产生完全相同的结果。你使用哪一种取决于你。在这本书中，我们将使用第一种约定。
- en: As you can see in lines [29 and 33], you need neither if the type is unambiguous
    in the called context.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在行[29和33]中看到的，如果你在调用上下文中类型是明确的，你不需要`if`。
- en: 'The generated value will be between its type''s `MIN` and `MAX` constants.
    In the case of `i32`, this would be `std::i32::MIN` and `std::i32::MAX`, or, in
    concrete numbers, -2147483648 and 2147483647\. You can verify these numbers easily
    by calling the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的值将在其类型的`MIN`和`MAX`常量之间。对于`i32`来说，这将是从`std::i32::MIN`和`std::i32::MAX`，或者具体数字是-2147483648和2147483647。你可以通过调用以下内容来轻松验证这些数字：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, these are very big numbers. For most purposes, you will probably
    want to define custom limits. You can go the second route discussed earlier and
    use `rand::Rng` for that[22]. It has a `gen` method, which is actually implicitly
    called by `rand::random()`, but also a `gen_range()` that accepts a minimum and
    maximum value. Keep in mind that this range is non-inclusive, which means that
    the maximum value can never be reached. This is why in line [29], `rng.gen_range(0,
    10)` will only generate the numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9, without
    the 10.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些数字非常大。对于大多数用途，你可能需要定义自定义限制。你可以走之前讨论的第二条路线，并使用`rand::Rng`来实现[22]。它有一个`gen`方法，实际上这个方法被`rand::random()`隐式调用，还有一个`gen_range()`方法，它接受最小值和最大值。记住，这个范围是非包含的，这意味着最大值永远不会被达到。这就是为什么在行[29]中，`rng.gen_range(0,
    10)`只会生成数字0, 1, 2, 3, 4, 5, 6, 7, 8, 9，而不包括10。
- en: All of the described ways of generating random values use **uniform distribution**,
    which means that every number in the range has the same chance of being generated.
    In some contexts, it makes sense to use other distributions. You can specify a
    generator's distribution during its creation[40]. As of the time of publication,
    the rand crate supports the ChaCha and ISAAC distributions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的所有生成随机值的方法都使用**均匀分布**，这意味着范围内的每个数字都有相同的机会被生成。在某些上下文中，使用其他分布是有意义的。你可以在创建生成器时指定生成器的分布[40]。截至出版时，rand
    crate支持ChaCha和ISAAC分布。
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you want to randomly populate an entire `struct`, you use the `rand_derive`
    helper crate in order to derive it from **Rand**. You can then generate your own
    `struct`, just as you would generate any other type.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要随机填充整个`struct`，你可以使用`rand_derive`辅助crate来从**Rand**派生它。然后你可以生成自己的`struct`，就像生成任何其他类型一样。
- en: Querying with regexes
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式查询
- en: When parsing simple data formats, it is often easier to write regular expressions
    (or *regex* for short) than use a parser. Rust has pretty decent support for this
    through its `regex` crate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析简单数据格式时，编写正则表达式（或简称*regex*）通常比使用解析器更容易。Rust通过其`regex`crate提供了相当不错的支持。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to really understand this chapter, you should be familiar with regexes.
    There are countless free online resources for this, like regexone ([https://www.regexone.com/](https://www.regexone.com/)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正理解这一章，你应该熟悉正则表达式。网上有无数免费资源，比如regexone ([https://www.regexone.com/](https://www.regexone.com/))。
- en: This recipe will not conform to clippy, as we kept the regexes intentionally
    *too* simple because we want to keep the focus of the recipe on the code, not
    the regex. Some of the examples shown could have been rewritten to use `.contains()`
    instead.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方不会符合clippy，因为我们故意使正则表达式**过于**简单，因为我们想将配方的重点放在代码上，而不是正则表达式上。一些显示的示例可以被重写以使用`.contains()`。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `Cargo.toml` file that was generated earlier for you
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`下添加以下行：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you want, you can go to regex's crates.io page ([https://crates.io/crates/regex](https://crates.io/crates/regex))
    to check for the newest version and use that one instead
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以访问正则表达式的crates.io页面([https://crates.io/crates/regex](https://crates.io/crates/regex))来检查最新版本并使用它。
- en: In the `bin` folder, create a file called `regex.rs`
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`regex.rs`的文件。
- en: 'Add the following code and run it with `cargo run --bin regex`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin regex`运行它：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can construct a regex object by calling `Regex::new()` with a valid regex
    string[7]. Most of the time, you will want to pass a *raw string* in the form
    of `r"..."`. Raw means that all symbols in the string are taken at literal value
    without being escaped. This is important because of the backslash (`\`) character
    that is used in regex to represent a couple of important concepts, such as digits(`\d`)
    or whitespace (`\s`). However, Rust already uses the backslash to escape special
    *non-printable* symbols, such as the newline (`\n`) or the tab (`\t`)[23]. If
    we wanted to use a backslash in a normal string, we would have to escape it by
    repeating it ( `\\`). Or the regex on line [14] would have to be rewritten as:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`Regex::new()`并传递一个有效的正则表达式字符串来构建一个正则表达式对象[7]。大多数情况下，你将想要传递一个形式为`r"..."`的原始字符串。原始字符串意味着字符串中的所有符号都被当作字面值处理，而不需要转义。这很重要，因为正则表达式使用反斜杠(`\`)字符来表示一些重要概念，例如数字(`\d`)或空白(`\s`)。然而，Rust已经使用反斜杠来转义特殊*不可打印*符号，例如换行符(`\n`)或制表符(`\t`)[23]。如果我们想在普通字符串中使用反斜杠，我们必须通过重复它来转义（`\\`）。或者第[14]行的正则表达式必须被重写为：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Worse yet, if we wanted to match for the backslash itself, we would have to
    escape it as well because of regex. With normal strings, we would have to quadruple-escape
    it! ( `\\\\`)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，如果我们想匹配反斜杠本身，我们也必须因为正则表达式而转义它！在普通字符串中，我们必须四次转义它！（`\\\\`）
- en: We can save ourselves the headache of missing readability and confusion by using
    raw strings and write our regex normally. In fact, it is considered good style
    to use raw strings in *every* regex, even when it doesn't have any backslashes
    [33]. This is a help for your future self if you notice down the line that you
    actually would like to use a feature that requires a backslash.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用原始字符串来避免丢失可读性和混淆，并正常编写我们的正则表达式。实际上，在*每个*正则表达式中使用原始字符串被认为是一种良好的风格，即使它没有反斜杠[33]。这有助于你未来的自己，如果你发现你实际上确实想使用需要反斜杠的功能。
- en: We can iterate over the results of our regex [18]. The object we get on every
    match is a collection of our capture groups. Keep in mind that the zeroeth index
    is always the entire capture [19]. The first index is then the string from our
    first capture group, the second index is the string of the second capture group,
    and so on. [20]. Unfortunately, we do not get a compile-time check on our index,
    so if we accessed `&cap[4]`, our program would compile but then crash during runtime.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历我们的正则表达式的结果[18]。每次匹配时我们得到的对象是我们捕获组的集合。请注意，零索引始终是整个捕获[19]。第一个索引然后是我们第一个捕获组的字符串，第二个索引是第二个捕获组的字符串，依此类推。[20]。不幸的是，我们没有在索引上获得编译时检查，所以如果我们访问`&cap[4]`，我们的程序会编译，但在运行时崩溃。
- en: 'When replacing, we follow the same concept: `$0` is the entire match, `$1`
    the result of the first capture group, and so on. To make our life easier, we
    can give the capture groups names by starting them with `?P<somename>`[29] and
    then use this name when replacing [31].'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换时，我们遵循相同的概念：`$0`是整个匹配，`$1`是第一个捕获组的结果，依此类推。为了使我们的生活更轻松，我们可以通过从`?P<somename>`开始给捕获组命名，然后在替换时使用这个名称[29][31]。
- en: There are many flags that you can specify, in the form of `(?flag)`, for fine-tuning,
    such as `i`, which makes the match case insensitive [33], or `x`, which ignores
    whitespace in the regex string. If you want to read up on them, visit their documentation
    ([https://doc.rust-lang.org/regex/regex/index.html](https://doc.rust-lang.org/regex/regex/index.html)).
    Most of the time though, you can get the same result by using the `RegexBuilder`
    that is also in the regex crate [36]. Both of the `rust_regex` objects we generate
    in lines [33] and [36] are equivalent. While the second version is definitely
    more verbose, it is also way easier to understand at first glance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定许多标志，形式为`(?flag)`，用于微调，例如`i`，它使匹配不区分大小写[33]，或者`x`，它在正则表达式中忽略空白。如果你想了解更多，请访问它们的文档([https://doc.rust-lang.org/regex/regex/index.html](https://doc.rust-lang.org/regex/regex/index.html))。不过，大多数情况下，你可以通过使用正则表达式crate中的`RegexBuilder`来获得相同的结果[36]。我们在第[33]行和第[36]行生成的两个`rust_regex`对象是等效的。虽然第二个版本确实更冗长，但它一开始就更容易理解。
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The regexes work by compiling their strings into the equivalent Rust code on
    creation. For performance reasons, you are advised to reuse your regexes instead
    of creating them anew every time you use them. A good way of doing this is by
    using the `lazy_static` crate, which we will look at later in the book, in the
    Creating lazy static objects section in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式通过在创建时将它们的字符串编译成等效的Rust代码来工作。出于性能考虑，建议你重用正则表达式，而不是每次使用时都重新创建它们。一个很好的方法是使用`lazy_static`包，我们将在本书的“创建懒静态对象”部分（第5章，[6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml]，*高级数据结构*）中稍后讨论。
- en: Be careful not to overdo it with regexes. As they say, "When all you have is
    a hammer, everything looks like a nail." If you parse complicated data, regexes
    can quickly become an unbelievably complex mess. When you notice that your regex
    has become too big to understand at first glance, try to rewrite it as a parser.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要过度使用正则表达式。正如他们所说，“当你只有一把锤子时，一切看起来都像钉子。”如果你解析复杂的数据，正则表达式可以迅速变得难以置信地复杂。当你注意到你的正则表达式变得太大，以至于一眼看不过来时，尝试将其重写为解析器。
- en: See also
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating lazy static objects* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    **Advanced Data Structures**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建懒静态对象*配方在[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，**高级数据结构**中'
- en: Accessing the command line
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问命令行
- en: Sooner or later, you'll want to interact with the user in some way or another.
    The most basic way to do this is by letting the user pass parameters while calling
    the application through the command line.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一天，你将想以某种方式与用户交互。最基本的方法是在通过命令行调用应用程序时让用户传递参数。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In the `bin` folder, create a file called `cli_params.rs`
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`cli_params.rs`的文件
- en: 'Add the following code and run it with `cargo run --bin cli_params some_option
    some_other_option`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用`cargo run --bin cli_params some_option some_other_option`运行它：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Calling `env::args()` returns an iterator over the provided parameters[6]. By
    convention, the first command-line parameter on most operating systems is the
    path to the executable itself [12].
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`env::args()`返回一个提供参数的迭代器[6]。按照惯例，大多数操作系统上的第一个命令行参数是可执行文件的路径[12]。
- en: 'We can access specific parameters in two ways: keep them as an iterator [11]
    or `collect` them into a collection such as `Vec`[23]. Don''t worry, we are going
    to talk about them in detail in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*. For now, it''s enough for you to know that:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式访问特定的参数：将它们保持为迭代器[11]或`collect`到像`Vec`[23]这样的集合中。不用担心，我们将在[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*与集合一起工作*中详细讨论它们。现在，你只需要知道：
- en: Accessing an iterator forces you to check at compile time whether the element
    exists, for example, an `if let` binding [12]
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问迭代器会强制你在编译时检查元素是否存在，例如，使用`if let`绑定[12]
- en: Accessing a vector checks the validity at runtime
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问向量时在运行时检查其有效性
- en: This means that we could have executed lines [26] and [29] without checking
    for their validity first in [25] and [28]. Try it yourself, add the `&args[3];`
    line at the end of the program and run it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在[25]和[28]中首先检查它们的有效性之前执行[26]和[29]行。试试看，在程序末尾添加`&args[3];`行并运行它。
- en: We check the length anyways because it is considered good style to check whether
    the expected parameters were provided. With the iterator way of accessing parameters,
    you don't have to worry about forgetting to check, as it forces you to do it.
    On the other hand, by using a vector, you can check for the parameters once at
    the beginning of the program and not worry about them afterward.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无论如何都会检查长度，因为这被认为是一种良好的风格，以确保预期的参数已被提供。使用迭代器方式访问参数时，你不必担心忘记检查，因为它会强制你这么做。另一方面，通过使用向量，你可以在程序开始时检查一次参数，之后就不必再担心了。
- en: There's more...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you are building a serious command-line utility in the style of *nix tools,
    you will have to parse a lot of different parameters. Instead of reinventing the
    wheel, you should take a look at third-party libraries, such as clap ([https://crates.io/crates/clap](https://crates.io/crates/clap)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在以*nix工具的风格构建一个严肃的命令行工具，你将不得不解析很多不同的参数。与其重新发明轮子，你应该看看第三方库，例如clap ([https://crates.io/crates/clap](https://crates.io/crates/clap))。
- en: Interacting with environment variables
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与环境变量交互
- en: According to the Twelve-Factor App ([https://12factor.net/](https://12factor.net/)),
    you should store your configuration in the environment ([https://12factor.net/config](https://12factor.net/config)).
    This means that you should pass values that could change between deployments,
    such as ports, domains, or database handles, as environment variables. Many programs
    also use environment variables to communicate with each other.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 根据《十二要素应用》([https://12factor.net/](https://12factor.net/))，你应该将配置存储在环境中([https://12factor.net/config](https://12factor.net/config))。这意味着你应该将可能在部署之间改变值的值，如端口、域名或数据库句柄，作为环境变量传递。许多程序也使用环境变量来相互通信。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the `bin` folder, create a file called `env_vars.rs`
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `env_vars.rs` 的文件
- en: 'Add the following code and run it with `cargo run --bin env_vars`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin env_vars` 运行它：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With `env::vars()`, we can access an iterator over all the `env var` that were
    set for the current process at the time of execution [6]. This list is pretty
    huge though, as you'll see when running the code, and for the most part, irrelevant
    for us.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `env::vars()`，我们可以访问在执行时为当前进程设置的 `env var` 的迭代器 [6]。这个列表相当庞大，正如你运行代码时将看到的，大部分对我们来说都是不相关的。
- en: It's more practical to access a single `env var` with `env::var()` [26], which
    returns an `Err` if the requested var is either not present or doesn't contain
    valid Unicode. We can see this in action in line [21], where we try to print a
    variable that we just deleted.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `env::var()` [26] 访问单个 `env var` 更为实用，它如果请求的变量不存在或包含无效的 Unicode，则返回一个 `Err`。我们可以在第
    [21] 行看到这一点，在那里我们尝试打印一个刚刚删除的变量。
- en: 'Because your `env::var` returns a `Result`, you can easily set up default values
    for them by using `unwrap_or_default`. One real-life example of this, involving
    the address of a running instance of the popular Redis ([https://redis.io/](https://redis.io/))
    key-value storage, looks like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你的 `env::var` 返回一个 `Result`，你可以通过使用 `unwrap_or_default` 来轻松地为它们设置默认值。一个涉及运行中的流行
    Redis ([https://redis.io/](https://redis.io/)) 键值存储地址的现实生活例子如下：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Keep in mind that creating an `env var` with `env::set_var()` [13] and deleting
    it with `env::remove_var()` [19] both only change the `env var` for our current
    process. This means that the created `env var` are not going to be readable by
    other programs. It also means that if we accidentally remove an important `env
    var`, the rest of the operating system is not going to care, as it can still access
    it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用 `env::set_var()` [13] 创建 `env var` 和使用 `env::remove_var()` [19] 删除它都只改变我们当前进程的
    `env var`。这意味着创建的 `env var` 不会被其他程序读取。这也意味着如果我们不小心删除了一个重要的 `env var`，操作系统的其他部分不会关心，因为它仍然可以访问它。
- en: There's more...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: At the beginning of this recipe, I wrote about storing your configuration in
    the environment. The industry standard way to do this is by creating a file called
    `.env` that contains said config in the form of key-value-pairs, and loading it
    into the process at some point during the build. One easy way to do this in Rust
    is by using the dotenv ([https://crates.io/crates/dotenv](https://crates.io/crates/dotenv))
    third-party crate.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱的开始，我写了关于将你的配置存储在环境中的内容。做这件事的行业标准方式是创建一个名为 `.env` 的文件，其中包含键值对形式的配置，并在构建过程中某个时刻将其加载到进程中。在
    Rust 中这样做的一个简单方法是通过使用 dotenv ([https://crates.io/crates/dotenv](https://crates.io/crates/dotenv))
    第三方包。
- en: Reading from stdin
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 stdin 读取
- en: If you want to create an interactive application, it's easy to prototype your
    functionality with the command line. For CLI programs, this will be all the interaction
    you need.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个交互式应用程序，使用命令行来原型化你的功能很容易。对于 CLI 程序，这将是所有需要的交互。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the `src/bin` folder, create a file called `stdin.rs`
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/bin` 文件夹中，创建一个名为 `stdin.rs` 的文件
- en: 'Add the following code and run it with `cargo run --bin stdin`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin stdin` 运行它：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to read from the standard console input, `stdin`, we first need to
    obtain a handle to it. We do this by calling `io::stdin()` [29]. Imagine the returned
    object as a reference to a global `stdin` object. This global buffer is managed
    by a `Mutex`, which means that only one thread can access it at a time (more on
    that later in the book, in the Parallelly accessing resources with Mutexes section
    in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism and Rayon*).
    We get this access by locking (using `lock()`) the buffer, which returns a new
    handle [31]. After we have done this, we can call the `lines` method on it, which
    returns an iterator over the lines the user will write [31 and 52]. More on iterators
    in the *Accessing collections as Iterators* section in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从标准控制台输入`stdin`读取，我们首先需要获取它的句柄。我们通过调用`io::stdin()`[29]来完成这个操作。想象一下返回的对象是一个全局`stdin`对象的引用。这个全局缓冲区由一个`Mutex`管理，这意味着一次只有一个线程可以访问它（关于这一点，本书将在第7章的*使用Mutex并行访问资源*部分中进一步讨论，*并行性和Rayon*）。我们通过锁定（使用`lock()`）缓冲区来获取这个访问权限，这会返回一个新的句柄[31]。完成这个操作后，我们可以在它上面调用`lines`方法，该方法返回用户将写入的行的迭代器[31和52]。关于迭代器的更多信息，请参阅[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)的*作为迭代器访问集合*部分，*处理集合*。
- en: Finally, we can iterate over as many submitted lines as we want until some kind
    of break condition is reached, otherwise the iteration would go on forever. In
    our example, we break the number-checking loop as soon as a valid number has been
    entered [56].
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以迭代提交的任意多行，直到达到某种中断条件，否则迭代将永远进行下去。在我们的例子中，一旦输入了有效数字，我们就中断数字检查循环[56]。
- en: 'If we''re not particularly picky about our input and just want the next line,
    we have two options:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对输入不太挑剔，只想获取下一行，我们有两个选择：
- en: We can continue using the infinite iterator provided by `lines()`, but simply
    call next on it in order to just take the first one. This comes with an additional
    error check as, generally speaking, we cannot guarantee that there is a next element.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以继续使用`lines()`提供的无限迭代器，但只需简单地调用它的`next`方法来获取第一个元素。这附带了一个额外的错误检查，因为一般来说，我们无法保证存在下一个元素。
- en: We can use `read_line` in order to populate an existing buffer [43]. This doesn't
    require that we `lock` the handler first, as it is done implicitly.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`read_line`来填充现有的缓冲区[43]。这不需要我们先`lock`处理程序，因为它被隐式地完成了。
- en: Although they both result in the same end effect, you should choose the first
    option. It is more idiomatic as it uses iterators instead of a mutable state,
    which makes it more maintainable and readable.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们都产生了相同的效果，但你应该选择第一个选项。它更符合惯例，因为它使用迭代器而不是可变状态，这使得它更易于维护和阅读。
- en: On a side note, we are using `print!` instead of `println!` in some places in
    this recipe for aesthetic reasons [22]. If you prefer the look of newlines before
    user input, you can refrain from using them.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，我们在这个配方的一些地方使用`print!`而不是`println!`是出于美观原因[22]。如果你更喜欢在用户输入前显示换行符的外观，你可以避免使用它们。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe is written with the assumption that you want to use stdin for live
    interaction over the `cli`. If you plan on instead piping some data into it (for
    example, `cat foo.txt | stdin.rs` on *nix), you can stop treating the iterator
    returned by `lines()` as infinite and retrieve the individual lines, not unlike
    how you retrieved the individual parameters in the last recipe.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是基于你希望使用stdin进行实时交互的`cli`编写的。如果你计划将一些数据通过管道输入（例如，`cat foo.txt | stdin.rs`在*nix上），你可以停止将`lines()`返回的迭代器视为无限，并检索单独的行，这与你在上一个配方中检索单独参数的方式类似。
- en: There are various calls to `trim()` in our recipe [35, 45 and 55]. This method
    removes leading and trailing whitespace in order to enhance the user-friendliness
    of our program. We are going to look at it in detail in the *Using a string* section
    in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中有各种对`trim()`的调用[35, 45和55]。此方法删除前导和尾随空白，以提高我们程序的易用性。我们将在[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)的*使用字符串*部分中详细探讨它，*处理集合*。
- en: See also
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Interacting with environment variables* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)中的*与环境变量交互*配方，*学习基础知识*'
- en: '*Using a string* and *Accessing collections as iterators recipe* in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)中的*使用字符串*和*将集合作为迭代器访问配方*，*与集合一起工作*'
- en: '*Parallelly accessing resources with Mutexes* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)中的*使用Mutex并行访问资源配方*，*并行性和Rayon*'
- en: Accepting a variable number of arguments
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受可变数量的参数
- en: Most of the time, when you want to operate on a dataset, you will design a function
    that takes a collection. In some cases, however, it is nice to have functions
    that just accept an unbound amount of parameters, like JavaScript's *rest parameters*.
    This concept is called **variadic functions** and is not supported by Rust. However,
    we can implement it ourselves by defining a recursive macro.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当你想要对一个数据集进行操作时，你会设计一个接受集合的函数。然而，在某些情况下，拥有只接受未绑定数量参数的函数会更好，就像JavaScript的*剩余参数*。这个概念被称为**可变参数函数**，在Rust中不受支持。但是，我们可以通过定义递归宏来实现它。
- en: Getting started
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The code in this recipe might be small, but it will look like gibberish if you're
    not familiar with macros. If you have not yet learned about macros or need a refresh,
    I recommend that you take a quick look at the relevant chapter in the official
    Rust book ([https://doc.rust-lang.org/stable/book/first-edition/macros.html](https://doc.rust-lang.org/stable/book/first-edition/macros.html)).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的代码可能很小，但如果你不熟悉宏，它看起来可能像是乱码。如果你还没有学习关于宏的内容或者需要复习，我建议你快速查看官方Rust书籍中的相关章节([https://doc.rust-lang.org/stable/book/first-edition/macros.html](https://doc.rust-lang.org/stable/book/first-edition/macros.html))。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the `src/bin` folder, create a file called `variadic.rs`
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`variadic.rs`的文件
- en: 'Add the following code and run it with `cargo run --bin variadic`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin variadic`运行它：
- en: '[PRE28]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start with our intention: we want to create a macro called multiply
    that accepts an undefined amount of parameters and multiplies them all together.
    In macros, this is done via recursion. We begin every recursive definition with
    the **edge case**, that is, the parameters where the recursion should stop. Most
    of the time, this is where a function call stops making sense. In our case, this
    is the single parameter. Think about it, what should `multiply!(3)` return? It
    doesn''t make sense to multiply it with anything, since we have no other parameter
    to multiply it with. Our best reaction is to simply return the parameter unmodified.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的意图开始：我们想要创建一个名为multiply的宏，它可以接受未定义数量的参数并将它们全部相乘。在宏中，这是通过递归实现的。我们每次递归定义都以**边缘情况**开始，即递归应该停止的参数。大多数时候，这是函数调用不再有意义的地方。在我们的例子中，这是一个单独的参数。想想看，`multiply!(3)`应该返回什么？由于我们没有其他参数与之相乘，所以将它与任何东西相乘都没有意义。我们最好的反应就是简单地返回未修改的参数。
- en: Our other condition is a match against more than one parameter, a `$head` and
    a comma-separated list of parameters inside of a `$tail`. Here, we just define
    the return value as the `$head` multiplied with the multiplication of the `$tail`.
    This will call `multiply!` with the `$tail` and without the `$head`, which means
    that on every call we process one parameter less until we finally reach our edge
    case, one single parameter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的另一个条件是匹配多个参数，一个`$head`和一个用逗号分隔的参数列表，位于`$tail`内部。在这里，我们只定义返回值为`$head`与`$tail`乘积的结果。这将调用`multiply!`与`$tail`和没有`$head`，这意味着在每次调用中我们处理一个更少的参数，直到我们最终达到边缘情况，一个单独的参数。
- en: There's more...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Keep in mind that you should use this technique sparingly. Most of the time,
    it is clearer to just accept and operate on a slice instead. However, it makes
    sense to use this in combination with other macros and higher kinds of concepts
    where the analogy of *a graspable list of things* breaks down. Finding a good
    example for this is difficult since they tend to be extremely specific. You can
    find one of them at the end of the book though.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你应该谨慎使用这种技术。大多数时候，直接接受并操作一个切片会更清晰。然而，与其他宏和更高层次的概念结合使用是有意义的，在这些情况下，“可触摸的事物列表”的类比就失效了。找到一个好的例子很难，因为它们往往非常具体。不过，你可以在书的末尾找到一个例子。
- en: See also
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Composing functions* recipe in [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml)中的*函数组合*配方，*使用实验性Nightly功能*'
