- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Protocols on Top of TCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used the Tokio framework to support an async actor
    model. Our Tokio framework accepted basic traffic and then sent those messages
    to actors once the messages were processed. However, our TCP processing was basic.
    You should not be comfortable building complex systems on this basic TCP process
    if this book is the only exposure you have had to TCP. In this chapter, we will
    completely focus on how to package, send, and read data over a TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a TCP client and echo server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing bytes over TCP using structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating frames to separate messages over TCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an HTTP frame on top of TCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to package, send, and read data
    sent over TCP using a range of different approaches. You will be able to understand
    how to split your data into frames that can be handled as structs. Finally, you
    will be able to build an HTTP frame that has a header containing the URL and method,
    and a body containing data. This will enable you to build whatever data structure
    you require when sending data over TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be purely focusing on how to process data over a TCP
    connection. Therefore, we will not be relying on any previous code as we are building
    our own echo server.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our TCP client and server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore sending and processing bytes over TCP, we will create a basic echo
    server and client. We will be dropping any complex logic that we built in the
    previous chapter because we do not need the distraction of the complex logic when
    trying to explore the ideas around sending, receiving, and processing bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new directory, we should have two cargo projects – one for the server
    and another for the client. They can take the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Both projects will be using the same dependency of Tokio, so both projects
    should have the following dependency defined in their `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We now need to construct the basic mechanism of an echo server. This is where
    a message is sent to the server from the client. The server then processes the
    message sent by the client, re-packages the message, and sends the same message
    back to the client. We will start by building out our server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our TCP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define the server in the `server/src/main.rs` file by initially importing
    everything we need with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is so we can listen to incoming TCP traffic, read bytes from that traffic,
    and write it back to the client sending the message. Then, we need to utilize
    the Tokio runtime to listen to incoming traffic, spinning up a thread if we get
    a message. If you completed the previous chapter, this is a good opportunity for
    you to attempt to do this yourself as we covered the concepts needed to create
    a TCP server listening for incoming traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have attempted to write the basics for your TCP server, your code should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we should be familiar with the concept that we create a listener, bind
    it to an address, and then wait for incoming messages, creating a thread when
    a message is sent. Inside the thread, we loop through the incoming message until
    there is a new line with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code should not be a surprise by now. If you are unfamiliar with any of
    the concepts the preceding code covers, it is advised that you read the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a basic echo server defined, and it is ready to run, which means
    we can turn our attention to creating our client code in the `client/src/main.rs`
    file. The same structs and traits will be needed to get the client working. Then,
    we need to send a standard text message to the TCP server. This is a good time
    to try and implement the client yourself, and there is nothing that has not been
    covered multiple times before to build the client.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our TCP client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you attempted to build the client yourself, you should have imported the
    following structs and traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must make the TCP connection, send a message, wait for the message
    to be sent back, and then print it out using the Tokio runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a functioning client and server. To test if the client and server
    are working, we must start the server in one terminal, and then run the client
    in another terminal by running `cargo run`. The server will have the following
    printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our server printout will have the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have a basic echo server and client working. We can now focus
    on packaging, unpacking, and processing bytes. In the next section, we will explore
    the basic method of using structs to standardize processing messages.
  prefs: []
  type: TYPE_NORMAL
- en: Processing bytes using structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we were sending strings to the server. However, the
    result is that we had to parse individual values into the type that we needed.
    As string parsing was not well structured, it is not clear to other developers
    what structure our messages are. We can make our message structure clearer by
    defining a struct that can be sent over the TCP channel. Sending a struct over
    a TCP channel can be achieved by converting the message struct into a binary format
    before sending the struct itself. This is also known as serializing the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are to convert a struct into a binary format, first, we will need to
    utilize the `serde` and `bincode` crates. With our new crates, both the client
    and server `Cargo.toml` file should contain the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `serde` crate will be used to serialize the struct, while the `bincode`
    crate will be used to convert our message struct into a binary format. Now that
    our dependencies have been defined, we can start creating a message sender client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a message sender client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can build out our `client/src/main.rs` file to send structs over TCP. First,
    we must import what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With our imports ready, we can define our `Message` struct with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The definition of our `Message` struct takes a similar form to the structs that
    we use to process the JSON bodies of HTTP requests on our Actix server. However,
    this time, we will not be using the Actix Web structs and traits to process the
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Message` struct can now be used in our `main` function. Remember that
    inside our `main` function, we have a TCP stream that was created by the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have made a connection, we can create our `Message` struct and
    convert the `Message` struct into binary format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Message` struct is now in binary format. Then, we must send our message
    over the TCP stream with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have sent the message and then a new line. This is because our
    server is going to read until there is a new line. If we do not send the new line,
    then the program will hang and never complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have sent our message, we can wait until we see receive the message
    back again. Then, we must construct the `Message` struct from the binary format
    and print out the constructed `Message` struct with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our client is now ready to send a message to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Processing messages in the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to updating our server code, we will aim to unpack the message,
    print out the message, and then convert the message into binary format to be sent
    back to the client. At this stage, you should be able to implement the change
    yourself. This is a good opportunity to revise what we have covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you did attempt to implement the processing of the message on the server
    in the `server/src/main.rs` file first, you should have imported the following
    additional requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you should have defined the `Message` struct, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only need to process the message, print out the message, and then return
    the message to the client. We can manage all the processes with the message in
    the loop inside the thread with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the same approach that we used in the client but vice versa
    – that is, we convert from binary format first and then convert into binary format
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our server and then our client, our server will give us the following
    printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our client gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that our `Message` struct can be sent, received, and then sent
    back again without any compromise. This gives our TCP traffic another level of
    sophistication as we can have more complex structures for our messages. For instance,
    one field of our message could be a HashMap, and another field of the message
    could be a vector of another struct if the struct in the vector has implemented
    the `serde` traits. We can chop and change the structure of our `Message` struct
    without having to rewrite our protocol for unpacking and packing a message. Other
    developers can merely look at our `Message` struct and know what is being sent
    over the TCP channel. Now that we have improved how we send messages over TCP,
    we can chunk our stream into frames with framing.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing framing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we are sending structs over TCP and separating these messages with a
    new line. Essentially, this is the most basic form of framing. However, there
    are some drawbacks. We must remember to put in a delimiter such as a new line;
    otherwise, our program will hang indefinitely. We also run the risk of prematurely
    splitting the message into two messages by having a delimiter in the data of the
    message. For instance, when we split our messages up with the new line delimiter,
    it is not inconceivable to have a chunk of text in a message that has new lines
    or any special character or byte to denote the need to separate the stream into
    serializable packages. To prevent such issues, we can use the built-in framing
    support that Tokio provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will be rewriting the client and server as the sending
    and receiving of messages will change. If we try and insert our new approach into
    existing code of the client, it can easily lead to confusion. Before we write
    our client and server, we must update the dependencies in the `Cargo.toml` file
    of both the client and server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a couple more crates. We will cover their needs as we go
    through the rest of the code in this section. To get to grips with framing, we
    will start with a simple task, which is rewriting our client so that it supports
    framing.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting our client so that it supports framing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember we are writing our entire client in the `client/src/main.rs` file.
    First, we must import what we need from Tokio with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`TcpStream` is for connecting to our server. The `BytesCodec` struct is for
    shipping raw bytes through connections. We will be using the `BytesCodec` struct
    to configure the framing. `Decoder` is a trait that decodes bytes that we accept
    through our connection. However, when it comes to sending data through a connection,
    we could pass in structs, strings, or anything else that must be converted into
    bytes. Therefore, we must inspect what is implemented for the `BytesCodec` struct
    by looking at the source code for `BytesCodec`. The source code can be inspected
    by looking at the documentation or merely control-clicking or hovering over the
    `BytesCodec` struct in your editor. When we inspect the source code of the `BytesCodec`
    struct, we will see the following `Encode` implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can only send `Bytes` or `BytesMut` through a connection using a `BytesCodec`
    struct. We could implement `Encode` for `BytesCodec` for sending other types of
    data; however, for our use case, this is excessive, and it just makes sense to
    send `Bytes` over our connection. However, before we write any more code, we might
    as well inspect the `Bytes` implementation to get an appreciation for how framing
    works. The implementation of `Encode` for `Bytes` takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the length of the data being passed is reserved in the
    buffer. The data is then put into the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand how we are going to encode and decode our messages using
    framing, we need to import traits from both the `futures` and `bytes` crates to
    enable us to process our messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SinkExt` and `StreamExt` traits essentially enable us to receive messages
    from the stream asynchronously. The `Bytes` struct will wrap our serialized message
    to be sent. Then, we must import the traits to enable the serialization of messages
    and define our message struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have everything we need to start working on our runtime. Remember that
    our main runtime has the following outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our runtime, we initially make a TCP connection and define the framing
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define our message, serialize the message, and then wrap the message
    in `Bytes` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can send our message, wait for the message to be sent back, and then
    deserialize the message to print it out with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With all this, our client is built. We can see that we do not have to worry
    about new lines or any other delimiters. Our code is clean and straightforward
    when it comes to sending and receiving messages over TCP. Now that our client
    has been built, we can move on to building our server so that it handles framing.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting our server so that it supports framing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to building our server to support framing, there is a lot of overlap
    with what we have coded in the previous section. At this point, it is a good time
    to try and build the server yourself. Building the server requires implementing
    the framing logic that we coded in the previous section into the existing server
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you attempted to rewrite the server, first, you should have imported the
    following structs and traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `Decoder` trait that we imported allows us to call `.framed`
    on the bytes codec. There is nothing here that should be new to you. Once we have
    the necessary imports, we must define the same `Message` struct with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must define the outline of the server runtime with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the listener is looping to accept traffic and spawning
    threads when messages are received, as in previous server implementations. Inside
    our thread, we read our framed message with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we do not have a `while` loop anymore. This is because our framing
    manages the splitting between messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have extracted our bytes from our connection, we must implement the
    same logic that we did in our client, where we process our message, print it out,
    process it again, and then send it back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a working client and server that utilizes framing. If we were to
    start the server and then run the client, the client will give us the following
    printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Our server will give us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our server and client now support framing. We have come a long way. Now, we
    only have one more concept to explore in this chapter, and this is building an
    HTTP frame using TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Building an HTTP frame on top of TCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we explored the Tokio framework in this book, we used HTTP to send and
    receive data to and from servers. The HTTP protocol is essentially built on top
    of TCP. In this section, while we will create an HTTP frame, we will not mimic
    the HTTP protocol completely. Instead, to prevent excessive code, we will create
    a basic HTTP frame to understand the mechanisms utilized when creating an HTTP
    frame. It also must be stressed that this is for educational purposes. TCP is
    good for our protocols, but if you want to use HTTP handlers, it is quicker, safer,
    and less error-prone to use out-of-the-box HTTP handlers such as Hyper. We will
    cover how to use Hyper HTTP handlers with Tokio in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to an HTTP request, a request generally has a header and a body.
    When we send over a request, the header will tell us what method is being used
    and the URL associated with the request. To define our HTTP frame, we need the
    same structs defining the frame on both the server and client. Therefore, we must
    have the same code for the `client/src/http_frame.rs` and `server/src/http_frame.rs`
    files. First, we must import the serialization traits that are needed with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must define our HTTP frame with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have defined a header and body within our `HttpFrame` struct.
    We define the header and body structs with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our basic HTTP frame is now complete, and we can import the HTTP frame into
    the `main.rs` file of both the client and server with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start by sending our HTTP frame in the `main.rs` file of our client
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that our HTTP frame is starting to look like an HTTP request that
    we would handle when receiving requests in our Actix servers. For the `main.rs`
    file in our server, there is little change. All we must do is redefine the struct
    that is being deserialized with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a basic HTTP frame that we can use to send information. If we were
    to run our server and then client programs, we would get the following printout
    for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Our client program will then give us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there is no corruption in our data. We have now covered all
    the core essential approaches and methods needed to be versatile in packaging,
    sending, and reading data over TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a basic TCP client that sends and receives data to
    an echo server. We started by sending over basic string data and separating the
    messages with delimiters. Then, we increased the complexity of the data that we
    sent over a TCP connection by serializing structs. This enabled us to have more
    complex data structures. This serialization also reduced the handling needed to
    get the message data in the format that we needed it to be in. For instance, in
    the previous chapter, we were parsing strings into floats after receiving the
    message. With structs, nothing is stopping us from having a list of floats as
    a field, and after the serialization of the message, we would have that field
    housing a list of floats without any extra lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: The serialization of structs is enough for us to handle most problems, but we
    explored framing so that we did not have to rely on delimiters to separate the
    messages that we send over TCP. With framing, we built a basic HTTP frame to visualize
    what we can do with frames and how HTTP is built on top of TCP. We must remember
    that implementing an HTTP protocol is more complicated than what we did in this
    chapter, and it is advised that we utilize established HTTP handlers from crates
    to handle and process HTTP traffic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the established Hyper crate to handle HTTP
    traffic with the Tokio runtime framework.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tokio framing documentation: [https://tokio.rs/tokio/tutorial/framing](https://tokio.rs/tokio/tutorial/framing).'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the advantage of framing over using a delimiter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we wrap our serialized message in a `Bytes` struct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would we be able to send over a string as a frame?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we use a delimiter such as a new line, the data that we send over TCP might
    contain a new line in the message. The problem with having a new line in the message
    means that the message is split before the end of the message is received. Framing
    gets rid of this issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We had to wrap our serialized message in a `Bytes` struct because the `Encode`
    trait is not implemented for any other data type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The simplest way to do this is to implement the `Encode` trait for a string.
    When implementing the `Encode` trait, we serialize the string and then wrap the
    string into a `Bytes` struct, reserve the length of the serialized string in the
    buffer, and then place the serialized string in the buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
