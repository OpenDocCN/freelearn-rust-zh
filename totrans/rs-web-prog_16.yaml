- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Building Protocols on Top of TCP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在TCP之上构建协议
- en: In the previous chapter, we used the Tokio framework to support an async actor
    model. Our Tokio framework accepted basic traffic and then sent those messages
    to actors once the messages were processed. However, our TCP processing was basic.
    You should not be comfortable building complex systems on this basic TCP process
    if this book is the only exposure you have had to TCP. In this chapter, we will
    completely focus on how to package, send, and read data over a TCP connection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了Tokio框架来支持异步actor模型。我们的Tokio框架接受基本流量，并在消息处理完毕后将这些消息发送给actor。然而，我们的TCP处理是基本的。如果你对TCP的唯一接触就是这本书，那么你不应该在这个基本的TCP流程上构建复杂的系统。在本章中，我们将完全专注于如何在TCP连接上打包、发送和读取数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up a TCP client and echo server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置TCP客户端和回声服务器
- en: Processing bytes over TCP using structs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构体在TCP上处理字节
- en: Creating frames to separate messages over TCP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在TCP上创建帧以分隔消息
- en: Building an HTTP frame on top of TCP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在TCP之上构建HTTP帧
- en: By the end of this chapter, you will be able to package, send, and read data
    sent over TCP using a range of different approaches. You will be able to understand
    how to split your data into frames that can be handled as structs. Finally, you
    will be able to build an HTTP frame that has a header containing the URL and method,
    and a body containing data. This will enable you to build whatever data structure
    you require when sending data over TCP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用多种不同的方法打包、发送和读取通过TCP发送的数据。你将能够理解如何将你的数据分割成可以处理为结构的帧。最后，你将能够构建一个包含URL和方法头的HTTP帧，以及包含数据的主体。这将使你能够在发送TCP数据时构建所需的数据结构。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be purely focusing on how to process data over a TCP
    connection. Therefore, we will not be relying on any previous code as we are building
    our own echo server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将纯粹专注于如何在TCP连接上处理数据。因此，我们不会依赖任何之前的代码，因为我们正在构建自己的回声服务器。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter16)找到。
- en: Setting up our TCP client and server
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的TCP客户端和服务器
- en: To explore sending and processing bytes over TCP, we will create a basic echo
    server and client. We will be dropping any complex logic that we built in the
    previous chapter because we do not need the distraction of the complex logic when
    trying to explore the ideas around sending, receiving, and processing bytes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索发送和处理TCP上的字节，我们将创建一个基本的回声服务器和客户端。我们将放弃上一章中构建的任何复杂逻辑，因为我们不需要在尝试探索发送、接收和处理字节的想法时被复杂逻辑分散注意力。
- en: 'In a new directory, we should have two cargo projects – one for the server
    and another for the client. They can take the following file structure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的目录中，我们应该有两个cargo项目——一个用于服务器，另一个用于客户端。它们可以采用以下文件结构：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both projects will be using the same dependency of Tokio, so both projects
    should have the following dependency defined in their `Cargo.toml` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 两个项目都将使用相同的Tokio依赖，因此两个项目应该在它们的`Cargo.toml`文件中定义以下依赖：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We now need to construct the basic mechanism of an echo server. This is where
    a message is sent to the server from the client. The server then processes the
    message sent by the client, re-packages the message, and sends the same message
    back to the client. We will start by building out our server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要构建回声服务器的基本机制。这是客户端向服务器发送消息的地方。服务器随后处理客户端发送的消息，重新打包消息，并将相同的消息发送回客户端。我们将从构建我们的服务器开始。
- en: Setting up our TCP server
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的TCP服务器
- en: 'We can define the server in the `server/src/main.rs` file by initially importing
    everything we need with the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码在`server/src/main.rs`文件中定义服务器：首先导入我们需要的所有内容：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is so we can listen to incoming TCP traffic, read bytes from that traffic,
    and write it back to the client sending the message. Then, we need to utilize
    the Tokio runtime to listen to incoming traffic, spinning up a thread if we get
    a message. If you completed the previous chapter, this is a good opportunity for
    you to attempt to do this yourself as we covered the concepts needed to create
    a TCP server listening for incoming traffic.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了我们可以监听传入的 TCP 流，从该流量中读取字节，并将其写回发送消息的客户。然后，我们需要利用 Tokio 运行时来监听传入的流量，如果收到消息则启动一个线程。如果你完成了上一章，这是一个很好的机会尝试自己完成这个任务，因为我们已经涵盖了创建监听传入流量的
    TCP 服务器的概念。
- en: 'If you have attempted to write the basics for your TCP server, your code should
    look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编写 TCP 服务器的基础知识，你的代码应该看起来像这样：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we should be familiar with the concept that we create a listener, bind
    it to an address, and then wait for incoming messages, creating a thread when
    a message is sent. Inside the thread, we loop through the incoming message until
    there is a new line with the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该熟悉以下概念：我们创建一个监听器，将其绑定到地址，然后等待传入的消息，当收到消息时创建一个线程。在线程内部，我们通过以下代码循环处理传入的消息，直到出现带有以下代码的新行：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code should not be a surprise by now. If you are unfamiliar with any of
    the concepts the preceding code covers, it is advised that you read the previous
    chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这段代码应该不会让你感到惊讶。如果你对前面代码中涵盖的任何概念不熟悉，建议你阅读上一章。
- en: We now have a basic echo server defined, and it is ready to run, which means
    we can turn our attention to creating our client code in the `client/src/main.rs`
    file. The same structs and traits will be needed to get the client working. Then,
    we need to send a standard text message to the TCP server. This is a good time
    to try and implement the client yourself, and there is nothing that has not been
    covered multiple times before to build the client.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个基本的回声服务器，并且它已经准备好运行，这意味着我们可以将注意力转向在 `client/src/main.rs` 文件中创建我们的客户端代码。我们需要相同的
    structs 和 traits 来使客户端工作。然后，我们需要向 TCP 服务器发送一个标准的文本消息。这是一个尝试自己实现客户端的好时机，而且之前已经多次涵盖了构建客户端所需的所有内容。
- en: Setting up our TCP client
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的 TCP 客户端
- en: 'If you attempted to build the client yourself, you should have imported the
    following structs and traits:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试自己构建客户端，你应该已经导入了以下 structs 和 traits：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we must make the TCP connection, send a message, wait for the message
    to be sent back, and then print it out using the Tokio runtime:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须建立 TCP 连接，发送一条消息，等待消息被发送回来，然后使用 Tokio 运行时将其打印出来：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now have a functioning client and server. To test if the client and server
    are working, we must start the server in one terminal, and then run the client
    in another terminal by running `cargo run`. The server will have the following
    printout:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个运行中的客户端和服务器。为了测试客户端和服务器是否工作正常，我们必须在一个终端中启动服务器，然后在另一个终端中运行客户端，通过运行 `cargo
    run`。服务器将显示以下输出：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our server printout will have the following printout:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务器的输出将如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With that, we have a basic echo server and client working. We can now focus
    on packaging, unpacking, and processing bytes. In the next section, we will explore
    the basic method of using structs to standardize processing messages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有一个基本的回声服务器和客户端正在工作。现在我们可以专注于打包、解包和处理字节。在下一节中，我们将探讨使用 structs 标准化处理消息的基本方法。
- en: Processing bytes using structs
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 structs 处理字节
- en: In the previous chapter, we were sending strings to the server. However, the
    result is that we had to parse individual values into the type that we needed.
    As string parsing was not well structured, it is not clear to other developers
    what structure our messages are. We can make our message structure clearer by
    defining a struct that can be sent over the TCP channel. Sending a struct over
    a TCP channel can be achieved by converting the message struct into a binary format
    before sending the struct itself. This is also known as serializing the data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向服务器发送字符串。然而，结果是我们必须将单个值解析成我们需要的类型。由于字符串解析没有很好地结构化，其他开发者不清楚我们的消息结构。我们可以通过定义一个可以发送到
    TCP 通道的 struct 来使我们的消息结构更清晰。通过在发送 struct 本身之前将其转换为二进制格式，我们可以实现通过 TCP 通道发送 struct。这也被称为序列化数据。
- en: 'If we are to convert a struct into a binary format, first, we will need to
    utilize the `serde` and `bincode` crates. With our new crates, both the client
    and server `Cargo.toml` file should contain the following dependencies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将结构体转换为二进制格式，首先，我们需要利用`serde`和`bincode`包。有了我们新的包，客户端和服务器`Cargo.toml`文件应该包含以下依赖项：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `serde` crate will be used to serialize the struct, while the `bincode`
    crate will be used to convert our message struct into a binary format. Now that
    our dependencies have been defined, we can start creating a message sender client.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将会使用`serde`包来序列化结构体，同时使用`bincode`包将我们的消息结构体转换为二进制格式。现在，我们的依赖项已经定义好了，我们可以开始创建消息发送客户端。
- en: Creating a message sender client
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建消息发送客户端
- en: 'We can build out our `client/src/main.rs` file to send structs over TCP. First,
    we must import what we need:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建`client/src/main.rs`文件以通过TCP发送结构体。首先，我们必须导入我们需要的内容：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With our imports ready, we can define our `Message` struct with the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好导入之后，我们可以使用以下代码定义我们的`Message`结构体：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The definition of our `Message` struct takes a similar form to the structs that
    we use to process the JSON bodies of HTTP requests on our Actix server. However,
    this time, we will not be using the Actix Web structs and traits to process the
    struct.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Message`结构体的定义形式与我们在Actix服务器上处理HTTP请求JSON主体的结构体类似。然而，这次我们不会使用Actix Web的结构体和特性来处理结构体。
- en: 'Our `Message` struct can now be used in our `main` function. Remember that
    inside our `main` function, we have a TCP stream that was created by the following
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Message`结构体现在可以在`main`函数中使用。记住，在我们的`main`函数中，我们有一个由以下代码创建的TCP流：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have made a connection, we can create our `Message` struct and
    convert the `Message` struct into binary format:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了连接，我们可以创建我们的`Message`结构体，并将`Message`结构体转换为二进制格式：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our `Message` struct is now in binary format. Then, we must send our message
    over the TCP stream with the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Message`结构体现在已经是二进制格式。然后，我们必须使用以下代码将我们的消息通过TCP流发送出去：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we have sent the message and then a new line. This is because our
    server is going to read until there is a new line. If we do not send the new line,
    then the program will hang and never complete.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们发送了消息然后换行。这是因为我们的服务器将会读取直到出现新行。如果我们不发送新行，那么程序将会挂起并且永远不会完成。
- en: 'Now that we have sent our message, we can wait until we see receive the message
    back again. Then, we must construct the `Message` struct from the binary format
    and print out the constructed `Message` struct with the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发送了消息，我们可以等待直到我们再次收到消息。然后，我们必须从二进制格式构造`Message`结构体，并使用以下代码打印出构造的`Message`结构体：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our client is now ready to send a message to the server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户现在已准备好向服务器发送消息。
- en: Processing messages in the server
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器中处理消息
- en: When it comes to updating our server code, we will aim to unpack the message,
    print out the message, and then convert the message into binary format to be sent
    back to the client. At this stage, you should be able to implement the change
    yourself. This is a good opportunity to revise what we have covered.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到更新我们的服务器代码时，我们的目标是解包消息，打印消息，然后将消息转换为二进制格式以发送回客户端。在这个阶段，你应该能够自己实现这个更改。这是一个复习我们所覆盖内容的好机会。
- en: 'If you did attempt to implement the processing of the message on the server
    in the `server/src/main.rs` file first, you should have imported the following
    additional requirements:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试首先在`server/src/main.rs`文件中实现服务器上的消息处理，你应该已经导入了以下额外的需求：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, you should have defined the `Message` struct, like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该已经定义了`Message`结构体，如下所示：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we only need to process the message, print out the message, and then return
    the message to the client. We can manage all the processes with the message in
    the loop inside the thread with the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要处理消息，打印消息，然后将消息返回给客户端。我们可以通过在线程中的循环内管理消息来处理所有这些过程。
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are using the same approach that we used in the client but vice versa
    – that is, we convert from binary format first and then convert into binary format
    at the end.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了与客户端相同的方法，但方向相反——也就是说，我们首先将二进制格式转换为结构体，然后在最后将其转换回二进制格式。
- en: 'If we run our server and then our client, our server will give us the following
    printout:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行服务器然后运行客户端，我们的服务器将给出以下输出：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our client gives us the following printout:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端给出了以下输出：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we can see that our `Message` struct can be sent, received, and then sent
    back again without any compromise. This gives our TCP traffic another level of
    sophistication as we can have more complex structures for our messages. For instance,
    one field of our message could be a HashMap, and another field of the message
    could be a vector of another struct if the struct in the vector has implemented
    the `serde` traits. We can chop and change the structure of our `Message` struct
    without having to rewrite our protocol for unpacking and packing a message. Other
    developers can merely look at our `Message` struct and know what is being sent
    over the TCP channel. Now that we have improved how we send messages over TCP,
    we can chunk our stream into frames with framing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的`Message`结构体可以被发送、接收，然后再次发送，而不会有任何妥协。这给我们的TCP流量带来了另一个层次的复杂性，因为我们可以为我们的消息创建更复杂的结构。例如，我们的消息中的一个字段可以是HashMap，另一个字段可以是另一个结构体的向量，如果该结构体实现了`serde`特性。我们可以根据需要更改`Message`结构体的结构，而无需重写解包和打包消息的协议。其他开发者只需查看我们的`Message`结构体，就可以知道通过TCP通道发送了什么。现在我们已经改进了通过TCP发送消息的方式，我们可以使用帧结构将流分割成帧。
- en: Utilizing framing
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用帧结构
- en: So far, we are sending structs over TCP and separating these messages with a
    new line. Essentially, this is the most basic form of framing. However, there
    are some drawbacks. We must remember to put in a delimiter such as a new line;
    otherwise, our program will hang indefinitely. We also run the risk of prematurely
    splitting the message into two messages by having a delimiter in the data of the
    message. For instance, when we split our messages up with the new line delimiter,
    it is not inconceivable to have a chunk of text in a message that has new lines
    or any special character or byte to denote the need to separate the stream into
    serializable packages. To prevent such issues, we can use the built-in framing
    support that Tokio provides.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过TCP发送结构体，并用换行符分隔这些消息。本质上，这是帧结构的最基本形式。然而，存在一些缺点。我们必须记住要添加一个分隔符，例如换行符；否则，我们的程序将无限期地挂起。我们还冒着在消息数据中包含分隔符的情况下，过早地将消息分割成两个消息的风险。例如，当我们使用换行符分隔消息时，在消息中包含换行符或任何特殊字符或字节以表示需要将流分割成可序列化的包的情况并非不可想象。为了防止这些问题，我们可以使用Tokio提供的内置帧结构支持。
- en: 'In this section, we will be rewriting the client and server as the sending
    and receiving of messages will change. If we try and insert our new approach into
    existing code of the client, it can easily lead to confusion. Before we write
    our client and server, we must update the dependencies in the `Cargo.toml` file
    of both the client and server:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新编写客户端和服务器，因为消息的发送和接收将会改变。如果我们试图将我们的新方法插入到客户端现有的代码中，很容易导致混淆。在我们编写客户端和服务器之前，我们必须更新客户端和服务器中的`Cargo.toml`文件中的依赖项：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are using a couple more crates. We will cover their needs as we go
    through the rest of the code in this section. To get to grips with framing, we
    will start with a simple task, which is rewriting our client so that it supports
    framing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了更多的crate。我们将在本节剩余的代码中介绍它们的需求。为了掌握帧结构，我们将从一个简单的任务开始，即重新编写我们的客户端以支持帧结构。
- en: Rewriting our client so that it supports framing
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新编写我们的客户端以支持帧结构
- en: 'Remember we are writing our entire client in the `client/src/main.rs` file.
    First, we must import what we need from Tokio with the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将在`client/src/main.rs`文件中编写整个客户端。首先，我们必须使用以下代码从Tokio中导入所需的模块：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`TcpStream` is for connecting to our server. The `BytesCodec` struct is for
    shipping raw bytes through connections. We will be using the `BytesCodec` struct
    to configure the framing. `Decoder` is a trait that decodes bytes that we accept
    through our connection. However, when it comes to sending data through a connection,
    we could pass in structs, strings, or anything else that must be converted into
    bytes. Therefore, we must inspect what is implemented for the `BytesCodec` struct
    by looking at the source code for `BytesCodec`. The source code can be inspected
    by looking at the documentation or merely control-clicking or hovering over the
    `BytesCodec` struct in your editor. When we inspect the source code of the `BytesCodec`
    struct, we will see the following `Encode` implementations:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`TcpStream`用于连接到我们的服务器。`BytesCodec`结构体用于通过连接传输原始字节。我们将使用`BytesCodec`结构体来配置分帧。`Decoder`是一个特质，用于解码我们通过连接接受的字节。然而，当涉及到通过连接发送数据时，我们可以传递结构体、字符串或其他任何必须转换为字节的内容。因此，我们必须检查`BytesCodec`结构体的实现，查看`BytesCodec`的源代码。源代码可以通过查看文档或在编辑器中控制点击或悬停于`BytesCodec`结构体上来检查。当我们检查`BytesCodec`结构体的源代码时，我们将看到以下`Encode`实现：'
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we can only send `Bytes` or `BytesMut` through a connection using a `BytesCodec`
    struct. We could implement `Encode` for `BytesCodec` for sending other types of
    data; however, for our use case, this is excessive, and it just makes sense to
    send `Bytes` over our connection. However, before we write any more code, we might
    as well inspect the `Bytes` implementation to get an appreciation for how framing
    works. The implementation of `Encode` for `Bytes` takes the following form:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只能通过`BytesCodec`结构体使用`Bytes`或`BytesMut`通过连接发送数据。我们可以为`BytesCodec`实现`Encode`来发送其他类型的数据；然而，对于我们的用例来说，这过于复杂，而且直接通过我们的连接发送`Bytes`更为合理。然而，在我们编写更多代码之前，我们不妨检查`Bytes`的实现，以了解分帧是如何工作的。`Bytes`的`Encode`实现形式如下：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we can see that the length of the data being passed is reserved in the
    buffer. The data is then put into the buffer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到正在传递的数据长度被保留在缓冲区中。然后，数据被放入缓冲区。
- en: 'Now that we understand how we are going to encode and decode our messages using
    framing, we need to import traits from both the `futures` and `bytes` crates to
    enable us to process our messages:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们将如何使用分帧来编码和解码我们的消息，我们需要从`futures`和`bytes`包中导入特质，以使我们能够处理我们的消息：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `SinkExt` and `StreamExt` traits essentially enable us to receive messages
    from the stream asynchronously. The `Bytes` struct will wrap our serialized message
    to be sent. Then, we must import the traits to enable the serialization of messages
    and define our message struct:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`SinkExt`和`StreamExt`特质基本上使我们能够异步地从流中接收消息。`Bytes`结构体会将我们的序列化消息包装起来以便发送。然后，我们必须导入这些特质以启用消息的序列化，并定义我们的消息结构体：'
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now have everything we need to start working on our runtime. Remember that
    our main runtime has the following outline:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有开始工作所需的全部内容，来构建我们的运行时。请记住，我们的主要运行时具有以下大纲：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inside our runtime, we initially make a TCP connection and define the framing
    with the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的运行时内部，我们最初建立一个TCP连接，并使用以下代码定义分帧：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we define our message, serialize the message, and then wrap the message
    in `Bytes` with the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的消息，序列化消息，并使用以下代码将消息包装在`Bytes`中：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can send our message, wait for the message to be sent back, and then
    deserialize the message to print it out with the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以发送我们的消息，等待消息被发送回来，然后反序列化消息并使用以下代码将其打印出来：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With all this, our client is built. We can see that we do not have to worry
    about new lines or any other delimiters. Our code is clean and straightforward
    when it comes to sending and receiving messages over TCP. Now that our client
    has been built, we can move on to building our server so that it handles framing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，我们的客户端已经构建完成。我们可以看到，我们不必担心换行符或其他任何分隔符。在通过TCP发送和接收消息时，我们的代码既干净又直接。现在，我们的客户端已经构建完成，我们可以继续构建服务器，以便它能够处理分帧。
- en: Rewriting our server so that it supports framing
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新编写我们的服务器以支持分帧
- en: When it comes to building our server to support framing, there is a lot of overlap
    with what we have coded in the previous section. At this point, it is a good time
    to try and build the server yourself. Building the server requires implementing
    the framing logic that we coded in the previous section into the existing server
    code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到构建支持帧处理的服务器时，它与我们在上一节中编写的代码有很多重叠。现在，尝试自己构建服务器是一个好时机。构建服务器需要将我们在上一节中编写的帧处理逻辑实现到现有的服务器代码中。
- en: 'If you attempted to rewrite the server, first, you should have imported the
    following structs and traits:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试重写服务器，首先，你应该已经导入了以下结构体和特质：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the `Decoder` trait that we imported allows us to call `.framed`
    on the bytes codec. There is nothing here that should be new to you. Once we have
    the necessary imports, we must define the same `Message` struct with the following
    code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们导入的`Decoder`特质允许我们在字节编解码器上调用`.framed`。这里没有什么应该让你感到陌生的。一旦我们有了必要的导入，我们必须使用以下代码定义相同的`Message`结构体：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we must define the outline of the server runtime with the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须使用以下代码定义服务器运行时的轮廓：
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we can see that the listener is looping to accept traffic and spawning
    threads when messages are received, as in previous server implementations. Inside
    our thread, we read our framed message with the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到监听器正在循环以接受流量，并在接收到消息时创建线程，就像之前的服务器实现一样。在我们的线程中，我们使用以下代码读取我们的帧化消息：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, we do not have a `while` loop anymore. This is because our framing
    manages the splitting between messages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们不再有`while`循环。这是因为我们的帧处理管理了消息之间的分割。
- en: 'Once we have extracted our bytes from our connection, we must implement the
    same logic that we did in our client, where we process our message, print it out,
    process it again, and then send it back to the client:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从连接中提取出我们的字节，我们必须实现我们在客户端中做的相同逻辑，即处理我们的消息，打印它，再次处理它，然后将其发送回客户端：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We now have a working client and server that utilizes framing. If we were to
    start the server and then run the client, the client will give us the following
    printout:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个正在工作的客户端和服务器，它们利用了帧处理。如果我们启动服务器然后运行客户端，客户端将给出以下打印输出：
- en: '[PRE36]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our server will give us the following printout:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器将给出以下打印输出：
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our server and client now support framing. We have come a long way. Now, we
    only have one more concept to explore in this chapter, and this is building an
    HTTP frame using TCP.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器和客户端现在支持帧处理。我们已经走了很长的路。现在，我们在这个章节中只剩下一个概念需要探索，那就是使用TCP构建HTTP帧。
- en: Building an HTTP frame on top of TCP
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在TCP之上构建HTTP帧
- en: Before we explored the Tokio framework in this book, we used HTTP to send and
    receive data to and from servers. The HTTP protocol is essentially built on top
    of TCP. In this section, while we will create an HTTP frame, we will not mimic
    the HTTP protocol completely. Instead, to prevent excessive code, we will create
    a basic HTTP frame to understand the mechanisms utilized when creating an HTTP
    frame. It also must be stressed that this is for educational purposes. TCP is
    good for our protocols, but if you want to use HTTP handlers, it is quicker, safer,
    and less error-prone to use out-of-the-box HTTP handlers such as Hyper. We will
    cover how to use Hyper HTTP handlers with Tokio in the next chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索这本书中的Tokio框架之前，我们使用HTTP在服务器之间发送和接收数据。HTTP协议本质上是在TCP之上构建的。在本节中，虽然我们将创建一个HTTP帧，但我们不会完全模仿HTTP协议。相反，为了防止代码过多，我们将创建一个基本的HTTP帧来理解创建HTTP帧时使用的机制。还必须强调，这只是为了教育目的。TCP对我们协议来说很好，但如果你想使用HTTP处理器，使用现成的HTTP处理器（如Hyper）会更快速、更安全、更不容易出错。我们将在下一章中介绍如何使用Hyper
    HTTP处理器与Tokio一起使用。
- en: 'When it comes to an HTTP request, a request generally has a header and a body.
    When we send over a request, the header will tell us what method is being used
    and the URL associated with the request. To define our HTTP frame, we need the
    same structs defining the frame on both the server and client. Therefore, we must
    have the same code for the `client/src/http_frame.rs` and `server/src/http_frame.rs`
    files. First, we must import the serialization traits that are needed with the
    following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到HTTP请求时，一个请求通常有一个头部和一个主体。当我们发送请求时，头部将告诉我们正在使用什么方法以及与请求关联的URL。为了定义我们的HTTP帧，我们需要在服务器和客户端上定义相同的帧结构体。因此，我们必须为`client/src/http_frame.rs`和`server/src/http_frame.rs`文件编写相同的代码。首先，我们必须使用以下代码导入需要的序列化特质：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we must define our HTTP frame with the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须使用以下代码定义我们的HTTP帧：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we can see, we have defined a header and body within our `HttpFrame` struct.
    We define the header and body structs with the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们在`HttpFrame`结构体中定义了一个头和体。我们使用以下代码定义头和体结构体：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our basic HTTP frame is now complete, and we can import the HTTP frame into
    the `main.rs` file of both the client and server with the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本HTTP帧现在已经完成，我们可以使用以下代码将HTTP帧导入客户端和服务器中的`main.rs`文件：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will start by sending our HTTP frame in the `main.rs` file of our client
    with the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在客户端的`main.rs`文件中发送我们的HTTP帧，以下代码：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can see that our HTTP frame is starting to look like an HTTP request that
    we would handle when receiving requests in our Actix servers. For the `main.rs`
    file in our server, there is little change. All we must do is redefine the struct
    that is being deserialized with the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的HTTP帧开始看起来像我们在Actix服务器接收请求时将要处理的HTTP请求。对于我们的服务器中的`main.rs`文件，几乎没有变化。我们只需要重新定义以下代码中正在反序列化的结构体：
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We now have a basic HTTP frame that we can use to send information. If we were
    to run our server and then client programs, we would get the following printout
    for the server:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的服务器和客户端程序，我们会得到以下服务器输出：
- en: '[PRE44]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our client program will then give us the following printout:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端程序将给出以下输出：
- en: '[PRE45]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can see that there is no corruption in our data. We have now covered all
    the core essential approaches and methods needed to be versatile in packaging,
    sending, and reading data over TCP.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的数据没有损坏。我们现在已经涵盖了所有核心必要的方法和技巧，以便在TCP上打包、发送和读取数据时更加灵活。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a basic TCP client that sends and receives data to
    an echo server. We started by sending over basic string data and separating the
    messages with delimiters. Then, we increased the complexity of the data that we
    sent over a TCP connection by serializing structs. This enabled us to have more
    complex data structures. This serialization also reduced the handling needed to
    get the message data in the format that we needed it to be in. For instance, in
    the previous chapter, we were parsing strings into floats after receiving the
    message. With structs, nothing is stopping us from having a list of floats as
    a field, and after the serialization of the message, we would have that field
    housing a list of floats without any extra lines of code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个基本的TCP客户端，向回声服务器发送和接收数据。我们首先发送基本的字符串数据，并用分隔符分隔消息。然后，我们通过序列化结构体增加了通过TCP连接发送的数据的复杂性。这使得我们能够拥有更复杂的数据结构。这种序列化还减少了获取所需格式的消息数据所需的处理。例如，在前一章中，我们在收到消息后会将字符串解析为浮点数。有了结构体，我们没有任何阻止我们将浮点数列表作为字段的理由，在消息序列化后，该字段将包含一个浮点数列表，而不需要任何额外的代码行。
- en: The serialization of structs is enough for us to handle most problems, but we
    explored framing so that we did not have to rely on delimiters to separate the
    messages that we send over TCP. With framing, we built a basic HTTP frame to visualize
    what we can do with frames and how HTTP is built on top of TCP. We must remember
    that implementing an HTTP protocol is more complicated than what we did in this
    chapter, and it is advised that we utilize established HTTP handlers from crates
    to handle and process HTTP traffic.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的序列化对于我们处理大多数问题已经足够，但我们探索了分帧技术，这样我们就不必依赖分隔符来区分我们通过TCP发送的消息。有了分帧，我们构建了一个基本的HTTP帧来可视化我们可以用帧做什么，以及HTTP是如何建立在TCP之上的。我们必须记住，实现HTTP协议比我们在本章中所做的工作要复杂得多，建议我们利用crate中已有的HTTP处理器来处理和HTTP流量。
- en: In the next chapter, we will use the established Hyper crate to handle HTTP
    traffic with the Tokio runtime framework.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用已建立的Hyper crate和Tokio运行时框架来处理HTTP流量。
- en: Further reading
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Tokio framing documentation: [https://tokio.rs/tokio/tutorial/framing](https://tokio.rs/tokio/tutorial/framing).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Tokio分帧文档：[https://tokio.rs/tokio/tutorial/framing](https://tokio.rs/tokio/tutorial/framing)。
- en: Questions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the advantage of framing over using a delimiter?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分帧与使用分隔符相比有什么优势？
- en: Why did we wrap our serialized message in a `Bytes` struct?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们将序列化的消息包装在`Bytes`结构体中？
- en: How would we be able to send over a string as a frame?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何能够发送一个字符串作为帧？
- en: Answers
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: If we use a delimiter such as a new line, the data that we send over TCP might
    contain a new line in the message. The problem with having a new line in the message
    means that the message is split before the end of the message is received. Framing
    gets rid of this issue.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用换行符等分隔符，通过 TCP 发送的数据中可能包含消息中的换行符。消息中存在换行符的问题意味着在接收到消息的末尾之前，消息已经被分割。帧结构解决了这个问题。
- en: We had to wrap our serialized message in a `Bytes` struct because the `Encode`
    trait is not implemented for any other data type.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不得不将序列化的消息包装进一个 `Bytes` 结构体中，因为 `Encode` 特性并未为任何其他数据类型实现。
- en: The simplest way to do this is to implement the `Encode` trait for a string.
    When implementing the `Encode` trait, we serialize the string and then wrap the
    string into a `Bytes` struct, reserve the length of the serialized string in the
    buffer, and then place the serialized string in the buffer.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现字符串的 `Encode` 特性是最简单的方法。在实现 `Encode` 特性时，我们序列化字符串，然后将字符串包装进一个 `Bytes` 结构体中，在缓冲区中预留序列化字符串的长度，然后将序列化后的字符串放入缓冲区。
