["```rs\nuse std::io;\n\npub enum ApplicationError {\n    Code { full: usize, short: u16 },\n    Message(String),\n    IOWrapper(io::Error),\n    Unknown\n}\n```", "```rs\nimpl ApplicationError {\n\n    pub fn print_kind(&self, mut to: &mut impl io::Write) -> \n    io::Result<()> {\n        let kind = match self {\n            ApplicationError::Code { full: _, short: _ } => \"Code\",\n            ApplicationError::Unknown => \"Unknown\",\n            ApplicationError::IOWrapper(_) => \"IOWrapper\",\n            ApplicationError::Message(_) => \"Message\"\n        };\n        write!(&mut to, \"{}\", kind)?; \n        Ok(())\n    }\n}\n```", "```rs\npub fn do_work(choice: i32) -> Result<(), ApplicationError> {\n    if choice < -100 {\n\n            Err(ApplicationError::IOWrapper(io::Error::\n             from(io::ErrorKind::Other\n  )))\n    } else if choice == 42 {\n        Err(ApplicationError::Code { full: choice as usize, short: \n        (choice % u16::max_value() as i32) as u16 } )\n    } else if choice > 42 {\n        Err(ApplicationError::Message(\n            format!(\"{} lead to a terrible error\", choice)\n        ))\n    } else {\n        Err(ApplicationError::Unknown)\n    }\n}\n```", "```rs\n\n#[cfg(test)]\nmod tests {\n    use super::{ApplicationError, do_work};\n    use std::io;\n\n    #[test]\n    fn test_do_work() {\n        let choice = 10;\n        if let Err(error) = do_work(choice) {\n            match error {\n                ApplicationError::Code { full: code, short: _ } => \n                assert_eq!(choice as usize, code),\n                // the following arm matches both variants (OR)\n                ApplicationError::Unknown | \n                ApplicationError::IOWrapper(_) => assert!(choice < \n                42),\n                ApplicationError::Message(msg) => \n                assert_eq!(format!\n                (\"{} lead to a terrible error\", choice), msg)\n            }\n        }\n    }\n```", "```rs\n    #[test]\n    fn test_application_error_get_kind() {\n        let mut target = vec![];\n        let _ = ApplicationError::Code { full: 100, short: 100 \n        }.print_kind(&mut target);\n        assert_eq!(String::from_utf8(target).unwrap(), \n        \"Code\".to_string());\n\n        let mut target = vec![];\n        let _ = ApplicationError::Message(\"0\".to_string()).\n        print_kind(&mut target);\n        assert_eq!(String::from_utf8(target).unwrap(), \n        \"Message\".to_string());\n\n        let mut target = vec![];\n        let _ = ApplicationError::Unknown.print_kind(&mut target);\n        assert_eq!(String::from_utf8(target).unwrap(), \n        \"Unknown\".to_string());\n\n        let mut target = vec![];\n        let error = io::Error::from(io::ErrorKind::WriteZero);\n        let _ = ApplicationError::IOWrapper(error).print_kind(&mut \n        target);\n        assert_eq!(String::from_utf8(target).unwrap(), \n        \"IOWrapper\".to_string());\n\n    }\n}\n```", "```rs\n$ cargo test\n   Compiling enums v0.1.0 (Rust-Cookbook/Chapter02/enums)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.61s\n     Running target/debug/deps/enums-af52cbd5cd8d54cb\n\nrunning 2 tests\ntest tests::test_do_work ... ok\ntest tests::test_application_error_get_kind ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests enums\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\npub enum ApplicationError {\n    Code { full: usize, short: u16 },\n    Message(String),\n    IOWrapper(io::Error),\n    Unknown\n}\n```", "```rs\n    #[test]\n    #[should_panic]\n    fn option_unwrap() {\n        // Options to unwrap Options\n        assert_eq!(Some(10).unwrap(), 10);\n        assert_eq!(None.unwrap_or(10), 10);\n        assert_eq!(None.unwrap_or_else(|| 5 * 2), 10);\n\n        Option::<i32>::None.unwrap();\n        Option::<i32>::None.expect(\"Better say something when \n        panicking\");\n    }\n```", "```rs\n    #[test]\n    fn option_working_with_values() {\n        let mut o = Some(42);\n\n        let nr = o.take();\n        assert!(o.is_none());\n        assert_eq!(nr, Some(42));\n\n        let mut o = Some(42);\n        assert_eq!(o.replace(1535), Some(42));\n        assert_eq!(o, Some(1535));\n\n        let o = Some(1535);\n        assert_eq!(o.map(|v| format!(\"{:#x}\", v)), \n        Some(\"0x5ff\".to_owned()));\n\n        let o = Some(1535);\n        match o.ok_or(\"Nope\") {\n            Ok(nr) => assert_eq!(nr, 1535),\n            Err(_) => assert!(false)\n        }\n    }\n```", "```rs\n    #[test]\n    fn option_sequentials() {\n        let a = Some(42);\n        let b = Some(1535);\n        // boolean logic with options. Note the returned values\n        assert_eq!(a.and(b), Some(1535));\n        assert_eq!(a.and(Option::<i32>::None), None);\n        assert_eq!(a.or(None), Some(42));\n        assert_eq!(a.or(b), Some(42));\n        assert_eq!(None.or(a), Some(42));\n        let new_a = a.and_then(|v| Some(v + 100))\n                     .filter(|&v| v != 42);\n\n        assert_eq!(new_a, Some(142));\n        let mut a_iter = new_a.iter();\n        assert_eq!(a_iter.next(), Some(&142));\n        assert_eq!(a_iter.next(), None);\n    }\n```", "```rs\n    #[test]\n    fn option_pattern_matching() {\n\n        // Some trivial pattern matching since this is common\n\n        match Some(100) {\n            Some(v) => assert_eq!(v, 100),\n            None => assert!(false) \n        };\n\n        if let Some(v) = Some(42) {\n            assert_eq!(v, 42);\n        }\n        else {\n            assert!(false);\n        }\n    }\n```", "```rs\n$ cargo test\n   Compiling not-null v0.1.0 (Rust-Cookbook/Chapter02/not-null)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.58s\n     Running target/debug/deps/not_null-ed3a746487e7e3fc\n\nrunning 4 tests\ntest tests::option_pattern_matching ... ok\ntest tests::option_sequentials ... ok\ntest tests::option_unwrap ... ok\ntest tests::option_working_with_values ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests not-null\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\nfn literal_match(choice: usize) -> String {\n    match choice {\n        0 | 1 => \"zero or one\".to_owned(),\n        2 ... 9 => \"two to nine\".to_owned(),\n        10 => \"ten\".to_owned(),\n        _ => \"anything else\".to_owned()\n    }\n}\n```", "```rs\nfn tuple_match(choices: (i32, i32, i32, i32)) -> String {\n    match choices {\n        (_, second, _, fourth) => format!(\"Numbers at positions 1 \n        and 3 are {} and {} respectively\", second, fourth)\n    }\n}\n```", "```rs\nenum Background {\n    Color(u8, u8, u8),\n    Image(&'static str),\n}\n\nenum UserType {\n    Casual,\n    Power\n}\n\nstruct MyApp {\n    theme: Background,\n    user_type: UserType,\n    secret_user_id: usize\n}\n```", "```rs\nfn destructuring_match(app: MyApp) -> String {\n    match app {\n        MyApp { user_type: UserType::Power, \n                secret_user_id: uid, \n                theme: Background::Color(b1, b2, b3) } => \n            format!(\"A power user with id >{}< and color background \n            (#{:02x}{:02x}{:02x})\", uid, b1, b2, b3),\n        MyApp { user_type: UserType::Power, \n                secret_user_id: uid, \n                theme: Background::Image(path) } => \n            format!(\"A power user with id >{}< and image background \n            (path: {})\", uid, path),\n        MyApp { user_type: _, secret_user_id: uid, .. } => format!\n        (\"A regular user with id >{}<, individual backgrounds not \n        supported\", uid), \n    }\n}\n```", "```rs\nfn guarded_match(app: MyApp) -> String { \n    match app {\n        MyApp { secret_user_id: uid, .. } if uid <= 100 => \"You are \n        an early bird!\".to_owned(),\n        MyApp { .. } => \"Thank you for also joining\".to_owned()\n    }\n}\n```", "```rs\nfn reference_match(m: &Option<&str>) -> String {\n    match m {\n        Some(ref s) => s.to_string(),\n        _ => \"Nothing\".to_string()\n    }\n}\n```", "```rs\nfn literal_str_match(choice: &str) -> String {\n    match choice {\n        \"\" => \"Power lifting\".to_owned(),\n        \"\" => \"Football\".to_owned(),\n        \"\" => \"BJJ\".to_owned(),\n        _ => \"Competitive BBQ\".to_owned()\n    }\n}\n```", "```rs\npub fn main() {\n    let opt = Some(42);\n    match opt {\n        Some(nr) => println!(\"Got {}\", nr),\n        _ => println!(\"Found None\") \n    }\n    println!();\n    println!(\"Literal match for 0: {}\", literal_match(0));\n    println!(\"Literal match for 10: {}\", literal_match(10));\n    println!(\"Literal match for 100: {}\", literal_match(100));\n\n    println!();\n    println!(\"Literal match for 0: {}\", tuple_match((0, 10, 0, \n    100)));\n\n    println!();\n    let mystr = Some(\"Hello\");\n    println!(\"Matching on a reference: {}\", \n    reference_match(&mystr));\n    println!(\"It's still owned here: {:?}\", mystr);\n```", "```rs\n    println!();\n    let power = MyApp {\n        secret_user_id: 99,\n        theme: Background::Color(255, 255, 0),\n        user_type: UserType::Power\n    };\n    println!(\"Destructuring a power user: {}\", \n    destructuring_match(power));\n\n    let casual = MyApp {\n        secret_user_id: 10,\n        theme: Background::Image(\"my/fav/image.png\"),\n        user_type: UserType::Casual\n    };\n    println!(\"Destructuring a casual user: {}\", \n    destructuring_match(casual));\n\n    let power2 = MyApp {\n        secret_user_id: 150,\n        theme: Background::Image(\"a/great/landscape.png\"),\n        user_type: UserType::Power\n    };\n    println!(\"Destructuring another power user: {}\", \n    destructuring_match(power2));\n```", "```rs\n    println!();\n    let early = MyApp {\n        secret_user_id: 4,\n        theme: Background::Color(255, 255, 0),\n        user_type: UserType::Power\n    };\n    println!(\"Guarded matching (early): {}\", guarded_match(early));\n\n     let not_so_early = MyApp {\n        secret_user_id: 1003942,\n        theme: Background::Color(255, 255, 0),\n        user_type: UserType::Power\n    };\n    println!(\"Guarded matching (late): {}\", \n    guarded_match(not_so_early));\n    println!();\n\n    println!(\"Literal match for : {}\", literal_str_match(\"\"));\n    println!(\"Literal match for : {}\", literal_str_match(\"\"));\n    println!(\"Literal match for : {}\", literal_str_match(\"\"));\n    println!(\"Literal match for : {}\", literal_str_match(\"\"));\n}\n```", "```rs\n$ cargo run\n   Compiling pattern-matching v0.1.0 (Rust-\n   Cookbook/Chapter02/pattern-matching)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/pattern-matching`\nGot 42\n\nLiteral match for 0: zero or one\nLiteral match for 10: ten\nLiteral match for 100: anything else\n\nLiteral match for 0: Numbers at positions 1 and 3 are 10 and 100 respectively\n\nMatching on a reference: Hello\nIt's still owned here: Some(\"Hello\")\n\nDestructuring a power user: A power user with id >99< and color background (#ffff00)\nDestructuring a casual user: A regular user with id >10<, individual backgrounds not supported\nDestructuring another power user: A power user with id >150< and image background (path: a/great/landscape.png)\n\nGuarded matching (early): You are an early bird!\nGuarded matching (late): Thank you for also joining\n\nLiteral match for : BJJ\nLiteral match for : Football\nLiteral match for : Power lifting\nLiteral match for : Competitive BBQ\n```", "```rs\npub struct ConsumingListIterator<T>\nwhere\n    T: Clone + Sized,\n{\n    list: List<T>,\n}\n\nimpl<T> ConsumingListIterator<T>\nwhere\n    T: Clone + Sized,\n{\n    fn new(list: List<T>) -> ConsumingListIterator<T> {\n        ConsumingListIterator { list: list }\n    }\n}\n```", "```rs\nimpl<T> Iterator for ConsumingListIterator<T>\nwhere\n    T: Clone + Sized,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        self.list.pop_front()\n    }\n}\n```", "```rs\nimpl<T> IntoIterator for List<T>\nwhere\n    T: Clone + Sized,\n{\n    type Item = T;\n    type IntoIter = ConsumingListIterator<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        ConsumingListIterator::new(self)\n    }\n}\n```", "```rs\n\n    fn new_list(n: usize, value: Option<usize>) -> List<usize>{\n        let mut list = List::new_empty();\n        for i in 1..=n {\n            if let Some(v) = value {\n                list.append(v);\n            } else {\n                list.append(i);\n            }\n        }\n        return list;\n    }\n\n    #[test]\n    fn test_list_iterator() {\n        let list = new_list(4, None);\n        assert_eq!(list.length, 4);\n\n        let mut iter = list.into_iter();\n        assert_eq!(iter.next(), Some(1));\n        assert_eq!(iter.next(), Some(2));\n        assert_eq!(iter.next(), Some(3));\n        assert_eq!(iter.next(), Some(4));\n        assert_eq!(iter.next(), None);\n\n        let list = new_list(4, Some(1));\n        assert_eq!(list.length, 4);\n\n        for item in list {\n            assert_eq!(item, 1);\n        } \n\n        let list = new_list(4, Some(1));\n        assert_eq!(list.length, 4);\n        assert_eq!(list.into_iter().fold(0, |s, e| s + e), 4);\n    }\n```", "```rs\n$ cargo test\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running target/debug/deps/custom_iterators-77e564edad00bd16\n\nrunning 7 tests\ntest tests::bench_list_append ... ok\ntest tests::test_list_append ... ok\ntest tests::test_list_new_empty ... ok\ntest tests::test_list_split ... ok\ntest tests::test_list_iterator ... ok\ntest tests::test_list_split_panics ... ok\ntest tests::test_list_pop_front ... ok\n\ntest result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests custom-iterators\n\nrunning 5 tests\ntest src/lib.rs - List (line 52) ... ignored\ntest src/lib.rs - List<T>::append (line 107) ... ok\ntest src/lib.rs - List<T>::new_empty (line 80) ... ok\ntest src/lib.rs - List<T>::pop_front (line 134) ... ok\ntest src/lib.rs - List<T>::split (line 173) ... ok\n\ntest result: ok. 4 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n```", "```rs\n[dev-dependencies]\nrand = \"^0.5\"\n```", "```rs\n    #[test]\n    fn getting_the_iterator() {\n        let v = vec![10, 10, 10];\n        let mut iter = v.iter();\n        assert_eq!(iter.next(), Some(&10));\n        assert_eq!(iter.next(), Some(&10));\n        assert_eq!(iter.next(), Some(&10));\n        assert_eq!(iter.next(), None);\n\n        for i in v {\n            assert_eq!(i, 10);\n        }\n    }\n```", "```rs\n    fn count_files(path: &String) -> usize {\n        path.len()\n    }\n\n    #[test]\n    fn data_transformations() {\n        let v = vec![10, 10, 10];\n        let hexed = v.iter().map(|i| format!(\"{:x}\", i));\n        assert_eq!(\n            hexed.collect::<Vec<String>>(),\n            vec![\"a\".to_string(), \"a\".to_string(), \"a\".to_string()]\n        );\n        assert_eq!(v.iter().fold(0, |p, c| p + c), 30);\n        let dirs = vec![\n            \"/home/alice\".to_string(),\n            \"/home/bob\".to_string(),\n            \"/home/carl\".to_string(),\n            \"/home/debra\".to_string(),\n        ];\n\n        let file_counter = dirs.iter().map(count_files);\n\n        let dir_file_counts: Vec<(&String, usize)> = \n        dirs.iter().zip(file_counter).collect();\n\n        assert_eq!(\n            dir_file_counts,\n            vec![\n                (&\"/home/alice\".to_string(), 11),\n                (&\"/home/bob\".to_string(), 9),\n                (&\"/home/carl\".to_string(), 10),\n                (&\"/home/debra\".to_string(), 11)\n            ]\n        )\n    }\n```", "```rs\n    #[test]\n    fn data_filtering() {\n        let data = vec![1, 2, 3, 4, 5, 6, 7, 8];\n        assert!(data.iter().filter(|&n| n % 2 == 0).all(|&n| n % 2 \n        == 0));\n\n        assert_eq!(data.iter().find(|&&n| n == 5), Some(&5));\n        assert_eq!(data.iter().find(|&&n| n == 0), None);\n        assert_eq!(data.iter().position(|&n| n == 5), Some(4));\n\n        assert_eq!(data.iter().skip(1).next(), Some(&2));\n        let mut data_iter = data.iter().take(2);\n        assert_eq!(data_iter.next(), Some(&1));\n        assert_eq!(data_iter.next(), Some(&2));\n        assert_eq!(data_iter.next(), None);\n\n        let (validation, train): (Vec<i32>, Vec<i32>) = data\n            .iter()\n            .partition(|&_| (rand::random::<f32>() % 1.0) > 0.8);\n\n        assert!(train.len() > validation.len());\n    }\n```", "```rs\n$ cargo test\n   Compiling libc v0.2.50\n   Compiling rand_core v0.4.0\n   Compiling iteration v0.1.0 (Rust-Cookbook/Chapter02/iteration)\n   Compiling rand_core v0.3.1\n   Compiling rand v0.5.6\n    Finished dev [unoptimized + debuginfo] target(s) in 5.44s\n     Running target/debug/deps/iteration-a23e5d58a97c9435\n\nrunning 3 tests\ntest tests::data_transformations ... ok\ntest tests::getting_the_iterator ... ok\ntest tests::data_filtering ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests iteration\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n#![allow(dead_code)]\nuse std::slice;\n\nfn split_into_equal_parts<T>(slice: &mut [T], parts: usize) -> Vec<&mut [T]> {\n    let len = slice.len();\n    assert!(parts <= len);\n    let step = len / parts;\n    unsafe {\n        let ptr = slice.as_mut_ptr();\n\n        (0..step + 1)\n            .map(|i| {\n                let offset = (i * step) as isize;\n                let a = ptr.offset(offset);\n                slice::from_raw_parts_mut(a, step)\n            })\n            .collect()\n    }\n}\n```", "```rs\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_split_into_equal_parts() {\n        let mut v = vec![1, 2, 3, 4, 5, 6];\n        assert_eq!(\n            split_into_equal_parts(&mut v, 3),\n            &[&[1, 2], &[3, 4], &[5, 6]]\n        );\n    }\n}\n```", "```rs\n#[test]\nfn test_str_to_bytes_horribly_unsafe() {\n    let bytes = unsafe { std::mem::transmute::<&str, &[u8]>(\"Going \n               off the menu\") };\n    assert_eq!(\n        bytes,\n            &[\n                71, 111, 105, 110, 103, 32, 111, 102, 102, 32, 116, \n                104, 101, 32, 109, 101, 110, 117\n            ]\n        );\n    }\n\n```", "```rs\n$ cargo test\n   Compiling unsafe-ways v0.1.0 (Rust-Cookbook/Chapter02/unsafe-ways)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.41s\n     Running target/debug/deps/unsafe_ways-e7a1d3ffcc456d53\n\nrunning 2 tests\ntest tests::test_str_to_bytes_horribly_unsafe ... ok\ntest tests::test_split_into_equal_parts ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests unsafe-ways\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n    /// \n    /// A length function that takes ownership of the input \n    /// variable\n    /// \n    fn length(s: String) -> usize {\n        s.len()\n    } \n```", "```rs\n    #[test]\n    fn cloning() {\n        let s = \"abcdef\".to_owned();\n        assert_eq!(length(s), 6);\n        // s is now \"gone\", we can't use it anymore\n        // therefore we can't use it in a loop either!\n        // ... unless we clone s - at a cost! (see benchmark)\n        let s = \"abcdef\".to_owned();\n\n        for _ in 0..10 {\n            // clone is typically an expensive deep copy\n            assert_eq!(length(s.clone()), 6);\n        }\n    }\n```", "```rs\n\n    extern crate test;\n    use std::rc::Rc;\n    use test::{black_box, Bencher};\n\n    #[bench]\n    fn bench_string_clone(b: &mut Bencher) {\n        let s: String = (0..100_000).map(|_| 'a').collect();\n        b.iter(|| {\n            black_box(length(s.clone()));\n        });\n    }\n```", "```rs\n\n    ///\n    /// The same length function, taking ownership of a Rc\n    /// \n    fn rc_length(s: Rc<String>) -> usize {\n        s.len() // calls to the wrapped object require no additions \n    }\n```", "```rs\n     #[test]\n    fn refcounting() {\n        let s = Rc::new(\"abcdef\".to_owned());\n        // we can clone Rc (reference counters) with low cost\n        assert_eq!(rc_length(s.clone()), 6);\n\n        for _ in 0..10 {\n            // clone is typically an expensive deep copy\n            assert_eq!(rc_length(s.clone()), 6);\n        }\n    }\n```", "```rs\n    #[bench]\n    fn bench_string_rc(b: &mut Bencher) {\n        let s: String = (0..100_000).map(|_| 'a').collect();\n        let rc_s = Rc::new(s);\n        b.iter(|| {\n            black_box(rc_length(rc_s.clone()));\n        });\n    }\n```", "```rs\n$ cargo test\n   Compiling sharing-ownership v0.1.0 (Rust-\n   Cookbook/Chapter02/sharing-ownership)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.81s\n     Running target/debug/deps/sharing_ownership-f029377019c63d62\n\nrunning 4 tests\ntest tests::cloning ... ok\ntest tests::refcounting ... ok\ntest tests::bench_string_rc ... ok\ntest tests::bench_string_clone ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests sharing-ownership\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n$ cargo bench\n   Compiling sharing-ownership v0.1.0 (Rust-\n   Cookbook/Chapter02/sharing-ownership)\n    Finished release [optimized] target(s) in 0.54s\n     Running target/release/deps/sharing_ownership-68bc8eb23caa9948\n\nrunning 4 tests\ntest tests::cloning ... ignored\ntest tests::refcounting ... ignored\ntest tests::bench_string_clone ... bench: 2,703 ns/iter (+/- 289)\ntest tests::bench_string_rc ... bench: 1 ns/iter (+/- 0)\n\ntest result: ok. 0 passed; 0 failed; 2 ignored; 2 measured; 0 filtered out\n```", "```rs\n    use std::cell::{Cell, RefCell};\n    use std::borrow::Cow;\n    use std::ptr::eq;\n\n    fn min_sum_cow(min: i32, v: &mut Cow<[i32]>) {\n        let sum: i32 = v.iter().sum();\n        if sum < min {\n            v.to_mut().push(min - sum);\n        }\n    }\n\n    fn min_sum_refcell(min: i32, v: &RefCell<Vec<i32>>) {\n        let sum: i32 = v.borrow().iter().sum();\n        if sum < min {\n            v.borrow_mut().push(min - sum);\n        }\n    }\n\n    fn min_sum_cell(min: i32, v: &Cell<Vec<i32>>) {\n        let mut vec = v.take();\n        let sum: i32 = vec.iter().sum();\n        if sum < min {\n            vec.push(min - sum);\n        }\n        v.set(vec);\n    }\n```", "```rs\n    #[test]\n    fn about_cells() {\n        // we allocate memory and use a RefCell to dynamically\n        // manage ownership\n        let ref_cell = RefCell::new(vec![10, 20, 30]);\n\n        // mutable borrows are fine,\n        min_sum_refcell(70, &ref_cell);\n\n        // they are equal!\n        assert!(ref_cell.borrow().eq(&vec![10, 20, 30, 10]));\n\n        // cells are a bit different\n        let cell = Cell::from(vec![10, 20, 30]);\n\n        // pass the immutable cell into the function\n        min_sum_cell(70, &cell);\n\n        // unwrap\n        let v = cell.into_inner();\n\n        // check the contents, and they changed!\n        assert_eq!(v, vec![10, 20, 30, 10]);\n    }\n```", "```rs\n    #[test]\n    #[should_panic]\n    fn failing_cells() {\n        let ref_cell = RefCell::new(vec![10, 20, 30]);\n\n        // multiple borrows are fine\n        let _v = ref_cell.borrow();\n        min_sum_refcell(60, &ref_cell);\n\n        // ... until they are mutable borrows\n        min_sum_refcell(70, &ref_cell); // panics!\n    }\n```", "```rs\n    extern crate test;\n    use test::{ Bencher};\n\n    #[bench]\n    fn bench_regular_push(b: &mut Bencher) {\n        let mut v = vec![];\n        b.iter(|| {\n            for _ in 0..1_000 {\n                v.push(10);\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_refcell_push(b: &mut Bencher) {\n        let v = RefCell::new(vec![]);\n        b.iter(|| {\n            for _ in 0..1_000 {\n                v.borrow_mut().push(10);\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_cell_push(b: &mut Bencher) {\n        let v = Cell::new(vec![]);\n        b.iter(|| {\n            for _ in 0..1_000 {\n                let mut vec = v.take();\n                vec.push(10);\n                v.set(vec);\n            }\n        });\n    }\n```", "```rs\n    #[test]\n    fn handling_cows() {\n        let v = vec![10, 20, 30];\n\n        let mut cow = Cow::from(&v);\n        assert!(eq(&v[..], &*cow));\n\n        min_sum_cow(70, &mut cow);\n\n        assert_eq!(v, vec![10, 20, 30]);\n        assert_eq!(cow, vec![10, 20, 30, 10]);\n        assert!(!eq(&v[..], &*cow));\n\n        let v2 = cow.into_owned();\n\n        let mut cow2 = Cow::from(&v2);\n        min_sum_cow(70, &mut cow2);\n\n        assert_eq!(cow2, v2);\n        assert!(eq(&v2[..], &*cow2));\n    }\n```", "```rs\n$ cargo test\n   Compiling mut-sharing-ownership v0.1.0 (Rust-\n   Cookbook/Chapter02/mut-sharing-ownership)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.81s\n     Running target/debug/deps/mut_sharing_ownership-\n     d086077040f0bd34\n\nrunning 6 tests\ntest tests::about_cells ... ok\ntest tests::bench_cell_push ... ok\ntest tests::bench_refcell_push ... ok\ntest tests::failing_cells ... ok\ntest tests::handling_cows ... ok\ntest tests::bench_regular_push ... ok\n\ntest result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests mut-sharing-ownership\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n$ cargo bench\n    Finished release [optimized] target(s) in 0.02s\n     Running target/release/deps/mut_sharing_ownership-\n     61f1f68a32def1a8\n\nrunning 6 tests\ntest tests::about_cells ... ignored\ntest tests::failing_cells ... ignored\ntest tests::handling_cows ... ignored\ntest tests::bench_cell_push ... bench: 10,352 ns/iter (+/- 595)\ntest tests::bench_refcell_push ... bench: 3,141 ns/iter (+/- 6,389)\ntest tests::bench_regular_push ... bench: 3,341 ns/iter (+/- 124)\n\ntest result: ok. 0 passed; 0 failed; 3 ignored; 3 measured; 0 filtered out\n```", "```rs\n// declaring a lifetime is optional here, since the compiler automates this\n\n///\n/// Compute the arithmetic mean\n/// \npub fn mean<'a>(numbers: &'a [f32]) -> Option<f32> {\n    if numbers.len() > 0 {\n        let sum: f32 = numbers.iter().sum();\n        Some(sum / numbers.len() as f32)\n    } else {\n        None\n    }\n} \n```", "```rs\n///\n/// Our almost generic statistics toolkit\n/// \npub struct StatisticsToolkit<'a> {\n    base: &'a [f64],\n}\n```", "```rs\nimpl<'a> StatisticsToolkit<'a> {\n\n    pub fn new(base: &'a [f64]) -> \n     Option<StatisticsToolkit> {\n        if base.len() < 3 {\n            None\n        } else {\n            Some(StatisticsToolkit { base: base })\n        }\n    }\n```", "```rs\n    pub fn var(&self) -> f64 {\n        let mean = self.mean();\n\n        let ssq: f64 = self.base.iter().map(|i| (i - \n        mean).powi(2)).sum();\n        return ssq / self.base.len() as f64;\n    }\n\n    pub fn std(&self) -> f64 {\n        self.var().sqrt()\n    }\n\n    pub fn mean(&self) -> f64 {\n        let sum: f64 = self.base.iter().sum();\n\n        sum / self.base.len() as f64\n    }\n```", "```rs\n    pub fn median(&self) -> f64 {\n        let mut clone = self.base.to_vec();\n\n        // .sort() is not implemented for floats\n        clone.sort_by(|a, b| a.partial_cmp(b).unwrap()); \n\n        let m = clone.len() / 2;\n        if clone.len() % 2 == 0 {\n            clone[m]\n        } else {\n            (clone[m] + clone[m - 1]) / 2.0\n        }\n    }\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    ///\n    /// a normal distribution created with numpy, with mu = \n    /// 42 and \n    /// sigma = 3.14 \n    /// \n    fn numpy_normal_distribution() -> Vec<f64> {\n        vec![\n            43.67221552, 46.40865622, 43.44603147, \n            43.16162571, \n            40.94815816, 44.585914 , 45.84833022, \n            37.77765835, \n            40.23715928, 48.08791899, 44.80964938, \n            42.13753315, \n            38.80713956, 39.16183586, 42.61511209, \n            42.25099062, \n            41.2240736 , 44.59644304, 41.27516889, \n            36.21238554\n        ]\n    }\n\n    #[test]\n    fn mean_tests() {\n        // testing some aspects of the mean function\n        assert_eq!(mean(&vec![1.0, 2.0, 3.0]), Some(2.0));\n        assert_eq!(mean(&vec![]), None);\n        assert_eq!(mean(&vec![0.0, 0.0, 0.0, 0.0, 0.0, 0.0, \n        0.0]), \n        Some(0.0));\n    }\n```", "```rs\n    #[test]\n    fn statisticstoolkit_new() {\n        // require >= 3 elements in an array for a \n        // plausible normal distribution\n        assert!(StatisticsToolkit::new(&vec![]).is_none());\n        assert!(StatisticsToolkit::new(&vec![2.0, \n         2.0]).is_none());\n\n        // a working example\n        assert!(StatisticsToolkit::new(&vec![1.0, 2.0, \n         1.0]).is_some());\n\n        // not a normal distribution, but we don't mind\n        assert!(StatisticsToolkit::new(&vec![2.0, 1.0, \n         2.0]).is_some());\n    }\n```", "```rs\n    #[test]\n    fn statisticstoolkit_statistics() {\n         // simple best case test\n        let a_sample = vec![1.0, 2.0, 1.0];\n        let nd = StatisticsToolkit::\n         new(&a_sample).unwrap();\n        assert_eq!(nd.var(), 0.2222222222222222);\n        assert_eq!(nd.std(), 0.4714045207910317);\n        assert_eq!(nd.mean(), 1.3333333333333333);\n        assert_eq!(nd.median(), 1.0);\n\n        // no variance\n        let a_sample = vec![1.0, 1.0, 1.0];\n        let nd = StatisticsToolkit::\n         new(&a_sample).unwrap();\n        assert_eq!(nd.var(), 0.0);\n        assert_eq!(nd.std(), 0.0);\n        assert_eq!(nd.mean(), 1.0);\n        assert_eq!(nd.median(), 1.0);\n```", "```rs\n        // double check with a real library\n        let a_sample = numpy_normal_distribution();\n        let nd = \n         StatisticsToolkit::new(&a_sample).unwrap();\n        assert_eq!(nd.var(), 8.580276516670548);\n        assert_eq!(nd.std(), 2.9292109034124785);\n        assert_eq!(nd.mean(), 42.36319998250001);\n        assert_eq!(nd.median(), 42.61511209);\n\n        // skewed distribution\n        let a_sample = vec![1.0, 1.0, 5.0];\n        let nd = \n         StatisticsToolkit::new(&a_sample).unwrap();\n        assert_eq!(nd.var(), 3.555555555555556);\n        assert_eq!(nd.std(), 1.8856180831641267);\n        assert_eq!(nd.mean(), 2.3333333333333335);\n        assert_eq!(nd.median(), 1.0);\n\n        // median with even collection length\n        let a_sample = vec![1.0, 2.0, 3.0, 4.0] ;\n        let nd = \n         StatisticsToolkit::new(&a_sample).unwrap();\n        assert_eq!(nd.var(), 1.25);\n        assert_eq!(nd.std(), 1.118033988749895);\n        assert_eq!(nd.mean(), 2.5);\n        assert_eq!(nd.median(), 3.0);\n    }\n}\n```", "```rs\n$ cargo test\n   Compiling lifetimes v0.1.0 (Rust-Cookbook/Chapter02/lifetimes)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.16s\n     Running target/debug/deps/lifetimes-69291f4a8f0af715\n\nrunning 3 tests\ntest tests::mean_tests ... ok\ntest tests::statisticstoolkit_new ... ok\ntest tests::statisticstoolkit_statistics ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests lifetimes\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n///\n/// A simple print function for printing debug formatted variables\n/// \nfn log_debug<T: Debug>(t: T) {\n    println!(\"{:?}\", t);\n}\n```", "```rs\n$ cargo run\n   Compiling trait-bounds v0.1.0 (Rust-Cookbook/Chapter02/trait-bounds)\nerror[E0277]: `AnotherType` doesn't implement `std::fmt::Debug`\n  --> src/main.rs:35:5\n   |\n35 | log_debug(b);\n   | ^^^^^^^^^ `AnotherType` cannot be formatted using `{:?}`\n   |\n   = help: the trait `std::fmt::Debug` is not implemented for `AnotherType`\n   = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`\nnote: required by `log_debug`\n  --> src/main.rs:11:1\n   |\n11 | fn log_debug<T: Debug>(t: T) {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: Could not compile `trait-bounds`.\n\nTo learn more, run the command again with --verbose.\n```", "```rs\n///\n/// An interface that can be used for quick and easy logging\n/// \npub trait Loggable: Debug + Sized {\n    fn log(self) {\n        println!(\"{:?}\", &self)\n    }\n}\n```", "```rs\n#[derive(Debug)]\nstruct ArbitraryType {\n    v: Vec<i32>\n}\n\nimpl ArbitraryType {\n    pub fn new() -> ArbitraryType {\n        ArbitraryType {\n            v: vec![1,2,3,4]\n        }\n    }\n}\nimpl Loggable for ArbitraryType {}\n```", "```rs\nfn main() {\n    let a = ArbitraryType::new();\n    a.log();\n    let b = AnotherType(2);\n    log_debug(b);\n}\n```", "```rs\n$ cargo run\n   Compiling trait-bounds v0.1.0 (Rust-Cookbook/Chapter02/trait-\n   bounds)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.38s\n     Running `target/debug/trait-bounds`\n     ArbitraryType { v: [1, 2, 3, 4] }\n     AnotherType(2)\n```", "```rs\nuse std::boxed::Box;\nuse std::cmp;\nuse std::ops::Index;\n\nconst MIN_SIZE: usize = 10;\n\ntype Node<T> = Option<T>;\n\npub struct DynamicArray<T>\nwhere\n    T: Sized + Clone,\n{\n    buf: Box<[Node<T>]>,\n    cap: usize,\n    pub length: usize,\n}\n```", "```rs\nimpl<T> DynamicArray<T>\nwhere\n    T: Sized + Clone,\n{\n    pub fn new_empty() -> DynamicArray<T> {\n        DynamicArray {\n            buf: vec![None; MIN_SIZE].into_boxed_slice(),\n            length: 0,\n            cap: MIN_SIZE,\n        }\n    }\n\n    fn grow(&mut self, min_cap: usize) {\n        let old_cap = self.buf.len();\n        let mut new_cap = old_cap + (old_cap >> 1);\n\n        new_cap = cmp::max(new_cap, min_cap);\n        new_cap = cmp::min(new_cap, usize::max_value());\n        let current = self.buf.clone();\n        self.cap = new_cap;\n\n        self.buf = vec![None; new_cap].into_boxed_slice();\n        self.buf[..current.len()].clone_from_slice(&current);\n    }\n\n    pub fn append(&mut self, value: T) {\n        if self.length == self.cap {\n            self.grow(self.length + 1);\n        }\n        self.buf[self.length] = Some(value);\n        self.length += 1;\n    }\n\n    pub fn at(&mut self, index: usize) -> Node<T> {\n        if self.length > index {\n            self.buf[index].clone()\n        } else {\n            None\n        }\n    }\n}\n```", "```rs\nimpl<T> Index<usize> for DynamicArray<T>\nwhere\n    T: Sized + Clone,\n{\n    type Output = Node<T>;\n\n    fn index(&self, index: usize) -> &Self::Output {\n        if self.length > index {\n            &self.buf[index]\n        } else {\n            &None\n        }\n    }\n}\n\nimpl<T> Clone for DynamicArray<T>\nwhere\n    T: Sized + Clone,\n{\n    fn clone(&self) -> Self {\n        DynamicArray {\n            buf: self.buf.clone(),\n            cap: self.cap,\n            length: self.length,\n        }\n    }\n}\n```", "```rs\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn dynamic_array_clone() {\n        let mut list = DynamicArray::new_empty();\n        list.append(3.14);\n        let mut list2 = list.clone();\n        list2.append(42.0);\n        assert_eq!(list[0], Some(3.14));\n        assert_eq!(list[1], None);\n\n        assert_eq!(list2[0], Some(3.14));\n        assert_eq!(list2[1], Some(42.0));\n    }\n\n    #[test]\n    fn dynamic_array_index() {\n        let mut list = DynamicArray::new_empty();\n        list.append(3.14);\n\n        assert_eq!(list[0], Some(3.14));\n        let mut list = DynamicArray::new_empty();\n        list.append(\"Hello\");\n        assert_eq!(list[0], Some(\"Hello\"));\n        assert_eq!(list[1], None);\n    }\n```", "```rs\n    #[test]\n    fn dynamic_array_2d_array() {\n        let mut list = DynamicArray::new_empty();\n        let mut sublist = DynamicArray::new_empty();\n        sublist.append(3.14);\n        list.append(sublist);\n\n        assert_eq!(list.at(0).unwrap().at(0), Some(3.14));\n        assert_eq!(list[0].as_ref().unwrap()[0], Some(3.14));\n\n    }\n\n    #[test]\n    fn dynamic_array_append() {\n        let mut list = DynamicArray::new_empty();\n        let max: usize = 1_000;\n        for i in 0..max {\n            list.append(i as u64);\n        }\n        assert_eq!(list.length, max);\n    }\n\n    #[test]\n    fn dynamic_array_at() {\n        let mut list = DynamicArray::new_empty();\n        let max: usize = 1_000;\n        for i in 0..max {\n            list.append(i as u64);\n        }\n        assert_eq!(list.length, max);\n        for i in 0..max {\n            assert_eq!(list.at(i), Some(i as u64));\n        }\n        assert_eq!(list.at(max + 1), None);\n    }\n}\n```", "```rs\n$ cargo test\n   Compiling generics v0.1.0 (Rust-Cookbook/Chapter02/generics)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.82s\n     Running target/debug/deps/generics-0c9bbd42843c67d5\n\nrunning 5 tests\ntest tests::dynamic_array_2d_array ... ok\ntest tests::dynamic_array_index ... ok\ntest tests::dynamic_array_append ... ok\ntest tests::dynamic_array_clone ... ok\ntest tests::dynamic_array_at ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests generics\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```"]