- en: Creating Crates and Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a module in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a nested module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a module with struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a file hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building libraries in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling external crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on introducing modules and crates in Rust. It will help
    you develop a highly modular and production-grade Rust application. With this,
    you will have a great file hierarchy, which will compliment the development of
    features in a modular fashion. The recipes in the chapter will also help you build
    libraries in Rust and define, control, and access features through external programs.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a module in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the applications must be modularized so that they become easy to maintain
    and develop. In Rust, we can have a powerful module system for our application
    that could hierarchically split the application source code into logical units,
    which we call modules, and manage their visibility (public/private) across the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary description of a module is that it's a collection of items, such
    as functions, structs, traits, impl blocks, and even other modules.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to create a sample module and understand the concept of visibility
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a file named `sample_mod.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a module named `sample_mod` using the `mod` keyword and define a function
    named `private_function` in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function named `sample_function` by marking its visibility as public,
    using the `pub` keyword in the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a public function `indirect_private_fn`, which would call `private_function`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define `sample_function` outside the scope of the `sample_mod` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `main` function, in which we will call each item of the `sample_mod`
    module to understand how they work and print the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the correct setup of the preceding code, you should get the following
    screenshot output when you compile and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b6ad408-6aed-42c1-80af-fa537251a934.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you learned how to create a sample module in Rust and how you
    are allowed to call the items of the module.
  prefs: []
  type: TYPE_NORMAL
- en: From this chapter onward we will follow the header style, which is our first
    step. It basically describes what the code or part of the application unit does.
    This is a very good code practice to follow, as it helps when another person starts
    off from where you develop.
  prefs: []
  type: TYPE_NORMAL
- en: We created a module named `sample_mod` using the `mod` keyword, followed by
    the braces `{}`. The content of the module is its items. Each item is designed
    to perform a specific task. By default, all the items in the module have private
    visibility, which means that they cannot be accessed directly outside the scope.
    In the `sample_mod` module, we explicitly created two functions with public visibility
    using the `pub` keyword. We added the keyword before creating or declaring the
    function using the `fn` keyword. This makes the item publicly visible outside
    the scope of the module. The private function or items can be accessed inside
    the scope of the module, where all the items can call each other, so we can indirectly
    call a public item to access a private item from it.
  prefs: []
  type: TYPE_NORMAL
- en: We create four functions in this code, where three are inside the module and
    one is accessible globally. The first function we created inside `sample_mod`
    was `private_function`, which, by default, has private visibility. Then we created
    two public functions, namely `sample_function` and `indirect_private_fn`, where
    `indirect_private_fn` calls `private_function` in its body.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call an item of the module outside its scope, we have to follow a particular
    syntax--`module_name::publically_visible_function name`. In the `main` function,
    we call `sample_fucntion`, which is a regular function, and the two publicly visible
    items of the `sample_mode` module: `function sample_mod::sample_function()` and
    `sample_mod::indirect_private_fn()`. These items will execute the content inside
    their respective scope.'
  prefs: []
  type: TYPE_NORMAL
- en: On calling the private item of the module, it will throw an error saying that
    the particular item is private. For example, in the preceding recipe, we got an
    error when we directly called `sample_mod::private_function();` from the `main`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Building a nested module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nested module is where we want to have modules inside modules, performing
    different tasks. You will learn how to declare and access the items of a nested
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Nested modules are a great way of having similar items or functional units in
    an application together, which helps in maintaining features and debugging crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a file named `sample_nested.rs` in the project workspace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header information, which will provide an overview of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a module named `sample_mod` using the `mod` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another module named `nested_mod` with `function` and public visibility
    under the `sample_mod` module, which makes `sample_mod` a nested module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `private_function` under the `nested_mod` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Define another module named `private_nested_mod` with a public function named
    `function` inside `sample_mod`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the nested modules with different items
    declared in them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the correct setup of the preceding code, you should get the following
    output when you compile and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12cab925-0611-405f-8ea7-fa5949698ca2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The nested module is a concept where you have a module inside another module.
    This feature is helpful in having a collection of units of application placed
    inside a common header.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we created a module named `sample_mod` using the `mod` keyword;
    in this module, we created two more modules, namely `nested_mod` and `private_nested_mod`,
    with different visibility. The rules of modules'' visibility follow the same rules
    as those of the items of the modules: we have to explicitly mention the `pub`
    keyword to mention the visibility of the module. If we do not mention anything,
    it will be considered private by the Rust compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create the items inside the nested modules, which are under the `sample_mod`
    module. In `nested_mod`, which is a public nested module, we created two items:
    a public method named `function` and a private method named `private_function`.
    In the other private nested module `private_nested_mod`, we created a public method
    named `function`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can have the same name for items/units residing inside different modules.
    In the preceding recipe, we had an item named `function`, which was present in
    both the nested modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we call the respective items that follow the standard
    syntax for accessing items. The only difference here is that the items reside
    inside different nested modules. In this case, we follow the `module_name::nested_module_name:item_name`
    syntax. Here, we first call the module name, followed by the nested module name
    and its items.
  prefs: []
  type: TYPE_NORMAL
- en: We call a public nested module a public item, which is `sample_mod::nested_mod::function()`.
    It will run fine and execute the contents of the item. On calling a private nested
    module, which in our recipe is `sample_mod::nested_mod::private_function()`, and
    similar private items of the public nested module, which in our recipe is `sample_mod::private_nested_mod::function()`,
    we will get an error mentioning that these items are private, as privately visible
    units cannot be directly accessed outside the scope.
  prefs: []
  type: TYPE_NORMAL
- en: We have the `#[allow(dead_code)]` attribute for the item `function` in the `private_nested_mod`
    module. The idea is to disable the `dead_code` lint of the compiler, which will
    warn about the unused function. In simple terms, lint is software which flags
    bugs in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module with struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe covers the structs that have an extra level of visibility with their
    fields. The visibility defaults to private and can be overridden with the pub
    modifier. This visibility only matters when a `struct` is accessed from outside
    the module, where it is defined and has the goal of hiding information (encapsulation).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a file named `sample_struct.rs` in the project workspace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the details of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a sample module named `sample_struct`, in which you can declare a public
    `struct` named `WhiteBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a public `struct` named `BlackBox` with a private generic type `T`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a public constructor named `const_new` using the `impl` keyword, which
    takes the generic `T` type as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `main` function by calling the `struct` items of the`sample_struct`
    module, which is the `whitebox` `struct` item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the correct setup of the preceding code, you should get the following
    output when you compile and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72c586e8-b773-412f-86f0-dc9e5fc4820c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, in the preceding recipes, we were only looking into modules that
    had functions that acted as their items. In this recipe, we will create `struct`
    items that have an extra level of visibility with their fields.
  prefs: []
  type: TYPE_NORMAL
- en: The visibility, by default, is private and can be changed using the `pub` keyword.
    The visibility allows us to hide information when we try to access a modules',
    items out of the scope of the module.
  prefs: []
  type: TYPE_NORMAL
- en: We created a module named `sample_struct` using the `mod` keyword. We created
    two structs with public visibility, named `WhiteBox` and `BlackBox`, using the
    `pub` and `struct` keywords. In both the `struct` items, we had a generic type
    `T`.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, generic means that the particular unit can accept one or more generic
    type parameters, `<T>`. For example, consider `fn foo<T>(T) { ... }`. Here, `T`
    is the argument that is specified as a generic type parameter using `<T>`, and
    it allows it to take any argument of any type.
  prefs: []
  type: TYPE_NORMAL
- en: In both structs, we had a field named `information`, which was tied up with
    `T`, which is the argument we received. The only difference is that we mentioned
    `information` in `WhiteBox` as public inside the `struct` and `information` inside
    `BlackBox` as private by default.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we created an implementation block for `BlackBox` where we explicitly
    specified the generic type `T` in the `impl` block. Inside it, we created a method
    named `const_new`, which we made publically visible, that accepted the generic
    type `T` as an argument and returned a `BlackBox` `struct`. The `const_new` acts
    as a public constructor for `BlackBox`, where we wanted to create the data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` block, we created the `WhiteBox` structure first and assigned
    it to a variable named `white_box` by `sample_struct::WhiteBox { information:
    "public information \n" }`. Here, we were calling the module, creating a complex
    data structure and printing the `white_box`, information field, which was delivered
    in the preceding step. Next, we tried to create a variable with the data structure
    of `BlackBox` in a similar manner. This led to an error saying the field name
    is private. This is the reason why we created a public method `const_new`, which
    is a constructor for the `BlackBox` data type. We performed this step by `sample_struct::BlackBox::const_new("classified
    information \n")` and assigned it to `_black_box`.'
  prefs: []
  type: TYPE_NORMAL
- en: This passed the argument from `main` to the `impl` block and created the structure.
    In this way, we were able to define a public `struct` with private fields, but
    we were still not able to publically access the information field by `_black_box.information`,
    as it was a private field originally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private members can be accessed by indirect methods in the module. Consider
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We expose a public constructor `create_foo` in the `foo` module, but the module
    `foo` still remains private and we only expose `create_foo` in `root` by the `use`
    keyword, which means that `bar` can now create a `Foo` `struct` but `create_foo`
    is still private outside of `root`.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe focuses on the usage of the `use` keyword in the Rust module, which
    will help in binding long and tiresome module call paths to a simple single entity.
    This will improve code readability and provide more control to the developer to
    call module units. We will also go through the scope of `use` and the concept
    of shadowing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a file named `sample_control.rs` in the project workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the details of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `other_function` using the `use` keyword, in order to create the binding
    for the `deeply` module''s items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the nested module `deeply` with the nested module named `nested` containing
    the public function `sample_function`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `sample_function`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `main` function by calling `other_function`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a block. In this block, use the `use` keyword and declare `deeply ::
    nested :: sample_function`, which is equivalent to binding it to `sample_function`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `sample_function` outside the block that is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the correct setup of the preceding code, you should get the following
    output when you compile and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56deda1c-814d-4cbf-ae51-2eadc68a3039.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We focused on the `use` keyword in this recipe, which is really handy when your
    modules get deeper (which means there are a lot of nested modules and units).
    In short, `use` helps bind a long module call to a single name. In the preceding
    recipe, we had a nested module named `deeply`, where `nested` is the module inside
    `deeply` that has a public function named `sample_function`. Conventionally, we
    can call this function by `deeply::nested::sample_function`; however, using the
    `use` keyword, we can bind this to a single entity and call it in the `main` function,
    which provides much easier access. Here, we bound this path to `other_function()`
    and we also created a normal function named `sample_function` to understand the
    concept of shadowing.
  prefs: []
  type: TYPE_NORMAL
- en: We created a block inside the `main` function and explicitly mentioned `use
    deeply::nested::sample_function` . We also called `sample_function` after that.
    This calls the `deeply` module's `sample_function` item rather than the globally
    available function and the `use` mentioned in the block ends once it goes outside
    the scope. Calling `sample_function` outside the block will lead to calling the
    global function, as `use` is not active anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `self` and `super` keywords in Rust to provide
    better access to the module's units and learn about the scope of Rust units. In
    this recipe, we will create various module units across the code with similar
    names, to create ambiguity in the unit name. We will check out how the `self`
    and `super` keywords help the developer overcome these problems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding. Also, create
    a file named `sample_module.rs` in the project workspace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a file named `sample_access.rs` in the project workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the details of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `sample_function` and print ``"called `sample_function()`"``
    in its scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a module named `cool` using the `mod` keyword and create a function
    named `sample_function` with public visibility. Then, print ``called `cool::sample_function()`
    n`` in its scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another module using the `mod` keyword named `sample_mod` and create
    a function item named `sample_function` by printing ``"called `sample_mod::sample_function()`
    n"``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a module named `cool` with the function item `sample_function` by marking
    its visibility as public using the `pub` keyword, and printing ``"called `sample_mod::cool::sample_function()`
    n"``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another function inside the `cool` module named `indirect_call` by marking
    its visibility as public using the `pub` keyword, and printing ``"called `sample_mod::indirect_call()`,
    thatn> "``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `sample_function` using the `self` and `super` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a block and call `root_sample_function`, which is bound to `cool::sample_function`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the sample module''s `indirect_call` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the correct setup of the preceding code, you should get the following
    screenshot as output when you compile and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a32d7ae-7916-4997-a740-7e2ef7ab8b59.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `super` and `self` keywords, we can remove ambiguity when accessing
    items across modules. This can help us eliminate a lot of hardcoding of paths.
  prefs: []
  type: TYPE_NORMAL
- en: We started off by creating a function named `sample_function`. In all the functions,
    we print how the function should be called. Then, we created a module named `cool`
    with a public function named `sample_function`, which had the same name as that
    of the declared outside the scope of `cool`. Lastly, we created a module named
    `sample_mod` consisting of a private function named `sample_function` and a public
    nested module `cool`, and a public function named `sample_function` and publicly
    visible function `indirect_call`.
  prefs: []
  type: TYPE_NORMAL
- en: All of the action in this recipe happens in the `indirect_call` function, which
    we call from the `main` function by `sample_mod::indirect_call()`. When we start
    to execute the `indirect_call` function, it first has a print statement that prints
    how the function was called, and then proceeds ahead with calling `self::sample_function()`.
    The `self` keyword refers to the current module scope. In this case, it was `sample_mod`,
    and calling `sample_function()` or `self::sample_function()` would have given
    the same result as they referred to the same `sample_function`.
  prefs: []
  type: TYPE_NORMAL
- en: To access `sample_function` of other modules (which in this case is `cool`)
    inside the scope of `sample_mod`, we have to mention the call using the `self`
    keyword, which is `self::cool::sample_function()`. To call the items/units outside
    the scope of the `sample_mod` module, we use `super`, which basically helps in
    calling the items outside the scope of the current module. Here, we called `sample_function`
    using the `super` keyword, which fetched the function that could be accessed by
    any units of the code. We achieved this by calling `super::sample_function()`.
    Next, we created a block in which we had the code chunk `use` `cool::sample_function`
    as `root_sample_function`, which used the `use` keyword to call `sample_function`
    of the `cool` module outside the scope and bind the path to `root_sample_function`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a file hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe discusses how to create a file structure for complex and bigger
    code bases so that it would be easier for the developer to manage application
    feature development. We will learn about the rules enforced by the Rust compiler
    to create a file hierarchy successfully so that the developer can utilize and
    get the same flexibility while using modules' units.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to code. Also, create
    a file named `sample_module.rs` in the project workspace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file named `sample_split.rs` and a folder named `sample_module` in
    the project workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `mod.rs`, `nested_mod.rs`, and `sample_private.rs` files inside
    the `sample_module` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get a folder structure, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaf93d7d-a35b-423a-a127-199ea0e6ad76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Write the code header with the details of the code in `sample_split.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a folder named `sample_module` containing the content of the `sample_mod`
    module in `sample_split.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a local function named `sample_function` that will print ``"called
    `sample_function()`"``, which will help in understanding the scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function, where we can call various items that will help
    in understanding the code workflow in the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the code header with the details of the code in `sample_module/mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Declare the different modules that are `sample_private` and the publicly visible
    module `nested_mod` from the files inside the `sample_module` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mod.rs` is an essential Rust script file inside the module folder that helps
    the compiler understand the different contents of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a public function named `sample_function` and print the called `` `sample_module::sample_function()`
    ``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function named `private_function` and print the ``"called `sample_module::private_function()`"``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a function named `indirect_access`, which calls `private_function`
    inside its scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the code header with the details of the code in `sample_module/nested_mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the items of the `nested_mod` module in this script. We start with
    defining the publicly visible `sample_function` and print ``"called `sample_module::nested::sample_function()`"``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a private function named `private_function` and print ``"called `sample_module::nested::private_function()`"``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the code header with the details of the code in `sample_module/sample_private.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a publicly visible function named `public_function` inside the script
    and print ``"called `sample_module::sample_private::public_function()`"``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the correct setup of the preceding code, you should get the following
    screenshot as output when you compile and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7c3afe0-1f3d-4032-b807-9aa2fe172d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not possible to have all the modules inside the same script for a large
    application, so we definitely need to follow a file hierarchy to maintain different
    units. We also need to learn the mapping to create a **file hierarchy**.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding recipe, we created the following files, which are `rs`, and
    a folder named `sample_module`, which has `mod.rs`, `nested_mod.rs`, and `sample_private.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: The `mod.rs` is a mandatory file inside the directory where we mention other
    modules that the `sample_split.rs` function would use in the file. The `sample_module`
    uses the private module `sample_private` and public module `nested_mod`, which
    are declared at the top of the file. We also created two public functions `sample_function`
    and `indirect_access`, which call the private function named `private_function`.
    These items are part of `sample_module` and can be directly called by `sample_module`
    in the `sample_split.rs` file.
  prefs: []
  type: TYPE_NORMAL
- en: In the `nested_mod.rs` file, we created a public function named `sample_function`,
    which can be called, and a private function named `private_function`, which cannot
    be called. Because `sample_module` is a private element of `nested_mod` and, similarly,
    the `sample_private.rs` file, we have a public function named `public_function`
    that cannot be accessed, as the `sample_private` module is private.
  prefs: []
  type: TYPE_NORMAL
- en: In `sample_split.rs`, which is outside the `sample_module` directory, we used
    this script as the gateway to call the modules that were inside the `sample_module`
    folder. We started off by calling `mod` `sample_module`, which is the module name
    to call the contents of the directory. We also created a function named `sample_function`,
    local to `sample_split.rs`, for understanding the purpose. Then, in the `main`
    function, we called all the units.
  prefs: []
  type: TYPE_NORMAL
- en: First, we called `sample_module::sample_function()`, which is the element of
    the `sample_function` module itself. The working of `sample_module::indirect_access()`,
    which would call the private item of `sample_module`, would be similar. To call
    the `nested_mod` public element, we called `sample_module::nested_mod::sample_function()`,
    which has the same syntax as that of the nested module.
  prefs: []
  type: TYPE_NORMAL
- en: Building libraries in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to build libraries that will contain the
    functional units of the Rust application, and the way we can compile the application
    in a library format so that we can access it externally from other programs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to code. Also, create
    a file named `sample_module.rs` in the project workspace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a file named `sample_lib.rs` in the project workspace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the details of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a public visible function named `public_function` and print ``"called
    sample_lib `public_function()`"``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a private function named `private_function` and print ``"called sample_lib
    `private_function()`"``:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Define another public function named `indirect_access` that will call `private_function`,
    declared in the preceding step, in its scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding code is set up, compile and run the project by the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following screenshot as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/150c8c6a-0f15-4fda-adf5-cb382d564ba9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a sample library and made a `.rlib` extension package
    of the code. This will help us call the units of the library in other crates or
    Rust programs.
  prefs: []
  type: TYPE_NORMAL
- en: We created two public functions named `public_function` and `indirect_access`
    and a private function named `private_function`. We called `private_function`
    from `indirect_access`, which is a way through which we can call it outside the
    scope. Then, we created the library using the Rust compiler and passed a few command-line
    arguments to it, which tells the compiler to create the library format of the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: While compiling the program, we ran `rustc --crate-type=lib sample_lib.rs`,
    which created a package named `libsample_lib.rlib` in the same directory. This
    file can be externally used at other crates. Alternatively, we can use Cargo to
    ship libraries by adding the `[lib]` tag in the `Cargo.toml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, libraries get prefixed with `lib`, and by default, they get the name
    of their crate file. But this default name can be overridden using the `crate_name`
    attribute while creating the library using rustc.
  prefs: []
  type: TYPE_NORMAL
- en: Calling external crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the external module units, libraries,
    or crates created from another Rust project. During the process, you will understand
    some basic syntax that allows external crate resources to be utilized as modules
    in the code, as well as the `extern crate` keyword, which provides a smooth way
    to call external crate resources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor to code. Also, create
    a file named `sample_module.rs` in the project workspace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a file named `sample_exec.rs` in the project workspace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the details of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous script creates `libsample_lib.rlib`, which uses the `extern` `crate`
    keyword we are calling in this particular script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `main` function that calls all the public items of `sample_lib`,
    which are `public_function` and `indirect_access`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding code is setup, compile and run the project by the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following screenshot as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fac5f416-2018-457e-b04d-b18f82c83098.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of this recipe is to reuse the units created in the `libsample_lib.rlib`
    library in the code to link a crate to a new Rust script. We have to use the `extern
    crate` declaration to call the units. This will not only link the library, but
    also import all its items/units under the same module name as the library name,
    which in our case is `sample_lib`.
  prefs: []
  type: TYPE_NORMAL
- en: The visibility rules that apply to modules also apply to libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Our first statement is `extern crate sample_lib`, which imports all the units.
    Now, we can call the units of the external library the way we call module items.
    In the `main` function, we call the units by `sample_lib::public_function()`;
    this would call `public_function` of `sample_lib` and `sample_lib::indirect_access()`
    would call `private_function` of `sample_lib`.
  prefs: []
  type: TYPE_NORMAL
