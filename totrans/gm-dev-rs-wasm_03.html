<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-25"><em class="italic"><a id="_idTextAnchor038"/>Chapter 2</em>: Drawing Sprites</h1>
			<p>Now that we've got a working app and we're drawing to the screen, we can start making something that actually looks like a game. That<a id="_idIndexMarker077"/> means <strong class="bold">rendering sprites</strong>, which is just a fancy way of saying drawing pictures. So, in this chapter, we'll start by defining what those pictures are by doing a little bit of game design, and then we'll render a static sprite to the screen. Since a static picture is a pretty boring game, we'll even get the sprite animating too.</p>
			<p>In this chapter, we'll do the following:</p>
			<ul>
				<li>Design our game, Walk the Dog.</li>
				<li>Render a sprite to the Canvas.</li>
				<li>Use a sprite sheet to load many sprites at once.</li>
				<li>Animate a character via the sprite sheet.</li>
			</ul>
			<p>By the end of this chapter, you'll be drawing characters instead of static triangles, and you'll even have them running on the screen.<a id="_idTextAnchor039"/></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor040"/>Technical requirements</h1>
			<p>In addition to the technical requirements of <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>, you'll need to download the assets found at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a>. We'll build on top of the results of that chapter as well, so don't throw away the code. If you're reading this book out of order because you can't be tamed by society's rules, then you can get the previous chapter's source code at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1</a> and start there. If you get stumped, you can find the complete source code for this chapter at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3wOpCqy">https://bit.ly/3wOpCqy</a></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor041"/>A quick game design session </h1>
			<p>In the previous<a id="_idIndexMarker078"/> chapter, I had you create a project called "Walk the Dog", and you were so engrossed by the process of creating a Rust project and my thrilling prose that you didn't even ask why that was the name of the project. Now we'll dig into the game we're making for this book – <strong class="bold">Walk the Dog</strong>.</p>
			<p><em class="italic">Walk the Dog</em> is an endless runner with a simple concept. You play as a boy walking his dog through the forest when your dog is surprised by a cat that runs by and starts chasing it. You, in turn, begin chasing your dog through the forest, dodging obstacles along the way, until you crash into one and fall down. At which point, of course, the dog turns around and checks on you.</p>
			<p>In case you hadn't guessed, the idea for this game came to me while walking the dog on ice. I've<a id="_idIndexMarker079"/> used <em class="italic">Miro</em> (<a href="https://miro.com">https://miro.com</a>) to make a prototype, just to get a feel for what the game will look like:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer014">
					<img alt="Figure 2.1 – A Walk the Dog screen, hypothetically" src="image/Figure_2.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – A Walk the Dog screen, hypothetically</p>
			<p>Before you get the idea that I'm a great artist, all of the assets I'm using are freely available online via creative commons licenses. You might notice that the background is a little fuzzy relative to the characters, and that's because I made almost no effort to scale the characters to fit beyond copying and pasting them into Miro and dragging the corners around. When we place the actual objects in our game, we'll need to make a better effort than that.</p>
			<p>The temptation at this point is to say, "we're done" and start coding. Given the small size of our game, I don't think we need a full treatment to start coding, but I do want to make sure that we clarify a few things about the game.</p>
			<p>Scoring is done by measuring <a id="_idIndexMarker080"/>how far our little <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong> for short) runs – the same as most endless runners<a id="_idIndexMarker081"/> such as <em class="italic">Canabalt</em> (<a href="http://canabalt.com/">http://canabalt.com/</a>) or the <em class="italic">Dinosaur T-Rex</em> game that shows up when you start Google Chrome without an internet connection. The dog and cat navigate all obstacles effortlessly and are just there to give the player ideas on how to catch the dog, and perhaps mislead the player by taking a path they cannot follow. Obstacles will include rocks and boxes that you can crash into and water that you can fall into. RHB has a slide animation, so sometimes he'll need to slide under little cliffs too, which the dog runs under effortlessly. It's not enough for a fully fledged<a id="_idIndexMarker082"/> game, but it's enough to give us a checklist of features for future chapters. Let's say goodbye to our lovely triangles and begin rendering our adorable Red Hat <a id="_idTextAnchor042"/>Boy.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor043"/>Rendering a sprite</h1>
			<p>Sprite is a term<a id="_idIndexMarker083"/> so commonplace that it's possible to use it in conversation without actually knowing its meaning, yet properly defining it means properly defining bitmap, which in turn means properly defining pixmap. Did you know the term sprite was coined in the 1970s by Danny Hillis (<a href="http://bit.ly/3aZlJ72">http://bit.ly/3aZlJ72</a>)? It's exhausting.</p>
			<p>While I find all of this fascinating, you didn't get this book for that, so for our purposes, a sprite is a 2D image loaded from a file. Red Hat Boy, his dog and cat, and the background will all be sprites. Let's not waste any more time on definitions and start drawing<a id="_idTextAnchor044"/> one.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor045"/>Loading images</h2>
			<p>We'll <a id="_idIndexMarker084"/>start by<a id="_idIndexMarker085"/> unzipping the assets and copying the <strong class="source-inline">Idle (1).png</strong> file from <strong class="source-inline">resized/rhb</strong> into the <strong class="source-inline">static</strong> directory in your project. This will make it reachable from your program. As we build the program out, we'll need further organization, but for one file, this is fine. Next, we'll need to modify our code. You can leave the Sierpiński triangle in there for now as it looks cute next to the sprite, but the first thing to do is use the <strong class="source-inline">HTMLImage</strong> element to load an image. For now, it's important that you load and draw the image <strong class="bold">before</strong> calling into the Sierpiński triangle. It looks like this:</p>
			<p class="source-code">#[wasm_bindgen(start)]</p>
			<p class="source-code">pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {</p>
			<p class="source-code">    ....</p>
			<p class="source-code">    let image = web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">    image.set_src("Idle (1).png");</p>
			<p class="source-code">    sierpinski(</p>
			<p class="source-code">        &amp;context,</p>
			<p class="source-code">        [(300.0, 0.0), (0.0, 600.0), (600.0, 600.0)],</p>
			<p class="source-code">        (0, 255, 0),</p>
			<p class="source-code">        5,</p>
			<p class="source-code">    );</p>
			<p class="source-code">    Ok(())</p>
			<p class="source-code">}</p>
			<p>You will<a id="_idIndexMarker086"/> once<a id="_idIndexMarker087"/> again get the <strong class="source-inline">^^^^^^^^^^^^^^^^ could not find `HtmlImageElement` in `web_sys`</strong> error. Remember that the <strong class="source-inline">web-sys</strong> crate makes heavy use of feature flags, so you'll need to add <strong class="source-inline">HtmlImageElement</strong> to the feature flag list in <strong class="source-inline">Cargo.toml</strong>. After you add that, rebuilding will take a little longer, but the application will build again. Now you have loaded the image, and we can draw it.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor046"/>Canvas coordinates </h2>
			<p>Before <a id="_idIndexMarker088"/>we <a id="_idIndexMarker089"/>draw it, we need to cover one thing about the <strong class="bold">Canvas</strong> that you might have noticed from the first chapter, and that is the coordinate system. In the first chapter, we covered how the Canvas has a context; in fact, it has multiple contexts, but you can only use one per canvas, and that we are using the <strong class="bold">2D</strong> context, which gives us an API for drawing directly to the screen. Then, we made a bunch of <strong class="source-inline">line_to</strong> and <strong class="source-inline">move_to</strong> commands that may not have made sense at the time, which is why we need to discuss the coordinate system:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer015">
					<img alt="Figure 2.2 – Source: Mozilla (http://mzl.la/30NLhxX)" src="image/Figure_2.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Source: Mozilla (http://mzl.la/30NLhxX)</p>
			<p>Our canvas is divided into a 2D grid with dimensions of 600 by 600. Why 600 x 600? Because that's the height and width of our canvas element on the HTML page that we created in <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>. The size itself was completely arbitrary, and we'll probably <a id="_idIndexMarker090"/>change<a id="_idIndexMarker091"/> it as our game grows. The units of the grid are pixels, so when we moved the top of our original triangle to <strong class="source-inline">(300.0, 0.0)</strong>, we moved it 300 pixels to the right (because <strong class="bold">x</strong> is first) and 0 pixels down (because <strong class="bold">y</strong> is second). Note that <strong class="bold">0</strong> is at the top of the screen because <strong class="source-inline">(0.0, 0.0)</strong> is in the top-left corner of<a id="_idTextAnchor047"/> the canvas.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor048"/>Drawing images</h2>
			<p>Drawing <a id="_idIndexMarker092"/>one image at this point seems uncomplicated – we'll <a id="_idIndexMarker093"/>use the <strong class="source-inline">drawImage</strong> command from JavaScript; only we'll use the <strong class="source-inline">web-sys</strong> version for <strong class="source-inline">HtmlElement</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Remember that JavaScript functions frequently use function overloading, which Rust doesn't support, so one JavaScript function may have many corresponding variations in Rust.</p>
			<p>So, let's add the draw command right after the code to load the image, and we'll be done:</p>
			<p class="source-code">image.set_src("Idle (1).png");</p>
			<p class="source-code">context.draw_image_with_html_image_element(&amp;image, 0.0, 0.0);</p>
			<p class="source-code">...</p>
			<p>We've ignored <strong class="source-inline">Result</strong> from the <strong class="source-inline">draw_image_with_html_image_element</strong> command, but that should draw the image, except, it…doesn't. It turns out you can't draw the image immediately after setting the source of an image element because the image hasn't been loaded yet. In order to wait for the image to be loaded, we'll use the <strong class="source-inline">onload</strong> callback of <strong class="source-inline">HtmlImageElement</strong>, which you can set up using <strong class="source-inline">set_onload</strong> in Rust. To do that, you'll need to learn a little about using JavaScript callbacks from Rust in the WebAssembl<a id="_idTextAnchor049"/>y environment.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor050"/>JavaScript callbacks</h2>
			<p>When you <a id="_idIndexMarker094"/>set the <strong class="source-inline">onload</strong> callback via the <strong class="source-inline">set_onload</strong> function<a id="_idIndexMarker095"/> in Rust, you're calling into JavaScript from WebAssembly, via a function that <strong class="source-inline">web-sys</strong> has generated for you. Unfortunately, translating the following JavaScript to Rust is complicated by the fact that JavaScript is garbage collected whereas Rust uses manual memory management, with its famous borrow checker. Take this code for example:</p>
			<p class="source-code">image.onload = () =&gt; { alert("loaded"); }</p>
			<p>What this means is to actually pass a function to JavaScript, as we want to do here, you have to use a complicated signature as well as think carefully about the borrowing rules of Rust. It's the kind of code that finally makes sense after you get it right but can be hard to write. Let's work through what we need to do here.</p>
			<p>Back in our source code, right after creating <strong class="source-inline">HtmlImageElement</strong>, we can try to add an <strong class="source-inline">onload</strong> callback<a id="_idIndexMarker096"/> in a<a id="_idIndexMarker097"/> way that seems intuitive:</p>
			<p class="source-code">let image = web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">image.set_onload(|| {</p>
			<p class="source-code">    web_sys::console::log_1(&amp;JsValue::from_str("loaded"));</p>
			<p class="source-code">});</p>
			<p class="source-code">image.set_src("Idle (1).png");</p>
			<p class="source-code">...</p>
			<p>Intuitive might be an exaggeration, but that fits with the code we know how to write so far. Unfortunately, that doesn't work, as you'll get compiler errors about mismatched types, as shown here:</p>
			<p class="source-code">error[E0308]: mismatched types</p>
			<p class="source-code">  --&gt; src/lib.rs:43:22</p>
			<p class="source-code">   |</p>
			<p class="source-code">   |       image.set_onload(|| {</p>
			<p class="source-code">   |  ______________________^</p>
			<p class="source-code">   | |         web_sys::console.log_1("loaded");</p>
			<p class="source-code">   | |     });</p>
			<p class="source-code">   | |_____^ expected enum `Option`, found closure</p>
			<p class="source-code">   |</p>
			<p class="source-code">   = note: expected enum `Option&lt;&amp;js_sys::Function&gt;`</p>
			<p class="source-code">           found closure `[closure@src/lib.rs:43:22: 45:6]`</p>
			<p>As the error says, <strong class="source-inline">set_onload</strong> doesn't take a Rust closure but instead takes <strong class="source-inline">Option&lt;&amp;js_sys::Function&gt;</strong>. Unfortunately, the error doesn't tell you how to fix it, and it's not clear how to create the <strong class="source-inline">js_sys::Function</strong> object. What you can do is start by creating a <strong class="source-inline">Closure</strong> object, with a capital "C," and try passing that into <strong class="source-inline">set_onload</strong>:</p>
			<p class="source-code">let image = web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">let callback = Closure::once(|| {</p>
			<p class="source-code">    web_sys::console::log_1(&amp;JsValue::from_str("loaded"));</p>
			<p class="source-code">});</p>
			<p class="source-code">image.set_onload(callback);</p>
			<p><strong class="source-inline">Closure</strong> is a <strong class="source-inline">wasm-bindgen</strong> struct that is used to transfer a Rust closure to JavaScript. Here, we <a id="_idIndexMarker098"/>are using the <strong class="source-inline">once</strong> function on <strong class="source-inline">Closure</strong> because<a id="_idIndexMarker099"/> we know the <strong class="source-inline">onload</strong> handler is only called once. However, we still can't just send that to JavaScript as is; trying to via <strong class="source-inline">image.set_onload(callback)</strong> results in the following error:</p>
			<p class="source-code">error[E0308]: mismatched types</p>
			<p class="source-code">  --&gt; src/lib.rs:47:22</p>
			<p class="source-code">   |</p>
			<p class="source-code">47 |     image.set_onload(callback);</p>
			<p class="source-code">   |                      ^^^^^^^^ expected enum `Option`, </p>
			<p class="source-code">   found struct `wasm_bindgen::prelude::Closure`</p>
			<p>Remember that <strong class="source-inline">set_onload</strong> wants <strong class="source-inline">Option&lt;&amp;js_sys::Function&gt;</strong>, and so far, we've only created <strong class="source-inline">Closure</strong>. Fortunately, the <strong class="source-inline">Closure</strong> struct provides a way to make that conversion, which looks like this:</p>
			<p class="source-code">image.set_onload(Some(callback.as_ref().unchecked_ref()));</p>
			<p>First, we call <strong class="source-inline">as_ref</strong> on the callback, which returns a raw <strong class="source-inline">JsValue</strong>, and then we call <strong class="source-inline">unchecked_ref</strong>, which converts it to a <strong class="source-inline">&amp;Function</strong> object. We pass that into <strong class="source-inline">Some</strong> because <strong class="source-inline">onload</strong> can be <strong class="source-inline">null</strong> in JavaScript. Hooray! It compiles! The draw code now looks like this:</p>
			<p class="source-code">let image = web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">let callback = Closure::once(|| {</p>
			<p class="source-code">    web_sys::console::log_1(&amp;JsValue::from_str("loaded"));</p>
			<p class="source-code">});</p>
			<p class="source-code">image.set_onload(Some(callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">image.set_src("Idle (1).png");</p>
			<p class="source-code">context.draw_image_with_html_image_element(&amp;image, 0.0, 0.0);</p>
			<p class="source-code">...</p>
			<p>And if you<a id="_idIndexMarker100"/> run the app, it <strong class="bold">still</strong> doesn't show our image, but it<a id="_idIndexMarker101"/> does log an error in the browser's console:</p>
			<p class="source-code">Uncaught Error: closure invoked recursively or destroyed already</p>
			<p>When was the closure destroyed? This is all in the <strong class="source-inline">main</strong> function, and so the closure is destroyed a couple of lines later when the function completes and the <strong class="source-inline">callback</strong> variable is no longer in scope. In order to see our log message, we can add one more call to the code after setting the <strong class="source-inline">on_load</strong> function:</p>
			<p class="source-code">image.set_onload(Some(callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">callback.forget();</p>
			<p>Calling <strong class="source-inline">forget()</strong> on the callback hands over memory management from Rust to JavaScript, effectively creating a deliberate memory leak. This is not something we want to do often, and it's here strictly to get us past our latest error, by preventing the closure from being destroyed. If you compile that and check your browser console, you'll see the message "loaded" now. This is great and all, but it still doesn't draw our picture because we're not actually waiting for the image to be loaded yet. For that, we'll need an asynchronous function.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Translating Rust closures to JavaScript closures is one of those cases where the abstractions between JavaScript and Rust are leaking all over the place, and it can be "accidentally-swear-in-front-of-your-kids" frustrating. So, don't feel bad when you get this wrong <a id="_idIndexMarker102"/>or get confused; it just means you're <a id="_idIndexMarker103"/>human.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We'll have more examples of sending closures to JavaScript throughout this book, but you may find yourself wanting to cross-reference the official documents at <a href="http://bit.ly/3kSyOSI">http://bit.ly/3kSyOSI</a> an<a id="_idTextAnchor051"/>d <a href="http://bit.ly/3sXt1OW">http://bit.ly/3sXt1OW</a>.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor052"/>Async Rust</h2>
			<p>Rust <a id="_idIndexMarker104"/>added <strong class="bold">async/.await</strong> support in version 1.39 as a "syntactic <a id="_idIndexMarker105"/>sugar" around <a id="_idIndexMarker106"/>futures. If you haven't used them before (in Rust or other languages), the shorthand is that you can annotate a function or block with <strong class="source-inline">async</strong>, letting the runtime know that a function can be made to run asynchronously. Inside that function, you can then use an <strong class="source-inline">await</strong> call to pause execution of the current thread/process and allow the rest of the application to continue until the function that's being waited for can resume. The key thing is that while <strong class="source-inline">await</strong> pauses execution of the current execution context, it allows the rest of the code to continue. This makes it ideal for a game that cannot ever stop executing its game loop. It's also significantly cleaner to work with than callback-based code, so we'll be using it here (in combination with channels) to make sure that we don't try to draw our image before it's loaded.</p>
			<p>If you're familiar with using <strong class="source-inline">async</strong>/<strong class="source-inline">.await</strong> in traditional Rust, then you know these functions need to execute in a runtime, usually using crates such as <strong class="source-inline">tokio</strong> or <strong class="source-inline">async-std</strong>. That runtime is responsible for handing off control and restoring it. Take this simple example from the <strong class="source-inline">async-std</strong> library's repository:</p>
			<p class="source-code">use async_std::task;</p>
			<p class="source-code">fn main() -&gt; Result&lt;(), surf::Error&gt; {</p>
			<p class="source-code">    task::block_on(async {</p>
			<p class="source-code">        let url = "https://www.rust-lang.org";</p>
			<p class="source-code">        let mut response = surf::get(url).send().await?;</p>
			<p class="source-code">        let body = response.body_string().await?;</p>
			<p class="source-code">        dbg!(url);</p>
			<p class="source-code">        dbg!(response.status());</p>
			<p class="source-code">        dbg!(response.version());</p>
			<p class="source-code">        dbg!(response.header_names());</p>
			<p class="source-code">        dbg!(response.header_values());</p>
			<p class="source-code">        dbg!(body.len());</p>
			<p class="source-code">        Ok(())</p>
			<p class="source-code">    })</p>
			<p class="source-code">}</p>
			<p>Here, the <strong class="source-inline">async</strong> block<a id="_idIndexMarker107"/> is <a id="_idIndexMarker108"/>wrapped in a function called <strong class="source-inline">task::block_on</strong>, which handles stopping the execution of this block on each <strong class="source-inline">await</strong> call and then resuming execution when the <strong class="source-inline">await</strong> "wakes up" for future processing. All of this requires spawning threads or checking event loops, code that you don't have to write because you're getting it from <strong class="source-inline">async-std</strong>.</p>
			<p>If you're familiar with other languages that natively support async/.await syntax, such as JavaScript, you might wonder why this additional step is necessary. The answer is that, unlike JavaScript, Rust doesn't <strong class="bold">have</strong> a runtime, asynchronous or otherwise, so we have to provide one. It's a little uncomfortable that the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords exist in the language but don't work without additional crates, but that's a price we pay for additional power.</p>
			<p>That's the bad news, but now for the good news – in WebAssembly, we don't need any additional runtime! Our code runs in the browser and can, therefore, use the browser's runtime; we <a id="_idIndexMarker109"/>just need to use a crate to spawn futures on the local <a id="_idIndexMarker110"/>event loop, and that crate is already present – <strong class="source-inline">wasm_bindgen_futures</strong>.</p>
			<h3>Spawning a future </h3>
			<p>A <strong class="bold">future</strong>, in Rust <a id="_idIndexMarker111"/>and other languages, is a data structure that represents an asynchronous computation. In other words, it's a reference to something that will happen <em class="italic">in the future</em>, hence the name. In the case of Rust, it's actually implemented as a trait. In Rust, the trait is named <strong class="source-inline">Future</strong>, naturally, but as a user of futures, you don't generally create the <strong class="source-inline">Future</strong> type directly. You declare a function or closure as <strong class="source-inline">async</strong>, and when an <strong class="source-inline">async</strong> function is called, its return value will be wrapped in <strong class="source-inline">Future</strong>. Then, the caller can wait for that <strong class="source-inline">Future</strong> instance to finish by calling <strong class="source-inline">await</strong>. The benefit of this approach is that while the program doesn't actually stop when you call <strong class="source-inline">await</strong>, it looks like it does from the perspective of the code author. This makes the code look a lot more linear. In reality, execution of your program continues; otherwise, it would become unresponsive, but the runtime handles picking up the program where it left off when <strong class="source-inline">Future</strong> completes.</p>
			<p>In case you forgot, we're trying to draw a sprite to the canvas, and to do so, we have to wait for the image to be loaded first. For that, we'll eventually use futures, but there's some infrastructure we need to build first. We'll start by adding an <strong class="source-inline">onload</strong> callback to <strong class="source-inline">HtmlImageElement</strong>, which will call a <strong class="source-inline">oneshot</strong> channel when the image is loaded. A <strong class="source-inline">oneshot</strong> channel is a channel where the receiver implements the <strong class="source-inline">Future</strong> trait, so we can call <strong class="source-inline">await</strong> on it to wait for it to receive a message. If we set up the <strong class="source-inline">onload</strong> callback to send a message to that channel, we can then call <strong class="source-inline">await</strong> on the receiver so execution will block until that image is loaded. Then, we can actually draw the image, knowing it's loaded. For all that to work, we need to wrap everything in an <strong class="source-inline">async</strong> block and spawn the returned future. That's a limitation of the <strong class="source-inline">await</strong> syntax; it can only work inside an <strong class="source-inline">async</strong> function of a block. Naturally, we'll start the implementation in the…<strong class="source-inline">Cargo.toml</strong> file.</p>
			<p>I guess it's not natural to start with the .<strong class="source-inline">TOML</strong> file, but we need to pull the future dependencies into our WebAssembly project. They're already present in testing, so we'll move <strong class="source-inline">futures</strong> and <strong class="source-inline">wasm-bindgen-futures</strong> out of <strong class="source-inline">dev-dependencies</strong> and into the standard <strong class="source-inline">dependencies</strong> block. You can put them right under <strong class="source-inline">getrandom</strong>, as shown in the following code:</p>
			<p class="source-code">getrandom = { version = "0.2.3", features = ["js"] }</p>
			<p class="source-code">futures = "0.3.17"</p>
			<p class="source-code">wasm-bindgen-futures = "0.4.28"</p>
			<p>Now that we have<a id="_idIndexMarker112"/> access to Rust futures, we can use <strong class="source-inline">wasm_bindgen_futures::spawn_local</strong> to spawn a local future and put all our code for drawing the image into it. Returning to the code we wrote earlier to load <strong class="source-inline">HtmlImageElement</strong>, we will want to wrap all of it in a call to <strong class="source-inline">spawn_local</strong>, as shown in the following code:</p>
			<p class="source-code">wasm_bindgen_futures::spawn_local(async move {</p>
			<p class="source-code">    let image = web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">    let callback = Closure::once(move || {</p>
			<p class="source-code">        web_sys::console::log_1(&amp;JsValue::from_str("loaded"));</p>
			<p class="source-code">    });</p>
			<p class="source-code">    image.set_onload(Some(callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">    callback.forget();</p>
			<p class="source-code">    image.set_src("Idle (1).png");</p>
			<p class="source-code">    context.draw_image_with_html_image_element</p>
			<p class="source-code">        (&amp;image, 0.0, 0.0);</p>
			<p class="source-code">    sierpinski(</p>
			<p class="source-code">...</p>
			<p class="source-code">});</p>
			<p>When you call <strong class="source-inline">spawn_local</strong>, you need to pass it as a block marked with <strong class="source-inline">async,</strong> because <strong class="source-inline">spawn_local</strong> requires <strong class="source-inline">Future</strong>. We've marked this block as <strong class="source-inline">move</strong> to give the block ownership of any bindings we reference in it. Later, we'll also need to make sure we deal properly with the lifetime of this closure, which must be <strong class="source-inline">'static</strong>, but right now, we don't have to worry about that because everything is in the closure. This image is still not going to draw because while <strong class="source-inline">Future</strong> gets spawned when it runs to completion, our program exits. We need to wait for the image to be loaded, and for that, we'll use the <strong class="source-inline">oneshot</strong> channel.</p>
			<p>A <strong class="source-inline">oneshot</strong> channel works like its name; you can call once, at which point it is consumed and cannot be called again. This means that when you move a <strong class="source-inline">oneshot</strong> channel into a<a id="_idIndexMarker113"/> Rust closure, the closure immediately becomes <strong class="source-inline">FnOnce</strong>. In fact, if you try to move <strong class="source-inline">oneshot</strong> into <strong class="source-inline">FnMut</strong> or <strong class="source-inline">Fn</strong>, you'll get compiler errors, with a side effect of your hair falling out as you try to figure out what's wrong. So, don't do that – it hurts.</p>
			<p>Instead, let's create the channel inside the <strong class="source-inline">spawn_local</strong> block, and then replace the <strong class="source-inline">web_sys::console::log_1</strong> call in the callback by sending a message to the channel. The changes are shown as follows:</p>
			<p class="source-code"><strong class="bold">let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;()&gt;();</strong></p>
			<p class="source-code">let image = web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">let callback = Closure::once(move || {</p>
			<p class="source-code">    <strong class="bold">success_tx.send(());</strong></p>
			<p class="source-code">});</p>
			<p class="source-code">...</p>
			<p>On the first line, we created the <strong class="source-inline">oneshot</strong> channel of <strong class="source-inline">unit</strong> type and then moved its transmitter into the callback. We got rid of the log message and replaced it with a call to <strong class="source-inline">send</strong> on the transmitter. Now, we need to wait for that message to be sent before we try to draw the image. Let's modify the code underneath the closure:</p>
			<p class="source-code">image.set_onload(Some(callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">image.set_src("Idle (1).png");</p>
			<p class="source-code"><strong class="bold">success_rx.await;</strong></p>
			<p class="source-code">context.draw_image_with_html_image_element(&amp;image, 0.0, 0.0);</p>
			<p>First, we remove<a id="_idIndexMarker114"/> the <strong class="source-inline">forget</strong> call, as it's no longer necessary since we'll wait for the <strong class="source-inline">onload</strong> function to be called before we try to draw the image. That makes it okay for the closure to be deleted when the scope completes. Then, we call <strong class="source-inline">success_rx.await</strong> to block while the load completes. Finally, we'll draw the image as we were doing before, and it shows up!</p>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 2.3 – It is I, Red Hat Boy, king of the triangle" src="image/Figure_2.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – It is I, Red Hat Boy, king of the triangle</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We're ignoring a lot of results here, which is a bad practice. In the next chapter, we'll start structuring our game to better separate concerns, and when doing so, we'll remove that in favor of explicit error handling or calls to <strong class="source-inline">expect</strong> if we truly want to halt execution.</p>
			<p>You might wonder why we're using <strong class="source-inline">spawn_local</strong> at all here, instead of just using a standard Rust channel and calling <strong class="source-inline">recv</strong> on it, and the reason is that a <strong class="source-inline">recv</strong> call blocks the main thread's execution, which is a big no-no in the browser. Browser-based code must allow the web browser to continue its event loop, and pausing it will cause the browser itself to become unresponsive. You could use a <strong class="source-inline">try_rcv</strong> call because that doesn't block, but you'd have to check it in a loop to make sure to wait until the image loads. That would <a id="_idIndexMarker115"/>also pause the browser and would probably cause one of those irritating <strong class="source-inline">The browser is not responding</strong> errors. Since both the browser and video games coincidentally can't cause the app to become unresponsive, we will use a <strong class="source-inline">spawn_local</strong> block and the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax. Remember that while the <strong class="source-inline">await</strong> context pauses local execution, the program itself actually keeps running, if only to constantly poll and see whether <strong class="source-inline">Future</strong> is complete. </p>
			<p>Congratulations! You've drawn an image on the screen a mere thousand words after I promised you would, but there's one more thing we have to concern ourselves with. Let's make a small change to the code:</p>
			<p class="source-code">image.set_onload(Some(callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">image.set_src("<strong class="bold">rhg.png</strong>");</p>
			<p class="source-code">success_rx.await;</p>
			<p>Now, if you run the app, the screen doesn't draw anything, including the triangle! This is because we await a successful load, which will never come. We need to handle the error case as well so that we can continue in the event of a failed load rather than hanging, even if we just want to halt the error. What we want to do is send one message (a unit) on success and another message (the error) to the receiver when the image is finished loading, either one way or the other. </p>
			<p>You might think you can change <strong class="source-inline">success_tx</strong> to take either <strong class="source-inline">unit</strong> or an error code when the load fails. We can use <strong class="source-inline">JsValue</strong> for the error since that's the type any error code from the browser will be. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><strong class="source-inline">JsValue</strong> is a type that represents any value that comes directly from JavaScript. In Rust code, we'll frequently convert these types into more specific Rust types.</p>
			<p>That code <a id="_idIndexMarker116"/>will look like this:</p>
			<p class="source-code">let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;<strong class="bold">Result&lt;(), JsValue&gt;</strong>&gt;();</p>
			<p class="source-code">let image = web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">let callback = Closure::once(move || {</p>
			<p class="source-code">    success_tx.send(Ok(()));</p>
			<p class="source-code">});</p>
			<p class="source-code"><strong class="bold">let error_callback = Closure::once(move |err| {</strong></p>
			<p class="source-code"><strong class="bold">    success_tx.send(Err(err)); </strong></p>
			<p class="source-code"><strong class="bold">});</strong></p>
			<p class="source-code">image.set_onload(Some(callback.as_ref().unchecked_ref()));</p>
			<p class="source-code"><strong class="bold">image.set_onerror(Some(error_callback.as_ref().unchecked_ref()));</strong></p>
			<p>This is immediately going to be a compiler error:</p>
			<p class="source-code">70 |         let error_callback = Closure::once(move |err| {</p>
			<p class="source-code">   |                                                     </p>
			<p class="source-code">^^^^^^^^^^ value used here after move</p>
			<p class="source-code">71 |             success_tx.send(Err(err));</p>
			<p><strong class="source-inline">success_tx</strong>  cannot be moved into both closures at the same time. We're going to need to use one of the Rust constructs to share the channel across threads so that we can use it in both callbacks.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We could use two <strong class="source-inline">oneshot</strong> channels and a <strong class="source-inline">select</strong> statement here as well, but at the time of writing, that did not work well in WebAssembly.</p>
			<p>What we'll do is create the channel and then set up a reference counted version of the success and error transmitters. This means that both transmitters will send to the same receiver. Both<a id="_idIndexMarker117"/> of these will need to wrapped inside <strong class="source-inline">Mutex</strong>, as shown here, replacing the original creation of the <strong class="source-inline">oneshot</strong> channel:</p>
			<p class="source-code">let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;Result&lt;(), JsValue&gt;&gt;();</p>
			<p class="source-code">let success_tx = Rc::new(Mutex::new(success_tx));</p>
			<p class="source-code">let error_tx = Rc::clone(&amp;success_tx);</p>
			<p>Note that we will start sending the channel the <strong class="source-inline">Result</strong>, so we can differentiate between success and failure later. You'll need to make sure that you import <strong class="source-inline">std::rc::Rc </strong> and <strong class="source-inline">std::sync::Mutex</strong>. Now that <strong class="source-inline">success_tx</strong> has been changed into <strong class="source-inline">Rc&lt;Mutex&lt;Sender&gt;</strong>, you'll need to update the <strong class="source-inline">success</strong> callback to reflect it. You'll want to lock access to <strong class="source-inline">Mutex</strong> and then send the <strong class="source-inline">success</strong> message. Your first try is likely to look like this:</p>
			<p class="source-code">let image = web_sys::HtmlImageElement::new().unwrap();</p>
			<p class="source-code">let callback = Closure::once(move || {</p>
			<p class="source-code">    success_tx</p>
			<p class="source-code">        .lock()</p>
			<p class="source-code">        .and_then(|oneshot| Ok(oneshot.send(Ok(()))));</p>
			<p class="source-code">});</p>
			<p class="source-code">...</p>
			<p>This locks <strong class="source-inline">Mutex</strong> and then sends its <strong class="source-inline">oneshot</strong> an <strong class="source-inline">Ok(())</strong>. This is <em class="italic">almost</em> right, but there's a problem leading to a compiler error, as shown here:</p>
			<p class="source-code">error[E0507]: cannot move out of dereference of `std::sync::MutexGuard&lt;'_, futures::futures_channel::oneshot::Sender&lt;Result&lt;(), wasm_bindgen::JsValue&gt;&gt;&gt;`</p>
			<p class="source-code">  --&gt; src/lib.rs:38:40</p>
			<p class="source-code">   |</p>
			<p class="source-code">38 |                 .and_then(|oneshot| Ok(oneshot.send(Ok(()))));</p>
			<p class="source-code">   |                                        ^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `futures::futures_channel::oneshot::Sender&lt;Result&lt;(), wasm_bindgen::JsValue&gt;&gt;`, which does not implement the `Copy` trait</p>
			<p>The compiler error<a id="_idIndexMarker118"/> is a mouthful, so it's worth breaking it down. As the error says, the<strong class="source-inline">.and_then(|oneshot| Ok(oneshot.send(Ok(()))));</strong> line requires the <strong class="source-inline">oneshot</strong> value to be moved into the closure. This is because <strong class="source-inline">oneshot</strong> doesn't implement copy. This makes sense; if you could copy <strong class="source-inline">oneshot</strong>, then you could use it more than once. Okay, so <strong class="source-inline">oneshot</strong> has to be moved into the closure – so what? Moves aren't bad, but the error says, <strong class="source-inline">error[E0507]: cannot move out of dereference of `std::sync::MutexGuard</strong>. <strong class="source-inline">Mutex</strong> takes ownership of the value you move into it, and you can't just move out its value leaving it with "nothing." So, the compiler prevents this action.</p>
			<p>These are the kinds of errors that are both a great feature of Rust and the bane of a Rustacean's existence. Here, the compiler is preventing us from making a threading mistake, the kind that would be easy to do in almost any other language, but the side effect is an error that's hard to read. The Rust team continues to work hard on clearer compiler messages, but some things are just hard. When the compiler has you confused, read the errors slowly and carefully, and you'll usually figure out what it's trying to tell you.</p>
			<p>So, how do you get around this problem? What you need to do is make sure to never move out of the <strong class="source-inline">Mutex</strong> reference while still getting access to the underlying <strong class="source-inline">Sender</strong>. The way we can do that is to use the <strong class="source-inline">Option&lt;T&gt;</strong> type, which implements a copy and the <strong class="source-inline">take</strong> function. That will allow us to replace, inside the locked <strong class="source-inline">Mutex</strong>, <strong class="source-inline">Sender</strong> with <strong class="source-inline">None</strong>. Then, any other user of that <strong class="source-inline">Mutex</strong> reference will have <strong class="source-inline">None</strong> and be able to use it appropriately.</p>
			<p>Start by modifying the creation of <strong class="source-inline">success_tx</strong> to take <strong class="source-inline">Option</strong>, as shown in the following code:</p>
			<p class="source-code">let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;Result&lt;(), JsValue&gt;&gt;();</p>
			<p class="source-code">let success_tx = Rc::new(Mutex::new(<strong class="bold">Some(success_tx))</strong>);</p>
			<p class="source-code">let error_tx = Rc::clone(&amp;success_tx);</p>
			<p>Now, in <a id="_idIndexMarker119"/>the <strong class="source-inline">success</strong> callback, we need to modify the code to account for the transmitter being optional. We'll use <strong class="source-inline">take</strong> here to immediately replace <strong class="source-inline">Some(transmitter)</strong> with <strong class="source-inline">None</strong> when its used. This is the <strong class="source-inline">success</strong> callback:</p>
			<p class="source-code">let callback = Closure::once(move || {</p>
			<p class="source-code">    if let Some(success_tx) = success_tx.lock().ok()</p>
			<p class="source-code">       <strong class="bold">.and_then(|mut opt| opt.take())</strong> {</p>
			<p class="source-code">        success_tx.send(Ok(()));</p>
			<p class="source-code">    }</p>
			<p class="source-code">});</p>
			<p>Here, we've used the <strong class="source-inline">if let</strong> construct to get the transmitter out of <strong class="source-inline">Mutex</strong> and <strong class="source-inline">Option</strong>. If you follow the code from <strong class="source-inline">success_tx.lock()</strong>, you'll see we call <strong class="source-inline">ok</strong> to convert the <strong class="source-inline">lock()</strong> result to an <strong class="source-inline">Option</strong>, use the <strong class="source-inline">and_then</strong> function to operate on the <strong class="source-inline">Some</strong> version of <strong class="source-inline">Option</strong>, and then finally use <strong class="source-inline">take</strong> to get the value of <strong class="source-inline">Option</strong>. In the <strong class="source-inline">if</strong> condition, we call the transmitter's <strong class="source-inline">send</strong> function with an <strong class="source-inline">Ok</strong> result, and we no longer need the strange <strong class="source-inline">Ok</strong> wrapper around the <strong class="source-inline">send</strong> call. The key is that <strong class="source-inline">Option</strong> never moves out of <strong class="source-inline">Mutex</strong>; it's replaced by <strong class="source-inline">None</strong>. Since nobody else can access the <strong class="source-inline">oneshot</strong> struct while in the lock, the code is thread-safe, and because we use <strong class="source-inline">Option</strong>, the <strong class="source-inline">Mutex</strong> always contains something – even if it's <strong class="source-inline">None</strong>.</p>
			<p>We can finally<a id="_idIndexMarker120"/> write the <strong class="source-inline">error</strong> callback that started all this, and it's very similar:</p>
			<p class="source-code">let error_callback = Closure::once(move |err| {</p>
			<p class="source-code">    if let Some(error_tx) = error_tx.lock().ok()</p>
			<p class="source-code">       .and_then(|mut opt| opt.take()) {</p>
			<p class="source-code">        error_tx.send(Err(err));</p>
			<p class="source-code">    }</p>
			<p class="source-code">});</p>
			<p class="source-code">...</p>
			<p>That <strong class="source-inline">error</strong> callback needs to be set using the <strong class="source-inline">set_onerror</strong> call. We had that previously, but just in case you didn't add that earlier, it looks like the following: </p>
			<p class="source-code">image.set_onload(Some(callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">image.set_onerror(Some(error_callback.as_ref().unchecked_ref()));</p>
			<p class="source-code">...</p>
			<p>I placed the <strong class="source-inline">set_onerror</strong> call right under the existing <strong class="source-inline">set_onload</strong> call for symmetry. We do not need to add a second <strong class="source-inline">await</strong> call for the errors. Both <strong class="source-inline">oneshot</strong> transmitters send to the same receiver, because <strong class="source-inline">error_tx</strong> is a clone of <strong class="source-inline">success_tx</strong>, and we are protected from receiving an error and success because <strong class="source-inline">oneshot</strong> can only fire one time. </p>
			<p>Now, we're handling the error and success cases correctly, and we aren't getting compiler errors. If you look at your browser right now, you should see just the triangle, as we aren't stuck at the <strong class="source-inline">await</strong> call anymore. Go ahead and restore the call to <strong class="source-inline">image.set_src("Idle (1).png")</strong> so that it uses the right file again and the RHB shows back up.</p>
			<p>So, there it is – our<a id="_idIndexMarker121"/> game now displays an image again <em class="italic">and</em> handles errors. But what if your game displays...more than one image?</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor053"/>Sprite sheets </h1>
			<p>Creating a<a id="_idIndexMarker122"/> game where every sprite is its own individual file is certainly possible, but it would mean making the player wait for every file to load individually when the game started. One common way to organize sprites for a game is a <strong class="bold">sprite sheet</strong>, which is made up of two parts. The first is an image file with many sprites in it, like this one:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 2.4 – The top of the sprite sheet" src="image/Figure_2.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The top of the sprite sheet</p>
			<p>The second part is a map of coordinates and metadata that lets us "cut out" each image we need, like a cookie cutter. For instance, if we want to show the first sprite in the preceding figure (which happens to be named <strong class="source-inline">Dead (7).png</strong>), we'll need to know its location and dimensions:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer018">
					<img alt="Figure 2.5 – One sprite in the sheet" src="image/Figure_2.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – One sprite in the sheet</p>
			<p>I've drawn a box marking the frame you'd want to "cut out" of the image when you want to draw <strong class="source-inline">Dead (7).png</strong>. When you want to draw a different file, say <strong class="source-inline">Slide (1).png</strong>, you can use the same image but a different frame when drawing.</p>
			<p>In order to know the frame and names of every sprite sheet, we need to load a separate file that stores all that information alongside the image itself. In our case, we will use files I've already<a id="_idIndexMarker123"/> generated for you with a tool called <em class="italic">TexturePacker</em> (<a href="https://www.codeandweb.com/texturepacker">https://www.codeandweb.com/texturepacker</a>), which lets you export a JSON file that looks like this:</p>
			<p class="source-code">{"frames": {</p>
			<p class="source-code">"Dead (1).png":</p>
			<p class="source-code">{</p>
			<p class="source-code">     "frame": {"x":0,"y":0,"w":160,"h":136},</p>
			<p class="source-code">     "rotated": false,</p>
			<p class="source-code">     "trimmed": false,</p>
			<p class="source-code">     "spriteSourceSize": {"x":0,"y":0,"w":160,"h":136},</p>
			<p class="source-code">     "sourceSize": {"w":160,"h":136}</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p><em class="italic">TexturePacker</em> generated a JSON file with a lookup table by sprite name. In this case, the "<strong class="source-inline">Dead</strong> <strong class="source-inline">(7).png</strong>" sprite is found at (<strong class="source-inline">0,0</strong>) with a width of 109 pixels and a height of 67 pixels, so in the upper left-hand corner of the larger image. To draw the image, you'll eventually use a version of the <strong class="source-inline">drawImage</strong> function that takes source coordinates, which are the dimensions you saw in the preceding code, and destination coordinates where you want to position the drawing on the canvas.</p>
			<p>So, to render<a id="_idIndexMarker124"/> the same <strong class="source-inline">Idle</strong> <strong class="source-inline">(1).png</strong> that we rendered earlier from the sprite sheet, we need to do the following:</p>
			<ol>
				<li>Load the JSON file.</li>
				<li>Parse the JSON file into a Rust structure.</li>
				<li>Load the image into <strong class="source-inline">HtmlImageElement</strong>.</li>
				<li>Use the version of <strong class="source-inline">drawImage</strong> that lets us draw only a part of an image element.</li>
			</ol>
			<p>There isn't <a id="_idTextAnchor054"/>anything else to do, so let's get started.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor055"/>Loading JSON</h2>
			<p>Inside the<a id="_idIndexMarker125"/> assets that you downloaded earlier, there's a directory <a id="_idIndexMarker126"/>called <strong class="source-inline">sprite_sheets</strong> that has two files, <strong class="source-inline">rhb.json</strong> and <strong class="source-inline">rhb.png</strong>. Go ahead and copy both of those to the <strong class="source-inline">static</strong> directory so that they can be loaded by our project. Now, let's go back and start editing <strong class="source-inline">lib.rs</strong> to load our sheet.</p>
			<p>In this case, we'll start by writing an entirely new function to call <strong class="source-inline">fetch_json</strong>. It will use the <strong class="source-inline">window.fetch</strong> call to retrieve the JSON file and then pull the JSON off of the response body. This requires two asynchronous calls, so we're going to write the entire thing as an <strong class="source-inline">async</strong> function. Go ahead and put all of this after <strong class="source-inline">main</strong>:</p>
			<p class="source-code">async fn fetch_json(json_path: &amp;str) -&gt; Result&lt;JsValue, JsValue&gt; {</p>
			<p class="source-code">    let window = web_sys::window().unwrap();</p>
			<p class="source-code">    let resp_value = wasm_bindgen_futures::JsFuture::from(</p>
			<p class="source-code">        window.fetch_with_str(json_path)).await?;</p>
			<p class="source-code">    let resp: web_sys::Response = resp_value.dyn_into()?;</p>
			<p class="source-code">    wasm_bindgen_futures::JsFuture::from(resp.json()?).await</p>
			<p class="source-code">}</p>
			<p>There are a few things that won't even compile yet, and we'll fix them as I walk through this line by line.</p>
			<p>First, we retrieve <strong class="source-inline">window</strong>. Once again, we're using <strong class="source-inline">unwrap</strong> because <strong class="source-inline">window()</strong> is an <strong class="source-inline">Option</strong>; in the <a id="_idIndexMarker127"/>next chapter, we'll do a better job of dealing with our errors. That second line is a <a id="_idIndexMarker128"/>doozy; we'll go through it in parts:</p>
			<p class="source-code">let resp_value = wasm_bindgen_futures::JsFuture::from(</p>
			<p class="source-code">    window.fetch_with_str(&amp;"rhb.json")).await?;</p>
			<p>The first part is the call to <strong class="source-inline">wasm_bindgen_futures::JsFuture::from</strong>, which is a little misleading. <strong class="source-inline">JsFuture</strong> is not a JavaScript future but a Rust future backed by a JavaScript promise. We want a Rust future so that we can eventually call <strong class="source-inline">await</strong> on it. We call <strong class="source-inline">from</strong> with the following:</p>
			<p class="source-code">window.fetch_with_str(json_path)</p>
			<p>This corresponds to the <strong class="source-inline">window.fetch</strong> function in JavaScript, but as with many other JavaScript functions, <strong class="source-inline">fetch</strong> is overloaded, so we need to explicitly call it <strong class="source-inline">with_str</strong>. That function returns <strong class="source-inline">Promise</strong>, which we immediately convert to a future via the <strong class="source-inline">from</strong> call we discussed earlier. Finally, we call <strong class="source-inline">await?</strong> , which will block until <strong class="source-inline">fetch</strong> returns. This is allowed because the <strong class="source-inline">fetch_json</strong> function is <strong class="source-inline">async</strong>.</p>
			<p>Still with me? If you understood that, you've figured out the hardest part. Next, we cast the returned <strong class="source-inline">resp_value</strong> into <strong class="source-inline">Response</strong> because the <strong class="source-inline">fetch</strong> call resolves to <strong class="source-inline">JsValue</strong>. Once again, we must convert from the dynamic typing of JavaScript to the static typing of Rust, and the <strong class="source-inline">dyn_into()</strong> function does that.</p>
			<p>Now that we've got a response (corresponding to the <strong class="source-inline">Response</strong> object in the browser), we can call its <strong class="source-inline">json()</strong> function, corresponding to the <strong class="source-inline">json()</strong> function on the web's <strong class="source-inline">Response</strong> object. That function also returns a promise, so we wrap it in <strong class="source-inline">JsFuture</strong> as well and block on it with an <strong class="source-inline">await</strong> call.</p>
			<p>Finally, this function returns <strong class="source-inline">Result&lt;JsValue, JsValue&gt;</strong>, which means it's <strong class="source-inline">Result</strong> with a dynamic JavaScript object as both its <strong class="source-inline">Ok</strong> or <strong class="source-inline">Err</strong> cases. That's why we can use <strong class="source-inline">?</strong> everywhere.</p>
			<p>But of course, this still doesn't compile because, once again, we're missing a feature flag. Make <a id="_idIndexMarker129"/>sure<a id="_idIndexMarker130"/> you add <strong class="source-inline">Response</strong> to the list of <strong class="source-inline">web-sys</strong> dependencies, and you should be green again. Well, except fo<a id="_idTextAnchor056"/>r the warning that says <strong class="source-inline">fetch_json</strong> isn't called.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor057"/>Parsing JSON</h2>
			<p>Back in <strong class="source-inline">main</strong>, we'll<a id="_idIndexMarker131"/> make <a id="_idIndexMarker132"/>the draw order as Red Hat Boy, the Sierpiński triangle, and then another Red Hat Boy. So, after the call to <strong class="source-inline">sierpinski</strong>, let's fetch the "<strong class="source-inline">rhb.json</strong>" file corresponding to the Red Hat Boy's data file:</p>
			<p class="source-code">context.draw_image_with_html_image_element(&amp;image, 0.0, 0.0);</p>
			<p class="source-code">let json = fetch_json("rhb.json").await.unwrap();</p>
			<p>This fetches the JSON but doesn't parse it into a structure we can use. We have a few options for JSON parsing, including using the browser's built-in facilities, but this is a Rust book, so let's use a Rust <a id="_idIndexMarker133"/>library, <strong class="bold">Serde</strong>.</p>
			<p>Serde is one of the more popular serialization libraries for Rust and is excellent at taking JSON (as well as many other formats) and converting it to Rust structures. Add the necessary dependency to <strong class="source-inline">Cargo.toml</strong>:</p>
			<p class="source-code">serde = {version = "1.0.131", features = ["derive"] }</p>
			<p>The crate we need is <strong class="source-inline">serde</strong>, which generically handles serialization and deserialization (<strong class="bold">ser*/*de</strong> – get it?). With that out of the way, go ahead and open the <strong class="source-inline">rhb.json</strong> file that you copied to the <strong class="source-inline">static</strong> directory earlier in your editor. At the top, you should see something like this:</p>
			<p class="source-code">{"frames": {</p>
			<p class="source-code">"Dead (1).png":</p>
			<p class="source-code">{</p>
			<p class="source-code">     "frame": {"x":0,"y":0,"w":160,"h":136},</p>
			<p class="source-code">     "rotated": false,</p>
			<p class="source-code">     "trimmed": false,</p>
			<p class="source-code">     "spriteSourceSize": {"x":0,"y":0,"w":160,"h":136},</p>
			<p class="source-code">     "sourceSize": {"w":160,"h":136}</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p>This JSON document describes a hash of frames, where the key to each frame is the name of the<a id="_idIndexMarker134"/> image <strong class="source-inline">("Dead (1).png</strong>") and the structure below it <a id="_idIndexMarker135"/>is the properties of that image. The property we care about is <strong class="source-inline">frame</strong>. The image for "<strong class="source-inline">Dead (1).png</strong>" is located at (<strong class="source-inline">210, 493</strong>) with a width of 71 pixels and a height of 115 pixels. Go back to the code, and we can parse that JSON that we fetched earlier.</p>
			<p>First, we need to set up data structures that <strong class="source-inline">serde</strong> can use. At the top of <strong class="source-inline">lib.rs</strong>, we can add the <strong class="source-inline">Deserialize</strong> procedural macro to the scope:</p>
			<p class="source-code">use serde::Deserialize;</p>
			<p>You'll also want to add <strong class="source-inline">HashMap</strong> from <strong class="source-inline">std::collections</strong>:</p>
			<p class="source-code">use std::collections::HashMap;</p>
			<p>Now, we'll work backward. You'll have a <strong class="source-inline">Sheet</strong> class that contains the lookup table from the preceding JSON. You can put this struct anywhere in the <strong class="source-inline">lib.rs</strong> file, just not inside a function. I put it at the top:</p>
			<p class="source-code">#[derive(Deserialize)]</p>
			<p class="source-code">struct Sheet {</p>
			<p class="source-code">    frames: HashMap&lt;String, Cell&gt;,</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">[derive(Deserialize)]</strong> macro means we can use <strong class="source-inline">Sheet</strong> as a target for deserializing the JSON, and <strong class="source-inline">HashMap</strong> and <strong class="source-inline">String</strong> work automatically, but we haven't defined <strong class="source-inline">Cell</strong>. This will represent the portion of the JSON containing <strong class="source-inline">frame</strong>, which is what we care about because it's where the target sprite is located. We'll add all the structs we<a id="_idIndexMarker136"/> need <a id="_idIndexMarker137"/>above <strong class="source-inline">Sheet</strong>:</p>
			<p class="source-code">#[derive(Deserialize)]</p>
			<p class="source-code">struct Rect {</p>
			<p class="source-code">    x: u16,</p>
			<p class="source-code">    y: u16,</p>
			<p class="source-code">    w: u16,</p>
			<p class="source-code">    h: u16,</p>
			<p class="source-code">}</p>
			<p class="source-code">#[derive(Deserialize)]</p>
			<p class="source-code">struct Cell {</p>
			<p class="source-code">    frame: Rect,</p>
			<p class="source-code">}</p>
			<p>Great – we have a bunch of structures that can hold the map of data we need to draw our images, but we haven't filled them, but fortunately, <strong class="source-inline">wasm-bindgen</strong> makes this very easy with the <strong class="source-inline">serde-serialize</strong> feature. To enable that feature, you'll need to once again update <strong class="source-inline">Cargo.toml</strong>, replacing the basic <strong class="source-inline">wasm-bindgen</strong> dependency with the following:</p>
			<p class="source-code">wasm-bindgen = { version = "0.2.78", features = ["serde-serialize"] }</p>
			<p>Where before you only had <strong class="source-inline">wasm-bindgen = "0.2.78"</strong>, now you'll need to add the <strong class="source-inline">serde-serialize</strong> feature flag, so you have to use the slightly more complex syntax. After that builds, you can import the JSON data with only one line of code, <strong class="source-inline">into_serde</strong>, after you fetch the JSON:</p>
			<p class="source-code">let json = fetch_json("rhb.json")</p>
			<p class="source-code">    .await</p>
			<p class="source-code">    .expect("Could not fetch rhb.json");</p>
			<p class="source-code">let sheet: Sheet = json</p>
			<p class="source-code">    .into_serde()</p>
			<p class="source-code">    .expect("Could not convert rhb.json into a Sheet </p>
			<p class="source-code">     structure");</p>
			<p>I removed the <strong class="source-inline">unwrap</strong> calls and replaced them with <strong class="source-inline">expect</strong> because I wanted a specific message in these cases.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Almost all of the dependencies that we are using are very young, and it's unlikely that this book will be able to keep up with every quirk. To follow along, stick to versions the book is<a id="_idIndexMarker138"/> using, but for your own future projects, remember to <a id="_idIndexMarker139"/>check documents for feature flags, version numbers, or both whenever a dependency seemingly doesn't work.</p>
			<p>Now that we have the sheet, we are ready to load the image and draw a sprite in it.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor058"/>Drawing with our "cookie cutter"</h2>
			<p>Recall that <a id="_idIndexMarker140"/>we had four steps to draw from a sprite sheet. We've<a id="_idIndexMarker141"/> completed the first two:</p>
			<ol>
				<li value="1">Load the JSON file.</li>
				<li>Parse the JSON file into a Rust structure.</li>
				<li>Load the image into <strong class="source-inline">HtmlImageElement</strong>.</li>
				<li>Use the version of <strong class="source-inline">drawImage</strong> that lets us draw only a part of an image element.</li>
			</ol>
			<p>Step 3 is something you've already done before, and like all good programmers, we go immediately to one tool when we need to write the same code twice…</p>
			<p>Copy and paste, of course! What, you thought that I was gonna say a function? We'll save that for later.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">More seriously, copying and pasting to get something working a second time is perfectly acceptable; just avoid checking that in as the final version.</p>
			<p>Copy<a id="_idIndexMarker142"/> everything<a id="_idIndexMarker143"/> from <strong class="source-inline">let (success_tx, success_rx)</strong> to <strong class="source-inline">success_rx.await</strong> and paste it right below, where we converted <strong class="source-inline">rhb.json</strong> into <strong class="source-inline">Sheet</strong>:</p>
			<p class="source-code">let sheet: Sheet = json</p>
			<p class="source-code">    .into_serde()</p>
			<p class="source-code">    .expect("Could not convert rhb.json into a Sheet </p>
			<p class="source-code">     structure");</p>
			<p class="source-code">let (success_tx, success_rx) = futures::channel::oneshot::channel::&lt;()&gt;();</p>
			<p class="source-code">...</p>
			<p class="source-code">image.set_src("Idle (1).png");</p>
			<p class="source-code">success_rx.await;</p>
			<p>Thanks to the way Rust works, you won't need to rename any variables, as every time you use <strong class="source-inline">let</strong>, you shadow the previous version of that variable and create a new binding. In the pasted code, we only need to make one change – to load the image sheet instead of "<strong class="source-inline">Idle (1().png</strong>":</p>
			<p class="source-code">image.set_src("rhb.png");</p>
			<p>Step 3 is now complete; we've loaded the large image with many sprites in it. Finally, we'll draw the sprite that we want. Let's go ahead and draw the "<strong class="source-inline">Run (1).png</strong>" sprite, which will admittedly look similar but will allow us to add some animation to go along with it. We'll use the version of the <strong class="source-inline">drawImage</strong> call that takes a source location, which is the frame we discussed earlier, and a destination location where we will put the image on the canvas. To make sure that we see the new image, let's stick this image somewhere <a id="_idIndexMarker144"/>near the middle. Add this right after the<a id="_idIndexMarker145"/> last <strong class="source-inline">await</strong> call:</p>
			<p class="source-code">let sprite = sheet.frames.get("Run (1).png").expect("Cell not found");</p>
			<p class="source-code">context.draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh(</p>
			<p class="source-code">    &amp;image,</p>
			<p class="source-code">    sprite.frame.x.into(),</p>
			<p class="source-code">    sprite.frame.y.into(),</p>
			<p class="source-code">    sprite.frame.w.into(),</p>
			<p class="source-code">    sprite.frame.h.into(),</p>
			<p class="source-code">    300.0,</p>
			<p class="source-code">    300.0,</p>
			<p class="source-code">    sprite.frame.w.into(),</p>
			<p class="source-code">    sprite.frame.h.into(),</p>
			<p class="source-code">);</p>
			<p>The first line, <strong class="source-inline">sheet.frames.get</strong>, retrieves the sprite by name, with an <strong class="source-inline">expect</strong> thrown in for when we get the name wrong. The next line is a monster because <strong class="source-inline">drawImage</strong> has nine argument versions in JavaScript, and it's represented in Rust by the call to <strong class="source-inline">draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh</strong>. That's a mouthful, but what it means is drawing the image using the source rectangle (our frame) to a destination rectangle, where the source rectangle is represented by four position and size coordinates, and the destination rectangle is also represented by four coordinates. The source rectangle is our frame, drawn from the JSON file we loaded earlier. The destination rectangle starts at (<strong class="source-inline">300,300</strong>) to put RHB in about the center of the canvas and uses the same width and height because we<a id="_idIndexMarker146"/> don't want to change the size of the image. The <a id="_idIndexMarker147"/>end result is this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer019">
					<img alt="Figure 2.6 – Multiple Red Hat Boys" src="image/Figure_2.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Multiple Red Hat Boys</p>
			<p>The original RHB is up in the left, using its own image file, and the second RHB from the sprite sheet is approximately in the center of the triangle. You'll notice his right hand is slightly tucked in because it's at the start of his run animation.</p>
			<p>Speaking of the run animation, how about we see it in action?</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Loading the sprite sheet and images the way we did here is just one of many ways to implement this technique. For example, another option would have been to embed the JSON and the images in the Rust executable, perhaps by Base64-encoding them, thereby doing all data loading at once. They could also have been bundled into destination applications via webpack and exposed to our Rust app. All these different ways come with their <a id="_idIndexMarker148"/>own trade-offs, and in our case, we have traded some <a id="_idIndexMarker149"/>complexity and upfront load times for the requirement to make calls to a server. Find the solution that works best for your game.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor059"/>Adding animation </h1>
			<p>Sprite animation works<a id="_idIndexMarker150"/> just like a flip-book or a movie. Show a sequence of images fast enough, where each image is drawn to be only slightly different than the previous one, and it causes the illusion of motion. Animation on the canvas works in much the same way, where each frame in the sprite sheet has the same effect as a drawing in a flip-book:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer020">
					<img alt="Figure 2.7 – The run animation for Red Hat Boy" src="image/Figure_2.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – The run animation for Red Hat Boy</p>
			<p>To draw Red Hat Boy running, we have to simply draw the images in order, one at a time, and loop after drawing the last one. Simple for a loop, right?</p>
			<p>Of course, it's not quite that simple. First, we can't just use an infinite loop, as that would block the browser from any processing, resulting in a frozen browser tab. Second, we have to make sure to clear the canvas between each frame. Otherwise, we'll see all the images merged together as one draws on top of the other. So, each time we draw the canvas, we'll need to clear it first, and then draw the desired frame.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you're familiar with double buffering in traditional game development and are worried about seeing flicker when we clear the canvas and then redraw, don't. The canvas element already handles this for you.</p>
			<p>Fortunately, you already know almost all you need to in order to draw the animated RHB. You'll need to pass a Rust closure to a function and draw a sprite from a sprite sheet. The only thing you don't know is how to clear the canvas, and we'll cover that in a moment, but<a id="_idIndexMarker151"/> we must start by saying goodbye:</p>
			<ol>
				<li value="1"><strong class="bold">Delete the Sierpiński triangle</strong>: We could try and draw the Sierpiński triangle over and over again after clearing the screen, but it would be distracting and slow. So, it's time to say goodbye, to the call to <strong class="source-inline">sierpinski</strong> and all the code it uses, including the <strong class="source-inline">midpoint</strong> and <strong class="source-inline">draw_triangle</strong> functions. They served us well and will be missed.</li>
				<li><strong class="bold">Delete the idle RHB</strong>: We could probably go to the effort of keeping the idle RHB sprite around, but it would require dealing with the duplicated code we wrote to create the sprite sheet. It's best to delete all that copy and paste code before the boss finds out.</li>
			</ol>
			<p>No, go ahead and delete everything inside the <strong class="source-inline">spawn_local</strong> closure up until we loaded the <strong class="source-inline">rhb.json</strong> file. After those deletions, your code should look like this around <strong class="source-inline">spawn_local</strong>:</p>
			<p class="source-code">let context = canvas</p>
			<p class="source-code">    .get_context("2d")</p>
			<p class="source-code">    .unwrap()</p>
			<p class="source-code">    .unwrap()</p>
			<p class="source-code">    .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()</p>
			<p class="source-code">    .unwrap();</p>
			<p class="source-code">wasm_bindgen_futures::spawn_local(async move {</p>
			<p class="source-code">    let json = fetch_json("rhb.json")</p>
			<p class="source-code">        .await</p>
			<p class="source-code">        .expect("Could not fetch rhb.json");</p>
			<p class="source-code">    ...</p>
			<p>So, before spawning the local future, the last thing you do is get the <strong class="source-inline">2d</strong> context, and the first thing you do after spawning the future is load the JSON.</p>
			<p>Now, it's <a id="_idIndexMarker152"/>time to change the draw into a callback function.</p>
			<ol>
				<li value="3"><strong class="bold">Draw on SetInterval</strong>: We want to draw our running RHB at approximately 20 frames per second, so we'll need to make the draw call every 50 milliseconds. You might be wondering why we don't have the animation go at 60 frames per second, the traditional frame rate of a game, and that's because the sprite itself isn't designed to run that fast. He'll look like a sped-up version of Usain Bolt. In the next chapter, when we set up a proper game loop, we'll run at 60 frames per second and only update the sprite every third tick to compensate, but for now, let's set up a callback every 50 milliseconds with JavaScript's <strong class="source-inline">setInterval</strong> function, which is called <strong class="source-inline">set_interval_with_callback</strong>. First, we need to set up the callback itself, using the <strong class="source-inline">Closure</strong> <strong class="source-inline">struct</strong> that we used earlier. Right after the <strong class="source-inline">success_rx.await</strong> call, add this:<p class="source-code">let interval_callback = Closure::wrap(Box::new(move || {}) as Box&lt;dyn FnMut()&gt;);</p></li>
			</ol>
			<p>This sets up an empty <strong class="source-inline">Closure</strong>, but unlike the previous time we created <strong class="source-inline">Closure</strong>, we're using <strong class="source-inline">Closure::wrap</strong> instead of <strong class="source-inline">Closure::once</strong>. Why? Well, because this closure will be called multiple times. This also means we need to use <strong class="source-inline">Box</strong> with an explicit cast, <strong class="source-inline">as Box&lt;dyn FnMut()&gt;</strong>, because the <strong class="source-inline">wrap</strong> function requires <strong class="source-inline">Box</strong>, and there isn't enough information for the compiler to infer the type.</p>
			<p>Now that we have an empty interval callback, we can schedule it to be called. On the next line, add the following:</p>
			<p class="source-code">window.set_interval_with_callback_and_timeout_and_arguments_0(</p>
			<p class="source-code">    interval_callback.as_ref().unchecked_ref(),</p>
			<p class="source-code">    50,</p>
			<p class="source-code">);</p>
			<p>Adding that will start the process of calling our <strong class="source-inline">interval_callback</strong> every 50 milliseconds; however, doing so will cause an error. If you look into the browser's error log via the <a id="_idIndexMarker153"/>console, you'll see this repeated:</p>
			<p class="source-code">Uncaught Error: closure invoked recursively or destroyed already</p>
			<p>That should sound familiar, as we've already fixed it once this chapter. The fix will be to once again forget the closure that we passed into <strong class="source-inline">setInterval</strong> so that Rust doesn't destroy it when we leave the scope of this future. Add this right <em class="italic">after</em> the <strong class="source-inline">set_interval</strong> call:</p>
			<p class="source-code">interval_callback.forget();</p>
			<p>Then, go back and check the console to verify that the error has gone away. You may need to refresh the browser to ensure that you don't get stale error messages showing up to confuse you.</p>
			<p>Now that you've scheduled a regular callback, let's add one line to that callback to clear the screen:</p>
			<p class="source-code">let interval_callback = Closure::wrap(Box::new(move || {</p>
			<p class="source-code">    context.clear_rect(0.0, 0.0, 600.0, 600.0);</p>
			<p class="source-code">}) as Box&lt;dyn FnMut()&gt;);</p>
			<p>This will not compile because outside of this callback, we're still calling <strong class="source-inline">draw_image</strong>. Since we've moved the <strong class="source-inline">context</strong> into this <strong class="source-inline">Closure</strong>, we've run afoul of the borrow checker. To address this, we're going to need to move the drawing code into the closure, like so:</p>
			<p class="source-code">let interval_callback = Closure::wrap(Box::new(move || {</p>
			<p class="source-code">    context.clear_rect(0.0, 0.0, 600.0, 600.0);</p>
			<p class="source-code">    let sprite = sheet.frames.get("Run(1).png").expect</p>
			<p class="source-code">        ("Cell not found");</p>
			<p class="source-code">    context.draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh(</p>
			<p class="source-code">        &amp;image,</p>
			<p class="source-code">        sprite.frame.x.into(),</p>
			<p class="source-code">        sprite.frame.y.into(),</p>
			<p class="source-code">        sprite.frame.w.into(),</p>
			<p class="source-code">        sprite.frame.h.into(),</p>
			<p class="source-code">        300.0,</p>
			<p class="source-code">        300.0,</p>
			<p class="source-code">        sprite.frame.w.into(),</p>
			<p class="source-code">        sprite.frame.h.into(),</p>
			<p class="source-code">    );</p>
			<p class="source-code">}) as Box&lt;dyn FnMut()&gt;);</p>
			<p>Congratulations! You <a id="_idIndexMarker154"/>are now clearing the screen and redrawing it every 50 milliseconds. Unfortunately, it doesn't look like anything because you're always drawing the same image. Let's change the code to loop from "<strong class="source-inline">Run (1).png</strong>" to "<strong class="source-inline">Run (8).png</strong>" over and over again.</p>
			<p>Initialize a frame counter outside of the closure:</p>
			<p class="source-code">let mut frame = -1;</p>
			<p class="source-code">let interval_callback = Closure::wrap(Box::new(move || {</p>
			<p>Now, on the inside of the closure, we'll cycle the frame count between 0 and 7:</p>
			<p class="source-code">let interval_callback = Closure::wrap(Box::new(move || {</p>
			<p class="source-code">    frame = (frame + 1) % 8;</p>
			<p>Why 0 to 7 when it goes to frame 8? Because we'll adjust it on the next line when we construct <strong class="source-inline">framename</strong>:</p>
			<p class="source-code">let interval_callback = Closure::wrap(Box::new(move || {</p>
			<p class="source-code">    frame = (frame + 1) % 8;</p>
			<p class="source-code">    let frame_name = format!("Run ({}).png", frame + 1);</p>
			<p>Finally, instead <a id="_idIndexMarker155"/>of getting "<strong class="source-inline">Run (1).png</strong>" every time, we'll get the constructed sprite name from the sprite sheet. Just change the <strong class="source-inline">sheet.get</strong> call to use <strong class="source-inline">&amp;frame_name</strong>, and we'll move the call to <strong class="source-inline">get</strong> above the <strong class="source-inline">clear_rect</strong> call as well:</p>
			<p class="source-code">let frame_name = format!("Run ({}).png", frame + 1);</p>
			<p class="source-code">let sprite = sheet.frames.get(&amp;frame_name).expect("Cell not found");</p>
			<p>Take a look now and, sure enough, Red Hat Bo<a id="_idTextAnchor060"/>y is running!</p>
			<div>
				<div class="IMG---Figure" id="_idContainer021">
					<img alt="Figure 2.8 – You can't see running in a book, trust me" src="image/Figure_2.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – You can't see running in a book, trust me</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor061"/>Summary</h1>
			<p>In this chapter, we have covered rendering sprites to the screen, including sprite sheets, but we actually covered so much more than that. We covered how to use futures and <strong class="source-inline">async</strong> code in a WebAssembly app, how to parse JSON, and perhaps most confusingly how to send Rust closures to JavaScript via the <strong class="source-inline">Closure</strong> struct. We also reviewed some of the quirks of using Rust in the WebAssembly environment from <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>,<em class="italic"> Hello WebAssembly</em>. This chapter was fun, but we made some messy code.</p>
			<p>In the next chapter, we'll deal with that by setting up a simple architecture for our game and writing a proper game loop. Lest you think <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, Creating a Game Loop</em>, is all refactoring, we'll also move our friend Red Hat Boy around the screen. It'll start to look like a real game!</p>
		</div>
	</body></html>